{"sha": "6b88314c653778739e9f92700c3ae6a94a2a222c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI4ODMxNGM2NTM3Nzg3MzllOWY5MjcwMGMzYWU2YTk0YTJhMjIyYw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-10T23:16:31Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-10T23:16:31Z"}, "message": "cppcharset.c (one_utf8_to_cppchar, [...]): New functions.\n\n\t* cppcharset.c (one_utf8_to_cppchar, one_cppchar_to_utf8,\n\tone_utf8_to_utf32, one_utf32_to_utf8, one_utf8_to_utf16,\n\tone_utf16_to_utf8, conversion_loop, convert_utf8_utf16,\n\tconvert_utf8_utf32, convert_utf16_utf8,\tconvert_utf32_utf8,\n\tconvert_no_conversion, convert_using_iconv): New functions.\n\t(APPLY_CONVERSION): New macro.\n\t(struct conversion, conversion_tab): New data structure.\n\t(init_iconv_desc): Check conversion_tab for a custom conversion\n\tprimitive before trying to use iconv.\n\t(convert_cset): Deleted.\n\t(cpp_init_iconv): Use UTF- terminology, not UCS-.\n\t(_cpp_destroy_iconv): Update to match.\n\t(_cpp_valid_ucn): We don't need iconv to implement UCNs.\n\t(convert_ucn): Use one_cppchar_to_utf8 and APPLY_CONVERSION.\n\t(convert_escape, cpp_interpret_string): Use APPLY_CONVERSION.\n\t(_cpp_interpret_string_notranslate): New function, moved here\n\tfrom cpplib.c.\n\n\t* cpphash.h (convert_f, struct cset_converter): New types.\n\t(struct cpp_reader): narrow_cset_desc and wide_cset_desc\n\tare now struct cset_converter, not bare iconv_t.\n\tUpdate prototypes.\n\t* cpplib.c (interpret_string_notranslate): Moved to cppcharset.c;\n\tall callers changed.\n\nFrom-SVN: r69204", "tree": {"sha": "aecfe84fc61678543cc3833bd2320e614dbbd339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aecfe84fc61678543cc3833bd2320e614dbbd339"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b88314c653778739e9f92700c3ae6a94a2a222c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b88314c653778739e9f92700c3ae6a94a2a222c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b88314c653778739e9f92700c3ae6a94a2a222c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b88314c653778739e9f92700c3ae6a94a2a222c/comments", "author": null, "committer": null, "parents": [{"sha": "38f4680f542122d06627905369389046efeb4289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f4680f542122d06627905369389046efeb4289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38f4680f542122d06627905369389046efeb4289"}], "stats": {"total": 791, "additions": 634, "deletions": 157}, "files": [{"sha": "509473892c028647fc2a16e0309c90972f4cca41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b88314c653778739e9f92700c3ae6a94a2a222c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b88314c653778739e9f92700c3ae6a94a2a222c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b88314c653778739e9f92700c3ae6a94a2a222c", "patch": "@@ -1,11 +1,38 @@\n+2003-07-10  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* cppcharset.c (one_utf8_to_cppchar, one_cppchar_to_utf8,\n+\tone_utf8_to_utf32, one_utf32_to_utf8, one_utf8_to_utf16,\n+\tone_utf16_to_utf8, conversion_loop, convert_utf8_utf16,\n+\tconvert_utf8_utf32, convert_utf16_utf8,\tconvert_utf32_utf8,\n+\tconvert_no_conversion, convert_using_iconv): New functions.\n+\t(APPLY_CONVERSION): New macro.\n+\t(struct conversion, conversion_tab): New data structure.\n+\t(init_iconv_desc): Check conversion_tab for a custom conversion\n+\tprimitive before trying to use iconv.\n+\t(convert_cset): Deleted.\n+\t(cpp_init_iconv): Use UTF- terminology, not UCS-.\n+\t(_cpp_destroy_iconv): Update to match.\n+\t(_cpp_valid_ucn): We don't need iconv to implement UCNs.\n+\t(convert_ucn): Use one_cppchar_to_utf8 and APPLY_CONVERSION.\n+\t(convert_escape, cpp_interpret_string): Use APPLY_CONVERSION.\n+\t(_cpp_interpret_string_notranslate): New function, moved here\n+\tfrom cpplib.c.\n+\n+\t* cpphash.h (convert_f, struct cset_converter): New types.\n+\t(struct cpp_reader): narrow_cset_desc and wide_cset_desc\n+\tare now struct cset_converter, not bare iconv_t.\n+\tUpdate prototypes.\n+\t* cpplib.c (interpret_string_notranslate): Moved to cppcharset.c;\n+\tall callers changed.\n+\n 2003-07-10  Kelley Cook  <kelleycook@wideopenwest.com>\n-        \n+\n \t* Makefile.in (options.h): Depend on Makefile.  Add move-if-change\n \tto opts.sh command line.\n \t* opts.sh: Write to temporary files with a move-if-change at the end.\n \n 2003-06-30  Denis Chertykov  <denisc@overta.ru>\n-            Richard Kenner <kenner@vlsi1.ultra.nyu.edu>\n+\t    Richard Kenner <kenner@vlsi1.ultra.nyu.edu>\n \n \t* combine.c (gen_binary): Handle the CLOBBER rtx and\n \tdon't build a binary operation with it.\n@@ -319,7 +346,7 @@\n 2003-07-09  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \tPR bootstrap/11043\n-\t* config/arc/t-arc: Replace bogus references to \"x-crtinit.o\", \n+\t* config/arc/t-arc: Replace bogus references to \"x-crtinit.o\",\n \t\"x-crtfini.o\" with \"crtinit.o\", \"crtfini.o\".\n \n \t* fixinc/inclhack.def (limits_ifndefs): Add select test."}, {"sha": "c170b5c33247871ca11e4418f92a6795ed030c7d", "filename": "gcc/cppcharset.c", "status": "modified", "additions": 582, "deletions": 128, "changes": 710, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b88314c653778739e9f92700c3ae6a94a2a222c/gcc%2Fcppcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b88314c653778739e9f92700c3ae6a94a2a222c/gcc%2Fcppcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppcharset.c?ref=6b88314c653778739e9f92700c3ae6a94a2a222c", "patch": "@@ -92,8 +92,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #error \"Unrecognized basic host character set\"\n #endif\n \n-/* This structure is used for a resizable string buffer, mostly by\n-   convert_cset and cpp_interpret_string.  */\n+/* This structure is used for a resizable string buffer throughout.  */\n struct strbuf\n {\n   uchar *text;\n@@ -103,32 +102,556 @@ struct strbuf\n \n /* This is enough to hold any string that fits on a single 80-column\n    line, even if iconv quadruples its size (e.g. conversion from\n-   ASCII to UCS-4) rounded up to a power of two.  */\n+   ASCII to UTF-32) rounded up to a power of two.  */\n #define OUTBUF_BLOCK_SIZE 256\n \n-/* Subroutine of cpp_init_iconv: initialize and return an iconv\n-   descriptor for conversion from FROM to TO.  If iconv_open() fails,\n-   issue an error and return (iconv_t) -1.  Silently return\n-   (iconv_t) -1 if FROM and TO are identical.  */\n-static iconv_t\n+/* Conversions between UTF-8 and UTF-16/32 are implemented by custom\n+   logic.  This is because a depressing number of systems lack iconv,\n+   or have have iconv libraries that do not do these conversions, so\n+   we need a fallback implementation for them.  To ensure the fallback\n+   doesn't break due to neglect, it is used on all systems.\n+\n+   UTF-32 encoding is nice and simple: a four-byte binary number,\n+   constrained to the range 00000000-7FFFFFFF to avoid questions of\n+   signedness.  We do have to cope with big- and little-endian\n+   variants.\n+\n+   UTF-16 encoding uses two-byte binary numbers, again in big- and\n+   little-endian variants, for all values in the 00000000-0000FFFF\n+   range.  Values in the 00010000-0010FFFF range are encoded as pairs\n+   of two-byte numbers, called \"surrogate pairs\": given a number S in\n+   this range, it is mapped to a pair (H, L) as follows:\n+\n+     H = (S - 0x10000) / 0x400 + 0xD800\n+     L = (S - 0x10000) % 0x400 + 0xDC00\n+\n+   Two-byte values in the D800...DFFF range are ill-formed except as a\n+   component of a surrogate pair.  Even if the encoding within a\n+   two-byte value is little-endian, the H member of the surrogate pair\n+   comes first.\n+\n+   There is no way to encode values in the 00110000-7FFFFFFF range,\n+   which is not currently a problem as there are no assigned code\n+   points in that range; however, the author expects that it will\n+   eventually become necessary to abandon UTF-16 due to this\n+   limitation.  Note also that, because of these pairs, UTF-16 does\n+   not meet the requirements of the C standard for a wide character\n+   encoding (see 3.7.3 and 6.4.4.4p11).\n+\n+   UTF-8 encoding looks like this:\n+\n+   value range\t       encoded as\n+   00000000-0000007F   0xxxxxxx\n+   00000080-000007FF   110xxxxx 10xxxxxx\n+   00000800-0000FFFF   1110xxxx 10xxxxxx 10xxxxxx\n+   00010000-001FFFFF   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+   00200000-03FFFFFF   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n+   04000000-7FFFFFFF   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n+\n+   Values in the 0000D800 ... 0000DFFF range (surrogates) are invalid,\n+   which means that three-byte sequences ED xx yy, with A0 <= xx <= BF,\n+   never occur.  Note also that any value that can be encoded by a\n+   given row of the table can also be encoded by all successive rows,\n+   but this is not done; only the shortest possible encoding for any\n+   given value is valid.  For instance, the character 07C0 could be\n+   encoded as any of DF 80, E0 9F 80, F0 80 9F 80, F8 80 80 9F 80, or\n+   FC 80 80 80 9F 80.  Only the first is valid.\n+\n+   An implementation note: the transformation from UTF-16 to UTF-8, or\n+   vice versa, is easiest done by using UTF-32 as an intermediary.  */\n+\n+/* Internal primitives which go from an UTF-8 byte stream to native-endian\n+   UTF-32 in a cppchar_t, or vice versa; this avoids an extra marshal/unmarshal\n+   operation in several places below.  */\n+static inline int\n+one_utf8_to_cppchar (const uchar **inbufp, size_t *inbytesleftp,\n+\t\t     cppchar_t *cp)\n+{\n+  static const uchar masks[6] = { 0x7F, 0x1F, 0x0F, 0x07, 0x02, 0x01 };\n+  static const uchar patns[6] = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n+  \n+  cppchar_t c;\n+  const uchar *inbuf = *inbufp;\n+  size_t nbytes, i;\n+\n+  if (*inbytesleftp < 1)\n+    return EINVAL;\n+\n+  c = *inbuf;\n+  if (c < 0x80)\n+    {\n+      *cp = c;\n+      *inbytesleftp -= 1;\n+      *inbufp += 1;\n+      return 0;\n+    }\n+\n+  /* The number of leading 1-bits in the first byte indicates how many\n+     bytes follow.  */\n+  for (nbytes = 2; nbytes < 7; nbytes++)\n+    if ((c & ~masks[nbytes-1]) == patns[nbytes-1])\n+      goto found;\n+  return EILSEQ;\n+ found:\n+\n+  if (*inbytesleftp < nbytes)\n+    return EINVAL;\n+\n+  c = (c & masks[nbytes-1]);\n+  inbuf++;\n+  for (i = 1; i < nbytes; i++)\n+    {\n+      cppchar_t n = *inbuf++;\n+      if ((n & 0xC0) != 0x80)\n+\treturn EILSEQ;\n+      c = ((c << 6) + (n & 0x3F));\n+    }\n+\n+  /* Make sure the shortest possible encoding was used.  */\n+  if (c <=      0x7F && nbytes > 1) return EILSEQ;\n+  if (c <=     0x7FF && nbytes > 2) return EILSEQ;\n+  if (c <=    0xFFFF && nbytes > 3) return EILSEQ;\n+  if (c <=  0x1FFFFF && nbytes > 4) return EILSEQ;\n+  if (c <= 0x3FFFFFF && nbytes > 5) return EILSEQ;\n+\n+  /* Make sure the character is valid.  */\n+  if (c > 0x7FFFFFFF || (c >= 0xD800 && c <= 0xDFFF)) return EILSEQ;\n+\n+  *cp = c;\n+  *inbufp = inbuf;\n+  *inbytesleftp -= nbytes;\n+  return 0;\n+}\n+\n+static inline int\n+one_cppchar_to_utf8 (cppchar_t c, uchar **outbufp, size_t *outbytesleftp)\n+{\n+  static const uchar masks[6] =  { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n+  static const uchar limits[6] = { 0x80, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };\n+  size_t nbytes;\n+  uchar buf[6], *p = &buf[6];\n+  uchar *outbuf = *outbufp;\n+\n+  nbytes = 1;\n+  if (c < 0x80)\n+    *--p = c;\n+  else\n+    {\n+      do\n+\t{\n+\t  *--p = ((c & 0x3F) | 0x80);\n+\t  c >>= 6;\n+\t  nbytes++;\n+\t}\n+      while (c >= 0x3F || (c & limits[nbytes-1]));\n+      *--p = (c | masks[nbytes-1]);\n+    }\n+\n+  if (*outbytesleftp < nbytes)\n+    return E2BIG;\n+\n+  while (p < &buf[6])\n+    *outbuf++ = *p++;\n+  *outbytesleftp -= nbytes;\n+  *outbufp = outbuf;\n+  return 0;\n+}\n+\n+/* The following four functions transform one character between the two\n+   encodings named in the function name.  All have the signature\n+   int (*)(iconv_t bigend, const uchar **inbufp, size_t *inbytesleftp,\n+           uchar **outbufp, size_t *outbytesleftp)\n+\n+   BIGEND must have the value 0 or 1, coerced to (iconv_t); it is\n+   interpreted as a boolean indicating whether big-endian or\n+   little-endian encoding is to be used for the member of the pair\n+   that is not UTF-8.\n+\n+   INBUFP, INBYTESLEFTP, OUTBUFP, OUTBYTESLEFTP work exactly as they\n+   do for iconv.\n+\n+   The return value is either 0 for success, or an errno value for\n+   failure, which may be E2BIG (need more space), EILSEQ (ill-formed\n+   input sequence), ir EINVAL (incomplete input sequence).  */\n+   \n+static inline int\n+one_utf8_to_utf32 (iconv_t bigend, const uchar **inbufp, size_t *inbytesleftp,\n+\t\t   uchar **outbufp, size_t *outbytesleftp)\n+{\n+  uchar *outbuf;\n+  cppchar_t s;\n+  int rval;\n+\n+  /* Check for space first, since we know exactly how much we need.  */\n+  if (*outbytesleftp < 4)\n+    return E2BIG;\n+\n+  rval = one_utf8_to_cppchar (inbufp, inbytesleftp, &s);\n+  if (rval)\n+    return rval;\n+\n+  outbuf = *outbufp;\n+  outbuf[bigend ? 3 : 0] = (s & 0x000000FF);\n+  outbuf[bigend ? 2 : 1] = (s & 0x0000FF00) >> 8;\n+  outbuf[bigend ? 1 : 2] = (s & 0x00FF0000) >> 16;\n+  outbuf[bigend ? 0 : 3] = (s & 0xFF000000) >> 24;\n+\n+  *outbufp += 4;\n+  *outbytesleftp -= 4;\n+  return 0;\n+}\n+\n+static inline int\n+one_utf32_to_utf8 (iconv_t bigend, const uchar **inbufp, size_t *inbytesleftp,\n+\t\t   uchar **outbufp, size_t *outbytesleftp)\n+{\n+  cppchar_t s;\n+  int rval;\n+  const uchar *inbuf;\n+\n+  if (*inbytesleftp < 4)\n+    return EINVAL;\n+\n+  inbuf = *inbufp;\n+\n+  s  = inbuf[bigend ? 0 : 3] << 24;\n+  s += inbuf[bigend ? 1 : 2] << 16;\n+  s += inbuf[bigend ? 2 : 1] << 8;\n+  s += inbuf[bigend ? 3 : 0];\n+\n+  if (s >= 0x7FFFFFFF || (s >= 0xD800 && s <= 0xDFFF))\n+    return EILSEQ;\n+\n+  rval = one_cppchar_to_utf8 (s, outbufp, outbytesleftp);\n+  if (rval)\n+    return rval;\n+\n+  *inbufp += 4;\n+  *inbytesleftp -= 4;\n+  return 0;\n+}\n+\n+static inline int\n+one_utf8_to_utf16 (iconv_t bigend, const uchar **inbufp, size_t *inbytesleftp,\n+\t\t   uchar **outbufp, size_t *outbytesleftp)\n+{\n+  int rval;\n+  cppchar_t s;\n+  const uchar *save_inbuf = *inbufp;\n+  size_t save_inbytesleft = *inbytesleftp;\n+  uchar *outbuf = *outbufp;\n+\n+  rval = one_utf8_to_cppchar (inbufp, inbytesleftp, &s);\n+  if (rval)\n+    return rval;\n+\n+  if (s > 0x0010FFFF)\n+    {\n+      *inbufp = save_inbuf;\n+      *inbytesleftp = save_inbytesleft;\n+      return EILSEQ;\n+    }\n+\n+  if (s < 0xFFFF)\n+    {\n+      if (*outbytesleftp < 2)\n+\t{\n+\t  *inbufp = save_inbuf;\n+\t  *inbytesleftp = save_inbytesleft;\n+\t  return E2BIG;\n+\t}\n+      outbuf[bigend ? 1 : 0] = (s & 0x00FF);\n+      outbuf[bigend ? 0 : 1] = (s & 0xFF00) >> 8;\n+\n+      *outbufp += 2;\n+      *outbytesleftp -= 2;\n+      return 0;\n+    }\n+  else\n+    {\n+      cppchar_t hi, lo;\n+\n+      if (*outbytesleftp < 4)\n+\t{\n+\t  *inbufp = save_inbuf;\n+\t  *inbytesleftp = save_inbytesleft;\n+\t  return E2BIG;\n+\t}\n+\n+      hi = (s - 0x10000) / 0x400 + 0xD800;\n+      lo = (s - 0x10000) % 0x400 + 0xDC00;\n+\n+      /* Even if we are little-endian, put the high surrogate first.\n+\t ??? Matches practice?  */\n+      outbuf[bigend ? 1 : 0] = (hi & 0x00FF);\n+      outbuf[bigend ? 0 : 1] = (hi & 0xFF00) >> 8;\n+      outbuf[bigend ? 3 : 2] = (lo & 0x00FF);\n+      outbuf[bigend ? 2 : 3] = (lo & 0xFF00) >> 8;\n+\n+      *outbufp += 4;\n+      *outbytesleftp -= 4;\n+      return 0;\n+    }\n+}\n+\n+static inline int\n+one_utf16_to_utf8 (iconv_t bigend, const uchar **inbufp, size_t *inbytesleftp,\n+\t\t   uchar **outbufp, size_t *outbytesleftp)\n+{\n+  cppchar_t s;\n+  const uchar *inbuf = *inbufp;\n+  int rval;\n+\n+  if (*inbytesleftp < 2)\n+    return EINVAL;\n+  s  = inbuf[bigend ? 0 : 1] << 8;\n+  s += inbuf[bigend ? 1 : 0];\n+\n+  /* Low surrogate without immediately preceding high surrogate is invalid.  */\n+  if (s >= 0xDC00 && s <= 0xDFFF)\n+    return EILSEQ;\n+  /* High surrogate must have a following low surrogate.  */\n+  else if (s >= 0xD800 && s <= 0xDBFF)\n+    {\n+      cppchar_t hi = s, lo;\n+      if (*inbytesleftp < 4)\n+\treturn EINVAL;\n+\n+      lo  = inbuf[bigend ? 2 : 3] << 8;\n+      lo += inbuf[bigend ? 3 : 2];\n+\n+      if (lo < 0xDC00 || lo > 0xDFFF)\n+\treturn EILSEQ;\n+\n+      s = (hi - 0xD800) * 0x400 + (lo - 0xDC00) + 0x10000;\n+    }\n+\n+  rval = one_cppchar_to_utf8 (s, outbufp, outbytesleftp);\n+  if (rval)\n+    return rval;\n+\n+  /* Success - update the input pointers (one_cppchar_to_utf8 has done\n+     the output pointers for us).  */\n+  if (s <= 0xFFFF)\n+    {\n+      *inbufp += 2;\n+      *inbytesleftp -= 2;\n+    }\n+  else\n+    {\n+      *inbufp += 4;\n+      *inbytesleftp -= 4;\n+    }\n+  return 0;\n+}\n+\n+/* Helper routine for the next few functions.  The 'const' on\n+   one_conversion means that we promise not to modify what function is\n+   pointed to, which lets the inliner see through it. */\n+\n+static inline bool\n+conversion_loop (int (*const one_conversion)(iconv_t, const uchar **, size_t *,\n+\t\t\t\t\t     uchar **, size_t *),\n+\t\t iconv_t cd, const uchar *from, size_t flen, struct strbuf *to)\n+{\n+  const uchar *inbuf;\n+  uchar *outbuf;\n+  size_t inbytesleft, outbytesleft;\n+  int rval;\n+\n+  inbuf = from;\n+  inbytesleft = flen;\n+  outbuf = to->text + to->len;\n+  outbytesleft = to->asize - to->len;\n+\n+  for (;;)\n+    {\n+      do\n+\trval = one_conversion (cd, &inbuf, &inbytesleft,\n+\t\t\t       &outbuf, &outbytesleft);\n+      while (inbytesleft && !rval);\n+\n+      if (__builtin_expect (inbytesleft == 0, 1))\n+\t{\n+\t  to->len = to->asize - outbytesleft;\n+\t  return true;\n+\t}\n+      if (rval != E2BIG)\n+\t{\n+\t  errno = rval;\n+\t  return false;\n+\t}\n+\n+      outbytesleft += OUTBUF_BLOCK_SIZE;\n+      to->asize += OUTBUF_BLOCK_SIZE;\n+      to->text = xrealloc (to->text, to->asize);\n+      outbuf = to->text + to->asize - outbytesleft;\n+    }\n+}\n+\t\t \n+\n+/* These functions convert entire strings between character sets.\n+   They all have the signature\n+\n+   bool (*)(iconv_t cd, const uchar *from, size_t flen, struct strbuf *to);\n+\n+   The input string FROM is converted as specified by the function\n+   name plus the iconv descriptor CD (which may be fake), and the\n+   result appended to TO.  On any error, false is returned, otherwise true.  */\n+\n+/* These four use the custom conversion code above.  */\n+static bool\n+convert_utf8_utf16 (iconv_t cd, const uchar *from, size_t flen,\n+\t\t    struct strbuf *to)\n+{\n+  return conversion_loop (one_utf8_to_utf16, cd, from, flen, to);\n+}\n+\n+static bool\n+convert_utf8_utf32 (iconv_t cd, const uchar *from, size_t flen,\n+\t\t    struct strbuf *to)\n+{\n+  return conversion_loop (one_utf8_to_utf32, cd, from, flen, to);\n+}\n+\n+static bool\n+convert_utf16_utf8 (iconv_t cd, const uchar *from, size_t flen,\n+\t\t    struct strbuf *to)\n+{\n+  return conversion_loop (one_utf16_to_utf8, cd, from, flen, to);\n+}\n+\n+static bool\n+convert_utf32_utf8 (iconv_t cd, const uchar *from, size_t flen,\n+\t\t    struct strbuf *to)\n+{\n+  return conversion_loop (one_utf32_to_utf8, cd, from, flen, to);\n+}\n+\n+/* Identity conversion, used when we have no alternative.  */\n+static bool\n+convert_no_conversion (iconv_t cd ATTRIBUTE_UNUSED,\n+\t\t       const uchar *from, size_t flen, struct strbuf *to)\n+{\n+  if (to->len + flen > to->asize)\n+    {\n+      to->asize = to->len + flen;\n+      to->text = xrealloc (to->text, to->asize);\n+    }\n+  memcpy (to->text + to->len, from, flen);\n+  to->len += flen;\n+  return true;\n+}\n+\n+/* And this one uses the system iconv primitive.  It's a little\n+   different, since iconv's interface is a little different.  */\n+\n+static bool\n+convert_using_iconv (iconv_t cd, const uchar *from, size_t flen,\n+\t\t     struct strbuf *to)\n+{\n+  ICONV_CONST char *inbuf;\n+  char *outbuf;\n+  size_t inbytesleft, outbytesleft;\n+\n+  /* Reset conversion descriptor and check that it is valid.  */\n+  if (iconv (cd, 0, 0, 0, 0) == (size_t)-1)\n+    return false;\n+\n+  inbuf = (ICONV_CONST char *)from;\n+  inbytesleft = flen;\n+  outbuf = (char *)to->text + to->len;\n+  outbytesleft = to->asize - to->len;\n+\n+  for (;;)\n+    {\n+      iconv (cd, &inbuf, &inbytesleft, &outbuf, &outbytesleft);\n+      if (__builtin_expect (inbytesleft == 0, 1))\n+\t{\n+\t  to->len = to->asize - outbytesleft;\n+\t  return true;\n+\t}\n+      if (errno != E2BIG)\n+\treturn false;\n+\n+      outbytesleft += OUTBUF_BLOCK_SIZE;\n+      to->asize += OUTBUF_BLOCK_SIZE;\n+      to->text = xrealloc (to->text, to->asize);\n+      outbuf = (char *)to->text + to->asize - outbytesleft;\n+    }\n+}\n+\n+/* Arrange for the above custom conversion logic to be used automatically\n+   when conversion between a suitable pair of character sets is requested.  */\n+\n+#define APPLY_CONVERSION(CONVERTER, FROM, FLEN, TO) \\\n+   CONVERTER.func (CONVERTER.cd, FROM, FLEN, TO)\n+\n+struct conversion\n+{\n+  const char *pair;\n+  convert_f func;\n+  iconv_t fake_cd;\n+};\n+static const struct conversion conversion_tab[] = {\n+  { \"UTF-8/UTF-32LE\", convert_utf8_utf32, (iconv_t)0 },\n+  { \"UTF-8/UTF-32BE\", convert_utf8_utf32, (iconv_t)1 },\n+  { \"UTF-8/UTF-16LE\", convert_utf8_utf16, (iconv_t)0 },\n+  { \"UTF-8/UTF-16BE\", convert_utf8_utf16, (iconv_t)1 },\n+  { \"UTF-32LE/UTF-8\", convert_utf32_utf8, (iconv_t)0 },\n+  { \"UTF-32BE/UTF-8\", convert_utf32_utf8, (iconv_t)1 },\n+  { \"UTF-16LE/UTF-8\", convert_utf16_utf8, (iconv_t)0 },\n+  { \"UTF-16BE/UTF-8\", convert_utf16_utf8, (iconv_t)1 },\n+};\n+\n+/* Subroutine of cpp_init_iconv: initialize and return a\n+   cset_converter structure for conversion from FROM to TO.  If\n+   iconv_open() fails, issue an error and return an identity\n+   converter.  Silently return an identity converter if FROM and TO\n+   are identical.  */\n+static struct cset_converter\n init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n {\n-  iconv_t dsc;\n+  struct cset_converter ret;\n+  char *pair;\n+  size_t i;\n+  \n+  if (!strcasecmp (to, from))\n+    {\n+      ret.func = convert_no_conversion;\n+      ret.cd = (iconv_t) -1;\n+      return ret;\n+    }\n+\n+  pair = alloca(strlen(to) + strlen(from) + 2);\n+\n+  strcpy(pair, from);\n+  strcat(pair, \"/\");\n+  strcat(pair, to);\n+  for (i = 0; i < ARRAY_SIZE (conversion_tab); i++)\n+    if (!strcasecmp (pair, conversion_tab[i].pair))\n+      {\n+\tret.func = conversion_tab[i].func;\n+\tret.cd = conversion_tab[i].fake_cd;\n+\treturn ret;\n+      }\n \n-  if (!strcmp (to, from))\n-    return (iconv_t) -1;\n+  /* No custom converter - try iconv.  */\n+  ret.func = convert_using_iconv;\n+  ret.cd = iconv_open (to, from);\n \n-  dsc = iconv_open (to, from);\n-  if (dsc == (iconv_t) -1)\n+  if (ret.cd == (iconv_t) -1)\n     {\n       if (errno == EINVAL)\n \tcpp_error (pfile, DL_ERROR, /* XXX should be DL_SORRY */\n \t\t   \"conversion from %s to %s not supported by iconv\",\n \t\t   from, to);\n       else\n \tcpp_errno (pfile, DL_ERROR, \"iconv_open\");\n+\n+      ret.func = convert_no_conversion;\n     }\n-  return dsc;\n+  return ret;\n }\n \n /* If charset conversion is requested, initialize iconv(3) descriptors\n@@ -146,9 +669,9 @@ cpp_init_iconv (cpp_reader *pfile)\n   bool be = CPP_OPTION (pfile, bytes_big_endian);\n \n   if (CPP_OPTION (pfile, wchar_precision) >= 32)\n-    default_wcset = be ? \"UCS-4BE\" : \"UCS-4LE\";\n+    default_wcset = be ? \"UTF-32BE\" : \"UTF-32LE\";\n   else if (CPP_OPTION (pfile, wchar_precision) >= 16)\n-    default_wcset = be ? \"UCS-2BE\" : \"UCS-2LE\";\n+    default_wcset = be ? \"UTF-16BE\" : \"UTF-16LE\";\n   else\n     /* This effectively means that wide strings are not supported,\n        so don't do any conversion at all.  */\n@@ -181,67 +704,13 @@ _cpp_destroy_iconv (cpp_reader *pfile)\n {\n   if (HAVE_ICONV)\n     {\n-      if (pfile->narrow_cset_desc != (iconv_t) -1)\n-\ticonv_close (pfile->narrow_cset_desc);\n-      if (pfile->wide_cset_desc != (iconv_t) -1)\n-\ticonv_close (pfile->wide_cset_desc);\n+      if (pfile->narrow_cset_desc.func == convert_using_iconv)\n+\ticonv_close (pfile->narrow_cset_desc.cd);\n+      if (pfile->wide_cset_desc.func == convert_using_iconv)\n+\ticonv_close (pfile->wide_cset_desc.cd);\n     }\n }\n \n-/* iconv(3) utility wrapper.  Convert the string FROM, of length FLEN,\n-   according to the iconv descriptor CD.  The result is appended to\n-   the string buffer TO.  If DESC is (iconv_t)-1 or iconv is not\n-   available, the string is simply copied into TO.\n-\n-   Returns true on success, false on error.  */\n-\n-static bool\n-convert_cset (iconv_t cd, const uchar *from, size_t flen, struct strbuf *to)\n-{\n-  if (!HAVE_ICONV || cd == (iconv_t)-1)\n-    {\n-      if (to->len + flen > to->asize)\n-\t{\n-\t  to->asize = to->len + flen;\n-\t  to->text = xrealloc (to->text, to->asize);\n-\t}\n-      memcpy (to->text + to->len, from, flen);\n-      to->len += flen;\n-      return true;\n-    }\n-  else\n-    {\n-      ICONV_CONST char *inbuf;\n-      char *outbuf;\n-      size_t inbytesleft, outbytesleft;\n-\n-      /* Reset conversion descriptor and check that it is valid.  */\n-      if (iconv (cd, 0, 0, 0, 0) == (size_t)-1)\n-\treturn false;\n-\n-      inbuf = (ICONV_CONST char *)from;\n-      inbytesleft = flen;\n-      outbuf = (char *)to->text + to->len;\n-      outbytesleft = to->asize - to->len;\n-\n-      for (;;)\n-\t{\n-\t  iconv (cd, &inbuf, &inbytesleft, &outbuf, &outbytesleft);\n-\t  if (__builtin_expect (inbytesleft == 0, 1))\n-\t    {\n-\t      to->len = to->asize - outbytesleft;\n-\t      return true;\n-\t    }\n-\t  if (errno != E2BIG)\n-\t    return false;\n-\n-\t  outbytesleft += OUTBUF_BLOCK_SIZE;\n-\t  to->asize += OUTBUF_BLOCK_SIZE;\n-\t  to->text = xrealloc (to->text, to->asize);\n-\t  outbuf = (char *)to->text + to->asize - outbytesleft;\n-\t}\n-    }\n-}\n \n /* Utility routine that computes a mask of the form 0000...111... with\n    WIDTH 1-bits.  */\n@@ -390,15 +859,6 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n    \"universal character %.*s is not valid at the start of an identifier\",\n \t\t   (int) (str - base), base);\n     }\n-  /* We don't accept UCNs if iconv is not available or will not\n-     convert to the target wide character set.  */\n-  else if (!HAVE_ICONV || pfile->wide_cset_desc == (iconv_t) -1)\n-    {\n-      /* XXX should be DL_SORRY */\n-      cpp_error (pfile, DL_ERROR,\n-\t\"universal character names are not supported in this configuration\");\n-    }\n-\n \n   if (result == 0)\n     result = 1;\n@@ -408,58 +868,31 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n \n /* Convert an UCN, pointed to by FROM, to UTF-8 encoding, then translate\n    it to the execution character set and write the result into TBUF.\n-   An advanced pointer is returned.  Issues all relevant diagnostics.\n-\n-   UTF-8 encoding looks like this:\n-\n-   value range\t       encoded as\n-   00000000-0000007F   0xxxxxxx\n-   00000080-000007FF   110xxxxx 10xxxxxx\n-   00000800-0000FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-   00010000-001FFFFF   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n-   00200000-03FFFFFF   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n-   04000000-7FFFFFFF   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n+   An advanced pointer is returned.  Issues all relevant diagnostics.  */\n \n-   Values in the 0000D800 ... 0000DFFF range (surrogates) are invalid,\n-   which means that three-byte sequences ED xx yy, with A0 <= xx <= BF,\n-   never occur.  Note also that any value that can be encoded by a\n-   given row of the table can also be encoded by all successive rows,\n-   but this is not done; only the shortest possible encoding for any\n-   given value is valid.  For instance, the character 07C0 could be\n-   encoded as any of DF 80, E0 9F 80, F0 80 9F 80, F8 80 80 9F 80, or\n-   FC 80 80 80 9F 80.  Only the first is valid.  */\n \n static const uchar *\n convert_ucn (cpp_reader *pfile, const uchar *from, const uchar *limit,\n \t     struct strbuf *tbuf, bool wide)\n {\n-  int nbytes;\n-  uchar buf[6], *p = &buf[6];\n-  static const uchar masks[6] = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n   cppchar_t ucn;\n-\n-  from++; /* skip u/U */\n+  uchar buf[6];\n+  uchar *bufp = buf;\n+  size_t bytesleft = 6;\n+  int rval;\n+  struct cset_converter cvt\n+    = wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc;\n+\n+  from++;  /* skip u/U */\n   ucn = _cpp_valid_ucn (pfile, &from, limit, 0);\n-  if (!ucn)\n-    return from;\n \n-  nbytes = 1;\n-  if (ucn < 0x80)\n-    *--p = ucn;\n-  else\n+  rval = one_cppchar_to_utf8 (ucn, &bufp, &bytesleft);\n+  if (rval)\n     {\n-      do\n-\t{\n-\t  *--p = ((ucn & 0x3F) | 0x80);\n-\t  ucn >>= 6;\n-\t  nbytes++;\n-\t}\n-      while (ucn >= 0x3F || (ucn & masks[nbytes-1]));\n-      *--p = (ucn | masks[nbytes-1]);\n+      errno = rval;\n+      cpp_errno (pfile, DL_ERROR, \"converting UCN to source character set\");\n     }\n-\n-  if (!convert_cset (wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc,\n-\t\t     p, nbytes, tbuf))\n+  else if (!APPLY_CONVERSION (cvt, buf, 6 - bytesleft, tbuf))\n     cpp_errno (pfile, DL_ERROR, \"converting UCN to execution character set\");\n \n   return from;\n@@ -615,6 +1048,8 @@ convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n #endif\n \n   uchar c;\n+  struct cset_converter cvt\n+    = wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc;\n \n   c = *from;\n   switch (c)\n@@ -676,8 +1111,7 @@ convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n     }\n \n   /* Now convert what we have to the execution character set.  */\n-  if (!convert_cset (wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc,\n-\t\t     &c, 1, tbuf))\n+  if (!APPLY_CONVERSION (cvt, &c, 1, tbuf))\n     cpp_errno (pfile, DL_ERROR,\n \t       \"converting escape sequence to execution character set\");\n \n@@ -697,7 +1131,8 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n   struct strbuf tbuf;\n   const uchar *p, *base, *limit;\n   size_t i;\n-  iconv_t cd = wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc;\n+  struct cset_converter cvt\n+    = wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc;\n \n   tbuf.asize = MAX (OUTBUF_BLOCK_SIZE, from->len);\n   tbuf.text = xmalloc (tbuf.asize);\n@@ -719,7 +1154,7 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n \t    {\n \t      /* We have a run of normal characters; these can be fed\n \t\t directly to convert_cset.  */\n-\t      if (!convert_cset (cd, base, p - base, &tbuf))\n+\t      if (!APPLY_CONVERSION (cvt, base, p - base, &tbuf))\n \t\tgoto fail;\n \t    }\n \t  if (p == limit)\n@@ -741,6 +1176,25 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n   free (tbuf.text);\n   return false;\n }\n+\n+/* Subroutine of do_line and do_linemarker.  Convert escape sequences\n+   in a string, but do not perform character set conversion.  */\n+bool\n+_cpp_interpret_string_notranslate (cpp_reader *pfile, const cpp_string *in,\n+\t\t\t\t   cpp_string *out)\n+{\n+  struct cset_converter save_narrow_cset_desc = pfile->narrow_cset_desc;\n+  bool retval;\n+\n+  pfile->narrow_cset_desc.func = convert_no_conversion;\n+  pfile->narrow_cset_desc.cd = (iconv_t) -1;\n+\n+  retval = cpp_interpret_string (pfile, in, 1, out, false);\n+\n+  pfile->narrow_cset_desc = save_narrow_cset_desc;\n+  return retval;\n+}\n+\n \f\n /* Subroutine of cpp_interpret_charconst which performs the conversion\n    to a number, for narrow strings.  STR is the string structure returned"}, {"sha": "0e1bb3922ce88c27421eed615fd7c00de2f965de", "filename": "gcc/cpphash.h", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b88314c653778739e9f92700c3ae6a94a2a222c/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b88314c653778739e9f92700c3ae6a94a2a222c/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=6b88314c653778739e9f92700c3ae6a94a2a222c", "patch": "@@ -35,6 +35,15 @@ typedef int iconv_t;  /* dummy */\n struct directive;\t\t/* Deliberately incomplete.  */\n struct pending_option;\n struct op;\n+struct strbuf;\n+\n+typedef bool (*convert_f) (iconv_t, const unsigned char *, size_t,\n+\t\t\t   struct strbuf *);\n+struct cset_converter\n+{\n+  convert_f func;\n+  iconv_t cd;\n+};\n \n #ifndef HAVE_UCHAR\n typedef unsigned char uchar;\n@@ -369,14 +378,13 @@ struct cpp_reader\n   unsigned char *macro_buffer;\n   unsigned int macro_buffer_len;\n \n-  /* Iconv descriptor for converting from the source character set\n-     to the execution character set.  (iconv_t)-1 for no conversion.  */\n-  iconv_t narrow_cset_desc;\n+  /* Descriptor for converting from the source character set to the\n+     execution character set.  */\n+  struct cset_converter narrow_cset_desc;\n \n-  /* Iconv descriptor for converting from the execution character set\n-     to the wide execution character set.  (iconv_t)-1 for no conversion\n-     other than zero-extending each character to the width of wchar_t.  */\n-  iconv_t wide_cset_desc;\n+  /* Descriptor for converting from the source character set to the\n+     wide execution character set.  */\n+  struct cset_converter wide_cset_desc;\n \n   /* Tree of other included files.  See cppfiles.c.  */\n   struct splay_tree_s *all_include_files;\n@@ -555,8 +563,11 @@ extern uchar *_cpp_copy_replacement_text (const cpp_macro *, uchar *);\n extern size_t _cpp_replacement_text_len (const cpp_macro *);\n \n /* In cppcharset.c.  */\n-cppchar_t _cpp_valid_ucn (cpp_reader *, const uchar **, const uchar *, int);\n-void _cpp_destroy_iconv (cpp_reader *);\n+extern cppchar_t _cpp_valid_ucn (cpp_reader *, const uchar **,\n+\t\t\t\t const uchar *, int);\n+extern void _cpp_destroy_iconv (cpp_reader *);\n+extern bool _cpp_interpret_string_notranslate (cpp_reader *, const cpp_string *,\n+\t\t\t\t\t       cpp_string *);\n \n /* Utility routines and macros.  */\n #define DSC(str) (const uchar *)str, sizeof str - 1"}, {"sha": "1dfef726954de1a5a8d9838f8b491e8287645a21", "filename": "gcc/cpplib.c", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b88314c653778739e9f92700c3ae6a94a2a222c/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b88314c653778739e9f92700c3ae6a94a2a222c/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=6b88314c653778739e9f92700c3ae6a94a2a222c", "patch": "@@ -733,21 +733,6 @@ strtoul_for_line (const uchar *str, unsigned int len, long unsigned int *nump)\n   return 0;\n }\n \n-/* Subroutine of do_line and do_linemarker.  Convert escape sequences\n-   in a string, but do not perform character set conversion.  */\n-static bool\n-interpret_string_notranslate (cpp_reader *pfile, const cpp_string *in,\n-\t\t\t      cpp_string *out)\n-{\n-  iconv_t save_narrow_cset_desc = pfile->narrow_cset_desc;\n-  bool retval;\n-\n-  pfile->narrow_cset_desc = (iconv_t) -1;\n-  retval = cpp_interpret_string (pfile, in, 1, out, false);\n-  pfile->narrow_cset_desc = save_narrow_cset_desc;\n-  return retval;\n-}\n-\n /* Interpret #line command.\n    Note that the filename string (if any) is a true string constant\n    (escapes are interpreted), unlike in #line.  */\n@@ -780,7 +765,7 @@ do_line (cpp_reader *pfile)\n   if (token->type == CPP_STRING)\n     {\n       cpp_string s = { 0, 0 };\n-      if (interpret_string_notranslate (pfile, &token->val.str, &s))\n+      if (_cpp_interpret_string_notranslate (pfile, &token->val.str, &s))\n \tnew_file = (const char *)s.text;\n       check_eol (pfile);\n     }\n@@ -829,7 +814,7 @@ do_linemarker (cpp_reader *pfile)\n   if (token->type == CPP_STRING)\n     {\n       cpp_string s = { 0, 0 };\n-      if (interpret_string_notranslate (pfile, &token->val.str, &s))\n+      if (_cpp_interpret_string_notranslate (pfile, &token->val.str, &s))\n \tnew_file = (const char *)s.text;\n       \n       new_sysp = 0;"}]}