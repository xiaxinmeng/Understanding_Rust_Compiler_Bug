{"sha": "575ad7700f3d29d9310a778818c0c7a360f4eb1a", "node_id": "C_kwDOANBUbNoAKDU3NWFkNzcwMGYzZDI5ZDkzMTBhNzc4ODE4YzBjN2EzNjBmNGViMWE", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-12-15T07:30:20Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-12-15T07:30:20Z"}, "message": "Generate XXSPLTIDP for scalars on power10.\n\nThis patch implements XXSPLTIDP support for SF, and DF scalar constants.\nThe previous patch added support for vector constants.  This patch adds\nthe support for SFmode and DFmode scalar constants.\n\nI added 2 new tests to test loading up SF and DF scalar constants.\n\n2021-12-15  Michael Meissner  <meissner@the-meissners.org>\n\ngcc/\n\n\t* config/rs6000/rs6000.md (UNSPEC_XXSPLTIDP_CONST): New unspec.\n\t(UNSPEC_XXSPLTIW_CONST): New unspec.\n\t(movsf_hardfloat): Add support for generating XXSPLTIDP.\n\t(mov<mode>_hardfloat32): Likewise.\n\t(mov<mode>_hardfloat64): Likewise.\n\t(xxspltidp_<mode>_internal): New insns.\n\t(xxspltiw_<mode>_internal): New insns.\n\t(splitters for SF/DFmode): Add new splitters for XXSPLTIDP.\n\ngcc/testsuite/\n\n\t* gcc.target/powerpc/vec-splat-constant-df.c: New test.\n\t* gcc.target/powerpc/vec-splat-constant-sf.c: New test.", "tree": {"sha": "bddfbadc4e93128f20b6f0370f6acd1c63fa561c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bddfbadc4e93128f20b6f0370f6acd1c63fa561c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/575ad7700f3d29d9310a778818c0c7a360f4eb1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/575ad7700f3d29d9310a778818c0c7a360f4eb1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/575ad7700f3d29d9310a778818c0c7a360f4eb1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/575ad7700f3d29d9310a778818c0c7a360f4eb1a/comments", "author": null, "committer": null, "parents": [{"sha": "8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5"}], "stats": {"total": 217, "additions": 199, "deletions": 18}, "files": [{"sha": "4122acb98cfde4554ee653c503918ac81463a38d", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 79, "deletions": 18, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575ad7700f3d29d9310a778818c0c7a360f4eb1a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575ad7700f3d29d9310a778818c0c7a360f4eb1a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=575ad7700f3d29d9310a778818c0c7a360f4eb1a", "patch": "@@ -156,6 +156,8 @@\n    UNSPEC_PEXTD\n    UNSPEC_HASHST\n    UNSPEC_HASHCHK\n+   UNSPEC_XXSPLTIDP_CONST\n+   UNSPEC_XXSPLTIW_CONST\n   ])\n \n ;;\n@@ -7764,17 +7766,17 @@\n ;;\n ;;\tLWZ          LFS        LXSSP       LXSSPX     STFS       STXSSP\n ;;\tSTXSSPX      STW        XXLXOR      LI         FMR        XSCPSGNDP\n-;;\tMR           MT<x>      MF<x>       NOP\n+;;\tMR           MT<x>      MF<x>       NOP        XXSPLTIDP\n \n (define_insn \"movsf_hardfloat\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\"\n \t \"=!r,       f,         v,          wa,        m,         wY,\n \t  Z,         m,         wa,         !r,        f,         wa,\n-\t  !r,        *c*l,      !r,         *h\")\n+\t  !r,        *c*l,      !r,         *h,        wa\")\n \t(match_operand:SF 1 \"input_operand\"\n \t \"m,         m,         wY,         Z,         f,         v,\n \t  wa,        r,         j,          j,         f,         wa,\n-\t  r,         r,         *h,         0\"))]\n+\t  r,         r,         *h,         0,         eP\"))]\n   \"(register_operand (operands[0], SFmode)\n    || register_operand (operands[1], SFmode))\n    && TARGET_HARD_FLOAT\n@@ -7796,15 +7798,16 @@\n    mr %0,%1\n    mt%0 %1\n    mf%1 %0\n-   nop\"\n+   nop\n+   #\"\n   [(set_attr \"type\"\n \t\"load,       fpload,    fpload,     fpload,    fpstore,   fpstore,\n \t fpstore,    store,     veclogical, integer,   fpsimple,  fpsimple,\n-\t *,          mtjmpr,    mfjmpr,     *\")\n+\t *,          mtjmpr,    mfjmpr,     *,         vecperm\")\n    (set_attr \"isa\"\n \t\"*,          *,         p9v,        p8v,       *,         p9v,\n \t p8v,        *,         *,          *,         *,         *,\n-\t *,          *,         *,          *\")])\n+\t *,          *,         *,          *,         p10\")])\n \n ;;\tLWZ          LFIWZX     STW        STFIWX     MTVSRWZ    MFVSRWZ\n ;;\tFMR          MR         MT%0       MF%1       NOP\n@@ -8064,18 +8067,18 @@\n \n ;;           STFD         LFD         FMR         LXSD        STXSD\n ;;           LXSD         STXSD       XXLOR       XXLXOR      GPR<-0\n-;;           LWZ          STW         MR\n+;;           LWZ          STW         MR          XXSPLTIDP\n \n \n (define_insn \"*mov<mode>_hardfloat32\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\"\n             \"=m,          d,          d,          <f64_p9>,   wY,\n               <f64_av>,   Z,          <f64_vsx>,  <f64_vsx>,  !r,\n-              Y,          r,          !r\")\n+              Y,          r,          !r,         wa\")\n \t(match_operand:FMOVE64 1 \"input_operand\"\n              \"d,          m,          d,          wY,         <f64_p9>,\n               Z,          <f64_av>,   <f64_vsx>,  <zero_fp>,  <zero_fp>,\n-              r,          Y,          r\"))]\n+              r,          Y,          r,          eP\"))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -8092,20 +8095,21 @@\n    #\n    #\n    #\n+   #\n    #\"\n   [(set_attr \"type\"\n             \"fpstore,     fpload,     fpsimple,   fpload,     fpstore,\n              fpload,      fpstore,    veclogical, veclogical, two,\n-             store,       load,       two\")\n+             store,       load,       two,        vecperm\")\n    (set_attr \"size\" \"64\")\n    (set_attr \"length\"\n             \"*,           *,          *,          *,          *,\n              *,           *,          *,          *,          8,\n-             8,           8,          8\")\n+             8,           8,          8,          *\")\n    (set_attr \"isa\"\n             \"*,           *,          *,          p9v,        p9v,\n              p7v,         p7v,        *,          *,          *,\n-             *,           *,          *\")])\n+             *,           *,          *,          p10\")])\n \n ;;           STW      LWZ     MR      G-const H-const F-const\n \n@@ -8132,19 +8136,19 @@\n ;;           STFD         LFD         FMR         LXSD        STXSD\n ;;           LXSDX        STXSDX      XXLOR       XXLXOR      LI 0\n ;;           STD          LD          MR          MT{CTR,LR}  MF{CTR,LR}\n-;;           NOP          MFVSRD      MTVSRD\n+;;           NOP          MFVSRD      MTVSRD      XXSPLTIDP\n \n (define_insn \"*mov<mode>_hardfloat64\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\"\n            \"=m,           d,          d,          <f64_p9>,   wY,\n              <f64_av>,    Z,          <f64_vsx>,  <f64_vsx>,  !r,\n              YZ,          r,          !r,         *c*l,       !r,\n-            *h,           r,          <f64_dm>\")\n+            *h,           r,          <f64_dm>,   wa\")\n \t(match_operand:FMOVE64 1 \"input_operand\"\n             \"d,           m,          d,          wY,         <f64_p9>,\n              Z,           <f64_av>,   <f64_vsx>,  <zero_fp>,  <zero_fp>,\n              r,           YZ,         r,          r,          *h,\n-             0,           <f64_dm>,   r\"))]\n+             0,           <f64_dm>,   r,          eP\"))]\n   \"TARGET_POWERPC64 && TARGET_HARD_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -8166,18 +8170,19 @@\n    mf%1 %0\n    nop\n    mfvsrd %0,%x1\n-   mtvsrd %x0,%1\"\n+   mtvsrd %x0,%1\n+   #\"\n   [(set_attr \"type\"\n             \"fpstore,     fpload,     fpsimple,   fpload,     fpstore,\n              fpload,      fpstore,    veclogical, veclogical, integer,\n              store,       load,       *,          mtjmpr,     mfjmpr,\n-             *,           mfvsr,      mtvsr\")\n+             *,           mfvsr,      mtvsr,      vecperm\")\n    (set_attr \"size\" \"64\")\n    (set_attr \"isa\"\n             \"*,           *,          *,          p9v,        p9v,\n              p7v,         p7v,        *,          *,          *,\n              *,           *,          *,          *,          *,\n-             *,           p8v,        p8v\")])\n+             *,           p8v,        p8v,        p10\")])\n \n ;;           STD      LD       MR      MT<SPR> MF<SPR> G-const\n ;;           H-const  F-const  Special\n@@ -8211,6 +8216,62 @@\n    (set_attr \"length\"\n             \"*,       *,      *,      *,      *,      8,\n              12,      16,     *\")])\n+\n+;; Split the VSX prefixed instruction to support SFmode and DFmode scalar\n+;; constants that look like DFmode floating point values where both elements\n+;; are the same.  The constant has to be expressible as a SFmode constant that\n+;; is not a SFmode denormal value.\n+;;\n+;; We don't need splitters for the 128-bit types, since the function\n+;; rs6000_output_move_128bit handles the generation of XXSPLTIDP.\n+(define_insn \"xxspltidp_<mode>_internal\"\n+  [(set (match_operand:SFDF 0 \"register_operand\" \"=wa\")\n+\t(unspec:SFDF [(match_operand:SI 1 \"c32bit_cint_operand\" \"n\")]\n+\t\t     UNSPEC_XXSPLTIDP_CONST))]\n+  \"TARGET_POWER10\"\n+  \"xxspltidp %x0,%1\"\n+  [(set_attr \"type\" \"vecperm\")\n+   (set_attr \"prefixed\" \"yes\")])\n+\n+(define_insn \"xxspltiw_<mode>_internal\"\n+  [(set (match_operand:SFDF 0 \"register_operand\" \"=wa\")\n+\t(unspec:SFDF [(match_operand:SI 1 \"c32bit_cint_operand\" \"n\")]\n+\t\t     UNSPEC_XXSPLTIW_CONST))]\n+  \"TARGET_POWER10\"\n+  \"xxspltiw %x0,%1\"\n+  [(set_attr \"type\" \"vecperm\")\n+   (set_attr \"prefixed\" \"yes\")])\n+\n+(define_split\n+  [(set (match_operand:SFDF 0 \"vsx_register_operand\")\n+\t(match_operand:SFDF 1 \"vsx_prefixed_constant\"))]\n+  \"TARGET_POWER10\"\n+  [(pc)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  vec_const_128bit_type vsx_const;\n+\n+  if (!vec_const_128bit_to_bytes (src, <MODE>mode, &vsx_const))\n+    gcc_unreachable ();\n+\n+  unsigned imm = constant_generates_xxspltidp (&vsx_const);\n+  if (imm)\n+    {\n+      emit_insn (gen_xxspltidp_<mode>_internal (dest, GEN_INT (imm)));\n+      DONE;\n+    }\n+\n+  imm = constant_generates_xxspltiw (&vsx_const);\n+  if (imm)\n+    {\n+      emit_insn (gen_xxspltiw_<mode>_internal (dest, GEN_INT (imm)));\n+      DONE;\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+})\n \f\n (define_expand \"mov<mode>\"\n   [(set (match_operand:FMOVE128 0 \"general_operand\")"}, {"sha": "8f6e176f9af7f57fed3b185fd8c6aeb5eeca06a7", "filename": "gcc/testsuite/gcc.target/powerpc/vec-splat-constant-df.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575ad7700f3d29d9310a778818c0c7a360f4eb1a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575ad7700f3d29d9310a778818c0c7a360f4eb1a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-df.c?ref=575ad7700f3d29d9310a778818c0c7a360f4eb1a", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#include <math.h>\n+\n+/* Test generating DFmode constants with the ISA 3.1 (power10) XXSPLTIDP\n+   instruction.  */\n+\n+double\n+scalar_double_0 (void)\n+{\n+  return 0.0;\t\t\t/* XXSPLTIB or XXLXOR.  */\n+}\n+\n+double\n+scalar_double_1 (void)\n+{\n+  return 1.0;\t\t\t/* XXSPLTIDP.  */\n+}\n+\n+#ifndef __FAST_MATH__\n+double\n+scalar_double_m0 (void)\n+{\n+  return -0.0;\t\t\t/* XXSPLTIDP.  */\n+}\n+\n+double\n+scalar_double_nan (void)\n+{\n+  return __builtin_nan (\"\");\t/* XXSPLTIDP.  */\n+}\n+\n+double\n+scalar_double_inf (void)\n+{\n+  return __builtin_inf ();\t/* XXSPLTIDP.  */\n+}\n+\n+double\n+scalar_double_m_inf (void)\t/* XXSPLTIDP.  */\n+{\n+  return - __builtin_inf ();\n+}\n+#endif\n+\n+double\n+scalar_double_pi (void)\n+{\n+  return M_PI;\t\t\t/* PLFD.  */\n+}\n+\n+double\n+scalar_double_denorm (void)\n+{\n+  return 0x1p-149f;\t\t/* PLFD.  */\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxspltidp\\M} 5 } } */"}, {"sha": "72504bdfbbd3118c6df3c554a74980493e68e854", "filename": "gcc/testsuite/gcc.target/powerpc/vec-splat-constant-sf.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575ad7700f3d29d9310a778818c0c7a360f4eb1a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575ad7700f3d29d9310a778818c0c7a360f4eb1a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-sf.c?ref=575ad7700f3d29d9310a778818c0c7a360f4eb1a", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#include <math.h>\n+\n+/* Test generating SFmode constants with the ISA 3.1 (power10) XXSPLTIDP\n+   instruction.  */\n+\n+float\n+scalar_float_0 (void)\n+{\n+  return 0.0f;\t\t\t/* XXSPLTIB or XXLXOR.  */\n+}\n+\n+float\n+scalar_float_1 (void)\n+{\n+  return 1.0f;\t\t\t/* XXSPLTIDP.  */\n+}\n+\n+#ifndef __FAST_MATH__\n+float\n+scalar_float_m0 (void)\n+{\n+  return -0.0f;\t\t\t/* XXSPLTIDP.  */\n+}\n+\n+float\n+scalar_float_nan (void)\n+{\n+  return __builtin_nanf (\"\");\t/* XXSPLTIDP.  */\n+}\n+\n+float\n+scalar_float_inf (void)\n+{\n+  return __builtin_inff ();\t/* XXSPLTIDP.  */\n+}\n+\n+float\n+scalar_float_m_inf (void)\t/* XXSPLTIDP.  */\n+{\n+  return - __builtin_inff ();\n+}\n+#endif\n+\n+float\n+scalar_float_pi (void)\n+{\n+  return (float)M_PI;\t\t/* XXSPLTIDP.  */\n+}\n+\n+float\n+scalar_float_denorm (void)\n+{\n+  return 0x1p-149f;\t\t/* PLFS.  */\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxspltidp\\M} 6 } } */"}]}