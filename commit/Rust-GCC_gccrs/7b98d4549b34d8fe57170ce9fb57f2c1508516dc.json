{"sha": "7b98d4549b34d8fe57170ce9fb57f2c1508516dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I5OGQ0NTQ5YjM0ZDhmZTU3MTcwY2U5ZmI1N2YyYzE1MDg1MTZkYw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2002-09-04T17:35:22Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-09-04T17:35:22Z"}, "message": "2002-09-04  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/DatagramSocket.java\n\t(DatagramSocket): Added documentation.\n\t(close): Likewise.\n\t(getLocalAddress): Likewise.\n\t(getLocalPort): Likewise.\n\t(receive): Likewise.\n\t(send): Likewise.\n\t(setSoTimeout): Likewise.\n\t(connect): New method.\n\t(disconnect): New method.\n\t(getInetAddress): New method (FIXME)\n\t(getPort): New method.\n\t(setReuseAddress): New method.\n\t(getReuseAddress): New method.\n\t(setBroadcast): New method.\n\t(getBroadcast): New method.\n\t(setTrafficClass): New method.\n\t(getTrafficClass): New method.\n\t* java/net/MulticastSocket.java):\n\t(getTTL): Added @see in documentation.\n\t(setTTL): Added @see in documentation.\n\t(setLoopbackMode): New method.\n\t(getLoopbackMode): New method.\n\t* java/net/PlainSocketImpl.java:\n\tAdded new constants for the options SO_BROADCAST, SO_OOBINLINE,\n\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n\t* java/net/PlainDatagramSocketImpl.java\n\tAdded new constants for the options SO_BROADCAST, SO_OOBINLINE,\n\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n\t* java/net/natPlainSocketImpl.cc\n\t(getOption): Implemented the options SO_BROADCAST, SO_OOBINLINE,\n\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n\t(setOption): Implemented the options SO_BROADCAST, SO_OOBINLINE,\n\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n\tThis should also fix SO_KEEPALIVE\n\t* java/net/natPlainDatagramSocketImpl.cc\n\t(getOption): Implemented the options SO_BROADCAST, SO_OOBINLINE,\n\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n\t(setOption): Implemented the options SO_BROADCAST, SO_OOBINLINE,\n\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n\nFrom-SVN: r56801", "tree": {"sha": "8bb320d92038cae1714858799816e7404ad258f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bb320d92038cae1714858799816e7404ad258f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b98d4549b34d8fe57170ce9fb57f2c1508516dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b98d4549b34d8fe57170ce9fb57f2c1508516dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b98d4549b34d8fe57170ce9fb57f2c1508516dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/comments", "author": null, "committer": null, "parents": [{"sha": "77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea"}], "stats": {"total": 439, "additions": 417, "deletions": 22}, "files": [{"sha": "fd994b68105df1254438cb18b2e60eefa66260e1", "filename": "libjava/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7b98d4549b34d8fe57170ce9fb57f2c1508516dc", "patch": "@@ -1,3 +1,46 @@\n+2002-09-04  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/DatagramSocket.java\n+\t(DatagramSocket): Added documentation.\n+\t(close): Likewise.\n+\t(getLocalAddress): Likewise.\n+\t(getLocalPort): Likewise.\n+\t(receive): Likewise.\n+\t(send): Likewise.\n+\t(setSoTimeout): Likewise.\n+\t(connect): New method.\n+\t(disconnect): New method.\n+\t(getInetAddress): New method (FIXME)\n+\t(getPort): New method.\n+\t(setReuseAddress): New method.\n+\t(getReuseAddress): New method.\n+\t(setBroadcast): New method.\n+\t(getBroadcast): New method.\n+\t(setTrafficClass): New method.\n+\t(getTrafficClass): New method.\n+\t* java/net/MulticastSocket.java):\n+\t(getTTL): Added @see in documentation.\n+\t(setTTL): Added @see in documentation.\n+\t(setLoopbackMode): New method.\n+\t(getLoopbackMode): New method.\n+\t* java/net/PlainSocketImpl.java:\n+\tAdded new constants for the options SO_BROADCAST, SO_OOBINLINE,\n+\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n+\t* java/net/PlainDatagramSocketImpl.java\n+\tAdded new constants for the options SO_BROADCAST, SO_OOBINLINE,\n+\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n+\t* java/net/natPlainSocketImpl.cc\n+\t(getOption): Implemented the options SO_BROADCAST, SO_OOBINLINE,\n+\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n+\t(setOption): Implemented the options SO_BROADCAST, SO_OOBINLINE,\n+\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n+\tThis should also fix SO_KEEPALIVE\n+\t* java/net/natPlainDatagramSocketImpl.cc\n+\t(getOption): Implemented the options SO_BROADCAST, SO_OOBINLINE,\n+\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n+\t(setOption): Implemented the options SO_BROADCAST, SO_OOBINLINE,\n+\tIP_MULTICAST_IF2, IP_MULTICAST_LOOP, IP_TOS\n+\n 2002-09-04  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/SocketOptions.java: added static variables to be JDK 1.4"}, {"sha": "93aea0754ed8be7f4d3c8d2323d54e1f0f55babf", "filename": "libjava/java/net/DatagramSocket.java", "status": "modified", "additions": 201, "deletions": 17, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=7b98d4549b34d8fe57170ce9fb57f2c1508516dc", "patch": "@@ -31,11 +31,26 @@ public DatagramSocket() throws SocketException\n     this(0, null);\n   }\n \n+  /**\n+   * Creates a datagram socket that is bound to a specific port\n+   *\n+   * @param port The port number to bind to\n+   *\n+   * @exception SocketException If an error occurs\n+   */\n   public DatagramSocket(int port) throws SocketException\n   {\n     this(port, null);\n   }\n \n+  /**\n+   * Creates a datagram socket that is bound to a specific port/inet address\n+   *\n+   * @param port The port number to bind to\n+   * @param laddr The local address to bind to\n+   *\n+   * @exception SocketException If an error occurs\n+   */\n   public DatagramSocket(int port, InetAddress laddr) throws SocketException\n   {\n     if (port < 0 || port > 65535)\n@@ -69,11 +84,19 @@ public DatagramSocket(int port, InetAddress laddr) throws SocketException\n     impl.bind(port, laddr == null ? InetAddress.ANY_IF : laddr);\n   }\n \n+  /**\n+   * Closes the datagram socket\n+   */\n   public void close()\n   {\n     impl.close();\n   }\n \n+  /**\n+   * Returns the local address of the datagram socket\n+   * \n+   * @since 1.1\n+   */\n   public InetAddress getLocalAddress()\n   {\n     SecurityManager s = System.getSecurityManager();\n@@ -112,12 +135,23 @@ public InetAddress getLocalAddress()\n       }\n   }\n \n+  /**\n+   * Returns the local port this socket uses\n+   *\n+   * @return The local port number\n+   */\n   public int getLocalPort()\n   {\n     return impl.getLocalPort();\n   }\n \n   /**\n+   * Gets the SO_TIMEOUT value\n+   *\n+   * @return The current timeout in milliseconds\n+   *\n+   * @exception SocketException If an error occurs\n+   * \n    * @since 1.1\n    */\n   public synchronized int getSoTimeout() throws SocketException\n@@ -129,6 +163,13 @@ public synchronized int getSoTimeout() throws SocketException\n       return 0;\n   }\n \n+  /**\n+   * Receive a datagram packet\n+   *\n+   * @param p The datagram packet to put the incoming data into\n+   * \n+   * @exception IOException If an error occurs\n+   */\n   public synchronized void receive(DatagramPacket p) throws IOException\n   {\n     SecurityManager s = System.getSecurityManager();\n@@ -138,6 +179,13 @@ public synchronized void receive(DatagramPacket p) throws IOException\n     impl.receive(p);\n   }\n \n+  /**\n+   * Sends a datagram packet\n+   *\n+   * @param p The datagram packet to send\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void send(DatagramPacket p) throws IOException\n   {\n     // JDK1.2: Don't do security checks if socket is connected; see jdk1.2 api.\n@@ -151,11 +199,17 @@ public void send(DatagramPacket p) throws IOException\n \t  s.checkConnect(addr.getHostAddress(), p.getPort());\n       }\n \n-    // FIXME: if this is a subclass of MulticastSocket, use getTTL for TTL val.\n+    // FIXME: if this is a subclass of MulticastSocket, use getTimeToLive for TTL val.\n     impl.send(p);\n   }\n \n   /**\n+   * Sets a new value for SO_TIMEOUT\n+   *\n+   * @param timeout The timeout in milliseconds\n+   *\n+   * @exception SocketException If an error occurs\n+   *\n    * @since 1.1\n    */\n   public synchronized void setSoTimeout(int timeout) throws SocketException\n@@ -166,25 +220,53 @@ public synchronized void setSoTimeout(int timeout) throws SocketException\n     impl.setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n   }\n \n-  // JDK1.2\n-  // public void connect(InetAddress address, int port)\n-  // {\n-  // }\n+  /**\n+   * Connects the datagrem socket to a specified address/port\n+   *\n+   * @param address The address to connect to\n+   * @param port The port to connect to\n+   *\n+   * @exception SocketException If an error occurs\n+   *\n+   * @since 1.2\n+   */\n+  public void connect(InetAddress address, int port)\n+    throws SocketException\n+  {\n+    //impl.connect(address, port);\n+  }\n \n-  // JDK1.2\n-  // public void disconnect()\n-  // {\n-  // }\n+  /**\n+   * Disconnects the datagram socket\n+   *\n+   * @since 1.2\n+   */\n+  public void disconnect()\n+  {\n+    //impl.disconnect();\n+  }\n \n-  // JDK1.2\n-  // public InetAddress getInetAddress()\n-  // {\n-  // }\n+  /**\n+   * Returns the InetAddress the socket is connected to\n+   * or null if the socket is not connected\n+   * \n+   * @since 1.2\n+   */\n+  public InetAddress getInetAddress()\n+  {\n+    // FIXME:\n+    return null;\n+  }\n \n-  // JDK1.2\n-  // public int getPort()\n-  // {\n-  // }\n+  /**\n+   * Returns the local port number of the socket\n+   * \n+   * @since 1.2\n+   */\n+  public int getPort()\n+  {\n+    return impl.localPort;\n+  }\n \n   /**\n    * This method returns the value of the system level socket option\n@@ -207,6 +289,108 @@ public int getReceiveBufferSize() throws SocketException\n       throw new SocketException(\"Unexpected type\");\n   }\n \n+  /**\n+   * Enables/Disables SO_REUSEADDR\n+   * \n+   * @param on Whether or not to have SO_REUSEADDR turned on\n+   *\n+   * @exception SocketException If an error occurs\n+   *\n+   * @since 1.4\n+   */\n+  public void setReuseAddress(boolean on) throws SocketException\n+  {\n+    impl.setOption (SocketOptions.SO_REUSEADDR, new Boolean (on));\n+  }\n+\n+  /**\n+   * Checks if SO_REUSEADDR is enabled\n+   *\n+   * @exception SocketException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public boolean getReuseAddress() throws SocketException\n+  {\n+    Object obj = impl.getOption (SocketOptions.SO_REUSEADDR);\n+  \n+    if (obj instanceof Boolean)\n+      return(((Boolean) obj).booleanValue ());\n+    else \n+      throw new SocketException (\"Unexpected type\");\n+  }\n+\n+  /**\n+   * Enables/Disables SO_BROADCAST\n+   * \n+   * @param on Whether or not to have SO_BROADCAST turned on\n+   *\n+   * @exception SocketException If an error occurs\n+   *\n+   * @since 1.4\n+   */\n+  public void setBroadcast(boolean on) throws SocketException\n+  {\n+    impl.setOption (SocketOptions.SO_BROADCAST, new Boolean (on));\n+  }\n+\n+  /**\n+   * Checks if SO_BROADCAST is enabled\n+   * \n+   * @exception SocketException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public boolean getBroadcast() throws SocketException\n+  {\n+    Object obj = impl.getOption (SocketOptions.SO_BROADCAST);\n+  \n+    if (obj instanceof Boolean)\n+      return ((Boolean) obj).booleanValue ();\n+    else \n+      throw new SocketException (\"Unexpected type\");\n+  }\n+\n+  /**\n+   * Sets the traffic class value\n+   *\n+   * @param tc The traffic class\n+   *\n+   * @exception SocketException If an error occurs\n+   * @exception IllegalArgumentException If tc < 0 or rc > 255\n+   *\n+   * @see DatagramSocket:getTrafficClass\n+   * \n+   * @since 1.4\n+   */\n+  public void setTrafficClass(int tc)\n+    throws SocketException\n+  {\n+    if (tc < 0 || tc > 255)\n+      throw new IllegalArgumentException();\n+\n+    impl.setOption (SocketOptions.IP_TOS, new Integer (tc));\n+  }\n+  \n+  /**\n+   * Returns the current traffic class\n+   * \n+   * @see DatagramSocket:setTrafficClass\n+   *\n+   * @exception SocketException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public int getTrafficClass() throws SocketException\n+  {\n+    Object obj = impl.getOption(SocketOptions.IP_TOS);\n+\n+    if (obj instanceof Integer)\n+      return ((Integer) obj).intValue ();\n+    else\n+      throw new SocketException (\"Unexpected type\");\n+  }\n+  \n   /**\n    * This method returns the value of the system level socket option\n    * SO_SNDBUF, which is used by the operating system to tune buffer"}, {"sha": "88cb149633dd5a32b13984413c29f2f485f85bdb", "filename": "libjava/java/net/MulticastSocket.java", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FMulticastSocket.java?ref=7b98d4549b34d8fe57170ce9fb57f2c1508516dc", "patch": "@@ -114,6 +114,8 @@ public InetAddress getInterface() throws SocketException\n    * @exception IOException If an error occurs\n    *\n    * @deprecated 1.2 Replaced by getTimeToLive()\n+   *\n+   * @see Multicastsocket:getTimeToLive\n    */\n   public byte getTTL() throws IOException\n   {\n@@ -150,6 +152,42 @@ public void setInterface(InetAddress inf) throws SocketException\n     impl.setOption(SocketOptions.IP_MULTICAST_IF, inf);\n   }\n \n+  /**\n+   * Disable/Enable local loopback of multicast packets.  The option is used by\n+   * the platform's networking code as a hint for setting whether multicast\n+   * data will be looped back to the local socket. \n+   *\n+   * Because this option is a hint, applications that want to verify what\n+   * loopback mode is set to should call #getLoopbackMode\n+   *\n+   * @param disable True to disable loopback mode\n+   *\n+   * @exception SocketException If an error occurs\n+   *\n+   * @since 1.4\n+   */\n+  public void setLoopbackMode(boolean disable) throws SocketException\n+  {\n+    impl.setOption (SocketOptions.IP_MULTICAST_LOOP, new Boolean (disable));\n+  }\n+\n+  /**\n+   * Checks if local loopback mode is enabled or not\n+   *\n+   * @exception SocketException If an error occurs\n+   *\n+   * @since 1.4\n+   */\n+  public boolean getLoopbackMode() throws SocketException\n+  {\n+    Object obj = impl.getOption (SocketOptions.IP_MULTICAST_LOOP);\n+\n+    if (obj instanceof Boolean)\n+      return ((Boolean) obj).booleanValue ();\n+    else\n+      throw new SocketException (\"Unexpected type\");\n+  }\n+\n   /**\n    * Sets the \"Time to Live\" value for a socket.  The value must be between\n    * 1 and 255.\n@@ -159,6 +197,8 @@ public void setInterface(InetAddress inf) throws SocketException\n    * @exception IOException If an error occurs\n    *\n    * @deprecated 1.2 Replaced by <code>setTimeToLive</code>\n+   *\n+   * @see MulticastSocket:setTimeToLive\n    */\n   public void setTTL(byte ttl) throws IOException\n   {"}, {"sha": "8f3cda256f21c411416a784088c89f43e6ef61a0", "filename": "libjava/java/net/PlainDatagramSocketImpl.java", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java?ref=7b98d4549b34d8fe57170ce9fb57f2c1508516dc", "patch": "@@ -29,7 +29,12 @@ class PlainDatagramSocketImpl extends DatagramSocketImpl\n   static final int _Jv_TCP_NODELAY_ = SocketOptions.TCP_NODELAY,\n                    _Jv_SO_BINDADDR_ = SocketOptions.SO_BINDADDR,\n                    _Jv_SO_REUSEADDR_ = SocketOptions.SO_REUSEADDR,\n-\t\t   _Jv_IP_MULTICAST_IF_ = SocketOptions.IP_MULTICAST_IF,\n+                   _Jv_SO_BROADCAST_ = SocketOptions.SO_BROADCAST,\n+                   _Jv_SO_OOBINLINE_ = SocketOptions.SO_OOBINLINE,\n+                   _Jv_IP_MULTICAST_IF_ = SocketOptions.IP_MULTICAST_IF,\n+                   _Jv_IP_MULTICAST_IF2_ = SocketOptions.IP_MULTICAST_IF2,\n+                   _Jv_IP_MULTICAST_LOOP_ = SocketOptions.IP_MULTICAST_LOOP,\n+                   _Jv_IP_TOS_ = SocketOptions.IP_TOS,\n                    _Jv_SO_LINGER_ = SocketOptions.SO_LINGER,\n                    _Jv_SO_TIMEOUT_ = SocketOptions.SO_TIMEOUT,\n                    _Jv_SO_SNDBUF_ = SocketOptions.SO_SNDBUF,\n@@ -67,7 +72,7 @@ protected native void bind(int lport, InetAddress laddr)\n   public native void setOption(int optID, Object value) throws SocketException;\n   public native Object getOption(int optID) throws SocketException;\n   private native void mcastGrp(InetAddress inetaddr, boolean join)\n-\tthrows IOException;\n+\t  throws IOException;\n   protected native void close();\n \n   // Deprecated in JDK 1.2."}, {"sha": "dd04a1423c3518e5506631c823d85adc18bd0e2f", "filename": "libjava/java/net/PlainSocketImpl.java", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=7b98d4549b34d8fe57170ce9fb57f2c1508516dc", "patch": "@@ -28,7 +28,12 @@ class PlainSocketImpl extends SocketImpl\n   static final int _Jv_TCP_NODELAY_ = SocketOptions.TCP_NODELAY,\n                    _Jv_SO_BINDADDR_ = SocketOptions.SO_BINDADDR,\n                    _Jv_SO_REUSEADDR_ = SocketOptions.SO_REUSEADDR,\n-\t\t   _Jv_IP_MULTICAST_IF_ = SocketOptions.IP_MULTICAST_IF,\n+                   _Jv_SO_BROADCAST_ = SocketOptions.SO_BROADCAST,\n+                   _Jv_SO_OOBINLINE_ = SocketOptions.SO_OOBINLINE,\n+                   _Jv_IP_MULTICAST_IF_ = SocketOptions.IP_MULTICAST_IF,\n+                   _Jv_IP_MULTICAST_IF2_ = SocketOptions.IP_MULTICAST_IF2,\n+                   _Jv_IP_MULTICAST_LOOP_ = SocketOptions.IP_MULTICAST_LOOP,\n+                   _Jv_IP_TOS_ = SocketOptions.IP_TOS,\n                    _Jv_SO_LINGER_ = SocketOptions.SO_LINGER,\n                    _Jv_SO_TIMEOUT_ = SocketOptions.SO_TIMEOUT,\n                    _Jv_SO_SNDBUF_ = SocketOptions.SO_SNDBUF,"}, {"sha": "ca7bbc978990da464407ebcbb31a79ab4599b57d", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=7b98d4549b34d8fe57170ce9fb57f2c1508516dc", "patch": "@@ -528,6 +528,18 @@ java::net::PlainDatagramSocketImpl::setOption (jint optID,\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_KEEPALIVE not valid for UDP\"));\n         return;\n+\t\n+      case _Jv_SO_BROADCAST_ :\n+        if (::setsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n+                          val_len) != 0)\n+          goto error;\n+        break;\n+\t\n+      case _Jv_SO_OOBINLINE_ :\n+        throw new java::net::SocketException (\n+          JvNewStringUTF (\"SO_OOBINLINE: not valid for UDP\"));\n+        break;\n+\t\n       case _Jv_SO_SNDBUF_ :\n       case _Jv_SO_RCVBUF_ :\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n@@ -591,6 +603,23 @@ java::net::PlainDatagramSocketImpl::setOption (jint optID,\n \tif (::setsockopt (fnum, level, opname, ptr, len) != 0)\n \t  goto error;\n         return;\n+\t\n+      case _Jv_IP_MULTICAST_IF2_ :\n+        throw new java::net::SocketException (\n+          JvNewStringUTF (\"IP_MULTICAST_IF2: not yet implemented\"));\n+        break;\n+\t\n+      case _Jv_IP_MULTICAST_LOOP_ :\n+        throw new java::net::SocketException (\n+          JvNewStringUTF (\"IP_MULTICAST_LOOP: not yet implemented\"));\n+        break;\n+\t\n+      case _Jv_IP_TOS_ :\n+        if (::setsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+\t   val_len) != 0)\n+\t  goto error;    \n+\treturn;\n+\n       case _Jv_SO_TIMEOUT_ :\n \ttimeout = val;\n         return;\n@@ -625,6 +654,18 @@ java::net::PlainDatagramSocketImpl::getOption (jint optID)\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_KEEPALIVE not valid for UDP\"));\n         break;\n+\n+      case _Jv_SO_BROADCAST_ :\n+\tif (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n+\t    &val_len) != 0)\n+\t  goto error;\n+\treturn new java::lang::Boolean (val != 0);\n+\t\n+      case _Jv_SO_OOBINLINE_ :\n+        throw new java::net::SocketException (\n+          JvNewStringUTF (\"SO_OOBINLINE not valid for UDP\"));\n+\tbreak;\n+\t\n       case _Jv_SO_RCVBUF_ :\n       case _Jv_SO_SNDBUF_ :\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n@@ -697,6 +738,24 @@ java::net::PlainDatagramSocketImpl::getOption (jint optID)\n       case _Jv_SO_TIMEOUT_ :\n \treturn new java::lang::Integer (timeout);\n \tbreak;\n+\t\n+      case _Jv_IP_MULTICAST_IF2_ :\n+        throw new java::net::SocketException (\n+          JvNewStringUTF (\"IP_MULTICAST_IF2: not yet implemented\"));\n+        break;\n+\t\n+      case _Jv_IP_MULTICAST_LOOP_ :\n+\tif (::getsockopt (fnum, SOL_SOCKET, IP_MULTICAST_LOOP, (char *) &val,\n+\t    &val_len) != 0)\n+\t  goto error;\n+\treturn new java::lang::Boolean (val != 0);\n+\t\n+      case _Jv_IP_TOS_ :\n+        if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+           &val_len) != 0)\n+          goto error;\n+        return new java::lang::Integer (val);\n+\n       default :\n \terrno = ENOPROTOOPT;\n     }"}, {"sha": "a785b1b72243854ccf01dacff509fd0e84ed8619", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b98d4549b34d8fe57170ce9fb57f2c1508516dc/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=7b98d4549b34d8fe57170ce9fb57f2c1508516dc", "patch": "@@ -747,7 +747,19 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n         if (::setsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n \t    val_len) != 0)\n \t  goto error;\n-\n+\tbreak;\n+      \n+      case _Jv_SO_BROADCAST_ :\n+        throw new java::net::SocketException (\n+          JvNewStringUTF (\"SO_BROADCAST not valid for TCP\"));\n+\tbreak;\n+\t\n+      case _Jv_SO_OOBINLINE_ :\n+        if (::setsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n+\t    val_len) != 0)\n+\t  goto error;\n+\tbreak;\n+\t\n       case _Jv_SO_LINGER_ :\n #ifdef SO_LINGER\n         struct linger l_val;\n@@ -781,6 +793,23 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\"));\n         return;\n+\t\n+      case _Jv_IP_MULTICAST_IF2_ :\n+        throw new java::net::SocketException (\n+          JvNewStringUTF (\"IP_MULTICAST_IF2: not valid for TCP\"));\n+        break;\n+\t\n+      case _Jv_IP_MULTICAST_LOOP_ :\n+        throw new java::net::SocketException (\n+          JvNewStringUTF (\"IP_MULTICAST_LOOP: not valid for TCP\"));\n+\tbreak;\n+\t\n+      case _Jv_IP_TOS_ :\n+        if (::setsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+\t   val_len) != 0)\n+\t  goto error;    \n+\tbreak;\n+\t\n       case _Jv_SO_REUSEADDR_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_REUSEADDR: not valid for TCP\"));\n@@ -830,7 +859,7 @@ java::net::PlainSocketImpl::getOption (jint optID)\n         if (l_val.l_onoff)\n           return new java::lang::Integer (l_val.l_linger);\n         else\n-\t  return new java::lang::Boolean ((__java_boolean)false);\n+\t  return new java::lang::Boolean ((jboolean)false);\n #else\n         throw new java::lang::InternalError (\n           JvNewStringUTF (\"SO_LINGER not supported\"));\n@@ -844,6 +873,18 @@ java::net::PlainSocketImpl::getOption (jint optID)\n         else\n \t  return new java::lang::Boolean (val != 0);\n \n+      case _Jv_SO_BROADCAST_ :\n+        if (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n+\t   &val_len) != 0)\n+\t  goto error;    \n+        return new java::lang::Boolean ((__java_boolean)val);\n+\t\n+      case _Jv_SO_OOBINLINE_ :\n+        if (::getsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n+\t    &val_len) != 0)\n+\t  goto error;    \n+        return new java::lang::Boolean ((__java_boolean)val);\n+\t\n       case _Jv_SO_RCVBUF_ :\n       case _Jv_SO_SNDBUF_ :\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n@@ -888,6 +929,24 @@ java::net::PlainSocketImpl::getOption (jint optID)\n \tthrow new java::net::SocketException (\n \t  JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\"));\n \tbreak;\n+\t\n+      case _Jv_IP_MULTICAST_IF2_ :\n+\tthrow new java::net::SocketException (\n+\t  JvNewStringUTF (\"IP_MULTICAST_IF2: not valid for TCP\"));\n+\tbreak;\n+\t\n+      case _Jv_IP_MULTICAST_LOOP_ :\n+\tthrow new java::net::SocketException(\n+          JvNewStringUTF (\"IP_MULTICAST_LOOP: not valid for TCP\"));\n+\tbreak;\n+\t\n+      case _Jv_IP_TOS_ :\n+        if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+           &val_len) != 0)\n+          goto error;\n+        return new java::lang::Integer (val);\n+\tbreak;\n+\t\n       case _Jv_SO_REUSEADDR_ :\n \tthrow new java::net::SocketException (\n \t  JvNewStringUTF (\"SO_REUSEADDR: not valid for TCP\"));"}]}