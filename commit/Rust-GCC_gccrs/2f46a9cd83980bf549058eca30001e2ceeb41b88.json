{"sha": "2f46a9cd83980bf549058eca30001e2ceeb41b88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY0NmE5Y2Q4Mzk4MGJmNTQ5MDU4ZWNhMzAwMDFlMmNlZWI0MWI4OA==", "commit": {"author": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2014-10-24T11:40:58Z"}, "committer": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2014-10-24T11:40:58Z"}, "message": "Add new files missing from previous commit.\n\nFrom-SVN: r216641", "tree": {"sha": "36117f2cf0adb45c088b07f234d00487d5225419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36117f2cf0adb45c088b07f234d00487d5225419"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f46a9cd83980bf549058eca30001e2ceeb41b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f46a9cd83980bf549058eca30001e2ceeb41b88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f46a9cd83980bf549058eca30001e2ceeb41b88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f46a9cd83980bf549058eca30001e2ceeb41b88/comments", "author": null, "committer": null, "parents": [{"sha": "16ad00b00a34cfa41472e79b8795bf03966c1305", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ad00b00a34cfa41472e79b8795bf03966c1305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16ad00b00a34cfa41472e79b8795bf03966c1305"}], "stats": {"total": 1380, "additions": 1380, "deletions": 0}, "files": [{"sha": "52c374c0933988409d32c089091c598abb753d3d", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/README", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2FREADME?ref=2f46a9cd83980bf549058eca30001e2ceeb41b88", "patch": "@@ -0,0 +1,132 @@\n+This directory contains executable tests for ARM/AArch64 Advanced SIMD\n+(Neon) intrinsics.\n+\n+It is meant to cover execution cases of all the Advanced SIMD\n+intrinsics, but does not scan the generated assembler code.\n+\n+The general framework is composed as follows:\n+- advsimd-intrinsics.exp: main dejagnu driver\n+- *.c: actual tests, generally one per intrinsinc family\n+- arm-neon-ref.h: contains macro definitions to save typing in actual\n+  test files\n+- compute-ref-data.h: contains input vectors definitions\n+- *.inc: generic tests, shared by several families of intrinsics. For\n+   instance, unary or binary operators\n+\n+A typical .c test file starts with the following contents (look at\n+vld1.c and vaba.c for sample cases):\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+\n+Then, definitions of expected results, based on common input values,\n+as defined in compute-ref-data.h.\n+For example:\n+VECT_VAR_DECL(expected,int,16,4) [] = { 0x16, 0x17, 0x18, 0x19 };\n+defines the expected results of an operator generating int16x4 values.\n+\n+The common input values defined in compute-ref-data.h have been chosen\n+to avoid corner-case values for most operators, yet exposing negative\n+values for signed operators. For this reason, their range is also\n+limited. For instance, the initialization of buffer_int16x4 will be\n+{ -16, -15, -14, -13 }.\n+\n+The initialization of floating-point values is done via hex notation,\n+to avoid potential rounding problems.\n+\n+To test special values and corner cases, specific initialization\n+values should be used in dedicated tests, to ensure proper coverage.\n+An example of this is vshl.\n+\n+When a variant of an intrinsic is not available, its expected result\n+should be defined to the value of CLEAN_PATTERN_8 as defined in\n+arm-neon-ref.h. For example:\n+VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };\n+if the given intrinsic has no variant producing an int64x1 result,\n+like the vcmp family (eg. vclt).\n+\n+This is because the helper function (check_results(), defined in\n+arm-neon-ref.h), iterates over all the possible variants, to save\n+typing in each individual test file. Alternatively, one can directly\n+call the CHECK/CHECK_FP macros to check only a few expected results\n+(see vabs.c for an example).\n+\n+Then, define the TEST_MSG string, which will be used when reporting errors.\n+\n+Next, define the function performing the actual tests, in general\n+relying on the helpers provided by arm-neon-ref.h, which means:\n+\n+* declare necessary vectors of suitable types: using\n+  DECL_VARIABLE_ALL_VARIANTS when all variants are supported, or the\n+  relevant of subset calls to DECL_VARIABLE.\n+\n+* call clean_results() to initialize the 'results' buffers.\n+\n+* initialize the input vectors, using VLOAD, VDUP or VSET_LANE (vld*\n+  tests do not need this step, since their actual purpose is to\n+  initialize vectors).\n+\n+* execute the intrinsic on relevant variants, for instance using\n+  TEST_MACRO_ALL_VARIANTS_2_5.\n+\n+* call check_results() to check that the results match the expected\n+  values.\n+\n+A template test file could be:\n+=================================================================\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf6, 0xf7, 0xf8, 0xf9,\n+\t\t\t\t       0xfa, 0xfb, 0xfc, 0xfd };\n+/* and as many others as necessary.  */\n+\n+#define TEST_MSG \"VMYINTRINSIC\"\n+void exec_myintrinsic (void)\n+{\n+  /* my test: v4=vmyintrinsic(v1,v2,v3), then store the result.  */\n+#define TEST_VMYINTR(Q, T1, T2, W, N)\t\t\t\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\t\t\\\n+    vmyintr##Q##_##T2##W(VECT_VAR(vector1, T1, W, N),\t\t\t\\\n+\t\t\t VECT_VAR(vector2, T1, W, N),\t\t\t\\\n+\t\t\t VECT_VAR(vector3, T1, W, N));\t\t\t\\\n+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))\n+\n+#define DECL_VMYINTR_VAR(VAR)\t\t\t\\\n+  DECL_VARIABLE(VAR, int, 8, 8);\n+/* And as many others as necessary.  */\n+\n+  DECL_VMYINTR_VAR(vector1);\n+  DECL_VMYINTR_VAR(vector2);\n+  DECL_VMYINTR_VAR(vector3);\n+  DECL_VMYINTR_VAR(vector_res);\n+\n+  clean_results ();\n+\n+  /* Initialize input \"vector1\" from \"buffer\".  */\n+  VLOAD(vector1, buffer, , int, s, 8, 8);\n+/* And as many others as necessary.  */\n+\n+  /* Choose init value arbitrarily.  */\n+  VDUP(vector2, , int, s, 8, 8, 1);\n+/* And as many others as necessary.  */\n+\n+  /* Choose init value arbitrarily.  */\n+  VDUP(vector3, , int, s, 8, 8, -5);\n+/* And as many others as necessary.  */\n+\n+  /* Execute the tests.  */\n+  TEST_VMYINTR(, int, s, 8, 8);\n+/* And as many others as necessary.  */\n+\n+  check_results (TEST_MSG, \"\");\n+}\n+\n+int main (void)\n+{\n+  exec_vmyintrinsic ();\n+  return 0;\n+}\n+================================================================="}, {"sha": "3aa0e1c90e2b3082b452639fc442ce6826136622", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/advsimd-intrinsics.exp", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fadvsimd-intrinsics.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fadvsimd-intrinsics.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fadvsimd-intrinsics.exp?ref=2f46a9cd83980bf549058eca30001e2ceeb41b88", "patch": "@@ -0,0 +1,60 @@\n+# Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an ARM or AArch64 target.\n+if {![istarget arm*-*-*]\n+    && ![istarget aarch64*-*-*]} then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Initialize `dg'.\n+load_lib c-torture.exp\n+load_lib target-supports.exp\n+load_lib torture-options.exp\n+\n+dg-init\n+\n+torture-init\n+set-torture-options $C_TORTURE_OPTIONS {{}} $LTO_TORTURE_OPTIONS\n+\n+# Make sure Neon flags are provided, if necessary.\n+set additional_flags [add_options_for_arm_neon \"\"]\n+\n+# Main loop.\n+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.c]] {\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $src] then {\n+\tcontinue\n+    }\n+\n+    # runtest_file_p is already run above, and the code below can run\n+    # runtest_file_p again, make sure everything for this test is\n+    # performed if the above runtest_file_p decided this runtest\n+    # instance should execute the test\n+    gcc_parallel_test_enable 0\n+    c-torture-execute $src $additional_flags\n+    gcc-dg-runtest $src \"\" $additional_flags\n+    gcc_parallel_test_enable 1\n+}\n+\n+# All done.\n+torture-finish\n+dg-finish"}, {"sha": "8ea1f26611f5c0388e26917d292f91e39c5763c7", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h", "status": "added", "additions": 547, "deletions": 0, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Farm-neon-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Farm-neon-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Farm-neon-ref.h?ref=2f46a9cd83980bf549058eca30001e2ceeb41b88", "patch": "@@ -0,0 +1,547 @@\n+/* This file defines helper operations shared by all the tests.  */\n+\n+#ifndef _ARM_NEON_REF_H_\n+#define _ARM_NEON_REF_H_\n+\n+#include <stdio.h>\n+#include <inttypes.h>\n+\n+/* helper type, to help write floating point results in integer form.  */\n+typedef uint32_t hfloat32_t;\n+\n+extern void abort(void);\n+extern void *memset(void *, int, size_t);\n+extern void *memcpy(void *, const void *, size_t);\n+extern size_t strlen(const char *);\n+\n+/* Various string construction helpers.  */\n+\n+/*\n+  The most useful at user-level are VECT_VAR and VECT_VAR_DECL, which\n+   construct variable names or declarations, such as:\n+   VECT_VAR(expected, int, 16, 4) -> expected_int16x4\n+   VECT_VAR_DECL(expected, int, 16, 4) -> int16x4_t expected_int16x4\n+*/\n+\n+#define xSTR(X) #X\n+#define STR(X) xSTR(X)\n+\n+#define xNAME1(V,T) V ## _ ##  T\n+#define xNAME(V,T) xNAME1(V,T)\n+\n+/* VAR(foo,int,16) -> foo_int16 */\n+#define VAR(V,T,W) xNAME(V,T##W)\n+/* VAR_DECL(foo,int,16) -> int16_t foo_int16 */\n+#define VAR_DECL(V, T, W) T##W##_t VAR(V,T,W)\n+\n+/* VECT_NAME(int,16,4) ->  int16x4 */\n+#define VECT_NAME(T, W, N) T##W##x##N\n+/* VECT_ARRAY_NAME(int,16,4,2) -> int16x4x2 */\n+#define VECT_ARRAY_NAME(T, W, N, L) T##W##x##N##x##L\n+/* VECT_TYPE(int,16,4) -> int16x4_t */\n+#define VECT_TYPE(T, W, N) xNAME(VECT_NAME(T,W,N),t)\n+/* VECT_ARRAY_TYPE(int,16,4,2) -> int16x4x2_t */\n+#define VECT_ARRAY_TYPE(T, W, N, L) xNAME(VECT_ARRAY_NAME(T,W,N,L),t)\n+\n+/* VECT_VAR(foo,int,16,4) -> foo_int16x4 */\n+#define VECT_VAR(V,T,W,N) xNAME(V,VECT_NAME(T,W,N))\n+/* VECT_VAR_DECL(foo,int,16,4) -> int16_t foo_int16x4 */\n+#define VECT_VAR_DECL(V, T, W, N) T##W##_t VECT_VAR(V,T,W,N)\n+\n+/* Array declarations.  */\n+/* ARRAY(foo,int,16,4) -> int16_t foo_int16x4[4] */\n+#define ARRAY(V, T, W, N) VECT_VAR_DECL(V,T,W,N)[N]\n+\n+/* Arrays of vectors.  */\n+/* VECT_ARRAY_VAR(foo,int,16,4,2) -> foo_int16x4x2 */\n+#define VECT_ARRAY_VAR(V,T,W,N,L) xNAME(V,VECT_ARRAY_NAME(T,W,N,L))\n+/* VECT_ARRAY(foo,int,16,4,2) -> int16_t foo_int16x4x2[4*2] */\n+#define VECT_ARRAY(V, T, W, N, L) T##W##_t VECT_ARRAY_VAR(V,T,W,N,L)[N*L]\n+\n+/* Check results vs expected values. Operates on one vector.  */\n+#define CHECK(MSG,T,W,N,FMT,EXPECTED,COMMENT)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for(i=0; i<N ; i++)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (VECT_VAR(result, T, W, N)[i] !=\t\t\t\t\\\n+\t    VECT_VAR(EXPECTED, T, W, N)[i]) {\t\t\t\t\\\n+\t  fprintf(stderr,\t\t\t\t\t\t\\\n+\t\t  \"ERROR in %s (%s line %d in buffer '%s') at type %s \"\t\\\n+\t\t  \"index %d: got 0x%\" FMT \" != 0x%\" FMT \" %s\\n\",\t\\\n+\t\t  MSG, __FILE__, __LINE__,\t\t\t\t\\\n+\t\t  STR(EXPECTED),\t\t\t\t\t\\\n+\t\t  STR(VECT_NAME(T, W, N)),\t\t\t\t\\\n+\t\t  i,\t\t\t\t\t\t\t\\\n+\t\t  VECT_VAR(result, T, W, N)[i],\t\t\t\t\\\n+\t\t  VECT_VAR(EXPECTED, T, W, N)[i],\t\t\t\\\n+\t\t  strlen(COMMENT) > 0 ? COMMENT : \"\");\t\t\t\\\n+\t  abort();\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+/* Floating-point variant.  */\n+#define CHECK_FP(MSG,T,W,N,FMT,EXPECTED,COMMENT)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for(i=0; i<N ; i++)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tunion fp_operand {\t\t\t\t\t\t\\\n+\t  uint##W##_t i;\t\t\t\t\t\t\\\n+\t  float##W##_t f;\t\t\t\t\t\t\\\n+\t} tmp_res, tmp_exp;\t\t\t\t\t\t\\\n+\ttmp_res.f = VECT_VAR(result, T, W, N)[i];\t\t\t\\\n+\ttmp_exp.i = VECT_VAR(EXPECTED, h##T, W, N)[i];\t\t\t\\\n+\tif (tmp_res.i != tmp_exp.i) {\t\t\t\t\t\\\n+\t  fprintf(stderr,\t\t\t\t\t\t\\\n+\t\t  \"ERROR in %s (%s line %d in buffer '%s') at type %s \"\t\\\n+\t\t  \"index %d: got 0x%\" FMT \" != 0x%\" FMT \" %s\\n\",\t\\\n+\t\t  MSG, __FILE__, __LINE__,\t\t\t\t\\\n+\t\t  STR(EXPECTED),\t\t\t\t\t\\\n+\t\t  STR(VECT_NAME(T, W, N)),\t\t\t\t\\\n+\t\t  i,\t\t\t\t\t\t\t\\\n+\t\t  tmp_res.i,\t\t\t\t\t\t\\\n+\t\t  tmp_exp.i,\t\t\t\t\t\t\\\n+\t\t  strlen(COMMENT) > 0 ? COMMENT : \"\");\t\t\t\\\n+\t  abort();\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+/* Clean buffer with a non-zero pattern to help diagnose buffer\n+   overflows.  */\n+#define CLEAN_PATTERN_8  0x33\n+\n+#define CLEAN(VAR,T,W,N)\t\t\t\t\t\t\\\n+  memset(VECT_VAR(VAR, T, W, N),\t\t\t\t\t\\\n+\t CLEAN_PATTERN_8,\t\t\t\t\t\t\\\n+\t sizeof(VECT_VAR(VAR, T, W, N)));\n+\n+/* Define output buffers, one of each size.  */\n+static ARRAY(result, int, 8, 8);\n+static ARRAY(result, int, 16, 4);\n+static ARRAY(result, int, 32, 2);\n+static ARRAY(result, int, 64, 1);\n+static ARRAY(result, uint, 8, 8);\n+static ARRAY(result, uint, 16, 4);\n+static ARRAY(result, uint, 32, 2);\n+static ARRAY(result, uint, 64, 1);\n+static ARRAY(result, poly, 8, 8);\n+static ARRAY(result, poly, 16, 4);\n+static ARRAY(result, float, 32, 2);\n+static ARRAY(result, int, 8, 16);\n+static ARRAY(result, int, 16, 8);\n+static ARRAY(result, int, 32, 4);\n+static ARRAY(result, int, 64, 2);\n+static ARRAY(result, uint, 8, 16);\n+static ARRAY(result, uint, 16, 8);\n+static ARRAY(result, uint, 32, 4);\n+static ARRAY(result, uint, 64, 2);\n+static ARRAY(result, poly, 8, 16);\n+static ARRAY(result, poly, 16, 8);\n+static ARRAY(result, float, 32, 4);\n+\n+/* Declare expected results, one of each size. They are defined and\n+   initialized in each test file.  */\n+extern ARRAY(expected, int, 8, 8);\n+extern ARRAY(expected, int, 16, 4);\n+extern ARRAY(expected, int, 32, 2);\n+extern ARRAY(expected, int, 64, 1);\n+extern ARRAY(expected, uint, 8, 8);\n+extern ARRAY(expected, uint, 16, 4);\n+extern ARRAY(expected, uint, 32, 2);\n+extern ARRAY(expected, uint, 64, 1);\n+extern ARRAY(expected, poly, 8, 8);\n+extern ARRAY(expected, poly, 16, 4);\n+extern ARRAY(expected, hfloat, 32, 2);\n+extern ARRAY(expected, int, 8, 16);\n+extern ARRAY(expected, int, 16, 8);\n+extern ARRAY(expected, int, 32, 4);\n+extern ARRAY(expected, int, 64, 2);\n+extern ARRAY(expected, uint, 8, 16);\n+extern ARRAY(expected, uint, 16, 8);\n+extern ARRAY(expected, uint, 32, 4);\n+extern ARRAY(expected, uint, 64, 2);\n+extern ARRAY(expected, poly, 8, 16);\n+extern ARRAY(expected, poly, 16, 8);\n+extern ARRAY(expected, hfloat, 32, 4);\n+\n+/* Check results. Operates on all possible vector types.  */\n+#define CHECK_RESULTS(test_name,comment)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    CHECK(test_name, int, 8, 8, PRIx8, expected, comment);\t\t\\\n+    CHECK(test_name, int, 16, 4, PRIx16, expected, comment);\t\t\\\n+    CHECK(test_name, int, 32, 2, PRIx32, expected, comment);\t\t\\\n+    CHECK(test_name, int, 64, 1, PRIx64, expected, comment);\t\t\\\n+    CHECK(test_name, uint, 8, 8, PRIx8, expected, comment);\t\t\\\n+    CHECK(test_name, uint, 16, 4, PRIx16, expected, comment);\t\t\\\n+    CHECK(test_name, uint, 32, 2, PRIx32, expected, comment);\t\t\\\n+    CHECK(test_name, uint, 64, 1, PRIx64, expected, comment);\t\t\\\n+    CHECK(test_name, poly, 8, 8, PRIx8, expected, comment);\t\t\\\n+    CHECK(test_name, poly, 16, 4, PRIx16, expected, comment);\t\t\\\n+    CHECK_FP(test_name, float, 32, 2, PRIx32, expected, comment);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    CHECK(test_name, int, 8, 16, PRIx8, expected, comment);\t\t\\\n+    CHECK(test_name, int, 16, 8, PRIx16, expected, comment);\t\t\\\n+    CHECK(test_name, int, 32, 4, PRIx32, expected, comment);\t\t\\\n+    CHECK(test_name, int, 64, 2, PRIx64, expected, comment);\t\t\\\n+    CHECK(test_name, uint, 8, 16, PRIx8, expected, comment);\t\t\\\n+    CHECK(test_name, uint, 16, 8, PRIx16, expected, comment);\t\t\\\n+    CHECK(test_name, uint, 32, 4, PRIx32, expected, comment);\t\t\\\n+    CHECK(test_name, uint, 64, 2, PRIx64, expected, comment);\t\t\\\n+    CHECK(test_name, poly, 8, 16, PRIx8, expected, comment);\t\t\\\n+    CHECK(test_name, poly, 16, 8, PRIx16, expected, comment);\t\t\\\n+    CHECK_FP(test_name, float, 32, 4, PRIx32, expected, comment);\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+#define CHECK_RESULTS_NAMED(test_name,EXPECTED,comment)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    CHECK(test_name, int, 8, 8, PRIx8, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, int, 16, 4, PRIx16, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, int, 32, 2, PRIx32, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, int, 64, 1, PRIx64, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, uint, 8, 8, PRIx8, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, uint, 16, 4, PRIx16, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, uint, 32, 2, PRIx32, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, uint, 64, 1, PRIx64, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, poly, 8, 8, PRIx8, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, poly, 16, 4, PRIx16, EXPECTED, comment);\t\t\\\n+    CHECK_FP(test_name, float, 32, 2, PRIx32, EXPECTED, comment);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    CHECK(test_name, int, 8, 16, PRIx8, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, int, 16, 8, PRIx16, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, int, 32, 4, PRIx32, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, int, 64, 2, PRIx64, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, uint, 8, 16, PRIx8, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, uint, 16, 8, PRIx16, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, uint, 32, 4, PRIx32, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, uint, 64, 2, PRIx64, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, poly, 8, 16, PRIx8, EXPECTED, comment);\t\t\\\n+    CHECK(test_name, poly, 16, 8, PRIx16, EXPECTED, comment);\t\t\\\n+    CHECK_FP(test_name, float, 32, 4, PRIx32, EXPECTED, comment);\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+\n+typedef union {\n+  struct {\n+    int _xxx:27;\n+    unsigned int QC:1;\n+    int V:1;\n+    int C:1;\n+    int Z:1;\n+    int N:1;\n+  } b;\n+  unsigned int word;\n+} _ARM_FPSCR;\n+\n+#else /* __ORDER_BIG_ENDIAN__ */\n+\n+typedef union {\n+  struct {\n+    int N:1;\n+    int Z:1;\n+    int C:1;\n+    int V:1;\n+    unsigned int QC:1;\n+    int _dnm:27;\n+  } b;\n+  unsigned int word;\n+} _ARM_FPSCR;\n+\n+#endif /* __ORDER_BIG_ENDIAN__ */\n+\n+#define Neon_Cumulative_Sat  __read_neon_cumulative_sat()\n+#define Set_Neon_Cumulative_Sat(x)  __set_neon_cumulative_sat((x))\n+\n+#if defined(__aarch64__)\n+static volatile int __read_neon_cumulative_sat (void) {\n+    _ARM_FPSCR _afpscr_for_qc;\n+    asm volatile (\"mrs %0,fpsr\" : \"=r\" (_afpscr_for_qc));\n+    return _afpscr_for_qc.b.QC;\n+}\n+static void __set_neon_cumulative_sat (int x) {\n+    _ARM_FPSCR _afpscr_for_qc;\n+    asm volatile (\"mrs %0,fpsr\" : \"=r\" (_afpscr_for_qc));\n+    _afpscr_for_qc.b.QC = x;\n+    asm volatile (\"msr fpsr,%0\" : : \"r\" (_afpscr_for_qc));\n+    return;\n+}\n+#else\n+static volatile int __read_neon_cumulative_sat (void) {\n+    _ARM_FPSCR _afpscr_for_qc;\n+    asm volatile (\"vmrs %0,fpscr\" : \"=r\" (_afpscr_for_qc));\n+    return _afpscr_for_qc.b.QC;\n+}\n+\n+static void __set_neon_cumulative_sat (int x) {\n+    _ARM_FPSCR _afpscr_for_qc;\n+    asm volatile (\"vmrs %0,fpscr\" : \"=r\" (_afpscr_for_qc));\n+    _afpscr_for_qc.b.QC = x;\n+    asm volatile (\"vmsr fpscr,%0\" : : \"r\" (_afpscr_for_qc));\n+    return;\n+}\n+#endif\n+\n+/* Declare expected cumulative saturation results, one for each\n+   size. They are defined and initialized in relevant test files.  */\n+extern int VECT_VAR(expected_cumulative_sat, int, 8, 8);\n+extern int VECT_VAR(expected_cumulative_sat, int, 16, 4);\n+extern int VECT_VAR(expected_cumulative_sat, int, 32, 2);\n+extern int VECT_VAR(expected_cumulative_sat, int, 64, 1);\n+extern int VECT_VAR(expected_cumulative_sat, uint, 8, 8);\n+extern int VECT_VAR(expected_cumulative_sat, uint, 16, 4);\n+extern int VECT_VAR(expected_cumulative_sat, uint, 32, 2);\n+extern int VECT_VAR(expected_cumulative_sat, uint, 64, 1);\n+extern int VECT_VAR(expected_cumulative_sat, int, 8, 16);\n+extern int VECT_VAR(expected_cumulative_sat, int, 16, 8);\n+extern int VECT_VAR(expected_cumulative_sat, int, 32, 4);\n+extern int VECT_VAR(expected_cumulative_sat, int, 64, 2);\n+extern int VECT_VAR(expected_cumulative_sat, uint, 8, 16);\n+extern int VECT_VAR(expected_cumulative_sat, uint, 16, 8);\n+extern int VECT_VAR(expected_cumulative_sat, uint, 32, 4);\n+extern int VECT_VAR(expected_cumulative_sat, uint, 64, 2);\n+\n+/* Check cumulative saturation flag vs expected value.  */\n+#define CHECK_CUMULATIVE_SAT(MSG,T,W,N,EXPECTED,COMMENT)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (Neon_Cumulative_Sat !=\t\t\t\t\t\t\\\n+\tVECT_VAR(EXPECTED, T, W, N)) {\t\t\t\t\t\\\n+      fprintf(stderr,\t\t\t\t\t\t\t\\\n+\t      \"ERROR in %s (%s line %d in cumulative_sat '%s') at type %s: \" \\\n+\t      \"got %d expected %d%s\\n\",\t\t\t\t\t\\\n+\t      MSG, __FILE__, __LINE__,\t\t\t\t\t\\\n+\t      STR(EXPECTED),\t\t\t\t\t\t\\\n+\t      STR(VECT_NAME(T, W, N)),\t\t\t\t\t\\\n+\t      Neon_Cumulative_Sat,\t\t\t\t\t\\\n+\t      VECT_VAR(EXPECTED, T, W, N),\t\t\t\t\\\n+\t      strlen(COMMENT) > 0 ? \" \" COMMENT : \"\");\t\t\t\\\n+      abort();\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define CHECK_CUMULATIVE_SAT_NAMED(test_name,EXPECTED,comment)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    CHECK_CUMULATIVE_SAT(test_name, int, 8, 8, PRIx8, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, int, 16, 4, PRIx16, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, int, 32, 2, PRIx32, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, int, 64, 1, PRIx64, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, uint, 8, 8, PRIx8, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, uint, 16, 4, PRIx16, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, uint, 32, 2, PRIx32, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, uint, 64, 1, PRIx64, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, poly, 8, 8, PRIx8, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, poly, 16, 4, PRIx16, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT_FP(test_name, float, 32, 2, PRIx32, EXPECTED, comment); \\\n+\t\t\t\t\t\t\t\t\t\\\n+    CHECK_CUMULATIVE_SAT(test_name, int, 8, 16, PRIx8, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, int, 16, 8, PRIx16, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, int, 32, 4, PRIx32, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, int, 64, 2, PRIx64, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, uint, 8, 16, PRIx8, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, uint, 16, 8, PRIx16, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, uint, 32, 4, PRIx32, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, uint, 64, 2, PRIx64, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, poly, 8, 16, PRIx8, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT(test_name, poly, 16, 8, PRIx16, EXPECTED, comment); \\\n+    CHECK_CUMULATIVE_SAT_FP(test_name, float, 32, 4, PRIx32, EXPECTED, comment); \\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+\n+/* Clean output buffers before execution.  */\n+static void clean_results (void)\n+{\n+  CLEAN(result, int, 8, 8);\n+  CLEAN(result, int, 16, 4);\n+  CLEAN(result, int, 32, 2);\n+  CLEAN(result, int, 64, 1);\n+  CLEAN(result, uint, 8, 8);\n+  CLEAN(result, uint, 16, 4);\n+  CLEAN(result, uint, 32, 2);\n+  CLEAN(result, uint, 64, 1);\n+  CLEAN(result, poly, 8, 8);\n+  CLEAN(result, poly, 16, 4);\n+  CLEAN(result, float, 32, 2);\n+\n+  CLEAN(result, int, 8, 16);\n+  CLEAN(result, int, 16, 8);\n+  CLEAN(result, int, 32, 4);\n+  CLEAN(result, int, 64, 2);\n+  CLEAN(result, uint, 8, 16);\n+  CLEAN(result, uint, 16, 8);\n+  CLEAN(result, uint, 32, 4);\n+  CLEAN(result, uint, 64, 2);\n+  CLEAN(result, poly, 8, 16);\n+  CLEAN(result, poly, 16, 8);\n+  CLEAN(result, float, 32, 4);\n+}\n+\n+\n+/* Helpers to declare variables of various types.   */\n+#define DECL_VARIABLE(VAR, T1, W, N)\t\t\\\n+  VECT_TYPE(T1, W, N) VECT_VAR(VAR, T1, W, N)\n+\n+/* Declare only 64 bits signed variants.  */\n+#define DECL_VARIABLE_64BITS_SIGNED_VARIANTS(VAR)\t\\\n+  DECL_VARIABLE(VAR, int, 8, 8);\t\t\t\\\n+  DECL_VARIABLE(VAR, int, 16, 4);\t\t\t\\\n+  DECL_VARIABLE(VAR, int, 32, 2);\t\t\t\\\n+  DECL_VARIABLE(VAR, int, 64, 1)\n+\n+/* Declare only 64 bits unsigned variants.  */\n+#define DECL_VARIABLE_64BITS_UNSIGNED_VARIANTS(VAR)\t\\\n+  DECL_VARIABLE(VAR, uint, 8, 8);\t\t\t\\\n+  DECL_VARIABLE(VAR, uint, 16, 4);\t\t\t\\\n+  DECL_VARIABLE(VAR, uint, 32, 2);\t\t\t\\\n+  DECL_VARIABLE(VAR, uint, 64, 1)\n+\n+/* Declare only 128 bits signed variants.  */\n+#define DECL_VARIABLE_128BITS_SIGNED_VARIANTS(VAR)\t\\\n+  DECL_VARIABLE(VAR, int, 8, 16);\t\t\t\\\n+  DECL_VARIABLE(VAR, int, 16, 8);\t\t\t\\\n+  DECL_VARIABLE(VAR, int, 32, 4);\t\t\t\\\n+  DECL_VARIABLE(VAR, int, 64, 2)\n+\n+/* Declare only 128 bits unsigned variants.  */\n+#define DECL_VARIABLE_128BITS_UNSIGNED_VARIANTS(VAR)\t\\\n+  DECL_VARIABLE(VAR, uint, 8, 16);\t\t\t\\\n+  DECL_VARIABLE(VAR, uint, 16, 8);\t\t\t\\\n+  DECL_VARIABLE(VAR, uint, 32, 4);\t\t\t\\\n+  DECL_VARIABLE(VAR, uint, 64, 2)\n+\n+/* Declare all 64 bits variants.  */\n+#define DECL_VARIABLE_64BITS_VARIANTS(VAR)\t\\\n+  DECL_VARIABLE_64BITS_SIGNED_VARIANTS(VAR);\t\\\n+  DECL_VARIABLE_64BITS_UNSIGNED_VARIANTS(VAR);\t\\\n+  DECL_VARIABLE(VAR, poly, 8, 8);\t\t\\\n+  DECL_VARIABLE(VAR, poly, 16, 4);\t\t\\\n+  DECL_VARIABLE(VAR, float, 32, 2)\n+\n+/* Declare all 128 bits variants.  */\n+#define DECL_VARIABLE_128BITS_VARIANTS(VAR)\t\\\n+  DECL_VARIABLE_128BITS_SIGNED_VARIANTS(VAR);\t\\\n+  DECL_VARIABLE_128BITS_UNSIGNED_VARIANTS(VAR);\t\\\n+  DECL_VARIABLE(VAR, poly, 8, 16);\t\t\\\n+  DECL_VARIABLE(VAR, poly, 16, 8);\t\t\\\n+  DECL_VARIABLE(VAR, float, 32, 4)\n+\n+/* Declare all variants.  */\n+#define DECL_VARIABLE_ALL_VARIANTS(VAR)\t\t\\\n+  DECL_VARIABLE_64BITS_VARIANTS(VAR);\t\t\\\n+  DECL_VARIABLE_128BITS_VARIANTS(VAR)\n+\n+/* Declare all signed variants.  */\n+#define DECL_VARIABLE_SIGNED_VARIANTS(VAR)\t\\\n+  DECL_VARIABLE_64BITS_SIGNED_VARIANTS(VAR);\t\\\n+  DECL_VARIABLE_128BITS_SIGNED_VARIANTS(VAR)\n+\n+/* Declare all unsigned variants.  */\n+#define DECL_VARIABLE_UNSIGNED_VARIANTS(VAR)\t\\\n+  DECL_VARIABLE_64BITS_UNSIGNED_VARIANTS(VAR);\t\\\n+  DECL_VARIABLE_128BITS_UNSIGNED_VARIANTS(VAR)\n+\n+/* Helpers to initialize vectors.  */\n+#define VDUP(VAR, Q, T1, T2, W, N, V)\t\t\t\\\n+  VECT_VAR(VAR, T1, W, N) = vdup##Q##_n_##T2##W(V)\n+\n+#define VSET_LANE(VAR, Q, T1, T2, W, N, L, V)\t\t\t\t\\\n+  VECT_VAR(VAR, T1, W, N) = vset##Q##_lane_##T2##W(V,\t\t\t\\\n+\t\t\t\t\t\t   VECT_VAR(VAR, T1, W, N), \\\n+\t\t\t\t\t\t   L)\n+\n+/* We need to load initial values first, so rely on VLD1.  */\n+#define VLOAD(VAR, BUF, Q, T1, T2, W, N)\t\t\t\t\\\n+  VECT_VAR(VAR, T1, W, N) = vld1##Q##_##T2##W(VECT_VAR(BUF, T1, W, N))\n+\n+/* Helpers to call macros with 1 constant and 5 variable\n+   arguments.  */\n+#define TEST_MACRO_64BITS_SIGNED_VARIANTS_1_5(MACRO, VAR)\t\\\n+  MACRO(VAR, , int, s, 8, 8);\t\t\t\t\t\\\n+  MACRO(VAR, , int, s, 16, 4);\t\t\t\t\t\\\n+  MACRO(VAR, , int, s, 32, 2);\t\t\t\t\t\\\n+  MACRO(VAR, , int, s, 64, 1)\n+\n+#define TEST_MACRO_64BITS_UNSIGNED_VARIANTS_1_5(MACRO, VAR)\t\\\n+  MACRO(VAR, , uint, u, 8, 8);\t\t\t\t\t\\\n+  MACRO(VAR, , uint, u, 16, 4);\t\t\t\t\t\\\n+  MACRO(VAR, , uint, u, 32, 2);\t\t\t\t\t\\\n+  MACRO(VAR, , uint, u, 64, 1)\n+\n+#define TEST_MACRO_128BITS_SIGNED_VARIANTS_1_5(MACRO, VAR)\t\\\n+  MACRO(VAR, q, int, s, 8, 16);\t\t\t\t\t\\\n+  MACRO(VAR, q, int, s, 16, 8);\t\t\t\t\t\\\n+  MACRO(VAR, q, int, s, 32, 4);\t\t\t\t\t\\\n+  MACRO(VAR, q, int, s, 64, 2)\n+\n+#define TEST_MACRO_128BITS_UNSIGNED_VARIANTS_1_5(MACRO,VAR)\t\\\n+  MACRO(VAR, q, uint, u, 8, 16);\t\t\t\t\\\n+  MACRO(VAR, q, uint, u, 16, 8);\t\t\t\t\\\n+  MACRO(VAR, q, uint, u, 32, 4);\t\t\t\t\\\n+  MACRO(VAR, q, uint, u, 64, 2)\n+\n+#define TEST_MACRO_64BITS_VARIANTS_1_5(MACRO, VAR)\t\\\n+  TEST_MACRO_64BITS_SIGNED_VARIANTS_1_5(MACRO, VAR);\t\\\n+  TEST_MACRO_64BITS_UNSIGNED_VARIANTS_1_5(MACRO, VAR)\n+\n+#define TEST_MACRO_128BITS_VARIANTS_1_5(MACRO, VAR)\t\\\n+  TEST_MACRO_128BITS_SIGNED_VARIANTS_1_5(MACRO, VAR);\t\\\n+  TEST_MACRO_128BITS_UNSIGNED_VARIANTS_1_5(MACRO, VAR)\n+\n+#define TEST_MACRO_ALL_VARIANTS_1_5(MACRO, VAR)\t\\\n+  TEST_MACRO_64BITS_VARIANTS_1_5(MACRO, VAR);\t\\\n+  TEST_MACRO_128BITS_VARIANTS_1_5(MACRO, VAR)\n+\n+#define TEST_MACRO_SIGNED_VARIANTS_1_5(MACRO, VAR)\t\\\n+  TEST_MACRO_64BITS_SIGNED_VARIANTS_1_5(MACRO, VAR);\t\\\n+  TEST_MACRO_128BITS_SIGNED_VARIANTS_1_5(MACRO, VAR)\n+\n+/* Helpers to call macros with 2 constant and 5 variable\n+   arguments.  */\n+#define TEST_MACRO_64BITS_SIGNED_VARIANTS_2_5(MACRO, VAR1, VAR2)\t\\\n+  MACRO(VAR1, VAR2, , int, s, 8, 8);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2, , int, s, 16, 4);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2, , int, s, 32, 2);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2 , , int, s, 64, 1)\n+\n+#define TEST_MACRO_64BITS_UNSIGNED_VARIANTS_2_5(MACRO, VAR1, VAR2)\t\\\n+  MACRO(VAR1, VAR2, , uint, u, 8, 8);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2, , uint, u, 16, 4);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2, , uint, u, 32, 2);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2, , uint, u, 64, 1)\n+\n+#define TEST_MACRO_128BITS_SIGNED_VARIANTS_2_5(MACRO, VAR1, VAR2)\t\\\n+  MACRO(VAR1, VAR2, q, int, s, 8, 16);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2, q, int, s, 16, 8);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2, q, int, s, 32, 4);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2, q, int, s, 64, 2)\n+\n+#define TEST_MACRO_128BITS_UNSIGNED_VARIANTS_2_5(MACRO, VAR1, VAR2)\t\\\n+  MACRO(VAR1, VAR2, q, uint, u, 8, 16);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2, q, uint, u, 16, 8);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2, q, uint, u, 32, 4);\t\t\t\t\t\\\n+  MACRO(VAR1, VAR2, q, uint, u, 64, 2)\n+\n+#define TEST_MACRO_64BITS_VARIANTS_2_5(MACRO, VAR1, VAR2)\t\\\n+  TEST_MACRO_64BITS_SIGNED_VARIANTS_2_5(MACRO, VAR1, VAR2);\t\\\n+  TEST_MACRO_64BITS_UNSIGNED_VARIANTS_2_5(MACRO, VAR1, VAR2);\t\\\n+  MACRO(VAR1, VAR2, , poly, p, 8, 8);\t\t\t\t\\\n+  MACRO(VAR1, VAR2, , poly, p, 16, 4)\n+\n+#define TEST_MACRO_128BITS_VARIANTS_2_5(MACRO, VAR1, VAR2)\t\\\n+  TEST_MACRO_128BITS_SIGNED_VARIANTS_2_5(MACRO, VAR1, VAR2);\t\\\n+  TEST_MACRO_128BITS_UNSIGNED_VARIANTS_2_5(MACRO, VAR1, VAR2);\t\\\n+  MACRO(VAR1, VAR2, q, poly, p, 8, 16);\t\t\t\t\\\n+  MACRO(VAR1, VAR2, q, poly, p, 16, 8)\n+\n+#define TEST_MACRO_ALL_VARIANTS_2_5(MACRO, VAR1, VAR2)\t\\\n+  TEST_MACRO_64BITS_VARIANTS_2_5(MACRO, VAR1, VAR2);\t\\\n+  TEST_MACRO_128BITS_VARIANTS_2_5(MACRO, VAR1, VAR2)\n+\n+#define TEST_MACRO_SIGNED_VARIANTS_2_5(MACRO, VAR1, VAR2)\t\\\n+  TEST_MACRO_64BITS_SIGNED_VARIANTS_2_5(MACRO, VAR1, VAR2);\t\\\n+  TEST_MACRO_128BITS_SIGNED_VARIANTS_2_5(MACRO, VAR1, VAR2)\n+\n+#endif /* _ARM_NEON_REF_H_ */"}, {"sha": "13824d47e88cb5a0f0f11a44f1ddc0c24476b76a", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/compute-ref-data.h", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fcompute-ref-data.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fcompute-ref-data.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fcompute-ref-data.h?ref=2f46a9cd83980bf549058eca30001e2ceeb41b88", "patch": "@@ -0,0 +1,193 @@\n+/* This file contains input data static definitions, shared by most of\n+   the tests.  */\n+\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+\n+/* Initialization helpers; 4 slices are needed for vld2, vld3 and\n+   vld4.  */\n+#define MY_INIT_TABLE(T,W,N) xNAME(INIT_TABLE,N)(T##W##_t)\n+#define MY_INIT_TABLE2(T,W,N) xNAME(INIT_TABLE2,N)(T##W##_t)\n+#define MY_INIT_TABLE3(T,W,N) xNAME(INIT_TABLE3,N)(T##W##_t)\n+#define MY_INIT_TABLE4(T,W,N) xNAME(INIT_TABLE4,N)(T##W##_t)\n+\n+/* Initialized input buffers.  */\n+#define VECT_VAR_DECL_INIT(V, T, W, N)\t\t\t\\\n+  VECT_VAR_DECL(V,T,W,N) [] = { MY_INIT_TABLE(T,W,N) }\n+\n+/* Specialized initializer with 4 entries, as used by vldX_dup and\n+   vdup tests, which iterate 4 times on input buffers.  */\n+#define VECT_VAR_DECL_INIT4(V, T, W, N)\t\t\t\\\n+  VECT_VAR_DECL(V,T,W,N) [] = { MY_INIT_TABLE(T,W,4) };\n+\n+/* Initializers for arrays of vectors.  */\n+#define VECT_ARRAY_INIT2(V, T, W, N)\t\t\\\n+  T##W##_t VECT_ARRAY_VAR(V,T,W,N,2)[] =\t\\\n+  { MY_INIT_TABLE(T,W,N)\t\t\t\\\n+    MY_INIT_TABLE2(T,W,N) }\n+\n+#define VECT_ARRAY_INIT3(V, T, W, N)\t\t\t\\\n+  T##W##_t VECT_ARRAY_VAR(V,T,W,N,3)[] =\t\t\\\n+  { MY_INIT_TABLE(T,W,N)\t\t\t\t\\\n+    MY_INIT_TABLE2(T,W,N)\t\t\t\t\\\n+    MY_INIT_TABLE3(T,W,N) }\n+\n+#define VECT_ARRAY_INIT4(V, T, W, N)\t\t\t\\\n+  T##W##_t VECT_ARRAY_VAR(V,T,W,N,4)[] =\t\t\\\n+  { MY_INIT_TABLE(T,W,N)\t\t\t\t\\\n+    MY_INIT_TABLE2(T,W,N)\t\t\t\t\\\n+    MY_INIT_TABLE3(T,W,N)\t\t\t\t\\\n+    MY_INIT_TABLE4(T,W,N) }\n+\n+/* Sample initialization vectors.  */\n+#define INIT_TABLE_1(T)\t\t\t\t\\\n+  (T)-16,\n+#define INIT_TABLE2_1(T)\t\t\t\\\n+  (T)-15,\n+#define INIT_TABLE3_1(T)\t\t\t\\\n+  (T)-14,\n+#define INIT_TABLE4_1(T)\t\t\t\\\n+  (T)-13,\n+\n+#define INIT_TABLE_2(T)\t\t\t\t\\\n+  (T)-16, (T)-15,\n+#define INIT_TABLE2_2(T)\t\t\t\\\n+  (T)-14, (T)-13,\n+#define INIT_TABLE3_2(T)\t\t\t\\\n+  (T)-12, (T)-11,\n+#define INIT_TABLE4_2(T)\t\t\t\\\n+  (T)-10, (T)-9,\n+\n+/* Initializer for vld3_lane tests.  */\n+#define INIT_TABLE_3(T)\t\t\t\t\\\n+  (T)-16, (T)-15, (T)-14,\n+\n+#define INIT_TABLE_4(T)\t\t\t\t\\\n+  (T)-16, (T)-15, (T)-14, (T)-13,\n+#define INIT_TABLE2_4(T)\t\t\t\\\n+  (T)-12, (T)-11, (T)-10, (T)-9,\n+#define INIT_TABLE3_4(T)\t\t\t\\\n+  (T)-8, (T)-7, (T)-6, (T)-5,\n+#define INIT_TABLE4_4(T)\t\t\t\\\n+  (T)-4, (T)-3, (T)-2, (T)-1,\n+\n+#define INIT_TABLE_8(T)\t\t\t\t\t\t\t\\\n+  (T)-16, (T)-15, (T)-14, (T)-13, (T)-12, (T)-11, (T)-10, (T)-9,\n+#define INIT_TABLE2_8(T)\t\t\t\t\t\\\n+  (T)-8, (T)-7, (T)-6, (T)-5, (T)-4, (T)-3, (T)-2, (T)-1,\n+#define INIT_TABLE3_8(T)\t\t\t\t\\\n+  (T)0, (T)1, (T)2, (T)3, (T)4, (T)5, (T)6, (T)7,\n+#define INIT_TABLE4_8(T)\t\t\t\t\\\n+  (T)8, (T)9, (T)10, (T)11, (T)12, (T)13, (T)14, (T)15,\n+\n+#define INIT_TABLE_16(T)\t\t\t\t\t\t\\\n+  (T)-16, (T)-15, (T)-14, (T)-13, (T)-12, (T)-11, (T)-10, (T)-9,\t\\\n+  (T)-8, (T)-7, (T)-6, (T)-5, (T)-4, (T)-3, (T)-2, (T)-1,\n+#define INIT_TABLE2_16(T)\t\t\t\t\t\t\\\n+  (T)0, (T)1, (T)2, (T)3, (T)4, (T)5, (T)6, (T)7,\t\t\t\\\n+  (T)8, (T)9, (T)10, (T)11, (T)12, (T)13, (T)14, (T)15,\n+#define INIT_TABLE3_16(T)\t\t\t\t\t\t\\\n+  (T)16, (T)17, (T)18, (T)19, (T)20, (T)21, (T)22, (T)23,\t\t\\\n+   (T)24, (T)25, (T)26, (T)27, (T)28, (T)29, (T)30, (T)31,\n+#define INIT_TABLE4_16(T)\t\t\t\t\t\t\\\n+  (T)32, (T)33, (T)34, (T)35, (T)36, (T)37, (T)38, (T)39,\t\t\\\n+  (T)40, (T)41, (T)42, (T)43, (T)44, (T)45, (T)46, (T)47,\n+\n+/* This one is used for padding between input buffers.  */\n+#define PAD(V, T, W, N) char VECT_VAR(V,T,W,N)=42\n+\n+/* Input buffers, one of each size.  */\n+/* Insert some padding to try to exhibit out of bounds accesses.  */\n+VECT_VAR_DECL_INIT(buffer, int, 8, 8);\n+PAD(buffer_pad, int, 8, 8);\n+VECT_VAR_DECL_INIT(buffer, int, 16, 4);\n+PAD(buffer_pad, int, 16, 4);\n+VECT_VAR_DECL_INIT(buffer, int, 32, 2);\n+PAD(buffer_pad, int, 32, 2);\n+VECT_VAR_DECL_INIT(buffer, int, 64, 1);\n+PAD(buffer_pad, int, 64, 1);\n+VECT_VAR_DECL_INIT(buffer, uint, 8, 8);\n+PAD(buffer_pad, uint, 8, 8);\n+VECT_VAR_DECL_INIT(buffer, poly, 8, 8);\n+PAD(buffer_pad, poly, 8, 8);\n+VECT_VAR_DECL_INIT(buffer, poly, 16, 4);\n+PAD(buffer_pad, poly, 16, 4);\n+VECT_VAR_DECL_INIT(buffer, uint, 16, 4);\n+PAD(buffer_pad, uint, 16, 4);\n+VECT_VAR_DECL_INIT(buffer, uint, 32, 2);\n+PAD(buffer_pad, uint, 32, 2);\n+VECT_VAR_DECL_INIT(buffer, uint, 64, 1);\n+PAD(buffer_pad, uint, 64, 1);\n+VECT_VAR_DECL_INIT(buffer, float, 32, 2);\n+PAD(buffer_pad, float, 32, 2);\n+VECT_VAR_DECL_INIT(buffer, int, 8, 16);\n+PAD(buffer_pad, int, 8, 16);\n+VECT_VAR_DECL_INIT(buffer, int, 16, 8);\n+PAD(buffer_pad, int, 16, 8);\n+VECT_VAR_DECL_INIT(buffer, int, 32, 4);\n+PAD(buffer_pad, int, 32, 4);\n+VECT_VAR_DECL_INIT(buffer, int, 64, 2);\n+PAD(buffer_pad, int, 64, 2);\n+VECT_VAR_DECL_INIT(buffer, uint, 8, 16);\n+PAD(buffer_pad, uint, 8, 16);\n+VECT_VAR_DECL_INIT(buffer, uint, 16, 8);\n+PAD(buffer_pad, uint, 16, 8);\n+VECT_VAR_DECL_INIT(buffer, uint, 32, 4);\n+PAD(buffer_pad, uint, 32, 4);\n+VECT_VAR_DECL_INIT(buffer, uint, 64, 2);\n+PAD(buffer_pad, uint, 64, 2);\n+VECT_VAR_DECL_INIT(buffer, poly, 8, 16);\n+PAD(buffer_pad, poly, 8, 16);\n+VECT_VAR_DECL_INIT(buffer, poly, 16, 8);\n+PAD(buffer_pad, poly, 16, 8);\n+VECT_VAR_DECL_INIT(buffer, float, 32, 4);\n+PAD(buffer_pad, float, 32, 4);\n+\n+/* The tests for vld1_dup and vdup expect at least 4 entries in the\n+   input buffer, so force 1- and 2-elements initializers to have 4\n+   entries (using VECT_VAR_DECL_INIT4).  */\n+VECT_VAR_DECL_INIT(buffer_dup, int, 8, 8);\n+VECT_VAR_DECL(buffer_dup_pad, int, 8, 8);\n+VECT_VAR_DECL_INIT(buffer_dup, int, 16, 4);\n+VECT_VAR_DECL(buffer_dup_pad, int, 16, 4);\n+VECT_VAR_DECL_INIT4(buffer_dup, int, 32, 2);\n+VECT_VAR_DECL(buffer_dup_pad, int, 32, 2);\n+VECT_VAR_DECL_INIT4(buffer_dup, int, 64, 1);\n+VECT_VAR_DECL(buffer_dup_pad, int, 64, 1);\n+VECT_VAR_DECL_INIT(buffer_dup, uint, 8, 8);\n+VECT_VAR_DECL(buffer_dup_pad, uint, 8, 8);\n+VECT_VAR_DECL_INIT(buffer_dup, uint, 16, 4);\n+VECT_VAR_DECL(buffer_dup_pad, uint, 16, 4);\n+VECT_VAR_DECL_INIT4(buffer_dup, uint, 32, 2);\n+VECT_VAR_DECL(buffer_dup_pad, uint, 32, 2);\n+VECT_VAR_DECL_INIT4(buffer_dup, uint, 64, 1);\n+VECT_VAR_DECL(buffer_dup_pad, uint, 64, 1);\n+VECT_VAR_DECL_INIT(buffer_dup, poly, 8, 8);\n+VECT_VAR_DECL(buffer_dup_pad, poly, 8, 8);\n+VECT_VAR_DECL_INIT(buffer_dup, poly, 16, 4);\n+VECT_VAR_DECL(buffer_dup_pad, poly, 16, 4);\n+VECT_VAR_DECL_INIT4(buffer_dup, float, 32, 2);\n+VECT_VAR_DECL(buffer_dup_pad, float, 32, 2);\n+\n+VECT_VAR_DECL_INIT(buffer_dup, int, 8, 16);\n+VECT_VAR_DECL(buffer_dup_pad, int, 8, 16);\n+VECT_VAR_DECL_INIT(buffer_dup, int, 16, 8);\n+VECT_VAR_DECL(buffer_dup_pad, int, 16, 8);\n+VECT_VAR_DECL_INIT(buffer_dup, int, 32, 4);\n+VECT_VAR_DECL(buffer_dup_pad, int, 32, 4);\n+VECT_VAR_DECL_INIT4(buffer_dup, int, 64, 2);\n+VECT_VAR_DECL(buffer_dup_pad, int, 64, 2);\n+VECT_VAR_DECL_INIT(buffer_dup, uint, 8, 16);\n+VECT_VAR_DECL(buffer_dup_pad, uint, 8, 16);\n+VECT_VAR_DECL_INIT(buffer_dup, uint, 16, 8);\n+VECT_VAR_DECL(buffer_dup_pad, uint, 16, 8);\n+VECT_VAR_DECL_INIT(buffer_dup, uint, 32, 4);\n+VECT_VAR_DECL(buffer_dup_pad, uint, 32, 4);\n+VECT_VAR_DECL_INIT4(buffer_dup, uint, 64, 2);\n+VECT_VAR_DECL(buffer_dup_pad, uint, 64, 2);\n+VECT_VAR_DECL_INIT(buffer_dup, poly, 8, 16);\n+VECT_VAR_DECL(buffer_dup_pad, poly, 8, 16);\n+VECT_VAR_DECL_INIT(buffer_dup, poly, 16, 8);\n+VECT_VAR_DECL(buffer_dup_pad, poly, 16, 8);\n+VECT_VAR_DECL_INIT(buffer_dup, float, 32, 4);\n+VECT_VAR_DECL(buffer_dup_pad, float, 32, 4);"}, {"sha": "2465cd24416c4c4bc6efa0497648ced2aef41041", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vaba.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvaba.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvaba.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvaba.c?ref=2f46a9cd83980bf549058eca30001e2ceeb41b88", "patch": "@@ -0,0 +1,142 @@\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf6, 0xf7, 0xf8, 0xf9,\n+\t\t\t\t       0xfa, 0xfb, 0xfc, 0xfd };\n+VECT_VAR_DECL(expected,int,16,4) [] = { 0x16, 0x17, 0x18, 0x19 };\n+VECT_VAR_DECL(expected,int,32,2) [] = { 0x20, 0x21 };\n+VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };\n+VECT_VAR_DECL(expected,uint,8,8) [] = { 0x53, 0x54, 0x55, 0x56,\n+\t\t\t\t\t0x57, 0x58, 0x59, 0x5a };\n+VECT_VAR_DECL(expected,uint,16,4) [] = { 0x907, 0x908, 0x909, 0x90a };\n+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffe7, 0xffffffe8 };\n+VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };\n+VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };\n+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };\n+VECT_VAR_DECL(expected,int,8,16) [] = { 0x5e, 0x5f, 0x60, 0x61,\n+\t\t\t\t\t0x62, 0x63, 0x64, 0x65,\n+\t\t\t\t\t0x66, 0x67, 0x68, 0x69,\n+\t\t\t\t\t0x6a, 0x6b, 0x6c, 0x6d };\n+VECT_VAR_DECL(expected,int,16,8) [] = { 0xb9c, 0xb9d, 0xb9e, 0xb9f,\n+\t\t\t\t\t0xba0, 0xba1, 0xba2, 0xba3 };\n+VECT_VAR_DECL(expected,int,32,4) [] = { 0x26e0, 0x26e1, 0x26e2, 0x26e3 };\n+VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,\n+\t\t\t\t\t0x3333333333333333 };\n+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xf8, 0xf9, 0xfa, 0xfb,\n+\t\t\t\t\t 0xfc, 0xfd, 0xfe, 0xff,\n+\t\t\t\t\t 0x0, 0x1, 0x2, 0x3,\n+\t\t\t\t\t 0x4, 0x5, 0x6, 0x7 };\n+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfff9, 0xfffa, 0xfffb, 0xfffc,\n+\t\t\t\t\t 0xfffd, 0xfffe, 0xffff, 0x0 };\n+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xc, 0xd, 0xe, 0xf };\n+VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,\n+\t\t\t\t\t 0x3333333333333333 };\n+VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,\n+\t\t\t\t\t 0x3333, 0x3333, 0x3333, 0x3333 };\n+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,\n+\t\t\t\t\t   0x33333333, 0x33333333 };\n+\n+#define TEST_MSG \"VABA/VABAQ\"\n+void exec_vaba (void)\n+{\n+  /* Basic test: v4=vaba(v1,v2,v3), then store the result.  */\n+#define TEST_VABA(Q, T1, T2, W, N)\t\t\t\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\t\t\\\n+    vaba##Q##_##T2##W(VECT_VAR(vector1, T1, W, N),\t\t\t\\\n+\t\t      VECT_VAR(vector2, T1, W, N),\t\t\t\\\n+\t\t      VECT_VAR(vector3, T1, W, N));\t\t\t\\\n+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))\n+\n+#define DECL_VABA_VAR(VAR)\t\t\t\\\n+  DECL_VARIABLE(VAR, int, 8, 8);\t\t\\\n+  DECL_VARIABLE(VAR, int, 16, 4);\t\t\\\n+  DECL_VARIABLE(VAR, int, 32, 2);\t\t\\\n+  DECL_VARIABLE(VAR, uint, 8, 8);\t\t\\\n+  DECL_VARIABLE(VAR, uint, 16, 4);\t\t\\\n+  DECL_VARIABLE(VAR, uint, 32, 2);\t\t\\\n+  DECL_VARIABLE(VAR, int, 8, 16);\t\t\\\n+  DECL_VARIABLE(VAR, int, 16, 8);\t\t\\\n+  DECL_VARIABLE(VAR, int, 32, 4);\t\t\\\n+  DECL_VARIABLE(VAR, uint, 8, 16);\t\t\\\n+  DECL_VARIABLE(VAR, uint, 16, 8);\t\t\\\n+  DECL_VARIABLE(VAR, uint, 32, 4)\n+\n+  DECL_VABA_VAR(vector1);\n+  DECL_VABA_VAR(vector2);\n+  DECL_VABA_VAR(vector3);\n+  DECL_VABA_VAR(vector_res);\n+\n+  clean_results ();\n+\n+  /* Initialize input \"vector1\" from \"buffer\".  */\n+  VLOAD(vector1, buffer, , int, s, 8, 8);\n+  VLOAD(vector1, buffer, , int, s, 16, 4);\n+  VLOAD(vector1, buffer, , int, s, 32, 2);\n+  VLOAD(vector1, buffer, , uint, u, 8, 8);\n+  VLOAD(vector1, buffer, , uint, u, 16, 4);\n+  VLOAD(vector1, buffer, , uint, u, 32, 2);\n+  VLOAD(vector1, buffer, q, int, s, 8, 16);\n+  VLOAD(vector1, buffer, q, int, s, 16, 8);\n+  VLOAD(vector1, buffer, q, int, s, 32, 4);\n+  VLOAD(vector1, buffer, q, uint, u, 8, 16);\n+  VLOAD(vector1, buffer, q, uint, u, 16, 8);\n+  VLOAD(vector1, buffer, q, uint, u, 32, 4);\n+\n+  /* Choose init value arbitrarily.  */\n+  VDUP(vector2, , int, s, 8, 8, 1);\n+  VDUP(vector2, , int, s, 16, 4, -13);\n+  VDUP(vector2, , int, s, 32, 2, 8);\n+  VDUP(vector2, , uint, u, 8, 8, 1);\n+  VDUP(vector2, , uint, u, 16, 4, 13);\n+  VDUP(vector2, , uint, u, 32, 2, 8);\n+  VDUP(vector2, q, int, s, 8, 16, 10);\n+  VDUP(vector2, q, int, s, 16, 8, -12);\n+  VDUP(vector2, q, int, s, 32, 4, 32);\n+  VDUP(vector2, q, uint, u, 8, 16, 10);\n+  VDUP(vector2, q, uint, u, 16, 8, 12);\n+  VDUP(vector2, q, uint, u, 32, 4, 32);\n+\n+  /* Choose init value arbitrarily.  */\n+  VDUP(vector3, , int, s, 8, 8, -5);\n+  VDUP(vector3, , int, s, 16, 4, 25);\n+  VDUP(vector3, , int, s, 32, 2, -40);\n+  VDUP(vector3, , uint, u, 8, 8, 100);\n+  VDUP(vector3, , uint, u, 16, 4, 2340);\n+  VDUP(vector3, , uint, u, 32, 2, 0xffffffff);\n+  VDUP(vector3, q, int, s, 8, 16, -100);\n+  VDUP(vector3, q, int, s, 16, 8, -3000);\n+  VDUP(vector3, q, int, s, 32, 4, 10000);\n+  VDUP(vector3, q, uint, u, 8, 16, 2);\n+  VDUP(vector3, q, uint, u, 16, 8, 3);\n+  VDUP(vector3, q, uint, u, 32, 4, 4);\n+\n+  /* Execute the tests.  */\n+  TEST_VABA(, int, s, 8, 8);\n+  TEST_VABA(, int, s, 16, 4);\n+  TEST_VABA(, int, s, 32, 2);\n+  TEST_VABA(, uint, u, 8, 8);\n+  TEST_VABA(, uint, u, 16, 4);\n+  TEST_VABA(, uint, u, 32, 2);\n+  TEST_VABA(q, int, s, 8, 16);\n+  TEST_VABA(q, int, s, 16, 8);\n+  TEST_VABA(q, int, s, 32, 4);\n+  TEST_VABA(q, uint, u, 8, 16);\n+  TEST_VABA(q, uint, u, 16, 8);\n+  TEST_VABA(q, uint, u, 32, 4);\n+\n+  CHECK_RESULTS (TEST_MSG, \"\");\n+}\n+\n+int main (void)\n+{\n+  exec_vaba ();\n+  return 0;\n+}"}, {"sha": "ced9d736d6d22cbd93352c1972fd9bab81fa747e", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld1.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvld1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvld1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvld1.c?ref=2f46a9cd83980bf549058eca30001e2ceeb41b88", "patch": "@@ -0,0 +1,75 @@\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,\n+\t\t\t\t       0xf4, 0xf5, 0xf6, 0xf7 };\n+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };\n+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffff0, 0xfffffff1 };\n+VECT_VAR_DECL(expected,int,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,\n+\t\t\t\t\t0xf4, 0xf5, 0xf6, 0xf7 };\n+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };\n+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff0, 0xfffffff1 };\n+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,\n+\t\t\t\t\t0xf4, 0xf5, 0xf6, 0xf7 };\n+VECT_VAR_DECL(expected,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };\n+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };\n+VECT_VAR_DECL(expected,int,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,\n+\t\t\t\t\t0xf4, 0xf5, 0xf6, 0xf7,\n+\t\t\t\t\t0xf8, 0xf9, 0xfa, 0xfb,\n+\t\t\t\t\t0xfc, 0xfd, 0xfe, 0xff };\n+VECT_VAR_DECL(expected,int,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,\n+\t\t\t\t\t0xfff4, 0xfff5, 0xfff6, 0xfff7 };\n+VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffff0, 0xfffffff1,\n+\t\t\t\t\t0xfffffff2, 0xfffffff3 };\n+VECT_VAR_DECL(expected,int,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t0xfffffffffffffff1 };\n+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,\n+\t\t\t\t\t 0xf4, 0xf5, 0xf6, 0xf7,\n+\t\t\t\t\t 0xf8, 0xf9, 0xfa, 0xfb,\n+\t\t\t\t\t 0xfc, 0xfd, 0xfe, 0xff };\n+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfff0, 0xfff1, 0xfff2,\n+\t\t\t\t\t 0xfff3, 0xfff4, 0xfff5,\n+\t\t\t\t\t 0xfff6, 0xfff7 };\n+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,\n+\t\t\t\t\t 0xfffffff2, 0xfffffff3 };\n+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t 0xfffffffffffffff1 };\n+VECT_VAR_DECL(expected,poly,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,\n+\t\t\t\t\t 0xf4, 0xf5, 0xf6, 0xf7,\n+\t\t\t\t\t 0xf8, 0xf9, 0xfa, 0xfb,\n+\t\t\t\t\t 0xfc, 0xfd, 0xfe, 0xff };\n+VECT_VAR_DECL(expected,poly,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,\n+\t\t\t\t\t 0xfff4, 0xfff5, 0xfff6, 0xfff7 };\n+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,\n+\t\t\t\t\t   0xc1600000, 0xc1500000 };\n+\n+#define TEST_MSG \"VLD1/VLD1Q\"\n+void exec_vld1 (void)\n+{\n+  /* Basic test vec=vld1(buffer); then store vec: vst1(result, vector).  */\n+  /* This test actually tests vdl1 and vst1 at the same time.  */\n+#define TEST_VLD1(VAR, BUF, Q, T1, T2, W, N)\t\t\t\t\\\n+  VECT_VAR(VAR, T1, W, N) = vld1##Q##_##T2##W(VECT_VAR(BUF, T1, W, N)); \\\n+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(VAR, T1, W, N))\n+\n+  DECL_VARIABLE_ALL_VARIANTS(vector);\n+\n+  clean_results ();\n+\n+  TEST_MACRO_ALL_VARIANTS_2_5(TEST_VLD1, vector, buffer);\n+\n+  TEST_VLD1(vector, buffer, , float, f, 32, 2);\n+  TEST_VLD1(vector, buffer, q, float, f, 32, 4);\n+\n+  CHECK_RESULTS (TEST_MSG, \"\");\n+}\n+\n+int main (void)\n+{\n+  exec_vld1 ();\n+  return 0;\n+}"}, {"sha": "e64d6e37c6e7ffa81f9a8fcdf74410dcaac4751b", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vshl.c", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvshl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvshl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvshl.c?ref=2f46a9cd83980bf549058eca30001e2ceeb41b88", "patch": "@@ -0,0 +1,230 @@\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected,int,8,8) [] = { 0xe0, 0xe2, 0xe4, 0xe6,\n+\t\t\t\t       0xe8, 0xea, 0xec, 0xee };\n+VECT_VAR_DECL(expected,int,16,4) [] = { 0xff80, 0xff88, 0xff90, 0xff98 };\n+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffff000, 0xfffff100 };\n+VECT_VAR_DECL(expected,int,64,1) [] = { 0xffffffffffffff80 };\n+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xe0, 0xe2, 0xe4, 0xe6,\n+\t\t\t\t\t0xe8, 0xea, 0xec, 0xee };\n+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xff80, 0xff88, 0xff90, 0xff98 };\n+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffff000, 0xfffff100 };\n+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xffffffffffffff80 };\n+VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333,\n+\t\t\t\t\t 0x3333, 0x3333 };\n+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };\n+VECT_VAR_DECL(expected,int,8,16) [] = { 0x0, 0x20, 0x40, 0x60,\n+\t\t\t\t\t0x80, 0xa0, 0xc0, 0xe0,\n+\t\t\t\t\t0x0, 0x20, 0x40, 0x60,\n+\t\t\t\t\t0x80, 0xa0, 0xc0, 0xe0 };\n+VECT_VAR_DECL(expected,int,16,8) [] = { 0x0, 0x1000, 0x2000, 0x3000,\n+\t\t\t\t\t0x4000, 0x5000, 0x6000, 0x7000 };\n+VECT_VAR_DECL(expected,int,32,4) [] = { 0x0, 0x40000000,\n+\t\t\t\t\t0x80000000, 0xc0000000 };\n+VECT_VAR_DECL(expected,int,64,2) [] = { 0x0, 0x8000000000000000 };\n+VECT_VAR_DECL(expected,uint,8,16) [] = { 0x0, 0x20, 0x40, 0x60,\n+\t\t\t\t\t 0x80, 0xa0, 0xc0, 0xe0,\n+\t\t\t\t\t 0x0, 0x20, 0x40, 0x60,\n+\t\t\t\t\t 0x80, 0xa0, 0xc0, 0xe0 };\n+VECT_VAR_DECL(expected,uint,16,8) [] = { 0x0, 0x1000, 0x2000, 0x3000,\n+\t\t\t\t\t 0x4000, 0x5000, 0x6000, 0x7000 };\n+VECT_VAR_DECL(expected,uint,32,4) [] = { 0x0, 0x40000000,\n+\t\t\t\t\t 0x80000000, 0xc0000000 };\n+VECT_VAR_DECL(expected,uint,64,2) [] = { 0x0, 0x8000000000000000 };\n+VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t 0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,\n+\t\t\t\t\t 0x3333, 0x3333, 0x3333, 0x3333 };\n+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,\n+\t\t\t\t\t   0x33333333, 0x33333333 };\n+\n+/* Expected results with large shift amount.  */\n+VECT_VAR_DECL(expected_large_shift,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t   0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,int,32,2) [] = { 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,int,64,1) [] = { 0x0 };\n+VECT_VAR_DECL(expected_large_shift,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t    0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,uint,32,2) [] = { 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,uint,64,1) [] = { 0x0 };\n+VECT_VAR_DECL(expected_large_shift,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t\t    0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected_large_shift,poly,16,4) [] = { 0x3333, 0x3333,\n+\t\t\t\t\t\t     0x3333, 0x3333 };\n+VECT_VAR_DECL(expected_large_shift,hfloat,32,2) [] = { 0x33333333, 0x33333333 };\n+VECT_VAR_DECL(expected_large_shift,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t    0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t    0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t    0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t    0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,int,64,2) [] = { 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t     0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t     0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t     0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,\n+\t\t\t\t\t\t     0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,uint,64,2) [] = { 0x0, 0x0 };\n+VECT_VAR_DECL(expected_large_shift,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t\t     0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t\t     0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t\t     0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected_large_shift,poly,16,8) [] = { 0x3333, 0x3333,\n+\t\t\t\t\t\t     0x3333, 0x3333,\n+\t\t\t\t\t\t     0x3333, 0x3333,\n+\t\t\t\t\t\t     0x3333, 0x3333 };\n+VECT_VAR_DECL(expected_large_shift,hfloat,32,4) [] = { 0x33333333, 0x33333333,\n+\t\t\t\t\t\t       0x33333333, 0x33333333 };\n+\n+\n+/* Expected results with negative shift amount.  */\n+VECT_VAR_DECL(expected_negative_shift,int,8,8) [] = { 0xf8, 0xf8, 0xf9, 0xf9,\n+\t\t\t\t\t\t      0xfa, 0xfa, 0xfb, 0xfb };\n+VECT_VAR_DECL(expected_negative_shift,int,16,4) [] = { 0xfff8, 0xfff8,\n+\t\t\t\t\t\t       0xfff9, 0xfff9  };\n+VECT_VAR_DECL(expected_negative_shift,int,32,2) [] = { 0xfffffffc, 0xfffffffc };\n+VECT_VAR_DECL(expected_negative_shift,int,64,1) [] = { 0xffffffffffffffff };\n+VECT_VAR_DECL(expected_negative_shift,uint,8,8) [] = { 0x78, 0x78, 0x79, 0x79,\n+\t\t\t\t\t\t       0x7a, 0x7a, 0x7b, 0x7b };\n+VECT_VAR_DECL(expected_negative_shift,uint,16,4) [] = { 0x7ff8, 0x7ff8,\n+\t\t\t\t\t\t\t0x7ff9, 0x7ff9 };\n+VECT_VAR_DECL(expected_negative_shift,uint,32,2) [] = { 0x3ffffffc,\n+\t\t\t\t\t\t\t0x3ffffffc };\n+VECT_VAR_DECL(expected_negative_shift,uint,64,1) [] = { 0xfffffffffffffff };\n+VECT_VAR_DECL(expected_negative_shift,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t\t       0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected_negative_shift,poly,16,4) [] = { 0x3333, 0x3333,\n+\t\t\t\t\t\t\t0x3333, 0x3333 };\n+VECT_VAR_DECL(expected_negative_shift,hfloat,32,2) [] = { 0x33333333,\n+\t\t\t\t\t\t\t  0x33333333 };\n+VECT_VAR_DECL(expected_negative_shift,int,8,16) [] = { 0xfc, 0xfc, 0xfc, 0xfc,\n+\t\t\t\t\t\t       0xfd, 0xfd, 0xfd, 0xfd,\n+\t\t\t\t\t\t       0xfe, 0xfe, 0xfe, 0xfe,\n+\t\t\t\t\t\t       0xff, 0xff, 0xff, 0xff };\n+VECT_VAR_DECL(expected_negative_shift,int,16,8) [] = { 0xffff, 0xffff,\n+\t\t\t\t\t\t       0xffff, 0xffff,\n+\t\t\t\t\t\t       0xffff, 0xffff,\n+\t\t\t\t\t\t       0xffff, 0xffff };\n+VECT_VAR_DECL(expected_negative_shift,int,32,4) [] = {  0xfffffffe, 0xfffffffe,\n+\t\t\t\t\t\t\t0xfffffffe, 0xfffffffe };\n+VECT_VAR_DECL(expected_negative_shift,int,64,2) [] = { 0xffffffffffffffff,\n+\t\t\t\t\t\t       0xffffffffffffffff };\n+VECT_VAR_DECL(expected_negative_shift,uint,8,16) [] = { 0x3c, 0x3c, 0x3c, 0x3c,\n+\t\t\t\t\t\t\t0x3d, 0x3d, 0x3d, 0x3d,\n+\t\t\t\t\t\t\t0x3e, 0x3e, 0x3e, 0x3e,\n+\t\t\t\t\t\t\t0x3f, 0x3f, 0x3f, 0x3f };\n+VECT_VAR_DECL(expected_negative_shift,uint,16,8) [] = { 0x7ff, 0x7ff,\n+\t\t\t\t\t\t\t0x7ff, 0x7ff,\n+\t\t\t\t\t\t\t0x7ff, 0x7ff,\n+\t\t\t\t\t\t\t0x7ff, 0x7ff };\n+VECT_VAR_DECL(expected_negative_shift,uint,32,4) [] = { 0x1ffffffe, 0x1ffffffe,\n+\t\t\t\t\t\t\t0x1ffffffe, 0x1ffffffe };\n+VECT_VAR_DECL(expected_negative_shift,uint,64,2) [] = { 0x7ffffffffffffff,\n+\t\t\t\t\t\t\t0x7ffffffffffffff };\n+VECT_VAR_DECL(expected_negative_shift,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t\t\t0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t\t\t0x33, 0x33, 0x33, 0x33,\n+\t\t\t\t\t\t\t0x33, 0x33, 0x33, 0x33 };\n+VECT_VAR_DECL(expected_negative_shift,poly,16,8) [] = { 0x3333, 0x3333,\n+\t\t\t\t\t\t\t0x3333, 0x3333,\n+\t\t\t\t\t\t\t0x3333, 0x3333,\n+\t\t\t\t\t\t\t0x3333, 0x3333 };\n+VECT_VAR_DECL(expected_negative_shift,hfloat,32,4) [] = { 0x33333333,\n+\t\t\t\t\t\t\t  0x33333333,\n+\t\t\t\t\t\t\t  0x33333333,\n+\t\t\t\t\t\t\t  0x33333333 };\n+\n+\n+#ifndef INSN_NAME\n+#define INSN_NAME vshl\n+#define TEST_MSG \"VSHL/VSHLQ\"\n+#endif\n+\n+#define FNNAME1(NAME) exec_ ## NAME\n+#define FNNAME(NAME) FNNAME1(NAME)\n+\n+void FNNAME (INSN_NAME) (void)\n+{\n+  /* Basic test: v3=vshl(v1,v2), then store the result.  */\n+#define TEST_VSHL(T3, Q, T1, T2, W, N)\t\t\t\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\t\t\\\n+    vshl##Q##_##T2##W(VECT_VAR(vector, T1, W, N),\t\t\t\\\n+\t\t      VECT_VAR(vector_shift, T3, W, N));\t\t\\\n+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))\n+\n+  DECL_VARIABLE_ALL_VARIANTS(vector);\n+  DECL_VARIABLE_ALL_VARIANTS(vector_res);\n+\n+  DECL_VARIABLE_SIGNED_VARIANTS(vector_shift);\n+\n+  clean_results ();\n+\n+  /* Initialize input \"vector\" from \"buffer\".  */\n+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);\n+\n+  /* Choose init value arbitrarily, will be used as shift amount.  */\n+  VDUP(vector_shift, , int, s, 8, 8, 1);\n+  VDUP(vector_shift, , int, s, 16, 4, 3);\n+  VDUP(vector_shift, , int, s, 32, 2, 8);\n+  VDUP(vector_shift, , int, s, 64, 1, 3);\n+  VDUP(vector_shift, q, int, s, 8, 16, 5);\n+  VDUP(vector_shift, q, int, s, 16, 8, 12);\n+  VDUP(vector_shift, q, int, s, 32, 4, 30);\n+  VDUP(vector_shift, q, int, s, 64, 2, 63);\n+\n+  /* Execute the tests.  */\n+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VSHL, int);\n+\n+  CHECK_RESULTS (TEST_MSG, \"\");\n+\n+\n+  /* Test large shift amount (larger or equal to the type width.  */\n+  VDUP(vector_shift, , int, s, 8, 8, 8);\n+  VDUP(vector_shift, , int, s, 16, 4, 16);\n+  VDUP(vector_shift, , int, s, 32, 2, 32);\n+  VDUP(vector_shift, , int, s, 64, 1, 64);\n+  VDUP(vector_shift, q, int, s, 8, 16, 8);\n+  VDUP(vector_shift, q, int, s, 16, 8, 17);\n+  VDUP(vector_shift, q, int, s, 32, 4, 33);\n+  VDUP(vector_shift, q, int, s, 64, 2, 65);\n+\n+  /* Execute the tests.  */\n+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VSHL, int);\n+\n+  CHECK_RESULTS_NAMED (TEST_MSG, expected_large_shift, \"(large shift amount)\");\n+\n+\n+  /* Test negative shift amount. */\n+  VDUP(vector_shift, , int, s, 8, 8, -1);\n+  VDUP(vector_shift, , int, s, 16, 4, -1);\n+  VDUP(vector_shift, , int, s, 32, 2, -2);\n+  VDUP(vector_shift, , int, s, 64, 1, -4);\n+  VDUP(vector_shift, q, int, s, 8, 16, -2);\n+  VDUP(vector_shift, q, int, s, 16, 8, -5);\n+  VDUP(vector_shift, q, int, s, 32, 4, -3);\n+  VDUP(vector_shift, q, int, s, 64, 2, -5);\n+\n+  /* Execute the tests.  */\n+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VSHL, int);\n+\n+  CHECK_RESULTS_NAMED (TEST_MSG, expected_negative_shift, \"(negative shift amount)\");\n+}\n+\n+int main (void)\n+{\n+  FNNAME (INSN_NAME) ();\n+\n+  return 0;\n+}"}, {"sha": "f246349985b3e7e090533e21f373888f1f62318a", "filename": "gcc/testsuite/gcc.target/arm/README.advsimd-intrinsics", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Farm%2FREADME.advsimd-intrinsics", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f46a9cd83980bf549058eca30001e2ceeb41b88/gcc%2Ftestsuite%2Fgcc.target%2Farm%2FREADME.advsimd-intrinsics", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2FREADME.advsimd-intrinsics?ref=2f46a9cd83980bf549058eca30001e2ceeb41b88", "patch": "@@ -0,0 +1 @@\n+Advanced SIMD intrinsics tests are located in gcc.target/aarch64."}]}