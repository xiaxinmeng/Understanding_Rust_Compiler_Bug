{"sha": "b573f931988b43a322ee454241b2af3a74f2fa84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU3M2Y5MzE5ODhiNDNhMzIyZWU0NTQyNDFiMmFmM2E3NGYyZmE4NA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-05-08T07:47:19Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-05-08T07:47:19Z"}, "message": "re PR fortran/54613 ([F08] Add FINDLOC plus support MAXLOC/MINLOC with KIND=/BACK=)\n\n2018-05-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/54613\n\t* check.c (gfc_check_minmaxloc): Remove error for BACK not being\n\timplemented.  Use gfc_logical_4_kind for BACK.\n\t* simplify.c (min_max_choose): Add optional argument back_val.\n\tHandle it.\n\t(simplify_minmaxloc_to_scalar): Add argument back_val. Pass\n\tback_val to min_max_choose.\n\t(simplify_minmaxloc_to_nodim): Likewise.\n\t(simplify_minmaxloc_to_array): Likewise.\n\t(gfc_simplify_minmaxloc): Add argument back, handle it.\n\tPass back_val to specific simplification functions.\n\t(gfc_simplify_minloc): Remove ATTRIBUTE_UNUSED from argument back,\n\tpass it on to gfc_simplify_minmaxloc.\n\t(gfc_simplify_maxloc): Likewise.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Adjust\n\tcomment. If BACK is true, use greater or equal (or lesser or\n\tequal) insteal of greater (or lesser). Mark the condition of\n\thaving found a value which exceeds the limit as unlikely.\n\n2018-05-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/54613\n\t* m4/iforeach-s.m4: Remove assertion that back is zero.\n\t* m4/iforeach.m4: Likewise.  Remove leading 'do'\n\tbefore implementation start.\n\t* m4/ifunction-s.m4: Remove assertion that back is zero.\n\t* m4/ifunction.m4: Likewise.  Remove for loop if HAVE_BACK_ARG\n\tis defined.\n\t* m4/maxloc0.m4: Reorganize loops. Split loops between >= and =,\n\tdepending if back is true.  Mark the condition of having\n\tfound a value which exceeds the limit as unlikely.\n\t* m4/minloc0.m4: Likewise.\n\t* m4/maxloc1.m4: Likewise.\n\t* m4/minloc1.m4: Likewise.\n\t* m4/maxloc1s.m4: Handle back argument.\n\t* m4/minloc1s.m4: Likewise.\n\t* m4/maxloc2s.m4: Remove assertion that back is zero.\n\tRemove special handling of loop start. Handle back argument.\n\t* m4/minloc2s.m4: Likewise.\n\t* generated/iall_i1.c: Regenerated.\n\t* generated/iall_i16.c: Regenerated.\n\t* generated/iall_i2.c: Regenerated.\n\t* generated/iall_i4.c: Regenerated.\n\t* generated/iall_i8.c: Regenerated.\n\t* generated/iany_i1.c: Regenerated.\n\t* generated/iany_i16.c: Regenerated.\n\t* generated/iany_i2.c: Regenerated.\n\t* generated/iany_i4.c: Regenerated.\n\t* generated/iany_i8.c: Regenerated.\n\t* generated/iparity_i1.c: Regenerated.\n\t* generated/iparity_i16.c: Regenerated.\n\t* generated/iparity_i2.c: Regenerated.\n\t* generated/iparity_i4.c: Regenerated.\n\t* generated/iparity_i8.c: Regenerated.\n\t* generated/maxloc0_16_i1.c: Regenerated.\n\t* generated/maxloc0_16_i16.c: Regenerated.\n\t* generated/maxloc0_16_i2.c: Regenerated.\n\t* generated/maxloc0_16_i4.c: Regenerated.\n\t* generated/maxloc0_16_i8.c: Regenerated.\n\t* generated/maxloc0_16_r10.c: Regenerated.\n\t* generated/maxloc0_16_r16.c: Regenerated.\n\t* generated/maxloc0_16_r4.c: Regenerated.\n\t* generated/maxloc0_16_r8.c: Regenerated.\n\t* generated/maxloc0_16_s1.c: Regenerated.\n\t* generated/maxloc0_16_s4.c: Regenerated.\n\t* generated/maxloc0_4_i1.c: Regenerated.\n\t* generated/maxloc0_4_i16.c: Regenerated.\n\t* generated/maxloc0_4_i2.c: Regenerated.\n\t* generated/maxloc0_4_i4.c: Regenerated.\n\t* generated/maxloc0_4_i8.c: Regenerated.\n\t* generated/maxloc0_4_r10.c: Regenerated.\n\t* generated/maxloc0_4_r16.c: Regenerated.\n\t* generated/maxloc0_4_r4.c: Regenerated.\n\t* generated/maxloc0_4_r8.c: Regenerated.\n\t* generated/maxloc0_4_s1.c: Regenerated.\n\t* generated/maxloc0_4_s4.c: Regenerated.\n\t* generated/maxloc0_8_i1.c: Regenerated.\n\t* generated/maxloc0_8_i16.c: Regenerated.\n\t* generated/maxloc0_8_i2.c: Regenerated.\n\t* generated/maxloc0_8_i4.c: Regenerated.\n\t* generated/maxloc0_8_i8.c: Regenerated.\n\t* generated/maxloc0_8_r10.c: Regenerated.\n\t* generated/maxloc0_8_r16.c: Regenerated.\n\t* generated/maxloc0_8_r4.c: Regenerated.\n\t* generated/maxloc0_8_r8.c: Regenerated.\n\t* generated/maxloc0_8_s1.c: Regenerated.\n\t* generated/maxloc0_8_s4.c: Regenerated.\n\t* generated/maxloc1_16_i1.c: Regenerated.\n\t* generated/maxloc1_16_i16.c: Regenerated.\n\t* generated/maxloc1_16_i2.c: Regenerated.\n\t* generated/maxloc1_16_i4.c: Regenerated.\n\t* generated/maxloc1_16_i8.c: Regenerated.\n\t* generated/maxloc1_16_r10.c: Regenerated.\n\t* generated/maxloc1_16_r16.c: Regenerated.\n\t* generated/maxloc1_16_r4.c: Regenerated.\n\t* generated/maxloc1_16_r8.c: Regenerated.\n\t* generated/maxloc1_16_s1.c: Regenerated.\n\t* generated/maxloc1_16_s4.c: Regenerated.\n\t* generated/maxloc1_4_i1.c: Regenerated.\n\t* generated/maxloc1_4_i16.c: Regenerated.\n\t* generated/maxloc1_4_i2.c: Regenerated.\n\t* generated/maxloc1_4_i4.c: Regenerated.\n\t* generated/maxloc1_4_i8.c: Regenerated.\n\t* generated/maxloc1_4_r10.c: Regenerated.\n\t* generated/maxloc1_4_r16.c: Regenerated.\n\t* generated/maxloc1_4_r4.c: Regenerated.\n\t* generated/maxloc1_4_r8.c: Regenerated.\n\t* generated/maxloc1_4_s1.c: Regenerated.\n\t* generated/maxloc1_4_s4.c: Regenerated.\n\t* generated/maxloc1_8_i1.c: Regenerated.\n\t* generated/maxloc1_8_i16.c: Regenerated.\n\t* generated/maxloc1_8_i2.c: Regenerated.\n\t* generated/maxloc1_8_i4.c: Regenerated.\n\t* generated/maxloc1_8_i8.c: Regenerated.\n\t* generated/maxloc1_8_r10.c: Regenerated.\n\t* generated/maxloc1_8_r16.c: Regenerated.\n\t* generated/maxloc1_8_r4.c: Regenerated.\n\t* generated/maxloc1_8_r8.c: Regenerated.\n\t* generated/maxloc1_8_s1.c: Regenerated.\n\t* generated/maxloc1_8_s4.c: Regenerated.\n\t* generated/maxloc2_16_s1.c: Regenerated.\n\t* generated/maxloc2_16_s4.c: Regenerated.\n\t* generated/maxloc2_4_s1.c: Regenerated.\n\t* generated/maxloc2_4_s4.c: Regenerated.\n\t* generated/maxloc2_8_s1.c: Regenerated.\n\t* generated/maxloc2_8_s4.c: Regenerated.\n\t* generated/maxval_i1.c: Regenerated.\n\t* generated/maxval_i16.c: Regenerated.\n\t* generated/maxval_i2.c: Regenerated.\n\t* generated/maxval_i4.c: Regenerated.\n\t* generated/maxval_i8.c: Regenerated.\n\t* generated/maxval_r10.c: Regenerated.\n\t* generated/maxval_r16.c: Regenerated.\n\t* generated/maxval_r4.c: Regenerated.\n\t* generated/maxval_r8.c: Regenerated.\n\t* generated/minloc0_16_i1.c: Regenerated.\n\t* generated/minloc0_16_i16.c: Regenerated.\n\t* generated/minloc0_16_i2.c: Regenerated.\n\t* generated/minloc0_16_i4.c: Regenerated.\n\t* generated/minloc0_16_i8.c: Regenerated.\n\t* generated/minloc0_16_r10.c: Regenerated.\n\t* generated/minloc0_16_r16.c: Regenerated.\n\t* generated/minloc0_16_r4.c: Regenerated.\n\t* generated/minloc0_16_r8.c: Regenerated.\n\t* generated/minloc0_16_s1.c: Regenerated.\n\t* generated/minloc0_16_s4.c: Regenerated.\n\t* generated/minloc0_4_i1.c: Regenerated.\n\t* generated/minloc0_4_i16.c: Regenerated.\n\t* generated/minloc0_4_i2.c: Regenerated.\n\t* generated/minloc0_4_i4.c: Regenerated.\n\t* generated/minloc0_4_i8.c: Regenerated.\n\t* generated/minloc0_4_r10.c: Regenerated.\n\t* generated/minloc0_4_r16.c: Regenerated.\n\t* generated/minloc0_4_r4.c: Regenerated.\n\t* generated/minloc0_4_r8.c: Regenerated.\n\t* generated/minloc0_4_s1.c: Regenerated.\n\t* generated/minloc0_4_s4.c: Regenerated.\n\t* generated/minloc0_8_i1.c: Regenerated.\n\t* generated/minloc0_8_i16.c: Regenerated.\n\t* generated/minloc0_8_i2.c: Regenerated.\n\t* generated/minloc0_8_i4.c: Regenerated.\n\t* generated/minloc0_8_i8.c: Regenerated.\n\t* generated/minloc0_8_r10.c: Regenerated.\n\t* generated/minloc0_8_r16.c: Regenerated.\n\t* generated/minloc0_8_r4.c: Regenerated.\n\t* generated/minloc0_8_r8.c: Regenerated.\n\t* generated/minloc0_8_s1.c: Regenerated.\n\t* generated/minloc0_8_s4.c: Regenerated.\n\t* generated/minloc1_16_i1.c: Regenerated.\n\t* generated/minloc1_16_i16.c: Regenerated.\n\t* generated/minloc1_16_i2.c: Regenerated.\n\t* generated/minloc1_16_i4.c: Regenerated.\n\t* generated/minloc1_16_i8.c: Regenerated.\n\t* generated/minloc1_16_r10.c: Regenerated.\n\t* generated/minloc1_16_r16.c: Regenerated.\n\t* generated/minloc1_16_r4.c: Regenerated.\n\t* generated/minloc1_16_r8.c: Regenerated.\n\t* generated/minloc1_16_s1.c: Regenerated.\n\t* generated/minloc1_16_s4.c: Regenerated.\n\t* generated/minloc1_4_i1.c: Regenerated.\n\t* generated/minloc1_4_i16.c: Regenerated.\n\t* generated/minloc1_4_i2.c: Regenerated.\n\t* generated/minloc1_4_i4.c: Regenerated.\n\t* generated/minloc1_4_i8.c: Regenerated.\n\t* generated/minloc1_4_r10.c: Regenerated.\n\t* generated/minloc1_4_r16.c: Regenerated.\n\t* generated/minloc1_4_r4.c: Regenerated.\n\t* generated/minloc1_4_r8.c: Regenerated.\n\t* generated/minloc1_4_s1.c: Regenerated.\n\t* generated/minloc1_4_s4.c: Regenerated.\n\t* generated/minloc1_8_i1.c: Regenerated.\n\t* generated/minloc1_8_i16.c: Regenerated.\n\t* generated/minloc1_8_i2.c: Regenerated.\n\t* generated/minloc1_8_i4.c: Regenerated.\n\t* generated/minloc1_8_i8.c: Regenerated.\n\t* generated/minloc1_8_r10.c: Regenerated.\n\t* generated/minloc1_8_r16.c: Regenerated.\n\t* generated/minloc1_8_r4.c: Regenerated.\n\t* generated/minloc1_8_r8.c: Regenerated.\n\t* generated/minloc1_8_s1.c: Regenerated.\n\t* generated/minloc1_8_s4.c: Regenerated.\n\t* generated/minloc2_16_s1.c: Regenerated.\n\t* generated/minloc2_16_s4.c: Regenerated.\n\t* generated/minloc2_4_s1.c: Regenerated.\n\t* generated/minloc2_4_s4.c: Regenerated.\n\t* generated/minloc2_8_s1.c: Regenerated.\n\t* generated/minloc2_8_s4.c: Regenerated.\n\t* generated/minval_i1.c: Regenerated.\n\t* generated/minval_i16.c: Regenerated.\n\t* generated/minval_i2.c: Regenerated.\n\t* generated/minval_i4.c: Regenerated.\n\t* generated/minval_i8.c: Regenerated.\n\t* generated/minval_r10.c: Regenerated.\n\t* generated/minval_r16.c: Regenerated.\n\t* generated/minval_r4.c: Regenerated.\n\t* generated/minval_r8.c: Regenerated.\n\t* generated/norm2_r10.c: Regenerated.\n\t* generated/norm2_r16.c: Regenerated.\n\t* generated/norm2_r4.c: Regenerated.\n\t* generated/norm2_r8.c: Regenerated.\n\t* generated/parity_l1.c: Regenerated.\n\t* generated/parity_l16.c: Regenerated.\n\t* generated/parity_l2.c: Regenerated.\n\t* generated/parity_l4.c: Regenerated.\n\t* generated/parity_l8.c: Regenerated.\n\t* generated/product_c10.c: Regenerated.\n\t* generated/product_c16.c: Regenerated.\n\t* generated/product_c4.c: Regenerated.\n\t* generated/product_c8.c: Regenerated.\n\t* generated/product_i1.c: Regenerated.\n\t* generated/product_i16.c: Regenerated.\n\t* generated/product_i2.c: Regenerated.\n\t* generated/product_i4.c: Regenerated.\n\t* generated/product_i8.c: Regenerated.\n\t* generated/product_r10.c: Regenerated.\n\t* generated/product_r16.c: Regenerated.\n\t* generated/product_r4.c: Regenerated.\n\t* generated/product_r8.c: Regenerated.\n\t* generated/sum_c10.c: Regenerated.\n\t* generated/sum_c16.c: Regenerated.\n\t* generated/sum_c4.c: Regenerated.\n\t* generated/sum_c8.c: Regenerated.\n\t* generated/sum_i1.c: Regenerated.\n\t* generated/sum_i16.c: Regenerated.\n\t* generated/sum_i2.c: Regenerated.\n\t* generated/sum_i4.c: Regenerated.\n\t* generated/sum_i8.c: Regenerated.\n\t* generated/sum_r10.c: Regenerated.\n\t* generated/sum_r16.c: Regenerated.\n\t* generated/sum_r4.c: Regenerated.\n\t* generated/sum_r8.c: Regenerated.\n\n2018-05-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/54613\n\t* gfortran.dg/minmaxloc_12.f90: New test case.\n\t* gfortran.dg/minmaxloc_13.f90: New test case.\n\nFrom-SVN: r260023", "tree": {"sha": "13876af9f83ad04e9dc0c13c19d75b93550ab84a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13876af9f83ad04e9dc0c13c19d75b93550ab84a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b573f931988b43a322ee454241b2af3a74f2fa84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b573f931988b43a322ee454241b2af3a74f2fa84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b573f931988b43a322ee454241b2af3a74f2fa84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b573f931988b43a322ee454241b2af3a74f2fa84/comments", "author": null, "committer": null, "parents": [{"sha": "6404980cf36b5d335de634c5bd76099330754682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6404980cf36b5d335de634c5bd76099330754682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6404980cf36b5d335de634c5bd76099330754682"}], "stats": {"total": 8122, "additions": 4966, "deletions": 3156}, "files": [{"sha": "91a84feb656561aebcd56a7854e4d84ae5d64a21", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -1,3 +1,24 @@\n+2018-05-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/54613\n+\t* check.c (gfc_check_minmaxloc): Remove error for BACK not being\n+\timplemented.  Use gfc_logical_4_kind for BACK.\n+\t* simplify.c (min_max_choose): Add optional argument back_val.\n+\tHandle it.\n+\t(simplify_minmaxloc_to_scalar): Add argument back_val. Pass\n+\tback_val to min_max_choose.\n+\t(simplify_minmaxloc_to_nodim): Likewise.\n+\t(simplify_minmaxloc_to_array): Likewise.\n+\t(gfc_simplify_minmaxloc): Add argument back, handle it.\n+\tPass back_val to specific simplification functions.\n+\t(gfc_simplify_minloc): Remove ATTRIBUTE_UNUSED from argument back,\n+\tpass it on to gfc_simplify_minmaxloc.\n+\t(gfc_simplify_maxloc): Likewise.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Adjust\n+\tcomment. If BACK is true, use greater or equal (or lesser or\n+\tequal) insteal of greater (or lesser). Mark the condition of\n+\thaving found a value which exceeds the limit as unlikely.\n+\n 2018-05-07  Jeff Law  <law@redhat.comg>\n \n \t* scanner.c (preprocessor_line): Call linemap_add after a line"}, {"sha": "61b72c12bbe99eb179ae474d0636f2ff277d59eb", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -3306,18 +3306,10 @@ gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n     {\n       if (!type_check (b, 4, BT_LOGICAL) || !scalar_check (b,4))\n \treturn false;\n-\n-      /* TODO: Remove this once BACK is actually implemented.  */\n-      if (b->expr_type != EXPR_CONSTANT || b->value.logical != 0)\n-\t{\n-\t  gfc_error (\"BACK argument to %qs intrinsic not yet \"\n-\t\t     \"implemented\", gfc_current_intrinsic);\n-\t  return false;\n-\t}\n     }\n   else\n     {\n-      b = gfc_get_logical_expr (gfc_default_logical_kind, NULL, 0);\n+      b = gfc_get_logical_expr (gfc_logical_4_kind, NULL, 0);\n       ap->next->next->next->next->expr = b;\n     }\n "}, {"sha": "fdd85edf62c66dc77ef105748b3bd2816406fb61", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -32,7 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Prototypes.  */\n \n-static int min_max_choose (gfc_expr *, gfc_expr *, int);\n+static int min_max_choose (gfc_expr *, gfc_expr *, int, bool back_val = false);\n \n gfc_expr gfc_bad_expr;\n \n@@ -4877,7 +4877,7 @@ gfc_simplify_merge_bits (gfc_expr *i, gfc_expr *j, gfc_expr *mask_expr)\n /* Selects between current value and extremum for simplify_min_max\n    and simplify_minval_maxval.  */\n static int\n-min_max_choose (gfc_expr *arg, gfc_expr *extremum, int sign)\n+min_max_choose (gfc_expr *arg, gfc_expr *extremum, int sign, bool back_val)\n {\n   int ret;\n \n@@ -4940,6 +4940,9 @@ min_max_choose (gfc_expr *arg, gfc_expr *extremum, int sign)\n       default:\n \tgfc_internal_error (\"simplify_min_max(): Bad type in arglist\");\n     }\n+  if (back_val && ret == 0)\n+    ret = 1;\n+\n   return ret;\n }\n \n@@ -5059,7 +5062,7 @@ gfc_simplify_maxval (gfc_expr *array, gfc_expr* dim, gfc_expr *mask)\n \n static gfc_expr *\n simplify_minmaxloc_to_scalar (gfc_expr *result, gfc_expr *array, gfc_expr *mask,\n-\t\t\t      gfc_expr *extremum, int sign)\n+\t\t\t      gfc_expr *extremum, int sign, bool back_val)\n {\n   gfc_expr *a, *m;\n   gfc_constructor *array_ctor, *mask_ctor;\n@@ -5094,7 +5097,7 @@ simplify_minmaxloc_to_scalar (gfc_expr *result, gfc_expr *array, gfc_expr *mask,\n \t  if (!m->value.logical)\n \t    continue;\n \t}\n-      if (min_max_choose (a, extremum, sign) > 0)\n+      if (min_max_choose (a, extremum, sign, back_val) > 0)\n \tmpz_set (result->value.integer, count);\n     }\n   mpz_clear (count);\n@@ -5106,7 +5109,8 @@ simplify_minmaxloc_to_scalar (gfc_expr *result, gfc_expr *array, gfc_expr *mask,\n \n static gfc_expr *\n simplify_minmaxloc_nodim (gfc_expr *result, gfc_expr *extremum,\n-\t\t\t  gfc_expr *array, gfc_expr *mask, int sign)\n+\t\t\t  gfc_expr *array, gfc_expr *mask, int sign,\n+\t\t\t  bool back_val)\n {\n   ssize_t res[GFC_MAX_DIMENSIONS];\n   int i, n;\n@@ -5158,7 +5162,7 @@ simplify_minmaxloc_nodim (gfc_expr *result, gfc_expr *extremum,\n \t  else\n \t    ma = true;\n \n-\t  if (ma && min_max_choose (a, extremum, sign) > 0)\n+\t  if (ma && min_max_choose (a, extremum, sign, back_val) > 0)\n \t    {\n \t      for (i = 0; i<array->rank; i++)\n \t\tres[i] = count[i];\n@@ -5225,7 +5229,7 @@ new_array (bt type, int kind, int n, locus *where)\n static gfc_expr *\n simplify_minmaxloc_to_array (gfc_expr *result, gfc_expr *array,\n \t\t\t     gfc_expr *dim, gfc_expr *mask,\n-\t\t\t     gfc_expr *extremum, int sign)\n+\t\t\t     gfc_expr *extremum, int sign, bool back_val)\n {\n   mpz_t size;\n   int done, i, n, arraysize, resultsize, dim_index, dim_extent, dim_stride;\n@@ -5313,7 +5317,7 @@ simplify_minmaxloc_to_array (gfc_expr *result, gfc_expr *array,\n       ex = gfc_copy_expr (extremum);\n       for (src = base, n = 0; n < dim_extent; src += dim_stride, ++n)\n \t{\n-\t  if (*src && min_max_choose (*src, ex, sign) > 0)\n+\t  if (*src && min_max_choose (*src, ex, sign, back_val) > 0)\n \t    mpz_set_si ((*dest)->value.integer, n + 1);\n \t}\n \n@@ -5367,12 +5371,13 @@ simplify_minmaxloc_to_array (gfc_expr *result, gfc_expr *array,\n \n gfc_expr *\n gfc_simplify_minmaxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n-\t\t\tgfc_expr *kind, int sign)\n+\t\t\tgfc_expr *kind, gfc_expr *back, int sign)\n {\n   gfc_expr *result;\n   gfc_expr *extremum;\n   int ikind;\n   int init_val;\n+  bool back_val = false;\n \n   if (!is_constant_array_expr (array)\n       || !gfc_is_constant_expr (dim))\n@@ -5391,6 +5396,14 @@ gfc_simplify_minmaxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n   else\n     ikind = gfc_default_integer_kind;\n \n+  if (back)\n+    {\n+      if (back->expr_type != EXPR_CONSTANT)\n+\treturn NULL;\n+\n+      back_val = back->value.logical;\n+    }\n+  \n   if (sign < 0)\n     init_val = INT_MAX;\n   else if (sign > 0)\n@@ -5408,29 +5421,32 @@ gfc_simplify_minmaxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n       init_result_expr (result, 0, array);\n \n       if (array->rank == 1)\n-\treturn simplify_minmaxloc_to_scalar (result, array, mask, extremum, sign);\n+\treturn simplify_minmaxloc_to_scalar (result, array, mask, extremum,\n+\t\t\t\t\t     sign, back_val);\n       else\n-\treturn simplify_minmaxloc_to_array (result, array, dim, mask, extremum, sign);\n+\treturn simplify_minmaxloc_to_array (result, array, dim, mask, extremum,\n+\t\t\t\t\t    sign, back_val);\n     }\n   else\n     {\n       result = new_array (BT_INTEGER, ikind, array->rank, &array->where);\n-      return simplify_minmaxloc_nodim (result, extremum, array, mask, sign);\n+      return simplify_minmaxloc_nodim (result, extremum, array, mask,\n+\t\t\t\t       sign, back_val);\n     }\n }\n \n gfc_expr *\n gfc_simplify_minloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask, gfc_expr *kind,\n-\t\t     gfc_expr *back ATTRIBUTE_UNUSED)\n+\t\t     gfc_expr *back)\n {\n-  return gfc_simplify_minmaxloc (array, dim, mask, kind, -1);\n+  return gfc_simplify_minmaxloc (array, dim, mask, kind, back, -1);\n }\n \n gfc_expr *\n gfc_simplify_maxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask, gfc_expr *kind,\n-\t\t     gfc_expr *back ATTRIBUTE_UNUSED)\n+\t\t     gfc_expr *back)\n {\n-  return gfc_simplify_minmaxloc (array, dim, mask, kind, 1);\n+  return gfc_simplify_minmaxloc (array, dim, mask, kind, back, 1);\n }\n \n gfc_expr *"}, {"sha": "651a97f1d3f73d9fa34ca83aba8de544836eaf74", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 74, "deletions": 5, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -4684,7 +4684,20 @@ gfc_conv_intrinsic_dot_product (gfc_se * se, gfc_expr * expr)\n \tS++;\n       }\n    For 3) and 5), if mask is scalar, this all goes into a conditional,\n-   setting pos = 0; in the else branch.  */\n+   setting pos = 0; in the else branch.\n+\n+   Since we now also support the BACK argument, instead of using\n+   if (a[S] < limit), we now use\n+\n+   if (back)\n+     cond = a[S] <= limit;\n+   else\n+     cond = a[S] < limit;\n+   if (cond) {\n+     ....\n+\n+     The optimizer is smart enough to move the condition out of the loop.\n+     The are now marked as unlikely to for further speedup.  */\n \n static void\n gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n@@ -4702,6 +4715,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   tree offset;\n   tree nonempty;\n   tree lab1, lab2;\n+  tree b_if, b_else;\n   gfc_loopinfo loop;\n   gfc_actual_arglist *actual;\n   gfc_ss *arrayss;\n@@ -4710,6 +4724,8 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   gfc_se maskse;\n   gfc_expr *arrayexpr;\n   gfc_expr *maskexpr;\n+  gfc_expr *backexpr;\n+  gfc_se backse;\n   tree pos;\n   int n;\n \n@@ -4766,6 +4782,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   actual = actual->next->next;\n   gcc_assert (actual);\n   maskexpr = actual->expr;\n+  backexpr = actual->next->next->expr;\n   nonempty = NULL;\n   if (maskexpr && maskexpr->rank != 0)\n     {\n@@ -4904,6 +4921,10 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   gfc_conv_expr_val (&arrayse, arrayexpr);\n   gfc_add_block_to_block (&block, &arrayse.pre);\n \n+  gfc_init_se (&backse, NULL);\n+  gfc_conv_expr_val (&backse, backexpr);\n+  gfc_add_block_to_block (&block, &backse.pre);\n+\n   /* We do the following if this is a more extreme value.  */\n   gfc_start_block (&ifblock);\n \n@@ -4943,9 +4964,33 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t\t\t\top == GT_EXPR ? GE_EXPR : LE_EXPR,\n \t\t\t\tlogical_type_node, arrayse.expr, limit);\n       else\n-\tcond = fold_build2_loc (input_location, op, logical_type_node,\n-\t\t\t\tarrayse.expr, limit);\n+\t{\n+\t  tree ifbody2, elsebody2;\n+\t  \n+\t  /* We switch to > or >= depending on the value of the BACK argument. */\n+\t  cond = gfc_create_var (logical_type_node, \"cond\");\n+\n+\t  gfc_start_block (&ifblock);\n+\t  b_if = fold_build2_loc (input_location, op == GT_EXPR ? GE_EXPR : LE_EXPR,\n+\t\t\t\t  logical_type_node, arrayse.expr, limit);\n+\n+\t  gfc_add_modify (&ifblock, cond, b_if);\n+\t  ifbody2 = gfc_finish_block (&ifblock);\n+\n+\t  gfc_start_block (&elseblock);\n+\t  b_else = fold_build2_loc (input_location, op, logical_type_node,\n+\t\t\t\t    arrayse.expr, limit);\n+\n+\t  gfc_add_modify (&elseblock, cond, b_else);\n+\t  elsebody2 = gfc_finish_block (&elseblock);\n+\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, logical_type_node,\n+\t\t\t\t backse.expr, ifbody2, elsebody2);\n+\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n \n+      cond = gfc_unlikely (cond, PRED_BUILTIN_EXPECT);\n       ifbody = build3_v (COND_EXPR, cond, ifbody,\n \t\t\t build_empty_stmt (input_location));\n     }\n@@ -5014,11 +5059,35 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n       ifbody = gfc_finish_block (&ifblock);\n \n-      cond = fold_build2_loc (input_location, op, logical_type_node,\n-\t\t\t      arrayse.expr, limit);\n+      /* We switch to > or >= depending on the value of the BACK argument. */\n+      {\n+\ttree ifbody2, elsebody2;\n+\n+\tcond = gfc_create_var (logical_type_node, \"cond\");\n+\n+\tgfc_start_block (&ifblock);\n+\tb_if = fold_build2_loc (input_location, op == GT_EXPR ? GE_EXPR : LE_EXPR,\n+\t\t\t\tlogical_type_node, arrayse.expr, limit);\n+\n+\tgfc_add_modify (&ifblock, cond, b_if);\n+\tifbody2 = gfc_finish_block (&ifblock);\n \n+\tgfc_start_block (&elseblock);\n+\tb_else = fold_build2_loc (input_location, op, logical_type_node,\n+\t\t\t\t  arrayse.expr, limit);\n+\n+\tgfc_add_modify (&elseblock, cond, b_else);\n+\telsebody2 = gfc_finish_block (&elseblock);\n+\n+\ttmp = fold_build3_loc (input_location, COND_EXPR, logical_type_node,\n+\t\t\t       backse.expr, ifbody2, elsebody2);\n+      }\n+\n+      gfc_add_expr_to_block (&block, tmp);\n+      cond = gfc_unlikely (cond, PRED_BUILTIN_EXPECT);\n       tmp = build3_v (COND_EXPR, cond, ifbody,\n \t\t      build_empty_stmt (input_location));\n+\n       gfc_add_expr_to_block (&block, tmp);\n \n       if (maskss)"}, {"sha": "6a94c0695323e85eb05bd101ea76083a9f20b11c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -1,3 +1,9 @@\n+2018-05-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/54613\n+\t* gfortran.dg/minmaxloc_12.f90: New test case.\n+\t* gfortran.dg/minmaxloc_13.f90: New test case.\n+\n 2018-05-07  Nathan Sidwell  <nathan@acm.org>\n \n \t* g++.dg/cpp0x/range-for10.C: Delete."}, {"sha": "54bebba826f4c2fe9c6a81974ae698ff5742bf63", "filename": "gcc/testsuite/gfortran.dg/minmaxloc_12.f90", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_12.f90?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -0,0 +1,67 @@\n+! { dg-do  run }\n+! Test compile-time simplification of minloc and maxloc with BACK argument\n+program main\n+  integer, parameter :: i1(*) = [ 1,2,3,1,2,3];\n+  integer, parameter :: d1 = minloc(i1,dim=1,back=.true.)\n+  integer, parameter :: d2 = minloc(i1,dim=1,back=.false.)\n+  integer, parameter :: d3 = maxloc(i1,dim=1,back=.true.)\n+  integer, parameter :: d4 = maxloc(i1,dim=1,back=.false.)\n+  integer, parameter :: i2(4,4) = reshape([1,2,1,2,2,3,3,2,3,4,4,3,4,5,5,4], &\n+       [4,4]);\n+  integer, parameter :: d5(2) = minloc(i2,back=.true.)\n+  integer, parameter :: d6(2) = maxloc(i2,back=.true.)\n+  integer, parameter :: d7(4) = minloc(i2,dim=1,back=.true.)\n+  integer, parameter :: d25(4) = minloc(i2,dim=2,mask=i2<2,back=.true.)\n+  integer, parameter :: d26(4) = maxloc(i2,dim=1,mask=i2<3,back=.true.)\n+\n+  integer, parameter :: i3(4,4) = transpose(i2)\n+  integer, parameter :: d8(4) = minloc(i3,dim=2,back=.true.)\n+  integer, parameter :: i4(4,4) = reshape([1,2,1,2,2,1,2,1,1,2,1,2,2,1,2,1],&\n+       ([4,4]))\n+  integer, parameter :: d9(4) = minloc(i4,dim=1,mask=i4>1,back=.true.)\n+\n+  integer, parameter :: d10(4) = maxloc(i4,dim=1,mask=i4>1,back=.true.)\n+  character(len=2), parameter :: c0(9) = [\"aa\", \"bb\", \"aa\", &\n+       \"cc\", \"bb\", \"cc\", \"aa\", \"bb\", \"aa\"]\n+  character(len=2), parameter :: c1 (3,3) = reshape(c0, [3,3]);\n+  integer, parameter :: d11(2) = minloc(c1,back=.true.)\n+  integer, parameter :: d12(2) = maxloc(c1,back=.true.)\n+  integer, parameter :: d13(2) = minloc(c1,mask=c1>\"aa\",back=.true.)\n+  integer, parameter :: d14(2) = maxloc(c1,mask=c1<\"cc\",back=.true.)\n+  integer, parameter :: d15(3) = minloc(c1,dim=1,back=.true.)\n+  integer, parameter :: d16(3) = maxloc(c1,dim=1,back=.true.)\n+  integer, parameter :: d17(3) = minloc(c1,dim=2,back=.true.)\n+  integer, parameter :: d18(3) = maxloc(c1,dim=2,back=.true.)\n+  integer, parameter :: d19    = minloc(c0,dim=1,back=.true.)\n+  integer, parameter :: d20    = maxloc(c0,dim=1,back=.true.)\n+  integer, parameter :: d21    = minloc(c0,dim=1,mask=c0>\"aa\",back=.true.)\n+  integer, parameter :: d22    = maxloc(c0,dim=1,mask=c0<\"cc\",back=.true.)\n+  integer, parameter :: d23(3) = minloc(c1,dim=2,mask=c1>\"aa\",back=.true.)\n+  integer, parameter :: d24(3) = maxloc(c1,dim=2,mask=c1<\"cc\",back=.true.)\n+\n+  if (d1 /= 4) STOP 2078\n+  if (d2 /= 1) STOP 2079\n+  if (d3 /= 6) STOP 2080\n+  if (d4 /= 3) STOP 2081\n+  if (any (d5 /= [3,1])) STOP 2082\n+  if (any (d6 /= [3,4])) STOP 2083\n+  if (any (d7 /= [3,4,4,4])) STOP 2084\n+  if (any (d8 /= d7)) STOP 2085\n+  if (any (d9 /= [4,3,4,3])) STOP 2086\n+  if (any (d10 /= d9)) STOP 2087\n+  if (any(d11 /= [3,3])) STOP 2088\n+  if (any(d12 /= [3,2])) STOP 2089\n+  if (any(d13 /= [2,3])) STOP 2090\n+  if (any(d14 /= [2,3])) STOP 2091\n+  if (any(d15 /= [3,2,3])) STOP 2092\n+  if (any(d16 /= [2,3,2])) STOP 2093\n+  if (any(d17 /= [3,3,3])) STOP 2094\n+  if (any(d18 /= [2,3,2])) STOP 2095\n+  if (d19 /= 9) STOP 2096\n+  if (d20 /= 6) STOP 2097\n+  if (d21 /= 8 .or. d22 /= 8) STOP 2098\n+  if (any(d23 /= [2,3,2])) STOP 2099\n+  if (any(d24 /= 3)) STOP 2100\n+  if (any(d25 /= [1,0,1,0])) STOP 2101\n+  if (any(d26 /= [4,4,0,0])) STOP 2102\n+end program main"}, {"sha": "3ebfdc921ec322e6b4fbc4a8355c901c13cf8c04", "filename": "gcc/testsuite/gfortran.dg/minmaxloc_13.f90", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_13.f90?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -0,0 +1,103 @@\n+! { dg-do  run }\n+! Test run-time of MINLOC and MAXLOC with BACK\n+program main\n+  implicit none\n+  integer:: i1(6) \n+  integer:: d1 \n+  integer:: d2 \n+  integer:: d3 \n+  integer:: d4 \n+  integer:: i2(4,4) \n+  integer:: d5(2) \n+  integer:: d6(2) \n+  integer:: d7(4) \n+  integer:: d25(4) \n+  integer:: d26(4) \n+\n+  integer:: i3(4,4) \n+  integer:: d8(4) \n+  integer:: i4(4,4) \n+  integer:: d9(4) \n+\n+  integer:: d10(4) \n+  character(len=2) :: c0(9)\n+  character(len=2) :: c1(3,3)\n+  integer:: d11(2) \n+  integer:: d12(2) \n+  integer:: d13(2) \n+  integer:: d14(2) \n+  integer:: d15(3) \n+  integer:: d16(3) \n+  integer:: d17(3) \n+  integer:: d18(3) \n+  integer:: d19    \n+  integer:: d20    \n+  integer:: d21    \n+  integer:: d22    \n+  integer:: d23(3) \n+  integer:: d24(3)\n+\n+  i1 = [ 1,2,3,1,2,3];\n+  d1 = minloc(i1,dim=1,back=.true.)\n+  d2 = minloc(i1,dim=1,back=.false.)\n+  d3 = maxloc(i1,dim=1,back=.true.)\n+  d4 = maxloc(i1,dim=1,back=.false.)\n+  i2 = reshape([1,2,1,2,2,3,3,2,3,4,4,3,4,5,5,4], &\n+       [4,4]);\n+  d5 = minloc(i2,back=.true.)\n+  d6 = maxloc(i2,back=.true.)\n+  d7= minloc(i2,dim=1,back=.true.)\n+  d25 = minloc(i2,dim=2,mask=i2<2,back=.true.)\n+  d26 = maxloc(i2,dim=1,mask=i2<3,back=.true.)\n+\n+  i3 = transpose(i2)\n+  d8 = minloc(i3,dim=2,back=.true.)\n+  i4 = reshape([1,2,1,2,2,1,2,1,1,2,1,2,2,1,2,1],&\n+       ([4,4]))\n+  d9 = minloc(i4,dim=1,mask=i4>1,back=.true.)\n+\n+  d10 = maxloc(i4,dim=1,mask=i4>1,back=.true.)\n+  c0 = [\"aa\", \"bb\", \"aa\", &\n+       \"cc\", \"bb\", \"cc\", \"aa\", \"bb\", \"aa\"]\n+  c1 = reshape(c0, [3,3]);\n+  d11 = minloc(c1,back=.true.)\n+  d12 = maxloc(c1,back=.true.)\n+  d13 = minloc(c1,mask=c1>\"aa\",back=.true.)\n+  d14 = maxloc(c1,mask=c1<\"cc\",back=.true.)\n+  d15 = minloc(c1,dim=1,back=.true.)\n+  d16 = maxloc(c1,dim=1,back=.true.)\n+  d17 = minloc(c1,dim=2,back=.true.)\n+  d18 = maxloc(c1,dim=2,back=.true.)\n+  d19    = minloc(c0,dim=1,back=.true.)\n+  d20    = maxloc(c0,dim=1,back=.true.)\n+  d21    = minloc(c0,dim=1,mask=c0>\"aa\",back=.true.)\n+  d22    = maxloc(c0,dim=1,mask=c0<\"cc\",back=.true.)\n+  d23 = minloc(c1,dim=2,mask=c1>\"aa\",back=.true.)\n+  d24 = maxloc(c1,dim=2,mask=c1<\"cc\",back=.true.)\n+\n+  if (d1 /= 4) STOP 2626\n+  if (d2 /= 1) STOP 2627\n+  if (d3 /= 6) STOP 2628\n+  if (d4 /= 3) STOP 2629\n+  if (any (d5 /= [3,1])) STOP 2630\n+  if (any (d6 /= [3,4])) STOP 2631\n+  if (any (d7 /= [3,4,4,4])) STOP 2632\n+  if (any (d8 /= d7)) STOP 2633\n+  if (any (d9 /= [4,3,4,3])) STOP 2634\n+  if (any (d10 /= d9)) STOP 2635\n+  if (any(d11 /= [3,3])) STOP 2636\n+  if (any(d12 /= [3,2])) STOP 2637\n+  if (any(d13 /= [2,3])) STOP 2638\n+  if (any(d14 /= [2,3])) STOP 2639\n+  if (any(d15 /= [3,2,3])) STOP 2640\n+  if (any(d16 /= [2,3,2])) STOP 2641\n+  if (any(d17 /= [3,3,3])) STOP 2642\n+  if (any(d18 /= [2,3,2])) STOP 2643\n+  if (d19 /= 9) STOP 2644\n+  if (d20 /= 6) STOP 2645\n+  if (d21 /= 8 .or. d22 /= 8) STOP 2646\n+  if (any(d23 /= [2,3,2])) STOP 2647\n+  if (any(d24 /= 3)) STOP 2648\n+  if (any(d25 /= [1,0,1,0])) STOP 2649\n+  if (any(d26 /= [4,4,0,0])) STOP 2650\n+end program"}, {"sha": "7a232acafaba9085b4ad193dec296ec1be27e38a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -1,3 +1,236 @@\n+2018-05-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/54613\n+\t* m4/iforeach-s.m4: Remove assertion that back is zero.\n+\t* m4/iforeach.m4: Likewise.  Remove leading 'do'\n+\tbefore implementation start.\n+\t* m4/ifunction-s.m4: Remove assertion that back is zero.\n+\t* m4/ifunction.m4: Likewise.  Remove for loop if HAVE_BACK_ARG\n+\tis defined.\n+\t* m4/maxloc0.m4: Reorganize loops. Split loops between >= and =,\n+\tdepending if back is true.  Mark the condition of having\n+\tfound a value which exceeds the limit as unlikely.\n+\t* m4/minloc0.m4: Likewise.\n+\t* m4/maxloc1.m4: Likewise.\n+\t* m4/minloc1.m4: Likewise.\n+\t* m4/maxloc1s.m4: Handle back argument.\n+\t* m4/minloc1s.m4: Likewise.\n+\t* m4/maxloc2s.m4: Remove assertion that back is zero.\n+\tRemove special handling of loop start. Handle back argument.\n+\t* m4/minloc2s.m4: Likewise.\n+\t* generated/iall_i1.c: Regenerated.\n+\t* generated/iall_i16.c: Regenerated.\n+\t* generated/iall_i2.c: Regenerated.\n+\t* generated/iall_i4.c: Regenerated.\n+\t* generated/iall_i8.c: Regenerated.\n+\t* generated/iany_i1.c: Regenerated.\n+\t* generated/iany_i16.c: Regenerated.\n+\t* generated/iany_i2.c: Regenerated.\n+\t* generated/iany_i4.c: Regenerated.\n+\t* generated/iany_i8.c: Regenerated.\n+\t* generated/iparity_i1.c: Regenerated.\n+\t* generated/iparity_i16.c: Regenerated.\n+\t* generated/iparity_i2.c: Regenerated.\n+\t* generated/iparity_i4.c: Regenerated.\n+\t* generated/iparity_i8.c: Regenerated.\n+\t* generated/maxloc0_16_i1.c: Regenerated.\n+\t* generated/maxloc0_16_i16.c: Regenerated.\n+\t* generated/maxloc0_16_i2.c: Regenerated.\n+\t* generated/maxloc0_16_i4.c: Regenerated.\n+\t* generated/maxloc0_16_i8.c: Regenerated.\n+\t* generated/maxloc0_16_r10.c: Regenerated.\n+\t* generated/maxloc0_16_r16.c: Regenerated.\n+\t* generated/maxloc0_16_r4.c: Regenerated.\n+\t* generated/maxloc0_16_r8.c: Regenerated.\n+\t* generated/maxloc0_16_s1.c: Regenerated.\n+\t* generated/maxloc0_16_s4.c: Regenerated.\n+\t* generated/maxloc0_4_i1.c: Regenerated.\n+\t* generated/maxloc0_4_i16.c: Regenerated.\n+\t* generated/maxloc0_4_i2.c: Regenerated.\n+\t* generated/maxloc0_4_i4.c: Regenerated.\n+\t* generated/maxloc0_4_i8.c: Regenerated.\n+\t* generated/maxloc0_4_r10.c: Regenerated.\n+\t* generated/maxloc0_4_r16.c: Regenerated.\n+\t* generated/maxloc0_4_r4.c: Regenerated.\n+\t* generated/maxloc0_4_r8.c: Regenerated.\n+\t* generated/maxloc0_4_s1.c: Regenerated.\n+\t* generated/maxloc0_4_s4.c: Regenerated.\n+\t* generated/maxloc0_8_i1.c: Regenerated.\n+\t* generated/maxloc0_8_i16.c: Regenerated.\n+\t* generated/maxloc0_8_i2.c: Regenerated.\n+\t* generated/maxloc0_8_i4.c: Regenerated.\n+\t* generated/maxloc0_8_i8.c: Regenerated.\n+\t* generated/maxloc0_8_r10.c: Regenerated.\n+\t* generated/maxloc0_8_r16.c: Regenerated.\n+\t* generated/maxloc0_8_r4.c: Regenerated.\n+\t* generated/maxloc0_8_r8.c: Regenerated.\n+\t* generated/maxloc0_8_s1.c: Regenerated.\n+\t* generated/maxloc0_8_s4.c: Regenerated.\n+\t* generated/maxloc1_16_i1.c: Regenerated.\n+\t* generated/maxloc1_16_i16.c: Regenerated.\n+\t* generated/maxloc1_16_i2.c: Regenerated.\n+\t* generated/maxloc1_16_i4.c: Regenerated.\n+\t* generated/maxloc1_16_i8.c: Regenerated.\n+\t* generated/maxloc1_16_r10.c: Regenerated.\n+\t* generated/maxloc1_16_r16.c: Regenerated.\n+\t* generated/maxloc1_16_r4.c: Regenerated.\n+\t* generated/maxloc1_16_r8.c: Regenerated.\n+\t* generated/maxloc1_16_s1.c: Regenerated.\n+\t* generated/maxloc1_16_s4.c: Regenerated.\n+\t* generated/maxloc1_4_i1.c: Regenerated.\n+\t* generated/maxloc1_4_i16.c: Regenerated.\n+\t* generated/maxloc1_4_i2.c: Regenerated.\n+\t* generated/maxloc1_4_i4.c: Regenerated.\n+\t* generated/maxloc1_4_i8.c: Regenerated.\n+\t* generated/maxloc1_4_r10.c: Regenerated.\n+\t* generated/maxloc1_4_r16.c: Regenerated.\n+\t* generated/maxloc1_4_r4.c: Regenerated.\n+\t* generated/maxloc1_4_r8.c: Regenerated.\n+\t* generated/maxloc1_4_s1.c: Regenerated.\n+\t* generated/maxloc1_4_s4.c: Regenerated.\n+\t* generated/maxloc1_8_i1.c: Regenerated.\n+\t* generated/maxloc1_8_i16.c: Regenerated.\n+\t* generated/maxloc1_8_i2.c: Regenerated.\n+\t* generated/maxloc1_8_i4.c: Regenerated.\n+\t* generated/maxloc1_8_i8.c: Regenerated.\n+\t* generated/maxloc1_8_r10.c: Regenerated.\n+\t* generated/maxloc1_8_r16.c: Regenerated.\n+\t* generated/maxloc1_8_r4.c: Regenerated.\n+\t* generated/maxloc1_8_r8.c: Regenerated.\n+\t* generated/maxloc1_8_s1.c: Regenerated.\n+\t* generated/maxloc1_8_s4.c: Regenerated.\n+\t* generated/maxloc2_16_s1.c: Regenerated.\n+\t* generated/maxloc2_16_s4.c: Regenerated.\n+\t* generated/maxloc2_4_s1.c: Regenerated.\n+\t* generated/maxloc2_4_s4.c: Regenerated.\n+\t* generated/maxloc2_8_s1.c: Regenerated.\n+\t* generated/maxloc2_8_s4.c: Regenerated.\n+\t* generated/maxval_i1.c: Regenerated.\n+\t* generated/maxval_i16.c: Regenerated.\n+\t* generated/maxval_i2.c: Regenerated.\n+\t* generated/maxval_i4.c: Regenerated.\n+\t* generated/maxval_i8.c: Regenerated.\n+\t* generated/maxval_r10.c: Regenerated.\n+\t* generated/maxval_r16.c: Regenerated.\n+\t* generated/maxval_r4.c: Regenerated.\n+\t* generated/maxval_r8.c: Regenerated.\n+\t* generated/minloc0_16_i1.c: Regenerated.\n+\t* generated/minloc0_16_i16.c: Regenerated.\n+\t* generated/minloc0_16_i2.c: Regenerated.\n+\t* generated/minloc0_16_i4.c: Regenerated.\n+\t* generated/minloc0_16_i8.c: Regenerated.\n+\t* generated/minloc0_16_r10.c: Regenerated.\n+\t* generated/minloc0_16_r16.c: Regenerated.\n+\t* generated/minloc0_16_r4.c: Regenerated.\n+\t* generated/minloc0_16_r8.c: Regenerated.\n+\t* generated/minloc0_16_s1.c: Regenerated.\n+\t* generated/minloc0_16_s4.c: Regenerated.\n+\t* generated/minloc0_4_i1.c: Regenerated.\n+\t* generated/minloc0_4_i16.c: Regenerated.\n+\t* generated/minloc0_4_i2.c: Regenerated.\n+\t* generated/minloc0_4_i4.c: Regenerated.\n+\t* generated/minloc0_4_i8.c: Regenerated.\n+\t* generated/minloc0_4_r10.c: Regenerated.\n+\t* generated/minloc0_4_r16.c: Regenerated.\n+\t* generated/minloc0_4_r4.c: Regenerated.\n+\t* generated/minloc0_4_r8.c: Regenerated.\n+\t* generated/minloc0_4_s1.c: Regenerated.\n+\t* generated/minloc0_4_s4.c: Regenerated.\n+\t* generated/minloc0_8_i1.c: Regenerated.\n+\t* generated/minloc0_8_i16.c: Regenerated.\n+\t* generated/minloc0_8_i2.c: Regenerated.\n+\t* generated/minloc0_8_i4.c: Regenerated.\n+\t* generated/minloc0_8_i8.c: Regenerated.\n+\t* generated/minloc0_8_r10.c: Regenerated.\n+\t* generated/minloc0_8_r16.c: Regenerated.\n+\t* generated/minloc0_8_r4.c: Regenerated.\n+\t* generated/minloc0_8_r8.c: Regenerated.\n+\t* generated/minloc0_8_s1.c: Regenerated.\n+\t* generated/minloc0_8_s4.c: Regenerated.\n+\t* generated/minloc1_16_i1.c: Regenerated.\n+\t* generated/minloc1_16_i16.c: Regenerated.\n+\t* generated/minloc1_16_i2.c: Regenerated.\n+\t* generated/minloc1_16_i4.c: Regenerated.\n+\t* generated/minloc1_16_i8.c: Regenerated.\n+\t* generated/minloc1_16_r10.c: Regenerated.\n+\t* generated/minloc1_16_r16.c: Regenerated.\n+\t* generated/minloc1_16_r4.c: Regenerated.\n+\t* generated/minloc1_16_r8.c: Regenerated.\n+\t* generated/minloc1_16_s1.c: Regenerated.\n+\t* generated/minloc1_16_s4.c: Regenerated.\n+\t* generated/minloc1_4_i1.c: Regenerated.\n+\t* generated/minloc1_4_i16.c: Regenerated.\n+\t* generated/minloc1_4_i2.c: Regenerated.\n+\t* generated/minloc1_4_i4.c: Regenerated.\n+\t* generated/minloc1_4_i8.c: Regenerated.\n+\t* generated/minloc1_4_r10.c: Regenerated.\n+\t* generated/minloc1_4_r16.c: Regenerated.\n+\t* generated/minloc1_4_r4.c: Regenerated.\n+\t* generated/minloc1_4_r8.c: Regenerated.\n+\t* generated/minloc1_4_s1.c: Regenerated.\n+\t* generated/minloc1_4_s4.c: Regenerated.\n+\t* generated/minloc1_8_i1.c: Regenerated.\n+\t* generated/minloc1_8_i16.c: Regenerated.\n+\t* generated/minloc1_8_i2.c: Regenerated.\n+\t* generated/minloc1_8_i4.c: Regenerated.\n+\t* generated/minloc1_8_i8.c: Regenerated.\n+\t* generated/minloc1_8_r10.c: Regenerated.\n+\t* generated/minloc1_8_r16.c: Regenerated.\n+\t* generated/minloc1_8_r4.c: Regenerated.\n+\t* generated/minloc1_8_r8.c: Regenerated.\n+\t* generated/minloc1_8_s1.c: Regenerated.\n+\t* generated/minloc1_8_s4.c: Regenerated.\n+\t* generated/minloc2_16_s1.c: Regenerated.\n+\t* generated/minloc2_16_s4.c: Regenerated.\n+\t* generated/minloc2_4_s1.c: Regenerated.\n+\t* generated/minloc2_4_s4.c: Regenerated.\n+\t* generated/minloc2_8_s1.c: Regenerated.\n+\t* generated/minloc2_8_s4.c: Regenerated.\n+\t* generated/minval_i1.c: Regenerated.\n+\t* generated/minval_i16.c: Regenerated.\n+\t* generated/minval_i2.c: Regenerated.\n+\t* generated/minval_i4.c: Regenerated.\n+\t* generated/minval_i8.c: Regenerated.\n+\t* generated/minval_r10.c: Regenerated.\n+\t* generated/minval_r16.c: Regenerated.\n+\t* generated/minval_r4.c: Regenerated.\n+\t* generated/minval_r8.c: Regenerated.\n+\t* generated/norm2_r10.c: Regenerated.\n+\t* generated/norm2_r16.c: Regenerated.\n+\t* generated/norm2_r4.c: Regenerated.\n+\t* generated/norm2_r8.c: Regenerated.\n+\t* generated/parity_l1.c: Regenerated.\n+\t* generated/parity_l16.c: Regenerated.\n+\t* generated/parity_l2.c: Regenerated.\n+\t* generated/parity_l4.c: Regenerated.\n+\t* generated/parity_l8.c: Regenerated.\n+\t* generated/product_c10.c: Regenerated.\n+\t* generated/product_c16.c: Regenerated.\n+\t* generated/product_c4.c: Regenerated.\n+\t* generated/product_c8.c: Regenerated.\n+\t* generated/product_i1.c: Regenerated.\n+\t* generated/product_i16.c: Regenerated.\n+\t* generated/product_i2.c: Regenerated.\n+\t* generated/product_i4.c: Regenerated.\n+\t* generated/product_i8.c: Regenerated.\n+\t* generated/product_r10.c: Regenerated.\n+\t* generated/product_r16.c: Regenerated.\n+\t* generated/product_r4.c: Regenerated.\n+\t* generated/product_r8.c: Regenerated.\n+\t* generated/sum_c10.c: Regenerated.\n+\t* generated/sum_c16.c: Regenerated.\n+\t* generated/sum_c4.c: Regenerated.\n+\t* generated/sum_c8.c: Regenerated.\n+\t* generated/sum_i1.c: Regenerated.\n+\t* generated/sum_i16.c: Regenerated.\n+\t* generated/sum_i2.c: Regenerated.\n+\t* generated/sum_i4.c: Regenerated.\n+\t* generated/sum_i8.c: Regenerated.\n+\t* generated/sum_r10.c: Regenerated.\n+\t* generated/sum_r16.c: Regenerated.\n+\t* generated/sum_r4.c: Regenerated.\n+\t* generated/sum_r8.c: Regenerated.\n+\n 2018-04-24  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* configure: Regenerated."}, {"sha": "f02f7afa4b080e3831ec5f0559292855c8ee160c", "filename": "libgfortran/generated/iall_i1.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiall_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiall_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iall_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iall_i1 (gfc_array_i1 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result &= *src;\n \t      }\n@@ -222,9 +220,6 @@ miall_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "e739fad7abd3e02d62099f16057db26f66625c36", "filename": "libgfortran/generated/iall_i16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiall_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiall_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iall_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iall_i16 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result &= *src;\n \t      }\n@@ -222,9 +220,6 @@ miall_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "ff958a9cd33252b5edba69aa92ba8c8998753603", "filename": "libgfortran/generated/iall_i2.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiall_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiall_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iall_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iall_i2 (gfc_array_i2 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result &= *src;\n \t      }\n@@ -222,9 +220,6 @@ miall_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "ece32e481d9222f7b8a98ae37c55260a410f7e4e", "filename": "libgfortran/generated/iall_i4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiall_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiall_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iall_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iall_i4 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result &= *src;\n \t      }\n@@ -222,9 +220,6 @@ miall_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "f181f153c7415d7c098abaf76ec67e648c63c23f", "filename": "libgfortran/generated/iall_i8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiall_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiall_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iall_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iall_i8 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result &= *src;\n \t      }\n@@ -222,9 +220,6 @@ miall_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "20088edee3a7e7964d3830bb64bf9630a1ba0869", "filename": "libgfortran/generated/iany_i1.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiany_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiany_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iany_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iany_i1 (gfc_array_i1 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result |= *src;\n \t      }\n@@ -222,9 +220,6 @@ miany_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "90844e884f42024a8925d4f06bc2de1e57fb1fec", "filename": "libgfortran/generated/iany_i16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiany_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiany_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iany_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iany_i16 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result |= *src;\n \t      }\n@@ -222,9 +220,6 @@ miany_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "e73438953013e3a3645abf5496f53e7a6ee5df70", "filename": "libgfortran/generated/iany_i2.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiany_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiany_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iany_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iany_i2 (gfc_array_i2 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result |= *src;\n \t      }\n@@ -222,9 +220,6 @@ miany_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "48043eefd2ab3bb5853c7d3bc408ef2a175029f3", "filename": "libgfortran/generated/iany_i4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiany_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiany_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iany_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iany_i4 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result |= *src;\n \t      }\n@@ -222,9 +220,6 @@ miany_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "078160b24b73b3997371d1922268522c6f34dd35", "filename": "libgfortran/generated/iany_i8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiany_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiany_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iany_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iany_i8 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result |= *src;\n \t      }\n@@ -222,9 +220,6 @@ miany_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "911f9f5a6e549c26288aeb795bc3af199d2aca75", "filename": "libgfortran/generated/iparity_i1.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiparity_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiparity_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iparity_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iparity_i1 (gfc_array_i1 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result ^= *src;\n \t      }\n@@ -222,9 +220,6 @@ miparity_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "b434f01b4f149849d87cdcf95e51e714c17be91e", "filename": "libgfortran/generated/iparity_i16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiparity_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiparity_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iparity_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iparity_i16 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result ^= *src;\n \t      }\n@@ -222,9 +220,6 @@ miparity_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "998df01fd8d3cfb8671e81c4b7c5365c34ffa82a", "filename": "libgfortran/generated/iparity_i2.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiparity_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiparity_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iparity_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iparity_i2 (gfc_array_i2 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result ^= *src;\n \t      }\n@@ -222,9 +220,6 @@ miparity_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "a0c515c77173d79b0c14d5269061d3d4ae2c10c3", "filename": "libgfortran/generated/iparity_i4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiparity_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiparity_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iparity_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iparity_i4 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result ^= *src;\n \t      }\n@@ -222,9 +220,6 @@ miparity_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "3225513273e6fc2ec29bd10432399ca6d51df9b4", "filename": "libgfortran/generated/iparity_i8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiparity_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fiparity_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ iparity_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ iparity_i8 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result ^= *src;\n \t      }\n@@ -222,9 +220,6 @@ miparity_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "3bb69059e5543d82a7bad23d510cbd8f1ae8f3eb", "filename": "libgfortran/generated/maxloc0_16_i1.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_1_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_16_i1 (gfc_array_i16 * const restrict, \n \tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "7c2967fedde57387ea70ab0d492474b24d41a0f2", "filename": "libgfortran/generated/maxloc0_16_i16.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_16_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "87edb85cdc635cecc68d76fc1e178065959c4922", "filename": "libgfortran/generated/maxloc0_16_i2.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_2_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_16_i2 (gfc_array_i16 * const restrict, \n \tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "38daf6d77a7d7f41201d8ab66c74211c41697900", "filename": "libgfortran/generated/maxloc0_16_i4.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_16_i4 (gfc_array_i16 * const restrict, \n \tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "f48e943d9fce0649fa9f118af5e7189cb5eba35c", "filename": "libgfortran/generated/maxloc0_16_i8.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_16_i8 (gfc_array_i16 * const restrict, \n \tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "f1dc89be33e7fcb35cc004488d308cf634c5f474", "filename": "libgfortran/generated/maxloc0_16_r10.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_10_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_16_r10 (gfc_array_i16 * const restrict, \n \tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "7003a60ac6887daef5b625b4f8dbbae101ee1950", "filename": "libgfortran/generated/maxloc0_16_r16.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_16_r16 (gfc_array_i16 * const restrict, \n \tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "0ada2d1b2088379d062aa431715067648ef02c04", "filename": "libgfortran/generated/maxloc0_16_r4.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_16_r4 (gfc_array_i16 * const restrict, \n \tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "75b59841aaae47847004f485251eccda9c41c43f", "filename": "libgfortran/generated/maxloc0_16_r8.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_16_r8 (gfc_array_i16 * const restrict, \n \tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "33f73e7d62caacb44cd4a3f6276d1a51563278be", "filename": "libgfortran/generated/maxloc0_16_s1.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ maxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ maxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_1 *maxval;\n-   maxval = base;\n+   maxval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, maxval, len) > 0)\n+    if (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0 :\n+     \t\t   \t   \t   compare_fcn (base, maxval, len) > 0))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mmaxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mmaxloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+  if (*mbase &&\n+        (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0:\n+\t\t   \t   \t   compare_fcn (base, maxval, len) > 0)))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "8eec34160cb0fc9b38b331c0d94bb5ead56c2583", "filename": "libgfortran/generated/maxloc0_16_s4.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ maxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ maxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_4 *maxval;\n-   maxval = base;\n+   maxval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, maxval, len) > 0)\n+    if (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0 :\n+     \t\t   \t   \t   compare_fcn (base, maxval, len) > 0))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mmaxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mmaxloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+  if (*mbase &&\n+        (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0:\n+\t\t   \t   \t   compare_fcn (base, maxval, len) > 0)))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "63a5d544c72fe6eb0c16baef463f2d860747ee3b", "filename": "libgfortran/generated/maxloc0_4_i1.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_1_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_4_i1 (gfc_array_i4 * const restrict, \n \tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "b515ee0c097e5065571cd02102825fafcaaff925", "filename": "libgfortran/generated/maxloc0_4_i16.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_4_i16 (gfc_array_i4 * const restrict, \n \tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "563aebe28b7f27313d940be998a7a24375a72877", "filename": "libgfortran/generated/maxloc0_4_i2.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_2_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_4_i2 (gfc_array_i4 * const restrict, \n \tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "7760807bac28f99bbbc83a09bcec720628f0b999", "filename": "libgfortran/generated/maxloc0_4_i4.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_4_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "e9113183aab9c47ea0b5146dc8b98a6f3464f904", "filename": "libgfortran/generated/maxloc0_4_i8.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_4_i8 (gfc_array_i4 * const restrict, \n \tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "b335b2ed5eb08297c8c23e47882b918b74e4679b", "filename": "libgfortran/generated/maxloc0_4_r10.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_10_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_4_r10 (gfc_array_i4 * const restrict, \n \tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "6a27d69f077629b7733b8774f05fdb87ba4f2f96", "filename": "libgfortran/generated/maxloc0_4_r16.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_4_r16 (gfc_array_i4 * const restrict, \n \tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "76732d7f6bb95fecdca7937fff47fdc444102af4", "filename": "libgfortran/generated/maxloc0_4_r4.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_4_r4 (gfc_array_i4 * const restrict, \n \tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "13e371030b79e679be3f212fd14dd9010a0abe57", "filename": "libgfortran/generated/maxloc0_4_r8.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_4_r8 (gfc_array_i4 * const restrict, \n \tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "ba8e63401187ce9592b188c63bcf423184c3e99f", "filename": "libgfortran/generated/maxloc0_4_s1.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ maxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ maxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_1 *maxval;\n-   maxval = base;\n+   maxval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, maxval, len) > 0)\n+    if (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0 :\n+     \t\t   \t   \t   compare_fcn (base, maxval, len) > 0))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mmaxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mmaxloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+  if (*mbase &&\n+        (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0:\n+\t\t   \t   \t   compare_fcn (base, maxval, len) > 0)))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "90a54b6aed8ac9acc5e2d5281e8eede29a75aaa6", "filename": "libgfortran/generated/maxloc0_4_s4.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ maxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ maxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_4 *maxval;\n-   maxval = base;\n+   maxval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, maxval, len) > 0)\n+    if (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0 :\n+     \t\t   \t   \t   compare_fcn (base, maxval, len) > 0))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mmaxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mmaxloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+  if (*mbase &&\n+        (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0:\n+\t\t   \t   \t   compare_fcn (base, maxval, len) > 0)))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "c7852b5c8e781abb3e236ace9e46b56ffcee982c", "filename": "libgfortran/generated/maxloc0_8_i1.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_1_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_8_i1 (gfc_array_i8 * const restrict, \n \tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "88d50d9751893141979032e1dbc792d75f268afc", "filename": "libgfortran/generated/maxloc0_8_i16.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_8_i16 (gfc_array_i8 * const restrict, \n \tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "b763e3b462e429635454f89876af4762b681f968", "filename": "libgfortran/generated/maxloc0_8_i2.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_2_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_8_i2 (gfc_array_i8 * const restrict, \n \tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "e338364f9511a8f34cd7fb6bdd6734f0d0bf77d2", "filename": "libgfortran/generated/maxloc0_8_i4.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_8_i4 (gfc_array_i8 * const restrict, \n \tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "11fd73de774ff75d442b328a9d833a95757ad5ca", "filename": "libgfortran/generated/maxloc0_8_i8.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_8_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "315c8d7e613d481c3fa6a920836b6d8e3092a7e5", "filename": "libgfortran/generated/maxloc0_8_r10.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_10_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_8_r10 (gfc_array_i8 * const restrict, \n \tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "6fcc69ec39420507dc9ca57c78646c0600ab58ee", "filename": "libgfortran/generated/maxloc0_8_r16.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_8_r16 (gfc_array_i8 * const restrict, \n \tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "3ecd60ed7ad438d7d6e32e6c9fd7c42dca48f37b", "filename": "libgfortran/generated/maxloc0_8_r4.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_8_r4 (gfc_array_i8 * const restrict, \n \tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "299be1a5c0d378c565c2ac5b9618ed6044a82468", "filename": "libgfortran/generated/maxloc0_8_r8.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mmaxloc0_8_r8 (gfc_array_i8 * const restrict, \n \tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n \t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];"}, {"sha": "405162338c7e420f23bcde63f4a4ce88b2d53f8d", "filename": "libgfortran/generated/maxloc0_8_s1.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ maxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ maxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_1 *maxval;\n-   maxval = base;\n+   maxval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, maxval, len) > 0)\n+    if (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0 :\n+     \t\t   \t   \t   compare_fcn (base, maxval, len) > 0))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mmaxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mmaxloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+  if (*mbase &&\n+        (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0:\n+\t\t   \t   \t   compare_fcn (base, maxval, len) > 0)))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "40ea75d257ffe00e2c92f917245f6c1480de4806", "filename": "libgfortran/generated/maxloc0_8_s4.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ maxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ maxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_4 *maxval;\n-   maxval = base;\n+   maxval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, maxval, len) > 0)\n+    if (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0 :\n+     \t\t   \t   \t   compare_fcn (base, maxval, len) > 0))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mmaxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mmaxloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+  if (*mbase &&\n+        (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0:\n+\t\t   \t   \t   compare_fcn (base, maxval, len) > 0)))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "cb04e9417eea8d06dff6c40d1c7dfa1d384bbd0a", "filename": "libgfortran/generated/maxloc1_16_i1.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_1_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "871bf028341d4274ac0578ff407470f47d7af605", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_16_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "3bba4bc92979c8ed24c3f8868b5aafb0c25e284f", "filename": "libgfortran/generated/maxloc1_16_i2.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_2_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "043a9874d720429367d569610c6ab28f7809ca03", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_4_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "fe9704fa68beef272a9e99e1058b4bf241f6f76a", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_8_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "25b0449d5860add94c2c03f01a4f59fbb9fa2273", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_10_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "4b0bddc4104d7c6505dab143a00b8544b3c012e2", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_16_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "9a021a05cfe5e2ef89a47b752061ed272d1fb9c7", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_4_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "2cb8db38fb58b27cacaa1f2bd061de6610f9c210", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_8_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "ae17ccd788ed912d29daf947e06656bee477c970", "filename": "libgfortran/generated/maxloc1_16_s1.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ maxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ maxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_1 *maxval;\n-\tmaxval = base;\n-\tresult = 1;\n+\tmaxval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (maxval == NULL || (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -244,9 +241,6 @@ mmaxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mmaxloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n \t    }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t     \t     compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_16)n + 1;"}, {"sha": "6b436d64a69859ea1ecce082fb5b8233cc1e9c5e", "filename": "libgfortran/generated/maxloc1_16_s4.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ maxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ maxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_4 *maxval;\n-\tmaxval = base;\n-\tresult = 1;\n+\tmaxval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (maxval == NULL || (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -244,9 +241,6 @@ mmaxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mmaxloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n \t    }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t     \t     compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_16)n + 1;"}, {"sha": "43d541e01f2d7e84a101eac175e951e224580d9a", "filename": "libgfortran/generated/maxloc1_4_i1.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_1_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "7d006abbd1426e6dd1ddda97b61dffb6441b08f4", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_16_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "6f3751be02105283b1b1ca0621e31792acd73dc6", "filename": "libgfortran/generated/maxloc1_4_i2.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_2_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "47c5d825fe85996c248f55046eaf10ec67e3e84f", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_4_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "e8380aa720691dc70f6b9d92c7a712983d20d6e0", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_8_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "fe922ba3f2f44dfb7b6764423c25e8522b5fef05", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_10_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "eeab770df1c50bcc90f938760417d0101a06a0b5", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_16_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "c0b80b0817dfad7dd69b6847b613b017e3ba8124", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_4_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "3560c3b74342381c7042c298416ed94fe99e4e9c", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_8_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "cdcd7fb265230c6877f5be1be2c99bfae1d8865c", "filename": "libgfortran/generated/maxloc1_4_s1.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ maxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ maxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_1 *maxval;\n-\tmaxval = base;\n-\tresult = 1;\n+\tmaxval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (maxval == NULL || (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -244,9 +241,6 @@ mmaxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mmaxloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n \t    }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t     \t     compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_4)n + 1;"}, {"sha": "f1e79cf90020dd8b338ead275c0733d7a58077fd", "filename": "libgfortran/generated/maxloc1_4_s4.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ maxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ maxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_4 *maxval;\n-\tmaxval = base;\n-\tresult = 1;\n+\tmaxval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (maxval == NULL || (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -244,9 +241,6 @@ mmaxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mmaxloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n \t    }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t     \t     compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_4)n + 1;"}, {"sha": "1ff5cd3c90c8c579e6ac71f36ea26d54c14487b8", "filename": "libgfortran/generated/maxloc1_8_i1.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_1_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "9341c2744df4ed74ab994cc79ae2f2a052ad21f7", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_16_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "4d443ae595ea28039c3c853b4f15a8a446c8b94f", "filename": "libgfortran/generated/maxloc1_8_i2.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_2_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "2058ab2ad69478485d8ade152f7b4ee8b4ef77a1", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_4_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "9dc002f6c7244e50368043255911efefa3dd0491", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_8_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "1a963d18c56cf629afa43a453e028f635efd0254", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_10_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "e04c70e50659c09c08308bf417f05d07b03c1433", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_16_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "b06820bce61c3199f7280c386336d4763a4904b5", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_4_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "1963746d42244059e76a18ca9d1ede2a0a89af68", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,21 +159,27 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_8_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -246,9 +248,6 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +395,23 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "2b16e0652456ff83977f10916fdb987b22d4c5c0", "filename": "libgfortran/generated/maxloc1_8_s1.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ maxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ maxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_1 *maxval;\n-\tmaxval = base;\n-\tresult = 1;\n+\tmaxval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (maxval == NULL || (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -244,9 +241,6 @@ mmaxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mmaxloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n \t    }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t     \t     compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_8)n + 1;"}, {"sha": "c4557e0e001981c3f5a1c121408fd4a1d60b381c", "filename": "libgfortran/generated/maxloc1_8_s4.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ maxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ maxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_4 *maxval;\n-\tmaxval = base;\n-\tresult = 1;\n+\tmaxval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (maxval == NULL || (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -244,9 +241,6 @@ mmaxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mmaxloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n \t    }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t     \t     compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (GFC_INTEGER_8)n + 1;"}, {"sha": "9efa7cb777843d4989a5e449b70e40ac39f0458f", "filename": "libgfortran/generated/maxloc2_16_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -53,7 +53,6 @@ maxloc2_16_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_char\n   const GFC_INTEGER_1 *maxval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -62,15 +61,16 @@ maxloc2_16_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_char\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  maxval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) > 0)\n+      if (maxval == NULL || (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t    \t    compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -95,7 +95,6 @@ mmaxloc2_16_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -133,7 +132,8 @@ mmaxloc2_16_s1 (gfc_array_s1 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t   compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "65573f8da4cfe6ab53e67f9513879c626fe5f3ae", "filename": "libgfortran/generated/maxloc2_16_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -53,7 +53,6 @@ maxloc2_16_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_char\n   const GFC_INTEGER_4 *maxval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -62,15 +61,16 @@ maxloc2_16_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_char\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  maxval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) > 0)\n+      if (maxval == NULL || (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t    \t    compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -95,7 +95,6 @@ mmaxloc2_16_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -133,7 +132,8 @@ mmaxloc2_16_s4 (gfc_array_s4 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t   compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "68e02f55134abc1cf20b340474f04b3096ffa76a", "filename": "libgfortran/generated/maxloc2_4_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -53,7 +53,6 @@ maxloc2_4_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n   const GFC_INTEGER_1 *maxval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -62,15 +61,16 @@ maxloc2_4_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  maxval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) > 0)\n+      if (maxval == NULL || (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t    \t    compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -95,7 +95,6 @@ mmaxloc2_4_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -133,7 +132,8 @@ mmaxloc2_4_s1 (gfc_array_s1 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t   compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "aa5a47aed4c61eb74bc23edfe6199f2a63852ed7", "filename": "libgfortran/generated/maxloc2_4_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -53,7 +53,6 @@ maxloc2_4_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n   const GFC_INTEGER_4 *maxval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -62,15 +61,16 @@ maxloc2_4_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  maxval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) > 0)\n+      if (maxval == NULL || (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t    \t    compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -95,7 +95,6 @@ mmaxloc2_4_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -133,7 +132,8 @@ mmaxloc2_4_s4 (gfc_array_s4 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t   compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "c9c316017b564ad24f1394de6ba99c3b1e1be262", "filename": "libgfortran/generated/maxloc2_8_s1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -53,7 +53,6 @@ maxloc2_8_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n   const GFC_INTEGER_1 *maxval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -62,15 +61,16 @@ maxloc2_8_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  maxval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) > 0)\n+      if (maxval == NULL || (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t    \t    compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -95,7 +95,6 @@ mmaxloc2_8_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -133,7 +132,8 @@ mmaxloc2_8_s1 (gfc_array_s1 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t   compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "f707b140c47368ff8f86635aadeb7684a745e19b", "filename": "libgfortran/generated/maxloc2_8_s4.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -53,7 +53,6 @@ maxloc2_8_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n   const GFC_INTEGER_4 *maxval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -62,15 +61,16 @@ maxloc2_8_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back, gfc_charl\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  maxval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) > 0)\n+      if (maxval == NULL || (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t    \t    compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -95,7 +95,6 @@ mmaxloc2_8_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -133,7 +132,8 @@ mmaxloc2_8_s4 (gfc_array_s4 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t   compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "86c9fb9018962768b907307391085295de7e3956", "filename": "libgfortran/generated/maxval_i1.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n \t  *dest = (-GFC_INTEGER_1_HUGE-1);\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_1_QUIET_NAN)\n \t\tif (*src >= result)\n@@ -236,9 +234,6 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "30a440e042a7cfcd212e1677f8f12ae65b497681", "filename": "libgfortran/generated/maxval_i16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n \t  *dest = (-GFC_INTEGER_16_HUGE-1);\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_16_QUIET_NAN)\n \t\tif (*src >= result)\n@@ -236,9 +234,6 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "2a329060c39f9ba6eda2cf9e28949eb865f8de32", "filename": "libgfortran/generated/maxval_i2.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n \t  *dest = (-GFC_INTEGER_2_HUGE-1);\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_2_QUIET_NAN)\n \t\tif (*src >= result)\n@@ -236,9 +234,6 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "2954e8ada4a23f3693de3f48ad7ce148dafefebe", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n \t  *dest = (-GFC_INTEGER_4_HUGE-1);\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_4_QUIET_NAN)\n \t\tif (*src >= result)\n@@ -236,9 +234,6 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "fde234cfcbfb92092dc05b808685777035529ed8", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n \t  *dest = (-GFC_INTEGER_8_HUGE-1);\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_8_QUIET_NAN)\n \t\tif (*src >= result)\n@@ -236,9 +234,6 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "9671fdfc98fe923447d9e3d7bd18f862cb263747", "filename": "libgfortran/generated/maxval_r10.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n \t  *dest = -GFC_REAL_10_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_10_QUIET_NAN)\n \t\tif (*src >= result)\n@@ -236,9 +234,6 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "14e6ce0d09112d1435b83065ba9db9db03f9a4f5", "filename": "libgfortran/generated/maxval_r16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n \t  *dest = -GFC_REAL_16_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_16_QUIET_NAN)\n \t\tif (*src >= result)\n@@ -236,9 +234,6 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "9b5dba0981866f4d5447121b34bac691b57e94e5", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n \t  *dest = -GFC_REAL_4_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_4_QUIET_NAN)\n \t\tif (*src >= result)\n@@ -236,9 +234,6 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "13f491114ab6201a76a8f91b623cb786af164bc0", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n \t  *dest = -GFC_REAL_8_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_8_QUIET_NAN)\n \t\tif (*src >= result)\n@@ -236,9 +234,6 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "1e1cd6180a3830fa54a4ad5d28e4c20ec37a147e", "filename": "libgfortran/generated/minloc0_16_i1.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_1_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_16_i1 (gfc_array_i16 * const restrict, \n \tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_16_i1 (gfc_array_i16 * const restrict, \n \tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_i1);"}, {"sha": "b3663d6199d4e643c927122993f74a0287961262", "filename": "libgfortran/generated/minloc0_16_i16.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_16_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_16_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_i16);"}, {"sha": "3a173ea6f37f24f3bd58c04edabffb78c9c88967", "filename": "libgfortran/generated/minloc0_16_i2.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_2_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_16_i2 (gfc_array_i16 * const restrict, \n \tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_16_i2 (gfc_array_i16 * const restrict, \n \tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_i2);"}, {"sha": "4141fa1f22f16796cdce8f2b1749291bd476c3db", "filename": "libgfortran/generated/minloc0_16_i4.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_16_i4 (gfc_array_i16 * const restrict, \n \tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_16_i4 (gfc_array_i16 * const restrict, \n \tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_i4);"}, {"sha": "0d2f3504408461fcf43030bdce56d07d63d28839", "filename": "libgfortran/generated/minloc0_16_i8.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_16_i8 (gfc_array_i16 * const restrict, \n \tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_16_i8 (gfc_array_i16 * const restrict, \n \tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_i8);"}, {"sha": "3fd940997986d0ee39423aaa3b1b3178afe176f7", "filename": "libgfortran/generated/minloc0_16_r10.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_10_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_16_r10 (gfc_array_i16 * const restrict, \n \tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_16_r10 (gfc_array_i16 * const restrict, \n \tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_r10);"}, {"sha": "d04fdda43c96ea74a4ba01497e52114c88c9fcd7", "filename": "libgfortran/generated/minloc0_16_r16.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_16_r16 (gfc_array_i16 * const restrict, \n \tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_16_r16 (gfc_array_i16 * const restrict, \n \tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_r16);"}, {"sha": "8b029151031ebd9b33cd4f3c8502fa08baeeae45", "filename": "libgfortran/generated/minloc0_16_r4.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_16_r4 (gfc_array_i16 * const restrict, \n \tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_16_r4 (gfc_array_i16 * const restrict, \n \tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_r4);"}, {"sha": "45ab7874177d62a8bf61044b367bb83cd28094ee", "filename": "libgfortran/generated/minloc0_16_r8.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_16_r8 (gfc_array_i16 * const restrict, \n \tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_16_r8 (gfc_array_i16 * const restrict, \n \tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_16_r8);"}, {"sha": "95a38a6b5d938c257776dd3a1c22e5990ce64795", "filename": "libgfortran/generated/minloc0_16_s1.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ minloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ minloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_1 *minval;\n-   minval = base;\n+   minval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, minval, len) < 0)\n+    if (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t   compare_fcn (base, minval, len) < 0))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mminloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mminloc0_16_s1 (gfc_array_i16 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+  if (*mbase &&\n+      (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t compare_fcn (base, minval, len) < 0)))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "091afb7a6e9a84d0df9b1d5d548400ece6128a4a", "filename": "libgfortran/generated/minloc0_16_s4.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ minloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ minloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_4 *minval;\n-   minval = base;\n+   minval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, minval, len) < 0)\n+    if (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t   compare_fcn (base, minval, len) < 0))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mminloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mminloc0_16_s4 (gfc_array_i16 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+  if (*mbase &&\n+      (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t compare_fcn (base, minval, len) < 0)))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "7120f000d89b3f68f2fac2b013980341329a2925", "filename": "libgfortran/generated/minloc0_4_i1.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_1_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_4_i1 (gfc_array_i4 * const restrict, \n \tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_4_i1 (gfc_array_i4 * const restrict, \n \tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_i1);"}, {"sha": "c9debdbd457e0bff636dde8851de343e18e51e0f", "filename": "libgfortran/generated/minloc0_4_i16.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_4_i16 (gfc_array_i4 * const restrict, \n \tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_4_i16 (gfc_array_i4 * const restrict, \n \tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_i16);"}, {"sha": "55fb58d4021370da63a22f86978fee08d93e4f65", "filename": "libgfortran/generated/minloc0_4_i2.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_2_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_4_i2 (gfc_array_i4 * const restrict, \n \tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_4_i2 (gfc_array_i4 * const restrict, \n \tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_i2);"}, {"sha": "351b4a1cc5c4ad84fa0cf7e0c6897517f5e40991", "filename": "libgfortran/generated/minloc0_4_i4.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_4_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_4_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_i4);"}, {"sha": "a736c59a105600c317588454c92ce8c6244cd73a", "filename": "libgfortran/generated/minloc0_4_i8.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_4_i8 (gfc_array_i4 * const restrict, \n \tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_4_i8 (gfc_array_i4 * const restrict, \n \tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_i8);"}, {"sha": "f714417518b9c9acdec1ade640365ca755b64cc3", "filename": "libgfortran/generated/minloc0_4_r10.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_10_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_4_r10 (gfc_array_i4 * const restrict, \n \tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_4_r10 (gfc_array_i4 * const restrict, \n \tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_r10);"}, {"sha": "7d7ece40a957a0121a8cfa3663143f535465ddf6", "filename": "libgfortran/generated/minloc0_4_r16.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_4_r16 (gfc_array_i4 * const restrict, \n \tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_4_r16 (gfc_array_i4 * const restrict, \n \tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_r16);"}, {"sha": "74757394d3331c3f9fe4d89ae5b54fe883f5ade5", "filename": "libgfortran/generated/minloc0_4_r4.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_4_r4 (gfc_array_i4 * const restrict, \n \tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_4_r4 (gfc_array_i4 * const restrict, \n \tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_r4);"}, {"sha": "0ac6e6b3264cf4a386f9956e7e77833298469682", "filename": "libgfortran/generated/minloc0_4_r8.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_4_r8 (gfc_array_i4 * const restrict, \n \tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_4_r8 (gfc_array_i4 * const restrict, \n \tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_4_r8);"}, {"sha": "aeb0ae9f425f98116a8c03b6efe814b85bb48b0a", "filename": "libgfortran/generated/minloc0_4_s1.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ minloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ minloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_1 *minval;\n-   minval = base;\n+   minval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, minval, len) < 0)\n+    if (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t   compare_fcn (base, minval, len) < 0))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mminloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mminloc0_4_s1 (gfc_array_i4 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+  if (*mbase &&\n+      (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t compare_fcn (base, minval, len) < 0)))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "f5b5906586355bb2ae445cd2354a6845e1e6f9a6", "filename": "libgfortran/generated/minloc0_4_s4.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ minloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ minloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_4 *minval;\n-   minval = base;\n+   minval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, minval, len) < 0)\n+    if (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t   compare_fcn (base, minval, len) < 0))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mminloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mminloc0_4_s4 (gfc_array_i4 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+  if (*mbase &&\n+      (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t compare_fcn (base, minval, len) < 0)))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "46dfa7807fda33b67b1c245a6a5da87eb0a871cc", "filename": "libgfortran/generated/minloc0_8_i1.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_1_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_8_i1 (gfc_array_i8 * const restrict, \n \tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_8_i1 (gfc_array_i8 * const restrict, \n \tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_i1);"}, {"sha": "c3da87d0e76c3a52cc3f9a0990cc3696a9d2ce8b", "filename": "libgfortran/generated/minloc0_8_i16.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_8_i16 (gfc_array_i8 * const restrict, \n \tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_8_i16 (gfc_array_i8 * const restrict, \n \tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_i16);"}, {"sha": "8455b7d406dcedc4c0d6285161a558be839f3f34", "filename": "libgfortran/generated/minloc0_8_i2.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_2_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_8_i2 (gfc_array_i8 * const restrict, \n \tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_8_i2 (gfc_array_i8 * const restrict, \n \tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_i2);"}, {"sha": "2b02216748275d4ec4df0a97b794ad0c01c1b243", "filename": "libgfortran/generated/minloc0_8_i4.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_8_i4 (gfc_array_i8 * const restrict, \n \tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_8_i4 (gfc_array_i8 * const restrict, \n \tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_i4);"}, {"sha": "55aafa4c634030fa34e356b7f8125f6c68b846a3", "filename": "libgfortran/generated/minloc0_8_i8.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_INTEGER_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_8_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_8_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_i8);"}, {"sha": "14b8a62f5109e3acd0b16361a4666542e127823d", "filename": "libgfortran/generated/minloc0_8_r10.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_10_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_8_r10 (gfc_array_i8 * const restrict, \n \tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_8_r10 (gfc_array_i8 * const restrict, \n \tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_r10);"}, {"sha": "e5c48fa77d62c0f0b090c77205fab15b86c2e9cf", "filename": "libgfortran/generated/minloc0_8_r16.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_16_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_8_r16 (gfc_array_i8 * const restrict, \n \tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_8_r16 (gfc_array_i8 * const restrict, \n \tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_r16);"}, {"sha": "caba6a7d49b025dd9a2dcae5861fc522e9979354", "filename": "libgfortran/generated/minloc0_8_r4.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_4_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_8_r4 (gfc_array_i8 * const restrict, \n \tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_8_r4 (gfc_array_i8 * const restrict, \n \tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_r4);"}, {"sha": "876e9cbae29e1f42f55190dab0c7763ad883d5be", "filename": "libgfortran/generated/minloc0_8_r8.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -47,7 +47,6 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -101,13 +100,9 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n #if defined(GFC_REAL_8_QUIET_NAN)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -126,15 +121,29 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n \t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n+\t    }\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -167,7 +176,6 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void mminloc0_8_r8 (gfc_array_i8 * const restrict, \n \tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict,\n \tGFC_LOGICAL_4);\n@@ -190,7 +198,6 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -261,12 +268,8 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n #endif\n   while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n \n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -294,14 +297,28 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n \t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n \t  /* Implementation end.  */\n \t  /* Advance to the next element.  */\n \t  base += sstride[0];\n@@ -337,7 +354,6 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n-\n extern void sminloc0_8_r8 (gfc_array_i8 * const restrict, \n \tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n export_proto(sminloc0_8_r8);"}, {"sha": "68b1800b4a9bd4cdd344b1fc3c9026a7a7a7e1b6", "filename": "libgfortran/generated/minloc0_8_s1.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ minloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ minloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_1 *minval;\n-   minval = base;\n+   minval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, minval, len) < 0)\n+    if (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t   compare_fcn (base, minval, len) < 0))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mminloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mminloc0_8_s1 (gfc_array_i8 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+  if (*mbase &&\n+      (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t compare_fcn (base, minval, len) < 0)))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "715e074312a7053ed0508675c5c0d6003394c8c4", "filename": "libgfortran/generated/minloc0_8_s4.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc0_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -61,10 +61,6 @@ minloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -107,15 +103,16 @@ minloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   {\n \n   const GFC_INTEGER_4 *minval;\n-   minval = base;\n+   minval = NULL;\n \n   while (base)\n     {\n       do\n \t{\n \t  /* Implementation start.  */\n \n-  if (compare_fcn (base, minval, len) < 0)\n+    if (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t   compare_fcn (base, minval, len) < 0))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)\n@@ -177,9 +174,6 @@ mminloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -250,7 +244,9 @@ mminloc0_8_s4 (gfc_array_i8 * const restrict retarray,\n \t{\n \t  /* Implementation start.  */\n \n-  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+  if (*mbase &&\n+      (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t compare_fcn (base, minval, len) < 0)))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "132b2f1abae3018516db07b23937f7e50cc2cb9c", "filename": "libgfortran/generated/minloc1_16_i1.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_1_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_16) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "83a8d5928c54b62ea837f4b0860c06eb2fa89c83", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_16_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_16) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "a22e2c71770ef3f54cb2d7b5881d5ee64d996f65", "filename": "libgfortran/generated/minloc1_16_i2.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_2_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_16) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "f384ff10f0ab242159b809c988f6e02bad94b505", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_4_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_16) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "72b75b0329d92829b8ebc7201d532be929a98de1", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_8_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_16) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "53cf97dbd24bab21f1b1f2b0808e401e742f3718", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_10_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_16) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "93193cf92d6e31584f55dfca404a35a260b8cf18", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_16_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_16) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "14369b697dcee7de2a4021ea8835b81549235be9", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_4_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_16) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "8dfe8ec3effab8728514622f26b04a84c399642f", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_8_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_16)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_16) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "5fea33ae1f71a81870b5adf47ab2769a19459398", "filename": "libgfortran/generated/minloc1_16_s1.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ minloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ minloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_1 *minval;\n-\tminval = base;\n-\tresult = 1;\n+\tminval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\tif (minval == NULL || (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -244,9 +241,6 @@ mminloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mminloc1_16_s1 (gfc_array_i16 * const restrict retarray,\n             }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t     \t     compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_16)n + 1;"}, {"sha": "46411b113bb355c7cc6f1d125dccddb7d82fd3fa", "filename": "libgfortran/generated/minloc1_16_s4.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ minloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ minloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_4 *minval;\n-\tminval = base;\n-\tresult = 1;\n+\tminval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\tif (minval == NULL || (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_16)n + 1;\n@@ -244,9 +241,6 @@ mminloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mminloc1_16_s4 (gfc_array_i16 * const restrict retarray,\n             }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t     \t     compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_16)n + 1;"}, {"sha": "ce9b926f22d0f681a54dfac6af39cdf771b2fdcc", "filename": "libgfortran/generated/minloc1_4_i1.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_1_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_4) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "871aa374a1a222769964df9dec44ea8b51f46649", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_16_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_4) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "16f7e5ef7b7dac89b89c080363608c3b68996502", "filename": "libgfortran/generated/minloc1_4_i2.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_2_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_4) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "08d919aabd09b750d86eeeddf4eb9bcf87df6e2d", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_4_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_4) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "807f6fa016bf45920e1169b725102968cc40e9e0", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_8_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_4) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "b2430c4ea6e57092d3fed4f3db6ca9a18b332153", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_10_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_4) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "e81a0a77e90ad47c32a7169c3809195c268087eb", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_16_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_4) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "b82aeeaf730732c6e91664c13f756fd48c7fef7a", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_4_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_4) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "3476a5e5adb6a47aae2f94281de3e59932d4fe21", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_8_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_4)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_4) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "f0c583ffa52abf09f4d903b6a6ba8acf17b6101e", "filename": "libgfortran/generated/minloc1_4_s1.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ minloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ minloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_1 *minval;\n-\tminval = base;\n-\tresult = 1;\n+\tminval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\tif (minval == NULL || (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -244,9 +241,6 @@ mminloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mminloc1_4_s1 (gfc_array_i4 * const restrict retarray,\n             }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t     \t     compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_4)n + 1;"}, {"sha": "eaafec1018bdf737838bfd96f995c303d0323897", "filename": "libgfortran/generated/minloc1_4_s4.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ minloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ minloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_4 *minval;\n-\tminval = base;\n-\tresult = 1;\n+\tminval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\tif (minval == NULL || (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_4)n + 1;\n@@ -244,9 +241,6 @@ mminloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mminloc1_4_s4 (gfc_array_i4 * const restrict retarray,\n             }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t     \t     compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_4)n + 1;"}, {"sha": "f04fd8d72d82b0843578ffebf4150c0770cbff70", "filename": "libgfortran/generated/minloc1_8_i1.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_1_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_8) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "d42c5feea2ea8c7a4ffa740eaf3644e6531d490e", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_16_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_8) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "134617d49f37895b34d71ffb7b7d3dc13efa253f", "filename": "libgfortran/generated/minloc1_8_i2.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_2_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_8) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "20f0595ae1d1f5a52b92a0f0fc6f17f1c9e0fce5", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_4_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_8) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "653393c532eb838d1da28e67db5d423a49ea9722", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_8_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_8) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "a51a290db1ff95569183aa8f4062eeda4aaeb6c1", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_10_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_8) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "e8e1b7452ad597e8ddfcde511f926c2f7ceea8be", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_16_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_8) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "f4a27e1c50d6e5cb7afe15317978529f39f1a0e2", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_4_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_8) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "4cd0df1209f0eeada13459d42432c39430eb9ce9", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,25 +159,41 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_8_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8) n + 1;\n+\t\t    }\n \t      }\n \t    \n \t    *dest = result;\n@@ -246,9 +258,6 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -396,13 +405,23 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (GFC_INTEGER_8)n + 1;\n-\t\t  }\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_8) n + 1;\n+\t\t      }\n \t  }\n \t*dest = result;\n       }"}, {"sha": "ee2547bc406cb4237fe3de2562d17aa2a5f35dec", "filename": "libgfortran/generated/minloc1_8_s1.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ minloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ minloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_1 *minval;\n-\tminval = base;\n-\tresult = 1;\n+\tminval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\tif (minval == NULL || (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -244,9 +241,6 @@ mminloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mminloc1_8_s1 (gfc_array_i8 * const restrict retarray,\n             }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t     \t     compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_8)n + 1;"}, {"sha": "605c5de3aefbdb9848ae2c2a593b34116f05488b", "filename": "libgfortran/generated/minloc1_8_s4.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc1_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -66,10 +66,6 @@ minloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -165,16 +161,17 @@ minloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n       {\n \n \tconst GFC_INTEGER_4 *minval;\n-\tminval = base;\n-\tresult = 1;\n+\tminval = NULL;\n+\tresult = 0;\n \tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\tif (minval == NULL || (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_8)n + 1;\n@@ -244,9 +241,6 @@ mminloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n@@ -377,7 +371,8 @@ mminloc1_8_s4 (gfc_array_i8 * const restrict retarray,\n             }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t     \t     compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (GFC_INTEGER_8)n + 1;"}, {"sha": "30fdd82d17809fef58b8e3bb23c5cf1e25503ef4", "filename": "libgfortran/generated/minloc2_16_s1.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_16_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,9 @@ minloc2_16_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n   index_type sstride;\n   index_type extent;\n   const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_INTEGER_1 *minval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -63,15 +62,16 @@ minloc2_16_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  minval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) < 0)\n+      if (minval == NULL || (back ? compare_fcn (src, minval, len) <= 0 :\n+      \t \t    \t    \t    compare_fcn (src, minval, len) < 0))\n       {\n \t ret = i;\n-\t maxval = src;\n+\t minval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -96,7 +96,6 @@ mminloc2_16_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -134,7 +133,9 @@ mminloc2_16_s1 (gfc_array_s1 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) <= 0 :\n+      \t \t    \t    compare_fcn (src, maxval, len) < 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "4b0b873bd18356f047f08b067b51b54088d50255", "filename": "libgfortran/generated/minloc2_16_s4.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_16_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,9 @@ minloc2_16_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n   index_type sstride;\n   index_type extent;\n   const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_INTEGER_4 *minval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -63,15 +62,16 @@ minloc2_16_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  minval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) < 0)\n+      if (minval == NULL || (back ? compare_fcn (src, minval, len) <= 0 :\n+      \t \t    \t    \t    compare_fcn (src, minval, len) < 0))\n       {\n \t ret = i;\n-\t maxval = src;\n+\t minval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -96,7 +96,6 @@ mminloc2_16_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -134,7 +133,9 @@ mminloc2_16_s4 (gfc_array_s4 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) <= 0 :\n+      \t \t    \t    compare_fcn (src, maxval, len) < 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "f4c8bb31e61ac0f32f7c65386a0bb4c7664f18bb", "filename": "libgfortran/generated/minloc2_4_s1.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_4_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,9 @@ minloc2_4_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n   index_type sstride;\n   index_type extent;\n   const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_INTEGER_1 *minval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -63,15 +62,16 @@ minloc2_4_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  minval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) < 0)\n+      if (minval == NULL || (back ? compare_fcn (src, minval, len) <= 0 :\n+      \t \t    \t    \t    compare_fcn (src, minval, len) < 0))\n       {\n \t ret = i;\n-\t maxval = src;\n+\t minval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -96,7 +96,6 @@ mminloc2_4_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -134,7 +133,9 @@ mminloc2_4_s1 (gfc_array_s1 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) <= 0 :\n+      \t \t    \t    compare_fcn (src, maxval, len) < 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "8e973f0b1d003633de0115b275aa76f56c2f3eeb", "filename": "libgfortran/generated/minloc2_4_s4.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_4_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,9 @@ minloc2_4_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n   index_type sstride;\n   index_type extent;\n   const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_INTEGER_4 *minval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -63,15 +62,16 @@ minloc2_4_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  minval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) < 0)\n+      if (minval == NULL || (back ? compare_fcn (src, minval, len) <= 0 :\n+      \t \t    \t    \t    compare_fcn (src, minval, len) < 0))\n       {\n \t ret = i;\n-\t maxval = src;\n+\t minval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -96,7 +96,6 @@ mminloc2_4_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -134,7 +133,9 @@ mminloc2_4_s4 (gfc_array_s4 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) <= 0 :\n+      \t \t    \t    compare_fcn (src, maxval, len) < 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "44b65bf24af8304bed223b72ec626af55cf6514a", "filename": "libgfortran/generated/minloc2_8_s1.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_8_s1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,9 @@ minloc2_8_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n   index_type sstride;\n   index_type extent;\n   const GFC_INTEGER_1 *src;\n-  const GFC_INTEGER_1 *maxval;\n+  const GFC_INTEGER_1 *minval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -63,15 +62,16 @@ minloc2_8_s1 (gfc_array_s1 * const restrict array, GFC_LOGICAL_4 back,\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  minval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) < 0)\n+      if (minval == NULL || (back ? compare_fcn (src, minval, len) <= 0 :\n+      \t \t    \t    \t    compare_fcn (src, minval, len) < 0))\n       {\n \t ret = i;\n-\t maxval = src;\n+\t minval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -96,7 +96,6 @@ mminloc2_8_s1 (gfc_array_s1 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -134,7 +133,9 @@ mminloc2_8_s1 (gfc_array_s1 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) <= 0 :\n+      \t \t    \t    compare_fcn (src, maxval, len) < 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "f6f9341bcbb5ab2ab04833d7f9db38bb931303ed", "filename": "libgfortran/generated/minloc2_8_s4.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminloc2_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_8_s4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,9 @@ minloc2_8_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n   index_type sstride;\n   index_type extent;\n   const GFC_INTEGER_4 *src;\n-  const GFC_INTEGER_4 *maxval;\n+  const GFC_INTEGER_4 *minval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -63,15 +62,16 @@ minloc2_8_s4 (gfc_array_s4 * const restrict array, GFC_LOGICAL_4 back,\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  minval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) < 0)\n+      if (minval == NULL || (back ? compare_fcn (src, minval, len) <= 0 :\n+      \t \t    \t    \t    compare_fcn (src, minval, len) < 0))\n       {\n \t ret = i;\n-\t maxval = src;\n+\t minval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -96,7 +96,6 @@ mminloc2_8_s4 (gfc_array_s4 * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -134,7 +133,9 @@ mminloc2_8_s4 (gfc_array_s4 * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) <= 0 :\n+      \t \t    \t    compare_fcn (src, maxval, len) < 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "d78c04603d03d9c56677a1d77d500091ac71f14f", "filename": "libgfortran/generated/minval_i1.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ minval_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ minval_i1 (gfc_array_i1 * const restrict retarray,\n \t  *dest = GFC_INTEGER_1_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_1_QUIET_NAN)\n \t\tif (*src <= result)\n@@ -236,9 +234,6 @@ mminval_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "1dc3cf57281c2d40f9b51d1e1ee95110140b6488", "filename": "libgfortran/generated/minval_i16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ minval_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ minval_i16 (gfc_array_i16 * const restrict retarray,\n \t  *dest = GFC_INTEGER_16_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_16_QUIET_NAN)\n \t\tif (*src <= result)\n@@ -236,9 +234,6 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "ca8f11028e124c783e314a7e67bb746aa2d82281", "filename": "libgfortran/generated/minval_i2.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ minval_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ minval_i2 (gfc_array_i2 * const restrict retarray,\n \t  *dest = GFC_INTEGER_2_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_2_QUIET_NAN)\n \t\tif (*src <= result)\n@@ -236,9 +234,6 @@ mminval_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "59fc3b6a5be2dc7d15dafa0e3c15319fbfc217e8", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ minval_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ minval_i4 (gfc_array_i4 * const restrict retarray,\n \t  *dest = GFC_INTEGER_4_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_4_QUIET_NAN)\n \t\tif (*src <= result)\n@@ -236,9 +234,6 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "7f6e5de483d660a280e0c018d7010e482ada9c47", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ minval_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ minval_i8 (gfc_array_i8 * const restrict retarray,\n \t  *dest = GFC_INTEGER_8_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_INTEGER_8_QUIET_NAN)\n \t\tif (*src <= result)\n@@ -236,9 +234,6 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "5a91dd23f4e14f894f5213d2d356eae74b2277f8", "filename": "libgfortran/generated/minval_r10.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ minval_r10 (gfc_array_r10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ minval_r10 (gfc_array_r10 * const restrict retarray,\n \t  *dest = GFC_REAL_10_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_10_QUIET_NAN)\n \t\tif (*src <= result)\n@@ -236,9 +234,6 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "3580e3098353994bf6a55968049848c08271c224", "filename": "libgfortran/generated/minval_r16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ minval_r16 (gfc_array_r16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ minval_r16 (gfc_array_r16 * const restrict retarray,\n \t  *dest = GFC_REAL_16_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_16_QUIET_NAN)\n \t\tif (*src <= result)\n@@ -236,9 +234,6 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "d5c191e1b8cff452751ebb21742cf7a84be3ab41", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ minval_r4 (gfc_array_r4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ minval_r4 (gfc_array_r4 * const restrict retarray,\n \t  *dest = GFC_REAL_4_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_4_QUIET_NAN)\n \t\tif (*src <= result)\n@@ -236,9 +234,6 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "b53093c53ec7ba4846c2a14856230a7788487f0b", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ minval_r8 (gfc_array_r8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -158,8 +154,10 @@ minval_r8 (gfc_array_r8 * const restrict retarray,\n \t  *dest = GFC_REAL_8_HUGE;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n #if defined (GFC_REAL_8_QUIET_NAN)\n \t\tif (*src <= result)\n@@ -236,9 +234,6 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "7e24f36acb9ed0e9d563dcb6d13542df724e0ced", "filename": "libgfortran/generated/norm2_r10.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fnorm2_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fnorm2_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ norm2_r10 (gfc_array_r10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -159,8 +155,10 @@ norm2_r10 (gfc_array_r10 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n \t  if (*src != 0)\n \t    {"}, {"sha": "e796d642d97d154a71945b4caf8a2e6f4490a02d", "filename": "libgfortran/generated/norm2_r16.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fnorm2_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fnorm2_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -58,10 +58,6 @@ norm2_r16 (gfc_array_r16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -163,8 +159,10 @@ norm2_r16 (gfc_array_r16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n \t  if (*src != 0)\n \t    {"}, {"sha": "313bda300fab7d89397b2922c81cbe8b54f976e5", "filename": "libgfortran/generated/norm2_r4.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fnorm2_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fnorm2_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ norm2_r4 (gfc_array_r4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -159,8 +155,10 @@ norm2_r4 (gfc_array_r4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n \t  if (*src != 0)\n \t    {"}, {"sha": "140e93a52707ecb0aa7b76c4b5f21f6a4596a5ab", "filename": "libgfortran/generated/norm2_r8.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fnorm2_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fnorm2_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ norm2_r8 (gfc_array_r8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -159,8 +155,10 @@ norm2_r8 (gfc_array_r8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n \t  if (*src != 0)\n \t    {"}, {"sha": "7f62a936181f646408a0f909a46ceadf9edb0cf5", "filename": "libgfortran/generated/parity_l1.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fparity_l1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fparity_l1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ parity_l1 (gfc_array_l1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ parity_l1 (gfc_array_l1 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result = result != *src;\n \t      }"}, {"sha": "5b2cb386d31d0e326e5291bec4a3029edb3ab889", "filename": "libgfortran/generated/parity_l16.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fparity_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fparity_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ parity_l16 (gfc_array_l16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ parity_l16 (gfc_array_l16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result = result != *src;\n \t      }"}, {"sha": "daf56b14aa1eff6ca127782403400718860873fb", "filename": "libgfortran/generated/parity_l2.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fparity_l2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fparity_l2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ parity_l2 (gfc_array_l2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ parity_l2 (gfc_array_l2 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result = result != *src;\n \t      }"}, {"sha": "3ddb70e622f21a6173c94a02439e82d8df535989", "filename": "libgfortran/generated/parity_l4.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fparity_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fparity_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ parity_l4 (gfc_array_l4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ parity_l4 (gfc_array_l4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result = result != *src;\n \t      }"}, {"sha": "ac1ae43c8ae720a8b7a45adfaa3c3d397d056660", "filename": "libgfortran/generated/parity_l8.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fparity_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fparity_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fparity_l8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ parity_l8 (gfc_array_l8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ parity_l8 (gfc_array_l8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result = result != *src;\n \t      }"}, {"sha": "bd41da8beed20ff2bf0587a93caf99f29bab4e5a", "filename": "libgfortran/generated/product_c10.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_c10 (gfc_array_c10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_c10 (gfc_array_c10 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "47f6dc016f202a7b5bf7e0d31c5be992301c68bd", "filename": "libgfortran/generated/product_c16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_c16 (gfc_array_c16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_c16 (gfc_array_c16 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "d3d705b36b9e18ac255cbc9d57bf52c8512e89b8", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_c4 (gfc_array_c4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_c4 (gfc_array_c4 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "2ff0e8ca9e9d228de05c72dbee2f5117b83b5c29", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_c8 (gfc_array_c8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_c8 (gfc_array_c8 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "73cbbeb13064fd40bec6666f5b04d5e604006394", "filename": "libgfortran/generated/product_i1.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_i1 (gfc_array_i1 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "cefa13f202782eb4a6eb5bc6e1901ad62b650997", "filename": "libgfortran/generated/product_i16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_i16 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "b135023b261510d8cee8e295f493778a248fa4b5", "filename": "libgfortran/generated/product_i2.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_i2 (gfc_array_i2 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "78a513bfbc8057c4fec38757ebce136e290d51fe", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_i4 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "044c50663615cd49eaf9a59a565c4a7239b2a7ec", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_i8 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "067890ebfa768ffe1fbdc64610f7703a30d31ade", "filename": "libgfortran/generated/product_r10.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_r10 (gfc_array_r10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_r10 (gfc_array_r10 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "2641379f02f72219e01bb4b8ee9002331e486405", "filename": "libgfortran/generated/product_r16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_r16 (gfc_array_r16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_r16 (gfc_array_r16 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "6f104b2ebbaa076df9ddc1d1d09d4071fb26ee76", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_r4 (gfc_array_r4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_r4 (gfc_array_r4 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "d70f88c41e9c2cae7de6efc9b400e2039797c90d", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ product_r8 (gfc_array_r8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ product_r8 (gfc_array_r8 * const restrict retarray,\n \t  *dest = 1;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result *= *src;\n \t      }\n@@ -222,9 +220,6 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "31d804973766c21a25bcd4e9de3942288662a497", "filename": "libgfortran/generated/sum_c10.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_c10 (gfc_array_c10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_c10 (gfc_array_c10 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_c10 (gfc_array_c10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "f9d5c1ec3fe0c8f3e27ff907166fb4010a977cd7", "filename": "libgfortran/generated/sum_c16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_c16 (gfc_array_c16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_c16 (gfc_array_c16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_c16 (gfc_array_c16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "66872ddbc04b61813624c011f2ac25b2a2287962", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_c4 (gfc_array_c4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_c4 (gfc_array_c4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_c4 (gfc_array_c4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "9d0e57fdf27baba7d829bb45323a0557e99d3b73", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_c8 (gfc_array_c8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_c8 (gfc_array_c8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_c8 (gfc_array_c8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "7fe696bc1876fe01a46356550df03d2b9db36d21", "filename": "libgfortran/generated/sum_i1.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i1.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_i1 (gfc_array_i1 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_i1 (gfc_array_i1 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "f1840d996bce98ac7410d40186d60a78570e86b7", "filename": "libgfortran/generated/sum_i16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_i16 (gfc_array_i16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "f8e453b68fee8fa041de075aeae2d5c628b633dc", "filename": "libgfortran/generated/sum_i2.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i2.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_i2 (gfc_array_i2 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_i2 (gfc_array_i2 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "e8dae17c81b66f13f652affa48287f6b8453cfb5", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_i4 (gfc_array_i4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "0abbaf8262289512b330cd3a052dd10fb998f1df", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_i8 (gfc_array_i8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "012909bcaba5ad9f15c15c32d2023f9bdd92dd22", "filename": "libgfortran/generated/sum_r10.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r10.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_r10 (gfc_array_r10 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_r10 (gfc_array_r10 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "23420b88737312c8499bc2245a95017ff7265fa6", "filename": "libgfortran/generated/sum_r16.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r16.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_r16 (gfc_array_r16 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_r16 (gfc_array_r16 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "09d8f05bf7480630ee075b9612e2579368b2851e", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_r4 (gfc_array_r4 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_r4 (gfc_array_r4 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "0f45648b9a8308f793220bedc082d9c30ce16639", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -51,10 +51,6 @@ sum_r8 (gfc_array_r8 * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -154,8 +150,10 @@ sum_r8 (gfc_array_r8 * const restrict retarray,\n \t  *dest = 0;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n \n   result += *src;\n \t      }\n@@ -222,9 +220,6 @@ msum_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "494d0626aac1364ec1caf304757f0278e290214e", "filename": "libgfortran/m4/iforeach-s.m4", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fiforeach-s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fiforeach-s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach-s.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -30,10 +30,6 @@ name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n-\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -139,9 +135,6 @@ m'name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray,\n   index_type n;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");"}, {"sha": "db063bf655e1bd19e69a2d4e307c1d02f3f9c0fb", "filename": "libgfortran/m4/iforeach.m4", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fiforeach.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fiforeach.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -21,7 +21,6 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n   index_type rank;\n   index_type n;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");\n@@ -66,8 +65,6 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n define(START_FOREACH_BLOCK,\n `  while (base)\n     {\n-      do\n-\t{\n \t  /* Implementation start.  */\n ')dnl\n define(FINISH_FOREACH_FUNCTION,\n@@ -126,7 +123,6 @@ void\n   index_type n;\n   int mask_kind;\n \n-  assert(back == 0);\n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n     runtime_error (\"Rank of array needs to be > 0\");"}, {"sha": "a5767f58885fb82d3b5d7cce500a07ad6d73fd80", "filename": "libgfortran/m4/ifunction-s.m4", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fifunction-s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fifunction-s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction-s.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,10 +54,6 @@ void\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -226,9 +222,6 @@ m'name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "27bad4ece92d056ee18b52e88915d488a1615521", "filename": "libgfortran/m4/ifunction.m4", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fifunction.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fifunction.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -41,10 +41,6 @@ name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray,\n   index_type dim;\n   int continue_loop;\n \n-#ifdef HAVE_BACK_ARG\n-  assert(back == 0);\n-#endif\n-\n   /* Make dim zero based to avoid confusion.  */\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n   dim = (*pdim) - 1;\n@@ -144,8 +140,10 @@ define(START_ARRAY_BLOCK,\n \t  *dest = '$1`;\n \telse\n \t  {\n+#if ! defined HAVE_BACK_ARG\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n+#endif\n ')dnl\n define(FINISH_ARRAY_FUNCTION,\n `\t      }\n@@ -212,9 +210,6 @@ m'name`'rtype_qual`_'atype_code` ('rtype` * const restrict retarray,\n   index_type mdelta;\n   int mask_kind;\n \n-#ifdef HAVE_BACK_ARG\n-  assert (back == 0);\n-#endif\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n "}, {"sha": "ad19885ff90875ea6f4e57de777cf332edbcc12f", "filename": "libgfortran/m4/maxloc0.m4", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fmaxloc0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fmaxloc0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc0.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -43,8 +43,6 @@ FOREACH_FUNCTION(\n     maxval = atype_min;\n #endif',\n `#if defined('atype_nan`)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -63,16 +61,29 @@ FOREACH_FUNCTION(\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base > maxval)\n-\t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }')\n-\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }')\n MASKED_FOREACH_FUNCTION(\n `  atype_name maxval;\n    int fast = 0;\n@@ -82,9 +93,7 @@ MASKED_FOREACH_FUNCTION(\n #else\n     maxval = atype_min;\n #endif',\n-`\t}\n-      while (0);\n-      if (unlikely (!fast))\n+`      if (unlikely (!fast))\n \t{\n \t  do\n \t    {\n@@ -111,14 +120,28 @@ MASKED_FOREACH_FUNCTION(\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base > maxval)\n+      else\n+        if (back)\n+\t  do\n \t    {\n-\t      maxval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }')\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }')\n \n SCALAR_FOREACH_FUNCTION(`0')\n #endif"}, {"sha": "b20233534f8fc52f07ec224c84317dcacf904ce2", "filename": "libgfortran/m4/maxloc0s.m4", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fmaxloc0s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fmaxloc0s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc0s.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -38,9 +38,10 @@ include(iforeach-s.m4)dnl\n \n FOREACH_FUNCTION(\n `  const atype_name *maxval;\n-   maxval = base;'\n+   maxval = NULL;'\n ,\n-`  if (compare_fcn (base, maxval, len) > 0)\n+`    if (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0 :\n+     \t\t   \t   \t   compare_fcn (base, maxval, len) > 0))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)\n@@ -52,7 +53,9 @@ MASKED_FOREACH_FUNCTION(\n \n   maxval = NULL;'\n ,\n-`  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+`  if (*mbase &&\n+        (maxval == NULL || (back ? compare_fcn (base, maxval, len) >= 0:\n+\t\t   \t   \t   compare_fcn (base, maxval, len) > 0)))\n     {\n       maxval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "811f7fdb80d94eb52511e1ae79a7adf7fe79ce77", "filename": "libgfortran/m4/maxloc1.m4", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fmaxloc1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fmaxloc1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc1.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -42,17 +42,21 @@ ARRAY_FUNCTION(0,\n #endif\n \tresult = 1;',\n `#if defined ('atype_nan`)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n \t\tif (*src >= maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (rtype_name)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n+#else\n+\t    n = 0;\n+#endif\n \t    for (; n < len; n++, src += delta)\n \t      {\n-#endif\n-\t\tif (*src > maxval)\n+\t\tif (back ? *src >= maxval : *src > maxval)\n \t\t  {\n \t\t    maxval = *src;\n \t\t    result = (rtype_name)n + 1;\n@@ -88,13 +92,23 @@ MASKED_ARRAY_FUNCTION(0,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src > maxval)\n-\t\t  {\n-\t\t    maxval = *src;\n-\t\t    result = (rtype_name)n + 1;\n-\t\t  }')\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (rtype_name)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (rtype_name)n + 1;\n+\t\t    }')\n \n SCALAR_ARRAY_FUNCTION(0)\n "}, {"sha": "8b9333983705bd52be0584f15010d6b0389e4ede", "filename": "libgfortran/m4/maxloc1s.m4", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fmaxloc1s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fmaxloc1s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc1s.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -34,9 +34,10 @@ include(ifunction-s.m4)dnl\n \n ARRAY_FUNCTION(0,\n `\tconst atype_name *maxval;\n-\tmaxval = base;\n-\tresult = 1;',\n-`\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\tmaxval = NULL;\n+\tresult = 0;',\n+`\t\tif (maxval == NULL || (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (rtype_name)n + 1;\n@@ -55,7 +56,8 @@ MASKED_ARRAY_FUNCTION(0,\n \t    }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, maxval, string_len) >= 0 :\n+\t\t   \t     \t     compare_fcn (src, maxval, string_len) > 0))\n \t\t  {\n \t\t    maxval = src;\n \t\t    result = (rtype_name)n + 1;"}, {"sha": "b30e257bfc34471a1de443a9382737d7f9dc4cde", "filename": "libgfortran/m4/maxloc2s.m4", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fmaxloc2s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fmaxloc2s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc2s.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -54,7 +54,6 @@ export_proto('name`'rtype_qual`_'atype_code`);\n   const 'atype_name` *maxval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -63,15 +62,16 @@ export_proto('name`'rtype_qual`_'atype_code`);\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  maxval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) > 0)\n+      if (maxval == NULL || (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t    \t    compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -96,7 +96,6 @@ m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -134,7 +133,8 @@ m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) >= 0 :\n+      \t \t    \t   compare_fcn (src, maxval, len) > 0))\n       {\n \t ret = i;\n \t maxval = src;"}, {"sha": "44174cf03fdabe9f192d6c044bb80293ad9adf31", "filename": "libgfortran/m4/minloc0.m4", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fminloc0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fminloc0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc0.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -43,8 +43,6 @@ FOREACH_FUNCTION(\n     minval = atype_max;\n #endif',\n `#if defined('atype_nan`)\n-\t}\n-      while (0);\n       if (unlikely (!fast))\n \t{\n \t  do\n@@ -63,16 +61,29 @@ FOREACH_FUNCTION(\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n+      else\n #endif\n-\t  if (*base < minval)\n+    if (back)\n+      do\n+\t{\n+\t  if (unlikely (*base <= minval))\n \t    {\n \t      minval = *base;\n \t      for (n = 0; n < rank; n++)\n \t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+    else\n+      do\n+        {\n+\t  if (unlikely (*base < minval))\n+\t    {\n+\t      minval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t        dest[n * dstride] = count[n] + 1;\n \t    }')\n-\n MASKED_FOREACH_FUNCTION(\n `  atype_name minval;\n    int fast = 0;\n@@ -82,9 +93,7 @@ MASKED_FOREACH_FUNCTION(\n #else\n     minval = atype_max;\n #endif',\n-`\t}\n-      while (0);\n-      if (unlikely (!fast))\n+`      if (unlikely (!fast))\n \t{\n \t  do\n \t    {\n@@ -111,14 +120,27 @@ MASKED_FOREACH_FUNCTION(\n \t  if (likely (fast))\n \t    continue;\n \t}\n-      else do\n-\t{\n-\t  if (*mbase && *base < minval)\n+        else\n+        if (back)\n+\t  do\n \t    {\n-\t      minval = *base;\n-\t      for (n = 0; n < rank; n++)\n-\t\tdest[n * dstride] = count[n] + 1;\n-\t    }')\n-\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n+\t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}')\n SCALAR_FOREACH_FUNCTION(`0')\n #endif"}, {"sha": "65d11ef62a1eb66c873c3e85d86d28c26b400f74", "filename": "libgfortran/m4/minloc0s.m4", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fminloc0s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fminloc0s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc0s.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -38,9 +38,10 @@ include(iforeach-s.m4)dnl\n \n FOREACH_FUNCTION(\n `  const atype_name *minval;\n-   minval = base;'\n+   minval = NULL;'\n ,\n-`  if (compare_fcn (base, minval, len) < 0)\n+`    if (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t   compare_fcn (base, minval, len) < 0))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)\n@@ -52,7 +53,9 @@ MASKED_FOREACH_FUNCTION(\n \n   minval = NULL;'\n ,\n-`  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+`  if (*mbase &&\n+      (minval == NULL || (back ? compare_fcn (base, minval, len) <= 0 :\n+       \t \t    \t    \t compare_fcn (base, minval, len) < 0)))\n     {\n       minval = base;\n       for (n = 0; n < rank; n++)"}, {"sha": "a83156eaa5386400e13d1a63a9d0aa5bd28ab208", "filename": "libgfortran/m4/minloc1.m4", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fminloc1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fminloc1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc1.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -42,21 +42,35 @@ ARRAY_FUNCTION(0,\n #endif\n \tresult = 1;',\n `#if defined ('atype_nan`)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n \t\tif (*src <= minval)\n \t\t  {\n \t\t    minval = *src;\n \t\t    result = (rtype_name)n + 1;\n \t\t    break;\n \t\t  }\n \t      }\n-\t    for (; n < len; n++, src += delta)\n-\t      {\n+#else\n+\t    n = 0;\n #endif\n-\t\tif (*src < minval)\n-\t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (rtype_name)n + 1;\n-\t\t  }')\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (rtype_name)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (rtype_name) n + 1;\n+\t\t    }')\n \n MASKED_ARRAY_FUNCTION(0,\n `\tatype_name minval;\n@@ -88,13 +102,23 @@ MASKED_ARRAY_FUNCTION(0,\n \t      result = result2;\n \t    else\n #endif\n-\t    for (; n < len; n++, src += delta, msrc += mdelta)\n-\t      {\n-\t\tif (*msrc && *src < minval)\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (rtype_name)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n \t\t  {\n-\t\t    minval = *src;\n-\t\t    result = (rtype_name)n + 1;\n-\t\t  }', `')\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (rtype_name) n + 1;\n+\t\t      }')\n \n SCALAR_ARRAY_FUNCTION(0)\n "}, {"sha": "e74e2781a500980f7d7eb19eb5c5fd59496a2589", "filename": "libgfortran/m4/minloc1s.m4", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fminloc1s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fminloc1s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc1s.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -34,9 +34,10 @@ include(ifunction-s.m4)dnl\n \n ARRAY_FUNCTION(0,\n `\tconst atype_name *minval;\n-\tminval = base;\n-\tresult = 1;',\n-`\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\tminval = NULL;\n+\tresult = 0;',\n+`\t\tif (minval == NULL || (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t      \t      \t      compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (rtype_name)n + 1;\n@@ -55,7 +56,8 @@ MASKED_ARRAY_FUNCTION(0,\n             }\n \t    for (; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n-\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\tif (*msrc && (back ? compare_fcn (src, minval, string_len) <= 0 :\n+\t\t   \t     \t     compare_fcn (src, minval, string_len) < 0))\n \t\t  {\n \t\t    minval = src;\n \t\t    result = (rtype_name)n + 1;"}, {"sha": "0cdb2a550890946b8b2f22f94b9f01a6860796cb", "filename": "libgfortran/m4/minloc2s.m4", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fminloc2s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b573f931988b43a322ee454241b2af3a74f2fa84/libgfortran%2Fm4%2Fminloc2s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc2s.m4?ref=b573f931988b43a322ee454241b2af3a74f2fa84", "patch": "@@ -52,10 +52,9 @@ export_proto('name`'rtype_qual`_'atype_code`);\n   index_type sstride;\n   index_type extent;\n   const 'atype_name` *src;\n-  const 'atype_name` *maxval;\n+  const 'atype_name` *minval;\n   index_type i;\n \n-  assert(back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -64,15 +63,16 @@ export_proto('name`'rtype_qual`_'atype_code`);\n \n   ret = 1;\n   src = array->base_addr;\n-  maxval = src;\n-  for (i=2; i<=extent; i++)\n+  minval = NULL;\n+  for (i=1; i<=extent; i++)\n     {\n-      src += sstride;\n-      if (compare_fcn (src, maxval, len) < 0)\n+      if (minval == NULL || (back ? compare_fcn (src, minval, len) <= 0 :\n+      \t \t    \t    \t    compare_fcn (src, minval, len) < 0))\n       {\n \t ret = i;\n-\t maxval = src;\n+\t minval = src;\n       }\n+      src += sstride;\n     }\n   return ret;\n }\n@@ -97,7 +97,6 @@ m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n   int mask_kind;\n   index_type mstride;\n \n-  assert (back == 0);\n   extent = GFC_DESCRIPTOR_EXTENT(array,0);\n   if (extent <= 0)\n     return 0;\n@@ -135,7 +134,9 @@ m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n \n   for (i=j+1; i<=extent; i++)\n     {\n-      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+\n+      if (*mbase && (back ? compare_fcn (src, maxval, len) <= 0 :\n+      \t \t    \t    compare_fcn (src, maxval, len) < 0))\n       {\n \t ret = i;\n \t maxval = src;"}]}