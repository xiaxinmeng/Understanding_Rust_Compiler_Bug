{"sha": "ea976606bee170bd19fa10737586834abc87189a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE5NzY2MDZiZWUxNzBiZDE5ZmExMDczNzU4NjgzNGFiYzg3MTg5YQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2003-01-26T09:33:46Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2003-01-26T09:33:46Z"}, "message": "fp-bit.h: Define macros for TFmode floating-point constants in IEEE quad TFmode type.\n\n* config/fp-bit.h: Define macros for TFmode floating-point\nconstants in IEEE quad TFmode type.  Declare functions according\nto L_ macros.\n(TMODES): Define if __LDBL_MANT_DIG__ is 113.\n(TFtype, TItype, UTItype): Define if TMODES is defined.\n(MAX_UDI_INT, MAX_DI_INT, BITS_PER_DI): Likewise.\n(F_T_BITOFF, D_T_BITOFF): Define.\n(IMPLICIT_1, IMPLICIT_2): Cast constants to types that are\nguaranteed to be wide enough.\n* config/fp-bit.c: Check for L_ macros for tf functions.\n(__thenan_tf): New.\n(nan): Adjust.\n(pack_d, unpack_d): Support IEEE 854 quad type.\n(_fpmul_parts): Support TFmode.  Compute exponent adjustment\nfrom FRAC_NBITS, FRAC_BITS and NGARDS.\n(usi_to_float): Cast constants to be shifted to fractype\ninstead of assuming long long is wide enough.\n(sf_to_tf, df_to_tf, __make_tp, tf_to_df, tf_to_sf): New.\n\nFrom-SVN: r61835", "tree": {"sha": "ca6525c88d9e57f193a1975dabea02ab0c163062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca6525c88d9e57f193a1975dabea02ab0c163062"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea976606bee170bd19fa10737586834abc87189a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea976606bee170bd19fa10737586834abc87189a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea976606bee170bd19fa10737586834abc87189a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea976606bee170bd19fa10737586834abc87189a/comments", "author": null, "committer": null, "parents": [{"sha": "fd7fd61e8e8423d305dabd12ae6a90fdff3a969b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7fd61e8e8423d305dabd12ae6a90fdff3a969b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd7fd61e8e8423d305dabd12ae6a90fdff3a969b"}], "stats": {"total": 359, "additions": 300, "deletions": 59}, "files": [{"sha": "ebb7632017cfa6dab9abb64a1cd7fa5e1036ef1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea976606bee170bd19fa10737586834abc87189a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea976606bee170bd19fa10737586834abc87189a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea976606bee170bd19fa10737586834abc87189a", "patch": "@@ -1,3 +1,24 @@\n+2003-01-26  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* config/fp-bit.h: Define macros for TFmode floating-point\n+\tconstants in IEEE quad TFmode type.  Declare functions according\n+\tto L_ macros.\n+\t(TMODES): Define if __LDBL_MANT_DIG__ is 113.\n+\t(TFtype, TItype, UTItype): Define if TMODES is defined.\n+\t(MAX_UDI_INT, MAX_DI_INT, BITS_PER_DI): Likewise.\n+\t(F_T_BITOFF, D_T_BITOFF): Define.\n+\t(IMPLICIT_1, IMPLICIT_2): Cast constants to types that are\n+\tguaranteed to be wide enough.\n+\t* config/fp-bit.c: Check for L_ macros for tf functions.\n+\t(__thenan_tf): New.\n+\t(nan): Adjust.\n+\t(pack_d, unpack_d): Support IEEE 854 quad type.\n+\t(_fpmul_parts): Support TFmode.  Compute exponent adjustment\n+\tfrom FRAC_NBITS, FRAC_BITS and NGARDS.\n+\t(usi_to_float): Cast constants to be shifted to fractype\n+\tinstead of assuming long long is wide enough.\n+\t(sf_to_tf, df_to_tf, __make_tp, tf_to_df, tf_to_sf): New.\n+\n 2003-01-26  Andreas Jaeger  <aj@suse.de>\n \n \t* df.c: Remove prototype of unused function df_regno_rtl_debug."}, {"sha": "fc87dd311b7b12b5d8386b88f299345d9a082845", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 148, "deletions": 33, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea976606bee170bd19fa10737586834abc87189a/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea976606bee170bd19fa10737586834abc87189a/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=ea976606bee170bd19fa10737586834abc87189a", "patch": "@@ -1,6 +1,6 @@\n /* This is a software floating point library which can be used\n    for targets without hardware floating point. \n-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002\n+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n \n This file is free software; you can redistribute it and/or modify it\n@@ -132,6 +132,10 @@ void __lttf2 (void) { abort(); }\n const fp_number_type __thenan_sf = { CLASS_SNAN, 0, 0, {(fractype) 0} };\n #elif defined L_thenan_df\n const fp_number_type __thenan_df = { CLASS_SNAN, 0, 0, {(fractype) 0} };\n+#elif defined L_thenan_tf\n+const fp_number_type __thenan_tf = { CLASS_SNAN, 0, 0, {(fractype) 0} };\n+#elif defined TFLOAT\n+extern const fp_number_type __thenan_tf;\n #elif defined FLOAT\n extern const fp_number_type __thenan_sf;\n #else\n@@ -143,7 +147,9 @@ static fp_number_type *\n nan (void)\n {\n   /* Discard the const qualifier...  */\n-#ifdef FLOAT  \n+#ifdef TFLOAT\n+  return (fp_number_type *) (& __thenan_tf);\n+#elif defined FLOAT  \n   return (fp_number_type *) (& __thenan_sf);\n #else\n   return (fp_number_type *) (& __thenan_df);\n@@ -182,7 +188,7 @@ flip_sign ( fp_number_type *  x)\n \n extern FLO_type pack_d ( fp_number_type * );\n \n-#if defined(L_pack_df) || defined(L_pack_sf)\n+#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)\n FLO_type\n pack_d ( fp_number_type *  src)\n {\n@@ -324,18 +330,29 @@ pack_d ( fp_number_type *  src)\n #endif\n \n #if defined(FLOAT_WORD_ORDER_MISMATCH) && !defined(FLOAT)\n+#ifdef TFLOAT\n+  {\n+    qrtrfractype tmp1 = dst.words[0];\n+    qrtrfractype tmp2 = dst.words[1];\n+    dst.words[0] = dst.words[3];\n+    dst.words[1] = dst.words[2];\n+    dst.words[2] = tmp2;\n+    dst.words[3] = tmp1;\n+  }\n+#else\n   {\n     halffractype tmp = dst.words[0];\n     dst.words[0] = dst.words[1];\n     dst.words[1] = tmp;\n   }\n+#endif\n #endif\n \n   return dst.value;\n }\n #endif\n \n-#if defined(L_unpack_df) || defined(L_unpack_sf)\n+#if defined(L_unpack_df) || defined(L_unpack_sf) || defined(L_unpack_tf)\n void\n unpack_d (FLO_union_type * src, fp_number_type * dst)\n {\n@@ -349,8 +366,15 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n #if defined(FLOAT_WORD_ORDER_MISMATCH) && !defined(FLOAT)\n   FLO_union_type swapped;\n \n+#ifdef TFLOAT\n+  swapped.words[0] = src->words[3];\n+  swapped.words[1] = src->words[2];\n+  swapped.words[2] = src->words[1];\n+  swapped.words[3] = src->words[0];\n+#else\n   swapped.words[0] = src->words[1];\n   swapped.words[1] = src->words[0];\n+#endif\n   src = &swapped;\n #endif\n   \n@@ -359,7 +383,7 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n   exp = src->bits.exp;\n   sign = src->bits.sign;\n #else\n-  fraction = src->value_raw & ((((fractype)1) << FRACBITS) - (fractype)1);\n+  fraction = src->value_raw & ((((fractype)1) << FRACBITS) - 1);\n   exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);\n   sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;\n #endif\n@@ -429,7 +453,7 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n }\n #endif /* L_unpack_df || L_unpack_sf */\n \n-#if defined(L_addsub_sf) || defined(L_addsub_df)\n+#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)\n static fp_number_type *\n _fpadd_parts (fp_number_type * a,\n \t      fp_number_type * b,\n@@ -613,7 +637,7 @@ sub (FLO_type arg_a, FLO_type arg_b)\n }\n #endif /* L_addsub_sf || L_addsub_df */\n \n-#if defined(L_mul_sf) || defined(L_mul_df)\n+#if defined(L_mul_sf) || defined(L_mul_df) || defined(L_mul_tf)\n static inline __attribute__ ((__always_inline__)) fp_number_type *\n _fpmul_parts ( fp_number_type *  a,\n \t       fp_number_type *  b,\n@@ -662,7 +686,7 @@ _fpmul_parts ( fp_number_type *  a,\n   /* Calculate the mantissa by multiplying both numbers to get a\n      twice-as-wide number.  */\n   {\n-#if defined(NO_DI_MODE)\n+#if defined(NO_DI_MODE) || defined(TFLOAT)\n     {\n       fractype x = a->fraction.ll;\n       fractype ylow = b->fraction.ll;\n@@ -725,13 +749,9 @@ _fpmul_parts ( fp_number_type *  a,\n #endif\n   }\n \n-  tmp->normal_exp = a->normal_exp + b->normal_exp;\n+  tmp->normal_exp = a->normal_exp + b->normal_exp\n+    + FRAC_NBITS - (FRACBITS + NGARDS);\n   tmp->sign = a->sign != b->sign;\n-#ifdef FLOAT\n-  tmp->normal_exp += 2;\t\t/* ??????????????? */\n-#else\n-  tmp->normal_exp += 4;\t\t/* ??????????????? */\n-#endif\n   while (high >= IMPLICIT_2)\n     {\n       tmp->normal_exp++;\n@@ -805,7 +825,7 @@ multiply (FLO_type arg_a, FLO_type arg_b)\n }\n #endif /* L_mul_sf || L_mul_df */\n \n-#if defined(L_div_sf) || defined(L_div_df)\n+#if defined(L_div_sf) || defined(L_div_df) || defined(L_div_tf)\n static inline __attribute__ ((__always_inline__)) fp_number_type *\n _fpdiv_parts (fp_number_type * a,\n \t      fp_number_type * b)\n@@ -915,7 +935,8 @@ divide (FLO_type arg_a, FLO_type arg_b)\n }\n #endif /* L_div_sf || L_div_df */\n \n-#if defined(L_fpcmp_parts_sf) || defined(L_fpcmp_parts_df)\n+#if defined(L_fpcmp_parts_sf) || defined(L_fpcmp_parts_df) \\\n+    || defined(L_fpcmp_parts_tf)\n /* according to the demo, fpcmp returns a comparison with 0... thus\n    a<b -> -1\n    a==b -> 0\n@@ -1000,7 +1021,7 @@ __fpcmp_parts (fp_number_type * a, fp_number_type * b)\n }\n #endif\n \n-#if defined(L_compare_sf) || defined(L_compare_df)\n+#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)\n CMPtype\n compare (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1022,7 +1043,7 @@ compare (FLO_type arg_a, FLO_type arg_b)\n \n /* These should be optimized for their specific tasks someday.  */\n \n-#if defined(L_eq_sf) || defined(L_eq_df)\n+#if defined(L_eq_sf) || defined(L_eq_df) || defined(L_eq_tf)\n CMPtype\n _eq_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1043,7 +1064,7 @@ _eq_f2 (FLO_type arg_a, FLO_type arg_b)\n }\n #endif /* L_eq_sf || L_eq_df */\n \n-#if defined(L_ne_sf) || defined(L_ne_df)\n+#if defined(L_ne_sf) || defined(L_ne_df) || defined(L_ne_tf)\n CMPtype\n _ne_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1064,7 +1085,7 @@ _ne_f2 (FLO_type arg_a, FLO_type arg_b)\n }\n #endif /* L_ne_sf || L_ne_df */\n \n-#if defined(L_gt_sf) || defined(L_gt_df)\n+#if defined(L_gt_sf) || defined(L_gt_df) || defined(L_gt_tf)\n CMPtype\n _gt_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1085,7 +1106,7 @@ _gt_f2 (FLO_type arg_a, FLO_type arg_b)\n }\n #endif /* L_gt_sf || L_gt_df */\n \n-#if defined(L_ge_sf) || defined(L_ge_df)\n+#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)\n CMPtype\n _ge_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1105,7 +1126,7 @@ _ge_f2 (FLO_type arg_a, FLO_type arg_b)\n }\n #endif /* L_ge_sf || L_ge_df */\n \n-#if defined(L_lt_sf) || defined(L_lt_df)\n+#if defined(L_lt_sf) || defined(L_lt_df) || defined(L_lt_tf)\n CMPtype\n _lt_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1126,7 +1147,7 @@ _lt_f2 (FLO_type arg_a, FLO_type arg_b)\n }\n #endif /* L_lt_sf || L_lt_df */\n \n-#if defined(L_le_sf) || defined(L_le_df)\n+#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)\n CMPtype\n _le_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1149,7 +1170,7 @@ _le_f2 (FLO_type arg_a, FLO_type arg_b)\n \n #endif /* ! US_SOFTWARE_GOFAST */\n \n-#if defined(L_unord_sf) || defined(L_unord_df)\n+#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)\n CMPtype\n _unord_f2 (FLO_type arg_a, FLO_type arg_b)\n {\n@@ -1167,7 +1188,7 @@ _unord_f2 (FLO_type arg_a, FLO_type arg_b)\n }\n #endif /* L_unord_sf || L_unord_df */\n \n-#if defined(L_si_to_sf) || defined(L_si_to_df)\n+#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)\n FLO_type\n si_to_float (SItype arg_a)\n {\n@@ -1195,7 +1216,7 @@ si_to_float (SItype arg_a)\n       else\n \tin.fraction.ll = arg_a;\n \n-      while (in.fraction.ll < (1LL << (FRACBITS + NGARDS)))\n+      while (in.fraction.ll < ((fractype)1 << (FRACBITS + NGARDS)))\n \t{\n \t  in.fraction.ll <<= 1;\n \t  in.normal_exp -= 1;\n@@ -1205,7 +1226,7 @@ si_to_float (SItype arg_a)\n }\n #endif /* L_si_to_sf || L_si_to_df */\n \n-#if defined(L_usi_to_sf) || defined(L_usi_to_df)\n+#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)\n FLO_type\n usi_to_float (USItype arg_a)\n {\n@@ -1222,12 +1243,12 @@ usi_to_float (USItype arg_a)\n       in.normal_exp = FRACBITS + NGARDS;\n       in.fraction.ll = arg_a;\n \n-      while (in.fraction.ll > (1LL << (FRACBITS + NGARDS)))\n+      while (in.fraction.ll > ((fractype)1 << (FRACBITS + NGARDS)))\n         {\n           in.fraction.ll >>= 1;\n           in.normal_exp += 1;\n         }\n-      while (in.fraction.ll < (1LL << (FRACBITS + NGARDS)))\n+      while (in.fraction.ll < ((fractype)1 << (FRACBITS + NGARDS)))\n \t{\n \t  in.fraction.ll <<= 1;\n \t  in.normal_exp -= 1;\n@@ -1237,7 +1258,7 @@ usi_to_float (USItype arg_a)\n }\n #endif\n \n-#if defined(L_sf_to_si) || defined(L_df_to_si)\n+#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)\n SItype\n float_to_si (FLO_type arg_a)\n {\n@@ -1265,8 +1286,8 @@ float_to_si (FLO_type arg_a)\n }\n #endif /* L_sf_to_si || L_df_to_si */\n \n-#if defined(L_sf_to_usi) || defined(L_df_to_usi)\n-#ifdef US_SOFTWARE_GOFAST\n+#if defined(L_sf_to_usi) || defined(L_df_to_usi) || defined(L_tf_to_usi)\n+#if defined US_SOFTWARE_GOFAST || defined(L_tf_to_usi)\n /* While libgcc2.c defines its own __fixunssfsi and __fixunsdfsi routines,\n    we also define them for GOFAST because the ones in libgcc2.c have the\n    wrong names and I'd rather define these here and keep GOFAST CYG-LOC's\n@@ -1305,7 +1326,7 @@ float_to_usi (FLO_type arg_a)\n #endif /* US_SOFTWARE_GOFAST */\n #endif /* L_sf_to_usi || L_df_to_usi */\n \n-#if defined(L_negate_sf) || defined(L_negate_df)\n+#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)\n FLO_type\n negate (FLO_type arg_a)\n {\n@@ -1361,6 +1382,21 @@ sf_to_df (SFtype arg_a)\n }\n #endif /* L_sf_to_df */\n \n+#if defined(L_sf_to_tf) && defined(TMODES)\n+TFtype\n+sf_to_tf (SFtype arg_a)\n+{\n+  fp_number_type in;\n+  FLO_union_type au;\n+\n+  au.value = arg_a;\n+  unpack_d (&au, &in);\n+\n+  return __make_tp (in.class, in.sign, in.normal_exp,\n+\t\t    ((UTItype) in.fraction.ll) << F_T_BITOFF);\n+}\n+#endif /* L_sf_to_df */\n+\n #endif /* ! FLOAT_ONLY */\n #endif /* FLOAT */\n \n@@ -1404,5 +1440,84 @@ df_to_sf (DFtype arg_a)\n }\n #endif /* L_df_to_sf */\n \n+#if defined(L_df_to_tf) && defined(TMODES) \\\n+    && !defined(FLOAT) && !defined(TFLOAT)\n+TFtype\n+df_to_tf (DFtype arg_a)\n+{\n+  fp_number_type in;\n+  FLO_union_type au;\n+\n+  au.value = arg_a;\n+  unpack_d (&au, &in);\n+\n+  return __make_tp (in.class, in.sign, in.normal_exp,\n+\t\t    ((UTItype) in.fraction.ll) << D_T_BITOFF);\n+}\n+#endif /* L_sf_to_df */\n+\n+#ifdef TFLOAT\n+#if defined(L_make_tf)\n+TFtype\n+__make_tp(fp_class_type class,\n+\t     unsigned int sign,\n+\t     int exp, \n+\t     UTItype frac)\n+{\n+  fp_number_type in;\n+\n+  in.class = class;\n+  in.sign = sign;\n+  in.normal_exp = exp;\n+  in.fraction.ll = frac;\n+  return pack_d (&in);\n+}\n+#endif /* L_make_tf */\n+\n+#if defined(L_tf_to_df)\n+DFtype\n+tf_to_df (TFtype arg_a)\n+{\n+  fp_number_type in;\n+  UDItype sffrac;\n+  FLO_union_type au;\n+\n+  au.value = arg_a;\n+  unpack_d (&au, &in);\n+\n+  sffrac = in.fraction.ll >> D_T_BITOFF;\n+\n+  /* We set the lowest guard bit in SFFRAC if we discarded any non\n+     zero bits.  */\n+  if ((in.fraction.ll & (((UTItype) 1 << D_T_BITOFF) - 1)) != 0)\n+    sffrac |= 1;\n+\n+  return __make_dp (in.class, in.sign, in.normal_exp, sffrac);\n+}\n+#endif /* L_tf_to_df */\n+\n+#if defined(L_tf_to_sf)\n+SFtype\n+tf_to_sf (TFtype arg_a)\n+{\n+  fp_number_type in;\n+  USItype sffrac;\n+  FLO_union_type au;\n+\n+  au.value = arg_a;\n+  unpack_d (&au, &in);\n+\n+  sffrac = in.fraction.ll >> F_T_BITOFF;\n+\n+  /* We set the lowest guard bit in SFFRAC if we discarded any non\n+     zero bits.  */\n+  if ((in.fraction.ll & (((UTItype) 1 << F_T_BITOFF) - 1)) != 0)\n+    sffrac |= 1;\n+\n+  return __make_fp (in.class, in.sign, in.normal_exp, sffrac);\n+}\n+#endif /* L_tf_to_sf */\n+#endif /* TFLOAT */\n+\n #endif /* ! FLOAT */\n #endif /* !EXTENDED_FLOAT_STUBS */"}, {"sha": "c146523b84dea02f6c73c30ac69af67e3e6e4578", "filename": "gcc/config/fp-bit.h", "status": "modified", "additions": 131, "deletions": 26, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea976606bee170bd19fa10737586834abc87189a/gcc%2Fconfig%2Ffp-bit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea976606bee170bd19fa10737586834abc87189a/gcc%2Fconfig%2Ffp-bit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.h?ref=ea976606bee170bd19fa10737586834abc87189a", "patch": "@@ -1,5 +1,5 @@\n /* Header file for fp-bit.c.  */\n-/* Copyright (C) 2000\n+/* Copyright (C) 2000, 2002, 2003\n    Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -87,12 +87,22 @@ Boston, MA 02111-1307, USA.  */\n #endif\n #endif /* ! FINE_GRAINED_LIBRARIES */\n \n+#if __LDBL_MANT_DIG__ == 113\n+# define TMODES\n+#endif\n+\n typedef float SFtype __attribute__ ((mode (SF)));\n typedef float DFtype __attribute__ ((mode (DF)));\n+#ifdef TMODES\n+typedef float TFtype __attribute__ ((mode (TF)));\n+#endif\n \n typedef int HItype __attribute__ ((mode (HI)));\n typedef int SItype __attribute__ ((mode (SI)));\n typedef int DItype __attribute__ ((mode (DI)));\n+#ifdef TMODES\n+typedef int TItype __attribute__ ((mode (TI)));\n+#endif\n \n /* The type of the result of a fp compare */\n #ifndef CMPtype\n@@ -102,16 +112,56 @@ typedef int DItype __attribute__ ((mode (DI)));\n typedef unsigned int UHItype __attribute__ ((mode (HI)));\n typedef unsigned int USItype __attribute__ ((mode (SI)));\n typedef unsigned int UDItype __attribute__ ((mode (DI)));\n+#ifdef TMODES\n+typedef unsigned int UTItype __attribute__ ((mode (TI)));\n+#endif\n \n #define MAX_USI_INT  (~(USItype)0)\n #define MAX_SI_INT   ((SItype) (MAX_USI_INT >> 1))\n #define BITS_PER_SI  (4 * BITS_PER_UNIT)\n+#ifdef TMODES\n+#define MAX_UDI_INT  (~(UDItype)0)\n+#define MAX_DI_INT   ((DItype) (MAX_UDI_INT >> 1))\n+#define BITS_PER_DI  (8 * BITS_PER_UNIT)\n+#endif\n \n #ifdef FLOAT_ONLY\n #define NO_DI_MODE\n #endif\n \n-#ifdef FLOAT\n+#ifdef TFLOAT\n+# ifndef TMODES\n+#  error \"TFLOAT requires long double to have 113 bits of mantissa\"\n+# endif\n+\n+#\tdefine PREFIXFPDP tp\n+#\tdefine PREFIXSFDF tf\n+#\tdefine NGARDS 10L /* Is this right? */\n+#\tdefine GARDROUND 0x1ff\n+#\tdefine GARDMASK  0x3ff\n+#\tdefine GARDMSB   0x200\n+#\tdefine FRAC_NBITS 128\n+\n+# if __LDBL_MANT_DIG__ == 113 /* IEEE quad */\n+#\tdefine EXPBITS 15\n+#\tdefine EXPBIAS 16383\n+#\tdefine EXPMAX (0x7fff)\n+#\tdefine QUIET_NAN ((TItype)0x8 << 108)\n+#\tdefine FRACHIGH  ((TItype)0x8 << 124)\n+#\tdefine FRACHIGH2 ((TItype)0xc << 124)\n+#\tdefine FRACBITS 112\n+# endif\n+\n+#\tdefine pack_d __pack_t\n+#\tdefine unpack_d __unpack_t\n+#\tdefine __fpcmp_parts __fpcmp_parts_t\n+\ttypedef UTItype fractype;\n+\ttypedef UDItype halffractype;\n+\ttypedef USItype qrtrfractype;\n+#define qrtrfractype qrtrfractype\n+\ttypedef TFtype FLO_type;\n+\ttypedef TItype intfrac;\n+#elif defined FLOAT\n #\tdefine NGARDS    7L\n #\tdefine GARDROUND 0x3f\n #\tdefine GARDMASK  0x7f\n@@ -157,7 +207,9 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n #endif /* FLOAT */\n \n #ifdef US_SOFTWARE_GOFAST\n-#\tifdef FLOAT\n+#\tifdef TFLOAT\n+#\t\terror \"GOFAST TFmode not supported\"\n+#\telif defined FLOAT\n #\t\tdefine add \t\tfpadd\n #\t\tdefine sub \t\tfpsub\n #\t\tdefine multiply \tfpmul\n@@ -170,8 +222,8 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n #\t\tdefine float_to_usi \tfptoui\n #\t\tdefine negate \t\t__negsf2\n #\t\tdefine sf_to_df\t\tfptodp\n-#\t\tdefine dptofp \t\tdptofp\n-#else\n+#\t\tdefine sf_to_tf\t\t__extendsftf2\n+#\telse\n #\t\tdefine add \t\tdpadd\n #\t\tdefine sub \t\tdpsub\n #\t\tdefine multiply \tdpmul\n@@ -184,9 +236,30 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n #\t\tdefine float_to_usi \tdptoul\n #\t\tdefine negate \t\t__negdf2\n #\t\tdefine df_to_sf \tdptofp\n+#\t\tdefine df_to_tf \t__extenddftf2\n #\tendif /* FLOAT */\n #else\n-#\tifdef FLOAT\n+#\tifdef TFLOAT\n+#\t\tdefine add \t\t__addtf3\n+#\t\tdefine sub \t\t__subtf3\n+#\t\tdefine multiply \t__multf3\n+#\t\tdefine divide \t\t__divtf3\n+#\t\tdefine compare \t\t__cmptf2\n+#\t\tdefine _eq_f2 \t\t__eqtf2\n+#\t\tdefine _ne_f2 \t\t__netf2\n+#\t\tdefine _gt_f2 \t\t__gttf2\n+#\t\tdefine _ge_f2 \t\t__getf2\n+#\t\tdefine _lt_f2 \t\t__lttf2\n+#\t\tdefine _le_f2 \t\t__letf2\n+#\t\tdefine _unord_f2\t__unordtf2\n+#\t\tdefine usi_to_float \t__floatunsitf\n+#\t\tdefine si_to_float \t__floatsitf\n+#\t\tdefine float_to_si \t__fixtfsi\n+#\t\tdefine float_to_usi \t__fixunstfsi\n+#\t\tdefine negate \t\t__negtf2\n+#\t\tdefine tf_to_sf\t\t__trunctfsf2\n+#\t\tdefine tf_to_df\t\t__trunctfdf2\n+#\telif defined FLOAT\n #\t\tdefine add \t\t__addsf3\n #\t\tdefine sub \t\t__subsf3\n #\t\tdefine multiply \t__mulsf3\n@@ -205,7 +278,8 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n #\t\tdefine float_to_usi \t__fixunssfsi\n #\t\tdefine negate \t\t__negsf2\n #\t\tdefine sf_to_df\t\t__extendsfdf2\n-#else\n+#\t\tdefine sf_to_tf\t\t__extendsftf2\n+#\telse\n #\t\tdefine add \t\t__adddf3\n #\t\tdefine sub \t\t__subdf3\n #\t\tdefine multiply \t__muldf3\n@@ -224,6 +298,7 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n #\t\tdefine float_to_usi \t__fixunsdfsi\n #\t\tdefine negate \t\t__negdf2\n #\t\tdefine df_to_sf\t\t__truncdfsf2\n+#\t\tdefine df_to_tf\t\t__extenddftf2\n #\tendif /* FLOAT */\n #endif /* US_SOFTWARE_GOFAST */\n \n@@ -241,10 +316,15 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n  */\n #define F_D_BITOFF (52+8-(23+7))\n \n+#ifdef TMODES\n+# define F_T_BITOFF (__LDBL_MANT_DIG__-1+10-(23+7))\n+# define D_T_BITOFF (__LDBL_MANT_DIG__-1+10-(52+8))\n+#endif\n+\n \n #define NORMAL_EXPMIN (-(EXPBIAS)+1)\n-#define IMPLICIT_1 (1LL<<(FRACBITS+NGARDS))\n-#define IMPLICIT_2 (1LL<<(FRACBITS+1+NGARDS))\n+#define IMPLICIT_1 ((fractype)1<<(FRACBITS+NGARDS))\n+#define IMPLICIT_2 ((fractype)1<<(FRACBITS+1+NGARDS))\n \n /* common types */\n \n@@ -282,7 +362,11 @@ typedef union\n   fractype value_raw;\n \n #ifndef FLOAT\n+# ifdef qrtrfractype\n+  qrtrfractype qwords[4];\n+# else\n   halffractype words[2];\n+# endif\n #endif\n \n #ifdef FLOAT_BIT_ORDER_MISMATCH\n@@ -317,82 +401,82 @@ FLO_union_type;\n \n /* Prototypes */\n \n-#if defined(L_pack_df) || defined(L_pack_sf)\n+#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)\n extern FLO_type pack_d (fp_number_type *);\n #endif\n \n extern void unpack_d (FLO_union_type *, fp_number_type *);\n \n-#if defined(L_addsub_sf) || defined(L_addsub_df)\n+#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)\n extern FLO_type add (FLO_type, FLO_type);\n extern FLO_type sub (FLO_type, FLO_type);\n #endif\n \n-#if defined(L_mul_sf) || defined(L_mul_df)\n+#if defined(L_mul_sf) || defined(L_mul_df) || defined(L_mul_tf)\n extern FLO_type multiply (FLO_type, FLO_type);\n #endif\n \n-#if defined(L_div_sf) || defined(L_div_df)\n+#if defined(L_div_sf) || defined(L_div_df) || defined(L_div_tf)\n extern FLO_type divide (FLO_type, FLO_type);\n #endif\n \n extern int __fpcmp_parts (fp_number_type *, fp_number_type *);\n \n-#if defined(L_compare_sf) || defined(L_compare_df)\n+#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compare_tf)\n extern CMPtype compare (FLO_type, FLO_type);\n #endif\n \n #ifndef US_SOFTWARE_GOFAST\n \n-#if defined(L_eq_sf) || defined(L_eq_df)\n+#if defined(L_eq_sf) || defined(L_eq_df) || defined(L_eq_tf)\n extern CMPtype _eq_f2 (FLO_type, FLO_type);\n #endif\n \n-#if defined(L_ne_sf) || defined(L_ne_df)\n+#if defined(L_ne_sf) || defined(L_ne_df) || defined(L_ne_tf)\n extern CMPtype _ne_f2 (FLO_type, FLO_type);\n #endif\n \n-#if defined(L_gt_sf) || defined(L_gt_df)\n+#if defined(L_gt_sf) || defined(L_gt_df) || defined(L_gt_tf)\n extern CMPtype _gt_f2 (FLO_type, FLO_type);\n #endif\n \n-#if defined(L_ge_sf) || defined(L_ge_df)\n+#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)\n extern CMPtype _ge_f2 (FLO_type, FLO_type);\n #endif\n \n-#if defined(L_lt_sf) || defined(L_lt_df)\n+#if defined(L_lt_sf) || defined(L_lt_df) || defined(L_lt_tf)\n extern CMPtype _lt_f2 (FLO_type, FLO_type);\n #endif\n \n-#if defined(L_le_sf) || defined(L_le_df)\n+#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)\n extern CMPtype _le_f2 (FLO_type, FLO_type);\n #endif\n \n-#if defined(L_unord_sf) || defined(L_unord_df)\n+#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)\n extern CMPtype _unord_f2 (FLO_type, FLO_type);\n #endif\n \n #endif /* ! US_SOFTWARE_GOFAST */\n \n-#if defined(L_si_to_sf) || defined(L_si_to_df)\n+#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)\n extern FLO_type si_to_float (SItype);\n #endif\n \n-#if defined(L_sf_to_si) || defined(L_df_to_si)\n+#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)\n extern SItype float_to_si (FLO_type);\n #endif\n \n-#if defined(L_sf_to_usi) || defined(L_df_to_usi)\n+#if defined(L_sf_to_usi) || defined(L_df_to_usi) || defined(L_tf_to_usi)\n #ifdef US_SOFTWARE_GOFAST\n extern USItype float_to_usi (FLO_type);\n #endif\n #endif\n \n-#if defined(L_usi_to_sf) || defined(L_usi_to_df)\n+#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)\n extern FLO_type usi_to_float (USItype);\n #endif\n \n-#if defined(L_negate_sf) || defined(L_negate_df)\n+#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)\n extern FLO_type negate (FLO_type);\n #endif\n \n@@ -405,6 +489,9 @@ extern DFtype __make_dp (fp_class_type, unsigned int, int, UDItype);\n #if defined(L_sf_to_df)\n extern DFtype sf_to_df (SFtype);\n #endif\n+#if defined(L_sf_to_tf) && defined(TMODES)\n+extern TFtype sf_to_tf (SFtype);\n+#endif\n #endif /* ! FLOAT_ONLY */\n #endif /* FLOAT */\n \n@@ -416,6 +503,24 @@ extern DFtype __make_dp (fp_class_type, unsigned int, int, UDItype);\n #if defined(L_df_to_sf)\n extern SFtype df_to_sf (DFtype);\n #endif\n+#if defined(L_df_to_tf) && defined(TMODES)\n+extern TFtype df_to_tf (DFtype);\n+#endif\n #endif /* ! FLOAT */\n \n+#ifdef TMODES\n+extern TFtype __make_tp (fp_class_type, unsigned int, int, UTItype);\n+#ifdef TFLOAT\n+#if defined(L_tf_to_sf)\n+extern SFtype tf_to_sf (TFtype);\n+#endif\n+#if defined(L_tf_to_df)\n+extern DFtype tf_to_df (TFtype);\n+#endif\n+#if defined(L_di_to_tf)\n+extern TFtype di_to_df (DItype);\n+#endif\n+#endif /* TFLOAT */\n+#endif /* TMODES */\n+\n #endif /* ! GCC_FP_BIT_H */"}]}