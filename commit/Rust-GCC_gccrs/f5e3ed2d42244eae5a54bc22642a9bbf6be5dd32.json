{"sha": "f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVlM2VkMmQ0MjI0NGVhZTVhNTRiYzIyNjQyYTliYmY2YmU1ZGQzMg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-03-19T11:13:32Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-03-19T11:13:32Z"}, "message": "Use C99 bool instead of enum try.\n\n2013-03-19  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* libgfortran.h: Include stdbool.h.\n\t(enum try): Remove.\n\t(notify_std): Change return type to bool.\n\t* intrinsics/chmod.c: Don't include stdbool.h.\n\t* intrinsics/execute_command_line.c: Likewise.\n\t* io/format.c: Likewise.\n\t* io/list_read.c (nml_parse_qualifier): Change return type to bool.\n\t(nml_read_obj): Likewise.\n\t(nml_get_obj_data): Likewise.\n\t* io/transfer.c (read_block_form): Fix comment.\n\t(write_buf): Change return type to bool.\n\t* io/write.c: Don't include stdbool.h.\n\t* io/write_float.def (output_float): Change return type to bool.\n\t(output_float_FMT_G_ ## x): Change type of result variable.\n\t* runtime/error.c (notify_std): Change return type to bool.\n\nFrom-SVN: r196791", "tree": {"sha": "dcc5c9502972eb9dff14e321035a33826c97e179", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcc5c9502972eb9dff14e321035a33826c97e179"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/comments", "author": null, "committer": null, "parents": [{"sha": "7469b1dc52d5cbd23c0b6e998adfe159c5034b28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7469b1dc52d5cbd23c0b6e998adfe159c5034b28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7469b1dc52d5cbd23c0b6e998adfe159c5034b28"}], "stats": {"total": 165, "additions": 87, "deletions": 78}, "files": [{"sha": "2a28f8405513a65b5cd2bb07d3423eb60402af34", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "patch": "@@ -1,3 +1,21 @@\n+2013-03-19  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* libgfortran.h: Include stdbool.h.\n+\t(enum try): Remove.\n+\t(notify_std): Change return type to bool.\n+\t* intrinsics/chmod.c: Don't include stdbool.h.\n+\t* intrinsics/execute_command_line.c: Likewise.\n+\t* io/format.c: Likewise.\n+\t* io/list_read.c (nml_parse_qualifier): Change return type to bool.\n+\t(nml_read_obj): Likewise.\n+\t(nml_get_obj_data): Likewise.\n+\t* io/transfer.c (read_block_form): Fix comment.\n+\t(write_buf): Change return type to bool.\n+\t* io/write.c: Don't include stdbool.h.\n+\t* io/write_float.def (output_float): Change return type to bool.\n+\t(output_float_FMT_G_ ## x): Change type of result variable.\n+\t* runtime/error.c (notify_std): Change return type to bool.\n+\n 2013-03-11  Tobias Burnus  <burnus@net-b.de>\n \n \t* io/transfer.c (read_block_direct): Correct condition."}, {"sha": "eca3e6a2231351eba28d254cad7e7065d5c5c8c6", "filename": "libgfortran/intrinsics/chmod.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fintrinsics%2Fchmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fintrinsics%2Fchmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fchmod.c?ref=f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "patch": "@@ -27,7 +27,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined(HAVE_SYS_STAT_H)\n \n-#include <stdbool.h>\n #include <string.h>\t/* For memcpy. */\n #include <sys/stat.h>\t/* For stat, chmod and umask.  */\n "}, {"sha": "fd9d4835cb28a0fafc2f2121400f803b2754975b", "filename": "libgfortran/intrinsics/execute_command_line.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fintrinsics%2Fexecute_command_line.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fintrinsics%2Fexecute_command_line.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fexecute_command_line.c?ref=f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "patch": "@@ -25,7 +25,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"libgfortran.h\"\n #include <string.h>\n-#include <stdbool.h>\n #include <stdlib.h>\n \n #ifdef HAVE_UNISTD_H"}, {"sha": "c64596baf52ba32200fc334eec0af0d7c171d043", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "patch": "@@ -31,7 +31,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"format.h\"\n #include <ctype.h>\n #include <string.h>\n-#include <stdbool.h>\n #include <stdlib.h>\n \n "}, {"sha": "22125be1afe254458687a93b1eda894674a0a3ba", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "patch": "@@ -2052,7 +2052,7 @@ void namelist_read (st_parameter_dt *dtp)\n /* Inputs a rank-dimensional qualifier, which can contain\n    singlets, doublets, triplets or ':' with the standard meanings.  */\n \n-static try\n+static bool\n nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t     array_loop_spec *ls, int rank, char *parse_err_msg,\n \t\t     size_t parse_err_msg_size,\n@@ -2079,7 +2079,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n   /* The next character in the stream should be the '('.  */\n \n   if ((c = next_char (dtp)) == EOF)\n-    return FAILURE;\n+    return false;\n \n   /* Process the qualifier, by dimension and triplet.  */\n \n@@ -2093,7 +2093,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \n \t  /* Process a potential sign.  */\n \t  if ((c = next_char (dtp)) == EOF)\n-\t    return FAILURE;\n+\t    return false;\n \t  switch (c)\n \t    {\n \t    case '-':\n@@ -2112,7 +2112,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t  for (;;)\n \t    {\n \t      if ((c = next_char (dtp)) == EOF)\n-\t\treturn FAILURE;\n+\t\treturn false;\n \n \t      switch (c)\n \t\t{\n@@ -2141,7 +2141,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\tcase ' ': case '\\t':\n \t\t  eat_spaces (dtp);\n \t\t  if ((c = next_char (dtp) == EOF))\n-\t\t    return FAILURE;\n+\t\t    return false;\n \t\t  break;\n \n \t\tdefault:\n@@ -2279,11 +2279,11 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n       ls[dim].idx = ls[dim].start;\n     }\n   eat_spaces (dtp);\n-  return SUCCESS;\n+  return true;\n \n err_ret:\n \n-  return FAILURE;\n+  return false;\n }\n \n static namelist_info *\n@@ -2467,7 +2467,7 @@ nml_query (st_parameter_dt *dtp, char c)\n    little data to be available.  On the other hand, too much data is an\n    error.  */\n \n-static try\n+static bool\n nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \t      namelist_info **pprev_nl, char *nml_err_msg,\n \t      size_t nml_err_msg_size, index_type clow, index_type chigh)\n@@ -2485,7 +2485,7 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n   /* This object not touched in name parsing.  */\n \n   if (!nl->touched)\n-    return SUCCESS;\n+    return true;\n \n   dtp->u.p.repeat_count = 0;\n   eat_spaces (dtp);\n@@ -2532,11 +2532,11 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n       if (--dtp->u.p.repeat_count <= 0)\n \t{\n \t  if (dtp->u.p.input_complete)\n-\t    return SUCCESS;\n+\t    return true;\n \t  if (dtp->u.p.at_eol)\n \t    finish_separator (dtp);\n \t  if (dtp->u.p.input_complete)\n-\t    return SUCCESS;\n+\t    return true;\n \n \t  dtp->u.p.saved_type = BT_UNKNOWN;\n \t  free_saved (dtp);\n@@ -2590,18 +2590,18 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \t\t cmp = cmp->next)\n \t      {\n \n-\t\tif (nml_read_obj (dtp, cmp, (index_type)(pdata - nl->mem_pos),\n+\t\tif (!nml_read_obj (dtp, cmp, (index_type)(pdata - nl->mem_pos),\n \t\t\t\t  pprev_nl, nml_err_msg, nml_err_msg_size,\n-\t\t\t\t  clow, chigh) == FAILURE)\n+\t\t\t\t  clow, chigh))\n \t\t  {\n \t\t    free (obj_name);\n-\t\t    return FAILURE;\n+\t\t    return false;\n \t\t  }\n \n \t\tif (dtp->u.p.input_complete)\n \t\t  {\n \t\t    free (obj_name);\n-\t\t    return SUCCESS;\n+\t\t    return true;\n \t\t  }\n \t      }\n \n@@ -2625,7 +2625,7 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n       if (dtp->u.p.nml_read_error)\n \t{\n \t  dtp->u.p.expanded_read = 0;\n-\t  return SUCCESS;\n+\t  return true;\n \t}\n \n       if (dtp->u.p.saved_type == BT_UNKNOWN)\n@@ -2711,11 +2711,11 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \t\t\"Repeat count too large for namelist object %s\", nl->var_name);\n       goto nml_err_ret;\n     }\n-  return SUCCESS;\n+  return true;\n \n nml_err_ret:\n \n-  return FAILURE;\n+  return false;\n }\n \n /* Parses the object name, including array and substring qualifiers.  It\n@@ -2725,7 +2725,7 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n    touched.  nml_read_obj is called at the end and this reads the data in\n    the manner specified by the object name.  */\n \n-static try\n+static bool\n nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \t\t  char *nml_err_msg, size_t nml_err_msg_size)\n {\n@@ -2743,32 +2743,32 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n   eat_separator (dtp);\n   if (dtp->u.p.input_complete)\n-    return SUCCESS;\n+    return true;\n \n   if (dtp->u.p.at_eol)\n     finish_separator (dtp);\n   if (dtp->u.p.input_complete)\n-    return SUCCESS;\n+    return true;\n \n   if ((c = next_char (dtp)) == EOF)\n-    return FAILURE;\n+    return false;\n   switch (c)\n     {\n     case '=':\n       if ((c = next_char (dtp)) == EOF)\n-\treturn FAILURE;\n+\treturn false;\n       if (c != '?')\n \t{\n \t  snprintf (nml_err_msg, nml_err_msg_size, \n \t\t    \"namelist read: misplaced = sign\");\n \t  goto nml_err_ret;\n \t}\n       nml_query (dtp, '=');\n-      return SUCCESS;\n+      return true;\n \n     case '?':\n       nml_query (dtp, '?');\n-      return SUCCESS;\n+      return true;\n \n     case '$':\n     case '&':\n@@ -2781,7 +2781,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \t}\n     case '/':\n       dtp->u.p.input_complete = 1;\n-      return SUCCESS;\n+      return true;\n \n     default :\n       break;\n@@ -2806,7 +2806,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       if (!is_separator (c))\n \tpush_char (dtp, tolower(c));\n       if ((c = next_char (dtp)) == EOF)\n-\treturn FAILURE;\n+\treturn false;\n     } while (!( c=='=' || c==' ' || c=='\\t' || c =='(' || c =='%' ));\n \n   unget_char (dtp, c);\n@@ -2866,9 +2866,9 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n   if (c == '(' && nl->var_rank)\n     {\n       parsed_rank = 0;\n-      if (nml_parse_qualifier (dtp, nl->dim, nl->ls, nl->var_rank,\n+      if (!nml_parse_qualifier (dtp, nl->dim, nl->ls, nl->var_rank,\n \t\t\t       nml_err_msg, nml_err_msg_size, \n-\t\t\t       &parsed_rank) == FAILURE)\n+\t\t\t       &parsed_rank))\n \t{\n \t  char *nml_err_msg_end = strchr (nml_err_msg, '\\0');\n \t  snprintf (nml_err_msg_end,\n@@ -2882,7 +2882,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       qualifier_flag = 1;\n \n       if ((c = next_char (dtp)) == EOF)\n-\treturn FAILURE;\n+\treturn false;\n       unget_char (dtp, c);\n     }\n   else if (nl->var_rank > 0)\n@@ -2908,7 +2908,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n       component_flag = 1;\n       if ((c = next_char (dtp)) == EOF)\n-\treturn FAILURE;\n+\treturn false;\n       goto get_name;\n     }\n \n@@ -2923,9 +2923,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       descriptor_dimension chd[1] = { {1, clow, nl->string_length} };\n       array_loop_spec ind[1] = { {1, clow, nl->string_length, 1} };\n \n-      if (nml_parse_qualifier (dtp, chd, ind, -1, nml_err_msg, \n-\t\t\t       nml_err_msg_size, &parsed_rank)\n-\t  == FAILURE)\n+      if (!nml_parse_qualifier (dtp, chd, ind, -1, nml_err_msg, \n+\t\t\t\tnml_err_msg_size, &parsed_rank))\n \t{\n \t  char *nml_err_msg_end = strchr (nml_err_msg, '\\0');\n \t  snprintf (nml_err_msg_end,\n@@ -2946,7 +2945,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \t}\n \n       if ((c = next_char (dtp)) == EOF)\n-\treturn FAILURE;\n+\treturn false;\n       unget_char (dtp, c);\n     }\n \n@@ -2978,15 +2977,15 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n   eat_separator (dtp);\n   if (dtp->u.p.input_complete)\n-    return SUCCESS;\n+    return true;\n \n   if (dtp->u.p.at_eol)\n     finish_separator (dtp);\n   if (dtp->u.p.input_complete)\n-    return SUCCESS;\n+    return true;\n \n   if ((c = next_char (dtp)) == EOF)\n-    return FAILURE;\n+    return false;\n \n   if (c != '=')\n     {\n@@ -3013,15 +3012,15 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \tnl = first_nl;\n     }\n \n-  if (nml_read_obj (dtp, nl, 0, pprev_nl, nml_err_msg, nml_err_msg_size,\n-\t\t    clow, chigh) == FAILURE)\n+  if (!nml_read_obj (dtp, nl, 0, pprev_nl, nml_err_msg, nml_err_msg_size,\n+\t\t    clow, chigh))\n     goto nml_err_ret;\n \n-  return SUCCESS;\n+  return true;\n \n nml_err_ret:\n \n-  return FAILURE;\n+  return false;\n }\n \n /* Entry point for namelist input.  Goes through input until namelist name\n@@ -3104,8 +3103,7 @@ namelist_read (st_parameter_dt *dtp)\n \n   while (!dtp->u.p.input_complete)\n     {\n-      if (nml_get_obj_data (dtp, &prev_nl, nml_err_msg, sizeof nml_err_msg)\n-\t\t\t    == FAILURE)\n+      if (!nml_get_obj_data (dtp, &prev_nl, nml_err_msg, sizeof nml_err_msg))\n \t{\n \t  if (dtp->u.p.current_unit->unit_number != options.stdin_unit)\n \t    goto nml_err_ret;"}, {"sha": "6fa954ce2879c0eeb53bbeb00b23ce32bb685036", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "patch": "@@ -401,7 +401,7 @@ read_sf (st_parameter_dt *dtp, int * length)\n \n \n /* Function for reading the next couple of bytes from the current\n-   file, advancing the current position. We return FAILURE on end of record or\n+   file, advancing the current position. We return NULL on end of record or\n    end of file. This function is only for formatted I/O, unformatted uses\n    read_block_direct.\n \n@@ -774,7 +774,7 @@ write_block (st_parameter_dt *dtp, int length)\n    called for unformatted files.  There are three cases to consider:\n    Stream I/O, unformatted direct, unformatted sequential.  */\n \n-static try\n+static bool\n write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n {\n \n@@ -790,12 +790,12 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       if (unlikely (have_written < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written; \n \n-      return SUCCESS;\n+      return true;\n     }\n \n   /* Unformatted direct access.  */\n@@ -805,23 +805,23 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       if (unlikely (dtp->u.p.current_unit->bytes_left < (gfc_offset) nbytes))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_DIRECT_EOR, NULL);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (buf == NULL && nbytes == 0)\n-\treturn SUCCESS;\n+\treturn true;\n \n       have_written = swrite (dtp->u.p.current_unit->s, buf, nbytes); \n       if (unlikely (have_written < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written;\n       dtp->u.p.current_unit->bytes_left -= (gfc_offset) have_written;\n \n-      return SUCCESS;\n+      return true;\n     }\n \n   /* Unformatted sequential.  */\n@@ -854,7 +854,7 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       if (unlikely (to_write_subrecord < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       dtp->u.p.current_unit->strm_pos += (gfc_offset) to_write_subrecord; \n@@ -871,9 +871,9 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n   if (unlikely (short_record))\n     {\n       generate_error (&dtp->common, LIBERROR_SHORT_RECORD, NULL);\n-      return FAILURE;\n+      return false;\n     }\n-  return SUCCESS;\n+  return true;\n }\n \n "}, {"sha": "153da2e2038a8f2d22c923333671ad1b4a977a9f", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "patch": "@@ -31,7 +31,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <ctype.h>\n #include <stdlib.h>\n-#include <stdbool.h>\n #include <errno.h>\n #define star_fill(p, n) memset(p, '*', n)\n "}, {"sha": "a157f0b63287d187980378bb61bc9679963d27f7", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "patch": "@@ -110,7 +110,7 @@ determine_precision (st_parameter_dt * dtp, const fnode * f, int len)\n \n /* Output a real number according to its format which is FMT_G free.  */\n \n-static try\n+static bool\n output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \t      int nprinted, int precision, int sign_bit, bool zero_flag)\n {\n@@ -244,13 +244,13 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \t{\n \t  generate_error (&dtp->common, LIBERROR_FORMAT, \"Precision not \"\n \t\t\t  \"greater than zero in format specifier 'E' or 'D'\");\n-\t  return FAILURE;\n+\t  return false;\n \t}\n       if (p <= -d || p >= d + 2)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_FORMAT, \"Scale factor \"\n \t\t\t  \"out of range in format specifier 'E' or 'D'\");\n-\t  return FAILURE;\n+\t  return false;\n \t}\n \n       if (!zero_flag)\n@@ -532,7 +532,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n   /* Create the ouput buffer.  */\n   out = write_block (dtp, w);\n   if (out == NULL)\n-    return FAILURE;\n+    return false;\n \n   /* Check the value fits in the specified field width.  */\n   if (nblanks < 0 || edigits == -1 || w == 1 || (w == 2 && sign != S_NONE))\n@@ -541,10 +541,10 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \t{\n \t  gfc_char4_t *out4 = (gfc_char4_t *) out;\n \t  memset4 (out4, '*', w);\n-\t  return FAILURE;\n+\t  return false;\n \t}\n       star_fill (out, w);\n-      return FAILURE;\n+      return false;\n     }\n \n   /* See if we have space for a zero before the decimal point.  */\n@@ -652,7 +652,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \t  memset4 (out4, ' ' , nblanks);\n \t  dtp->u.p.no_leading_blank = 0;\n \t}\n-      return SUCCESS;\n+      return true;\n     } /* End of character(kind=4) internal unit code.  */\n \n   /* Pad to full field width.  */\n@@ -745,7 +745,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n       dtp->u.p.no_leading_blank = 0;\n     }\n \n-  return SUCCESS;\n+  return true;\n }\n \n \n@@ -995,7 +995,7 @@ output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n   int ubound, lbound;\\\n   char *p, pad = ' ';\\\n   int save_scale_factor, nb = 0;\\\n-  try result;\\\n+  bool result;\\\n   int nprinted, precision;\\\n \\\n   save_scale_factor = dtp->u.p.scale_factor;\\\n@@ -1087,7 +1087,7 @@ output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n       p = write_block (dtp, nb);\\\n       if (p == NULL)\\\n \treturn;\\\n-      if (result == FAILURE)\\\n+      if (!result)\\\n         pad = '*';\\\n       if (unlikely (is_char4_unit (dtp)))\\\n \t{\\"}, {"sha": "56c98715febbcc793bfb681dd60eb9e1902a1abe", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "patch": "@@ -43,6 +43,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <stddef.h>\n #include <float.h>\n #include <stdarg.h>\n+#include <stdbool.h>\n \n #if HAVE_COMPLEX_H\n /* Must appear before math.h on VMS systems.  */\n@@ -561,10 +562,6 @@ typedef enum\n { NOTIFICATION_SILENT, NOTIFICATION_WARNING, NOTIFICATION_ERROR }\n notification;\n \n-/* This is returned by notify_std and several io functions.  */\n-typedef enum\n-{ SUCCESS = 1, FAILURE }\n-try;\n \n /* The filename and line number don't go inside the globals structure.\n    They are set by the rest of the program and must be linked to.  */\n@@ -732,7 +729,7 @@ iexport_proto(generate_error);\n extern void generate_warning (st_parameter_common *, const char *);\n internal_proto(generate_warning);\n \n-extern try notify_std (st_parameter_common *, int, const char *);\n+extern bool notify_std (st_parameter_common *, int, const char *);\n internal_proto(notify_std);\n \n extern notification notification_std(int);"}, {"sha": "5f048192c23679a4177ea61d9b7ff7620f1aba5b", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=f5e3ed2d42244eae5a54bc22642a9bbf6be5dd32", "patch": "@@ -586,17 +586,17 @@ notification_std (int std)\n    feature.  An error/warning will be issued if the currently selected\n    standard does not contain the requested bits.  */\n \n-try\n+bool\n notify_std (st_parameter_common *cmp, int std, const char * message)\n {\n   int warning;\n \n   if (!compile_options.pedantic)\n-    return SUCCESS;\n+    return true;\n \n   warning = compile_options.warn_std & std;\n   if ((compile_options.allow_std & std) != 0 && !warning)\n-    return SUCCESS;\n+    return true;\n \n   if (!warning)\n     {\n@@ -614,5 +614,5 @@ notify_std (st_parameter_common *cmp, int std, const char * message)\n       estr_write (message);\n       estr_write (\"\\n\");\n     }\n-  return FAILURE;\n+  return false;\n }"}]}