{"sha": "fc24ea2374259d401a46ce3526688b7e79d4cc13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMyNGVhMjM3NDI1OWQ0MDFhNDZjZTM1MjY2ODhiN2U3OWQ0Y2MxMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-21T16:27:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-21T16:27:39Z"}, "message": "dwarf2out: Fix debug info for 2 byte floats [PR99388]\n\nAarch64, ARM and a couple of other architectures have 16-bit floats, HFmode.\nAs can be seen e.g. on\nvoid\nfoo (void)\n{\n  __fp16 a = 1.0;\n  asm (\"nop\");\n  a = 2.0;\n  asm (\"nop\");\n  a = 3.0;\n  asm (\"nop\");\n}\ntestcase, GCC mishandles this on the dwarf2out.c side by assuming all\nfloating point types have sizes in multiples of 4 bytes, so what GCC emits\nis it says that e.g. the DW_OP_implicit_value will be 2 bytes but then\ndoesn't emit anything and so anything emitted after it is treated by\nconsumers as the value and then they get out of sync.\nreal_to_target which insert_float uses indeed fills it that way, but putting\ninto an array of long 32 bits each time, but for the half floats it puts\neverything into the least significant 16 bits of the first long no matter\nwhat endianity host or target has.\n\nThe following patch fixes it.  With the patch the -g -O2 -dA output changes\n(in a cross without .uleb128 support):\n        .byte   0x9e    // DW_OP_implicit_value\n        .byte   0x2     // uleb128 0x2\n+       .2byte  0x3c00  // fp or vector constant word 0\n        .byte   0x7     // DW_LLE_start_end (*.LLST0)\n        .8byte  .LVL1   // Location list begin address (*.LLST0)\n        .8byte  .LVL2   // Location list end address (*.LLST0)\n        .byte   0x4     // uleb128 0x4; Location expression size\n        .byte   0x9e    // DW_OP_implicit_value\n        .byte   0x2     // uleb128 0x2\n+       .2byte  0x4000  // fp or vector constant word 0\n        .byte   0x7     // DW_LLE_start_end (*.LLST0)\n        .8byte  .LVL2   // Location list begin address (*.LLST0)\n        .8byte  .LFE0   // Location list end address (*.LLST0)\n        .byte   0x4     // uleb128 0x4; Location expression size\n        .byte   0x9e    // DW_OP_implicit_value\n        .byte   0x2     // uleb128 0x2\n+       .2byte  0x4200  // fp or vector constant word 0\n        .byte   0       // DW_LLE_end_of_list (*.LLST0)\n\nBootstrapped/regtested on x86_64-linux, aarch64-linux and\narmv7hl-linux-gnueabi, ok for trunk?\n\nI fear the CONST_VECTOR case is still broken, while HFmode elements of vectors\nshould be fine (it uses eltsize of the element sizes) and likewise SFmode could\nbe fine, DFmode vectors are emitted as two 32-bit ints regardless of endianity\nand I'm afraid it can't be right on big-endian.  But I haven't been able to\ncreate a testcase that emits a CONST_VECTOR, for e.g. unused vector vars\nwith constant operands we emit CONCATN during expansion and thus ...\nDW_OP_*piece for each element of the vector and for\nDW_TAG_call_site_parameter we give up (because we handle CONST_VECTOR only\nin loc_descriptor, not mem_loc_descriptor).\n\n2021-03-21  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/99388\n\t* dwarf2out.c (insert_float): Change return type from void to\n\tunsigned, handle GET_MODE_SIZE (mode) == 2 and return element size.\n\t(mem_loc_descriptor, loc_descriptor, add_const_value_attribute):\n\tAdjust callers.", "tree": {"sha": "a0862b0ec20392fa08b153ed6c3fc438c9abd53c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0862b0ec20392fa08b153ed6c3fc438c9abd53c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc24ea2374259d401a46ce3526688b7e79d4cc13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc24ea2374259d401a46ce3526688b7e79d4cc13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc24ea2374259d401a46ce3526688b7e79d4cc13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc24ea2374259d401a46ce3526688b7e79d4cc13/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6af7b307f659a4f1845a9efd36ca37899515e234", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6af7b307f659a4f1845a9efd36ca37899515e234", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6af7b307f659a4f1845a9efd36ca37899515e234"}], "stats": {"total": 30, "additions": 20, "deletions": 10}, "files": [{"sha": "ececcf50f8a99aa3aaf6c595c32f39eaafcc86ff", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc24ea2374259d401a46ce3526688b7e79d4cc13/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc24ea2374259d401a46ce3526688b7e79d4cc13/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=fc24ea2374259d401a46ce3526688b7e79d4cc13", "patch": "@@ -3825,7 +3825,7 @@ static void add_data_member_location_attribute (dw_die_ref, tree,\n static bool add_const_value_attribute (dw_die_ref, rtx);\n static void insert_int (HOST_WIDE_INT, unsigned, unsigned char *);\n static void insert_wide_int (const wide_int &, unsigned char *, int);\n-static void insert_float (const_rtx, unsigned char *);\n+static unsigned insert_float (const_rtx, unsigned char *);\n static rtx rtl_for_decl_location (tree);\n static bool add_location_or_const_value_attribute (dw_die_ref, tree, bool);\n static bool tree_add_const_value_attribute (dw_die_ref, tree);\n@@ -16292,11 +16292,12 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \t      scalar_float_mode float_mode = as_a <scalar_float_mode> (mode);\n \t      unsigned int length = GET_MODE_SIZE (float_mode);\n \t      unsigned char *array = ggc_vec_alloc<unsigned char> (length);\n+\t      unsigned int elt_size = insert_float (rtl, array);\n \n-\t      insert_float (rtl, array);\n \t      mem_loc_result->dw_loc_oprnd2.val_class = dw_val_class_vec;\n-\t      mem_loc_result->dw_loc_oprnd2.v.val_vec.length = length / 4;\n-\t      mem_loc_result->dw_loc_oprnd2.v.val_vec.elt_size = 4;\n+\t      mem_loc_result->dw_loc_oprnd2.v.val_vec.length\n+\t\t= length / elt_size;\n+\t      mem_loc_result->dw_loc_oprnd2.v.val_vec.elt_size = elt_size;\n \t      mem_loc_result->dw_loc_oprnd2.v.val_vec.array = array;\n \t    }\n \t}\n@@ -16866,11 +16867,11 @@ loc_descriptor (rtx rtl, machine_mode mode,\n \t    {\n \t      unsigned int length = GET_MODE_SIZE (smode);\n \t      unsigned char *array = ggc_vec_alloc<unsigned char> (length);\n+\t      unsigned int elt_size = insert_float (rtl, array);\n \n-\t      insert_float (rtl, array);\n \t      loc_result->dw_loc_oprnd2.val_class = dw_val_class_vec;\n-\t      loc_result->dw_loc_oprnd2.v.val_vec.length = length / 4;\n-\t      loc_result->dw_loc_oprnd2.v.val_vec.elt_size = 4;\n+\t      loc_result->dw_loc_oprnd2.v.val_vec.length = length / elt_size;\n+\t      loc_result->dw_loc_oprnd2.v.val_vec.elt_size = elt_size;\n \t      loc_result->dw_loc_oprnd2.v.val_vec.array = array;\n \t    }\n \t}\n@@ -19689,7 +19690,7 @@ insert_wide_int (const wide_int &val, unsigned char *dest, int elt_size)\n \n /* Writes floating point values to dw_vec_const array.  */\n \n-static void\n+static unsigned\n insert_float (const_rtx rtl, unsigned char *array)\n {\n   long val[4];\n@@ -19699,11 +19700,19 @@ insert_float (const_rtx rtl, unsigned char *array)\n   real_to_target (val, CONST_DOUBLE_REAL_VALUE (rtl), mode);\n \n   /* real_to_target puts 32-bit pieces in each long.  Pack them.  */\n+  if (GET_MODE_SIZE (mode) < 4)\n+    {\n+      gcc_assert (GET_MODE_SIZE (mode) == 2);\n+      insert_int (val[0], 2, array);\n+      return 2;\n+    }\n+\n   for (i = 0; i < GET_MODE_SIZE (mode) / 4; i++)\n     {\n       insert_int (val[i], 4, array);\n       array += 4;\n     }\n+  return 4;\n }\n \n /* Attach a DW_AT_const_value attribute for a variable or a parameter which\n@@ -19752,9 +19761,10 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \t  scalar_float_mode mode = as_a <scalar_float_mode> (GET_MODE (rtl));\n \t  unsigned int length = GET_MODE_SIZE (mode);\n \t  unsigned char *array = ggc_vec_alloc<unsigned char> (length);\n+\t  unsigned int elt_size = insert_float (rtl, array);\n \n-\t  insert_float (rtl, array);\n-\t  add_AT_vec (die, DW_AT_const_value, length / 4, 4, array);\n+\t  add_AT_vec (die, DW_AT_const_value, length / elt_size, elt_size,\n+\t\t      array);\n \t}\n       return true;\n "}]}