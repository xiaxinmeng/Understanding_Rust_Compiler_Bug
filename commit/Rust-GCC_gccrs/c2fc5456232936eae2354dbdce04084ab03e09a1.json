{"sha": "c2fc5456232936eae2354dbdce04084ab03e09a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJmYzU0NTYyMzI5MzZlYWUyMzU0ZGJkY2UwNDA4NGFiMDNlMDlhMQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2005-12-19T14:36:59Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2005-12-19T14:36:59Z"}, "message": "re PR rtl-optimization/20070 (If-conversion can't match equivalent code, and cross-jumping only works for literal matches)\n\n\t* cfgcleanup.c: Temporarily revert patches for PR 20070 till Bernd\n\tcomes back.\n\nFrom-SVN: r108792", "tree": {"sha": "8e45492fc15d457ca5117d45335c2c2d1d9b040d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e45492fc15d457ca5117d45335c2c2d1d9b040d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2fc5456232936eae2354dbdce04084ab03e09a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2fc5456232936eae2354dbdce04084ab03e09a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2fc5456232936eae2354dbdce04084ab03e09a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2fc5456232936eae2354dbdce04084ab03e09a1/comments", "author": null, "committer": null, "parents": [{"sha": "4264bbf9bdd193254face8802cf459da0a2d75fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4264bbf9bdd193254face8802cf459da0a2d75fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4264bbf9bdd193254face8802cf459da0a2d75fb"}], "stats": {"total": 566, "additions": 470, "deletions": 96}, "files": [{"sha": "f696975b60bf6f6af8709bcc3073bb39be76aa4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2fc5456232936eae2354dbdce04084ab03e09a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2fc5456232936eae2354dbdce04084ab03e09a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2fc5456232936eae2354dbdce04084ab03e09a1", "patch": "@@ -1,3 +1,8 @@\n+2005-12-19  J\"orn Rennecke <joern.rennecke@st.com>\n+\n+\t* cfgcleanup.c: Temporarily revert patches for PR 20070 till Bernd\n+\tcomes back.\n+\n 2005-12-19  J\"orn Rennecke <joern.rennecke@st.com>\n \n \t* struct-equiv.c (struct_equiv_improve_checkpoint): Fix sets_cc0_p"}, {"sha": "8bc49a2abd8035cff3eafcd00d80902de098d145", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 465, "deletions": 96, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2fc5456232936eae2354dbdce04084ab03e09a1/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2fc5456232936eae2354dbdce04084ab03e09a1/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=c2fc5456232936eae2354dbdce04084ab03e09a1", "patch": "@@ -60,7 +60,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n static bool first_pass;\n static bool try_crossjump_to_edge (int, edge, edge);\n static bool try_crossjump_bb (int, basic_block);\n-static bool outgoing_edges_match (int *, struct equiv_info *);\n+static bool outgoing_edges_match (int, basic_block, basic_block);\n+static int flow_find_cross_jump (int, basic_block, basic_block, rtx *, rtx *);\n+static bool old_insns_match_p (int, rtx, rtx);\n \n static void merge_blocks_move_predecessor_nojumps (basic_block, basic_block);\n static void merge_blocks_move_successor_nojumps (basic_block, basic_block);\n@@ -72,6 +74,7 @@ static bool mark_effect (rtx, bitmap);\n static void notice_new_block (basic_block);\n static void update_forwarder_flag (basic_block);\n static int mentions_nonequal_regs (rtx *, void *);\n+static void merge_memattrs (rtx, rtx);\n \f\n /* Set flags for newly created block.  */\n \n@@ -878,6 +881,319 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n   return NULL;\n }\n \f\n+\n+/* Removes the memory attributes of MEM expression\n+   if they are not equal.  */\n+\n+void\n+merge_memattrs (rtx x, rtx y)\n+{\n+  int i;\n+  int j;\n+  enum rtx_code code;\n+  const char *fmt;\n+\n+  if (x == y)\n+    return;\n+  if (x == 0 || y == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+\n+  if (code != GET_CODE (y))\n+    return;\n+\n+  if (GET_MODE (x) != GET_MODE (y))\n+    return;\n+\n+  if (code == MEM && MEM_ATTRS (x) != MEM_ATTRS (y))\n+    {\n+      if (! MEM_ATTRS (x))\n+\tMEM_ATTRS (y) = 0;\n+      else if (! MEM_ATTRS (y))\n+\tMEM_ATTRS (x) = 0;\n+      else \n+\t{\n+\t  rtx mem_size;\n+\n+\t  if (MEM_ALIAS_SET (x) != MEM_ALIAS_SET (y))\n+\t    {\n+\t      set_mem_alias_set (x, 0);\n+\t      set_mem_alias_set (y, 0);\n+\t    }\n+\t  \n+\t  if (! mem_expr_equal_p (MEM_EXPR (x), MEM_EXPR (y)))\n+\t    {\n+\t      set_mem_expr (x, 0);\n+\t      set_mem_expr (y, 0);\n+\t      set_mem_offset (x, 0);\n+\t      set_mem_offset (y, 0);\n+\t    }\n+\t  else if (MEM_OFFSET (x) != MEM_OFFSET (y))\n+\t    {\n+\t      set_mem_offset (x, 0);\n+\t      set_mem_offset (y, 0);\n+\t    }\n+\t \n+\t  if (!MEM_SIZE (x))\n+\t    mem_size = NULL_RTX;\n+\t  else if (!MEM_SIZE (y))\n+\t    mem_size = NULL_RTX;\n+\t  else\n+\t    mem_size = GEN_INT (MAX (INTVAL (MEM_SIZE (x)),\n+\t\t\t\t     INTVAL (MEM_SIZE (y))));\n+\t  set_mem_size (x, mem_size);\n+\t  set_mem_size (y, mem_size);\n+\n+\t  set_mem_align (x, MIN (MEM_ALIGN (x), MEM_ALIGN (y)));\n+\t  set_mem_align (y, MEM_ALIGN (x));\n+\t}\n+    }\n+  \n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'E':\n+\t  /* Two vectors must have the same length.  */\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return;\n+\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    merge_memattrs (XVECEXP (x, i, j), XVECEXP (y, i, j));\n+\n+\t  break;\n+\n+\tcase 'e':\n+\t  merge_memattrs (XEXP (x, i), XEXP (y, i));\n+\t}\n+    }\n+  return;\n+}\n+\n+\n+/* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */\n+\n+static bool\n+old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n+{\n+  rtx p1, p2;\n+\n+  /* Verify that I1 and I2 are equivalent.  */\n+  if (GET_CODE (i1) != GET_CODE (i2))\n+    return false;\n+\n+  p1 = PATTERN (i1);\n+  p2 = PATTERN (i2);\n+\n+  if (GET_CODE (p1) != GET_CODE (p2))\n+    return false;\n+\n+  /* If this is a CALL_INSN, compare register usage information.\n+     If we don't check this on stack register machines, the two\n+     CALL_INSNs might be merged leaving reg-stack.c with mismatching\n+     numbers of stack registers in the same basic block.\n+     If we don't check this on machines with delay slots, a delay slot may\n+     be filled that clobbers a parameter expected by the subroutine.\n+\n+     ??? We take the simple route for now and assume that if they're\n+     equal, they were constructed identically.  */\n+\n+  if (CALL_P (i1)\n+      && (!rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n+\t\t        CALL_INSN_FUNCTION_USAGE (i2))\n+\t  || SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2)))\n+    return false;\n+\n+#ifdef STACK_REGS\n+  /* If cross_jump_death_matters is not 0, the insn's mode\n+     indicates whether or not the insn contains any stack-like\n+     regs.  */\n+\n+  if ((mode & CLEANUP_POST_REGSTACK) && stack_regs_mentioned (i1))\n+    {\n+      /* If register stack conversion has already been done, then\n+         death notes must also be compared before it is certain that\n+         the two instruction streams match.  */\n+\n+      rtx note;\n+      HARD_REG_SET i1_regset, i2_regset;\n+\n+      CLEAR_HARD_REG_SET (i1_regset);\n+      CLEAR_HARD_REG_SET (i2_regset);\n+\n+      for (note = REG_NOTES (i1); note; note = XEXP (note, 1))\n+\tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n+\t  SET_HARD_REG_BIT (i1_regset, REGNO (XEXP (note, 0)));\n+\n+      for (note = REG_NOTES (i2); note; note = XEXP (note, 1))\n+\tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n+\t  SET_HARD_REG_BIT (i2_regset, REGNO (XEXP (note, 0)));\n+\n+      GO_IF_HARD_REG_EQUAL (i1_regset, i2_regset, done);\n+\n+      return false;\n+\n+    done:\n+      ;\n+    }\n+#endif\n+\n+  if (reload_completed\n+      ? rtx_renumbered_equal_p (p1, p2) : rtx_equal_p (p1, p2))\n+    return true;\n+\n+  /* Do not do EQUIV substitution after reload.  First, we're undoing the\n+     work of reload_cse.  Second, we may be undoing the work of the post-\n+     reload splitting pass.  */\n+  /* ??? Possibly add a new phase switch variable that can be used by\n+     targets to disallow the troublesome insns after splitting.  */\n+  if (!reload_completed)\n+    {\n+      /* The following code helps take care of G++ cleanups.  */\n+      rtx equiv1 = find_reg_equal_equiv_note (i1);\n+      rtx equiv2 = find_reg_equal_equiv_note (i2);\n+\n+      if (equiv1 && equiv2\n+\t  /* If the equivalences are not to a constant, they may\n+\t     reference pseudos that no longer exist, so we can't\n+\t     use them.  */\n+\t  && (! reload_completed\n+\t      || (CONSTANT_P (XEXP (equiv1, 0))\n+\t\t  && rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))))\n+\t{\n+\t  rtx s1 = single_set (i1);\n+\t  rtx s2 = single_set (i2);\n+\t  if (s1 != 0 && s2 != 0\n+\t      && rtx_renumbered_equal_p (SET_DEST (s1), SET_DEST (s2)))\n+\t    {\n+\t      validate_change (i1, &SET_SRC (s1), XEXP (equiv1, 0), 1);\n+\t      validate_change (i2, &SET_SRC (s2), XEXP (equiv2, 0), 1);\n+\t      if (! rtx_renumbered_equal_p (p1, p2))\n+\t\tcancel_changes (0);\n+\t      else if (apply_change_group ())\n+\t\treturn true;\n+\t    }\n+\t}\n+    }\n+\n+  return false;\n+}\n+\f\n+/* Look through the insns at the end of BB1 and BB2 and find the longest\n+   sequence that are equivalent.  Store the first insns for that sequence\n+   in *F1 and *F2 and return the sequence length.\n+\n+   To simplify callers of this function, if the blocks match exactly,\n+   store the head of the blocks in *F1 and *F2.  */\n+\n+static int\n+flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n+\t\t      basic_block bb2, rtx *f1, rtx *f2)\n+{\n+  rtx i1, i2, last1, last2, afterlast1, afterlast2;\n+  int ninsns = 0;\n+\n+  /* Skip simple jumps at the end of the blocks.  Complex jumps still\n+     need to be compared for equivalence, which we'll do below.  */\n+\n+  i1 = BB_END (bb1);\n+  last1 = afterlast1 = last2 = afterlast2 = NULL_RTX;\n+  if (onlyjump_p (i1)\n+      || (returnjump_p (i1) && !side_effects_p (PATTERN (i1))))\n+    {\n+      last1 = i1;\n+      i1 = PREV_INSN (i1);\n+    }\n+\n+  i2 = BB_END (bb2);\n+  if (onlyjump_p (i2)\n+      || (returnjump_p (i2) && !side_effects_p (PATTERN (i2))))\n+    {\n+      last2 = i2;\n+      /* Count everything except for unconditional jump as insn.  */\n+      if (!simplejump_p (i2) && !returnjump_p (i2) && last1)\n+\tninsns++;\n+      i2 = PREV_INSN (i2);\n+    }\n+\n+  while (true)\n+    {\n+      /* Ignore notes.  */\n+      while (!INSN_P (i1) && i1 != BB_HEAD (bb1))\n+\ti1 = PREV_INSN (i1);\n+\n+      while (!INSN_P (i2) && i2 != BB_HEAD (bb2))\n+\ti2 = PREV_INSN (i2);\n+\n+      if (i1 == BB_HEAD (bb1) || i2 == BB_HEAD (bb2))\n+\tbreak;\n+\n+      if (!old_insns_match_p (mode, i1, i2))\n+\tbreak;\n+\n+      merge_memattrs (i1, i2);\n+\n+      /* Don't begin a cross-jump with a NOTE insn.  */\n+      if (INSN_P (i1))\n+\t{\n+\t  /* If the merged insns have different REG_EQUAL notes, then\n+\t     remove them.  */\n+\t  rtx equiv1 = find_reg_equal_equiv_note (i1);\n+\t  rtx equiv2 = find_reg_equal_equiv_note (i2);\n+\n+\t  if (equiv1 && !equiv2)\n+\t    remove_note (i1, equiv1);\n+\t  else if (!equiv1 && equiv2)\n+\t    remove_note (i2, equiv2);\n+\t  else if (equiv1 && equiv2\n+\t\t   && !rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))\n+\t    {\n+\t      remove_note (i1, equiv1);\n+\t      remove_note (i2, equiv2);\n+\t    }\n+\n+\t  afterlast1 = last1, afterlast2 = last2;\n+\t  last1 = i1, last2 = i2;\n+\t  ninsns++;\n+\t}\n+\n+      i1 = PREV_INSN (i1);\n+      i2 = PREV_INSN (i2);\n+    }\n+\n+#ifdef HAVE_cc0\n+  /* Don't allow the insn after a compare to be shared by\n+     cross-jumping unless the compare is also shared.  */\n+  if (ninsns && reg_mentioned_p (cc0_rtx, last1) && ! sets_cc0_p (last1))\n+    last1 = afterlast1, last2 = afterlast2, ninsns--;\n+#endif\n+\n+  /* Include preceding notes and labels in the cross-jump.  One,\n+     this may bring us to the head of the blocks as requested above.\n+     Two, it keeps line number notes as matched as may be.  */\n+  if (ninsns)\n+    {\n+      while (last1 != BB_HEAD (bb1) && !INSN_P (PREV_INSN (last1)))\n+\tlast1 = PREV_INSN (last1);\n+\n+      if (last1 != BB_HEAD (bb1) && LABEL_P (PREV_INSN (last1)))\n+\tlast1 = PREV_INSN (last1);\n+\n+      while (last2 != BB_HEAD (bb2) && !INSN_P (PREV_INSN (last2)))\n+\tlast2 = PREV_INSN (last2);\n+\n+      if (last2 != BB_HEAD (bb2) && LABEL_P (PREV_INSN (last2)))\n+\tlast2 = PREV_INSN (last2);\n+\n+      *f1 = last1;\n+      *f2 = last2;\n+    }\n+\n+  return ninsns;\n+}\n+\n /* Return true iff the condbranches at the end of BB1 and BB2 match.  */\n bool\n condjump_equiv_p (struct equiv_info *info, bool call_init)\n@@ -1006,20 +1322,15 @@ condjump_equiv_p (struct equiv_info *info, bool call_init)\n   return match;\n }\n \n-/* Return true iff outgoing edges of INFO->y_block and INFO->x_block match,\n-   together with the branch instruction.  This means that if we commonize the\n-   control flow before end of the basic block, the semantic remains unchanged.\n-   If we need to compare jumps, we set STRUCT_EQUIV_MATCH_JUMPS in *MODE,\n-   and pass *MODE to struct_equiv_init or assign it to INFO->mode, as\n-   appropriate.\n+/* Return true iff outgoing edges of BB1 and BB2 match, together with\n+   the branch instruction.  This means that if we commonize the control\n+   flow before end of the basic block, the semantic remains unchanged.\n \n    We may assume that there exists one edge with a common destination.  */\n \n static bool\n-outgoing_edges_match (int *mode, struct equiv_info *info)\n+outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n {\n-  basic_block bb1 = info->y_block;\n-  basic_block bb2 = info->x_block;\n   int nehedges1 = 0, nehedges2 = 0;\n   edge fallthru1 = 0, fallthru2 = 0;\n   edge e1, e2;\n@@ -1035,19 +1346,114 @@ outgoing_edges_match (int *mode, struct equiv_info *info)\n \t\t& (EDGE_COMPLEX | EDGE_FAKE)) == 0\n \t    && (!JUMP_P (BB_END (bb2)) || simplejump_p (BB_END (bb2))));\n \n-  *mode |= STRUCT_EQUIV_MATCH_JUMPS;\n   /* Match conditional jumps - this may get tricky when fallthru and branch\n      edges are crossed.  */\n   if (EDGE_COUNT (bb1->succs) == 2\n       && any_condjump_p (BB_END (bb1))\n       && onlyjump_p (BB_END (bb1)))\n     {\n+      edge b1, f1, b2, f2;\n+      bool reverse, match;\n+      rtx set1, set2, cond1, cond2;\n+      enum rtx_code code1, code2;\n+\n       if (EDGE_COUNT (bb2->succs) != 2\n \t  || !any_condjump_p (BB_END (bb2))\n \t  || !onlyjump_p (BB_END (bb2)))\n \treturn false;\n-      info->mode = *mode;\n-      return condjump_equiv_p (info, true);\n+\n+      b1 = BRANCH_EDGE (bb1);\n+      b2 = BRANCH_EDGE (bb2);\n+      f1 = FALLTHRU_EDGE (bb1);\n+      f2 = FALLTHRU_EDGE (bb2);\n+\n+      /* Get around possible forwarders on fallthru edges.  Other cases\n+         should be optimized out already.  */\n+      if (FORWARDER_BLOCK_P (f1->dest))\n+\tf1 = single_succ_edge (f1->dest);\n+\n+      if (FORWARDER_BLOCK_P (f2->dest))\n+\tf2 = single_succ_edge (f2->dest);\n+\n+      /* To simplify use of this function, return false if there are\n+\t unneeded forwarder blocks.  These will get eliminated later\n+\t during cleanup_cfg.  */\n+      if (FORWARDER_BLOCK_P (f1->dest)\n+\t  || FORWARDER_BLOCK_P (f2->dest)\n+\t  || FORWARDER_BLOCK_P (b1->dest)\n+\t  || FORWARDER_BLOCK_P (b2->dest))\n+\treturn false;\n+\n+      if (f1->dest == f2->dest && b1->dest == b2->dest)\n+\treverse = false;\n+      else if (f1->dest == b2->dest && b1->dest == f2->dest)\n+\treverse = true;\n+      else\n+\treturn false;\n+\n+      set1 = pc_set (BB_END (bb1));\n+      set2 = pc_set (BB_END (bb2));\n+      if ((XEXP (SET_SRC (set1), 1) == pc_rtx)\n+\t  != (XEXP (SET_SRC (set2), 1) == pc_rtx))\n+\treverse = !reverse;\n+\n+      cond1 = XEXP (SET_SRC (set1), 0);\n+      cond2 = XEXP (SET_SRC (set2), 0);\n+      code1 = GET_CODE (cond1);\n+      if (reverse)\n+\tcode2 = reversed_comparison_code (cond2, BB_END (bb2));\n+      else\n+\tcode2 = GET_CODE (cond2);\n+\n+      if (code2 == UNKNOWN)\n+\treturn false;\n+\n+      /* Verify codes and operands match.  */\n+      match = ((code1 == code2\n+\t\t&& rtx_renumbered_equal_p (XEXP (cond1, 0), XEXP (cond2, 0))\n+\t\t&& rtx_renumbered_equal_p (XEXP (cond1, 1), XEXP (cond2, 1)))\n+\t       || (code1 == swap_condition (code2)\n+\t\t   && rtx_renumbered_equal_p (XEXP (cond1, 1),\n+\t\t\t\t\t      XEXP (cond2, 0))\n+\t\t   && rtx_renumbered_equal_p (XEXP (cond1, 0),\n+\t\t\t\t\t      XEXP (cond2, 1))));\n+\n+      /* If we return true, we will join the blocks.  Which means that\n+\t we will only have one branch prediction bit to work with.  Thus\n+\t we require the existing branches to have probabilities that are\n+\t roughly similar.  */\n+      if (match\n+\t  && !optimize_size\n+\t  && maybe_hot_bb_p (bb1)\n+\t  && maybe_hot_bb_p (bb2))\n+\t{\n+\t  int prob2;\n+\n+\t  if (b1->dest == b2->dest)\n+\t    prob2 = b2->probability;\n+\t  else\n+\t    /* Do not use f2 probability as f2 may be forwarded.  */\n+\t    prob2 = REG_BR_PROB_BASE - b2->probability;\n+\n+\t  /* Fail if the difference in probabilities is greater than 50%.\n+\t     This rules out two well-predicted branches with opposite\n+\t     outcomes.  */\n+\t  if (abs (b1->probability - prob2) > REG_BR_PROB_BASE / 2)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Outcomes of branch in bb %i and %i differ too much (%i %i)\\n\",\n+\t\t\t bb1->index, bb2->index, b1->probability, prob2);\n+\n+\t      return false;\n+\t    }\n+\t}\n+\n+      if (dump_file && match)\n+\tfprintf (dump_file, \"Conditionals in bb %i and %i match.\\n\",\n+\t\t bb1->index, bb2->index);\n+\n+      return match;\n     }\n \n   /* Generic case - we are seeing a computed jump, table jump or trapping\n@@ -1095,22 +1501,31 @@ outgoing_edges_match (int *mode, struct equiv_info *info)\n \t\t      identical = false;\n \t\t}\n \n-\t      if (identical\n-\t\t  && struct_equiv_init (STRUCT_EQUIV_START | *mode, info))\n+\t      if (identical)\n \t\t{\n+\t\t  replace_label_data rr;\n \t\t  bool match;\n \n-\t\t  /* Indicate that LABEL1 is to be replaced with LABEL2\n+\t\t  /* Temporarily replace references to LABEL1 with LABEL2\n \t\t     in BB1->END so that we could compare the instructions.  */\n-\t\t  info->y_label = label1;\n-\t\t  info->x_label = label2;\n+\t\t  rr.r1 = label1;\n+\t\t  rr.r2 = label2;\n+\t\t  rr.update_label_nuses = false;\n+\t\t  for_each_rtx (&BB_END (bb1), replace_label, &rr);\n \n-\t\t  match = insns_match_p (BB_END (bb1), BB_END (bb2), info);\n+\t\t  match = old_insns_match_p (mode, BB_END (bb1), BB_END (bb2));\n \t\t  if (dump_file && match)\n \t\t    fprintf (dump_file,\n \t\t\t     \"Tablejumps in bb %i and %i match.\\n\",\n \t\t\t     bb1->index, bb2->index);\n \n+\t\t  /* Set the original label in BB1->END because when deleting\n+\t\t     a block whose end is a tablejump, the tablejump referenced\n+\t\t     from the instruction is deleted too.  */\n+\t\t  rr.r1 = label2;\n+\t\t  rr.r2 = label1;\n+\t\t  for_each_rtx (&BB_END (bb1), replace_label, &rr);\n+\n \t\t  return match;\n \t\t}\n \t    }\n@@ -1120,8 +1535,7 @@ outgoing_edges_match (int *mode, struct equiv_info *info)\n \n   /* First ensure that the instructions match.  There may be many outgoing\n      edges so this test is generally cheaper.  */\n-  if (!struct_equiv_init (STRUCT_EQUIV_START | *mode, info)\n-      || !insns_match_p (BB_END (bb1), BB_END (bb2), info))\n+  if (!old_insns_match_p (mode, BB_END (bb1), BB_END (bb2)))\n     return false;\n \n   /* Search the outgoing edges, ensure that the counts do match, find possible\n@@ -1187,21 +1601,22 @@ outgoing_edges_match (int *mode, struct equiv_info *info)\n static bool\n try_crossjump_to_edge (int mode, edge e1, edge e2)\n {\n-  int nmatch, i;\n+  int nmatch;\n   basic_block src1 = e1->src, src2 = e2->src;\n   basic_block redirect_to, redirect_from, to_remove;\n+  rtx newpos1, newpos2;\n   edge s;\n   edge_iterator ei;\n-  struct equiv_info info;\n-  rtx x_active, y_active;\n+\n+  newpos1 = newpos2 = NULL_RTX;\n \n   /* If we have partitioned hot/cold basic blocks, it is a bad idea\n-     to try this optimization.\n+     to try this optimization. \n \n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really\n-     must be left untouched (they are required to make it safely across\n-     partition boundaries).  See the comments at the top of\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (flag_reorder_blocks_and_partition && no_new_pseudos)\n@@ -1240,67 +1655,20 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n     return false;\n \n   /* Look for the common insn sequence, part the first ...  */\n-  info.x_block = src2;\n-  info.y_block = src1;\n-  if (!outgoing_edges_match (&mode, &info))\n+  if (!outgoing_edges_match (mode, src1, src2))\n     return false;\n \n   /* ... and part the second.  */\n-  info.input_cost = optimize_size ? COSTS_N_INSNS (1) : -1;\n-  nmatch = struct_equiv_block_eq (STRUCT_EQUIV_START | mode, &info);\n+  nmatch = flow_find_cross_jump (mode, src1, src2, &newpos1, &newpos2);\n \n   /* Don't proceed with the crossjump unless we found a sufficient number\n      of matching instructions or the 'from' block was totally matched\n      (such that its predecessors will hopefully be redirected and the\n      block removed).  */\n-  if (!nmatch)\n-    return false;\n-  if ((nmatch -info.cur.input_count < PARAM_VALUE (PARAM_MIN_CROSSJUMP_INSNS))\n-      && (info.cur.y_start != BB_HEAD (src1)))\n-    return false;\n-  while (info.need_rerun)\n-    {\n-      nmatch = struct_equiv_block_eq (STRUCT_EQUIV_RERUN | mode, &info);\n-      if (!nmatch)\n-\treturn false;\n-      if ((nmatch -info.cur.input_count < PARAM_VALUE (PARAM_MIN_CROSSJUMP_INSNS))\n-\t   && (info.cur.y_start != BB_HEAD (src1)))\n-\treturn false;\n-    }\n-  nmatch = struct_equiv_block_eq (STRUCT_EQUIV_FINAL | mode, &info);\n-  if ((nmatch -info.cur.input_count < PARAM_VALUE (PARAM_MIN_CROSSJUMP_INSNS))\n-      && (info.cur.y_start != BB_HEAD (src1)))\n+  if ((nmatch < PARAM_VALUE (PARAM_MIN_CROSSJUMP_INSNS))\n+      && (newpos1 != BB_HEAD (src1)))\n     return false;\n \n-  /* Skip possible basic block header.  */\n-  x_active = info.cur.x_start;\n-  if (LABEL_P (x_active))\n-    x_active = NEXT_INSN (x_active);\n-  if (NOTE_P (x_active))\n-    x_active = NEXT_INSN (x_active);\n-\n-  y_active = info.cur.y_start;\n-  if (LABEL_P (y_active))\n-    y_active = NEXT_INSN (y_active);\n-  if (NOTE_P (y_active))\n-    y_active = NEXT_INSN (y_active);\n-\n-  /* In order for this code to become active, either we have to be called\n-     before reload, or struct_equiv_block_eq needs to add register scavenging\n-     code to allocate input_reg after reload.  */\n-  if (info.input_reg)\n-    {\n-      emit_insn_before (gen_move_insn (info.input_reg, info.x_input),\n-\t\t\tx_active);\n-      emit_insn_before (gen_move_insn (info.input_reg, info.y_input),\n-\t\t\ty_active);\n-    }\n-\n-  for (i = 0; i < info.cur.local_count; i++)\n-    if (info.local_rvalue[i])\n-      emit_insn_before (gen_move_insn (info.x_local[i], info.y_local[i]),\n-\t\t\ty_active);\n-\n   /* Here we know that the insns in the end of SRC1 which are common with SRC2\n      will be deleted.\n      If we have tablejumps in the end of SRC1 and SRC2\n@@ -1335,36 +1703,30 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   /* Avoid splitting if possible.  We must always split when SRC2 has\n      EH predecessor edges, or we may end up with basic blocks with both\n      normal and EH predecessor edges.  */\n-  if (info.cur.x_start == BB_HEAD (src2)\n+  if (newpos2 == BB_HEAD (src2)\n       && !(EDGE_PRED (src2, 0)->flags & EDGE_EH))\n     redirect_to = src2;\n   else\n     {\n-      if (info.cur.x_start == BB_HEAD (src2))\n+      if (newpos2 == BB_HEAD (src2))\n \t{\n \t  /* Skip possible basic block header.  */\n-\t  if (LABEL_P (info.cur.x_start))\n-\t    info.cur.x_start = NEXT_INSN (info.cur.x_start);\n-\t  if (NOTE_P (info.cur.x_start))\n-\t    info.cur.x_start = NEXT_INSN (info.cur.x_start);\n+\t  if (LABEL_P (newpos2))\n+\t    newpos2 = NEXT_INSN (newpos2);\n+\t  if (NOTE_P (newpos2))\n+\t    newpos2 = NEXT_INSN (newpos2);\n \t}\n \n       if (dump_file)\n \tfprintf (dump_file, \"Splitting bb %i before %i insns\\n\",\n \t\t src2->index, nmatch);\n-      redirect_to = split_block (src2, PREV_INSN (info.cur.x_start))->dest;\n-      COPY_REG_SET (info.y_block->il.rtl->global_live_at_end,\n-\t\t    info.x_block->il.rtl->global_live_at_end);\n+      redirect_to = split_block (src2, PREV_INSN (newpos2))->dest;\n     }\n \n   if (dump_file)\n-    {\n-      fprintf (dump_file, \"Cross jumping from bb %i to bb %i; %i common insns\",\n-\t       src1->index, src2->index, nmatch);\n-      if (info.cur.local_count)\n-\tfprintf (dump_file, \", %i local registers\", info.cur.local_count);\n-       fprintf (dump_file, \"\\n\");\n-    }\n+    fprintf (dump_file,\n+\t     \"Cross jumping from bb %i to bb %i; %i common insns\\n\",\n+\t     src1->index, src2->index, nmatch);\n \n   redirect_to->count += src1->count;\n   redirect_to->frequency += src1->frequency;\n@@ -1428,7 +1790,14 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n \n   /* Edit SRC1 to go to REDIRECT_TO at NEWPOS1.  */\n \n-  redirect_from = split_block (src1, PREV_INSN (y_active))->src;\n+  /* Skip possible basic block header.  */\n+  if (LABEL_P (newpos1))\n+    newpos1 = NEXT_INSN (newpos1);\n+\n+  if (NOTE_P (newpos1))\n+    newpos1 = NEXT_INSN (newpos1);\n+\n+  redirect_from = split_block (src1, PREV_INSN (newpos1))->src;\n   to_remove = single_succ (redirect_from);\n \n   redirect_edge_and_branch_force (single_succ_edge (redirect_from), redirect_to);"}]}