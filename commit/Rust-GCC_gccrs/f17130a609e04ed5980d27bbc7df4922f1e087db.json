{"sha": "f17130a609e04ed5980d27bbc7df4922f1e087db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE3MTMwYTYwOWUwNGVkNTk4MGQyN2JiYzdkZjQ5MjJmMWUwODdkYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-02-13T13:32:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-02-13T13:32:00Z"}, "message": "[multiple changes]\n\n2019-02-13  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/89303\n\t* tree-ssa-structalias.c (set_uids_in_ptset): Or in vi->is_heap_var\n\tinto pt->vars_contains_escaped_heap instead of setting\n\tpt->vars_contains_escaped_heap to it.\n\n2019-02-13  Jonathan Wakely  <jwakely@redhat.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/89303\n\t* g++.dg/torture/pr89303.C: New test.\n\nFrom-SVN: r268843", "tree": {"sha": "03ca58b7028b2d0038f30e1ae539cbb0260574c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03ca58b7028b2d0038f30e1ae539cbb0260574c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f17130a609e04ed5980d27bbc7df4922f1e087db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f17130a609e04ed5980d27bbc7df4922f1e087db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f17130a609e04ed5980d27bbc7df4922f1e087db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f17130a609e04ed5980d27bbc7df4922f1e087db/comments", "author": null, "committer": null, "parents": [{"sha": "53fcf729090af5a8269e363f3d737f023a17cf35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53fcf729090af5a8269e363f3d737f023a17cf35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53fcf729090af5a8269e363f3d737f023a17cf35"}], "stats": {"total": 805, "additions": 804, "deletions": 1}, "files": [{"sha": "dc4d5475ec5930ec8190396764c1f3017b03d308", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17130a609e04ed5980d27bbc7df4922f1e087db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17130a609e04ed5980d27bbc7df4922f1e087db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f17130a609e04ed5980d27bbc7df4922f1e087db", "patch": "@@ -1,5 +1,10 @@\n 2019-02-13  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/89303\n+\t* tree-ssa-structalias.c (set_uids_in_ptset): Or in vi->is_heap_var\n+\tinto pt->vars_contains_escaped_heap instead of setting\n+\tpt->vars_contains_escaped_heap to it.\n+\n \tPR middle-end/89281\n \t* optabs.c (prepare_cmp_insn): Use UINTVAL (size) instead of\n \tINTVAL (size), compare it to GET_MODE_MASK instead of"}, {"sha": "d3223f0e313c0c2886682098d5b98eb468c199a2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17130a609e04ed5980d27bbc7df4922f1e087db/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17130a609e04ed5980d27bbc7df4922f1e087db/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f17130a609e04ed5980d27bbc7df4922f1e087db", "patch": "@@ -1,3 +1,9 @@\n+2019-02-13  Jonathan Wakely  <jwakely@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/89303\n+\t* g++.dg/torture/pr89303.C: New test.\n+\n 2019-02-13  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/88986"}, {"sha": "94a0f90cd533ba7c92c7bfaab11eda5855d7340d", "filename": "gcc/testsuite/g++.dg/torture/pr89303.C", "status": "added", "additions": 792, "deletions": 0, "changes": 792, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17130a609e04ed5980d27bbc7df4922f1e087db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr89303.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17130a609e04ed5980d27bbc7df4922f1e087db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr89303.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr89303.C?ref=f17130a609e04ed5980d27bbc7df4922f1e087db", "patch": "@@ -0,0 +1,792 @@\n+// PR middle-end/89303\n+// { dg-do run }\n+// { dg-additional-options \"-std=c++14\" }\n+\n+namespace std\n+{\n+  typedef __SIZE_TYPE__ size_t;\n+  typedef decltype(nullptr) nullptr_t;\n+\n+  template<typename _Tp, _Tp __v>\n+    struct integral_constant\n+    {\n+      static constexpr _Tp value = __v;\n+      typedef _Tp value_type;\n+      typedef integral_constant<_Tp, __v> type;\n+      constexpr operator value_type() const noexcept { return value; }\n+      constexpr value_type operator()() const noexcept { return value; }\n+    };\n+\n+  template<typename _Tp, _Tp __v>\n+    constexpr _Tp integral_constant<_Tp, __v>::value;\n+\n+  typedef integral_constant<bool, true> true_type;\n+  typedef integral_constant<bool, false> false_type;\n+\n+  template<bool __v>\n+    using __bool_constant = integral_constant<bool, __v>;\n+\n+  template<bool, typename, typename>\n+    struct conditional;\n+\n+  template<typename...>\n+    struct __and_;\n+\n+  template<>\n+    struct __and_<>\n+    : public true_type\n+    { };\n+\n+  template<typename _B1>\n+    struct __and_<_B1>\n+    : public _B1\n+    { };\n+\n+  template<typename _B1, typename _B2>\n+    struct __and_<_B1, _B2>\n+    : public conditional<_B1::value, _B2, _B1>::type\n+    { };\n+\n+  template<typename _B1, typename _B2, typename _B3, typename... _Bn>\n+    struct __and_<_B1, _B2, _B3, _Bn...>\n+    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type\n+    { };\n+\n+  template<typename>\n+    struct remove_cv;\n+\n+  template<typename>\n+    struct __is_void_helper\n+    : public false_type { };\n+\n+  template<>\n+    struct __is_void_helper<void>\n+    : public true_type { };\n+\n+  template<typename _Tp>\n+    struct is_void\n+    : public __is_void_helper<typename remove_cv<_Tp>::type>::type\n+    { };\n+\n+  template<typename _Tp, typename _Up = _Tp&&>\n+    _Up\n+    __declval(int);\n+\n+  template<typename _Tp>\n+    _Tp\n+    __declval(long);\n+\n+  template<typename _Tp>\n+    auto declval() noexcept -> decltype(__declval<_Tp>(0));\n+\n+  template<typename, typename>\n+    struct is_same\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct is_same<_Tp, _Tp>\n+    : public true_type { };\n+\n+  template<typename _Tp>\n+    struct remove_const\n+    { typedef _Tp type; };\n+\n+  template<typename _Tp>\n+    struct remove_const<_Tp const>\n+    { typedef _Tp type; };\n+\n+  template<typename _Tp>\n+    struct remove_volatile\n+    { typedef _Tp type; };\n+\n+  template<typename _Tp>\n+    struct remove_volatile<_Tp volatile>\n+    { typedef _Tp type; };\n+\n+  template<typename _Tp>\n+    struct remove_cv\n+    {\n+      typedef typename\n+      remove_const<typename remove_volatile<_Tp>::type>::type type;\n+    };\n+\n+  template<typename _Tp>\n+    struct remove_reference\n+    { typedef _Tp type; };\n+\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&>\n+    { typedef _Tp type; };\n+\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&&>\n+    { typedef _Tp type; };\n+\n+  template<bool, typename _Tp = void>\n+    struct enable_if\n+    { };\n+\n+  template<typename _Tp>\n+    struct enable_if<true, _Tp>\n+    { typedef _Tp type; };\n+\n+  template<typename... _Cond>\n+    using _Require = typename enable_if<__and_<_Cond...>::value>::type;\n+\n+  template<bool _Cond, typename _Iftrue, typename _Iffalse>\n+    struct conditional\n+    { typedef _Iftrue type; };\n+\n+  template<typename _Iftrue, typename _Iffalse>\n+    struct conditional<false, _Iftrue, _Iffalse>\n+    { typedef _Iffalse type; };\n+\n+  template<typename _Tp>\n+    struct __declval_protector\n+    {\n+      static const bool __stop = false;\n+    };\n+\n+  template<typename _Tp>\n+    auto declval() noexcept -> decltype(__declval<_Tp>(0))\n+    {\n+      static_assert(__declval_protector<_Tp>::__stop,\n+      \"declval() must not be used!\");\n+      return __declval<_Tp>(0);\n+    }\n+\n+  namespace void_details {\n+    template <class... >\n+    struct make_void { using type = void; };\n+}\n+\n+template <class... T> using __void_t = typename void_details ::make_void<T...>::type;\n+\n+  template<typename _Tp>\n+    inline constexpr _Tp*\n+    __addressof(_Tp& __r) noexcept\n+    {\n+      return reinterpret_cast<_Tp*>\n+\t(&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));\n+    }\n+\n+  template<typename _Tp>\n+    constexpr _Tp&&\n+    forward(typename std::remove_reference<_Tp>::type& __t) noexcept\n+    { return static_cast<_Tp&&>(__t); }\n+\n+  template<typename _Tp>\n+    constexpr _Tp&&\n+    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept\n+    {\n+      return static_cast<_Tp&&>(__t);\n+    }\n+\n+  template<typename _Tp>\n+    constexpr typename std::remove_reference<_Tp>::type&&\n+    move(_Tp&& __t) noexcept\n+    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }\n+}\n+       \n+inline void* operator new(std::size_t, void* p) { return p; }\n+\n+extern \"C\" void* malloc(std::size_t);\n+extern \"C\" void free(void*);\n+\n+namespace std\n+{\n+  template<typename T>\n+    class allocator\n+    {\n+    public:\n+      using value_type = T;\n+\n+      allocator() { }\n+\n+      template<typename U>\n+        allocator(const allocator<U>&) { }\n+\n+      T* allocate(size_t n) { return (T*)malloc(n*sizeof(T)); }\n+      void deallocate(T* p, size_t) { free(p); }\n+\n+      template<typename U, typename... Args>\n+        void construct(U* p, Args&&... args)\n+        { ::new((void*)p) U(args...); }\n+\n+      template<typename U>\n+        void destroy(U* p)\n+        { p->~U(); }\n+    };\n+\n+  class __undefined;\n+\n+  template<typename _Tp, typename _Up>\n+    struct __replace_first_arg\n+    { };\n+\n+  template<template<typename, typename...> class _Template, typename _Up,\n+           typename _Tp, typename... _Types>\n+    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>\n+    { using type = _Template<_Up, _Types...>; };\n+\n+  struct __allocator_traits_base\n+  {\n+    template<typename _Tp, typename _Up, typename = void>\n+      struct __rebind : __replace_first_arg<_Tp, _Up> { };\n+\n+    template<typename _Tp, typename _Up>\n+      struct __rebind<_Tp, _Up,\n+        __void_t<typename _Tp::template rebind<_Up>::other>>\n+      { using type = typename _Tp::template rebind<_Up>::other; };\n+  };\n+\n+  template<typename _Alloc, typename _Up>\n+    using __alloc_rebind\n+      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;\n+\n+  template<typename _Alloc>\n+    struct allocator_traits;\n+\n+  template<typename _Tp>\n+    struct allocator_traits<allocator<_Tp>>\n+    {\n+      using allocator_type = allocator<_Tp>;\n+      using value_type = _Tp;\n+      using pointer = _Tp*;\n+      using const_pointer = const _Tp*;\n+      using size_type = std::size_t;\n+\n+      static pointer\n+      allocate(allocator_type& __a, size_type __n)\n+      { return __a.allocate(__n); }\n+\n+      static void\n+      deallocate(allocator_type& __a, pointer __p, size_type __n)\n+      { __a.deallocate(__p, __n); }\n+\n+      template<typename _Up, typename... _Args>\n+        static void\n+        construct(allocator_type& __a, _Up* __p, _Args&&... __args)\n+        { __a.construct(__p, std::forward<_Args>(__args)...); }\n+\n+      template<typename _Up>\n+        static void\n+        destroy(allocator_type& __a, _Up* __p)\n+        { __a.destroy(__p); }\n+    };\n+\n+  template<typename _Alloc>\n+    struct __allocated_ptr\n+    {\n+      using pointer = typename allocator_traits<_Alloc>::pointer;\n+      using value_type = typename allocator_traits<_Alloc>::value_type;\n+\n+      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept\n+      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)\n+      { }\n+\n+      template<typename _Ptr,\n+        typename _Req = _Require<is_same<_Ptr, value_type*>>>\n+      __allocated_ptr(_Alloc& __a, _Ptr __ptr)\n+      : _M_alloc(std::__addressof(__a)),\n+      _M_ptr(__ptr)\n+      { }\n+\n+      __allocated_ptr(__allocated_ptr&& __gd) noexcept\n+      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)\n+      { __gd._M_ptr = nullptr; }\n+\n+      ~__allocated_ptr()\n+      {\n+        if (_M_ptr != nullptr)\n+          std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);\n+      }\n+\n+      __allocated_ptr&\n+      operator=(std::nullptr_t) noexcept\n+      {\n+        _M_ptr = nullptr;\n+        return *this;\n+      }\n+\n+      value_type* get() { return _M_ptr; }\n+\n+    private:\n+      _Alloc* _M_alloc;\n+      pointer _M_ptr;\n+    };\n+\n+  template<typename _Alloc>\n+    __allocated_ptr<_Alloc>\n+    __allocate_guarded(_Alloc& __a)\n+    {\n+      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };\n+    }\n+\n+  template<typename _Tp>\n+    struct __aligned_buffer\n+    {\n+      alignas(__alignof__(_Tp)) unsigned char _M_storage[sizeof(_Tp)];\n+      __aligned_buffer() = default;\n+\n+      void*\n+      _M_addr() noexcept\n+      {\n+        return static_cast<void*>(&_M_storage);\n+      }\n+\n+      const void*\n+      _M_addr() const noexcept\n+      {\n+        return static_cast<const void*>(&_M_storage);\n+      }\n+\n+      _Tp*\n+      _M_ptr() noexcept\n+      { return static_cast<_Tp*>(_M_addr()); }\n+\n+      const _Tp*\n+      _M_ptr() const noexcept\n+      { return static_cast<const _Tp*>(_M_addr()); }\n+    };\n+\n+  class bad_weak_ptr { };\n+\n+  inline void\n+  __throw_bad_weak_ptr()\n+  { (throw (bad_weak_ptr())); }\n+\n+    class _Sp_counted_base\n+    {\n+    public:\n+      _Sp_counted_base() noexcept\n+      : _M_use_count(1), _M_weak_count(1) { }\n+\n+      virtual\n+      ~_Sp_counted_base() noexcept\n+      { }\n+\n+      virtual void\n+      _M_dispose() noexcept = 0;\n+\n+      virtual void\n+      _M_destroy() noexcept\n+      { delete this; }\n+\n+      void\n+      _M_add_ref_copy()\n+      { ++_M_use_count; }\n+\n+      void\n+      _M_add_ref_lock()\n+      {\n+        if (_M_use_count == 0)\n+          __throw_bad_weak_ptr();\n+        ++_M_use_count;\n+      }\n+\n+      void\n+      _M_release() noexcept\n+      {\n+        if (--_M_use_count == 0)\n+        {\n+          _M_dispose();\n+          if (--_M_weak_count == 0)\n+            _M_destroy();\n+        }\n+      }\n+\n+      void\n+      _M_weak_add_ref() noexcept\n+      { ++_M_weak_count; }\n+\n+      void\n+      _M_weak_release() noexcept\n+      {\n+        if (--_M_weak_count == 0)\n+          _M_destroy();\n+      }\n+\n+      long\n+      _M_get_use_count() const noexcept\n+      {\n+        return _M_use_count;\n+      }\n+\n+    private:\n+      _Sp_counted_base(_Sp_counted_base const&) = delete;\n+      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;\n+\n+      int _M_use_count;\n+      int _M_weak_count;\n+    };\n+\n+  template<typename _Tp>\n+    class shared_ptr;\n+\n+  template<typename _Tp>\n+    class weak_ptr;\n+\n+  template<typename _Tp>\n+    class enable_shared_from_this;\n+\n+  class __weak_count;\n+\n+  class __shared_count;\n+\n+  template<typename _Alloc>\n+    struct _Sp_alloc_shared_tag\n+    {\n+      const _Alloc& _M_a;\n+    };\n+\n+  template<typename _Tp, typename _Alloc>\n+    class _Sp_counted_ptr_inplace final : public _Sp_counted_base\n+    {\n+      class _Impl : _Alloc\n+      {\n+      public:\n+        explicit _Impl(_Alloc __a) noexcept : _Alloc(__a) { }\n+\n+        _Alloc& _M_alloc() noexcept { return *this; }\n+\n+        __aligned_buffer<_Tp> _M_storage;\n+      };\n+\n+    public:\n+      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;\n+\n+      template<typename... _Args>\n+        _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)\n+        : _M_impl(__a)\n+        {\n+          allocator_traits<_Alloc>::construct(__a, _M_ptr(),\n+              std::forward<_Args>(__args)...);\n+        }\n+\n+      ~_Sp_counted_ptr_inplace() noexcept { }\n+\n+      virtual void\n+      _M_dispose() noexcept\n+      {\n+        allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());\n+      }\n+\n+      virtual void\n+      _M_destroy() noexcept\n+      {\n+        __allocator_type __a(_M_impl._M_alloc());\n+        __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };\n+        this->~_Sp_counted_ptr_inplace();\n+      }\n+\n+    private:\n+      friend class __shared_count;\n+\n+      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }\n+\n+      _Impl _M_impl;\n+    };\n+\n+  class __shared_count\n+  {\n+  public:\n+    constexpr __shared_count() noexcept : _M_pi(0)\n+    { }\n+\n+    template<typename _Tp, typename _Alloc, typename... _Args>\n+      __shared_count(_Tp*& __p, _Sp_alloc_shared_tag<_Alloc> __a,\n+          _Args&&... __args)\n+      {\n+        typedef _Sp_counted_ptr_inplace<_Tp, _Alloc> _Sp_cp_type;\n+        typename _Sp_cp_type::__allocator_type __a2(__a._M_a);\n+        auto __guard = std::__allocate_guarded(__a2);\n+        _Sp_cp_type* __mem = __guard.get();\n+        auto __pi = ::new (__mem)\n+          _Sp_cp_type(__a._M_a, std::forward<_Args>(__args)...);\n+        __guard = nullptr;\n+        _M_pi = __pi;\n+        __p = __pi->_M_ptr();\n+      }\n+\n+    ~__shared_count() noexcept\n+    {\n+      if (_M_pi != nullptr)\n+        _M_pi->_M_release();\n+    }\n+\n+    __shared_count(const __shared_count& __r) noexcept\n+    : _M_pi(__r._M_pi)\n+    {\n+      if (_M_pi != 0)\n+        _M_pi->_M_add_ref_copy();\n+    }\n+\n+    explicit __shared_count(const __weak_count& __r);\n+\n+    long\n+    _M_get_use_count() const noexcept\n+    { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n+\n+  private:\n+    friend class __weak_count;\n+\n+    _Sp_counted_base* _M_pi;\n+  };\n+\n+  class __weak_count\n+  {\n+  public:\n+    constexpr __weak_count() noexcept : _M_pi(nullptr)\n+    { }\n+\n+    __weak_count(const __shared_count& __r) noexcept\n+    : _M_pi(__r._M_pi)\n+    {\n+      if (_M_pi != nullptr)\n+        _M_pi->_M_weak_add_ref();\n+    }\n+\n+    __weak_count(const __weak_count& __r) noexcept\n+    : _M_pi(__r._M_pi)\n+    {\n+      if (_M_pi != nullptr)\n+        _M_pi->_M_weak_add_ref();\n+    }\n+\n+    __weak_count(__weak_count&& __r) noexcept\n+    : _M_pi(__r._M_pi)\n+    { __r._M_pi = nullptr; }\n+\n+    ~__weak_count() noexcept\n+    {\n+      if (_M_pi != nullptr)\n+      {\n+        _M_pi->_M_weak_release();\n+      }\n+    }\n+\n+    __weak_count&\n+    operator=(const __shared_count& __r) noexcept\n+    {\n+      _Sp_counted_base* __tmp = __r._M_pi;\n+      if (__tmp != nullptr)\n+        __tmp->_M_weak_add_ref();\n+      if (_M_pi != nullptr)\n+        _M_pi->_M_weak_release();\n+      _M_pi = __tmp;\n+      return *this;\n+    }\n+\n+    long\n+    _M_get_use_count() const noexcept\n+    { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }\n+\n+  private:\n+    friend class __shared_count;\n+\n+    _Sp_counted_base* _M_pi;\n+  };\n+\n+  inline\n+  __shared_count::__shared_count(const __weak_count& __r)\n+  : _M_pi(__r._M_pi)\n+  {\n+    if (_M_pi != nullptr)\n+      _M_pi->_M_add_ref_lock();\n+    else\n+      __throw_bad_weak_ptr();\n+  }\n+\n+  template<typename _Tp>\n+    class shared_ptr\n+    {\n+    public:\n+      using element_type = _Tp;\n+\n+      constexpr shared_ptr() noexcept\n+        : _M_ptr(0), _M_refcount()\n+        { }\n+\n+      shared_ptr(const shared_ptr&) noexcept = default;\n+      shared_ptr& operator=(const shared_ptr&) noexcept = default;\n+      ~shared_ptr() = default;\n+\n+      template<typename _Yp>\n+\texplicit shared_ptr(const weak_ptr<_Yp>& __r)\n+\t: _M_refcount(__r._M_refcount) // may throw\n+\t{\n+\t  // It is now safe to copy __r._M_ptr, as\n+\t  // _M_refcount(__r._M_refcount) did not throw.\n+\t  _M_ptr = __r._M_ptr;\n+\t}\n+\n+      long\n+      use_count() const noexcept\n+      { return _M_refcount._M_get_use_count(); }\n+\n+      element_type* operator->() const noexcept { return _M_ptr; }\n+\n+    protected:\n+\n+      template<typename _Alloc, typename... _Args>\n+        shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)\n+        : _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)\n+        { _M_enable_shared_from_this_with(_M_ptr); }\n+\n+      template<typename _Tp1, typename _Alloc,\n+        typename... _Args>\n+          friend shared_ptr<_Tp1>\n+          allocate_shared(const _Alloc& __a, _Args&&... __args);\n+\n+      friend class weak_ptr<_Tp>;\n+\n+    private:\n+\n+      template<typename _Yp>\n+        using __esft_base_t = decltype(__enable_shared_from_this_base(\n+              std::declval<const __shared_count&>(),\n+              std::declval<_Yp*>()));\n+\n+      template<typename _Yp, typename = void>\n+        struct __has_esft_base\n+        : false_type { };\n+\n+      template<typename _Yp>\n+        struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>\n+        : true_type { };\n+\n+      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>\n+        typename enable_if<__has_esft_base<_Yp2>::value>::type\n+        _M_enable_shared_from_this_with(_Yp* __p) noexcept\n+        {\n+          if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))\n+            __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);\n+        }\n+\n+      template<typename _Tp1> friend class shared_ptr;\n+      template<typename _Tp1> friend class weak_ptr;\n+\n+      element_type* _M_ptr;\n+      __shared_count _M_refcount;\n+    };\n+\n+  template<typename _Tp>\n+    class weak_ptr\n+    {\n+    public:\n+      using element_type = _Tp;\n+\n+      constexpr weak_ptr() noexcept\n+      : _M_ptr(nullptr), _M_refcount()\n+      { }\n+\n+      weak_ptr(const weak_ptr&) noexcept = default;\n+\n+      ~weak_ptr() = default;\n+\n+      weak_ptr&\n+      operator=(const weak_ptr& __r) noexcept = default;\n+\n+      long\n+      use_count() const noexcept\n+      { return _M_refcount._M_get_use_count(); }\n+\n+    private:\n+\n+      void\n+      _M_assign(_Tp* __ptr, const __shared_count& __refcount) noexcept\n+      {\n+        if (use_count() == 0)\n+        {\n+          _M_ptr = __ptr;\n+          _M_refcount = __refcount;\n+        }\n+      }\n+\n+      template<typename _Tp1> friend class shared_ptr;\n+      template<typename _Tp1> friend class weak_ptr;\n+      friend class enable_shared_from_this<_Tp>;\n+\n+      element_type* _M_ptr;\n+      __weak_count _M_refcount;\n+    };\n+\n+  template<typename _Tp>\n+    class enable_shared_from_this\n+    {\n+    protected:\n+      constexpr enable_shared_from_this() noexcept { }\n+\n+      enable_shared_from_this(const enable_shared_from_this&) noexcept { }\n+\n+      enable_shared_from_this&\n+      operator=(const enable_shared_from_this&) noexcept\n+      { return *this; }\n+\n+      ~enable_shared_from_this() { }\n+\n+    public:\n+      shared_ptr<_Tp>\n+      shared_from_this()\n+      { return shared_ptr<_Tp>(this->_M_weak_this); }\n+\n+      shared_ptr<const _Tp>\n+      shared_from_this() const\n+      { return shared_ptr<const _Tp>(this->_M_weak_this); }\n+\n+    private:\n+      template<typename _Tp1>\n+        void\n+        _M_weak_assign(_Tp1* __p, const __shared_count& __n) const noexcept\n+        { _M_weak_this._M_assign(__p, __n); }\n+\n+      friend const enable_shared_from_this*\n+      __enable_shared_from_this_base(const __shared_count&,\n+         const enable_shared_from_this* __p)\n+      { return __p; }\n+\n+      template<typename>\n+        friend class shared_ptr;\n+\n+      mutable weak_ptr<_Tp> _M_weak_this;\n+    };\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    inline shared_ptr<_Tp>\n+    allocate_shared(const _Alloc& __a, _Args&&... __args)\n+    {\n+      return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},\n+        std::forward<_Args>(__args)...);\n+    }\n+\n+  template<typename _Tp, typename... _Args>\n+    inline shared_ptr<_Tp>\n+    make_shared(_Args&&... __args)\n+    {\n+      typedef typename std::remove_const<_Tp>::type _Tp_nc;\n+      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),\n+           std::forward<_Args>(__args)...);\n+    }\n+}\n+\n+class blob final: public std::enable_shared_from_this<blob>\n+{\n+  int* data;\n+\n+public:\n+  blob() { data = new int; }\n+  ~blob() { delete data; }\n+};\n+\n+static int\n+bar(std::shared_ptr<blob>)\n+{\n+  return 0;\n+}\n+\n+int main()\n+{\n+  std::shared_ptr<blob> tg = std::make_shared<blob>();\n+  return tg->shared_from_this().use_count() - 2;\n+}"}, {"sha": "f930d87840c2e75de2f0b140ff01d7a0f504238d", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17130a609e04ed5980d27bbc7df4922f1e087db/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17130a609e04ed5980d27bbc7df4922f1e087db/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=f17130a609e04ed5980d27bbc7df4922f1e087db", "patch": "@@ -6412,7 +6412,7 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt,\n \t      && bitmap_bit_p (escaped_vi->solution, i)))\n \t{\n \t  pt->vars_contains_escaped = true;\n-\t  pt->vars_contains_escaped_heap = vi->is_heap_var;\n+\t  pt->vars_contains_escaped_heap |= vi->is_heap_var;\n \t}\n \n       if (vi->is_restrict_var)"}]}