{"sha": "24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRkNGIzZDUwMDIwMGNhYWU2MWY3NzkyNGI0ZWJlMWJkMmI1ZTBiZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T13:02:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T13:02:44Z"}, "message": "[multiple changes]\n\n2014-08-04  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): In GNATprove mode,\n\tdo not generate two Itypes with the same name for an array\n\tdefinition.\n\t* sinfo.ads: Expand doc on GNATprove mode.\n\n2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Expand_Freeze_Record_Type): Set the finalization\n\tmaster and storage pool attributes on the root type of an\n\tanonymous access type.\n\t* exp_ch4.adb (Expand_N_Allocator): Set the finalization master\n\tand storage pool attributes on the root type of an anonymous\n\taccess type.\n\n2014-08-04  Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_ch3.adb: Minor reformatting.\n\t* tb-alvms.c, tb-alvxw.c, tb-ivms.c: Removed.\n\t* tracebak.c: Remove use of above files.\n\t* gcc-interface/Makefile.in: Update dependencies.\n\n2014-08-04  Pierre-Marie Derodat  <derodat@adacore.com>\n\n\t* gcc-interface/utils.c (gnat_set_type_context): Also set the\n\tcontext for parallel types' TYPE_STUB_DECL.  Do not change\n\tanything if the context is already set for them.\n\t(gnat_pushdecl): Update the comment for calls to\n\tgnat_set_type_context to mention parallel types.\n\t(add_parallel_type): When adding a context-less parallel type to\n\ta type that has a context, propagate the context from the latter\n\ttype to the former.\n\t(process_deferred_decl_context): Call gnat_set_type_context\n\trather than manually setting the type context.\n\t(build_unc_object_type): Call gnat_set_type_context on the\n\ttemplate type.\n\nFrom-SVN: r213584", "tree": {"sha": "cb6541747ff86af28069e975fb55ae8015015976", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb6541747ff86af28069e975fb55ae8015015976"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/comments", "author": null, "committer": null, "parents": [{"sha": "69fff50e08365770deca864efd7a904ac9eb25e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69fff50e08365770deca864efd7a904ac9eb25e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69fff50e08365770deca864efd7a904ac9eb25e0"}], "stats": {"total": 1732, "additions": 190, "deletions": 1542}, "files": [{"sha": "4cc36d8a46123c26df03da608a2f7dd849b502e8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "patch": "@@ -1,3 +1,41 @@\n+2014-08-04  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): In GNATprove mode,\n+\tdo not generate two Itypes with the same name for an array\n+\tdefinition.\n+\t* sinfo.ads: Expand doc on GNATprove mode.\n+\n+2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_Freeze_Record_Type): Set the finalization\n+\tmaster and storage pool attributes on the root type of an\n+\tanonymous access type.\n+\t* exp_ch4.adb (Expand_N_Allocator): Set the finalization master\n+\tand storage pool attributes on the root type of an anonymous\n+\taccess type.\n+\n+2014-08-04  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_ch3.adb: Minor reformatting.\n+\t* tb-alvms.c, tb-alvxw.c, tb-ivms.c: Removed.\n+\t* tracebak.c: Remove use of above files.\n+\t* gcc-interface/Makefile.in: Update dependencies.\n+\n+2014-08-04  Pierre-Marie Derodat  <derodat@adacore.com>\n+\n+\t* gcc-interface/utils.c (gnat_set_type_context): Also set the\n+\tcontext for parallel types' TYPE_STUB_DECL.  Do not change\n+\tanything if the context is already set for them.\n+\t(gnat_pushdecl): Update the comment for calls to\n+\tgnat_set_type_context to mention parallel types.\n+\t(add_parallel_type): When adding a context-less parallel type to\n+\ta type that has a context, propagate the context from the latter\n+\ttype to the former.\n+\t(process_deferred_decl_context): Call gnat_set_type_context\n+\trather than manually setting the type context.\n+\t(build_unc_object_type): Call gnat_set_type_context on the\n+\ttemplate type.\n+\n 2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_ch5.adb (Expand_N_Case_Statement): If a choice is a"}, {"sha": "476b42e3c07eec4d99c2147fca0d06e18995e019", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 83, "deletions": 89, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "patch": "@@ -7235,43 +7235,47 @@ package body Exp_Ch3 is\n                         Master_Built := True;\n \n                         --  All anonymous access-to-controlled types allocate\n-                        --  on the global pool.\n+                        --  on the global pool. Note that the finalization\n+                        --  master and the associated storage pool must be set\n+                        --  on the root type (both are \"root type only\").\n \n                         Set_Associated_Storage_Pool\n-                          (Comp_Typ, RTE (RE_Global_Pool_Object));\n+                          (Root_Type (Comp_Typ), RTE (RE_Global_Pool_Object));\n \n                         Build_Finalization_Master\n-                          (Typ        => Comp_Typ,\n+                          (Typ        => Root_Type (Comp_Typ),\n                            Ins_Node   => Ins_Node,\n                            Encl_Scope => Encl_Scope);\n \n                         Fin_Mas_Id := Finalization_Master (Comp_Typ);\n \n                      --  Subsequent anonymous access-to-controlled components\n-                     --  reuse the already available master.\n+                     --  reuse the available master.\n \n                      else\n                         --  All anonymous access-to-controlled types allocate\n-                        --  on the global pool.\n+                        --  on the global pool. Note that both the finalization\n+                        --  master and the associated storage pool must be set\n+                        --  on the root type (both are \"root type only\").\n \n                         Set_Associated_Storage_Pool\n-                          (Comp_Typ, RTE (RE_Global_Pool_Object));\n+                          (Root_Type (Comp_Typ), RTE (RE_Global_Pool_Object));\n \n                         --  Shared the master among multiple components\n \n-                        Set_Finalization_Master (Comp_Typ, Fin_Mas_Id);\n+                        Set_Finalization_Master\n+                          (Root_Type (Comp_Typ), Fin_Mas_Id);\n \n                         --  Convert the master into a heterogeneous collection.\n                         --  Generate:\n-                        --\n                         --    Set_Is_Heterogeneous (<Fin_Mas_Id>);\n \n                         if not Attributes_Set then\n                            Attributes_Set := True;\n \n                            Insert_Action (Ins_Node,\n                              Make_Procedure_Call_Statement (Loc,\n-                               Name =>\n+                               Name                   =>\n                                  New_Occurrence_Of\n                                    (RTE (RE_Set_Is_Heterogeneous), Loc),\n                                Parameter_Associations => New_List (\n@@ -7330,9 +7334,7 @@ package body Exp_Ch3 is\n       --  Primitive operations of tagged types are frozen when the dispatch\n       --  table is constructed.\n \n-      if not Comes_From_Source (Typ)\n-        or else Is_Tagged_Type (Typ)\n-      then\n+      if not Comes_From_Source (Typ) or else Is_Tagged_Type (Typ) then\n          return;\n       end if;\n \n@@ -7342,7 +7344,7 @@ package body Exp_Ch3 is\n          if Present (Stream_Op)\n            and then Is_Subprogram (Stream_Op)\n            and then Nkind (Unit_Declaration_Node (Stream_Op)) =\n-                      N_Subprogram_Declaration\n+                                                    N_Subprogram_Declaration\n            and then not Is_Frozen (Stream_Op)\n          then\n             Append_Freeze_Actions (Typ, Freeze_Entity (Stream_Op, N));\n@@ -7371,9 +7373,9 @@ package body Exp_Ch3 is\n       if Present (Access_Types_To_Process (N)) then\n          declare\n             E : Elmt_Id := First_Elmt (Access_Types_To_Process (N));\n+\n          begin\n             while Present (E) loop\n-\n                if Is_Remote_Access_To_Class_Wide_Type (Node (E)) then\n                   Validate_RACW_Primitives (Node (E));\n                   RACW_Seen := True;\n@@ -7395,7 +7397,6 @@ package body Exp_Ch3 is\n       if Is_Record_Type (Def_Id) then\n          if Ekind (Def_Id) = E_Record_Type then\n             Expand_Freeze_Record_Type (N);\n-\n          elsif Is_Class_Wide_Type (Def_Id) then\n             Expand_Freeze_Class_Wide_Type (N);\n          end if;\n@@ -7460,21 +7461,18 @@ package body Exp_Ch3 is\n                   if Is_Composite_Type (Desig_Type)\n                     and then not Is_Constrained (Desig_Type)\n                   then\n-                     DT_Size :=\n-                       Make_Integer_Literal (Loc, 0);\n-\n-                     DT_Align :=\n-                       Make_Integer_Literal (Loc, Maximum_Alignment);\n+                     DT_Size  := Make_Integer_Literal (Loc, 0);\n+                     DT_Align := Make_Integer_Literal (Loc, Maximum_Alignment);\n \n                   else\n                      DT_Size :=\n                        Make_Attribute_Reference (Loc,\n-                         Prefix => New_Occurrence_Of (Desig_Type, Loc),\n+                         Prefix         => New_Occurrence_Of (Desig_Type, Loc),\n                          Attribute_Name => Name_Max_Size_In_Storage_Elements);\n \n                      DT_Align :=\n                        Make_Attribute_Reference (Loc,\n-                         Prefix => New_Occurrence_Of (Desig_Type, Loc),\n+                         Prefix         => New_Occurrence_Of (Desig_Type, Loc),\n                          Attribute_Name => Name_Alignment);\n                   end if;\n \n@@ -7508,26 +7506,26 @@ package body Exp_Ch3 is\n                   Append_Freeze_Action (Freeze_Action_Typ,\n                     Make_Object_Declaration (Loc,\n                       Defining_Identifier => Pool_Object,\n-                      Object_Definition =>\n+                      Object_Definition   =>\n                         Make_Subtype_Indication (Loc,\n                           Subtype_Mark =>\n                             New_Occurrence_Of\n                               (RTE (RE_Stack_Bounded_Pool), Loc),\n \n-                          Constraint =>\n+                          Constraint   =>\n                             Make_Index_Or_Discriminant_Constraint (Loc,\n                               Constraints => New_List (\n \n-                              --  First discriminant is the Pool Size\n+                                --  First discriminant is the Pool Size\n \n                                 New_Occurrence_Of (\n                                   Storage_Size_Variable (Def_Id), Loc),\n \n-                              --  Second discriminant is the element size\n+                                --  Second discriminant is the element size\n \n                                 DT_Size,\n \n-                              --  Third discriminant is the alignment\n+                                --  Third discriminant is the alignment\n \n                                 DT_Align)))));\n                end;\n@@ -7575,8 +7573,8 @@ package body Exp_Ch3 is\n \n                      if Is_Ancestor (RSPWS, Etype (Pool)) then\n                         Error_Msg_N\n-                          (\"??subpool access type has deeper accessibility \" &\n-                           \"level than pool\", Def_Id);\n+                          (\"??subpool access type has deeper accessibility \"\n+                           & \"level than pool\", Def_Id);\n \n                         Append_Freeze_Action (Def_Id,\n                           Make_Raise_Program_Error (Loc,\n@@ -7593,10 +7591,9 @@ package body Exp_Ch3 is\n                      elsif Is_Class_Wide_Type (Etype (Pool)) then\n                         Append_Freeze_Action (Def_Id,\n                           Make_If_Statement (Loc,\n-                            Condition =>\n+                            Condition       =>\n                               Make_In (Loc,\n-                                Left_Opnd =>\n-                                  New_Occurrence_Of (Pool, Loc),\n+                                Left_Opnd  => New_Occurrence_Of (Pool, Loc),\n                                 Right_Opnd =>\n                                   New_Occurrence_Of\n                                     (Class_Wide_Type (RSPWS), Loc)),\n@@ -8016,7 +8013,7 @@ package body Exp_Ch3 is\n            Make_Aggregate (Loc,\n              Component_Associations => New_List (\n                Make_Component_Association (Loc,\n-                 Choices => New_List (\n+                 Choices    => New_List (\n                    Make_Others_Choice (Loc)),\n                  Expression =>\n                    Get_Simple_Init_Val\n@@ -8112,17 +8109,16 @@ package body Exp_Ch3 is\n             --  other checks.\n \n             declare\n-               Bod : Node_Id;\n+               Bod    : Node_Id;\n                Inv_Id : constant Entity_Id := Invariant_Procedure (Typ);\n-               Call   : constant Node_Id :=\n+               Call   : constant Node_Id   :=\n                  Make_Procedure_Call_Statement (Sloc (N),\n-                   Name => New_Occurrence_Of (Proc_Id, Loc),\n+                   Name                   => New_Occurrence_Of (Proc_Id, Loc),\n                    Parameter_Associations =>\n                      New_List\n                        (New_Occurrence_Of (First_Formal (Inv_Id), Loc)));\n \n             begin\n-\n                --  The invariant  body has not been analyzed yet, so we do a\n                --  sequential search forward, and retrieve it by name.\n \n@@ -8229,11 +8225,10 @@ package body Exp_Ch3 is\n \n       Formals := New_List (\n         Make_Parameter_Specification (Loc,\n-          Defining_Identifier =>\n-            Make_Defining_Identifier (Loc, Name_uInit),\n-          In_Present  => True,\n-          Out_Present => True,\n-          Parameter_Type => New_Occurrence_Of (Typ, Loc)));\n+          Defining_Identifier => Make_Defining_Identifier (Loc, Name_uInit),\n+          In_Present          => True,\n+          Out_Present         => True,\n+          Parameter_Type      => New_Occurrence_Of (Typ, Loc)));\n \n       --  For task record value, or type that contains tasks, add two more\n       --  formals, _Master : Master_Id and _Chain : in out Activation_Chain\n@@ -8324,9 +8319,9 @@ package body Exp_Ch3 is\n          if not Is_Ancestor (Iface, Typ, Use_Full_View => True) then\n             Append_To (Stmts_List,\n               Make_Assignment_Statement (Loc,\n-                Name =>\n+                Name       =>\n                   Make_Selected_Component (Loc,\n-                    Prefix => New_Copy_Tree (Target),\n+                    Prefix        => New_Copy_Tree (Target),\n                     Selector_Name => New_Occurrence_Of (Tag_Comp, Loc)),\n                 Expression =>\n                   New_Occurrence_Of (Iface_Tag, Loc)));\n@@ -8362,8 +8357,8 @@ package body Exp_Ch3 is\n \n             Append_To (Stmts_List,\n               Make_Procedure_Call_Statement (Loc,\n-                Name => New_Occurrence_Of\n-                          (RTE (RE_Set_Dynamic_Offset_To_Top), Loc),\n+                Name                   =>\n+                  New_Occurrence_Of (RTE (RE_Set_Dynamic_Offset_To_Top), Loc),\n                 Parameter_Associations => New_List (\n                   Make_Attribute_Reference (Loc,\n                     Prefix         => New_Copy_Tree (Target),\n@@ -8398,11 +8393,12 @@ package body Exp_Ch3 is\n \n             Append_To (Stmts_List,\n               Make_Assignment_Statement (Loc,\n-                Name =>\n+                Name       =>\n                   Make_Selected_Component (Loc,\n-                    Prefix => New_Copy_Tree (Target),\n-                    Selector_Name => New_Occurrence_Of\n-                                       (Offset_To_Top_Comp, Loc)),\n+                    Prefix        => New_Copy_Tree (Target),\n+                    Selector_Name =>\n+                      New_Occurrence_Of (Offset_To_Top_Comp, Loc)),\n+\n                 Expression =>\n                   Make_Attribute_Reference (Loc,\n                     Prefix       =>\n@@ -8424,7 +8420,7 @@ package body Exp_Ch3 is\n                    Offset_Value =>\n                      Unchecked_Convert_To (RTE (RE_Storage_Offset),\n                        Make_Attribute_Reference (Loc,\n-                         Prefix =>\n+                         Prefix         =>\n                            Make_Selected_Component (Loc,\n                              Prefix        => New_Copy_Tree (Target),\n                              Selector_Name =>\n@@ -8443,8 +8439,9 @@ package body Exp_Ch3 is\n             if RTE_Available (RE_Register_Interface_Offset) then\n                Append_To (Stmts_List,\n                  Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Occurrence_Of\n-                             (RTE (RE_Register_Interface_Offset), Loc),\n+                   Name                   =>\n+                     New_Occurrence_Of\n+                       (RTE (RE_Register_Interface_Offset), Loc),\n                    Parameter_Associations => New_List (\n                      Make_Attribute_Reference (Loc,\n                        Prefix         => New_Copy_Tree (Target),\n@@ -8456,14 +8453,13 @@ package body Exp_Ch3 is\n \n                      New_Occurrence_Of (Standard_True, Loc),\n \n-                     Unchecked_Convert_To\n-                       (RTE (RE_Storage_Offset),\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix =>\n-                            Make_Selected_Component (Loc,\n-                              Prefix         => New_Copy_Tree (Target),\n-                              Selector_Name  =>\n-                                New_Occurrence_Of (Tag_Comp, Loc)),\n+                     Unchecked_Convert_To (RTE (RE_Storage_Offset),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix         =>\n+                           Make_Selected_Component (Loc,\n+                             Prefix         => New_Copy_Tree (Target),\n+                             Selector_Name  =>\n+                               New_Occurrence_Of (Tag_Comp, Loc)),\n                          Attribute_Name => Name_Position)),\n \n                      Make_Null (Loc))));\n@@ -8537,8 +8533,8 @@ package body Exp_Ch3 is\n                      then\n                         exit when\n                           (Is_Record_Type (Comp_Typ)\n-                            and then Is_Variable_Size_Record\n-                                       (Base_Type (Comp_Typ)))\n+                            and then\n+                              Is_Variable_Size_Record (Base_Type (Comp_Typ)))\n                          or else\n                            (Is_Array_Type (Comp_Typ)\n                              and then Is_Variable_Size_Array (Comp_Typ));\n@@ -8551,7 +8547,7 @@ package body Exp_Ch3 is\n                   Error_Msg_Node_2 := Comp;\n                   Error_Msg_NE\n                     (\"parent type & with dynamic component & cannot be parent\"\n-                       & \" of 'C'P'P derivation if new interfaces are present\",\n+                     & \" of 'C'P'P derivation if new interfaces are present\",\n                      Typ, Scope (Original_Record_Component (Comp)));\n \n                   Error_Msg_Sloc :=\n@@ -8760,16 +8756,17 @@ package body Exp_Ch3 is\n               Make_Simple_Return_Statement (Loc,\n                 Expression =>\n                   Make_Extension_Aggregate (Loc,\n-                    Ancestor_Part =>\n+                    Ancestor_Part       =>\n                       Make_Function_Call (Loc,\n-                        Name => New_Occurrence_Of (Alias (Subp), Loc),\n+                        Name                   =>\n+                          New_Occurrence_Of (Alias (Subp), Loc),\n                         Parameter_Associations => Actual_List),\n                     Null_Record_Present => True));\n \n             Func_Body :=\n               Make_Subprogram_Body (Loc,\n-                Specification => New_Copy_Tree (Func_Spec),\n-                Declarations => Empty_List,\n+                Specification              => New_Copy_Tree (Func_Spec),\n+                Declarations               => Empty_List,\n                 Handled_Statement_Sequence =>\n                   Make_Handled_Sequence_Of_Statements (Loc,\n                     Statements => New_List (Return_Stmt)));\n@@ -9223,7 +9220,7 @@ package body Exp_Ch3 is\n           Expression =>\n             Make_Op_Not (Loc,\n               Make_Function_Call (Loc,\n-                Name => New_Occurrence_Of (Target, Loc),\n+                Name                   => New_Occurrence_Of (Target, Loc),\n                 Parameter_Associations => New_List (\n                   Make_Identifier (Loc, Chars (Left_Op)),\n                   Make_Identifier (Loc, Chars (Right_Op)))))));\n@@ -9287,15 +9284,14 @@ package body Exp_Ch3 is\n                   --  of the interface type)\n \n                   if Is_Controlling_Formal (Formal) then\n-                     if Nkind (Parameter_Type (Parent (Formal)))\n-                       = N_Identifier\n+                     if Nkind (Parameter_Type (Parent (Formal))) = N_Identifier\n                      then\n                         Set_Parameter_Type (New_Param_Spec,\n                           New_Occurrence_Of (Tag_Typ, Loc));\n \n                      else pragma Assert\n-                            (Nkind (Parameter_Type (Parent (Formal)))\n-                               = N_Access_Definition);\n+                            (Nkind (Parameter_Type (Parent (Formal))) =\n+                                                        N_Access_Definition);\n                         Set_Subtype_Mark (Parameter_Type (New_Param_Spec),\n                           New_Occurrence_Of (Tag_Typ, Loc));\n                      end if;\n@@ -9310,10 +9306,10 @@ package body Exp_Ch3 is\n             Append_To (Decl_List,\n               Make_Subprogram_Declaration (Loc,\n                 Make_Procedure_Specification (Loc,\n-                  Defining_Unit_Name =>\n+                  Defining_Unit_Name       =>\n                     Make_Defining_Identifier (Loc, Chars (Subp)),\n                   Parameter_Specifications => Formal_List,\n-                  Null_Present => True)));\n+                  Null_Present             => True)));\n          end if;\n \n          Next_Elmt (Prim_Elmt);\n@@ -9352,7 +9348,7 @@ package body Exp_Ch3 is\n \n       Loc       : constant Source_Ptr := Sloc (Tag_Typ);\n       Res       : constant List_Id    := New_List;\n-      Eq_Name   : Name_Id := Name_Op_Eq;\n+      Eq_Name   : Name_Id             := Name_Op_Eq;\n       Eq_Needed : Boolean;\n       Eq_Spec   : Node_Id;\n       Prim      : Elmt_Id;\n@@ -9482,11 +9478,12 @@ package body Exp_Ch3 is\n                 Make_Parameter_Specification (Loc,\n                   Defining_Identifier =>\n                     Make_Defining_Identifier (Loc, Name_X),\n-                    Parameter_Type      => New_Occurrence_Of (Tag_Typ, Loc)),\n+                  Parameter_Type      => New_Occurrence_Of (Tag_Typ, Loc)),\n+\n                 Make_Parameter_Specification (Loc,\n                   Defining_Identifier =>\n                     Make_Defining_Identifier (Loc, Name_Y),\n-                    Parameter_Type      => New_Occurrence_Of (Tag_Typ, Loc))),\n+                  Parameter_Type      => New_Occurrence_Of (Tag_Typ, Loc))),\n                 Ret_Type => Standard_Boolean);\n             Append_To (Res, Eq_Spec);\n \n@@ -9588,9 +9585,8 @@ package body Exp_Ch3 is\n                 Specification =>\n                   Make_Disp_Timed_Select_Spec (Tag_Typ)));\n \n-         --  If the ancestor is an interface type we declare non-abstract\n-         --  primitives to override the abstract primitives of the interface\n-         --  type.\n+         --  If ancestor is an interface type, declare non-abstract primitives\n+         --  to override the abstract primitives of the interface type.\n \n          --  In VM targets we define these primitives in all root tagged types\n          --  that are not interface types. Done because in VM targets we don't\n@@ -9675,8 +9671,7 @@ package body Exp_Ch3 is\n       Consider_IS : Boolean := True) return Boolean\n    is\n       Consider_IS_NS : constant Boolean :=\n-                         Normalize_Scalars\n-                           or (Initialize_Scalars and Consider_IS);\n+        Normalize_Scalars or (Initialize_Scalars and Consider_IS);\n \n    begin\n       --  Never need initialization if it is suppressed\n@@ -9691,7 +9686,6 @@ package body Exp_Ch3 is\n       if Is_Private_Type (T) then\n          declare\n             RT : constant Entity_Id := Underlying_Type (T);\n-\n          begin\n             if Present (RT) then\n                return Needs_Simple_Initialization (RT);\n@@ -10014,8 +10008,7 @@ package body Exp_Ch3 is\n       if Stream_Operation_OK (Tag_Typ, TSS_Stream_Output)\n         and then No (TSS (Tag_Typ, TSS_Stream_Output))\n       then\n-         Build_Record_Or_Elementary_Output_Procedure\n-           (Loc, Tag_Typ, Decl, Ent);\n+         Build_Record_Or_Elementary_Output_Procedure (Loc, Tag_Typ, Decl, Ent);\n          Append_To (Res, Decl);\n       end if;\n \n@@ -10063,9 +10056,8 @@ package body Exp_Ch3 is\n          Append_To (Res, Make_Disp_Timed_Select_Body        (Tag_Typ));\n       end if;\n \n-      if not Is_Limited_Type (Tag_Typ)\n-        and then not Is_Interface (Tag_Typ)\n-      then\n+      if not Is_Limited_Type (Tag_Typ) and then not Is_Interface (Tag_Typ) then\n+\n          --  Body for equality\n \n          if Eq_Needed then\n@@ -10126,6 +10118,7 @@ package body Exp_Ch3 is\n                      Make_Adjust_Call (\n                        Obj_Ref => Make_Identifier (Loc, Name_V),\n                        Typ     => Tag_Typ))));\n+\n             else\n                Set_Handled_Statement_Sequence (Decl,\n                  Make_Handled_Sequence_Of_Statements (Loc,\n@@ -10145,6 +10138,7 @@ package body Exp_Ch3 is\n                   Make_Final_Call\n                     (Obj_Ref => Make_Identifier (Loc, Name_V),\n                      Typ     => Tag_Typ))));\n+\n          else\n             Set_Handled_Statement_Sequence (Decl,\n               Make_Handled_Sequence_Of_Statements (Loc,"}, {"sha": "9068fdcdfbb5f5b1c433d24dfd714f3def61f6ef", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "patch": "@@ -1124,10 +1124,11 @@ package body Exp_Ch4 is\n                --  Inherit the allocation-related attributes from the original\n                --  access type.\n \n-               Set_Finalization_Master (Def_Id, Finalization_Master (PtrT));\n+               Set_Finalization_Master\n+                 (Def_Id, Finalization_Master (PtrT));\n \n-               Set_Associated_Storage_Pool (Def_Id,\n-                 Associated_Storage_Pool (PtrT));\n+               Set_Associated_Storage_Pool\n+                 (Def_Id, Associated_Storage_Pool (PtrT));\n \n                --  Declare the object using the previous type declaration\n \n@@ -4318,26 +4319,29 @@ package body Exp_Ch4 is\n \n          --  Anonymous access-to-controlled types allocate on the global pool.\n          --  Do not set this attribute on .NET/JVM since those targets do not\n-         --  support pools.\n+         --  support pools. Note that this is a \"root type only\" attribute.\n \n          if No (Associated_Storage_Pool (PtrT)) and then VM_Target = No_VM then\n             if Present (Rel_Typ) then\n                Set_Associated_Storage_Pool\n-                 (PtrT, Associated_Storage_Pool (Rel_Typ));\n+                 (Root_Type (PtrT), Associated_Storage_Pool (Rel_Typ));\n             else\n                Set_Associated_Storage_Pool\n-                 (PtrT, RTE (RE_Global_Pool_Object));\n+                 (Root_Type (PtrT), RTE (RE_Global_Pool_Object));\n             end if;\n          end if;\n \n          --  The finalization master must be inserted and analyzed as part of\n          --  the current semantic unit. Note that the master is updated when\n-         --  analysis changes current units.\n+         --  analysis changes current units. Note that this is a \"root type\n+         --  only\" attribute.\n \n          if Present (Rel_Typ) then\n-            Set_Finalization_Master (PtrT, Finalization_Master (Rel_Typ));\n+            Set_Finalization_Master\n+              (Root_Type (PtrT), Finalization_Master (Rel_Typ));\n          else\n-            Set_Finalization_Master (PtrT, Current_Anonymous_Master);\n+            Set_Finalization_Master\n+              (Root_Type (PtrT), Current_Anonymous_Master);\n          end if;\n       end if;\n "}, {"sha": "03df9321765d918623e9ca0f6fba84e4eb02f66d", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "patch": "@@ -515,7 +515,7 @@ ifeq ($(strip $(filter-out m68k% wrs vx%,$(target_cpu) $(target_vendor) $(target\n endif\n \n # PowerPC and e500v2 VxWorks\n-ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(target_cpu) $(target_vendor) $(target_os))),)\n+ifeq ($(strip $(filter-out powerpc% wrs vxworks vxworks7,$(target_cpu) $(target_vendor) $(target_os))),)\n \n   ifeq ($(strip $(filter-out e500%, $(target_alias))),)\n      ARCH_STR=e500\n@@ -3012,7 +3012,7 @@ a-tags.o  : a-tags.adb a-tags.ads\n \n # need to keep the frame pointer in this file to pop the stack properly on\n # some targets.\n-tracebak.o  : tracebak.c tb-alvms.c tb-alvxw.c tb-gcc.c\n+tracebak.o  : tracebak.c tb-gcc.c\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ADA_CFLAGS) $(ALL_CPPFLAGS) \\\n \t      $(INCLUDES) -fno-omit-frame-pointer $< $(OUTPUT_OPTION)\n "}, {"sha": "9f81eae81579732d97fab4551fcbd53923fdb6fe", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "patch": "@@ -575,7 +575,18 @@ gnat_set_type_context (tree type, tree context)\n \n   while (decl && DECL_PARALLEL_TYPE (decl))\n     {\n-      TYPE_CONTEXT (DECL_PARALLEL_TYPE (decl)) = context;\n+      tree parallel_type = DECL_PARALLEL_TYPE (decl);\n+\n+      /* Give a context to the parallel types and their stub decl, if any.\n+\t Some parallel types seems to be present in multiple parallel type\n+\t chains, so don't mess with their context if they already have one.  */\n+      if (TYPE_CONTEXT (parallel_type) == NULL_TREE)\n+\t{\n+\t  if (TYPE_STUB_DECL (parallel_type) != NULL_TREE)\n+\t    DECL_CONTEXT (TYPE_STUB_DECL (parallel_type)) = context;\n+\t  TYPE_CONTEXT (parallel_type) = context;\n+\t}\n+\n       decl = TYPE_STUB_DECL (DECL_PARALLEL_TYPE (decl));\n     }\n }\n@@ -799,7 +810,9 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \tt = NULL_TREE;\n \n       /* Propagate the name to all the anonymous variants.  This is needed\n-\t for the type qualifiers machinery to work properly.  */\n+\t for the type qualifiers machinery to work properly.  Also propagate\n+\t the context to them.  Note that the context will be propagated to all\n+\t parallel types too thanks to gnat_set_type_context.  */\n       if (t)\n \tfor (t = TYPE_MAIN_VARIANT (t); t; t = TYPE_NEXT_VARIANT (t))\n \t  if (!(TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL))\n@@ -1763,7 +1776,10 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n     rest_of_record_type_compilation (record_type);\n }\n \n-/* Append PARALLEL_TYPE on the chain of parallel types of TYPE.  */\n+/* Append PARALLEL_TYPE on the chain of parallel types of TYPE.  If\n+   PARRALEL_TYPE has no context and its computation is not deferred yet, also\n+   propagate TYPE's context to PARALLEL_TYPE's or defer its propagation to the\n+   moment TYPE will get a context.  */\n \n void\n add_parallel_type (tree type, tree parallel_type)\n@@ -1774,6 +1790,19 @@ add_parallel_type (tree type, tree parallel_type)\n     decl = TYPE_STUB_DECL (DECL_PARALLEL_TYPE (decl));\n \n   SET_DECL_PARALLEL_TYPE (decl, parallel_type);\n+\n+  /* If PARALLEL_TYPE already has a context, we are done.  */\n+  if (TYPE_CONTEXT (parallel_type) != NULL_TREE)\n+    return;\n+\n+  /* Otherwise, try to get one from TYPE's context.  */\n+  if (TYPE_CONTEXT (type) != NULL_TREE)\n+    /* TYPE already has a context, so simply propagate it to PARALLEL_TYPE.  */\n+    gnat_set_type_context (parallel_type, TYPE_CONTEXT (type));\n+\n+    /* ... otherwise TYPE has not context yet.  We know it will thanks to\n+       gnat_pushdecl, and then its context will be propagated to PARALLEL_TYPE.\n+       So we have nothing to do in this case.  */\n }\n \n /* Return true if TYPE has a parallel type.  */\n@@ -2851,7 +2880,7 @@ process_deferred_decl_context (bool force)\n \t     ..._TYPE nodes.  */\n \t  FOR_EACH_VEC_ELT (node->types, i, t)\n \t    {\n-\t      TYPE_CONTEXT (t) = context;\n+\t      gnat_set_type_context (t, context);\n \t    }\n \t  processed = true;\n \t}\n@@ -3629,6 +3658,7 @@ tree\n build_unc_object_type (tree template_type, tree object_type, tree name,\n \t\t       bool debug_info_p)\n {\n+  tree decl;\n   tree type = make_node (RECORD_TYPE);\n   tree template_field\n     = create_field_decl (get_identifier (\"BOUNDS\"), template_type, type,\n@@ -3644,7 +3674,12 @@ build_unc_object_type (tree template_type, tree object_type, tree name,\n \n   /* Declare it now since it will never be declared otherwise.  This is\n      necessary to ensure that its subtrees are properly marked.  */\n-  create_type_decl (name, type, true, debug_info_p, Empty);\n+  decl = create_type_decl (name, type, true, debug_info_p, Empty);\n+\n+  /* template_type will not be used elsewhere than here, so to keep the debug\n+     info clean and in order to avoid scoping issues, make decl its\n+     context.  */\n+  gnat_set_type_context (template_type, decl);\n \n   return type;\n }"}, {"sha": "695b27ef169fb32c7f104f0ccaba233fb0b7ccb6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "patch": "@@ -3769,6 +3769,14 @@ package body Sem_Ch3 is\n             elsif Is_Interface (T) then\n                null;\n \n+            --  In GNATprove mode, Expand_Subtype_From_Expr does nothing. Thus,\n+            --  we should prevent the generation of another Itype with the\n+            --  same name as the one already generated, or we end up with\n+            --  two identical types in GNATprove.\n+\n+            elsif GNATprove_Mode then\n+               null;\n+\n             else\n                Expand_Subtype_From_Expr (N, T, Object_Definition (N), E);\n                Act_T := Find_Type_Of_Object (Object_Definition (N), N);"}, {"sha": "85a0d537225ab079c3fd568ca1312bf0663d5649", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "patch": "@@ -577,6 +577,10 @@ package Sinfo is\n    --       warning issued when generating code, to avoid formal verification\n    --       of a partial unit.\n \n+   --    4. Unconstrained types are not replaced by constrained types whose\n+   --       bounds are generated from an expression: Expand_Subtype_From_Expr\n+   --       should be noop.\n+\n    -----------------------\n    -- Check Flag Fields --\n    -----------------------"}, {"sha": "1fd837e150c74add10a7c0505c55924658357fe0", "filename": "gcc/ada/tb-alvms.c", "status": "removed", "additions": 0, "deletions": 395, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69fff50e08365770deca864efd7a904ac9eb25e0/gcc%2Fada%2Ftb-alvms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69fff50e08365770deca864efd7a904ac9eb25e0/gcc%2Fada%2Ftb-alvms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftb-alvms.c?ref=69fff50e08365770deca864efd7a904ac9eb25e0", "patch": "@@ -1,395 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT RUN-TIME COMPONENTS                         *\n- *                                                                          *\n- *                   T R A C E B A C K - A l p h a / V M S                  *\n- *                                                                          *\n- *                          C Implementation File                           *\n- *                                                                          *\n- *                     Copyright (C) 2003-2011, AdaCore                     *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n- *                                                                          *\n- * As a special exception under Section 7 of GPL version 3, you are granted *\n- * additional permissions described in the GCC Runtime Library Exception,   *\n- * version 3.1, as published by the Free Software Foundation.               *\n- *                                                                          *\n- * You should have received a copy of the GNU General Public License and    *\n- * a copy of the GCC Runtime Library Exception along with this program;     *\n- * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    *\n- * <http://www.gnu.org/licenses/>.                                          *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-\n-/* Alpha VMS requires a special treatment due to the complexity of the ABI.\n-   What is here is along the lines of what the MD_FALLBACK_FRAME_STATE_FOR\n-   macro does for frame unwinding during exception propagation. This file is\n-   #included within tracebak.c in the appropriate case.\n-\n-   Most of the contents is directed by the OpenVMS/Alpha Conventions (ABI)\n-   document, sections of which we will refer to as ABI-<section_number>.  */\n-\n-#include <vms/pdscdef.h>\n-#include <vms/libicb.h>\n-#include <vms/chfctxdef.h>\n-#include <vms/chfdef.h>\n-\n-/* A couple of items missing from the header file included above.  */\n-extern void * SYS$GL_CALL_HANDL;\n-#define PDSC$M_BASE_FRAME (1 << 10)\n-\n-/* Registers are 64bit wide and addresses are 32bit wide on alpha-vms.  */\n-typedef void * ADDR;\n-typedef unsigned long long REG;\n-\n-#define REG_AT(addr) (*(REG *)(addr))\n-\n-#define AS_REG(addr) ((REG)(unsigned long)(addr))\n-#define AS_ADDR(reg) ((ADDR)(unsigned long)(reg))\n-#define ADDR_IN(reg) (AS_ADDR(reg))\n-\n-/* The following structure defines the state maintained during the\n-   unwinding process.  */\n-typedef struct\n-{\n-  ADDR pc;  /* Address of the call insn involved in the chain.  */\n-  ADDR sp;  /* Stack Pointer at the time of this call.  */\n-  ADDR fp;  /* Frame Pointer at the time of this call.  */\n-\n-  /* The values above are fetched as saved REGisters on the stack. They are\n-     typed ADDR because this is what the values in those registers are.  */\n-\n-  /* Values of the registers saved by the functions in the chain,\n-     incrementally updated through consecutive calls to the \"unwind\" function\n-     below.  */\n-  REG saved_regs [32];\n-} frame_state_t;\n-\n-/* Shortcuts for saved_regs of specific interest:\n-\n-   Frame Pointer   is r29,\n-   Stack Pointer   is r30,\n-   Return Address  is r26,\n-   Procedure Value is r27.\n-\n-   This is from ABI-3.1.1 [Integer Registers].  */\n-\n-#define saved_fpr saved_regs[29]\n-#define saved_spr saved_regs[30]\n-#define saved_rar saved_regs[26]\n-#define saved_pvr saved_regs[27]\n-\n-/* Special values for saved_rar, used to control the overall unwinding\n-   process.  */\n-#define RA_UNKNOWN ((REG)~0)\n-#define RA_STOP    ((REG)0)\n-\n-/* We still use a number of macros similar to the ones for the generic\n-   __gnat_backtrace implementation.  */\n-#define PC_ADJUST 4\n-#define STOP_FRAME (frame_state.saved_rar == RA_STOP)\n-\n-/* Compute Procedure Value from Frame Pointer value.  This follows the rules\n-   in ABI-3.6.1 [Current Procedure].  */\n-#define PV_FOR(FP) \\\n-  (((FP) != 0) \\\n-    ? (((REG_AT (FP) & 0x7) == 0) ? *(PDSCDEF **)(FP) : (PDSCDEF *)(FP)) : 0)\n-\n-\n-/**********\n- * unwind *\n- **********/\n-\n-/* Helper for __gnat_backtrace.\n-\n-   FS represents some call frame, identified by a pc and associated frame\n-   pointer in FS->pc and FS->fp. FS->saved_regs contains the state of the\n-   general registers upon entry in this frame. Of most interest in this set\n-   are the saved return address and frame pointer registers, which actually\n-   allow identifying the caller's frame.\n-\n-   This routine \"unwinds\" the input frame state by adjusting it to eventually\n-   represent its caller's frame. The basic principle is to shift the fp and pc\n-   saved values into the current state, and then compute the corresponding new\n-   saved registers set.\n-\n-   If the call chain goes through a signal handler, special processing is\n-   required when we process the kernel frame which has called the handler, to\n-   switch it to the interrupted context frame.  */\n-\n-#define K_HANDLER_FRAME(fs) (PV_FOR ((fs)->fp) == SYS$GL_CALL_HANDL)\n-\n-static void unwind_regular_code (frame_state_t * fs);\n-static void unwind_kernel_handler (frame_state_t * fs);\n-\n-void\n-unwind (frame_state_t * fs)\n-{\n-  /* Don't do anything if requested so.  */\n-  if (fs->saved_rar == RA_STOP)\n-    return;\n-\n-  /* Retrieve the values of interest computed during the previous\n-     call. PC_ADJUST gets us from the return address to the call insn\n-     address.  */\n-  fs->pc = ADDR_IN (fs->saved_rar) - PC_ADJUST;\n-  fs->sp = ADDR_IN (fs->saved_spr);\n-  fs->fp = ADDR_IN (fs->saved_fpr);\n-\n-  /* Unless we are able to determine otherwise, set the frame state's\n-     saved return address such that the unwinding process will stop.  */\n-  fs->saved_rar = RA_STOP;\n-\n-  /* Now we want to update fs->saved_regs to reflect the state of the caller\n-     of the procedure described by pc/fp.\n-\n-     The condition to check for a special kernel frame which has called a\n-     signal handler is stated in ABI-6.7.1 [Signaler's Registers] : \"The frame\n-     of the call to the handler can be identified by the return address of\n-     SYS$CALL_HANDL+4\". We use the equivalent procedure value identification\n-     here because SYS$CALL_HANDL appears to be undefined. */\n-\n-  if (K_HANDLER_FRAME (fs))\n-    unwind_kernel_handler (fs);\n-  else\n-    unwind_regular_code (fs);\n-}\n-\n-/***********************\n- * unwind_regular_code *\n- ***********************/\n-\n-/* Helper for unwind, for the case of unwinding through regular code which\n-   is not a signal handler.  */\n-\n-static void\n-unwind_regular_code (frame_state_t * fs)\n-{\n-  PDSCDEF * pv = PV_FOR (fs->fp);\n-\n-  ADDR frame_base;\n-\n-  /* Use the procedure value to unwind, in a way depending on the kind of\n-     procedure at hand. See ABI-3.3 [Procedure Representation] and ABI-3.4\n-     [Procedure Types].  */\n-\n-  if (pv == 0\n-      || pv->pdsc$w_flags & PDSC$M_BASE_FRAME)\n-    return;\n-\n-  frame_base\n-    = (pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP) ? fs->fp : fs->sp;\n-\n-  switch (pv->pdsc$w_flags & 0xf)\n-    {\n-    case PDSC$K_KIND_FP_STACK:\n-      /* Stack Frame Procedure (ABI-3.4.1). Retrieve the necessary registers\n-\t from the Register Save Area in the frame.  */\n-      {\n-\tADDR rsa_base = frame_base + pv->pdsc$w_rsa_offset;\n-\tint i, j;\n-\n-\tfs->saved_rar = REG_AT (rsa_base);\n-\tfs->saved_pvr = REG_AT (frame_base);\n-\n-\tfor (i = 0, j = 0; i < 32; i++)\n-\t  if (pv->pdsc$l_ireg_mask & (1 << i))\n-\t    fs->saved_regs[i] = REG_AT (rsa_base + 8 * ++j);\n-\n-\t/* Note that the loop above is guaranteed to set fs->saved_fpr,\n-\t   because \"The preserved register set must always include R29(FP)\n-\t   since it will always be used.\" (ABI-3.4.3.4 [Register Save Area for\n-\t   All Stack Frames]).\n-\n-\t   Also note that we need to run through all the registers to ensure\n-\t   that unwinding through register procedures (see below) gets the\n-\t   right values out of the saved_regs array.  */\n-      }\n-      break;\n-\n-    case PDSC$K_KIND_FP_REGISTER:\n-      /* Register Procedure (ABI-3.4.4). Retrieve the necessary registers from\n-\t the registers where they have been saved.  */\n-      {\n-\tfs->saved_rar = fs->saved_regs[pv->pdsc$b_save_ra];\n-\tfs->saved_fpr = fs->saved_regs[pv->pdsc$b_save_fp];\n-      }\n-      break;\n-\n-    default:\n-      /* ??? Are we supposed to ever get here ?  Don't think so.  */\n-      break;\n-    }\n-\n-  /* SP is actually never part of the saved registers area, so we use the\n-     corresponding entry in the saved_regs array to manually keep track of\n-     it's evolution.  */\n-  fs->saved_spr = AS_REG (frame_base) + pv->pdsc$l_size;\n-}\n-\n-/*************************\n- * unwind_kernel_handler *\n- *************************/\n-\n-/* Helper for unwind, for the specific case of unwinding through a signal\n-   handler.\n-\n-   The input frame state describes the kernel frame which has called a signal\n-   handler. We fill the corresponding saved_regs to have it's \"caller\" frame\n-   represented as the interrupted context.  */\n-\n-static void\n-unwind_kernel_handler (frame_state_t * fs)\n-{\n-  PDSCDEF * pv = PV_FOR (fs->fp);\n-\n-  CHFDEF1 *sigargs;\n-  CHFDEF2 *mechargs;\n-\n-  /* Retrieve the arguments passed to the handler, by way of a VMS service\n-     providing the corresponding \"Invocation Context Block\".  */\n-  {\n-    long handler_ivhandle;\n-    INVO_CONTEXT_BLK handler_ivcb;\n-\n-    CHFCTX *chfctx;\n-\n-    handler_ivcb.libicb$q_ireg [29] = AS_REG (fs->fp);\n-    handler_ivcb.libicb$q_ireg [30] = 0;\n-\n-    handler_ivhandle = LIB$GET_INVO_HANDLE (&handler_ivcb);\n-\n-    if ((LIB$GET_INVO_CONTEXT (handler_ivhandle, &handler_ivcb) & 1) != 1)\n-      return;\n-\n-    chfctx = (CHFCTX *) AS_ADDR (handler_ivcb.libicb$ph_chfctx_addr);\n-\n-    sigargs = (CHFDEF1 *) AS_ADDR (chfctx->chfctx$q_sigarglst);\n-    mechargs = (CHFDEF2 *) AS_ADDR (chfctx->chfctx$q_mcharglst);\n-  }\n-\n-  /* Compute the saved return address as the PC of the instruction causing the\n-     condition, accounting for the fact that it will be adjusted by the next\n-     call to \"unwind\" as if it was an actual call return address.  */\n-  {\n-    /* ABI-6.5.1.1 [Signal Argument Vector]: The signal occurrence address\n-       is available from the sigargs argument to the handler, designed to\n-       support both 32 and 64 bit addresses.  The initial reference we get\n-       is a pointer to the 32bit form, from which one may extract a pointer\n-       to the 64bit version if need be.  We work directly from the 32bit\n-       form here.  */\n-\n-    /* The sigargs vector structure for 32bits addresses is:\n-\n-       <......32bit......>\n-       +-----------------+\n-       |      Vsize      | :chf$is_sig_args\n-       +-----------------+ -+-\n-       | Condition Value |  : [0]\n-       +-----------------+  :\n-       |       ...       |  :\n-       +-----------------+  : vector of Vsize entries\n-       |    Signal PC    |  :\n-       +-----------------+  :\n-       |       PS        |  : [Vsize - 1]\n-       +-----------------+ -+-\n-\n-       */\n-\n-    unsigned long * sigargs_vector\n-      = ((unsigned long *) (&sigargs->chf$is_sig_args)) + 1;\n-\n-    long sigargs_vsize\n-      = sigargs->chf$is_sig_args;\n-\n-    fs->saved_rar = (REG) sigargs_vector [sigargs_vsize - 2] + PC_ADJUST;\n-  }\n-\n-  fs->saved_spr = RA_UNKNOWN;\n-  fs->saved_fpr = (REG) mechargs->chf$q_mch_frame;\n-  fs->saved_pvr = (REG) mechargs->chf$q_mch_savr27;\n-\n-  fs->saved_regs[16] = (REG) mechargs->chf$q_mch_savr16;\n-  fs->saved_regs[17] = (REG) mechargs->chf$q_mch_savr17;\n-  fs->saved_regs[18] = (REG) mechargs->chf$q_mch_savr18;\n-  fs->saved_regs[19] = (REG) mechargs->chf$q_mch_savr19;\n-  fs->saved_regs[20] = (REG) mechargs->chf$q_mch_savr20;\n-}\n-\n-/* Structure representing a traceback entry in the tracebacks array to be\n-   filled by __gnat_backtrace below.\n-\n-   !! This should match what is in System.Traceback_Entries, so beware of\n-   !! the REG/ADDR difference here.\n-\n-   The use of a structure is motivated by the potential necessity of having\n-   several fields to fill for each entry, for instance if later calls to VMS\n-   system functions need more than just a mere PC to compute info on a frame\n-   (e.g. for non-symbolic->symbolic translation purposes).  */\n-typedef struct {\n-  ADDR pc;  /* Program Counter.  */\n-  ADDR pv;  /* Procedure Value.  */\n-} tb_entry_t;\n-\n-/********************\n- * __gnat_backtrace *\n- ********************/\n-\n-int\n-__gnat_backtrace (void **array, int size,\n-                  void *exclude_min, void *exclude_max, int skip_frames)\n-{\n-  int cnt;\n-\n-  tb_entry_t * tbe = (tb_entry_t *)&array [0];\n-\n-  frame_state_t frame_state;\n-\n-  /* Setup the frame state before initiating the unwinding sequence.  */\n-  register REG this_FP __asm__(\"$29\");\n-  register REG this_SP __asm__(\"$30\");\n-\n-  frame_state.saved_fpr = this_FP;\n-  frame_state.saved_spr = this_SP;\n-  frame_state.saved_rar = RA_UNKNOWN;\n-\n-  unwind (&frame_state);\n-\n-  /* At this point frame_state describes this very function. Skip the\n-     requested number of calls.  */\n-  for (cnt = 0; cnt < skip_frames; cnt ++)\n-    unwind (&frame_state);\n-\n-  /* Now consider each frame as a potential candidate for insertion inside\n-     the provided array.  */\n-  cnt = 0;\n-  while (cnt < size)\n-    {\n-      /* Stop if either the frame contents or the unwinder say so.  */\n-      if (STOP_FRAME)\n-        break;\n-\n-      if (! K_HANDLER_FRAME (&frame_state)\n-\t  && (frame_state.pc < exclude_min || frame_state.pc > exclude_max))\n-\t{\n-\t  tbe->pc = (ADDR) frame_state.pc;\n-\t  tbe->pv = (ADDR) PV_FOR (frame_state.fp);\n-\n-\t  cnt ++;\n-\t  tbe ++;\n-\t}\n-\n-      unwind (&frame_state);\n-    }\n-\n-  return cnt;\n-}"}, {"sha": "4f743a110a7fe3f9615e0c49cd1b9052394922ed", "filename": "gcc/ada/tb-alvxw.c", "status": "removed", "additions": 0, "deletions": 940, "changes": 940, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69fff50e08365770deca864efd7a904ac9eb25e0/gcc%2Fada%2Ftb-alvxw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69fff50e08365770deca864efd7a904ac9eb25e0/gcc%2Fada%2Ftb-alvxw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftb-alvxw.c?ref=69fff50e08365770deca864efd7a904ac9eb25e0", "patch": "@@ -1,940 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT RUN-TIME COMPONENTS                         *\n- *                                                                          *\n- *                T R A C E B A C K - A l p h a / V x W o r k s             *\n- *                                                                          *\n- *                          C Implementation File                           *\n- *                                                                          *\n- *                     Copyright (C) 2000-2011, AdaCore                     *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n- *                                                                          *\n- * As a special exception under Section 7 of GPL version 3, you are granted *\n- * additional permissions described in the GCC Runtime Library Exception,   *\n- * version 3.1, as published by the Free Software Foundation.               *\n- *                                                                          *\n- * You should have received a copy of the GNU General Public License and    *\n- * a copy of the GCC Runtime Library Exception along with this program;     *\n- * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    *\n- * <http://www.gnu.org/licenses/>.                                          *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* Alpha vxWorks requires a special, complex treatment that is extracted\n-   from GDB. This file is #included within tracebak.c in the appropriate\n-   case.  */\n-\n-#include <stddef.h>\n-#include <stdlib.h>\n-#include <limits.h>\n-#include <string.h>\n-\n-extern void kerTaskEntry(void);\n-\n-/* We still use a number of macros similar to the ones for the generic\n-   __gnat_backtrace implementation.  */\n-#define SKIP_FRAME 1\n-#define PC_ADJUST -4\n-\n-#define STOP_FRAME \\\n-   (current == NULL \\\n-    || ((CORE_ADDR) &kerTaskEntry >= PROC_LOW_ADDR (current->proc_desc) \\\n-        && current->pc >= (CORE_ADDR) &kerTaskEntry))\n-\n-/* Register numbers of various important registers.\n-   Note that most of these values are \"real\" register numbers,\n-   and correspond to the general registers of the machine,\n-   and FP_REGNUM is a \"phony\" register number which is too large\n-   to be an actual register number as far as the user is concerned\n-   but serves to get the desired value when passed to read_register.  */\n-\n-#define T7_REGNUM 8\t\t/* Return address register for OSF/1 __add* */\n-#define GCC_FP_REGNUM 15\t/* Used by gcc as frame register */\n-#define T9_REGNUM 23\t\t/* Return address register for OSF/1 __div* */\n-#define SP_REGNUM 30\t\t/* Contains address of top of stack */\n-#define RA_REGNUM 26\t\t/* Contains return address value */\n-#define FP0_REGNUM 32\t\t/* Floating point register 0 */\n-#define PC_REGNUM 64\t\t/* Contains program counter */\n-#define NUM_REGS 66\n-\n-#define VM_MIN_ADDRESS (CORE_ADDR)0x120000000\n-\n-#define SIZEOF_FRAME_SAVED_REGS (sizeof (CORE_ADDR) * (NUM_REGS))\n-#define INIT_EXTRA_FRAME_INFO(fromleaf, fci) init_extra_frame_info(fci)\n-\n-#define FRAME_CHAIN(thisframe) (CORE_ADDR) alpha_frame_chain (thisframe)\n-\n-#define FRAME_CHAIN_VALID(CHAIN, THISFRAME)\t\\\n-  ((CHAIN) != 0\t\t\t\t\t\\\n-   && !inside_entry_file (FRAME_SAVED_PC (THISFRAME)))\n-\n-#define FRAME_SAVED_PC(FRAME)\t(alpha_frame_saved_pc (FRAME))\n-\n-#define\tFRAME_CHAIN_COMBINE(CHAIN, THISFRAME) (CHAIN)\n-\n-#define\tINIT_FRAME_PC(FROMLEAF, PREV)\n-\n-#define INIT_FRAME_PC_FIRST(FROMLEAF, PREV) \\\n-  (PREV)->pc = ((FROMLEAF) ? SAVED_PC_AFTER_CALL ((PREV)->next) \\\n-\t\t: (PREV)->next ? FRAME_SAVED_PC ((PREV)->next) : read_pc ());\n-\n-#define SAVED_PC_AFTER_CALL(FRAME)\talpha_saved_pc_after_call (FRAME)\n-\n-typedef unsigned long long int bfd_vma;\n-\n-typedef bfd_vma CORE_ADDR;\n-\n-typedef struct pdr\n-{\n-  bfd_vma adr;\t\t/* memory address of start of procedure */\n-  long\tisym;\t\t/* start of local symbol entries */\n-  long\tiline;\t\t/* start of line number entries*/\n-  long\tregmask;\t/* save register mask */\n-  long\tregoffset;\t/* save register offset */\n-  long\tiopt;\t\t/* start of optimization symbol entries*/\n-  long\tfregmask;\t/* save floating point register mask */\n-  long\tfregoffset;\t/* save floating point register offset */\n-  long\tframeoffset;\t/* frame size */\n-  short\tframereg;\t/* frame pointer register */\n-  short\tpcreg;\t\t/* offset or reg of return pc */\n-  long\tlnLow;\t\t/* lowest line in the procedure */\n-  long\tlnHigh;\t\t/* highest line in the procedure */\n-  bfd_vma cbLineOffset;\t/* byte offset for this procedure from the fd base */\n-  /* These fields are new for 64 bit ECOFF.  */\n-  unsigned gp_prologue : 8; /* byte size of GP prologue */\n-  unsigned gp_used : 1;\t/* true if the procedure uses GP */\n-  unsigned reg_frame : 1; /* true if register frame procedure */\n-  unsigned prof : 1;\t/* true if compiled with -pg */\n-  unsigned reserved : 13; /* reserved: must be zero */\n-  unsigned localoff : 8; /* offset of local variables from vfp */\n-} PDR;\n-\n-typedef struct alpha_extra_func_info\n-{\n-  long numargs;\t\t/* number of args to procedure (was iopt) */\n-  PDR pdr;\t\t\t/* Procedure descriptor record */\n-}\n-*alpha_extra_func_info_t;\n-\n-struct frame_info\n-{\n-  /* Nominal address of the frame described.  See comments at FRAME_FP\n-     about what this means outside the *FRAME* macros; in the *FRAME*\n-     macros, it can mean whatever makes most sense for this machine.  */\n-  CORE_ADDR frame;\n-\n-  /* Address at which execution is occurring in this frame.  For the\n-     innermost frame, it's the current pc.  For other frames, it is a\n-     pc saved in the next frame.  */\n-  CORE_ADDR pc;\n-\n-  /* For each register, address of where it was saved on entry to the\n-     frame, or zero if it was not saved on entry to this frame.  This\n-     includes special registers such as pc and fp saved in special\n-     ways in the stack frame.  The SP_REGNUM is even more special, the\n-     address here is the sp for the next frame, not the address where\n-     the sp was saved.  Allocated by frame_saved_regs_zalloc () which\n-     is called and initialized by FRAME_INIT_SAVED_REGS. */\n-  CORE_ADDR *saved_regs;\t/*NUM_REGS */\n-\n-  int localoff;\n-  int pc_reg;\n-  alpha_extra_func_info_t proc_desc;\n-\n-  /* Pointers to the next and previous frame_info's in the frame cache.  */\n-  struct frame_info *next, *prev;\n-};\n-\n-struct frame_saved_regs\n-{\n-  /* For each register R (except the SP), regs[R] is the address at\n-     which it was saved on entry to the frame, or zero if it was not\n-     saved on entry to this frame.  This includes special registers\n-     such as pc and fp saved in special ways in the stack frame.\n-\n-     regs[SP_REGNUM] is different.  It holds the actual SP, not the\n-     address at which it was saved.  */\n-\n-  CORE_ADDR regs[NUM_REGS];\n-};\n-\n-static CORE_ADDR theRegisters[32];\n-\n-/* Prototypes for local functions. */\n-\n-static CORE_ADDR read_next_frame_reg (struct frame_info *, int);\n-static CORE_ADDR heuristic_proc_start (CORE_ADDR);\n-static int alpha_about_to_return (CORE_ADDR pc);\n-static void init_extra_frame_info (struct frame_info *);\n-static CORE_ADDR alpha_frame_chain (struct frame_info *);\n-static CORE_ADDR alpha_frame_saved_pc (struct frame_info *frame);\n-static void *trace_alloc (unsigned int);\n-static struct frame_info *create_new_frame (CORE_ADDR, CORE_ADDR);\n-\n-static alpha_extra_func_info_t\n-heuristic_proc_desc (CORE_ADDR, CORE_ADDR, struct frame_info *,\n-\t\t     struct frame_saved_regs *);\n-\n-static alpha_extra_func_info_t\n-find_proc_desc (CORE_ADDR, struct frame_info *, struct frame_saved_regs *);\n-\n-/* Heuristic_proc_start may hunt through the text section for a long\n-   time across a 2400 baud serial line.  Allows the user to limit this\n-   search.  */\n-static unsigned int heuristic_fence_post = 1<<16;\n-\n-/* Layout of a stack frame on the alpha:\n-\n-                |\t\t\t\t|\n- pdr members:\t|  7th ... nth arg,\t\t|\n-                |  `pushed' by caller.\t\t|\n-                |\t\t\t\t|\n-----------------|-------------------------------|<--  old_sp == vfp\n-   ^  ^  ^  ^\t|\t\t\t\t|\n-   |  |  |  |\t|\t\t\t\t|\n-   |  |localoff\t|  Copies of 1st .. 6th\t\t|\n-   |  |  |  |\t|  argument if necessary.\t|\n-   |  |  |  v\t|\t\t\t\t|\n-   |  |  |  ---\t|-------------------------------|<-- FRAME_LOCALS_ADDRESS\n-   |  |  |      |\t\t\t\t|\n-   |  |  |      |  Locals and temporaries.\t|\n-   |  |  |      |\t\t\t\t|\n-   |  |  |      |-------------------------------|\n-   |  |  |      |\t\t\t\t|\n-   |-fregoffset\t|  Saved float registers.\t|\n-   |  |  |      |  F9\t\t\t\t|\n-   |  |  |      |   .\t\t\t\t|\n-   |  |  |      |   .\t\t\t\t|\n-   |  |  |      |  F2\t\t\t\t|\n-   |  |  v      |\t\t\t\t|\n-   |  |  -------|-------------------------------|\n-   |  |         |\t\t\t\t|\n-   |  |         |  Saved registers.\t\t|\n-   |  |         |  S6\t\t\t\t|\n-   |-regoffset\t|   .\t\t\t\t|\n-   |  |         |   .\t\t\t\t|\n-   |  |         |  S0\t\t\t\t|\n-   |  |         |  pdr.pcreg\t\t\t|\n-   |  v         |\t\t\t\t|\n-   |  ----------|-------------------------------|\n-   |            |\t\t\t\t|\n- frameoffset    |  Argument build area, gets\t|\n-   |            |  7th ... nth arg for any\t|\n-   |            |  called procedure.\t\t|\n-   v            |  \t\t\t\t|\n-   -------------|-------------------------------|<-- sp\n-                |\t\t\t\t|            */\n-\n-#define PROC_LOW_ADDR(PROC) ((PROC)->pdr.adr)\t\t    /* least address */\n-#define PROC_HIGH_ADDR(PROC) ((PROC)->pdr.iline)      /* upper address bound */\n-#define PROC_DUMMY_FRAME(PROC) ((PROC)->pdr.cbLineOffset) /*CALL_DUMMY frame */\n-#define PROC_FRAME_OFFSET(PROC) ((PROC)->pdr.frameoffset)\n-#define PROC_FRAME_REG(PROC) ((PROC)->pdr.framereg)\n-#define PROC_REG_MASK(PROC) ((PROC)->pdr.regmask)\n-#define PROC_FREG_MASK(PROC) ((PROC)->pdr.fregmask)\n-#define PROC_REG_OFFSET(PROC) ((PROC)->pdr.regoffset)\n-#define PROC_FREG_OFFSET(PROC) ((PROC)->pdr.fregoffset)\n-#define PROC_PC_REG(PROC) ((PROC)->pdr.pcreg)\n-#define PROC_LOCALOFF(PROC) ((PROC)->pdr.localoff)\n-\n-/* Local storage allocation/deallocation functions.  trace_alloc does\n-   a malloc, but also chains allocated blocks on trace_alloc_chain, so\n-   they may all be freed on exit from __gnat_backtrace. */\n-\n-struct alloc_chain\n-{\n-  struct alloc_chain *next;\n-  double x[0];\n-};\n-struct alloc_chain *trace_alloc_chain;\n-\n-static void *\n-trace_alloc (unsigned int n)\n-{\n-  struct alloc_chain * result = malloc (n + sizeof(struct alloc_chain));\n-\n-  result->next = trace_alloc_chain;\n-  trace_alloc_chain = result;\n-  return (void*) result->x;\n-}\n-\n-static void\n-free_trace_alloc (void)\n-{\n-  while (trace_alloc_chain != 0)\n-    {\n-      struct alloc_chain *old = trace_alloc_chain;\n-\n-      trace_alloc_chain = trace_alloc_chain->next;\n-      free (old);\n-    }\n-}\n-\n-/* Read value at ADDR into *DEST, returning 0 if this is valid, != 0\n-   otherwise. */\n-\n-static int\n-read_memory_safe4 (CORE_ADDR addr, unsigned int *dest)\n-{\n-  *dest = *((unsigned int*) addr);\n-  return 0;\n-}\n-\n-/* Read value at ADDR into *DEST, returning 0 if this is valid, != 0\n-   otherwise. */\n-\n-static int\n-read_memory_safe8 (CORE_ADDR addr, CORE_ADDR *dest)\n-{\n-  *dest = *((CORE_ADDR*) addr);\n-  return 0;\n-}\n-\n-static CORE_ADDR\n-read_register (int regno)\n-{\n-  if (regno >= 0 && regno < 31)\n-    return theRegisters[regno];\n-\n-  return (CORE_ADDR) 0;\n-}\n-\n-static void\n-frame_saved_regs_zalloc (struct frame_info *fi)\n-{\n-  fi->saved_regs = (CORE_ADDR *) trace_alloc (SIZEOF_FRAME_SAVED_REGS);\n-  memset (fi->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);\n-}\n-\n-static void *\n-frame_obstack_alloc (unsigned long size)\n-{\n-  return (void *) trace_alloc (size);\n-}\n-\n-static int\n-inside_entry_file (CORE_ADDR addr)\n-{\n-  if (addr == 0)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-static CORE_ADDR\n-alpha_saved_pc_after_call (struct frame_info *frame)\n-{\n-  CORE_ADDR pc = frame->pc;\n-  alpha_extra_func_info_t proc_desc;\n-  int pcreg;\n-\n-  proc_desc = find_proc_desc (pc, frame->next, NULL);\n-  pcreg = proc_desc ? PROC_PC_REG (proc_desc) : RA_REGNUM;\n-\n-  return read_register (pcreg);\n-}\n-\n-/* Guaranteed to set frame->saved_regs to some values (it never leaves it\n-   NULL).  */\n-\n-static void\n-alpha_find_saved_regs (struct frame_info *frame)\n-{\n-  int ireg;\n-  CORE_ADDR reg_position;\n-  unsigned long mask;\n-  alpha_extra_func_info_t proc_desc;\n-  int returnreg;\n-\n-  frame_saved_regs_zalloc (frame);\n-\n-  /* If it is the frame for __sigtramp, the saved registers are located in a\n-     sigcontext structure somewhere on the stack. __sigtramp passes a pointer\n-     to the sigcontext structure on the stack.  If the stack layout for\n-     __sigtramp changes, or if sigcontext offsets change, we might have to\n-     update this code.  */\n-\n-#ifndef SIGFRAME_PC_OFF\n-#define SIGFRAME_PC_OFF\t\t(2 * 8)\n-#define SIGFRAME_REGSAVE_OFF\t(4 * 8)\n-#define SIGFRAME_FPREGSAVE_OFF\t(SIGFRAME_REGSAVE_OFF + 32 * 8 + 8)\n-#endif\n-\n-  proc_desc = frame->proc_desc;\n-  if (proc_desc == NULL)\n-    /* I'm not sure how/whether this can happen.  Normally when we can't\n-       find a proc_desc, we \"synthesize\" one using heuristic_proc_desc\n-       and set the saved_regs right away.  */\n-    return;\n-\n-  /* Fill in the offsets for the registers which gen_mask says\n-     were saved.  */\n-\n-  reg_position = frame->frame + PROC_REG_OFFSET (proc_desc);\n-  mask = PROC_REG_MASK (proc_desc);\n-\n-  returnreg = PROC_PC_REG (proc_desc);\n-\n-  /* Note that RA is always saved first, regardless of its actual\n-     register number.  */\n-  if (mask & (1 << returnreg))\n-    {\n-      frame->saved_regs[returnreg] = reg_position;\n-      reg_position += 8;\n-      mask &= ~(1 << returnreg);\t/* Clear bit for RA so we\n-\t\t\t\t\t   don't save again later. */\n-    }\n-\n-  for (ireg = 0; ireg <= 31; ireg++)\n-    if (mask & (1 << ireg))\n-      {\n-\tframe->saved_regs[ireg] = reg_position;\n-\treg_position += 8;\n-      }\n-\n-  /* Fill in the offsets for the registers which float_mask says\n-     were saved.  */\n-\n-  reg_position = frame->frame + PROC_FREG_OFFSET (proc_desc);\n-  mask = PROC_FREG_MASK (proc_desc);\n-\n-  for (ireg = 0; ireg <= 31; ireg++)\n-    if (mask & (1 << ireg))\n-      {\n-\tframe->saved_regs[FP0_REGNUM + ireg] = reg_position;\n-\treg_position += 8;\n-      }\n-\n-  frame->saved_regs[PC_REGNUM] = frame->saved_regs[returnreg];\n-}\n-\n-static CORE_ADDR\n-read_next_frame_reg (struct frame_info *fi, int regno)\n-{\n-  CORE_ADDR result;\n-  for (; fi; fi = fi->next)\n-    {\n-      /* We have to get the saved sp from the sigcontext\n-         if it is a signal handler frame.  */\n-      if (regno == SP_REGNUM)\n-\treturn fi->frame;\n-      else\n-\t{\n-\t  if (fi->saved_regs == 0)\n-\t    alpha_find_saved_regs (fi);\n-\n-\t  if (fi->saved_regs[regno])\n-\t    {\n-\t      if (read_memory_safe8 (fi->saved_regs[regno], &result) == 0)\n-\t\treturn result;\n-\t      else\n-\t\treturn 0;\n-\t    }\n-\t}\n-    }\n-\n-  return read_register (regno);\n-}\n-\n-static CORE_ADDR\n-alpha_frame_saved_pc (struct frame_info *frame)\n-{\n-  return read_next_frame_reg (frame, frame->pc_reg);\n-}\n-\n-static struct alpha_extra_func_info temp_proc_desc;\n-\n-/* Nonzero if instruction at PC is a return instruction.  \"ret\n-   $zero,($ra),1\" on alpha. */\n-\n-static int\n-alpha_about_to_return (CORE_ADDR pc)\n-{\n-  int inst;\n-\n-  read_memory_safe4 (pc, &inst);\n-  return inst == 0x6bfa8001;\n-}\n-\n-/* A heuristically computed start address for the subprogram\n-   containing address PC.   Returns 0 if none detected. */\n-\n-static CORE_ADDR\n-heuristic_proc_start (CORE_ADDR pc)\n-{\n-  CORE_ADDR start_pc = pc;\n-  CORE_ADDR fence = start_pc - heuristic_fence_post;\n-\n-  if (start_pc == 0)\n-    return 0;\n-\n-  if (heuristic_fence_post == UINT_MAX\n-      || fence < VM_MIN_ADDRESS)\n-    fence = VM_MIN_ADDRESS;\n-\n-  /* search back for previous return */\n-  for (start_pc -= 4; ; start_pc -= 4)\n-    {\n-      if (start_pc < fence)\n-\treturn 0;\n-      else if (alpha_about_to_return (start_pc))\n-\tbreak;\n-    }\n-\n-  start_pc += 4;\t\t/* skip return */\n-  return start_pc;\n-}\n-\n-static alpha_extra_func_info_t\n-heuristic_proc_desc (CORE_ADDR start_pc,\n-                     CORE_ADDR limit_pc,\n-                     struct frame_info *next_frame,\n-                     struct frame_saved_regs *saved_regs_p)\n-{\n-  CORE_ADDR sp = read_next_frame_reg (next_frame, SP_REGNUM);\n-  CORE_ADDR cur_pc;\n-  int frame_size;\n-  int has_frame_reg = 0;\n-  unsigned long reg_mask = 0;\n-  int pcreg = -1;\n-\n-  if (start_pc == 0)\n-    return 0;\n-\n-  memset (&temp_proc_desc, '\\0', sizeof (temp_proc_desc));\n-  if (saved_regs_p != 0)\n-    memset (saved_regs_p, '\\0', sizeof (struct frame_saved_regs));\n-\n-  PROC_LOW_ADDR (&temp_proc_desc) = start_pc;\n-\n-  if (start_pc + 200 < limit_pc)\n-    limit_pc = start_pc + 200;\n-\n-  frame_size = 0;\n-  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += 4)\n-    {\n-      unsigned int word;\n-      int status;\n-\n-      status = read_memory_safe4 (cur_pc, &word);\n-      if (status)\n-\treturn 0;\n-\n-      if ((word & 0xffff0000) == 0x23de0000)\t/* lda $sp,n($sp) */\n-\t{\n-\t  if (word & 0x8000)\n-\t    frame_size += (-word) & 0xffff;\n-\t  else\n-\t    /* Exit loop if a positive stack adjustment is found, which\n-\t       usually means that the stack cleanup code in the function\n-\t       epilogue is reached.  */\n-\t    break;\n-\t}\n-      else if ((word & 0xfc1f0000) == 0xb41e0000\t/* stq reg,n($sp) */\n-\t       && (word & 0xffff0000) != 0xb7fe0000)\t/* reg != $zero */\n-\t{\n-\t  int reg = (word & 0x03e00000) >> 21;\n-\n-\t  reg_mask |= 1 << reg;\n-\t  if (saved_regs_p != 0)\n-\t    saved_regs_p->regs[reg] = sp + (short) word;\n-\n-\t  /* Starting with OSF/1-3.2C, the system libraries are shipped\n-\t     without local symbols, but they still contain procedure\n-\t     descriptors without a symbol reference. GDB is currently\n-\t     unable to find these procedure descriptors and uses\n-\t     heuristic_proc_desc instead.\n-\t     As some low level compiler support routines (__div*, __add*)\n-\t     use a non-standard return address register, we have to\n-\t     add some heuristics to determine the return address register,\n-\t     or stepping over these routines will fail.\n-\t     Usually the return address register is the first register\n-\t     saved on the stack, but assembler optimization might\n-\t     rearrange the register saves.\n-\t     So we recognize only a few registers (t7, t9, ra) within\n-\t     the procedure prologue as valid return address registers.\n-\t     If we encounter a return instruction, we extract the\n-\t     return address register from it.\n-\n-\t     FIXME: Rewriting GDB to access the procedure descriptors,\n-\t     e.g. via the minimal symbol table, might obviate this hack.  */\n-\t  if (pcreg == -1\n-\t      && cur_pc < (start_pc + 80)\n-\t      && (reg == T7_REGNUM || reg == T9_REGNUM || reg == RA_REGNUM))\n-\t    pcreg = reg;\n-\t}\n-      else if ((word & 0xffe0ffff) == 0x6be08001)\t/* ret zero,reg,1 */\n-\tpcreg = (word >> 16) & 0x1f;\n-      else if (word == 0x47de040f)\t/* bis sp,sp fp */\n-\thas_frame_reg = 1;\n-    }\n-\n-  if (pcreg == -1)\n-    {\n-      /* If we haven't found a valid return address register yet,\n-         keep searching in the procedure prologue.  */\n-      while (cur_pc < (limit_pc + 80) && cur_pc < (start_pc + 80))\n-\t{\n-\t  unsigned int word;\n-\n-\t  if (read_memory_safe4 (cur_pc, &word))\n-\t    break;\n-\t  cur_pc += 4;\n-\n-\t  if ((word & 0xfc1f0000) == 0xb41e0000\t\t/* stq reg,n($sp) */\n-\t      && (word & 0xffff0000) != 0xb7fe0000)\t/* reg != $zero */\n-\t    {\n-\t      int reg = (word & 0x03e00000) >> 21;\n-\n-\t      if (reg == T7_REGNUM || reg == T9_REGNUM || reg == RA_REGNUM)\n-\t\t{\n-\t\t  pcreg = reg;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  else if ((word & 0xffe0ffff) == 0x6be08001)\t/* ret zero,reg,1 */\n-\t    {\n-\t      pcreg = (word >> 16) & 0x1f;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  if (has_frame_reg)\n-    PROC_FRAME_REG (&temp_proc_desc) = GCC_FP_REGNUM;\n-  else\n-    PROC_FRAME_REG (&temp_proc_desc) = SP_REGNUM;\n-\n-  PROC_FRAME_OFFSET (&temp_proc_desc) = frame_size;\n-  PROC_REG_MASK (&temp_proc_desc) = reg_mask;\n-  PROC_PC_REG (&temp_proc_desc) = (pcreg == -1) ? RA_REGNUM : pcreg;\n-  PROC_LOCALOFF (&temp_proc_desc) = 0;\t/* XXX - bogus */\n-\n-  return &temp_proc_desc;\n-}\n-\n-static alpha_extra_func_info_t\n-find_proc_desc (CORE_ADDR pc,\n-                struct frame_info *next_frame,\n-                struct frame_saved_regs *saved_regs)\n-{\n-  CORE_ADDR startaddr;\n-\n-  /* If heuristic_fence_post is nonzero, determine the procedure\n-     start address by examining the instructions.\n-     This allows us to find the start address of static functions which\n-     have no symbolic information, as startaddr would have been set to\n-     the preceding global function start address by the\n-     find_pc_partial_function call above.  */\n-  startaddr = heuristic_proc_start (pc);\n-\n-  return heuristic_proc_desc (startaddr, pc, next_frame, saved_regs);\n-}\n-\n-static CORE_ADDR\n-alpha_frame_chain (struct frame_info *frame)\n-{\n-  alpha_extra_func_info_t proc_desc;\n-  CORE_ADDR saved_pc = FRAME_SAVED_PC (frame);\n-\n-  if (saved_pc == 0 || inside_entry_file (saved_pc))\n-    return 0;\n-\n-  proc_desc = find_proc_desc (saved_pc, frame, NULL);\n-  if (!proc_desc)\n-    return 0;\n-\n-  /* If no frame pointer and frame size is zero, we must be at end\n-     of stack (or otherwise hosed).  If we don't check frame size,\n-     we loop forever if we see a zero size frame.  */\n-  if (PROC_FRAME_REG (proc_desc) == SP_REGNUM\n-      && PROC_FRAME_OFFSET (proc_desc) == 0)\n-    return 0;\n-  else\n-    return read_next_frame_reg (frame, PROC_FRAME_REG (proc_desc))\n-      + PROC_FRAME_OFFSET (proc_desc);\n-}\n-\n-static void\n-init_extra_frame_info (struct frame_info *frame)\n-{\n-  struct frame_saved_regs temp_saved_regs;\n-  alpha_extra_func_info_t proc_desc =\n-    find_proc_desc (frame->pc, frame->next, &temp_saved_regs);\n-\n-  frame->saved_regs = NULL;\n-  frame->localoff = 0;\n-  frame->pc_reg = RA_REGNUM;\n-  frame->proc_desc = proc_desc;\n-\n-  if (proc_desc)\n-    {\n-      /* Get the locals offset and the saved pc register from the\n-         procedure descriptor, they are valid even if we are in the\n-         middle of the prologue.  */\n-      frame->localoff = PROC_LOCALOFF (proc_desc);\n-      frame->pc_reg = PROC_PC_REG (proc_desc);\n-\n-      /* Fixup frame-pointer - only needed for top frame */\n-\n-      /* This may not be quite right, if proc has a real frame register.\n-         Get the value of the frame relative sp, procedure might have been\n-         interrupted by a signal at it's very start.  */\n-      if (frame->pc == PROC_LOW_ADDR (proc_desc))\n-\tframe->frame = read_next_frame_reg (frame->next, SP_REGNUM);\n-      else\n-\tframe->frame\n-\t  = (read_next_frame_reg (frame->next, PROC_FRAME_REG (proc_desc))\n-\t     + PROC_FRAME_OFFSET (proc_desc));\n-\n-      frame->saved_regs\n-\t= (CORE_ADDR *) frame_obstack_alloc (SIZEOF_FRAME_SAVED_REGS);\n-      memcpy\n-        (frame->saved_regs, temp_saved_regs.regs, SIZEOF_FRAME_SAVED_REGS);\n-      frame->saved_regs[PC_REGNUM] = frame->saved_regs[RA_REGNUM];\n-    }\n-}\n-\n-/* Create an arbitrary (i.e. address specified by user) or innermost frame.\n-   Always returns a non-NULL value.  */\n-\n-static struct frame_info *\n-create_new_frame (CORE_ADDR addr, CORE_ADDR pc)\n-{\n-  struct frame_info *fi;\n-\n-  fi = (struct frame_info *)\n-    trace_alloc (sizeof (struct frame_info));\n-\n-  /* Arbitrary frame */\n-  fi->next = NULL;\n-  fi->prev = NULL;\n-  fi->frame = addr;\n-  fi->pc = pc;\n-\n-#ifdef INIT_EXTRA_FRAME_INFO\n-  INIT_EXTRA_FRAME_INFO (0, fi);\n-#endif\n-\n-  return fi;\n-}\n-\n-static CORE_ADDR current_pc;\n-\n-static void\n-set_current_pc (void)\n-{\n-  current_pc = (CORE_ADDR) __builtin_return_address (0);\n-}\n-\n-static CORE_ADDR\n-read_pc (void)\n-{\n-  return current_pc;\n-}\n-\n-static struct frame_info *\n-get_current_frame (void)\n-{\n-  return create_new_frame (0, read_pc ());\n-}\n-\n-/* Return the frame that called FI.\n-   If FI is the original frame (it has no caller), return 0.  */\n-\n-static struct frame_info *\n-get_prev_frame (struct frame_info *next_frame)\n-{\n-  CORE_ADDR address = 0;\n-  struct frame_info *prev;\n-  int fromleaf = 0;\n-\n-  /* If we have the prev one, return it */\n-  if (next_frame->prev)\n-    return next_frame->prev;\n-\n-  /* On some machines it is possible to call a function without\n-     setting up a stack frame for it.  On these machines, we\n-     define this macro to take two args; a frameinfo pointer\n-     identifying a frame and a variable to set or clear if it is\n-     or isn't leafless.  */\n-\n-  /* Two macros defined in tm.h specify the machine-dependent\n-     actions to be performed here.\n-\n-     First, get the frame's chain-pointer.  If that is zero, the frame\n-     is the outermost frame or a leaf called by the outermost frame.\n-     This means that if start calls main without a frame, we'll return\n-     0 (which is fine anyway).\n-\n-     Nope; there's a problem.  This also returns when the current\n-     routine is a leaf of main.  This is unacceptable.  We move\n-     this to after the ffi test; I'd rather have backtraces from\n-     start go curfluy than have an abort called from main not show\n-     main.  */\n-\n-  address = FRAME_CHAIN (next_frame);\n-  if (!FRAME_CHAIN_VALID (address, next_frame))\n-    return 0;\n-  address = FRAME_CHAIN_COMBINE (address, next_frame);\n-\n-  if (address == 0)\n-    return 0;\n-\n-  prev = (struct frame_info *) trace_alloc (sizeof (struct frame_info));\n-\n-  prev->saved_regs = NULL;\n-  if (next_frame)\n-    next_frame->prev = prev;\n-\n-  prev->next = next_frame;\n-  prev->prev = (struct frame_info *) 0;\n-  prev->frame = address;\n-\n-  /* This change should not be needed, FIXME!  We should\n-     determine whether any targets *need* INIT_FRAME_PC to happen\n-     after INIT_EXTRA_FRAME_INFO and come up with a simple way to\n-     express what goes on here.\n-\n-     INIT_EXTRA_FRAME_INFO is called from two places: create_new_frame\n-     (where the PC is already set up) and here (where it isn't).\n-     INIT_FRAME_PC is only called from here, always after\n-     INIT_EXTRA_FRAME_INFO.\n-\n-     The catch is the MIPS, where INIT_EXTRA_FRAME_INFO requires the PC\n-     value (which hasn't been set yet).  Some other machines appear to\n-     require INIT_EXTRA_FRAME_INFO before they can do INIT_FRAME_PC.  Phoo.\n-\n-     We shouldn't need INIT_FRAME_PC_FIRST to add more complication to\n-     an already overcomplicated part of GDB.   gnu@cygnus.com, 15Sep92.\n-\n-     Assuming that some machines need INIT_FRAME_PC after\n-     INIT_EXTRA_FRAME_INFO, one possible scheme:\n-\n-     SETUP_INNERMOST_FRAME()\n-     Default version is just create_new_frame (read_fp ()),\n-     read_pc ()).  Machines with extra frame info would do that (or the\n-     local equivalent) and then set the extra fields.\n-     INIT_PREV_FRAME(fromleaf, prev)\n-     Replace INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC.  This should\n-     also return a flag saying whether to keep the new frame, or\n-     whether to discard it, because on some machines (e.g.  mips) it\n-     is really awkward to have FRAME_CHAIN_VALID called *before*\n-     INIT_EXTRA_FRAME_INFO (there is no good way to get information\n-     deduced in FRAME_CHAIN_VALID into the extra fields of the new frame).\n-     std_frame_pc(fromleaf, prev)\n-     This is the default setting for INIT_PREV_FRAME.  It just does what\n-     the default INIT_FRAME_PC does.  Some machines will call it from\n-     INIT_PREV_FRAME (either at the beginning, the end, or in the middle).\n-     Some machines won't use it.\n-     kingdon@cygnus.com, 13Apr93, 31Jan94, 14Dec94.  */\n-\n-#ifdef INIT_FRAME_PC_FIRST\n-  INIT_FRAME_PC_FIRST (fromleaf, prev);\n-#endif\n-\n-#ifdef INIT_EXTRA_FRAME_INFO\n-  INIT_EXTRA_FRAME_INFO (fromleaf, prev);\n-#endif\n-\n-  /* This entry is in the frame queue now, which is good since\n-     FRAME_SAVED_PC may use that queue to figure out its value\n-     (see tm-sparc.h).  We want the pc saved in the inferior frame. */\n-  INIT_FRAME_PC (fromleaf, prev);\n-\n-  /* If ->frame and ->pc are unchanged, we are in the process of getting\n-     ourselves into an infinite backtrace.  Some architectures check this\n-     in FRAME_CHAIN or thereabouts, but it seems like there is no reason\n-     this can't be an architecture-independent check.  */\n-  if (next_frame != NULL)\n-    {\n-      if (prev->frame == next_frame->frame\n-\t  && prev->pc == next_frame->pc)\n-\t{\n-\t  next_frame->prev = NULL;\n-\t  free (prev);\n-\t  return NULL;\n-\t}\n-    }\n-\n-  return prev;\n-}\n-\n-#define SAVE(regno,disp) \\\n-    \"stq $\" #regno \", \" #disp \"(%0)\\n\"\n-\n-int\n-__gnat_backtrace (void **array,\n-                  int size,\n-                  void *exclude_min,\n-                  void *exclude_max,\n-                  int skip_frames)\n-{\n-  struct frame_info* top;\n-  struct frame_info* current;\n-  int cnt;\n-\n-  /* This function is not thread safe, protect it */\n-  (*Lock_Task) ();\n-  asm volatile (\n-      SAVE (9,72)\n-      SAVE (10,80)\n-      SAVE (11,88)\n-      SAVE (12,96)\n-      SAVE (13,104)\n-      SAVE (14,112)\n-      SAVE (15,120)\n-      SAVE (16,128)\n-      SAVE (17,136)\n-      SAVE (18,144)\n-      SAVE (19,152)\n-      SAVE (20,160)\n-      SAVE (21,168)\n-      SAVE (22,176)\n-      SAVE (23,184)\n-      SAVE (24,192)\n-      SAVE (25,200)\n-      SAVE (26,208)\n-      SAVE (27,216)\n-      SAVE (28,224)\n-      SAVE (29,232)\n-      SAVE (30,240)\n-      : : \"r\" (&theRegisters));\n-\n-  trace_alloc_chain = NULL;\n-  set_current_pc ();\n-\n-  top = current = get_current_frame ();\n-  cnt = 0;\n-\n-  for (cnt = 0; cnt < skip_frames; cnt += 1) {\n-    current = get_prev_frame (current);\n-  }\n-\n-  cnt = 0;\n-  while (cnt < size)\n-    {\n-      if (STOP_FRAME)\n-        break;\n-\n-      if (current->pc < (CORE_ADDR) exclude_min\n-\t  || current->pc > (CORE_ADDR) exclude_max)\n-        array[cnt++] = (void*) (current->pc + PC_ADJUST);\n-\n-      current = get_prev_frame (current);\n-    }\n-\n-  free_trace_alloc ();\n-  (*Unlock_Task) ();\n-\n-  return cnt;\n-}"}, {"sha": "3d55c6e86279ad3b6c7099afa95fcffe723320bf", "filename": "gcc/ada/tb-ivms.c", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69fff50e08365770deca864efd7a904ac9eb25e0/gcc%2Fada%2Ftb-ivms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69fff50e08365770deca864efd7a904ac9eb25e0/gcc%2Fada%2Ftb-ivms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftb-ivms.c?ref=69fff50e08365770deca864efd7a904ac9eb25e0", "patch": "@@ -1,88 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT RUN-TIME COMPONENTS                         *\n- *                                                                          *\n- *                 T R A C E B A C K - I t a n i u m  / V M S               *\n- *                                                                          *\n- *                          C Implementation File                           *\n- *                                                                          *\n- *                     Copyright (C) 2007-2011, AdaCore                     *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n- *                                                                          *\n- * As a special exception under Section 7 of GPL version 3, you are granted *\n- * additional permissions described in the GCC Runtime Library Exception,   *\n- * version 3.1, as published by the Free Software Foundation.               *\n- *                                                                          *\n- * You should have received a copy of the GNU General Public License and    *\n- * a copy of the GCC Runtime Library Exception along with this program;     *\n- * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    *\n- * <http://www.gnu.org/licenses/>.                                          *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* Itanium Open/VMS implementation of backtrace.  Use ICB (Invocation\n-   Context Block) routines.  */\n-#include <stdlib.h>\n-#include <vms/libicb.h>\n-\n-/* Declare libicb routines.  */\n-extern INVO_CONTEXT_BLK *LIB$I64_CREATE_INVO_CONTEXT (void *(*)(size_t),\n-\t\t\t\t\t\t      void (*)(void *),\n-\t\t\t\t\t\t      int);\n-extern void LIB$I64_FREE_INVO_CONTEXT (INVO_CONTEXT_BLK *);\n-extern int LIB$I64_GET_CURR_INVO_CONTEXT(INVO_CONTEXT_BLK *);\n-extern int LIB$I64_GET_PREV_INVO_CONTEXT(INVO_CONTEXT_BLK *);\n-\n-/* Gcc internal headers poison malloc.  So use xmalloc() when building the\n-   compiler.  */\n-#ifdef IN_RTS\n-#define BT_MALLOC malloc\n-#else\n-#define BT_MALLOC xmalloc\n-#endif\n-\n-int\n-__gnat_backtrace (void **array, int size,\n-                  void *exclude_min, void *exclude_max, int skip_frames)\n-{\n-  INVO_CONTEXT_BLK *ctxt;\n-  int res = 0;\n-  int n = 0;\n-\n-  /* Create the context.  */\n-  ctxt = LIB$I64_CREATE_INVO_CONTEXT (BT_MALLOC, free, 0);\n-  if (ctxt == NULL)\n-    return 0;\n-\n-  LIB$I64_GET_CURR_INVO_CONTEXT (ctxt);\n-\n-  while (1)\n-    {\n-      void *pc = (void *)ctxt->libicb$ih_pc;\n-      if (pc == (void *)0)\n-\tbreak;\n-      if (ctxt->libicb$v_bottom_of_stack)\n-\tbreak;\n-      if (n >= skip_frames && (pc < exclude_min || pc > exclude_max))\n-\t{\n-\t  array[res++] = (void *)(ctxt->libicb$ih_pc);\n-\t  if (res == size)\n-\t    break;\n-\t}\n-      n++;\n-      LIB$I64_GET_PREV_INVO_CONTEXT (ctxt);\n-    }\n-\n-  /* Free the context.  */\n-  LIB$I64_FREE_INVO_CONTEXT (ctxt);\n-  return res;\n-}"}, {"sha": "54ec90f674b96d7561f3b16d7f10770554807751", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d4b3d500200caae61f77924b4ebe1bd2b5e0be/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=24d4b3d500200caae61f77924b4ebe1bd2b5e0be", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *            Copyright (C) 2000-2012, Free Software Foundation, Inc.       *\n+ *            Copyright (C) 2000-2014, Free Software Foundation, Inc.       *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -95,19 +95,7 @@ extern void (*Unlock_Task) (void);\n  *-- Target specific implementations --*\n  *-------------------------------------*/\n \n-#if defined (__alpha_vxworks)\n-\n-#include \"tb-alvxw.c\"\n-\n-#elif defined (__ALPHA) && defined (__VMS__)\n-\n-#include \"tb-alvms.c\"\n-\n-#elif defined (__ia64__) && defined (__VMS__)\n-\n-#include \"tb-ivms.c\"\n-\n-#elif defined (_WIN64) && defined (__SEH__)\n+#if defined (_WIN64) && defined (__SEH__)\n \n #include <windows.h>\n "}]}