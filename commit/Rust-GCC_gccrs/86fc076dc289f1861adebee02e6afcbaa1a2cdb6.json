{"sha": "86fc076dc289f1861adebee02e6afcbaa1a2cdb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZmYzA3NmRjMjg5ZjE4NjFhZGViZWUwMmU2YWZjYmFhMWEyY2RiNg==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-06-12T02:52:30Z"}, "committer": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-06-26T01:47:42Z"}, "message": "Expand the comparison argument of fold_cond_expr_with_comparison\n\nTo make things slightly easiler to convert fold_cond_expr_with_comparison\nover to match.pd, expanding the arg0 argument into 3 different arguments\nis done. Also this was simple because we don't use arg0 after grabbing\nthe code and the two operands.\nAlso since we do this, we don't need to fold the comparison to\nget the inverse but just use invert_tree_comparison directly.\n\nOK? Bootstrapped and tested on x86_64-linux-gnu with no regressions.\n\ngcc/ChangeLog:\n\n\t* fold-const.c (fold_cond_expr_with_comparison):\n\tExand arg0 into comp_code, arg00, and arg01.\n\t(fold_ternary_loc): Use invert_tree_comparison\n\tinstead of fold_invert_truthvalue for the case\n\twhere we have A CMP B ? C : A.", "tree": {"sha": "71341c3f73196b5754145834d00a607dee38d5c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71341c3f73196b5754145834d00a607dee38d5c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86fc076dc289f1861adebee02e6afcbaa1a2cdb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fc076dc289f1861adebee02e6afcbaa1a2cdb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86fc076dc289f1861adebee02e6afcbaa1a2cdb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fc076dc289f1861adebee02e6afcbaa1a2cdb6/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90708f87b8d13da61f7d5cba7c6597fee0025bb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90708f87b8d13da61f7d5cba7c6597fee0025bb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90708f87b8d13da61f7d5cba7c6597fee0025bb1"}], "stats": {"total": 39, "additions": 22, "deletions": 17}, "files": [{"sha": "e2110b6bffe8e0af6581f721f19074579d892637", "filename": "gcc/fold-const.c", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc076dc289f1861adebee02e6afcbaa1a2cdb6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc076dc289f1861adebee02e6afcbaa1a2cdb6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=86fc076dc289f1861adebee02e6afcbaa1a2cdb6", "patch": "@@ -126,7 +126,8 @@ static tree range_binop (enum tree_code, tree, tree, int, tree, int);\n static tree range_predecessor (tree);\n static tree range_successor (tree);\n static tree fold_range_test (location_t, enum tree_code, tree, tree, tree);\n-static tree fold_cond_expr_with_comparison (location_t, tree, tree, tree, tree);\n+static tree fold_cond_expr_with_comparison (location_t, tree, enum tree_code,\n+\t\t\t\t\t    tree, tree, tree, tree);\n static tree unextend (tree, int, int, tree);\n static tree extract_muldiv (tree, tree, enum tree_code, tree, bool *);\n static tree extract_muldiv_1 (tree, tree, enum tree_code, tree, bool *);\n@@ -5734,20 +5735,19 @@ merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n \f\n \n /* Subroutine of fold, looking inside expressions of the form\n-   A op B ? A : C, where ARG0, ARG1 and ARG2 are the three operands\n-   of the COND_EXPR.  This function is being used also to optimize\n-   A op B ? C : A, by reversing the comparison first.\n+   A op B ? A : C, where (ARG00, COMP_CODE, ARG01), ARG1 and ARG2\n+   are the three operands of the COND_EXPR.  This function is\n+   being used also to optimize A op B ? C : A, by reversing the\n+   comparison first.\n \n    Return a folded expression whose code is not a COND_EXPR\n    anymore, or NULL_TREE if no folding opportunity is found.  */\n \n static tree\n fold_cond_expr_with_comparison (location_t loc, tree type,\n-\t\t\t\ttree arg0, tree arg1, tree arg2)\n+\t\t\t\tenum tree_code comp_code,\n+\t\t\t\ttree arg00, tree arg01, tree arg1, tree arg2)\n {\n-  enum tree_code comp_code = TREE_CODE (arg0);\n-  tree arg00 = TREE_OPERAND (arg0, 0);\n-  tree arg01 = TREE_OPERAND (arg0, 1);\n   tree arg1_type = TREE_TYPE (arg1);\n   tree tem;\n \n@@ -12821,7 +12821,10 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0), op1)\n \t  && !HONOR_SIGNED_ZEROS (element_mode (op1)))\n \t{\n-\t  tem = fold_cond_expr_with_comparison (loc, type, arg0, op1, op2);\n+\t  tem = fold_cond_expr_with_comparison (loc, type, TREE_CODE (arg0),\n+\t\t\t\t\t\tTREE_OPERAND (arg0, 0),\n+\t\t\t\t\t\tTREE_OPERAND (arg0, 1),\n+\t\t\t\t\t\top1, op2);\n \t  if (tem)\n \t    return tem;\n \t}\n@@ -12830,14 +12833,16 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0), op2)\n \t  && !HONOR_SIGNED_ZEROS (element_mode (op2)))\n \t{\n-\t  location_t loc0 = expr_location_or (arg0, loc);\n-\t  tem = fold_invert_truthvalue (loc0, arg0);\n-\t  if (tem && COMPARISON_CLASS_P (tem))\n-\t    {\n-\t      tem = fold_cond_expr_with_comparison (loc, type, tem, op2, op1);\n-\t      if (tem)\n-\t\treturn tem;\n-\t    }\n+\t  enum tree_code comp_code = TREE_CODE (arg0);\n+\t  tree arg00 = TREE_OPERAND (arg0, 0);\n+\t  tree arg01 = TREE_OPERAND (arg0, 1);\n+\t  comp_code = invert_tree_comparison (comp_code, HONOR_NANS (arg00));\n+\t  tem = fold_cond_expr_with_comparison (loc, type, comp_code,\n+\t\t\t\t\t\targ00,\n+\t\t\t\t\t\targ01,\n+\t\t\t\t\t\top2, op1);\n+\t  if (tem)\n+\t    return tem;\n \t}\n \n       /* If the second operand is simpler than the third, swap them"}]}