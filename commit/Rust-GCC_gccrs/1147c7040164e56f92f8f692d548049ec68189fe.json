{"sha": "1147c7040164e56f92f8f692d548049ec68189fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE0N2M3MDQwMTY0ZTU2ZjkyZjhmNjkyZDU0ODA0OWVjNjgxODlmZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-10T16:02:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-10T16:02:23Z"}, "message": "Revert unwanted change in previous commit.\n\nFrom-SVN: r145925", "tree": {"sha": "f086941b52cb28d0fcb9bd7024afe8633d9f9a89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f086941b52cb28d0fcb9bd7024afe8633d9f9a89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1147c7040164e56f92f8f692d548049ec68189fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1147c7040164e56f92f8f692d548049ec68189fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1147c7040164e56f92f8f692d548049ec68189fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1147c7040164e56f92f8f692d548049ec68189fe/comments", "author": null, "committer": null, "parents": [{"sha": "fad0600db0ecc1bbd55a7faf17046d727dde94c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad0600db0ecc1bbd55a7faf17046d727dde94c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad0600db0ecc1bbd55a7faf17046d727dde94c6"}], "stats": {"total": 70, "additions": 2, "deletions": 68}, "files": [{"sha": "6b2794b407317d38416838e8261725aa08966588", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 68, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1147c7040164e56f92f8f692d548049ec68189fe/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1147c7040164e56f92f8f692d548049ec68189fe/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=1147c7040164e56f92f8f692d548049ec68189fe", "patch": "@@ -4799,7 +4799,7 @@ package body Exp_Ch4 is\n \n          --  Check for 64-bit division available, or long shifts if the divisor\n          --  is a small power of 2 (since such divides will be converted into\n-         --  long shifts.\n+         --  long shifts).\n \n          if Esize (Ltyp) > 32\n            and then not Support_64_Bit_Divides_On_Target\n@@ -5715,7 +5715,7 @@ package body Exp_Ch4 is\n \n       --  Otherwise we have to introduce conversions (conversions are also\n       --  required in the universal cases, since the runtime routine is\n-      --  typed using one of the standard types.\n+      --  typed using one of the standard types).\n \n       else\n          Rewrite (N,\n@@ -7936,72 +7936,6 @@ package body Exp_Ch4 is\n             or else\n           (Is_Fixed_Point_Type (Target_Type) and then Conversion_OK (N)))\n       then\n-         --  Handle case in which type conversions from real types to integers\n-         --  are truncated instead of rounded. For example, in the .NET target\n-         --  the only instructions available for conversion from float types to\n-         --  integers truncate the result. That is, the result of Integer (3.9)\n-         --  is 3 instead of 4. The frontend expansion done here to handle also\n-         --  negative values is the following composition of conditional\n-         --  expressions:\n-\n-         --    (if Abs (Operand - Float(Integer(Operand))) >= 0.5 then\n-         --        (if Operand >= 0.0 then\n-         --            Integer(Operand) + 1\n-         --         else\n-         --            Integer(Operand) - 1)\n-         --     else\n-         --       Integer(Operand))\n-\n-         if Integer_Truncation_On_Target and then Comes_From_Source (N) then\n-            declare\n-               Conv_Node : Node_Id;\n-\n-            begin\n-               --  This code is weird, why are we doing all these copy tree\n-               --  operations, instead of just capturing Integer(Operand)\n-               --  once and then reusing the value instead of forcing this\n-               --  conversion to be done four times! ???\n-\n-               --  There should be no New_Copy_Tree operations in the below\n-               --  code at all???\n-\n-               Conv_Node := New_Copy_Tree (N);\n-               Set_Parent (Conv_Node, Parent (N));\n-               Set_Comes_From_Source (Conv_Node, False);\n-               Analyze_And_Resolve (Conv_Node, Target_Type);\n-\n-               Rewrite (N,\n-                 Make_Conditional_Expression (Loc,\n-                   Expressions => New_List (\n-                     Make_Op_Ge (Loc,\n-                       Left_Opnd =>\n-                         Make_Op_Abs (Loc,\n-                           Make_Op_Subtract (Loc,\n-                             New_Copy_Tree (Operand),\n-                             Make_Type_Conversion (Loc,\n-                               New_Reference_To (Etype (Operand), Loc),\n-                               New_Copy_Tree (Conv_Node)))),\n-                       Right_Opnd => Make_Real_Literal (Loc, Ureal_Half)),\n-\n-                     Make_Conditional_Expression (Loc,\n-                       Expressions => New_List (\n-                         Make_Op_Ge (Loc,\n-                           Left_Opnd  => New_Copy_Tree (Operand),\n-                           Right_Opnd => Make_Real_Literal (Loc, Ureal_0)),\n-                         Make_Op_Add (Loc,\n-                           New_Copy_Tree (Conv_Node),\n-                           Make_Integer_Literal (Loc, 1)),\n-                         Make_Op_Subtract (Loc,\n-                           New_Copy_Tree (Conv_Node),\n-                           Make_Integer_Literal (Loc, 1)))),\n-\n-                     New_Copy_Tree (Conv_Node))));\n-\n-               Analyze_And_Resolve (N, Target_Type);\n-               return;\n-            end;\n-         end if;\n-\n          --  One more check here, gcc is still not able to do conversions of\n          --  this type with proper overflow checking, and so gigi is doing an\n          --  approximation of what is required by doing floating-point compares"}]}