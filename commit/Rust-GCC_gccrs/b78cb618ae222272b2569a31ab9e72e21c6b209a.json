{"sha": "b78cb618ae222272b2569a31ab9e72e21c6b209a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4Y2I2MThhZTIyMjI3MmIyNTY5YTMxYWI5ZTcyZTIxYzZiMjA5YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-07-22T21:40:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-07-22T21:40:41Z"}, "message": "re PR target/45027 (FAIL: c-c++-common/dfp/pr36800.c)\n\n\tPR target/45027\n\t* config/i386/i386.c (setup_incoming_varargs_64): Force the use\n\tof V4SFmode for the SSE saves; increase stack alignment if needed.\n\t(ix86_gimplify_va_arg): Don't increase stack alignment here.\n\nFrom-SVN: r162429", "tree": {"sha": "644104a945f1c15e1f304eb684ac796a416611bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/644104a945f1c15e1f304eb684ac796a416611bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b78cb618ae222272b2569a31ab9e72e21c6b209a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78cb618ae222272b2569a31ab9e72e21c6b209a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b78cb618ae222272b2569a31ab9e72e21c6b209a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78cb618ae222272b2569a31ab9e72e21c6b209a/comments", "author": null, "committer": null, "parents": [{"sha": "2e29059874e839158a2e42aa6510ca874568355f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e29059874e839158a2e42aa6510ca874568355f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e29059874e839158a2e42aa6510ca874568355f"}], "stats": {"total": 28, "additions": 17, "deletions": 11}, "files": [{"sha": "d2576fbd246e86506a5a3f97c3cb25ea1c7c18b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78cb618ae222272b2569a31ab9e72e21c6b209a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78cb618ae222272b2569a31ab9e72e21c6b209a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b78cb618ae222272b2569a31ab9e72e21c6b209a", "patch": "@@ -1,3 +1,10 @@\n+2010-07-22  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/45027\n+\t* config/i386/i386.c (setup_incoming_varargs_64): Force the use\n+\tof V4SFmode for the SSE saves; increase stack alignment if needed.\n+\t(ix86_gimplify_va_arg): Don't increase stack alignment here.\n+\n 2010-07-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/45028"}, {"sha": "596a6db22adf99a845f515342c42006eea541140", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78cb618ae222272b2569a31ab9e72e21c6b209a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78cb618ae222272b2569a31ab9e72e21c6b209a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b78cb618ae222272b2569a31ab9e72e21c6b209a", "patch": "@@ -7073,7 +7073,7 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n \n   /* FPR size of varargs save area.  We don't need it if we don't pass\n      anything in SSE registers.  */\n-  if (cum->sse_nregs && cfun->va_list_fpr_size)\n+  if (TARGET_SSE && cfun->va_list_fpr_size)\n     ix86_varargs_fpr_size = X86_64_SSE_REGPARM_MAX * 16;\n   else\n     ix86_varargs_fpr_size = 0;\n@@ -7112,12 +7112,13 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n       emit_jump_insn (gen_cbranchqi4 (test, XEXP (test, 0), XEXP (test, 1),\n \t\t\t\t      label));\n \n-      /* If we've determined that we're only loading scalars (and not\n-\t vector data) then we can store doubles instead.  */\n-      if (crtl->stack_alignment_needed < 128)\n-\tsmode = DFmode;\n-      else\n-\tsmode = V4SFmode;\n+      /* ??? If !TARGET_SSE_TYPELESS_STORES, would we perform better if\n+\t we used movdqa (i.e. TImode) instead?  Perhaps even better would\n+\t be if we could determine the real mode of the data, via a hook\n+\t into pass_stdarg.  Ignore all that for now.  */\n+      smode = V4SFmode;\n+      if (crtl->stack_alignment_needed < GET_MODE_ALIGNMENT (smode))\n+\tcrtl->stack_alignment_needed = GET_MODE_ALIGNMENT (smode);\n \n       max = cum->sse_regno + cfun->va_list_fpr_size / 16;\n       if (max > X86_64_SSE_REGPARM_MAX)\n@@ -7549,8 +7550,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n     arg_boundary = MAX_SUPPORTED_STACK_ALIGNMENT;\n \n   /* Care for on-stack alignment if needed.  */\n-  if (arg_boundary <= 64\n-      || integer_zerop (TYPE_SIZE (type)))\n+  if (arg_boundary <= 64 || size == 0)\n     t = ovf;\n  else\n     {\n@@ -7561,9 +7561,8 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n       t = build2 (BIT_AND_EXPR, TREE_TYPE (t), t,\n \t\t  size_int (-align));\n       t = fold_convert (TREE_TYPE (ovf), t);\n-      if (crtl->stack_alignment_needed < arg_boundary)\n-\tcrtl->stack_alignment_needed = arg_boundary;\n     }\n+\n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n   gimplify_assign (addr, t, pre_p);\n "}]}