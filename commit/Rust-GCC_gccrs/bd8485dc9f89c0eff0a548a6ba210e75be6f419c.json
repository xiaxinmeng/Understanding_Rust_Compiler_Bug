{"sha": "bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ4NDg1ZGM5Zjg5YzBlZmYwYTU0OGE2YmEyMTBlNzViZTZmNDE5Yw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-07-09T13:06:29Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-07-09T13:06:29Z"}, "message": "stl_vector.h: Use new allocator model in C++0x mode.\n\n2011-07-09  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\t* include/bits/stl_vector.h: Use new allocator model in C++0x mode.\n\t* include/bits/vector.tcc: Likewise.\n\t* testsuite/util/testsuite_allocator.h (propagating_allocator): Define.\n\t* testsuite/23_containers/vector/allocator/copy_assign.cc: New.\n\t* testsuite/23_containers/vector/allocator/noexcept.cc: New.\n\t* testsuite/23_containers/vector/allocator/copy.cc: New.\n\t* testsuite/23_containers/vector/allocator/swap.cc: New.\n\t* testsuite/23_containers/vector/allocator/move_assign.cc: New.\n\t* testsuite/23_containers/vector/requirements/dr438/assign_neg.cc:\n\tAdjust dg-error line numbers.\n\t* testsuite/23_containers/vector/requirements/dr438/insert_neg.cc:\n\tLikewise.\n\t* testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc:\n\tLikewise.\n\t* testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc:\n\tLikewise.\n\nFrom-SVN: r176078", "tree": {"sha": "9de30d3673ee4ce80fd8dab53b821f2f28eef1b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9de30d3673ee4ce80fd8dab53b821f2f28eef1b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d526242cd8b91c314769b920b7e24a457f7f585e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d526242cd8b91c314769b920b7e24a457f7f585e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d526242cd8b91c314769b920b7e24a457f7f585e"}], "stats": {"total": 580, "additions": 521, "deletions": 59}, "files": [{"sha": "1304b9241e2800599a953fef85abfd8502d027d4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -1,3 +1,22 @@\n+2011-07-09  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/bits/stl_vector.h: Use new allocator model in C++0x mode.\n+\t* include/bits/vector.tcc: Likewise.\n+\t* testsuite/util/testsuite_allocator.h (propagating_allocator): Define.\n+\t* testsuite/23_containers/vector/allocator/copy_assign.cc: New.\n+\t* testsuite/23_containers/vector/allocator/noexcept.cc: New.\n+\t* testsuite/23_containers/vector/allocator/copy.cc: New.\n+\t* testsuite/23_containers/vector/allocator/swap.cc: New.\n+\t* testsuite/23_containers/vector/allocator/move_assign.cc: New.\n+\t* testsuite/23_containers/vector/requirements/dr438/assign_neg.cc:\n+\tAdjust dg-error line numbers.\n+\t* testsuite/23_containers/vector/requirements/dr438/insert_neg.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc:\n+\tLikewise.\n+\n 2011-07-09  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* include/ext/alloc_traits.h (__allocator_always_compares_equal): New"}, {"sha": "0211033a456fa709773c255d5c55eb2acbac12b8", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 103, "deletions": 42, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -71,13 +71,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     struct _Vector_base\n     {\n       typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;\n+      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer\n+       \tpointer;\n \n       struct _Vector_impl \n       : public _Tp_alloc_type\n       {\n-\ttypename _Tp_alloc_type::pointer _M_start;\n-\ttypename _Tp_alloc_type::pointer _M_finish;\n-\ttypename _Tp_alloc_type::pointer _M_end_of_storage;\n+\tpointer _M_start;\n+\tpointer _M_finish;\n+\tpointer _M_end_of_storage;\n \n \t_Vector_impl()\n \t: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n@@ -93,6 +95,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  _M_start(0), _M_finish(0), _M_end_of_storage(0)\n \t{ }\n #endif\n+\n+\tvoid _M_swap_data(_Vector_impl& __x)\n+\t{\n+\t  std::swap(_M_start, __x._M_start);\n+\t  std::swap(_M_finish, __x._M_finish);\n+\t  std::swap(_M_end_of_storage, __x._M_end_of_storage);\n+\t}\n       };\n       \n     public:\n@@ -118,30 +127,30 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       _Vector_base(size_t __n)\n       : _M_impl()\n-      {\n-\tthis->_M_impl._M_start = this->_M_allocate(__n);\n-\tthis->_M_impl._M_finish = this->_M_impl._M_start;\n-\tthis->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n-      }\n+      { _M_create_storage(__n); }\n \n       _Vector_base(size_t __n, const allocator_type& __a)\n       : _M_impl(__a)\n-      {\n-\tthis->_M_impl._M_start = this->_M_allocate(__n);\n-\tthis->_M_impl._M_finish = this->_M_impl._M_start;\n-\tthis->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n-      }\n+      { _M_create_storage(__n); }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      _Vector_base(_Tp_alloc_type&& __a)\n+      : _M_impl(std::move(__a)) { }\n+\n       _Vector_base(_Vector_base&& __x)\n       : _M_impl(std::move(__x._M_get_Tp_allocator()))\n+      { this->_M_impl._M_swap_data(__x._M_impl); }\n+\n+      _Vector_base(_Vector_base&& __x, const allocator_type& __a)\n+      : _M_impl(__a)\n       {\n-\tthis->_M_impl._M_start = __x._M_impl._M_start;\n-\tthis->_M_impl._M_finish = __x._M_impl._M_finish;\n-\tthis->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;\n-\t__x._M_impl._M_start = 0;\n-\t__x._M_impl._M_finish = 0;\n-\t__x._M_impl._M_end_of_storage = 0;\n+\tif (__x.get_allocator() == __a)\n+\t  this->_M_impl._M_swap_data(__x._M_impl);\n+\telse\n+\t  {\n+\t    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;\n+\t    _M_create_storage(__n);\n+\t  }\n       }\n #endif\n \n@@ -152,16 +161,25 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     public:\n       _Vector_impl _M_impl;\n \n-      typename _Tp_alloc_type::pointer\n+      pointer\n       _M_allocate(size_t __n)\n       { return __n != 0 ? _M_impl.allocate(__n) : 0; }\n \n       void\n-      _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)\n+      _M_deallocate(pointer __p, size_t __n)\n       {\n \tif (__p)\n \t  _M_impl.deallocate(__p, __n);\n       }\n+\n+    private:\n+      void\n+      _M_create_storage(size_t __n)\n+      {\n+\tthis->_M_impl._M_start = this->_M_allocate(__n);\n+\tthis->_M_impl._M_finish = this->_M_impl._M_start;\n+\tthis->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n+      }\n     };\n \n \n@@ -196,10 +214,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n     public:\n       typedef _Tp\t\t\t\t\t value_type;\n-      typedef typename _Tp_alloc_type::pointer           pointer;\n-      typedef typename _Tp_alloc_type::const_pointer     const_pointer;\n-      typedef typename _Tp_alloc_type::reference         reference;\n-      typedef typename _Tp_alloc_type::const_reference   const_reference;\n+      typedef typename _Base::pointer                    pointer;\n+      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>  _Alloc_traits;\n+      typedef typename _Alloc_traits::const_pointer      const_pointer;\n+      typedef typename _Alloc_traits::reference          reference;\n+      typedef typename _Alloc_traits::const_reference    const_reference;\n       typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;\n       typedef __gnu_cxx::__normal_iterator<const_pointer, vector>\n       const_iterator;\n@@ -283,7 +302,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @a x (for fast expansion) will not be copied.\n        */\n       vector(const vector& __x)\n-      : _Base(__x.size(), __x._M_get_Tp_allocator())\n+      : _Base(__x.size(),\n+        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))\n       { this->_M_impl._M_finish =\n \t  std::__uninitialized_copy_a(__x.begin(), __x.end(),\n \t\t\t\t      this->_M_impl._M_start,\n@@ -301,6 +321,29 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       vector(vector&& __x) noexcept\n       : _Base(std::move(__x)) { }\n \n+      /// Copy constructor with alternative allocator\n+      vector(const vector& __x, const allocator_type& __a)\n+      : _Base(__x.size(), __a)\n+      { this->_M_impl._M_finish =\n+\t  std::__uninitialized_copy_a(__x.begin(), __x.end(),\n+\t\t\t\t      this->_M_impl._M_start,\n+\t\t\t\t      _M_get_Tp_allocator());\n+      }\n+\n+      /// Move constructor with alternative allocator\n+      vector(vector&& __rv, const allocator_type& __m)\n+      : _Base(std::move(__rv), __m)\n+      {\n+\tif (__rv.get_allocator() != __m)\n+\t  {\n+\t    this->_M_impl._M_finish =\n+\t      std::__uninitialized_move_a(__rv.begin(), __rv.end(),\n+\t\t\t\t\t  this->_M_impl._M_start,\n+\t\t\t\t\t  _M_get_Tp_allocator());\n+\t    __rv.clear();\n+\t  }\n+      }\n+\n       /**\n        *  @brief  Builds a %vector from an initializer list.\n        *  @param  l  An initializer_list.\n@@ -377,12 +420,32 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @a x is a valid, but unspecified %vector.\n        */\n       vector&\n-      operator=(vector&& __x)\n+      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n       {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n+\tif (_Alloc_traits::_S_propagate_on_move_assign())\n+\t  {\n+\t    // We're moving the rvalue's allocator so can move the data too.\n+\t    const vector __tmp(std::move(*this));     // discard existing data\n+\t    this->_M_impl._M_swap_data(__x._M_impl);\n+\t    std::__alloc_on_move(_M_get_Tp_allocator(),\n+\t\t\t\t __x._M_get_Tp_allocator());\n+\t  }\n+\telse if (_Alloc_traits::_S_always_equal()\n+\t         || __x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())\n+\t  {\n+\t    // The rvalue's allocator can free our storage and vice versa,\n+\t    // so can swap the data storage after destroying our contents.\n+\t    this->clear();\n+\t    this->_M_impl._M_swap_data(__x._M_impl);\n+\t  }\n+\telse\n+\t  {\n+\t    // The rvalue's allocator cannot be moved, or is not equal,\n+\t    // so we need to individually move each element.\n+\t    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),\n+\t\t\t std::__make_move_if_noexcept_iterator(__x.end()));\n+\t    __x.clear();\n+\t  }\n \treturn *this;\n       }\n \n@@ -834,7 +897,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       {\n \tif (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n \t  {\n-\t    this->_M_impl.construct(this->_M_impl._M_finish, __x);\n+\t    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n+\t                             __x);\n \t    ++this->_M_impl._M_finish;\n \t  }\n \telse\n@@ -864,7 +928,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       pop_back()\n       {\n \t--this->_M_impl._M_finish;\n-\tthis->_M_impl.destroy(this->_M_impl._M_finish);\n+\t_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);\n       }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n@@ -1024,16 +1088,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       swap(vector& __x)\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+\t\t\tnoexcept(_Alloc_traits::_S_nothrow_swap())\n+#endif\n       {\n-\tstd::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n-\tstd::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n-\tstd::swap(this->_M_impl._M_end_of_storage,\n-\t\t  __x._M_impl._M_end_of_storage);\n-\n-\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 431. Swapping containers with unequal allocators.\n-\tstd::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),\n-\t\t\t\t\t\t    __x._M_get_Tp_allocator());\n+\tthis->_M_impl._M_swap_data(__x._M_impl);\n+\t_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),\n+\t                          __x._M_get_Tp_allocator());\n       }\n \n       /**"}, {"sha": "85b514b561b00ce2ccacf72cdcfc22d71c43996f", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -94,8 +94,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       {\n \tif (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n \t  {\n-\t    this->_M_impl.construct(this->_M_impl._M_finish,\n-\t\t\t\t    std::forward<_Args>(__args)...);\n+\t    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n+\t\t\t\t     std::forward<_Args>(__args)...);\n \t    ++this->_M_impl._M_finish;\n \t  }\n \telse\n@@ -112,7 +112,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage\n \t  && __position == end())\n \t{\n-\t  this->_M_impl.construct(this->_M_impl._M_finish, __x);\n+\t  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);\n \t  ++this->_M_impl._M_finish;\n \t}\n       else\n@@ -138,7 +138,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       if (__position + 1 != end())\n \t_GLIBCXX_MOVE3(__position + 1, end(), __position);\n       --this->_M_impl._M_finish;\n-      this->_M_impl.destroy(this->_M_impl._M_finish);\n+      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);\n       return __position;\n     }\n \n@@ -160,6 +160,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     {\n       if (&__x != this)\n \t{\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+\t  if (_Alloc_traits::_S_propagate_on_copy_assign())\n+\t    {\n+\t      if (!_Alloc_traits::_S_always_equal()\n+\t          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())\n+\t        {\n+\t\t  // replacement allocator cannot free existing storage\n+\t\t  this->clear();\n+\t\t  _M_deallocate(this->_M_impl._M_start,\n+\t\t\t\tthis->_M_impl._M_end_of_storage\n+\t\t\t\t- this->_M_impl._M_start);\n+\t\t}\n+\t      std::__alloc_on_copy(_M_get_Tp_allocator(),\n+\t\t\t\t   __x._M_get_Tp_allocator());\n+\t    }\n+#endif\n \t  const size_type __xlen = __x.size();\n \t  if (__xlen > capacity())\n \t    {\n@@ -277,8 +293,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tif (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage\n \t    && __position == end())\n \t  {\n-\t    this->_M_impl.construct(this->_M_impl._M_finish,\n-\t\t\t\t    std::forward<_Args>(__args)...);\n+\t    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n+\t\t\t\t     std::forward<_Args>(__args)...);\n \t    ++this->_M_impl._M_finish;\n \t  }\n \telse\n@@ -300,9 +316,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     {\n       if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n \t{\n-\t  this->_M_impl.construct(this->_M_impl._M_finish,\n-\t\t\t\t  _GLIBCXX_MOVE(*(this->_M_impl._M_finish\n-\t\t\t\t\t\t  - 1)));\n+\t  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n+\t\t\t           _GLIBCXX_MOVE(*(this->_M_impl._M_finish\n+\t\t\t\t                   - 1)));\n \t  ++this->_M_impl._M_finish;\n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n \t  _Tp __x_copy = __x;\n@@ -329,11 +345,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t      // case, where the moves could alter a new element belonging\n \t      // to the existing vector.  This is an issue only for callers\n \t      // taking the element by const lvalue ref (see 23.1/13).\n-\t      this->_M_impl.construct(__new_start + __elems_before,\n+\t      _Alloc_traits::construct(this->_M_impl,\n+\t\t                       __new_start + __elems_before,\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-\t\t\t\t      std::forward<_Args>(__args)...);\n+\t\t\t\t       std::forward<_Args>(__args)...);\n #else\n-\t                              __x);\n+\t                               __x);\n #endif\n \t      __new_finish = 0;\n \n@@ -352,7 +369,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n           __catch(...)\n \t    {\n \t      if (!__new_finish)\n-\t\tthis->_M_impl.destroy(__new_start + __elems_before);\n+\t\t_Alloc_traits::destroy(this->_M_impl,\n+\t\t                       __new_start + __elems_before);\n \t      else\n \t\tstd::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());\n \t      _M_deallocate(__new_start, __len);"}, {"sha": "bcd521efe18dd9419b4ab75d8a0de5ee68795a78", "filename": "libstdc++-v3/testsuite/23_containers/vector/allocator/copy.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fcopy.cc?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2011 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+ \n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+ \n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "0e2050e0e3cd9ff5fd626ca15f9f6bfb0c5eb0bb", "filename": "libstdc++-v3/testsuite/23_containers/vector/allocator/copy_assign.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fcopy_assign.cc?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2011 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+ \n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+ \n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "2a792c61c895acbd71d7c8ad9d00729f0c896e9b", "filename": "libstdc++-v3/testsuite/23_containers/vector/allocator/move_assign.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fmove_assign.cc?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2011 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+ \n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+ \n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  v2 = std::move(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  v2 = std::move(v1);\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "8bde430e23970b5292e18dba42a4dcedd7ade3c5", "filename": "libstdc++-v3/testsuite/23_containers/vector/allocator/noexcept.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fnoexcept.cc?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -0,0 +1,76 @@\n+// Copyright (C) 2011 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+ \n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+ \n+struct T { int i; };\n+\n+namespace __gnu_test\n+{\n+  inline void\n+  swap(propagating_allocator<T, true>& l, propagating_allocator<T, true>& r)\n+  noexcept(false)\n+  {\n+    typedef uneq_allocator<T> base_alloc;\n+    swap(static_cast<base_alloc&>(l), static_cast<base_alloc&>(r));\n+  }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<T> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "808753e752095ce3423a845b12d7de449085c71a", "filename": "libstdc++-v3/testsuite/23_containers/vector/allocator/swap.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fswap.cc?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2011 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+ \n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+ \n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "8ff85455db71c91ce0023de0bc65dee7141ec7dd", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fassign_neg.cc?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1157 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1218 }\n \n #include <vector>\n "}, {"sha": "344f1a68170f39dce62c3c6ba8c3303f4c621a9b", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1087 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1148 }\n \n #include <vector>\n "}, {"sha": "7f3c52e805894776558bb9640b8e182516998aaf", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1087 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1148 }\n \n #include <vector>\n #include <utility>"}, {"sha": "c2337c82c657be16ab4b32d12ca7c8b647f2f78e", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/insert_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Finsert_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Finsert_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Finsert_neg.cc?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1198 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1259 }\n \n #include <vector>\n "}, {"sha": "3b9fb28b9011467357eb01d5b31068f039a9af36", "filename": "libstdc++-v3/testsuite/util/testsuite_allocator.h", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8485dc9f89c0eff0a548a6ba210e75be6f419c/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h?ref=bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "patch": "@@ -371,6 +371,68 @@ namespace __gnu_test\n       \n       int personality;\n     };\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  // An uneq_allocator which can be used to test allocator propagation.\n+  template<typename Tp, bool Propagate>\n+    class propagating_allocator : public uneq_allocator<Tp>\n+    {\n+      typedef uneq_allocator<Tp> base_alloc;\n+      base_alloc& base() { return *this; }\n+      const base_alloc& base() const  { return *this; }\n+      void swap_base(base_alloc& b) { swap(b, this->base()); }\n+\n+      typedef std::integral_constant<bool, Propagate> trait_type;\n+\n+    public:\n+      template<typename Up>\n+\tstruct rebind { typedef propagating_allocator<Up, Propagate> other; };\n+\n+      propagating_allocator(int i) noexcept\n+      : base_alloc(i)\n+      { }\n+\n+      template<typename Up>\n+\tpropagating_allocator(const propagating_allocator<Up, Propagate>& a)\n+       \tnoexcept\n+\t: base_alloc(a)\n+\t{ }\n+\n+      propagating_allocator() noexcept = default;\n+\n+      propagating_allocator(const propagating_allocator&) noexcept = default;\n+\n+      template<bool P2>\n+  \tpropagating_allocator&\n+  \toperator=(const propagating_allocator<Tp, P2>& a) noexcept\n+  \t{\n+\t  static_assert(P2, \"assigning propagating_allocator<T, true>\");\n+\t  propagating_allocator(a).swap_base(*this);\n+  \t}\n+\n+      // postcondition: a.get_personality() == 0\n+      propagating_allocator(propagating_allocator&& a) noexcept\n+      : base_alloc()\n+      { swap_base(a); }\n+\n+      // postcondition: a.get_personality() == 0\n+      propagating_allocator&\n+      operator=(propagating_allocator&& a) noexcept\n+      {\n+\tpropagating_allocator(std::move(a)).swap_base(*this);\n+\treturn *this;\n+      }\n+\n+      typedef trait_type propagate_on_container_copy_assignment;\n+      typedef trait_type propagate_on_container_move_assignment;\n+      typedef trait_type propagate_on_container_swap;\n+\n+      propagating_allocator select_on_container_copy_construction() const\n+      { return Propagate ? *this : propagating_allocator(); }\n+    };\n+\n+#endif\n+\n } // namespace __gnu_test\n \n #endif // _GLIBCXX_TESTSUITE_ALLOCATOR_H"}]}