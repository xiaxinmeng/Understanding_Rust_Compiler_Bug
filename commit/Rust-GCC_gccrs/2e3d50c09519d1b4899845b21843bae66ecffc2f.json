{"sha": "2e3d50c09519d1b4899845b21843bae66ecffc2f", "node_id": "C_kwDOANBUbNoAKDJlM2Q1MGMwOTUxOWQxYjQ4OTk4NDViMjE4NDNiYWU2NmVjZmZjMmY", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-10-06T17:24:24Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-10-06T20:08:47Z"}, "message": "libsanitizer: Merge with upstream\n\nMerged revision: fdf4c035225de52f596899931b1f6100e5e3e928", "tree": {"sha": "1c5ac48bcb8a3893f929c68d5e470913d4d31f97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c5ac48bcb8a3893f929c68d5e470913d4d31f97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e3d50c09519d1b4899845b21843bae66ecffc2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3d50c09519d1b4899845b21843bae66ecffc2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e3d50c09519d1b4899845b21843bae66ecffc2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3d50c09519d1b4899845b21843bae66ecffc2f/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "881d1689a42cc7a1fd63bde53c883e52a56eded3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881d1689a42cc7a1fd63bde53c883e52a56eded3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/881d1689a42cc7a1fd63bde53c883e52a56eded3"}], "stats": {"total": 514, "additions": 257, "deletions": 257}, "files": [{"sha": "5ea083a693a353926ef3c012c551d0db778b8206", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -1,4 +1,4 @@\n-1c2e5fd66ea27d0c51360ba4e22099124a915562\n+fdf4c035225de52f596899931b1f6100e5e3e928\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "268feac59ddda3332aaa08c6b3ff28637d6d3203", "filename": "libsanitizer/asan/asan_allocator.cpp", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -908,13 +908,6 @@ AllocType AsanChunkView::GetAllocType() const {\n   return (AllocType)chunk_->alloc_type;\n }\n \n-static StackTrace GetStackTraceFromId(u32 id) {\n-  CHECK(id);\n-  StackTrace res = StackDepotGet(id);\n-  CHECK(res.trace);\n-  return res;\n-}\n-\n u32 AsanChunkView::GetAllocStackId() const {\n   u32 tid = 0;\n   u32 stack = 0;\n@@ -931,14 +924,6 @@ u32 AsanChunkView::GetFreeStackId() const {\n   return stack;\n }\n \n-StackTrace AsanChunkView::GetAllocStack() const {\n-  return GetStackTraceFromId(GetAllocStackId());\n-}\n-\n-StackTrace AsanChunkView::GetFreeStack() const {\n-  return GetStackTraceFromId(GetFreeStackId());\n-}\n-\n void InitializeAllocator(const AllocatorOptions &options) {\n   instance.InitLinkerInitialized(options);\n }"}, {"sha": "27d826fb613ae9f686804b0f8bddf420f8aa80d7", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -64,8 +64,6 @@ class AsanChunkView {\n   bool Eq(const AsanChunkView &c) const { return chunk_ == c.chunk_; }\n   u32 GetAllocStackId() const;\n   u32 GetFreeStackId() const;\n-  StackTrace GetAllocStack() const;\n-  StackTrace GetFreeStack() const;\n   AllocType GetAllocType() const;\n   bool AddrIsInside(uptr addr, uptr access_size, sptr *offset) const {\n     if (addr >= Beg() && (addr + access_size) <= End()) {"}, {"sha": "0b4bf52f2490a0a8401bf98fdf626d3229e4e580", "filename": "libsanitizer/asan/asan_debugging.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_debugging.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_debugging.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_debugging.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -19,6 +19,7 @@\n #include \"asan_mapping.h\"\n #include \"asan_report.h\"\n #include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n \n namespace {\n using namespace __asan;\n@@ -54,11 +55,11 @@ uptr AsanGetStack(uptr addr, uptr *trace, u32 size, u32 *thread_id,\n   StackTrace stack(nullptr, 0);\n   if (alloc_stack) {\n     if (chunk.AllocTid() == kInvalidTid) return 0;\n-    stack = chunk.GetAllocStack();\n+    stack = StackDepotGet(chunk.GetAllocStackId());\n     if (thread_id) *thread_id = chunk.AllocTid();\n   } else {\n     if (chunk.FreeTid() == kInvalidTid) return 0;\n-    stack = chunk.GetFreeStack();\n+    stack = StackDepotGet(chunk.GetFreeStackId());\n     if (thread_id) *thread_id = chunk.FreeTid();\n   }\n "}, {"sha": "9bf378f62071da89513da0cf9ddf4d00dbefb9d6", "filename": "libsanitizer/asan/asan_globals.cpp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_globals.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_globals.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -154,6 +154,23 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n   }\n }\n \n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n+  }\n+}\n+\n // Clang provides two different ways for global variables protection:\n // it can poison the global itself or its private alias. In former\n // case we may poison same symbol multiple times, that can help us to\n@@ -199,6 +216,8 @@ static void RegisterGlobal(const Global *g) {\n     // where two globals with the same name are defined in different modules.\n     if (UseODRIndicator(g))\n       CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);"}, {"sha": "047b044c8bf47da51e74436dc088b2740fd162dc", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -81,12 +81,7 @@ void InitializePlatformInterceptors();\n #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \\\n     !SANITIZER_NETBSD\n # define ASAN_INTERCEPT___CXA_THROW 1\n-# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \\\n-     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n-# else\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0\n-# endif\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))\n #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1\n # else"}, {"sha": "e5a7f2007aea8b8208e929e08ee675a55cd252eb", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -165,7 +165,7 @@ static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n static const u64 kRiscv64_ShadowOffset64 = 0xd55550000;\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n-static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kPPC64_ShadowOffset64 = 1ULL << 44;\n static const u64 kSystemZ_ShadowOffset64 = 1ULL << 52;\n static const u64 kSPARC64_ShadowOffset64 = 1ULL << 43;  // 0x80000000000\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000"}, {"sha": "9a715ea76fee75665ec0dad06d7ca8526ed1d9fa", "filename": "libsanitizer/asan/asan_stats.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_stats.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fasan%2Fasan_stats.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -124,9 +124,9 @@ static void PrintAccumulatedStats() {\n   // Use lock to keep reports from mixing up.\n   Lock lock(&print_lock);\n   stats.Print();\n-  StackDepotStats *stack_depot_stats = StackDepotGetStats();\n+  StackDepotStats stack_depot_stats = StackDepotGetStats();\n   Printf(\"Stats: StackDepot: %zd ids; %zdM allocated\\n\",\n-         stack_depot_stats->n_uniq_ids, stack_depot_stats->allocated >> 20);\n+         stack_depot_stats.n_uniq_ids, stack_depot_stats.allocated >> 20);\n   PrintInternalAllocatorStats();\n }\n "}, {"sha": "e8ffbbd6f48decb6d4695e45631d507ded12a9ac", "filename": "libsanitizer/hwasan/hwasan.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fhwasan%2Fhwasan.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fhwasan%2Fhwasan.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -141,7 +141,7 @@ static void CheckUnwind() {\n static void HwasanFormatMemoryUsage(InternalScopedString &s) {\n   HwasanThreadList &thread_list = hwasanThreadList();\n   auto thread_stats = thread_list.GetThreadStats();\n-  auto *sds = StackDepotGetStats();\n+  auto sds = StackDepotGetStats();\n   AllocatorStatCounters asc;\n   GetAllocatorStats(asc);\n   s.append(\n@@ -151,7 +151,7 @@ static void HwasanFormatMemoryUsage(InternalScopedString &s) {\n       internal_getpid(), GetRSS(), thread_stats.n_live_threads,\n       thread_stats.total_stack_size,\n       thread_stats.n_live_threads * thread_list.MemoryUsedPerThread(),\n-      sds->allocated, sds->n_uniq_ids, asc[AllocatorStatMapped]);\n+      sds.allocated, sds.n_uniq_ids, asc[AllocatorStatMapped]);\n }\n \n #if SANITIZER_ANDROID"}, {"sha": "7566c1ea0a57ec114b9af03465802f786238ea19", "filename": "libsanitizer/hwasan/hwasan_setjmp_x86_64.S", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fhwasan%2Fhwasan_setjmp_x86_64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fhwasan%2Fhwasan_setjmp_x86_64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_setjmp_x86_64.S?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -35,6 +35,7 @@\n ASM_TYPE_FUNCTION(__interceptor_setjmp)\n __interceptor_setjmp:\n   CFI_STARTPROC\n+  _CET_ENDBR\n   xorl %esi, %esi\n   jmp\t__interceptor_sigsetjmp\n   CFI_ENDPROC\n@@ -44,6 +45,7 @@ ASM_SIZE(__interceptor_setjmp)\n ASM_TYPE_FUNCTION(__interceptor_sigsetjmp)\n __interceptor_sigsetjmp:\n   CFI_STARTPROC\n+  _CET_ENDBR\n \n   // Save callee save registers.\n   mov %rbx, (0*8)(%rdi)"}, {"sha": "5f8fc5be4176f7fe0333d85cb072cc780af81ff5", "filename": "libsanitizer/lsan/lsan_common.cpp", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Flsan%2Flsan_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Flsan%2Flsan_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -79,7 +79,8 @@ class LeakSuppressionContext {\n                          int suppression_types_num)\n       : context(supprression_types, suppression_types_num) {}\n \n-  Suppression *GetSuppressionForStack(u32 stack_trace_id);\n+  Suppression *GetSuppressionForStack(u32 stack_trace_id,\n+                                      const StackTrace &stack);\n \n   const InternalMmapVector<u32> &GetSortedSuppressedStacks() {\n     if (!suppressed_stacks_sorted) {\n@@ -477,9 +478,7 @@ static void CollectIgnoredCb(uptr chunk, void *arg) {\n   }\n }\n \n-static uptr GetCallerPC(u32 stack_id, StackDepotReverseMap *map) {\n-  CHECK(stack_id);\n-  StackTrace stack = map->Get(stack_id);\n+static uptr GetCallerPC(const StackTrace &stack) {\n   // The top frame is our malloc/calloc/etc. The next frame is the caller.\n   if (stack.size >= 2)\n     return stack.trace[1];\n@@ -488,7 +487,7 @@ static uptr GetCallerPC(u32 stack_id, StackDepotReverseMap *map) {\n \n struct InvalidPCParam {\n   Frontier *frontier;\n-  StackDepotReverseMap *stack_depot_reverse_map;\n+  const StackDepotReverseMap *stack_depot;\n   bool skip_linker_allocations;\n };\n \n@@ -503,7 +502,7 @@ static void MarkInvalidPCCb(uptr chunk, void *arg) {\n     u32 stack_id = m.stack_trace_id();\n     uptr caller_pc = 0;\n     if (stack_id > 0)\n-      caller_pc = GetCallerPC(stack_id, param->stack_depot_reverse_map);\n+      caller_pc = GetCallerPC(param->stack_depot->Get(stack_id));\n     // If caller_pc is unknown, this chunk may be allocated in a coroutine. Mark\n     // it as reachable, as we can't properly report its allocation stack anyway.\n     if (caller_pc == 0 || (param->skip_linker_allocations &&\n@@ -534,18 +533,19 @@ static void MarkInvalidPCCb(uptr chunk, void *arg) {\n // which we don't care about).\n // On all other platforms, this simply checks to ensure that the caller pc is\n // valid before reporting chunks as leaked.\n-void ProcessPC(Frontier *frontier) {\n-  StackDepotReverseMap stack_depot_reverse_map;\n+static void ProcessPC(Frontier *frontier,\n+                      const StackDepotReverseMap &stack_depot) {\n   InvalidPCParam arg;\n   arg.frontier = frontier;\n-  arg.stack_depot_reverse_map = &stack_depot_reverse_map;\n+  arg.stack_depot = &stack_depot;\n   arg.skip_linker_allocations =\n       flags()->use_tls && flags()->use_ld_allocations && GetLinker() != nullptr;\n   ForEachChunk(MarkInvalidPCCb, &arg);\n }\n \n // Sets the appropriate tag on each chunk.\n static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads,\n+                              const StackDepotReverseMap &stack_depot,\n                               Frontier *frontier) {\n   const InternalMmapVector<u32> &suppressed_stacks =\n       GetSuppressionContext()->GetSortedSuppressedStacks();\n@@ -560,7 +560,7 @@ static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads,\n   FloodFillTag(frontier, kReachable);\n \n   CHECK_EQ(0, frontier->size());\n-  ProcessPC(frontier);\n+  ProcessPC(frontier, stack_depot);\n \n   // The check here is relatively expensive, so we do this in a separate flood\n   // fill. That way we can skip the check for chunks that are reachable\n@@ -584,11 +584,6 @@ static void ResetTagsCb(uptr chunk, void *arg) {\n     m.set_tag(kDirectlyLeaked);\n }\n \n-static void PrintStackTraceById(u32 stack_trace_id) {\n-  CHECK(stack_trace_id);\n-  StackDepotGet(stack_trace_id).Print();\n-}\n-\n // ForEachChunk callback. Aggregates information about unreachable chunks into\n // a LeakReport.\n static void CollectLeaksCb(uptr chunk, void *arg) {\n@@ -598,16 +593,7 @@ static void CollectLeaksCb(uptr chunk, void *arg) {\n   LsanMetadata m(chunk);\n   if (!m.allocated()) return;\n   if (m.tag() == kDirectlyLeaked || m.tag() == kIndirectlyLeaked) {\n-    u32 resolution = flags()->resolution;\n-    u32 stack_trace_id = 0;\n-    if (resolution > 0) {\n-      StackTrace stack = StackDepotGet(m.stack_trace_id());\n-      stack.size = Min(stack.size, resolution);\n-      stack_trace_id = StackDepotPut(stack);\n-    } else {\n-      stack_trace_id = m.stack_trace_id();\n-    }\n-    leak_report->AddLeakedChunk(chunk, stack_trace_id, m.requested_size(),\n+    leak_report->AddLeakedChunk(chunk, m.stack_trace_id(), m.requested_size(),\n                                 m.tag());\n   }\n }\n@@ -668,7 +654,8 @@ static void CheckForLeaksCallback(const SuspendedThreadsList &suspended_threads,\n   CHECK(param);\n   CHECK(!param->success);\n   ReportUnsuspendedThreads(suspended_threads);\n-  ClassifyAllChunks(suspended_threads, &param->frontier);\n+  ClassifyAllChunks(suspended_threads, param->leak_report.stack_depot(),\n+                    &param->frontier);\n   ForEachChunk(CollectLeaksCb, &param->leak_report);\n   // Clean up for subsequent leak checks. This assumes we did not overwrite any\n   // kIgnored tags.\n@@ -780,9 +767,8 @@ Suppression *LeakSuppressionContext::GetSuppressionForAddr(uptr addr) {\n }\n \n Suppression *LeakSuppressionContext::GetSuppressionForStack(\n-    u32 stack_trace_id) {\n+    u32 stack_trace_id, const StackTrace &stack) {\n   LazyInit();\n-  StackTrace stack = StackDepotGet(stack_trace_id);\n   for (uptr i = 0; i < stack.size; i++) {\n     Suppression *s = GetSuppressionForAddr(\n         StackTrace::GetPreviousInstructionPc(stack.trace[i]));\n@@ -807,6 +793,13 @@ const uptr kMaxLeaksConsidered = 5000;\n void LeakReport::AddLeakedChunk(uptr chunk, u32 stack_trace_id,\n                                 uptr leaked_size, ChunkTag tag) {\n   CHECK(tag == kDirectlyLeaked || tag == kIndirectlyLeaked);\n+\n+  if (u32 resolution = flags()->resolution) {\n+    StackTrace stack = stack_depot_.Get(stack_trace_id);\n+    stack.size = Min(stack.size, resolution);\n+    stack_trace_id = StackDepotPut(stack);\n+  }\n+\n   bool is_directly_leaked = (tag == kDirectlyLeaked);\n   uptr i;\n   for (i = 0; i < leaks_.size(); i++) {\n@@ -869,7 +862,8 @@ void LeakReport::PrintReportForLeak(uptr index) {\n          leaks_[index].total_size, leaks_[index].hit_count);\n   Printf(\"%s\", d.Default());\n \n-  PrintStackTraceById(leaks_[index].stack_trace_id);\n+  CHECK(leaks_[index].stack_trace_id);\n+  stack_depot_.Get(leaks_[index].stack_trace_id).Print();\n \n   if (flags()->report_objects) {\n     Printf(\"Objects leaked above:\\n\");\n@@ -905,8 +899,8 @@ uptr LeakReport::ApplySuppressions() {\n   LeakSuppressionContext *suppressions = GetSuppressionContext();\n   uptr new_suppressions = false;\n   for (uptr i = 0; i < leaks_.size(); i++) {\n-    Suppression *s =\n-        suppressions->GetSuppressionForStack(leaks_[i].stack_trace_id);\n+    Suppression *s = suppressions->GetSuppressionForStack(\n+        leaks_[i].stack_trace_id, stack_depot_.Get(leaks_[i].stack_trace_id));\n     if (s) {\n       s->weight += leaks_[i].total_size;\n       atomic_store_relaxed(&s->hit_count, atomic_load_relaxed(&s->hit_count) +"}, {"sha": "c15df1bfa7111ece265af31cca30c5bd525b2348", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -18,6 +18,7 @@\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_platform.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_stoptheworld.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n \n@@ -107,12 +108,14 @@ class LeakReport {\n   uptr ApplySuppressions();\n   uptr UnsuppressedLeakCount();\n   uptr IndirectUnsuppressedLeakCount();\n+  const StackDepotReverseMap &stack_depot() { return stack_depot_; }\n \n  private:\n   void PrintReportForLeak(uptr index);\n   void PrintLeakedObjectsForLeak(uptr index);\n \n   u32 next_id_ = 0;\n+  StackDepotReverseMap stack_depot_;\n   InternalMmapVector<Leak> leaks_;\n   InternalMmapVector<LeakedObject> leaked_objects_;\n };"}, {"sha": "6b861203ac2d1da46e9db9c5d2d3e277930537a6", "filename": "libsanitizer/sanitizer_common/sanitizer_asm.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -66,3 +66,7 @@\n #else\n #define NO_EXEC_STACK_DIRECTIVE\n #endif\n+\n+#if defined(__x86_64__) || defined(__i386__)\n+#include <cet.h>\n+#endif"}, {"sha": "7fe9cd78d1d98f85c6b8fd57cf6af94552e6ab21", "filename": "libsanitizer/sanitizer_common/sanitizer_chained_origin_depot.cpp", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -14,7 +14,7 @@\n namespace __sanitizer {\n \n bool ChainedOriginDepot::ChainedOriginDepotNode::eq(\n-    u32 hash, const args_type &args) const {\n+    hash_type hash, const args_type &args) const {\n   return here_id == args.here_id && prev_id == args.prev_id;\n }\n \n@@ -36,7 +36,8 @@ uptr ChainedOriginDepot::ChainedOriginDepotNode::storage_size(\n    split, or one of two reserved values (-1) or (-2). Either case can\n    dominate depending on the workload.\n */\n-u32 ChainedOriginDepot::ChainedOriginDepotNode::hash(const args_type &args) {\n+ChainedOriginDepot::ChainedOriginDepotNode::hash_type\n+ChainedOriginDepot::ChainedOriginDepotNode::hash(const args_type &args) {\n   const u32 m = 0x5bd1e995;\n   const u32 seed = 0x9747b28c;\n   const u32 r = 24;\n@@ -67,7 +68,7 @@ bool ChainedOriginDepot::ChainedOriginDepotNode::is_valid(\n }\n \n void ChainedOriginDepot::ChainedOriginDepotNode::store(const args_type &args,\n-                                                       u32 other_hash) {\n+                                                       hash_type other_hash) {\n   here_id = args.here_id;\n   prev_id = args.prev_id;\n }\n@@ -85,7 +86,9 @@ ChainedOriginDepot::ChainedOriginDepotNode::get_handle() {\n \n ChainedOriginDepot::ChainedOriginDepot() {}\n \n-StackDepotStats *ChainedOriginDepot::GetStats() { return depot.GetStats(); }\n+StackDepotStats ChainedOriginDepot::GetStats() const {\n+  return depot.GetStats();\n+}\n \n bool ChainedOriginDepot::Put(u32 here_id, u32 prev_id, u32 *new_id) {\n   ChainedOriginDepotDesc desc = {here_id, prev_id};"}, {"sha": "73a10e114f9b5b47906b2f1273897e6777d45a5c", "filename": "libsanitizer/sanitizer_common/sanitizer_chained_origin_depot.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -22,7 +22,7 @@ class ChainedOriginDepot {\n   ChainedOriginDepot();\n \n   // Gets the statistic of the origin chain storage.\n-  StackDepotStats *GetStats();\n+  StackDepotStats GetStats() const;\n \n   // Stores a chain with StackDepot ID here_id and previous chain ID prev_id.\n   // If successful, returns true and the new chain id new_id.\n@@ -43,22 +43,23 @@ class ChainedOriginDepot {\n   };\n \n   struct ChainedOriginDepotNode {\n+    using hash_type = u32;\n     ChainedOriginDepotNode *link;\n     u32 id;\n     u32 here_id;\n     u32 prev_id;\n \n     typedef ChainedOriginDepotDesc args_type;\n \n-    bool eq(u32 hash, const args_type &args) const;\n+    bool eq(hash_type hash, const args_type &args) const;\n \n     static uptr storage_size(const args_type &args);\n \n-    static u32 hash(const args_type &args);\n+    static hash_type hash(const args_type &args);\n \n     static bool is_valid(const args_type &args);\n \n-    void store(const args_type &args, u32 other_hash);\n+    void store(const args_type &args, hash_type other_hash);\n \n     args_type load() const;\n "}, {"sha": "f60b05d157bba455eeffcbb7176b3862502effdf", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_vfork_i386.inc.S", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_i386.inc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_i386.inc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_i386.inc.S?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -6,6 +6,7 @@\n .globl ASM_WRAPPER_NAME(vfork)\n ASM_TYPE_FUNCTION(ASM_WRAPPER_NAME(vfork))\n ASM_WRAPPER_NAME(vfork):\n+        _CET_ENDBR\n         // Store return address in the spill area and tear down the stack frame.\n         sub     $12, %esp\n         call    COMMON_INTERCEPTOR_SPILL_AREA"}, {"sha": "8fd18ea67ffd2b6e912980c667c80f3df0222338", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_vfork_x86_64.inc.S", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_x86_64.inc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_x86_64.inc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_x86_64.inc.S?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -6,6 +6,7 @@\n .globl ASM_WRAPPER_NAME(vfork)\n ASM_TYPE_FUNCTION(ASM_WRAPPER_NAME(vfork))\n ASM_WRAPPER_NAME(vfork):\n+        _CET_ENDBR\n         // Store return address in the spill area and tear down the stack frame.\n         push    %rcx\n         call    COMMON_INTERCEPTOR_SPILL_AREA"}, {"sha": "bc4b477e350ff11cdd747494ee4a35663e8bbe4d", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cpp", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -26,9 +26,7 @@ void SetSoftRssLimitExceededCallback(void (*Callback)(bool exceeded)) {\n \n #if (SANITIZER_LINUX || SANITIZER_NETBSD) && !SANITIZER_GO\n // Weak default implementation for when sanitizer_stackdepot is not linked in.\n-SANITIZER_WEAK_ATTRIBUTE StackDepotStats *StackDepotGetStats() {\n-  return nullptr;\n-}\n+SANITIZER_WEAK_ATTRIBUTE StackDepotStats StackDepotGetStats() { return {}; }\n \n void *BackgroundThread(void *arg) {\n   const uptr hard_rss_limit_mb = common_flags()->hard_rss_limit_mb;\n@@ -48,16 +46,12 @@ void *BackgroundThread(void *arg) {\n         prev_reported_rss = current_rss_mb;\n       }\n       // If stack depot has grown 10% since last time, print it too.\n-      StackDepotStats *stack_depot_stats = StackDepotGetStats();\n-      if (stack_depot_stats) {\n-        if (prev_reported_stack_depot_size * 11 / 10 <\n-            stack_depot_stats->allocated) {\n-          Printf(\"%s: StackDepot: %zd ids; %zdM allocated\\n\",\n-                 SanitizerToolName,\n-                 stack_depot_stats->n_uniq_ids,\n-                 stack_depot_stats->allocated >> 20);\n-          prev_reported_stack_depot_size = stack_depot_stats->allocated;\n-        }\n+      StackDepotStats stack_depot_stats = StackDepotGetStats();\n+      if (prev_reported_stack_depot_size * 11 / 10 <\n+          stack_depot_stats.allocated) {\n+        Printf(\"%s: StackDepot: %zd ids; %zdM allocated\\n\", SanitizerToolName,\n+               stack_depot_stats.n_uniq_ids, stack_depot_stats.allocated >> 20);\n+        prev_reported_stack_depot_size = stack_depot_stats.allocated;\n       }\n     }\n     // Check RSS against the limit."}, {"sha": "f7cf9f234e6fc680b6411bb9c3f63f48bca971ea", "filename": "libsanitizer/sanitizer_common/sanitizer_hash.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_hash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_hash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_hash.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -38,6 +38,30 @@ class MurMur2HashBuilder {\n     return x;\n   }\n };\n+\n+class MurMur2Hash64Builder {\n+  static const u64 m = 0xc6a4a7935bd1e995ull;\n+  static const u64 seed = 0x9747b28c9747b28cull;\n+  static const u64 r = 47;\n+  u64 h;\n+\n+ public:\n+  explicit MurMur2Hash64Builder(u64 init = 0) { h = seed ^ (init * m); }\n+  void add(u64 k) {\n+    k *= m;\n+    k ^= k >> r;\n+    k *= m;\n+    h ^= k;\n+    h *= m;\n+  }\n+  u64 get() {\n+    u64 x = h;\n+    x ^= x >> r;\n+    x *= m;\n+    x ^= x >> r;\n+    return x;\n+  }\n+};\n }  //namespace __sanitizer\n \n #endif  // SANITIZER_HASH_H"}, {"sha": "7ce9e25da342d8d70312d956a68b137f29326eb8", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -759,13 +759,9 @@ u32 GetNumberOfCPUs() {\n #elif SANITIZER_SOLARIS\n   return sysconf(_SC_NPROCESSORS_ONLN);\n #else\n-#if defined(CPU_COUNT)\n   cpu_set_t CPUs;\n   CHECK_EQ(sched_getaffinity(0, sizeof(cpu_set_t), &CPUs), 0);\n   return CPU_COUNT(&CPUs);\n-#else\n-  return 1;\n-#endif\n #endif\n }\n "}, {"sha": "b8839f197d2c1fb89f032258692ea399a6421d5f", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cpp", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -37,7 +37,7 @@\n extern char **environ;\n #endif\n \n-#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n+#if defined(__has_include) && __has_include(<os/trace.h>)\n #define SANITIZER_OS_TRACE 1\n #include <os/trace.h>\n #else\n@@ -70,15 +70,7 @@ extern \"C\" {\n #include <mach/mach_time.h>\n #include <mach/vm_statistics.h>\n #include <malloc/malloc.h>\n-#if defined(__has_builtin) && __has_builtin(__builtin_os_log_format)\n-# include <os/log.h>\n-#else\n-   /* Without support for __builtin_os_log_format, fall back to the older\n-      method.  */\n-# define OS_LOG_DEFAULT 0\n-# define os_log_error(A,B,C) \\\n-  asl_log(nullptr, nullptr, ASL_LEVEL_ERR, \"%s\", (C));\n-#endif\n+#include <os/log.h>\n #include <pthread.h>\n #include <sched.h>\n #include <signal.h>"}, {"sha": "0b6af5a3c0edc649c4d65dfd1a6ca1bce13aa9b9", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -14,26 +14,6 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_platform.h\"\n-\n-/* TARGET_OS_OSX is not present in SDKs before Darwin16 (macOS 10.12) use\n-   TARGET_OS_MAC (we have no support for iOS in any form for these versions,\n-   so there's no ambiguity).  */\n-#if !defined(TARGET_OS_OSX) && TARGET_OS_MAC\n-# define TARGET_OS_OSX 1\n-#endif\n-\n-/* Other TARGET_OS_xxx are not present on earlier versions, define them to\n-   0 (we have no support for them; they are not valid targets anyway).  */\n-#ifndef TARGET_OS_IOS\n-#define TARGET_OS_IOS 0\n-#endif\n-#ifndef TARGET_OS_TV\n-#define TARGET_OS_TV 0\n-#endif\n-#ifndef TARGET_OS_WATCH\n-#define TARGET_OS_WATCH 0\n-#endif\n-\n #if SANITIZER_MAC\n #include \"sanitizer_posix.h\"\n "}, {"sha": "4e6efcad44d119cb2a0a40d21d725eca080ed6c3", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -548,10 +548,10 @@\n #define SANITIZER_INTERCEPT_SHA1 SI_NETBSD\n #define SANITIZER_INTERCEPT_MD4 SI_NETBSD\n #define SANITIZER_INTERCEPT_RMD160 SI_NETBSD\n-#define SANITIZER_INTERCEPT_MD5 SI_NETBSD\n+#define SANITIZER_INTERCEPT_MD5 (SI_NETBSD || SI_FREEBSD)\n #define SANITIZER_INTERCEPT_FSEEK (SI_NETBSD || SI_FREEBSD)\n #define SANITIZER_INTERCEPT_MD2 SI_NETBSD\n-#define SANITIZER_INTERCEPT_SHA2 SI_NETBSD\n+#define SANITIZER_INTERCEPT_SHA2 (SI_NETBSD || SI_FREEBSD)\n #define SANITIZER_INTERCEPT_CDB SI_NETBSD\n #define SANITIZER_INTERCEPT_VIS (SI_NETBSD || SI_FREEBSD)\n #define SANITIZER_INTERCEPT_POPEN SI_POSIX"}, {"sha": "64535805e40d88579940063fc830a002851b367d", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_freebsd.cpp", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -69,6 +69,11 @@\n #include <semaphore.h>\n #include <signal.h>\n #include <stddef.h>\n+#include <md5.h>\n+#include <sha224.h>\n+#include <sha256.h>\n+#include <sha384.h>\n+#include <sha512.h>\n #include <stdio.h>\n #include <stringlist.h>\n #include <term.h>\n@@ -361,6 +366,22 @@ const int si_SEGV_MAPERR = SEGV_MAPERR;\n const int si_SEGV_ACCERR = SEGV_ACCERR;\n const int unvis_valid = UNVIS_VALID;\n const int unvis_validpush = UNVIS_VALIDPUSH;\n+\n+const unsigned MD5_CTX_sz = sizeof(MD5_CTX);\n+const unsigned MD5_return_length = MD5_DIGEST_STRING_LENGTH;\n+\n+#define SHA2_CONST(LEN)                                                      \\\n+  const unsigned SHA##LEN##_CTX_sz = sizeof(SHA##LEN##_CTX);                 \\\n+  const unsigned SHA##LEN##_return_length = SHA##LEN##_DIGEST_STRING_LENGTH; \\\n+  const unsigned SHA##LEN##_block_length = SHA##LEN##_BLOCK_LENGTH;          \\\n+  const unsigned SHA##LEN##_digest_length = SHA##LEN##_DIGEST_LENGTH\n+\n+SHA2_CONST(224);\n+SHA2_CONST(256);\n+SHA2_CONST(384);\n+SHA2_CONST(512);\n+\n+#undef SHA2_CONST\n }  // namespace __sanitizer\n \n using namespace __sanitizer;"}, {"sha": "649e64fd1a32b9bbcc203bd79963030ec9dddf84", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_freebsd.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -647,6 +647,22 @@ extern unsigned IOCTL_KDSKBMODE;\n extern const int si_SEGV_MAPERR;\n extern const int si_SEGV_ACCERR;\n \n+extern const unsigned MD5_CTX_sz;\n+extern const unsigned MD5_return_length;\n+\n+#define SHA2_EXTERN(LEN)                          \\\n+  extern const unsigned SHA##LEN##_CTX_sz;        \\\n+  extern const unsigned SHA##LEN##_return_length; \\\n+  extern const unsigned SHA##LEN##_block_length;  \\\n+  extern const unsigned SHA##LEN##_digest_length\n+\n+SHA2_EXTERN(224);\n+SHA2_EXTERN(256);\n+SHA2_EXTERN(384);\n+SHA2_EXTERN(512);\n+\n+#undef SHA2_EXTERN\n+\n struct __sanitizer_cap_rights {\n   u64 cr_rights[2];\n };"}, {"sha": "9d577570ea1e2e219b4a08c64f450794d6a145d7", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cpp", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -26,10 +26,7 @@\n \n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n-// fine with newer headers, too.  Beware that with <sys/stat.h>, struct stat\n-// takes the form of struct stat64 on 32-bit platforms if _FILE_OFFSET_BITS=64.\n-// Also, for some platforms (e.g. mips) there are additional members in the\n-// <sys/stat.h> struct stat:s.\n+// fine with newer headers, too.\n #include <linux/posix_types.h>\n #  if defined(__x86_64__) || defined(__mips__) || defined(__hexagon__)\n #    include <sys/stat.h>"}, {"sha": "d69b344dd613d6e2f25c39d839cbf5a899ddf81d", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -83,7 +83,7 @@ const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__mips__)\n const unsigned struct_kernel_stat_sz = SANITIZER_ANDROID\n                                            ? FIRST_32_SECOND_64(104, 128)\n-                                           : FIRST_32_SECOND_64(144, 216);\n+                                           : FIRST_32_SECOND_64(160, 216);\n const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__s390__) && !defined(__s390x__)\n const unsigned struct_kernel_stat_sz = 64;"}, {"sha": "fc2ea2fc768fe5d640a7dc03c2fd5cfa2003e366", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cpp", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -19,26 +19,24 @@\n namespace __sanitizer {\n \n struct StackDepotNode {\n+  using hash_type = u32;\n   StackDepotNode *link;\n   u32 id;\n-  atomic_uint32_t hash_and_use_count; // hash_bits : 12; use_count : 20;\n+  hash_type stack_hash;\n   u32 size;\n-  u32 tag;\n+  atomic_uint32_t tag_and_use_count;  // tag : 12 high bits; use_count : 20;\n   uptr stack[1];  // [size]\n \n   static const u32 kTabSizeLog = SANITIZER_ANDROID ? 16 : 20;\n-  // Lower kTabSizeLog bits are equal for all items in one bucket.\n-  // We use these bits to store the per-stack use counter.\n-  static const u32 kUseCountBits = kTabSizeLog;\n+  static const u32 kUseCountBits = 20;\n   static const u32 kMaxUseCount = 1 << kUseCountBits;\n   static const u32 kUseCountMask = (1 << kUseCountBits) - 1;\n-  static const u32 kHashMask = ~kUseCountMask;\n \n   typedef StackTrace args_type;\n-  bool eq(u32 hash, const args_type &args) const {\n-    u32 hash_bits =\n-        atomic_load(&hash_and_use_count, memory_order_relaxed) & kHashMask;\n-    if ((hash & kHashMask) != hash_bits || args.size != size || args.tag != tag)\n+  bool eq(hash_type hash, const args_type &args) const {\n+    u32 tag =\n+        atomic_load(&tag_and_use_count, memory_order_relaxed) >> kUseCountBits;\n+    if (stack_hash != hash || args.size != size || args.tag != tag)\n       return false;\n     uptr i = 0;\n     for (; i < size; i++) {\n@@ -49,38 +47,42 @@ struct StackDepotNode {\n   static uptr storage_size(const args_type &args) {\n     return sizeof(StackDepotNode) + (args.size - 1) * sizeof(uptr);\n   }\n-  static u32 hash(const args_type &args) {\n+  static hash_type hash(const args_type &args) {\n     MurMur2HashBuilder H(args.size * sizeof(uptr));\n     for (uptr i = 0; i < args.size; i++) H.add(args.trace[i]);\n     return H.get();\n   }\n   static bool is_valid(const args_type &args) {\n     return args.size > 0 && args.trace;\n   }\n-  void store(const args_type &args, u32 hash) {\n-    atomic_store(&hash_and_use_count, hash & kHashMask, memory_order_relaxed);\n+  void store(const args_type &args, hash_type hash) {\n+    CHECK_EQ(args.tag & (~kUseCountMask >> kUseCountBits), args.tag);\n+    atomic_store(&tag_and_use_count, args.tag << kUseCountBits,\n+                 memory_order_relaxed);\n+    stack_hash = hash;\n     size = args.size;\n-    tag = args.tag;\n     internal_memcpy(stack, args.trace, size * sizeof(uptr));\n   }\n   args_type load() const {\n+    u32 tag =\n+        atomic_load(&tag_and_use_count, memory_order_relaxed) >> kUseCountBits;\n     return args_type(&stack[0], size, tag);\n   }\n   StackDepotHandle get_handle() { return StackDepotHandle(this); }\n \n   typedef StackDepotHandle handle_type;\n };\n \n-COMPILER_CHECK(StackDepotNode::kMaxUseCount == (u32)kStackDepotMaxUseCount);\n+COMPILER_CHECK(StackDepotNode::kMaxUseCount >= (u32)kStackDepotMaxUseCount);\n \n u32 StackDepotHandle::id() { return node_->id; }\n int StackDepotHandle::use_count() {\n-  return atomic_load(&node_->hash_and_use_count, memory_order_relaxed) &\n+  return atomic_load(&node_->tag_and_use_count, memory_order_relaxed) &\n          StackDepotNode::kUseCountMask;\n }\n void StackDepotHandle::inc_use_count_unsafe() {\n   u32 prev =\n-      atomic_fetch_add(&node_->hash_and_use_count, 1, memory_order_relaxed) &\n+      atomic_fetch_add(&node_->tag_and_use_count, 1, memory_order_relaxed) &\n       StackDepotNode::kUseCountMask;\n   CHECK_LT(prev + 1, StackDepotNode::kMaxUseCount);\n }\n@@ -90,9 +92,7 @@ typedef StackDepotBase<StackDepotNode, 1, StackDepotNode::kTabSizeLog>\n     StackDepot;\n static StackDepot theDepot;\n \n-StackDepotStats *StackDepotGetStats() {\n-  return theDepot.GetStats();\n-}\n+StackDepotStats StackDepotGetStats() { return theDepot.GetStats(); }\n \n u32 StackDepotPut(StackTrace stack) {\n   StackDepotHandle h = theDepot.Put(stack);\n@@ -127,8 +127,10 @@ bool StackDepotReverseMap::IdDescPair::IdComparator(\n   return a.id < b.id;\n }\n \n-StackDepotReverseMap::StackDepotReverseMap() {\n-  map_.reserve(StackDepotGetStats()->n_uniq_ids + 100);\n+void StackDepotReverseMap::Init() const {\n+  if (LIKELY(map_.capacity()))\n+    return;\n+  map_.reserve(StackDepotGetStats().n_uniq_ids + 100);\n   for (int idx = 0; idx < StackDepot::kTabSize; idx++) {\n     atomic_uintptr_t *p = &theDepot.tab[idx];\n     uptr v = atomic_load(p, memory_order_consume);\n@@ -141,7 +143,8 @@ StackDepotReverseMap::StackDepotReverseMap() {\n   Sort(map_.data(), map_.size(), &IdDescPair::IdComparator);\n }\n \n-StackTrace StackDepotReverseMap::Get(u32 id) {\n+StackTrace StackDepotReverseMap::Get(u32 id) const {\n+  Init();\n   if (!map_.size())\n     return StackTrace();\n   IdDescPair pair = {id, nullptr};"}, {"sha": "6f79fffeea8a4de617beaa765d9e08bb69bda35f", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -33,7 +33,7 @@ struct StackDepotHandle {\n \n const int kStackDepotMaxUseCount = 1U << (SANITIZER_ANDROID ? 16 : 20);\n \n-StackDepotStats *StackDepotGetStats();\n+StackDepotStats StackDepotGetStats();\n u32 StackDepotPut(StackTrace stack);\n StackDepotHandle StackDepotPut_WithHandle(StackTrace stack);\n // Retrieves a stored stack trace by the id.\n@@ -49,8 +49,8 @@ void StackDepotPrintAll();\n // which were stored before it was instantiated.\n class StackDepotReverseMap {\n  public:\n-  StackDepotReverseMap();\n-  StackTrace Get(u32 id);\n+  StackDepotReverseMap() = default;\n+  StackTrace Get(u32 id) const;\n \n  private:\n   struct IdDescPair {\n@@ -60,7 +60,9 @@ class StackDepotReverseMap {\n     static bool IdComparator(const IdDescPair &a, const IdDescPair &b);\n   };\n \n-  InternalMmapVector<IdDescPair> map_;\n+  void Init() const;\n+\n+  mutable InternalMmapVector<IdDescPair> map_;\n \n   // Disallow evil constructors.\n   StackDepotReverseMap(const StackDepotReverseMap&);"}, {"sha": "435f634cd11f6e6dbf382f1f5c49f480f454cc29", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepotbase.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -27,19 +27,20 @@ class StackDepotBase {\n  public:\n   typedef typename Node::args_type args_type;\n   typedef typename Node::handle_type handle_type;\n+  typedef typename Node::hash_type hash_type;\n   // Maps stack trace to an unique id.\n   handle_type Put(args_type args, bool *inserted = nullptr);\n   // Retrieves a stored stack trace by the id.\n   args_type Get(u32 id);\n \n-  StackDepotStats *GetStats() { return &stats; }\n+  StackDepotStats GetStats() const { return stats; }\n \n   void LockAll();\n   void UnlockAll();\n   void PrintAll();\n \n  private:\n-  static Node *find(Node *s, args_type args, u32 hash);\n+  static Node *find(Node *s, args_type args, hash_type hash);\n   static Node *lock(atomic_uintptr_t *p);\n   static void unlock(atomic_uintptr_t *p, Node *s);\n \n@@ -62,7 +63,7 @@ class StackDepotBase {\n template <class Node, int kReservedBits, int kTabSizeLog>\n Node *StackDepotBase<Node, kReservedBits, kTabSizeLog>::find(Node *s,\n                                                              args_type args,\n-                                                             u32 hash) {\n+                                                             hash_type hash) {\n   // Searches linked list s for the stack, returns its id.\n   for (; s; s = s->link) {\n     if (s->eq(hash, args)) {\n@@ -101,7 +102,7 @@ StackDepotBase<Node, kReservedBits, kTabSizeLog>::Put(args_type args,\n                                                       bool *inserted) {\n   if (inserted) *inserted = false;\n   if (!Node::is_valid(args)) return handle_type();\n-  uptr h = Node::hash(args);\n+  hash_type h = Node::hash(args);\n   atomic_uintptr_t *p = &tab[h % kTabSize];\n   uptr v = atomic_load(p, memory_order_consume);\n   Node *s = (Node *)(v & ~1);"}, {"sha": "4707c6c5d00b3da3198114594d42d383e6e7317b", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cpp", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -86,8 +86,8 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   // Nope, this does not look right either. This means the frame after next does\n   // not have a valid frame pointer, but we can still extract the caller PC.\n   // Unfortunately, there is no way to decide between GCC and LLVM frame\n-  // layouts. Assume GCC.\n-  return bp_prev - 1;\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n@@ -110,21 +110,14 @@ void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n #ifdef __powerpc__\n-    // PowerPC ABIs specify that the return address is saved on the\n-    // *caller's* stack frame.  Thus we must dereference the back chain\n-    // to find the caller frame before extracting it.\n+    // PowerPC ABIs specify that the return address is saved at offset\n+    // 16 of the *caller's* stack frame.  Thus we must dereference the\n+    // back chain to find the caller frame before extracting it.\n     uhwptr *caller_frame = (uhwptr*)frame[0];\n     if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||\n         !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n-    // For most ABIs the offset where the return address is saved is two\n-    // register sizes.  The exception is the SVR4 ABI, which uses an\n-    // offset of only one register size.\n-#ifdef _CALL_SYSV\n-    uhwptr pc1 = caller_frame[1];\n-#else\n     uhwptr pc1 = caller_frame[2];\n-#endif\n #elif defined(__s390__)\n     uhwptr pc1 = frame[14];\n #elif defined(__riscv)"}, {"sha": "89b2f990d036f2605fe2607f2bda82db43fb8a44", "filename": "libsanitizer/tsan/tsan_interceptors.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -32,16 +32,14 @@ LibIgnore *libignore();\n \n #if !SANITIZER_GO\n inline bool in_symbolizer() {\n-  cur_thread_init();\n-  return UNLIKELY(cur_thread()->in_symbolizer);\n+  return UNLIKELY(cur_thread_init()->in_symbolizer);\n }\n #endif\n \n }  // namespace __tsan\n \n #define SCOPED_INTERCEPTOR_RAW(func, ...)      \\\n-  cur_thread_init();                           \\\n-  ThreadState *thr = cur_thread();             \\\n+  ThreadState *thr = cur_thread_init();        \\\n   const uptr caller_pc = GET_CALLER_PC();      \\\n   ScopedInterceptor si(thr, #func, caller_pc); \\\n   const uptr pc = GET_CURRENT_PC();            \\"}, {"sha": "617eda65031752fe44c20a0f93f2d3be51d15af2", "filename": "libsanitizer/tsan/tsan_interceptors_posix.cpp", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -153,7 +153,7 @@ const int SIG_SETMASK = 2;\n #endif\n \n #define COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED \\\n-  (cur_thread_init(), !cur_thread()->is_inited)\n+  (!cur_thread_init()->is_inited)\n \n namespace __tsan {\n struct SignalDesc {\n@@ -531,10 +531,7 @@ static void LongJmp(ThreadState *thr, uptr *env) {\n }\n \n // FIXME: put everything below into a common extern \"C\" block?\n-extern \"C\" void __tsan_setjmp(uptr sp) {\n-  cur_thread_init();\n-  SetJmp(cur_thread(), sp);\n-}\n+extern \"C\" void __tsan_setjmp(uptr sp) { SetJmp(cur_thread_init(), sp); }\n \n #if SANITIZER_MAC\n TSAN_INTERCEPTOR(int, setjmp, void *env);\n@@ -973,8 +970,7 @@ extern \"C\" void *__tsan_thread_start_func(void *arg) {\n   void* (*callback)(void *arg) = p->callback;\n   void *param = p->param;\n   {\n-    cur_thread_init();\n-    ThreadState *thr = cur_thread();\n+    ThreadState *thr = cur_thread_init();\n     // Thread-local state is not initialized yet.\n     ScopedIgnoreInterceptors ignore;\n #if !SANITIZER_MAC && !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n@@ -2061,8 +2057,7 @@ static bool is_sync_signal(ThreadSignalContext *sctx, int sig) {\n }\n \n void sighandler(int sig, __sanitizer_siginfo *info, void *ctx) {\n-  cur_thread_init();\n-  ThreadState *thr = cur_thread();\n+  ThreadState *thr = cur_thread_init();\n   ThreadSignalContext *sctx = SigCtx(thr);\n   if (sig < 0 || sig >= kSigCount) {\n     VPrintf(1, \"ThreadSanitizer: ignoring signal %d\\n\", sig);"}, {"sha": "048715185151c450ecde042107166d442661ee0e", "filename": "libsanitizer/tsan/tsan_interface.cpp", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_interface.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_interface.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -20,10 +20,7 @@\n \n using namespace __tsan;\n \n-void __tsan_init() {\n-  cur_thread_init();\n-  Initialize(cur_thread());\n-}\n+void __tsan_init() { Initialize(cur_thread_init()); }\n \n void __tsan_flush_memory() {\n   FlushShadowMemory();"}, {"sha": "2fb753dd080c8116fa5c16afa5998558ea9d78ec", "filename": "libsanitizer/tsan/tsan_platform_linux.cpp", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -124,13 +124,13 @@ void WriteMemoryProfile(char *buf, uptr buf_size, u64 uptime_ns) {\n   internal_memset(mem, 0, sizeof(mem));\n   GetMemoryProfile(FillProfileCallback, mem, MemCount);\n   auto meta = ctx->metamap.GetMemoryStats();\n-  StackDepotStats *stacks = StackDepotGetStats();\n+  StackDepotStats stacks = StackDepotGetStats();\n   uptr nthread, nlive;\n   ctx->thread_registry.GetNumberOfThreads(&nthread, &nlive);\n   uptr internal_stats[AllocatorStatCount];\n   internal_allocator()->GetStats(internal_stats);\n   // All these are allocated from the common mmap region.\n-  mem[MemMmap] -= meta.mem_block + meta.sync_obj + stacks->allocated +\n+  mem[MemMmap] -= meta.mem_block + meta.sync_obj + stacks.allocated +\n                   internal_stats[AllocatorStatMapped];\n   if (s64(mem[MemMmap]) < 0)\n     mem[MemMmap] = 0;\n@@ -143,8 +143,8 @@ void WriteMemoryProfile(char *buf, uptr buf_size, u64 uptime_ns) {\n       mem[MemShadow] >> 20, mem[MemMeta] >> 20, mem[MemFile] >> 20,\n       mem[MemMmap] >> 20, mem[MemTrace] >> 20, mem[MemHeap] >> 20,\n       mem[MemOther] >> 20, internal_stats[AllocatorStatMapped] >> 20,\n-      meta.mem_block >> 20, meta.sync_obj >> 20, stacks->allocated >> 20,\n-      stacks->n_uniq_ids, nlive, nthread);\n+      meta.mem_block >> 20, meta.sync_obj >> 20, stacks.allocated >> 20,\n+      stacks.n_uniq_ids, nlive, nthread);\n }\n \n #  if SANITIZER_LINUX\n@@ -456,12 +456,14 @@ static void InitializeLongjmpXorKey() {\n extern \"C\" void __tsan_tls_initialization() {}\n \n void ImitateTlsWrite(ThreadState *thr, uptr tls_addr, uptr tls_size) {\n+  // Check that the thr object is in tls;\n   const uptr thr_beg = (uptr)thr;\n   const uptr thr_end = (uptr)thr + sizeof(*thr);\n-  // ThreadState is normally allocated in TLS and is large,\n-  // so we skip it. But unit tests allocate ThreadState outside of TLS.\n-  if (thr_beg < tls_addr || thr_end >= tls_addr + tls_size)\n-    return;\n+  CHECK_GE(thr_beg, tls_addr);\n+  CHECK_LE(thr_beg, tls_addr + tls_size);\n+  CHECK_GE(thr_end, tls_addr);\n+  CHECK_LE(thr_end, tls_addr + tls_size);\n+  // Since the thr object is huge, skip it.\n   const uptr pc = StackTrace::GetNextInstructionPc(\n       reinterpret_cast<uptr>(__tsan_tls_initialization));\n   MemoryRangeImitateWrite(thr, pc, tls_addr, thr_beg - tls_addr);"}, {"sha": "388b3836d7d14d6964714ff436c3fc559cd3ac29", "filename": "libsanitizer/tsan/tsan_platform_mac.cpp", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -159,35 +159,35 @@ void WriteMemoryProfile(char *buf, uptr buf_size, u64 uptime_ns) {\n   RegionMemUsage(LoAppMemBeg(), LoAppMemEnd(), &app_res, &app_dirty);\n #endif\n \n-  StackDepotStats *stacks = StackDepotGetStats();\n+  StackDepotStats stacks = StackDepotGetStats();\n   uptr nthread, nlive;\n   ctx->thread_registry.GetNumberOfThreads(&nthread, &nlive);\n-  internal_snprintf(buf, buf_size,\n-    \"shadow   (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n-    \"meta     (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n-    \"traces   (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n-#if !SANITIZER_GO\n-    \"low app  (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n-    \"high app (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n-    \"heap     (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n-#else  // !SANITIZER_GO\n+  internal_snprintf(\n+      buf, buf_size,\n+      \"shadow   (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n+      \"meta     (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n+      \"traces   (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n+#  if !SANITIZER_GO\n+      \"low app  (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n+      \"high app (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n+      \"heap     (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n+#  else  // !SANITIZER_GO\n       \"app      (0x%016zx-0x%016zx): resident %zd kB, dirty %zd kB\\n\"\n-#endif\n-    \"stacks: %zd unique IDs, %zd kB allocated\\n\"\n-    \"threads: %zd total, %zd live\\n\"\n-    \"------------------------------\\n\",\n-    ShadowBeg(), ShadowEnd(), shadow_res / 1024, shadow_dirty / 1024,\n-    MetaShadowBeg(), MetaShadowEnd(), meta_res / 1024, meta_dirty / 1024,\n-    TraceMemBeg(), TraceMemEnd(), trace_res / 1024, trace_dirty / 1024,\n-#if !SANITIZER_GO\n-    LoAppMemBeg(), LoAppMemEnd(), low_res / 1024, low_dirty / 1024,\n-    HiAppMemBeg(), HiAppMemEnd(), high_res / 1024, high_dirty / 1024,\n-    HeapMemBeg(), HeapMemEnd(), heap_res / 1024, heap_dirty / 1024,\n-#else  // !SANITIZER_GO\n+#  endif\n+      \"stacks: %zd unique IDs, %zd kB allocated\\n\"\n+      \"threads: %zd total, %zd live\\n\"\n+      \"------------------------------\\n\",\n+      ShadowBeg(), ShadowEnd(), shadow_res / 1024, shadow_dirty / 1024,\n+      MetaShadowBeg(), MetaShadowEnd(), meta_res / 1024, meta_dirty / 1024,\n+      TraceMemBeg(), TraceMemEnd(), trace_res / 1024, trace_dirty / 1024,\n+#  if !SANITIZER_GO\n+      LoAppMemBeg(), LoAppMemEnd(), low_res / 1024, low_dirty / 1024,\n+      HiAppMemBeg(), HiAppMemEnd(), high_res / 1024, high_dirty / 1024,\n+      HeapMemBeg(), HeapMemEnd(), heap_res / 1024, heap_dirty / 1024,\n+#  else  // !SANITIZER_GO\n       LoAppMemBeg(), LoAppMemEnd(), app_res / 1024, app_dirty / 1024,\n-#endif\n-    stacks->n_uniq_ids, stacks->allocated / 1024,\n-    nthread, nlive);\n+#  endif\n+      stacks.n_uniq_ids, stacks.allocated / 1024, nthread, nlive);\n }\n \n #  if !SANITIZER_GO\n@@ -283,24 +283,26 @@ uptr ExtractLongJmpSp(uptr *env) {\n }\n \n #if !SANITIZER_GO\n+extern \"C\" void __tsan_tls_initialization() {}\n+\n void ImitateTlsWrite(ThreadState *thr, uptr tls_addr, uptr tls_size) {\n   // The pointer to the ThreadState object is stored in the shadow memory\n   // of the tls.\n   uptr tls_end = tls_addr + tls_size;\n   uptr thread_identity = (uptr)pthread_self();\n+  const uptr pc = StackTrace::GetNextInstructionPc(\n+      reinterpret_cast<uptr>(__tsan_tls_initialization));\n   if (thread_identity == main_thread_identity) {\n-    MemoryRangeImitateWrite(thr, /*pc=*/2, tls_addr, tls_size);\n+    MemoryRangeImitateWrite(thr, pc, tls_addr, tls_size);\n   } else {\n     uptr thr_state_start = thread_identity;\n     uptr thr_state_end = thr_state_start + sizeof(uptr);\n     CHECK_GE(thr_state_start, tls_addr);\n     CHECK_LE(thr_state_start, tls_addr + tls_size);\n     CHECK_GE(thr_state_end, tls_addr);\n     CHECK_LE(thr_state_end, tls_addr + tls_size);\n-    MemoryRangeImitateWrite(thr, /*pc=*/2, tls_addr,\n-                            thr_state_start - tls_addr);\n-    MemoryRangeImitateWrite(thr, /*pc=*/2, thr_state_end,\n-                            tls_end - thr_state_end);\n+    MemoryRangeImitateWrite(thr, pc, tls_addr, thr_state_start - tls_addr);\n+    MemoryRangeImitateWrite(thr, pc, thr_state_end, tls_end - thr_state_end);\n   }\n }\n #endif"}, {"sha": "1c53f957bdf1db017fe0466bcba29d82058562e1", "filename": "libsanitizer/tsan/tsan_rtl.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -43,9 +43,10 @@ int (*on_finalize)(int);\n \n #if !SANITIZER_GO && !SANITIZER_MAC\n __attribute__((tls_model(\"initial-exec\")))\n-THREADLOCAL char cur_thread_placeholder[sizeof(ThreadState)] ALIGNED(64);\n+THREADLOCAL char cur_thread_placeholder[sizeof(ThreadState)] ALIGNED(\n+    SANITIZER_CACHE_LINE_SIZE);\n #endif\n-static char ctx_placeholder[sizeof(Context)] ALIGNED(64);\n+static char ctx_placeholder[sizeof(Context)] ALIGNED(SANITIZER_CACHE_LINE_SIZE);\n Context *ctx;\n \n // Can be overriden by a front-end.\n@@ -195,8 +196,7 @@ static void *BackgroundThread(void *arg) {\n   // We don't use ScopedIgnoreInterceptors, because we want ignores to be\n   // enabled even when the thread function exits (e.g. during pthread thread\n   // shutdown code).\n-  cur_thread_init();\n-  cur_thread()->ignore_interceptors++;\n+  cur_thread_init()->ignore_interceptors++;\n   const u64 kMs2Ns = 1000 * 1000;\n   const u64 start = NanoTime();\n "}, {"sha": "669c4ac9a5498c1e7734f596e299439055f6e92c", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -230,23 +230,24 @@ struct ThreadState {\n ThreadState *cur_thread();\n void set_cur_thread(ThreadState *thr);\n void cur_thread_finalize();\n-inline void cur_thread_init() { }\n-#else\n+inline ThreadState *cur_thread_init() { return cur_thread(); }\n+#  else\n __attribute__((tls_model(\"initial-exec\")))\n extern THREADLOCAL char cur_thread_placeholder[];\n inline ThreadState *cur_thread() {\n   return reinterpret_cast<ThreadState *>(cur_thread_placeholder)->current;\n }\n-inline void cur_thread_init() {\n+inline ThreadState *cur_thread_init() {\n   ThreadState *thr = reinterpret_cast<ThreadState *>(cur_thread_placeholder);\n   if (UNLIKELY(!thr->current))\n     thr->current = thr;\n+  return thr->current;\n }\n inline void set_cur_thread(ThreadState *thr) {\n   reinterpret_cast<ThreadState *>(cur_thread_placeholder)->current = thr;\n }\n inline void cur_thread_finalize() { }\n-#endif  // SANITIZER_MAC || SANITIZER_ANDROID\n+#  endif  // SANITIZER_MAC || SANITIZER_ANDROID\n #endif  // SANITIZER_GO\n \n class ThreadContext final : public ThreadContextBase {"}, {"sha": "10c0122f564a1e246d01593297f42e09117db4da", "filename": "libsanitizer/tsan/tsan_rtl_amd64.S", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -13,6 +13,7 @@ ASM_HIDDEN(__tsan_trace_switch)\n .globl ASM_SYMBOL(__tsan_trace_switch_thunk)\n ASM_SYMBOL(__tsan_trace_switch_thunk):\n   CFI_STARTPROC\n+  _CET_ENDBR\n   # Save scratch registers.\n   push %rax\n   CFI_ADJUST_CFA_OFFSET(8)\n@@ -93,6 +94,7 @@ ASM_HIDDEN(__tsan_report_race)\n .globl ASM_SYMBOL(__tsan_report_race_thunk)\n ASM_SYMBOL(__tsan_report_race_thunk):\n   CFI_STARTPROC\n+  _CET_ENDBR\n   # Save scratch registers.\n   push %rax\n   CFI_ADJUST_CFA_OFFSET(8)\n@@ -185,6 +187,7 @@ ASM_TYPE_FUNCTION(ASM_SYMBOL_INTERCEPTOR(setjmp))\n ASM_SYMBOL_INTERCEPTOR(setjmp):\n #endif\n   CFI_STARTPROC\n+  _CET_ENDBR\n   // save env parameter\n   push %rdi\n   CFI_ADJUST_CFA_OFFSET(8)\n@@ -226,6 +229,7 @@ ASM_SIZE(ASM_SYMBOL_INTERCEPTOR(setjmp))\n ASM_TYPE_FUNCTION(ASM_SYMBOL_INTERCEPTOR(_setjmp))\n ASM_SYMBOL_INTERCEPTOR(_setjmp):\n   CFI_STARTPROC\n+  _CET_ENDBR\n   // save env parameter\n   push %rdi\n   CFI_ADJUST_CFA_OFFSET(8)\n@@ -267,6 +271,7 @@ ASM_TYPE_FUNCTION(ASM_SYMBOL_INTERCEPTOR(sigsetjmp))\n ASM_SYMBOL_INTERCEPTOR(sigsetjmp):\n #endif\n   CFI_STARTPROC\n+  _CET_ENDBR\n   // save env parameter\n   push %rdi\n   CFI_ADJUST_CFA_OFFSET(8)\n@@ -323,6 +328,7 @@ ASM_SIZE(ASM_SYMBOL_INTERCEPTOR(sigsetjmp))\n ASM_TYPE_FUNCTION(ASM_SYMBOL_INTERCEPTOR(__sigsetjmp))\n ASM_SYMBOL_INTERCEPTOR(__sigsetjmp):\n   CFI_STARTPROC\n+  _CET_ENDBR\n   // save env parameter\n   push %rdi\n   CFI_ADJUST_CFA_OFFSET(8)"}, {"sha": "8285e21aa1ec7a797dfcf4840ee5a7851106b497", "filename": "libsanitizer/tsan/tsan_rtl_ppc64.S", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -1,6 +1,5 @@\n #include \"tsan_ppc_regs.h\"\n \n-        .machine altivec\n         .section .text\n         .hidden __tsan_setjmp\n         .globl _setjmp"}, {"sha": "25cefd46ce27ced7fb6092d8d04b5074c56ebe95", "filename": "libsanitizer/ubsan/ubsan_flags.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -50,7 +50,6 @@ void InitializeFlags() {\n   {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n-    cf.print_summary = false;\n     cf.external_symbolizer_path = GetFlag(\"UBSAN_SYMBOLIZER_PATH\");\n     OverrideCommonFlags(cf);\n   }"}, {"sha": "e201e6bba22078e3d873aeb5792b98ecd860cdaa", "filename": "libsanitizer/ubsan/ubsan_handlers.cpp", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cpp?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -894,21 +894,6 @@ void __ubsan_handle_cfi_bad_type(CFICheckFailData *Data, ValueHandle Vtable,\n \n }  // namespace __ubsan\n \n-void __ubsan::__ubsan_handle_cfi_bad_icall(CFIBadIcallData *CallData,\n-                                           ValueHandle Function) {\n-  GET_REPORT_OPTIONS(false);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-}\n-\n-void __ubsan::__ubsan_handle_cfi_bad_icall_abort(CFIBadIcallData *CallData,\n-                                                 ValueHandle Function) {\n-  GET_REPORT_OPTIONS(true);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-  Die();\n-}\n-\n void __ubsan::__ubsan_handle_cfi_check_fail(CFICheckFailData *Data,\n                                             ValueHandle Value,\n                                             uptr ValidVtable) {"}, {"sha": "219fb15de55fe02a4544422095baa0d8532baaa0", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -215,20 +215,12 @@ enum CFITypeCheckKind : unsigned char {\n   CFITCK_VMFCall,\n };\n \n-struct CFIBadIcallData {\n-  SourceLocation Loc;\n-  const TypeDescriptor &Type;\n-};\n-\n struct CFICheckFailData {\n   CFITypeCheckKind CheckKind;\n   SourceLocation Loc;\n   const TypeDescriptor &Type;\n };\n \n-/// \\brief Handle control flow integrity failure for indirect function calls.\n-RECOVERABLE(cfi_bad_icall, CFIBadIcallData *Data, ValueHandle Function)\n-\n /// \\brief Handle control flow integrity failures.\n RECOVERABLE(cfi_check_fail, CFICheckFailData *Data, ValueHandle Function,\n             uptr VtableIsValid)"}, {"sha": "d2cc2e10bd2f023b8d9aa1685a79a192a6d1e1e8", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3d50c09519d1b4899845b21843bae66ecffc2f/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=2e3d50c09519d1b4899845b21843bae66ecffc2f", "patch": "@@ -12,7 +12,6 @@\n #ifndef UBSAN_PLATFORM_H\n #define UBSAN_PLATFORM_H\n \n-#ifndef CAN_SANITIZE_UB\n // Other platforms should be easy to add, and probably work as-is.\n #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) ||        \\\n     defined(__NetBSD__) || defined(__DragonFly__) ||                           \\\n@@ -22,6 +21,5 @@\n #else\n # define CAN_SANITIZE_UB 0\n #endif\n-#endif //CAN_SANITIZE_UB\n \n #endif"}]}