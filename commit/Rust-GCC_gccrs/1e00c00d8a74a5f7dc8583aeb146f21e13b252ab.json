{"sha": "1e00c00d8a74a5f7dc8583aeb146f21e13b252ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUwMGMwMGQ4YTc0YTVmN2RjODU4M2FlYjE0NmYyMWUxM2IyNTJhYg==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2020-10-16T20:49:58Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-11-26T08:39:37Z"}, "message": "[Ada] Compiler crash on named association in return aggregate\n\ngcc/ada/\n\n\t* sem_ch6.adb (First_Selector): Utility routine to return the\n\tfirst selector or choice in an association.\n\t(Check_Return_Construct_Accessibility): Modify loop to handle\n\tnamed associations when iterating through discriminants.", "tree": {"sha": "a3f2e1055721596c090ba466308f0835aa46ccdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3f2e1055721596c090ba466308f0835aa46ccdc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e00c00d8a74a5f7dc8583aeb146f21e13b252ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e00c00d8a74a5f7dc8583aeb146f21e13b252ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e00c00d8a74a5f7dc8583aeb146f21e13b252ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e00c00d8a74a5f7dc8583aeb146f21e13b252ab/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8593037b17ddbdad375954e59838e6f4083f44ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8593037b17ddbdad375954e59838e6f4083f44ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8593037b17ddbdad375954e59838e6f4083f44ba"}], "stats": {"total": 214, "additions": 201, "deletions": 13}, "files": [{"sha": "416c618984853261719f1de2eb886d212c3d0608", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 201, "deletions": 13, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e00c00d8a74a5f7dc8583aeb146f21e13b252ab/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e00c00d8a74a5f7dc8583aeb146f21e13b252ab/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=1e00c00d8a74a5f7dc8583aeb146f21e13b252ab", "patch": "@@ -784,13 +784,49 @@ package body Sem_Ch6 is\n       ------------------------------------------\n \n       procedure Check_Return_Construct_Accessibility (Return_Stmt : Node_Id) is\n-         Return_Con : Node_Id;\n-         Assoc      : Node_Id := Empty;\n-         Assoc_Expr : Node_Id;\n-         Disc       : Entity_Id;\n+\n+         function First_Selector (Assoc : Node_Id) return Node_Id;\n+         --  Obtain the first selector or choice from a given association\n+\n+         --------------------\n+         -- First_Selector --\n+         --------------------\n+\n+         function First_Selector (Assoc : Node_Id) return Node_Id is\n+         begin\n+            if Nkind (Assoc) = N_Component_Association then\n+               return First (Choices (Assoc));\n+\n+            elsif Nkind (Assoc) = N_Discriminant_Association then\n+               return (First (Selector_Names (Assoc)));\n+\n+            else\n+               raise Program_Error;\n+            end if;\n+         end First_Selector;\n+\n+         --  Local declarations\n+\n+         Assoc : Node_Id := Empty;\n+         --  Assoc should perhaps be renamed and declared as a\n+         --  Node_Or_Entity_Id since it encompasses not only component and\n+         --  discriminant associations, but also discriminant components within\n+         --  a type declaration or subtype indication ???\n+\n+         Assoc_Expr    : Node_Id;\n+         Assoc_Present : Boolean := False;\n+\n+         Unseen_Disc_Count : Nat := 0;\n+         Seen_Discs        : Elist_Id;\n+         Disc              : Entity_Id;\n+         First_Disc        : Entity_Id;\n+\n          Obj_Decl   : Node_Id;\n+         Return_Con : Node_Id;\n          Unqual     : Node_Id;\n \n+      --  Start of processing for Check_Return_Construct_Accessibility\n+\n       begin\n          --  Only perform checks on record types with access discriminants and\n          --  non-internally generated functions.\n@@ -845,7 +881,7 @@ package body Sem_Ch6 is\n \n          Unqual := Unqualify (Original_Node (Return_Con));\n \n-         --  Obtain the corresponding declaration based on the return object's\n+         --  Get the corresponding declaration based on the return object's\n          --  identifier.\n \n          if Nkind (Unqual) = N_Identifier\n@@ -982,30 +1018,175 @@ package body Sem_Ch6 is\n                       (Etype (Defining_Identifier (Obj_Decl)));\n          end if;\n \n+         --  Preserve the first discriminant for checking named associations\n+\n+         First_Disc := Disc;\n+\n+         --  Count the number of discriminants for processing an aggregate\n+         --  which includes an others.\n+\n+         Disc := First_Disc;\n+         while Present (Disc) loop\n+            Unseen_Disc_Count := Unseen_Disc_Count + 1;\n+\n+            Next_Discriminant (Disc);\n+         end loop;\n+\n+         Seen_Discs := New_Elmt_List;\n+\n          --  Loop through each of the discriminants and check each expression\n          --  associated with an anonymous access discriminant.\n \n-         while Present (Assoc) and then Present (Disc) loop\n-            --  Unwrap the associated expression\n+         --  When named associations occur in the return aggregate then\n+         --  discriminants can be in any order, so we need to ensure we do\n+         --  not continue to loop when all discriminants have been seen.\n+\n+         Disc := First_Disc;\n+         while Present (Assoc)\n+           and then (Present (Disc) or else Assoc_Present)\n+           and then Unseen_Disc_Count > 0\n+         loop\n+            --  Handle named associations by searching through the names of\n+            --  the relevant discriminant components.\n \n             if Nkind (Assoc)\n                  in N_Component_Association | N_Discriminant_Association\n             then\n-               Assoc_Expr := Expression (Assoc);\n+               Assoc_Expr    := Expression (Assoc);\n+               Assoc_Present := True;\n+\n+               --  We currently don't handle box initialized discriminants,\n+               --  however, since default initialized anonymous access\n+               --  discriminants are a corner case, this is ok for now ???\n+\n+               if Nkind (Assoc) = N_Component_Association\n+                 and then Box_Present (Assoc)\n+               then\n+                  Assoc_Present := False;\n+\n+                  if Nkind (First_Selector (Assoc)) = N_Others_Choice then\n+                     Unseen_Disc_Count := 0;\n+                  end if;\n+\n+               --  When others is present we must identify a discriminant we\n+               --  haven't already seen so as to get the appropriate type for\n+               --  the static accessibility check.\n+\n+               --  This works because all components within an others clause\n+               --  must have the same type.\n+\n+               elsif Nkind (First_Selector (Assoc)) = N_Others_Choice then\n+\n+                  Disc := First_Disc;\n+                  Outer : while Present (Disc) loop\n+                     declare\n+                        Current_Seen_Disc : Elmt_Id;\n+                     begin\n+                        --  Move through the list of identified discriminants\n+\n+                        Current_Seen_Disc := First_Elmt (Seen_Discs);\n+                        while Present (Current_Seen_Disc) loop\n+                           --  Exit the loop when we found a match\n+\n+                           exit when\n+                             Chars (Node (Current_Seen_Disc)) = Chars (Disc);\n+\n+                           Next_Elmt (Current_Seen_Disc);\n+                        end loop;\n+\n+                        --  When we have exited the above loop without finding\n+                        --  a match then we know that Disc has not been seen.\n+\n+                        exit Outer when No (Current_Seen_Disc);\n+                     end;\n+\n+                     Next_Discriminant (Disc);\n+                  end loop Outer;\n+\n+                  --  If we got to an others clause with a non-zero\n+                  --  discriminant count there must be a discriminant left to\n+                  --  check.\n+\n+                  pragma Assert (Present (Disc));\n+\n+                  --  Set the unseen discriminant count to zero because we know\n+                  --  an others clause sets all remaining components of an\n+                  --  aggregate.\n+\n+                  Unseen_Disc_Count := 0;\n+\n+               --  Move through each of the selectors in the named association\n+               --  and obtain a discriminant for accessibility checking if one\n+               --  is referenced in the list. Also track which discriminants\n+               --  are referenced for the purpose of handling an others clause.\n+\n+               else\n+                  declare\n+                     Assoc_Choice : Node_Id;\n+                     Curr_Disc    : Node_Id;\n+                  begin\n+\n+                     Disc      := Empty;\n+                     Curr_Disc := First_Disc;\n+                     while Present (Curr_Disc) loop\n+                        --  Check each of the choices in the associations for a\n+                        --  match to the name of the current discriminant.\n+\n+                        Assoc_Choice := First_Selector (Assoc);\n+                        while Present (Assoc_Choice) loop\n+                           --  When the name matches we track that we have seen\n+                           --  the discriminant, but instead of exiting the\n+                           --  loop we continue iterating to make sure all the\n+                           --  discriminants within the named association get\n+                           --  tracked.\n+\n+                           if Chars (Assoc_Choice) = Chars (Curr_Disc) then\n+                              Append_Elmt (Curr_Disc, Seen_Discs);\n+\n+                              Disc              := Curr_Disc;\n+                              Unseen_Disc_Count := Unseen_Disc_Count - 1;\n+                           end if;\n+\n+                           Next (Assoc_Choice);\n+                        end loop;\n+\n+                        Next_Discriminant (Curr_Disc);\n+                     end loop;\n+                  end;\n+               end if;\n+\n+            --  Unwrap the associated expression if we are looking at a default\n+            --  initialized type declaration. In this case Assoc is not really\n+            --  an association, but a component declaration. Should Assoc be\n+            --  renamed in some way to be more clear ???\n+\n+            --  This occurs when the return object does not initialize\n+            --  discriminant and instead relies on the type declaration for\n+            --  their supplied values.\n \n             elsif Nkind (Assoc) in N_Entity\n               and then Ekind (Assoc) = E_Discriminant\n             then\n-               Assoc_Expr := Discriminant_Default_Value (Assoc);\n+               Append_Elmt (Disc, Seen_Discs);\n+\n+               Assoc_Expr        := Discriminant_Default_Value (Assoc);\n+               Unseen_Disc_Count := Unseen_Disc_Count - 1;\n+\n+            --  Otherwise, there is nothing to do because Assoc is an\n+            --  expression within the return aggregate itself.\n \n             else\n-               Assoc_Expr := Assoc;\n+               Append_Elmt (Disc, Seen_Discs);\n+\n+               Assoc_Expr        := Assoc;\n+               Unseen_Disc_Count := Unseen_Disc_Count - 1;\n             end if;\n \n             --  Check the accessibility level of the expression when the\n             --  discriminant is of an anonymous access type.\n \n             if Present (Assoc_Expr)\n+              and then Present (Disc)\n               and then Ekind (Etype (Disc)) = E_Anonymous_Access_Type\n             then\n                --  Perform a static check first, if possible\n@@ -1019,8 +1200,8 @@ package body Sem_Ch6 is\n                   Error_Msg_N\n                     (\"access discriminant in return object would be a dangling\"\n                      & \" reference\", Return_Stmt);\n-                  exit;\n \n+                  exit;\n                end if;\n \n                --  Otherwise, generate a dynamic check based on the extra\n@@ -1041,9 +1222,16 @@ package body Sem_Ch6 is\n                end if;\n             end if;\n \n-            --  Iterate over the discriminants\n+            --  Iterate over the discriminants, except when we have encountered\n+            --  a named association since the discriminant order becomes\n+            --  irrelevant in that case.\n+\n+            if not Assoc_Present then\n+               Next_Discriminant (Disc);\n+            end if;\n+\n+            --  Iterate over associations\n \n-            Disc := Next_Discriminant (Disc);\n             if not Is_List_Member (Assoc) then\n                exit;\n             else"}]}