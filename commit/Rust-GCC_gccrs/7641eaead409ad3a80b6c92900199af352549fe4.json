{"sha": "7641eaead409ad3a80b6c92900199af352549fe4", "node_id": "C_kwDOANBUbNoAKDc2NDFlYWVhZDQwOWFkM2E4MGI2YzkyOTAwMTk5YWYzNTI1NDlmZTQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-21T11:45:38Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:04Z"}, "message": "gccrs: Add HIR definitions and visitor framework\n\nThis patch implements the classes mentioned in the previous HIR patch,\nas well as a set of visitor frameworks used in handling that HIR.\n\n\tgcc/rust/\n\t* hir/tree/rust-hir-full-decls.h: New.\n\t* hir/tree/rust-hir-full-test.cc: New.\n\t* hir/tree/rust-hir-full.h: New.\n\t* hir/tree/rust-hir-visitor.h: New.\n\t* hir/tree/rust-hir.h: New.", "tree": {"sha": "b73aaf69350a272924f4ed9c5d123f9053b660f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b73aaf69350a272924f4ed9c5d123f9053b660f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7641eaead409ad3a80b6c92900199af352549fe4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7641eaead409ad3a80b6c92900199af352549fe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7641eaead409ad3a80b6c92900199af352549fe4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7641eaead409ad3a80b6c92900199af352549fe4/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ad1d56d68a998fdc662a944f461e7bcb125920e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad1d56d68a998fdc662a944f461e7bcb125920e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad1d56d68a998fdc662a944f461e7bcb125920e"}], "stats": {"total": 6968, "additions": 6968, "deletions": 0}, "files": [{"sha": "2798ba9fd8483d46580dd087bc55ef40e598611b", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7641eaead409ad3a80b6c92900199af352549fe4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7641eaead409ad3a80b6c92900199af352549fe4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=7641eaead409ad3a80b6c92900199af352549fe4", "patch": "@@ -0,0 +1,232 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_FULL_DECLS_H\n+#define RUST_HIR_FULL_DECLS_H\n+\n+namespace Rust {\n+namespace HIR {\n+\n+struct Literal;\n+class Stmt;\n+class Item;\n+class Expr;\n+class ExprWithoutBlock;\n+class Pattern;\n+class Type;\n+class TypeNoBounds;\n+class TypeParamBound;\n+class Lifetime;\n+class GenericParam;\n+class LifetimeParam;\n+\n+class TraitItem;\n+class ImplItem;\n+struct Crate;\n+class PathExpr;\n+\n+// rust-path.h\n+class PathIdentSegment;\n+struct GenericArgsBinding;\n+struct GenericArgs;\n+class PathExprSegment;\n+class PathPattern;\n+class PathInExpression;\n+class TypePathSegment;\n+class TypePathSegmentGeneric;\n+struct TypePathFunction;\n+class TypePathSegmentFunction;\n+class TypePath;\n+struct QualifiedPathType;\n+class QualifiedPathInExpression;\n+class QualifiedPathInType;\n+\n+// rust-expr.h\n+class ExprWithBlock;\n+class LiteralExpr;\n+class AttrInputLiteral;\n+class OperatorExpr;\n+class BorrowExpr;\n+class DereferenceExpr;\n+class ErrorPropagationExpr;\n+class NegationExpr;\n+class ArithmeticOrLogicalExpr;\n+class ComparisonExpr;\n+class LazyBooleanExpr;\n+class TypeCastExpr;\n+class AssignmentExpr;\n+class CompoundAssignmentExpr;\n+class GroupedExpr;\n+class ArrayElems;\n+class ArrayElemsValues;\n+class ArrayElemsCopied;\n+class ArrayExpr;\n+class ArrayIndexExpr;\n+class TupleExpr;\n+class TupleIndexExpr;\n+class StructExpr;\n+class StructExprStruct;\n+struct StructBase;\n+class StructExprField;\n+class StructExprFieldIdentifier;\n+class StructExprFieldWithVal;\n+class StructExprFieldIdentifierValue;\n+class StructExprFieldIndexValue;\n+class StructExprStructFields;\n+class StructExprStructBase;\n+class CallExpr;\n+class MethodCallExpr;\n+class FieldAccessExpr;\n+struct ClosureParam;\n+class ClosureExpr;\n+class ClosureExprInner;\n+class BlockExpr;\n+class ClosureExprInnerTyped;\n+class ContinueExpr;\n+class BreakExpr;\n+class RangeExpr;\n+class RangeFromToExpr;\n+class RangeFromExpr;\n+class RangeToExpr;\n+class RangeFullExpr;\n+class RangeFromToInclExpr;\n+class RangeToInclExpr;\n+class ReturnExpr;\n+class UnsafeBlockExpr;\n+class LoopLabel;\n+class BaseLoopExpr;\n+class LoopExpr;\n+class WhileLoopExpr;\n+class WhileLetLoopExpr;\n+class ForLoopExpr;\n+class IfExpr;\n+class IfExprConseqElse;\n+class IfExprConseqIf;\n+class IfLetExpr;\n+class IfExprConseqIfLet;\n+class IfLetExprConseqElse;\n+class IfLetExprConseqIf;\n+class IfLetExprConseqIfLet;\n+struct MatchArm;\n+// class MatchCase;\n+// class MatchCaseBlockExpr;\n+// class MatchCaseExpr;\n+struct MatchCase;\n+class MatchExpr;\n+class AwaitExpr;\n+class AsyncBlockExpr;\n+\n+// rust-stmt.h\n+class EmptyStmt;\n+class LetStmt;\n+class ExprStmt;\n+class ExprStmtWithoutBlock;\n+class ExprStmtWithBlock;\n+\n+// rust-item.h\n+class TypeParam;\n+class ConstGenericParam;\n+class WhereClauseItem;\n+class LifetimeWhereClauseItem;\n+class TypeBoundWhereClauseItem;\n+struct WhereClause;\n+struct SelfParam;\n+struct FunctionQualifiers;\n+struct FunctionParam;\n+struct Visibility;\n+class VisItem;\n+class Module;\n+class ExternCrate;\n+class UseTree;\n+class UseTreeGlob;\n+class UseTreeList;\n+class UseTreeRebind;\n+class UseDeclaration;\n+class Function;\n+class TypeAlias;\n+class Struct;\n+struct StructField;\n+class StructStruct;\n+struct TupleField;\n+class TupleStruct;\n+class EnumItem;\n+class EnumItemTuple;\n+class EnumItemStruct;\n+class EnumItemDiscriminant;\n+class Enum;\n+class Union;\n+class ConstantItem;\n+class StaticItem;\n+struct TraitFunctionDecl;\n+class TraitItemFunc;\n+class TraitItemConst;\n+class TraitItemType;\n+class Trait;\n+class ImplBlock;\n+class ExternalItem;\n+class ExternalStaticItem;\n+struct NamedFunctionParam;\n+class ExternalFunctionItem;\n+class ExternBlock;\n+\n+// rust-pattern.h\n+class LiteralPattern;\n+class IdentifierPattern;\n+class WildcardPattern;\n+class RangePatternBound;\n+class RangePatternBoundLiteral;\n+class RangePatternBoundPath;\n+class RangePatternBoundQualPath;\n+class RangePattern;\n+class ReferencePattern;\n+struct StructPatternEtc;\n+class StructPatternField;\n+class StructPatternFieldTuplePat;\n+class StructPatternFieldIdentPat;\n+class StructPatternFieldIdent;\n+class StructPattern;\n+class TupleStructItems;\n+class TupleStructItemsNoRange;\n+class TupleStructItemsRange;\n+class TupleStructPattern;\n+class TuplePatternItems;\n+class TuplePatternItemsMultiple;\n+class TuplePatternItemsRanged;\n+class TuplePattern;\n+class GroupedPattern;\n+class SlicePattern;\n+\n+// rust-type.h\n+class TraitBound;\n+class ImplTraitType;\n+class TraitObjectType;\n+class ParenthesisedType;\n+class ImplTraitTypeOneBound;\n+class TupleType;\n+class NeverType;\n+class RawPointerType;\n+class ReferenceType;\n+class ArrayType;\n+class SliceType;\n+class InferredType;\n+struct MaybeNamedParam;\n+class BareFunctionType;\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "4e255320e2dd62bf6527987c388eed6bad38bf95", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "added", "additions": 5292, "deletions": 0, "changes": 5292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7641eaead409ad3a80b6c92900199af352549fe4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7641eaead409ad3a80b6c92900199af352549fe4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=7641eaead409ad3a80b6c92900199af352549fe4"}, {"sha": "646b793654e66bf2c6ffa07d69ab15fbe2d45927", "filename": "gcc/rust/hir/tree/rust-hir-full.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7641eaead409ad3a80b6c92900199af352549fe4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7641eaead409ad3a80b6c92900199af352549fe4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h?ref=7641eaead409ad3a80b6c92900199af352549fe4", "patch": "@@ -0,0 +1,30 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_FULL_H\n+#define RUST_HIR_FULL_H\n+\n+#include \"rust-hir.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-item.h\"\n+#include \"rust-hir-path.h\"\n+#include \"rust-hir-pattern.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-type.h\"\n+\n+#endif // RUST_HIR_FULL_H"}, {"sha": "b3c0b9359cc422b2dc6720c956e85bd4e3df3850", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "added", "additions": 493, "deletions": 0, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7641eaead409ad3a80b6c92900199af352549fe4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7641eaead409ad3a80b6c92900199af352549fe4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=7641eaead409ad3a80b6c92900199af352549fe4", "patch": "@@ -0,0 +1,493 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_VISITOR_H\n+#define RUST_HIR_VISITOR_H\n+\n+#include \"rust-hir-full-decls.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class HIRFullVisitor\n+{\n+public:\n+  virtual void visit (Lifetime &lifetime) = 0;\n+  virtual void visit (LifetimeParam &lifetime_param) = 0;\n+  virtual void visit (PathInExpression &path) = 0;\n+  virtual void visit (TypePathSegment &segment) = 0;\n+  virtual void visit (TypePathSegmentGeneric &segment) = 0;\n+  virtual void visit (TypePathSegmentFunction &segment) = 0;\n+  virtual void visit (TypePath &path) = 0;\n+  virtual void visit (QualifiedPathInExpression &path) = 0;\n+  virtual void visit (QualifiedPathInType &path) = 0;\n+  virtual void visit (LiteralExpr &expr) = 0;\n+  virtual void visit (BorrowExpr &expr) = 0;\n+  virtual void visit (DereferenceExpr &expr) = 0;\n+  virtual void visit (ErrorPropagationExpr &expr) = 0;\n+  virtual void visit (NegationExpr &expr) = 0;\n+  virtual void visit (ArithmeticOrLogicalExpr &expr) = 0;\n+  virtual void visit (ComparisonExpr &expr) = 0;\n+  virtual void visit (LazyBooleanExpr &expr) = 0;\n+  virtual void visit (TypeCastExpr &expr) = 0;\n+  virtual void visit (AssignmentExpr &expr) = 0;\n+  virtual void visit (CompoundAssignmentExpr &expr) = 0;\n+  virtual void visit (GroupedExpr &expr) = 0;\n+  virtual void visit (ArrayElemsValues &elems) = 0;\n+  virtual void visit (ArrayElemsCopied &elems) = 0;\n+  virtual void visit (ArrayExpr &expr) = 0;\n+  virtual void visit (ArrayIndexExpr &expr) = 0;\n+  virtual void visit (TupleExpr &expr) = 0;\n+  virtual void visit (TupleIndexExpr &expr) = 0;\n+  virtual void visit (StructExprStruct &expr) = 0;\n+  virtual void visit (StructExprFieldIdentifier &field) = 0;\n+  virtual void visit (StructExprFieldIdentifierValue &field) = 0;\n+  virtual void visit (StructExprFieldIndexValue &field) = 0;\n+  virtual void visit (StructExprStructFields &expr) = 0;\n+  virtual void visit (StructExprStructBase &expr) = 0;\n+  virtual void visit (CallExpr &expr) = 0;\n+  virtual void visit (MethodCallExpr &expr) = 0;\n+  virtual void visit (FieldAccessExpr &expr) = 0;\n+  virtual void visit (ClosureExprInner &expr) = 0;\n+  virtual void visit (BlockExpr &expr) = 0;\n+  virtual void visit (ClosureExprInnerTyped &expr) = 0;\n+  virtual void visit (ContinueExpr &expr) = 0;\n+  virtual void visit (BreakExpr &expr) = 0;\n+  virtual void visit (RangeFromToExpr &expr) = 0;\n+  virtual void visit (RangeFromExpr &expr) = 0;\n+  virtual void visit (RangeToExpr &expr) = 0;\n+  virtual void visit (RangeFullExpr &expr) = 0;\n+  virtual void visit (RangeFromToInclExpr &expr) = 0;\n+  virtual void visit (RangeToInclExpr &expr) = 0;\n+  virtual void visit (ReturnExpr &expr) = 0;\n+  virtual void visit (UnsafeBlockExpr &expr) = 0;\n+  virtual void visit (LoopExpr &expr) = 0;\n+  virtual void visit (WhileLoopExpr &expr) = 0;\n+  virtual void visit (WhileLetLoopExpr &expr) = 0;\n+  virtual void visit (ForLoopExpr &expr) = 0;\n+  virtual void visit (IfExpr &expr) = 0;\n+  virtual void visit (IfExprConseqElse &expr) = 0;\n+  virtual void visit (IfExprConseqIf &expr) = 0;\n+  virtual void visit (IfExprConseqIfLet &expr) = 0;\n+  virtual void visit (IfLetExpr &expr) = 0;\n+  virtual void visit (IfLetExprConseqElse &expr) = 0;\n+  virtual void visit (IfLetExprConseqIf &expr) = 0;\n+  virtual void visit (IfLetExprConseqIfLet &expr) = 0;\n+  virtual void visit (MatchExpr &expr) = 0;\n+  virtual void visit (AwaitExpr &expr) = 0;\n+  virtual void visit (AsyncBlockExpr &expr) = 0;\n+  virtual void visit (TypeParam &param) = 0;\n+  virtual void visit (ConstGenericParam &param) = 0;\n+  virtual void visit (LifetimeWhereClauseItem &item) = 0;\n+  virtual void visit (TypeBoundWhereClauseItem &item) = 0;\n+  virtual void visit (Module &module) = 0;\n+  virtual void visit (ExternCrate &crate) = 0;\n+  virtual void visit (UseTreeGlob &use_tree) = 0;\n+  virtual void visit (UseTreeList &use_tree) = 0;\n+  virtual void visit (UseTreeRebind &use_tree) = 0;\n+  virtual void visit (UseDeclaration &use_decl) = 0;\n+  virtual void visit (Function &function) = 0;\n+  virtual void visit (TypeAlias &type_alias) = 0;\n+  virtual void visit (StructStruct &struct_item) = 0;\n+  virtual void visit (TupleStruct &tuple_struct) = 0;\n+  virtual void visit (EnumItem &item) = 0;\n+  virtual void visit (EnumItemTuple &item) = 0;\n+  virtual void visit (EnumItemStruct &item) = 0;\n+  virtual void visit (EnumItemDiscriminant &item) = 0;\n+  virtual void visit (Enum &enum_item) = 0;\n+  virtual void visit (Union &union_item) = 0;\n+  virtual void visit (ConstantItem &const_item) = 0;\n+  virtual void visit (StaticItem &static_item) = 0;\n+  virtual void visit (TraitItemFunc &item) = 0;\n+  virtual void visit (TraitItemConst &item) = 0;\n+  virtual void visit (TraitItemType &item) = 0;\n+  virtual void visit (Trait &trait) = 0;\n+  virtual void visit (ImplBlock &impl) = 0;\n+  virtual void visit (ExternalStaticItem &item) = 0;\n+  virtual void visit (ExternalFunctionItem &item) = 0;\n+  virtual void visit (ExternBlock &block) = 0;\n+  virtual void visit (LiteralPattern &pattern) = 0;\n+  virtual void visit (IdentifierPattern &pattern) = 0;\n+  virtual void visit (WildcardPattern &pattern) = 0;\n+  virtual void visit (RangePatternBoundLiteral &bound) = 0;\n+  virtual void visit (RangePatternBoundPath &bound) = 0;\n+  virtual void visit (RangePatternBoundQualPath &bound) = 0;\n+  virtual void visit (RangePattern &pattern) = 0;\n+  virtual void visit (ReferencePattern &pattern) = 0;\n+  virtual void visit (StructPatternFieldTuplePat &field) = 0;\n+  virtual void visit (StructPatternFieldIdentPat &field) = 0;\n+  virtual void visit (StructPatternFieldIdent &field) = 0;\n+  virtual void visit (StructPattern &pattern) = 0;\n+  virtual void visit (TupleStructItemsNoRange &tuple_items) = 0;\n+  virtual void visit (TupleStructItemsRange &tuple_items) = 0;\n+  virtual void visit (TupleStructPattern &pattern) = 0;\n+  virtual void visit (TuplePatternItemsMultiple &tuple_items) = 0;\n+  virtual void visit (TuplePatternItemsRanged &tuple_items) = 0;\n+  virtual void visit (TuplePattern &pattern) = 0;\n+  virtual void visit (GroupedPattern &pattern) = 0;\n+  virtual void visit (SlicePattern &pattern) = 0;\n+  virtual void visit (EmptyStmt &stmt) = 0;\n+  virtual void visit (LetStmt &stmt) = 0;\n+  virtual void visit (ExprStmtWithoutBlock &stmt) = 0;\n+  virtual void visit (ExprStmtWithBlock &stmt) = 0;\n+  virtual void visit (TraitBound &bound) = 0;\n+  virtual void visit (ImplTraitType &type) = 0;\n+  virtual void visit (TraitObjectType &type) = 0;\n+  virtual void visit (ParenthesisedType &type) = 0;\n+  virtual void visit (ImplTraitTypeOneBound &type) = 0;\n+  virtual void visit (TupleType &type) = 0;\n+  virtual void visit (NeverType &type) = 0;\n+  virtual void visit (RawPointerType &type) = 0;\n+  virtual void visit (ReferenceType &type) = 0;\n+  virtual void visit (ArrayType &type) = 0;\n+  virtual void visit (SliceType &type) = 0;\n+  virtual void visit (InferredType &type) = 0;\n+  virtual void visit (BareFunctionType &type) = 0;\n+};\n+\n+class HIRFullVisitorBase : public HIRFullVisitor\n+{\n+public:\n+  virtual ~HIRFullVisitorBase () {}\n+\n+  virtual void visit (Lifetime &) override {}\n+  virtual void visit (LifetimeParam &) override {}\n+  virtual void visit (PathInExpression &) override {}\n+  virtual void visit (TypePathSegment &) override {}\n+  virtual void visit (TypePathSegmentGeneric &) override {}\n+  virtual void visit (TypePathSegmentFunction &) override {}\n+  virtual void visit (TypePath &) override {}\n+  virtual void visit (QualifiedPathInExpression &) override {}\n+  virtual void visit (QualifiedPathInType &) override {}\n+\n+  virtual void visit (LiteralExpr &) override {}\n+  virtual void visit (BorrowExpr &) override {}\n+  virtual void visit (DereferenceExpr &) override {}\n+  virtual void visit (ErrorPropagationExpr &) override {}\n+  virtual void visit (NegationExpr &) override {}\n+  virtual void visit (ArithmeticOrLogicalExpr &) override {}\n+  virtual void visit (ComparisonExpr &) override {}\n+  virtual void visit (LazyBooleanExpr &) override {}\n+  virtual void visit (TypeCastExpr &) override {}\n+  virtual void visit (AssignmentExpr &) override {}\n+  virtual void visit (CompoundAssignmentExpr &) override {}\n+  virtual void visit (GroupedExpr &) override {}\n+\n+  virtual void visit (ArrayElemsValues &) override {}\n+  virtual void visit (ArrayElemsCopied &) override {}\n+  virtual void visit (ArrayExpr &) override {}\n+  virtual void visit (ArrayIndexExpr &) override {}\n+  virtual void visit (TupleExpr &) override {}\n+  virtual void visit (TupleIndexExpr &) override {}\n+  virtual void visit (StructExprStruct &) override {}\n+\n+  virtual void visit (StructExprFieldIdentifier &) override {}\n+  virtual void visit (StructExprFieldIdentifierValue &) override {}\n+\n+  virtual void visit (StructExprFieldIndexValue &) override {}\n+  virtual void visit (StructExprStructFields &) override {}\n+  virtual void visit (StructExprStructBase &) override {}\n+\n+  virtual void visit (CallExpr &) override {}\n+  virtual void visit (MethodCallExpr &) override {}\n+  virtual void visit (FieldAccessExpr &) override {}\n+  virtual void visit (ClosureExprInner &) override {}\n+  virtual void visit (BlockExpr &) override {}\n+  virtual void visit (ClosureExprInnerTyped &) override {}\n+  virtual void visit (ContinueExpr &) override {}\n+  virtual void visit (BreakExpr &) override {}\n+  virtual void visit (RangeFromToExpr &) override {}\n+  virtual void visit (RangeFromExpr &) override {}\n+  virtual void visit (RangeToExpr &) override {}\n+  virtual void visit (RangeFullExpr &) override {}\n+  virtual void visit (RangeFromToInclExpr &) override {}\n+  virtual void visit (RangeToInclExpr &) override {}\n+  virtual void visit (ReturnExpr &) override {}\n+  virtual void visit (UnsafeBlockExpr &) override {}\n+  virtual void visit (LoopExpr &) override {}\n+  virtual void visit (WhileLoopExpr &) override {}\n+  virtual void visit (WhileLetLoopExpr &) override {}\n+  virtual void visit (ForLoopExpr &) override {}\n+  virtual void visit (IfExpr &) override {}\n+  virtual void visit (IfExprConseqElse &) override {}\n+  virtual void visit (IfExprConseqIf &) override {}\n+  virtual void visit (IfExprConseqIfLet &) override {}\n+  virtual void visit (IfLetExpr &) override {}\n+  virtual void visit (IfLetExprConseqElse &) override {}\n+  virtual void visit (IfLetExprConseqIf &) override {}\n+  virtual void visit (IfLetExprConseqIfLet &) override {}\n+\n+  virtual void visit (MatchExpr &) override {}\n+  virtual void visit (AwaitExpr &) override {}\n+  virtual void visit (AsyncBlockExpr &) override {}\n+\n+  virtual void visit (TypeParam &) override {}\n+  virtual void visit (ConstGenericParam &) override {}\n+\n+  virtual void visit (LifetimeWhereClauseItem &) override {}\n+  virtual void visit (TypeBoundWhereClauseItem &) override {}\n+  virtual void visit (Module &) override {}\n+  virtual void visit (ExternCrate &) override {}\n+\n+  virtual void visit (UseTreeGlob &) override {}\n+  virtual void visit (UseTreeList &) override {}\n+  virtual void visit (UseTreeRebind &) override {}\n+  virtual void visit (UseDeclaration &) override {}\n+  virtual void visit (Function &) override {}\n+  virtual void visit (TypeAlias &) override {}\n+  virtual void visit (StructStruct &) override {}\n+  virtual void visit (TupleStruct &) override {}\n+  virtual void visit (EnumItem &) override {}\n+  virtual void visit (EnumItemTuple &) override {}\n+  virtual void visit (EnumItemStruct &) override {}\n+  virtual void visit (EnumItemDiscriminant &) override {}\n+  virtual void visit (Enum &) override {}\n+  virtual void visit (Union &) override {}\n+  virtual void visit (ConstantItem &) override {}\n+  virtual void visit (StaticItem &) override {}\n+  virtual void visit (TraitItemFunc &) override {}\n+  virtual void visit (TraitItemConst &) override {}\n+  virtual void visit (TraitItemType &) override {}\n+  virtual void visit (Trait &) override {}\n+  virtual void visit (ImplBlock &) override {}\n+\n+  virtual void visit (ExternalStaticItem &) override {}\n+  virtual void visit (ExternalFunctionItem &) override {}\n+  virtual void visit (ExternBlock &) override {}\n+\n+  virtual void visit (LiteralPattern &) override {}\n+  virtual void visit (IdentifierPattern &) override {}\n+  virtual void visit (WildcardPattern &) override {}\n+\n+  virtual void visit (RangePatternBoundLiteral &) override {}\n+  virtual void visit (RangePatternBoundPath &) override {}\n+  virtual void visit (RangePatternBoundQualPath &) override {}\n+  virtual void visit (RangePattern &) override {}\n+  virtual void visit (ReferencePattern &) override {}\n+\n+  virtual void visit (StructPatternFieldTuplePat &) override {}\n+  virtual void visit (StructPatternFieldIdentPat &) override {}\n+  virtual void visit (StructPatternFieldIdent &) override {}\n+  virtual void visit (StructPattern &) override {}\n+\n+  virtual void visit (TupleStructItemsNoRange &) override {}\n+  virtual void visit (TupleStructItemsRange &) override {}\n+  virtual void visit (TupleStructPattern &) override {}\n+\n+  virtual void visit (TuplePatternItemsMultiple &) override {}\n+  virtual void visit (TuplePatternItemsRanged &) override {}\n+  virtual void visit (TuplePattern &) override {}\n+  virtual void visit (GroupedPattern &) override {}\n+  virtual void visit (SlicePattern &) override {}\n+\n+  virtual void visit (EmptyStmt &) override {}\n+  virtual void visit (LetStmt &) override {}\n+  virtual void visit (ExprStmtWithoutBlock &) override {}\n+  virtual void visit (ExprStmtWithBlock &) override {}\n+\n+  virtual void visit (TraitBound &) override {}\n+  virtual void visit (ImplTraitType &) override {}\n+  virtual void visit (TraitObjectType &) override {}\n+  virtual void visit (ParenthesisedType &) override {}\n+  virtual void visit (ImplTraitTypeOneBound &) override {}\n+  virtual void visit (TupleType &) override {}\n+  virtual void visit (NeverType &) override {}\n+  virtual void visit (RawPointerType &) override {}\n+  virtual void visit (ReferenceType &) override {}\n+  virtual void visit (ArrayType &) override {}\n+  virtual void visit (SliceType &) override {}\n+  virtual void visit (InferredType &) override {}\n+  virtual void visit (BareFunctionType &) override {}\n+};\n+\n+class HIRExternalItemVisitor\n+{\n+public:\n+  virtual void visit (ExternalStaticItem &item) = 0;\n+  virtual void visit (ExternalFunctionItem &item) = 0;\n+};\n+\n+class HIRTraitItemVisitor\n+{\n+public:\n+  virtual void visit (TraitItemFunc &item) = 0;\n+  virtual void visit (TraitItemConst &item) = 0;\n+  virtual void visit (TraitItemType &item) = 0;\n+};\n+\n+class HIRVisItemVisitor\n+{\n+public:\n+  virtual void visit (Module &module) = 0;\n+  virtual void visit (ExternCrate &crate) = 0;\n+  virtual void visit (UseDeclaration &use_decl) = 0;\n+  virtual void visit (Function &function) = 0;\n+  virtual void visit (TypeAlias &type_alias) = 0;\n+  virtual void visit (StructStruct &struct_item) = 0;\n+  virtual void visit (TupleStruct &tuple_struct) = 0;\n+  virtual void visit (Enum &enum_item) = 0;\n+  virtual void visit (Union &union_item) = 0;\n+  virtual void visit (ConstantItem &const_item) = 0;\n+  virtual void visit (StaticItem &static_item) = 0;\n+  virtual void visit (Trait &trait) = 0;\n+  virtual void visit (ImplBlock &impl) = 0;\n+  virtual void visit (ExternBlock &block) = 0;\n+};\n+\n+class HIRImplVisitor\n+{\n+public:\n+  virtual void visit (Function &function) = 0;\n+  virtual void visit (ConstantItem &const_item) = 0;\n+  virtual void visit (TypeAlias &type_alias) = 0;\n+};\n+\n+class HIRTypeVisitor\n+{\n+public:\n+  virtual void visit (TypePathSegmentFunction &segment) = 0;\n+  virtual void visit (TypePath &path) = 0;\n+  virtual void visit (QualifiedPathInType &path) = 0;\n+  virtual void visit (TraitBound &bound) = 0;\n+  virtual void visit (ImplTraitType &type) = 0;\n+  virtual void visit (TraitObjectType &type) = 0;\n+  virtual void visit (ParenthesisedType &type) = 0;\n+  virtual void visit (ImplTraitTypeOneBound &type) = 0;\n+  virtual void visit (TupleType &type) = 0;\n+  virtual void visit (NeverType &type) = 0;\n+  virtual void visit (RawPointerType &type) = 0;\n+  virtual void visit (ReferenceType &type) = 0;\n+  virtual void visit (ArrayType &type) = 0;\n+  virtual void visit (SliceType &type) = 0;\n+  virtual void visit (InferredType &type) = 0;\n+  virtual void visit (BareFunctionType &type) = 0;\n+};\n+\n+class HIRStmtVisitor\n+{\n+public:\n+  virtual void visit (EnumItemTuple &) = 0;\n+  virtual void visit (EnumItemStruct &) = 0;\n+  virtual void visit (EnumItem &item) = 0;\n+  virtual void visit (TupleStruct &tuple_struct) = 0;\n+  virtual void visit (EnumItemDiscriminant &) = 0;\n+  virtual void visit (TypePathSegmentFunction &segment) = 0;\n+  virtual void visit (TypePath &path) = 0;\n+  virtual void visit (QualifiedPathInType &path) = 0;\n+  virtual void visit (Module &module) = 0;\n+  virtual void visit (ExternCrate &crate) = 0;\n+  virtual void visit (UseDeclaration &use_decl) = 0;\n+  virtual void visit (Function &function) = 0;\n+  virtual void visit (TypeAlias &type_alias) = 0;\n+  virtual void visit (StructStruct &struct_item) = 0;\n+  virtual void visit (Enum &enum_item) = 0;\n+  virtual void visit (Union &union_item) = 0;\n+  virtual void visit (ConstantItem &const_item) = 0;\n+  virtual void visit (StaticItem &static_item) = 0;\n+  virtual void visit (Trait &trait) = 0;\n+  virtual void visit (ImplBlock &impl) = 0;\n+  virtual void visit (ExternBlock &block) = 0;\n+  virtual void visit (EmptyStmt &stmt) = 0;\n+  virtual void visit (LetStmt &stmt) = 0;\n+  virtual void visit (ExprStmtWithoutBlock &stmt) = 0;\n+  virtual void visit (ExprStmtWithBlock &stmt) = 0;\n+};\n+\n+class HIRExpressionVisitor\n+{\n+public:\n+  // These are StructExprField\n+  // Added because of CompileStructExprField\n+  virtual void visit (StructExprFieldIdentifier &field) = 0;\n+  virtual void visit (StructExprFieldIdentifierValue &field) = 0;\n+  virtual void visit (StructExprFieldIndexValue &field) = 0;\n+\n+  virtual void visit (HIR::QualifiedPathInExpression &expr) = 0;\n+  virtual void visit (HIR::PathInExpression &expr) = 0;\n+  virtual void visit (ClosureExprInnerTyped &) = 0;\n+  virtual void visit (ClosureExprInner &expr) = 0;\n+  virtual void visit (StructExprStructFields &) = 0;\n+  virtual void visit (StructExprStruct &) = 0;\n+  virtual void visit (LiteralExpr &expr) = 0;\n+  virtual void visit (BorrowExpr &expr) = 0;\n+  virtual void visit (DereferenceExpr &expr) = 0;\n+  virtual void visit (ErrorPropagationExpr &expr) = 0;\n+  virtual void visit (NegationExpr &expr) = 0;\n+  virtual void visit (ArithmeticOrLogicalExpr &expr) = 0;\n+  virtual void visit (ComparisonExpr &expr) = 0;\n+  virtual void visit (LazyBooleanExpr &expr) = 0;\n+  virtual void visit (TypeCastExpr &expr) = 0;\n+  virtual void visit (AssignmentExpr &expr) = 0;\n+  virtual void visit (CompoundAssignmentExpr &expr) = 0;\n+  virtual void visit (GroupedExpr &expr) = 0;\n+  virtual void visit (ArrayExpr &expr) = 0;\n+  virtual void visit (ArrayIndexExpr &expr) = 0;\n+  virtual void visit (TupleExpr &expr) = 0;\n+  virtual void visit (TupleIndexExpr &expr) = 0;\n+  virtual void visit (CallExpr &expr) = 0;\n+  virtual void visit (MethodCallExpr &expr) = 0;\n+  virtual void visit (FieldAccessExpr &expr) = 0;\n+  virtual void visit (BlockExpr &expr) = 0;\n+  virtual void visit (ContinueExpr &expr) = 0;\n+  virtual void visit (BreakExpr &expr) = 0;\n+  virtual void visit (RangeFromToExpr &expr) = 0;\n+  virtual void visit (RangeFromExpr &expr) = 0;\n+  virtual void visit (RangeToExpr &expr) = 0;\n+  virtual void visit (RangeFullExpr &expr) = 0;\n+  virtual void visit (RangeFromToInclExpr &expr) = 0;\n+  virtual void visit (RangeToInclExpr &expr) = 0;\n+  virtual void visit (ReturnExpr &expr) = 0;\n+  virtual void visit (UnsafeBlockExpr &expr) = 0;\n+  virtual void visit (LoopExpr &expr) = 0;\n+  virtual void visit (WhileLoopExpr &expr) = 0;\n+  virtual void visit (WhileLetLoopExpr &expr) = 0;\n+  virtual void visit (ForLoopExpr &expr) = 0;\n+  virtual void visit (IfExpr &expr) = 0;\n+  virtual void visit (IfExprConseqElse &expr) = 0;\n+  virtual void visit (IfExprConseqIf &expr) = 0;\n+  virtual void visit (IfExprConseqIfLet &expr) = 0;\n+  virtual void visit (IfLetExpr &expr) = 0;\n+  virtual void visit (IfLetExprConseqElse &expr) = 0;\n+  virtual void visit (IfLetExprConseqIf &expr) = 0;\n+  virtual void visit (IfLetExprConseqIfLet &expr) = 0;\n+  virtual void visit (MatchExpr &expr) = 0;\n+  virtual void visit (AwaitExpr &expr) = 0;\n+  virtual void visit (AsyncBlockExpr &expr) = 0;\n+};\n+\n+class HIRPatternVisitor\n+{\n+public:\n+  virtual void visit (GroupedPattern &) = 0;\n+  virtual void visit (IdentifierPattern &) = 0;\n+  virtual void visit (LiteralPattern &) = 0;\n+  virtual void visit (PathInExpression &) = 0;\n+  virtual void visit (QualifiedPathInExpression &) = 0;\n+  virtual void visit (RangePattern &) = 0;\n+  virtual void visit (ReferencePattern &) = 0;\n+  virtual void visit (SlicePattern &) = 0;\n+  virtual void visit (StructPattern &) = 0;\n+  virtual void visit (TuplePattern &) = 0;\n+  virtual void visit (TupleStructPattern &) = 0;\n+  virtual void visit (WildcardPattern &) = 0;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "927ac06fc4a30c473a7aa3f86468cfbfd21594c2", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "added", "additions": 921, "deletions": 0, "changes": 921, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7641eaead409ad3a80b6c92900199af352549fe4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7641eaead409ad3a80b6c92900199af352549fe4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=7641eaead409ad3a80b6c92900199af352549fe4", "patch": "@@ -0,0 +1,921 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_BASE_H\n+#define RUST_HIR_BASE_H\n+\n+#include \"rust-ast.h\"\n+#include \"rust-system.h\"\n+#include \"rust-token.h\"\n+#include \"rust-location.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-diagnostics.h\"\n+\n+namespace Rust {\n+typedef std::string Identifier;\n+typedef int TupleIndex;\n+\n+namespace HIR {\n+// foward decl: ast visitor\n+class HIRFullVisitor;\n+class HIRStmtVisitor;\n+class HIRTraitItemVisitor;\n+class HIRExternalItemVisitor;\n+class HIRVisItemVisitor;\n+class HIRExpressionVisitor;\n+class HIRPatternVisitor;\n+class HIRImplVisitor;\n+class HIRTypeVisitor;\n+\n+// forward decl for use in token tree method\n+class Token;\n+\n+class Node\n+{\n+public:\n+  // Kind for downcasting various HIR nodes to other base classes when visiting\n+  // them\n+  enum BaseKind\n+  {\n+    /* class ExternalItem */\n+    EXTERNAL,\n+    /* class TraitItem */\n+    TRAIT_ITEM,\n+    /* class VisItem */\n+    VIS_ITEM,\n+    /* class Item */\n+    ITEM,\n+    /* class ImplItem */\n+    IMPL,\n+    /* class Type */\n+    TYPE,\n+    /* class Stmt */\n+    STMT,\n+    /* class Expr */\n+    EXPR,\n+    /* class Pattern */\n+    PATTERN,\n+  };\n+\n+  /**\n+   * Get the kind of HIR node we are dealing with. This is useful for\n+   * downcasting to more precise types when necessary, i.e going from an `Item*`\n+   * to a `VisItem*`\n+   */\n+  virtual BaseKind get_hir_kind () = 0;\n+};\n+\n+// A literal - value with a type. Used in LiteralExpr and LiteralPattern.\n+struct Literal\n+{\n+public:\n+  enum LitType\n+  {\n+    CHAR,\n+    STRING,\n+    BYTE,\n+    BYTE_STRING,\n+    INT,\n+    FLOAT,\n+    BOOL\n+  };\n+\n+private:\n+  std::string value_as_string;\n+  LitType type;\n+  PrimitiveCoreType type_hint;\n+\n+public:\n+  std::string as_string () const { return value_as_string; }\n+\n+  LitType get_lit_type () const { return type; }\n+\n+  PrimitiveCoreType get_type_hint () const { return type_hint; }\n+\n+  Literal (std::string value_as_string, LitType type,\n+\t   PrimitiveCoreType type_hint)\n+    : value_as_string (std::move (value_as_string)), type (type),\n+      type_hint (type_hint)\n+  {}\n+\n+  static Literal create_error ()\n+  {\n+    return Literal (\"\", CHAR, PrimitiveCoreType::CORETYPE_UNKNOWN);\n+  }\n+\n+  void set_lit_type (LitType lt) { type = lt; }\n+\n+  // Returns whether literal is in an invalid state.\n+  bool is_error () const { return value_as_string == \"\"; }\n+\n+  bool is_equal (Literal &other)\n+  {\n+    return value_as_string == other.value_as_string && type == other.type\n+\t   && type_hint == other.type_hint;\n+  }\n+};\n+\n+/* Base statement abstract class. Note that most \"statements\" are not allowed in\n+ * top-level module scope - only a subclass of statements called \"items\" are. */\n+class Stmt : public Node\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Stmt> clone_stmt () const\n+  {\n+    return std::unique_ptr<Stmt> (clone_stmt_impl ());\n+  }\n+\n+  BaseKind get_hir_kind () override { return STMT; }\n+\n+  virtual ~Stmt () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+  virtual void accept_vis (HIRStmtVisitor &vis) = 0;\n+\n+  virtual Location get_locus () const = 0;\n+\n+  virtual bool is_unit_check_needed () const { return false; }\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+\n+  virtual bool is_item () const = 0;\n+\n+protected:\n+  Stmt (Analysis::NodeMapping mappings) : mappings (std::move (mappings)) {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Stmt *clone_stmt_impl () const = 0;\n+\n+  Analysis::NodeMapping mappings;\n+};\n+\n+// Rust \"item\" HIR node (declaration of top-level/module-level allowed stuff)\n+class Item : public Stmt\n+{\n+  AST::AttrVec outer_attrs;\n+\n+  // TODO: should outer attrs be defined here or in each derived class?\n+\n+public:\n+  enum class ItemKind\n+  {\n+    Static,\n+    Constant,\n+    TypeAlias,\n+    Function,\n+    UseDeclaration,\n+    ExternBlock,\n+    ExternCrate,\n+    Struct,\n+    Union,\n+    Enum,\n+    EnumItem, // FIXME: ARTHUR: Do we need that?\n+    Trait,\n+    Impl,\n+    Module,\n+  };\n+\n+  virtual ItemKind get_item_kind () const = 0;\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Item> clone_item () const\n+  {\n+    return std::unique_ptr<Item> (clone_item_impl ());\n+  }\n+\n+  BaseKind get_hir_kind () override { return ITEM; }\n+\n+  std::string as_string () const override;\n+\n+  /* Adds crate names to the vector passed by reference, if it can\n+   * (polymorphism). */\n+  virtual void\n+  add_crate_name (std::vector<std::string> &names ATTRIBUTE_UNUSED) const\n+  {}\n+\n+  AST::AttrVec &get_outer_attrs () { return outer_attrs; }\n+  const AST::AttrVec &get_outer_attrs () const { return outer_attrs; }\n+\n+  bool is_item () const override final { return true; }\n+\n+protected:\n+  // Constructor\n+  Item (Analysis::NodeMapping mappings,\n+\tAST::AttrVec outer_attribs = AST::AttrVec ())\n+    : Stmt (std::move (mappings)), outer_attrs (std::move (outer_attribs))\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Item *clone_item_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making\n+   * statement clone return item clone. Hopefully won't affect performance too\n+   * much. */\n+  Item *clone_stmt_impl () const override { return clone_item_impl (); }\n+};\n+\n+// forward decl of ExprWithoutBlock\n+class ExprWithoutBlock;\n+\n+// Base expression HIR node - abstract\n+class Expr : public Node\n+{\n+  AST::AttrVec outer_attrs;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  enum BlockType\n+  {\n+    WITH_BLOCK,\n+    WITHOUT_BLOCK,\n+  };\n+\n+  enum ExprType\n+  {\n+    Lit,\n+    Operator,\n+    Grouped,\n+    Array,\n+    ArrayIndex,\n+    Tuple,\n+    TupleIdx,\n+    Struct,\n+    Call,\n+    MethodCall,\n+    FieldAccess,\n+    Closure,\n+    Block,\n+    Continue,\n+    Break,\n+    Range,\n+    Return,\n+    UnsafeBlock,\n+    BaseLoop,\n+    If,\n+    IfLet,\n+    Match,\n+    Await,\n+    AsyncBlock,\n+    Path,\n+  };\n+\n+  BaseKind get_hir_kind () override final { return EXPR; }\n+\n+  const AST::AttrVec &get_outer_attrs () const { return outer_attrs; }\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Expr> clone_expr () const\n+  {\n+    return std::unique_ptr<Expr> (clone_expr_impl ());\n+  }\n+\n+  /* HACK: downcasting without dynamic_cast (if possible) via polymorphism -\n+   * overrided in subclasses of ExprWithoutBlock */\n+  virtual ExprWithoutBlock *as_expr_without_block () const { return nullptr; }\n+\n+  // TODO: make pure virtual if move out outer attributes to derived classes\n+  virtual std::string as_string () const;\n+\n+  virtual ~Expr () {}\n+\n+  virtual Location get_locus () const = 0;\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Expr *clone_expr_impl () const = 0;\n+\n+  virtual BlockType get_block_expr_type () const = 0;\n+\n+  virtual ExprType get_expression_type () const = 0;\n+\n+  virtual void accept_vis (HIRExpressionVisitor &vis) = 0;\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+\n+protected:\n+  // Constructor\n+  Expr (Analysis::NodeMapping mappings,\n+\tAST::AttrVec outer_attribs = AST::AttrVec ())\n+    : outer_attrs (std::move (outer_attribs)), mappings (std::move (mappings))\n+  {}\n+\n+  // TODO: think of less hacky way to implement this kind of thing\n+  // Sets outer attributes.\n+  void set_outer_attrs (AST::AttrVec outer_attrs_to_set)\n+  {\n+    outer_attrs = std::move (outer_attrs_to_set);\n+  }\n+};\n+\n+// HIR node for an expression without an accompanying block - abstract\n+class ExprWithoutBlock : public Expr\n+{\n+protected:\n+  // Constructor\n+  ExprWithoutBlock (Analysis::NodeMapping mappings,\n+\t\t    AST::AttrVec outer_attribs = AST::AttrVec ())\n+    : Expr (std::move (mappings), std::move (outer_attribs))\n+  {}\n+\n+  // pure virtual clone implementation\n+  virtual ExprWithoutBlock *clone_expr_without_block_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making expr\n+   * clone return exprwithoutblock clone. Hopefully won't affect performance too\n+   * much. */\n+  ExprWithoutBlock *clone_expr_impl () const override\n+  {\n+    return clone_expr_without_block_impl ();\n+  }\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<ExprWithoutBlock> clone_expr_without_block () const\n+  {\n+    return std::unique_ptr<ExprWithoutBlock> (clone_expr_without_block_impl ());\n+  }\n+\n+  /* downcasting hack from expr to use pratt parsing with\n+   * parse_expr_without_block */\n+  ExprWithoutBlock *as_expr_without_block () const override\n+  {\n+    return clone_expr_without_block_impl ();\n+  }\n+\n+  BlockType get_block_expr_type () const final override\n+  {\n+    return BlockType::WITHOUT_BLOCK;\n+  };\n+};\n+\n+// Pattern base HIR node\n+class Pattern : public Node\n+{\n+public:\n+  enum PatternType\n+  {\n+    PATH,\n+    LITERAL,\n+    IDENTIFIER,\n+    WILDCARD,\n+    RANGE,\n+    REFERENCE,\n+    STRUCT,\n+    TUPLE_STRUCT,\n+    TUPLE,\n+    GROUPED,\n+    SLICE,\n+  };\n+\n+  BaseKind get_hir_kind () override final { return PATTERN; }\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Pattern> clone_pattern () const\n+  {\n+    return std::unique_ptr<Pattern> (clone_pattern_impl ());\n+  }\n+\n+  // possible virtual methods: is_refutable()\n+\n+  virtual ~Pattern () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+  virtual void accept_vis (HIRPatternVisitor &vis) = 0;\n+\n+  virtual Analysis::NodeMapping get_pattern_mappings () const = 0;\n+\n+  virtual Location get_locus () const = 0;\n+\n+  virtual PatternType get_pattern_type () const = 0;\n+\n+protected:\n+  // Clone pattern implementation as pure virtual method\n+  virtual Pattern *clone_pattern_impl () const = 0;\n+};\n+\n+// forward decl for Type\n+class TraitBound;\n+\n+// Base class for types as represented in HIR - abstract\n+class Type : public Node\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Type> clone_type () const\n+  {\n+    return std::unique_ptr<Type> (clone_type_impl ());\n+  }\n+\n+  // virtual destructor\n+  virtual ~Type () {}\n+\n+  BaseKind get_hir_kind () override final { return TYPE; }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  /* HACK: convert to trait bound. Virtual method overriden by classes that\n+   * enable this. */\n+  virtual TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const\n+  {\n+    return nullptr;\n+  }\n+  /* as pointer, shouldn't require definition beforehand, only forward\n+   * declaration. */\n+\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+  virtual void accept_vis (HIRTypeVisitor &vis) = 0;\n+\n+  virtual Analysis::NodeMapping get_mappings () const { return mappings; }\n+  virtual Location get_locus () const { return locus; }\n+\n+protected:\n+  Type (Analysis::NodeMapping mappings, Location locus)\n+    : mappings (mappings), locus (locus)\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Type *clone_type_impl () const = 0;\n+\n+  Analysis::NodeMapping mappings;\n+  Location locus;\n+};\n+\n+// A type without parentheses? - abstract\n+class TypeNoBounds : public Type\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypeNoBounds> clone_type_no_bounds () const\n+  {\n+    return std::unique_ptr<TypeNoBounds> (clone_type_no_bounds_impl ());\n+  }\n+\n+protected:\n+  TypeNoBounds (Analysis::NodeMapping mappings, Location locus)\n+    : Type (mappings, locus)\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual TypeNoBounds *clone_type_no_bounds_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making type\n+   * clone return typenobounds clone. Hopefully won't affect performance too\n+   * much. */\n+  TypeNoBounds *clone_type_impl () const override\n+  {\n+    return clone_type_no_bounds_impl ();\n+  }\n+};\n+\n+/* Abstract base class representing a type param bound - Lifetime and TraitBound\n+ * extends it */\n+class TypeParamBound\n+{\n+public:\n+  enum BoundType\n+  {\n+    LIFETIME,\n+    TRAITBOUND\n+  };\n+\n+  virtual ~TypeParamBound () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypeParamBound> clone_type_param_bound () const\n+  {\n+    return std::unique_ptr<TypeParamBound> (clone_type_param_bound_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+\n+  virtual Analysis::NodeMapping get_mappings () const = 0;\n+\n+  virtual Location get_locus () const = 0;\n+\n+  virtual BoundType get_bound_type () const = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual TypeParamBound *clone_type_param_bound_impl () const = 0;\n+};\n+\n+// Represents a lifetime (and is also a kind of type param bound)\n+class Lifetime : public TypeParamBound\n+{\n+private:\n+  AST::Lifetime::LifetimeType lifetime_type;\n+  std::string lifetime_name;\n+  Location locus;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  // Constructor\n+  Lifetime (Analysis::NodeMapping mapping, AST::Lifetime::LifetimeType type,\n+\t    std::string name, Location locus)\n+    : lifetime_type (type), lifetime_name (std::move (name)), locus (locus),\n+      mappings (mapping)\n+  {}\n+\n+  // Returns true if the lifetime is in an error state.\n+  bool is_error () const\n+  {\n+    return lifetime_type == AST::Lifetime::LifetimeType::NAMED\n+\t   && lifetime_name.empty ();\n+  }\n+\n+  static Lifetime error ()\n+  {\n+    return Lifetime (Analysis::NodeMapping::get_error (),\n+\t\t     AST::Lifetime::LifetimeType::NAMED, \"\", Location ());\n+  }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  std::string get_name () const { return lifetime_name; }\n+\n+  AST::Lifetime::LifetimeType get_lifetime_type () const\n+  {\n+    return lifetime_type;\n+  }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  Analysis::NodeMapping get_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  BoundType get_bound_type () const final override { return LIFETIME; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Lifetime *clone_type_param_bound_impl () const override\n+  {\n+    return new Lifetime (*this);\n+  }\n+};\n+\n+/* Base generic parameter in HIR. Abstract - can be represented by a Lifetime or\n+ * Type param */\n+class GenericParam\n+{\n+public:\n+  virtual ~GenericParam () {}\n+\n+  enum class GenericKind\n+  {\n+    TYPE,\n+    LIFETIME,\n+    CONST,\n+  };\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<GenericParam> clone_generic_param () const\n+  {\n+    return std::unique_ptr<GenericParam> (clone_generic_param_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+\n+  virtual Location get_locus () const = 0;\n+\n+  Analysis::NodeMapping get_mappings () const { return mappings; }\n+\n+  enum GenericKind get_kind () const { return kind; }\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual GenericParam *clone_generic_param_impl () const = 0;\n+\n+  Analysis::NodeMapping mappings;\n+\n+  enum GenericKind kind;\n+\n+  GenericParam (Analysis::NodeMapping mapping,\n+\t\tenum GenericKind kind = GenericKind::TYPE)\n+    : mappings (mapping), kind (kind)\n+  {}\n+};\n+\n+// A lifetime generic parameter (as opposed to a type generic parameter)\n+class LifetimeParam : public GenericParam\n+{\n+  Lifetime lifetime;\n+\n+  // bool has_lifetime_bounds;\n+  // LifetimeBounds lifetime_bounds;\n+  std::vector<Lifetime> lifetime_bounds; // inlined LifetimeBounds\n+\n+  // bool has_outer_attribute;\n+  // std::unique_ptr<Attribute> outer_attr;\n+  AST::Attribute outer_attr;\n+\n+  Location locus;\n+\n+public:\n+  Lifetime get_lifetime () { return lifetime; }\n+\n+  // Returns whether the lifetime param has any lifetime bounds.\n+  bool has_lifetime_bounds () const { return !lifetime_bounds.empty (); }\n+\n+  // Returns whether the lifetime param has an outer attribute.\n+  bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n+\n+  // Returns whether the lifetime param is in an error state.\n+  bool is_error () const { return lifetime.is_error (); }\n+\n+  // Constructor\n+  LifetimeParam (Analysis::NodeMapping mappings, Lifetime lifetime,\n+\t\t Location locus = Location (),\n+\t\t std::vector<Lifetime> lifetime_bounds\n+\t\t = std::vector<Lifetime> (),\n+\t\t AST::Attribute outer_attr = AST::Attribute::create_empty ())\n+    : GenericParam (mappings, GenericKind::LIFETIME),\n+      lifetime (std::move (lifetime)),\n+      lifetime_bounds (std::move (lifetime_bounds)),\n+      outer_attr (std::move (outer_attr)), locus (locus)\n+  {}\n+\n+  // TODO: remove copy and assignment operator definitions - not required\n+\n+  // Copy constructor with clone\n+  LifetimeParam (LifetimeParam const &other)\n+    : GenericParam (other.mappings, GenericKind::LIFETIME),\n+      lifetime (other.lifetime), lifetime_bounds (other.lifetime_bounds),\n+      outer_attr (other.outer_attr), locus (other.locus)\n+  {}\n+\n+  // Overloaded assignment operator to clone attribute\n+  LifetimeParam &operator= (LifetimeParam const &other)\n+  {\n+    lifetime = other.lifetime;\n+    lifetime_bounds = other.lifetime_bounds;\n+    outer_attr = other.outer_attr;\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  LifetimeParam (LifetimeParam &&other) = default;\n+  LifetimeParam &operator= (LifetimeParam &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  LifetimeParam *clone_generic_param_impl () const override\n+  {\n+    return new LifetimeParam (*this);\n+  }\n+};\n+\n+class ConstGenericParam : public GenericParam\n+{\n+public:\n+  ConstGenericParam (std::string name, std::unique_ptr<Type> type,\n+\t\t     std::unique_ptr<Expr> default_expression,\n+\t\t     Analysis::NodeMapping mapping, Location locus)\n+    : GenericParam (mapping, GenericKind::CONST), name (std::move (name)),\n+      type (std::move (type)),\n+      default_expression (std::move (default_expression)), locus (locus)\n+  {}\n+\n+  ConstGenericParam (const ConstGenericParam &other) : GenericParam (other)\n+  {\n+    name = other.name;\n+    locus = other.locus;\n+\n+    if (other.type)\n+      type = other.type->clone_type ();\n+    if (other.default_expression)\n+      default_expression = other.default_expression->clone_expr ();\n+  }\n+\n+  std::string as_string () const override final;\n+\n+  void accept_vis (HIRFullVisitor &vis) override final;\n+\n+  Location get_locus () const override final { return locus; };\n+\n+  bool has_default_expression () { return default_expression != nullptr; }\n+\n+  std::unique_ptr<Type> &get_type () { return type; }\n+  std::unique_ptr<Expr> &get_default_expression ()\n+  {\n+    rust_assert (has_default_expression ());\n+\n+    return default_expression;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConstGenericParam *clone_generic_param_impl () const override\n+  {\n+    return new ConstGenericParam (*this);\n+  }\n+\n+private:\n+  std::string name;\n+  std::unique_ptr<Type> type;\n+\n+  /* Optional - can be a null pointer if there is no default expression */\n+  std::unique_ptr<Expr> default_expression;\n+\n+  Location locus;\n+};\n+\n+// Item used in trait declarations - abstract base class\n+class TraitItem : public Node\n+{\n+public:\n+  enum TraitItemKind\n+  {\n+    FUNC,\n+    CONST,\n+    TYPE\n+  };\n+\n+  BaseKind get_hir_kind () override final { return TRAIT_ITEM; }\n+\n+protected:\n+  // Constructor\n+  TraitItem (Analysis::NodeMapping mappings) : mappings (mappings) {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual TraitItem *clone_trait_item_impl () const = 0;\n+\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  virtual ~TraitItem () {}\n+\n+  std::unique_ptr<TraitItem> clone_trait_item () const\n+  {\n+    return std::unique_ptr<TraitItem> (clone_trait_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRTraitItemVisitor &vis) = 0;\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+\n+  virtual const std::string trait_identifier () const = 0;\n+\n+  const Analysis::NodeMapping get_mappings () const { return mappings; }\n+\n+  virtual TraitItemKind get_item_kind () const = 0;\n+\n+  virtual AST::AttrVec &get_outer_attrs () = 0;\n+  virtual const AST::AttrVec &get_outer_attrs () const = 0;\n+};\n+\n+class ImplItem : public Node\n+{\n+public:\n+  enum ImplItemType\n+  {\n+    FUNCTION,\n+    TYPE_ALIAS,\n+    CONSTANT\n+  };\n+\n+  virtual ~ImplItem () {}\n+\n+  BaseKind get_hir_kind () override final { return IMPL; }\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<ImplItem> clone_inherent_impl_item () const\n+  {\n+    return std::unique_ptr<ImplItem> (clone_inherent_impl_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRImplVisitor &vis) = 0;\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+  virtual void accept_vis (HIRStmtVisitor &vis) = 0;\n+\n+  virtual Analysis::NodeMapping get_impl_mappings () const = 0;\n+\n+  virtual Location get_locus () const = 0;\n+\n+  virtual ImplItemType get_impl_item_type () const = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual ImplItem *clone_inherent_impl_item_impl () const = 0;\n+};\n+\n+// A crate HIR object - holds all the data for a single compilation unit\n+struct Crate\n+{\n+  AST::AttrVec inner_attrs;\n+  // dodgy spacing required here\n+  /* TODO: is it better to have a vector of items here or a module (implicit\n+   * top-level one)? */\n+  std::vector<std::unique_ptr<Item> > items;\n+\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  // Constructor\n+  Crate (std::vector<std::unique_ptr<Item> > items, AST::AttrVec inner_attrs,\n+\t Analysis::NodeMapping mappings)\n+    : inner_attrs (std::move (inner_attrs)), items (std::move (items)),\n+      mappings (mappings)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  Crate (Crate const &other)\n+    : inner_attrs (other.inner_attrs), mappings (other.mappings)\n+  {\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_item ());\n+  }\n+\n+  ~Crate () = default;\n+\n+  // Overloaded assignment operator with vector clone\n+  Crate &operator= (Crate const &other)\n+  {\n+    inner_attrs = other.inner_attrs;\n+    mappings = other.mappings;\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_item ());\n+\n+    return *this;\n+  }\n+\n+  // Move constructors\n+  Crate (Crate &&other) = default;\n+  Crate &operator= (Crate &&other) = default;\n+\n+  // Get crate representation as string (e.g. for debugging).\n+  std::string as_string () const;\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+};\n+\n+// Base path expression HIR node - abstract\n+class PathExpr : public ExprWithoutBlock\n+{\n+protected:\n+  PathExpr (Analysis::NodeMapping mappings, AST::AttrVec outer_attribs)\n+    : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs))\n+  {}\n+\n+public:\n+  /* Replaces the outer attributes of this path expression with the given outer\n+   * attributes. */\n+  void replace_outer_attrs (AST::AttrVec outer_attrs)\n+  {\n+    set_outer_attrs (std::move (outer_attrs));\n+  }\n+\n+  ExprType get_expression_type () const final override\n+  {\n+    return ExprType::Path;\n+  }\n+};\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}]}