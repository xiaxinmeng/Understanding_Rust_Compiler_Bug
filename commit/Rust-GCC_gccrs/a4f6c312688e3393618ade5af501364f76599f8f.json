{"sha": "a4f6c312688e3393618ade5af501364f76599f8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRmNmMzMTI2ODhlMzM5MzYxOGFkZTVhZjUwMTM2NGY3NjU5OWY4Zg==", "commit": {"author": {"name": "Stan Shebs", "email": "shebs@apple.com", "date": "2001-10-17T18:08:39Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2001-10-17T18:08:39Z"}, "message": "rs6000.c: Make assorted mechanical formatting and typo fixes throughout.\n\n        * config/rs6000/rs6000.c: Make assorted mechanical formatting and\n        typo fixes throughout.\n        (machopic_output_stub): Remove some dead code.\n\nFrom-SVN: r46320", "tree": {"sha": "c3bf61fdbba80d807a4a624137f253792a026574", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3bf61fdbba80d807a4a624137f253792a026574"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4f6c312688e3393618ade5af501364f76599f8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f6c312688e3393618ade5af501364f76599f8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4f6c312688e3393618ade5af501364f76599f8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f6c312688e3393618ade5af501364f76599f8f/comments", "author": null, "committer": null, "parents": [{"sha": "b011ef316bb13d0319ede7f6e0be6301e619f1f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b011ef316bb13d0319ede7f6e0be6301e619f1f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b011ef316bb13d0319ede7f6e0be6301e619f1f9"}], "stats": {"total": 569, "additions": 295, "deletions": 274}, "files": [{"sha": "7da1ad87ce758c350a8f85509cd84c8befd40a23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f6c312688e3393618ade5af501364f76599f8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f6c312688e3393618ade5af501364f76599f8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4f6c312688e3393618ade5af501364f76599f8f", "patch": "@@ -1,3 +1,9 @@\n+2001-10-17  Stan Shebs  <shebs@apple.com>\n+\n+\t* config/rs6000/rs6000.c: Make assorted mechanical formatting and\n+\ttypo fixes throughout.\n+\t(machopic_output_stub): Remove some dead code.\n+\n 2001-10-17  Richard Earnshaw <rearnsha@arm.com>\n \n \t* cpplex.c (_cpp_get_buff): Fix off-by-one error that caused memory"}, {"sha": "a55459edf0203e127038e26b879dfb4e313f2e6e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 289, "deletions": 274, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f6c312688e3393618ade5af501364f76599f8f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f6c312688e3393618ade5af501364f76599f8f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a4f6c312688e3393618ade5af501364f76599f8f", "patch": "@@ -309,12 +309,12 @@ rs6000_override_options (default_cpu)\n \t {\"750\", PROCESSOR_PPC750,\n  \t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n  \t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n-       {\"7400\", PROCESSOR_PPC7400,\n-          MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-          POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n-       {\"7450\", PROCESSOR_PPC7450,\n-          MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n-          POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t {\"7400\", PROCESSOR_PPC7400,\n+            MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n+            POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t {\"7450\", PROCESSOR_PPC7450,\n+            MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n+            POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n \t {\"801\", PROCESSOR_MPCCORE,\n \t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS,\n \t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n@@ -330,12 +330,14 @@ rs6000_override_options (default_cpu)\n \n   size_t ptt_size = sizeof (processor_target_table) / sizeof (struct ptt);\n \n-  int multiple = TARGET_MULTIPLE;\t/* save current -mmultiple/-mno-multiple status */\n-  int string   = TARGET_STRING;\t\t/* save current -mstring/-mno-string status */\n+  /* Save current -mmultiple/-mno-multiple status.  */\n+  int multiple = TARGET_MULTIPLE;\n+  /* Save current -mstring/-mno-string status.  */\n+  int string = TARGET_STRING;\n \n   profile_block_flag = 0;\n \n-  /* Identify the processor type */\n+  /* Identify the processor type.  */\n   rs6000_select[0].string = default_cpu;\n   rs6000_cpu = TARGET_POWERPC64 ? PROCESSOR_DEFAULT64 : PROCESSOR_DEFAULT;\n \n@@ -363,8 +365,8 @@ rs6000_override_options (default_cpu)\n \t}\n     }\n \n-  /* If we are optimizing big endian systems for space, use the\n-     store multiple instructions.  */\n+  /* If we are optimizing big endian systems for space, use the store\n+     multiple instructions.  */\n   if (BYTES_BIG_ENDIAN && optimize_size)\n     target_flags |= MASK_MULTIPLE;\n \n@@ -373,15 +375,16 @@ rs6000_override_options (default_cpu)\n   if (TARGET_MULTIPLE_SET)\n     target_flags = (target_flags & ~MASK_MULTIPLE) | multiple;\n \n-  /* If -mstring or -mno-string was explicitly used, don't\n-     override with the processor default */\n+  /* If -mstring or -mno-string was explicitly used, don't override\n+     with the processor default.  */\n   if (TARGET_STRING_SET)\n     target_flags = (target_flags & ~MASK_STRING) | string;\n \n-  /* Don't allow -mmultiple or -mstring on little endian systems unless the cpu\n-     is a 750, because the hardware doesn't support the instructions used in\n-     little endian mode, and causes an alignment trap.  The 750 does not cause\n-     an alignment trap (except when the target is unaligned).  */\n+  /* Don't allow -mmultiple or -mstring on little endian systems\n+     unless the cpu is a 750, because the hardware doesn't support the\n+     instructions used in little endian mode, and causes an alignment\n+     trap.  The 750 does not cause an alignment trap (except when the\n+     target is unaligned).  */\n \n   if (! BYTES_BIG_ENDIAN && rs6000_cpu != PROCESSOR_PPC750)\n     {\n@@ -436,8 +439,8 @@ rs6000_override_options (default_cpu)\n     }\n \n #ifdef TARGET_REGNAMES\n-  /* If the user desires alternate register names, copy in the alternate names\n-     now.  */\n+  /* If the user desires alternate register names, copy in the\n+     alternate names now.  */\n   if (TARGET_REGNAMES)\n     memcpy (rs6000_reg_names, alt_reg_names, sizeof (rs6000_reg_names));\n #endif\n@@ -558,9 +561,9 @@ any_operand (op, mode)\n   return 1;\n }\n \n-/* Returns 1 if op is the count register */\n+/* Returns 1 if op is the count register.  */\n int\n-count_register_operand(op, mode)\n+count_register_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n@@ -577,7 +580,7 @@ count_register_operand(op, mode)\n }\n \n int\n-xer_operand(op, mode)\n+xer_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n@@ -679,9 +682,9 @@ cc_reg_not_cr0_operand (op, mode)\n \t      || CR_REGNO_NOT_CR0_P (REGNO (op))));\n }\n \n-/* Returns 1 if OP is either a constant integer valid for a D-field or a\n-   non-special register.  If a register, it must be in the proper mode unless\n-   MODE is VOIDmode.  */\n+/* Returns 1 if OP is either a constant integer valid for a D-field or\n+   a non-special register.  If a register, it must be in the proper\n+   mode unless MODE is VOIDmode.  */\n \n int\n reg_or_short_operand (op, mode)\n@@ -691,8 +694,8 @@ reg_or_short_operand (op, mode)\n   return short_cint_operand (op, mode) || gpc_reg_operand (op, mode);\n }\n \n-/* Similar, except check if the negation of the constant would be valid for\n-   a D-field.  */\n+/* Similar, except check if the negation of the constant would be\n+   valid for a D-field.  */\n \n int\n reg_or_neg_short_operand (op, mode)\n@@ -705,8 +708,8 @@ reg_or_neg_short_operand (op, mode)\n   return gpc_reg_operand (op, mode);\n }\n \n-/* Return 1 if the operand is either a register or an integer whose high-order\n-   16 bits are zero.  */\n+/* Return 1 if the operand is either a register or an integer whose\n+   high-order 16 bits are zero.  */\n \n int\n reg_or_u_short_operand (op, mode)\n@@ -724,7 +727,7 @@ reg_or_cint_operand (op, mode)\n     rtx op;\n     enum machine_mode mode;\n {\n-     return (GET_CODE (op) == CONST_INT || gpc_reg_operand (op, mode));\n+  return (GET_CODE (op) == CONST_INT || gpc_reg_operand (op, mode));\n }\n \n /* Return 1 is the operand is either a non-special register or ANY\n@@ -735,13 +738,13 @@ reg_or_arith_cint_operand (op, mode)\n     rtx op;\n     enum machine_mode mode;\n {\n-     return (gpc_reg_operand (op, mode)\n-\t     || (GET_CODE (op) == CONST_INT\n+  return (gpc_reg_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n #if HOST_BITS_PER_WIDE_INT != 32\n-\t\t && ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80000000)\n-\t\t     < (unsigned HOST_WIDE_INT) 0x100000000ll)\n+\t      && ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80000000)\n+\t\t  < (unsigned HOST_WIDE_INT) 0x100000000ll)\n #endif\n-\t\t ));\n+\t      ));\n }\n \n /* Return 1 is the operand is either a non-special register or a 32-bit\n@@ -752,14 +755,14 @@ reg_or_add_cint64_operand (op, mode)\n     rtx op;\n     enum machine_mode mode;\n {\n-     return (gpc_reg_operand (op, mode)\n-\t     || (GET_CODE (op) == CONST_INT\n-\t\t && INTVAL (op) < 0x7fff8000\n+  return (gpc_reg_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && INTVAL (op) < 0x7fff8000\n #if HOST_BITS_PER_WIDE_INT != 32\n-\t\t && ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80008000)\n-\t\t     < 0x100000000ll)\n+\t      && ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80008000)\n+\t\t  < 0x100000000ll)\n #endif\n-\t\t ));\n+\t      ));\n }\n \n /* Return 1 is the operand is either a non-special register or a 32-bit\n@@ -770,14 +773,14 @@ reg_or_sub_cint64_operand (op, mode)\n     rtx op;\n     enum machine_mode mode;\n {\n-     return (gpc_reg_operand (op, mode)\n-\t     || (GET_CODE (op) == CONST_INT\n-\t\t && (- INTVAL (op)) < 0x7fff8000\n+  return (gpc_reg_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && (- INTVAL (op)) < 0x7fff8000\n #if HOST_BITS_PER_WIDE_INT != 32\n-\t\t && ((unsigned HOST_WIDE_INT) ((- INTVAL (op)) + 0x80008000)\n-\t\t     < 0x100000000ll)\n+\t      && ((unsigned HOST_WIDE_INT) ((- INTVAL (op)) + 0x80008000)\n+\t\t  < 0x100000000ll)\n #endif\n-\t\t ));\n+\t      ));\n }\n \n /* Return 1 is the operand is either a non-special register or ANY\n@@ -793,7 +796,7 @@ reg_or_logical_cint_operand (op, mode)\n       if (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT)\n \t{\n \t  if (GET_MODE_BITSIZE (mode) <= 32)\n-\t    abort();\n+\t    abort ();\n \n \t  if (INTVAL (op) < 0)\n \t    return 0;\n@@ -806,7 +809,7 @@ reg_or_logical_cint_operand (op, mode)\n     {\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  || mode != DImode)\n-\tabort();\n+\tabort ();\n \n       return CONST_DOUBLE_HIGH (op) == 0;\n     }\n@@ -954,9 +957,9 @@ num_insns_constant (op, mode)\n     abort ();\n }\n \n-/* Return 1 if the operand is a CONST_DOUBLE and it can be put into a register\n-   with one instruction per word.  We only do this if we can safely read\n-   CONST_DOUBLE_{LOW,HIGH}.  */\n+/* Return 1 if the operand is a CONST_DOUBLE and it can be put into a\n+   register with one instruction per word.  We only do this if we can\n+   safely read CONST_DOUBLE_{LOW,HIGH}.  */\n \n int\n easy_fp_constant (op, mode)\n@@ -968,16 +971,17 @@ easy_fp_constant (op, mode)\n       || (GET_MODE_CLASS (mode) != MODE_FLOAT && mode != DImode))\n     return 0;\n \n-  /* Consider all constants with -msoft-float to be easy */\n+  /* Consider all constants with -msoft-float to be easy.  */\n   if (TARGET_SOFT_FLOAT && mode != DImode)\n     return 1;\n \n-  /* If we are using V.4 style PIC, consider all constants to be hard */\n+  /* If we are using V.4 style PIC, consider all constants to be hard.  */\n   if (flag_pic && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS))\n     return 0;\n \n #ifdef TARGET_RELOCATABLE\n-  /* Similarly if we are using -mrelocatable, consider all constants to be hard */\n+  /* Similarly if we are using -mrelocatable, consider all constants\n+     to be hard.  */\n   if (TARGET_RELOCATABLE)\n     return 0;\n #endif\n@@ -1025,8 +1029,8 @@ zero_fp_constant (op, mode)\n   return GET_MODE_CLASS (mode) == MODE_FLOAT && op == CONST0_RTX (mode);\n }\n \n-/* Return 1 if the operand is in volatile memory.  Note that during the\n-   RTL generation phase, memory_operand does not return TRUE for\n+/* Return 1 if the operand is in volatile memory.  Note that during\n+   the RTL generation phase, memory_operand does not return TRUE for\n    volatile memory references.  So this function allows us to\n    recognize volatile references where its safe.  */\n \n@@ -1265,7 +1269,7 @@ and64_operand (op, mode)\n     rtx op;\n     enum machine_mode mode;\n {\n-  if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis. */\n+  if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis.  */\n     return (gpc_reg_operand (op, mode) || mask64_operand (op, mode));\n \n   return (logical_operand (op, mode) || mask64_operand (op, mode));\n@@ -1279,7 +1283,7 @@ and_operand (op, mode)\n     rtx op;\n     enum machine_mode mode;\n {\n-  if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis. */\n+  if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis.  */\n     return (gpc_reg_operand (op, mode) || mask_operand (op, mode));\n \n   return (logical_operand (op, mode) || mask_operand (op, mode));\n@@ -1336,9 +1340,8 @@ call_operand (op, mode)\n \t  || (GET_CODE (op) == REG && REGNO (op) >= FIRST_PSEUDO_REGISTER));\n }\n \n-\n /* Return 1 if the operand is a SYMBOL_REF for a function known to be in\n-   this file and the function is not weakly defined. */\n+   this file and the function is not weakly defined.  */\n \n int\n current_file_function_operand (op, mode)\n@@ -1351,7 +1354,6 @@ current_file_function_operand (op, mode)\n \t          && ! DECL_WEAK (current_function_decl))));\n }\n \n-\n /* Return 1 if this operand is a valid input for a move insn.  */\n \n int\n@@ -1409,7 +1411,7 @@ input_operand (op, mode)\n   return 0;\n }\n \n-/* Return 1 for an operand in small memory on V.4/eabi */\n+/* Return 1 for an operand in small memory on V.4/eabi.  */\n \n int\n small_data_operand (op, mode)\n@@ -1467,33 +1469,33 @@ constant_pool_expr_1 (op, have_sym, have_toc)\n   switch (GET_CODE(op)) \n     {\n     case SYMBOL_REF:\n-\tif (CONSTANT_POOL_ADDRESS_P (op))\n-\t  {\n-\t   if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (op), Pmode))\n-\t     {\n-\t       *have_sym = 1;\n-\t       return 1;\n-\t     }\n-\t   else\n-\t     return 0;\n-\t  }\n-\telse if (! strcmp (XSTR (op, 0), toc_label_name))\n-\t  {\n-\t    *have_toc = 1;\n-\t    return 1;\n-\t  }\n-\telse\n-\t  return 0;\n+      if (CONSTANT_POOL_ADDRESS_P (op))\n+\t{\n+\t  if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (op), Pmode))\n+\t    {\n+\t      *have_sym = 1;\n+\t      return 1;\n+\t    }\n+\t  else\n+\t    return 0;\n+\t}\n+      else if (! strcmp (XSTR (op, 0), toc_label_name))\n+\t{\n+\t  *have_toc = 1;\n+\t  return 1;\n+\t}\n+      else\n+\treturn 0;\n     case PLUS:\n     case MINUS:\n-\treturn constant_pool_expr_1 (XEXP (op, 0), have_sym, have_toc) &&\n-\t    \tconstant_pool_expr_1 (XEXP (op, 1), have_sym, have_toc);\n+      return constant_pool_expr_1 (XEXP (op, 0), have_sym, have_toc) &&\n+\tconstant_pool_expr_1 (XEXP (op, 1), have_sym, have_toc);\n     case CONST:\n-\treturn constant_pool_expr_1 (XEXP (op, 0), have_sym, have_toc);\n+      return constant_pool_expr_1 (XEXP (op, 0), have_sym, have_toc);\n     case CONST_INT:\n-\treturn 1;\n+      return 1;\n     default:\n-\treturn 0;\n+      return 0;\n     }\n }\n \n@@ -1519,13 +1521,14 @@ toc_relative_expr_p (op)\n    to be legitimate.  If we find one, return the new, valid address.\n    This is used from only one place: `memory_address' in explow.c.\n \n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n+   OLDX is the address as it was before break_out_memory_refs was\n+   called.  In some cases it is useful to look at this to decide what\n+   needs to be done.\n \n-   MODE is passed so that this macro can use GO_IF_LEGITIMATE_ADDRESS.\n+   MODE is passed so that this function can use GO_IF_LEGITIMATE_ADDRESS.\n \n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n+   It is always safe for this function to do nothing.  It exists to\n+   recognize opportunities to optimize the output.\n \n    On RS/6000, first check for the sum of a register with a constant\n    integer that is out of range.  If so, generate code to add the\n@@ -1654,11 +1657,11 @@ rs6000_legitimate_address (mode, x, reg_ok_strict)\n   return 0;\n }\n \f\n-/* Try to output insns to set TARGET equal to the constant C if it can be\n-   done in less than N insns.  Do all computations in MODE.  Returns the place\n-   where the output has been placed if it can be done and the insns have been\n-   emitted.  If it would take more than N insns, zero is returned and no\n-   insns and emitted.  */\n+/* Try to output insns to set TARGET equal to the constant C if it can\n+   be done in less than N insns.  Do all computations in MODE.\n+   Returns the place where the output has been placed if it can be\n+   done and the insns have been emitted.  If it would take more than N\n+   insns, zero is returned and no insns and emitted.  */\n \n rtx\n rs6000_emit_set_const (dest, mode, source, n)\n@@ -1692,7 +1695,7 @@ rs6000_emit_set_const (dest, mode, source, n)\n #endif\n     }\n   else\n-    abort();\n+    abort ();\n \n   return rs6000_emit_set_long_const (dest, c0, c1);\n }\n@@ -1961,7 +1964,7 @@ rs6000_emit_move (dest, source, mode)\n \n \t      operands[1] =\n \t\trs6000_machopic_legitimize_pic_address (operands[1], mode,\n-\t\t\t\t\t\t\t\t    temp_reg);\n+\t\t\t\t\t\t\ttemp_reg);\n #endif\n \t      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n \t      return;\n@@ -1979,7 +1982,8 @@ rs6000_emit_move (dest, source, mode)\n \t\t  || GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF)\n \t      && ! side_effects_p (operands[0]))\n \t    {\n-\t      rtx sym = force_const_mem (mode, XEXP (XEXP (operands[1], 0), 0));\n+\t      rtx sym =\n+\t\tforce_const_mem (mode, XEXP (XEXP (operands[1], 0), 0));\n \t      rtx other = XEXP (XEXP (operands[1], 0), 1);\n \n \t      sym = force_reg (mode, sym);\n@@ -2214,6 +2218,7 @@ function_arg_advance (cum, mode, type, named)\n     {\n       int align = (TARGET_32BIT && (cum->words & 1) != 0\n \t\t   && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n+\n       cum->words += align + RS6000_ARG_SIZE (mode, type);\n \n       if (GET_MODE_CLASS (mode) == MODE_FLOAT && TARGET_HARD_FLOAT)\n@@ -2262,10 +2267,10 @@ function_arg (cum, mode, type, named)\n {\n   enum rs6000_abi abi = DEFAULT_ABI;\n \n-  /* Return a marker to indicate whether CR1 needs to set or clear the bit\n-     that V.4 uses to say fp args were passed in registers.  Assume that we\n-     don't need the marker for software floating point, or compiler generated\n-     library calls.  */\n+  /* Return a marker to indicate whether CR1 needs to set or clear the\n+     bit that V.4 uses to say fp args were passed in registers.\n+     Assume that we don't need the marker for software floating point,\n+     or compiler generated library calls.  */\n   if (mode == VOIDmode)\n     {\n       if ((abi == ABI_V4 || abi == ABI_SOLARIS)\n@@ -2746,9 +2751,7 @@ rs6000_va_arg (valist, type)\n       sav_scale = 4;\n     }\n \n-  /*\n-   * Pull the value out of the saved registers ...\n-   */\n+  /* Pull the value out of the saved registers ...  */\n \n   lab_false = gen_label_rtx ();\n   lab_over = gen_label_rtx ();\n@@ -2794,9 +2797,7 @@ rs6000_va_arg (valist, type)\n   emit_barrier ();\n   emit_label (lab_false);\n \n-  /*\n-   * ... otherwise out of the overflow area.\n-   */\n+  /* ... otherwise out of the overflow area.  */\n \n   /* Make sure we don't find reg 7 for the next int arg.  */\n   if (n_reg > 1)\n@@ -2986,8 +2987,9 @@ expand_block_move (operands)\n \t\t\t\t\t    align_rtx));\n \t    }\n \t  else if (bytes >= 8 && TARGET_POWERPC64\n-\t      /* 64-bit loads and stores require word-aligned displacements. */\n-\t      && (align >= 8 || (! STRICT_ALIGNMENT && align >= 4)))\n+\t\t   /* 64-bit loads and stores require word-aligned\n+                      displacements. */\n+\t\t   && (align >= 8 || (! STRICT_ALIGNMENT && align >= 4)))\n \t    {\n \t      move_bytes = 8;\n \t      tmp_reg = gen_reg_rtx (DImode);\n@@ -3096,7 +3098,8 @@ expand_block_move (operands)\n \t  /* Generate the appropriate load and store, saving the stores\n \t     for later.  */\n \t  if (bytes >= 8 && TARGET_POWERPC64\n-\t      /* 64-bit loads and stores require word-aligned displacements. */\n+\t      /* 64-bit loads and stores require word-aligned\n+                 displacements.  */\n \t      && (align >= 8 || (! STRICT_ALIGNMENT && align >= 4)))\n \t    {\n \t      move_bytes = 8;\n@@ -3147,7 +3150,7 @@ expand_block_move (operands)\n \t      stores[num_reg++] = gen_movqi (expand_block_move_mem (QImode,\n \t\t\t\t\t\t\t\t    dest_addr,\n \t\t\t\t\t\t\t\t    orig_dest),\n-\t\t\t\t\t       tmp_reg);\n+\t\t\t\t\t     tmp_reg);\n \t    }\n \n \t  if (num_reg >= MAX_MOVE_REG)\n@@ -3252,7 +3255,7 @@ store_multiple_operation (op, mode)\n   return 1;\n }\n \n-/* Return 1 for an PARALLEL suitable for mtcrf. */\n+/* Return 1 for an PARALLEL suitable for mtcrf.  */\n \n int\n mtcrf_operation (op, mode)\n@@ -3301,7 +3304,7 @@ mtcrf_operation (op, mode)\n   return 1;\n }\n \n-/* Return 1 for an PARALLEL suitable for lmw. */\n+/* Return 1 for an PARALLEL suitable for lmw.  */\n \n int\n lmw_operation (op, mode)\n@@ -3379,7 +3382,7 @@ lmw_operation (op, mode)\n   return 1;\n }\n \n-/* Return 1 for an PARALLEL suitable for stmw. */\n+/* Return 1 for an PARALLEL suitable for stmw.  */\n \n int\n stmw_operation (op, mode)\n@@ -3457,10 +3460,10 @@ stmw_operation (op, mode)\n   return 1;\n }\n \f\n+/* A validation routine: say whether CODE, a condition code, and MODE\n+   match.  The other alternatives either don't make sense or should\n+   never be generated.  */\n \n-/* A validation routine:  say whether CODE, a condition code,\n-   and MODE match.  The other alternatives either don't make\n-   sense or should never be generated.  */\n static void\n validate_condition_mode (code, mode)\n      enum rtx_code code;\n@@ -3484,7 +3487,7 @@ validate_condition_mode (code, mode)\n \t  || code == UNEQ || code == LTGT\n \t  || code == UNGT || code == UNLT\n \t  || code == UNGE || code == UNLE))\n-    abort();\n+    abort ();\n   \n   /* These should never be generated except for \n      flag_unsafe_math_optimizations.  */\n@@ -3544,7 +3547,6 @@ branch_positive_comparison_operator (op, mode)\n \t  || code == UNORDERED);\n }\n \n-\n /* Return 1 if OP is a comparison operation that is valid for an scc insn.\n    We check the opcode against the mode of the CC value and disallow EQ or\n    NE comparisons for integers.  */\n@@ -3758,7 +3760,7 @@ includes_rldicr_lshift_p (shiftop, andop)\n       lsb = c & -c;\n \n       /* It must be covered by the shift mask.\n-\t This test also rejects c == 0. */\n+\t This test also rejects c == 0.  */\n       if ((lsb & shift_mask) == 0)\n \treturn 0;\n \n@@ -3826,8 +3828,9 @@ registers_ok_for_quad_peep (reg1, reg2)\n   return (REGNO (reg1) == REGNO (reg2) - 1);\n }\n \n-/* Return 1 if addr1 and addr2 are suitable for lfq or stfq insn.  addr1 and\n-   addr2 must be in consecutive memory locations (addr2 == addr1 + 8).  */\n+/* Return 1 if addr1 and addr2 are suitable for lfq or stfq insn.\n+   addr1 and addr2 must be in consecutive memory locations\n+   (addr2 == addr1 + 8).  */\n \n int\n addrs_ok_for_quad_peep (addr1, addr2)\n@@ -4016,9 +4019,9 @@ struct rtx_def *\n rs6000_got_register (value)\n      rtx value ATTRIBUTE_UNUSED;\n {\n-  /* The second flow pass currently (June 1999) can't update regs_ever_live\n-     without disturbing other parts of the compiler, so update it here to\n-     make the prolog/epilogue code happy. */\n+  /* The second flow pass currently (June 1999) can't update\n+     regs_ever_live without disturbing other parts of the compiler, so\n+     update it here to make the prolog/epilogue code happy.  */\n   if (no_new_pseudos && ! regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \n@@ -4187,17 +4190,17 @@ print_operand (file, x, code)\n       return;\n \n     case 'h':\n-      /* If constant, output low-order five bits.  Otherwise,\n-\t write normally. */\n+      /* If constant, output low-order five bits.  Otherwise, write\n+\t normally.  */\n       if (INT_P (x))\n \tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 31);\n       else\n \tprint_operand (file, x, 0);\n       return;\n \n     case 'H':\n-      /* If constant, output low-order six bits.  Otherwise,\n-\t write normally. */\n+      /* If constant, output low-order six bits.  Otherwise, write\n+\t normally.  */\n       if (INT_P (x))\n \tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 63);\n       else\n@@ -4388,7 +4391,7 @@ print_operand (file, x, code)\n \n     case 'P':\n       /* The operand must be an indirect memory reference.  The result\n-\t is the register number. */\n+\t is the register number.  */\n       if (GET_CODE (x) != MEM || GET_CODE (XEXP (x, 0)) != REG\n \t  || REGNO (XEXP (x, 0)) >= 32)\n \toutput_operand_lossage (\"invalid %%P value\");\n@@ -4627,7 +4630,7 @@ print_operand (file, x, code)\n \t  val = CONST_DOUBLE_LOW (x);\n \n \t  if (val == 0)\n-\t    abort();\n+\t    abort ();\n \t  else if (val < 0)\n \t    --i;\n \t  else\n@@ -4756,7 +4759,7 @@ print_operand_address (file, x)\n \tfprintf (file, \"@%s(%s)\", SMALL_DATA_RELOC,\n \t\t reg_names[SMALL_DATA_REG]);\n       else if (TARGET_TOC)\n-\tabort();\n+\tabort ();\n     }\n   else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == REG)\n     {\n@@ -4789,7 +4792,7 @@ print_operand_address (file, x)\n \t  const char *name;\n \t  \n \t  /* Find the (minus (sym) (toc)) buried in X, and temporarily\n-\t     turn it into (sym) for output_addr_const. */\n+\t     turn it into (sym) for output_addr_const.  */\n \t  while (GET_CODE (XEXP (contains_minus, 0)) != MINUS)\n \t    contains_minus = XEXP (contains_minus, 0);\n \n@@ -4833,9 +4836,9 @@ rs6000_reverse_condition (mode, code)\n     return reverse_condition (code);\n }\n \n-\n /* Generate a compare for CODE.  Return a brand-new rtx that\n    represents the result of the compare.  */\n+\n static rtx\n rs6000_generate_compare (code)\n      enum rtx_code code;\n@@ -4927,7 +4930,6 @@ rs6000_emit_sCOND (code, result)\n     }\n }\n \n-\n /* Emit a branch of kind CODE to location LOC.  */\n \n void\n@@ -4944,7 +4946,6 @@ rs6000_emit_cbranch (code, loc)\n \t\t\t\t\t\t     loc_ref, pc_rtx)));\n }\n \n-\n /* Return the string to output a conditional branch to LABEL, which is\n    the operand number of the label, or -1 if the branch is really a\n    conditional return.  \n@@ -5005,7 +5006,7 @@ output_cbranch (op, label, reversed, insn)\n     case UNGE: ccode = \"nl\"; break;\n     case UNLE: ccode = \"ng\"; break;\n     default:\n-      abort();\n+      abort ();\n     }\n   \n   /* Maybe we have a guess as to how likely the branch is.  \n@@ -5053,6 +5054,7 @@ output_cbranch (op, label, reversed, insn)\n /* Emit a conditional move: move TRUE_COND to DEST if OP of the\n    operands of the last comparison is nonzero/true, FALSE_COND if it\n    is zero/false.  Return 0 if the hardware has no such operation.  */\n+\n int\n rs6000_emit_cmove (dest, op, true_cond, false_cond)\n      rtx dest;\n@@ -5225,11 +5227,11 @@ rs6000_emit_minmax (dest, code, op0, op1)\n     emit_move_insn (dest, target);\n }\n \f\n-/* This page contains routines that are used to determine what the function\n-   prologue and epilogue code will do and write them out.  */\n+/* This page contains routines that are used to determine what the\n+   function prologue and epilogue code will do and write them out.  */\n \n-/*  Return the first fixed-point register that is required to be saved. 32 if\n-    none.  */\n+/* Return the first fixed-point register that is required to be\n+   saved. 32 if none.  */\n \n int\n first_reg_to_save ()\n@@ -5389,7 +5391,6 @@ first_fp_reg_to_save ()\n    align the stack at program startup.  A happy side-effect is that\n    -mno-eabi libraries can be used with -meabi programs.)\n \n-\n    The EABI configuration defaults to the V.4 layout, unless\n    -mcall-aix is used, in which case the AIX layout is used.  However,\n    the stack alignment requirements may differ.  If -mno-eabi is not\n@@ -5411,13 +5412,13 @@ rs6000_stack_info ()\n   int ehrd_size;\n   int total_raw_size;\n \n-  /* Zero all fields portably */\n+  /* Zero all fields portably.  */\n   info = zero_info;\n \n-  /* Select which calling sequence */\n+  /* Select which calling sequence.  */\n   info_ptr->abi = abi = DEFAULT_ABI;\n \n-  /* Calculate which registers need to be saved & save area size */\n+  /* Calculate which registers need to be saved & save area size.  */\n   info_ptr->first_gp_reg_save = first_reg_to_save ();\n   /* Assume that we will have to save PIC_OFFSET_TABLE_REGNUM, \n      even if it currently looks like we won't.  */\n@@ -5438,7 +5439,7 @@ rs6000_stack_info ()\n   info_ptr->calls_p = (! current_function_is_leaf\n \t\t       || cfun->machine->ra_needs_full_frame);\n \n-  /* Determine if we need to save the link register */\n+  /* Determine if we need to save the link register.  */\n   if (rs6000_ra_ever_killed ()\n       || (DEFAULT_ABI == ABI_AIX && profile_flag)\n #ifdef TARGET_RELOCATABLE\n@@ -5448,7 +5449,9 @@ rs6000_stack_info ()\n \t  && !FP_SAVE_INLINE (info_ptr->first_fp_reg_save))\n       || (abi == ABI_V4 && current_function_calls_alloca)\n       || (abi == ABI_SOLARIS && current_function_calls_alloca)\n-      || (DEFAULT_ABI == ABI_DARWIN && flag_pic && current_function_uses_pic_offset_table)\n+      || (DEFAULT_ABI == ABI_DARWIN\n+\t  && flag_pic\n+\t  && current_function_uses_pic_offset_table)\n       || info_ptr->calls_p)\n     {\n       info_ptr->lr_save_p = 1;\n@@ -5483,13 +5486,14 @@ rs6000_stack_info ()\n   info_ptr->fixed_size   = RS6000_SAVE_AREA;\n   info_ptr->varargs_size = RS6000_VARARGS_AREA;\n   info_ptr->vars_size    = RS6000_ALIGN (get_frame_size (), 8);\n-  info_ptr->parm_size    = RS6000_ALIGN (current_function_outgoing_args_size, 8);\n+  info_ptr->parm_size    = RS6000_ALIGN (current_function_outgoing_args_size,\n+\t\t\t\t\t 8);\n   info_ptr->save_size    = RS6000_ALIGN (info_ptr->fp_size\n-\t\t\t\t  + info_ptr->gp_size\n-\t\t\t\t  + ehrd_size\n-\t\t\t\t  + info_ptr->cr_size\n-\t\t\t\t  + info_ptr->lr_size\n-\t\t\t\t  + info_ptr->toc_size, 8);\n+\t\t\t\t\t + info_ptr->gp_size\n+\t\t\t\t\t + ehrd_size\n+\t\t\t\t\t + info_ptr->cr_size\n+\t\t\t\t\t + info_ptr->lr_size\n+\t\t\t\t\t + info_ptr->toc_size, 8);\n   if (DEFAULT_ABI == ABI_DARWIN)\n     info_ptr->save_size = RS6000_ALIGN (info_ptr->save_size, 16);\n \n@@ -5527,18 +5531,20 @@ rs6000_stack_info ()\n \t\t\t    + info_ptr->varargs_size\n \t\t\t    + info_ptr->fixed_size);\n \n-  info_ptr->total_size   = RS6000_ALIGN (total_raw_size, ABI_STACK_BOUNDARY / BITS_PER_UNIT);\n+  info_ptr->total_size =\n+    RS6000_ALIGN (total_raw_size, ABI_STACK_BOUNDARY / BITS_PER_UNIT);\n \n   /* Determine if we need to allocate any stack frame:\n \n-     For AIX we need to push the stack if a frame pointer is needed (because\n-     the stack might be dynamically adjusted), if we are debugging, if we\n-     make calls, or if the sum of fp_save, gp_save, and local variables\n-     are more than the space needed to save all non-volatile registers:\n-     32-bit: 18*8 + 19*4 = 220 or 64-bit: 18*8 + 18*8 = 288 (GPR13 reserved).\n+     For AIX we need to push the stack if a frame pointer is needed\n+     (because the stack might be dynamically adjusted), if we are\n+     debugging, if we make calls, or if the sum of fp_save, gp_save,\n+     and local variables are more than the space needed to save all\n+     non-volatile registers: 32-bit: 18*8 + 19*4 = 220 or 64-bit: 18*8\n+     + 18*8 = 288 (GPR13 reserved).\n \n-     For V.4 we don't have the stack cushion that AIX uses, but assume that\n-     the debugger can handle stackless frames.  */\n+     For V.4 we don't have the stack cushion that AIX uses, but assume\n+     that the debugger can handle stackless frames.  */\n \n   if (info_ptr->calls_p)\n     info_ptr->push_p = 1;\n@@ -5553,7 +5559,7 @@ rs6000_stack_info ()\n \t\t\t|| ((total_raw_size - info_ptr->fixed_size)\n \t\t\t    > (TARGET_32BIT ? 220 : 288)));\n \n-  /* Zero offsets if we're not saving those registers */\n+  /* Zero offsets if we're not saving those registers.  */\n   if (info_ptr->fp_size == 0)\n     info_ptr->fp_save_offset = 0;\n \n@@ -5659,13 +5665,13 @@ debug_stack_info (info)\n   if (info->fp_size)\n     fprintf (stderr, \"\\tfp_size             = %5d\\n\", info->fp_size);\n \n- if (info->lr_size)\n+  if (info->lr_size)\n     fprintf (stderr, \"\\tlr_size             = %5d\\n\", info->lr_size);\n \n   if (info->cr_size)\n     fprintf (stderr, \"\\tcr_size             = %5d\\n\", info->cr_size);\n \n- if (info->toc_size)\n+  if (info->toc_size)\n     fprintf (stderr, \"\\ttoc_size            = %5d\\n\", info->toc_size);\n \n   if (info->save_size)\n@@ -5682,21 +5688,21 @@ rs6000_return_addr (count, frame)\n      int count;\n      rtx frame;\n {\n-  /* Currently we don't optimize very well between prolog and body code and\n-     for PIC code the code can be actually quite bad, so don't try to be\n-     too clever here.  */\n+  /* Currently we don't optimize very well between prolog and body\n+     code and for PIC code the code can be actually quite bad, so\n+     don't try to be too clever here.  */\n   if (count != 0\n       || flag_pic != 0\n       || DEFAULT_ABI == ABI_AIX\n       || DEFAULT_ABI == ABI_AIX_NODESC)\n     {\n       cfun->machine->ra_needs_full_frame = 1;\n-      return\n-\tgen_rtx_MEM (Pmode,\n-          memory_address (Pmode,\n-\t\t\t  plus_constant (copy_to_reg (gen_rtx_MEM (Pmode,\n-\t\t\t\t\t\t\t\t   memory_address (Pmode, frame))),\n-\t\t\t\t\t RETURN_ADDRESS_OFFSET)));\n+      return gen_rtx_MEM (Pmode,\n+\t       memory_address (Pmode,\n+\t\t plus_constant (copy_to_reg\n+\t\t\t\t(gen_rtx_MEM (Pmode,\n+\t\t\t\t\t      memory_address (Pmode, frame))),\n+\t\t\t\tRETURN_ADDRESS_OFFSET)));\n     }\n \n   return get_hard_reg_initial_val (Pmode, LINK_REGISTER_REGNUM);\n@@ -5821,7 +5827,7 @@ rs6000_emit_load_toc_table (fromprolog)\n \t  rs6000_maybe_dead (emit_insn (gen_elf_low (dest, dest, realsym)));\n \t}\n       else\n-        abort();\n+        abort ();\n     }\n   else\n     {\n@@ -5844,6 +5850,7 @@ get_TOC_alias_set ()\n /* This retuns nonzero if the current function uses the TOC.  This is\n    determined by the presence of (unspec ... 7), which is generated by\n    the various load_toc_* patterns.  */\n+\n int\n uses_TOC () \n {\n@@ -5865,7 +5872,7 @@ uses_TOC ()\n }\n \n rtx\n-create_TOC_reference(symbol) \n+create_TOC_reference (symbol) \n     rtx symbol;\n {\n   return gen_rtx_PLUS (Pmode, \n@@ -5886,7 +5893,7 @@ create_TOC_reference(symbol)\n    Most of this code should be removed by CSE.  */\n static rtx insn_after_throw;\n \n-/* This does the saving... */\n+/* This does the saving...  */\n void\n rs6000_aix_emit_builtin_unwind_init ()\n {\n@@ -5906,14 +5913,14 @@ rs6000_aix_emit_builtin_unwind_init ()\n   emit_move_insn (insn_after_throw, gen_rtx_MEM (SImode, opcode_addr));\n }\n \n-/* Emit insns to _restore_ the TOC register, at runtime (specifically in _eh.o).\n-   Only used on AIX.\n+/* Emit insns to _restore_ the TOC register, at runtime (specifically\n+   in _eh.o).  Only used on AIX.\n \n    The idea is that on AIX, function calls look like this:\n \tbl  somefunction-trampoline\n \tlwz r2,20(sp)\n \n-    and later,\n+   and later,\n \tsomefunction-trampoline:\n \tstw r2,20(sp)\n \t ... load function address in the count register ...\n@@ -5941,6 +5948,7 @@ rs6000_aix_emit_builtin_unwind_init ()\n    the amount to be popped off the stack in addition to the stack frame\n    of this routine (which will be __throw or __rethrow, and so is\n    guaranteed to have a stack frame).  */\n+\n void\n rs6000_emit_eh_toc_restore (stacksize)\n      rtx stacksize;\n@@ -5969,7 +5977,7 @@ rs6000_emit_eh_toc_restore (stacksize)\n \t\t\t\t\t       : 0xE8410028, SImode)));\n \n   if (insn_after_throw == NULL_RTX)\n-    abort();\n+    abort ();\n   emit_move_insn (opcode, insn_after_throw);\n   \n   emit_note (NULL, NOTE_INSN_LOOP_BEG);\n@@ -6108,11 +6116,11 @@ rs6000_emit_allocate_stack (size, copy_r12)\n \t\t       REG_NOTES (insn));\n }\n \n-/* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced with\n-   (plus:P (reg 1) VAL), and with REG2 replaced with RREG if REG2 is not \n-   NULL.  \n-   It would be nice if dwarf2out_frame_debug_expr could deduce these\n-   equivalences by itself so it wasn't necessary to hold its hand so much.  */\n+/* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced\n+   with (plus:P (reg 1) VAL), and with REG2 replaced with RREG if REG2\n+   is not NULL.  It would be nice if dwarf2out_frame_debug_expr could\n+   deduce these equivalences by itself so it wasn't necessary to hold\n+   its hand so much.  */\n \n static void\n rs6000_frame_related (insn, reg, val, reg2, rreg)\n@@ -6176,7 +6184,7 @@ rs6000_frame_related (insn, reg, val, reg2, rreg)\n \t  }\n     }\n   else\n-    abort();\n+    abort ();\n   \n   if (reg2 != NULL_RTX)\n     real = replace_rtx (real, reg2, rreg);\n@@ -6239,8 +6247,8 @@ rs6000_emit_prologue ()\n       emit_insn (gen_movesi_from_cr (cr_save_rtx));\n     }\n \n-  /* Do any required saving of fpr's.  If only one or two to save, do it\n-     ourself.  Otherwise, call function.  */\n+  /* Do any required saving of fpr's.  If only one or two to save, do\n+     it ourselves.  Otherwise, call function.  */\n   if (saving_FPRs_inline)\n     {\n       int i;\n@@ -6253,7 +6261,7 @@ rs6000_emit_prologue ()\n \t    addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t\t GEN_INT (info->fp_save_offset \n \t\t\t\t\t  + sp_offset \n-\t\t\t\t\t  + 8*i));\n+\t\t\t\t\t  + 8 * i));\n \t    mem = gen_rtx_MEM (DFmode, addr);\n \t    set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n@@ -6467,8 +6475,8 @@ rs6000_emit_prologue ()\n     }\n }\n \n-\n /* Write function prologue.  */\n+\n static void\n rs6000_output_function_prologue (file, size)\n      FILE *file;\n@@ -6479,12 +6487,14 @@ rs6000_output_function_prologue (file, size)\n   if (TARGET_DEBUG_STACK)\n     debug_stack_info (info);\n \n-  /* Write .extern for any function we will call to save and restore fp\n-     values.  */\n-  if (info->first_fp_reg_save < 64 && !FP_SAVE_INLINE (info->first_fp_reg_save))\n+  /* Write .extern for any function we will call to save and restore\n+     fp values.  */\n+  if (info->first_fp_reg_save < 64\n+      && !FP_SAVE_INLINE (info->first_fp_reg_save))\n     fprintf (file, \"\\t.extern %s%d%s\\n\\t.extern %s%d%s\\n\",\n \t     SAVE_FP_PREFIX, info->first_fp_reg_save - 32, SAVE_FP_SUFFIX,\n-\t     RESTORE_FP_PREFIX, info->first_fp_reg_save - 32, RESTORE_FP_SUFFIX);\n+\t     RESTORE_FP_PREFIX, info->first_fp_reg_save - 32,\n+\t     RESTORE_FP_SUFFIX);\n \n   /* Write .extern for AIX common mode routines, if needed.  */\n   if (! TARGET_POWER && ! TARGET_POWERPC && ! common_mode_defined)\n@@ -6502,15 +6512,15 @@ rs6000_output_function_prologue (file, size)\n     {\n       start_sequence ();\n       \n-      /* A NOTE_INSN_DELETED is supposed to be at the start\n-\t and end of the \"toplevel\" insn chain.  */\n+      /* A NOTE_INSN_DELETED is supposed to be at the start and end of\n+\t the \"toplevel\" insn chain.  */\n       emit_note (0, NOTE_INSN_DELETED);\n       rs6000_emit_prologue ();\n       emit_note (0, NOTE_INSN_DELETED);\n       \n       if (TARGET_DEBUG_STACK)\n-\tdebug_rtx_list (get_insns(), 100);\n-      final (get_insns(), file, FALSE, FALSE);\n+\tdebug_rtx_list (get_insns (), 100);\n+      final (get_insns (), file, FALSE, FALSE);\n       end_sequence ();\n     }\n \n@@ -6691,7 +6701,7 @@ rs6000_emit_epilogue (sibcall)\n \t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->fp_save_offset \n \t\t\t\t\t+ sp_offset \n-\t\t\t\t\t+ 8*i));\n+\t\t\t\t\t+ 8 * i));\n \t  mem = gen_rtx_MEM (DFmode, addr);\n \t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n@@ -6857,8 +6867,8 @@ rs6000_output_function_epilogue (file, size)\n \t  emit_note (0, NOTE_INSN_DELETED);\n \n \t  if (TARGET_DEBUG_STACK)\n-\t    debug_rtx_list (get_insns(), 100);\n-\t  final (get_insns(), file, FALSE, FALSE);\n+\t    debug_rtx_list (get_insns (), 100);\n+\t  final (get_insns (), file, FALSE, FALSE);\n \t  end_sequence ();\n \t}\n     }\n@@ -7073,35 +7083,37 @@ rs6000_output_function_epilogue (file, size)\n     }\n }\n \f\n-/* A C compound statement that outputs the assembler code for a thunk function,\n-   used to implement C++ virtual function calls with multiple inheritance.  The\n-   thunk acts as a wrapper around a virtual function, adjusting the implicit\n-   object parameter before handing control off to the real function.\n-\n-   First, emit code to add the integer DELTA to the location that contains the\n-   incoming first argument.  Assume that this argument contains a pointer, and\n-   is the one used to pass the `this' pointer in C++.  This is the incoming\n-   argument *before* the function prologue, e.g. `%o0' on a sparc.  The\n-   addition must preserve the values of all other incoming arguments.\n+/* A C compound statement that outputs the assembler code for a thunk\n+   function, used to implement C++ virtual function calls with\n+   multiple inheritance.  The thunk acts as a wrapper around a virtual\n+   function, adjusting the implicit object parameter before handing\n+   control off to the real function.\n+\n+   First, emit code to add the integer DELTA to the location that\n+   contains the incoming first argument.  Assume that this argument\n+   contains a pointer, and is the one used to pass the `this' pointer\n+   in C++.  This is the incoming argument *before* the function\n+   prologue, e.g. `%o0' on a sparc.  The addition must preserve the\n+   values of all other incoming arguments.\n \n    After the addition, emit code to jump to FUNCTION, which is a\n-   `FUNCTION_DECL'.  This is a direct pure jump, not a call, and does not touch\n-   the return address.  Hence returning from FUNCTION will return to whoever\n-   called the current `thunk'.\n+   `FUNCTION_DECL'.  This is a direct pure jump, not a call, and does\n+   not touch the return address.  Hence returning from FUNCTION will\n+   return to whoever called the current `thunk'.\n \n-   The effect must be as if FUNCTION had been called directly with the adjusted\n-   first argument.  This macro is responsible for emitting all of the code for\n-   a thunk function; output_function_prologue() and output_function_epilogue()\n-   are not invoked.\n+   The effect must be as if FUNCTION had been called directly with the\n+   adjusted first argument.  This macro is responsible for emitting\n+   all of the code for a thunk function; output_function_prologue()\n+   and output_function_epilogue() are not invoked.\n \n-   The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already been\n-   extracted from it.)  It might possibly be useful on some targets, but\n-   probably not.\n+   The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already\n+   been extracted from it.)  It might possibly be useful on some\n+   targets, but probably not.\n \n-   If you do not define this macro, the target-independent code in the C++\n-   frontend will generate a less efficient heavyweight thunk that calls\n-   FUNCTION instead of jumping to it.  The generic approach does not support\n-   varargs.  */\n+   If you do not define this macro, the target-independent code in the\n+   C++ frontend will generate a less efficient heavyweight thunk that\n+   calls FUNCTION instead of jumping to it.  The generic approach does\n+   not support varargs.  */\n \n void\n output_mi_thunk (file, thunk_fndecl, delta, function)\n@@ -7110,7 +7122,8 @@ output_mi_thunk (file, thunk_fndecl, delta, function)\n      int delta;\n      tree function;\n {\n-  const char *this_reg = reg_names[ aggregate_value_p (TREE_TYPE (TREE_TYPE (function))) ? 4 : 3 ];\n+  const char *this_reg =\n+    reg_names[ aggregate_value_p (TREE_TYPE (TREE_TYPE (function))) ? 4 : 3 ];\n   const char *prefix;\n   const char *fname;\n   const char *r0\t = reg_names[0];\n@@ -7120,7 +7133,7 @@ output_mi_thunk (file, thunk_fndecl, delta, function)\n   char buf[512];\n   static int labelno = 0;\n \n-  /* Small constants that can be done by one add instruction */\n+  /* Small constants that can be done by one add instruction.  */\n   if (delta >= -32768 && delta <= 32767)\n     {\n       if (! TARGET_NEW_MNEMONICS)\n@@ -7129,16 +7142,16 @@ output_mi_thunk (file, thunk_fndecl, delta, function)\n \tfprintf (file, \"\\taddi %s,%s,%d\\n\", this_reg, this_reg, delta);\n     }\n \n-  /* Large constants that can be done by one addis instruction */\n+  /* Large constants that can be done by one addis instruction.  */\n   else if ((delta & 0xffff) == 0 && num_insns_constant_wide (delta) == 1)\n     asm_fprintf (file, \"\\t{cau|addis} %s,%s,%d\\n\", this_reg, this_reg,\n \t\t delta >> 16);\n \n   /* 32-bit constants that can be done by an add and addis instruction.  */\n   else if (TARGET_32BIT || num_insns_constant_wide (delta) == 1)\n     {\n-      /* Break into two pieces, propagating the sign bit from the low word to\n-\t the upper word.  */\n+      /* Break into two pieces, propagating the sign bit from the low\n+\t word to the upper word.  */\n       int delta_high = delta >> 16;\n       int delta_low  = delta & 0xffff;\n       if ((delta_low & 0x8000) != 0)\n@@ -7206,8 +7219,9 @@ output_mi_thunk (file, thunk_fndecl, delta, function)\n \t  ASM_OUTPUT_INTERNAL_LABEL (file, \"Lthunk\", labelno);\n \t  labelno++;\n \n-\t  /* Note, MINIMAL_TOC doesn't make sense in the case of a thunk, since\n-\t     there will be only one TOC entry for this function.  */\n+\t  /* Note, MINIMAL_TOC doesn't make sense in the case of a\n+\t     thunk, since there will be only one TOC entry for this\n+\t     function.  */\n \t  fputs (\"\\t.tc\\t\", file);\n \t  assemble_name (file, buf);\n \t  fputs (\"[TC],\", file);\n@@ -7351,7 +7365,7 @@ rs6000_hash_constant (k)\n \t  }\n \tbreak;\n       default:\n-\tabort();\n+\tabort ();\n       }\n   return result;\n }\n@@ -7381,7 +7395,7 @@ toc_hash_eq (h1, h2)\n \n   /* Gotcha:  One of these const_doubles will be in memory.\n      The other may be on the constant-pool chain.\n-     So rtx_equal_p will think they are different... */\n+     So rtx_equal_p will think they are different...  */\n   if (r1 == r2)\n     return 1;\n   if (GET_CODE (r1) != GET_CODE (r2)\n@@ -7415,7 +7429,7 @@ toc_hash_mark_entry (hash_slot, unused)\n     *(const struct toc_hash_struct **) hash_slot;\n   rtx r = hash_entry->key;\n   ggc_set_mark (hash_entry);\n-  /* For CODE_LABELS, we don't want to drag in the whole insn chain... */\n+  /* For CODE_LABELS, we don't want to drag in the whole insn chain...  */\n   if (GET_CODE (r) == LABEL_REF)\n     {\n       ggc_set_mark (r);\n@@ -7469,8 +7483,8 @@ rs6000_output_symbol_ref (file, x)\n     assemble_name (file, name);\n }\n \n-/* Output a TOC entry.  We derive the entry name from what is\n-   being written.  */\n+/* Output a TOC entry.  We derive the entry name from what is being\n+   written.  */\n \n void\n output_toc (file, x, labelno, mode)\n@@ -7716,7 +7730,7 @@ output_toc (file, x, labelno, mode)\n    On the RS/6000, we have to do this using the .byte operation and\n    write out special characters outside the quoted string.\n    Also, the assembler is broken; very long strings are truncated,\n-   so we must artificially break them up early. */\n+   so we must artificially break them up early.  */\n \n void\n output_ascii (file, p, n)\n@@ -7835,8 +7849,8 @@ rs6000_gen_section_name (buf, filename, section_desc)\n     *p = '\\0';\n }\n \f\n+/* Emit profile function.  */\n \n-/* Emit profile function. */\n void\n output_profile_hook (labelno)\n      int labelno;\n@@ -7880,7 +7894,7 @@ output_profile_hook (labelno)\n     }\n }\n \n-/* Write function profiler code. */\n+/* Write function profiler code.  */\n \n void\n output_function_profiler (file, labelno)\n@@ -7946,7 +7960,7 @@ output_function_profiler (file, labelno)\n \n     case ABI_AIX:\n     case ABI_DARWIN:\n-      /* Don't do anything, done in output_profile_hook (). */\n+      /* Don't do anything, done in output_profile_hook ().  */\n       break;\n \n     }\n@@ -8003,20 +8017,21 @@ rs6000_adjust_cost (insn, link, dep_insn, cost)\n   return cost;\n }\n \n-/* A C statement (sans semicolon) to update the integer scheduling priority\n-   INSN_PRIORITY (INSN).  Reduce the priority to execute the INSN earlier,\n-   increase the priority to execute INSN later.  Do not define this macro if\n-   you do not need to adjust the scheduling priorities of insns.  */\n+/* A C statement (sans semicolon) to update the integer scheduling\n+   priority INSN_PRIORITY (INSN).  Reduce the priority to execute the\n+   INSN earlier, increase the priority to execute INSN later.  Do not\n+   define this macro if you do not need to adjust the scheduling\n+   priorities of insns.  */\n \n static int\n rs6000_adjust_priority (insn, priority)\n      rtx insn ATTRIBUTE_UNUSED;\n      int priority;\n {\n-  /* On machines (like the 750) which have asymmetric integer units, where one\n-     integer unit can do multiply and divides and the other can't, reduce the\n-     priority of multiply/divide so it is scheduled before other integer\n-     operations.  */\n+  /* On machines (like the 750) which have asymmetric integer units,\n+     where one integer unit can do multiply and divides and the other\n+     can't, reduce the priority of multiply/divide so it is scheduled\n+     before other integer operations.  */\n \n #if 0\n   if (! INSN_P (insn))\n@@ -8046,7 +8061,8 @@ rs6000_adjust_priority (insn, priority)\n   return priority;\n }\n \n-/* Return how many instructions the machine can issue per cycle */\n+/* Return how many instructions the machine can issue per cycle.  */\n+\n static int\n rs6000_issue_rate ()\n {\n@@ -8153,15 +8169,17 @@ rs6000_initialize_trampoline (addr, fnaddr, cxt)\n \n \f\n /* Table of valid machine attributes.  */\n+\n const struct attribute_spec rs6000_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n   { \"longcall\", 0, 0, false, true,  true,  rs6000_handle_longcall_attribute },\n   { NULL,       0, 0, false, false, false, NULL }\n };\n \n-/* Handle a \"longcall\" attribute;\n-   arguments as in struct attribute_spec.handler.  */\n+/* Handle a \"longcall\" attribute; arguments as in struct\n+   attribute_spec.handler.  */\n+\n static tree\n rs6000_handle_longcall_attribute (node, name, args, flags, no_add_attrs)\n      tree *node;\n@@ -8184,6 +8202,7 @@ rs6000_handle_longcall_attribute (node, name, args, flags, no_add_attrs)\n \n /* Return a reference suitable for calling a function with the\n    longcall attribute.  */\n+\n struct rtx_def *\n rs6000_longcall_ref (call_ref)\n      rtx call_ref;\n@@ -8529,10 +8548,12 @@ add_compiler_stub (label_name, function_name, line_number)\n #define STUB_FUNCTION_NAME(STUB)  TREE_PURPOSE (STUB)\n #define STUB_LINE_NUMBER(STUB)    TREE_INT_CST_LOW (TREE_TYPE (STUB))\n \n-/* OUTPUT_COMPILER_STUB outputs the compiler generated stub for handling \n-   procedure calls from the linked list and initializes the linked list.  */\n+/* OUTPUT_COMPILER_STUB outputs the compiler generated stub for\n+   handling procedure calls from the linked list and initializes the\n+   linked list.  */\n \n-void output_compiler_stub ()\n+void\n+output_compiler_stub ()\n {\n   char tmp_buf[256];\n   char label_buf[256];\n@@ -8579,7 +8600,8 @@ void output_compiler_stub ()\n /* NO_PREVIOUS_DEF checks in the link list whether the function name is\n    already there or not.  */\n \n-int no_previous_def (function_name)\n+int\n+no_previous_def (function_name)\n      tree function_name;\n {\n   tree stub;\n@@ -8592,7 +8614,8 @@ int no_previous_def (function_name)\n /* GET_PREV_LABEL gets the label name from the previous definition of\n    the function.  */\n \n-tree get_prev_label (function_name)\n+tree\n+get_prev_label (function_name)\n      tree function_name;\n {\n   tree stub;\n@@ -8676,19 +8699,15 @@ machopic_output_stub (file, symb, stub)\n      const char *symb, *stub;\n {\n   unsigned int length;\n-  char *binder_name, *symbol_name, *lazy_ptr_name;\n-  char *local_label_0, *local_label_1, *local_label_2;\n+  char *symbol_name, *lazy_ptr_name;\n+  char *local_label_0;\n   static int label = 0;\n \n   /* Lose our funky encoding stuff so it doesn't contaminate the stub.  */\n   STRIP_NAME_ENCODING (symb, symb);\n \n   label += 1;\n \n-  length = strlen (stub);\n-  binder_name = alloca (length + 32);\n-  GEN_BINDER_NAME_FOR_STUB (binder_name, stub, length);\n-\n   length = strlen (symb);\n   symbol_name = alloca (length + 32);\n   GEN_SYMBOL_NAME_FOR_SYMBOL (symbol_name, symb, length);\n@@ -8699,12 +8718,6 @@ machopic_output_stub (file, symb, stub)\n   local_label_0 = alloca (length + 32);\n   GEN_LOCAL_LABEL_FOR_SYMBOL (local_label_0, symb, length, 0);\n \n-  local_label_1 = alloca (length + 32);\n-  GEN_LOCAL_LABEL_FOR_SYMBOL (local_label_1, symb, length, 1);\n-\n-  local_label_2 = alloca (length + 32);\n-  GEN_LOCAL_LABEL_FOR_SYMBOL (local_label_2, symb, length, 2);\n-\n   if (flag_pic == 2)\n     machopic_picsymbol_stub_section ();\n   else\n@@ -8763,10 +8776,12 @@ rs6000_machopic_legitimize_pic_address (orig, mode, reg)\n \n       if (GET_CODE (XEXP (orig, 0)) == PLUS)\n \t{\n-\t  base = rs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 0),\n-\t\t\t\t\t\t\t Pmode, reg);\n-\t  offset = rs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 1),\n-\t\t\t\t\t\t\t   Pmode, reg);\n+\t  base =\n+\t    rs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 0),\n+\t\t\t\t\t\t    Pmode, reg);\n+\t  offset =\n+\t    rs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 1),\n+\t\t\t\t\t\t    Pmode, reg);\n \t}\n       else\n \tabort ();"}]}