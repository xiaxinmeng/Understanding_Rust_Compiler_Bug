{"sha": "dfd3a76caecd5cea52ad04e0790165ba44742d59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZkM2E3NmNhZWNkNWNlYTUyYWQwNGUwNzkwMTY1YmE0NDc0MmQ1OQ==", "commit": {"author": {"name": "Igor Zamyatin", "email": "igor.zamyatin@intel.com", "date": "2015-01-19T13:58:54Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-01-19T13:58:54Z"}, "message": "re PR rtl-optimization/64081 (r217828 prevents RTL loop unroll)\n\ngcc/\n\n\tPR rtl-optimization/64081\n\t* loop-iv.c (def_pred_latch_p): New function.\n\t(latch_dominating_def): Allow specific cases with non-single\n\tdefinitions.\n\t(iv_get_reaching_def): Likewise.\n\t(check_complex_exit_p): New function.\n\t(check_simple_exit): Use check_complex_exit_p to allow certain cases\n\twith exits not executing on any iteration.\n\ngcc/testsuite/\n\n\tPR rtl-optimization/64081\n\t* gcc.dg/pr64081.c: New test.\n\nFrom-SVN: r219842", "tree": {"sha": "c1f846899315d6031ccc41dbf434feb410fedec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1f846899315d6031ccc41dbf434feb410fedec2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfd3a76caecd5cea52ad04e0790165ba44742d59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd3a76caecd5cea52ad04e0790165ba44742d59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfd3a76caecd5cea52ad04e0790165ba44742d59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd3a76caecd5cea52ad04e0790165ba44742d59/comments", "author": {"login": "Garra1980", "id": 25365940, "node_id": "MDQ6VXNlcjI1MzY1OTQw", "avatar_url": "https://avatars.githubusercontent.com/u/25365940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Garra1980", "html_url": "https://github.com/Garra1980", "followers_url": "https://api.github.com/users/Garra1980/followers", "following_url": "https://api.github.com/users/Garra1980/following{/other_user}", "gists_url": "https://api.github.com/users/Garra1980/gists{/gist_id}", "starred_url": "https://api.github.com/users/Garra1980/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Garra1980/subscriptions", "organizations_url": "https://api.github.com/users/Garra1980/orgs", "repos_url": "https://api.github.com/users/Garra1980/repos", "events_url": "https://api.github.com/users/Garra1980/events{/privacy}", "received_events_url": "https://api.github.com/users/Garra1980/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff6a32a98ea33fcc69d7c342c9d91502ae1dcdd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6a32a98ea33fcc69d7c342c9d91502ae1dcdd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff6a32a98ea33fcc69d7c342c9d91502ae1dcdd2"}], "stats": {"total": 184, "additions": 169, "deletions": 15}, "files": [{"sha": "39758e785f3b287353e95e7dafdc6ed2aa4244d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd3a76caecd5cea52ad04e0790165ba44742d59/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd3a76caecd5cea52ad04e0790165ba44742d59/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfd3a76caecd5cea52ad04e0790165ba44742d59", "patch": "@@ -1,3 +1,14 @@\n+2015-01-19  Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\tPR rtl-optimization/64081\n+\t* loop-iv.c (def_pred_latch_p): New function.\n+\t(latch_dominating_def): Allow specific cases with non-single\n+\tdefinitions.\n+\t(iv_get_reaching_def): Likewise.\n+\t(check_complex_exit_p): New function.\n+\t(check_simple_exit): Use check_complex_exit_p to allow certain cases\n+\twith exits not executing on any iteration.\n+\n 2015-01-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* common.opt (fgraphite): Fix a typo."}, {"sha": "7b2116c61a211bc85833f8a1b942de689cac5880", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 112, "deletions": 15, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd3a76caecd5cea52ad04e0790165ba44742d59/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd3a76caecd5cea52ad04e0790165ba44742d59/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=dfd3a76caecd5cea52ad04e0790165ba44742d59", "patch": "@@ -332,34 +332,72 @@ iv_analysis_loop_init (struct loop *loop)\n   check_iv_ref_table_size ();\n }\n \n+/* Return true if D_REF is defined in an immediate predecessor of the\n+   current loop's latch block.  Otherwise return false.  */\n+\n+static bool\n+def_pred_latch_p (df_ref d_ref)\n+{\n+  basic_block bb = DF_REF_BB (d_ref);\n+  edge_iterator ei;\n+  edge e;\n+\n+  FOR_EACH_EDGE (e, ei, current_loop->latch->preds)\n+    {\n+      if (e->src == bb)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Finds the definition of REG that dominates loop latch and stores\n    it to DEF.  Returns false if there is not a single definition\n-   dominating the latch.  If REG has no definition in loop, DEF\n+   dominating the latch or all defs are same and they are on different\n+   predecessors of loop latch.  If REG has no definition in loop, DEF\n    is set to NULL and true is returned.  */\n \n static bool\n latch_dominating_def (rtx reg, df_ref *def)\n {\n   df_ref single_rd = NULL, adef;\n-  unsigned regno = REGNO (reg);\n+  unsigned regno = REGNO (reg), def_num = 0;\n   struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (current_loop->latch);\n \n   for (adef = DF_REG_DEF_CHAIN (regno); adef; adef = DF_REF_NEXT_REG (adef))\n     {\n+      /* Initialize this to true for the very first iteration when\n+\t SINGLE_RD is NULL.  */\n+      bool def_pred_latch = true;\n+\n       if (!bitmap_bit_p (df->blocks_to_analyze, DF_REF_BBNO (adef))\n \t  || !bitmap_bit_p (&bb_info->out, DF_REF_ID (adef)))\n \tcontinue;\n \n-      /* More than one reaching definition.  */\n+      /* More than one reaching definition is ok in case definitions are\n+\t in predecessors of latch block and those definitions are the same.\n+\t Probably this could be relaxed and check for sub-dominance instead\n+\t predecessor.  */\n+      def_num++;\n       if (single_rd)\n-\treturn false;\n-\n-      if (!just_once_each_iteration_p (current_loop, DF_REF_BB (adef)))\n-\treturn false;\n+\t{\n+\t  if (!(def_pred_latch = def_pred_latch_p (adef))\n+\t      || !rtx_equal_p (PATTERN (DF_REF_INSN (single_rd)),\n+\t\t\t       PATTERN (DF_REF_INSN (adef))))\n+\t    return false;\n+\t}\n \n       single_rd = adef;\n     }\n \n+  /* If we have single definition it has to be executed on each iteration.  */\n+  if ((def_num == 1) && single_rd\n+      && !just_once_each_iteration_p (current_loop, DF_REF_BB (single_rd)))\n+    return false;\n+\n+  /* Make sure all preds contain definitions.  */\n+  if (def_num != EDGE_COUNT (current_loop->latch->preds))\n+    return false;\n+\n   *def = single_rd;\n   return true;\n }\n@@ -369,10 +407,10 @@ latch_dominating_def (rtx reg, df_ref *def)\n static enum iv_grd_result\n iv_get_reaching_def (rtx_insn *insn, rtx reg, df_ref *def)\n {\n-  df_ref use, adef;\n+  df_ref use, adef = NULL;\n   basic_block def_bb, use_bb;\n   rtx_insn *def_insn;\n-  bool dom_p;\n+  bool dom_p, dom_latch_p = false;\n \n   *def = NULL;\n   if (!simple_reg_p (reg))\n@@ -387,11 +425,26 @@ iv_get_reaching_def (rtx_insn *insn, rtx reg, df_ref *def)\n   if (!DF_REF_CHAIN (use))\n     return GRD_INVARIANT;\n \n-  /* More than one reaching def.  */\n+  adef = DF_REF_CHAIN (use)->ref;\n+  /* Having more than one reaching def is ok once all defs are in blocks which\n+     are latch's predecessors.  */\n   if (DF_REF_CHAIN (use)->next)\n-    return GRD_INVALID;\n+    {\n+      df_link* defs;\n+      unsigned int def_num = 0;\n \n-  adef = DF_REF_CHAIN (use)->ref;\n+      for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n+\t{\n+\t  if (!def_pred_latch_p (defs->ref))\n+\t    return GRD_INVALID;\n+\t  def_num++;\n+\t}\n+      /* Make sure all preds contain definitions.  */\n+      if (def_num != EDGE_COUNT (current_loop->latch->preds))\n+\treturn GRD_INVALID;\n+\n+      dom_latch_p = true;\n+    }\n \n   /* We do not handle setting only part of the register.  */\n   if (DF_REF_FLAGS (adef) & DF_REF_READ_WRITE)\n@@ -414,8 +467,8 @@ iv_get_reaching_def (rtx_insn *insn, rtx reg, df_ref *def)\n \n   /* The definition does not dominate the use.  This is still OK if\n      this may be a use of a biv, i.e. if the def_bb dominates loop\n-     latch.  */\n-  if (just_once_each_iteration_p (current_loop, def_bb))\n+     latch or all defs are in latch's predecessors.  */\n+  if (dom_latch_p || just_once_each_iteration_p (current_loop, def_bb))\n     return GRD_MAYBE_BIV;\n \n   return GRD_INVALID;\n@@ -2928,6 +2981,49 @@ iv_number_of_iterations (struct loop *loop, rtx_insn *insn, rtx condition,\n   return;\n }\n \n+/* Return true if LOOP has a complex exit, but is still good for further\n+   analysis.  Return false otherwise.  BB is LOOP's exit block.  */\n+\n+static bool\n+check_complex_exit_p (struct loop* loop, basic_block bb)\n+{\n+  edge e;\n+  basic_block pred, exit;\n+\n+  if (EDGE_COUNT (bb->preds) > 1)\n+    return false;\n+\n+  e = EDGE_PRED (bb, 0);\n+\n+  pred = e->src;\n+  if (EDGE_COUNT (pred->succs) != 2)\n+    return false;\n+\n+  /* Predecessor must be tested (at least) once during any iteration.  */\n+  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, pred))\n+    return false;\n+\n+  if (EDGE_SUCC (pred, 0)->dest == bb)\n+    exit = EDGE_SUCC (pred, 1)->dest;\n+  else\n+    exit = EDGE_SUCC (pred, 0)->dest;\n+\n+  /* Check that EXIT is really loop exit.  */\n+  if (flow_bb_inside_loop_p (loop, exit))\n+    {\n+      edge_iterator eei;\n+      edge ee;\n+\n+      FOR_EACH_EDGE (ee, eei, exit->succs)\n+\t{\n+\t  if (!flow_bb_inside_loop_p (loop, ee->dest))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+\n+}\n+\n /* Checks whether E is a simple exit from LOOP and stores its description\n    into DESC.  */\n \n@@ -2947,7 +3043,8 @@ check_simple_exit (struct loop *loop, edge e, struct niter_desc *desc)\n     return;\n \n   /* It must be tested (at least) once during any iteration.  */\n-  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, exit_bb))\n+  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, exit_bb)\n+      && !check_complex_exit_p (loop, exit_bb))\n     return;\n \n   /* It must end in a simple conditional jump.  */"}, {"sha": "87017f73e12327f6685070bef00819f709097f56", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd3a76caecd5cea52ad04e0790165ba44742d59/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd3a76caecd5cea52ad04e0790165ba44742d59/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dfd3a76caecd5cea52ad04e0790165ba44742d59", "patch": "@@ -1,3 +1,8 @@\n+2014-01-19  Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\tPR rtl-optimization/64081\n+\t* gcc.dg/pr64081.c: New test.\n+\n 2015-01-19  Tejas Belagod  <tejas.belagod@arm.com>\n \n \tPR target/63971"}, {"sha": "6151d0054a486c6c24b7564bf8110c417b66adb3", "filename": "gcc/testsuite/gcc.dg/pr64081.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd3a76caecd5cea52ad04e0790165ba44742d59/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64081.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd3a76caecd5cea52ad04e0790165ba44742d59/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64081.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64081.c?ref=dfd3a76caecd5cea52ad04e0790165ba44742d59", "patch": "@@ -0,0 +1,41 @@\n+/* PR rtl-optimization/64081 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funroll-loops -fdump-rtl-loop2_unroll\" } */\n+\n+long token;\n+long *data;\n+long *arr1;\n+long *arr2;\n+\n+int main (int argc, const char* argv[])\n+{\n+  unsigned long i;\n+  static long pos, start, count;\n+  static int dir;\n+\n+  pos = 0;\n+  dir = 1;\n+\n+  for (i = 0; i < argc; i++)\n+    {\n+      start = pos;\n+      for (count = 0; count <= 400; count++)\n+\t{\n+\t  if (token == data[pos])\n+\t    break;\n+\t  if (dir == 1)\n+\t    pos = arr1[pos];\n+\t  else\n+\t    pos = arr2[pos];\n+\t  if (pos == -1)\n+\t    {\n+\t      pos = start;\n+\t      dir = !dir;\n+\t    }\n+\t}\n+    }\n+  return pos + dir;\n+}\n+\n+/* { dg-final { scan-rtl-dump \"loop unrolled 7 times\" \"loop2_unroll\" } } */\n+/* { dg-final { cleanup-rtl-dump \"loop*\" } } */"}]}