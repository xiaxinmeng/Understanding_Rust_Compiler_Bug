{"sha": "992118a1f9192614d3916e112e3e9a833d00566c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkyMTE4YTFmOTE5MjYxNGQzOTE2ZTExMmUzZTlhODMzZDAwNTY2Yw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2015-08-02T17:31:55Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2015-08-02T17:31:55Z"}, "message": "Refactor entry point to -Wmisleading-indentation\n\ngcc/c-family/ChangeLog:\n\n\t* c-indentation.h (struct token_indent_info): Define.\n\t(get_token_indent_info): Define.\n\t(warn_for_misleading_information): Declare.\n\t* c-common.h (warn_for_misleading_information): Remove.\n\t* c-identation.c (warn_for_misleading_indentation):\n\tChange declaration to take three token_indent_infos.  Adjust\n\taccordingly.\n\t* c-identation.c (should_warn_for_misleading_indentation):\n\tLikewise.  Bail out early if the body is a compound statement.\n\t(guard_tinfo_to_string): Define.\n\ngcc/c/ChangeLog:\n\n\t* c-parser.c (c_parser_if_body): Take token_indent_info\n\targument. Call warn_for_misleading_indentation even when the\n\tbody is a semicolon.  Extract token_indent_infos corresponding\n\tto the guard, body and next tokens.  Adjust call to\n\twarn_for_misleading_indentation accordingly.\n\t(c_parser_else_body): Likewise.\n\t(c_parser_if_statement): Likewise.\n\t(c_parser_while_statement): Likewise.\n\t(c_parser_for_statement): Likewise.\n\ngcc/cp/ChangeLog:\n\n\t* parser.c (cp_parser_selection_statement): Move handling of\n\tsemicolon body to ...\n\t(cp_parser_implicitly_scoped_statement): .. here.  Call\n\twarn_for_misleading_indentation even when the body is a\n\tsemicolon.  Extract token_indent_infos corresponding to the\n\tguard, body and next tokens.  Adjust call to\n\twarn_for_misleading_indentation accordingly.  Take\n\ttoken_indent_info argument.\n\t(cp_parser_already_scoped_statement): Likewise.\n\t(cp_parser_selection_statement, cp_parser_iteration_statement):\n\tExtract a token_indent_info corresponding to the guard token.\n\nFrom-SVN: r226477", "tree": {"sha": "4382b53b305ac8e976613091b7987f093d40123f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4382b53b305ac8e976613091b7987f093d40123f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/992118a1f9192614d3916e112e3e9a833d00566c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/992118a1f9192614d3916e112e3e9a833d00566c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/992118a1f9192614d3916e112e3e9a833d00566c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/992118a1f9192614d3916e112e3e9a833d00566c/comments", "author": null, "committer": null, "parents": [{"sha": "fea8f6c692a091dd9e7639949e45ca7445fb53a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea8f6c692a091dd9e7639949e45ca7445fb53a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fea8f6c692a091dd9e7639949e45ca7445fb53a0"}], "stats": {"total": 358, "additions": 240, "deletions": 118}, "files": [{"sha": "8dfc81bdee9cbdab04b0044307d8ed32aabf00cb", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=992118a1f9192614d3916e112e3e9a833d00566c", "patch": "@@ -1,3 +1,16 @@\n+2015-08-02  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\t* c-indentation.h (struct token_indent_info): Define.\n+\t(get_token_indent_info): Define.\n+\t(warn_for_misleading_information): Declare.\n+\t* c-common.h (warn_for_misleading_information): Remove.\n+\t* c-identation.c (warn_for_misleading_indentation):\n+\tChange declaration to take three token_indent_infos.  Adjust\n+\taccordingly.\n+\t* c-identation.c (should_warn_for_misleading_indentation):\n+\tLikewise.  Bail out early if the body is a compound statement.\n+\t(guard_tinfo_to_string): Define.\n+\n 2015-07-30  Jason Merrill  <jason@redhat.com>\n \n \t* c-pretty-print.c (unary_expression) [INDIRECT_REF]: Don't print"}, {"sha": "ff74e53c7085d91ad29cc79a5c1bd7d44b7c72e6", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=992118a1f9192614d3916e112e3e9a833d00566c", "patch": "@@ -1431,12 +1431,5 @@ extern bool contains_cilk_spawn_stmt (tree);\n extern tree cilk_for_number_of_iterations (tree);\n extern bool check_no_cilk (tree, const char *, const char *,\n \t\t           location_t loc = UNKNOWN_LOCATION);\n-/* In c-indentation.c.  */\n-extern void\n-warn_for_misleading_indentation (location_t guard_loc,\n-\t\t\t\t location_t body_loc,\n-\t\t\t\t location_t next_stmt_loc,\n-\t\t\t\t enum cpp_ttype next_tok_type,\n-\t\t\t\t const char *guard_kind);\n \n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "544b0d43739666eaf692fd1afa9a417903385e7d", "filename": "gcc/c-family/c-indentation.c", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc-family%2Fc-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc-family%2Fc-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.c?ref=992118a1f9192614d3916e112e3e9a833d00566c", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"stor-layout.h\"\n #include \"c-common.h\"\n+#include \"c-indentation.h\"\n \n extern cpp_options *cpp_opts;\n \n@@ -184,11 +185,16 @@ detect_preprocessor_logic (expanded_location body_exploc,\n    description of that function below.  */\n \n static bool\n-should_warn_for_misleading_indentation (location_t guard_loc,\n-\t\t\t\t\tlocation_t body_loc,\n-\t\t\t\t\tlocation_t next_stmt_loc,\n-\t\t\t\t\tenum cpp_ttype next_tok_type)\n+should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n+\t\t\t\t\tconst token_indent_info &body_tinfo,\n+\t\t\t\t\tconst token_indent_info &next_tinfo)\n {\n+  location_t guard_loc = guard_tinfo.location;\n+  location_t body_loc = body_tinfo.location;\n+  location_t next_stmt_loc = next_tinfo.location;\n+\n+  enum cpp_ttype next_tok_type = next_tinfo.type;\n+\n   /* Don't attempt to compare the indentation of BODY_LOC and NEXT_STMT_LOC\n      if either are within macros.  */\n   if (linemap_location_from_macro_expansion_p (line_table, body_loc)\n@@ -214,7 +220,22 @@ should_warn_for_misleading_indentation (location_t guard_loc,\n   if (line_table->seen_line_directive)\n     return false;\n \n-  if (next_tok_type == CPP_CLOSE_BRACE)\n+  /* If the token following the body is a close brace or an \"else\"\n+     then while indentation may be sloppy, there is not much ambiguity\n+     about control flow, e.g.\n+\n+     if (foo)       <- GUARD\n+       bar ();      <- BODY\n+       else baz (); <- NEXT\n+\n+     {\n+     while (foo)  <- GUARD\n+     bar ();      <- BODY\n+     }            <- NEXT\n+     baz ();\n+  */\n+  if (next_tok_type == CPP_CLOSE_BRACE\n+      || next_tinfo.keyword == RID_ELSE)\n     return false;\n \n   /* Don't warn here about spurious semicolons.  */\n@@ -341,6 +362,28 @@ should_warn_for_misleading_indentation (location_t guard_loc,\n   return false;\n }\n \n+/* Return the string identifier corresponding to the given guard token.  */\n+\n+static const char *\n+guard_tinfo_to_string (const token_indent_info &guard_tinfo)\n+{\n+  switch (guard_tinfo.keyword)\n+    {\n+    case RID_FOR:\n+      return \"for\";\n+    case RID_ELSE:\n+      return \"else\";\n+    case RID_IF:\n+      return \"if\";\n+    case RID_WHILE:\n+      return \"while\";\n+    case RID_DO:\n+      return \"do\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Called by the C/C++ frontends when we have a guarding statement at\n    GUARD_LOC containing a statement at BODY_LOC, where the block wasn't\n    written using braces, like this:\n@@ -368,24 +411,24 @@ should_warn_for_misleading_indentation (location_t guard_loc,\n    GUARD_KIND identifies the kind of clause e.g. \"if\", \"else\" etc.  */\n \n void\n-warn_for_misleading_indentation (location_t guard_loc,\n-\t\t\t\t location_t body_loc,\n-\t\t\t\t location_t next_stmt_loc,\n-\t\t\t\t enum cpp_ttype next_tok_type,\n-\t\t\t\t const char *guard_kind)\n+warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n+\t\t\t\t const token_indent_info &body_tinfo,\n+\t\t\t\t const token_indent_info &next_tinfo)\n {\n   /* Early reject for the case where -Wmisleading-indentation is disabled,\n      to avoid doing work only to have the warning suppressed inside the\n      diagnostic machinery.  */\n   if (!warn_misleading_indentation)\n     return;\n \n-  if (should_warn_for_misleading_indentation (guard_loc,\n-\t\t\t\t\t      body_loc,\n-\t\t\t\t\t      next_stmt_loc,\n-\t\t\t\t\t      next_tok_type))\n-    if (warning_at (next_stmt_loc, OPT_Wmisleading_indentation,\n-\t\t    \"statement is indented as if it were guarded by...\"))\n-      inform (guard_loc,\n-\t      \"...this %qs clause, but it is not\", guard_kind);\n+  if (should_warn_for_misleading_indentation (guard_tinfo,\n+\t\t\t\t\t      body_tinfo,\n+\t\t\t\t\t      next_tinfo))\n+    {\n+      if (warning_at (next_tinfo.location, OPT_Wmisleading_indentation,\n+\t\t      \"statement is indented as if it were guarded by...\"))\n+        inform (guard_tinfo.location,\n+\t\t\"...this %qs clause, but it is not\",\n+\t\tguard_tinfo_to_string (guard_tinfo));\n+    }\n }"}, {"sha": "7fb6bb4fbfceba5d094a3803194c8cf65eff59ac", "filename": "gcc/c-family/c-indentation.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc-family%2Fc-indentation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc-family%2Fc-indentation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.h?ref=992118a1f9192614d3916e112e3e9a833d00566c", "patch": "@@ -0,0 +1,52 @@\n+/* Definitions for c-indentation.c.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_C_INDENTATION_H\n+#define GCC_C_INDENTATION_H\n+\n+/* Token information used by the -Wmisleading-indentation implementation.  */\n+\n+struct token_indent_info\n+{\n+  location_t location;\n+  ENUM_BITFIELD (cpp_ttype) type : 8;\n+  ENUM_BITFIELD (rid) keyword : 8;\n+};\n+\n+/* Extract token information from TOKEN, which ought to either be a\n+   cp_token * or a c_token *.  */\n+\n+template <typename T>\n+inline token_indent_info\n+get_token_indent_info (const T *token)\n+{\n+  token_indent_info info;\n+  info.location = token->location;\n+  info.type = token->type;\n+  info.keyword = token->keyword;\n+\n+  return info;\n+}\n+\n+extern void\n+warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n+\t\t\t\t const token_indent_info &body_tinfo,\n+\t\t\t\t const token_indent_info &next_tinfo);\n+\n+#endif  /* ! GCC_C_INDENTATION_H  */"}, {"sha": "aa4ab6000ba9cb7c64fb3eade8e119847f13f2b2", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=992118a1f9192614d3916e112e3e9a833d00566c", "patch": "@@ -1,3 +1,15 @@\n+2015-08-02  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\t* c-parser.c (c_parser_if_body): Take token_indent_info\n+\targument. Call warn_for_misleading_indentation even when the\n+\tbody is a semicolon.  Extract token_indent_infos corresponding\n+\tto the guard, body and next tokens.  Adjust call to\n+\twarn_for_misleading_indentation accordingly.\n+\t(c_parser_else_body): Likewise.\n+\t(c_parser_if_statement): Likewise.\n+\t(c_parser_while_statement): Likewise.\n+\t(c_parser_for_statement): Likewise.\n+\n 2015-07-28  Luis Felipe Strano Moraes  <luis.strano@gmail.com>\n \t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n "}, {"sha": "30b4302b09e83e70733686ece36f1eac463cd383", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=992118a1f9192614d3916e112e3e9a833d00566c", "patch": "@@ -65,6 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-low.h\"\n #include \"builtins.h\"\n #include \"gomp-constants.h\"\n+#include \"c-family/c-indentation.h\"\n \n \f\n /* Initialization routine for this file.  */\n@@ -5179,10 +5180,14 @@ c_parser_c99_block_statement (c_parser *parser)\n    parser->in_if_block.  */\n \n static tree\n-c_parser_if_body (c_parser *parser, bool *if_p, location_t if_loc)\n+c_parser_if_body (c_parser *parser, bool *if_p,\n+\t\t  const token_indent_info &if_tinfo)\n {\n   tree block = c_begin_compound_stmt (flag_isoc99);\n   location_t body_loc = c_parser_peek_token (parser)->location;\n+  token_indent_info body_tinfo\n+    = get_token_indent_info (c_parser_peek_token (parser));\n+\n   c_parser_all_labels (parser);\n   *if_p = c_parser_next_token_is_keyword (parser, RID_IF);\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n@@ -5197,14 +5202,11 @@ c_parser_if_body (c_parser *parser, bool *if_p, location_t if_loc)\n   else if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n     add_stmt (c_parser_compound_statement (parser));\n   else\n-    {\n-      c_parser_statement_after_labels (parser);\n-      if (!c_parser_next_token_is_keyword (parser, RID_ELSE))\n-\twarn_for_misleading_indentation (if_loc, body_loc,\n-\t\t\t\t\t c_parser_peek_token (parser)->location,\n-\t\t\t\t\t c_parser_peek_token (parser)->type,\n-\t\t\t\t\t \"if\");\n-    }\n+    c_parser_statement_after_labels (parser);\n+\n+  token_indent_info next_tinfo\n+    = get_token_indent_info (c_parser_peek_token (parser));\n+  warn_for_misleading_indentation (if_tinfo, body_tinfo, next_tinfo);\n \n   return c_end_compound_stmt (body_loc, block, flag_isoc99);\n }\n@@ -5214,10 +5216,13 @@ c_parser_if_body (c_parser *parser, bool *if_p, location_t if_loc)\n    specially for the sake of -Wempty-body warnings.  */\n \n static tree\n-c_parser_else_body (c_parser *parser, location_t else_loc)\n+c_parser_else_body (c_parser *parser, const token_indent_info &else_tinfo)\n {\n   location_t body_loc = c_parser_peek_token (parser)->location;\n   tree block = c_begin_compound_stmt (flag_isoc99);\n+  token_indent_info body_tinfo\n+    = get_token_indent_info (c_parser_peek_token (parser));\n+\n   c_parser_all_labels (parser);\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n@@ -5229,13 +5234,12 @@ c_parser_else_body (c_parser *parser, location_t else_loc)\n       c_parser_consume_token (parser);\n     }\n   else\n-    {\n-      c_parser_statement_after_labels (parser);\n-      warn_for_misleading_indentation (else_loc, body_loc,\n-\t\t\t\t       c_parser_peek_token (parser)->location,\n-\t\t\t\t       c_parser_peek_token (parser)->type,\n-\t\t\t\t       \"else\");\n-    }\n+    c_parser_statement_after_labels (parser);\n+\n+  token_indent_info next_tinfo\n+    = get_token_indent_info (c_parser_peek_token (parser));\n+  warn_for_misleading_indentation (else_tinfo, body_tinfo, next_tinfo);\n+\n   return c_end_compound_stmt (body_loc, block, flag_isoc99);\n }\n \n@@ -5258,7 +5262,8 @@ c_parser_if_statement (c_parser *parser)\n   tree if_stmt;\n \n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_IF));\n-  location_t if_loc = c_parser_peek_token (parser)->location;\n+  token_indent_info if_tinfo\n+    = get_token_indent_info (c_parser_peek_token (parser));\n   c_parser_consume_token (parser);\n   block = c_begin_compound_stmt (flag_isoc99);\n   loc = c_parser_peek_token (parser)->location;\n@@ -5270,13 +5275,14 @@ c_parser_if_statement (c_parser *parser)\n     }\n   in_if_block = parser->in_if_block;\n   parser->in_if_block = true;\n-  first_body = c_parser_if_body (parser, &first_if, if_loc);\n+  first_body = c_parser_if_body (parser, &first_if, if_tinfo);\n   parser->in_if_block = in_if_block;\n   if (c_parser_next_token_is_keyword (parser, RID_ELSE))\n     {\n-      location_t else_loc = c_parser_peek_token (parser)->location;\n+      token_indent_info else_tinfo\n+\t= get_token_indent_info (c_parser_peek_token (parser));\n       c_parser_consume_token (parser);\n-      second_body = c_parser_else_body (parser, else_loc);\n+      second_body = c_parser_else_body (parser, else_tinfo);\n     }\n   else\n     second_body = NULL_TREE;\n@@ -5356,7 +5362,8 @@ c_parser_while_statement (c_parser *parser, bool ivdep)\n   tree block, cond, body, save_break, save_cont;\n   location_t loc;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_WHILE));\n-  location_t while_loc = c_parser_peek_token (parser)->location;\n+  token_indent_info while_tinfo\n+    = get_token_indent_info (c_parser_peek_token (parser));\n   c_parser_consume_token (parser);\n   block = c_begin_compound_stmt (flag_isoc99);\n   loc = c_parser_peek_token (parser)->location;\n@@ -5374,14 +5381,14 @@ c_parser_while_statement (c_parser *parser, bool ivdep)\n   save_cont = c_cont_label;\n   c_cont_label = NULL_TREE;\n \n-  location_t body_loc = UNKNOWN_LOCATION;\n-  if (c_parser_peek_token (parser)->type != CPP_OPEN_BRACE)\n-    body_loc = c_parser_peek_token (parser)->location;\n+  token_indent_info body_tinfo\n+    = get_token_indent_info (c_parser_peek_token (parser));\n+\n   body = c_parser_c99_block_statement (parser);\n-  warn_for_misleading_indentation (while_loc, body_loc,\n-\t\t\t\t   c_parser_peek_token (parser)->location,\n-\t\t\t\t   c_parser_peek_token (parser)->type,\n-\t\t\t\t   \"while\");\n+\n+  token_indent_info next_tinfo\n+    = get_token_indent_info (c_parser_peek_token (parser));\n+  warn_for_misleading_indentation (while_tinfo, body_tinfo, next_tinfo);\n \n   c_finish_loop (loc, cond, NULL, body, c_break_label, c_cont_label, true);\n   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n@@ -5501,6 +5508,8 @@ c_parser_for_statement (c_parser *parser, bool ivdep)\n   location_t for_loc = c_parser_peek_token (parser)->location;\n   bool is_foreach_statement = false;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_FOR));\n+  token_indent_info for_tinfo\n+    = get_token_indent_info (c_parser_peek_token (parser));\n   c_parser_consume_token (parser);\n   /* Open a compound statement in Objective-C as well, just in case this is\n      as foreach expression.  */\n@@ -5661,14 +5670,14 @@ c_parser_for_statement (c_parser *parser, bool ivdep)\n   save_cont = c_cont_label;\n   c_cont_label = NULL_TREE;\n \n-  location_t body_loc = UNKNOWN_LOCATION;\n-  if (c_parser_peek_token (parser)->type != CPP_OPEN_BRACE)\n-    body_loc = c_parser_peek_token (parser)->location;\n+  token_indent_info body_tinfo\n+    = get_token_indent_info (c_parser_peek_token (parser));\n+\n   body = c_parser_c99_block_statement (parser);\n-  warn_for_misleading_indentation (for_loc, body_loc,\n-\t\t\t\t   c_parser_peek_token (parser)->location,\n-\t\t\t\t   c_parser_peek_token (parser)->type,\n-\t\t\t\t   \"for\");\n+\n+  token_indent_info next_tinfo\n+    = get_token_indent_info (c_parser_peek_token (parser));\n+  warn_for_misleading_indentation (for_tinfo, body_tinfo, next_tinfo);\n \n   if (is_foreach_statement)\n     objc_finish_foreach_loop (loc, object_expression, collection_expression, body, c_break_label, c_cont_label);"}, {"sha": "ca3be9f127d29f6a0df59bdac827ce43522f3caa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=992118a1f9192614d3916e112e3e9a833d00566c", "patch": "@@ -1,3 +1,17 @@\n+2015-08-02  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\t* parser.c (cp_parser_selection_statement): Move handling of\n+\tsemicolon body to ...\n+\t(cp_parser_implicitly_scoped_statement): .. here.  Call\n+\twarn_for_misleading_indentation even when the body is a\n+\tsemicolon.  Extract token_indent_infos corresponding to the\n+\tguard, body and next tokens.  Adjust call to\n+\twarn_for_misleading_indentation accordingly.  Take\n+\ttoken_indent_info argument.\n+\t(cp_parser_already_scoped_statement): Likewise.\n+\t(cp_parser_selection_statement, cp_parser_iteration_statement):\n+\tExtract a token_indent_info corresponding to the guard token.\n+\n 2015-08-01  Caroline Tice  <cmtice@google.com>\n \n \tPR 66521"}, {"sha": "b978fcfc613c947b5ae768c7c3df7de08aac0f08", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992118a1f9192614d3916e112e3e9a833d00566c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=992118a1f9192614d3916e112e3e9a833d00566c", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"type-utils.h\"\n #include \"omp-low.h\"\n #include \"gomp-constants.h\"\n+#include \"c-family/c-indentation.h\"\n \n \f\n /* The lexer.  */\n@@ -2055,9 +2056,9 @@ static void cp_parser_declaration_statement\n   (cp_parser *);\n \n static tree cp_parser_implicitly_scoped_statement\n-  (cp_parser *, bool *, location_t, const char *);\n+  (cp_parser *, bool *, const token_indent_info &);\n static void cp_parser_already_scoped_statement\n-  (cp_parser *, location_t, const char *);\n+  (cp_parser *, const token_indent_info &);\n \n /* Declarations [gram.dcl.dcl] */\n \n@@ -10120,12 +10121,14 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n {\n   cp_token *token;\n   enum rid keyword;\n+  token_indent_info guard_tinfo;\n \n   if (if_p != NULL)\n     *if_p = false;\n \n   /* Peek at the next token.  */\n   token = cp_parser_require (parser, CPP_KEYWORD, RT_SELECT);\n+  guard_tinfo = get_token_indent_info (token);\n \n   /* See what kind of keyword it is.  */\n   keyword = token->keyword;\n@@ -10168,19 +10171,8 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t    /* Parse the then-clause.  */\n \t    in_statement = parser->in_statement;\n \t    parser->in_statement |= IN_IF_STMT;\n-\t    if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-\t      {\n-\t        location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n-\t\tadd_stmt (build_empty_stmt (loc));\n-\t\tcp_lexer_consume_token (parser->lexer);\n-\t        if (!cp_lexer_next_token_is_keyword (parser->lexer, RID_ELSE))\n-\t\t  warning_at (loc, OPT_Wempty_body, \"suggest braces around \"\n-\t\t\t      \"empty body in an %<if%> statement\");\n-\t\tnested_if = false;\n-\t      }\n-\t    else\n-\t      cp_parser_implicitly_scoped_statement (parser, &nested_if,\n-\t\t\t\t\t\t     token->location, \"if\");\n+\t    cp_parser_implicitly_scoped_statement (parser, &nested_if,\n+\t\t\t\t\t\t   guard_tinfo);\n \t    parser->in_statement = in_statement;\n \n \t    finish_then_clause (statement);\n@@ -10189,24 +10181,14 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t    if (cp_lexer_next_token_is_keyword (parser->lexer,\n \t\t\t\t\t\tRID_ELSE))\n \t      {\n+\t\tguard_tinfo\n+\t\t  = get_token_indent_info (cp_lexer_peek_token (parser->lexer));\n \t\t/* Consume the `else' keyword.  */\n-\t\tlocation_t else_tok_loc\n-\t\t  = cp_lexer_consume_token (parser->lexer)->location;\n+\t\tcp_lexer_consume_token (parser->lexer);\n \t\tbegin_else_clause (statement);\n \t\t/* Parse the else-clause.  */\n-\t        if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-\t          {\n-\t\t    location_t loc;\n-\t\t    loc = cp_lexer_peek_token (parser->lexer)->location;\n-\t\t    warning_at (loc,\n-\t\t\t\tOPT_Wempty_body, \"suggest braces around \"\n-\t\t\t        \"empty body in an %<else%> statement\");\n-\t\t    add_stmt (build_empty_stmt (loc));\n-\t\t    cp_lexer_consume_token (parser->lexer);\n-\t\t  }\n-\t\telse\n-\t\t  cp_parser_implicitly_scoped_statement (parser, NULL,\n-\t\t\t\t\t\t\t else_tok_loc, \"else\");\n+\t\tcp_parser_implicitly_scoped_statement (parser, NULL,\n+\t\t\t\t\t\t       guard_tinfo);\n \n \t\tfinish_else_clause (statement);\n \n@@ -10247,7 +10229,7 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t    parser->in_switch_statement_p = true;\n \t    parser->in_statement |= IN_SWITCH_STMT;\n \t    cp_parser_implicitly_scoped_statement (parser, NULL,\n-\t\t\t\t\t\t   0, \"switch\");\n+\t\t\t\t\t\t   guard_tinfo);\n \t    parser->in_switch_statement_p = in_switch_statement_p;\n \t    parser->in_statement = in_statement;\n \n@@ -10792,17 +10774,17 @@ static tree\n cp_parser_iteration_statement (cp_parser* parser, bool ivdep)\n {\n   cp_token *token;\n-  location_t tok_loc;\n   enum rid keyword;\n   tree statement;\n   unsigned char in_statement;\n+  token_indent_info guard_tinfo;\n \n   /* Peek at the next token.  */\n   token = cp_parser_require (parser, CPP_KEYWORD, RT_INTERATION);\n   if (!token)\n     return error_mark_node;\n \n-  tok_loc = token->location;\n+  guard_tinfo = get_token_indent_info (token);\n \n   /* Remember whether or not we are already within an iteration\n      statement.  */\n@@ -10827,7 +10809,7 @@ cp_parser_iteration_statement (cp_parser* parser, bool ivdep)\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t/* Parse the dependent statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n-\tcp_parser_already_scoped_statement (parser, tok_loc, \"while\");\n+\tcp_parser_already_scoped_statement (parser, guard_tinfo);\n \tparser->in_statement = in_statement;\n \t/* We're done with the while-statement.  */\n \tfinish_while_stmt (statement);\n@@ -10842,7 +10824,7 @@ cp_parser_iteration_statement (cp_parser* parser, bool ivdep)\n \tstatement = begin_do_stmt ();\n \t/* Parse the body of the do-statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n-\tcp_parser_implicitly_scoped_statement (parser, NULL, 0, \"do\");\n+\tcp_parser_implicitly_scoped_statement (parser, NULL, guard_tinfo);\n \tparser->in_statement = in_statement;\n \tfinish_do_body (statement);\n \t/* Look for the `while' keyword.  */\n@@ -10872,7 +10854,7 @@ cp_parser_iteration_statement (cp_parser* parser, bool ivdep)\n \n \t/* Parse the body of the for-statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n-\tcp_parser_already_scoped_statement (parser, tok_loc, \"for\");\n+\tcp_parser_already_scoped_statement (parser, guard_tinfo);\n \tparser->in_statement = in_statement;\n \n \t/* We're done with the for-statement.  */\n@@ -11142,20 +11124,29 @@ cp_parser_declaration_statement (cp_parser* parser)\n \n static tree\n cp_parser_implicitly_scoped_statement (cp_parser* parser, bool *if_p,\n-\t\t\t\t       location_t guard_loc,\n-\t\t\t\t       const char *guard_kind)\n+\t\t\t\t       const token_indent_info &guard_tinfo)\n {\n   tree statement;\n+  location_t body_loc = cp_lexer_peek_token (parser->lexer)->location;\n+  token_indent_info body_tinfo\n+    = get_token_indent_info (cp_lexer_peek_token (parser->lexer));\n \n   if (if_p != NULL)\n     *if_p = false;\n \n   /* Mark if () ; with a special NOP_EXPR.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n     {\n-      location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n       cp_lexer_consume_token (parser->lexer);\n-      statement = add_stmt (build_empty_stmt (loc));\n+      statement = add_stmt (build_empty_stmt (body_loc));\n+\n+      if (guard_tinfo.keyword == RID_IF\n+\t  && !cp_lexer_next_token_is_keyword (parser->lexer, RID_ELSE))\n+\twarning_at (body_loc, OPT_Wempty_body,\n+\t\t    \"suggest braces around empty body in an %<if%> statement\");\n+      else if (guard_tinfo.keyword == RID_ELSE)\n+\twarning_at (body_loc, OPT_Wempty_body,\n+\t\t    \"suggest braces around empty body in an %<else%> statement\");\n     }\n   /* if a compound is opened, we simply parse the statement directly.  */\n   else if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n@@ -11166,20 +11157,15 @@ cp_parser_implicitly_scoped_statement (cp_parser* parser, bool *if_p,\n       /* Create a compound-statement.  */\n       statement = begin_compound_stmt (0);\n       /* Parse the dependent-statement.  */\n-      location_t body_loc = cp_lexer_peek_token (parser->lexer)->location;\n       cp_parser_statement (parser, NULL_TREE, false, if_p);\n       /* Finish the dummy compound-statement.  */\n       finish_compound_stmt (statement);\n-      cp_token *next_tok = cp_lexer_peek_token (parser->lexer);\n-      if (next_tok->keyword != RID_ELSE)\n-        {\n-          location_t next_stmt_loc = next_tok->location;\n-          warn_for_misleading_indentation (guard_loc, body_loc,\n-                                           next_stmt_loc, next_tok->type,\n-                                           guard_kind);\n-        }\n     }\n \n+  token_indent_info next_tinfo\n+    = get_token_indent_info (cp_lexer_peek_token (parser->lexer));\n+  warn_for_misleading_indentation (guard_tinfo, body_tinfo, next_tinfo);\n+\n   /* Return the statement.  */\n   return statement;\n }\n@@ -11190,19 +11176,19 @@ cp_parser_implicitly_scoped_statement (cp_parser* parser, bool *if_p,\n    scope.  */\n \n static void\n-cp_parser_already_scoped_statement (cp_parser* parser, location_t guard_loc,\n-\t\t\t\t    const char *guard_kind)\n+cp_parser_already_scoped_statement (cp_parser* parser,\n+\t\t\t\t    const token_indent_info &guard_tinfo)\n {\n   /* If the token is a `{', then we must take special action.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE))\n     {\n-      location_t body_loc = cp_lexer_peek_token (parser->lexer)->location;\n+      token_indent_info body_tinfo\n+\t= get_token_indent_info (cp_lexer_peek_token (parser->lexer));\n+\n       cp_parser_statement (parser, NULL_TREE, false, NULL);\n-      cp_token *next_tok = cp_lexer_peek_token (parser->lexer);\n-      location_t next_stmt_loc = next_tok->location;\n-      warn_for_misleading_indentation (guard_loc, body_loc,\n-                                       next_stmt_loc, next_tok->type,\n-                                       guard_kind);\n+      token_indent_info next_tinfo\n+\t= get_token_indent_info (cp_lexer_peek_token (parser->lexer));\n+      warn_for_misleading_indentation (guard_tinfo, body_tinfo, next_tinfo);\n     }\n   else\n     {"}]}