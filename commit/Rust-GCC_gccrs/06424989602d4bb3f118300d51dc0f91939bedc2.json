{"sha": "06424989602d4bb3f118300d51dc0f91939bedc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY0MjQ5ODk2MDJkNGJiM2YxMTgzMDBkNTFkYzBmOTE5MzliZWRjMg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-08-28T14:57:55Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-28T14:57:55Z"}, "message": "sparc.md (DImode, [...]): Delete self_reference code.\n\n\t* sparc.md (DImode, DFmode, TFmode splits): Delete self_reference\n\tcode.  Use reg_overlap_mentioned_p to detect when source and\n\tdestination overlap.\n\t(negtf2_notv9+1): Use DFmode instead of SFmode in last two operands.\n\nFrom-SVN: r22057", "tree": {"sha": "395af8d68679f0af54100e8ef82ee453aa652bcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/395af8d68679f0af54100e8ef82ee453aa652bcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06424989602d4bb3f118300d51dc0f91939bedc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06424989602d4bb3f118300d51dc0f91939bedc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06424989602d4bb3f118300d51dc0f91939bedc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06424989602d4bb3f118300d51dc0f91939bedc2/comments", "author": null, "committer": null, "parents": [{"sha": "ea6021e832a937087583f9c1b1ca1f3220ef5bd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea6021e832a937087583f9c1b1ca1f3220ef5bd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea6021e832a937087583f9c1b1ca1f3220ef5bd3"}], "stats": {"total": 29, "additions": 13, "deletions": 16}, "files": [{"sha": "6d156b17ca97f52a4ab46919312e98185b46b2c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06424989602d4bb3f118300d51dc0f91939bedc2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06424989602d4bb3f118300d51dc0f91939bedc2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06424989602d4bb3f118300d51dc0f91939bedc2", "patch": "@@ -1,3 +1,10 @@\n+Fri Aug 28 13:52:35 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* sparc.md (DImode, DFmode, TFmode splits): Delete self_reference\n+\tcode.  Use reg_overlap_mentioned_p to detect when source and\n+\tdestination overlap.\n+\t(negtf2_notv9+1): Use DFmode instead of SFmode in last two operands.\n+\n 1998-08-28  Brendan Kehoe  <brendan@cygnus.com>\n \n \t* loop.c (check_dbra_loop): Pass COMPARISON_VALUE, not"}, {"sha": "6290a55d34dd8667956a015d5a40c832bac6f2c7", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06424989602d4bb3f118300d51dc0f91939bedc2/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06424989602d4bb3f118300d51dc0f91939bedc2/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=06424989602d4bb3f118300d51dc0f91939bedc2", "patch": "@@ -2691,12 +2691,8 @@\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 4));\n   rtx high_part = gen_highpart (SImode, operands[0]);\n   rtx low_part = gen_lowpart (SImode, operands[0]);\n-  int self_reference;\n \n-  self_reference = reg_overlap_mentioned_p (operands[0],\n-\t\t\t\t\t    XEXP (XEXP (word1, 0), 0));\n-  if (self_reference != 0\n-      && WORDS_BIG_ENDIAN)\n+  if (reg_overlap_mentioned_p (high_part, word1))\n     {\n       emit_insn (gen_movsi (low_part, word1));\n       emit_insn (gen_movsi (high_part, word0));\n@@ -3206,15 +3202,11 @@\n   rtx word0 = change_address (operands[1], SFmode, NULL_RTX);\n   rtx word1 = change_address (operands[1], SFmode,\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 4));\n-  int self_reference;\n \n-  self_reference = reg_overlap_mentioned_p (operands[0],\n-\t\t\t\t\t    XEXP (XEXP (word1, 0), 0));\n   if (GET_CODE (operands[0]) == SUBREG)\n     operands[0] = alter_subreg (operands[0]);\n \n-  if (self_reference != 0\n-      && WORDS_BIG_ENDIAN)\n+  if (reg_overlap_mentioned_p (gen_highpart (SFmode, operands[0]), word1))\n     {\n       emit_insn (gen_movsf (gen_lowpart (SFmode, operands[0]),\n \t\t\t    word1));\n@@ -3439,17 +3431,15 @@\n   rtx word1 = change_address (operands[1], DFmode,\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 8));\n   rtx dest1, dest2;\n-  int self_reference = reg_overlap_mentioned_p (operands[0],\n-\t\t\t\t\t\tXEXP (XEXP (word1, 0), 0));\n \n   /* Ugly, but gen_highpart will crap out here for 32-bit targets.  */\n   dest1 = gen_rtx_SUBREG (DFmode, operands[0], WORDS_BIG_ENDIAN == 0);\n   dest2 = gen_rtx_SUBREG (DFmode, operands[0], WORDS_BIG_ENDIAN != 0);\n \n   /* Now output, ordering such that we don't clobber any registers\n      mentioned in the address.  */\n-  if (self_reference != 0\n-      && WORDS_BIG_ENDIAN)\n+  if (reg_overlap_mentioned_p (dest1, word1))\n+\n     {\n       emit_insn (gen_movdf (dest2, word1));\n       emit_insn (gen_movdf (dest1, word0));\n@@ -6626,8 +6616,8 @@\n    operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n    operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n    operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\n-   operands[6] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 2);\n-   operands[7] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 2);\")\n+   operands[6] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]) + 2);\n+   operands[7] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]) + 2);\")\n \n (define_insn \"*negtf2_v9\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")"}]}