{"sha": "391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkxY2QwOTU1ZWIyYTUwMThhZjlmYjc5MWZmZWVhYzE3MWViYjliOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@unitus.it", "date": "2003-02-24T18:22:58Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-02-24T18:22:58Z"}, "message": "PR libstdc++/9404, PR libstdc++/9701 (partial)\n\n2003-02-24  Paolo Carlini <pcarlini@unitus.it>\n\t    Nathan Myers <ncm@cantrip.org>\n\n\tPR libstdc++/9404, PR libstdc++/9701 (partial)\n\t(aka pptr == epptr implies overflow)\n\t* include/bits/fstream.tcc (_M_allocate_internal_buffer):\n\tConsistently, _M_out_end points to the end of the buffer just\n\tcreated.\n\t(overflow): Tweak to use _M_out_buf_size().\n\t(_M_convert_to_external): The role of the old _M_out_end is\n\tnow played by _M_out_lim.\n\t(_M_really_overflow): Likewise.\n\t(seekoff): Likewise.\n\t(setbuf): _M_out_end points to the end of the external buffer.\n\t* include/bits/sstream.tcc (overflow): Rewrote, taking into\n\taccount the resolution of DR 169 (TC).\n\t(seekoff): Use _M_string.capacity(); ios_base::end is now _M_out_lim.\n\t(seekpos): Use _M_string.capacity(); tweak.\n\t* include/bits/streambuf.tcc (sputc, xsputn): Remove comments.\n\t* include/std/std_fstream.h (sync): The role of the old\n\t_M_out_end is now played by _M_out_lim.\n\t(_M_set_indeterminate): Use _M_set_determinate.\n\t(_M_set_determinate): _M_out_end is now _M_out_lim.\n\t(_M_is_indeterminate): Likewise.\n\t* include/std/std_sstream.h (str()): _M_out_end is now _M_out_lim.\n\t(_M_stringbuf_init): Don't set _M_buf_size, unused for sstreams,\n\twhich have the information readily available as _M_string.capacity();\n\tfor ate and app modes, pass the string size to _M_really_sync.\n\t(_M_really_sync): Consistently set _M_out_end and _M_out_lim, to\n\tpoint to the end of the buffer (i.e., epptr) and to the string end,\n\trespectively.\n\t* include/std/std_streambuf.h: tweak comments, add _M_out_lim,\n\twhich points to the right limit of the used put area.\n\t(_M_out_cur_move): The role of the old _M_out_end is now played\n\tby _M_out_lim.\n\t(_M_out_buf_size): Simplify: now (when _M_out_cur) return simply\n\t_M_out_end  - _M_out_cur (i.e., pptr), _very_ close to the letter\n\tof the standard.\n\t(basic_streambuf()): Initialize _M_out_lim too.\n\t* testsuite/27_io/filebuf_virtuals.cc (test10): Trivial tweak.\n\t* testsuite/27_io/filebuf_virtuals.cc (test11): Add.\n \t* testsuite/27_io/stringbuf_virtuals.cc (test09): Add.\n\nCo-Authored-By: Nathan Myers <ncm@cantrip.org>\n\nFrom-SVN: r63367", "tree": {"sha": "8376b0af396f1a5c1994c13b24882ce10a2d45f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8376b0af396f1a5c1994c13b24882ce10a2d45f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/comments", "author": null, "committer": null, "parents": [{"sha": "2e812a0a4109831740d0a30805f63994386be007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e812a0a4109831740d0a30805f63994386be007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e812a0a4109831740d0a30805f63994386be007"}], "stats": {"total": 354, "additions": 249, "deletions": 105}, "files": [{"sha": "30d0c0c049ef48c4c3353bb8ed618fcc223306cc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "patch": "@@ -1,3 +1,46 @@\n+2003-02-24  Paolo Carlini <pcarlini@unitus.it>\n+\t    Nathan Myers <ncm@cantrip.org>\n+\n+\tPR libstdc++/9404, PR libstdc++/9701 (partial)\n+\t(aka pptr == epptr implies overflow)\n+\t* include/bits/fstream.tcc (_M_allocate_internal_buffer):\n+\tConsistently, _M_out_end points to the end of the buffer just\n+\tcreated.\n+\t(overflow): Tweak to use _M_out_buf_size().\n+\t(_M_convert_to_external): The role of the old _M_out_end is\n+\tnow played by _M_out_lim.\n+\t(_M_really_overflow): Likewise.\n+\t(seekoff): Likewise.\n+\t(setbuf): _M_out_end points to the end of the external buffer.\n+\t* include/bits/sstream.tcc (overflow): Rewrote, taking into\n+\taccount the resolution of DR 169 (TC).\n+\t(seekoff): Use _M_string.capacity(); ios_base::end is now _M_out_lim.\n+\t(seekpos): Use _M_string.capacity(); tweak.\n+\t* include/bits/streambuf.tcc (sputc, xsputn): Remove comments.\n+\t* include/std/std_fstream.h (sync): The role of the old\n+\t_M_out_end is now played by _M_out_lim.\n+\t(_M_set_indeterminate): Use _M_set_determinate.\n+\t(_M_set_determinate): _M_out_end is now _M_out_lim.\n+\t(_M_is_indeterminate): Likewise.\n+\t* include/std/std_sstream.h (str()): _M_out_end is now _M_out_lim.\n+\t(_M_stringbuf_init): Don't set _M_buf_size, unused for sstreams,\n+\twhich have the information readily available as _M_string.capacity();\n+\tfor ate and app modes, pass the string size to _M_really_sync.\n+\t(_M_really_sync): Consistently set _M_out_end and _M_out_lim, to\n+\tpoint to the end of the buffer (i.e., epptr) and to the string end,\n+\trespectively.\n+\t* include/std/std_streambuf.h: tweak comments, add _M_out_lim,\n+\twhich points to the right limit of the used put area.\n+\t(_M_out_cur_move): The role of the old _M_out_end is now played\n+\tby _M_out_lim.\n+\t(_M_out_buf_size): Simplify: now (when _M_out_cur) return simply\n+\t_M_out_end  - _M_out_cur (i.e., pptr), _very_ close to the letter\n+\tof the standard.\n+\t(basic_streambuf()): Initialize _M_out_lim too.\n+\t* testsuite/27_io/filebuf_virtuals.cc (test10): Trivial tweak.\n+\t* testsuite/27_io/filebuf_virtuals.cc (test11): Add.\n+ \t* testsuite/27_io/stringbuf_virtuals.cc (test09): Add.\n+\n 2003-02-24  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/27_io/ios_base_storage.cc (main): Call"}, {"sha": "be4b0c029473445f82343fbcdeb71ffeab612f5f", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "patch": "@@ -48,8 +48,10 @@ namespace std\n \t{\n \t  this->_M_buf_size = this->_M_buf_size_opt;\n \n-\t  // Allocate internal buffer.\n-\t  this->_M_buf = new char_type[this->_M_buf_size]; \n+\t  // Allocate internal buffer...\n+\t  this->_M_buf = new char_type[this->_M_buf_size];\n+\t  // ... and consistently set the end of buffer pointer.\n+\t  this->_M_out_end = this->_M_buf + this->_M_buf_size;\n \t  _M_buf_allocated = true;\n \t}\n     }\n@@ -125,7 +127,7 @@ namespace std\n \t{\n \t  const int_type __eof = traits_type::eof();\n \t  bool __testput = this->_M_out_cur\n-\t    && this->_M_out_beg < this->_M_out_end;\n+\t    && this->_M_out_beg < this->_M_out_lim;\n \t  if (__testput \n \t      && traits_type::eq_int_type(_M_really_overflow(__eof), __eof))\n \t    return __ret;\n@@ -245,8 +247,7 @@ namespace std\n     overflow(int_type __c)\n     {\n       int_type __ret = traits_type::eof();\n-      bool __testput = this->_M_out_cur\n-\t&& this->_M_out_cur < this->_M_buf + this->_M_buf_size;\n+      bool __testput = _M_out_buf_size();\n       bool __testout = this->_M_mode & ios_base::out;\n       \n       if (__testout)\n@@ -314,7 +315,7 @@ namespace std\n \t  if (__r == codecvt_base::partial)\n \t    {\n \t      const char_type* __iresume = __iend;\n-\t      streamsize __rlen = this->_M_out_end - __iend;\n+\t      streamsize __rlen = this->_M_out_lim - __iend;\n \t      __r = __cvt.out(_M_state_cur, __iresume, __iresume + __rlen, \n \t\t\t      __iend, __buf, __buf + __blen, __bend);\n \t      if (__r != codecvt_base::error)\n@@ -336,7 +337,7 @@ namespace std\n     _M_really_overflow(int_type __c)\n     {\n       int_type __ret = traits_type::eof();\n-      bool __testput = this->_M_out_cur && this->_M_out_beg < this->_M_out_end;\n+      bool __testput = this->_M_out_cur && this->_M_out_beg < this->_M_out_lim;\n       bool __testunbuffered = _M_file.is_open() && !this->_M_buf_size_opt;\n \n       if (__testput || __testunbuffered)\n@@ -358,7 +359,7 @@ namespace std\n \t  // NB: In the unbuffered case, no internal buffer exists. \n \t  if (!__testunbuffered)\n \t    _M_convert_to_external(this->_M_out_beg,\n-\t\t\t\t   this->_M_out_end - this->_M_out_beg, \n+\t\t\t\t   this->_M_out_lim - this->_M_out_beg, \n \t\t\t\t   __elen, __plen);\n \n \t  // Convert pending sequence to external representation, output.\n@@ -398,12 +399,15 @@ namespace std\n \t  // that an external char_type array of length (__s + __n)\n \t  // exists and has been pre-allocated. If this is not the\n \t  // case, things will quickly blow up.\n+\n \t  // Step 1: Destroy the current internal array.\n \t  _M_destroy_internal_buffer();\n \t  \n \t  // Step 2: Use the external array.\n \t  this->_M_buf = __s;\n \t  this->_M_buf_size_opt = this->_M_buf_size = __n;\n+\t  // Consistently set the end of buffer pointer.\n+\t  this->_M_out_end = this->_M_buf + this->_M_buf_size;\n \t  _M_set_indeterminate();\n \t}\n       _M_last_overflowed = false;\t\n@@ -437,7 +441,7 @@ namespace std\n \t      bool __testget = this->_M_in_cur\n \t\t&& this->_M_in_beg < this->_M_in_end;\n \t      bool __testput = this->_M_out_cur\n-\t\t&& this->_M_out_beg < this->_M_out_end;\n+\t\t&& this->_M_out_beg < this->_M_out_lim;\n \t      // Sync the internal and external streams.\n \t      // out\n \t      if (__testput || _M_last_overflowed)"}, {"sha": "5f9f62e93427deada42a3077e7a28cb2ec869e50", "filename": "libstdc++-v3/include/bits/sstream.tcc", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc?ref=391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "patch": "@@ -80,38 +80,35 @@ namespace std\n     basic_stringbuf<_CharT, _Traits, _Alloc>::\n     overflow(int_type __c)\n     {\n-      int_type __ret = traits_type::eof();\n-      bool __testeof = traits_type::eq_int_type(__c, __ret);\n-      bool __testwrite = this->_M_out_cur < this->_M_buf + this->_M_buf_size;\n       bool __testout = this->_M_mode & ios_base::out;\n+      if (__builtin_expect(!__testout, false))\n+\treturn traits_type::eof();\n+      bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());\n+      if (__builtin_expect(__testeof, false))\n+\treturn traits_type::not_eof(__c);\n+\n+      // In virtue of DR 169 (TC) we are allowed to grow more than\n+      // one char the first time and also...\n+      __size_type __len =\n+\tstd::max(_M_string.capacity() + 1, this->_M_buf_size_opt);\n+\n+      bool __testwrite = _M_out_buf_size();\n+      if (__builtin_expect(!__testwrite && __len > _M_string.max_size(), false))\n+\treturn traits_type::eof();\n \n       // Try to append __c into output sequence in one of two ways.\n       // Order these tests done in is unspecified by the standard.\n-      if (__testout)\n+      if (!__testwrite)\n \t{\n-\t  if (!__testeof)\n-\t    {\n-\t      __size_type __len = std::max(this->_M_buf_size, \n-\t\t\t\t\t   this->_M_buf_size_opt);\n-\t      __len *= 2;\n-\n-\t      if (__testwrite)\n-\t\t__ret = this->sputc(traits_type::to_char_type(__c));\n-\t      else if (__len <= _M_string.max_size())\n-\t\t{\n-\t\t  // Force-allocate, re-sync.\n-\t\t  _M_string = this->str();\n-\t\t  _M_string.reserve(__len);\n-\t\t  this->_M_buf_size = __len;\n-\t\t  _M_really_sync(this->_M_in_cur - this->_M_in_beg, \n-\t\t\t\t this->_M_out_cur - this->_M_out_beg);\n-\t\t  __ret = this->sputc(traits_type::to_char_type(__c));\n-\t\t}\n-\t    }\n-\t  else\n-\t    __ret = traits_type::not_eof(__c);\n+\t  // Force-allocate, re-sync.\n+\t  _M_string = this->str();\n+\t  // ... the next times. That's easy to implement thanks to the\n+\t  // exponential growth policy builtin into basic_string.\n+\t  _M_string.reserve(__len);\n+\t  _M_really_sync(this->_M_in_cur - this->_M_in_beg, \n+\t\t\t this->_M_out_cur - this->_M_out_beg);\n \t}\n-      return __ret;\n+      return this->sputc(traits_type::to_char_type(__c));\n     }\n \n   template <class _CharT, class _Traits, class _Alloc>\n@@ -126,7 +123,7 @@ namespace std\n       __testin &= !(__mode & ios_base::out);\n       __testout &= !(__mode & ios_base::in);\n \n-      if (this->_M_buf_size && (__testin || __testout || __testboth))\n+      if (_M_string.capacity() && (__testin || __testout || __testboth))\n \t{\n \t  char_type* __beg = this->_M_buf;\n \t  char_type* __curi = NULL;\n@@ -142,7 +139,9 @@ namespace std\n \t  if (__testout || __testboth)\n \t    {\n \t      __curo = this->pptr();\n-\t      __endo = this->epptr();\n+\t      // Due to the resolution of DR169, ios_base::end\n+\t      // is this->_M_out_lim, not epptr().\n+\t      __endo = this->_M_out_lim;\n \t    }\n \n \t  off_type __newoffi = 0;\n@@ -181,7 +180,7 @@ namespace std\n     {\n       pos_type __ret =  pos_type(off_type(-1)); \n       \n-      if (this->_M_buf_size)\n+      if (_M_string.capacity())\n \t{\n \t  off_type __pos = __sp; // Use streamoff operator to do conversion.\n \t  char_type* __beg = NULL;\n@@ -205,7 +204,7 @@ namespace std\n \t  if (__testout || __testboth)\n \t    {\n \t      __beg = this->pbase();\n-\t      __end = this->_M_buf + this->_M_buf_size;\n+\t      __end = this->epptr();\n \t      if (0 <= __pos && __pos <= __end - __beg)\n \t\t__testposo = true;\n \t    }"}, {"sha": "c14139988af3b0e2b38d2de4dff316d4c46e9241", "filename": "libstdc++-v3/include/bits/streambuf.tcc", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc?ref=391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "patch": "@@ -93,11 +93,6 @@ namespace std\n       return __ret;\n     }\n \n-  // Don't test against _M_buf + _M_buf_size, because _M_buf reflects\n-  // allocated space, and on certain (rare but entirely legal)\n-  // situations, there will be no allocated space yet the internal\n-  // buffers will still be valid. (This happens if setp is used to set\n-  // the internal buffer to say some externally-allocated sequence.)\n   template<typename _CharT, typename _Traits>\n     typename basic_streambuf<_CharT, _Traits>::int_type\n     basic_streambuf<_CharT, _Traits>::\n@@ -149,11 +144,6 @@ namespace std\n       return __ret;\n     }\n \n-  // Don't test against _M_buf + _M_buf_size, because _M_buf reflects\n-  // allocated space, and on certain (rare but entirely legal)\n-  // situations, there will be no allocated space yet the internal\n-  // buffers will still be valid. (This happens if setp is used to set\n-  // the internal buffer to say some externally-allocated sequence.)\n   template<typename _CharT, typename _Traits>\n     streamsize\n     basic_streambuf<_CharT, _Traits>::"}, {"sha": "6dd75dd1bba3929a835a2d8a8c6b6d2c857fefd8", "filename": "libstdc++-v3/include/std/std_fstream.h", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h?ref=391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "patch": "@@ -312,14 +312,14 @@ namespace std\n       sync()\n       {\n \tbool __testput = this->_M_out_cur\n-\t  && this->_M_out_beg < this->_M_out_end;\n+\t  && this->_M_out_beg < this->_M_out_lim;\n \n \t// Make sure that the internal buffer resyncs its idea of\n \t// the file position with the external file.\n \tif (__testput)\n \t  {\n \t    // Need to restore current position after the write.\n-\t    off_type __off = this->_M_out_cur - this->_M_out_end;\n+\t    off_type __off = this->_M_out_cur - this->_M_out_lim;\n \t    _M_really_overflow(); // _M_file.sync() will be called within\n \t    if (__off)\n \t      _M_file.seekoff(__off, ios_base::cur);\n@@ -387,11 +387,7 @@ namespace std\n       void\n       _M_set_indeterminate(void)\n       {\n-\tif (this->_M_mode & ios_base::in)\n-\t  this->setg(this->_M_buf, this->_M_buf, this->_M_buf);\n-\tif (this->_M_mode & ios_base::out)\n-\t  this->setp(this->_M_buf, this->_M_buf);\n-\t_M_filepos = this->_M_buf;\n+\t_M_set_determinate(off_type(0));\n       }\n \n       /**\n@@ -405,9 +401,15 @@ namespace std\n \tbool __testin = this->_M_mode & ios_base::in;\n \tbool __testout = this->_M_mode & ios_base::out;\n \tif (__testin)\n-\t  this->setg(this->_M_buf, this->_M_buf, this->_M_buf + __off);\n+\t  {\n+\t    this->_M_in_beg = this->_M_in_cur = this->_M_buf;\n+\t    this->_M_in_end = this->_M_buf + __off;\n+\t  }\n \tif (__testout)\n-\t  this->setp(this->_M_buf, this->_M_buf + __off);\n+\t  {\n+\t    this->_M_out_beg = this->_M_out_cur = this->_M_buf;\n+\t    this->_M_out_lim = this->_M_buf + __off;\n+\t  }\n \t_M_filepos = this->_M_buf + __off;\n       }\n \n@@ -419,16 +421,18 @@ namespace std\n       bool\n       _M_is_indeterminate(void)\n       { \n+\tbool __testin = this->_M_mode & ios_base::in;\n+\tbool __testout = this->_M_mode & ios_base::out;\n \tbool __ret = false;\n \t// Don't return true if unbuffered.\n \tif (this->_M_buf)\n \t  {\n-\t    if (this->_M_mode & ios_base::in)\n+\t    if (__testin)\n \t      __ret = this->_M_in_beg == this->_M_in_cur\n \t\t&& this->_M_in_cur == this->_M_in_end;\n-\t    if (this->_M_mode & ios_base::out)\n+\t    if (__testout)\n \t      __ret = this->_M_out_beg == this->_M_out_cur\n-\t\t&& this->_M_out_cur == this->_M_out_end;\n+\t\t&& this->_M_out_cur == this->_M_out_lim;\n \t  }\n \treturn __ret;\n       }"}, {"sha": "cb538b563040deffbad5b02e387b3dd90d42a172", "filename": "libstdc++-v3/include/std/std_sstream.h", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h?ref=391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "patch": "@@ -140,8 +140,8 @@ namespace std\n \t    // _M_string, and may not be the correct size of the\n \t    // current stringbuf internal buffer.\n \t    __size_type __len = _M_string.size();\n-\t    if (this->_M_out_end > this->_M_out_beg)\n-\t      __len = std::max(__size_type(this->_M_out_end \n+\t    if (this->_M_out_lim > this->_M_out_beg)\n+\t      __len = std::max(__size_type(this->_M_out_lim \n \t\t\t\t\t   - this->_M_out_beg), __len);\n \t    return __string_type(this->_M_out_beg, this->_M_out_beg + __len);\n \t  }\n@@ -174,21 +174,14 @@ namespace std\n       void\n       _M_stringbuf_init(ios_base::openmode __mode)\n       {\n-\t// _M_buf_size is a convenient alias for \"what the streambuf\n-\t// thinks the allocated size of the string really is.\" This is\n-\t// necessary as ostringstreams are implemented with the\n-\t// streambufs having control of the allocation and\n-\t// re-allocation of the internal string object, _M_string.\n-\tthis->_M_buf_size = _M_string.size();\n-\n \t// NB: Start ostringstream buffers at 512 bytes. This is an\n \t// experimental value (pronounced \"arbitrary\" in some of the\n \t// hipper english-speaking countries), and can be changed to\n \t// suit particular needs.\n \tthis->_M_buf_size_opt = 512;\n \tthis->_M_mode = __mode;\n \tif (this->_M_mode & (ios_base::ate | ios_base::app))\n-\t  _M_really_sync(0, this->_M_buf_size);\n+\t  _M_really_sync(0, _M_string.size());\n \telse\n \t  _M_really_sync(0, 0);\n       }\n@@ -268,7 +261,9 @@ namespace std\n \t    this->setg(__base, __base + __i, __base + __len);\n \tif (__testout)\n \t  {\n-\t    this->setp(__base, __base + __len);\n+\t    this->setp(__base, __base + _M_string.capacity());\n+\t    // _M_out_lim points to the string end.\n+\t    this->_M_out_lim = __base + __len;\n \t    this->_M_out_cur += __o;\n \t  }\n \treturn 0;"}, {"sha": "850f2015530056e10bcca1686ced6aa66762f632", "filename": "libstdc++-v3/include/std/std_streambuf.h", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h?ref=391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "patch": "@@ -172,7 +172,8 @@ namespace std\n \n       /**\n        *  @if maint\n-       *  Actual size of allocated internal buffer, in bytes.\n+       *  Actual size of allocated internal buffer, in bytes. Unused\n+       *  for sstreams, which have readily available _M_string.capacity().\n        *  @endif\n       */\n       size_t\t\t\t_M_buf_size;\n@@ -202,12 +203,15 @@ namespace std\n        *  -  put == output == write\n        *  @endif\n       */\n-      char_type* \t\t_M_in_beg;  \t// Start of get area. \n-      char_type* \t\t_M_in_cur;\t// Current read area. \n-      char_type* \t\t_M_in_end;\t// End of get area. \n-      char_type* \t\t_M_out_beg; \t// Start of put area. \n-      char_type* \t\t_M_out_cur;  \t// Current put area. \n-      char_type* \t\t_M_out_end;  \t// End of put area. \n+      char_type* \t\t_M_in_beg;     // Start of get area. \n+      char_type* \t\t_M_in_cur;     // Current read area. \n+      char_type* \t\t_M_in_end;     // End of get area. \n+      char_type* \t\t_M_out_beg;    // Start of put area. \n+      char_type* \t\t_M_out_cur;    // Current put area. \n+      char_type* \t\t_M_out_end;    // End of put area.\n+\n+      char_type*                _M_out_lim;    // Right limit of used put area.\n+\n       //@}\n \n       /**\n@@ -305,13 +309,13 @@ namespace std\n       }\n \n       // Correctly sets the _M_out_cur pointer, and bumps the\n-      // appropriate _M_*_end pointers as well. Necessary for the\n-      // un-tied stringbufs, in in|out mode.\n+      // appropriate _M_out_lim and _M_in_end pointers as well. Necessary\n+      // for the un-tied stringbufs, in in|out mode.\n       // Invariant:\n-      // __n + _M_out_[cur, end] <= _M_buf + _M_buf_size\n-      // Assuming all _M_*_[beg, cur, end] pointers are operating on\n+      // __n + _M_out_[cur, lim] <= _M_out_end\n+      // Assuming all _M_out_[beg, cur, lim] pointers are operating on\n       // the same range:\n-      // _M_buf <= _M_*_ <= _M_buf + _M_buf_size\n+      // _M_buf <= _M_*_ <= _M_out_end\n       void \n       _M_out_cur_move(off_type __n) // argument needs to be +-\n       {\n@@ -320,32 +324,23 @@ namespace std\n \t_M_out_cur += __n;\n \tif (__testin && _M_buf_unified)\n \t  _M_in_cur += __n;\n-\tif (_M_out_cur > _M_out_end)\n+\tif (_M_out_cur > _M_out_lim)\n \t  {\n-\t    _M_out_end = _M_out_cur;\n+\t    _M_out_lim = _M_out_cur;\n \t    // NB: in | out buffers drag the _M_in_end pointer along...\n \t    if (__testin)\n \t      _M_in_end += __n;\n \t  }\n       }\n \n-      // Return the size of the output buffer.  This depends on the\n-      // buffer in use: allocated buffers have a stored size in\n-      // _M_buf_size and setbuf() buffers don't.\n+      // Returns zero if the output buffer is full (-> overflow).\n       off_type\n       _M_out_buf_size()\n       {\n-\toff_type __ret = 0;\n \tif (_M_out_cur)\n-\t  {\n-\t    // Using allocated buffer.\n-\t    if (_M_out_beg == _M_buf)\n-\t      __ret = _M_out_beg + _M_buf_size - _M_out_cur;\n-\t    // Using non-allocated buffer.\n-\t    else\n-\t      __ret = _M_out_end - _M_out_cur;\n-\t  }\n-\treturn __ret;\n+\t  return _M_out_end - _M_out_cur;\n+\telse\n+\t  return off_type(0);\n       }\n \n   public:\n@@ -568,8 +563,8 @@ namespace std\n       */\n       basic_streambuf()\n       : _M_buf(NULL), _M_buf_size(0), _M_buf_size_opt(BUFSIZ), \n-      _M_buf_unified(false), _M_in_beg(0), _M_in_cur(0), _M_in_end(0), \n-      _M_out_beg(0), _M_out_cur(0), _M_out_end(0), \n+      _M_buf_unified(false), _M_in_beg(0), _M_in_cur(0), _M_in_end(0),\n+      _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_out_lim(0),\n       _M_mode(ios_base::openmode(0)), _M_buf_locale(locale()), \n       _M_pback_cur_save(0), _M_pback_end_save(0), \n       _M_pback_init(false)\n@@ -666,7 +661,7 @@ namespace std\n       setp(char_type* __pbeg, char_type* __pend)\n       { \n \t_M_out_beg = _M_out_cur = __pbeg; \n-\t_M_out_end = __pend; \n+\t_M_out_end = __pend;\n \tif (!(_M_mode & ios_base::out) && __pbeg && __pend)\n \t  _M_mode = _M_mode | ios_base::out;\n       }"}, {"sha": "fc9262f8e75007ac25c9464df99e39b8348cfbfb", "filename": "libstdc++-v3/testsuite/27_io/filebuf_virtuals.cc", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals.cc?ref=391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "patch": "@@ -71,7 +71,8 @@ const char carray_02[] = \"memphis, new orleans, and savanah\";\n const char name_01[] = \"filebuf_virtuals-1.txt\"; // file with data in it\n const char name_02[] = \"filebuf_virtuals-2.txt\"; // empty file, need to create\n const char name_03[] = \"filebuf_virtuals-3.txt\"; // empty file, need to create\n-\n+const char name_04[] = \"filebuf_virtuals-4.txt\"; // empty file, need to create\n+const char name_05[] = \"filebuf_virtuals-5.txt\"; // empty file, need to create\n \n class derived_filebuf: public std::filebuf\n {\n@@ -607,14 +608,14 @@ void test10()\n   {\n     ofstream out;\n     out.imbue(loc);\n-    out.open(\"filebuf_virtuals-4.txt\");\n+    out.open(name_04);\n     copy(str.begin(), str.end(),\n \t ostreambuf_iterator<char>(out));\n   }\n \n   {\n     ifstream in;\n-    in.open(\"filebuf_virtuals-4.txt\");\n+    in.open(name_04);\n     copy(istreambuf_iterator<char>(in),\n \t istreambuf_iterator<char>(),\n \t back_inserter(tmp));\n@@ -624,6 +625,62 @@ void test10()\n   VERIFY( tmp == str );\n }\n \n+bool over_called;\n+\n+class Derived_filebuf : public std::filebuf\n+{\n+public:\n+  int_type overflow(int_type c)\n+  {\n+    over_called = true;\n+    return std::filebuf::overflow(c);\n+  }\n+  \n+  const char_type* pub_epptr() const\n+  {\n+    return epptr();\n+  }\n+  \n+  const char_type* pub_pptr() const\n+  {\n+    return pptr();\n+  }\n+};\n+\n+// libstdc++/9701 (partial)\n+void test11()\n+{\n+  bool test = true;\n+\n+  bool over_expected;\n+\n+  // sputc\n+  Derived_filebuf dfbuf_01;\n+  dfbuf_01.open(name_05, std::ios_base::out);\n+  over_called = false;\n+  dfbuf_01.sputc('i');\n+  VERIFY( !over_called );\n+  over_expected = dfbuf_01.pub_epptr() == dfbuf_01.pub_pptr();\n+  over_called = false;\n+  dfbuf_01.sputc('v');\n+  VERIFY( (!over_expected && !over_called)\n+\t  || (over_expected && over_called) );\n+  dfbuf_01.close();\n+\n+  // sputn\n+  Derived_filebuf dfbuf_02;\n+  dfbuf_02.open(name_05, std::ios_base::out);\n+  over_called = false;\n+  dfbuf_02.sputn(\"sonne's\", 7);\n+  VERIFY( !over_called );\n+  over_expected = dfbuf_02.pub_epptr() == dfbuf_02.pub_pptr();\n+  over_called = false;\n+  dfbuf_02.sputn(\" peak\", 5);\n+  VERIFY( (!over_expected && !over_called)\n+\t  || (over_expected && over_called) );\n+  dfbuf_02.close();\n+}\n+\n main() \n {\n   test01();\n@@ -638,5 +695,6 @@ main()\n   test08();\n   test09();\n   test10();\n+  test11();\n   return 0;\n }"}, {"sha": "a2a8368abfc6798f1d62defdeead6375807a87f9", "filename": "libstdc++-v3/testsuite/27_io/stringbuf_virtuals.cc", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf_virtuals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391cd0955eb2a5018af9fb791ffeeac171ebb9b9/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf_virtuals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf_virtuals.cc?ref=391cd0955eb2a5018af9fb791ffeeac171ebb9b9", "patch": "@@ -92,6 +92,61 @@ void test08()\n   VERIFY( ob.getloc() == loc_de );\n }\n \n+bool over_called;\n+\n+class Derived_stringbuf : public std::stringbuf\n+{\n+public:\n+  int_type overflow(int_type c)\n+  {\n+    over_called = true;\n+    return std::stringbuf::overflow(c);\n+  }\n+  \n+  const char_type* pub_epptr() const\n+  {\n+    return epptr();\n+  }\n+  \n+  const char_type* pub_pptr() const\n+  {\n+    return pptr();\n+  }\n+};\n+\n+// libstdc++/9404\n+void test09()\n+{\n+  bool test = true;\n+\n+  bool over_expected;\n+\n+  // sputc\n+  Derived_stringbuf dsbuf_01;\n+  over_called = false;\n+  dsbuf_01.sputc('i');\n+  VERIFY( over_called );\n+  over_expected = dsbuf_01.pub_epptr() == dsbuf_01.pub_pptr();\n+  over_called = false;\n+  dsbuf_01.sputc('v');\n+  VERIFY( (!over_expected && !over_called)\n+\t  || (over_expected && over_called) );\n+  dsbuf_01.sputc('i');\n+  VERIFY( dsbuf_01.str() == \"ivi\" ); // Sanity check.\n+\n+  // sputn\n+  Derived_stringbuf dsbuf_02;\n+  over_called = false;\n+  dsbuf_02.sputn(\"sonne's\", 7);\n+  VERIFY( over_called );\n+  over_expected = dsbuf_02.pub_epptr() == dsbuf_02.pub_pptr();\n+  over_called = false;\n+  dsbuf_02.sputn(\" peak\", 5);\n+  VERIFY( (!over_expected && !over_called)\n+\t  || (over_expected && over_called) );\n+  VERIFY( dsbuf_02.str() == \"sonne's peak\" ); // Sanity check.\n+}\n+\n int main() \n {\n   using namespace std;\n@@ -106,5 +161,6 @@ int main()\n   test02(in3, false);\n \n   test08();\n+  test09();\n   return 0;\n }"}]}