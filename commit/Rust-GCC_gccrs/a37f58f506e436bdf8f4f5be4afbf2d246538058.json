{"sha": "a37f58f506e436bdf8f4f5be4afbf2d246538058", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM3ZjU4ZjUwNmU0MzZiZGY4ZjRmNWJlNGFmYmYyZDI0NjUzODA1OA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-11-14T08:35:25Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-11-14T08:35:25Z"}, "message": "Use func_checker::hash_operand for hashing of GIMPLE operands.\n\n2019-11-14  Martin Liska  <mliska@suse.cz>\n\n\t* ipa-icf-gimple.h (func_checker::func_checker): Add\n\tdefault constructor.\n\t* ipa-icf.c (sem_function::init): Make operand_equal_p\n\tand hash_operand public.\n\t(sem_item::add_expr): Remove.\n\t(sem_item::add_type): Remove.\n\t(sem_function::hash_stmt): Use m_checker for hashing\n\tof GIMPLE statements.\n\t(sem_function::parse): Init with checker.\n\t(sem_variable::parse): Pass NULL as checker.\n\t(sem_item_optimizer::parse_funcs_and_vars):\n\tPass checker to ::parse function.\n\t(sem_item_optimizer::parse_nonsingleton_classes): Likewise.\n\t(sem_variable::parse): New function.\n\t(sem_variable::get_hash): Only return computed hash value.\n\t(sem_variable::init): Initialize hash of a variable.\n\t* ipa-icf.h: Remove add_expr, add_type and add func_checker\n\tto couple of functions as a new argument.\n\nFrom-SVN: r278207", "tree": {"sha": "d38650119a98e2f0c28c37b44b54bf5daa1344a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d38650119a98e2f0c28c37b44b54bf5daa1344a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a37f58f506e436bdf8f4f5be4afbf2d246538058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a37f58f506e436bdf8f4f5be4afbf2d246538058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a37f58f506e436bdf8f4f5be4afbf2d246538058", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a37f58f506e436bdf8f4f5be4afbf2d246538058/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d0152bf59a626fd01b64c95bb8d91d890d93820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d0152bf59a626fd01b64c95bb8d91d890d93820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d0152bf59a626fd01b64c95bb8d91d890d93820"}], "stats": {"total": 291, "additions": 81, "deletions": 210}, "files": [{"sha": "e60da6e03227b399a308042b05c16d5b5620baea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37f58f506e436bdf8f4f5be4afbf2d246538058/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37f58f506e436bdf8f4f5be4afbf2d246538058/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a37f58f506e436bdf8f4f5be4afbf2d246538058", "patch": "@@ -1,3 +1,24 @@\n+2019-11-14  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-icf-gimple.h (func_checker::func_checker): Add\n+\tdefault constructor.\n+\t* ipa-icf.c (sem_function::init): Make operand_equal_p\n+\tand hash_operand public.\n+\t(sem_item::add_expr): Remove.\n+\t(sem_item::add_type): Remove.\n+\t(sem_function::hash_stmt): Use m_checker for hashing\n+\tof GIMPLE statements.\n+\t(sem_function::parse): Init with checker.\n+\t(sem_variable::parse): Pass NULL as checker.\n+\t(sem_item_optimizer::parse_funcs_and_vars):\n+\tPass checker to ::parse function.\n+\t(sem_item_optimizer::parse_nonsingleton_classes): Likewise.\n+\t(sem_variable::parse): New function.\n+\t(sem_variable::get_hash): Only return computed hash value.\n+\t(sem_variable::init): Initialize hash of a variable.\n+\t* ipa-icf.h: Remove add_expr, add_type and add func_checker\n+\tto couple of functions as a new argument.\n+\n 2019-11-14  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-icf-gimple.c (func_checker::compare_gimple_call): Update"}, {"sha": "b59d05fd605b1f887b69a1738dc761a9874a2247", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37f58f506e436bdf8f4f5be4afbf2d246538058/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37f58f506e436bdf8f4f5be4afbf2d246538058/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=a37f58f506e436bdf8f4f5be4afbf2d246538058", "patch": "@@ -121,6 +121,16 @@ class sem_bb\n class func_checker : operand_compare\n {\n public:\n+  /* Default constructor.  */\n+  func_checker ():\n+    m_source_func_decl (NULL_TREE), m_target_func_decl (NULL_TREE),\n+    m_ignored_source_nodes (NULL), m_ignored_target_nodes (NULL),\n+    m_ignore_labels (false)\n+  {\n+    m_source_ssa_names.create (0);\n+    m_target_ssa_names.create (0);\n+  }\n+\n   /* Initialize internal structures for a given SOURCE_FUNC_DECL and\n      TARGET_FUNC_DECL. Strict polymorphic comparison is processed if\n      an option COMPARE_POLYMORPHIC is true. For special cases, one can\n@@ -254,6 +264,7 @@ class func_checker : operand_compare\n   /* Flag if ignore labels in comparison.  */\n   bool m_ignore_labels;\n \n+public:\n   /* Return true if two operands are equal.  The flags fields can be used\n      to specify OEP flags described above.  */\n   virtual bool operand_equal_p (const_tree, const_tree, unsigned int flags);"}, {"sha": "8297eec93883a2bb1553f2641649a11cb0e824d5", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 42, "deletions": 197, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37f58f506e436bdf8f4f5be4afbf2d246538058/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37f58f506e436bdf8f4f5be4afbf2d246538058/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=a37f58f506e436bdf8f4f5be4afbf2d246538058", "patch": "@@ -1335,8 +1335,9 @@ sem_function::merge (sem_item *alias_item)\n /* Semantic item initialization function.  */\n \n void\n-sem_function::init (void)\n+sem_function::init (ipa_icf_gimple::func_checker *checker)\n {\n+  m_checker = checker;\n   if (in_lto_p)\n     get_node ()->get_untransformed_body ();\n \n@@ -1411,161 +1412,6 @@ sem_function::init (void)\n     }\n }\n \n-/* Accumulate to HSTATE a hash of expression EXP.\n-   Identical to inchash::add_expr, but guaranteed to be stable across LTO\n-   and DECL equality classes.  */\n-\n-void\n-sem_item::add_expr (const_tree exp, inchash::hash &hstate)\n-{\n-  if (exp == NULL_TREE)\n-    {\n-      hstate.merge_hash (0);\n-      return;\n-    }\n-\n-  /* Handled component can be matched in a cureful way proving equivalence\n-     even if they syntactically differ.  Just skip them.  */\n-  STRIP_NOPS (exp);\n-  while (handled_component_p (exp))\n-    exp = TREE_OPERAND (exp, 0);\n-\n-  enum tree_code code = TREE_CODE (exp);\n-  hstate.add_int (code);\n-\n-  switch (code)\n-    {\n-    /* Use inchash::add_expr for everything that is LTO stable.  */\n-    case VOID_CST:\n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case FIXED_CST:\n-    case STRING_CST:\n-    case COMPLEX_CST:\n-    case VECTOR_CST:\n-      inchash::add_expr (exp, hstate);\n-      break;\n-    case CONSTRUCTOR:\n-      {\n-\tunsigned HOST_WIDE_INT idx;\n-\ttree value;\n-\n-\thstate.add_hwi (int_size_in_bytes (TREE_TYPE (exp)));\n-\n-\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), idx, value)\n-\t  if (value)\n-\t    add_expr (value, hstate);\n-\tbreak;\n-      }\n-    case ADDR_EXPR:\n-    case FDESC_EXPR:\n-      add_expr (get_base_address (TREE_OPERAND (exp, 0)), hstate);\n-      break;\n-    case SSA_NAME:\n-    case VAR_DECL:\n-    case CONST_DECL:\n-    case PARM_DECL:\n-      hstate.add_hwi (int_size_in_bytes (TREE_TYPE (exp)));\n-      break;\n-    case MEM_REF:\n-    case POINTER_PLUS_EXPR:\n-    case MINUS_EXPR:\n-    case RANGE_EXPR:\n-      add_expr (TREE_OPERAND (exp, 0), hstate);\n-      add_expr (TREE_OPERAND (exp, 1), hstate);\n-      break;\n-    case PLUS_EXPR:\n-      {\n-\tinchash::hash one, two;\n-\tadd_expr (TREE_OPERAND (exp, 0), one);\n-\tadd_expr (TREE_OPERAND (exp, 1), two);\n-\thstate.add_commutative (one, two);\n-      }\n-      break;\n-    CASE_CONVERT:\n-      hstate.add_hwi (int_size_in_bytes (TREE_TYPE (exp)));\n-      return add_expr (TREE_OPERAND (exp, 0), hstate);\n-    default:\n-      break;\n-    }\n-}\n-\n-/* Accumulate to HSTATE a hash of type t.\n-   TYpes that may end up being compatible after LTO type merging needs to have\n-   the same hash.  */\n-\n-void\n-sem_item::add_type (const_tree type, inchash::hash &hstate)\n-{\n-  if (type == NULL_TREE)\n-    {\n-      hstate.merge_hash (0);\n-      return;\n-    }\n-\n-  type = TYPE_MAIN_VARIANT (type);\n-\n-  hstate.add_int (TYPE_MODE (type));\n-\n-  if (TREE_CODE (type) == COMPLEX_TYPE)\n-    {\n-      hstate.add_int (COMPLEX_TYPE);\n-      sem_item::add_type (TREE_TYPE (type), hstate);\n-    }\n-  else if (INTEGRAL_TYPE_P (type))\n-    {\n-      hstate.add_int (INTEGER_TYPE);\n-      hstate.add_flag (TYPE_UNSIGNED (type));\n-      hstate.add_int (TYPE_PRECISION (type));\n-    }\n-  else if (VECTOR_TYPE_P (type))\n-    {\n-      hstate.add_int (VECTOR_TYPE);\n-      hstate.add_int (TYPE_PRECISION (type));\n-      sem_item::add_type (TREE_TYPE (type), hstate);\n-    }\n-  else if (TREE_CODE (type) == ARRAY_TYPE)\n-    {\n-      hstate.add_int (ARRAY_TYPE);\n-      /* Do not hash size, so complete and incomplete types can match.  */\n-      sem_item::add_type (TREE_TYPE (type), hstate);\n-    }\n-  else if (RECORD_OR_UNION_TYPE_P (type))\n-    {\n-      /* Incomplete types must be skipped here.  */\n-      if (!COMPLETE_TYPE_P (type))\n-\t{\n-\t  hstate.add_int (RECORD_TYPE);\n-\t  return;\n-\t}\n-\n-      hashval_t *val = m_type_hash_cache.get (type);\n-\n-      if (!val)\n-\t{\n-\t  inchash::hash hstate2;\n-\t  unsigned nf;\n-\t  tree f;\n-\t  hashval_t hash;\n-\n-\t  hstate2.add_int (RECORD_TYPE);\n-\t  for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n-\t    if (TREE_CODE (f) == FIELD_DECL)\n-\t      {\n-\t\tadd_type (TREE_TYPE (f), hstate2);\n-\t\tnf++;\n-\t      }\n-\n-\t  hstate2.add_int (nf);\n-\t  hash = hstate2.end ();\n-\t  hstate.add_hwi (hash);\n-\t  m_type_hash_cache.put (type, hash);\n-\t}\n-      else\n-        hstate.add_hwi (*val);\n-    }\n-}\n-\n /* Improve accumulated hash for HSTATE based on a gimple statement STMT.  */\n \n void\n@@ -1578,27 +1424,19 @@ sem_function::hash_stmt (gimple *stmt, inchash::hash &hstate)\n   switch (code)\n     {\n     case GIMPLE_SWITCH:\n-      add_expr (gimple_switch_index (as_a <gswitch *> (stmt)), hstate);\n+      m_checker->hash_operand (gimple_switch_index (as_a <gswitch *> (stmt)),\n+\t\t\t     hstate, 0);\n       break;\n     case GIMPLE_ASSIGN:\n       hstate.add_int (gimple_assign_rhs_code (stmt));\n       if (commutative_tree_code (gimple_assign_rhs_code (stmt))\n \t  || commutative_ternary_tree_code (gimple_assign_rhs_code (stmt)))\n \t{\n-\t  inchash::hash one, two;\n-\n-\t  add_expr (gimple_assign_rhs1 (stmt), one);\n-\t  add_type (TREE_TYPE (gimple_assign_rhs1 (stmt)), one);\n-\t  add_expr (gimple_assign_rhs2 (stmt), two);\n-\t  hstate.add_commutative (one, two);\n+\t  m_checker->hash_operand (gimple_assign_rhs1 (stmt), hstate, 0);\n+\t  m_checker->hash_operand (gimple_assign_rhs2 (stmt), hstate, 0);\n \t  if (commutative_ternary_tree_code (gimple_assign_rhs_code (stmt)))\n-\t    {\n-\t      add_expr (gimple_assign_rhs3 (stmt), hstate);\n-\t      add_type (TREE_TYPE (gimple_assign_rhs3 (stmt)), hstate);\n-\t    }\n-\t  add_expr (gimple_assign_lhs (stmt), hstate);\n-\t  add_type (TREE_TYPE (gimple_assign_lhs (stmt)), two);\n-\t  break;\n+\t    m_checker->hash_operand (gimple_assign_rhs3 (stmt), hstate, 0);\n+\t  m_checker->hash_operand (gimple_assign_lhs (stmt), hstate, 0);\n \t}\n       /* fall through */\n     case GIMPLE_CALL:\n@@ -1608,11 +1446,7 @@ sem_function::hash_stmt (gimple *stmt, inchash::hash &hstate)\n     case GIMPLE_RETURN:\n       /* All these statements are equivalent if their operands are.  */\n       for (unsigned i = 0; i < gimple_num_ops (stmt); ++i)\n-\t{\n-\t  add_expr (gimple_op (stmt, i), hstate);\n-\t  if (gimple_op (stmt, i))\n-\t    add_type (TREE_TYPE (gimple_op (stmt, i)), hstate);\n-\t}\n+\tm_checker->hash_operand (gimple_op (stmt, i), hstate, 0);\n       /* Consider nocf_check attribute in hash as it affects code\n  \t generation.  */\n       if (code == GIMPLE_CALL\n@@ -1648,7 +1482,8 @@ sem_function::compare_polymorphic_p (void)\n    semantic function item.  */\n \n sem_function *\n-sem_function::parse (cgraph_node *node, bitmap_obstack *stack)\n+sem_function::parse (cgraph_node *node, bitmap_obstack *stack,\n+\t\t     func_checker *checker)\n {\n   tree fndecl = node->decl;\n   function *func = DECL_STRUCT_FUNCTION (fndecl);\n@@ -1669,8 +1504,7 @@ sem_function::parse (cgraph_node *node, bitmap_obstack *stack)\n     return NULL;\n \n   sem_function *f = new sem_function (node, stack);\n-\n-  f->init ();\n+  f->init (checker);\n \n   return f;\n }\n@@ -2038,40 +1872,45 @@ sem_variable::equals (tree t1, tree t2)\n /* Parser function that visits a varpool NODE.  */\n \n sem_variable *\n-sem_variable::parse (varpool_node *node, bitmap_obstack *stack)\n+sem_variable::parse (varpool_node *node, bitmap_obstack *stack,\n+\t\t     func_checker *checker)\n {\n   if (TREE_THIS_VOLATILE (node->decl) || DECL_HARD_REGISTER (node->decl)\n       || node->alias)\n     return NULL;\n \n   sem_variable *v = new sem_variable (node, stack);\n-\n-  v->init ();\n+  v->init (checker);\n \n   return v;\n }\n \n-/* References independent hash function.  */\n+/* Semantic variable initialization function.  */\n \n-hashval_t\n-sem_variable::get_hash (void)\n+void\n+sem_variable::init (ipa_icf_gimple::func_checker *checker)\n {\n-  if (m_hash_set)\n-    return m_hash;\n+  decl = get_node ()->decl;\n \n   /* All WPA streamed in symbols should have their hashes computed at compile\n      time.  At this point, the constructor may not be in memory at all.\n      DECL_INITIAL (decl) would be error_mark_node in that case.  */\n-  gcc_assert (!node->lto_file_data);\n-  tree ctor = DECL_INITIAL (decl);\n-  inchash::hash hstate;\n+  if (!m_hash_set)\n+    {\n+      gcc_assert (!node->lto_file_data);\n+      inchash::hash hstate;\n+      hstate.add_int (456346417);\n+      checker->hash_operand (DECL_INITIAL (decl), hstate, 0);\n+      set_hash (hstate.end ());\n+    }\n+}\n \n-  hstate.add_int (456346417);\n-  if (DECL_SIZE (decl) && tree_fits_shwi_p (DECL_SIZE (decl)))\n-    hstate.add_hwi (tree_to_shwi (DECL_SIZE (decl)));\n-  add_expr (ctor, hstate);\n-  set_hash (hstate.end ());\n+/* References independent hash function.  */\n \n+hashval_t\n+sem_variable::get_hash (void)\n+{\n+  gcc_checking_assert (m_hash_set);\n   return m_hash;\n }\n \n@@ -2590,10 +2429,13 @@ sem_item_optimizer::parse_funcs_and_vars (void)\n {\n   cgraph_node *cnode;\n \n+  /* Create dummy func_checker for hashing purpose.  */\n+  func_checker checker;\n+\n   if (flag_ipa_icf_functions)\n     FOR_EACH_DEFINED_FUNCTION (cnode)\n     {\n-      sem_function *f = sem_function::parse (cnode, &m_bmstack);\n+      sem_function *f = sem_function::parse (cnode, &m_bmstack, &checker);\n       if (f)\n \t{\n \t  m_items.safe_push (f);\n@@ -2606,7 +2448,7 @@ sem_item_optimizer::parse_funcs_and_vars (void)\n   if (flag_ipa_icf_variables)\n     FOR_EACH_DEFINED_VARIABLE (vnode)\n     {\n-      sem_variable *v = sem_variable::parse (vnode, &m_bmstack);\n+      sem_variable *v = sem_variable::parse (vnode, &m_bmstack, &checker);\n \n       if (v)\n \t{\n@@ -2750,10 +2592,13 @@ sem_item_optimizer::parse_nonsingleton_classes (void)\n {\n   unsigned int counter = 0;\n \n+  /* Create dummy func_checker for hashing purpose.  */\n+  func_checker checker;\n+\n   for (unsigned i = 0; i < m_items.length (); i++)\n     if (m_items[i]->cls->members.length () > 1)\n       {\n-\tm_items[i]->init ();\n+\tm_items[i]->init (&checker);\n \t++counter;\n       }\n "}, {"sha": "906002214d5d2b8dbbcf3e3781cfc06a0fac5888", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37f58f506e436bdf8f4f5be4afbf2d246538058/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37f58f506e436bdf8f4f5be4afbf2d246538058/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=a37f58f506e436bdf8f4f5be4afbf2d246538058", "patch": "@@ -191,7 +191,7 @@ class sem_item\n   DEBUG_FUNCTION void dump (void);\n \n   /* Semantic item initialization function.  */\n-  virtual void init (void) = 0;\n+  virtual void init (ipa_icf_gimple::func_checker *) = 0;\n \n   /* Add reference to a semantic TARGET.  */\n   void add_reference (ref_map *map, sem_item *target);\n@@ -269,11 +269,6 @@ class sem_item\n protected:\n   /* Cached, once calculated hash for the item.  */\n \n-  /* Accumulate to HSTATE a hash of expression EXP.  */\n-  static void add_expr (const_tree exp, inchash::hash &hstate);\n-  /* Accumulate to HSTATE a hash of type T.  */\n-  static void add_type (const_tree t, inchash::hash &hstate);\n-\n   /* Compare properties of symbol that does not affect semantics of symbol\n      itself but affects semantics of its references.\n      If ADDRESS is true, do extra checking needed for IPA_REF_ADDR.  */\n@@ -322,7 +317,7 @@ class sem_function: public sem_item\n \n   ~sem_function ();\n \n-  virtual void init (void);\n+  virtual void init (ipa_icf_gimple::func_checker *);\n   virtual bool equals_wpa (sem_item *item,\n \t\t\t   hash_map <symtab_node *, sem_item *> &ignored_nodes);\n   virtual hashval_t get_hash (void);\n@@ -351,7 +346,8 @@ class sem_function: public sem_item\n \n   /* For a given call graph NODE, the function constructs new\n      semantic function item.  */\n-  static sem_function *parse (cgraph_node *node, bitmap_obstack *stack);\n+  static sem_function *parse (cgraph_node *node, bitmap_obstack *stack,\n+\t\t\t      ipa_icf_gimple::func_checker *checker);\n \n   /* Perform additional checks needed to match types of used function\n      paramters.  */\n@@ -423,10 +419,7 @@ class sem_variable: public sem_item\n   sem_variable (varpool_node *_node, bitmap_obstack *stack);\n \n   /* Semantic variable initialization function.  */\n-  inline virtual void init (void)\n-  {\n-    decl = get_node ()->decl;\n-  }\n+  virtual void init (ipa_icf_gimple::func_checker *);\n \n   virtual hashval_t get_hash (void);\n   virtual bool merge (sem_item *alias_item);\n@@ -445,7 +438,8 @@ class sem_variable: public sem_item\n   }\n \n   /* Parser function that visits a varpool NODE.  */\n-  static sem_variable *parse (varpool_node *node, bitmap_obstack *stack);\n+  static sem_variable *parse (varpool_node *node, bitmap_obstack *stack,\n+\t\t\t      ipa_icf_gimple::func_checker *checker);\n \n private:\n   /* Compares trees T1 and T2 for semantic equality.  */"}]}