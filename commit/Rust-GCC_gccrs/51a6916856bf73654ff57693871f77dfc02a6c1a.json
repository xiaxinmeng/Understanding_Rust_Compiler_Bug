{"sha": "51a6916856bf73654ff57693871f77dfc02a6c1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFhNjkxNjg1NmJmNzM2NTRmZjU3NjkzODcxZjc3ZGZjMDJhNmMxYQ==", "commit": {"author": {"name": "Zhenqiang Chen", "email": "zhenqiang.chen@linaro.org", "date": "2014-06-30T03:36:47Z"}, "committer": {"name": "Zhenqiang Chen", "email": "zqchen@gcc.gnu.org", "date": "2014-06-30T03:36:47Z"}, "message": "loop-invariant.c (get_inv_cost): Handle register class.\n\nChangeLog:\n2014-06-30  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n\n\t* loop-invariant.c (get_inv_cost): Handle register class.\n\t(gain_for_invariant): Check the register pressure of the inv\n\tand its overlapped register class, other than all.\n\ntestsuite/ChangeLog:\n2014-06-30  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n\n\t* ira-loop-pressure.c: New test.\n\nFrom-SVN: r212135", "tree": {"sha": "500d8005ad0d4e829d98dec7aeaf318585727526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/500d8005ad0d4e829d98dec7aeaf318585727526"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51a6916856bf73654ff57693871f77dfc02a6c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a6916856bf73654ff57693871f77dfc02a6c1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51a6916856bf73654ff57693871f77dfc02a6c1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a6916856bf73654ff57693871f77dfc02a6c1a/comments", "author": null, "committer": null, "parents": [{"sha": "22fa5b71aa4ed902474f03267ffa30f3e9981b82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fa5b71aa4ed902474f03267ffa30f3e9981b82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22fa5b71aa4ed902474f03267ffa30f3e9981b82"}], "stats": {"total": 82, "additions": 76, "deletions": 6}, "files": [{"sha": "4cc167ab98af960ebfa5565807b1349677f3e7e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a6916856bf73654ff57693871f77dfc02a6c1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a6916856bf73654ff57693871f77dfc02a6c1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51a6916856bf73654ff57693871f77dfc02a6c1a", "patch": "@@ -1,3 +1,9 @@\n+2014-06-30  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n+\n+\t* loop-invariant.c (get_inv_cost): Handle register class.\n+\t(gain_for_invariant): Check the register pressure of the inv\n+\tand its overlapped register class, other than all.\n+\n 2014-06-30  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/invoke.texi (Optimize Options): Fix descriptions of"}, {"sha": "d47d461bfd7555293618f13d67d7a5b9ef1620f9", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a6916856bf73654ff57693871f77dfc02a6c1a/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a6916856bf73654ff57693871f77dfc02a6c1a/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=51a6916856bf73654ff57693871f77dfc02a6c1a", "patch": "@@ -1087,16 +1087,22 @@ get_pressure_class_and_nregs (rtx insn, int *nregs)\n }\n \n /* Calculates cost and number of registers needed for moving invariant INV\n-   out of the loop and stores them to *COST and *REGS_NEEDED.  */\n+   out of the loop and stores them to *COST and *REGS_NEEDED.  *CL will be\n+   the REG_CLASS of INV.  Return\n+     -1: if INV is invalid.\n+      0: if INV and its depends_on have same reg_class\n+      1: if INV and its depends_on have different reg_classes.  */\n \n-static void\n-get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n+static int\n+get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed,\n+\t      enum reg_class *cl)\n {\n   int i, acomp_cost;\n   unsigned aregs_needed[N_REG_CLASSES];\n   unsigned depno;\n   struct invariant *dep;\n   bitmap_iterator bi;\n+  int ret = 1;\n \n   /* Find the representative of the class of the equivalent invariants.  */\n   inv = invariants[inv->eqto];\n@@ -1112,7 +1118,7 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \n   if (inv->move\n       || inv->stamp == actual_stamp)\n-    return;\n+    return -1;\n   inv->stamp = actual_stamp;\n \n   if (! flag_ira_loop_pressure)\n@@ -1124,6 +1130,8 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \n       pressure_class = get_pressure_class_and_nregs (inv->insn, &nregs);\n       regs_needed[pressure_class] += nregs;\n+      *cl = pressure_class;\n+      ret = 0;\n     }\n \n   if (!inv->cheap_address\n@@ -1164,14 +1172,16 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n   EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, depno, bi)\n     {\n       bool check_p;\n+      enum reg_class dep_cl = ALL_REGS;\n+      int dep_ret;\n \n       dep = invariants[depno];\n \n       /* If DEP is moved out of the loop, it is not a depends_on any more.  */\n       if (dep->move)\n \tcontinue;\n \n-      get_inv_cost (dep, &acomp_cost, aregs_needed);\n+      dep_ret = get_inv_cost (dep, &acomp_cost, aregs_needed, &dep_cl);\n \n       if (! flag_ira_loop_pressure)\n \tcheck_p = aregs_needed[0] != 0;\n@@ -1181,6 +1191,12 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \t    if (aregs_needed[ira_pressure_classes[i]] != 0)\n \t      break;\n \t  check_p = i < ira_pressure_classes_num;\n+\n+\t  if ((dep_ret == 1) || ((dep_ret == 0) && (*cl != dep_cl)))\n+\t    {\n+\t      *cl = ALL_REGS;\n+\t      ret = 1;\n+\t    }\n \t}\n       if (check_p\n \t  /* We need to check always_executed, since if the original value of\n@@ -1214,6 +1230,7 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \t}\n       (*comp_cost) += acomp_cost;\n     }\n+  return ret;\n }\n \n /* Calculates gain for eliminating invariant INV.  REGS_USED is the number\n@@ -1228,10 +1245,12 @@ gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n \t\t    bool speed, bool call_p)\n {\n   int comp_cost, size_cost;\n+  enum reg_class cl;\n+  int ret;\n \n   actual_stamp++;\n \n-  get_inv_cost (inv, &comp_cost, regs_needed);\n+  ret = get_inv_cost (inv, &comp_cost, regs_needed, &cl);\n \n   if (! flag_ira_loop_pressure)\n     {\n@@ -1240,6 +1259,11 @@ gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n \t\t   - estimate_reg_pressure_cost (new_regs[0],\n \t\t\t\t\t\t regs_used, speed, call_p));\n     }\n+  else if (ret < 0)\n+    return -1;\n+  else if ((ret == 0) && (cl == NO_REGS))\n+    /* Hoist it anyway since it does not impact register pressure.  */\n+    return 1;\n   else\n     {\n       int i;\n@@ -1248,6 +1272,10 @@ gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n       for (i = 0; i < ira_pressure_classes_num; i++)\n \t{\n \t  pressure_class = ira_pressure_classes[i];\n+\n+\t  if (!reg_classes_intersect_p (pressure_class, cl))\n+\t    continue;\n+\n \t  if ((int) new_regs[pressure_class]\n \t      + (int) regs_needed[pressure_class]\n \t      + LOOP_DATA (curr_loop)->max_reg_pressure[pressure_class]"}, {"sha": "5a9d73a49638a5f36e9ee3b6276056ba88e81b15", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a6916856bf73654ff57693871f77dfc02a6c1a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a6916856bf73654ff57693871f77dfc02a6c1a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=51a6916856bf73654ff57693871f77dfc02a6c1a", "patch": "@@ -1,3 +1,7 @@\n+2014-06-30  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n+\n+\t* ira-loop-pressure.c: New test.\n+\n 2014-06-29  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/36275"}, {"sha": "7ef4fa7be9365abb83e1784a4b12a35e53e008f6", "filename": "gcc/testsuite/gcc.dg/ira-loop-pressure.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a6916856bf73654ff57693871f77dfc02a6c1a/gcc%2Ftestsuite%2Fgcc.dg%2Fira-loop-pressure.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a6916856bf73654ff57693871f77dfc02a6c1a/gcc%2Ftestsuite%2Fgcc.dg%2Fira-loop-pressure.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fira-loop-pressure.c?ref=51a6916856bf73654ff57693871f77dfc02a6c1a", "patch": "@@ -0,0 +1,32 @@\n+/* Loop2_invariants pass should distinguish register pressures of different\n+   register classes.  In this case, register pressue of INT is high.  But\n+   we can still move the FP invariant out of the loop.  */\n+\n+/* { dg-do compile { target { x86_64-*-* && lp64 } } } */\n+/* { dg-options \"-O2 -fira-loop-pressure -fdump-rtl-loop2_invariant \" } */\n+\n+float tt;\n+extern void foo2 (int *, int *, int *, int *, int *, int *);\n+extern int foo3 (int, int, int, int, int, int);\n+int foo (int a, int b, int c, int d)\n+{\n+   int i = a;\n+   int t1, t2, t3, t4, t5, t6;\n+   t1 = t2 = t3 = t4 = t5 = t6 = 0;\n+\n+   for (; i > 0; i += c)\n+    {\n+      tt += 123456.0;\n+      if (d > t1 + t2)\n+\ttt = 3.0;\n+      foo2 (&t1, &t2, &t3, &t4, &t5, &t6);\n+      t1 += t3 + t4 + a + b;\n+      t2 -= t5 - t6 - c - d;\n+    }\n+\n+ return foo3 (t1, t2, t3, t4, t5, t6);\n+}\n+\n+/* { dg-final { scan-rtl-dump \"Decided to move invariant\" \"loop2_invariant\"  } } */\n+/* { dg-final { cleanup-rtl-dump \"loop2_invariant\" } } */\n+"}]}