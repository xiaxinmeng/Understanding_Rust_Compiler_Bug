{"sha": "e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYzZjI5ZTgxNGE3YjJkOWU0ZGJhYzg2YThhMzc4MGYxYmQ1MGY4MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2012-10-29T09:50:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-29T09:50:53Z"}, "message": "* adabkend.ads, adabkend.adb, aa_util.ads, aa_util.adb: New.\n\nFrom-SVN: r192913", "tree": {"sha": "d9304b5967c4c289db26282bf7af9d38f8b3c69d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9304b5967c4c289db26282bf7af9d38f8b3c69d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e58a0b759bbf4521ffe01406365c74262f56b0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e58a0b759bbf4521ffe01406365c74262f56b0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e58a0b759bbf4521ffe01406365c74262f56b0e"}], "stats": {"total": 940, "additions": 939, "deletions": 1}, "files": [{"sha": "2fb275398b4e5e67c2b7a1d9003f0cd97a50208e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80", "patch": "@@ -1,6 +1,7 @@\n 2012-10-29  Arnaud Charlet  <charlet@adacore.com>\n \n-\t* pprint.ads, pprint.adb: New.\n+\t* pprint.ads, pprint.adb, adabkend.ads, adabkend.adb,\n+\taa_util.ads, aa_util.adb: New.\n \n 2012-10-23  Eric Botcazou  <ebotcazou@adacore.com>\n "}, {"sha": "6ea4421f570d8bd74f9d063099f2e440614875d2", "filename": "gcc/ada/aa_util.adb", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80/gcc%2Fada%2Faa_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80/gcc%2Fada%2Faa_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faa_util.adb?ref=e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80", "patch": "@@ -0,0 +1,458 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAAMP COMPILER COMPONENTS                        --\n+--                                                                          --\n+--                              A A _ U T I L                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2001-2012, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Sem_Aux; use Sem_Aux;\n+with Sinput;  use Sinput;\n+with Stand;   use Stand;\n+with Stringt; use Stringt;\n+\n+with GNAT.Case_Util;  use GNAT.Case_Util;\n+\n+package body AA_Util is\n+\n+   ----------------------\n+   -- Is_Global_Entity --\n+   ----------------------\n+\n+   function Is_Global_Entity (E : Entity_Id) return Boolean is\n+   begin\n+      return Enclosing_Dynamic_Scope (E) = Standard_Standard;\n+   end Is_Global_Entity;\n+\n+   -----------------\n+   -- New_Name_Id --\n+   -----------------\n+\n+   function New_Name_Id (Name : String) return Name_Id is\n+   begin\n+      for J in 1 .. Name'Length loop\n+         Name_Buffer (J) := Name (Name'First + (J - 1));\n+      end loop;\n+\n+      Name_Len := Name'Length;\n+      return Name_Find;\n+   end New_Name_Id;\n+\n+   -----------------\n+   -- Name_String --\n+   -----------------\n+\n+   function Name_String (Name : Name_Id) return String is\n+   begin\n+      pragma Assert (Name /= No_Name);\n+      return Get_Name_String (Name);\n+   end Name_String;\n+\n+   -------------------\n+   -- New_String_Id --\n+   -------------------\n+\n+   function New_String_Id (S : String) return String_Id is\n+   begin\n+      for J in 1 .. S'Length loop\n+         Name_Buffer (J) := S (S'First + (J - 1));\n+      end loop;\n+\n+      Name_Len := S'Length;\n+      return String_From_Name_Buffer;\n+   end New_String_Id;\n+\n+   ------------------\n+   -- String_Value --\n+   ------------------\n+\n+   function String_Value (Str_Id : String_Id) return String is\n+   begin\n+      --  ??? pragma Assert (Str_Id /= No_String);\n+\n+      if Str_Id = No_String then\n+         return \"\";\n+      end if;\n+\n+      String_To_Name_Buffer (Str_Id);\n+\n+      return Name_Buffer (1 .. Name_Len);\n+   end String_Value;\n+\n+   ---------------\n+   -- Next_Name --\n+   ---------------\n+\n+   function Next_Name\n+     (Name_Seq    : not null access Name_Sequencer;\n+      Name_Prefix : String) return Name_Id\n+   is\n+   begin\n+      Name_Seq.Sequence_Number := Name_Seq.Sequence_Number + 1;\n+\n+      declare\n+         Number_Image : constant String := Name_Seq.Sequence_Number'Img;\n+      begin\n+         return New_Name_Id\n+                  (Name_Prefix & \"__\" & Number_Image (2 .. Number_Image'Last));\n+      end;\n+   end Next_Name;\n+\n+   --------------------\n+   -- Elab_Spec_Name --\n+   --------------------\n+\n+   function Elab_Spec_Name (Module_Name : Name_Id) return Name_Id is\n+   begin\n+      return New_Name_Id (Name_String (Module_Name) & \"___elabs\");\n+   end Elab_Spec_Name;\n+\n+   --------------------\n+   -- Elab_Spec_Name --\n+   --------------------\n+\n+   function Elab_Body_Name (Module_Name : Name_Id) return Name_Id is\n+   begin\n+      return New_Name_Id (Name_String (Module_Name) & \"___elabb\");\n+   end Elab_Body_Name;\n+\n+   --------------------------------\n+   -- Source_Name_Without_Suffix --\n+   --------------------------------\n+\n+   function File_Name_Without_Suffix (File_Name : String) return String is\n+      Name_Index : Natural := File_Name'Last;\n+\n+   begin\n+      pragma Assert (File_Name'Length > 0);\n+\n+      --  We loop in reverse to ensure that file names that follow nonstandard\n+      --  naming conventions that include additional dots are handled properly,\n+      --  preserving dots in front of the main file suffix (for example,\n+      --  main.2.ada => main.2).\n+\n+      while Name_Index >= File_Name'First\n+        and then File_Name (Name_Index) /= '.'\n+      loop\n+         Name_Index := Name_Index - 1;\n+      end loop;\n+\n+      --  Return the part of the file name up to but not including the last dot\n+      --  in the name, or return the whole name as is if no dot character was\n+      --  found.\n+\n+      if Name_Index >= File_Name'First then\n+         return File_Name (File_Name'First .. Name_Index - 1);\n+\n+      else\n+         return File_Name;\n+      end if;\n+   end File_Name_Without_Suffix;\n+\n+   -----------------\n+   -- Source_Name --\n+   -----------------\n+\n+   function Source_Name (Sloc : Source_Ptr) return File_Name_Type is\n+   begin\n+      if Sloc = No_Location or Sloc = Standard_Location then\n+         return No_File;\n+      else\n+         return File_Name (Get_Source_File_Index (Sloc));\n+      end if;\n+   end Source_Name;\n+\n+   --------------------------------\n+   -- Source_Name_Without_Suffix --\n+   --------------------------------\n+\n+   function Source_Name_Without_Suffix (Sloc : Source_Ptr) return String is\n+      Src_Name  : constant String :=\n+        Name_String (Name_Id (Source_Name (Sloc)));\n+      Src_Index : Natural         := Src_Name'Last;\n+\n+   begin\n+      pragma Assert (Src_Name'Length > 0);\n+\n+      --  Treat the presence of a \".dg\" suffix specially, stripping it off\n+      --  in addition to any suffix preceding it.\n+\n+      if Src_Name'Length >= 4\n+        and then Src_Name (Src_Name'Last - 2 .. Src_Name'Last) = \".dg\"\n+      then\n+         Src_Index := Src_Index - 3;\n+      end if;\n+\n+      return File_Name_Without_Suffix (Src_Name (Src_Name'First .. Src_Index));\n+   end Source_Name_Without_Suffix;\n+\n+   ----------------------\n+   -- Source_Id_String --\n+   ----------------------\n+\n+   function Source_Id_String (Unit_Name : Name_Id) return String is\n+      Unit_String : String   := Name_String (Unit_Name);\n+      Name_Last   : Positive := Unit_String'Last;\n+      Name_Index  : Positive := Unit_String'First;\n+\n+   begin\n+      To_Mixed (Unit_String);\n+\n+      --  Replace any embedded sequences of two or more '_' characters\n+      --  with a single '.' character. Note that this will leave any\n+      --  leading or trailing single '_' characters untouched, but those\n+      --  should normally not occur in compilation unit names (and if\n+      --  they do then it's better to leave them as is).\n+\n+      while Name_Index <= Name_Last loop\n+         if Unit_String (Name_Index) = '_'\n+           and then Name_Index /= Name_Last\n+           and then Unit_String (Name_Index + 1) = '_'\n+         then\n+            Unit_String (Name_Index) := '.';\n+            Name_Index := Name_Index + 1;\n+\n+            while Unit_String (Name_Index) = '_'\n+              and then Name_Index <= Name_Last\n+            loop\n+               Unit_String (Name_Index .. Name_Last - 1)\n+                 := Unit_String (Name_Index + 1 .. Name_Last);\n+               Name_Last := Name_Last - 1;\n+            end loop;\n+\n+         else\n+            Name_Index := Name_Index + 1;\n+         end if;\n+      end loop;\n+\n+      return Unit_String (Unit_String'First .. Name_Last);\n+   end Source_Id_String;\n+\n+   --  This version of Source_Id_String is obsolescent and is being\n+   --  replaced with the above function.\n+\n+   function Source_Id_String (Sloc : Source_Ptr) return String is\n+      File_Index : Source_File_Index;\n+\n+   begin\n+      --  Use an arbitrary artificial 22-character value for package Standard,\n+      --  since Standard doesn't have an associated source file.\n+\n+      if Sloc <= Standard_Location then\n+         return \"20010101010101standard\";\n+\n+      --  Return the concatentation of the source file's timestamp and\n+      --  its 8-digit hex checksum.\n+\n+      else\n+         File_Index := Get_Source_File_Index (Sloc);\n+\n+         return String (Time_Stamp (File_Index))\n+                  & Get_Hex_String (Source_Checksum (File_Index));\n+      end if;\n+   end Source_Id_String;\n+\n+   ---------------\n+   -- Source_Id --\n+   ---------------\n+\n+   function Source_Id (Unit_Name : Name_Id) return String_Id is\n+   begin\n+      return New_String_Id (Source_Id_String (Unit_Name));\n+   end Source_Id;\n+\n+   --  This version of Source_Id is obsolescent and is being\n+   --  replaced with the above function.\n+\n+   function Source_Id (Sloc : Source_Ptr) return String_Id is\n+   begin\n+      return New_String_Id (Source_Id_String (Sloc));\n+   end Source_Id;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (I : Int) return String is\n+      Image_String : constant String := Pos'Image (I);\n+   begin\n+      if Image_String (1) = ' ' then\n+         return Image_String (2 .. Image_String'Last);\n+      else\n+         return Image_String;\n+      end if;\n+   end Image;\n+\n+   --------------\n+   -- UI_Image --\n+   --------------\n+\n+   function UI_Image (I : Uint; Format : Integer_Image_Format) return String is\n+   begin\n+      if Format = Decimal then\n+         UI_Image (I, Format => Decimal);\n+         return UI_Image_Buffer (1 .. UI_Image_Length);\n+\n+      elsif Format = Ada_Hex then\n+         UI_Image (I, Format => Hex);\n+         return UI_Image_Buffer (1 .. UI_Image_Length);\n+\n+      else\n+         pragma Assert (I >= Uint_0);\n+\n+         UI_Image (I, Format => Hex);\n+\n+         pragma Assert (UI_Image_Buffer (1 .. 3) = \"16#\"\n+                         and then UI_Image_Buffer (UI_Image_Length) = '#');\n+\n+         --  Declare a string where we will copy the digits from the UI_Image,\n+         --  interspersing '_' characters as 4-digit group separators. The\n+         --  underscores in UI_Image's result are not always at the places\n+         --  where we want them, which is why we do the following copy\n+         --  (e.g., we map \"16#ABCD_EF#\" to \"^AB_CDEF^\").\n+\n+         declare\n+            Hex_String     : String (1 .. UI_Image_Max);\n+            Last_Index     : Natural;\n+            Digit_Count    : Natural := 0;\n+            UI_Image_Index : Natural := 4; -- Skip past the \"16#\" bracket\n+            Sep_Count      : Natural := 0;\n+\n+         begin\n+            --  Count up the number of non-underscore characters in the\n+            --  literal value portion of the UI_Image string.\n+\n+            while UI_Image_Buffer (UI_Image_Index) /= '#' loop\n+               if UI_Image_Buffer (UI_Image_Index) /= '_' then\n+                  Digit_Count := Digit_Count + 1;\n+               end if;\n+\n+               UI_Image_Index := UI_Image_Index + 1;\n+            end loop;\n+\n+            UI_Image_Index := 4; -- Reset the index past the \"16#\" bracket\n+\n+            Last_Index := 1;\n+\n+            Hex_String (Last_Index) := '^';\n+            Last_Index := Last_Index + 1;\n+\n+            --  Copy digits from UI_Image_Buffer to Hex_String, adding\n+            --  underscore separators as appropriate. The initial value\n+            --  of Sep_Count accounts for the leading '^' and being one\n+            --  character ahead after inserting a digit.\n+\n+            Sep_Count := 2;\n+\n+            while UI_Image_Buffer (UI_Image_Index) /= '#' loop\n+               if UI_Image_Buffer (UI_Image_Index) /= '_' then\n+                  Hex_String (Last_Index) := UI_Image_Buffer (UI_Image_Index);\n+\n+                  Last_Index := Last_Index + 1;\n+\n+                  --  Add '_' characters to separate groups of four hex\n+                  --  digits for readability (grouping from right to left).\n+\n+                  if (Digit_Count - (Last_Index - Sep_Count)) mod 4 = 0 then\n+                     Hex_String (Last_Index) := '_';\n+                     Last_Index := Last_Index + 1;\n+                     Sep_Count := Sep_Count + 1;\n+                  end if;\n+               end if;\n+\n+               UI_Image_Index := UI_Image_Index + 1;\n+            end loop;\n+\n+            --  Back up before any trailing underscore\n+\n+            if Hex_String (Last_Index - 1) = '_' then\n+               Last_Index := Last_Index - 1;\n+            end if;\n+\n+            Hex_String (Last_Index) := '^';\n+\n+            return Hex_String (1 .. Last_Index);\n+         end;\n+      end if;\n+   end UI_Image;\n+\n+   --------------\n+   -- UR_Image --\n+   --------------\n+\n+   --  Shouldn't this be added to Urealp???\n+\n+   function UR_Image (R : Ureal) return String is\n+\n+      --  The algorithm used here for conversion of Ureal values\n+      --  is taken from the JGNAT back end.\n+\n+      Num    : Long_Long_Float := 0.0;\n+      Den    : Long_Long_Float := 0.0;\n+      Sign   : Long_Long_Float := 1.0;\n+      Result : Long_Long_Float;\n+      Tmp    : Uint;\n+      Index  : Integer;\n+\n+   begin\n+      if UR_Is_Negative (R) then\n+         Sign := -1.0;\n+      end if;\n+\n+      --  In the following calculus, we consider numbers modulo 2 ** 31,\n+      --  so that we don't have problems with signed Int...\n+\n+      Tmp := abs (Numerator (R));\n+      Index := 0;\n+      while Tmp > 0 loop\n+         Num := Num\n+           + Long_Long_Float (UI_To_Int (Tmp mod (Uint_2 ** 31)))\n+           * (2.0 ** Index);\n+         Tmp := Tmp / Uint_2 ** 31;\n+         Index := Index + 31;\n+      end loop;\n+\n+      Tmp := abs (Denominator (R));\n+      if Rbase (R) /= 0 then\n+         Tmp := Rbase (R) ** Tmp;\n+      end if;\n+\n+      Index := 0;\n+      while Tmp > 0 loop\n+         Den := Den\n+           + Long_Long_Float (UI_To_Int (Tmp mod (Uint_2 ** 31)))\n+           * (2.0 ** Index);\n+         Tmp := Tmp / Uint_2 ** 31;\n+         Index := Index + 31;\n+      end loop;\n+\n+      --  If the denominator denotes a negative power of Rbase,\n+      --  then multiply by the denominator.\n+\n+      if Rbase (R) /= 0 and then Denominator (R) < 0 then\n+         Result := Sign * Num * Den;\n+\n+      --  Otherwise compute the quotient\n+\n+      else\n+         Result := Sign * Num / Den;\n+      end if;\n+\n+      return Long_Long_Float'Image (Result);\n+   end UR_Image;\n+\n+end AA_Util;"}, {"sha": "27b6183248e7d7795c775dd4f91f74b2c1af55bd", "filename": "gcc/ada/aa_util.ads", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80/gcc%2Fada%2Faa_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80/gcc%2Fada%2Faa_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faa_util.ads?ref=e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80", "patch": "@@ -0,0 +1,145 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAAMP COMPILER COMPONENTS                        --\n+--                                                                          --\n+--                              A A _ U T I L                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 2001-2011, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides various utility operations used by GNAT back-ends\n+--  (e.g. AAMP).\n+\n+--  This package is a messy grab bag of stuff. These routines should be moved\n+--  to appropriate units (sem_util,sem_aux,exp_util,namet,uintp,urealp). ???\n+\n+with Namet;  use Namet;\n+with Types;  use Types;\n+with Uintp;  use Uintp;\n+with Urealp; use Urealp;\n+\n+package AA_Util is\n+\n+   function Is_Global_Entity (E : Entity_Id) return Boolean;\n+   --  Returns true if and only if E is a library-level entity (excludes\n+   --  entities declared within blocks at the outer level of library packages).\n+\n+   function New_Name_Id (Name : String) return Name_Id;\n+   --  Returns a Name_Id corresponding to the given name string\n+\n+   function Name_String (Name : Name_Id) return String;\n+   --  Returns the name string associated with Name\n+\n+   function New_String_Id (S : String) return String_Id;\n+   --  Returns a String_Id corresponding to the given string\n+\n+   function String_Value (Str_Id : String_Id) return String;\n+   --  Returns the string associated with Str_Id\n+\n+   --  Name-generation utilities\n+\n+   type Name_Sequencer is private;\n+   --  This type is used to support back-end generation of unique symbol\n+   --  (e.g., for string literal objects or labels). By declaring an\n+   --  aliased object of type Name_Sequence and passing that object\n+   --  to the function Next_Name, a series of names with suffixes\n+   --  of the form \"__n\" will be produced, where n is a string denoting\n+   --  a positive integer.  The sequence starts with \"__1\", and increases\n+   --  by one on each successive call to Next_Name for a given Name_Sequencer.\n+\n+   function Next_Name\n+     (Name_Seq    : not null access Name_Sequencer;\n+      Name_Prefix : String) return Name_Id;\n+   --  Returns the Name_Id for a name composed of the given Name_Prefix\n+   --  concatentated with a unique number suffix of the form \"__n\",\n+   --  as detemined by the current state of Name_Seq.\n+\n+   function Elab_Spec_Name (Module_Name : Name_Id) return Name_Id;\n+   --  Returns a name id for the elaboration subprogram to be associated with\n+   --  the specification of the named module. The denoted name is of the form\n+   --  \"modulename___elabs\".\n+\n+   function Elab_Body_Name (Module_Name : Name_Id) return Name_Id;\n+   --  Returns a name id for the elaboration subprogram to be associated\n+   --  with the body of the named module. The denoted name is of the form\n+   --  \"modulename___elabb\".\n+\n+   function File_Name_Without_Suffix (File_Name : String) return String;\n+   --  Removes the suffix ('.' followed by other characters), if present, from\n+   --  the end of File_Name and returns the shortened name (otherwise simply\n+   --  returns File_Name).\n+\n+   function Source_Name (Sloc : Source_Ptr) return File_Name_Type;\n+   --  Returns file name corresponding to the source file name associated with\n+   --  the given source position Sloc.\n+\n+   function Source_Name_Without_Suffix (Sloc : Source_Ptr) return String;\n+   --  Returns a string corresponding to the source file name associated with\n+   --  the given source position Sloc, with its dot-preceded suffix, if any,\n+   --  removed. As examples, the name \"main.adb\" is mapped to \"main\" and the\n+   --  name \"main.2.ada\" is mapped to \"main.2\". As a special case, file names\n+   --  with a \".dg\" suffix will also strip off the \".dg\", so \"main.adb.dg\"\n+   --  becomes simply \"main\".\n+\n+   function Source_Id_String (Unit_Name : Name_Id) return String;\n+   --  Returns a string that uniquely identifies the unit with the given\n+   --  Unit_Name. This string is derived from Unit_Name by replacing any\n+   --  multiple underscores with dot ('.') characters and normalizing the\n+   --  casing to mixed case (e.g., \"ada__strings\" is mapped to (\"Ada.Strings\").\n+\n+   function Source_Id (Unit_Name : Name_Id) return String_Id;\n+   --  Returns a String_Id reference to a string that uniquely identifies\n+   --  the program unit having the given name (as defined for function\n+   --  Source_Id_String).\n+\n+   function Source_Id_String (Sloc : Source_Ptr) return String;\n+   --  Returns a string that uniquely identifies the source file containing\n+   --  the given source location.  This string is constructed from the\n+   --  concatentation of the date and time stamp of the file with a\n+   --  hexadecimal check sum (e.g., \"020425143059ABCDEF01\").\n+\n+   function Source_Id (Sloc : Source_Ptr) return String_Id;\n+   --  Returns a String_Id reference to a string that uniquely identifies the\n+   --  source file containing the given source location (as defined for\n+   --  function Source_Id_String).\n+\n+   function Image (I : Int) return String;\n+   --  Returns Int'Image (I), but without a leading space in the case where\n+   --  I is nonnegative. Useful for concatenating integers onto other names.\n+\n+   type Integer_Image_Format is (Decimal, Ada_Hex, AAMP_Hex);\n+\n+   function UI_Image (I : Uint; Format : Integer_Image_Format) return String;\n+   --  Returns the image of the universal integer I, with no leading spaces\n+   --  and in the format specified. The Format parameter specifies whether\n+   --  the integer representation should be decimal (the default), or Ada\n+   --  hexadecimal (Ada_Hex => \"16#xxxxx#\" format), or AAMP hexadecimal.\n+   --  In the latter case, the integer will have the form of a sequence of\n+   --  hexadecimal digits bracketed by '^' characters, and will contain '_'\n+   --  characters as separators for groups of four hexadecimal digits\n+   --  (e.g., ^1C_A3CD^). If the format AAMP_Hex is selected, the universal\n+   --  integer must have a nonnegative value.\n+\n+   function UR_Image (R : Ureal) return String;\n+   --  Returns a decimal image of the universal real value R\n+\n+private\n+\n+   type Name_Sequencer is record\n+      Sequence_Number : Natural := 0;\n+   end record;\n+\n+end AA_Util;"}, {"sha": "96bd00d99dfc0132441efc8b41df255d03ec90ca", "filename": "gcc/ada/adabkend.adb", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80/gcc%2Fada%2Fadabkend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80/gcc%2Fada%2Fadabkend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadabkend.adb?ref=e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80", "patch": "@@ -0,0 +1,282 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAAMP COMPILER COMPONENTS                        --\n+--                                                                          --\n+--                             A D A B K E N D                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2001-2011, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the version of the Back_End package for back ends written in Ada\n+\n+with Debug;\n+with Lib;\n+with Opt;      use Opt;\n+with Output;   use Output;\n+with Osint;    use Osint;\n+with Osint.C;  use Osint.C;\n+with Switch.C; use Switch.C;\n+with Types;    use Types;\n+\n+with System.OS_Lib; use System.OS_Lib;\n+\n+package body Adabkend is\n+\n+   use Switch;\n+\n+   -------------------\n+   -- Call_Back_End --\n+   -------------------\n+\n+   procedure Call_Back_End is\n+   begin\n+      if (Opt.Verbose_Mode or Opt.Full_List)\n+        and then not Debug.Debug_Flag_7\n+      then\n+         Write_Eol;\n+         Write_Str (Product_Name);\n+         Write_Str (\", Copyright \");\n+         Write_Str (Copyright_Years);\n+         Write_Str (\" Ada Core Technologies, Inc.\");\n+         Write_Str (\" (http://www.adacore.com)\");\n+         Write_Eol;\n+         Write_Eol;\n+      end if;\n+\n+      Driver (Lib.Cunit (Types.Main_Unit));\n+   end Call_Back_End;\n+\n+   ------------------------\n+   -- Scan_Compiler_Args --\n+   ------------------------\n+\n+   procedure Scan_Compiler_Arguments is\n+      Output_File_Name_Seen : Boolean := False;\n+      --  Set to True after having scanned the file_name for switch\n+      --  \"-gnatO file_name\"\n+\n+      Argument_Count : constant Integer := Arg_Count - 1;\n+      --  Number of arguments (excluding program name)\n+\n+      Args     : Argument_List (1 .. Argument_Count);\n+      Next_Arg : Positive := 1;\n+\n+      procedure Scan_Back_End_Switches (Switch_Chars : String);\n+      --  Procedure to scan out switches stored in Switch_Chars. The first\n+      --  character is known to be a valid switch character, and there are no\n+      --  blanks or other switch terminator characters in the string, so the\n+      --  entire string should consist of valid switch characters, except that\n+      --  an optional terminating NUL character is allowed.\n+      --\n+      --  If the switch is not valid, control will not return. The switches\n+      --  must still be scanned to skip the \"-o\" arguments, or internal GCC\n+      --  switches, which may be safely ignored by other back-ends.\n+\n+      ----------------------------\n+      -- Scan_Back_End_Switches --\n+      ----------------------------\n+\n+      procedure Scan_Back_End_Switches (Switch_Chars : String) is\n+         First : constant Positive := Switch_Chars'First + 1;\n+         Last  : constant Natural  := Switch_Last (Switch_Chars);\n+\n+      begin\n+         --  Process any back end switches, returning if the switch does not\n+         --  affect code generation or falling through if it does, so the\n+         --  switch will get stored.\n+\n+         if Is_Internal_GCC_Switch (Switch_Chars) then\n+            Next_Arg := Next_Arg + 1;\n+            return; -- ignore this switch\n+\n+         --  Record that an object file name has been specified. The actual\n+         --  file name argument is picked up and saved below by the main body\n+         --  of Scan_Compiler_Arguments.\n+\n+         elsif Switch_Chars (First .. Last) = \"o\" then\n+            if First = Last then\n+               Opt.Output_File_Name_Present := True;\n+               return;\n+            else\n+               Fail (\"invalid switch: \" & Switch_Chars);\n+            end if;\n+\n+         --  Set optimization indicators appropriately. In gcc-based GNAT this\n+         --  is picked up from imported variables set by the gcc driver, but\n+         --  for compilers with non-gcc back ends we do it here to allow use\n+         --  of these switches by the front end. Allowed optimization switches\n+         --  are -Os (optimize for size), -O[0123], and -O (same as -O1).\n+\n+         elsif Switch_Chars (First) = 'O' then\n+            if First = Last then\n+               Optimization_Level := 1;\n+\n+            elsif Last - First = 1 then\n+               if Switch_Chars (Last) = 's' then\n+                  Optimize_Size := 1;\n+                  Optimization_Level := 2;  -- Consistent with gcc setting\n+\n+               elsif Switch_Chars (Last) in '0' .. '3' then\n+                  Optimization_Level :=\n+                    Character'Pos (Switch_Chars (Last)) - Character'Pos ('0');\n+\n+               else\n+                  Fail (\"invalid switch: \" & Switch_Chars);\n+               end if;\n+\n+            else\n+               Fail (\"invalid switch: \" & Switch_Chars);\n+            end if;\n+\n+         elsif Switch_Chars (First .. Last) = \"quiet\" then\n+            return; -- ignore this switch\n+\n+         elsif Switch_Chars (First .. Last) = \"c\" then\n+            return; -- ignore this switch\n+\n+         --  The -x switch and its language name argument will generally be\n+         --  ignored by non-gcc back ends (e.g. the GNAAMP back end). In any\n+         --  case, we save the switch and argument in the compilation switches.\n+\n+         elsif Switch_Chars (First .. Last) = \"x\" then\n+            Lib.Store_Compilation_Switch (Switch_Chars);\n+            Next_Arg := Next_Arg + 1;\n+\n+            declare\n+               Argv : constant String := Args (Next_Arg).all;\n+\n+            begin\n+               if Is_Switch (Argv) then\n+                  Fail (\"language name missing after -x\");\n+               else\n+                  Lib.Store_Compilation_Switch (Argv);\n+               end if;\n+            end;\n+\n+            return;\n+\n+         --  Special check, the back end switch -fno-inline also sets the\n+         --  front end flag to entirely inhibit all inlining. So we store it\n+         --  and set the appropriate flag.\n+\n+         elsif Switch_Chars (First .. Last) = \"fno-inline\" then\n+            Lib.Store_Compilation_Switch (Switch_Chars);\n+            Opt.Suppress_All_Inlining := True;\n+            return;\n+\n+         --  Similar processing for -fpreserve-control-flow\n+\n+         elsif Switch_Chars (First .. Last) = \"fpreserve-control-flow\" then\n+            Lib.Store_Compilation_Switch (Switch_Chars);\n+            Opt.Suppress_Control_Flow_Optimizations := True;\n+            return;\n+\n+         --  Ignore all other back end switches\n+\n+         elsif Is_Back_End_Switch (Switch_Chars) then\n+            null;\n+\n+         --  Give error for junk switch\n+\n+         else\n+            Fail (\"invalid switch: \" & Switch_Chars);\n+         end if;\n+\n+         --  Store any other GCC switches\n+\n+         Lib.Store_Compilation_Switch (Switch_Chars);\n+      end Scan_Back_End_Switches;\n+\n+   --  Start of processing for Scan_Compiler_Args\n+\n+   begin\n+      --  Put all the arguments in argument list Args\n+\n+      for Arg in 1 .. Argument_Count loop\n+         declare\n+            Argv : String (1 .. Len_Arg (Arg));\n+         begin\n+            Fill_Arg (Argv'Address, Arg);\n+            Args (Arg) := new String'(Argv);\n+         end;\n+      end loop;\n+\n+      --  Loop through command line arguments, storing them for later access\n+\n+      while Next_Arg <= Argument_Count loop\n+         Look_At_Arg : declare\n+            Argv : constant String := Args (Next_Arg).all;\n+\n+         begin\n+            if Argv'Length = 0 then\n+               Fail (\"Empty argument\");\n+            end if;\n+\n+            --  If the previous switch has set the Output_File_Name_Present\n+            --  flag (that is we have seen a -gnatO), then the next argument\n+            --  is the name of the output object file.\n+\n+            if Opt.Output_File_Name_Present\n+              and then not Output_File_Name_Seen\n+            then\n+               if Is_Switch (Argv) then\n+                  Fail (\"Object file name missing after -gnatO\");\n+               else\n+                  Set_Output_Object_File_Name (Argv);\n+                  Output_File_Name_Seen := True;\n+               end if;\n+\n+               --  If the previous switch has set the Search_Directory_Present\n+               --  flag (that is if we have just seen -I), then the next\n+               --  argument is a search directory path.\n+\n+            elsif Search_Directory_Present then\n+               if Is_Switch (Argv) then\n+                  Fail (\"search directory missing after -I\");\n+               else\n+                  Add_Src_Search_Dir (Argv);\n+\n+                  --  Add directory to lib search so that back-end can take as\n+                  --  input ALI files if needed. Otherwise this won't have any\n+                  --  impact on the compiler.\n+\n+                  Add_Lib_Search_Dir (Argv);\n+\n+                  Search_Directory_Present := False;\n+               end if;\n+\n+            --  If not a switch, must be a file name\n+\n+            elsif not Is_Switch (Argv) then\n+               Add_File (Argv);\n+\n+            --  Front end switch\n+\n+            elsif Is_Front_End_Switch (Argv) then\n+               Scan_Front_End_Switches (Argv, Args, Next_Arg);\n+\n+            --  All non-front-end switches are back-end switches\n+\n+            else\n+               Scan_Back_End_Switches (Argv);\n+            end if;\n+         end Look_At_Arg;\n+\n+         Next_Arg := Next_Arg + 1;\n+      end loop;\n+   end Scan_Compiler_Arguments;\n+\n+end Adabkend;"}, {"sha": "877422c949e21a818b0372276f0407545171c77f", "filename": "gcc/ada/adabkend.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80/gcc%2Fada%2Fadabkend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80/gcc%2Fada%2Fadabkend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadabkend.ads?ref=e63f29e814a7b2d9e4dbac86a8a3780f1bd50f80", "patch": "@@ -0,0 +1,52 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              A D A B K E N D                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Generic package implementing the common parts of back_end.adb for back ends\n+--  written in Ada, thereby reducing code duplication.\n+\n+with Types;\n+\n+generic\n+   Product_Name    : String;\n+   Copyright_Years : String;\n+\n+   with procedure Driver (Root : Types.Node_Id);\n+   --  Main driver procedure for back end\n+\n+   with function Is_Back_End_Switch (Switch : String) return Boolean;\n+   --  Back-end specific function to determine validity of switches\n+\n+package Adabkend is\n+\n+   procedure Call_Back_End;\n+   --  Call back end, i.e. make call to the Driver passing the root\n+   --  node for this compilation unit.\n+\n+   procedure Scan_Compiler_Arguments;\n+   --  Acquires command-line parameters passed to the compiler and processes\n+   --  them. Calls Scan_Front_End_Switches for any front-end switches\n+   --  encountered. See spec of Back_End for more details.\n+\n+end Adabkend;"}]}