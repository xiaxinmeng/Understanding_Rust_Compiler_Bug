{"sha": "5ffe581dd305bd58d49d53fc2d3776d89e56a541", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZmZTU4MWRkMzA1YmQ1OGQ0OWQ1M2ZjMmQzNzc2ZDg5ZTU2YTU0MQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-04-23T22:26:41Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-23T22:26:41Z"}, "message": "cp-tree.def: Add WRAPPER.\n\n\t* cp-tree.def: Add WRAPPER.  USER_CONV now only has two ops.\n\t* cp-tree.h: Add WRAPPER support.\n\t* call.c (add_candidate): Split out from add_*_candidate fns.\n\t(build_over_call): Take the candidate instead of function and args.\n\tEnforce access control here.  Emit overload warnings here.\n\t(add_warning): New fn.\n\t(joust): Add WARN parm.  If not set, call add_warning instead of\n\tprinting a warning.  Reenable some warnings.\n\t(tourney): Pass it.\n\t(convert_like): Adjust.\n\t(build_new_op): Adjust.\n\t(build_new_function_call): Adjust.\n\t(build_user_type_conversion_1): Adjust.\n\t(USER_CONV_FN): Adjust.\n\t* tree.c (build_expr_wrapper, build_expr_ptr_wrapper,\n\tbuild_int_wrapper): New fns.\n\nFrom-SVN: r19393", "tree": {"sha": "b93fa3db5f37a1e13f91c30e07db66b00d3399e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b93fa3db5f37a1e13f91c30e07db66b00d3399e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ffe581dd305bd58d49d53fc2d3776d89e56a541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ffe581dd305bd58d49d53fc2d3776d89e56a541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ffe581dd305bd58d49d53fc2d3776d89e56a541", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ffe581dd305bd58d49d53fc2d3776d89e56a541/comments", "author": null, "committer": null, "parents": [{"sha": "624411284f57833e930b911bb9f90a0e725bc4f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/624411284f57833e930b911bb9f90a0e725bc4f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/624411284f57833e930b911bb9f90a0e725bc4f6"}], "stats": {"total": 249, "additions": 174, "deletions": 75}, "files": [{"sha": "eb764e85be15bd16f8e2361db87619bebd043bda", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5ffe581dd305bd58d49d53fc2d3776d89e56a541", "patch": "@@ -1,3 +1,22 @@\n+Thu Apr 23 21:19:06 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.def: Add WRAPPER.  USER_CONV now only has two ops.\n+\t* cp-tree.h: Add WRAPPER support.\n+\t* call.c (add_candidate): Split out from add_*_candidate fns.\n+\t(build_over_call): Take the candidate instead of function and args.\n+\tEnforce access control here.  Emit overload warnings here.\n+\t(add_warning): New fn.\n+\t(joust): Add WARN parm.  If not set, call add_warning instead of\n+\tprinting a warning.  Reenable some warnings.\n+\t(tourney): Pass it.\n+\t(convert_like): Adjust.\n+\t(build_new_op): Adjust.\n+\t(build_new_function_call): Adjust.\n+\t(build_user_type_conversion_1): Adjust.\n+\t(USER_CONV_FN): Adjust.\n+\t* tree.c (build_expr_wrapper, build_expr_ptr_wrapper, \n+\tbuild_int_wrapper): New fns.\n+\n Thu Apr 23 18:27:53 1998  Mark P. Mitchell  <mmitchell@usa.net>\n \n \t* pt.c (unify): Fix typo in previous change."}, {"sha": "5fd81f511bd892a3f49d426a608a5505774a9ff0", "filename": "gcc/cp/call.c", "status": "modified", "additions": 95, "deletions": 71, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5ffe581dd305bd58d49d53fc2d3776d89e56a541", "patch": "@@ -43,10 +43,10 @@ static tree build_new_method_call PROTO((tree, tree, tree, tree, int));\n static tree build_field_call PROTO((tree, tree, tree, tree));\n static tree find_scoped_type PROTO((tree, tree, tree));\n static struct z_candidate * tourney PROTO((struct z_candidate *));\n-static int joust PROTO((struct z_candidate *, struct z_candidate *));\n+static int joust PROTO((struct z_candidate *, struct z_candidate *, int));\n static int compare_qual PROTO((tree, tree));\n static int compare_ics PROTO((tree, tree));\n-static tree build_over_call PROTO((tree, tree, tree, int));\n+static tree build_over_call PROTO((struct z_candidate *, tree, int));\n static tree convert_default_arg PROTO((tree, tree));\n static tree convert_like PROTO((tree, tree));\n static void op_error PROTO((enum tree_code, enum tree_code, tree, tree,\n@@ -664,6 +664,7 @@ struct z_candidate {\n   int viable;\n   tree basetype_path;\n   tree template;\n+  tree warnings;\n   struct z_candidate *next;\n };\n \n@@ -689,7 +690,9 @@ struct z_candidate {\n #define ICS_THIS_FLAG(NODE) TREE_LANG_FLAG_2 (NODE)\n #define ICS_BAD_FLAG(NODE) TREE_LANG_FLAG_3 (NODE)\n \n-#define USER_CONV_FN(NODE) TREE_OPERAND (NODE, 1)\n+#define USER_CONV_CAND(NODE) \\\n+  ((struct z_candidate *)WRAPPER_PTR (TREE_OPERAND (NODE, 1)))\n+#define USER_CONV_FN(NODE) (USER_CONV_CAND (NODE)->fn)\n \n int\n null_ptr_cst_p (t)\n@@ -1049,6 +1052,30 @@ implicit_conversion (to, from, expr, flags)\n   return conv;\n }\n \n+/* Add a new entry to the list of candidates.  Used by the add_*_candidate\n+   functions.  */\n+\n+static struct z_candidate *\n+add_candidate (candidates, fn, convs, viable)\n+     struct z_candidate *candidates;\n+     tree fn, convs;\n+     int viable;\n+{\n+  struct z_candidate *cand\n+    = (struct z_candidate *) scratchalloc (sizeof (struct z_candidate));\n+\n+  cand->fn = fn;\n+  cand->convs = convs;\n+  cand->second_conv = NULL_TREE;\n+  cand->viable = viable;\n+  cand->basetype_path = NULL_TREE;\n+  cand->template = NULL_TREE;\n+  cand->warnings = NULL_TREE;\n+  cand->next = candidates;\n+\n+  return cand;\n+}\n+\n /* Create an overload candidate for the function or method FN called with\n    the argument list ARGLIST and add it to CANDIDATES.  FLAGS is passed on\n    to implicit_conversion.  */\n@@ -1130,17 +1157,7 @@ add_function_candidate (candidates, fn, arglist, flags)\n \tbreak;\n       }\n \n-  cand = (struct z_candidate *) scratchalloc (sizeof (struct z_candidate));\n-\n-  cand->fn = fn;\n-  cand->convs = convs;\n-  cand->second_conv = NULL_TREE;\n-  cand->viable = viable;\n-  cand->basetype_path = NULL_TREE;\n-  cand->template = NULL_TREE;\n-  cand->next = candidates;\n-\n-  return cand;\n+  return add_candidate (candidates, fn, convs, viable);\n }\n \n /* Create an overload candidate for the conversion function FN which will\n@@ -1207,17 +1224,7 @@ add_conv_candidate (candidates, fn, obj, arglist)\n \tbreak;\n       }\n \n-  cand = (struct z_candidate *) scratchalloc (sizeof (struct z_candidate));\n-\n-  cand->fn = fn;\n-  cand->convs = convs;\n-  cand->second_conv = NULL_TREE;\n-  cand->viable = viable;\n-  cand->basetype_path = NULL_TREE;\n-  cand->template = NULL_TREE;\n-  cand->next = candidates;\n-\n-  return cand;\n+  return add_candidate (candidates, fn, convs, viable);\n }\n \n static struct z_candidate *\n@@ -1267,17 +1274,7 @@ build_builtin_candidate (candidates, fnname, type1, type2,\n \tviable = 0;\n     }      \n \n-  cand = (struct z_candidate *) scratchalloc (sizeof (struct z_candidate));\n-\n-  cand->fn = fnname;\n-  cand->convs = convs;\n-  cand->second_conv = NULL_TREE;\n-  cand->viable = viable;\n-  cand->basetype_path = NULL_TREE;\n-  cand->template = NULL_TREE;\n-  cand->next = candidates;\n-\n-  return cand;\n+  return add_candidate (candidates, fnname, convs, viable);\n }\n \n static int\n@@ -2173,7 +2170,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n     (USER_CONV,\n      (DECL_CONSTRUCTOR_P (cand->fn)\n       ? totype : non_reference (TREE_TYPE (TREE_TYPE (cand->fn)))),\n-     expr, cand->fn, cand->convs, cand->basetype_path);\n+     expr, build_expr_ptr_wrapper (cand));\n   ICS_USER_FLAG (cand->second_conv) = 1;\n   if (cand->viable == -1)\n     ICS_BAD_FLAG (cand->second_conv) = 1;\n@@ -2287,7 +2284,7 @@ build_new_function_call (fn, args)\n \t  && ! DECL_INITIAL (cand->fn))\n \tadd_maybe_template (cand->fn, templates);\n \n-      return build_over_call (cand->fn, cand->convs, args, LOOKUP_NORMAL);\n+      return build_over_call (cand, args, LOOKUP_NORMAL);\n     }\n \n   return build_function_call (fn, args);\n@@ -2390,7 +2387,7 @@ build_object_call (obj, args)\n     }\n \n   if (DECL_NAME (cand->fn) == ansi_opname [CALL_EXPR])\n-    return build_over_call (cand->fn, cand->convs, mem_args, LOOKUP_NORMAL);\n+    return build_over_call (cand, mem_args, LOOKUP_NORMAL);\n \n   obj = convert_like (TREE_VEC_ELT (cand->convs, 0), obj);\n \n@@ -2719,9 +2716,6 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t\t\t : candidates->fn);\n \t}\n \n-      if (DECL_FUNCTION_MEMBER_P (cand->fn))\n-\tenforce_access (cand->basetype_path, cand->fn);\n-\n       /* Pedantically, normal function declarations are never considered\n \t to refer to template instantiations, so we only do this with\n \t -fguiding-decls.  */ \n@@ -2731,7 +2725,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \tadd_maybe_template (cand->fn, templates);\n \n       return build_over_call\n-\t(cand->fn, cand->convs,\n+\t(cand,\n \t TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n \t ? mem_arglist : arglist,\n \t LOOKUP_NORMAL);\n@@ -3045,9 +3039,10 @@ convert_like (convs, expr)\n     {\n     case USER_CONV:\n       {\n-\ttree fn = TREE_OPERAND (convs, 1);\n+\tstruct z_candidate *cand\n+\t  = WRAPPER_PTR (TREE_OPERAND (convs, 1));\n+\ttree fn = cand->fn;\n \ttree args;\n-\tenforce_access (TREE_OPERAND (convs, 3), fn);\n \n \tif (DECL_CONSTRUCTOR_P (fn))\n \t  {\n@@ -3061,9 +3056,7 @@ convert_like (convs, expr)\n \t  }\n \telse\n \t  args = build_this (expr);\n-\texpr = build_over_call\n-\t  (TREE_OPERAND (convs, 1), TREE_OPERAND (convs, 2),\n-\t   args, LOOKUP_NORMAL);\n+\texpr = build_over_call (cand, args, LOOKUP_NORMAL);\n \n \t/* If this is a constructor or a function returning an aggr type,\n \t   we need to build up a TARGET_EXPR.  */\n@@ -3147,16 +3140,27 @@ convert_default_arg (type, arg)\n }\n \n static tree\n-build_over_call (fn, convs, args, flags)\n-     tree fn, convs, args;\n+build_over_call (cand, args, flags)\n+     struct z_candidate *cand;\n+     tree args;\n      int flags;\n {\n+  tree fn = cand->fn;\n+  tree convs = cand->convs;\n   tree converted_args = NULL_TREE;\n   tree parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   tree conv, arg, val;\n   int i = 0;\n   int is_method = 0;\n \n+  /* Give any warnings we noticed during overload resolution.  */\n+  if (cand->warnings)\n+    for (val = cand->warnings; val; val = TREE_CHAIN (val))\n+      joust (cand, WRAPPER_PTR (TREE_VALUE (val)), 1);\n+\n+  if (DECL_FUNCTION_MEMBER_P (fn))\n+    enforce_access (cand->basetype_path, fn);\n+\n   if (args && TREE_CODE (args) != TREE_LIST)\n     args = build_scratch_list (NULL_TREE, args);\n   arg = args;\n@@ -3588,7 +3592,6 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       return error_mark_node;\n     }\n \n-  enforce_access (cand->basetype_path, cand->fn);\n   if (DECL_ABSTRACT_VIRTUAL_P (cand->fn)\n       && instance == current_class_ref\n       && DECL_CONSTRUCTOR_P (current_function_decl)\n@@ -3613,7 +3616,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n     add_maybe_template (cand->fn, templates);\n \n   return build_over_call\n-    (cand->fn, cand->convs,\n+    (cand,\n      TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE ? mem_args : args,\n      flags);\n }\n@@ -3939,7 +3942,6 @@ compare_ics (ics1, ics2)\n   return 0;\n }\n \n-#if 0\n /* The source type for this standard conversion sequence.  */\n \n static tree\n@@ -3955,7 +3957,19 @@ source_type (t)\n     }\n   my_friendly_abort (1823);\n }\n-#endif\n+\n+/* Note a warning about preferring WINNER to LOSER.  We do this by storing\n+   a pointer to LOSER and re-running joust to produce the warning if WINNER\n+   is actually used.  */\n+\n+static void\n+add_warning (winner, loser)\n+     struct z_candidate *winner, *loser;\n+{\n+  winner->warnings = expr_tree_cons (NULL_PTR,\n+\t\t\t\t     build_expr_ptr_wrapper (loser),\n+\t\t\t\t     winner->warnings);\n+}\n \n /* Compare two candidates for overloading as described in\n    [over.match.best].  Return values:\n@@ -3965,8 +3979,9 @@ source_type (t)\n       0: cand1 and cand2 are indistinguishable */\n \n static int\n-joust (cand1, cand2)\n+joust (cand1, cand2, warn)\n      struct z_candidate *cand1, *cand2;\n+     int warn;\n {\n   int winner = 0;\n   int i, off1 = 0, off2 = 0, len;\n@@ -4014,7 +4029,6 @@ joust (cand1, cand2)\n \n       if (comp != 0)\n \t{\n-#if 0 /* move this warning to tourney.  */\n \t  if (warn_sign_promo\n \t      && ICS_RANK (t1) + ICS_RANK (t2) == STD_RANK + PROMO_RANK\n \t      && TREE_CODE (t1) == STD_CONV\n@@ -4029,16 +4043,23 @@ joust (cand1, cand2)\n \t    {\n \t      tree type = TREE_TYPE (TREE_OPERAND (t1, 0));\n \t      tree type1, type2;\n+\t      struct z_candidate *w, *l;\n \t      if (comp > 0)\n-\t\ttype1 = TREE_TYPE (t1), type2 = TREE_TYPE (t2);\n+\t\ttype1 = TREE_TYPE (t1), type2 = TREE_TYPE (t2),\n+\t\t  w = cand1, l = cand2;\n \t      else\n-\t\ttype1 = TREE_TYPE (t2), type2 = TREE_TYPE (t1);\n+\t\ttype1 = TREE_TYPE (t2), type2 = TREE_TYPE (t1),\n+\t\t  w = cand2, l = cand1;\n \n-\t      cp_warning (\"passing `%T' chooses `%T' over `%T'\",\n-\t\t\t  type, type1, type2);\n-\t      cp_warning (\"  in call to `%D'\", DECL_NAME (cand1->fn));\n+\t      if (warn)\n+\t\t{\n+\t\t  cp_warning (\"passing `%T' chooses `%T' over `%T'\",\n+\t\t\t      type, type1, type2);\n+\t\t  cp_warning (\"  in call to `%D'\", w->fn);\n+\t\t}\n+\t      else\n+\t\tadd_warning (w, l);\n \t    }\n-#endif\n \n \t  if (winner && comp != winner)\n \t    {\n@@ -4049,7 +4070,6 @@ joust (cand1, cand2)\n \t}\n     }\n \n-#if 0 /* move this warning to tourney.  */\n   /* warn about confusing overload resolution */\n   if (winner && cand1->second_conv\n       && ! DECL_CONSTRUCTOR_P (cand1->fn)\n@@ -4063,14 +4083,18 @@ joust (cand1, cand2)\n \t    w = cand1, l = cand2;\n \t  else\n \t    w = cand2, l = cand1;\n-\t  cp_warning (\"choosing `%D' over `%D'\", w->fn, l->fn);\n-\t  cp_warning (\"  for conversion from `%T' to `%T'\",\n-\t\t      TREE_TYPE (source_type (TREE_VEC_ELT (w->convs, 0))),\n-\t\t      TREE_TYPE (w->second_conv));\n-\t  cp_warning (\"  because conversion sequence for `this' argument is better\");\n+\t  if (warn)\n+\t    {\n+\t      cp_warning (\"choosing `%D' over `%D'\", w->fn, l->fn);\n+\t      cp_warning (\"  for conversion from `%T' to `%T'\",\n+\t\t\t  TREE_TYPE (source_type (TREE_VEC_ELT (w->convs, 0))),\n+\t\t\t  TREE_TYPE (w->second_conv));\n+\t      cp_warning (\"  because conversion sequence for `this' argument is better\");\n+\t    }\n+\t  else\n+\t    add_warning (w, l);\n \t}\n     }\n-#endif\n \n   if (winner)\n     return winner;\n@@ -4171,7 +4195,7 @@ tourney (candidates)\n \n   for (challenger = champ->next; challenger; )\n     {\n-      fate = joust (champ, challenger);\n+      fate = joust (champ, challenger, 0);\n       if (fate == 1)\n \tchallenger = challenger->next;\n       else\n@@ -4196,7 +4220,7 @@ tourney (candidates)\n   for (challenger = candidates; challenger != champ;\n        challenger = challenger->next)\n     {\n-      fate = joust (champ, challenger);\n+      fate = joust (champ, challenger, 0);\n       if (fate != 1)\n \treturn 0;\n     }"}, {"sha": "0a42d74a67b80b100542b898884910440f90c4d0", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=5ffe581dd305bd58d49d53fc2d3776d89e56a541", "patch": "@@ -173,6 +173,10 @@ DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n /* XXX: could recycle some of the common fields */\n DEFTREECODE (CPLUS_BINDING, \"binding\", 'x', 2)\n \n+/* A generic wrapper for something not tree that we want to include in\n+   tree structure.  */\n+DEFTREECODE (WRAPPER, \"wrapper\", 'x', 1)\n+\n /* A whole bunch of tree codes for the initial, superficial parsing of\n    templates.  */\n DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", 'e', 2)\n@@ -208,6 +212,10 @@ DEFTREECODE (RETURN_INIT, \"return_init\", 'e', 2)\n DEFTREECODE (TRY_BLOCK, \"try_stmt\", 'e', 2)\n DEFTREECODE (HANDLER, \"catch_stmt\", 'e', 2)\n \n+DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n+\n+/* And some codes for expressing conversions for overload resolution.  */\n+\n DEFTREECODE (IDENTITY_CONV, \"identity_conv\", 'e', 1)\n DEFTREECODE (LVALUE_CONV, \"lvalue_conv\", 'e', 1)\n DEFTREECODE (QUAL_CONV, \"qual_conv\", 'e', 1)\n@@ -216,12 +224,10 @@ DEFTREECODE (PTR_CONV, \"ptr_conv\", 'e', 1)\n DEFTREECODE (PMEM_CONV, \"pmem_conv\", 'e', 1)\n DEFTREECODE (BASE_CONV, \"base_conv\", 'e', 1)\n DEFTREECODE (REF_BIND, \"ref_bind\", 'e', 1)\n-DEFTREECODE (USER_CONV, \"user_conv\", 'e', 4)\n+DEFTREECODE (USER_CONV, \"user_conv\", 'e', 2)\n DEFTREECODE (AMBIG_CONV, \"ambig_conv\", 'e', 1)\n DEFTREECODE (RVALUE_CONV, \"rvalue_conv\", 'e', 1)\n \n-DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n-\n /*\n Local variables:\n mode:c"}, {"sha": "3247196fcc2bc7e0df2b526972ff724ed01232cf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5ffe581dd305bd58d49d53fc2d3776d89e56a541", "patch": "@@ -73,6 +73,18 @@ struct tree_binding\n   tree value;\n };\n \n+#define WRAPPER_PTR(NODE) (((struct tree_wrapper*)NODE)->u.ptr)\n+#define WRAPPER_INT(NODE) (((struct tree_wrapper*)NODE)->u.i)\n+\n+struct tree_wrapper\n+{\n+  char common[sizeof (struct tree_common)];\n+  union {\n+    void *ptr;\n+    int i;\n+  } u;\n+};\n+\n /* To identify to the debug emitters if it should pay attention to the\n    flag `-Wtemplate-debugging'.  */\n #define HAVE_TEMPLATES 1\n@@ -2624,6 +2636,9 @@ extern tree hack_decl_function_context \t\tPROTO((tree));\n extern tree lvalue_type\t\t\t\tPROTO((tree));\n extern tree error_type\t\t\t\tPROTO((tree));\n extern tree make_temp_vec\t\t\tPROTO((int));\n+extern tree build_ptr_wrapper\t\t\tPROTO((void *));\n+extern tree build_expr_ptr_wrapper\t\tPROTO((void *));\n+extern tree build_int_wrapper\t\t\tPROTO((int));\n extern int varargs_function_p\t\t\tPROTO((tree));\n extern int really_overloaded_fn\t\t\tPROTO((tree));\n extern int cp_tree_equal\t\t\tPROTO((tree, tree));"}, {"sha": "5284e7654ea04ab847dec9c939d227aedc0aa540", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5ffe581dd305bd58d49d53fc2d3776d89e56a541", "patch": "@@ -5594,7 +5594,7 @@ template_decl_level (decl)\n \n     default:\n       my_friendly_abort (0);\n-      break;\n+      return 0;\n     }\n }\n "}, {"sha": "3b4ca22efc9bd5f96a159511a83bd0203e335a26", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe581dd305bd58d49d53fc2d3776d89e56a541/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5ffe581dd305bd58d49d53fc2d3776d89e56a541", "patch": "@@ -2141,6 +2141,41 @@ make_temp_vec (len)\n   return node;\n }\n \n+/* Build a wrapper around some pointer PTR so we can use it as a tree.  */\n+\n+tree\n+build_ptr_wrapper (ptr)\n+     void *ptr;\n+{\n+  tree t = make_node (WRAPPER);\n+  WRAPPER_PTR (t) = ptr;\n+  return t;\n+}\n+\n+/* Same, but on the expression_obstack.  */\n+\n+tree\n+build_expr_ptr_wrapper (ptr)\n+     void *ptr;\n+{\n+  tree t;\n+  push_expression_obstack ();\n+  t = build_ptr_wrapper (ptr);\n+  pop_obstacks ();\n+  return t;\n+}\n+\n+/* Build a wrapper around some integer I so we can use it as a tree.  */\n+\n+tree\n+build_int_wrapper (i)\n+     int i;\n+{\n+  tree t = make_node (WRAPPER);\n+  WRAPPER_INT (t) = i;\n+  return t;\n+}\n+\n void\n push_expression_obstack ()\n {"}]}