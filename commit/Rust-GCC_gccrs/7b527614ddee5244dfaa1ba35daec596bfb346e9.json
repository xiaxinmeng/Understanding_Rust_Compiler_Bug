{"sha": "7b527614ddee5244dfaa1ba35daec596bfb346e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I1Mjc2MTRkZGVlNTI0NGRmYWExYmEzNWRhZWM1OTZiZmIzNDZlOQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-07-26T14:08:00Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-07-27T11:04:18Z"}, "message": "libstdc++: Move COW string definitions to separate header\n\nThis moves the definitions of the COW string to a separate file, so that\nthey don't need to be preprocessed for the common case. We could also\nmove the SSO string definitions to a new file, so that they don't need\nto be preprocessed for the old ABI case, but that would require more\nshovel work because there are some parts of <bits/basic_string.h> and\n<bits/basic_string.tcc> that are common to both definitions.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/basic_string.h [!_GLIBCXX_USE_CXX11_ABI]\n\t(basic_string): Move definition of Copy-on-Write string to\n\tnew file.\n\t* include/bits/basic_string.tcc: Likewise.\n\t* include/bits/cow_string.h: New file.", "tree": {"sha": "92189a9bf3f716e50d887bb3813bfa0e7616abfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92189a9bf3f716e50d887bb3813bfa0e7616abfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b527614ddee5244dfaa1ba35daec596bfb346e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b527614ddee5244dfaa1ba35daec596bfb346e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b527614ddee5244dfaa1ba35daec596bfb346e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b527614ddee5244dfaa1ba35daec596bfb346e9/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16158c96496b537194111526d25e19f268d613b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16158c96496b537194111526d25e19f268d613b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16158c96496b537194111526d25e19f268d613b6"}], "stats": {"total": 7252, "additions": 3655, "deletions": 3597}, "files": [{"sha": "15c0ad8dd03c4d609cd3f1fd20e931895dc4dcb8", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b527614ddee5244dfaa1ba35daec596bfb346e9/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b527614ddee5244dfaa1ba35daec596bfb346e9/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=7b527614ddee5244dfaa1ba35daec596bfb346e9", "patch": "@@ -119,6 +119,7 @@ bits_headers = \\\n \t${bits_srcdir}/charconv.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n+\t${bits_srcdir}/cow_string.h \\\n \t${bits_srcdir}/cpp_type_traits.h \\\n \t${bits_srcdir}/deque.tcc \\\n \t${bits_srcdir}/enable_special_members.h \\"}, {"sha": "9d559e2806c8f1e1282eb0b157eec06ef0a2445c", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b527614ddee5244dfaa1ba35daec596bfb346e9/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b527614ddee5244dfaa1ba35daec596bfb346e9/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=7b527614ddee5244dfaa1ba35daec596bfb346e9", "patch": "@@ -469,6 +469,7 @@ bits_headers = \\\n \t${bits_srcdir}/charconv.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n+\t${bits_srcdir}/cow_string.h \\\n \t${bits_srcdir}/cpp_type_traits.h \\\n \t${bits_srcdir}/deque.tcc \\\n \t${bits_srcdir}/enable_special_members.h \\"}, {"sha": "b61fe05efcf998be80627875f5a0e7c34c3c019c", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 10, "deletions": 2949, "changes": 2959, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b527614ddee5244dfaa1ba35daec596bfb346e9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b527614ddee5244dfaa1ba35daec596bfb346e9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=7b527614ddee5244dfaa1ba35daec596bfb346e9"}, {"sha": "371f1c3ccee5fa1e1ccda4ddc7429e7fd50e8971", "filename": "libstdc++-v3/include/bits/basic_string.tcc", "status": "modified", "additions": 1, "deletions": 648, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b527614ddee5244dfaa1ba35daec596bfb346e9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b527614ddee5244dfaa1ba35daec596bfb346e9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc?ref=7b527614ddee5244dfaa1ba35daec596bfb346e9", "patch": "@@ -515,654 +515,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __n;\n     }\n \n-#else  // !_GLIBCXX_USE_CXX11_ABI\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    const typename basic_string<_CharT, _Traits, _Alloc>::size_type\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    const _CharT\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    _Rep::_S_terminal = _CharT();\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    const typename basic_string<_CharT, _Traits, _Alloc>::size_type\n-    basic_string<_CharT, _Traits, _Alloc>::npos;\n-\n-  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)\n-  // at static init time (before static ctors are run).\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n-    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[\n-    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /\n-      sizeof(size_type)];\n-\n-  // NB: This is the special case for Input Iterators, used in\n-  // istreambuf_iterators, etc.\n-  // Input Iterators have a cost structure very different from\n-  // pointers, calling for a different coding style.\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    template<typename _InIterator>\n-      _CharT*\n-      basic_string<_CharT, _Traits, _Alloc>::\n-      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,\n-\t\t   input_iterator_tag)\n-      {\n-#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n-\tif (__beg == __end && __a == _Alloc())\n-\t  return _S_empty_rep()._M_refdata();\n-#endif\n-\t// Avoid reallocation for common case.\n-\t_CharT __buf[128];\n-\tsize_type __len = 0;\n-\twhile (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))\n-\t  {\n-\t    __buf[__len++] = *__beg;\n-\t    ++__beg;\n-\t  }\n-\t_Rep* __r = _Rep::_S_create(__len, size_type(0), __a);\n-\t_M_copy(__r->_M_refdata(), __buf, __len);\n-\t__try\n-\t  {\n-\t    while (__beg != __end)\n-\t      {\n-\t\tif (__len == __r->_M_capacity)\n-\t\t  {\n-\t\t    // Allocate more space.\n-\t\t    _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);\n-\t\t    _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);\n-\t\t    __r->_M_destroy(__a);\n-\t\t    __r = __another;\n-\t\t  }\n-\t\t__r->_M_refdata()[__len++] = *__beg;\n-\t\t++__beg;\n-\t      }\n-\t  }\n-\t__catch(...)\n-\t  {\n-\t    __r->_M_destroy(__a);\n-\t    __throw_exception_again;\n-\t  }\n-\t__r->_M_set_length_and_sharable(__len);\n-\treturn __r->_M_refdata();\n-      }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    template <typename _InIterator>\n-      _CharT*\n-      basic_string<_CharT, _Traits, _Alloc>::\n-      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,\n-\t\t   forward_iterator_tag)\n-      {\n-#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n-\tif (__beg == __end && __a == _Alloc())\n-\t  return _S_empty_rep()._M_refdata();\n-#endif\n-\t// NB: Not required, but considered best practice.\n-\tif (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)\n-\t  __throw_logic_error(__N(\"basic_string::_S_construct null not valid\"));\n-\n-\tconst size_type __dnew = static_cast<size_type>(std::distance(__beg,\n-\t\t\t\t\t\t\t\t      __end));\n-\t// Check for out_of_range and length_error exceptions.\n-\t_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);\n-\t__try\n-\t  { _S_copy_chars(__r->_M_refdata(), __beg, __end); }\n-\t__catch(...)\n-\t  {\n-\t    __r->_M_destroy(__a);\n-\t    __throw_exception_again;\n-\t  }\n-\t__r->_M_set_length_and_sharable(__dnew);\n-\treturn __r->_M_refdata();\n-      }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    _CharT*\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)\n-    {\n-#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n-      if (__n == 0 && __a == _Alloc())\n-\treturn _S_empty_rep()._M_refdata();\n-#endif\n-      // Check for out_of_range and length_error exceptions.\n-      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);\n-      if (__n)\n-\t_M_assign(__r->_M_refdata(), __n, __c);\n-\n-      __r->_M_set_length_and_sharable(__n);\n-      return __r->_M_refdata();\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    basic_string(const basic_string& __str, size_type __pos, const _Alloc& __a)\n-    : _M_dataplus(_S_construct(__str._M_data()\n-\t\t\t       + __str._M_check(__pos,\n-\t\t\t\t\t\t\"basic_string::basic_string\"),\n-\t\t\t       __str._M_data() + __str._M_limit(__pos, npos)\n-\t\t\t       + __pos, __a), __a)\n-    { }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    basic_string(const basic_string& __str, size_type __pos, size_type __n)\n-    : _M_dataplus(_S_construct(__str._M_data()\n-\t\t\t       + __str._M_check(__pos,\n-\t\t\t\t\t\t\"basic_string::basic_string\"),\n-\t\t\t       __str._M_data() + __str._M_limit(__pos, __n)\n-\t\t\t       + __pos, _Alloc()), _Alloc())\n-    { }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    basic_string(const basic_string& __str, size_type __pos,\n-\t\t size_type __n, const _Alloc& __a)\n-    : _M_dataplus(_S_construct(__str._M_data()\n-\t\t\t       + __str._M_check(__pos,\n-\t\t\t\t\t\t\"basic_string::basic_string\"),\n-\t\t\t       __str._M_data() + __str._M_limit(__pos, __n)\n-\t\t\t       + __pos, __a), __a)\n-    { }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>&\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    assign(const basic_string& __str)\n-    {\n-      if (_M_rep() != __str._M_rep())\n-\t{\n-\t  // XXX MT\n-\t  const allocator_type __a = this->get_allocator();\n-\t  _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());\n-\t  _M_rep()->_M_dispose(__a);\n-\t  _M_data(__tmp);\n-\t}\n-      return *this;\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>&\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    assign(const _CharT* __s, size_type __n)\n-    {\n-      __glibcxx_requires_string_len(__s, __n);\n-      _M_check_length(this->size(), __n, \"basic_string::assign\");\n-      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())\n-\treturn _M_replace_safe(size_type(0), this->size(), __s, __n);\n-      else\n-\t{\n-\t  // Work in-place.\n-\t  const size_type __pos = __s - _M_data();\n-\t  if (__pos >= __n)\n-\t    _M_copy(_M_data(), __s, __n);\n-\t  else if (__pos)\n-\t    _M_move(_M_data(), __s, __n);\n-\t  _M_rep()->_M_set_length_and_sharable(__n);\n-\t  return *this;\n-\t}\n-     }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>&\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    append(size_type __n, _CharT __c)\n-    {\n-      if (__n)\n-\t{\n-\t  _M_check_length(size_type(0), __n, \"basic_string::append\");\t  \n-\t  const size_type __len = __n + this->size();\n-\t  if (__len > this->capacity() || _M_rep()->_M_is_shared())\n-\t    this->reserve(__len);\n-\t  _M_assign(_M_data() + this->size(), __n, __c);\n-\t  _M_rep()->_M_set_length_and_sharable(__len);\n-\t}\n-      return *this;\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>&\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    append(const _CharT* __s, size_type __n)\n-    {\n-      __glibcxx_requires_string_len(__s, __n);\n-      if (__n)\n-\t{\n-\t  _M_check_length(size_type(0), __n, \"basic_string::append\");\n-\t  const size_type __len = __n + this->size();\n-\t  if (__len > this->capacity() || _M_rep()->_M_is_shared())\n-\t    {\n-\t      if (_M_disjunct(__s))\n-\t\tthis->reserve(__len);\n-\t      else\n-\t\t{\n-\t\t  const size_type __off = __s - _M_data();\n-\t\t  this->reserve(__len);\n-\t\t  __s = _M_data() + __off;\n-\t\t}\n-\t    }\n-\t  _M_copy(_M_data() + this->size(), __s, __n);\n-\t  _M_rep()->_M_set_length_and_sharable(__len);\n-\t}\n-      return *this;\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>&\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    append(const basic_string& __str)\n-    {\n-      const size_type __size = __str.size();\n-      if (__size)\n-\t{\n-\t  const size_type __len = __size + this->size();\n-\t  if (__len > this->capacity() || _M_rep()->_M_is_shared())\n-\t    this->reserve(__len);\n-\t  _M_copy(_M_data() + this->size(), __str._M_data(), __size);\n-\t  _M_rep()->_M_set_length_and_sharable(__len);\n-\t}\n-      return *this;\n-    }    \n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>&\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    append(const basic_string& __str, size_type __pos, size_type __n)\n-    {\n-      __str._M_check(__pos, \"basic_string::append\");\n-      __n = __str._M_limit(__pos, __n);\n-      if (__n)\n-\t{\n-\t  const size_type __len = __n + this->size();\n-\t  if (__len > this->capacity() || _M_rep()->_M_is_shared())\n-\t    this->reserve(__len);\n-\t  _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);\n-\t  _M_rep()->_M_set_length_and_sharable(__len);\t  \n-\t}\n-      return *this;\n-    }\n-\n-   template<typename _CharT, typename _Traits, typename _Alloc>\n-     basic_string<_CharT, _Traits, _Alloc>&\n-     basic_string<_CharT, _Traits, _Alloc>::\n-     insert(size_type __pos, const _CharT* __s, size_type __n)\n-     {\n-       __glibcxx_requires_string_len(__s, __n);\n-       _M_check(__pos, \"basic_string::insert\");\n-       _M_check_length(size_type(0), __n, \"basic_string::insert\");\n-       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())\n-         return _M_replace_safe(__pos, size_type(0), __s, __n);\n-       else\n-         {\n-           // Work in-place.\n-           const size_type __off = __s - _M_data();\n-           _M_mutate(__pos, 0, __n);\n-           __s = _M_data() + __off;\n-           _CharT* __p = _M_data() + __pos;\n-           if (__s  + __n <= __p)\n-             _M_copy(__p, __s, __n);\n-           else if (__s >= __p)\n-             _M_copy(__p, __s + __n, __n);\n-           else\n-             {\n-\t       const size_type __nleft = __p - __s;\n-               _M_copy(__p, __s, __nleft);\n-               _M_copy(__p + __nleft, __p + __n, __n - __nleft);\n-             }\n-           return *this;\n-         }\n-     }\n-\n-   template<typename _CharT, typename _Traits, typename _Alloc>\n-     typename basic_string<_CharT, _Traits, _Alloc>::iterator\n-     basic_string<_CharT, _Traits, _Alloc>::\n-     erase(iterator __first, iterator __last)\n-     {\n-       _GLIBCXX_DEBUG_PEDASSERT(__first >= _M_ibegin() && __first <= __last\n-\t\t\t\t&& __last <= _M_iend());\n-\n-       // NB: This isn't just an optimization (bail out early when\n-       // there is nothing to do, really), it's also a correctness\n-       // issue vs MT, see libstdc++/40518.\n-       const size_type __size = __last - __first;\n-       if (__size)\n-\t {\n-\t   const size_type __pos = __first - _M_ibegin();\n-\t   _M_mutate(__pos, __size, size_type(0));\n-\t   _M_rep()->_M_set_leaked();\n-\t   return iterator(_M_data() + __pos);\n-\t }\n-       else\n-\t return __first;\n-     }\n-\n-   template<typename _CharT, typename _Traits, typename _Alloc>\n-     basic_string<_CharT, _Traits, _Alloc>&\n-     basic_string<_CharT, _Traits, _Alloc>::\n-     replace(size_type __pos, size_type __n1, const _CharT* __s,\n-\t     size_type __n2)\n-     {\n-       __glibcxx_requires_string_len(__s, __n2);\n-       _M_check(__pos, \"basic_string::replace\");\n-       __n1 = _M_limit(__pos, __n1);\n-       _M_check_length(__n1, __n2, \"basic_string::replace\");\n-       bool __left;\n-       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())\n-         return _M_replace_safe(__pos, __n1, __s, __n2);\n-       else if ((__left = __s + __n2 <= _M_data() + __pos)\n-\t\t|| _M_data() + __pos + __n1 <= __s)\n-\t {\n-\t   // Work in-place: non-overlapping case.\n-\t   size_type __off = __s - _M_data();\n-\t   __left ? __off : (__off += __n2 - __n1);\n-\t   _M_mutate(__pos, __n1, __n2);\n-\t   _M_copy(_M_data() + __pos, _M_data() + __off, __n2);\n-\t   return *this;\n-\t }\n-       else\n-\t {\n-\t   // Todo: overlapping case.\n-\t   const basic_string __tmp(__s, __n2);\n-\t   return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);\n-\t }\n-     }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    void\n-    basic_string<_CharT, _Traits, _Alloc>::_Rep::\n-    _M_destroy(const _Alloc& __a) throw ()\n-    {\n-      const size_type __size = sizeof(_Rep_base) +\n-\t                       (this->_M_capacity + 1) * sizeof(_CharT);\n-      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    void\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    _M_leak_hard()\n-    {\n-#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n-      if (_M_rep() == &_S_empty_rep())\n-\treturn;\n-#endif\n-      if (_M_rep()->_M_is_shared())\n-\t_M_mutate(0, 0, 0);\n-      _M_rep()->_M_set_leaked();\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    void\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    _M_mutate(size_type __pos, size_type __len1, size_type __len2)\n-    {\n-      const size_type __old_size = this->size();\n-      const size_type __new_size = __old_size + __len2 - __len1;\n-      const size_type __how_much = __old_size - __pos - __len1;\n-\n-      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())\n-\t{\n-\t  // Must reallocate.\n-\t  const allocator_type __a = get_allocator();\n-\t  _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);\n-\n-\t  if (__pos)\n-\t    _M_copy(__r->_M_refdata(), _M_data(), __pos);\n-\t  if (__how_much)\n-\t    _M_copy(__r->_M_refdata() + __pos + __len2,\n-\t\t    _M_data() + __pos + __len1, __how_much);\n-\n-\t  _M_rep()->_M_dispose(__a);\n-\t  _M_data(__r->_M_refdata());\n-\t}\n-      else if (__how_much && __len1 != __len2)\n-\t{\n-\t  // Work in-place.\n-\t  _M_move(_M_data() + __pos + __len2,\n-\t\t  _M_data() + __pos + __len1, __how_much);\n-\t}\n-      _M_rep()->_M_set_length_and_sharable(__new_size);\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    void\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    reserve(size_type __res)\n-    {\n-      const size_type __capacity = capacity();\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 2968. Inconsistencies between basic_string reserve and\n-      // vector/unordered_map/unordered_set reserve functions\n-      // P0966 reserve should not shrink\n-      if (__res <= __capacity)\n-\t{\n-\t  if (!_M_rep()->_M_is_shared())\n-\t    return;\n-\n-\t  // unshare, but keep same capacity\n-\t  __res = __capacity;\n-\t}\n-\n-      const allocator_type __a = get_allocator();\n-      _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());\n-      _M_rep()->_M_dispose(__a);\n-      _M_data(__tmp);\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    void\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    swap(basic_string& __s)\n-    _GLIBCXX_NOEXCEPT_IF(allocator_traits<_Alloc>::is_always_equal::value)\n-    {\n-      if (_M_rep()->_M_is_leaked())\n-\t_M_rep()->_M_set_sharable();\n-      if (__s._M_rep()->_M_is_leaked())\n-\t__s._M_rep()->_M_set_sharable();\n-      if (this->get_allocator() == __s.get_allocator())\n-\t{\n-\t  _CharT* __tmp = _M_data();\n-\t  _M_data(__s._M_data());\n-\t  __s._M_data(__tmp);\n-\t}\n-      // The code below can usually be optimized away.\n-      else\n-\t{\n-\t  const basic_string __tmp1(_M_ibegin(), _M_iend(),\n-\t\t\t\t    __s.get_allocator());\n-\t  const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),\n-\t\t\t\t    this->get_allocator());\n-\t  *this = __tmp2;\n-\t  __s = __tmp1;\n-\t}\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*\n-    basic_string<_CharT, _Traits, _Alloc>::_Rep::\n-    _S_create(size_type __capacity, size_type __old_capacity,\n-\t      const _Alloc& __alloc)\n-    {\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 83.  String::npos vs. string::max_size()\n-      if (__capacity > _S_max_size)\n-\t__throw_length_error(__N(\"basic_string::_S_create\"));\n-\n-      // The standard places no restriction on allocating more memory\n-      // than is strictly needed within this layer at the moment or as\n-      // requested by an explicit application call to reserve(n).\n-\n-      // Many malloc implementations perform quite poorly when an\n-      // application attempts to allocate memory in a stepwise fashion\n-      // growing each allocation size by only 1 char.  Additionally,\n-      // it makes little sense to allocate less linear memory than the\n-      // natural blocking size of the malloc implementation.\n-      // Unfortunately, we would need a somewhat low-level calculation\n-      // with tuned parameters to get this perfect for any particular\n-      // malloc implementation.  Fortunately, generalizations about\n-      // common features seen among implementations seems to suffice.\n-\n-      // __pagesize need not match the actual VM page size for good\n-      // results in practice, thus we pick a common value on the low\n-      // side.  __malloc_header_size is an estimate of the amount of\n-      // overhead per memory allocation (in practice seen N * sizeof\n-      // (void*) where N is 0, 2 or 4).  According to folklore,\n-      // picking this value on the high side is better than\n-      // low-balling it (especially when this algorithm is used with\n-      // malloc implementations that allocate memory blocks rounded up\n-      // to a size which is a power of 2).\n-      const size_type __pagesize = 4096;\n-      const size_type __malloc_header_size = 4 * sizeof(void*);\n-\n-      // The below implements an exponential growth policy, necessary to\n-      // meet amortized linear time requirements of the library: see\n-      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.\n-      // It's active for allocations requiring an amount of memory above\n-      // system pagesize. This is consistent with the requirements of the\n-      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html\n-      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)\n-\t__capacity = 2 * __old_capacity;\n-\n-      // NB: Need an array of char_type[__capacity], plus a terminating\n-      // null char_type() element, plus enough for the _Rep data structure.\n-      // Whew. Seemingly so needy, yet so elemental.\n-      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\n-\n-      const size_type __adj_size = __size + __malloc_header_size;\n-      if (__adj_size > __pagesize && __capacity > __old_capacity)\n-\t{\n-\t  const size_type __extra = __pagesize - __adj_size % __pagesize;\n-\t  __capacity += __extra / sizeof(_CharT);\n-\t  // Never allocate a string bigger than _S_max_size.\n-\t  if (__capacity > _S_max_size)\n-\t    __capacity = _S_max_size;\n-\t  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\n-\t}\n-\n-      // NB: Might throw, but no worries about a leak, mate: _Rep()\n-      // does not throw.\n-      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);\n-      _Rep *__p = new (__place) _Rep;\n-      __p->_M_capacity = __capacity;\n-      // ABI compatibility - 3.4.x set in _S_create both\n-      // _M_refcount and _M_length.  All callers of _S_create\n-      // in basic_string.tcc then set just _M_length.\n-      // In 4.0.x and later both _M_refcount and _M_length\n-      // are initialized in the callers, unfortunately we can\n-      // have 3.4.x compiled code with _S_create callers inlined\n-      // calling 4.0.x+ _S_create.\n-      __p->_M_set_sharable();\n-      return __p;\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    _CharT*\n-    basic_string<_CharT, _Traits, _Alloc>::_Rep::\n-    _M_clone(const _Alloc& __alloc, size_type __res)\n-    {\n-      // Requested capacity of the clone.\n-      const size_type __requested_cap = this->_M_length + __res;\n-      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,\n-\t\t\t\t  __alloc);\n-      if (this->_M_length)\n-\t_M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);\n-\n-      __r->_M_set_length_and_sharable(this->_M_length);\n-      return __r->_M_refdata();\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    void\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    resize(size_type __n, _CharT __c)\n-    {\n-      const size_type __size = this->size();\n-      _M_check_length(__size, __n, \"basic_string::resize\");\n-      if (__size < __n)\n-\tthis->append(__n - __size, __c);\n-      else if (__n < __size)\n-\tthis->erase(__n);\n-      // else nothing (in particular, avoid calling _M_mutate() unnecessarily.)\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    template<typename _InputIterator>\n-      basic_string<_CharT, _Traits, _Alloc>&\n-      basic_string<_CharT, _Traits, _Alloc>::\n-      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,\n-\t\t\t  _InputIterator __k2, __false_type)\n-      {\n-\tconst basic_string __s(__k1, __k2);\n-\tconst size_type __n1 = __i2 - __i1;\n-\t_M_check_length(__n1, __s.size(), \"basic_string::_M_replace_dispatch\");\n-\treturn _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),\n-\t\t\t       __s.size());\n-      }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>&\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n-\t\t   _CharT __c)\n-    {\n-      _M_check_length(__n1, __n2, \"basic_string::_M_replace_aux\");\n-      _M_mutate(__pos1, __n1, __n2);\n-      if (__n2)\n-\t_M_assign(_M_data() + __pos1, __n2, __c);\n-      return *this;\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>&\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,\n-\t\t    size_type __n2)\n-    {\n-      _M_mutate(__pos1, __n1, __n2);\n-      if (__n2)\n-\t_M_copy(_M_data() + __pos1, __s, __n2);\n-      return *this;\n-    }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    void\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    reserve()\n-    {\n-#if __cpp_exceptions\n-      if (length() < capacity() || _M_rep()->_M_is_shared())\n-\ttry\n-\t  {\n-\t    const allocator_type __a = get_allocator();\n-\t    _CharT* __tmp = _M_rep()->_M_clone(__a);\n-\t    _M_rep()->_M_dispose(__a);\n-\t    _M_data(__tmp);\n-\t  }\n-\tcatch (const __cxxabiv1::__forced_unwind&)\n-\t  { throw; }\n-\tcatch (...)\n-\t  { /* swallow the exception */ }\n-#endif\n-    }\n-\n-    template<typename _CharT, typename _Traits, typename _Alloc>\n-    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    copy(_CharT* __s, size_type __n, size_type __pos) const\n-    {\n-      _M_check(__pos, \"basic_string::copy\");\n-      __n = _M_limit(__pos, __n);\n-      __glibcxx_requires_string_len(__s, __n);\n-      if (__n)\n-\t_M_copy(__s, _M_data() + __pos, __n);\n-      // 21.3.5.7 par 3: do not append null.  (good.)\n-      return __n;\n-    }\n-#endif  // !_GLIBCXX_USE_CXX11_ABI\n+#endif  // _GLIBCXX_USE_CXX11_ABI\n    \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT, _Traits, _Alloc>"}, {"sha": "53532657492b5bdeb1fde03dcad496d7915e1af4", "filename": "libstdc++-v3/include/bits/cow_string.h", "status": "added", "additions": 3642, "deletions": 0, "changes": 3642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b527614ddee5244dfaa1ba35daec596bfb346e9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcow_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b527614ddee5244dfaa1ba35daec596bfb346e9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcow_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcow_string.h?ref=7b527614ddee5244dfaa1ba35daec596bfb346e9"}]}