{"sha": "c34fdf0b7d1e046a50934c10011753d04be8e8b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM0ZmRmMGI3ZDFlMDQ2YTUwOTM0YzEwMDExNzUzZDA0YmU4ZThiNw==", "commit": {"author": {"name": "Robert Schuster", "email": "thebohemian@gmx.net", "date": "2005-02-23T08:26:36Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-02-23T08:26:36Z"}, "message": "ChannelReader: Fixed comments.\n\n2005-02-23  Robert Schuster  <thebohemian@gmx.net>\n\n\t* gnu/java/nio/ChannelReader: Fixed comments.\n\n2005-02-23  Robert Schuster  <thebohemian@gmx.net>\n\n\t* java/nio/channels/Channels: Added FIXMEs about\n\tstub method implementation.\n\t(newReader): Implemented.\n\t* gnu/java/nio/ChannelReader: New class.\n\nFrom-SVN: r95444", "tree": {"sha": "801764634800278672a258eed2b0c774e28e1538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/801764634800278672a258eed2b0c774e28e1538"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c34fdf0b7d1e046a50934c10011753d04be8e8b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34fdf0b7d1e046a50934c10011753d04be8e8b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34fdf0b7d1e046a50934c10011753d04be8e8b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34fdf0b7d1e046a50934c10011753d04be8e8b7/comments", "author": {"login": "thebohemian", "id": 336602, "node_id": "MDQ6VXNlcjMzNjYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/336602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thebohemian", "html_url": "https://github.com/thebohemian", "followers_url": "https://api.github.com/users/thebohemian/followers", "following_url": "https://api.github.com/users/thebohemian/following{/other_user}", "gists_url": "https://api.github.com/users/thebohemian/gists{/gist_id}", "starred_url": "https://api.github.com/users/thebohemian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thebohemian/subscriptions", "organizations_url": "https://api.github.com/users/thebohemian/orgs", "repos_url": "https://api.github.com/users/thebohemian/repos", "events_url": "https://api.github.com/users/thebohemian/events{/privacy}", "received_events_url": "https://api.github.com/users/thebohemian/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16b31d8f3e8f942c70be8a0c5704b1de8789fe9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b31d8f3e8f942c70be8a0c5704b1de8789fe9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16b31d8f3e8f942c70be8a0c5704b1de8789fe9f"}], "stats": {"total": 226, "additions": 225, "deletions": 1}, "files": [{"sha": "2aded18a25e870860299f78e28ea0ee10b5e4e4c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34fdf0b7d1e046a50934c10011753d04be8e8b7/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34fdf0b7d1e046a50934c10011753d04be8e8b7/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c34fdf0b7d1e046a50934c10011753d04be8e8b7", "patch": "@@ -1,3 +1,14 @@\n+2005-02-23  Robert Schuster  <thebohemian@gmx.net>\n+\n+\t* gnu/java/nio/ChannelReader: Fixed comments.\n+\n+2005-02-23  Robert Schuster  <thebohemian@gmx.net>\n+\n+\t* java/nio/channels/Channels: Added FIXMEs about\n+\tstub method implementation.\n+\t(newReader): Implemented.\n+\t* gnu/java/nio/ChannelReader: New class.\n+\n 2005-02-23  Michael Koch  <konqueror@gmx.de>\n \n \t* java/text/SimpleDateFormat.java:"}, {"sha": "11e66a77ebb48a2e37ca7828d02e2b15f108bf31", "filename": "libjava/gnu/java/nio/ChannelReader.java", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34fdf0b7d1e046a50934c10011753d04be8e8b7/libjava%2Fgnu%2Fjava%2Fnio%2FChannelReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34fdf0b7d1e046a50934c10011753d04be8e8b7/libjava%2Fgnu%2Fjava%2Fnio%2FChannelReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FChannelReader.java?ref=c34fdf0b7d1e046a50934c10011753d04be8e8b7", "patch": "@@ -0,0 +1,211 @@\n+/* ChannelReader.java -- \n+ Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+ This file is part of GNU Classpath.\n+\n+ GNU Classpath is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU Classpath is distributed in the hope that it will be useful, but\n+ WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU Classpath; see the file COPYING.  If not, write to the\n+ Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+ 02111-1307 USA.\n+\n+ Linking this library statically or dynamically with other modules is\n+ making a combined work based on this library.  Thus, the terms and\n+ conditions of the GNU General Public License cover the whole\n+ combination.\n+\n+ As a special exception, the copyright holders of this library give you\n+ permission to link this library with independent modules to produce an\n+ executable, regardless of the license terms of these independent\n+ modules, and to copy and distribute the resulting executable under\n+ terms of your choice, provided that you also meet, for each linked\n+ independent module, the terms and conditions of the license of that\n+ module.  An independent module is a module which is not derived from\n+ or based on this library.  If you modify this library, you may extend\n+ this exception to your version of the library, but you are not\n+ obligated to do so.  If you do not wish to do so, delete this\n+ exception statement from your version. */\n+\n+\n+package gnu.java.nio;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CoderResult;\n+import java.nio.charset.CodingErrorAction;\n+\n+/**\n+ * A Reader implementation that works using a ReadableByteChannel and a\n+ * CharsetDecoder.\n+ * \n+ * <p>\n+ * This is a bridge between NIO <-> IO character decoding.\n+ * </p>\n+ * \n+ * @author Robert Schuster\n+ */\n+public class ChannelReader extends Reader\n+{\n+\n+  private static final int DEFAULT_BUFFER_CAP = 8192;\n+\n+  private ReadableByteChannel channel;\n+\n+  private CharsetDecoder decoder;\n+\n+  private ByteBuffer byteBuffer;\n+\n+  private CharBuffer charBuffer;\n+\n+  public ChannelReader(ReadableByteChannel channel, CharsetDecoder decoder,\n+                       int minBufferCap)\n+  {\n+    this.channel = channel;\n+    this.decoder = decoder;\n+\n+    // JDK reports errors, so we do the same.\n+    decoder.onMalformedInput(CodingErrorAction.REPORT);\n+    decoder.onUnmappableCharacter(CodingErrorAction.REPORT);\n+    decoder.reset();\n+\n+    int size = (minBufferCap == -1) ? DEFAULT_BUFFER_CAP : minBufferCap;\n+\n+    // Allocates the buffers and prepares them for reading, because that is the\n+    // first operation being done on them.\n+    byteBuffer = ByteBuffer.allocate(size);\n+    byteBuffer.flip();\n+    charBuffer = CharBuffer.allocate((int) (size * decoder.averageCharsPerByte()));\n+  }\n+\n+  public int read(char[] buf, int offset, int count) throws IOException\n+  {\n+    // I declared channel being null meaning that the reader is closed.\n+    if (!channel.isOpen())\n+      throw new IOException(\"Reader was already closed.\");\n+\n+    // I declared decoder being null meaning that there is no more data to read\n+    // and convert.\n+    if (decoder == null)\n+      return -1;\n+\n+    // Stores the amount of character being read. It -1 so that if no conversion\n+    // occured the caller will see this as an 'end of file'.\n+    int sum = -1;\n+\n+    // Copies any characters which may be left from the last invocation into the\n+    // destination array.\n+    if (charBuffer.remaining() > 0)\n+      {\n+        sum = Math.min(count, charBuffer.remaining());\n+        charBuffer.get(buf, offset, sum);\n+\n+        // Updates the control variables according to the latest copy operation.\n+        offset += sum;\n+        count -= sum;\n+      }\n+\n+    // Copies the character which have not been put in the destination array to\n+    // the beginning. If data is actually copied count will be 0. If no data is\n+    // copied count is >0 and we can now convert some more characters.\n+    charBuffer.compact();\n+\n+    int converted = 0;\n+    boolean last = false;\n+\n+    while (count != 0)\n+      {\n+        // Tries to convert some bytes (Which will intentionally fail in the\n+        // first place because we have not read any bytes yet.)\n+        CoderResult result = decoder.decode(byteBuffer, charBuffer, last);\n+        if (result.isMalformed() || result.isUnmappable())\n+          {\n+            // JDK throws exception when bytes are malformed for sure.\n+            // FIXME: Unsure what happens when a character is simply\n+            // unmappable.\n+            result.throwException();\n+          }\n+\n+        // Marks that we should end this loop regardless whether the caller\n+        // wants more chars or not, when this was the last conversion.\n+        if (last)\n+          {\n+            decoder = null;\n+          }\n+        else if (result.isUnderflow())\n+          {\n+            // We need more bytes to do the conversion.\n+\n+            // Copies the not yet converted bytes to the beginning making it\n+            // being able to receive more bytes.\n+            byteBuffer.compact();\n+\n+            // Reads in another bunch of bytes for being converted.\n+            if (channel.read(byteBuffer) == -1)\n+              {\n+                // If there is no more data available in the channel we mark\n+                // that state for the final character conversion run which is\n+                // done in the next loop iteration.\n+                last = true;\n+              }\n+\n+            // Prepares the byteBuffer for the next character conversion run.\n+            byteBuffer.flip();\n+          }\n+\n+        // Prepares the charBuffer for being drained.\n+        charBuffer.flip();\n+\n+        converted = Math.min(count, charBuffer.remaining());\n+        charBuffer.get(buf, offset, converted);\n+\n+        // Copies characters which have not yet being copied into the char-Array\n+        // to the beginning making it possible to read them later (If data is\n+        // really copied here, then the caller has received enough characters so\n+        // far.).\n+        charBuffer.compact();\n+\n+        // Updates the control variables according to the latest copy operation.\n+        offset += converted;\n+        count -= converted;\n+\n+        // Updates the amount of transferred characters.\n+        sum += converted;\n+\n+        if (decoder == null)\n+          {\n+            break;\n+          }\n+\n+        // Now that more characters have been transfered we let the loop decide\n+        // what to do next.\n+      }\n+\n+    // Makes the charBuffer ready for reading on the next invocation.\n+    charBuffer.flip();\n+\n+    return sum;\n+  }\n+\n+  public void close() throws IOException\n+  {\n+    channel.close();\n+\n+    // Makes sure all intermediate data is released by the decoder.\n+    if (decoder != null)\n+      decoder.reset();\n+  }\n+\n+}"}, {"sha": "1da5d13193e62494dd4b5fce4ca07c6cccb2a1a5", "filename": "libjava/java/nio/channels/Channels.java", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34fdf0b7d1e046a50934c10011753d04be8e8b7/libjava%2Fjava%2Fnio%2Fchannels%2FChannels.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34fdf0b7d1e046a50934c10011753d04be8e8b7/libjava%2Fjava%2Fnio%2Fchannels%2FChannels.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FChannels.java?ref=c34fdf0b7d1e046a50934c10011753d04be8e8b7", "patch": "@@ -40,6 +40,7 @@\n \n import gnu.java.nio.ChannelInputStream;\n import gnu.java.nio.ChannelOutputStream;\n+import gnu.java.nio.ChannelReader;\n import gnu.java.nio.InputStreamChannel;\n import gnu.java.nio.OutputStreamChannel;\n import gnu.java.nio.channels.FileChannelImpl;\n@@ -115,7 +116,7 @@ public static WritableByteChannel newChannel(OutputStream out)\n   public static Reader newReader(ReadableByteChannel ch, CharsetDecoder dec,\n                                  int minBufferCap)\n   {\n-    throw new Error(\"not implemented\");\n+    return new ChannelReader(ch, dec, minBufferCap);\n   }\n \n   /**\n@@ -137,6 +138,7 @@ public static Reader newReader(ReadableByteChannel ch, String csName)\n   public static Writer newWriter(WritableByteChannel ch, CharsetEncoder enc,\n                                  int minBufferCap)\n   {\n+    // FIXME: implement java.nio.channels.Channel.newWriter(WritableByteChannel, CharsetEncoder, int) \n     throw new Error(\"not implemented\");\n   }\n "}]}