{"sha": "d28f307870b411905989a09a524211a88561640b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI4ZjMwNzg3MGI0MTE5MDU5ODlhMDlhNTI0MjExYTg4NTYxNjQwYg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2004-11-06T23:07:45Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2004-11-06T23:07:45Z"}, "message": "* java/io/FilePermission.java: Reindented.\n\nFrom-SVN: r90201", "tree": {"sha": "58a510c6153b3349ed1740e17ae4efa5f1885424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58a510c6153b3349ed1740e17ae4efa5f1885424"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d28f307870b411905989a09a524211a88561640b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d28f307870b411905989a09a524211a88561640b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d28f307870b411905989a09a524211a88561640b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d28f307870b411905989a09a524211a88561640b/comments", "author": null, "committer": null, "parents": [{"sha": "7771b8da335a758fac6296f34f164c82470cf6d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7771b8da335a758fac6296f34f164c82470cf6d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7771b8da335a758fac6296f34f164c82470cf6d3"}], "stats": {"total": 312, "additions": 150, "deletions": 162}, "files": [{"sha": "7de8b5cbfbba1f4c2dbcc45f15ec3b5a41e0820f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d28f307870b411905989a09a524211a88561640b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d28f307870b411905989a09a524211a88561640b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d28f307870b411905989a09a524211a88561640b", "patch": "@@ -1,3 +1,7 @@\n+2004-11-06  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/io/FilePermission.java: Reindented.\n+\n 2004-11-06  Tom Tromey  <tromey@redhat.com>\n \n \t* java/io/ObjectOutputStream.java (currentObjectStreamClass): Now"}, {"sha": "9151bf66964832da9f5c1c56341813aa9c3b9b70", "filename": "libjava/java/io/FilePermission.java", "status": "modified", "additions": 146, "deletions": 162, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d28f307870b411905989a09a524211a88561640b/libjava%2Fjava%2Fio%2FFilePermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d28f307870b411905989a09a524211a88561640b/libjava%2Fjava%2Fio%2FFilePermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilePermission.java?ref=d28f307870b411905989a09a524211a88561640b", "patch": "@@ -46,62 +46,62 @@ public final class FilePermission extends Permission implements Serializable\n \n   private static final String CURRENT_DIRECTORY = \n     System.getProperty(\"user.dir\");\n+\n   private boolean readPerm = false;\n   private boolean writePerm = false;\n   private boolean executePerm = false;\n   private boolean deletePerm = false;\n   private final String actionsString;\n-  \n+\n   // Checks and caches the actions\n   private void checkPerms() throws IllegalArgumentException\n   {\n     String action;\n     int i = actionsString.indexOf(',');\n     int startI = 0;\n-    while(i != -1) \n+    while (i != -1) \n       {\n-        action = actionsString.substring(startI,i).trim().toLowerCase();\n-        if(action.equals(\"read\"))\n+        action = actionsString.substring(startI, i).trim().toLowerCase();\n+        if (action.equals(\"read\"))\n           readPerm = true;\n-        else if(action.equals(\"write\"))\n+        else if (action.equals(\"write\"))\n           writePerm = true;\n-        else if(action.equals(\"execute\"))\n+        else if (action.equals(\"execute\"))\n           executePerm = true;\n-        else if(action.equals(\"delete\"))\n+        else if (action.equals(\"delete\"))\n           deletePerm = true;\n \telse\n \t  throw new IllegalArgumentException(\"Unknown action: \" + action);\n       \n-        startI = i+1;\n-        i = actionsString.indexOf(',',startI);\n+        startI = i + 1;\n+        i = actionsString.indexOf(',', startI);\n       }\n-    \n+\n     action = actionsString.substring(startI).trim().toLowerCase();\n-    if(action.equals(\"read\"))\n+    if (action.equals(\"read\"))\n       readPerm = true;\n-    else if(action.equals(\"write\"))\n+    else if (action.equals(\"write\"))\n       writePerm = true;\n-    else if(action.equals(\"execute\"))\n+    else if (action.equals(\"execute\"))\n       executePerm = true;\n-    else if(action.equals(\"delete\"))\n+    else if (action.equals(\"delete\"))\n       deletePerm = true;\n     else\n       throw new IllegalArgumentException(\"Unknown action: \" + action);\n   }\n-  \n-  /*\n+\n+  /**\n    * Create a new FilePermission.\n    *\n    * @param pathExpression an expression specifying the paths this\n    *        permission represents.\n    * @param actionsString a comma-separated list of the actions this\n    *        permission represents. The actions must be \"read\", \"write\",\n    *        \"execute\" and/or \"delete\".\n-   *\n-   * FIXME: what to do when the file string is malformed?\n    */\n   public FilePermission(String pathExpression, String actionsString) \n   {\n+    // FIXME: what to do when the file string is malformed?\n     super(pathExpression);\n     if (pathExpression == null)\n       throw new NullPointerException(\"pathExpression\");\n@@ -111,195 +111,179 @@ public FilePermission(String pathExpression, String actionsString)\n     checkPerms();\n   }\n   \n-  /** Get the actions this FilePermission supports.\n-   ** @return the String representing the actions this FilePermission supports.\n-   **/\n+  /**\n+   * Get the actions this FilePermission supports.\n+   * @return the String representing the actions this FilePermission supports.\n+   */\n   public String getActions() \n   {\n     return actionsString;\n   }\n-  \n-  /** Get the hash code for this Object.<P>\n-   ** FilePermission's hash code is calculated as the exclusive or of the \n-   ** target\n-   ** String's hash code and the action String's hash code.\n-   ** @specnote Sun did not specify how to calculate the hash code; \n-   ** I made this up.\n-   ** @return the hash code for this Object.\n-   **/\n+\n+  /**\n+   * Get the hash code for this Object.<P>\n+   * FilePermission's hash code is calculated as the exclusive or of the \n+   * target\n+   * String's hash code and the action String's hash code.\n+   * @specnote Sun did not specify how to calculate the hash code; \n+   * I made this up.\n+   * @return the hash code for this Object.\n+   */\n   public int hashCode() \n   {\n     return getName().hashCode() ^ actionsString.hashCode();\n   }\n-  \n-  /** Check two FilePermissions for semantic equality.\n-   ** Two FilePermissions are exactly equivalent if they have identical path\n-   ** expressions and have exactly the same access permissions.\n-   ** @param o the Object to compare to.\n-   ** @return whether the Objects are semantically equivalent.\n-   **/\n+\n+  /**\n+   * Check two FilePermissions for semantic equality.\n+   * Two FilePermissions are exactly equivalent if they have identical path\n+   * expressions and have exactly the same access permissions.\n+   * @param o the Object to compare to.\n+   * @return whether the Objects are semantically equivalent.\n+   */\n   public boolean equals(Object o) \n   {\n-    if(!(o instanceof FilePermission))\n+    if (! (o instanceof FilePermission))\n       return false;\n-    FilePermission p = (FilePermission)o;\n-    \n+    FilePermission p = (FilePermission) o;\n+\n     String f1 = getName();\n     String f2 = p.getName();\n \n-    /* Compare names, taking into account if they refer to a\n-     * directory and one has a separator and the other does not.\n-     */\n-    if(f1.length() > 0 && f1.charAt(f1.length() - 1) == File.separatorChar) \n+    // Compare names, taking into account if they refer to a directory\n+    // and one has a separator and the other does not.\n+    if (f1.length() > 0 && f1.charAt(f1.length() - 1) == File.separatorChar) \n       {\n-        if(f2.length() > 0\n-\t   && f2.charAt(f2.length() - 1) == File.separatorChar) \n+        if (f2.length() > 0\n+\t    && f2.charAt(f2.length() - 1) == File.separatorChar) \n           {\n-\t    if(!f2.equals(f1))\n+\t    if (! f2.equals(f1))\n \t      return false;\n-          } \n-        else \n+          }\n+        else\n           {\n-\t    if(!f2.equals(f1.substring(0,f1.length()-1)))\n+\t    if (! f2.equals(f1.substring(0, f1.length() - 1)))\n \t      return false;\n           }\n-      } \n-    else \n+      }\n+    else\n       {\n-        if(f2.length() > 0\n-\t   && f2.charAt(f2.length() - 1) == File.separatorChar) \n+        if (f2.length() > 0\n+\t    && f2.charAt(f2.length() - 1) == File.separatorChar)\n           {\n-\t    if(!f1.equals(f2.substring(0,f2.length()-1)))\n+\t    if (! f1.equals(f2.substring(0, f2.length() - 1)))\n \t      return false;\n-          } \n-        else \n+          }\n+        else\n           {\n-\t    if(!f1.equals(f2))\n+\t    if (! f1.equals(f2))\n \t      return false;\n           }\n-       }\n-    return readPerm == p.readPerm && writePerm == p.writePerm && executePerm == p.executePerm && deletePerm == p.deletePerm;\n+      }\n+    return (readPerm == p.readPerm\n+\t    && writePerm == p.writePerm\n+\t    && executePerm == p.executePerm\n+\t    && deletePerm == p.deletePerm);\n   }\n-  \n-  /** Check to see if this permission implies another.\n-   ** Permission A implies permission B if these things are all true:\n-   ** <OL>\n-   ** <LI>A and B are both FilePermissions.</LI>\n-   ** <LI>All possible files in B are included in A \n-   ** (possibly more are in A).</LI>\n-   ** <LI>All actions B supports, A also supports.</LI>\n-   ** </OL>\n-   ** @param p the Permission to compare against.\n-   ** @return whether this Permission implies p\n-   **/\n+\n+  /**\n+   * Check to see if this permission implies another.\n+   * Permission A implies permission B if these things are all true:\n+   * <OL>\n+   * <LI>A and B are both FilePermissions.</LI>\n+   * <LI>All possible files in B are included in A \n+   * (possibly more are in A).</LI>\n+   * <LI>All actions B supports, A also supports.</LI>\n+   * </OL>\n+   * @param p the Permission to compare against.\n+   * @return whether this Permission implies p\n+   */\n   public boolean implies(Permission p) \n   {\n     FilePermission fp;\n-    \n-    if(!(p instanceof FilePermission))\n+\n+    if (! (p instanceof FilePermission))\n       return false;\n-    \n-    fp = (FilePermission)p;\n-    \n+\n+    fp = (FilePermission) p;\n+\n     String f1 = getName();\n     String f2 = fp.getName();\n-    \n-    if(f1.charAt(0) != File.separatorChar) \n-      {\n-        f1 = CURRENT_DIRECTORY + f1;\n-      }\n-    if(f2.charAt(0) != File.separatorChar) \n-      {\n-        f2 = CURRENT_DIRECTORY + f2;\n-      }\n-    \n+\n+    if (f1.charAt(0) != File.separatorChar)\n+      f1 = CURRENT_DIRECTORY + f1;\n+    if (f2.charAt(0) != File.separatorChar)\n+      f2 = CURRENT_DIRECTORY + f2;\n+\n     String sub1;\n-    \n-    switch(f1.charAt(f1.length() - 1)) \n+\n+    switch (f1.charAt(f1.length() - 1))\n       {\n-        case '*':\n-          sub1 = f1.substring(0,f1.length() - 1); // chop off \"*\"\n-          if(f2.length() <= sub1.length()) \n-            {\n-\t  /* If it's smaller, there is no way it could be part of this \n-           * directory.\n-\t   * If it's the same (or length - 1), it could be the same \n-           * directory but\n-\t   * specifies access to the directory rather than the files in it.\n-\t   */\n-\t      return false;\n-            } \n-          else if(f2.charAt(sub1.length() - 1) == File.separatorChar) \n-            {\n-\t      /* Make sure the part before the \"/\" is the same */\n-\t      if(!f2.substring(0,sub1.length()).equals(sub1))\n-\t        return false;\n-\t      /* Make sure there are no subdirectories specified \n-                 underneath this one */\n-\t      if(f2.substring(sub1.length()+1).indexOf(File.separatorChar) \n-                 != -1)\n-\t        return false;\n-            } \n-          else \n-            {\n-\t  /* Obviously not equal: f2 is either not a directory or is not\n-\t   * the same directory (its name continues further than we want)\n-\t   */\n-\t      return false;\n-            }\n-          break;\n-        case '-':\n-          sub1 = f1.substring(0,f1.length() - 2); // chop off \"/-\"\n-          if(f2.length() < sub1.length()) \n-            {\n-\t     /* If it's smaller, there is no way it could be part of \n-              * this directory. */\n+      case '*':\n+\tsub1 = f1.substring(0, f1.length() - 1); // chop off \"*\"\n+\tif (f2.length() <= sub1.length())\n+\t  {\n+\t    // If it's smaller, there is no way it could be part of\n+\t    // this directory.  If it's the same (or length - 1), it\n+\t    // could be the same directory but specifies access to\n+\t    // the directory rather than the files in it.\n+\t    return false;\n+\t  } \n+\telse if (f2.charAt(sub1.length() - 1) == File.separatorChar)\n+\t  {\n+\t    // Make sure the part before the \"/\" is the same.\n+\t    if (! f2.substring(0, sub1.length()).equals(sub1))\n \t      return false;\n-            } \n-          else if(f2.length() > sub1.length() && f2.charAt(sub1.length()) \n-             != File.separatorChar) \n-            {\n+\t    // Make sure there are no subdirectories specified\n+\t    // underneath this one.\n+\t    if (f2.substring(sub1.length() + 1).indexOf(File.separatorChar)\n+\t\t!= -1)\n \t      return false;\n-            \n-            } \n-          else if(!f2.substring(0,sub1.length()).equals(sub1))\n+\t  }\n+\telse\n+\t  {\n+\t    // Obviously not equal: f2 is either not a directory or\n+\t    // is not the same directory (its name continues further\n+\t    // than we want).\n+\t    return false;\n+\t  }\n+\tbreak;\n+      case '-':\n+\t// Chop off \"/-\".\n+\tsub1 = f1.substring(0, f1.length() - 2);\n+\tif (f2.length() < sub1.length())\n+\t  {\n+\t    // If it's smaller, there is no way it could be part of\n+\t    // this directory.\n \t    return false;\n-          break;\n-/* Looks redundant with default case and won't compile anyway - arenn\n-    case File.separatorChar:\n-      if(f2.charAt(f2.length()) == File.separatorChar) {\n-\tif(!f2.equals(f1))\n+\t  }\n+\telse if (f2.length() > sub1.length()\n+\t\t && f2.charAt(sub1.length()) != File.separatorChar)\n \t  return false;\n-      } else {\n-\tif(!f2.equals(f1.substring(0,f1.length()-1)))\n+\telse if (! f2.substring(0, sub1.length()).equals(sub1))\n \t  return false;\n+\tbreak;\n+\n+      default:\n+\tif (f2.charAt(f2.length() - 1) == File.separatorChar)\n+\t  {\n+\t    if (! f1.equals(f2.substring(0, f2.length() - 1)))\n+\t      return false;\n+\t  }\n+\telse if (!f1.equals(f2))\n+\t  return false;\n+\tbreak;\n       }\n-      break;\n-*/\n-        default:\n-          if(f2.charAt(f2.length() - 1) == File.separatorChar) \n-            {\n-              if(!f1.equals(f2.substring(0,f2.length() - 1)))\n-\t        return false;\n-            } \n-          else \n-            {\n-\t      if(!f1.equals(f2))\n-\t        return false;\n-            }\n-         break;\n-      }\n-    \n-    if(readPerm && !fp.readPerm)\n+\n+    if (readPerm && ! fp.readPerm)\n       return false;\n-    if(writePerm && !fp.writePerm)\n+    if (writePerm && ! fp.writePerm)\n       return false;\n-    if(executePerm && !fp.executePerm)\n+    if (executePerm && ! fp.executePerm)\n       return false;\n-    if(deletePerm && !fp.deletePerm)\n+    if (deletePerm && ! fp.deletePerm)\n       return false;\n     \n     return true;\n   }\n-} // class FilePermission\n-\n+}"}]}