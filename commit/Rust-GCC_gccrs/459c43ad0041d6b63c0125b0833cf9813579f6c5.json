{"sha": "459c43ad0041d6b63c0125b0833cf9813579f6c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU5YzQzYWQwMDQxZDZiNjNjMDEyNWIwODMzY2Y5ODEzNTc5ZjZjNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-12T06:43:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-12T06:43:27Z"}, "message": "mangle.c (NESTED_TEMPLATE_MATCH): Fix typo in comment.\n\n\t* mangle.c (NESTED_TEMPLATE_MATCH): Fix typo in comment.\n\t(is_std_substitution): Don't check CLASSTYPE_USE_TEMPLATE here.\n\t(find_substitution): Only use the `Sa' substitution for\n\tstd::allocator, not instantiations of it.\n\t(write_template_prefix): Move comment.  Only use a TREE_LIST to\n\trepresent substitutions for a member template.\n\t(write_array_type): Mangle array dimensions correctly.\n\t* optimize.c (maybe_clone_body): Copy more information from the\n\tcloned function.\n\t* pt.c (regenerate_decl_from_template): Preserve DECL_USE_TEMPLATE\n\ton the regenerated declaration.\n\nFrom-SVN: r34497", "tree": {"sha": "d26768333b2ecad582bc0cc90c3d58ab9160ef61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d26768333b2ecad582bc0cc90c3d58ab9160ef61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/459c43ad0041d6b63c0125b0833cf9813579f6c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/459c43ad0041d6b63c0125b0833cf9813579f6c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/459c43ad0041d6b63c0125b0833cf9813579f6c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/459c43ad0041d6b63c0125b0833cf9813579f6c5/comments", "author": null, "committer": null, "parents": [{"sha": "cbd3488bb9798167f4eeb8dd7ed693dcbf66d987", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd3488bb9798167f4eeb8dd7ed693dcbf66d987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbd3488bb9798167f4eeb8dd7ed693dcbf66d987"}], "stats": {"total": 116, "additions": 73, "deletions": 43}, "files": [{"sha": "f1ea463d2f0a6d404a931ace6086da4cd81e5585", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/459c43ad0041d6b63c0125b0833cf9813579f6c5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/459c43ad0041d6b63c0125b0833cf9813579f6c5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=459c43ad0041d6b63c0125b0833cf9813579f6c5", "patch": "@@ -1,3 +1,24 @@\n+2000-06-11  Mark Mitchell <mark@codesourcery.com>\n+\t\n+\t* mangle.c (NESTED_TEMPLATE_MATCH): Fix typo in comment.\n+\t(is_std_substitution): Don't check CLASSTYPE_USE_TEMPLATE here.\n+\t(find_substitution): Only use the `Sa' substitution for\n+\tstd::allocator, not instantiations of it.\n+\t(write_template_prefix): Move comment.  Only use a TREE_LIST to\n+\trepresent substitutions for a member template.\n+\t(write_array_type): Mangle array dimensions correctly.\n+\t* optimize.c (maybe_clone_body): Copy more information from the\n+\tcloned function.\n+\t* pt.c (regenerate_decl_from_template): Preserve DECL_USE_TEMPLATE\n+\ton the regenerated declaration.\n+\n+2000-06-11  Chip Salzenberg  <chip@valinux.com>\n+\t    Mark Mitchell <mark@codesourcery.com>\n+\n+\t* class.c (build_vtable): Clarify comment.\n+\t(build_ctor_vtbl_group): Pass the most derived type to\n+\tbuild_vtable.\n+\t\n 2000-06-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* decl2.c (compare_options): Don't needlessly cast away const-ness."}, {"sha": "c34deb0836da14087db8757963b2436197c905f9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/459c43ad0041d6b63c0125b0833cf9813579f6c5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/459c43ad0041d6b63c0125b0833cf9813579f6c5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=459c43ad0041d6b63c0125b0833cf9813579f6c5", "patch": "@@ -673,7 +673,6 @@ get_vfield_offset (binfo)\n    on method calling is expected to point to a DECL_CONTEXT (fndecl)\n    object, and not a baseclass of it.   */\n \n-\n static tree\n get_derived_offset (binfo, type)\n      tree binfo, type;\n@@ -695,9 +694,9 @@ get_derived_offset (binfo, type)\n   return size_binop (MINUS_EXPR, offset1, offset2);\n }\n \n-/* Create a VAR_DECL for a primary or secondary vtable for\n-   CLASS_TYPE.  Use NAME for the name of the vtable, and VTABLE_TYPE\n-   for its type.  */\n+/* Create a VAR_DECL for a primary or secondary vtable for CLASS_TYPE.\n+   (For a secondary vtable for B-in-D, CLASS_TYPE should be D, not B.)\n+   Use NAME for the name of the vtable, and VTABLE_TYPE for its type.  */\n \n static tree\n build_vtable (class_type, name, vtable_type)\n@@ -6781,7 +6780,7 @@ build_ctor_vtbl_group (binfo, t)\n   /* Build a version of VTBL (with the wrong type) for use in\n      constructing the addresses of secondary vtables in the\n      construction vtable group.  */\n-  vtbl = build_vtable (BINFO_TYPE (binfo), id, ptr_type_node);\n+  vtbl = build_vtable (t, id, ptr_type_node);\n   list = build_tree_list (vtbl, NULL_TREE);\n   accumulate_vtbl_inits (binfo, TYPE_BINFO (TREE_TYPE (binfo)),\n \t\t\t binfo, t, list);"}, {"sha": "57c49de00e52b7ada5b4118a1028eef895df70b4", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/459c43ad0041d6b63c0125b0833cf9813579f6c5/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/459c43ad0041d6b63c0125b0833cf9813579f6c5/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=459c43ad0041d6b63c0125b0833cf9813579f6c5", "patch": "@@ -208,8 +208,8 @@ static tree mangle_special_for_type PARAMS ((tree, const char *));\n #define mangled_position()                                              \\\n   obstack_object_size (&G.name_obstack)\n \n-/* Non-zero if NODE1__ and NODE2__ are both TREE_LIST nodes and have\n-   the same purpose (context, which may be a type) and value (template\n+/* Non-zero if NODE1 and NODE2 are both TREE_LIST nodes and have the\n+   same purpose (context, which may be a type) and value (template\n    decl).  See write_template_prefix for more information on what this\n    is used for.  */\n #define NESTED_TEMPLATE_MATCH(NODE1, NODE2)                         \\\n@@ -348,12 +348,11 @@ is_std_substitution (node, index)\n     /* These are not the droids you're looking for.  */\n     return 0;\n \n-  return \n-    DECL_NAMESPACE_STD_P (CP_DECL_CONTEXT (decl))\n-    && TYPE_LANG_SPECIFIC (type) \n-    && CLASSTYPE_USE_TEMPLATE (type)\n-    && (DECL_NAME (CLASSTYPE_TI_TEMPLATE (type)) \n-\t== subst_identifiers[index]);\n+  return (DECL_NAMESPACE_STD_P (CP_DECL_CONTEXT (decl))\n+\t  && TYPE_LANG_SPECIFIC (type) \n+\t  && CLASSTYPE_TEMPLATE_INFO (type)\n+\t  && (DECL_NAME (CLASSTYPE_TI_TEMPLATE (type)) \n+\t      == subst_identifiers[index]));\n }\n \n /* Helper function for find_substitution.  Returns non-zero if NODE,\n@@ -441,7 +440,9 @@ find_substitution (node)\n   type = TYPE_P (node) ? node : TREE_TYPE (node);\n \n   /* Check for std::allocator.  */\n-  if (decl && is_std_substitution (decl, SUBID_ALLOCATOR))\n+  if (decl \n+      && is_std_substitution (decl, SUBID_ALLOCATOR)\n+      && !CLASSTYPE_USE_TEMPLATE (TREE_TYPE (decl)))\n     {\n       write_string (\"Sa\");\n       return 1;\n@@ -782,32 +783,7 @@ write_prefix (node)\n }\n \n /* <template-prefix> ::= <prefix> <template component>\n-                     ::= <substitution>  \n-\n-   Names of templates are substitution candidates.  For a nested\n-   template, though, the template name for the innermost name must\n-   have all the outer template levels instantiated.  For instance,\n-   consider\n-\n-     template<typename T> struct Outer\n-     {\n-       template<typename U> struct Inner {};\n-     };\n-\n-   The template name for `Inner' in `Outer<int>::Inner<float>' is\n-   `Outer<int>::Inner<U>'.  In g++, we don't instantiate the template\n-   levels separately, so there's no TEMPLATE_DECL available for this\n-   (there's only `Outer<T>::Inner<U>').\n-\n-   In order to get the substitutions right, we create a special\n-   TREE_LIST to represent the substitution candidate for a nested\n-   template.  The TREE_PURPOSE is the tempate's context, fully\n-   instantiated, and the TREE_VALUE is the TEMPLATE_DECL for the inner\n-   template.  \n-\n-   So, for the example above, `Inner' is represented as a substitution\n-   candidate by a TREE_LIST whose purpose is `Outer<int>' and whose\n-   value is `Outer<T>::Inner<U>'.  */\n+                     ::= <substitution>  */\n \n static void\n write_template_prefix (node)\n@@ -830,8 +806,32 @@ write_template_prefix (node)\n     /* Oops, not a template.  */\n     my_friendly_abort (20000524);\n \n-  /* Build the substitution candidate TREE_LIST.  */\n-  substitution = build_tree_list (context, template);\n+  /* For a member template, though, the template name for the\n+     innermost name must have all the outer template levels\n+     instantiated.  For instance, consider\n+\n+       template<typename T> struct Outer {\n+\t template<typename U> struct Inner {};\n+       };\n+\n+     The template name for `Inner' in `Outer<int>::Inner<float>' is\n+     `Outer<int>::Inner<U>'.  In g++, we don't instantiate the template\n+     levels separately, so there's no TEMPLATE_DECL available for this\n+     (there's only `Outer<T>::Inner<U>').\n+\n+     In order to get the substitutions right, we create a special\n+     TREE_LIST to represent the substitution candidate for a nested\n+     template.  The TREE_PURPOSE is the template's context, fully\n+     instantiated, and the TREE_VALUE is the TEMPLATE_DECL for the inner\n+     template.\n+\n+     So, for the example above, `Outer<int>::Inner' is represented as a\n+     substitution candidate by a TREE_LIST whose purpose is `Outer<int>'\n+     and whose value is `Outer<T>::Inner<U>'.  */\n+  if (TYPE_P (context))\n+    substitution = build_tree_list (context, template);\n+  else\n+    substitution = template;\n \n   if (find_substitution (substitution))\n     return;\n@@ -1768,7 +1768,12 @@ write_array_type (type)\n \t array.  */\n       max = TYPE_MAX_VALUE (index_type);\n       if (TREE_CODE (max) == INTEGER_CST)\n-\twrite_unsigned_number (tree_low_cst (max, 1));\n+\t{\n+\t  /* The ABI specifies that we should mangle the number of\n+\t     elements in the array, not the largest allowed index.  */\n+\t  max = size_binop (PLUS_EXPR, max, size_one_node);\n+\t  write_unsigned_number (tree_low_cst (max, 1));\n+\t}\n       else\n \twrite_expression (TREE_OPERAND (max, 0));\n     }"}, {"sha": "fa8d9e821a0823fead21e02211e512671722ebe4", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/459c43ad0041d6b63c0125b0833cf9813579f6c5/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/459c43ad0041d6b63c0125b0833cf9813579f6c5/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=459c43ad0041d6b63c0125b0833cf9813579f6c5", "patch": "@@ -911,6 +911,10 @@ maybe_clone_body (fn)\n       DECL_WEAK (clone) = DECL_WEAK (fn);\n       DECL_ONE_ONLY (clone) = DECL_ONE_ONLY (fn);\n       DECL_SECTION_NAME (clone) = DECL_SECTION_NAME (fn);\n+      DECL_USE_TEMPLATE (clone) = DECL_USE_TEMPLATE (fn);\n+      DECL_EXTERNAL (clone) = DECL_EXTERNAL (fn);\n+      DECL_INTERFACE_KNOWN (clone) = DECL_INTERFACE_KNOWN (fn);\n+      DECL_NOT_REALLY_EXTERN (clone) = DECL_NOT_REALLY_EXTERN (fn);\n \n       /* Start processing the function.  */\n       push_to_top_level ();"}, {"sha": "cd584c28cae200c04d7536bb55e9e4b960ac7364", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/459c43ad0041d6b63c0125b0833cf9813579f6c5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/459c43ad0041d6b63c0125b0833cf9813579f6c5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=459c43ad0041d6b63c0125b0833cf9813579f6c5", "patch": "@@ -9469,6 +9469,7 @@ regenerate_decl_from_template (decl, tmpl)\n   DECL_TI_TEMPLATE (new_decl) = DECL_TI_TEMPLATE (decl);\n   DECL_ASSEMBLER_NAME (new_decl) = DECL_ASSEMBLER_NAME (decl);\n   DECL_RTL (new_decl) = DECL_RTL (decl);\n+  DECL_USE_TEMPLATE (new_decl) = DECL_USE_TEMPLATE (decl);\n \n   /* Call duplicate decls to merge the old and new declarations.  */\n   duplicate_decls (new_decl, decl);"}]}