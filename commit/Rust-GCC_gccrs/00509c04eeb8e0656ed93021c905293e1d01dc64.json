{"sha": "00509c04eeb8e0656ed93021c905293e1d01dc64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA1MDljMDRlZWI4ZTA2NTZlZDkzMDIxYzkwNTI5M2UxZDAxZGM2NA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2006-12-08T14:07:53Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2006-12-08T14:07:53Z"}, "message": "New TER code.\n\n2006-12-08  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* Makefile.in: Add new file tree-ssa-ter.c.\n\t* tree-outof-ssa.c (struct temp_expr_table_d, new_temp_expr_table, \n\tfree_temp_expr_table, add_value_to_version_list, \n\tadd_value_to_partition_list, remove_value_from_partition_list, \n\tadd_dependence, check_replaceable, finish_expr, mark_replaceable, \n\tkill_expr, kill_virtual_exprs, find_replaceable_in_bb, \n\tfind_replaceable_exprs, dump_replaceable_exprs): Move to tree-ssa-ter.c.\n\t* tree-ssa-live.h (find_replaceable_exprs, dump_replaceable_exprs): Add\n\tprototypes.\n\t* tree-ssa-ter.c: New file using code moved from tree-outof-ssa.c.\n\t(struct value_expr_d): Remove.\n\t(struct temp_expr_table_d): Rename fields, add explicit vector of\n\treplaceable expressions instead of sharing. Change value_expr_p's to \n\tbitmap.  Delete free_list.\n\t(new_temp_expr_table): Rename fields, count number of ssa_names in\n\teach partition.\n\t(free_temp_expr_table): Rename field, free new fields.\n\t(new_value_expr, free_value_expr, find_value_in_list, add_value_to_list,\n\tadd_info_to_list, remove_value_from_list): Delete.\n\t(version_to_be_replaced_p): New. Is an ssa-name replaceable?\n\t(make_dependent_on_partition): New. Set bit in version list, allocating\n\ta bitmap if need be.\n\t(add_to_partition_kill_list): New.  Set bit in the partition list,\n\tallocating a bitmap if need be.\n\t(remove_from_partition_kill_list): New.  Remove a bit from the\n\tpartition list, free the bitmap if it is empty.\n\t(add_dependence): Use renamed field, cleanup. Don't add a dependence\n\ton partitions with only one member.\n\t(is_replaceable_p): New.  Split out replaceability check from \n\tcheck_replaceable.\n\t(process_replaceable): New. Replacement code split from \n\tcheck_replaceable.\n\t(check_replaceable): Removed.\n\t(finished_with_expr): Renamed from finish_expr.\n\t(kill_expr): Use renamed fields. Less parameters.\n\t(kill_virtual_exprs): Less parameters.\n\t(mark_replaceable): Use renamed fields.\n\t(find_replaceable_in_bb): Use renamed fields, cleanup.\n\t(find_replaceable_exprs): Use renamed routines, cleanup.\n\t(dump_replaceable_exprs): don;t go past end of ssa_names list.\n\t(debug_ter): New.  Debug routine to dump state.\n\nFrom-SVN: r119657", "tree": {"sha": "d4de61798fb6a40c4303da719507d3d7a1e2c7f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4de61798fb6a40c4303da719507d3d7a1e2c7f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00509c04eeb8e0656ed93021c905293e1d01dc64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00509c04eeb8e0656ed93021c905293e1d01dc64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00509c04eeb8e0656ed93021c905293e1d01dc64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00509c04eeb8e0656ed93021c905293e1d01dc64/comments", "author": null, "committer": null, "parents": [{"sha": "5848e34ae42f32df64511f0bf710a2aeac91f8d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5848e34ae42f32df64511f0bf710a2aeac91f8d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5848e34ae42f32df64511f0bf710a2aeac91f8d3"}], "stats": {"total": 1406, "additions": 801, "deletions": 605}, "files": [{"sha": "dbd4e8aec3c80f65ed759ebb039ce6f04beacd0c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00509c04eeb8e0656ed93021c905293e1d01dc64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00509c04eeb8e0656ed93021c905293e1d01dc64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00509c04eeb8e0656ed93021c905293e1d01dc64", "patch": "@@ -1,3 +1,46 @@\n+2006-12-08  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* Makefile.in: Add new file tree-ssa-ter.c.\n+\t* tree-outof-ssa.c (struct temp_expr_table_d, new_temp_expr_table, \n+\tfree_temp_expr_table, add_value_to_version_list, \n+\tadd_value_to_partition_list, remove_value_from_partition_list, \n+\tadd_dependence, check_replaceable, finish_expr, mark_replaceable, \n+\tkill_expr, kill_virtual_exprs, find_replaceable_in_bb, \n+\tfind_replaceable_exprs, dump_replaceable_exprs): Move to tree-ssa-ter.c.\n+\t* tree-ssa-live.h (find_replaceable_exprs, dump_replaceable_exprs): Add\n+\tprototypes.\n+\t* tree-ssa-ter.c: New file using code moved from tree-outof-ssa.c.\n+\t(struct value_expr_d): Remove.\n+\t(struct temp_expr_table_d): Rename fields, add explicit vector of\n+\treplaceable expressions instead of sharing.  Change value_expr_p's to \n+\tbitmap.  Delete free_list.\n+\t(new_temp_expr_table): Rename fields, count number of ssa_names in\n+\teach partition.\n+\t(free_temp_expr_table): Rename field, free new fields.\n+\t(new_value_expr, free_value_expr, find_value_in_list, add_value_to_list,\n+\tadd_info_to_list, remove_value_from_list): Delete.\n+\t(version_to_be_replaced_p): New.  Is an ssa-name replaceable?\n+\t(make_dependent_on_partition): New.  Set bit in version list, allocating\n+\ta bitmap if need be.\n+\t(add_to_partition_kill_list): New.  Set bit in the partition list,\n+\tallocating a bitmap if need be.\n+\t(remove_from_partition_kill_list): New.  Remove a bit from the\n+\tpartition list, free the bitmap if it is empty.\n+\t(add_dependence): Use renamed field, cleanup.  Don't add a dependence\n+\ton partitions with only one member.\n+\t(is_replaceable_p): New.  Split out replaceability check from \n+\tcheck_replaceable.\n+\t(process_replaceable): New.  Code split from check_replaceable.\n+\t(check_replaceable): Removed.\n+\t(finished_with_expr): Renamed from finish_expr.\n+\t(kill_expr): Use renamed fields and less parameters.\n+\t(kill_virtual_exprs): Less parameters.\n+\t(mark_replaceable): Use renamed fields.\n+\t(find_replaceable_in_bb): Use renamed fields, cleanup.\n+\t(find_replaceable_exprs): Use renamed routines, cleanup.\n+\t(dump_replaceable_exprs): Don't go past end of ssa_names list.\n+\t(debug_ter): New.  Debug routine to dump state.\n+\n 2006-12-08  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.c (effective_address_32bit_p): Return true for"}, {"sha": "bf954ebab886a5be69c0f6de84a43b3882cd5b36", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00509c04eeb8e0656ed93021c905293e1d01dc64/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00509c04eeb8e0656ed93021c905293e1d01dc64/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=00509c04eeb8e0656ed93021c905293e1d01dc64", "patch": "@@ -975,7 +975,7 @@ C_OBJS = c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)\n OBJS-common = \\\n  double-int.o tree-chrec.o tree-scalar-evolution.o tree-data-ref.o\t   \\\n  tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-gimple.o  \\\n- gimplify.o tree-pretty-print.o tree-into-ssa.o\t\t\t\t   \\\n+ gimplify.o tree-pretty-print.o tree-into-ssa.o tree-ssa-ter.o\t\t   \\\n  tree-outof-ssa.o tree-ssa-ccp.o tree-vn.o tree-ssa-uncprop.o\t\t   \\\n  tree-ssa-dce.o  tree-ssa-copy.o tree-nrv.o tree-ssa-copyrename.o\t   \\\n  tree-ssa-pre.o tree-ssa-live.o tree-ssa-operands.o tree-ssa-alias.o       \\\n@@ -1850,6 +1850,12 @@ tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    langhooks.h domwalk.h tree-pass.h $(GGC_H) $(PARAMS_H) $(BASIC_BLOCK_H) \\\n    bitmap.h $(CFGLOOP_H) $(FLAGS_H) hard-reg-set.h $(HASHTAB_H) \\\n    $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) vecprim.h\n+tree-ssa-ter.o : tree-ssa-ter.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n+   $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   langhooks.h tree-pass.h $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) bitmap.h \\\n+   $(FLAGS_H) $(GGC_H) hard-reg-set.h $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n+   $(TREE_INLINE_H) $(VARRAY_H) toplev.h vecprim.h\n tree-outof-ssa.o : tree-outof-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n    $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\"}, {"sha": "5edea642805bc7007834a8aad1a7fcaecf0a9ce2", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 0, "deletions": 604, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00509c04eeb8e0656ed93021c905293e1d01dc64/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00509c04eeb8e0656ed93021c905293e1d01dc64/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=00509c04eeb8e0656ed93021c905293e1d01dc64", "patch": "@@ -1121,610 +1121,6 @@ eliminate_virtual_phis (void)\n }\n \n \n-/* Temporary Expression Replacement (TER)\n-\n-   Replace SSA version variables during out-of-ssa with their defining\n-   expression if there is only one use of the variable.\n-\n-   A pass is made through the function, one block at a time.  No cross block\n-   information is tracked.\n-\n-   Variables which only have one use, and whose defining stmt is considered\n-   a replaceable expression (see check_replaceable) are entered into \n-   consideration by adding a list of dependent partitions to the version_info\n-   vector for that ssa_name_version.  This information comes from the partition\n-   mapping for each USE.  At the same time, the partition_dep_list vector for \n-   these partitions have this version number entered into their lists.\n-\n-   When the use of a replaceable ssa_variable is encountered, the dependence\n-   list in version_info[] is moved to the \"pending_dependence\" list in case\n-   the current expression is also replaceable. (To be determined later in \n-   processing this stmt.) version_info[] for the version is then updated to \n-   point to the defining stmt and the 'replaceable' bit is set.\n-\n-   Any partition which is defined by a statement 'kills' any expression which\n-   is dependent on this partition.  Every ssa version in the partitions' \n-   dependence list is removed from future consideration.\n-\n-   All virtual references are lumped together.  Any expression which is\n-   dependent on any virtual variable (via a VUSE) has a dependence added\n-   to the special partition defined by VIRTUAL_PARTITION.\n-\n-   Whenever a V_MAY_DEF is seen, all expressions dependent this \n-   VIRTUAL_PARTITION are removed from consideration.\n-\n-   At the end of a basic block, all expression are removed from consideration\n-   in preparation for the next block.  \n-   \n-   The end result is a vector over SSA_NAME_VERSION which is passed back to\n-   rewrite_out_of_ssa.  As the SSA variables are being rewritten, instead of\n-   replacing the SSA_NAME tree element with the partition it was assigned, \n-   it is replaced with the RHS of the defining expression.  */\n-\n-\n-/* Dependency list element.  This can contain either a partition index or a\n-   version number, depending on which list it is in.  */\n-\n-typedef struct value_expr_d \n-{\n-  int value;\n-  struct value_expr_d *next;\n-} *value_expr_p;\n-\n-\n-/* Temporary Expression Replacement (TER) table information.  */\n-\n-typedef struct temp_expr_table_d \n-{\n-  var_map map;\n-  void **version_info;\n-  bitmap *expr_vars;\n-  value_expr_p *partition_dep_list;\n-  bitmap replaceable;\n-  bool saw_replaceable;\n-  int virtual_partition;\n-  bitmap partition_in_use;\n-  value_expr_p free_list;\n-  value_expr_p pending_dependence;\n-} *temp_expr_table_p;\n-\n-/* Used to indicate a dependency on V_MAY_DEFs.  */\n-#define VIRTUAL_PARTITION(table)\t(table->virtual_partition)\n-\n-static temp_expr_table_p new_temp_expr_table (var_map);\n-static tree *free_temp_expr_table (temp_expr_table_p);\n-static inline value_expr_p new_value_expr (temp_expr_table_p);\n-static inline void free_value_expr (temp_expr_table_p, value_expr_p);\n-static inline value_expr_p find_value_in_list (value_expr_p, int, \n-\t\t\t\t\t       value_expr_p *);\n-static inline void add_value_to_list (temp_expr_table_p, value_expr_p *, int);\n-static inline void add_info_to_list (temp_expr_table_p, value_expr_p *, \n-\t\t\t\t     value_expr_p);\n-static value_expr_p remove_value_from_list (value_expr_p *, int);\n-static void add_dependence (temp_expr_table_p, int, tree);\n-static bool check_replaceable (temp_expr_table_p, tree);\n-static void finish_expr (temp_expr_table_p, int, bool);\n-static void mark_replaceable (temp_expr_table_p, tree);\n-static inline void kill_expr (temp_expr_table_p, int, bool);\n-static inline void kill_virtual_exprs (temp_expr_table_p, bool);\n-static void find_replaceable_in_bb (temp_expr_table_p, basic_block);\n-static tree *find_replaceable_exprs (var_map);\n-static void dump_replaceable_exprs (FILE *, tree *);\n-\n-\n-/* Create a new TER table for MAP.  */\n-\n-static temp_expr_table_p\n-new_temp_expr_table (var_map map)\n-{\n-  temp_expr_table_p t;\n-\n-  t = XNEW (struct temp_expr_table_d);\n-  t->map = map;\n-\n-  t->version_info = XCNEWVEC (void *, num_ssa_names + 1);\n-  t->expr_vars = XCNEWVEC (bitmap, num_ssa_names + 1);\n-  t->partition_dep_list = XCNEWVEC (value_expr_p,\n-                                    num_var_partitions (map) + 1);\n-\n-  t->replaceable = BITMAP_ALLOC (NULL);\n-  t->partition_in_use = BITMAP_ALLOC (NULL);\n-\n-  t->saw_replaceable = false;\n-  t->virtual_partition = num_var_partitions (map);\n-  t->free_list = NULL;\n-  t->pending_dependence = NULL;\n-\n-  return t;\n-}\n-\n-\n-/* Free TER table T.  If there are valid replacements, return the expression \n-   vector.  */\n-\n-static tree *\n-free_temp_expr_table (temp_expr_table_p t)\n-{\n-  value_expr_p p;\n-  tree *ret = NULL;\n-  unsigned i;\n-\n-#ifdef ENABLE_CHECKING\n-  unsigned x;\n-  for (x = 0; x <= num_var_partitions (t->map); x++)\n-    gcc_assert (!t->partition_dep_list[x]);\n-#endif\n-\n-  while ((p = t->free_list))\n-    {\n-      t->free_list = p->next;\n-      free (p);\n-    }\n-\n-  BITMAP_FREE (t->partition_in_use);\n-  BITMAP_FREE (t->replaceable);\n-\n-  for (i = 0; i <= num_ssa_names; i++)\n-    if (t->expr_vars[i])\n-      BITMAP_FREE (t->expr_vars[i]);\n-  free (t->expr_vars);\n-\n-  free (t->partition_dep_list);\n-  if (t->saw_replaceable)\n-    ret = (tree *)t->version_info;\n-  else\n-    free (t->version_info);\n-  \n-  free (t);\n-  return ret;\n-}\n-\n-\n-/* Allocate a new value list node. Take it from the free list in TABLE if \n-   possible.  */\n-\n-static inline value_expr_p\n-new_value_expr (temp_expr_table_p table)\n-{\n-  value_expr_p p;\n-  if (table->free_list)\n-    {\n-      p = table->free_list;\n-      table->free_list = p->next;\n-    }\n-  else\n-    p = (value_expr_p) xmalloc (sizeof (struct value_expr_d));\n-\n-  return p;\n-}\n-\n-\n-/* Add value list node P to the free list in TABLE.  */\n-\n-static inline void\n-free_value_expr (temp_expr_table_p table, value_expr_p p)\n-{\n-  p->next = table->free_list;\n-  table->free_list = p;\n-}\n-\n-\n-/* Find VALUE if it's in LIST.  Return a pointer to the list object if found,  \n-   else return NULL.  If LAST_PTR is provided, it will point to the previous \n-   item upon return, or NULL if this is the first item in the list.  */\n-\n-static inline value_expr_p\n-find_value_in_list (value_expr_p list, int value, value_expr_p *last_ptr)\n-{\n-  value_expr_p curr;\n-  value_expr_p last = NULL;\n-\n-  for (curr = list; curr; last = curr, curr = curr->next)\n-    {\n-      if (curr->value == value)\n-        break;\n-    }\n-  if (last_ptr)\n-    *last_ptr = last;\n-  return curr;\n-}\n-\n-\n-/* Add VALUE to LIST, if it isn't already present.  TAB is the expression \n-   table */\n-\n-static inline void\n-add_value_to_list (temp_expr_table_p tab, value_expr_p *list, int value)\n-{\n-  value_expr_p info;\n-\n-  if (!find_value_in_list (*list, value, NULL))\n-    {\n-      info = new_value_expr (tab);\n-      info->value = value;\n-      info->next = *list;\n-      *list = info;\n-    }\n-}\n-\n-\n-/* Add value node INFO if it's value isn't already in LIST.  Free INFO if\n-   it is already in the list. TAB is the expression table.  */\n-\n-static inline void\n-add_info_to_list (temp_expr_table_p tab, value_expr_p *list, value_expr_p info)\n-{\n-  if (find_value_in_list (*list, info->value, NULL))\n-    free_value_expr (tab, info);\n-  else\n-    {\n-      info->next = *list;\n-      *list = info;\n-    }\n-}\n-\n-\n-/* Look for VALUE in LIST.  If found, remove it from the list and return it's \n-   pointer.  */\n-\n-static value_expr_p\n-remove_value_from_list (value_expr_p *list, int value)\n-{\n-  value_expr_p info, last;\n-\n-  info = find_value_in_list (*list, value, &last);\n-  if (!info)\n-    return NULL;\n-  if (!last)\n-    *list = info->next;\n-  else\n-    last->next = info->next;\n- \n-  return info;\n-}\n-\n-\n-/* Add a dependency between the def of ssa VERSION and VAR.  If VAR is \n-   replaceable by an expression, add a dependence each of the elements of the \n-   expression.  These are contained in the pending list.  TAB is the\n-   expression table.  */\n-\n-static void\n-add_dependence (temp_expr_table_p tab, int version, tree var)\n-{\n-  int i, x;\n-  value_expr_p info;\n-\n-  i = SSA_NAME_VERSION (var);\n-  if (bitmap_bit_p (tab->replaceable, i))\n-    {\n-      /* This variable is being substituted, so use whatever dependences\n-         were queued up when we marked this as replaceable earlier.  */\n-      while ((info = tab->pending_dependence))\n-        {\n-\t  tab->pending_dependence = info->next;\n-\t  /* Get the partition this variable was dependent on. Reuse this\n-\t     object to represent the current  expression instead.  */\n-\t  x = info->value;\n-\t  info->value = version;\n-\t  add_info_to_list (tab, &(tab->partition_dep_list[x]), info);\n-          add_value_to_list (tab, \n-\t\t\t     (value_expr_p *)&(tab->version_info[version]), x);\n-\t  bitmap_set_bit (tab->partition_in_use, x);\n-\t}\n-    }\n-  else\n-    {\n-      i = var_to_partition (tab->map, var);\n-      gcc_assert (i != NO_PARTITION);\n-      add_value_to_list (tab, &(tab->partition_dep_list[i]), version);\n-      add_value_to_list (tab, \n-\t\t\t (value_expr_p *)&(tab->version_info[version]), i);\n-      bitmap_set_bit (tab->partition_in_use, i);\n-    }\n-}\n-\n-\n-/* Check if expression STMT is suitable for replacement in table TAB.  If so, \n-   create an expression entry.  Return true if this stmt is replaceable.  */\n-\n-static bool\n-check_replaceable (temp_expr_table_p tab, tree stmt)\n-{\n-  tree var, def, basevar;\n-  int version;\n-  ssa_op_iter iter;\n-  tree call_expr;\n-  bitmap def_vars, use_vars;\n-\n-  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n-    return false;\n-  \n-  /* Punt if there is more than 1 def, or more than 1 use.  */\n-  def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n-  if (!def)\n-    return false;\n-\n-  if (num_imm_uses (def) != 1)\n-    return false;\n-\n-  /* There must be no V_MAY_DEFS or V_MUST_DEFS.  */\n-  if (!(ZERO_SSA_OPERANDS (stmt, (SSA_OP_VMAYDEF | SSA_OP_VMUSTDEF))))\n-    return false;\n-\n-  /* Float expressions must go through memory if float-store is on.  */\n-  if (flag_float_store && FLOAT_TYPE_P (TREE_TYPE\n-\t\t\t\t\t(GENERIC_TREE_OPERAND (stmt, 1))))\n-    return false;\n-\n-  /* Calls to functions with side-effects cannot be replaced.  */\n-  if ((call_expr = get_call_expr_in (stmt)) != NULL_TREE)\n-    {\n-      int call_flags = call_expr_flags (call_expr);\n-      if (TREE_SIDE_EFFECTS (call_expr)\n-\t  && !(call_flags & (ECF_PURE | ECF_CONST | ECF_NORETURN)))\n-\treturn false;\n-    }\n-\n-  version = SSA_NAME_VERSION (def);\n-  basevar = SSA_NAME_VAR (def);\n-  def_vars = BITMAP_ALLOC (NULL);\n-  bitmap_set_bit (def_vars, DECL_UID (basevar));\n-\n-  /* Add this expression to the dependency list for each use partition.  */\n-  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)\n-    {\n-      add_dependence (tab, version, var);\n-\n-      use_vars = tab->expr_vars[SSA_NAME_VERSION (var)];\n-      if (use_vars)\n-\tbitmap_ior_into (def_vars, use_vars);\n-    }\n-  tab->expr_vars[version] = def_vars;\n-\n-  /* If there are VUSES, add a dependence on virtual defs.  */\n-  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VUSE))\n-    {\n-      add_value_to_list (tab, (value_expr_p *)&(tab->version_info[version]), \n-\t\t\t VIRTUAL_PARTITION (tab));\n-      add_value_to_list (tab, \n-\t\t\t &(tab->partition_dep_list[VIRTUAL_PARTITION (tab)]), \n-\t\t\t version);\n-      bitmap_set_bit (tab->partition_in_use, VIRTUAL_PARTITION (tab));\n-    }\n-\n-  return true;\n-}\n-\n-\n-/* This function will remove the expression for VERSION from replacement \n-   consideration.n table TAB  If 'replace' is true, it is marked as \n-   replaceable, otherwise not.  */\n-\n-static void\n-finish_expr (temp_expr_table_p tab, int version, bool replace)\n-{\n-  value_expr_p info, tmp;\n-  int partition;\n-\n-  /* Remove this expression from its dependent lists.  The partition dependence\n-     list is retained and transfered later to whomever uses this version.  */\n-  for (info = (value_expr_p) tab->version_info[version]; info; info = tmp)\n-    {\n-      partition = info->value;\n-      gcc_assert (tab->partition_dep_list[partition]);\n-      tmp = remove_value_from_list (&(tab->partition_dep_list[partition]), \n-\t\t\t\t    version);\n-      gcc_assert (tmp);\n-      free_value_expr (tab, tmp);\n-      /* Only clear the bit when the dependency list is emptied via \n-         a replacement. Otherwise kill_expr will take care of it.  */\n-      if (!(tab->partition_dep_list[partition]) && replace)\n-        bitmap_clear_bit (tab->partition_in_use, partition);\n-      tmp = info->next;\n-      if (!replace)\n-        free_value_expr (tab, info);\n-    }\n-\n-  if (replace)\n-    {\n-      tab->saw_replaceable = true;\n-      bitmap_set_bit (tab->replaceable, version);\n-    }\n-  else\n-    {\n-      gcc_assert (!bitmap_bit_p (tab->replaceable, version));\n-      tab->version_info[version] = NULL;\n-    }\n-}\n-\n-\n-/* Mark the expression associated with VAR as replaceable, and enter\n-   the defining stmt into the version_info table TAB.  */\n-\n-static void\n-mark_replaceable (temp_expr_table_p tab, tree var)\n-{\n-  value_expr_p info;\n-  int version = SSA_NAME_VERSION (var);\n-  finish_expr (tab, version, true);\n-\n-  /* Move the dependence list to the pending list.  */\n-  if (tab->version_info[version])\n-    {\n-      info = (value_expr_p) tab->version_info[version]; \n-      for ( ; info->next; info = info->next)\n-\tcontinue;\n-      info->next = tab->pending_dependence;\n-      tab->pending_dependence = (value_expr_p)tab->version_info[version];\n-    }\n-\n-  tab->version_info[version] = SSA_NAME_DEF_STMT (var);\n-}\n-\n-\n-/* This function marks any expression in TAB which is dependent on PARTITION\n-   as NOT replaceable.  CLEAR_BIT is used to determine whether partition_in_use\n-   should have its bit cleared.  Since this routine can be called within an\n-   EXECUTE_IF_SET_IN_BITMAP, the bit can't always be cleared.  */\n-\n-static inline void\n-kill_expr (temp_expr_table_p tab, int partition, bool clear_bit)\n-{\n-  value_expr_p ptr;\n-\n-  /* Mark every active expr dependent on this var as not replaceable.  */\n-  while ((ptr = tab->partition_dep_list[partition]) != NULL)\n-    finish_expr (tab, ptr->value, false);\n-\n-  if (clear_bit)\n-    bitmap_clear_bit (tab->partition_in_use, partition);\n-}\n-\n-\n-/* This function kills all expressions in TAB which are dependent on virtual \n-   DEFs.  CLEAR_BIT determines whether partition_in_use gets cleared.  */\n-\n-static inline void\n-kill_virtual_exprs (temp_expr_table_p tab, bool clear_bit)\n-{\n-  kill_expr (tab, VIRTUAL_PARTITION (tab), clear_bit);\n-}\n-\n-\n-/* This function processes basic block BB, and looks for variables which can\n-   be replaced by their expressions.  Results are stored in TAB.  */\n-\n-static void\n-find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n-{\n-  block_stmt_iterator bsi;\n-  tree stmt, def, use;\n-  stmt_ann_t ann;\n-  int partition;\n-  var_map map = tab->map;\n-  value_expr_p p;\n-  ssa_op_iter iter;\n-\n-  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-    {\n-      stmt = bsi_stmt (bsi);\n-      ann = stmt_ann (stmt);\n-\n-      /* Determine if this stmt finishes an existing expression.  */\n-      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n-\t{\n-\t  unsigned ver = SSA_NAME_VERSION (use);\n-\n-\t  if (tab->version_info[ver])\n-\t    {\n-\t      bool same_root_var = false;\n-\t      ssa_op_iter iter2;\n-\t      bitmap vars = tab->expr_vars[ver];\n-\n-\t      /* See if the root variables are the same.  If they are, we\n-\t\t do not want to do the replacement to avoid problems with\n-\t\t code size, see PR tree-optimization/17549.  */\n-\t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter2, SSA_OP_DEF)\n-\t\t{\n-\t\t  if (bitmap_bit_p (vars, DECL_UID (SSA_NAME_VAR (def))))\n-\t\t    {\n-\t\t      same_root_var = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\n-\t      /* Mark expression as replaceable unless stmt is volatile\n-\t\t or DEF sets the same root variable as STMT.  */\n-\t      if (!ann->has_volatile_ops && !same_root_var)\n-\t\tmark_replaceable (tab, use);\n-\t      else\n-\t\tfinish_expr (tab, ver, false);\n-\t    }\n-\t}\n-      \n-      /* Next, see if this stmt kills off an active expression.  */\n-      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n-\t{\n-\t  partition = var_to_partition (map, def);\n-\t  if (partition != NO_PARTITION && tab->partition_dep_list[partition])\n-\t    kill_expr (tab, partition, true);\n-\t}\n-\n-      /* Now see if we are creating a new expression or not.  */\n-      if (!ann->has_volatile_ops)\n-\tcheck_replaceable (tab, stmt);\n-\n-      /* Free any unused dependency lists.  */\n-      while ((p = tab->pending_dependence))\n-\t{\n-\t  tab->pending_dependence = p->next;\n-\t  free_value_expr (tab, p);\n-\t}\n-\n-      /* A V_{MAY,MUST}_DEF kills any expression using a virtual operand.  */\n-      if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n-        kill_virtual_exprs (tab, true);\n-    }\n-}\n-\n-\n-/* This function is the driver routine for replacement of temporary expressions\n-   in the SSA->normal phase, operating on MAP.  If there are replaceable \n-   expressions, a table is returned which maps SSA versions to the \n-   expressions they should be replaced with.  A NULL_TREE indicates no \n-   replacement should take place.  If there are no replacements at all, \n-   NULL is returned by the function, otherwise an expression vector indexed\n-   by SSA_NAME version numbers.  */\n-\n-static tree *\n-find_replaceable_exprs (var_map map)\n-{\n-  basic_block bb;\n-  unsigned i;\n-  temp_expr_table_p table;\n-  tree *ret;\n-\n-  table = new_temp_expr_table (map);\n-  FOR_EACH_BB (bb)\n-    {\n-      bitmap_iterator bi;\n-\n-      find_replaceable_in_bb (table, bb);\n-      EXECUTE_IF_SET_IN_BITMAP ((table->partition_in_use), 0, i, bi)\n-        {\n-\t  kill_expr (table, i, false);\n-\t}\n-    }\n-\n-  ret = free_temp_expr_table (table);\n-  return ret;\n-}\n-\n-\n-/* Dump TER expression table EXPR to file F.  */\n-\n-static void\n-dump_replaceable_exprs (FILE *f, tree *expr)\n-{\n-  tree stmt, var;\n-  int x;\n-  fprintf (f, \"\\nReplacing Expressions\\n\");\n-  for (x = 0; x < (int)num_ssa_names + 1; x++)\n-    if (expr[x])\n-      {\n-        stmt = expr[x];\n-\tvar = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n-\tgcc_assert (var != NULL_TREE);\n-\tprint_generic_expr (f, var, TDF_SLIM);\n-\tfprintf (f, \" replace with --> \");\n-\tprint_generic_expr (f, TREE_OPERAND (stmt, 1), TDF_SLIM);\n-\tfprintf (f, \"\\n\");\n-      }\n-  fprintf (f, \"\\n\");\n-}\n-\n-\n /* This function will rewrite the current program using the variable mapping\n    found in MAP.  If the replacement vector VALUES is provided, any \n    occurrences of partitions with non-null entries in the vector will be "}, {"sha": "19c708922e8a17ec38ac9b2c1ec4ae74c928367b", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00509c04eeb8e0656ed93021c905293e1d01dc64/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00509c04eeb8e0656ed93021c905293e1d01dc64/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=00509c04eeb8e0656ed93021c905293e1d01dc64", "patch": "@@ -586,5 +586,9 @@ extern conflict_graph build_tree_conflict_graph (tree_live_info_p, tpa_p,\n extern void coalesce_tpa_members (tpa_p tpa, conflict_graph graph, var_map map,\n \t\t\t\t  coalesce_list_p cl, FILE *);\n \n+/* From tree-ssa-ter.c  */\n+extern tree *find_replaceable_exprs (var_map);\n+extern void dump_replaceable_exprs (FILE *, tree *);\n+\n \n #endif /* _TREE_SSA_LIVE_H  */"}, {"sha": "2bd58cc38f2d164edd1fa70ff15b600960646584", "filename": "gcc/tree-ssa-ter.c", "status": "added", "additions": 747, "deletions": 0, "changes": 747, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00509c04eeb8e0656ed93021c905293e1d01dc64/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00509c04eeb8e0656ed93021c905293e1d01dc64/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=00509c04eeb8e0656ed93021c905293e1d01dc64", "patch": "@@ -0,0 +1,747 @@\n+/* Routines for performing Temporary Expression Replacement (TER) in SSA trees.\n+   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod  <amacleod@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"langhooks.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"expr.h\"\n+#include \"function.h\"\n+#include \"diagnostic.h\"\n+#include \"bitmap.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-gimple.h\"\n+#include \"tree-inline.h\"\n+#include \"varray.h\"\n+#include \"timevar.h\"\n+#include \"hashtab.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-ssa-live.h\"\n+#include \"tree-pass.h\"\n+#include \"toplev.h\"\n+#include \"vecprim.h\"\n+\n+\n+/* Temporary Expression Replacement (TER)\n+\n+   Replace SSA version variables during out-of-ssa with their defining\n+   expression if there is only one use of the variable.  \n+\n+   This pass is required in order for the RTL expansion pass to see larger\n+   chunks of code.  This allows it to make better choices on RTL pattern\n+   selection.  When expand is rewritten and merged with out-of-ssa, and\n+   understands SSA, this should be eliminated.  \n+\n+   A pass is made through the function, one block at a time.  No cross block\n+   information is tracked.\n+\n+   Variables which only have one use, and whose defining stmt is considered\n+   a replaceable expression (see is_replaceable_p) are tracked to see whether\n+   they can be replaced at their use location.  \n+   \n+   n_12 = C * 10\n+   a_2 = b_5 + 6\n+   v_9 = a_2 * n_12\n+\n+   if there are the only use of n_12 and a_2, TER will substitute in their\n+   expressions in v_9, and end up with:\n+\n+   v_9 = (b_5 + 6) * (C * 10)\n+\n+   which will then have the ssa_name assigned to regular variables, and the\n+   resulting code which will be passed ot the expander looks something like:\n+\n+   v = (b + 6) * (C * 10)\n+\n+   \n+   This requires ensuring that none of the variables used by the expression \n+   change between the def point and where it is used.  Furthermore, if any \n+   of the ssa_names used in this expression are themselves replaceable, we \n+   have to ensure none of that expressions' arguments change either.  \n+   Although SSA_NAMES themselves don't change, this pass is performed after \n+   coalescing has coalesced different SSA_NAMES together, so there could be a \n+   definition of an SSA_NAME which is coalesced with a use that causes a\n+   problem.  ie\n+   \n+   PHI b_5 = <b_8(2), b_14(1)>\n+   <...>\n+   a_2 = b_5 + 6\n+   b_8 = c_4 + 4\n+   v_9 = a_2 * n_12\n+   <...>\n+\n+   If b_5, b_8 and b_14 are all colaesced together...\n+   The expression b_5 + 6 CANNOT replace the use in the statement defining v_9\n+   because b_8 is in fact killing the value of b_5 since they share a partition\n+   and will be assigned the same memory or regster location.\n+   \n+   TER implements this but stepping through the instructions in a block and\n+   tracking potential expressions for replacement, and the paritions they are\n+   dependent on.  Expressions are represented by the SSA_NAME_VERSION of the\n+   DEF on the LHS of a GIMPLE_MODIFY_STMT and the expression is the RHS.\n+\n+   When a stmt is determined to be a possible replacement expression, the\n+   following steps are taken:\n+\n+   EXPR_DECL_UID bitmap is allocated and set to the base variable UID of the \n+   def and any uses in the expression.  non-NULL means the expression is being \n+   tracked.  The UID's themselves are used to prevent TER substitution into\n+   accumulating sequences.\n+   ie\n+   x = x + y\n+   x = x + z\n+   x = x + w\n+   etc.\n+   this can result in very large expressions which don't accomplish anything\n+   see PR tree-optimization/17549.  \n+\n+   PARTITION_DEPENDENCIES is another bitmap array, and it has a bit set for any \n+   partition which is used in the expression.  This is primarily used to remove\n+   an expression from the partition kill lists when a decision is made whether\n+   to replace it or not.  This is indexed by ssa version number as well, and\n+   indicates a partition number.  virtual operands are not tracked individually,\n+   but they are summarized by an artifical partition called VIRTUAL_PARTITION.\n+   This means a MAY or MUST def will kill *ALL* expressions that are dependant\n+   on a virtual operand.\n+   Note that the EXPR_DECL_UID and this bitmap represent very similar \n+   information, but the info in one is not easy to obtain from the other.\n+\n+   KILL_LIST is yet another bitmap array, this time it is indexed by partition\n+   number, and represents a list of active expressions which will will no \n+   longer be valid if a definition into this partition takes place.\n+\n+   PARTITION_IN_USE is simply a bitmap which is used to track which partitions\n+   currently have sokmething in their kill list.  This is used at the end of \n+   a block to clear out the KILL_LIST bitmaps at the end of each block.\n+\n+   NEW_REPLACEABLE_DEPENDENCIES is used as a temporary place to store \n+   dependencies which will be reused by the current defintion. ALl the uses\n+   on an expression are processed before anything else is done. If a use is\n+   determined to be a replaceable expression AND the current stmt is also going\n+   to be replaceable, all the dependencies of this replaceable use will be\n+   picked up by the current stmt's expression. Rather than recreate them, they\n+   are simply copied here and then copied into the new expression when it is\n+   processed.\n+\n+   a_2 = b_5 + 6\n+   v_8 = a_2 + c_4\n+\n+   a_2's expression 'b_5 + 6' is determined to be replaceable at the use \n+   location. It is dependent on the partition 'b_5' is in. This is cached into\n+   the NEW_REPLACEABLE_DEPENDENCIES bitmap. and when v_8 is examined for\n+   replaceablility, it is a candidate, and it is dependent on the partition \n+   b_5 is in *NOT* a_2, as well as c_4's partition.\n+\n+   if v_8 is also replaceable:\n+\n+   x_9 = v_8 * 5\n+\n+   x_9 is dependent on partitions b_5, and c_4\n+   \n+   if a statement is found which has either of those partitions written to \n+   before x_9 is used, then x_9 itself is NOT replaceable.  */\n+\n+\n+/* Temporary Expression Replacement (TER) table information.  */\n+\n+typedef struct temp_expr_table_d \n+{\n+  var_map map;\n+  bitmap *partition_dependencies;\t/* Partitions expr is dependent on.  */\n+  tree *replaceable_expressions;\t/* Replacement expression table.  */\n+  bitmap *expr_decl_uids;\t\t/* Base uids of exprs.  */\n+  bitmap *kill_list;\t\t\t/* Expr's killed by a partition.  */\n+  int virtual_partition;\t\t/* Psuedo partition for virtual ops.  */\n+  bitmap partition_in_use;\t\t/* Partitions with kill entires.  */\n+  bitmap new_replaceable_dependencies;\t/* Holding place for pending dep's.  */\n+  int *num_in_part;\t\t\t/* # of ssa_names in a partition.  */\n+} *temp_expr_table_p;\n+\n+/* Used to indicate a dependency on V_MAY_DEFs.  */\n+#define VIRTUAL_PARTITION(table)\t(table->virtual_partition)\n+\n+#ifdef ENABLE_CHECKING\n+extern void debug_ter (FILE *, temp_expr_table_p);\n+#endif\n+\n+\n+/* Create a new TER table for MAP.  */\n+\n+static temp_expr_table_p\n+new_temp_expr_table (var_map map)\n+{\n+  temp_expr_table_p t;\n+  unsigned x;\n+\n+  t = XNEW (struct temp_expr_table_d);\n+  t->map = map;\n+\n+  t->partition_dependencies = XCNEWVEC (bitmap, num_ssa_names + 1);\n+  t->expr_decl_uids = XCNEWVEC (bitmap, num_ssa_names + 1);\n+  t->kill_list = XCNEWVEC (bitmap, num_var_partitions (map) + 1);\n+\n+  t->partition_in_use = BITMAP_ALLOC (NULL);\n+\n+  t->virtual_partition = num_var_partitions (map);\n+  t->new_replaceable_dependencies = BITMAP_ALLOC (NULL);\n+\n+  t->replaceable_expressions = NULL;\n+  t->num_in_part = XCNEWVEC (int, num_var_partitions (map));\n+  for (x = 1; x < num_ssa_names; x++)\n+    {\n+      int p;\n+      tree name = ssa_name (x);\n+      if (!name)\n+        continue;\n+      p = var_to_partition (map, name);\n+      if (p != NO_PARTITION)\n+        t->num_in_part[p]++;\n+    }\n+\n+  return t;\n+}\n+\n+\n+/* Free TER table T.  If there are valid replacements, return the expression \n+   vector.  */\n+\n+static tree *\n+free_temp_expr_table (temp_expr_table_p t)\n+{\n+  tree *ret = NULL;\n+  unsigned i;\n+\n+#ifdef ENABLE_CHECKING\n+  unsigned x;\n+  for (x = 0; x <= num_var_partitions (t->map); x++)\n+    gcc_assert (!t->kill_list[x]);\n+#endif\n+\n+  BITMAP_FREE (t->partition_in_use);\n+\n+  for (i = 0; i <= num_ssa_names; i++)\n+    if (t->expr_decl_uids[i])\n+      BITMAP_FREE (t->expr_decl_uids[i]);\n+  free (t->expr_decl_uids);\n+\n+  free (t->kill_list);\n+  free (t->partition_dependencies);\n+\n+  if (t->replaceable_expressions)\n+    ret = t->replaceable_expressions;\n+\n+  free (t);\n+  return ret;\n+}\n+\n+\n+/* Return TRUE if VERSION is to be replaced by an expression in TAB.  */\n+\n+static inline bool\n+version_to_be_replaced_p (temp_expr_table_p tab, int version)\n+{\n+  if (!tab->replaceable_expressions)\n+    return false;\n+  return tab->replaceable_expressions[version] != NULL_TREE;\n+}\n+\n+\n+/* Add partition P to the list if partititons VERSION is dependent on.  TAB is \n+   the expression table */\n+\n+static inline void\n+make_dependent_on_partition (temp_expr_table_p tab, int version, int p)\n+{\n+  if (!tab->partition_dependencies[version])\n+    tab->partition_dependencies[version] = BITMAP_ALLOC (NULL);\n+\n+  bitmap_set_bit (tab->partition_dependencies[version], p);\n+}\n+\n+\n+/* Add VER to the kill list for P.  TAB is the expression table */\n+\n+static inline void\n+add_to_partition_kill_list (temp_expr_table_p tab, int p, int ver)\n+{\n+  if (!tab->kill_list[p])\n+    {\n+      tab->kill_list[p] = BITMAP_ALLOC (NULL);\n+      bitmap_set_bit (tab->partition_in_use, p);\n+    }\n+  bitmap_set_bit (tab->kill_list[p], ver);\n+}\n+\n+\n+/* Remove VER from the partition kill list for P.  TAB is the expression \n+   table.  */\n+\n+static inline void \n+remove_from_partition_kill_list (temp_expr_table_p tab, int p, int version)\n+{\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (tab->kill_list[p]);\n+#endif\n+  bitmap_clear_bit (tab->kill_list[p], version);\n+  if (bitmap_empty_p (tab->kill_list[p]))\n+    {\n+      bitmap_clear_bit (tab->partition_in_use, p);\n+      BITMAP_FREE (tab->kill_list[p]);\n+    }\n+}\n+\n+\n+/* Add a dependency between the def of ssa VERSION and VAR.  If VAR is \n+   replaceable by an expression, add a dependence each of the elements of the \n+   expression.  These are contained in the new_replaceable list.  TAB is the\n+   expression table.  */\n+\n+static void\n+add_dependence (temp_expr_table_p tab, int version, tree var)\n+{\n+  int i;\n+  bitmap_iterator bi;\n+  unsigned x;\n+\n+  i = SSA_NAME_VERSION (var);\n+  if (version_to_be_replaced_p (tab, i))\n+    {\n+      if (!bitmap_empty_p (tab->new_replaceable_dependencies))\n+        {\n+\t  /* Version will now be killed by a write to any partition the \n+\t     substituted expression would have been killed by.  */\n+\t  EXECUTE_IF_SET_IN_BITMAP (tab->new_replaceable_dependencies, 0, x, bi)\n+\t    add_to_partition_kill_list (tab, x, version);\n+\n+\t  /* Rather than set partition_dependencies and in_use lists bit by \n+\t     bit, simply OR in the new_replaceable_dependencies bits.  */\n+\t  if (!tab->partition_dependencies[version])\n+\t    tab->partition_dependencies[version] = BITMAP_ALLOC (NULL);\n+\t  bitmap_ior_into (tab->partition_dependencies[version], \n+\t\t\t   tab->new_replaceable_dependencies);\n+\t  bitmap_ior_into (tab->partition_in_use, \n+\t\t\t   tab->new_replaceable_dependencies);\n+\t  /* It is only necessary to add these once.  */\n+\t  bitmap_clear (tab->new_replaceable_dependencies);\n+\t}\n+    }\n+  else\n+    {\n+      i = var_to_partition (tab->map, var);\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (i != NO_PARTITION);\n+      gcc_assert (tab->num_in_part[i] != 0);\n+#endif\n+      /* Only dependencies on ssa_names which are coalesced with something need\n+         to be tracked.  Partitions with containing only a single SSA_NAME\n+\t *cannot* have their value changed.  */\n+      if (tab->num_in_part[i] > 1)\n+        {\n+\t  add_to_partition_kill_list (tab, i, version);\n+\t  make_dependent_on_partition (tab, version, i);\n+\t}\n+    }\n+}\n+\n+\n+/* Return TRUE if expression STMT is suitable for replacement.  */\n+\n+static inline bool\n+is_replaceable_p (tree stmt)\n+{\n+  tree call_expr;\n+  use_operand_p use_p;\n+  tree def, use_stmt;\n+\n+  /* Only consider modify stmts.  */\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+    return false;\n+\n+  /* Punt if there is more than 1 def.  */\n+  def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n+  if (!def)\n+    return false;\n+\n+  /* Only consider definitions which have a single use.  */\n+  if (!single_imm_use (def, &use_p, &use_stmt))\n+    return false;\n+\n+  /* If the use isn't in this block, it wont be replaced either.  */\n+  if (bb_for_stmt (use_stmt) != bb_for_stmt (stmt))\n+    return false;\n+\n+  /* Used in this block, but at the TOP of the block, not the end.  */\n+  if (TREE_CODE (use_stmt) == PHI_NODE)\n+    return false;\n+\n+  /* There must be no V_MAY_DEFS or V_MUST_DEFS.  */\n+  if (!(ZERO_SSA_OPERANDS (stmt, (SSA_OP_VMAYDEF | SSA_OP_VMUSTDEF))))\n+    return false;\n+\n+  /* Float expressions must go through memory if float-store is on.  */\n+  if (flag_float_store \n+      && FLOAT_TYPE_P (TREE_TYPE (GENERIC_TREE_OPERAND (stmt, 1))))\n+    return false;\n+\n+  /* Calls to functions with side-effects cannot be replaced.  */\n+  if ((call_expr = get_call_expr_in (stmt)) != NULL_TREE)\n+    {\n+      int call_flags = call_expr_flags (call_expr);\n+      if (TREE_SIDE_EFFECTS (call_expr)\n+\t  && !(call_flags & (ECF_PURE | ECF_CONST | ECF_NORETURN)))\n+\treturn false;\n+    }\n+\n+  /* Leave any stmt with voltile operands alone as well.  */\n+  if (stmt_ann (stmt)->has_volatile_ops)\n+    return false;\n+  \n+\n+  return true;\n+}\n+\n+\n+/* This function will remove the expression for VERSION from replacement \n+   consideration in table TAB.  If FREE_EXPR is true, then remove the \n+   expression from consideration as well by freeing the decl uid bitmap.  */\n+\n+static void\n+finished_with_expr (temp_expr_table_p tab, int version, bool free_expr)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+\n+  /* Remove this expression from its dependent lists.  The partition dependence\n+     list is retained and transfered later to whomever uses this version.  */\n+  if (tab->partition_dependencies[version])\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (tab->partition_dependencies[version], 0, i, bi)\n+\tremove_from_partition_kill_list (tab, i, version);\n+      BITMAP_FREE (tab->partition_dependencies[version]);\n+    }\n+  if (free_expr)\n+    BITMAP_FREE (tab->expr_decl_uids[version]);\n+}\n+\n+\n+/* Create an expression entry fora replaceable expression.  */\n+\n+static void \n+process_replaceable (temp_expr_table_p tab, tree stmt)\n+{\n+  tree var, def, basevar;\n+  int version;\n+  ssa_op_iter iter;\n+  bitmap def_vars, use_vars;\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (is_replaceable_p (stmt));\n+#endif\n+\n+  def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n+  version = SSA_NAME_VERSION (def);\n+  basevar = SSA_NAME_VAR (def);\n+  def_vars = BITMAP_ALLOC (NULL);\n+\n+  bitmap_set_bit (def_vars, DECL_UID (basevar));\n+\n+  /* Add this expression to the dependency list for each use partition.  */\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)\n+    {\n+      int var_version = SSA_NAME_VERSION (var);\n+\n+      use_vars = tab->expr_decl_uids[var_version];\n+      add_dependence (tab, version, var);\n+      if (use_vars)\n+        {\n+\t  bitmap_ior_into (def_vars, use_vars);\n+\t  BITMAP_FREE (tab->expr_decl_uids[var_version]);\n+\t}\n+      else\n+\tbitmap_set_bit (def_vars, DECL_UID (SSA_NAME_VAR (var)));\n+    }\n+  tab->expr_decl_uids[version] = def_vars;\n+\n+  /* If there are VUSES, add a dependence on virtual defs.  */\n+  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VUSE))\n+    {\n+      make_dependent_on_partition (tab, version, VIRTUAL_PARTITION (tab));\n+      add_to_partition_kill_list (tab, VIRTUAL_PARTITION (tab), version);\n+    }\n+}\n+\n+\n+/* This function removes any expression in TAB which is dependent on PARTITION\n+   from consideration, making it not replaceable.  */\n+\n+static inline void\n+kill_expr (temp_expr_table_p tab, int partition)\n+{\n+  unsigned version;\n+\n+  /* Mark every active expr dependent on this var as not replaceable.  \n+     finished_with_expr can modify the bitmap, so we can't execute over it.  */\n+  while (tab->kill_list[partition])\n+    {\n+      version = bitmap_first_set_bit (tab->kill_list[partition]);\n+      finished_with_expr (tab, version, true);\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (!tab->kill_list[partition]);\n+#endif\n+}\n+\n+\n+/* This function kills all expressions in TAB which are dependent on virtual \n+   partitions.  */\n+\n+static inline void\n+kill_virtual_exprs (temp_expr_table_p tab)\n+{\n+  kill_expr (tab, VIRTUAL_PARTITION (tab));\n+}\n+\n+\n+/* Mark the expression associated with VAR as replaceable, and enter\n+   the defining stmt into the partition_dependencies table TAB.  if\n+   MORE_REPLACING is true, accumulate the pending partition dependencies.  */\n+\n+static void\n+mark_replaceable (temp_expr_table_p tab, tree var, bool more_replacing)\n+{\n+  int version = SSA_NAME_VERSION (var);\n+\n+  /* Move the dependence list to the pending listpending.  */\n+  if (more_replacing && tab->partition_dependencies[version])\n+    bitmap_ior_into (tab->new_replaceable_dependencies, \n+\t\t     tab->partition_dependencies[version]);\n+\n+  finished_with_expr (tab, version, !more_replacing);\n+\n+  /* Set the replaceable expression.  */\n+  if (!tab->replaceable_expressions)\n+    tab->replaceable_expressions = XCNEWVEC (tree, num_ssa_names + 1);\n+  tab->replaceable_expressions[version] = SSA_NAME_DEF_STMT (var);\n+}\n+\n+\n+/* This function processes basic block BB, and looks for variables which can\n+   be replaced by their expressions.  Results are stored in the table TAB.  */\n+\n+static void\n+find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n+{\n+  block_stmt_iterator bsi;\n+  tree stmt, def, use;\n+  stmt_ann_t ann;\n+  int partition;\n+  var_map map = tab->map;\n+  ssa_op_iter iter;\n+  bool stmt_replaceable;\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      stmt = bsi_stmt (bsi);\n+      ann = stmt_ann (stmt);\n+\n+      stmt_replaceable = is_replaceable_p (stmt);\n+      /* Determine if this stmt finishes an existing expression.  */\n+      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+\t{\n+\t  unsigned ver = SSA_NAME_VERSION (use);\n+\n+\t  /* If this use is a potential replacement variable, process it.  */\n+\t  if (tab->expr_decl_uids[ver])\n+\t    {\n+\t      bool same_root_var = false;\n+\t      ssa_op_iter iter2;\n+\t      bitmap vars = tab->expr_decl_uids[ver];\n+\n+\t      /* See if the root variables are the same.  If they are, we\n+\t\t do not want to do the replacement to avoid problems with\n+\t\t code size, see PR tree-optimization/17549.  */\n+\t      if (!bitmap_empty_p (vars))\n+\t\tFOR_EACH_SSA_TREE_OPERAND (def, stmt, iter2, SSA_OP_DEF)\n+\t\t  {\n+\t\t    if (bitmap_bit_p (vars, DECL_UID (SSA_NAME_VAR (def))))\n+\t\t      {\n+\t\t\tsame_root_var = true;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\n+\t      /* Mark expression as replaceable unless stmt is volatile or the \n+\t\t def variable has the same root variable as something in the \n+\t\t substitution list.  */\n+\t      if (ann->has_volatile_ops || same_root_var)\n+\t\tfinished_with_expr (tab, ver, true);\n+\t      else\n+\t\tmark_replaceable (tab, use, stmt_replaceable);\n+\t    }\n+\t}\n+      \n+      /* Next, see if this stmt kills off an active expression.  */\n+      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n+\t{\n+\t  partition = var_to_partition (map, def);\n+\t  if (partition != NO_PARTITION && tab->kill_list[partition])\n+\t    kill_expr (tab, partition);\n+\t}\n+\n+      /* Now see if we are creating a new expression or not.  */\n+      if (stmt_replaceable)\n+\tprocess_replaceable (tab, stmt);\n+\n+      /* Free any unused dependency lists.  */\n+      bitmap_clear (tab->new_replaceable_dependencies);\n+\n+      /* A V_{MAY,MUST}_DEF kills any expression using a virtual operand,\n+\t including the current stmt.  */\n+      if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n+        kill_virtual_exprs (tab);\n+    }\n+}\n+\n+\n+/* This function is the driver routine for replacement of temporary expressions\n+   in the SSA->normal phase, operating on MAP.  If there are replaceable \n+   expressions, a table is returned which maps SSA versions to the \n+   expressions they should be replaced with.  A NULL_TREE indicates no \n+   replacement should take place.  If there are no replacements at all, \n+   NULL is returned by the function, otherwise an expression vector indexed\n+   by SSA_NAME version numbers.  */\n+\n+extern tree *\n+find_replaceable_exprs (var_map map)\n+{\n+  basic_block bb;\n+  temp_expr_table_p table;\n+  tree *ret;\n+\n+  table = new_temp_expr_table (map);\n+  FOR_EACH_BB (bb)\n+    {\n+      find_replaceable_in_bb (table, bb);\n+      gcc_assert (bitmap_empty_p (table->partition_in_use));\n+\n+#ifdef ENABLE_CHECKING\n+      {\n+\tunsigned i;\n+\t/* Make sure all the tables have been cleared out.  */\n+\tfor (i = 0; i < num_ssa_names + 1; i++)\n+\t  {\n+\t    gcc_assert (table->partition_dependencies[i] == NULL);\n+\t    gcc_assert (table->expr_decl_uids[i] == NULL);\n+\t    if (i < num_var_partitions (map))\n+\t      gcc_assert (table->kill_list[i] == NULL);\n+\t  }\n+      }\n+#endif\n+    }\n+\n+  ret = free_temp_expr_table (table);\n+  return ret;\n+}\n+\n+\n+/* Dump TER expression table EXPR to file F.  */\n+\n+extern void\n+dump_replaceable_exprs (FILE *f, tree *expr)\n+{\n+  tree stmt, var;\n+  int x;\n+\n+  fprintf (f, \"\\nReplacing Expressions\\n\");\n+  for (x = 0; x < (int)num_ssa_names; x++)\n+    if (expr[x])\n+      {\n+        stmt = expr[x];\n+\tvar = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n+\tgcc_assert (var != NULL_TREE);\n+\tprint_generic_expr (f, var, TDF_SLIM);\n+\tfprintf (f, \" replace with --> \");\n+\tprint_generic_expr (f, TREE_OPERAND (stmt, 1), TDF_SLIM);\n+\tfprintf (f, \"\\n\");\n+      }\n+  fprintf (f, \"\\n\");\n+}\n+\n+\n+#ifdef ENABLE_CHECKING\n+/* Dump the status of the various tables in the expression table.  This is used\n+   exclusively to debug TER.  F is the place to send debug info and T is the\n+   table being debugged.  */\n+\n+extern void\n+debug_ter (FILE *f, temp_expr_table_p t)\n+{\n+  unsigned x, y;\n+  bitmap_iterator bi;\n+\n+  fprintf (f, \"\\nDumping current state of TER\\n virtual partition = %d\\n\", \n+\t   VIRTUAL_PARTITION (t));\n+  if (t->replaceable_expressions)\n+    dump_replaceable_exprs (f, t->replaceable_expressions);\n+  fprintf (f, \"Currently tracking the following expressions:\\n\");\n+\n+  for (x = 1; x < num_ssa_names; x++)\n+    if (t->expr_decl_uids[x])\n+      {\n+        print_generic_expr (stderr, ssa_name (x), TDF_SLIM);\n+        fprintf (f, \" dep-parts : \");\n+\tif (t->partition_dependencies[x] \n+\t    && !bitmap_empty_p (t->partition_dependencies[x]))\n+\t  {\n+\t    EXECUTE_IF_SET_IN_BITMAP (t->partition_dependencies[x], 0, y, bi)\n+\t      fprintf (f, \"P%d \",y);\n+\t  }\n+\tfprintf (stderr, \"   basedecls: \");\n+\tEXECUTE_IF_SET_IN_BITMAP (t->expr_decl_uids[x], 0, y, bi)\n+\t  fprintf (f, \"%d \",y);\n+\tfprintf (stderr, \"\\n\");\n+      }\n+\n+  bitmap_print (f, t->partition_in_use, \"Partitions in use \", \n+\t\t\"\\npartition KILL lists:\\n\");\n+\n+  for (x = 0; x <= num_var_partitions (t->map); x++)\n+    if (t->kill_list[x])\n+      {\n+        fprintf (f, \"Partition %d : \", x);\n+\tEXECUTE_IF_SET_IN_BITMAP (t->kill_list[x], 0, y, bi)\n+\t  fprintf (f, \"_%d \",y);\n+      }\n+\n+  fprintf (f, \"\\n----------\\n\");\n+}\n+#endif"}]}