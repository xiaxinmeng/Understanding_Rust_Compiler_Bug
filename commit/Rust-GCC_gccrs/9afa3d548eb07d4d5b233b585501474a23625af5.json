{"sha": "9afa3d548eb07d4d5b233b585501474a23625af5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFmYTNkNTQ4ZWIwN2Q0ZDViMjMzYjU4NTUwMTQ3NGEyMzYyNWFmNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-05-19T22:09:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-05-19T22:09:24Z"}, "message": "(set_nonzero_bits_and_sign_copies...\n\n(set_nonzero_bits_and_sign_copies, nonzero_bits): If we have a\npositive constant that is negative in the mode it is being used in,\ntreat it as negative.\n\nFrom-SVN: r4506", "tree": {"sha": "c9614a5dd500d45461b891936017ab1122dd710b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9614a5dd500d45461b891936017ab1122dd710b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9afa3d548eb07d4d5b233b585501474a23625af5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9afa3d548eb07d4d5b233b585501474a23625af5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9afa3d548eb07d4d5b233b585501474a23625af5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9afa3d548eb07d4d5b233b585501474a23625af5/comments", "author": null, "committer": null, "parents": [{"sha": "b310570af3762926756f56c4d22db577f95d1e5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b310570af3762926756f56c4d22db577f95d1e5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b310570af3762926756f56c4d22db577f95d1e5d"}], "stats": {"total": 59, "additions": 57, "deletions": 2}, "files": [{"sha": "ca1567c6f0e3e1cb49aaeaf80a86497a02b7a4ad", "filename": "gcc/combine.c", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9afa3d548eb07d4d5b233b585501474a23625af5/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9afa3d548eb07d4d5b233b585501474a23625af5/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9afa3d548eb07d4d5b233b585501474a23625af5", "patch": "@@ -692,8 +692,31 @@ set_nonzero_bits_and_sign_copies (x, set)\n \t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (set)))))\n \t      && SUBREG_REG (SET_DEST (set)) == x))\n \t{\n+\t  rtx src = SET_SRC (set);\n+\n+#ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n+\t  /* If X is narrower than a word and SRC is a non-negative\n+\t     constant that would appear negative in the mode of X,\n+\t     sign-extend it for use in reg_nonzero_bits because some\n+\t     machines (maybe most) will actually do the sign-extension\n+\t     and this is the conservative approach. \n+\n+\t     ??? For 2.5, try to tighten up the MD files in this regard\n+\t     instead of this kludge.  */\n+\n+\t  if (GET_MODE_BITSIZE (GET_MODE (x)) < BITS_PER_WORD\n+\t      && GET_CODE (src) == CONST_INT\n+\t      && INTVAL (src) > 0\n+\t      && 0 != (INTVAL (src)\n+\t\t       & ((HOST_WIDE_INT) 1\n+\t\t\t  << GET_MODE_BITSIZE (GET_MODE (x)))))\n+\t    src = GEN_INT (INTVAL (src)\n+\t\t\t   | ((HOST_WIDE_INT) (-1)\n+\t\t\t      << GET_MODE_BITSIZE (GET_MODE (x))));\n+#endif\n+\n \t  reg_nonzero_bits[REGNO (x)]\n-\t    |= nonzero_bits (SET_SRC (set), nonzero_bits_mode);\n+\t    |= nonzero_bits (src, nonzero_bits_mode);\n \t  num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));\n \t  if (reg_sign_bit_copies[REGNO (x)] == 0\n \t      || reg_sign_bit_copies[REGNO (x)] > num)\n@@ -6222,14 +6245,46 @@ nonzero_bits (x, mode)\n \treturn reg_last_set_nonzero_bits[REGNO (x)];\n \n       tem = get_last_value (x);\n+\n       if (tem)\n-\treturn nonzero_bits (tem, mode);\n+\t{\n+#ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n+\t  /* If X is narrower than MODE and TEM is a non-negative\n+\t     constant that would appear negative in the mode of X,\n+\t     sign-extend it for use in reg_nonzero_bits because some\n+\t     machines (maybe most) will actually do the sign-extension\n+\t     and this is the conservative approach. \n+\n+\t     ??? For 2.5, try to tighten up the MD files in this regard\n+\t     instead of this kludge.  */\n+\n+\t  if (GET_MODE_BITSIZE (GET_MODE (x)) < mode_width\n+\t      && GET_CODE (tem) == CONST_INT\n+\t      && INTVAL (tem) > 0\n+\t      && 0 != (INTVAL (tem)\n+\t\t       & ((HOST_WIDE_INT) 1\n+\t\t\t  << GET_MODE_BITSIZE (GET_MODE (x)))))\n+\t    tem = GEN_INT (INTVAL (tem)\n+\t\t\t   | ((HOST_WIDE_INT) (-1)\n+\t\t\t      << GET_MODE_BITSIZE (GET_MODE (x))));\n+#endif\n+\t  return nonzero_bits (tem, mode);\n+\t}\n       else if (nonzero_sign_valid && reg_nonzero_bits[REGNO (x)])\n \treturn reg_nonzero_bits[REGNO (x)] & nonzero;\n       else\n \treturn nonzero;\n \n     case CONST_INT:\n+#ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n+      /* If X is negative in MODE, sign-extend the value.  */\n+      if (INTVAL (x) > 0\n+\t  && 0 != (INTVAL (x)\n+\t\t   & ((HOST_WIDE_INT) 1 << GET_MODE_BITSIZE (GET_MODE (x)))))\n+\treturn (INTVAL (x)\n+\t\t| ((HOST_WIDE_INT) (-1) << GET_MODE_BITSIZE (GET_MODE (x))));\n+#endif\n+\n       return INTVAL (x);\n \n #ifdef BYTE_LOADS_ZERO_EXTEND"}]}