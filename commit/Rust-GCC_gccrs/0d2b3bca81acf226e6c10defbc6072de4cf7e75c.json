{"sha": "0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQyYjNiY2E4MWFjZjIyNmU2YzEwZGVmYmM2MDcyZGU0Y2Y3ZTc1Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-25T08:09:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-25T08:09:39Z"}, "message": "Fold VEC_COND_EXPRs to IFN_COND_* where possible\n\nThis patch adds the folds:\n\n  (vec_cond COND (foo A B) C) -> (IFN_COND_FOO COND A B C)\n  (vec_cond COND C (foo A B)) -> (IFN_COND_FOO (!COND) A B C)\n\nwith the usual implicit restriction that the target must support\nthe produced IFN_COND_FOO.\n\nThe results of these folds don't have identical semantics, since\nthe reverse transform would be invalid if (FOO A[i] B[i]) faults when\nCOND[i] is false.  But this direction is OK since we're simply dropping\nfaults for operations whose results aren't needed.\n\nThe new gimple_resimplify4 doesn't try to do any constant folding\non the IFN_COND_*s.  This is because a later patch will handle it\nby folding the associated unconditional operation.\n\nDoing this in gimple is better than doing it in .md patterns,\nsince the second form (with the inverted condition) is much more\ncommon than the first, and it's better to fold away the inversion\nin gimple and optimise the result before entering expand.\n\n2018-05-24  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* doc/sourcebuild.texi (vect_double_cond_arith: Document.\n\t* gimple-match.h (gimple_match_op::MAX_NUM_OPS): Bump to 4.\n\t(gimple_match_op::gimple_match_op): Add an overload for 4 operands.\n\t(gimple_match_op::set_op): Likewise.\n\t(gimple_resimplify4): Declare.\n\t* genmatch.c (get_operand_type): Handle CFN_COND_* functions.\n\t(expr::gen_transform): Likewise.\n\t(decision_tree::gen): Generate a simplification routine for 4 operands.\n\t* gimple-match-head.c (gimple_simplify): Add an overload for\n\t4 operands.  In the top-level function, handle up to 4 call\n\targuments and call gimple_resimplify4.\n\t(gimple_resimplify4): New function.\n\t(build_call_internal): Pass a fourth operand.\n\t(maybe_push_to_seq): Likewise.\n\t* match.pd (UNCOND_BINARY, COND_BINARY): New operator lists.\n\tFold VEC_COND_EXPRs of an operation and a default value into\n\tan IFN_COND_* function if possible.\n\t* config/aarch64/iterators.md (UNSPEC_COND_MAX, UNSPEC_COND_MIN):\n\tNew unspecs.\n\t(SVE_COND_FP_BINARY): Include them.\n\t(optab, sve_fp_op): Handle them.\n\t(SVE_INT_BINARY_REV): New code iterator.\n\t(SVE_COND_FP_BINARY_REV): New int iterator.\n\t(commutative): New int attribute.\n\t* config/aarch64/aarch64-protos.h (aarch64_sve_prepare_conditional_op):\n\tDeclare.\n\t* config/aarch64/aarch64.c (aarch64_sve_prepare_conditional_op): New\n\tfunction.\n\t* config/aarch64/aarch64-sve.md (cond_<optab><mode>): Use it.\n\t(*cond_<optab><mode>): New patterns for reversed operands.\n\ngcc/testsuite/\n\t* lib/target-supports.exp\n\t(check_effective_target_vect_double_cond_arith): New proc.\n\t* gcc.dg/vect/vect-cond-arith-1.c: New test.\n\t* gcc.target/aarch64/sve/vcond_8.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_8_run.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_9.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_9_run.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_12.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_12_run.c: Likewise.\n\nFrom-SVN: r260710", "tree": {"sha": "2a0e429a6a0d5569f6a5df85a05bb542308c387e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a0e429a6a0d5569f6a5df85a05bb542308c387e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/comments", "author": null, "committer": null, "parents": [{"sha": "2c53b149b7476fabd329429b2a6dce090f580ff4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c53b149b7476fabd329429b2a6dce090f580ff4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c53b149b7476fabd329429b2a6dce090f580ff4"}], "stats": {"total": 797, "additions": 786, "deletions": 11}, "files": [{"sha": "fd187b92d391090064c1d03dd4693455bc28ea53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -1,3 +1,36 @@\n+2018-05-25  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* doc/sourcebuild.texi (vect_double_cond_arith: Document.\n+\t* gimple-match.h (gimple_match_op::MAX_NUM_OPS): Bump to 4.\n+\t(gimple_match_op::gimple_match_op): Add an overload for 4 operands.\n+\t(gimple_match_op::set_op): Likewise.\n+\t(gimple_resimplify4): Declare.\n+\t* genmatch.c (get_operand_type): Handle CFN_COND_* functions.\n+\t(expr::gen_transform): Likewise.\n+\t(decision_tree::gen): Generate a simplification routine for 4 operands.\n+\t* gimple-match-head.c (gimple_simplify): Add an overload for\n+\t4 operands.  In the top-level function, handle up to 4 call\n+\targuments and call gimple_resimplify4.\n+\t(gimple_resimplify4): New function.\n+\t(build_call_internal): Pass a fourth operand.\n+\t(maybe_push_to_seq): Likewise.\n+\t* match.pd (UNCOND_BINARY, COND_BINARY): New operator lists.\n+\tFold VEC_COND_EXPRs of an operation and a default value into\n+\tan IFN_COND_* function if possible.\n+\t* config/aarch64/iterators.md (UNSPEC_COND_MAX, UNSPEC_COND_MIN):\n+\tNew unspecs.\n+\t(SVE_COND_FP_BINARY): Include them.\n+\t(optab, sve_fp_op): Handle them.\n+\t(SVE_INT_BINARY_REV): New code iterator.\n+\t(SVE_COND_FP_BINARY_REV): New int iterator.\n+\t(commutative): New int attribute.\n+\t* config/aarch64/aarch64-protos.h (aarch64_sve_prepare_conditional_op):\n+\tDeclare.\n+\t* config/aarch64/aarch64.c (aarch64_sve_prepare_conditional_op): New\n+\tfunction.\n+\t* config/aarch64/aarch64-sve.md (cond_<optab><mode>): Use it.\n+\t(*cond_<optab><mode>): New patterns for reversed operands.\n+\n 2018-05-25  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vectorizer.h (STMT_VINFO_GROUP_*, GROUP_*): Remove."}, {"sha": "4ea50acaa59c0b58a213bd1f27fb78b6d8deee96", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -513,6 +513,7 @@ bool aarch64_gen_adjusted_ldpstp (rtx *, bool, scalar_mode, RTX_CODE);\n void aarch64_expand_sve_vec_cmp_int (rtx, rtx_code, rtx, rtx);\n bool aarch64_expand_sve_vec_cmp_float (rtx, rtx_code, rtx, rtx, bool);\n void aarch64_expand_sve_vcond (machine_mode, machine_mode, rtx *);\n+void aarch64_sve_prepare_conditional_op (rtx *, unsigned int, bool);\n #endif /* RTX_CODE */\n \n void aarch64_init_builtins (void);"}, {"sha": "0bb37e72bd43bbdb1507f5da69f098a2f4a12f90", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -1769,7 +1769,8 @@\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n {\n-  gcc_assert (rtx_equal_p (operands[2], operands[4]));\n+  bool commutative_p = (GET_RTX_CLASS (<CODE>) == RTX_COMM_ARITH);\n+  aarch64_sve_prepare_conditional_op (operands, 5, commutative_p);\n })\n \n ;; Predicated integer operations.\n@@ -1786,6 +1787,20 @@\n   \"<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n )\n \n+;; Predicated integer operations with the operands reversed.\n+(define_insn \"*cond_<optab><mode>\"\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w\")\n+\t(unspec:SVE_I\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n+\t   (SVE_INT_BINARY_REV:SVE_I\n+\t     (match_operand:SVE_I 2 \"register_operand\" \"w\")\n+\t     (match_operand:SVE_I 3 \"register_operand\" \"0\"))\n+\t   (match_dup 3)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"<sve_int_op>r\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\"\n+)\n+\n ;; Set operand 0 to the last active element in operand 3, or to tied\n ;; operand 1 if no elements are active.\n (define_insn \"fold_extract_last_<mode>\"\n@@ -2567,7 +2582,7 @@\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n {\n-  gcc_assert (rtx_equal_p (operands[2], operands[4]));\n+  aarch64_sve_prepare_conditional_op (operands, 5, <commutative>);\n })\n \n ;; Predicated floating-point operations.\n@@ -2586,6 +2601,22 @@\n   \"<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n )\n \n+;; Predicated floating-point operations with the operands reversed.\n+(define_insn \"*cond_<optab><mode>\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w\")\n+\t(unspec:SVE_F\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n+\t   (unspec:SVE_F\n+\t     [(match_dup 1)\n+\t      (match_operand:SVE_F 2 \"register_operand\" \"w\")\n+\t      (match_operand:SVE_F 3 \"register_operand\" \"0\")]\n+\t     SVE_COND_FP_BINARY)\n+\t   (match_dup 3)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"<sve_fp_op>r\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\"\n+)\n+\n ;; Shift an SVE vector left and insert a scalar into element 0.\n (define_insn \"vec_shl_insert_<mode>\"\n   [(set (match_operand:SVE_ALL 0 \"register_operand\" \"=w, w\")"}, {"sha": "afc91850d6f1458459f64bff0c8dfa3419d5e588", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -16041,6 +16041,54 @@ aarch64_expand_sve_vcond (machine_mode data_mode, machine_mode cmp_mode,\n   emit_set_insn (ops[0], gen_rtx_UNSPEC (data_mode, vec, UNSPEC_SEL));\n }\n \n+/* Prepare a cond_<optab><mode> operation that has the operands\n+   given by OPERANDS, where:\n+\n+   - operand 0 is the destination\n+   - operand 1 is a predicate\n+   - operands 2 to NOPS - 2 are the operands to an operation that is\n+     performed for active lanes\n+   - operand NOPS - 1 specifies the values to use for inactive lanes.\n+\n+   COMMUTATIVE_P is true if operands 2 and 3 are commutative.  In that case,\n+   no pattern is provided for a tie between operands 3 and NOPS - 1.  */\n+\n+void\n+aarch64_sve_prepare_conditional_op (rtx *operands, unsigned int nops,\n+\t\t\t\t    bool commutative_p)\n+{\n+  /* We can do the operation directly if the \"else\" value matches one\n+     of the other inputs.  */\n+  for (unsigned int i = 2; i < nops - 1; ++i)\n+    if (rtx_equal_p (operands[i], operands[nops - 1]))\n+      {\n+\tif (i == 3 && commutative_p)\n+\t  std::swap (operands[2], operands[3]);\n+\treturn;\n+      }\n+\n+  /* If the \"else\" value is different from the other operands, we have\n+     the choice of doing a SEL on the output or a SEL on an input.\n+     Neither choice is better in all cases, but one advantage of\n+     selecting the input is that it can avoid a move when the output\n+     needs to be distinct from the inputs.  E.g. if operand N maps to\n+     register N, selecting the output would give:\n+\n+\tMOVPRFX Z0.S, Z2.S\n+\tADD Z0.S, P1/M, Z0.S, Z3.S\n+\tSEL Z0.S, P1, Z0.S, Z4.S\n+\n+     whereas selecting the input avoids the MOVPRFX:\n+\n+\tSEL Z0.S, P1, Z2.S, Z4.S\n+\tADD Z0.S, P1/M, Z0.S, Z3.S.  */\n+  machine_mode mode = GET_MODE (operands[0]);\n+  rtx temp = gen_reg_rtx (mode);\n+  rtvec vec = gen_rtvec (3, operands[1], operands[2], operands[nops - 1]);\n+  emit_set_insn (temp, gen_rtx_UNSPEC (mode, vec, UNSPEC_SEL));\n+  operands[2] = operands[nops - 1] = temp;\n+}\n+\n /* Implement TARGET_MODES_TIEABLE_P.  In principle we should always return\n    true.  However due to issues with register allocation it is preferable\n    to avoid tieing integer scalar and FP scalar modes.  Executing integer"}, {"sha": "4db3a4c368f35ca5ddc95ff8917a9bb82fc64b17", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -464,6 +464,8 @@\n     UNSPEC_UMUL_HIGHPART ; Used in aarch64-sve.md.\n     UNSPEC_COND_ADD\t; Used in aarch64-sve.md.\n     UNSPEC_COND_SUB\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_MAX\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_MIN\t; Used in aarch64-sve.md.\n     UNSPEC_COND_LT\t; Used in aarch64-sve.md.\n     UNSPEC_COND_LE\t; Used in aarch64-sve.md.\n     UNSPEC_COND_EQ\t; Used in aarch64-sve.md.\n@@ -1203,6 +1205,8 @@\n (define_code_iterator SVE_INT_BINARY [plus minus smax umax smin umin\n \t\t\t\t      and ior xor])\n \n+(define_code_iterator SVE_INT_BINARY_REV [minus])\n+\n ;; SVE integer comparisons.\n (define_code_iterator SVE_INT_CMP [lt le eq ne ge gt ltu leu geu gtu])\n \n@@ -1529,7 +1533,10 @@\n \n (define_int_iterator MUL_HIGHPART [UNSPEC_SMUL_HIGHPART UNSPEC_UMUL_HIGHPART])\n \n-(define_int_iterator SVE_COND_FP_BINARY [UNSPEC_COND_ADD UNSPEC_COND_SUB])\n+(define_int_iterator SVE_COND_FP_BINARY [UNSPEC_COND_ADD UNSPEC_COND_SUB\n+\t\t\t\t\t UNSPEC_COND_MAX UNSPEC_COND_MIN])\n+\n+(define_int_iterator SVE_COND_FP_BINARY_REV [UNSPEC_COND_SUB])\n \n (define_int_iterator SVE_COND_FP_CMP [UNSPEC_COND_LT UNSPEC_COND_LE\n \t\t\t\t      UNSPEC_COND_EQ UNSPEC_COND_NE\n@@ -1559,7 +1566,9 @@\n \t\t\t(UNSPEC_IORV \"ior\")\n \t\t\t(UNSPEC_XORV \"xor\")\n \t\t\t(UNSPEC_COND_ADD \"add\")\n-\t\t\t(UNSPEC_COND_SUB \"sub\")])\n+\t\t\t(UNSPEC_COND_SUB \"sub\")\n+\t\t\t(UNSPEC_COND_MAX \"smax\")\n+\t\t\t(UNSPEC_COND_MIN \"smin\")])\n \n (define_int_attr  maxmin_uns [(UNSPEC_UMAXV \"umax\")\n \t\t\t      (UNSPEC_UMINV \"umin\")\n@@ -1771,4 +1780,11 @@\n \t\t\t (UNSPEC_COND_GT \"gt\")])\n \n (define_int_attr sve_fp_op [(UNSPEC_COND_ADD \"fadd\")\n-\t\t\t    (UNSPEC_COND_SUB \"fsub\")])\n+\t\t\t    (UNSPEC_COND_SUB \"fsub\")\n+\t\t\t    (UNSPEC_COND_MAX \"fmaxnm\")\n+\t\t\t    (UNSPEC_COND_MIN \"fminnm\")])\n+\n+(define_int_attr commutative [(UNSPEC_COND_ADD \"true\")\n+\t\t\t      (UNSPEC_COND_SUB \"false\")\n+\t\t\t      (UNSPEC_COND_MIN \"true\")\n+\t\t\t      (UNSPEC_COND_MAX \"true\")])"}, {"sha": "00e53a657c82ef65ffa5006f3e6cd01443c57caa", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -1425,6 +1425,10 @@ have different type from the value operands.\n @item vect_double\n Target supports hardware vectors of @code{double}.\n \n+@item vect_double_cond_arith\n+Target supports conditional addition, subtraction, minimum and maximum\n+on vectors of @code{double}, via the @code{cond_} optabs.\n+\n @item vect_element_align_preferred\n The target's preferred vector alignment is the same as the element\n alignment."}, {"sha": "d6bd90d15339de5b4a4ee1353ef04766054efd79", "filename": "gcc/genmatch.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -2370,6 +2370,18 @@ get_operand_type (id_base *op, unsigned pos,\n   else if (*op == COND_EXPR\n \t   && pos == 0)\n     return \"boolean_type_node\";\n+  else if (strncmp (op->id, \"CFN_COND_\", 9) == 0)\n+    {\n+      /* IFN_COND_* operands 1 and later by default have the same type\n+\t as the result.  The type of operand 0 needs to be specified\n+\t explicitly.  */\n+      if (pos > 0 && expr_type)\n+\treturn expr_type;\n+      else if (pos > 0 && in_type)\n+\treturn in_type;\n+      else\n+\treturn NULL;\n+    }\n   else\n     {\n       /* Otherwise all types should match - choose one in order of\n@@ -2429,7 +2441,8 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       in_type = NULL;\n     }\n   else if (*opr == COND_EXPR\n-\t   || *opr == VEC_COND_EXPR)\n+\t   || *opr == VEC_COND_EXPR\n+\t   || strncmp (opr->id, \"CFN_COND_\", 9) == 0)\n     {\n       /* Conditions are of the same type as their first alternative.  */\n       sprintf (optype, \"TREE_TYPE (ops%d[1])\", depth);\n@@ -3737,7 +3750,7 @@ decision_tree::gen (FILE *f, bool gimple)\n     }\n   fprintf (stderr, \"removed %u duplicate tails\\n\", rcnt);\n \n-  for (unsigned n = 1; n <= 3; ++n)\n+  for (unsigned n = 1; n <= 4; ++n)\n     {\n       /* First generate split-out functions.  */\n       for (unsigned i = 0; i < root->kids.length (); i++)"}, {"sha": "1a12bb35e01e3a4a266ed2683caa51ff4fac0a2b", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -51,6 +51,8 @@ static bool gimple_simplify (gimple_match_op *, gimple_seq *, tree (*)(tree),\n \t\t\t     code_helper, tree, tree, tree);\n static bool gimple_simplify (gimple_match_op *, gimple_seq *, tree (*)(tree),\n \t\t\t     code_helper, tree, tree, tree, tree);\n+static bool gimple_simplify (gimple_match_op *, gimple_seq *, tree (*)(tree),\n+\t\t\t     code_helper, tree, tree, tree, tree, tree);\n \n const unsigned int gimple_match_op::MAX_NUM_OPS;\n \n@@ -215,6 +217,30 @@ gimple_resimplify3 (gimple_seq *seq, gimple_match_op *res_op,\n   return canonicalized;\n }\n \n+/* Helper that matches and simplifies the toplevel result from\n+   a gimple_simplify run (where we don't want to build\n+   a stmt in case it's used in in-place folding).  Replaces\n+   RES_OP with a simplified and/or canonicalized result and\n+   returns whether any change was made.  */\n+\n+bool\n+gimple_resimplify4 (gimple_seq *seq, gimple_match_op *res_op,\n+\t\t    tree (*valueize)(tree))\n+{\n+  /* No constant folding is defined for four-operand functions.  */\n+\n+  gimple_match_op res_op2 (*res_op);\n+  if (gimple_simplify (&res_op2, seq, valueize,\n+\t\t       res_op->code, res_op->type,\n+\t\t       res_op->ops[0], res_op->ops[1], res_op->ops[2],\n+\t\t       res_op->ops[3]))\n+    {\n+      *res_op = res_op2;\n+      return true;\n+    }\n+\n+  return false;\n+}\n \n /* If in GIMPLE the operation described by RES_OP should be single-rhs,\n    build a GENERIC tree for that expression and update RES_OP accordingly.  */\n@@ -256,7 +282,8 @@ build_call_internal (internal_fn fn, gimple_match_op *res_op)\n   return gimple_build_call_internal (fn, res_op->num_ops,\n \t\t\t\t     res_op->op_or_null (0),\n \t\t\t\t     res_op->op_or_null (1),\n-\t\t\t\t     res_op->op_or_null (2));\n+\t\t\t\t     res_op->op_or_null (2),\n+\t\t\t\t     res_op->op_or_null (3));\n }\n \n /* Push the exploded expression described by RES_OP as a statement to\n@@ -343,7 +370,8 @@ maybe_push_res_to_seq (gimple_match_op *res_op, gimple_seq *seq, tree res)\n \t  new_stmt = gimple_build_call (decl, num_ops,\n \t\t\t\t\tres_op->op_or_null (0),\n \t\t\t\t\tres_op->op_or_null (1),\n-\t\t\t\t\tres_op->op_or_null (2));\n+\t\t\t\t\tres_op->op_or_null (2),\n+\t\t\t\t\tres_op->op_or_null (3));\n \t}\n       if (!res)\n \t{\n@@ -654,7 +682,7 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n       /* ???  This way we can't simplify calls with side-effects.  */\n       if (gimple_call_lhs (stmt) != NULL_TREE\n \t  && gimple_call_num_args (stmt) >= 1\n-\t  && gimple_call_num_args (stmt) <= 3)\n+\t  && gimple_call_num_args (stmt) <= 4)\n \t{\n \t  bool valueized = false;\n \t  combined_fn cfn;\n@@ -697,6 +725,9 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n \t    case 3:\n \t      return (gimple_resimplify3 (seq, res_op, valueize)\n \t\t      || valueized);\n+\t    case 4:\n+\t      return (gimple_resimplify4 (seq, res_op, valueize)\n+\t\t      || valueized);\n \t    default:\n \t     gcc_unreachable ();\n \t    }"}, {"sha": "69b53f2115703a1cf69c12156dfa03cc8e608f80", "filename": "gcc/gimple-match.h", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fgimple-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fgimple-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match.h?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -49,17 +49,19 @@ struct gimple_match_op\n   gimple_match_op (code_helper, tree, tree);\n   gimple_match_op (code_helper, tree, tree, tree);\n   gimple_match_op (code_helper, tree, tree, tree, tree);\n+  gimple_match_op (code_helper, tree, tree, tree, tree, tree);\n \n   void set_op (code_helper, tree, unsigned int);\n   void set_op (code_helper, tree, tree);\n   void set_op (code_helper, tree, tree, tree);\n   void set_op (code_helper, tree, tree, tree, tree);\n+  void set_op (code_helper, tree, tree, tree, tree, tree);\n   void set_value (tree);\n \n   tree op_or_null (unsigned int) const;\n \n   /* The maximum value of NUM_OPS.  */\n-  static const unsigned int MAX_NUM_OPS = 3;\n+  static const unsigned int MAX_NUM_OPS = 4;\n \n   /* The operation being performed.  */\n   code_helper code;\n@@ -113,6 +115,17 @@ gimple_match_op::gimple_match_op (code_helper code_in, tree type_in,\n   ops[2] = op2;\n }\n \n+inline\n+gimple_match_op::gimple_match_op (code_helper code_in, tree type_in,\n+\t\t\t\t  tree op0, tree op1, tree op2, tree op3)\n+  : code (code_in), type (type_in), num_ops (4)\n+{\n+  ops[0] = op0;\n+  ops[1] = op1;\n+  ops[2] = op2;\n+  ops[3] = op3;\n+}\n+\n /* Change the operation performed to CODE_IN, the type of the result to\n    TYPE_IN, and the number of operands to NUM_OPS_IN.  The caller needs\n    to set the operands itself.  */\n@@ -160,6 +173,19 @@ gimple_match_op::set_op (code_helper code_in, tree type_in,\n   ops[2] = op2;\n }\n \n+inline void\n+gimple_match_op::set_op (code_helper code_in, tree type_in,\n+\t\t\t tree op0, tree op1, tree op2, tree op3)\n+{\n+  code = code_in;\n+  type = type_in;\n+  num_ops = 4;\n+  ops[0] = op0;\n+  ops[1] = op1;\n+  ops[2] = op2;\n+  ops[3] = op3;\n+}\n+\n /* Set the \"operation\" to be the single value VALUE, such as a constant\n    or SSA_NAME.  */\n \n@@ -196,6 +222,7 @@ bool gimple_simplify (gimple *, gimple_match_op *, gimple_seq *,\n bool gimple_resimplify1 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n bool gimple_resimplify2 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n bool gimple_resimplify3 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n+bool gimple_resimplify4 (gimple_seq *, gimple_match_op *, tree (*)(tree));\n tree maybe_push_res_to_seq (gimple_match_op *, gimple_seq *,\n \t\t\t    tree res = NULL_TREE);\n void maybe_build_generic_op (gimple_match_op *);"}, {"sha": "f08571ef28c6bc95a78f906631341ac92d6b975e", "filename": "gcc/match.pd", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -74,6 +74,16 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (FLOOR)\n DEFINE_INT_AND_FLOAT_ROUND_FN (CEIL)\n DEFINE_INT_AND_FLOAT_ROUND_FN (ROUND)\n DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n+\n+/* Binary operations and their associated IFN_COND_* function.  */\n+(define_operator_list UNCOND_BINARY\n+  plus minus\n+  min max\n+  bit_and bit_ior bit_xor)\n+(define_operator_list COND_BINARY\n+  IFN_COND_ADD IFN_COND_SUB\n+  IFN_COND_MIN IFN_COND_MAX\n+  IFN_COND_AND IFN_COND_IOR IFN_COND_XOR)\n     \n /* As opposed to convert?, this still creates a single pattern, so\n    it is not a suitable replacement for convert? in all cases.  */\n@@ -4780,3 +4790,28 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n     (simplify\n       (cmp (popcount @0) integer_zerop)\n       (rep @0 { build_zero_cst (TREE_TYPE (@0)); }))))\n+\n+/* Simplify:\n+\n+     a = a1 op a2\n+     r = c ? a : b;\n+\n+   to:\n+\n+     r = c ? a1 op a2 : b;\n+\n+   if the target can do it in one go.  This makes the operation conditional\n+   on c, so could drop potentially-trapping arithmetic, but that's a valid\n+   simplification if the result of the operation isn't needed.  */\n+(for uncond_op (UNCOND_BINARY)\n+     cond_op (COND_BINARY)\n+ (simplify\n+  (vec_cond @0 (view_convert? (uncond_op@4 @1 @2)) @3)\n+  (with { tree op_type = TREE_TYPE (@4); }\n+   (if (element_precision (type) == element_precision (op_type))\n+    (view_convert (cond_op @0 @1 @2 (view_convert:op_type @3))))))\n+ (simplify\n+  (vec_cond @0 @1 (view_convert? (uncond_op@4 @2 @3)))\n+  (with { tree op_type = TREE_TYPE (@4); }\n+   (if (element_precision (type) == element_precision (op_type))\n+    (view_convert (cond_op (bit_not @0) @2 @3 (view_convert:op_type @1)))))))"}, {"sha": "c5b2c631b5d8c70b78bec00191412d16f7c62324", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -1,3 +1,15 @@\n+2018-05-25  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_vect_double_cond_arith): New proc.\n+\t* gcc.dg/vect/vect-cond-arith-1.c: New test.\n+\t* gcc.target/aarch64/sve/vcond_8.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_8_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_9.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_9_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_12.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_12_run.c: Likewise.\n+\n 2018-05-25  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/85839"}, {"sha": "9f2fccd7187b39706266525e87105ab073122620", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-arith-1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-1.c?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-additional-options \"-fdump-tree-optimized -fno-trapping-math -ffinite-math-only\" } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS * 11 / 64 + 3)\n+\n+#define add(A, B) ((A) + (B))\n+#define sub(A, B) ((A) - (B))\n+\n+#define DEF(OP)\t\t\t\t\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\t\\\n+  f_##OP (double *restrict a, double *restrict b, double x)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tdouble truev = OP (b[i], x);\t\t\t\t\\\n+\ta[i] = b[i] < 100 ? truev : b[i];\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST(OP)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    f_##OP (a, b, 10);\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tint bval = (i % 17) * 10;\t\t\t\\\n+\tint truev = OP (bval, 10);\t\t\t\\\n+\tif (a[i] != (bval < 100 ? truev : bval))\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_OP(T)\t\t\t\t\\\n+  T (add)\t\t\t\t\t\\\n+  T (sub)\t\t\t\t\t\\\n+  T (__builtin_fmax)\t\t\t\t\\\n+  T (__builtin_fmin)\n+\n+FOR_EACH_OP (DEF)\n+\n+int\n+main (void)\n+{\n+  double a[N], b[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      b[i] = (i % 17) * 10;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  FOR_EACH_OP (TEST)\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump { = \\.COND_ADD} \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump { = \\.COND_SUB} \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump { = \\.COND_MAX} \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump { = \\.COND_MIN} \"optimized\" { target vect_double_cond_arith } } } */"}, {"sha": "95b371a177358ded0c3a1f1cad5ba5edb5497697", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_12.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_12.c?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -0,0 +1,125 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include <stdint.h>\n+\n+#define add(A, B) ((A) + (B))\n+#define sub(A, B) ((A) - (B))\n+#define max(A, B) ((A) > (B) ? (A) : (B))\n+#define min(A, B) ((A) < (B) ? (A) : (B))\n+#define and(A, B) ((A) & (B))\n+#define ior(A, B) ((A) | (B))\n+#define xor(A, B) ((A) ^ (B))\n+\n+#define N 121\n+\n+#define DEF_LOOP(TYPE, CMPTYPE, OP)\t\t\t\t\\\n+  void __attribute__((noipa))\t\t\t\t\t\\\n+  f_##OP##_##TYPE (TYPE *restrict dest, CMPTYPE *restrict cond,\t\\\n+\t\t   CMPTYPE limit, TYPE src2v, TYPE elsev)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE induc = 0;\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N; ++i, induc += 1)\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE truev = OP (induc, src2v);\t\t\t\t\\\n+\tdest[i] = cond[i] < limit ? truev : elsev;\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_INT_TYPE(T, TYPE) \\\n+  T (TYPE, TYPE, add) \\\n+  T (TYPE, TYPE, sub) \\\n+  T (TYPE, TYPE, max) \\\n+  T (TYPE, TYPE, min) \\\n+  T (TYPE, TYPE, and) \\\n+  T (TYPE, TYPE, ior) \\\n+  T (TYPE, TYPE, xor)\n+\n+#define FOR_EACH_FP_TYPE(T, TYPE, CMPTYPE, SUFFIX) \\\n+  T (TYPE, CMPTYPE, add) \\\n+  T (TYPE, CMPTYPE, sub) \\\n+  T (TYPE, CMPTYPE, __builtin_fmax##SUFFIX) \\\n+  T (TYPE, CMPTYPE, __builtin_fmin##SUFFIX)\n+\n+#define FOR_EACH_LOOP(T) \\\n+  FOR_EACH_INT_TYPE (T, int8_t) \\\n+  FOR_EACH_INT_TYPE (T, int16_t) \\\n+  FOR_EACH_INT_TYPE (T, int32_t) \\\n+  FOR_EACH_INT_TYPE (T, int64_t) \\\n+  FOR_EACH_INT_TYPE (T, uint8_t) \\\n+  FOR_EACH_INT_TYPE (T, uint16_t) \\\n+  FOR_EACH_INT_TYPE (T, uint32_t) \\\n+  FOR_EACH_INT_TYPE (T, uint64_t) \\\n+  FOR_EACH_FP_TYPE (T, _Float16, uint16_t, f16) \\\n+  FOR_EACH_FP_TYPE (T, float, float, f32) \\\n+  FOR_EACH_FP_TYPE (T, double, double, f64)\n+\n+FOR_EACH_LOOP (DEF_LOOP)\n+\n+/* { dg-final { scan-assembler-not {\\tmov\\tz[0-9]+\\.., z[0-9]+} } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsel\\tz[0-9]+\\.b,} 14 } } */\n+/* { dg-final { scan-assembler-times {\\tsel\\tz[0-9]+\\.h,} 18 } } */\n+/* { dg-final { scan-assembler-times {\\tsel\\tz[0-9]+\\.s,} 18 } } */\n+/* { dg-final { scan-assembler-times {\\tsel\\tz[0-9]+\\.d,} 18 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmaxnm\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfmaxnm\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfmaxnm\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfminnm\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfminnm\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfminnm\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */"}, {"sha": "50a98c84a59f18c2cb073d2cc2a07408f94fba73", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_12_run.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_12_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_12_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_12_run.c?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include \"vcond_12.c\"\n+\n+#define TEST_LOOP(TYPE, CMPTYPE, OP)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE dest[N];\t\t\t\t\t\t\\\n+    CMPTYPE cond[N];\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N; ++i)\t\t\t\\\n+      cond[i] = i % 5;\t\t\t\t\t\t\\\n+    TYPE src2v = 14;\t\t\t\t\t\t\\\n+    TYPE elsev = 17;\t\t\t\t\t\t\\\n+    f_##OP##_##TYPE (dest, cond, 3, src2v, elsev);\t\t\\\n+    TYPE induc = 0;\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE if_true = OP (induc, src2v);\t\t\t\\\n+\tif (dest[i] != (i % 5 < 3 ? if_true : elsev))\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+\tinduc += 1;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  FOR_EACH_LOOP (TEST_LOOP);\n+  return 0;\n+}"}, {"sha": "c32ab5967169d0b4ab04d02945f7bb1a1bd3d22e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_8.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_8.c?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -0,0 +1,119 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-trapping-math -ffinite-math-only\" } */\n+\n+#include <stdint.h>\n+\n+#define add(A, B) ((A) + (B))\n+#define sub(A, B) ((A) - (B))\n+#define max(A, B) ((A) > (B) ? (A) : (B))\n+#define min(A, B) ((A) < (B) ? (A) : (B))\n+#define and(A, B) ((A) & (B))\n+#define ior(A, B) ((A) | (B))\n+#define xor(A, B) ((A) ^ (B))\n+\n+#define DEF_LOOP(TYPE, CMPTYPE, OP)\t\t\t\t\\\n+  void __attribute__((noipa))\t\t\t\t\t\\\n+  f_##OP##_##TYPE (TYPE *restrict dest, CMPTYPE *restrict cond,\t\\\n+\t\t   CMPTYPE limit, TYPE *restrict src,\t\t\\\n+\t\t   TYPE val, unsigned int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < n; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE truev = OP (src[i], val);\t\t\t\t\\\n+\tdest[i] = cond[i] < limit ? truev : src[i];\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_INT_TYPE(T, TYPE) \\\n+  T (TYPE, TYPE, add) \\\n+  T (TYPE, TYPE, sub) \\\n+  T (TYPE, TYPE, max) \\\n+  T (TYPE, TYPE, min) \\\n+  T (TYPE, TYPE, and) \\\n+  T (TYPE, TYPE, ior) \\\n+  T (TYPE, TYPE, xor)\n+\n+#define FOR_EACH_FP_TYPE(T, TYPE, CMPTYPE, SUFFIX) \\\n+  T (TYPE, CMPTYPE, add) \\\n+  T (TYPE, CMPTYPE, sub) \\\n+  T (TYPE, CMPTYPE, __builtin_fmax##SUFFIX) \\\n+  T (TYPE, CMPTYPE, __builtin_fmin##SUFFIX)\n+\n+#define FOR_EACH_LOOP(T) \\\n+  FOR_EACH_INT_TYPE (T, int8_t) \\\n+  FOR_EACH_INT_TYPE (T, int16_t) \\\n+  FOR_EACH_INT_TYPE (T, int32_t) \\\n+  FOR_EACH_INT_TYPE (T, int64_t) \\\n+  FOR_EACH_INT_TYPE (T, uint8_t) \\\n+  FOR_EACH_INT_TYPE (T, uint16_t) \\\n+  FOR_EACH_INT_TYPE (T, uint32_t) \\\n+  FOR_EACH_INT_TYPE (T, uint64_t) \\\n+  FOR_EACH_FP_TYPE (T, _Float16, uint16_t, f16) \\\n+  FOR_EACH_FP_TYPE (T, float, float, f32) \\\n+  FOR_EACH_FP_TYPE (T, double, double, f64)\n+\n+FOR_EACH_LOOP (DEF_LOOP)\n+\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tmov\\tz[0-9]+\\.., z[0-9]+} } } */\n+\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmaxnm\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfmaxnm\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfmaxnm\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfminnm\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfminnm\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfminnm\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */"}, {"sha": "5f45e1667d36320d1ed140c8e228bd689156a24b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_8_run.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_8_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_8_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_8_run.c?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-trapping-math -ffinite-math-only\" } */\n+\n+#include \"vcond_8.c\"\n+\n+#define N 187\n+\n+#define TEST_LOOP(TYPE, CMPTYPE, OP)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE dest[N], src[N];\t\t\t\t\t\\\n+    CMPTYPE cond[N];\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        src[i] = i * 3;\t\t\t\t\t\t\\\n+\tcond[i] = i % 5;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    f_##OP##_##TYPE (dest, cond, 3, src, 77, N);\t\t\\\n+    for (unsigned int i = 0; i < N; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        TYPE if_false = i * 3;\t\t\t\t\t\\\n+\tTYPE if_true = OP (if_false, (TYPE) 77);\t\t\\\n+\tif (dest[i] != (i % 5 < 3 ? if_true : if_false))\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  FOR_EACH_LOOP (TEST_LOOP);\n+  return 0;\n+}"}, {"sha": "618e187d5872072424ac12773e6139171ced9c34", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_9.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_9.c?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -0,0 +1,119 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-trapping-math -ffinite-math-only\" } */\n+\n+#include <stdint.h>\n+\n+#define add(A, B) ((A) + (B))\n+#define sub(A, B) ((A) - (B))\n+#define max(A, B) ((A) > (B) ? (A) : (B))\n+#define min(A, B) ((A) < (B) ? (A) : (B))\n+#define and(A, B) ((A) & (B))\n+#define ior(A, B) ((A) | (B))\n+#define xor(A, B) ((A) ^ (B))\n+\n+#define DEF_LOOP(TYPE, CMPTYPE, OP)\t\t\t\t\\\n+  void __attribute__((noipa))\t\t\t\t\t\\\n+  f_##OP##_##TYPE (TYPE *restrict dest, CMPTYPE *restrict cond,\t\\\n+\t\t   CMPTYPE limit, TYPE *restrict src1,\t\t\\\n+\t\t   TYPE *restrict src2, unsigned int n)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < n; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE truev = OP (src1[i], src2[i]);\t\t\t\\\n+\tdest[i] = cond[i] < limit ? truev : src2[i];\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_INT_TYPE(T, TYPE) \\\n+  T (TYPE, TYPE, add) \\\n+  T (TYPE, TYPE, sub) \\\n+  T (TYPE, TYPE, max) \\\n+  T (TYPE, TYPE, min) \\\n+  T (TYPE, TYPE, and) \\\n+  T (TYPE, TYPE, ior) \\\n+  T (TYPE, TYPE, xor)\n+\n+#define FOR_EACH_FP_TYPE(T, TYPE, CMPTYPE, SUFFIX) \\\n+  T (TYPE, CMPTYPE, add) \\\n+  T (TYPE, CMPTYPE, sub) \\\n+  T (TYPE, CMPTYPE, __builtin_fmax##SUFFIX) \\\n+  T (TYPE, CMPTYPE, __builtin_fmin##SUFFIX)\n+\n+#define FOR_EACH_LOOP(T) \\\n+  FOR_EACH_INT_TYPE (T, int8_t) \\\n+  FOR_EACH_INT_TYPE (T, int16_t) \\\n+  FOR_EACH_INT_TYPE (T, int32_t) \\\n+  FOR_EACH_INT_TYPE (T, int64_t) \\\n+  FOR_EACH_INT_TYPE (T, uint8_t) \\\n+  FOR_EACH_INT_TYPE (T, uint16_t) \\\n+  FOR_EACH_INT_TYPE (T, uint32_t) \\\n+  FOR_EACH_INT_TYPE (T, uint64_t) \\\n+  FOR_EACH_FP_TYPE (T, _Float16, uint16_t, f16) \\\n+  FOR_EACH_FP_TYPE (T, float, float, f32) \\\n+  FOR_EACH_FP_TYPE (T, double, double, f64)\n+\n+FOR_EACH_LOOP (DEF_LOOP)\n+\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tmov\\tz[0-9]+\\.., z[0-9]+} } } */\n+\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsubr\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tsubr\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tsubr\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tsubr\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmax\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.b, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.b, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.h, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.s, p[0-7]/m,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, p[0-7]/m,} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfsubr\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfsubr\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfsubr\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmaxnm\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfmaxnm\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfmaxnm\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfminnm\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfminnm\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfminnm\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */"}, {"sha": "14f32420e1ef3bdf9c4cbff41f45f878613b127d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_9_run.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_9_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_9_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_9_run.c?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-trapping-math -ffinite-math-only\" } */\n+\n+#include \"vcond_9.c\"\n+\n+#define N 187\n+\n+#define TEST_LOOP(TYPE, CMPTYPE, OP)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE dest[N], src1[N], src2[N];\t\t\t\t\\\n+    CMPTYPE cond[N];\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        src1[i] = i * 4 - i % 7;\t\t\t\t\\\n+        src2[i] = i * 3 + 1;\t\t\t\t\t\\\n+\tcond[i] = i % 5;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    f_##OP##_##TYPE (dest, cond, 3, src1, src2, N);\t\t\\\n+    for (unsigned int i = 0; i < N; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE src1v = i * 4 - i % 7;\t\t\t\t\\\n+        TYPE src2v = i * 3 + 1;\t\t\t\t\t\\\n+\tTYPE if_true = OP (src1v, src2v);\t\t\t\\\n+\tif (dest[i] != (i % 5 < 3 ? if_true : src2v))\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  FOR_EACH_LOOP (TEST_LOOP);\n+  return 0;\n+}"}, {"sha": "0f8edce69bf944b043cdff562a9757afa330d413", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2b3bca81acf226e6c10defbc6072de4cf7e75c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "patch": "@@ -5590,6 +5590,13 @@ proc check_effective_target_vect_double { } {\n     return $et_vect_double_saved($et_index)\n }\n \n+# Return 1 if the target supports conditional addition, subtraction, minimum\n+# and maximum on vectors of double, via the cond_ optabs.  Return 0 otherwise.\n+\n+proc check_effective_target_vect_double_cond_arith { } {\n+    return [check_effective_target_aarch64_sve]\n+}\n+\n # Return 1 if the target supports hardware vectors of long long, 0 otherwise.\n #\n # This won't change for different subtargets so cache the result."}]}