{"sha": "ad00a297ec4236b327430c171dfbe7587901ffd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQwMGEyOTdlYzQyMzZiMzI3NDMwYzE3MWRmYmU3NTg3OTAxZmZkNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-09T20:01:24Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-09T20:14:04Z"}, "message": "Small housekeeping work in gigi\n\nNo functional changes.\n\n\t* gcc-interface/gigi.h (change_qualified_type): Move around.\n\t(maybe_vector_array): Likewise.\n\t(maybe_padded_object): New static line function.\n\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Component_Size>:\n\tRemove useless code.\n\t<Attr_Null_Parameter>: Remove obsolete code.\n\t(Call_to_gn): Likewise.  Use maybe_padded_object to remove padding.\n\t(gnat_to_gnu): Likewise.\n\t<N_String_Literal>: Do not add a useless null character at the end.\n\t<N_Indexed_Component>: Likewise and remove obsolete code.\n\t(add_decl_expr): Likewise.\n\t(maybe_implicit_deref): Likewise.\n\t* gcc-interface/utils.c (maybe_unconstrained_array): Likewise.\n\t* gcc-interface/utils2.c (gnat_invariant_expr): Likewise.", "tree": {"sha": "4b41900f1bb918b06dad4b1004ad185a12002bd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b41900f1bb918b06dad4b1004ad185a12002bd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad00a297ec4236b327430c171dfbe7587901ffd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad00a297ec4236b327430c171dfbe7587901ffd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad00a297ec4236b327430c171dfbe7587901ffd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad00a297ec4236b327430c171dfbe7587901ffd7/comments", "author": null, "committer": null, "parents": [{"sha": "65ba91b79e1664ba7e7f60f68e4cb956453b692e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65ba91b79e1664ba7e7f60f68e4cb956453b692e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65ba91b79e1664ba7e7f60f68e4cb956453b692e"}], "stats": {"total": 147, "additions": 66, "deletions": 81}, "files": [{"sha": "6fdb3f4a35e1ddb15407636222d4cf8ec776e563", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad00a297ec4236b327430c171dfbe7587901ffd7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad00a297ec4236b327430c171dfbe7587901ffd7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ad00a297ec4236b327430c171dfbe7587901ffd7", "patch": "@@ -1,3 +1,20 @@\n+2020-05-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (change_qualified_type): Move around.\n+\t(maybe_vector_array): Likewise.\n+\t(maybe_padded_object): New static line function.\n+\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Component_Size>:\n+\tRemove useless code.\n+\t<Attr_Null_Parameter>: Remove obsolete code.\n+\t(Call_to_gn): Likewise.  Use maybe_padded_object to remove padding.\n+\t(gnat_to_gnu): Likewise.\n+\t<N_String_Literal>: Do not add a useless null character at the end.\n+\t<N_Indexed_Component>: Likewise and remove obsolete code.\n+\t(add_decl_expr): Likewise.\n+\t(maybe_implicit_deref): Likewise.\n+\t* gcc-interface/utils.c (maybe_unconstrained_array): Likewise.\n+\t* gcc-interface/utils2.c (gnat_invariant_expr): Likewise.\n+\n 2020-05-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils2.c: Include builtins.h."}, {"sha": "c4e9d77e771b6e96c215c7ed2743e9c4a4068586", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad00a297ec4236b327430c171dfbe7587901ffd7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad00a297ec4236b327430c171dfbe7587901ffd7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=ad00a297ec4236b327430c171dfbe7587901ffd7", "patch": "@@ -1065,20 +1065,6 @@ extern void enumerate_modes (void (*f) (const char *, int, int, int, int, int,\n #define gigi_checking_assert(EXPR) \\\n   gcc_checking_assert ((EXPR) || type_annotate_only)\n \n-/* If EXP's type is a VECTOR_TYPE, return EXP converted to the associated\n-   TYPE_REPRESENTATIVE_ARRAY.  */\n-\n-static inline tree\n-maybe_vector_array (tree exp)\n-{\n-  tree etype = TREE_TYPE (exp);\n-\n-  if (VECTOR_TYPE_P (etype))\n-    exp = convert (TYPE_REPRESENTATIVE_ARRAY (etype), exp);\n-\n-  return exp;\n-}\n-\n /* Return the smallest power of 2 larger than X.  */\n \n static inline unsigned HOST_WIDE_INT\n@@ -1144,6 +1130,33 @@ gnat_signed_type_for (tree type_node)\n   return gnat_signed_or_unsigned_type_for (0, type_node);\n }\n \n+/* Like build_qualified_type, but TYPE_QUALS is added to the existing\n+   qualifiers on TYPE.  */\n+\n+static inline tree\n+change_qualified_type (tree type, int type_quals)\n+{\n+  /* Qualifiers must be put on the associated array type.  */\n+  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n+    return type;\n+\n+  return build_qualified_type (type, TYPE_QUALS (type) | type_quals);\n+}\n+\n+/* If EXPR's type is a VECTOR_TYPE, return EXPR converted to the associated\n+   TYPE_REPRESENTATIVE_ARRAY.  */\n+\n+static inline tree\n+maybe_vector_array (tree expr)\n+{\n+  tree type = TREE_TYPE (expr);\n+\n+  if (VECTOR_TYPE_P (type))\n+    expr = convert (TYPE_REPRESENTATIVE_ARRAY (type), expr);\n+\n+  return expr;\n+}\n+\n /* Adjust the character type TYPE if need be.  */\n \n static inline tree\n@@ -1186,15 +1199,15 @@ maybe_debug_type (tree type)\n   return type;\n }\n \n-/* Like build_qualified_type, but TYPE_QUALS is added to the existing\n-   qualifiers on TYPE.  */\n+/* Remove the padding around EXPR if need be.  */\n \n static inline tree\n-change_qualified_type (tree type, int type_quals)\n+maybe_padded_object (tree expr)\n {\n-  /* Qualifiers must be put on the associated array type.  */\n-  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n-    return type;\n+  tree type = TREE_TYPE (expr);\n \n-  return build_qualified_type (type, TYPE_QUALS (type) | type_quals);\n+  if (TYPE_IS_PADDING_P (type))\n+    expr = convert (TREE_TYPE (TYPE_FIELDS (type)), expr);\n+\n+  return expr;\n }"}, {"sha": "20529e157e0571aeab6396eaa06701713f41d9a4", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 12, "deletions": 54, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad00a297ec4236b327430c171dfbe7587901ffd7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad00a297ec4236b327430c171dfbe7587901ffd7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ad00a297ec4236b327430c171dfbe7587901ffd7", "patch": "@@ -2893,10 +2893,6 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       break;\n \n     case Attr_Component_Size:\n-      if (TREE_CODE (gnu_prefix) == COMPONENT_REF\n-\t  && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_prefix, 0))))\n-\tgnu_prefix = TREE_OPERAND (gnu_prefix, 0);\n-\n       gnu_prefix = maybe_implicit_deref (gnu_prefix);\n       gnu_type = TREE_TYPE (gnu_prefix);\n \n@@ -2934,7 +2930,6 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t= build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t  convert (build_pointer_type (gnu_result_type),\n \t\t\t\t   integer_zero_node));\n-      TREE_PRIVATE (gnu_result) = 1;\n       break;\n \n     case Attr_Mechanism_Code:\n@@ -5468,8 +5463,6 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       /* Otherwise the parameter is passed by copy.  */\n       else\n \t{\n-\t  tree gnu_size;\n-\n \t  if (!in_param)\n \t    gnu_name_list = tree_cons (NULL_TREE, gnu_name, gnu_name_list);\n \n@@ -5490,25 +5483,9 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \n \t  gnu_actual = convert (gnu_formal_type, gnu_actual);\n \n-\t  /* If this is 'Null_Parameter, pass a zero even though we are\n-\t     dereferencing it.  */\n-\t  if (TREE_CODE (gnu_actual) == INDIRECT_REF\n-\t      && TREE_PRIVATE (gnu_actual)\n-\t      && (gnu_size = TYPE_SIZE (TREE_TYPE (gnu_actual)))\n-\t      && TREE_CODE (gnu_size) == INTEGER_CST\n-\t      && compare_tree_int (gnu_size, BITS_PER_WORD) <= 0)\n-\t    {\n-\t      tree type_for_size\n-\t\t= gnat_type_for_size (TREE_INT_CST_LOW (gnu_size), 1);\n-\t      gnu_actual\n-\t\t= unchecked_convert (DECL_ARG_TYPE (gnu_formal),\n-\t\t\t\t     build_int_cst (type_for_size, 0),\n-\t\t\t\t     false);\n-\t    }\n-\n \t  /* If this is a front-end built-in function, there is no need to\n \t     convert to the type used to pass the argument.  */\n-\t  else if (!frontend_builtin)\n+\t  if (!frontend_builtin)\n \t    gnu_actual = convert (DECL_ARG_TYPE (gnu_formal), gnu_actual);\n \t}\n \n@@ -5630,11 +5607,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t    tree gnu_actual\n \t      = maybe_unconstrained_array (TREE_VALUE (gnu_name_list));\n \n-\t    /* If the result is a padded type, remove the padding.  */\n-\t    if (TYPE_IS_PADDING_P (TREE_TYPE (gnu_result)))\n-\t      gnu_result\n-\t\t= convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_result))),\n-\t\t\t   gnu_result);\n+\t    /* If the result is padded, remove the padding.  */\n+\t    gnu_result = maybe_padded_object (gnu_result);\n \n \t    /* If the actual is a type conversion, the real target object is\n \t       denoted by the inner Expression and we need to convert the\n@@ -6959,19 +6933,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  int i;\n \t  char *string;\n \t  if (length >= ALLOCA_THRESHOLD)\n-\t    string = XNEWVEC (char, length + 1);\n+\t    string = XNEWVEC (char, length);\n \t  else\n-\t    string = (char *) alloca (length + 1);\n+\t    string = (char *) alloca (length);\n \n \t  /* Build the string with the characters in the literal.  Note\n \t     that Ada strings are 1-origin.  */\n \t  for (i = 0; i < length; i++)\n \t    string[i] = Get_String_Char (gnat_string, i + 1);\n \n-\t  /* Put a null at the end of the string in case it's in a context\n-\t     where GCC will want to treat it as a C string.  */\n-\t  string[i] = 0;\n-\n \t  gnu_result = build_string (length, string);\n \n \t  /* Strings in GCC don't normally have types, but we want\n@@ -7199,6 +7169,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \tNode_Id *gnat_expr_array;\n \n \tgnu_array_object = maybe_implicit_deref (gnu_array_object);\n+\tgnu_array_object = maybe_unconstrained_array (gnu_array_object);\n \n \t/* Convert vector inputs to their representative array type, to fit\n \t   what the code below expects.  */\n@@ -7209,14 +7180,6 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_array_object = maybe_vector_array (gnu_array_object);\n \t  }\n \n-\tgnu_array_object = maybe_unconstrained_array (gnu_array_object);\n-\n-\t/* If we got a padded type, remove it too.  */\n-\tif (TYPE_IS_PADDING_P (TREE_TYPE (gnu_array_object)))\n-\t  gnu_array_object\n-\t    = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_array_object))),\n-\t\t       gnu_array_object);\n-\n \t/* The failure of this assertion will very likely come from a missing\n \t   expansion for a packed array access.  */\n \tgcc_assert (TREE_CODE (TREE_TYPE (gnu_array_object)) == ARRAY_TYPE);\n@@ -8855,9 +8818,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t       && TREE_CODE (TREE_TYPE (gnu_result)) == RECORD_TYPE))\n     {\n       /* Remove any padding.  */\n-      if (TYPE_IS_PADDING_P (TREE_TYPE (gnu_result)))\n-\tgnu_result = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_result))),\n-\t\t\t      gnu_result);\n+      gnu_result = maybe_padded_object (gnu_result);\n     }\n \n   else if (gnu_result == error_mark_node || gnu_result_type == void_type_node)\n@@ -9083,10 +9044,8 @@ add_decl_expr (tree gnu_decl, Node_Id gnat_node)\n \t  DECL_READONLY_ONCE_ELAB (gnu_decl) = 1;\n \t}\n \n-      /* If GNU_DECL has a padded type, convert it to the unpadded\n-\t type so the assignment is done properly.  */\n-      if (TYPE_IS_PADDING_P (type))\n-\tgnu_decl = convert (TREE_TYPE (TYPE_FIELDS (type)), gnu_decl);\n+      /* Remove any padding so the assignment is done properly.  */\n+      gnu_decl = maybe_padded_object (gnu_decl);\n \n       gnu_stmt = build_binary_op (INIT_EXPR, NULL_TREE, gnu_decl, gnu_init);\n       add_stmt_with_node (gnu_stmt, gnat_node);\n@@ -10806,14 +10765,13 @@ adjust_for_implicit_deref (Node_Id exp)\n static tree\n maybe_implicit_deref (tree exp)\n {\n-  /* If the type is a pointer, dereference it.  */\n+  /* If the object is a pointer, dereference it.  */\n   if (POINTER_TYPE_P (TREE_TYPE (exp))\n       || TYPE_IS_FAT_POINTER_P (TREE_TYPE (exp)))\n     exp = build_unary_op (INDIRECT_REF, NULL_TREE, exp);\n \n-  /* If we got a padded type, remove it too.  */\n-  if (TYPE_IS_PADDING_P (TREE_TYPE (exp)))\n-    exp = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (exp))), exp);\n+  /* If the object is padded, remove the padding.  */\n+  exp = maybe_padded_object (exp);\n \n   return exp;\n }"}, {"sha": "9dd08e2f02c1d621f47878013ab5a3b757479ffd", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad00a297ec4236b327430c171dfbe7587901ffd7/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad00a297ec4236b327430c171dfbe7587901ffd7/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=ad00a297ec4236b327430c171dfbe7587901ffd7", "patch": "@@ -5257,11 +5257,9 @@ maybe_unconstrained_array (tree exp)\n \n \t  exp = build_component_ref (exp, DECL_CHAIN (TYPE_FIELDS (type)),\n \t\t\t\t     false);\n-\t  type = TREE_TYPE (exp);\n \n-\t  /* If the array type is padded, convert to the unpadded type.  */\n-\t  if (TYPE_IS_PADDING_P (type))\n-\t    exp = convert (TREE_TYPE (TYPE_FIELDS (type)), exp);\n+\t  /* If the array is padded, remove the padding.  */\n+\t  exp = maybe_padded_object (exp);\n \t}\n       break;\n "}, {"sha": "2ff865434b97f37b79ea5b5db2e8f496ace09cef", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad00a297ec4236b327430c171dfbe7587901ffd7/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad00a297ec4236b327430c171dfbe7587901ffd7/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=ad00a297ec4236b327430c171dfbe7587901ffd7", "patch": "@@ -2934,8 +2934,7 @@ gnat_invariant_expr (tree expr)\n     {\n       expr = DECL_INITIAL (expr);\n       /* Look into CONSTRUCTORs built to initialize padded types.  */\n-      if (TYPE_IS_PADDING_P (TREE_TYPE (expr)))\n-\texpr = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (expr))), expr);\n+      expr = maybe_padded_object (expr);\n       expr = remove_conversions (expr, false);\n     }\n "}]}