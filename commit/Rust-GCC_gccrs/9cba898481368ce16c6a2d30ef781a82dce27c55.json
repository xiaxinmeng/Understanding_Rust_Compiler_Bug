{"sha": "9cba898481368ce16c6a2d30ef781a82dce27c55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNiYTg5ODQ4MTM2OGNlMTZjNmEyZDMwZWY3ODFhODJkY2UyN2M1NQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-07-13T17:33:47Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-07-13T17:33:47Z"}, "message": "x86: Pass a copy of the string length to cmpstrnqi\n\ncmpstrnsi expander may pass the actual string length directly to cmpstrnqi\npatterns.  For cmpstrnsi, one of the strings must be a constant and\nexpand_builtin_strncmp rewrites the length argument to be the minimum of\nthe const string length and the actual string length.  But it is not the\ncase for cmpmemsi.  Pass a copy of the string length to cmpstrnqi patterns\nto avoid changing the actual string length by cmpstrnqi patterns.\n\ngcc/\n\n\tPR target/95443\n\t* config/i386/i386.md (cmpstrnsi): Pass a copy of the string\n\tlength to cmpstrnqi patterns.\n\ngcc/testsuite/\n\n\tPR target/95443\n\t* gcc.target/i386/pr95443-1.c: New test.\n\t* gcc.target/i386/pr95443-2.c: Likewise.", "tree": {"sha": "6d44bf71c40e5f79feed433195185d8977b966d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d44bf71c40e5f79feed433195185d8977b966d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cba898481368ce16c6a2d30ef781a82dce27c55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cba898481368ce16c6a2d30ef781a82dce27c55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cba898481368ce16c6a2d30ef781a82dce27c55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cba898481368ce16c6a2d30ef781a82dce27c55/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a9a3434c7396ea14c8f9c291694faea382c36dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a9a3434c7396ea14c8f9c291694faea382c36dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a9a3434c7396ea14c8f9c291694faea382c36dc"}], "stats": {"total": 215, "additions": 214, "deletions": 1}, "files": [{"sha": "b24a45578714f3a40f1e488e26d4910326d340bd", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cba898481368ce16c6a2d30ef781a82dce27c55/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cba898481368ce16c6a2d30ef781a82dce27c55/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9cba898481368ce16c6a2d30ef781a82dce27c55", "patch": "@@ -18057,7 +18057,11 @@\n   if (addr2 != XEXP (operands[2], 0))\n     operands[2] = replace_equiv_address_nv (operands[2], addr2);\n \n-  countreg = ix86_zero_extend_to_Pmode (operands[3]);\n+  /* NB: Make a copy of the data length to avoid changing the original\n+     data length by cmpstrnqi patterns.  */\n+  rtx count = ix86_zero_extend_to_Pmode (operands[3]);\n+  countreg = gen_reg_rtx (Pmode);\n+  emit_move_insn (countreg, count);\n \n   /* %%% Iff we are testing strict equality, we can use known alignment\n      to good advantage.  This may be possible with combine, particularly"}, {"sha": "292ff16afddcd9cebe5bacf2025feb22e4ce0371", "filename": "gcc/testsuite/gcc.target/i386/pr95443-1.c", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cba898481368ce16c6a2d30ef781a82dce27c55/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95443-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cba898481368ce16c6a2d30ef781a82dce27c55/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95443-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95443-1.c?ref=9cba898481368ce16c6a2d30ef781a82dce27c55", "patch": "@@ -0,0 +1,130 @@\n+/* { dg-do run { target mmap } } */\n+/* { dg-options \"-O2 -minline-all-stringops\" } */\n+\n+#include <stdint.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <sys/mman.h>\n+#ifndef MAP_ANON\n+#define MAP_ANON 0\n+#endif\n+#ifndef MAP_FAILED\n+#define MAP_FAILED ((void *)-1)\n+#endif\n+\n+uint8_t shift[256];\n+\n+static size_t\n+__attribute__ ((noclone, noinline))\n+hash2(const unsigned char *p)\n+{\n+  return (((size_t)(p)[0] - ((size_t)(p)[-1] << 3)) % sizeof (shift));\n+}\n+\n+char *\n+simple_strstr (const char *haystack, const char *needle)\n+{\n+  const unsigned char *hs = (const unsigned char *) haystack;\n+  const unsigned char *ne = (const unsigned char *) needle;\n+  size_t ne_len = strlen ((const char*)ne);\n+  size_t hs_len = strnlen ((const char*)hs, ne_len | 512);\n+\n+  if (hs_len < ne_len)\n+    return NULL;\n+\n+  if (memcmp (hs, ne, ne_len) == 0)\n+    return (char *) hs;\n+\n+  const unsigned char *end = hs + hs_len - ne_len;\n+  size_t tmp, shift1;\n+  size_t m1 = ne_len - 1;\n+  size_t offset = 0;\n+\n+  memset (shift, 0, sizeof (shift));\n+  for (int i = 1; i < m1; i++)\n+    shift[hash2 (ne + i)] = i;\n+  shift1 = m1 - shift[hash2 (ne + m1)];\n+  shift[hash2 (ne + m1)] = m1;\n+\n+  while (1)\n+    {\n+      if (__glibc_unlikely (hs > end))\n+\t{\n+\t  end += strnlen ((const char*)end + m1 + 1, 2048);\n+\t  if (hs > end)\n+\t    return NULL;\n+\t}\n+\n+      do\n+\t{\n+\t  hs += m1;\n+\t  tmp = shift[hash2 (hs)];\n+\t}\n+      while (tmp == 0 && hs <= end);\n+\n+      hs -= tmp;\n+      if (tmp < m1)\n+\tcontinue;\n+\n+      if (m1 < 15 || memcmp (hs + offset, ne + offset, 8) == 0)\n+\t{\n+\t  if (memcmp (hs, ne, m1) == 0)\n+\t    return (void *) hs;\n+\n+\t  offset = (offset >= 8 ? offset : m1) - 8;\n+\t}\n+\n+      hs += shift1;\n+    }\n+}\n+\n+static int\n+check_result (const char *s1, const char *s2,\n+\t      char *exp_result)\n+{\n+  char *result = simple_strstr (s1, s2);\n+  if (result != exp_result)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+void\n+__attribute__ ((noclone, noinline))\n+check1 (void)\n+{\n+  const char s1[] =\n+    \"F_BD_CE_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_C3_88_20_EF_BF_BD_EF_BF_BD_EF_BF_BD_C3_A7_20_EF_BF_BD\";\n+  const char s2[] = \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n+  char *exp_result;\n+\n+  exp_result = simple_strstr (s1, s2);\n+  if (check_result (s1, s2, exp_result) != 0)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  unsigned char *buf1, *buf2;\n+  size_t page_size = 2 * sysconf(_SC_PAGESIZE);\n+  buf1 = mmap (0, (1 + 1) * page_size, PROT_READ | PROT_WRITE,\n+\t       MAP_PRIVATE | MAP_ANON, -1, 0);\n+  if (buf1 == MAP_FAILED)\n+    return -1;\n+  if (mprotect (buf1 + 1 * page_size, page_size, PROT_NONE))\n+    return -1;\n+  buf2 = mmap (0, 2 * page_size, PROT_READ | PROT_WRITE,\n+\t       MAP_PRIVATE | MAP_ANON, -1, 0);\n+  if (buf2 == MAP_FAILED)\n+    return -1;\n+  if (mprotect (buf2 + page_size, page_size, PROT_NONE))\n+    return -1;\n+\n+  memset (buf1, 0xa5, 1 * page_size);\n+  memset (buf2, 0x5a, page_size);\n+\n+  check1 ();\n+  return 0;\n+}"}, {"sha": "23bb13ab7ff111abc0d427e71a3d8907072941a7", "filename": "gcc/testsuite/gcc.target/i386/pr95443-2.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cba898481368ce16c6a2d30ef781a82dce27c55/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95443-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cba898481368ce16c6a2d30ef781a82dce27c55/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95443-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95443-2.c?ref=9cba898481368ce16c6a2d30ef781a82dce27c55", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-do run { target mmap } } */\n+/* { dg-options \"-O2 -minline-all-stringops\" } */\n+\n+#include <stdint.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <sys/mman.h>\n+#ifndef MAP_ANON\n+#define MAP_ANON 0\n+#endif\n+#ifndef MAP_FAILED\n+#define MAP_FAILED ((void *)-1)\n+#endif\n+\n+int ret;\n+\n+static void\n+do_one_test (char *dst, char *src, const char *orig_src, unsigned int len)\n+{\n+  __builtin_memcpy (src, orig_src, len);\n+  __builtin_memmove (dst, src, len);\n+\n+  if (__builtin_memcmp (dst, orig_src, len) != 0)\n+    {\n+      ret = 1;\n+      return;\n+    }\n+}\n+\n+void\n+do_test (char *s1, char *s2, int n, unsigned int len)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    do_one_test (s2, s2, s1, len);\n+}\n+\n+int\n+main (void)\n+{\n+  unsigned char *buf1, *buf2;\n+  size_t page_size = 2 * sysconf(_SC_PAGESIZE);\n+\n+  buf1 = mmap (0, (1 + 1) * page_size, PROT_READ | PROT_WRITE,\n+\t       MAP_PRIVATE | MAP_ANON, -1, 0);\n+  if (buf1 == MAP_FAILED)\n+    return -1;\n+  if (mprotect (buf1 + 1 * page_size, page_size, PROT_NONE))\n+    return -1;\n+  buf2 = mmap (0, 2 * page_size, PROT_READ | PROT_WRITE,\n+\t       MAP_PRIVATE | MAP_ANON, -1, 0);\n+  if (buf2 == MAP_FAILED)\n+    return -1;\n+  if (mprotect (buf2 + page_size, page_size, PROT_NONE))\n+    return -1;\n+\n+  memset (buf1, 0xa5, 1 * page_size);\n+  memset (buf2, 0x5a, page_size);\n+\n+  char *s1 = (char *) buf1;\n+  char *s2 = (char *) buf2;\n+\n+  size_t len;\n+  size_t i, j;\n+  len = 1 << 2;\n+  for (i = 0, j = 1; i < len; i++, j += 23)\n+    s1[i] = j;\n+\n+  do_test (s1, s2, 10, 1 << 2);\n+\n+  len = 1 << 4;\n+  for (i = 0, j = 1; i < len; i++, j += 23)\n+    s1[i] = j;\n+\n+  do_test (s1, s2, 10, 1 << 4);\n+\n+  return ret;\n+}"}]}