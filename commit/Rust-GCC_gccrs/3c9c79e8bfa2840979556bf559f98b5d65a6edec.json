{"sha": "3c9c79e8bfa2840979556bf559f98b5d65a6edec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M5Yzc5ZThiZmEyODQwOTc5NTU2YmY1NTlmOThiNWQ2NWE2ZWRlYw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-06-14T07:52:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-06-14T07:52:32Z"}, "message": "tree-vrp.c (VR_INITIALIZER): New define.\n\n2012-06-14  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (VR_INITIALIZER): New define.\n\t(ranges_from_anti_range): New function.\n\t(extract_range_from_binary_expr_1): Decompose operations on\n\tVR_ANTI_RANGEs to operations on VR_RANGE.\n\t(extract_range_from_unary_expr_1): Likewise.\n\t(extract_range_from_binary_expr_1, extract_range_from_binary_expr,\n\textract_range_from_unary_expr_1, extract_range_from_unary_expr,\n\textract_range_from_cond_expr, adjust_range_with_scev,\n\tvrp_visit_assignment_or_call, vrp_visit_phi_node,\n\tsimplify_bit_ops_using_ranges): Use VR_INITIALIZER.\n\nFrom-SVN: r188551", "tree": {"sha": "b5f639729300c3d8f611430d79cf4ba4c57df38e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5f639729300c3d8f611430d79cf4ba4c57df38e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c9c79e8bfa2840979556bf559f98b5d65a6edec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9c79e8bfa2840979556bf559f98b5d65a6edec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9c79e8bfa2840979556bf559f98b5d65a6edec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9c79e8bfa2840979556bf559f98b5d65a6edec/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30cf3db7cd7bcfeb003f29a6bfd9c41b59d7b74b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30cf3db7cd7bcfeb003f29a6bfd9c41b59d7b74b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30cf3db7cd7bcfeb003f29a6bfd9c41b59d7b74b"}], "stats": {"total": 186, "additions": 150, "deletions": 36}, "files": [{"sha": "308798367e6cfbd1f75632898467734c8dc442b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9c79e8bfa2840979556bf559f98b5d65a6edec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9c79e8bfa2840979556bf559f98b5d65a6edec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c9c79e8bfa2840979556bf559f98b5d65a6edec", "patch": "@@ -1,3 +1,16 @@\n+2012-06-14  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (VR_INITIALIZER): New define.\n+\t(ranges_from_anti_range): New function.\n+\t(extract_range_from_binary_expr_1): Decompose operations on\n+\tVR_ANTI_RANGEs to operations on VR_RANGE.\n+\t(extract_range_from_unary_expr_1): Likewise.\n+\t(extract_range_from_binary_expr_1, extract_range_from_binary_expr,\n+\textract_range_from_unary_expr_1, extract_range_from_unary_expr,\n+\textract_range_from_cond_expr, adjust_range_with_scev,\n+\tvrp_visit_assignment_or_call, vrp_visit_phi_node,\n+\tsimplify_bit_ops_using_ranges): Use VR_INITIALIZER.\n+\n 2012-06-13  Richard Henderson  <rth@redhat.com>\n \n \t* hwint.h (HOST_WIDEST_INT_C): New."}, {"sha": "c4ecd6cdd237f9dcbba05520d7e39acc1338b0d4", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 137, "deletions": 36, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9c79e8bfa2840979556bf559f98b5d65a6edec/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9c79e8bfa2840979556bf559f98b5d65a6edec/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=3c9c79e8bfa2840979556bf559f98b5d65a6edec", "patch": "@@ -76,6 +76,8 @@ struct value_range_d\n \n typedef struct value_range_d value_range_t;\n \n+#define VR_INITIALIZER { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL }\n+\n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n static sbitmap *live;\n@@ -2216,6 +2218,54 @@ zero_nonzero_bits_from_vr (value_range_t *vr,\n   return true;\n }\n \n+/* Create two value-ranges in *VR0 and *VR1 from the anti-range *AR\n+   so that *VR0 U *VR1 == *AR.  Returns true if that is possible,\n+   false otherwise.  If *AR can be represented with a single range\n+   *VR1 will be VR_UNDEFINED.  */\n+\n+static bool\n+ranges_from_anti_range (value_range_t *ar,\n+\t\t\tvalue_range_t *vr0, value_range_t *vr1)\n+{\n+  tree type = TREE_TYPE (ar->min);\n+\n+  vr0->type = VR_UNDEFINED;\n+  vr1->type = VR_UNDEFINED;\n+\n+  if (ar->type != VR_ANTI_RANGE\n+      || TREE_CODE (ar->min) != INTEGER_CST\n+      || TREE_CODE (ar->max) != INTEGER_CST\n+      || !vrp_val_min (type)\n+      || !vrp_val_max (type))\n+    return false;\n+\n+  if (!vrp_val_is_min (ar->min))\n+    {\n+      vr0->type = VR_RANGE;\n+      vr0->min = vrp_val_min (type);\n+      vr0->max\n+\t= double_int_to_tree (type,\n+\t\t\t      double_int_sub (tree_to_double_int (ar->min),\n+\t\t\t\t\t      double_int_one));\n+    }\n+  if (!vrp_val_is_max (ar->max))\n+    {\n+      vr1->type = VR_RANGE;\n+      vr1->min\n+\t= double_int_to_tree (type,\n+\t\t\t      double_int_add (tree_to_double_int (ar->max),\n+\t\t\t\t\t      double_int_one));\n+      vr1->max = vrp_val_max (type);\n+    }\n+  if (vr0->type == VR_UNDEFINED)\n+    {\n+      *vr0 = *vr1;\n+      vr1->type = VR_UNDEFINED;\n+    }\n+\n+  return vr0->type != VR_UNDEFINED;\n+}\n+\n /* Helper to extract a value-range *VR for a multiplicative operation\n    *VR0 CODE *VR1.  */\n \n@@ -2379,6 +2429,7 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t\t\t\t  value_range_t *vr0_, value_range_t *vr1_)\n {\n   value_range_t vr0 = *vr0_, vr1 = *vr1_;\n+  value_range_t vrtem0 = VR_INITIALIZER, vrtem1 = VR_INITIALIZER;\n   enum value_range_type type;\n   tree min = NULL_TREE, max = NULL_TREE;\n   int cmp;\n@@ -2429,6 +2480,36 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n   else if (vr1.type == VR_UNDEFINED)\n     set_value_range_to_varying (&vr1);\n \n+  /* Now canonicalize anti-ranges to ranges when they are not symbolic\n+     and express ~[] op X as ([]' op X) U ([]'' op X).  */\n+  if (vr0.type == VR_ANTI_RANGE\n+      && ranges_from_anti_range (&vr0, &vrtem0, &vrtem1))\n+    {\n+      extract_range_from_binary_expr_1 (vr, code, expr_type, &vrtem0, vr1_);\n+      if (vrtem1.type != VR_UNDEFINED)\n+\t{\n+\t  value_range_t vrres = VR_INITIALIZER;\n+\t  extract_range_from_binary_expr_1 (&vrres, code, expr_type,\n+\t\t\t\t\t    &vrtem1, vr1_);\n+\t  vrp_meet (vr, &vrres);\n+\t}\n+      return;\n+    }\n+  /* Likewise for X op ~[].  */\n+  if (vr1.type == VR_ANTI_RANGE\n+      && ranges_from_anti_range (&vr1, &vrtem0, &vrtem1))\n+    {\n+      extract_range_from_binary_expr_1 (vr, code, expr_type, vr0_, &vrtem0);\n+      if (vrtem1.type != VR_UNDEFINED)\n+\t{\n+\t  value_range_t vrres = VR_INITIALIZER;\n+\t  extract_range_from_binary_expr_1 (&vrres, code, expr_type,\n+\t\t\t\t\t    vr0_, &vrtem1);\n+\t  vrp_meet (vr, &vrres);\n+\t}\n+      return;\n+    }\n+\n   /* The type of the resulting value range defaults to VR0.TYPE.  */\n   type = vr0.type;\n \n@@ -2616,7 +2697,8 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n       /* We can map shifts by constants to MULT_EXPR handling.  */\n       if (range_int_cst_singleton_p (&vr1))\n \t{\n-\t  value_range_t vr1p = { VR_RANGE, NULL_TREE, NULL_TREE, NULL };\n+\t  value_range_t vr1p = VR_INITIALIZER;\n+\t  vr1p.type = VR_RANGE;\n \t  vr1p.min\n \t    = double_int_to_tree (expr_type,\n \t\t\t\t  double_int_lshift (double_int_one,\n@@ -2920,8 +3002,8 @@ extract_range_from_binary_expr (value_range_t *vr,\n \t\t\t\tenum tree_code code,\n \t\t\t\ttree expr_type, tree op0, tree op1)\n {\n-  value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n-  value_range_t vr1 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+  value_range_t vr0 = VR_INITIALIZER;\n+  value_range_t vr1 = VR_INITIALIZER;\n \n   /* Get value ranges for each operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n@@ -2951,7 +3033,7 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n \t\t\t\t enum tree_code code, tree type,\n \t\t\t\t value_range_t *vr0_, tree op0_type)\n {\n-  value_range_t vr0 = *vr0_;\n+  value_range_t vr0 = *vr0_, vrtem0 = VR_INITIALIZER, vrtem1 = VR_INITIALIZER;\n \n   /* VRP only operates on integral and pointer types.  */\n   if (!(INTEGRAL_TYPE_P (op0_type)\n@@ -2970,6 +3052,49 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n       return;\n     }\n \n+  /* Handle operations that we express in terms of others.  */\n+  if (code == PAREN_EXPR)\n+    {\n+      /* PAREN_EXPR is a simple copy.  */\n+      copy_value_range (vr, &vr0);\n+      return;\n+    }\n+  else if (code == NEGATE_EXPR)\n+    {\n+      /* -X is simply 0 - X, so re-use existing code that also handles\n+         anti-ranges fine.  */\n+      value_range_t zero = VR_INITIALIZER;\n+      set_value_range_to_value (&zero, build_int_cst (type, 0), NULL);\n+      extract_range_from_binary_expr_1 (vr, MINUS_EXPR, type, &zero, &vr0);\n+      return;\n+    }\n+  else if (code == BIT_NOT_EXPR)\n+    {\n+      /* ~X is simply -1 - X, so re-use existing code that also handles\n+         anti-ranges fine.  */\n+      value_range_t minusone = VR_INITIALIZER;\n+      set_value_range_to_value (&minusone, build_int_cst (type, -1), NULL);\n+      extract_range_from_binary_expr_1 (vr, MINUS_EXPR,\n+\t\t\t\t\ttype, &minusone, &vr0);\n+      return;\n+    }\n+\n+  /* Now canonicalize anti-ranges to ranges when they are not symbolic\n+     and express op ~[]  as (op []') U (op []'').  */\n+  if (vr0.type == VR_ANTI_RANGE\n+      && ranges_from_anti_range (&vr0, &vrtem0, &vrtem1))\n+    {\n+      extract_range_from_unary_expr_1 (vr, code, type, &vrtem0, op0_type);\n+      if (vrtem1.type != VR_UNDEFINED)\n+\t{\n+\t  value_range_t vrres = VR_INITIALIZER;\n+\t  extract_range_from_unary_expr_1 (&vrres, code, type,\n+\t\t\t\t\t   &vrtem1, op0_type);\n+\t  vrp_meet (vr, &vrres);\n+\t}\n+      return;\n+    }\n+\n   if (CONVERT_EXPR_CODE_P (code))\n     {\n       tree inner_type = op0_type;\n@@ -3046,15 +3171,6 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n       set_value_range_to_varying (vr);\n       return;\n     }\n-  else if (code == NEGATE_EXPR)\n-    {\n-      /* -X is simply 0 - X, so re-use existing code that also handles\n-         anti-ranges fine.  */\n-      value_range_t zero = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n-      set_value_range_to_value (&zero, build_int_cst (type, 0), NULL);\n-      extract_range_from_binary_expr_1 (vr, MINUS_EXPR, type, &zero, &vr0);\n-      return;\n-    }\n   else if (code == ABS_EXPR)\n     {\n       tree min, max;\n@@ -3208,21 +3324,6 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n \tset_value_range (vr, vr0.type, min, max, NULL);\n       return;\n     }\n-  else if (code == BIT_NOT_EXPR)\n-    {\n-      /* ~X is simply -1 - X, so re-use existing code that also handles\n-         anti-ranges fine.  */\n-      value_range_t minusone = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n-      set_value_range_to_value (&minusone, build_int_cst (type, -1), NULL);\n-      extract_range_from_binary_expr_1 (vr, MINUS_EXPR,\n-\t\t\t\t\ttype, &minusone, &vr0);\n-      return;\n-    }\n-  else if (code == PAREN_EXPR)\n-    {\n-      copy_value_range (vr, &vr0);\n-      return;\n-    }\n \n   /* For unhandled operations fall back to varying.  */\n   set_value_range_to_varying (vr);\n@@ -3238,7 +3339,7 @@ static void\n extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n \t\t\t       tree type, tree op0)\n {\n-  value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+  value_range_t vr0 = VR_INITIALIZER;\n \n   /* Get value ranges for the operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n@@ -3260,8 +3361,8 @@ static void\n extract_range_from_cond_expr (value_range_t *vr, gimple stmt)\n {\n   tree op0, op1;\n-  value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n-  value_range_t vr1 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+  value_range_t vr0 = VR_INITIALIZER;\n+  value_range_t vr1 = VR_INITIALIZER;\n \n   /* Get value ranges for each operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n@@ -3464,7 +3565,7 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop,\n \t the number of latch executions is the correct thing to use.  */\n       if (max_loop_iterations (loop, &nit))\n \t{\n-\t  value_range_t maxvr = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+\t  value_range_t maxvr = VR_INITIALIZER;\n \t  double_int dtmp;\n \t  bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (step));\n \t  int overflow = 0;\n@@ -6123,7 +6224,7 @@ vrp_visit_assignment_or_call (gimple stmt, tree *output_p)\n \t   && TYPE_MAX_VALUE (TREE_TYPE (lhs)))\n \t  || POINTER_TYPE_P (TREE_TYPE (lhs))))\n     {\n-      value_range_t new_vr = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+      value_range_t new_vr = VR_INITIALIZER;\n \n       /* Try folding the statement to a constant first.  */\n       tree tem = gimple_fold_stmt_to_constant (stmt, vrp_valueize);\n@@ -7112,7 +7213,7 @@ vrp_visit_phi_node (gimple phi)\n   size_t i;\n   tree lhs = PHI_RESULT (phi);\n   value_range_t *lhs_vr = get_value_range (lhs);\n-  value_range_t vr_result = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+  value_range_t vr_result = VR_INITIALIZER;\n   bool first = true;\n   int edges, old_edges;\n   struct loop *l;\n@@ -7493,8 +7594,8 @@ simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n   tree op0 = gimple_assign_rhs1 (stmt);\n   tree op1 = gimple_assign_rhs2 (stmt);\n   tree op = NULL_TREE;\n-  value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n-  value_range_t vr1 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+  value_range_t vr0 = VR_INITIALIZER;\n+  value_range_t vr1 = VR_INITIALIZER;\n   double_int may_be_nonzero0, may_be_nonzero1;\n   double_int must_be_nonzero0, must_be_nonzero1;\n   double_int mask;"}]}