{"sha": "beaee0a871b6485d20573fe050b1fd425581e56a", "node_id": "C_kwDOANBUbNoAKGJlYWVlMGE4NzFiNjQ4NWQyMDU3M2ZlMDUwYjFmZDQyNTU4MWU1NmE", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-01-01T21:00:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-01-07T00:23:17Z"}, "message": "c++: temporary lifetime with array aggr init [PR94041]\n\nThe previous patch fixed temporary lifetime for aggregate initialization of\nclasses; this one extends that fix to arrays.  This specifically reverses my\nr74790, the patch for PR12253, which was made wrong when these semantics\nwere specified in DR201.\n\nSince the array cleanup region encloses the regions for any temporaries, we\ndon't need to add an additional region for the array object itself in either\ninitialize_local_var or split_nonconstant_init; we do, however, need to tell\nsplit_nonconstant_init how to disable the cleanup once an enclosing object\nis fully constructed, at which point we want to run that destructor instead.\n\n\tPR c++/94041\n\ngcc/cp/ChangeLog:\n\n\t* decl.c (initialize_local_var): Fix comment.\n\t* init.c (build_new_1): Do stabilize array init.\n\t(build_vec_init): Use TARGET_EXPR for cleanup.  Initialization\n\tof an element from an explicit initializer is not a\n\tfull-expression.\n\t* tree.c (expand_vec_init_expr): Pass flags through.\n\t* typeck2.c (split_nonconstant_init_1): Handle VEC_INIT_EXPR.\n\t(split_nonconstant_init): Handle array cleanups.\n\t* cp-tree.h: Adjust.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/init/array12.C:\n\t* g++.dg/init/aggr7-eh2.C: New test.\n\t* g++.dg/init/aggr7-eh3.C: New test.", "tree": {"sha": "5b5a1320fcbead17619a0dfdfdf701528f8a5ca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b5a1320fcbead17619a0dfdfdf701528f8a5ca9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/beaee0a871b6485d20573fe050b1fd425581e56a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beaee0a871b6485d20573fe050b1fd425581e56a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beaee0a871b6485d20573fe050b1fd425581e56a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beaee0a871b6485d20573fe050b1fd425581e56a/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce0ab8fb46f07b0bde56aa31e46d57b81379fde3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3"}], "stats": {"total": 372, "additions": 298, "deletions": 74}, "files": [{"sha": "c75ecaf8c8e23584a8ef0974a8997e34bb987db1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=beaee0a871b6485d20573fe050b1fd425581e56a", "patch": "@@ -7011,7 +7011,8 @@ extern tree build_new\t\t\t\t(location_t,\n \t\t\t\t\t\t int, tsubst_flags_t);\n extern tree get_temp_regvar\t\t\t(tree, tree);\n extern tree build_vec_init\t\t\t(tree, tree, tree, bool, int,\n-                                                 tsubst_flags_t);\n+\t\t\t\t\t\t tsubst_flags_t,\n+\t\t\t\t\t\t vec<tree, va_gc> ** = nullptr);\n extern tree build_delete\t\t\t(location_t, tree, tree,\n \t\t\t\t\t\t special_function_kind,\n \t\t\t\t\t\t int, int, tsubst_flags_t);\n@@ -7779,7 +7780,8 @@ extern bool array_of_runtime_bound_p\t\t(tree);\n extern bool vla_type_p\t\t\t\t(tree);\n extern tree build_array_copy\t\t\t(tree);\n extern tree build_vec_init_expr\t\t\t(tree, tree, tsubst_flags_t);\n-extern tree expand_vec_init_expr\t\t(tree, tree, tsubst_flags_t);\n+extern tree expand_vec_init_expr\t\t(tree, tree, tsubst_flags_t,\n+\t\t\t\t\t\t vec<tree,va_gc>** = nullptr);\n extern void diagnose_non_constexpr_vec_init\t(tree);\n extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);"}, {"sha": "b16a4f9ed343c2664db7c99de02af980e77ca903", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=beaee0a871b6485d20573fe050b1fd425581e56a", "patch": "@@ -7518,8 +7518,7 @@ initialize_local_var (tree decl, tree init)\n \n \t  /* If we're only initializing a single object, guard the\n \t     destructors of any temporaries used in its initializer with\n-\t     its destructor.  This isn't right for arrays because each\n-\t     element initialization is a full-expression.  */\n+\t     its destructor.  But arrays are handled in build_vec_init.  */\n \t  if (cleanup && TREE_CODE (type) != ARRAY_TYPE)\n \t    wrap_temporary_cleanups (init, cleanup);\n "}, {"sha": "7c7b81040262003b2c9313ddd134a2442622cc36", "filename": "gcc/cp/init.c", "status": "modified", "additions": 49, "deletions": 35, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=beaee0a871b6485d20573fe050b1fd425581e56a", "patch": "@@ -4292,7 +4292,9 @@ finish_length_check (tree atype, tree iterator, tree obase, unsigned n)\n tree\n build_vec_init (tree base, tree maxindex, tree init,\n \t\tbool explicit_value_init_p,\n-\t\tint from_array, tsubst_flags_t complain)\n+\t\tint from_array,\n+\t\ttsubst_flags_t complain,\n+\t\tvec<tree, va_gc>** flags /* = nullptr */)\n {\n   tree rval;\n   tree base2 = NULL_TREE;\n@@ -4310,7 +4312,6 @@ build_vec_init (tree base, tree maxindex, tree init,\n   tree stmt_expr;\n   tree compound_stmt;\n   int destroy_temps;\n-  tree try_block = NULL_TREE;\n   HOST_WIDE_INT num_initialized_elts = 0;\n   bool is_global;\n   tree obase = base;\n@@ -4447,7 +4448,9 @@ build_vec_init (tree base, tree maxindex, tree init,\n   current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n   rval = get_temp_regvar (ptype, base);\n   base = get_temp_regvar (ptype, rval);\n-  iterator = get_temp_regvar (ptrdiff_type_node, maxindex);\n+  tree iterator_targ = get_target_expr (maxindex);\n+  add_stmt (iterator_targ);\n+  iterator = TARGET_EXPR_SLOT (iterator_targ);\n \n   /* If initializing one array from another, initialize element by\n      element.  We rely upon the below calls to do the argument\n@@ -4470,7 +4473,37 @@ build_vec_init (tree base, tree maxindex, tree init,\n   if (flag_exceptions && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n       && from_array != 2)\n     {\n-      try_block = begin_try_block ();\n+      tree e;\n+      tree m = cp_build_binary_op (input_location,\n+\t\t\t\t   MINUS_EXPR, maxindex, iterator,\n+\t\t\t\t   complain);\n+\n+      /* Flatten multi-dimensional array since build_vec_delete only\n+\t expects one-dimensional array.  */\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+\tm = cp_build_binary_op (input_location,\n+\t\t\t\tMULT_EXPR, m,\n+\t\t\t\t/* Avoid mixing signed and unsigned.  */\n+\t\t\t\tconvert (TREE_TYPE (m),\n+\t\t\t\t\t array_type_nelts_total (type)),\n+\t\t\t\tcomplain);\n+\n+      e = build_vec_delete_1 (input_location, rval, m,\n+\t\t\t      inner_elt_type, sfk_complete_destructor,\n+\t\t\t      /*use_global_delete=*/0, complain);\n+      if (e == error_mark_node)\n+\terrors = true;\n+      TARGET_EXPR_CLEANUP (iterator_targ) = e;\n+      CLEANUP_EH_ONLY (iterator_targ) = true;\n+\n+      /* Since we push this cleanup before doing any initialization, cleanups\n+\t for any temporaries in the initialization are naturally within our\n+\t cleanup region, so we don't want wrap_temporary_cleanups to do\n+\t anything for arrays.  But if the array is a subobject, we need to\n+\t tell split_nonconstant_init how to turn off this cleanup in favor of\n+\t the cleanup for the complete object.  */\n+      if (flags)\n+\tvec_safe_push (*flags, build_tree_list (iterator, maxindex));\n     }\n \n   /* Should we try to create a constant initializer?  */\n@@ -4520,11 +4553,10 @@ build_vec_init (tree base, tree maxindex, tree init,\n \n \t  num_initialized_elts++;\n \n-\t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n \t  if (digested)\n \t    one_init = build2 (INIT_EXPR, type, baseref, elt);\n \t  else if (TREE_CODE (elt) == VEC_INIT_EXPR)\n-\t    one_init = expand_vec_init_expr (baseref, elt, complain);\n+\t    one_init = expand_vec_init_expr (baseref, elt, complain, flags);\n \t  else if (MAYBE_CLASS_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n \t    one_init = build_aggr_init (baseref, elt, 0, complain);\n \t  else\n@@ -4560,7 +4592,6 @@ build_vec_init (tree base, tree maxindex, tree init,\n \n \t  if (one_init)\n \t    finish_expr_stmt (one_init);\n-\t  current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n \n \t  one_init = cp_build_unary_op (PREINCREMENT_EXPR, base, false,\n \t\t\t\t\tcomplain);\n@@ -4782,6 +4813,17 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t    }\n \t}\n \n+      /* [class.temporary]: \"There are three contexts in which temporaries are\n+\t destroyed at a different point than the end of the full-\n+\t expression. The first context is when a default constructor is called\n+\t to initialize an element of an array with no corresponding\n+\t initializer. The second context is when a copy constructor is called\n+\t to copy an element of an array while the entire array is copied. In\n+\t either case, if the constructor has one or more default arguments, the\n+\t destruction of every temporary created in a default argument is\n+\t sequenced before the construction of the next array element, if any.\"\n+\n+\t So, for this loop, statements are full-expressions.  */\n       current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n       if (elt_init && !errors)\n \telt_init = build2 (COMPOUND_EXPR, void_type_node, elt_init, decr);\n@@ -4799,34 +4841,6 @@ build_vec_init (tree base, tree maxindex, tree init,\n       finish_for_stmt (for_stmt);\n     }\n \n-  /* Make sure to cleanup any partially constructed elements.  */\n-  if (flag_exceptions && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n-      && from_array != 2)\n-    {\n-      tree e;\n-      tree m = cp_build_binary_op (input_location,\n-\t\t\t\t   MINUS_EXPR, maxindex, iterator,\n-\t\t\t\t   complain);\n-\n-      /* Flatten multi-dimensional array since build_vec_delete only\n-\t expects one-dimensional array.  */\n-      if (TREE_CODE (type) == ARRAY_TYPE)\n-\tm = cp_build_binary_op (input_location,\n-\t\t\t\tMULT_EXPR, m,\n-\t\t\t\t/* Avoid mixing signed and unsigned.  */\n-\t\t\t\tconvert (TREE_TYPE (m),\n-\t\t\t\t\t array_type_nelts_total (type)),\n-\t\t\t\tcomplain);\n-\n-      finish_cleanup_try_block (try_block);\n-      e = build_vec_delete_1 (input_location, rval, m,\n-\t\t\t      inner_elt_type, sfk_complete_destructor,\n-\t\t\t      /*use_global_delete=*/0, complain);\n-      if (e == error_mark_node)\n-\terrors = true;\n-      finish_cleanup (e, try_block);\n-    }\n-\n   /* The value of the array initialization is the array itself, RVAL\n      is a pointer to the first element.  */\n   finish_stmt_expr_expr (rval, stmt_expr);"}, {"sha": "964e40ea11a092fc8818fb119de9f46e09d14ec5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=beaee0a871b6485d20573fe050b1fd425581e56a", "patch": "@@ -824,7 +824,8 @@ build_vec_init_expr (tree type, tree init, tsubst_flags_t complain)\n    means VEC_INIT_EXPR_SLOT).  */\n \n tree\n-expand_vec_init_expr (tree target, tree vec_init, tsubst_flags_t complain)\n+expand_vec_init_expr (tree target, tree vec_init, tsubst_flags_t complain,\n+\t\t      vec<tree,va_gc> **flags)\n {\n   iloc_sentinel ils = EXPR_LOCATION (vec_init);\n \n@@ -834,7 +835,7 @@ expand_vec_init_expr (tree target, tree vec_init, tsubst_flags_t complain)\n   int from_array = (init && TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE);\n   return build_vec_init (target, NULL_TREE, init,\n \t\t\t VEC_INIT_EXPR_VALUE_INIT (vec_init),\n-\t\t\t from_array, complain);\n+\t\t\t from_array, complain, flags);\n }\n \n /* Give a helpful diagnostic for a non-constexpr VEC_INIT_EXPR in a context"}, {"sha": "7907c53996dcd2e2e418334bbedf48fbfd92bf02", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=beaee0a871b6485d20573fe050b1fd425581e56a", "patch": "@@ -486,7 +486,7 @@ maybe_push_temp_cleanup (tree sub, vec<tree,va_gc> **flags)\n    generated statements.  */\n \n static bool\n-split_nonconstant_init_1 (tree dest, tree init, bool nested, vec<tree,va_gc> **flags)\n+split_nonconstant_init_1 (tree dest, tree init, vec<tree,va_gc> **flags)\n {\n   unsigned HOST_WIDE_INT idx, tidx = HOST_WIDE_INT_M1U;\n   tree field_index, value;\n@@ -515,14 +515,10 @@ split_nonconstant_init_1 (tree dest, tree init, bool nested, vec<tree,va_gc> **f\n \t    }\n \n \t  /* For an array, we only need/want a single cleanup region rather\n-\t     than one per element.  */\n+\t     than one per element.  build_vec_init will handle it.  */\n \t  tree code = build_vec_init (dest, NULL_TREE, init, false, 1,\n-\t\t\t\t      tf_warning_or_error);\n+\t\t\t\t      tf_warning_or_error, flags);\n \t  add_stmt (code);\n-\t  if (nested)\n-\t    /* Also clean up the whole array if something later in an enclosing\n-\t       init-list throws.  */\n-\t    maybe_push_temp_cleanup (dest, flags);\n \t  return true;\n \t}\n       /* FALLTHRU */\n@@ -541,18 +537,17 @@ split_nonconstant_init_1 (tree dest, tree init, bool nested, vec<tree,va_gc> **f\n \t  if (!array_type_p)\n \t    inner_type = TREE_TYPE (field_index);\n \n+\t  tree sub;\n+\t  if (array_type_p)\n+\t    sub = build4 (ARRAY_REF, inner_type, dest, field_index,\n+\t\t\t  NULL_TREE, NULL_TREE);\n+\t  else\n+\t    sub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n+\t\t\t  NULL_TREE);\n+\n \t  if (TREE_CODE (value) == CONSTRUCTOR)\n \t    {\n-\t      tree sub;\n-\n-\t      if (array_type_p)\n-\t\tsub = build4 (ARRAY_REF, inner_type, dest, field_index,\n-\t\t\t      NULL_TREE, NULL_TREE);\n-\t      else\n-\t\tsub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n-\t\t\t      NULL_TREE);\n-\n-\t      if (!split_nonconstant_init_1 (sub, value, true, flags)\n+\t      if (!split_nonconstant_init_1 (sub, value, flags)\n \t\t      /* For flexible array member with initializer we\n \t\t\t can't remove the initializer, because only the\n \t\t\t initializer determines how many elements the\n@@ -576,10 +571,20 @@ split_nonconstant_init_1 (tree dest, tree init, bool nested, vec<tree,va_gc> **f\n \t\t  num_split_elts++;\n \t\t}\n \t    }\n+\t  else if (TREE_CODE (value) == VEC_INIT_EXPR)\n+\t    {\n+\t      add_stmt (expand_vec_init_expr (sub, value, tf_warning_or_error,\n+\t\t\t\t\t      flags));\n+\n+\t      /* Mark element for removal.  */\n+\t      CONSTRUCTOR_ELT (init, idx)->index = NULL_TREE;\n+\t      if (idx < tidx)\n+\t\ttidx = idx;\n+\t      num_split_elts++;\n+\t    }\n \t  else if (!initializer_constant_valid_p (value, inner_type))\n \t    {\n \t      tree code;\n-\t      tree sub;\n \n \t      /* Mark element for removal.  */\n \t      CONSTRUCTOR_ELT (init, idx)->index = NULL_TREE;\n@@ -603,13 +608,6 @@ split_nonconstant_init_1 (tree dest, tree init, bool nested, vec<tree,va_gc> **f\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (array_type_p)\n-\t\t    sub = build4 (ARRAY_REF, inner_type, dest, field_index,\n-\t\t\t\t  NULL_TREE, NULL_TREE);\n-\t\t  else\n-\t\t    sub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n-\t\t\t\t  NULL_TREE);\n-\n \t\t  /* We may need to add a copy constructor call if\n \t\t     the field has [[no_unique_address]].  */\n \t\t  if (unsafe_return_slot_p (sub))\n@@ -710,18 +708,29 @@ split_nonconstant_init (tree dest, tree init)\n       init = cp_fully_fold_init (init);\n       code = push_stmt_list ();\n \n-      /* Collect flags for disabling subobject cleanups once the complete\n-\t object is fully constructed.  */\n-      vec<tree, va_gc> *flags = make_tree_vector ();\n+      /* If the complete object is an array, build_vec_init's cleanup is\n+\t enough.  Otherwise, collect flags for disabling subobject\n+\t cleanups once the complete object is fully constructed.  */\n+      vec<tree, va_gc> *flags = nullptr;\n+      if (TREE_CODE (TREE_TYPE (dest)) != ARRAY_TYPE)\n+\tflags = make_tree_vector ();\n \n-      if (split_nonconstant_init_1 (dest, init, false, &flags))\n+      if (split_nonconstant_init_1 (dest, init, &flags))\n \tinit = NULL_TREE;\n \n       for (tree f : flags)\n \t{\n \t  /* See maybe_push_temp_cleanup.  */\n \t  tree d = f;\n \t  tree i = boolean_false_node;\n+\t  if (TREE_CODE (f) == TREE_LIST)\n+\t    {\n+\t      /* To disable a build_vec_init cleanup, set\n+\t\t iterator = maxindex.  */\n+\t      d = TREE_PURPOSE (f);\n+\t      i = TREE_VALUE (f);\n+\t      ggc_free (f);\n+\t    }\n \t  add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (d), d, i));\n \t}\n       release_tree_vector (flags);"}, {"sha": "0037b0923941372667f0870d0788672ee6485e87", "filename": "gcc/testsuite/g++.dg/init/aggr7-eh2.C", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Faggr7-eh2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Faggr7-eh2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Faggr7-eh2.C?ref=beaee0a871b6485d20573fe050b1fd425581e56a", "patch": "@@ -0,0 +1,98 @@\n+// PR c++/50866, adjusted\n+// { dg-do run }\n+\n+#if __cplusplus > 201100L\n+#define THROWING noexcept(false)\n+#else\n+#define THROWING\n+#endif\n+\n+extern \"C\" void abort ();\n+\n+#ifdef DEBUG\n+  extern \"C\" int printf (const char *, ...);\n+  #define dump(X,Y) printf(X,Y)\n+#define abort() printf(\"wrong\\n\");\n+\n+#else\n+  #define dump(X,Y)\n+#endif\n+\n+int a, b;\n+int d;\n+struct A {\n+  int n;\n+  A() { n = ++a; dump(\"A%d\\n\",a); }\n+  A(const A&);\n+  ~A() THROWING {\n+    dump(\"~A%d\\n\",n);\n+    --a;\n+    if (d == 1 ? a == 0 : (b == d && a == 1))\n+      {\n+\tdump (\"~A%d throwing\\n\", n);\n+\tthrow (short)b;\n+      }\n+  }\n+};\n+int t;\n+struct B {\n+  int n;\n+  B(const A& = A())\n+  {\n+    if (b == t)\n+      {\n+\tdump (\"B%d throwing\\n\", b+1);\n+\tthrow b;\n+      }\n+    n = ++b;\n+    dump(\"B%d\\n\",b);\n+\n+    /* The first B has an explicit initializer, so its A lives for the\n+       full-expression.  The second B does not, so its A should be destroyed\n+       before we construct the third B.  */\n+    if (a != 2) abort ();\n+  }\n+  B(const char *, const A& = A())\n+  {\n+    if (b == t)\n+      {\n+\tdump (\"B%d throwing\\n\", b+1);\n+\tthrow b;\n+      }\n+    n = ++b;\n+    dump(\"B%d\\n\",b);\n+    if (a != b) abort ();\n+  }\n+  B(const B&);\n+  ~B()\n+  {\n+    dump(\"~B%d\\n\",n);\n+    --b;\n+  }\n+};\n+struct C {\n+  B bs[3];\n+};\n+void f()\n+{\n+  a = b = 0;\n+  try\n+    {\n+      C c = { \"x\" };\n+      if (a != 0) abort ();\n+      if (b != 3) abort ();\n+    }\n+  catch (int i) { }\n+  catch (short s) { }\n+  if (a != 0) abort ();\n+  if (b != 0) abort ();\n+  dump (\"\\n\", 0);\n+}\n+\n+int main()\n+{\n+  for (t = 0; t <= 3; ++t)\n+    f();\n+  for (d = 1; d <= 3; ++d)\n+    f();\n+}"}, {"sha": "6ddabec58b18ab80c65cc0a5fdff1f5991b52ccd", "filename": "gcc/testsuite/g++.dg/init/aggr7-eh3.C", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Faggr7-eh3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Faggr7-eh3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Faggr7-eh3.C?ref=beaee0a871b6485d20573fe050b1fd425581e56a", "patch": "@@ -0,0 +1,98 @@\n+// PR c++/50866, adjusted\n+// { dg-do run }\n+\n+#if __cplusplus > 201100L\n+#define THROWING noexcept(false)\n+#else\n+#define THROWING\n+#endif\n+\n+extern \"C\" void abort ();\n+\n+#ifdef DEBUG\n+  extern \"C\" int printf (const char *, ...);\n+  #define dump(X,Y) printf(X,Y)\n+#define abort() printf(\"wrong\\n\");\n+\n+#else\n+  #define dump(X,Y)\n+#endif\n+\n+int a, b;\n+int d;\n+struct A {\n+  int n;\n+  A() { n = ++a; dump(\"A%d\\n\",a); }\n+  A(const A&);\n+  ~A() THROWING {\n+    dump(\"~A%d\\n\",n);\n+    --a;\n+    if (d == 1 ? a == 0 : (b == d && a == 1))\n+      {\n+\tdump (\"~A%d throwing\\n\", n);\n+\tthrow (short)b;\n+      }\n+  }\n+};\n+int t;\n+struct B {\n+  int n;\n+  B(const A& = A())\n+  {\n+    if (b == t)\n+      {\n+\tdump (\"B%d throwing\\n\", b+1);\n+\tthrow b;\n+      }\n+    n = ++b;\n+    dump(\"B%d\\n\",b);\n+\n+    /* The first B has an explicit initializer, so its A lives for the\n+       full-expression.  The second B does not, so its A should be destroyed\n+       before we construct the third B.  */\n+    if (a != 2) abort ();\n+  }\n+  B(const char *, const A& = A())\n+  {\n+    if (b == t)\n+      {\n+\tdump (\"B%d throwing\\n\", b+1);\n+\tthrow b;\n+      }\n+    n = ++b;\n+    dump(\"B%d\\n\",b);\n+    if (a != b) abort ();\n+  }\n+  B(const B&);\n+  ~B()\n+  {\n+    dump(\"~B%d\\n\",n);\n+    --b;\n+  }\n+};\n+struct C {\n+  B bs[3];\n+};\n+void f()\n+{\n+  a = b = 0;\n+  try\n+    {\n+      B bs[3] = { \"x\" };\n+      if (a != 0) abort ();\n+      if (b != 3) abort ();\n+    }\n+  catch (int i) { }\n+  catch (short s) { }\n+  if (a != 0) abort ();\n+  if (b != 0) abort ();\n+  dump (\"\\n\", 0);\n+}\n+\n+int main()\n+{\n+  for (t = 0; t <= 3; ++t)\n+    f();\n+  for (d = 1; d <= 3; ++d)\n+    f();\n+}"}, {"sha": "f45a6e141b76071e9872d73987af5e741b4e8548", "filename": "gcc/testsuite/g++.dg/init/array12.C", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beaee0a871b6485d20573fe050b1fd425581e56a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray12.C?ref=beaee0a871b6485d20573fe050b1fd425581e56a", "patch": "@@ -1,5 +1,5 @@\n // PR c++/12253\n-// Bug: We were failing to destroy the temporary A passed to the\n+// We should not destroy the temporary A passed to the\n // constructor for b[0] before going on to construct b[1].\n \n // { dg-do run }\n@@ -11,18 +11,21 @@ int r;\n \n struct A\n {\n-  A() { printf (\"A()\\n\"); if (c++) r = 1; }\n+  A() { printf (\"A()\\n\"); ++c; }\n   A(const A&) { printf (\"A(const A&)\\n\"); ++c; }\n   ~A() { printf (\"~A()\\n\"); --c; }\n };\n  \n struct B\n {\n-  B(int, const A& = A()) { printf (\"B()\\n\"); }\n+  B(int i, const A& = A()) {\n+    printf (\"B()\\n\");\n+    if (c != i) r = 1;\n+  }\n };\n  \n int main()\n {\n-  B b[] = { 0, 0 };\n+  B b[] = { 1, 2 };\n   return r;\n }"}]}