{"sha": "a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "node_id": "C_kwDOANBUbNoAKGExNDNjM2Y3YTYxYzYxYmI1YTVlMDk5ZmRiNTlmM2FkYmY5OWI2YjM", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2022-12-23T00:52:46Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2022-12-23T05:41:34Z"}, "message": "RISC-V: Support vle.v/vse.v intrinsics\n\ngcc/ChangeLog:\n\n\t* config/riscv/riscv-protos.h (get_avl_type_rtx): New function.\n\t* config/riscv/riscv-v.cc (get_avl_type_rtx): Ditto.\n\t* config/riscv/riscv-vector-builtins-bases.cc (class loadstore): New\n\tclass.\n\t(BASE): Ditto.\n\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n\t* config/riscv/riscv-vector-builtins-functions.def (vle): Ditto.\n\t(vse): Ditto.\n\t* config/riscv/riscv-vector-builtins-shapes.cc (build_one): Ditto.\n\t(struct loadstore_def): Ditto.\n\t(SHAPE): Ditto.\n\t* config/riscv/riscv-vector-builtins-shapes.h: Ditto.\n\t* config/riscv/riscv-vector-builtins-types.def (DEF_RVV_U_OPS): New\n\tmacro.\n\t(DEF_RVV_F_OPS): Ditto.\n\t(vuint8mf8_t): Add corresponding mask type.\n\t(vuint8mf4_t): Ditto.\n\t(vuint8mf2_t): Ditto.\n\t(vuint8m1_t): Ditto.\n\t(vuint8m2_t): Ditto.\n\t(vuint8m4_t): Ditto.\n\t(vuint8m8_t): Ditto.\n\t(vuint16mf4_t): Ditto.\n\t(vuint16mf2_t): Ditto.\n\t(vuint16m1_t): Ditto.\n\t(vuint16m2_t): Ditto.\n\t(vuint16m4_t): Ditto.\n\t(vuint16m8_t): Ditto.\n\t(vuint32mf2_t): Ditto.\n\t(vuint32m1_t): Ditto.\n\t(vuint32m2_t): Ditto.\n\t(vuint32m4_t): Ditto.\n\t(vuint32m8_t): Ditto.\n\t(vuint64m1_t): Ditto.\n\t(vuint64m2_t): Ditto.\n\t(vuint64m4_t): Ditto.\n\t(vuint64m8_t): Ditto.\n\t(vfloat32mf2_t): Ditto.\n\t(vfloat32m1_t): Ditto.\n\t(vfloat32m2_t): Ditto.\n\t(vfloat32m4_t): Ditto.\n\t(vfloat32m8_t): Ditto.\n\t(vfloat64m1_t): Ditto.\n\t(vfloat64m2_t): Ditto.\n\t(vfloat64m4_t): Ditto.\n\t(vfloat64m8_t): Ditto.\n\t* config/riscv/riscv-vector-builtins.cc (DEF_RVV_TYPE): Adjust for new\n\tmacro.\n\t(DEF_RVV_I_OPS): Ditto.\n\t(DEF_RVV_U_OPS): New macro.\n\t(DEF_RVV_F_OPS): New macro.\n\t(use_real_mask_p): New function.\n\t(use_real_merge_p): Ditto.\n\t(get_tail_policy_for_pred): Ditto.\n\t(get_mask_policy_for_pred): Ditto.\n\t(function_builder::apply_predication): Ditto.\n\t(function_builder::append_base_name): Ditto.\n\t(function_builder::append_sew): Ditto.\n\t(function_expander::add_vundef_operand): Ditto.\n\t(function_expander::add_mem_operand): Ditto.\n\t(function_expander::use_contiguous_load_insn): Ditto.\n\t(function_expander::use_contiguous_store_insn): Ditto.\n\t* config/riscv/riscv-vector-builtins.def (DEF_RVV_TYPE): Adjust for\n\tadding mask type.\n\t(vbool64_t): Ditto.\n\t(vbool32_t): Ditto.\n\t(vbool16_t): Ditto.\n\t(vbool8_t): Ditto.\n\t(vbool4_t): Ditto.\n\t(vbool2_t): Ditto.\n\t(vbool1_t): Ditto.\n\t(vint8mf8_t): Ditto.\n\t(vint8mf4_t): Ditto.\n\t(vint8mf2_t): Ditto.\n\t(vint8m1_t): Ditto.\n\t(vint8m2_t): Ditto.\n\t(vint8m4_t): Ditto.\n\t(vint8m8_t): Ditto.\n\t(vint16mf4_t): Ditto.\n\t(vint16mf2_t): Ditto.\n\t(vint16m1_t): Ditto.\n\t(vint16m2_t): Ditto.\n\t(vint16m4_t): Ditto.\n\t(vint16m8_t): Ditto.\n\t(vint32mf2_t): Ditto.\n\t(vint32m1_t): Ditto.\n\t(vint32m2_t): Ditto.\n\t(vint32m4_t): Ditto.\n\t(vint32m8_t): Ditto.\n\t(vint64m1_t): Ditto.\n\t(vint64m2_t): Ditto.\n\t(vint64m4_t): Ditto.\n\t(vint64m8_t): Ditto.\n\t(vfloat32mf2_t): Ditto.\n\t(vfloat32m1_t): Ditto.\n\t(vfloat32m2_t): Ditto.\n\t(vfloat32m4_t): Ditto.\n\t(vfloat32m8_t): Ditto.\n\t(vfloat64m1_t): Ditto.\n\t(vfloat64m4_t): Ditto.\n\t* config/riscv/riscv-vector-builtins.h\n\t(function_expander::add_output_operand): New function.\n\t(function_expander::add_all_one_mask_operand): Ditto.\n\t(function_expander::add_fixed_operand): Ditto.\n\t(function_expander::vector_mode): Ditto.\n\t(function_base::apply_vl_p): Ditto.\n\t(function_base::can_be_overloaded_p): Ditto.\n\t* config/riscv/riscv-vsetvl.cc (get_vl): Remove restrict of supporting\n\tAVL is not VLMAX.\n\t* config/riscv/t-riscv: Add include file.", "tree": {"sha": "05b1e9019e430c399048da6c296cb4e8770e6f02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05b1e9019e430c399048da6c296cb4e8770e6f02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55d65ad4fd808c7806d770f03c26fa38672a4e28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d65ad4fd808c7806d770f03c26fa38672a4e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d65ad4fd808c7806d770f03c26fa38672a4e28"}], "stats": {"total": 582, "additions": 506, "deletions": 76}, "files": [{"sha": "64ee56b8a7c970b1ccc0ddf9eaba72d684c5b103", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -171,6 +171,7 @@ enum mask_policy\n };\n enum tail_policy get_prefer_tail_policy ();\n enum mask_policy get_prefer_mask_policy ();\n+rtx get_avl_type_rtx (enum avl_type);\n }\n \n /* We classify builtin types into two classes:"}, {"sha": "c769cf603323863d4660c2070b73e899a9fd36b7", "filename": "gcc/config/riscv/riscv-v.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -79,8 +79,7 @@ template <int MAX_OPERANDS> class insn_expander\n   }\n   void add_avl_type_operand ()\n   {\n-    rtx vlmax_rtx = gen_int_mode (avl_type::VLMAX, Pmode);\n-    add_input_operand (vlmax_rtx, Pmode);\n+    add_input_operand (get_avl_type_rtx (avl_type::VLMAX), Pmode);\n   }\n \n   void expand (enum insn_code icode, bool temporary_volatile_p = false)\n@@ -342,4 +341,11 @@ get_prefer_mask_policy ()\n   return MASK_ANY;\n }\n \n+/* Get avl_type rtx.  */\n+rtx\n+get_avl_type_rtx (enum avl_type type)\n+{\n+  return gen_int_mode (type, Pmode);\n+}\n+\n } // namespace riscv_vector"}, {"sha": "10373e5ccf276479940359f9a0dad09385bc535d", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.cc", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -53,6 +53,11 @@ template<bool VLMAX_P>\n class vsetvl : public function_base\n {\n public:\n+  bool apply_vl_p () const override\n+  {\n+    return false;\n+  }\n+\n   rtx expand (function_expander &e) const override\n   {\n     if (VLMAX_P)\n@@ -79,11 +84,47 @@ class vsetvl : public function_base\n   }\n };\n \n+/* Implements vle.v/vse.v codegen.  */\n+template <bool STORE_P>\n+class loadstore : public function_base\n+{\n+  unsigned int call_properties (const function_instance &) const override\n+  {\n+    if (STORE_P)\n+      return CP_WRITE_MEMORY;\n+    else\n+      return CP_READ_MEMORY;\n+  }\n+\n+  bool can_be_overloaded_p (enum predication_type_index pred) const override\n+  {\n+    if (STORE_P)\n+      return true;\n+    return pred != PRED_TYPE_none && pred != PRED_TYPE_mu;\n+  }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (STORE_P)\n+      return e.use_contiguous_store_insn (code_for_pred_mov (e.vector_mode ()));\n+    else\n+      return e.use_contiguous_load_insn (code_for_pred_mov (e.vector_mode ()));\n+  }\n+};\n+\n static CONSTEXPR const vsetvl<false> vsetvl_obj;\n static CONSTEXPR const vsetvl<true> vsetvlmax_obj;\n-namespace bases {\n-const function_base *const vsetvl = &vsetvl_obj;\n-const function_base *const vsetvlmax = &vsetvlmax_obj;\n-}\n+static CONSTEXPR const loadstore<false> vle_obj;\n+static CONSTEXPR const loadstore<true> vse_obj;\n+\n+/* Declare the function base NAME, pointing it to an instance\n+   of class <NAME>_obj.  */\n+#define BASE(NAME) \\\n+  namespace bases { const function_base *const NAME = &NAME##_obj; }\n+\n+BASE (vsetvl)\n+BASE (vsetvlmax)\n+BASE (vle)\n+BASE (vse)\n \n } // end namespace riscv_vector"}, {"sha": "79684bcb50d6dcf21784a1e9fac9c71ba539399f", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -26,6 +26,8 @@ namespace riscv_vector {\n namespace bases {\n extern const function_base *const vsetvl;\n extern const function_base *const vsetvlmax;\n+extern const function_base *const vle;\n+extern const function_base *const vse;\n }\n \n } // end namespace riscv_vector"}, {"sha": "e5ebb7d829c0fc0293d00346bfbb508dc9f69fae", "filename": "gcc/config/riscv/riscv-vector-builtins-functions.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -39,5 +39,8 @@ along with GCC; see the file COPYING3. If not see\n /* 6. Configuration-Setting Instructions.  */\n DEF_RVV_FUNCTION (vsetvl, vsetvl, none_preds, i_none_size_size_ops)\n DEF_RVV_FUNCTION (vsetvlmax, vsetvlmax, none_preds, i_none_size_void_ops)\n+/* 7. Vector Loads and Stores. */\n+DEF_RVV_FUNCTION (vle, loadstore, full_preds, all_v_scalar_const_ptr_ops)\n+DEF_RVV_FUNCTION (vse, loadstore, none_m_preds, all_v_scalar_ptr_ops)\n \n #undef DEF_RVV_FUNCTION"}, {"sha": "0332c031ce4d905602d59200c0acb161b8cd7a5e", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.cc", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -48,6 +48,7 @@ build_one (function_builder &b, const function_group_info &group,\n   tree return_type = group.ops_infos.ret.get_tree_type (\n     group.ops_infos.types[vec_type_idx].index);\n   b.allocate_argument_types (function_instance, argument_types);\n+  b.apply_predication (function_instance, return_type, argument_types);\n   b.add_unique_function (function_instance, (*group.shape), return_type,\n \t\t\t argument_types);\n }\n@@ -93,13 +94,46 @@ struct vsetvl_def : public build_base\n     /* vsetvl* instruction doesn't have C++ overloaded functions.  */\n     if (overloaded_p)\n       return nullptr;\n-    b.append_name (\"__riscv_\");\n-    b.append_name (instance.base_name);\n+    b.append_base_name (instance.base_name);\n     b.append_name (type_suffixes[instance.type.index].vsetvl);\n     return b.finish_name ();\n   }\n };\n+\n+/* loadstore_def class.  */\n+struct loadstore_def : public build_base\n+{\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    /* Return nullptr if it can not be overloaded.  */\n+    if (overloaded_p && !instance.base->can_be_overloaded_p (instance.pred))\n+      return nullptr;\n+\n+    b.append_base_name (instance.base_name);\n+\n+    tree type = builtin_types[instance.type.index].vector;\n+    machine_mode mode = TYPE_MODE (type);\n+    int sew = GET_MODE_BITSIZE (GET_MODE_INNER (mode));\n+    /* vop --> vop<sew>.  */\n+    b.append_sew (sew);\n+\n+    /* vop<sew>_v --> vop<sew>_v_<type>.  */\n+    if (!overloaded_p)\n+      {\n+\t/* vop<sew> --> vop<sew>_v.  */\n+\tb.append_name (operand_suffixes[instance.op_info->op]);\n+\t/* vop<sew>_v --> vop<sew>_v_<type>.  */\n+\tb.append_name (type_suffixes[instance.type.index].vector);\n+      }\n+\n+    b.append_name (predication_suffixes[instance.pred]);\n+    return b.finish_name ();\n+  }\n+};\n+\n SHAPE(vsetvl, vsetvl)\n SHAPE(vsetvl, vsetvlmax)\n+SHAPE(loadstore, loadstore)\n \n } // end namespace riscv_vector"}, {"sha": "b17dcd88877632b735ce031b2ba165a1943e3a3c", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -26,6 +26,7 @@ namespace riscv_vector {\n namespace shapes {\n extern const function_shape *const vsetvl;\n extern const function_shape *const vsetvlmax;\n+extern const function_shape *const loadstore;\n }\n \n } // end namespace riscv_vector"}, {"sha": "6a867c999879f78cda7e8a731121e7ab10cf8994", "filename": "gcc/config/riscv/riscv-vector-builtins-types.def", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -18,12 +18,24 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3. If not see\n <http://www.gnu.org/licenses/>. */\n \n-/* Use \"DEF_ALL_SIGNED_INTEGER\" macro include all signed integer which will be\n+/* Use \"DEF_RVV_I_OPS\" macro include all signed integer which will be\n    iterated and registered as intrinsic functions.  */\n #ifndef DEF_RVV_I_OPS\n #define DEF_RVV_I_OPS(TYPE, REQUIRE)\n #endif\n \n+/* Use \"DEF_RVV_U_OPS\" macro include all unsigned integer which will be\n+   iterated and registered as intrinsic functions.  */\n+#ifndef DEF_RVV_U_OPS\n+#define DEF_RVV_U_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_F_OPS\" macro include all floating-point which will be\n+   iterated and registered as intrinsic functions.  */\n+#ifndef DEF_RVV_F_OPS\n+#define DEF_RVV_F_OPS(TYPE, REQUIRE)\n+#endif\n+\n DEF_RVV_I_OPS (vint8mf8_t, RVV_REQUIRE_ZVE64)\n DEF_RVV_I_OPS (vint8mf4_t, 0)\n DEF_RVV_I_OPS (vint8mf2_t, 0)\n@@ -47,4 +59,39 @@ DEF_RVV_I_OPS (vint64m2_t, RVV_REQUIRE_ZVE64)\n DEF_RVV_I_OPS (vint64m4_t, RVV_REQUIRE_ZVE64)\n DEF_RVV_I_OPS (vint64m8_t, RVV_REQUIRE_ZVE64)\n \n+DEF_RVV_U_OPS (vuint8mf8_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_U_OPS (vuint8mf4_t, 0)\n+DEF_RVV_U_OPS (vuint8mf2_t, 0)\n+DEF_RVV_U_OPS (vuint8m1_t, 0)\n+DEF_RVV_U_OPS (vuint8m2_t, 0)\n+DEF_RVV_U_OPS (vuint8m4_t, 0)\n+DEF_RVV_U_OPS (vuint8m8_t, 0)\n+DEF_RVV_U_OPS (vuint16mf4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_U_OPS (vuint16mf2_t, 0)\n+DEF_RVV_U_OPS (vuint16m1_t, 0)\n+DEF_RVV_U_OPS (vuint16m2_t, 0)\n+DEF_RVV_U_OPS (vuint16m4_t, 0)\n+DEF_RVV_U_OPS (vuint16m8_t, 0)\n+DEF_RVV_U_OPS (vuint32mf2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_U_OPS (vuint32m1_t, 0)\n+DEF_RVV_U_OPS (vuint32m2_t, 0)\n+DEF_RVV_U_OPS (vuint32m4_t, 0)\n+DEF_RVV_U_OPS (vuint32m8_t, 0)\n+DEF_RVV_U_OPS (vuint64m1_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_U_OPS (vuint64m2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_U_OPS (vuint64m4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_U_OPS (vuint64m8_t, RVV_REQUIRE_ZVE64)\n+\n+DEF_RVV_F_OPS (vfloat32mf2_t, RVV_REQUIRE_ELEN_FP_32 | RVV_REQUIRE_ZVE64)\n+DEF_RVV_F_OPS (vfloat32m1_t, RVV_REQUIRE_ELEN_FP_32)\n+DEF_RVV_F_OPS (vfloat32m2_t, RVV_REQUIRE_ELEN_FP_32)\n+DEF_RVV_F_OPS (vfloat32m4_t, RVV_REQUIRE_ELEN_FP_32)\n+DEF_RVV_F_OPS (vfloat32m8_t, RVV_REQUIRE_ELEN_FP_32)\n+DEF_RVV_F_OPS (vfloat64m1_t, RVV_REQUIRE_ELEN_FP_64)\n+DEF_RVV_F_OPS (vfloat64m2_t, RVV_REQUIRE_ELEN_FP_64)\n+DEF_RVV_F_OPS (vfloat64m4_t, RVV_REQUIRE_ELEN_FP_64)\n+DEF_RVV_F_OPS (vfloat64m8_t, RVV_REQUIRE_ELEN_FP_64)\n+\n #undef DEF_RVV_I_OPS\n+#undef DEF_RVV_U_OPS\n+#undef DEF_RVV_F_OPS"}, {"sha": "9170776f97928cca63d6efe6faaf6c9c572084a1", "filename": "gcc/config/riscv/riscv-vector-builtins.cc", "status": "modified", "additions": 235, "deletions": 1, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -44,6 +44,7 @@\n #include \"attribs.h\"\n #include \"targhooks.h\"\n #include \"regs.h\"\n+#include \"emit-rtl.h\"\n #include \"riscv-vector-builtins.h\"\n #include \"riscv-vector-builtins-shapes.h\"\n #include \"riscv-vector-builtins-bases.h\"\n@@ -105,11 +106,20 @@ const char *const operand_suffixes[NUM_OP_TYPES] = {\n const rvv_builtin_suffixes type_suffixes[NUM_VECTOR_TYPES + 1] = {\n #define DEF_RVV_TYPE(NAME, NCHARS, ABI_NAME, SCALAR_TYPE, VECTOR_MODE,         \\\n \t\t     VECTOR_MODE_MIN_VLEN_32, VECTOR_SUFFIX, SCALAR_SUFFIX,    \\\n-\t\t     VSETVL_SUFFIX)                                            \\\n+\t\t     VSETVL_SUFFIX, MASK_TYPE)                                 \\\n   {#VECTOR_SUFFIX, #SCALAR_SUFFIX, #VSETVL_SUFFIX},\n #include \"riscv-vector-builtins.def\"\n };\n \n+/* Mask type for each RVV type.  */\n+const vector_type_index mask_types[NUM_VECTOR_TYPES + 1] = {\n+#define DEF_RVV_TYPE(NAME, NCHARS, ABI_NAME, SCALAR_TYPE, VECTOR_MODE,         \\\n+\t\t     VECTOR_MODE_MIN_VLEN_32, VECTOR_SUFFIX, SCALAR_SUFFIX,    \\\n+\t\t     VSETVL_SUFFIX, MASK_TYPE)                                 \\\n+  VECTOR_TYPE_##MASK_TYPE,\n+#include \"riscv-vector-builtins.def\"\n+};\n+\n /* Static information about predication suffix for each RVV type.  */\n const char *const predication_suffixes[NUM_PRED_TYPES] = {\n   \"\", /* PRED_TYPE_none.  */\n@@ -123,6 +133,14 @@ static const rvv_type_info i_ops[] = {\n #include \"riscv-vector-builtins-types.def\"\n   {NUM_VECTOR_TYPES, 0}};\n \n+/* A list of all types will be registered for intrinsic functions.  */\n+static const rvv_type_info all_ops[] = {\n+#define DEF_RVV_I_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#define DEF_RVV_U_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#define DEF_RVV_F_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n static CONSTEXPR const rvv_arg_type_info rvv_arg_type_info_end\n   = rvv_arg_type_info (NUM_BASE_TYPES);\n \n@@ -134,10 +152,28 @@ static CONSTEXPR const rvv_arg_type_info void_args[]\n static CONSTEXPR const rvv_arg_type_info size_args[]\n   = {rvv_arg_type_info (RVV_BASE_size), rvv_arg_type_info_end};\n \n+/* A list of args for vector_type func (const scalar_type *) function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_const_ptr_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_const_ptr), rvv_arg_type_info_end};\n+\n+/* A list of args for void func (scalar_type *, vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_ptr_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_const_ptr),\n+     rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n+\n /* A list of none preds that will be registered for intrinsic functions.  */\n static CONSTEXPR const predication_type_index none_preds[]\n   = {PRED_TYPE_none, NUM_PRED_TYPES};\n \n+/* vop/vop_m/vop_tu/vop_tum/vop_tumu/vop_mu will be registered.  */\n+static CONSTEXPR const predication_type_index full_preds[]\n+  = {PRED_TYPE_none, PRED_TYPE_m,  PRED_TYPE_tu,  PRED_TYPE_tum,\n+     PRED_TYPE_tumu, PRED_TYPE_mu, NUM_PRED_TYPES};\n+\n+/* vop/vop_m will be registered.  */\n+static CONSTEXPR const predication_type_index none_m_preds[]\n+  = {PRED_TYPE_none, PRED_TYPE_m, NUM_PRED_TYPES};\n+\n /* A static operand information for size_t func (void) function registration. */\n static CONSTEXPR const rvv_op_info i_none_size_void_ops\n   = {i_ops,\t\t\t\t/* Types */\n@@ -153,6 +189,22 @@ static CONSTEXPR const rvv_op_info i_none_size_size_ops\n      rvv_arg_type_info (RVV_BASE_size), /* Return type */\n      size_args /* Args */};\n \n+/* A static operand information for vector_type func (const scalar_type *)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_const_ptr_ops\n+  = {all_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     scalar_const_ptr_args /* Args */};\n+\n+/* A static operand information for void func (scalar_type *, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_ptr_ops\n+  = {all_ops,\t\t\t\t/* Types */\n+     OP_TYPE_v,\t\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_void), /* Return type */\n+     scalar_ptr_args /* Args */};\n+\n /* A list of all RVV intrinsic functions.  */\n static function_group_info function_groups[] = {\n #define DEF_RVV_FUNCTION(NAME, SHAPE, PREDS, OPS_INFO)                         \\\n@@ -362,6 +414,42 @@ check_required_extensions (uint64_t required_extensions)\n   return true;\n }\n \n+/* Return true if predication is using a real mask operand.  */\n+static bool\n+use_real_mask_p (enum predication_type_index pred)\n+{\n+  return pred == PRED_TYPE_m || pred == PRED_TYPE_tum || pred == PRED_TYPE_tumu\n+\t || pred == PRED_TYPE_mu;\n+}\n+\n+/* Return true if predication is using a real merge operand.  */\n+static bool\n+use_real_merge_p (enum predication_type_index pred)\n+{\n+  return pred == PRED_TYPE_tu || pred == PRED_TYPE_tum || pred == PRED_TYPE_tumu\n+\t || pred == PRED_TYPE_mu;\n+}\n+\n+/* Get TAIL policy for predication. If predication indicates TU, return the TU.\n+   Otherwise, return the prefer default configuration.  */\n+static rtx\n+get_tail_policy_for_pred (enum predication_type_index pred)\n+{\n+  if (pred == PRED_TYPE_tu || pred == PRED_TYPE_tum || pred == PRED_TYPE_tumu)\n+    return gen_int_mode (TAIL_UNDISTURBED, Pmode);\n+  return gen_int_mode (get_prefer_tail_policy (), Pmode);\n+}\n+\n+/* Get MASK policy for predication. If predication indicates MU, return the MU.\n+   Otherwise, return the prefer default configuration.  */\n+static rtx\n+get_mask_policy_for_pred (enum predication_type_index pred)\n+{\n+  if (pred == PRED_TYPE_tumu || pred == PRED_TYPE_mu)\n+    return gen_int_mode (MASK_UNDISTURBED, Pmode);\n+  return gen_int_mode (get_prefer_mask_policy (), Pmode);\n+}\n+\n tree\n rvv_arg_type_info::get_tree_type (vector_type_index type_idx) const\n {\n@@ -546,6 +634,28 @@ function_builder::allocate_argument_types (const function_instance &instance,\n       instance.op_info->args[i].get_tree_type (instance.type.index));\n }\n \n+/* Apply predication into argument_types.  */\n+void\n+function_builder::apply_predication (const function_instance &instance,\n+\t\t\t\t     tree return_type,\n+\t\t\t\t     vec<tree> &argument_types) const\n+{\n+  /* These predication types need to apply merge type.  */\n+  if (instance.pred == PRED_TYPE_tu || instance.pred == PRED_TYPE_tum\n+      || instance.pred == PRED_TYPE_tumu || instance.pred == PRED_TYPE_mu)\n+    argument_types.quick_insert (0, return_type);\n+\n+  /* These predication types need to apply mask type.  */\n+  tree mask_type = builtin_types[mask_types[instance.type.index]].vector;\n+  if (instance.pred == PRED_TYPE_m || instance.pred == PRED_TYPE_tum\n+      || instance.pred == PRED_TYPE_tumu || instance.pred == PRED_TYPE_mu)\n+    argument_types.quick_insert (0, mask_type);\n+\n+  /* check if vl parameter need  */\n+  if (instance.base->apply_vl_p ())\n+    argument_types.quick_push (size_type_node);\n+}\n+\n /* Register all the functions in GROUP.  */\n void\n function_builder::register_function_group (const function_group_info &group)\n@@ -560,6 +670,37 @@ function_builder::append_name (const char *name)\n   obstack_grow (&m_string_obstack, name, strlen (name));\n }\n \n+/* Add \"__riscv_\" and \"name\".  */\n+void\n+function_builder::append_base_name (const char *name)\n+{\n+  append_name (\"__riscv_\");\n+  append_name (name);\n+}\n+\n+/* Add SEW into function name.  */\n+void\n+function_builder::append_sew (int sew)\n+{\n+  switch (sew)\n+    {\n+    case 8:\n+      append_name (\"8\");\n+      break;\n+    case 16:\n+      append_name (\"16\");\n+      break;\n+    case 32:\n+      append_name (\"32\");\n+      break;\n+    case 64:\n+      append_name (\"64\");\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Zero-terminate and complete the function name being built.  */\n char *\n function_builder::finish_name ()\n@@ -694,6 +835,99 @@ function_expander::add_input_operand (unsigned argno)\n   add_input_operand (TYPE_MODE (TREE_TYPE (arg)), x);\n }\n \n+/* Since we may normalize vop/vop_tu/vop_m/vop_tumu.. into a single patter.\n+   We add a undef for the intrinsics that don't need a real merge.  */\n+void\n+function_expander::add_vundef_operand (machine_mode mode)\n+{\n+  rtx vundef = gen_rtx_UNSPEC (mode, gen_rtvec (1, const0_rtx), UNSPEC_VUNDEF);\n+  add_input_operand (mode, vundef);\n+}\n+\n+/* Add a memory operand with mode MODE and address ADDR.  */\n+rtx\n+function_expander::add_mem_operand (machine_mode mode, rtx addr)\n+{\n+  gcc_assert (VECTOR_MODE_P (mode));\n+  rtx mem = gen_rtx_MEM (mode, memory_address (mode, addr));\n+  /* The memory is only guaranteed to be element-aligned.  */\n+  set_mem_align (mem, GET_MODE_ALIGNMENT (GET_MODE_INNER (mode)));\n+  add_fixed_operand (mem);\n+  return mem;\n+}\n+\n+/* Use contiguous load INSN.  */\n+rtx\n+function_expander::use_contiguous_load_insn (insn_code icode)\n+{\n+  gcc_assert (call_expr_nargs (exp) > 0);\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+  tree mask_type = builtin_types[mask_types[type.index]].vector;\n+  machine_mode mask_mode = TYPE_MODE (mask_type);\n+\n+  /* Record the offset to get the argument.  */\n+  int arg_offset = 0;\n+\n+  if (use_real_mask_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_all_one_mask_operand (mask_mode);\n+\n+  if (use_real_merge_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_vundef_operand (mode);\n+\n+  tree addr_arg = CALL_EXPR_ARG (exp, arg_offset++);\n+  rtx addr = expand_normal (addr_arg);\n+  add_mem_operand (mode, addr);\n+\n+  for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n+    add_input_operand (argno);\n+\n+  add_input_operand (Pmode, get_tail_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+\n+  return generate_insn (icode);\n+}\n+\n+/* Use contiguous store INSN.  */\n+rtx\n+function_expander::use_contiguous_store_insn (insn_code icode)\n+{\n+  gcc_assert (call_expr_nargs (exp) > 0);\n+  machine_mode mode = TYPE_MODE (builtin_types[type.index].vector);\n+  tree mask_type = builtin_types[mask_types[type.index]].vector;\n+  machine_mode mask_mode = TYPE_MODE (mask_type);\n+\n+  /* Record the offset to get the argument.  */\n+  int arg_offset = 0;\n+\n+  int addr_loc = use_real_mask_p (pred) ? 1 : 0;\n+  tree addr_arg = CALL_EXPR_ARG (exp, addr_loc);\n+  rtx addr = expand_normal (addr_arg);\n+  rtx mem = add_mem_operand (mode, addr);\n+\n+  if (use_real_mask_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_all_one_mask_operand (mask_mode);\n+\n+  /* To model \"+m\" constraint, we include memory operand into input.  */\n+  add_input_operand (mode, mem);\n+\n+  arg_offset++;\n+  for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n+    add_input_operand (argno);\n+\n+  add_input_operand (Pmode, get_tail_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+\n+  return generate_insn (icode);\n+}\n+\n /* Generate instruction ICODE, given that its operands have already\n    been added to M_OPS.  Return the value of the first operand.  */\n rtx"}, {"sha": "7636e34d595bc49c57eca936c21e4a3ba3a949d0", "filename": "gcc/config/riscv/riscv-vector-builtins.def", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -44,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef DEF_RVV_TYPE\n #define DEF_RVV_TYPE(NAME, NCHARS, ABI_NAME, SCALAR_TYPE, VECTOR_MODE,         \\\n \t\t     VECTOR_MODE_MIN_VLEN_32, VECTOR_SUFFIX, SCALAR_SUFFIX,    \\\n-\t\t     VSETVL_SUFFIX)\n+\t\t     VSETVL_SUFFIX, MASK_TYPE)\n #endif\n \n /* Use \"DEF_RVV_OP_TYPE\" macro to define RVV operand types.\n@@ -61,212 +61,212 @@ along with GCC; see the file COPYING3.  If not see\n \n /* SEW/LMUL = 64:\n    Only enable when TARGET_MIN_VLEN > 32 and machine mode = VNx1BImode.  */\n-DEF_RVV_TYPE (vbool64_t, 14, __rvv_bool64_t, boolean, VNx1BI, VOID, _b64, , )\n+DEF_RVV_TYPE (vbool64_t, 14, __rvv_bool64_t, boolean, VNx1BI, VOID, _b64, , , vbool64_t)\n /* SEW/LMUL = 32:\n    Machine mode = VNx2BImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1BImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vbool32_t, 14, __rvv_bool32_t, boolean, VNx2BI, VNx1BI, _b32, , )\n+DEF_RVV_TYPE (vbool32_t, 14, __rvv_bool32_t, boolean, VNx2BI, VNx1BI, _b32, , , vbool32_t)\n /* SEW/LMUL = 16:\n    Machine mode = VNx2BImode when TARGET_MIN_VLEN = 32.\n    Machine mode = VNx4BImode when TARGET_MIN_VLEN > 32.  */\n-DEF_RVV_TYPE (vbool16_t, 14, __rvv_bool16_t, boolean, VNx4BI, VNx2BI, _b16, , )\n+DEF_RVV_TYPE (vbool16_t, 14, __rvv_bool16_t, boolean, VNx4BI, VNx2BI, _b16, , , vbool16_t)\n /* SEW/LMUL = 8:\n    Machine mode = VNx8BImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4BImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vbool8_t, 13, __rvv_bool8_t, boolean, VNx8BI, VNx4BI, _b8, , )\n+DEF_RVV_TYPE (vbool8_t, 13, __rvv_bool8_t, boolean, VNx8BI, VNx4BI, _b8, , , vbool8_t)\n /* SEW/LMUL = 4:\n    Machine mode = VNx16BImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8BImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vbool4_t, 13, __rvv_bool4_t, boolean, VNx16BI, VNx8BI, _b4, , )\n+DEF_RVV_TYPE (vbool4_t, 13, __rvv_bool4_t, boolean, VNx16BI, VNx8BI, _b4, , , vbool4_t)\n /* SEW/LMUL = 2:\n    Machine mode = VNx32BImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx16BImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vbool2_t, 13, __rvv_bool2_t, boolean, VNx32BI, VNx16BI, _b2, , )\n+DEF_RVV_TYPE (vbool2_t, 13, __rvv_bool2_t, boolean, VNx32BI, VNx16BI, _b2, , , vbool2_t)\n /* SEW/LMUL = 1:\n    Machine mode = VNx64BImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx32BImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vbool1_t, 13, __rvv_bool1_t, boolean, VNx64BI, VNx32BI, _b1, , )\n+DEF_RVV_TYPE (vbool1_t, 13, __rvv_bool1_t, boolean, VNx64BI, VNx32BI, _b1, , , vbool1_t)\n \n /* LMUL = 1/8:\n    Only enble when TARGET_MIN_VLEN > 32 and machine mode = VNx1QImode.  */\n DEF_RVV_TYPE (vint8mf8_t, 15, __rvv_int8mf8_t, intQI, VNx1QI, VOID, _i8mf8, _i8,\n-\t      _e8mf8)\n+\t      _e8mf8, vbool64_t)\n DEF_RVV_TYPE (vuint8mf8_t, 16, __rvv_uint8mf8_t, unsigned_intQI, VNx1QI, VOID,\n-\t      _u8mf8, _u8, _e8mf8)\n+\t      _u8mf8, _u8, _e8mf8, vbool64_t)\n /* LMUL = 1/4:\n    Machine mode = VNx2QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1QImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint8mf4_t, 15, __rvv_int8mf4_t, intQI, VNx2QI, VNx1QI, _i8mf4,\n-\t      _i8, _e8mf4)\n+\t      _i8, _e8mf4, vbool32_t)\n DEF_RVV_TYPE (vuint8mf4_t, 16, __rvv_uint8mf4_t, unsigned_intQI, VNx2QI, VNx1QI,\n-\t      _u8mf4, _u8, _e8mf4)\n+\t      _u8mf4, _u8, _e8mf4, vbool32_t)\n /* LMUL = 1/2:\n    Machine mode = VNx4QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx2QImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint8mf2_t, 15, __rvv_int8mf2_t, intQI, VNx4QI, VNx2QI, _i8mf2,\n-\t      _i8, _e8mf2)\n+\t      _i8, _e8mf2, vbool16_t)\n DEF_RVV_TYPE (vuint8mf2_t, 16, __rvv_uint8mf2_t, unsigned_intQI, VNx4QI, VNx2QI,\n-\t      _u8mf2, _u8, _e8mf2)\n+\t      _u8mf2, _u8, _e8mf2, vbool16_t)\n /* LMUL = 1:\n    Machine mode = VNx8QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4QImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint8m1_t, 14, __rvv_int8m1_t, intQI, VNx8QI, VNx4QI, _i8m1, _i8,\n-\t      _e8m1)\n+\t      _e8m1, vbool8_t)\n DEF_RVV_TYPE (vuint8m1_t, 15, __rvv_uint8m1_t, unsigned_intQI, VNx8QI, VNx4QI,\n-\t      _u8m1, _u8, _e8m1)\n+\t      _u8m1, _u8, _e8m1, vbool8_t)\n /* LMUL = 2:\n    Machine mode = VNx16QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8QImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint8m2_t, 14, __rvv_int8m2_t, intQI, VNx16QI, VNx8QI, _i8m2, _i8,\n-\t      _e8m2)\n+\t      _e8m2, vbool4_t)\n DEF_RVV_TYPE (vuint8m2_t, 15, __rvv_uint8m2_t, unsigned_intQI, VNx16QI, VNx8QI,\n-\t      _u8m2, _u8, _e8m2)\n+\t      _u8m2, _u8, _e8m2, vbool4_t)\n /* LMUL = 4:\n    Machine mode = VNx32QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx16QImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint8m4_t, 14, __rvv_int8m4_t, intQI, VNx32QI, VNx16QI, _i8m4,\n-\t      _i8, _e8m4)\n+\t      _i8, _e8m4, vbool2_t)\n DEF_RVV_TYPE (vuint8m4_t, 15, __rvv_uint8m4_t, unsigned_intQI, VNx32QI, VNx16QI,\n-\t      _u8m4, _u8, _e8m4)\n+\t      _u8m4, _u8, _e8m4, vbool2_t)\n /* LMUL = 8:\n    Machine mode = VNx64QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx32QImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint8m8_t, 14, __rvv_int8m8_t, intQI, VNx64QI, VNx32QI, _i8m8,\n-\t      _i8, _e8m8)\n+\t      _i8, _e8m8, vbool1_t)\n DEF_RVV_TYPE (vuint8m8_t, 15, __rvv_uint8m8_t, unsigned_intQI, VNx64QI, VNx32QI,\n-\t      _u8m8, _u8, _e8m8)\n+\t      _u8m8, _u8, _e8m8, vbool1_t)\n \n /* LMUL = 1/4:\n    Only enble when TARGET_MIN_VLEN > 32 and machine mode = VNx1HImode.  */\n DEF_RVV_TYPE (vint16mf4_t, 16, __rvv_int16mf4_t, intHI, VNx1HI, VOID, _i16mf4,\n-\t      _i16, _e16mf4)\n+\t      _i16, _e16mf4, vbool64_t)\n DEF_RVV_TYPE (vuint16mf4_t, 17, __rvv_uint16mf4_t, unsigned_intHI, VNx1HI, VOID,\n-\t      _u16mf4, _u16, _e16mf4)\n+\t      _u16mf4, _u16, _e16mf4, vbool64_t)\n /* LMUL = 1/2:\n    Machine mode = VNx2HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1HImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint16mf2_t, 16, __rvv_int16mf2_t, intHI, VNx2HI, VNx1HI, _i16mf2,\n-\t      _i16, _e16mf2)\n+\t      _i16, _e16mf2, vbool32_t)\n DEF_RVV_TYPE (vuint16mf2_t, 17, __rvv_uint16mf2_t, unsigned_intHI, VNx2HI,\n-\t      VNx1HI, _u16mf2, _u16, _e16mf2)\n+\t      VNx1HI, _u16mf2, _u16, _e16mf2, vbool32_t)\n /* LMUL = 1:\n    Machine mode = VNx4HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx2HImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint16m1_t, 15, __rvv_int16m1_t, intHI, VNx4HI, VNx2HI, _i16m1,\n-\t      _i16, _e16m1)\n+\t      _i16, _e16m1, vbool16_t)\n DEF_RVV_TYPE (vuint16m1_t, 16, __rvv_uint16m1_t, unsigned_intHI, VNx4HI, VNx2HI,\n-\t      _u16m1, _u16, _e16m1)\n+\t      _u16m1, _u16, _e16m1, vbool16_t)\n /* LMUL = 2:\n    Machine mode = VNx8HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4HImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint16m2_t, 15, __rvv_int16m2_t, intHI, VNx8HI, VNx4HI, _i16m2,\n-\t      _i16, _e16m2)\n+\t      _i16, _e16m2, vbool8_t)\n DEF_RVV_TYPE (vuint16m2_t, 16, __rvv_uint16m2_t, unsigned_intHI, VNx8HI, VNx4HI,\n-\t      _u16m2, _u16, _e16m2)\n+\t      _u16m2, _u16, _e16m2, vbool8_t)\n /* LMUL = 4:\n    Machine mode = VNx16HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8HImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint16m4_t, 15, __rvv_int16m4_t, intHI, VNx16HI, VNx8HI, _i16m4,\n-\t      _i16, _e16m4)\n+\t      _i16, _e16m4, vbool4_t)\n DEF_RVV_TYPE (vuint16m4_t, 16, __rvv_uint16m4_t, unsigned_intHI, VNx16HI,\n-\t      VNx8HI, _u16m4, _u16, _e16m4)\n+\t      VNx8HI, _u16m4, _u16, _e16m4, vbool4_t)\n /* LMUL = 8:\n    Machine mode = VNx32HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx16HImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint16m8_t, 15, __rvv_int16m8_t, intHI, VNx32HI, VNx16HI, _i16m8,\n-\t      _i16, _e16m8)\n+\t      _i16, _e16m8, vbool2_t)\n DEF_RVV_TYPE (vuint16m8_t, 16, __rvv_uint16m8_t, unsigned_intHI, VNx32HI,\n-\t      VNx16HI, _u16m8, _u16, _e16m8)\n+\t      VNx16HI, _u16m8, _u16, _e16m8, vbool2_t)\n \n /* LMUL = 1/2:\n    Only enble when TARGET_MIN_VLEN > 32 and machine mode = VNx1SImode.  */\n DEF_RVV_TYPE (vint32mf2_t, 16, __rvv_int32mf2_t, int32, VNx1SI, VOID, _i32mf2,\n-\t      _i32, _e32mf2)\n+\t      _i32, _e32mf2, vbool64_t)\n DEF_RVV_TYPE (vuint32mf2_t, 17, __rvv_uint32mf2_t, unsigned_int32, VNx1SI, VOID,\n-\t      _u32mf2, _u32, _e32mf2)\n+\t      _u32mf2, _u32, _e32mf2, vbool64_t)\n /* LMUL = 1:\n    Machine mode = VNx2SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1SImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint32m1_t, 15, __rvv_int32m1_t, int32, VNx2SI, VNx1SI, _i32m1,\n-\t      _i32, _e32m1)\n+\t      _i32, _e32m1, vbool32_t)\n DEF_RVV_TYPE (vuint32m1_t, 16, __rvv_uint32m1_t, unsigned_int32, VNx2SI, VNx1SI,\n-\t      _u32m1, _u32, _e32m1)\n+\t      _u32m1, _u32, _e32m1, vbool32_t)\n /* LMUL = 2:\n    Machine mode = VNx4SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx2SImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint32m2_t, 15, __rvv_int32m2_t, int32, VNx4SI, VNx2SI, _i32m2,\n-\t      _i32, _e32m2)\n+\t      _i32, _e32m2, vbool16_t)\n DEF_RVV_TYPE (vuint32m2_t, 16, __rvv_uint32m2_t, unsigned_int32, VNx4SI, VNx2SI,\n-\t      _u32m2, _u32, _e32m2)\n+\t      _u32m2, _u32, _e32m2, vbool16_t)\n /* LMUL = 4:\n    Machine mode = VNx8SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4SImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint32m4_t, 15, __rvv_int32m4_t, int32, VNx8SI, VNx4SI, _i32m4,\n-\t      _i32, _e32m4)\n+\t      _i32, _e32m4, vbool8_t)\n DEF_RVV_TYPE (vuint32m4_t, 16, __rvv_uint32m4_t, unsigned_int32, VNx8SI, VNx4SI,\n-\t      _u32m4, _u32, _e32m4)\n+\t      _u32m4, _u32, _e32m4, vbool8_t)\n /* LMUL = 8:\n    Machine mode = VNx16SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8SImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint32m8_t, 15, __rvv_int32m8_t, int32, VNx16SI, VNx8SI, _i32m8,\n-\t      _i32, _e32m8)\n+\t      _i32, _e32m8, vbool4_t)\n DEF_RVV_TYPE (vuint32m8_t, 16, __rvv_uint32m8_t, unsigned_int32, VNx16SI,\n-\t      VNx8SI, _u32m8, _u32, _e32m8)\n+\t      VNx8SI, _u32m8, _u32, _e32m8, vbool4_t)\n \n /* SEW = 64:\n    Disable when TARGET_MIN_VLEN > 32.  */\n DEF_RVV_TYPE (vint64m1_t, 15, __rvv_int64m1_t, intDI, VNx1DI, VOID, _i64m1,\n-\t      _i64, _e64m1)\n+\t      _i64, _e64m1, vbool64_t)\n DEF_RVV_TYPE (vuint64m1_t, 16, __rvv_uint64m1_t, unsigned_intDI, VNx1DI, VOID,\n-\t      _u64m1, _u64, _e64m1)\n+\t      _u64m1, _u64, _e64m1, vbool64_t)\n DEF_RVV_TYPE (vint64m2_t, 15, __rvv_int64m2_t, intDI, VNx2DI, VOID, _i64m2,\n-\t      _i64, _e64m2)\n+\t      _i64, _e64m2, vbool32_t)\n DEF_RVV_TYPE (vuint64m2_t, 16, __rvv_uint64m2_t, unsigned_intDI, VNx2DI, VOID,\n-\t      _u64m2, _u64, _e64m2)\n+\t      _u64m2, _u64, _e64m2, vbool32_t)\n DEF_RVV_TYPE (vint64m4_t, 15, __rvv_int64m4_t, intDI, VNx4DI, VOID, _i64m4,\n-\t      _i64, _e64m4)\n+\t      _i64, _e64m4, vbool16_t)\n DEF_RVV_TYPE (vuint64m4_t, 16, __rvv_uint64m4_t, unsigned_intDI, VNx4DI, VOID,\n-\t      _u64m4, _u64, _e64m4)\n+\t      _u64m4, _u64, _e64m4, vbool16_t)\n DEF_RVV_TYPE (vint64m8_t, 15, __rvv_int64m8_t, intDI, VNx8DI, VOID, _i64m8,\n-\t      _i64, _e64m8)\n+\t      _i64, _e64m8, vbool8_t)\n DEF_RVV_TYPE (vuint64m8_t, 16, __rvv_uint64m8_t, unsigned_intDI, VNx8DI, VOID,\n-\t      _u64m8, _u64, _e64m8)\n+\t      _u64m8, _u64, _e64m8, vbool8_t)\n \n /* LMUL = 1/2:\n    Only enble when TARGET_MIN_VLEN > 32 and machine mode = VNx1SFmode.  */\n DEF_RVV_TYPE (vfloat32mf2_t, 18, __rvv_float32mf2_t, float, VNx1SF, VOID,\n-\t      _f32mf2, _f32, _e32mf2)\n+\t      _f32mf2, _f32, _e32mf2, vbool64_t)\n /* LMUL = 1:\n    Machine mode = VNx2SFmode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1SFmode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vfloat32m1_t, 17, __rvv_float32m1_t, float, VNx2SF, VNx1SF,\n-\t      _f32m1, _f32, _e32m1)\n+\t      _f32m1, _f32, _e32m1, vbool32_t)\n /* LMUL = 2:\n    Machine mode = VNx4SFmode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx2SFmode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vfloat32m2_t, 17, __rvv_float32m2_t, float, VNx4SF, VNx2SF,\n-\t      _f32m2, _f32, _e32m2)\n+\t      _f32m2, _f32, _e32m2, vbool16_t)\n /* LMUL = 4:\n    Machine mode = VNx8SFmode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4SFmode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vfloat32m4_t, 17, __rvv_float32m4_t, float, VNx8SF, VNx4SF,\n-\t      _f32m4, _f32, _e32m4)\n+\t      _f32m4, _f32, _e32m4, vbool8_t)\n /* LMUL = 8:\n    Machine mode = VNx16SFmode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8SFmode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vfloat32m8_t, 17, __rvv_float32m8_t, float, VNx16SF, VNx8SF,\n-\t      _f32m8, _f32, _e32m8)\n+\t      _f32m8, _f32, _e32m8, vbool4_t)\n \n /* SEW = 64:\n    Disable when TARGET_VECTOR_FP64.  */\n DEF_RVV_TYPE (vfloat64m1_t, 17, __rvv_float64m1_t, double, VNx1DF, VOID, _f64m1,\n-\t      _f64, _e64m1)\n+\t      _f64, _e64m1, vbool64_t)\n DEF_RVV_TYPE (vfloat64m2_t, 17, __rvv_float64m2_t, double, VNx2DF, VOID, _f64m2,\n-\t      _f64, _e64m2)\n+\t      _f64, _e64m2, vbool32_t)\n DEF_RVV_TYPE (vfloat64m4_t, 17, __rvv_float64m4_t, double, VNx4DF, VOID, _f64m4,\n-\t      _f64, _e64m4)\n+\t      _f64, _e64m4, vbool16_t)\n DEF_RVV_TYPE (vfloat64m8_t, 17, __rvv_float64m8_t, double, VNx8DF, VOID, _f64m8,\n-\t      _f64, _e64m8)\n+\t      _f64, _e64m8, vbool8_t)\n \n DEF_RVV_OP_TYPE (vv)\n DEF_RVV_OP_TYPE (vx)"}, {"sha": "c13df99cb5b1e9d8c9c6dcee9c49f495ee9c4092", "filename": "gcc/config/riscv/riscv-vector-builtins.h", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -264,10 +264,13 @@ class function_builder\n   ~function_builder ();\n \n   void allocate_argument_types (const function_instance &, vec<tree> &) const;\n+  void apply_predication (const function_instance &, tree, vec<tree> &) const;\n   void add_unique_function (const function_instance &, const function_shape *,\n \t\t\t    tree, vec<tree> &);\n   void register_function_group (const function_group_info &);\n   void append_name (const char *);\n+  void append_base_name (const char *);\n+  void append_sew (int);\n   char *finish_name ();\n \n private:\n@@ -315,6 +318,16 @@ class function_expander : public function_call_info\n \n   void add_input_operand (machine_mode, rtx);\n   void add_input_operand (unsigned argno);\n+  void add_output_operand (machine_mode, rtx);\n+  void add_all_one_mask_operand (machine_mode mode);\n+  void add_vundef_operand (machine_mode mode);\n+  void add_fixed_operand (rtx);\n+  rtx add_mem_operand (machine_mode, rtx);\n+\n+  machine_mode vector_mode (void) const;\n+\n+  rtx use_contiguous_load_insn (insn_code);\n+  rtx use_contiguous_store_insn (insn_code);\n   rtx generate_insn (insn_code);\n \n   /* The function call expression.  */\n@@ -342,6 +355,12 @@ class function_base\n      in addition to reading its arguments and returning a result.  */\n   virtual unsigned int call_properties (const function_instance &) const;\n \n+  /* Return true if intrinsics should apply vl operand.  */\n+  virtual bool apply_vl_p () const;\n+\n+  /* Return true if intrinsic can be overloaded.  */\n+  virtual bool can_be_overloaded_p (enum predication_type_index) const;\n+\n   /* Expand the given call into rtl.  Return the result of the function,\n      or an arbitrary value if the function doesn't return a result.  */\n   virtual rtx expand (function_expander &) const = 0;\n@@ -394,6 +413,37 @@ function_expander::add_input_operand (machine_mode mode, rtx op)\n   create_input_operand (&m_ops[opno++], op, mode);\n }\n \n+/* Create output and add it into M_OPS and increase OPNO.  */\n+inline void\n+function_expander::add_output_operand (machine_mode mode, rtx target)\n+{\n+  create_output_operand (&m_ops[opno++], target, mode);\n+}\n+\n+/* Since we may normalize vop/vop_tu/vop_m/vop_tumu.. into a single patter.\n+   We add a fake all true mask for the intrinsics that don't need a real mask.\n+ */\n+inline void\n+function_expander::add_all_one_mask_operand (machine_mode mode)\n+{\n+  add_input_operand (mode, CONSTM1_RTX (mode));\n+}\n+\n+/* Add an operand that must be X.  The only way of legitimizing an\n+   invalid X is to reload the address of a MEM.  */\n+inline void\n+function_expander::add_fixed_operand (rtx x)\n+{\n+  create_fixed_operand (&m_ops[opno++], x);\n+}\n+\n+/* Return the machine_mode of the corresponding vector type.  */\n+inline machine_mode\n+function_expander::vector_mode (void) const\n+{\n+  return TYPE_MODE (builtin_types[type.index].vector);\n+}\n+\n /* Default implementation of function_base::call_properties, with conservatively\n    correct behavior for floating-point instructions.  */\n inline unsigned int\n@@ -405,6 +455,21 @@ function_base::call_properties (const function_instance &instance) const\n   return flags;\n }\n \n+/* We choose to apply vl operand by default since most of the intrinsics\n+   has vl operand.  */\n+inline bool\n+function_base::apply_vl_p () const\n+{\n+  return true;\n+}\n+\n+/* Since most of intrinsics can be overloaded, we set it true by default.  */\n+inline bool\n+function_base::can_be_overloaded_p (enum predication_type_index) const\n+{\n+  return true;\n+}\n+\n } // end namespace riscv_vector\n \n #endif"}, {"sha": "01530c1ae75f1f1c06f18f58bd7ee753d4472c66", "filename": "gcc/config/riscv/riscv-vsetvl.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -302,10 +302,6 @@ get_vl (rtx_insn *rinsn)\n {\n   if (has_vl_op (rinsn))\n     {\n-      /* We only call get_vl for VLMAX use VTYPE instruction.\n-\t It's used to get the VL operand to emit VLMAX VSETVL instruction:\n-\t vsetvl a5,zero,e32,m1,ta,ma.  */\n-      gcc_assert (get_attr_avl_type (rinsn) == VLMAX);\n       extract_insn_cached (rinsn);\n       return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n     }"}, {"sha": "d30e02353568cf43558a105e4116481ed6b4ffd8", "filename": "gcc/config/riscv/t-riscv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Ft-riscv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3/gcc%2Fconfig%2Friscv%2Ft-riscv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-riscv?ref=a143c3f7a61c61bb5a5e099fdb59f3adbf99b6b3", "patch": "@@ -9,7 +9,7 @@ riscv-vector-builtins.o: $(srcdir)/config/riscv/riscv-vector-builtins.cc \\\n   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) $(TM_P_H) \\\n   memmodel.h insn-codes.h $(OPTABS_H) $(RECOG_H) $(DIAGNOSTIC_H) $(EXPR_H) \\\n   $(FUNCTION_H) fold-const.h gimplify.h explow.h stor-layout.h $(REGS_H) \\\n-  alias.h langhooks.h attribs.h stringpool.h \\\n+  alias.h langhooks.h attribs.h stringpool.h emit-rtl.h \\\n   $(srcdir)/config/riscv/riscv-vector-builtins.h \\\n   $(srcdir)/config/riscv/riscv-vector-builtins-shapes.h \\\n   $(srcdir)/config/riscv/riscv-vector-builtins-bases.h \\"}]}