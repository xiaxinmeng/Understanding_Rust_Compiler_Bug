{"sha": "f27cd94df5ccb68dffbe513a8c26f52c52eb708d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI3Y2Q5NGRmNWNjYjY4ZGZmYmU1MTNhOGMyNmY1MmM1MmViNzA4ZA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2000-09-21T17:33:51Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-09-21T17:33:51Z"}, "message": "Fix compile time warnings\n\nFrom-SVN: r36562", "tree": {"sha": "53b6edb2b177b1a00587e4a7d75de52e61b4c54d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53b6edb2b177b1a00587e4a7d75de52e61b4c54d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f27cd94df5ccb68dffbe513a8c26f52c52eb708d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f27cd94df5ccb68dffbe513a8c26f52c52eb708d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f27cd94df5ccb68dffbe513a8c26f52c52eb708d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f27cd94df5ccb68dffbe513a8c26f52c52eb708d/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d5d6f3f8c527645b078157e6c2b691a0538d598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d5d6f3f8c527645b078157e6c2b691a0538d598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d5d6f3f8c527645b078157e6c2b691a0538d598"}], "stats": {"total": 262, "additions": 141, "deletions": 121}, "files": [{"sha": "182f6c36122acc85cb41fc27b52c34b49d05366e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27cd94df5ccb68dffbe513a8c26f52c52eb708d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27cd94df5ccb68dffbe513a8c26f52c52eb708d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f27cd94df5ccb68dffbe513a8c26f52c52eb708d", "patch": "@@ -1,3 +1,8 @@\n+2000-09-21  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/mcore/mcore.c: Fix compile time warnings.\n+\t* config/mcore/mcore-protos.h: Fix compile time warnings. \n+\n 2000-09-20  J. David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* configure.in: Correct test of gcc_cv_glibc."}, {"sha": "50af00819f4cf44f7809ba0cb0477bb829b909cd", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27cd94df5ccb68dffbe513a8c26f52c52eb708d/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27cd94df5ccb68dffbe513a8c26f52c52eb708d/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=f27cd94df5ccb68dffbe513a8c26f52c52eb708d", "patch": "@@ -1,6 +1,6 @@\n /* Prototypes for exported functions defined in mcore.c\n    Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Nick Clifton (nickc@cygnus.com)\n+   Contributed by Nick Clifton (nickc@redhat.com)\n \n This file is part of GNU CC.\n \n@@ -19,36 +19,36 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-extern char * mcore_output_jump_label_table\tPARAMS ((void));\n-extern void   mcore_expand_prolog          \tPARAMS ((void));\n-extern void   mcore_expand_epilog          \tPARAMS ((void));\n-extern int    mcore_const_ok_for_inline    \tPARAMS ((long));\n-extern int    mcore_num_ones               \tPARAMS ((int));\n-extern int    mcore_num_zeros              \tPARAMS ((int));\n-extern int    mcore_initial_elimination_offset\tPARAMS ((int, int));\n-extern int    mcore_byte_offset            \tPARAMS ((unsigned int));\n-extern int    mcore_halfword_offset        \tPARAMS ((unsigned int));\n-extern int    mcore_const_trick_uses_not   \tPARAMS ((long));\n-extern void   mcore_override_options       \tPARAMS ((void));\n-extern int    mcore_dllexport_name_p       \tPARAMS ((const char *));\n-extern int    mcore_dllimport_name_p       \tPARAMS ((const char *));\n-extern int    mcore_naked_function_p       \tPARAMS ((void));\n+extern const char * mcore_output_jump_label_table\tPARAMS ((void));\n+extern void         mcore_expand_prolog          \tPARAMS ((void));\n+extern void         mcore_expand_epilog          \tPARAMS ((void));\n+extern int          mcore_const_ok_for_inline    \tPARAMS ((long));\n+extern int          mcore_num_ones               \tPARAMS ((int));\n+extern int          mcore_num_zeros              \tPARAMS ((int));\n+extern int          mcore_initial_elimination_offset\tPARAMS ((int, int));\n+extern int          mcore_byte_offset            \tPARAMS ((unsigned int));\n+extern int          mcore_halfword_offset        \tPARAMS ((unsigned int));\n+extern int          mcore_const_trick_uses_not   \tPARAMS ((long));\n+extern void         mcore_override_options       \tPARAMS ((void));\n+extern int          mcore_dllexport_name_p       \tPARAMS ((const char *));\n+extern int          mcore_dllimport_name_p       \tPARAMS ((const char *));\n+extern int          mcore_naked_function_p       \tPARAMS ((void));\n \n #ifdef TREE_CODE\n-extern void   mcore_unique_section         \tPARAMS ((tree, int));\n-extern void   mcore_encode_section_info    \tPARAMS ((tree));\n-extern int    mcore_valid_machine_decl_attribute PARAMS ((tree, tree, tree, tree));\n-extern tree   mcore_merge_machine_decl_attributes PARAMS ((tree, tree));\n+extern void         mcore_unique_section         \tPARAMS ((tree, int));\n+extern void         mcore_encode_section_info    \tPARAMS ((tree));\n+extern int          mcore_valid_machine_decl_attribute\tPARAMS ((tree, tree, tree, tree));\n+extern tree         mcore_merge_machine_decl_attributes PARAMS ((tree, tree));\n \n #ifdef HAVE_MACHINE_MODES\n-extern int    mcore_function_arg_partial_nregs\tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int));\n-extern void   mcore_setup_incoming_varargs\tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int *));\n-extern int    mcore_num_arg_regs           \tPARAMS ((enum machine_mode, tree));\n-extern int    mcore_must_pass_on_stack     \tPARAMS ((enum machine_mode, tree));\n+extern int          mcore_function_arg_partial_nregs\tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int));\n+extern void         mcore_setup_incoming_varargs\tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int *));\n+extern int          mcore_num_arg_regs           \tPARAMS ((enum machine_mode, tree));\n+extern int          mcore_must_pass_on_stack     \tPARAMS ((enum machine_mode, tree));\n #endif /* HAVE_MACHINE_MODES */\n \n #ifdef RTX_CODE\n-extern rtx  mcore_function_value         PARAMS ((tree, tree));\n+extern rtx          mcore_function_value         \tPARAMS ((tree, tree));\n #endif /* RTX_CODE */\n #endif /* TREE_CODE */\n \n@@ -57,53 +57,53 @@ extern rtx  mcore_function_value         PARAMS ((tree, tree));\n extern rtx arch_compare_op0;\n extern rtx arch_compare_op1;\n \n-extern char * mcore_output_bclri         \tPARAMS ((rtx, int));\n-extern char * mcore_output_bseti         \tPARAMS ((rtx, int));\n-extern char * mcore_output_cmov          \tPARAMS ((rtx *, int, char *));\n-extern char * mcore_output_call          \tPARAMS ((rtx *, int));\n-extern int    mcore_is_dead                \tPARAMS ((rtx, rtx));\n-extern int    mcore_expand_insv            \tPARAMS ((rtx *));\n-extern int    mcore_modify_comparison      \tPARAMS ((RTX_CODE));\n-extern void   mcore_expand_block_move      \tPARAMS ((rtx, rtx, rtx *));\n-extern rtx    mcore_dependent_simplify_rtx \tPARAMS ((rtx, int, int, int, int *));\n-extern void   mcore_dependent_reorg        \tPARAMS ((rtx));\n-extern int    mcore_const_costs            \tPARAMS ((rtx, RTX_CODE));\n-extern int    mcore_and_cost               \tPARAMS ((rtx));\n-extern int    mcore_ior_cost               \tPARAMS ((rtx));\n-extern char * mcore_output_andn          \tPARAMS ((rtx, rtx *));\n-extern void   mcore_print_operand_address  \tPARAMS ((FILE *, rtx));\n-extern void   mcore_print_operand          \tPARAMS ((FILE *, rtx, int));\n-extern rtx    mcore_gen_compare_reg        \tPARAMS ((RTX_CODE));\n-extern int    mcore_symbolic_address_p     \tPARAMS ((rtx));\n-extern enum reg_class mcore_reload_class \tPARAMS ((rtx, enum reg_class));\n-extern int    mcore_is_same_reg            \tPARAMS ((rtx, rtx));\n-extern int    mcore_arith_S_operand         \tPARAMS ((rtx));\n+extern const char * mcore_output_bclri         \t\tPARAMS ((rtx, int));\n+extern const char * mcore_output_bseti         \t\tPARAMS ((rtx, int));\n+extern const char * mcore_output_cmov          \t\tPARAMS ((rtx *, int, char *));\n+extern char *       mcore_output_call          \t\tPARAMS ((rtx *, int));\n+extern int          mcore_is_dead                \tPARAMS ((rtx, rtx));\n+extern int          mcore_expand_insv            \tPARAMS ((rtx *));\n+extern int          mcore_modify_comparison      \tPARAMS ((RTX_CODE));\n+extern void         mcore_expand_block_move      \tPARAMS ((rtx, rtx, rtx *));\n+extern rtx          mcore_dependent_simplify_rtx\tPARAMS ((rtx, int, int, int, int *));\n+extern void         mcore_dependent_reorg        \tPARAMS ((rtx));\n+extern int          mcore_const_costs            \tPARAMS ((rtx, RTX_CODE));\n+extern int          mcore_and_cost               \tPARAMS ((rtx));\n+extern int          mcore_ior_cost               \tPARAMS ((rtx));\n+extern const char * mcore_output_andn          \t\tPARAMS ((rtx, rtx *));\n+extern void         mcore_print_operand_address  \tPARAMS ((FILE *, rtx));\n+extern void         mcore_print_operand          \tPARAMS ((FILE *, rtx, int));\n+extern rtx          mcore_gen_compare_reg        \tPARAMS ((RTX_CODE));\n+extern int          mcore_symbolic_address_p     \tPARAMS ((rtx));\n+extern enum reg_class mcore_reload_class \t\tPARAMS ((rtx, enum reg_class));\n+extern int          mcore_is_same_reg            \tPARAMS ((rtx, rtx));\n+extern int          mcore_arith_S_operand         \tPARAMS ((rtx));\n \n #ifdef HAVE_MACHINE_MODES\n-extern char * mcore_output_move          \tPARAMS ((rtx, rtx *, enum machine_mode));\n-extern char * mcore_output_movedouble    \tPARAMS ((rtx *, enum machine_mode));\n-extern char * mcore_output_inline_const_forced\tPARAMS ((rtx, rtx *, enum machine_mode));\n-extern int    mcore_arith_reg_operand       \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_general_movsrc_operand  \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_general_movdst_operand  \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_reload_operand          \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_arith_J_operand         \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_arith_K_operand         \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_arith_K_operand_not_0   \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_arith_M_operand         \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_arith_K_S_operand       \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_arith_imm_operand       \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_arith_any_imm_operand   \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_arith_O_operand         \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_literal_K_operand       \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_addsub_operand          \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_compare_operand         \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_load_multiple_operation \tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_store_multiple_operation\tPARAMS ((rtx, enum machine_mode));\n-extern int    mcore_call_address_operand    \tPARAMS ((rtx, enum machine_mode));\n+extern const char * mcore_output_move          \t\tPARAMS ((rtx, rtx *, enum machine_mode));\n+extern const char * mcore_output_movedouble    \t\tPARAMS ((rtx *, enum machine_mode));\n+extern const char * mcore_output_inline_const_forced\tPARAMS ((rtx, rtx *, enum machine_mode));\n+extern int          mcore_arith_reg_operand       \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_general_movsrc_operand  \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_general_movdst_operand  \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_reload_operand          \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_arith_J_operand         \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_arith_K_operand         \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_arith_K_operand_not_0   \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_arith_M_operand         \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_arith_K_S_operand       \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_arith_imm_operand       \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_arith_any_imm_operand   \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_arith_O_operand         \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_literal_K_operand       \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_addsub_operand          \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_compare_operand         \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_load_multiple_operation \tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_store_multiple_operation\tPARAMS ((rtx, enum machine_mode));\n+extern int          mcore_call_address_operand    \tPARAMS ((rtx, enum machine_mode));\n \n #ifdef TREE_CODE\n-extern rtx    mcore_function_arg           \tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int));\n+extern rtx          mcore_function_arg           \tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int));\n #endif /* TREE_CODE */\n #endif /* HAVE_MACHINE_MODES */\n #endif /* RTX_CODE */"}, {"sha": "603b70c86f91532873078c90c3bc5f91a2f17408", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 69, "deletions": 54, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27cd94df5ccb68dffbe513a8c26f52c52eb708d/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27cd94df5ccb68dffbe513a8c26f52c52eb708d/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=f27cd94df5ccb68dffbe513a8c26f52c52eb708d", "patch": "@@ -44,9 +44,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"toplev.h\"\n #include \"mcore-protos.h\"\n \n-static int const_ok_for_mcore  PARAMS ((int));\n-static int try_constant_tricks PARAMS ((long, int *, int *));\n-\n /* Maximum size we are allowed to grow the stack in a single operation.\n    If we want more, we must do it in increments of at most this size.\n    If this value is 0, we don't check at all.  */\n@@ -88,6 +85,54 @@ enum reg_class reg_class_from_letter[] =\n   /* y */ NO_REGS, /* z */ NO_REGS\n };\n \n+struct mcore_frame\n+{\n+  int arg_size;\t\t\t/* stdarg spills (bytes) */\n+  int reg_size;\t\t\t/* non-volatile reg saves (bytes) */\n+  int reg_mask;\t\t\t/* non-volatile reg saves */\n+  int local_size;\t\t/* locals */\n+  int outbound_size;\t\t/* arg overflow on calls out */\n+  int pad_outbound;\n+  int pad_local;\n+  int pad_reg;\n+  /* Describe the steps we'll use to grow it.  */\n+#define\tMAX_STACK_GROWS\t4\t/* gives us some spare space */\n+  int growth[MAX_STACK_GROWS];\n+  int arg_offset;\n+  int reg_offset;\n+  int reg_growth;\n+  int local_growth;\n+};\n+\n+typedef enum\n+{\n+  COND_NO,\n+  COND_MOV_INSN,\n+  COND_CLR_INSN,\n+  COND_INC_INSN,\n+  COND_DEC_INSN,\n+  COND_BRANCH_INSN\n+}\n+cond_type;\n+\n+static void       output_stack_adjust          PARAMS ((int, int));\n+static int        calc_live_regs               PARAMS ((int *));\n+static int        const_ok_for_mcore           PARAMS ((int));\n+static int        try_constant_tricks          PARAMS ((long, int *, int *));\n+static const char *     output_inline_const          PARAMS ((enum machine_mode, rtx *));\n+static void       block_move_sequence          PARAMS ((rtx, rtx, rtx, rtx, int, int, int));\n+static void       layout_mcore_frame           PARAMS ((struct mcore_frame *));\n+static cond_type  is_cond_candidate            PARAMS ((rtx));\n+static rtx        emit_new_cond_insn           PARAMS ((rtx, int));\n+static rtx        conditionalize_block         PARAMS ((rtx));\n+static void       conditionalize_optimization  PARAMS ((rtx));\n+static void       mcore_add_gc_roots           PARAMS ((void));\n+static rtx        handle_structs_in_regs       PARAMS ((enum machine_mode, tree, int));\n+static void       mcore_mark_dllexport         PARAMS ((tree));\n+static void       mcore_mark_dllimport         PARAMS ((tree));\n+static int        mcore_dllexport_p            PARAMS ((tree));\n+static int        mcore_dllimport_p            PARAMS ((tree));\n+\f\n /* Adjust the stack and return the number of bytes taken to do it.  */\n static void\n output_stack_adjust (direction, size)\n@@ -507,6 +552,7 @@ mcore_call_address_operand (x, mode)\n }\n \n /* Functions to output assembly code for a function call.  */\n+\n char *\n mcore_output_call (operands, index)\n      rtx operands[];\n@@ -831,7 +877,7 @@ mcore_halfword_offset (mask)\n }\n \n /* Output a series of bseti's corresponding to mask.  */\n-char *\n+const char *\n mcore_output_bseti (dst, mask)\n      rtx dst;\n      int mask;\n@@ -856,7 +902,7 @@ mcore_output_bseti (dst, mask)\n }\n \n /* Output a series of bclri's corresponding to mask.  */\n-char *\n+const char *\n mcore_output_bclri (dst, mask)\n      rtx dst;\n      int mask;\n@@ -884,7 +930,7 @@ mcore_output_bclri (dst, mask)\n /* Output a conditional move of two constants that are +/- 1 within each\n    other.  See the \"movtK\" patterns in mcore.md.   I'm not sure this is\n    really worth the effort.  */\n-char *\n+const char *\n mcore_output_cmov (operands, cmp_t, test)\n      rtx operands[];\n      int cmp_t;\n@@ -953,14 +999,14 @@ mcore_output_cmov (operands, cmp_t, test)\n \n /* Outputs the peephole for moving a constant that gets not'ed followed \n    by an and (i.e. combine the not and the and into andn) BRC */\n-char *\n+const char *\n mcore_output_andn (insn, operands)\n      rtx insn ATTRIBUTE_UNUSED;\n      rtx operands[];\n {\n   int x, y;\n   rtx out_operands[3];\n-  char * load_op;\n+  const char * load_op;\n   char buf[256];\n \n   if (try_constant_tricks (INTVAL (operands[1]), &x, &y) != 2)\n@@ -988,7 +1034,7 @@ mcore_output_andn (insn, operands)\n }\n \n /* Output an inline constant.  */\n-static char *\n+static const char *\n output_inline_const (mode, operands)\n      enum machine_mode mode;\n      rtx operands[];\n@@ -998,7 +1044,7 @@ output_inline_const (mode, operands)\n   rtx out_operands[3];\n   char buf[256];\n   char load_op[256];\n-  char *dst_fmt;\n+  const char *dst_fmt;\n   int value;\n \n   value = INTVAL (operands[1]);\n@@ -1086,7 +1132,7 @@ output_inline_const (mode, operands)\n }\n \n /* Output a move of a word or less value.  */\n-char *\n+const char *\n mcore_output_move (insn, operands, mode)\n      rtx insn ATTRIBUTE_UNUSED;\n      rtx operands[];\n@@ -1139,7 +1185,7 @@ mcore_output_move (insn, operands, mode)\n    Useful for things where we've gotten into trouble and think we'd\n    be doing an lrw into r15 (forbidden). This lets us get out of\n    that pickle even after register allocation.  */\n-char *\n+const char *\n mcore_output_inline_const_forced (insn, operands, mode)\n      rtx insn ATTRIBUTE_UNUSED;\n      rtx operands[];\n@@ -1226,7 +1272,7 @@ mcore_output_inline_const_forced (insn, operands, mode)\n /* Return a sequence of instructions to perform DI or DF move.\n    Since the MCORE cannot move a DI or DF in one instruction, we have\n    to take care when we see overlapping source and dest registers.  */\n-char *\n+const char *\n mcore_output_movedouble (operands, mode)\n      rtx operands[];\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n@@ -1658,7 +1704,7 @@ mcore_expand_insv (operands)\n      We don't have to mask if we're shifting this up against the\n      MSB of the register (e.g., the shift will push out any hi-order\n      bits. */\n-  if (width + posn != GET_MODE_SIZE (SImode))\n+  if (width + posn != (int) GET_MODE_SIZE (SImode))\n     {\n       ereg = force_reg (SImode, GEN_INT ((1 << width) - 1));      \n       emit_insn (gen_rtx (SET, SImode, sreg,\n@@ -1705,9 +1751,9 @@ mcore_load_multiple_operation (op, mode)\n       if (GET_CODE (elt) != SET\n \t  || GET_CODE (SET_DEST (elt)) != REG\n \t  || GET_MODE (SET_DEST (elt)) != SImode\n-\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || GET_MODE (SET_SRC (elt)) != SImode\n+\t  || REGNO (SET_DEST (elt))    != (unsigned) (dest_regno + i)\n+\t  || GET_CODE (SET_SRC (elt))  != MEM\n+\t  || GET_MODE (SET_SRC (elt))  != SImode\n \t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n \t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n \t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n@@ -1746,7 +1792,7 @@ mcore_store_multiple_operation (op, mode)\n       if (GET_CODE (elt) != SET\n \t  || GET_CODE (SET_SRC (elt)) != REG\n \t  || GET_MODE (SET_SRC (elt)) != SImode\n-\t  || REGNO (SET_SRC (elt)) != src_regno + i\n+\t  || REGNO (SET_SRC (elt)) != (unsigned) (src_regno + i)\n \t  || GET_CODE (SET_DEST (elt)) != MEM\n \t  || GET_MODE (SET_DEST (elt)) != SImode\n \t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n@@ -1916,31 +1962,10 @@ static int number_of_regs_before_varargs;\n    for a varargs function.  */\n static int current_function_anonymous_args;\n \n-\n #define\tSTACK_BYTES (STACK_BOUNDARY/BITS_PER_UNIT)\n #define\tSTORE_REACH (64)\t/* Maximum displace of word store + 4.  */\n #define\tADDI_REACH (32)\t\t/* Maximum addi operand. */\n \n-struct mcore_frame\n-{\n-  int arg_size;\t\t\t/* stdarg spills (bytes) */\n-  int reg_size;\t\t\t/* non-volatile reg saves (bytes) */\n-  int reg_mask;\t\t\t/* non-volatile reg saves */\n-  int local_size;\t\t/* locals */\n-  int outbound_size;\t\t/* arg overflow on calls out */\n-  int pad_outbound;\n-  int pad_local;\n-  int pad_reg;\n-\n-  /* describe the steps we'll use to grow it */\n-#define\tMAX_STACK_GROWS\t4\t/* gives us some spare space */\n-  int growth[MAX_STACK_GROWS];\n-  int arg_offset;\n-  int reg_offset;\n-  int reg_growth;\n-  int local_growth;\n-};\n-\n static void\n layout_mcore_frame (infp)\n      struct mcore_frame * infp;\n@@ -2150,7 +2175,7 @@ layout_mcore_frame (infp)\n       infp->local_growth = growths;\n     }\n \n-  /* Anything else that we've forgotten?, plus a few consistency checks. */\n+  /* Anything else that we've forgotten?, plus a few consistency checks.  */\n  finish:\n   assert (infp->reg_offset >= 0);\n   assert (growths <= MAX_STACK_GROWS);\n@@ -2369,12 +2394,13 @@ mcore_expand_epilog ()\n   int offs;\n   int growth = MAX_STACK_GROWS - 1 ;\n \n+    \n   /* Find out what we're doing.  */\n   layout_mcore_frame(&fi);\n \n   if (mcore_naked_function_p ())\n     return;\n-  \n+\n   /* If we had a frame pointer, restore the sp from that.  */\n   if (frame_pointer_needed)\n     {\n@@ -2508,7 +2534,7 @@ static int pool_size;\n \n /* Dump out any constants accumulated in the final pass.  These\n    will only be labels.  */\n-char *\n+const char *\n mcore_output_jump_label_table ()\n {\n   int i;\n@@ -2597,17 +2623,6 @@ mcore_dependent_simplify_rtx (x, int_op0_mode, last, in_dest, general_simplify)\n }\n #endif\n \n-typedef enum\n-{\n-  COND_NO,\n-  COND_MOV_INSN,\n-  COND_CLR_INSN,\n-  COND_INC_INSN,\n-  COND_DEC_INSN,\n-  COND_BRANCH_INSN\n-}\n-cond_type;\n-\n /* Check whether insn is a candidate for a conditional.  */\n static cond_type\n is_cond_candidate (insn)\n@@ -3540,7 +3555,7 @@ mcore_unique_section (decl, reloc)\n   int len;\n   char * name;\n   char * string;\n-  char * prefix;\n+  const char * prefix;\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n   "}]}