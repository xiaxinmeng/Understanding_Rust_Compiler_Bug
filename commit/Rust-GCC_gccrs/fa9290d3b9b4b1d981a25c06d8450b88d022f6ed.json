{"sha": "fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE5MjkwZDNiOWI0YjFkOTgxYTI1YzA2ZDg0NTBiODhkMDIyZjZlZA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-05-16T06:52:14Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2008-05-16T06:52:14Z"}, "message": "primary.c: New private structure \"gfc_structure_ctor_component\".\n\n2008-05-16  Daniel Kraft  <d@domob.eu>\n\n        * primary.c:  New private structure \"gfc_structure_ctor_component\".\n        (gfc_free_structure_ctor_component):  New helper function.\n        (gfc_match_structure_constructor):  Extended largely to support named\n        arguments and default initialization for structure constructors.\n\n2008-05-16  Daniel Kraft  <d@domob.eu>\n\n        * gfortran.dg/private_type_6.f90:  Adapted expected error messages.\n        * gfortran.dg/structure_constructor_1.f03:  New test.\n        * gfortran.dg/structure_constructor_2.f03:  New test.\n        * gfortran.dg/structure_constructor_3.f03:  New test.\n        * gfortran.dg/structure_constructor_4.f03:  New test.\n        * gfortran.dg/structure_constructor_5.f03:  New test.\n        * gfortran.dg/structure_constructor_6.f03:  New test.\n        * gfortran.dg/structure_constructor_7.f03:  New test.\n        * gfortran.dg/structure_constructor_8.f03:  New test.\n        * gfortran.dg/structure_constructor_9.f90:  New test.\n\nFrom-SVN: r135410", "tree": {"sha": "0e1d9f53ecc1b39324f0851d428961ad945886f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e1d9f53ecc1b39324f0851d428961ad945886f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d0208f9b647dc20ca5e1cff958f81c063ff25a17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0208f9b647dc20ca5e1cff958f81c063ff25a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0208f9b647dc20ca5e1cff958f81c063ff25a17"}], "stats": {"total": 575, "additions": 532, "deletions": 43}, "files": [{"sha": "2bc0d2c6513baa312aeaaa1b29df78ea82214f96", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -1,3 +1,10 @@\n+2008-05-16  Daniel Kraft  <d@domob.eu>\n+\n+\t* primary.c:  New private structure \"gfc_structure_ctor_component\".\n+\t(gfc_free_structure_ctor_component):  New helper function.\n+\t(gfc_match_structure_constructor):  Extended largely to support named\n+\targuments and default initialization for structure constructors.\n+\n 2008-05-15  Steven G. Kargl  <kargls@comcast.net>\n \n \t* simplify.c (gfc_simplify_dble, gfc_simplify_float,"}, {"sha": "be5fca094b63ce6b3539eb9de902050dba2fd925", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 206, "deletions": 41, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -1966,17 +1966,39 @@ gfc_expr_attr (gfc_expr *e)\n /* Match a structure constructor.  The initial symbol has already been\n    seen.  */\n \n+typedef struct gfc_structure_ctor_component\n+{\n+  char* name;\n+  gfc_expr* val;\n+  locus where;\n+  struct gfc_structure_ctor_component* next;\n+}\n+gfc_structure_ctor_component;\n+\n+#define gfc_get_structure_ctor_component() \\\n+  gfc_getmem(sizeof(gfc_structure_ctor_component))\n+\n+static void\n+gfc_free_structure_ctor_component (gfc_structure_ctor_component *comp)\n+{\n+  gfc_free (comp->name);\n+  gfc_free_expr (comp->val);\n+}\n+\n match\n gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n {\n-  gfc_constructor *head, *tail;\n-  gfc_component *comp;\n+  gfc_structure_ctor_component *comp_head, *comp_tail;\n+  gfc_structure_ctor_component *comp_iter;\n+  gfc_constructor *ctor_head, *ctor_tail;\n+  gfc_component *comp; /* Is set NULL when named component is first seen */\n   gfc_expr *e;\n   locus where;\n   match m;\n-  bool private_comp = false;\n+  const char* last_name = NULL;\n \n-  head = tail = NULL;\n+  comp_head = comp_tail = NULL;\n+  ctor_head = ctor_tail = NULL;\n \n   if (gfc_match_char ('(') != MATCH_YES)\n     goto syntax;\n@@ -1985,58 +2007,195 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n \n   gfc_find_component (sym, NULL);\n \n-  for (comp = sym->components; comp; comp = comp->next)\n+  /* Match the component list and store it in a list together with the\n+     corresponding component names.  Check for empty argument list first.  */\n+  if (gfc_match_char (')') != MATCH_YES)\n     {\n-      if (comp->access == ACCESS_PRIVATE)\n-\t{\n-\t  private_comp = true;\n-\t  break;\n-\t}\n-      if (head == NULL)\n-\ttail = head = gfc_get_constructor ();\n-      else\n+      comp = sym->components;\n+      do\n \t{\n-\t  tail->next = gfc_get_constructor ();\n-\t  tail = tail->next;\n-\t}\n+\t  gfc_component *this_comp = NULL;\n \n-      m = gfc_match_expr (&tail->expr);\n-      if (m == MATCH_NO)\n-\tgoto syntax;\n-      if (m == MATCH_ERROR)\n-\tgoto cleanup;\n+\t  if (!comp_head)\n+\t    comp_tail = comp_head = gfc_get_structure_ctor_component ();\n+\t  else\n+\t    {\n+\t      comp_tail->next = gfc_get_structure_ctor_component ();\n+\t      comp_tail = comp_tail->next;\n+\t    }\n+\t  comp_tail->name = gfc_getmem(GFC_MAX_SYMBOL_LEN + 1);\n+\t  comp_tail->val = NULL;\n+\t  comp_tail->where = gfc_current_locus;\n \n-      if (gfc_match_char (',') == MATCH_YES)\n-\t{\n-\t  if (comp->next == NULL)\n+\t  /* Try matching a component name.  */\n+\t  if (gfc_match_name (comp_tail->name) == MATCH_YES \n+\t      && gfc_match_char ('=') == MATCH_YES)\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Structure\"\n+\t\t\t\t  \" constructor with named arguments at %C\")\n+\t\t  == FAILURE)\n+\t\tgoto cleanup;\n+\n+\t      last_name = comp_tail->name;\n+\t      comp = NULL;\n+\t    }\n+\t  else\n \t    {\n-\t      gfc_error (\"Too many components in structure constructor at %C\");\n+\t      /* Components without name are not allowed after the first named\n+\t\t component initializer!  */\n+\t      if (!comp)\n+\t\t{\n+\t\t  if (last_name)\n+\t\t    gfc_error (\"Component initializer without name after\"\n+\t\t\t       \" component named %s at %C!\", last_name);\n+\t\t  else\n+\t\t    gfc_error (\"Too many components in structure constructor at\"\n+\t\t\t       \" %C!\");\n+\t\t  goto cleanup;\n+\t\t}\n+\n+\t      gfc_current_locus = comp_tail->where;\n+\t      strncpy (comp_tail->name, comp->name, GFC_MAX_SYMBOL_LEN + 1);\n+\t    }\n+\n+\t  /* Find the current component in the structure definition; this is\n+\t     needed to get its access attribute in the private check below.  */\n+\t  if (comp)\n+\t    this_comp = comp;\n+\t  else\n+\t    {\n+\t      for (comp = sym->components; comp; comp = comp->next)\n+\t\tif (!strcmp (comp->name, comp_tail->name))\n+\t\t  {\n+\t\t    this_comp = comp;\n+\t\t    break;\n+\t\t  }\n+\t      comp = NULL; /* Reset needed!  */\n+\n+\t      /* Here we can check if a component name is given which does not\n+\t\t correspond to any component of the defined structure.  */\n+\t      if (!this_comp)\n+\t\t{\n+\t\t  gfc_error (\"Component '%s' in structure constructor at %C\"\n+\t\t\t     \" does not correspond to any component in the\"\n+\t\t\t     \" constructed structure!\", comp_tail->name);\n+\t\t  goto cleanup;\n+\t\t}\n+\t    }\n+\t  gcc_assert (this_comp);\n+\n+\t  /* Check the current component's access status.  */\n+\t  if (sym->attr.use_assoc && this_comp->access == ACCESS_PRIVATE)\n+\t    {\n+\t      gfc_error (\"Component '%s' is PRIVATE in structure constructor\"\n+\t\t\t \" at %C!\", comp_tail->name);\n \t      goto cleanup;\n \t    }\n \n-\t  continue;\n+\t  /* Check if this component is already given a value.  */\n+\t  for (comp_iter = comp_head; comp_iter != comp_tail; \n+\t       comp_iter = comp_iter->next)\n+\t    {\n+\t      gcc_assert (comp_iter);\n+\t      if (!strcmp (comp_iter->name, comp_tail->name))\n+\t\t{\n+\t\t  gfc_error (\"Component '%s' is initialized twice in the\"\n+\t\t\t     \" structure constructor at %C!\", comp_tail->name);\n+\t\t  goto cleanup;\n+\t\t}\n+\t    }\n+\n+\t  /* Match the current initializer expression.  */\n+\t  m = gfc_match_expr (&comp_tail->val);\n+\t  if (m == MATCH_NO)\n+\t    goto syntax;\n+\t  if (m == MATCH_ERROR)\n+\t    goto cleanup;\n+\n+\t  if (comp)\n+\t    comp = comp->next;\n \t}\n+      while (gfc_match_char (',') == MATCH_YES);\n \n-      break;\n+      if (gfc_match_char (')') != MATCH_YES)\n+\tgoto syntax;\n+\t\n+      /* If there were components given and all components are private, error\n+\t out at this place.  */\n+      if (sym->attr.use_assoc && sym->component_access == ACCESS_PRIVATE)\n+\t{\n+\t  gfc_error (\"All components of '%s' are PRIVATE in structure\"\n+\t\t     \" constructor at %C\", sym->name);\n+\t  goto cleanup;\n+\t}\n     }\n \n-  if (sym->attr.use_assoc\n-      && (sym->component_access == ACCESS_PRIVATE || private_comp))\n+  /* Translate the component list into the actual constructor by sorting it in\n+     the order required; this also checks along the way that each and every\n+     component actually has an initializer and handles default initializers\n+     for components without explicit value given.  */\n+  for (comp = sym->components; comp; comp = comp->next)\n     {\n-      gfc_error (\"Structure constructor for '%s' at %C has PRIVATE \"\n-\t\t \"components\", sym->name);\n-      goto cleanup;\n-    }\n+      gfc_structure_ctor_component **next_ptr;\n+      gfc_expr *value = NULL;\n \n-  if (gfc_match_char (')') != MATCH_YES)\n-    goto syntax;\n+      /* Try to find the initializer for the current component by name.  */\n+      next_ptr = &comp_head;\n+      for (comp_iter = comp_head; comp_iter; comp_iter = comp_iter->next)\n+\t{\n+\t  if (!strcmp (comp_iter->name, comp->name))\n+\t    break;\n+\t  next_ptr = &comp_iter->next;\n+\t}\n \n-  if (comp && comp->next != NULL)\n-    {\n-      gfc_error (\"Too few components in structure constructor at %C\");\n-      goto cleanup;\n+      /* If it was not found, try the default initializer if there's any;\n+\t otherwise, it's an error.  */\n+      if (!comp_iter)\n+\t{\n+\t  if (comp->initializer)\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Structure\"\n+\t\t\t\t  \" constructor with missing optional arguments\"\n+\t\t\t\t  \" at %C\") == FAILURE)\n+\t\tgoto cleanup;\n+\t      value = gfc_copy_expr (comp->initializer);\n+\t    }\n+\t  else\n+\t    {\n+\t      gfc_error (\"No initializer for component '%s' given in the\"\n+\t\t\t \" structure constructor at %C!\", comp->name);\n+\t      goto cleanup;\n+\t    }\n+\t}\n+      else\n+\tvalue = comp_iter->val;\n+\n+      /* Add the value to the constructor chain built.  */\n+      if (ctor_tail)\n+\t{\n+\t  ctor_tail->next = gfc_get_constructor ();\n+\t  ctor_tail = ctor_tail->next;\n+\t}\n+      else\n+\tctor_head = ctor_tail = gfc_get_constructor ();\n+      gcc_assert (value);\n+      ctor_tail->expr = value;\n+\n+      /* Remove the entry from the component list.  We don't want the expression\n+\t value to be free'd, so set it to NULL.  */\n+      if (comp_iter)\n+\t{\n+\t  *next_ptr = comp_iter->next;\n+\t  comp_iter->val = NULL;\n+\t  gfc_free_structure_ctor_component (comp_iter);\n+\t}\n     }\n \n+  /* No component should be left, as this should have caused an error in the\n+     loop constructing the component-list (name that does not correspond to any\n+     component in the structure definition).  */\n+  gcc_assert (!comp_head);\n+\n   e = gfc_get_expr ();\n \n   e->expr_type = EXPR_STRUCTURE;\n@@ -2045,7 +2204,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n   e->ts.derived = sym;\n   e->where = where;\n \n-  e->value.constructor = head;\n+  e->value.constructor = ctor_head;\n \n   *result = e;\n   return MATCH_YES;\n@@ -2054,7 +2213,13 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n   gfc_error (\"Syntax error in structure constructor at %C\");\n \n cleanup:\n-  gfc_free_constructor (head);\n+  for (comp_iter = comp_head; comp_iter; )\n+    {\n+      gfc_structure_ctor_component *next = comp_iter->next;\n+      gfc_free_structure_ctor_component (comp_iter);\n+      comp_iter = next;\n+    }\n+  gfc_free_constructor (ctor_head);\n   return MATCH_ERROR;\n }\n "}, {"sha": "e256308c4566c48b72e3e8d22da4936b94149253", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -1,3 +1,16 @@\n+2008-05-16  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.dg/private_type_6.f90:  Adapted expected error messages.\n+\t* gfortran.dg/structure_constructor_1.f03:  New test.\n+\t* gfortran.dg/structure_constructor_2.f03:  New test.\n+\t* gfortran.dg/structure_constructor_3.f03:  New test.\n+\t* gfortran.dg/structure_constructor_4.f03:  New test.\n+\t* gfortran.dg/structure_constructor_5.f03:  New test.\n+\t* gfortran.dg/structure_constructor_6.f03:  New test.\n+\t* gfortran.dg/structure_constructor_7.f03:  New test.\n+\t* gfortran.dg/structure_constructor_8.f03:  New test.\n+\t* gfortran.dg/structure_constructor_9.f90:  New test.\n+\n 2008-05-15  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.target/i386/m128-check.h: New."}, {"sha": "d3cc809dfef2247afa1d55a4b242752ddca9eb82", "filename": "gcc/testsuite/gfortran.dg/private_type_6.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_6.f90?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -18,8 +18,8 @@ program foo_test\n   implicit none\n   TYPE(footype) :: foo\n   TYPE(bartype) :: foo2\n-  foo  = footype(1) ! { dg-error \"has PRIVATE components\" }\n-  foo2 = bartype(1,2) ! { dg-error \"has PRIVATE components\" }\n+  foo  = footype(1) ! { dg-error \"All components of 'footype' are PRIVATE\" }\n+  foo2 = bartype(1,2) ! { dg-error \"'dummy2' is PRIVATE\" }\n   foo2%dummy2 = 5 ! { dg-error \"is a PRIVATE component\" }\n end program foo_test\n ! { dg-final { cleanup-modules \"foomod\" } }"}, {"sha": "8f8f58ef92057b8dd0eb68e65663c51f86d49e4a", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_1.f03", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_1.f03?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -0,0 +1,74 @@\n+! { dg-do run }\n+! Simple structure constructors, without naming arguments, default values\n+! or inheritance and the like.\n+\n+PROGRAM test\n+  IMPLICIT NONE\n+\n+  ! Empty structuer\n+  TYPE :: empty_t\n+  END TYPE empty_t\n+\n+  ! Structure of basic data types\n+  TYPE :: basics_t\n+    INTEGER :: i\n+    REAL :: r\n+    COMPLEX :: c\n+    LOGICAL :: l\n+  END TYPE basics_t\n+\n+  ! Structure with strings\n+  TYPE :: strings_t\n+    CHARACTER(len=5) :: str1, str2\n+    CHARACTER(len=10) :: long\n+  END TYPE strings_t\n+\n+  ! Structure with arrays\n+  TYPE :: array_t\n+    INTEGER :: ints(2:5)\n+    REAL :: matrix(2, 2)\n+  END TYPE array_t\n+\n+  ! Structure containing structures\n+  TYPE :: nestedStruct_t\n+    TYPE(basics_t) :: basics\n+    TYPE(array_t) :: arrays\n+  END TYPE nestedStruct_t\n+\n+  TYPE(empty_t) :: empty\n+  TYPE(basics_t) :: basics\n+  TYPE(strings_t) :: strings\n+  TYPE(array_t) :: arrays\n+  TYPE(nestedStruct_t) :: nestedStruct\n+\n+  empty = empty_t ()\n+\n+  basics = basics_t (42, -1.5, (.5, .5), .FALSE.)\n+  IF (basics%i /= 42 .OR. basics%r /= -1.5 &\n+      .OR. basics%c /= (.5, .5) .OR. basics%l) THEN\n+    CALL abort()\n+  END IF\n+\n+  strings = strings_t (\"hello\", \"abc\", \"this one is long\")\n+  IF (strings%str1 /= \"hello\" .OR. strings%str2 /= \"abc\" &\n+      .OR. strings%long /= \"this one i\") THEN\n+    CALL abort()\n+  END IF\n+\n+  arrays = array_t ( (/ 1, 2, 3, 4 /), RESHAPE((/ 5, 6, 7, 8 /), (/ 2, 2 /)) )\n+  IF (arrays%ints(2) /= 1 .OR. arrays%ints(3) /= 2 &\n+      .OR. arrays%ints(4) /= 3 .OR. arrays%ints(5) /= 4 &\n+      .OR. arrays%matrix(1, 1) /= 5. .OR. arrays%matrix(2, 1) /= 6. &\n+      .OR. arrays%matrix(1, 2) /= 7. .OR. arrays%matrix(2, 2) /= 8.) THEN\n+    CALL abort()\n+  END IF\n+\n+  nestedStruct = nestedStruct_t (basics_t (42, -1.5, (.5, .5), .FALSE.), arrays)\n+  IF (nestedStruct%basics%i /= 42 .OR. nestedStruct%basics%r /= -1.5 &\n+      .OR. nestedStruct%basics%c /= (.5, .5) .OR. nestedStruct%basics%l &\n+      .OR. ANY(nestedStruct%arrays%ints /= arrays%ints) &\n+      .OR. ANY(nestedStruct%arrays%matrix /= arrays%matrix)) THEN\n+    CALL abort()\n+  END IF\n+\n+END PROGRAM test"}, {"sha": "c551ebfde88c7f011e0974cd34c68bdcc108f70c", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_2.f03", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_2.f03?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! Structure constructor with component naming.\n+\n+PROGRAM test\n+  IMPLICIT NONE\n+\n+  ! Structure of basic data types\n+  TYPE :: basics_t\n+    INTEGER :: i\n+    REAL :: r\n+    COMPLEX :: c\n+    LOGICAL :: l\n+  END TYPE basics_t\n+\n+  TYPE(basics_t) :: basics\n+\n+  basics = basics_t (42, -1.5, c=(.5, .5), l=.FALSE.)\n+  IF (basics%i /= 42 .OR. basics%r /= -1.5 &\n+      .OR. basics%c /= (.5, .5) .OR. basics%l) THEN\n+    CALL abort()\n+  END IF\n+\n+  basics = basics_t (r=-1.5, i=42, l=.FALSE., c=(.5, .5))\n+  IF (basics%i /= 42 .OR. basics%r /= -1.5 &\n+      .OR. basics%c /= (.5, .5) .OR. basics%l) THEN\n+    CALL abort()\n+  END IF\n+\n+END PROGRAM test"}, {"sha": "aa5934951c482baba2380eb83ece865766908d8c", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_3.f03", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_3.f03?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! Structure constructor with component naming, test that an error is emitted\n+! if there are arguments without name after ones with name.\n+\n+PROGRAM test\n+  IMPLICIT NONE\n+\n+  ! Structure of basic data types\n+  TYPE :: basics_t\n+    INTEGER :: i\n+    REAL :: r\n+  END TYPE basics_t\n+\n+  TYPE(basics_t) :: basics\n+\n+  basics = basics_t (i=42, 1.5) ! { dg-error \"without name after\" }\n+\n+END PROGRAM test"}, {"sha": "647be5fbb7d9779dac9c46f9b5ab3189b768f3ee", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_4.f03", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_4.f03?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! Structure constructor with component naming, test that an error is emitted if\n+! a component is given two initializers.\n+\n+PROGRAM test\n+  IMPLICIT NONE\n+\n+  ! Structure of basic data types\n+  TYPE :: basics_t\n+    INTEGER :: i\n+    REAL :: r\n+  END TYPE basics_t\n+\n+  TYPE(basics_t) :: basics\n+\n+  basics = basics_t (42, r=1.5, i=15) ! { dg-error \"'i' is initialized twice\" }\n+  basics = basics_t (42, r=1., r=-2.) ! { dg-error \"'r' is initialized twice\" }\n+\n+END PROGRAM test"}, {"sha": "064db66a2bf5ffd8a784db578ea0892ca1b96b01", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_5.f03", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_5.f03?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+! Structure constructor with default initialization.\n+\n+PROGRAM test\n+  IMPLICIT NONE\n+\n+  ! Type with all default values\n+  TYPE :: quasiempty_t\n+    CHARACTER(len=5) :: greeting = \"hello\"\n+  END TYPE quasiempty_t\n+\n+  ! Structure of basic data types\n+  TYPE :: basics_t\n+    INTEGER :: i = 42\n+    REAL :: r\n+    COMPLEX :: c = (0., 1.)\n+  END TYPE basics_t\n+\n+  TYPE(quasiempty_t) :: empty\n+  TYPE(basics_t) :: basics\n+\n+  empty = quasiempty_t ()\n+  IF (empty%greeting /= \"hello\") THEN\n+    CALL abort()\n+  END IF\n+\n+  basics = basics_t (r = 1.5)\n+  IF (basics%i /= 42 .OR. basics%r /= 1.5 .OR. basics%c /= (0., 1.)) THEN\n+    CALL abort()\n+  END IF\n+\n+  basics%c = (0., 0.) ! So we see it's surely gotten re-initialized\n+  basics = basics_t (1, 5.1)\n+  IF (basics%i /= 1 .OR. basics%r /= 5.1 .OR. basics%c /= (0., 1.)) THEN\n+    CALL abort()\n+  END IF\n+\n+END PROGRAM test"}, {"sha": "9952e2e7c93c929a2efaf70c5ace409a08ac6cf7", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_6.f03", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_6.f03?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! Structure constructor with default initialization, test that an error is\n+! emitted for components without default initializer missing value.\n+\n+PROGRAM test\n+  IMPLICIT NONE\n+\n+  ! Structure of basic data types\n+  TYPE :: basics_t\n+    INTEGER :: i = 42\n+    REAL :: r\n+    COMPLEX :: c = (0., 1.)\n+  END TYPE basics_t\n+\n+  TYPE(basics_t) :: basics\n+\n+  basics = basics_t (i = 42) ! { dg-error \"No initializer for component 'r'\" }\n+  basics = basics_t (42) ! { dg-error \"No initializer for component 'r'\" }\n+\n+END PROGRAM test"}, {"sha": "3ba79ea373ba44758ae4bdbd77a560facb5b9486", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_7.f03", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_7.f03?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! Test for errors when excess components are given for a structure-constructor.\n+\n+PROGRAM test\n+  IMPLICIT NONE\n+\n+  ! Structure of basic data types\n+  TYPE :: basics_t\n+    INTEGER :: i\n+    REAL :: r = 1.5\n+  END TYPE basics_t\n+\n+  TYPE(basics_t) :: basics\n+\n+  basics = basics_t (42, 1.5, 1000) ! { dg-error \"Too many components\" }\n+  basics = basics_t (42, xxx = 1000) ! { dg-error \"Component 'xxx'\" }\n+\n+END PROGRAM test"}, {"sha": "995fd806a96217e7a382e0f8fead549764e07751", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_8.f03", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_8.f03?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do compile }\n+! Test for errors when setting private components inside a structure constructor\n+! or when constructing a private structure.\n+\n+MODULE privmod\n+  IMPLICIT NONE\n+\n+  TYPE :: haspriv_t\n+    INTEGER :: a\n+    INTEGER, PRIVATE :: b = 42\n+  END TYPE haspriv_t\n+\n+  TYPE :: allpriv_t\n+    PRIVATE\n+    INTEGER :: a = 25\n+  END TYPE allpriv_t\n+\n+  TYPE, PRIVATE :: ispriv_t\n+    INTEGER :: x\n+  END TYPE ispriv_t\n+\n+CONTAINS\n+  \n+  SUBROUTINE testfunc ()\n+    IMPLICIT NONE\n+    TYPE(haspriv_t) :: struct1\n+    TYPE(allpriv_t) :: struct2\n+    TYPE(ispriv_t) :: struct3\n+\n+    ! This should succeed from within the module, no error.\n+    struct1 = haspriv_t (1, 2)\n+    struct2 = allpriv_t (42)\n+    struct3 = ispriv_t (42)\n+  END SUBROUTINE testfunc\n+\n+END MODULE privmod\n+\n+PROGRAM test\n+  USE privmod\n+  IMPLICIT NONE\n+\n+  TYPE(haspriv_t) :: struct1\n+  TYPE(allpriv_t) :: struct2\n+\n+  ! This should succeed, not giving value to private component\n+  struct1 = haspriv_t (5)\n+  struct2 = allpriv_t ()\n+\n+  ! These should fail\n+  struct1 = haspriv_t (1, 2) ! { dg-error \"'b' is PRIVATE\" }\n+  struct1 = haspriv_t (b = 2, a = 1) ! { dg-error \"'b' is PRIVATE\" }\n+\n+  ! This should fail as all components are private\n+  struct2 = allpriv_t (5) ! { dg-error \"of 'allpriv_t' are PRIVATE\" }\n+\n+  ! This should fail as the type itself is private, and the expression should\n+  ! be deduced as call to an undefined function.\n+  WRITE (*,*) ispriv_t (5) ! { dg-error \"has no IMPLICIT type\" }\n+\n+END PROGRAM test\n+! { dg-final { cleanup-modules privmod } }"}, {"sha": "75120856e139860224ae52b8d7691b6335d70733", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_9.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9290d3b9b4b1d981a25c06d8450b88d022f6ed/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_9.f90?ref=fa9290d3b9b4b1d981a25c06d8450b88d022f6ed", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+! Check for notify-std-messages when F2003 structure constructors are compiled\n+! with -std=f95.\n+\n+PROGRAM test\n+  IMPLICIT NONE\n+\n+  ! Basic type with default initializers\n+  TYPE :: basics_t\n+    INTEGER :: i = 42\n+    REAL :: r = 1.5\n+  END TYPE basics_t\n+\n+  TYPE(basics_t) :: basics\n+\n+  ! This is ok in F95\n+  basics = basics_t (1, 2.)\n+\n+  ! No argument naming in F95\n+  basics = basics_t (1, r = 4.2) ! { dg-error \"Fortran 2003\" }\n+\n+  ! No optional arguments in F95\n+  basics = basics_t () ! { dg-error \"Fortran 2003\" }\n+  basics = basics_t (5) ! { dg-error \"Fortran 2003\" }\n+\n+END PROGRAM test"}]}