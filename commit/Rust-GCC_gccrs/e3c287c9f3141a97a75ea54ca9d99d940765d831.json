{"sha": "e3c287c9f3141a97a75ea54ca9d99d940765d831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNjMjg3YzlmMzE0MWE5N2E3NWVhNTRjYTlkOTlkOTQwNzY1ZDgzMQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@apple.com", "date": "2004-05-05T18:25:52Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2004-05-05T18:25:52Z"}, "message": "darwin-c.c (add_framework): Copy the directory name as it can be freed later.\n\n\t* config/darwin-c.c (add_framework): Copy the directory name as it\n\tcan be freed later.  Also, ensure we always allocate enough room\n\tfor the cached framework information.\n\t(find_subframework_header): Keep track of the directory where the\n\tsubframework header was found.\n\t(framework_construct_pathname): Speed up by not trying to re-add a\n\tframework.\n\t* cppfiles.c (search_path_exhausted): Arrange for the missing\n\theader callback to be able to set the directory where the header\n\twas found.\n\t(cpp_get_dir): Add.\n\t* cpplib.h (missing_header_cb): Add a parameter.\n\t(cpp_get_dir): Add.\n\nFrom-SVN: r81534", "tree": {"sha": "c90d3529878cc7887b1b4e333bac9bb10c41467a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c90d3529878cc7887b1b4e333bac9bb10c41467a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3c287c9f3141a97a75ea54ca9d99d940765d831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c287c9f3141a97a75ea54ca9d99d940765d831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3c287c9f3141a97a75ea54ca9d99d940765d831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c287c9f3141a97a75ea54ca9d99d940765d831/comments", "author": null, "committer": null, "parents": [{"sha": "f08a3544c21fba472a946b93ad506d6469481311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f08a3544c21fba472a946b93ad506d6469481311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f08a3544c21fba472a946b93ad506d6469481311"}], "stats": {"total": 58, "additions": 49, "deletions": 9}, "files": [{"sha": "558e3a45a278f59dc5d84dfcb4004a851abd16da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c287c9f3141a97a75ea54ca9d99d940765d831/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c287c9f3141a97a75ea54ca9d99d940765d831/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3c287c9f3141a97a75ea54ca9d99d940765d831", "patch": "@@ -1,4 +1,20 @@\n-2004-05-3  Mike Stump  <mrs@apple.com>\n+2004-05-05  Mike Stump  <mrs@apple.com>\n+\n+\t* config/darwin-c.c (add_framework): Copy the directory name as it\n+\tcan be freed later.  Also, ensure we always allocate enough room\n+\tfor the cached framework information.\n+\t(find_subframework_header): Keep track of the directory where the\n+\tsubframework header was found.\n+\t(framework_construct_pathname): Speed up by not trying to re-add a\n+\tframework.\n+\t* cppfiles.c (search_path_exhausted): Arrange for the missing\n+\theader callback to be able to set the directory where the header\n+\twas found.\n+\t(cpp_get_dir): Add.\n+\t* cpplib.h (missing_header_cb): Add a parameter.\n+\t(cpp_get_dir): Add.\n+\n+2004-05-03  Mike Stump  <mrs@apple.com>\n \n \t* doc/invoke.texi (Directory Options): Document -iquote.\n \t* doc/cpp.texi: Likewise."}, {"sha": "281d166868544bc832e60d4a164f1aaab022e713", "filename": "gcc/config/darwin-c.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c287c9f3141a97a75ea54ca9d99d940765d831/gcc%2Fconfig%2Fdarwin-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c287c9f3141a97a75ea54ca9d99d940765d831/gcc%2Fconfig%2Fdarwin-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-c.c?ref=e3c287c9f3141a97a75ea54ca9d99d940765d831", "patch": "@@ -44,7 +44,8 @@ static void push_field_alignment (int);\n static void pop_field_alignment (void);\n static const char *find_subframework_file (const char *, const char *);\n static void add_system_framework_path (char *);\n-static const char *find_subframework_header (cpp_reader *pfile, const char *header);\n+static const char *find_subframework_header (cpp_reader *pfile, const char *header,\n+\t\t\t\t\t     cpp_dir **dirp);\n \n typedef struct align_stack\n {\n@@ -166,11 +167,13 @@ static int max_frameworks = 0;\n /* Remember which frameworks have been seen, so that we can ensure\n    that all uses of that framework come from the same framework.  DIR\n    is the place where the named framework NAME, which is of length\n-   LEN, was found.  */\n+   LEN, was found.  We copy the directory name from NAME, as it will be\n+   freed by others.  */\n \n static void\n add_framework (const char *name, size_t len, cpp_dir *dir)\n {\n+  char *dir_name;\n   int i;\n   for (i = 0; i < num_frameworks; ++i)\n     {\n@@ -183,10 +186,14 @@ add_framework (const char *name, size_t len, cpp_dir *dir)\n   if (i >= max_frameworks)\n     {\n       max_frameworks = i*2;\n+      max_frameworks += i == 0;\n       frameworks_in_use = xrealloc (frameworks_in_use,\n \t\t\t\t    max_frameworks*sizeof(*frameworks_in_use));\n     }\n-  frameworks_in_use[num_frameworks].name = name;\n+  dir_name = xmalloc (len + 1);\n+  memcpy (dir_name, name, len);\n+  dir_name[len] = '\\0';\n+  frameworks_in_use[num_frameworks].name = dir_name;\n   frameworks_in_use[num_frameworks].len = len;\n   frameworks_in_use[num_frameworks].dir = dir;\n   ++num_frameworks;\n@@ -272,7 +279,8 @@ framework_construct_pathname (const char *fname, cpp_dir *dir)\n \n       if (stat (frname, &st) == 0)\n \t{\n-\t  add_framework (fname, fname_len, dir);\n+\t  if (fast_dir == 0)\n+\t    add_framework (fname, fname_len, dir);\n \t  return frname;\n \t}\n     }\n@@ -445,7 +453,7 @@ darwin_register_frameworks (int stdinc)\n    returns non-zero.  */\n \n static const char*\n-find_subframework_header (cpp_reader *pfile, const char *header)\n+find_subframework_header (cpp_reader *pfile, const char *header, cpp_dir **dirp)\n {\n   const char *fname = header;\n   struct cpp_buffer *b;\n@@ -457,7 +465,14 @@ find_subframework_header (cpp_reader *pfile, const char *header)\n     {\n       n = find_subframework_file (fname, cpp_get_path (cpp_get_file (b)));\n       if (n)\n-\treturn n;\n+\t{\n+\t  /* Logically, the place where we found the subframework is\n+\t     the place where we found the Framework that contains the\n+\t     subframework.  This is useful for tracking wether or not\n+\t     we are in a system header.  */\n+\t  *dirp = cpp_get_dir (cpp_get_file (b));\n+\t  return n;\n+\t}\n     }\n \n   return 0;"}, {"sha": "65db6db5d570f532f9ccd82a911a911ad17099ef", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c287c9f3141a97a75ea54ca9d99d940765d831/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c287c9f3141a97a75ea54ca9d99d940765d831/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=e3c287c9f3141a97a75ea54ca9d99d940765d831", "patch": "@@ -362,7 +362,7 @@ search_path_exhausted (cpp_reader *pfile, const char *header, _cpp_file *file)\n   if (func\n       && file->dir == NULL)\n     {\n-      if ((file->path = func (pfile, header)) != NULL)\n+      if ((file->path = func (pfile, header, &file->dir)) != NULL)\n \t{\n \t  if (open_file (file))\n \t    return true;\n@@ -1316,6 +1316,14 @@ cpp_get_path (struct _cpp_file *f)\n   return f->path;\n }\n \n+/* Get the directory associated with the _cpp_file F.  */\n+\n+cpp_dir *\n+cpp_get_dir (struct _cpp_file *f)\n+{\n+  return f->dir;\n+}\n+\n /* Get the cpp_buffer currently associated with the cpp_reader\n    PFILE.  */\n "}, {"sha": "5ac0a19bec91371faa45a94053f1840018afe7fb", "filename": "gcc/cpplib.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c287c9f3141a97a75ea54ca9d99d940765d831/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c287c9f3141a97a75ea54ca9d99d940765d831/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=e3c287c9f3141a97a75ea54ca9d99d940765d831", "patch": "@@ -385,7 +385,7 @@ struct cpp_options\n    The return value is the malloced name of a header to try and open,\n    if any, or NULL otherwise.  This callback is called only if the\n    header is otherwise unfound.  */\n-typedef const char *(*missing_header_cb)(cpp_reader *, const char *header);\n+typedef const char *(*missing_header_cb)(cpp_reader *, const char *header, cpp_dir **);\n \n /* Call backs to cpplib client.  */\n struct cpp_callbacks\n@@ -744,6 +744,7 @@ extern void cpp_make_system_header (cpp_reader *, int, int);\n extern bool cpp_push_include (cpp_reader *, const char *);\n extern void cpp_change_file (cpp_reader *, enum lc_reason, const char *);\n extern const char *cpp_get_path (struct _cpp_file *);\n+extern cpp_dir *cpp_get_dir (struct _cpp_file *);\n extern cpp_buffer *cpp_get_buffer (cpp_reader *);\n extern struct _cpp_file *cpp_get_file (cpp_buffer *);\n extern cpp_buffer *cpp_get_prev (cpp_buffer *);"}]}