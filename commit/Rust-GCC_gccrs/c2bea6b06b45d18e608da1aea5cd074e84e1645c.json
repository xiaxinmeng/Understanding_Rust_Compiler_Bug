{"sha": "c2bea6b06b45d18e608da1aea5cd074e84e1645c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJiZWE2YjA2YjQ1ZDE4ZTYwOGRhMWFlYTVjZDA3NGU4NGUxNjQ1Yw==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2002-12-01T16:16:19Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-12-01T16:16:19Z"}, "message": "SecurityManager.java: Remerge comments, indenting and checkXXX methods with Classpath.\n\n       * java/lang/SecurityManager.java: Remerge comments, indenting and\n       checkXXX methods with Classpath.\n\nFrom-SVN: r59685", "tree": {"sha": "cc2e278eeffc1585e3bdad7348b73fd064ea249f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc2e278eeffc1585e3bdad7348b73fd064ea249f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2bea6b06b45d18e608da1aea5cd074e84e1645c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2bea6b06b45d18e608da1aea5cd074e84e1645c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2bea6b06b45d18e608da1aea5cd074e84e1645c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2bea6b06b45d18e608da1aea5cd074e84e1645c/comments", "author": null, "committer": null, "parents": [{"sha": "5bb7e2ac1cf9454c99efccde698550283121b90a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb7e2ac1cf9454c99efccde698550283121b90a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb7e2ac1cf9454c99efccde698550283121b90a"}], "stats": {"total": 1644, "additions": 956, "deletions": 688}, "files": [{"sha": "61e147e50f4017d62e84947c71a4aee264dfc561", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2bea6b06b45d18e608da1aea5cd074e84e1645c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2bea6b06b45d18e608da1aea5cd074e84e1645c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c2bea6b06b45d18e608da1aea5cd074e84e1645c", "patch": "@@ -1,3 +1,8 @@\n+2002-12-01  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/lang/SecurityManager.java: Remerge comments, indenting and\n+\tcheckXXX methods with Classpath.\n+\n 2002-11-29  Scott Gilbertson  <scottg@mantatest.com>\n \n \t* java/awt/image/ColorModel.java (getUnnormalizedComponents,"}, {"sha": "e54ebc62f70e86e01f161725a342dee3c0b33bb4", "filename": "libjava/java/lang/SecurityManager.java", "status": "modified", "additions": 951, "deletions": 688, "changes": 1639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2bea6b06b45d18e608da1aea5cd074e84e1645c/libjava%2Fjava%2Flang%2FSecurityManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2bea6b06b45d18e608da1aea5cd074e84e1645c/libjava%2Fjava%2Flang%2FSecurityManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FSecurityManager.java?ref=c2bea6b06b45d18e608da1aea5cd074e84e1645c", "patch": "@@ -1,13 +1,13 @@\n-/* java.lang.SecurityManager\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+/* SecurityManager.java -- security checks for privileged actions\n+   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -38,736 +38,999 @@\n \n package java.lang;\n \n-import java.net.*;\n-import java.util.*;\n-import java.io.*;\n+import java.awt.AWTPermission;\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.FilePermission;\n+import java.lang.reflect.Member;\n+import java.net.InetAddress;\n+import java.net.SocketPermission;\n+import java.security.AllPermission;\n+import java.security.Permission;\n+import java.security.Security;\n+import java.security.SecurityPermission;\n+import java.util.PropertyPermission;\n \n /**\n- ** SecurityManager is a class you can extend to create\n- ** your own Java security policy.  By default, there is\n- ** no SecurityManager installed in 1.1, which means that\n- ** all things are permitted to all people.<P>\n- **\n- ** The default methods in this class deny all\n- ** things to all people.\n- **\n- ** @author  John Keiser\n- ** @version 1.1.0, 31 May 1998\n- ** @since JDK1.0\n- **/\n-public class SecurityManager {\n-\t/** Tells whether or not the SecurityManager is currently\n-\t ** performing a security check.\n-\t **/\n-\tprotected boolean inCheck;\n-\n-\t/** Tells whether or not the SecurityManager is currently\n-\t ** performing a security check.\n-\t **\n-\t ** @return whether or not the SecurityManager is\n-\t **         currently performing a security check.\n-\t **/\n-\tpublic boolean getInCheck() {\n-\t\treturn inCheck;\n-\t}\n+ * SecurityManager is a class you can extend to create your own Java\n+ * security policy.  By default, there is no SecurityManager installed in\n+ * 1.1, which means that all things are permitted to all people. The security\n+ * manager, if set, is consulted before doing anything with potentially\n+ * dangerous results, and throws a <code>SecurityException</code> if the\n+ * action is forbidden.\n+ *\n+ * <p>A typical check is as follows, just before the dangerous operation:<br>\n+ * <pre>\n+ * SecurityManager sm = System.getSecurityManager();\n+ * if (sm != null)\n+ *   sm.checkABC(<em>argument</em>, ...);\n+ * </pre>\n+ * Note that this is thread-safe, by caching the security manager in a local\n+ * variable rather than risking a NullPointerException if the mangager is\n+ * changed between the check for null and before the permission check.\n+ *\n+ * <p>The special method <code>checkPermission</code> is a catchall, and\n+ * the default implementation calls\n+ * <code>AccessController.checkPermission</code>. In fact, all the other\n+ * methods default to calling checkPermission.\n+ *\n+ * <p>Sometimes, the security check needs to happen from a different context,\n+ * such as when called from a worker thread. In such cases, use\n+ * <code>getSecurityContext</code> to take a snapshot that can be passed\n+ * to the worker thread:<br>\n+ * <pre>\n+ * Object context = null;\n+ * SecurityManager sm = System.getSecurityManager();\n+ * if (sm != null)\n+ *   context = sm.getSecurityContext(); // defaults to an AccessControlContext\n+ * // now, in worker thread\n+ * if (sm != null)\n+ *   sm.checkPermission(permission, context);\n+ * <pre>\n+ *\n+ * <p>Permissions fall into these categories: File, Socket, Net, Security,\n+ * Runtime, Property, AWT, Reflect, and Serializable. Each of these\n+ * permissions have a property naming convention, that follows a hierarchical\n+ * naming convention, to make it easy to grant or deny several permissions\n+ * at once. Some permissions also take a list of permitted actions, such\n+ * as \"read\" or \"write\", to fine-tune control even more. The permission\n+ * <code>java.security.AllPermission</code> grants all permissions.\n+ *\n+ * <p>The default methods in this class deny all things to all people. You\n+ * must explicitly grant permission for anything you want to be legal when\n+ * subclassing this class.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see ClassLoader\n+ * @see SecurityException\n+ * @see #checkTopLevelWindow(Object)\n+ * @see System#getSecurityManager()\n+ * @see System#setSecurityManager(SecurityManager)\n+ * @see AccessController\n+ * @see AccessControlContext\n+ * @see AccessControlException\n+ * @see Permission\n+ * @see BasicPermission\n+ * @see java.io.FilePermission\n+ * @see java.net.SocketPermission\n+ * @see java.util.PropertyPermission\n+ * @see RuntimePermission\n+ * @see java.awt.AWTPermission\n+ * @see Policy\n+ * @see SecurityPermission\n+ * @see ProtectionDomain\n+ * @since 1.0\n+ * @status still missing 1.4 functionality\n+ */\n+public class SecurityManager\n+{\n+  /**\n+   * Tells whether or not the SecurityManager is currently performing a\n+   * security check.\n+   * @deprecated Use {@link #checkPermission(Permission)} instead.\n+   */\n+  protected boolean inCheck;\n \n-\t/** Get a list of all the classes currently executing\n-\t ** methods on the Java stack.  getClassContext()[0] is\n-\t ** the currently executing method\n-\t ** <STRONG>Spec Note:</STRONG> does not say whether\n-\t ** the stack will include the getClassContext() call or\n-\t ** the one just before it.\n-\t **\n-\t ** @return an array containing all the methods on classes\n-\t **         on the Java execution stack.\n-\t **/\n-\tprotected Class[] getClassContext() {\n-\t\treturn VMSecurityManager.getClassContext();\n-\t}\n+  /**\n+   * Construct a new security manager. There may be a security check, of\n+   * <code>RuntimePermission(\"createSecurityManager\")</code>.\n+   *\n+   * @throws SecurityException if permission is denied\n+   */\n+  public SecurityManager()\n+  {\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkPermission(new RuntimePermission(\"createSecurityManager\"));\n+  }\n \n-\t/** Find the ClassLoader for the most recent class on the\n-\t ** stack that was loaded by an explicit ClassLoader.  If\n-\t ** everything on the stack was loaded by the system\n-\t ** classloader, null is returned.\n-\t **\n-\t ** @return the most recent ClassLoader on the execution\n-\t **         stack.\n-\t **/\n-\tprotected ClassLoader currentClassLoader() {\n-\t\treturn VMSecurityManager.currentClassLoader();\n-\t}\n+  /**\n+   * Tells whether or not the SecurityManager is currently performing a\n+   * security check.\n+   *\n+   * @return true if the SecurityManager is in a security check\n+   * @see #inCheck\n+   * @deprecated use {@link #checkPermission(Permission)} instead\n+   */\n+  public boolean getInCheck()\n+  {\n+    return inCheck;\n+  }\n \n-\t/** Find the most recent class on the stack that was\n-\t ** loaded by an explicit ClassLoader.  If everything on\n-\t ** the stack was loaded by the system classloader, null\n-\t ** is returned.\n-\t **\n-\t ** @return the most recent loaded Class on the execution\n-\t **         stack.\n-\t **/\n-\tprotected Class currentLoadedClass() {\n-\t\tClass[] c = getClassContext();\n-\t\tfor(int i=0;i<c.length;i++) {\n-\t\t\tif(c[i].getClassLoader() != null) {\n-\t\t\t\treturn c[i];\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n+  /**\n+   * Get a list of all the classes currently executing methods on the Java\n+   * stack.  getClassContext()[0] is the currently executing method (ie. the\n+   * class that CALLED getClassContext, not SecurityManager).\n+   *\n+   * @return an array of classes on the Java execution stack\n+   */\n+  protected Class[] getClassContext()\n+  {\n+    return VMSecurityManager.getClassContext();\n+  }\n \n-\t/** Get the depth on the execution stack of the most\n-\t ** recent class that was loaded by an explicit\n-\t ** ClassLoader.  This can be used as an index into\n-\t ** getClassContext().\n-\t **\n-\t ** @return the index of the most recent loaded Class on\n-\t **         the execution stack.\n-\t **/\n-\tprotected int classLoaderDepth() {\n-\t\tClass[] c = getClassContext();\n-\t\tfor(int i=0;i<c.length;i++) {\n-\t\t\tif(c[i].getClassLoader() != null) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\t\treturn -1;\n-\t}\n+  /**\n+   * Find the ClassLoader of the first non-system class on the execution\n+   * stack. A non-system class is one whose ClassLoader is not equal to\n+   * {@link ClassLoader#getSystemClassLoader()} or its ancestors. This\n+   * will return null in three cases:<br><nl>\n+   * <li>All methods on the stack are from system classes</li>\n+   * <li>All methods on the stack up to the first \"privileged\" caller, as\n+   *  created by {@link AccessController.doPrivileged(PrivilegedAction)},\n+   *  are from system classes</li>\n+   * <li>A check of <code>java.security.AllPermission</code> succeeds.</li>\n+   * </nl>\n+   * \n+   * @return the most recent non-system ClassLoader on the execution stack\n+   * @deprecated use {@link #checkPermission(Permission)} instead\n+   */\n+  protected ClassLoader currentClassLoader()\n+  {\n+    return VMSecurityManager.currentClassLoader();\n+  }\n \n-\t/** Tell whether there is a class loaded with an explicit\n-\t ** ClassLoader on the stack.\n-\t **\n-\t ** @return whether there is a class loaded with an\n-\t **         explicit ClassLoader on the stack.\n-\t **/\n-\tprotected boolean inClassLoader() {\n-\t\treturn classLoaderDepth() != -1;\n-\t}\n+  /**\n+   * Find the first non-system class on the execution stack. A non-system\n+   * class is one whose ClassLoader is not equal to\n+   * {@link ClassLoader#getSystemClassLoader()} or its ancestors. This\n+   * will return null in three cases:<br><nl>\n+   * <li>All methods on the stack are from system classes</li>\n+   * <li>All methods on the stack up to the first \"privileged\" caller, as\n+   *  created by {@link AccessController.doPrivileged(PrivilegedAction)},\n+   *  are from system classes</li>\n+   * <li>A check of <code>java.security.AllPermission</code> succeeds.</li>\n+   * </nl>\n+   * \n+   * @return the most recent non-system Class on the execution stack\n+   * @deprecated use {@link #checkPermission(Permission)} instead\n+   */\n+  protected Class currentLoadedClass()\n+  {\n+    Class[] c = getClassContext();\n+    for (int i = 0; i < c.length; i++)\n+      if (c[i].getClassLoader() != null)\n+\treturn c[i];\n+    return null;\n+  }\n \n+  /**\n+   * Get the depth of a particular class on the execution stack.\n+   *\n+   * @param className the fully-qualified name to search for\n+   * @return the index of the class on the stack, or -1\n+   * @deprecated use {@link #checkPermission(Permission)} instead\n+   */\n+  protected int classDepth(String className)\n+  {\n+    Class[] c = getClassContext();\n+    for (int i = 0; i < c.length; i++)\n+      if (className.equals(c[i].getName()))\n+        return i;\n+    return -1;\n+  }\n \n-\t/** Get the depth of a particular class on the execution\n-\t ** stack.\n-\t **\n-\t ** @param className the fully-qualified name of the class\n-\t **        to search for on the stack.\n-\t ** @return the index of the class on the stack, or -1 if\n-\t **         the class is not on the stack.\n-\t **/\n-\tprotected int classDepth(String className) {\n-\t\tClass[] c = getClassContext();\n-\t\tfor(int i=0;i<c.length;i++) {\n-\t\t\tif(className.equals(c[i].getName())) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\t\treturn -1;\n-\t}\n+  /**\n+   * Get the depth on the execution stack of the most recent non-system class.\n+   * A non-system class is one whose ClassLoader is not equal to\n+   * {@link ClassLoader#getSystemClassLoader()} or its ancestors. This\n+   * will return -1 in three cases:<br><nl>\n+   * <li>All methods on the stack are from system classes</li>\n+   * <li>All methods on the stack up to the first \"privileged\" caller, as\n+   *  created by {@link AccessController.doPrivileged(PrivilegedAction)},\n+   *  are from system classes</li>\n+   * <li>A check of <code>java.security.AllPermission</code> succeeds.</li>\n+   * </nl>\n+   * \n+   * @return the index of the most recent non-system Class on the stack\n+   * @deprecated use {@link #checkPermission(Permission)} instead\n+   */\n+  protected int classLoaderDepth()\n+  {\n+    Class[] c = getClassContext();\n+    for (int i = 0; i < c.length; i++)\n+      if (c[i].getClassLoader() != null)\n+\treturn i;\n+    return -1;\n+  }\n \n-\t/** Tell whether the specified class is on the execution\n-\t ** stack.\n-\t **\n-\t ** @param className the fully-qualified name of the class\n-\t **        to search for on the stack.\n-\t ** @return whether the specified class is on the\n-\t **         execution stack.\n-\t **/\n-\tprotected boolean inClass(String className) {\n-\t\treturn classDepth(className) != -1;\n-\t}\n+  /**\n+   * Tell whether the specified class is on the execution stack.\n+   *\n+   * @param className the fully-qualified name of the class to find\n+   * @return whether the specified class is on the execution stack\n+   * @deprecated use {@link #checkPermission(Permission)} instead\n+   */\n+  protected boolean inClass(String className)\n+  {\n+    return classDepth(className) != -1;\n+  }\n \n-\t/** Get an implementation-dependent Object that contains\n-\t ** enough information about the current environment to be\n-\t ** able to perform standard security checks later.  This\n-\t ** is used by trusted methods that need to verify that\n-\t ** their callers have sufficient access to perform\n-\t ** certain operations.<P>\n-\t **\n-\t ** Currently the only methods that use this are checkRead()\n-\t ** and checkConnect().\n-\t **\n-\t ** @see checkConnect(java.lang.String,int,java.lang.Object)\n-\t ** @see checkRead(java.lang.String,java.lang.Object)\n-\t **/\n-\tpublic Object getSecurityContext() {\n-\t\treturn new SecurityContext(getClassContext());\n-\t}\n+  /**\n+   * Tell whether there is a class loaded with an explicit ClassLoader on\n+   * the stack.\n+   *\n+   * @return whether a class with an explicit ClassLoader is on the stack\n+   * @deprecated use {@link #checkPermission(Permission)} instead\n+   */\n+  protected boolean inClassLoader()\n+  {\n+    return classLoaderDepth() != -1;\n+  }\n \n-\t/** Check if the current thread is allowed to create a\n-\t ** ClassLoader.<P>\n-\t **\n-\t ** This method is called from ClassLoader.ClassLoader(),\n-\t ** in other words, whenever a ClassLoader is created.<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.lang.ClassLoader#ClassLoader()\n-\t **/\n-\tpublic void checkCreateClassLoader() {\n-\t\tthrow new SecurityException(\"Cannot create new ClassLoaders.\");\n-\t}\n+  /**\n+   * Get an implementation-dependent Object that contains enough information\n+   * about the current environment to be able to perform standard security\n+   * checks later.  This is used by trusted methods that need to verify that\n+   * their callers have sufficient access to perform certain operations.\n+   *\n+   * <p>Currently the only methods that use this are checkRead() and\n+   * checkConnect(). The default implementation returns an\n+   * <code>AccessControlContext</code>.\n+   *\n+   * @return a security context\n+   * @see #checkConnect(String, int, Object)\n+   * @see #checkRead(String, Object)\n+   * @see AccessControlContext\n+   * @see AccessController#getContext()\n+   */\n+  public Object getSecurityContext()\n+  {\n+    // XXX Should be: return AccessController.getContext();\n+    return new SecurityContext(getClassContext());\n+  }\n \n-\t/** Check if the current thread is allowed to modify this\n-\t ** other Thread.<P>\n-\t **\n-\t ** Called by Thread.stop(), suspend(), resume(), and\n-\t ** interrupt(), destroy(), setPriority(), setName() and\n-\t ** setDaemon().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param g the Thread to check against\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.lang.Thread#stop()\n-\t ** @see java.lang.Thread#suspend()\n-\t ** @see java.lang.Thread#resume()\n-\t ** @see java.lang.Thread#interrupt()\n-\t ** @see java.lang.Thread#destroy()\n-\t ** @see java.lang.Thread#setPriority(int)\n-\t ** @see java.lang.Thread#setName(java.lang.String)\n-\t ** @see java.lang.Thread#setDaemon(boolean)\n-\t **/\n-\tpublic void checkAccess(Thread t) {\n-\t\tthrow new SecurityException(\"Cannot modify Threads.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to perform an operation that\n+   * requires the specified <code>Permission</code>. This defaults to\n+   * <code>AccessController.checkPermission</code>.\n+   *\n+   * @param perm the <code>Permission</code> required\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if perm is null\n+   * @since 1.2\n+   */\n+  public void checkPermission(Permission perm)\n+  {\n+    // XXX Should be: AccessController.checkPermission(perm);\n+    throw new SecurityException(\"Operation not allowed\");\n+  }\n \n-\t/** Check if the current thread is allowed to modify this\n-\t ** ThreadGroup.<P>\n-\t **\n-\t ** Called by Thread.Thread() (to add a thread to the\n-\t ** ThreadGroup), ThreadGroup.ThreadGroup() (to add this\n-\t ** ThreadGroup to a parent), ThreadGroup.stop(),\n-\t ** suspend(), resume(), interrupt(), destroy(),\n-\t ** setDaemon(), and setMaxPriority().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param g the ThreadGroup to check against\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.lang.Thread#Thread()\n-\t ** @see java.lang.ThreadGroup#ThreadGroup()\n-\t ** @see java.lang.ThreadGroup#stop()\n-\t ** @see java.lang.ThreadGroup#suspend()\n-\t ** @see java.lang.ThreadGroup#resume()\n-\t ** @see java.lang.ThreadGroup#interrupt()\n-\t ** @see java.lang.ThreadGroup#setDaemon(boolean)\n-\t ** @see java.lang.ThreadGroup#setMaxPriority(int)\n-\t **/\n-\tpublic void checkAccess(ThreadGroup g) {\n-\t\tthrow new SecurityException(\"Cannot modify ThreadGroups.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to perform an operation that\n+   * requires the specified <code>Permission</code>. This is done in a\n+   * context previously returned by <code>getSecurityContext()</code>. The\n+   * default implementation expects context to be an AccessControlContext,\n+   * and it calls <code>AccessControlContext.checkPermission(perm)</code>.\n+   *\n+   * @param perm the <code>Permission</code> required\n+   * @param context a security context\n+   * @throws SecurityException if permission is denied, or if context is\n+   *         not an AccessControlContext\n+   * @throws NullPointerException if perm is null\n+   * @see #getSecurityContext()\n+   * @see AccessControlContext#checkPermission(Permission)\n+   * @since 1.2\n+   */\n+  public void checkPermission(Permission perm, Object context)\n+  {\n+    // XXX Should be:\n+    // if (! (context instanceof AccessControlContext))\n+    //   throw new SecurityException(\"Missing context\");\n+    // ((AccessControlContext) context).checkPermission(perm);\n+    throw new SecurityException(\"Operation not allowed\");\n+  }\n \n-\t/** Check if the current thread is allowed to exit the\n-\t ** JVM with the given status.<P>\n-\t **\n-\t ** This method is called from Runtime.exit().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param status the status to exit with\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.lang.Runtime#exit()\n-\t ** @see java.lang.Runtime#exit(int)\n-\t **/\n-\tpublic void checkExit(int status) {\n-\t\tthrow new SecurityException(\"Cannot exit JVM.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to create a ClassLoader. This\n+   * method is called from ClassLoader.ClassLoader(), and checks\n+   * <code>RuntimePermission(\"createClassLoader\")</code>. If you override\n+   * this, you should call <code>super.checkCreateClassLoader()</code> rather\n+   * than throwing an exception.\n+   *\n+   * @throws SecurityException if permission is denied\n+   * @see ClassLoader#ClassLoader()\n+   */\n+  public void checkCreateClassLoader()\n+  {\n+    checkPermission(new RuntimePermission(\"createClassLoader\"));\n+  }\n \n-\t/** Check if the current thread is allowed to execute the\n-\t ** given program.<P>\n-\t **\n-\t ** This method is called from Runtime.exec().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param program the name of the program to exec\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.lang.Runtime#exec(java.lang.String[],java.lang.String[])\n-\t **/\n-\tpublic void checkExec(String program) {\n-\t\tthrow new SecurityException(\"Cannot execute programs.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to modify another Thread. This is\n+   * called by Thread.stop(), suspend(), resume(), interrupt(), destroy(),\n+   * setPriority(), setName(), and setDaemon(). The default implementation\n+   * checks <code>RuntimePermission(\"modifyThread\") on system threads (ie.\n+   * threads in ThreadGroup with a null parent), and returns silently on\n+   * other threads.\n+   *\n+   * <p>If you override this, you must do two things. First, call\n+   * <code>super.checkAccess(t)</code>, to make sure you are not relaxing\n+   * requirements. Second, if the calling thread has\n+   * <code>RuntimePermission(\"modifyThread\")</code>, return silently, so that\n+   * core classes (the Classpath library!) can modify any thread.\n+   *\n+   * @param t the other Thread to check\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if t is null\n+   * @see Thread#stop()\n+   * @see Thread#suspend()\n+   * @see Thread#resume()\n+   * @see Thread#setPriority(int)\n+   * @see Thread#setName(String)\n+   * @see Thread#setDaemon(boolean)\n+   */\n+  public void checkAccess(Thread t)\n+  {\n+    if (t.group != null && t.group.getParent() != null)\n+      checkPermission(new RuntimePermission(\"modifyThread\"));\n+  }\n \n-\t/** Check if the current thread is allowed to link in the\n-\t ** given native library.<P>\n-\t **\n-\t ** This method is called from Runtime.load() (and hence,\n-\t ** by loadLibrary() as well).<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param filename the full name of the library to load\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.lang.Runtime#load(java.lang.String)\n-\t **/\n-\tpublic void checkLink(String filename) {\n-\t\tthrow new SecurityException(\"Cannot link native libraries.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to modify a ThreadGroup. This is\n+   * called by Thread.Thread() (to add a thread to the ThreadGroup),\n+   * ThreadGroup.ThreadGroup() (to add this ThreadGroup to a parent),\n+   * ThreadGroup.stop(), suspend(), resume(), interrupt(), destroy(),\n+   * setDaemon(), and setMaxPriority(). The default implementation\n+   * checks <code>RuntimePermission(\"modifyThread\") on the system group (ie.\n+   * the one with a null parent), and returns silently on other groups.\n+   *\n+   * <p>If you override this, you must do two things. First, call\n+   * <code>super.checkAccess(t)</code>, to make sure you are not relaxing\n+   * requirements. Second, if the calling thread has\n+   * <code>RuntimePermission(\"modifyThreadGroup\")</code>, return silently,\n+   * so that core classes (the Classpath library!) can modify any thread.\n+   *\n+   * @param g the ThreadGroup to check\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if g is null\n+   * @see Thread#Thread()\n+   * @see ThreadGroup#ThreadGroup()\n+   * @see ThreadGroup#stop()\n+   * @see ThreadGroup#suspend()\n+   * @see ThreadGroup#resume()\n+   * @see ThreadGroup#interrupt()\n+   * @see ThreadGroup#setDaemon(boolean)\n+   * @see ThreadGroup#setMaxPriority(int)\n+   */\n+  public void checkAccess(ThreadGroup g)\n+  {\n+    if (g.getParent() != null)\n+      checkPermission(new RuntimePermission(\"modifyThreadGroup\"));\n+  }\n \n-\t/** Check if the current thread is allowed to read the\n-\t ** given file using the FileDescriptor.<P>\n-\t **\n-\t ** This method is called from\n-\t ** FileInputStream.FileInputStream().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param desc the FileDescriptor representing the file\n-\t **        to access\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.io.FileInputStream#FileInputStream(java.io.FileDescriptor)\n-\t **/\n-\tpublic void checkRead(FileDescriptor desc) {\n-\t\tthrow new SecurityException(\"Cannot read files via file descriptors.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to exit the JVM with the given\n+   * status. This method is called from Runtime.exit() and Runtime.halt().\n+   * The default implementation checks\n+   * <code>RuntimePermission(\"exitVM\")</code>. If you override this, call\n+   * <code>super.checkExit</code> rather than throwing an exception.\n+   *\n+   * @param status the status to exit with\n+   * @throws SecurityException if permission is denied\n+   * @see Runtime#exit(int)\n+   * @see Runtime#halt(int)\n+   */\n+  public void checkExit(int status)\n+  {\n+    checkPermission(new RuntimePermission(\"exitVM\"));\n+  }\n \n-\t/** Check if the current thread is allowed to read the\n-\t ** given file.<P>\n-\t **\n-\t ** This method is called from\n-\t ** FileInputStream.FileInputStream(),\n-\t ** RandomAccessFile.RandomAccessFile(), File.exists(),\n-\t ** canRead(), isFile(), isDirectory(), lastModified(),\n-\t ** length() and list().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param filename the full name of the file to access\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.io.File\n-\t ** @see java.io.FileInputStream#FileInputStream(java.lang.String)\n-\t ** @see java.io.RandomAccessFile#RandomAccessFile(java.lang.String)\n-\t **/\n-\tpublic void checkRead(String filename) {\n-\t\tthrow new SecurityException(\"Cannot read files via file names.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to execute the given program. This\n+   * method is called from Runtime.exec(). If the name is an absolute path,\n+   * the default implementation checks\n+   * <code>FilePermission(program, \"execute\")</code>, otherwise it checks\n+   * <code>FilePermission(\"&lt;&lt;ALL FILES&gt;&gt;\", \"execute\")</code>. If\n+   * you override this, call <code>super.checkExec</code> rather than\n+   * throwing an exception.\n+   *\n+   * @param program the name of the program to exec\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if program is null\n+   * @see Runtime#exec(String[], String[], File)\n+   */\n+  public void checkExec(String program)\n+  {\n+    if (! program.equals(new File(program).getAbsolutePath()))\n+      program = \"<<ALL FILES>>\";\n+    checkPermission(new FilePermission(program, \"execute\"));\n+  }\n \n-\t/** Check if the current thread is allowed to read the\n-\t ** given file. using the given SecurityContext.<P>\n-\t **\n-\t ** I know of no core class that calls this method.<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param filename the full name of the file to access\n-\t ** @param securityContext the Security Context to\n-\t **        determine access for.\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t **/\n-\tpublic void checkRead(String filename, Object securityContext) {\n-\t\tthrow new SecurityException(\"Cannot read files via file names.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to link in the given native\n+   * library. This method is called from Runtime.load() (and hence, by\n+   * loadLibrary() as well). The default implementation checks\n+   * <code>RuntimePermission(\"loadLibrary.\" + filename)</code>. If you\n+   * override this, call <code>super.checkLink</code> rather than throwing\n+   * an exception.\n+   *\n+   * @param filename the full name of the library to load\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if filename is null\n+   * @see Runtime#load(String)\n+   */\n+  public void checkLink(String filename)\n+  {\n+    // Use the toString() hack to do the null check.\n+    checkPermission(new RuntimePermission(\"loadLibrary.\"\n+                                          + filename.toString()));\n+  }\n \n-\t/** Check if the current thread is allowed to write to the\n-\t ** given file using the FileDescriptor.<P>\n-\t **\n-\t ** This method is called from\n-\t ** FileOutputStream.FileOutputStream().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param desc the FileDescriptor representing the file\n-\t **        to access\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.io.FileOutputStream#FileOutputStream(java.io.FileDescriptor)\n-\t **/\n-\tpublic void checkWrite(FileDescriptor desc) {\n-\t\tthrow new SecurityException(\"Cannot write files via file descriptors.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to read the given file using the\n+   * FileDescriptor. This method is called from\n+   * FileInputStream.FileInputStream(). The default implementation checks\n+   * <code>RuntimePermission(\"readFileDescriptor\")</code>. If you override\n+   * this, call <code>super.checkRead</code> rather than throwing an\n+   * exception.\n+   *\n+   * @param desc the FileDescriptor representing the file to access\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if desc is null\n+   * @see FileInputStream#FileInputStream(FileDescriptor)\n+   */\n+  public void checkRead(FileDescriptor desc)\n+  {\n+    if (desc == null)\n+      throw new NullPointerException();\n+    checkPermission(new RuntimePermission(\"readFileDescriptor\"));\n+  }\n \n-\t/** Check if the current thread is allowed to write to the\n-\t ** given file.<P>\n-\t **\n-\t ** This method is called from\n-\t ** FileOutputStream.FileOutputStream(),\n-\t ** RandomAccessFile.RandomAccessFile(),\n-\t ** File.canWrite(), mkdir(), and renameTo().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param filename the full name of the file to access\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.io.File#canWrite()\n-\t ** @see java.io.File#mkdir()\n-\t ** @see java.io.File#renameTo()\n-\t ** @see java.io.FileOutputStream#FileOutputStream(java.lang.String)\n-\t ** @see java.io.RandomAccessFile#RandomAccessFile(java.lang.String)\n-\t **/\n-\tpublic void checkWrite(String filename) {\n-\t\tthrow new SecurityException(\"Cannot write files via file names.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to read the given file. This\n+   * method is called from FileInputStream.FileInputStream(),\n+   * RandomAccessFile.RandomAccessFile(), File.exists(), canRead(), isFile(),\n+   * isDirectory(), lastModified(), length() and list(). The default\n+   * implementation checks <code>FilePermission(filename, \"read\")</code>. If\n+   * you override this, call <code>super.checkRead</code> rather than\n+   * throwing an exception.\n+   *\n+   * @param filename the full name of the file to access\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if filename is null\n+   * @see File\n+   * @see FileInputStream#FileInputStream(String)\n+   * @see RandomAccessFile#RandomAccessFile(String)\n+   */\n+  public void checkRead(String filename)\n+  {\n+    checkPermission(new FilePermission(filename, \"read\"));\n+  }\n \n-\t/** Check if the current thread is allowed to delete the\n-\t ** given file.<P>\n-\t **\n-\t ** This method is called from File.delete().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param filename the full name of the file to delete\n-\t ** @exception SecurityException if th operation is not\n-\t **            permitted.\n-\t ** @see java.io.File#delete()\n-\t **/\n-\tpublic void checkDelete(String filename) {\n-\t\tthrow new SecurityException(\"Cannot delete files.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to read the given file. using the\n+   * given security context. The context must be a result of a previous call\n+   * to <code>getSecurityContext()</code>. The default implementation checks\n+   * <code>AccessControlContext.checkPermission(new FilePermission(filename,\n+   * \"read\"))</code>. If you override this, call <code>super.checkRead</code>\n+   * rather than throwing an exception.\n+   *\n+   * @param filename the full name of the file to access\n+   * @param context the context to determine access for\n+   * @throws SecurityException if permission is denied, or if context is\n+   *         not an AccessControlContext\n+   * @throws NullPointerException if filename is null\n+   * @see #getSecurityContext()\n+   * @see AccessControlContext#checkPermission(Permission)\n+   */\n+  public void checkRead(String filename, Object context)\n+  {\n+    // XXX Should be:\n+    // if (! (context instanceof AccessControlContext))\n+    //   throw new SecurityException(\"Missing context\");\n+    // AccessControlContext ac = (AccessControlContext) context;\n+    // ac.checkPermission(new FilePermission(filename, \"read\"));\n+    throw new SecurityException(\"Cannot read files via file names.\");\n+  }\n \n-\t/** Check if the current thread is allowed to connect to a\n-\t ** given host on a given port.<P>\n-\t **\n-\t ** This method is called from Socket.Socket().\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param host the host to connect to\n-\t ** @param port the port to connect on\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted\n-\t ** @see java.net.Socket#Socket()\n-\t **/\n-\tpublic void checkConnect(String host, int port) {\n-\t\tthrow new SecurityException(\"Cannot make network connections.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to write the given file using the\n+   * FileDescriptor. This method is called from\n+   * FileOutputStream.FileOutputStream(). The default implementation checks\n+   * <code>RuntimePermission(\"writeFileDescriptor\")</code>. If you override\n+   * this, call <code>super.checkWrite</code> rather than throwing an\n+   * exception.\n+   *\n+   * @param desc the FileDescriptor representing the file to access\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if desc is null\n+   * @see FileOutputStream#FileOutputStream(FileDescriptor)\n+   */\n+  public void checkWrite(FileDescriptor desc)\n+  {\n+    if (desc == null)\n+      throw new NullPointerException();\n+    checkPermission(new RuntimePermission(\"writeFileDescriptor\"));\n+  }\n \n-\t/** Check if the current thread is allowed to connect to a\n-\t ** given host on a given port using a specific security\n-\t ** context to determine access.<P>\n-\t **\n-\t ** This method is not called in the 1.1 core classes.<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param host the host to connect to\n-\t ** @param port the port to connect on\n-\t ** @param securityContext the security context to\n-\t **        determine access with\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted\n-\t **/\n-\tpublic void checkConnect(String host, int port, Object securityContext) {\n-\t\tthrow new SecurityException(\"Cannot make network connections.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to write the given file. This\n+   * method is called from FileOutputStream.FileOutputStream(),\n+   * RandomAccessFile.RandomAccessFile(), File.canWrite(), mkdir(), and\n+   * renameTo(). The default implementation checks\n+   * <code>FilePermission(filename, \"write\")</code>. If you override this,\n+   * call <code>super.checkWrite</code> rather than throwing an exception.\n+   *\n+   * @param filename the full name of the file to access\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if filename is null\n+   * @see File\n+   * @see File#canWrite()\n+   * @see File#mkdir()\n+   * @see File#renameTo()\n+   * @see FileOutputStream#FileOutputStream(String)\n+   * @see RandomAccessFile#RandomAccessFile(String)\n+   */\n+  public void checkWrite(String filename)\n+  {\n+    checkPermission(new FilePermission(filename, \"write\"));\n+  }\n \n-\t/** Check if the current thread is allowed to listen to a\n-\t ** specific port for data.<P>\n-\t **\n-\t ** This method is called by ServerSocket.ServerSocket().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param port the port to listen on\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted\n-\t ** @see java.net.ServerSocket#ServerSocket(int)\n-\t **/\n-\tpublic void checkListen(int port) {\n-\t\tthrow new SecurityException(\"Cannot listen for connections.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to delete the given file. This\n+   * method is called from File.delete(). The default implementation checks\n+   * <code>FilePermission(filename, \"delete\")</code>. If you override this,\n+   * call <code>super.checkDelete</code> rather than throwing an exception.\n+   *\n+   * @param filename the full name of the file to delete\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if filename is null\n+   * @see File#delete()\n+   */\n+  public void checkDelete(String filename)\n+  {\n+    checkPermission(new FilePermission(filename, \"delete\"));\n+  }\n \n-\t/** Check if the current thread is allowed to accept a\n-\t ** connection from a particular host on a particular\n-\t ** port.<P>\n-\t **\n-\t ** This method is called by ServerSocket.implAccept().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param host the host which wishes to connect\n-\t ** @param port the port the connection will be on\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted\n-\t ** @see java.net.ServerSocket#accept()\n-\t **/\n-\tpublic void checkAccept(String host, int port) {\n-\t\tthrow new SecurityException(\"Cannot accept connections.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to connect to a given host on a\n+   * given port. This method is called from Socket.Socket(). A port number\n+   * of -1 indicates the caller is attempting to determine an IP address, so\n+   * the default implementation checks\n+   * <code>SocketPermission(host, \"resolve\")</code>. Otherwise, the default\n+   * implementation checks\n+   * <code>SocketPermission(host + \":\" + port, \"connect\")</code>. If you\n+   * override this, call <code>super.checkConnect</code> rather than throwing\n+   * an exception.\n+   *\n+   * @param host the host to connect to\n+   * @param port the port to connect on\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if host is null\n+   * @see Socket#Socket()\n+   */\n+  public void checkConnect(String host, int port)\n+  {\n+    if (port == -1)\n+      checkPermission(new SocketPermission(host, \"resolve\"));\n+    else\n+      // Use the toString() hack to do the null check.\n+      checkPermission(new SocketPermission(host.toString() + \":\" + port,\n+                                           \"connect\"));\n+  }\n \n-\t/** Check if the current thread is allowed to read and\n-\t ** write multicast to a particular address.<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @XXX where is it called?\n-\t **\n-\t ** @param addr the address to multicast to.\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t **/\n-\tpublic void checkMulticast(InetAddress addr) {\n-\t\tthrow new SecurityException(\"Cannot read or write multicast.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to connect to a given host on a\n+   * given port, using the given security context. The context must be a\n+   * result of a previous call to <code>getSecurityContext</code>. A port\n+   * number of -1 indicates the caller is attempting to determine an IP\n+   * address, so the default implementation checks\n+   * <code>AccessControlContext.checkPermission(new SocketPermission(host,\n+   * \"resolve\"))</code>. Otherwise, the default implementation checks\n+   * <code>AccessControlContext.checkPermission(new SocketPermission(host\n+   * + \":\" + port, \"connect\"))</code>. If you override this, call\n+   * <code>super.checkConnect</code> rather than throwing an exception.\n+   *\n+   * @param host the host to connect to\n+   * @param port the port to connect on\n+   * @param context the context to determine access for\n+   * @throws SecurityException if permission is denied, or if context is\n+   *         not an AccessControlContext\n+   * @throws NullPointerException if host is null\n+   * @see #getSecurityContext()\n+   * @see AccessControlContext#checkPermission(Permission)\n+   */\n+  public void checkConnect(String host, int port, Object securityContext)\n+  {\n+    // XXX Should be:\n+    // if (! (context instanceof AccessControlContext))\n+    //   throw new SecurityException(\"Missing context\");\n+    // AccessControlContext ac = (AccessControlContext) context;\n+    // if (port == -1)\n+    //   ac.checkPermission(new SocketPermission(host, \"resolve\"));\n+    // else\n+    //   // Use the toString() hack to do the null check.\n+    //   ac.checkPermission(new SocketPermission(host.toString + \":\" +port,\n+    //                                           \"connect\"));\n+    throw new SecurityException(\"Cannot make network connections.\");\n+  }\n \n-\t/** Check if the current thread is allowed to read and\n-\t ** write multicast to a particular address with a\n-\t ** particular ttl value.<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.<P>\n-\t **\n-\t ** @XXX where is it called?\n-\t **\n-\t ** @XXX what the hell is ttl?  Expand abbreviation.\n-\t **\n-\t ** @param addr the address to multicast to.\n-\t ** @param ttl the ttl value to use\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t **/\n-\tpublic void checkMulticast(InetAddress addr, byte ttl) {\n-\t\tthrow new SecurityException(\"Cannot read or write multicast.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to listen to a specific port for\n+   * data. This method is called by ServerSocket.ServerSocket(). The default\n+   * implementation checks\n+   * <code>SocketPermission(\"localhost:\" + (port == 0 ? \"1024-\" : \"\" + port),\n+   * \"listen\")</code>. If you override this, call\n+   * <code>super.checkListen</code> rather than throwing an exception.\n+   *\n+   * @param port the port to listen on\n+   * @throws SecurityException if permission is denied\n+   * @see ServerSocket#ServerSocket(int)\n+   */\n+  public void checkListen(int port)\n+  {\n+    checkPermission(new SocketPermission(\"localhost:\"\n+                                         + (port == 0 ? \"1024-\" : \"\" +port),\n+                                         \"listen\"));\n+  }\n \n-        /**\n-         ** Check if the current thread is allowed to perform an\n-         ** operation that requires the specified <code>Permission</code>.\n-         **\n-         ** @param perm The <code>Permission</code> required.\n-         ** @exception SecurityException If the operation is not allowed.\n-         **/\n-         public void checkPermission(java.security.Permission perm) {\n-\t\tthrow new SecurityException(\"Operation not allowed\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to accept a connection from a\n+   * particular host on a particular port. This method is called by\n+   * ServerSocket.implAccept(). The default implementation checks\n+   * <code>SocketPermission(host + \":\" + port, \"accept\")</code>. If you\n+   * override this, call <code>super.checkAccept</code> rather than throwing\n+   * an exception.\n+   *\n+   * @param host the host which wishes to connect\n+   * @param port the port the connection will be on\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if host is null\n+   * @see ServerSocket#accept()\n+   */\n+  public void checkAccept(String host, int port)\n+  {\n+    // Use the toString() hack to do the null check.\n+    checkPermission(new SocketPermission(host.toString() + \":\" + port,\n+                                         \"accept\"));\n+  }\n \n-        /**\n-         ** Check if the current thread is allowed to perform an\n-         ** operation that requires the specified <code>Permission</code>.\n-         **\n-         ** @param perm The <code>Permission</code> required.\n-\t ** @param context A security context\n-         ** @exception SecurityException If the operation is not allowed.\n-\t ** @since 1.2\n-         **/\n-         public void checkPermission(java.security.Permission perm,\n-\t\t\t\t     Object context) {\n-\t\tthrow new SecurityException(\"Operation not allowed\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to read and write multicast to\n+   * a particular address. The default implementation checks\n+   * <code>SocketPermission(addr.getHostAddress(), \"accept,connect\")</code>.\n+   * If you override this, call <code>super.checkMulticast</code> rather than\n+   * throwing an exception.\n+   *\n+   * @param addr the address to multicast to\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if host is null\n+   * @since 1.1\n+   */\n+  public void checkMulticast(InetAddress addr)\n+  {\n+    checkPermission(new SocketPermission(addr.getHostAddress(),\n+                                         \"accept,connect\"));\n+  }\n \n-\t/** Check if the current thread is allowed to read or\n-\t ** write all the system properties at once.<P>\n-\t **\n-\t ** This method is called by System.getProperties()\n-\t ** and setProperties().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.lang.System#getProperties()\n-\t ** @see java.lang.System#setProperties(java.util.Properties)\n-\t **/\n-\tpublic void checkPropertiesAccess() {\n-\t\tthrow new SecurityException(\"Cannot access all system properties at once.\");\n-\t}\n+  /**\n+   *Check if the current thread is allowed to read and write multicast to\n+   * a particular address with a particular ttl (time-to-live) value. The\n+   * default implementation ignores ttl, and checks\n+   * <code>SocketPermission(addr.getHostAddress(), \"accept,connect\")</code>.\n+   * If you override this, call <code>super.checkMulticast</code> rather than\n+   * throwing an exception.\n+   *\n+   * @param addr the address to multicast to\n+   * @param ttl value in use for multicast send\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if host is null\n+   * @since 1.1\n+   * @deprecated use {@link #checkPermission(Permission)} instead\n+   */\n+  public void checkMulticast(InetAddress addr, byte ttl)\n+  {\n+    checkPermission(new SocketPermission(addr.getHostAddress(),\n+                                         \"accept,connect\"));\n+  }\n \n-\t/** Check if the current thread is allowed to read or\n-\t ** write a particular system property.<P>\n-\t **\n-\t ** This method is called by System.getProperty() and\n-\t ** setProperty().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @exception SecurityException is the operation is not\n-\t **            permitted.\n-\t ** @see java.lang.System#getProperty(java.lang.String)\n-\t ** @see java.lang.System#setProperty(java.lang.String,java.lang.String)\n-\t **/\n-\tpublic void checkPropertyAccess(String name) {\n-\t\tthrow new SecurityException(\"Cannot access individual system properties.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to read or write all the system\n+   * properties at once. This method is called by System.getProperties()\n+   * and setProperties(). The default implementation checks\n+   * <code>PropertyPermission(\"*\", \"read,write\")</code>. If you override\n+   * this, call <code>super.checkPropertiesAccess</code> rather than\n+   * throwing an exception.\n+   *\n+   * @throws SecurityException if permission is denied\n+   * @see System#getProperties()\n+   * @see System#setProperties(Properties)\n+   */\n+  public void checkPropertiesAccess()\n+  {\n+    checkPermission(new PropertyPermission(\"*\", \"read,write\"));\n+  }\n \n-\t/** Check if the current thread is allowed to create a\n-\t ** top-level window.  If it is not, the operation should\n-\t ** still go through, but some sort of nonremovable\n-\t ** warning should be placed on the window to show that it\n-\t ** is untrusted.<P>\n-\t **\n-\t ** This method is called by Window.Window().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param window the window to create\n-\t ** @see java.awt.Window#Window(java.awt.Frame)\n-\t **/\n-\tpublic boolean checkTopLevelWindow(Object window) {\n-\t  return false;\n-\t}\n+  /**\n+   * Check if the current thread is allowed to read a particular system\n+   * property (writes are checked directly via checkPermission). This method\n+   * is called by System.getProperty() and setProperty(). The default\n+   * implementation checks <code>PropertyPermission(key, \"read\")</code>. If\n+   * you override this, call <code>super.checkPropertyAccess</code> rather\n+   * than throwing an exception.\n+   *\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if key is null\n+   * @throws IllegalArgumentException if key is \"\"\n+   * @see System#getProperty(String)\n+   */\n+  public void checkPropertyAccess(String key)\n+  {\n+    checkPermission(new PropertyPermission(key, \"read\"));\n+  }\n \n-\t/** Check if the current thread is allowed to create a\n-\t ** print job.<P>\n-\t **\n-\t ** This method is called by Toolkit.getPrintJob().  (I\n-\t ** assume so, at least, it just don't say nothing about\n-\t ** it in the spec.)<P>\n-\t ** \n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.awt.Toolkit.getPrintJob(java.awt.Frame,java.lang.String,java.util.Properties)\n-\t **/\n-\tpublic void checkPrintJobAccess() {\n-\t\tthrow new SecurityException(\"Cannot create print jobs.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to create a top-level window. If\n+   * it is not, the operation should still go through, but some sort of\n+   * nonremovable warning should be placed on the window to show that it\n+   * is untrusted. This method is called by Window.Window(). The default\n+   * implementation checks\n+   * <code>AWTPermission(\"showWindowWithoutWarningBanner\")</code>, and returns\n+   * true if no exception was thrown. If you override this, use\n+   * <code>return super.checkTopLevelWindow</code> rather than returning\n+   * false.\n+   *\n+   * @param window the window to create\n+   * @return true if there is permission to show the window without warning\n+   * @throws NullPointerException if window is null\n+   * @see Window#Window(Frame)\n+   */\n+  public boolean checkTopLevelWindow(Object window)\n+  {\n+    if (window == null)\n+      throw new NullPointerException();\n+    try\n+      {\n+        checkPermission(new AWTPermission(\"showWindowWithoutWarningBanner\"));\n+        return true;\n+      }\n+    catch (SecurityException e)\n+      {\n+        return false;\n+      }\n+  }\n \n-\t/** Check if the current thread is allowed to use the\n-\t ** system clipboard.<P>\n-\t **\n-\t ** This method is called by Toolkit.getSystemClipboard().\n-\t ** (I assume.)<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.awt.Toolkit#getSystemClipboard()\n-\t **/\n-\tpublic void checkSystemClipboardAccess() {\n-\t\tthrow new SecurityException(\"Cannot access the system clipboard.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to create a print job. This\n+   * method is called by Toolkit.getPrintJob(). The default implementation\n+   * checks <code>RuntimePermission(\"queuePrintJob\")</code>. If you override\n+   * this, call <code>super.checkPrintJobAccess</code> rather than throwing\n+   * an exception.\n+   *\n+   * @throws SecurityException if permission is denied\n+   * @see Toolkit#getPrintJob(Frame, String, Properties)\n+   * @since 1.1\n+   */\n+  public void checkPrintJobAccess()\n+  {\n+    checkPermission(new RuntimePermission(\"queuePrintJob\"));\n+  }\n \n-\t/** Check if the current thread is allowed to use the AWT\n-\t ** event queue.<P>\n-\t **\n-\t ** This method is called by Toolkit.getSystemEventQueue().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.awt.Toolkit#getSystemEventQueue()\n-\t **/\n-\tpublic void checkAwtEventQueueAccess() {\n-\t\tthrow new SecurityException(\"Cannot access the AWT event queue.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to use the system clipboard. This\n+   * method is called by Toolkit.getSystemClipboard(). The default\n+   * implementation checks <code>AWTPermission(\"accessClipboard\")</code>. If\n+   * you override this, call <code>super.checkSystemClipboardAccess</code>\n+   * rather than throwing an exception.\n+   *\n+   * @throws SecurityException if permission is denied\n+   * @see Toolkit#getSystemClipboard()\n+   * @since 1.1\n+   */\n+  public void checkSystemClipboardAccess()\n+  {\n+    checkPermission(new AWTPermission(\"accessClipboard\"));\n+  }\n \n-\t/** Check if the current thread is allowed to access the\n-\t ** specified package at all.<P>\n-\t **\n-\t ** This method is called by ClassLoader.loadClass() in\n-\t ** user-created ClassLoaders.<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param packageName the package name to check access to\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)\n-\t **/\n-\tpublic void checkPackageAccess(String packageName) {\n-\t\tthrow new SecurityException(\"Cannot access packages via the ClassLoader.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to use the AWT event queue. This\n+   * method is called by Toolkit.getSystemEventQueue(). The default\n+   * implementation checks <code>AWTPermission(\"accessEventQueue\")</code>.\n+   * you override this, call <code>super.checkAwtEventQueueAccess</code>\n+   * rather than throwing an exception.\n+   *\n+   * @throws SecurityException if permission is denied\n+   * @see Toolkit#getSystemEventQueue()\n+   * @since 1.1\n+   */\n+  public void checkAwtEventQueueAccess()\n+  {\n+    // Should be: checkPermission(new AWTPermission(\"accessEventQueue\"));\n+    throw new SecurityException(\"Cannot access the AWT event queue.\");\n+  }\n \n-\t/** Check if the current thread is allowed to define\n-\t ** classes the specified package.  If the class already\n-\t ** created, though, ClassLoader.loadClass() can still\n-\t ** return the Class if checkPackageAccess() checks out.<P>\n-\t **\n-\t ** This method is called by ClassLoader.loadClass() in\n-\t ** user-created ClassLoaders.<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param packageName the package name to check access to\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)\n-\t **/\n-\tpublic void checkPackageDefinition(String packageName) {\n-\t\tthrow new SecurityException(\"Cannot load classes into any packages via the ClassLoader.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to access the specified package\n+   * at all. This method is called by ClassLoader.loadClass() in user-created\n+   * ClassLoaders. The default implementation gets a list of all restricted\n+   * packages, via <code>Security.getProperty(\"package.access\")</code>. Then,\n+   * if packageName starts with or equals any restricted package, it checks\n+   * <code>RuntimePermission(\"accessClassInPackage.\" + packageName)</code>.\n+   * If you override this, you should call\n+   * <code>super.checkPackageAccess</code> before doing anything else.\n+   *\n+   * @param packageName the package name to check access to\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if packageName is null\n+   * @see ClassLoader#loadClass(String, boolean)\n+   * @see Security#getProperty(String)\n+   */\n+  public void checkPackageAccess(String packageName)\n+  {\n+    checkPackageList(packageName, \"access\", \"accessClassInPackage.\");\n+  }\n \n-\t/** Check if the current thread is allowed to set the\n-\t ** current socket factory.<P>\n-\t **\n-\t ** This method is called by Socket.setSocketImplFactory(),\n-\t ** ServerSocket.setSocketFactory(), and\n-\t ** URL.setURLStreamHandlerFactory().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)\n-\t ** @see java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)\n-\t ** @see java.net.URL#setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory)\n-\t **/\n-\tpublic void checkSetFactory() {\n-\t\tthrow new SecurityException(\"Cannot set the socket factory.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to define a class into the\n+   * specified package. This method is called by ClassLoader.loadClass() in\n+   * user-created ClassLoaders. The default implementation gets a list of all\n+   * restricted packages, via\n+   * <code>Security.getProperty(\"package.definition\")</code>. Then, if\n+   * packageName starts with or equals any restricted package, it checks\n+   * <code>RuntimePermission(\"defineClassInPackage.\" + packageName)</code>.\n+   * If you override this, you should call\n+   * <code>super.checkPackageDefinition</code> before doing anything else.\n+   *\n+   * @param packageName the package name to check access to\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if packageName is null\n+   * @see ClassLoader#loadClass(String, boolean)\n+   * @see Security#getProperty(String)\n+   */\n+  public void checkPackageDefinition(String packageName)\n+  {\n+    checkPackageList(packageName, \"definition\", \"defineClassInPackage.\");\n+  }\n \n-\t/** Check if the current thread is allowed to get certain\n-\t ** types of Methods, Fields and Constructors from a Class\n-\t ** object.<P>\n-\t **\n-\t ** This method is called by Class.getMethod[s](),\n-\t ** Class.getField[s](), Class.getConstructor[s],\n-\t ** Class.getDeclaredMethod[s](),\n-\t ** Class.getDeclaredField[s](), and\n-\t ** Class.getDeclaredConstructor[s]().<P>\n-\t **\n-\t ** SecurityManager's implementation always denies access.\n-\t **\n-\t ** @param c the Class to check\n-\t ** @param memberType the type of members to check\n-\t **        against, either Member.DECLARED or\n-\t **        Member.PUBLIC.\n-\t ** @exception SecurityException if the operation is not\n-\t **            permitted.\n-\t ** @see java.lang.Class\n-\t ** @see java.lang.reflect.Member#DECLARED\n-\t ** @see java.lang.reflect.Member#PUBLIC\n-\t **/\n-\tpublic void checkMemberAccess(Class c, int memberType) {\n-\t\tthrow new SecurityException(\"Cannot access members of classes.\");\n-\t}\n+  /**\n+   * Check if the current thread is allowed to set the current socket factory.\n+   * This method is called by Socket.setSocketImplFactory(),\n+   * ServerSocket.setSocketFactory(), and URL.setURLStreamHandlerFactory().\n+   * The default implementation checks\n+   * <code>RuntimePermission(\"setFactory\")</code>. If you override this, call\n+   * <code>super.checkSetFactory</code> rather than throwing an exception.\n+   *\n+   * @throws SecurityException if permission is denied\n+   * @see Socket#setSocketImplFactory(SocketImplFactory)\n+   * @see ServerSocket#setSocketFactory(SocketImplFactory)\n+   * @see URL#setURLStreamHandlerFactory(URLStreamHandlerFactory)\n+   */\n+  public void checkSetFactory()\n+  {\n+    checkPermission(new RuntimePermission(\"setFactory\"));\n+  }\n \n-\t/** Test whether a particular security action may be\n-\t ** taken.\n-\t ** @param action the desired action to take\n-\t ** @exception SecurityException if the action is denied.\n-\t ** @XXX I have no idea what actions must be tested\n-\t **      or where.\n-\t **/\n-\tpublic void checkSecurityAccess(String action) {\n-\t\tcheckPermission (new java.security.SecurityPermission (action));\n-\t}\n+  /**\n+   * Check if the current thread is allowed to get certain types of Methods,\n+   * Fields and Constructors from a Class object. This method is called by\n+   * Class.getMethod[s](), Class.getField[s](), Class.getConstructor[s],\n+   * Class.getDeclaredMethod[s](), Class.getDeclaredField[s](), and\n+   * Class.getDeclaredConstructor[s](). The default implementation allows\n+   * PUBLIC access, and access to classes defined by the same classloader as\n+   * the code performing the reflection. Otherwise, it checks\n+   * <code>RuntimePermission(\"accessDeclaredMembers\")</code>. If you override\n+   * this, do not call <code>super.checkMemberAccess</code>, as this would\n+   * mess up the stack depth check that determines the ClassLoader requesting\n+   * the access.\n+   *\n+   * @param c the Class to check\n+   * @param memberType either DECLARED or PUBLIC\n+   * @throws SecurityException if permission is denied, including when\n+   *         memberType is not DECLARED or PUBLIC\n+   * @throws NullPointerException if c is null\n+   * @see Class\n+   * @see Member#DECLARED\n+   * @see Member#PUBLIC\n+   * @since 1.1\n+   */\n+  public void checkMemberAccess(Class c, int memberType)\n+  {\n+    if (c == null)\n+      throw new NullPointerException();\n+    if (memberType == Member.PUBLIC)\n+      return;\n+    // XXX Allow access to classes created by same classloader before next\n+    // check.\n+    checkPermission(new RuntimePermission(\"accessDeclaredMembers\"));\n+  }\n \n-\t/** Get the ThreadGroup that a new Thread should belong\n-\t ** to by default.<P>\n-\t **\n-\t ** Called by Thread.Thread().<P>\n-\t **\n-\t ** SecurityManager's implementation just uses the\n-\t ** ThreadGroup of the current Thread.<P>\n-\t **\n-\t ** <STRONG>Spec Note:</STRONG> it is not clear whether\n-\t ** the new Thread is guaranteed to pass the\n-\t ** checkAccessThreadGroup() test when using this\n-\t ** ThreadGroup.  I presume so.\n-\t **\n-\t ** @return the ThreadGroup to put the new Thread into.\n-\t **/\n-\tpublic ThreadGroup getThreadGroup() {\n-\t\treturn Thread.currentThread().getThreadGroup();\n-\t}\n+  /**\n+   * Test whether a particular security action may be taken. The default\n+   * implementation checks <code>SecurityPermission(action)</code>. If you\n+   * override this, call <code>super.checkSecurityAccess</code> rather than\n+   * throwing an exception.\n+   *\n+   * @param action the desired action to take\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if action is null\n+   * @throws IllegalArgumentException if action is \"\"\n+   * @since 1.1\n+   */\n+  public void checkSecurityAccess(String action)\n+  {\n+    checkPermission(new SecurityPermission(action));\n+  }\n \n-\tpublic SecurityManager () {\n-\t\tif (System.getSecurityManager () != null)\n-\t\t\tthrow new SecurityException ();\n-\t}\n-}\n+  /**\n+   * Get the ThreadGroup that a new Thread should belong to by default. Called\n+   * by Thread.Thread(). The default implementation returns the current\n+   * ThreadGroup of the current Thread. <STRONG>Spec Note:</STRONG> it is not\n+   * clear whether the new Thread is guaranteed to pass the\n+   * checkAccessThreadGroup() test when using this ThreadGroup, but I presume\n+   * so.\n+   *\n+   * @return the ThreadGroup to put the new Thread into\n+   * @since 1.1\n+   */\n+  public ThreadGroup getThreadGroup()\n+  {\n+    return Thread.currentThread().getThreadGroup();\n+  }\n+\n+  /**\n+   * Helper that checks a comma-separated list of restricted packages, from\n+   * <code>Security.getProperty(\"package.definition\")</code>, for the given\n+   * package access permission. If packageName starts with or equals any\n+   * restricted package, it checks\n+   * <code>RuntimePermission(permission + packageName)</code>.\n+   *\n+   * @param packageName the package name to check access to\n+   * @param restriction the list of restrictions, after \"package.\"\n+   * @param permission the base permission, including the '.'\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if packageName is null\n+   * @see #checkPackageAccess(String)\n+   * @see #checkPackageDefinition(String)\n+   */\n+  void checkPackageList(String packageName, String restriction,\n+                        String permission)\n+  {\n+    // Use the toString() hack to do the null check.\n+    Permission p = new RuntimePermission(permission + packageName.toString());\n+    String list = Security.getProperty(\"package.\" + restriction);\n+    if (list == null)\n+      return;\n+    while (! \"\".equals(packageName))\n+      {\n+        for (int index = list.indexOf(packageName);\n+             index != -1; index = list.indexOf(packageName, index + 1))\n+          {\n+\t    int packageNameCount = packageName.length();\n+            if (index + packageNameCount == list.length()\n+                || list.charAt(index + packageNameCount) == ',')\n+              {\n+                checkPermission(p);\n+                return;\n+              }\n+          }\n+        int index = packageName.lastIndexOf('.');\n+        packageName = index < 0 ? \"\" : packageName.substring(0, index);\n+      }\n+  }\n+} // class SecurityManager\n \n+// XXX This class is unnecessary.\n class SecurityContext {\n \tClass[] classes;\n \tSecurityContext(Class[] classes) {"}]}