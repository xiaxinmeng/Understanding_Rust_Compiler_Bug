{"sha": "f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM3ZTkyOGNhNDgxY2U4MWFlYWU3OWFlOWZiOTUwNGYyZDEzYjNhMQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-08-22T07:13:25Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-08-22T07:13:25Z"}, "message": "re PR fortran/32095 (Accepts invalid character(len(a)),dimension(1) :: a)\n\n2008-08-22  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/32095\n\tPR fortran/34228\n\t* gfortran.h (in_prefix): New global.\n\t(gfc_check_symbol_typed), (gfc_check_expr_typed): New methods.\n\t* array.c (match_array_element_spec): Check that bounds-expressions\n\tdon't have symbols not-yet-typed in them.\n\t* decl.c (var_element): Check that variable used is already typed.\n\t(char_len_param_value): Check that expression does not contain\n\tnot-yet-typed symbols.\n\t(in_prefix): New global.\n\t(gfc_match_prefix): Record using `in_prefix' if we're at the moment\n\tparsing a prefix or not.\n\t* expr.c (gfc_expr_check_typed): New method.\n\t* parse.c (verify_st_order): New argument to disable error output.\n\t(check_function_result_typed): New helper method.\n\t(parse_spec): Check that the function-result declaration, if given in\n\ta prefix, contains no not-yet-typed symbols when the IMPLICIT rules are\n\tparsed.\n\t* symbol.c (gfc_check_symbol_typed): Check that a symbol already has\n\ta type associated to it, otherwise use the IMPLICIT rules or signal\n\tan error.\n\n2008-08-22  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/32095\n\tPR fortran/34228\n\t* gfortran.dg/used_before_typed_1.f90: New test.\n\t* gfortran.dg/used_before_typed_2.f90: New test.\n\t* gfortran.dg/used_before_typed_3.f90: New test.\n\t* gfortran.dg/array_constructor_26.f03: Add -std=gnu to not enable\n\tlegacy-behaviour for the new check.\n\t* gfortran.dg/array_constructor_27.f03: Ditto.\n\t* gfortran.dg/blockdata_4.f90: Ditto.\n\t* gfortran.dg/bound_2.f90: Reordered declarations to satisfy the check.\n\t* gfortran.dg/result_in_spec_1.f90: Ditto.\n\t* gfortran.dg/argument_checking_7.f90: Adapted expected error messages.\n\nFrom-SVN: r139425", "tree": {"sha": "7eadcf3647d5b38792adf1c288e5c984abfbad59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7eadcf3647d5b38792adf1c288e5c984abfbad59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6b7387327a09e13e7b7ae2fd5f0371b0f88189e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b7387327a09e13e7b7ae2fd5f0371b0f88189e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b7387327a09e13e7b7ae2fd5f0371b0f88189e9"}], "stats": {"total": 403, "additions": 380, "deletions": 23}, "files": [{"sha": "30329d030d20763fb50e60d95e82a86f3d6c264e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -1,3 +1,27 @@\n+2008-08-22  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/32095\n+\tPR fortran/34228\n+\t* gfortran.h (in_prefix): New global.\n+\t(gfc_check_symbol_typed), (gfc_check_expr_typed): New methods.\n+\t* array.c (match_array_element_spec): Check that bounds-expressions\n+\tdon't have symbols not-yet-typed in them.\n+\t* decl.c (var_element): Check that variable used is already typed.\n+\t(char_len_param_value): Check that expression does not contain\n+\tnot-yet-typed symbols.\n+\t(in_prefix): New global.\n+\t(gfc_match_prefix): Record using `in_prefix' if we're at the moment\n+\tparsing a prefix or not.\n+\t* expr.c (gfc_expr_check_typed): New method.\n+\t* parse.c (verify_st_order): New argument to disable error output.\n+\t(check_function_result_typed): New helper method.\n+\t(parse_spec): Check that the function-result declaration, if given in\n+\ta prefix, contains no not-yet-typed symbols when the IMPLICIT rules are\n+\tparsed.\n+\t* symbol.c (gfc_check_symbol_typed): Check that a symbol already has\n+\ta type associated to it, otherwise use the IMPLICIT rules or signal\n+\tan error.\n+\n 2008-08-21  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \t* f95-lang.c: Update all calls to pedwarn."}, {"sha": "d99ed9e30a065034ce6f45f54e6475f7df6818af", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -314,6 +314,8 @@ match_array_element_spec (gfc_array_spec *as)\n     gfc_error (\"Expected expression in array specification at %C\");\n   if (m != MATCH_YES)\n     return AS_UNKNOWN;\n+  if (gfc_expr_check_typed (*upper, gfc_current_ns, false) == FAILURE)\n+    return AS_UNKNOWN;\n \n   if (gfc_match_char (':') == MATCH_NO)\n     {\n@@ -332,6 +334,8 @@ match_array_element_spec (gfc_array_spec *as)\n     return AS_UNKNOWN;\n   if (m == MATCH_NO)\n     return AS_ASSUMED_SHAPE;\n+  if (gfc_expr_check_typed (*upper, gfc_current_ns, false) == FAILURE)\n+    return AS_UNKNOWN;\n \n   return AS_EXPLICIT;\n }"}, {"sha": "892c8f3e99b678d864887a7ac4f25cf1aaeeb1e9", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -247,6 +247,11 @@ var_element (gfc_data_variable *new_var)\n \n   sym = new_var->expr->symtree->n.sym;\n \n+  /* Symbol should already have an associated type.  */\n+  if (gfc_check_symbol_typed (sym, gfc_current_ns,\n+\t\t\t      false, gfc_current_locus) == FAILURE)\n+    return MATCH_ERROR;\n+\n   if (!sym->attr.function && gfc_current_ns->parent\n       && gfc_current_ns->parent == sym->ns)\n     {\n@@ -598,6 +603,11 @@ char_len_param_value (gfc_expr **expr)\n     }\n \n   m = gfc_match_expr (expr);\n+\n+  if (m == MATCH_YES\n+      && gfc_expr_check_typed (*expr, gfc_current_ns, false) == FAILURE)\n+    return MATCH_ERROR;\n+\n   if (m == MATCH_YES && (*expr)->expr_type == EXPR_FUNCTION)\n     {\n       if ((*expr)->value.function.actual\n@@ -3743,6 +3753,8 @@ gfc_match_data_decl (void)\n    can be matched.  Note that if nothing matches, MATCH_YES is\n    returned (the null string was matched).  */\n \n+bool in_prefix = false;\n+\n match\n gfc_match_prefix (gfc_typespec *ts)\n {\n@@ -3751,6 +3763,9 @@ gfc_match_prefix (gfc_typespec *ts)\n   gfc_clear_attr (&current_attr);\n   seen_type = 0;\n \n+  gcc_assert (!in_prefix);\n+  in_prefix = true;\n+\n loop:\n   if (!seen_type && ts != NULL\n       && gfc_match_type_spec (ts, 0) == MATCH_YES\n@@ -3764,29 +3779,36 @@ gfc_match_prefix (gfc_typespec *ts)\n   if (gfc_match (\"elemental% \") == MATCH_YES)\n     {\n       if (gfc_add_elemental (&current_attr, NULL) == FAILURE)\n-\treturn MATCH_ERROR;\n+\tgoto error;\n \n       goto loop;\n     }\n \n   if (gfc_match (\"pure% \") == MATCH_YES)\n     {\n       if (gfc_add_pure (&current_attr, NULL) == FAILURE)\n-\treturn MATCH_ERROR;\n+\tgoto error;\n \n       goto loop;\n     }\n \n   if (gfc_match (\"recursive% \") == MATCH_YES)\n     {\n       if (gfc_add_recursive (&current_attr, NULL) == FAILURE)\n-\treturn MATCH_ERROR;\n+\tgoto error;\n \n       goto loop;\n     }\n \n   /* At this point, the next item is not a prefix.  */\n+  gcc_assert (in_prefix);\n+  in_prefix = false;\n   return MATCH_YES;\n+\n+error:\n+  gcc_assert (in_prefix);\n+  in_prefix = false;\n+  return MATCH_ERROR;\n }\n \n "}, {"sha": "941b5c5581a4ea70e74e5db90ffd10ce94f5f04f", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -3266,3 +3266,78 @@ gfc_expr_set_symbols_referenced (gfc_expr *expr)\n {\n   gfc_traverse_expr (expr, NULL, expr_set_symbols_referenced, 0);\n }\n+\n+\n+/* Walk an expression tree and check each variable encountered for being typed.\n+   If strict is not set, a top-level variable is tolerated untyped in -std=gnu\n+   mode; this is for things in legacy-code like:\n+\n+     INTEGER :: arr(n), n\n+\n+   The namespace is needed for IMPLICIT typing.  */\n+\n+gfc_try\n+gfc_expr_check_typed (gfc_expr* e, gfc_namespace* ns, bool strict)\n+{\n+  gfc_try t;\n+  gfc_actual_arglist* act;\n+  gfc_constructor* c;\n+\n+  if (!e)\n+    return SUCCESS;\n+\n+  /* FIXME:  Check indices for EXPR_VARIABLE / EXPR_SUBSTRING, too, to catch\n+     things like len(arr(1:n)) as specification expression.  */\n+\n+  switch (e->expr_type)\n+    {\n+\n+    case EXPR_NULL:\n+    case EXPR_CONSTANT:\n+    case EXPR_SUBSTRING:\n+      break;\n+\n+    case EXPR_VARIABLE:\n+      gcc_assert (e->symtree);\n+      t = gfc_check_symbol_typed (e->symtree->n.sym, ns, strict, e->where);\n+      if (t == FAILURE)\n+\treturn t;\n+      break;\n+\n+    case EXPR_FUNCTION:\n+      for (act = e->value.function.actual; act; act = act->next)\n+\t{\n+\t  t = gfc_expr_check_typed (act->expr, ns, true);\n+\t  if (t == FAILURE)\n+\t    return t;\n+\t}\n+      break;\n+\n+    case EXPR_OP:\n+      t = gfc_expr_check_typed (e->value.op.op1, ns, true);\n+      if (t == FAILURE)\n+\treturn t;\n+\n+      t = gfc_expr_check_typed (e->value.op.op2, ns, true);\n+      if (t == FAILURE)\n+\treturn t;\n+\n+      break;\n+\n+    case EXPR_STRUCTURE:\n+    case EXPR_ARRAY:\n+      for (c = e->value.constructor; c; c = c->next)\n+\t{\n+\t  t = gfc_expr_check_typed (c->expr, ns, true);\n+\t  if (t == FAILURE)\n+\t    return t;\n+\t}\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+\n+    }\n+\n+  return SUCCESS;\n+}"}, {"sha": "a9a363362a21b2ca92d3cacc76f969bcff802fc1", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -2245,6 +2245,10 @@ void copy_formal_args (gfc_symbol *dest, gfc_symbol *src);\n \n void gfc_free_finalizer (gfc_finalizer *el); /* Needed in resolve.c, too  */\n \n+/* FIXME:  Do this with parser-state instead of global variable.  */\n+extern bool in_prefix;\n+gfc_try gfc_check_symbol_typed (gfc_symbol*, gfc_namespace*, bool, locus);\n+\n /* intrinsic.c */\n extern int gfc_init_expr;\n \n@@ -2336,6 +2340,8 @@ bool gfc_traverse_expr (gfc_expr *, gfc_symbol *,\n \t\t\tint);\n void gfc_expr_set_symbols_referenced (gfc_expr *);\n \n+gfc_try gfc_expr_check_typed (gfc_expr*, gfc_namespace*, bool);\n+\n /* st.c */\n extern gfc_code new_st;\n "}, {"sha": "815dbc616bc30f8aff4f587dcbd259ace9926f58", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 80, "deletions": 9, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -1576,7 +1576,7 @@ typedef struct\n st_state;\n \n static gfc_try\n-verify_st_order (st_state *p, gfc_statement st)\n+verify_st_order (st_state *p, gfc_statement st, bool silent)\n {\n \n   switch (st)\n@@ -1660,9 +1660,10 @@ verify_st_order (st_state *p, gfc_statement st)\n   return SUCCESS;\n \n order:\n-  gfc_error (\"%s statement at %C cannot follow %s statement at %L\",\n-\t     gfc_ascii_statement (st),\n-\t     gfc_ascii_statement (p->last_statement), &p->where);\n+  if (!silent)\n+    gfc_error (\"%s statement at %C cannot follow %s statement at %L\",\n+\t       gfc_ascii_statement (st),\n+\t       gfc_ascii_statement (p->last_statement), &p->where);\n \n   return FAILURE;\n }\n@@ -2169,26 +2170,97 @@ match_deferred_characteristics (gfc_typespec * ts)\n }\n \n \n+/* Check specification-expressions in the function result of the currently\n+   parsed block and ensure they are typed (give an IMPLICIT type if necessary).\n+   For return types specified in a FUNCTION prefix, the IMPLICIT rules of the\n+   scope are not yet parsed so this has to be delayed up to parse_spec.  */\n+\n+static void\n+check_function_result_typed (void)\n+{\n+  gfc_typespec* ts = &gfc_current_ns->proc_name->result->ts;\n+\n+  gcc_assert (gfc_current_state () == COMP_FUNCTION);\n+  gcc_assert (ts->type != BT_UNKNOWN);\n+\n+  /* Check type-parameters, at the moment only CHARACTER lengths possible.  */\n+  /* TODO:  Extend when KIND type parameters are implemented.  */\n+  if (ts->type == BT_CHARACTER && ts->cl && ts->cl->length)\n+    gfc_expr_check_typed (ts->cl->length, gfc_current_ns, true);\n+}\n+\n+\n /* Parse a set of specification statements.  Returns the statement\n    that doesn't fit.  */\n \n static gfc_statement\n parse_spec (gfc_statement st)\n {\n   st_state ss;\n+  bool function_result_typed = false;\n   bool bad_characteristic = false;\n   gfc_typespec *ts;\n \n-  verify_st_order (&ss, ST_NONE);\n+  verify_st_order (&ss, ST_NONE, false);\n   if (st == ST_NONE)\n     st = next_statement ();\n \n+  /* If we are not inside a function or don't have a result specified so far,\n+     do nothing special about it.  */\n+  if (gfc_current_state () != COMP_FUNCTION)\n+    function_result_typed = true;\n+  else\n+    {\n+      gfc_symbol* proc = gfc_current_ns->proc_name;\n+      gcc_assert (proc);\n+\n+      if (proc->result->ts.type == BT_UNKNOWN)\n+\tfunction_result_typed = true;\n+    }\n+\n loop:\n+  \n+  /* If we find a statement that can not be followed by an IMPLICIT statement\n+     (and thus we can expect to see none any further), type the function result\n+     if it has not yet been typed.  Be careful not to give the END statement\n+     to verify_st_order!  */\n+  if (!function_result_typed && st != ST_GET_FCN_CHARACTERISTICS)\n+    {\n+      bool verify_now = false;\n+\n+      if (st == ST_END_FUNCTION)\n+\tverify_now = true;\n+      else\n+\t{\n+\t  st_state dummyss;\n+\t  verify_st_order (&dummyss, ST_NONE, false);\n+\t  verify_st_order (&dummyss, st, false);\n+\n+\t  if (verify_st_order (&dummyss, ST_IMPLICIT, true) == FAILURE)\n+\t    verify_now = true;\n+\t}\n+\n+      if (verify_now)\n+\t{\n+\t  check_function_result_typed ();\n+\t  function_result_typed = true;\n+\t}\n+    }\n+\n   switch (st)\n     {\n     case ST_NONE:\n       unexpected_eof ();\n \n+    case ST_IMPLICIT_NONE:\n+    case ST_IMPLICIT:\n+      if (!function_result_typed)\n+\t{\n+\t  check_function_result_typed ();\n+\t  function_result_typed = true;\n+\t}\n+      goto declSt;\n+\n     case ST_FORMAT:\n     case ST_ENTRY:\n     case ST_DATA:\t/* Not allowed in interfaces */\n@@ -2199,14 +2271,13 @@ parse_spec (gfc_statement st)\n \n     case ST_USE:\n     case ST_IMPORT:\n-    case ST_IMPLICIT_NONE:\n-    case ST_IMPLICIT:\n     case ST_PARAMETER:\n     case ST_PUBLIC:\n     case ST_PRIVATE:\n     case ST_DERIVED_DECL:\n     case_decl:\n-      if (verify_st_order (&ss, st) == FAILURE)\n+declSt:\n+      if (verify_st_order (&ss, st, false) == FAILURE)\n \t{\n \t  reject_statement ();\n \t  st = next_statement ();\n@@ -2295,7 +2366,7 @@ parse_spec (gfc_statement st)\n       gfc_current_block ()->ts.kind = 0;\n       /* Keep the derived type; if it's bad, it will be discovered later.  */\n       if (!(ts->type == BT_DERIVED && ts->derived))\n-        ts->type = BT_UNKNOWN;\n+\tts->type = BT_UNKNOWN;\n     }\n \n   return st;"}, {"sha": "195982271151523dc204c4366300f773d6e71737", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -4230,3 +4230,36 @@ get_iso_c_sym (gfc_symbol *old_sym, char *new_name,\n   return new_symtree->n.sym;\n }\n \n+\n+/* Check that a symbol is already typed.  If strict is not set, an untyped\n+   symbol is acceptable for non-standard-conforming mode.  */\n+\n+gfc_try\n+gfc_check_symbol_typed (gfc_symbol* sym, gfc_namespace* ns,\n+\t\t\tbool strict, locus where)\n+{\n+  gcc_assert (sym);\n+\n+  if (in_prefix)\n+    return SUCCESS;\n+\n+  /* Check for the type and try to give it an implicit one.  */\n+  if (sym->ts.type == BT_UNKNOWN\n+      && gfc_set_default_type (sym, 0, ns) == FAILURE)\n+    {\n+      if (strict)\n+\t{\n+\t  gfc_error (\"Symbol '%s' is used before it is typed at %L\",\n+\t\t     sym->name, &where);\n+\t  return FAILURE;\n+\t}\n+\n+      if (gfc_notify_std (GFC_STD_GNU,\n+\t\t\t  \"Extension: Symbol '%s' is used before\"\n+\t\t\t  \" it is typed at %L\", sym->name, &where) == FAILURE)\n+\treturn FAILURE;\n+    }\n+\n+  /* Everything is ok.  */\n+  return SUCCESS;\n+}"}, {"sha": "928a34b1d50ee042220b555c1b562d78f9894298", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -1,3 +1,18 @@\n+2008-08-22  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/32095\n+\tPR fortran/34228\n+\t* gfortran.dg/used_before_typed_1.f90: New test.\n+\t* gfortran.dg/used_before_typed_2.f90: New test.\n+\t* gfortran.dg/used_before_typed_3.f90: New test.\n+\t* gfortran.dg/array_constructor_26.f03: Add -std=gnu to not enable\n+\tlegacy-behaviour for the new check.\n+\t* gfortran.dg/array_constructor_27.f03: Ditto.\n+\t* gfortran.dg/blockdata_4.f90: Ditto.\n+\t* gfortran.dg/bound_2.f90: Reordered declarations to satisfy the check.\n+\t* gfortran.dg/result_in_spec_1.f90: Ditto.\n+\t* gfortran.dg/argument_checking_7.f90: Adapted expected error messages.\n+\n 2008-08-21  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR 30457"}, {"sha": "0bf76cbb4516e4497fa566eba3e209b42032684d", "filename": "gcc/testsuite/gfortran.dg/argument_checking_7.f90", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_7.f90?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -5,14 +5,14 @@ module cyclic\n   implicit none\n   contains\n     function ouch(x,y) ! { dg-error \"has no IMPLICIT type\" }\n-      implicit character(len(ouch)) (x) ! { dg-error \"Conflict in attributes\" }\n-      implicit character(len(x)+1) (y)\n-      implicit character(len(y)-1) (o)\n+      implicit character(len(ouch)) (x) ! { dg-error \"used before it is typed\" }\n+      implicit character(len(x)+1) (y) ! { dg-error \"used before it is typed\" }\n+      implicit character(len(y)-1) (o) ! { dg-error \"used before it is typed\" }\n       intent(in) x,y\n-      character(len(y)-1) ouch\n+      character(len(y)-1) ouch ! { dg-error \"used before it is typed\" }\n       integer i\n       do i = 1, len(ouch)\n-        ouch(i:i) = achar(ieor(iachar(x(i:i)),iachar(y(i:i)))) ! { dg-error \"Syntax error in argument list\" }\n+        ouch(i:i) = achar(ieor(iachar(x(i:i)),iachar(y(i:i)))) ! { dg-error \"Unclassifiable statement\" }\n       end do\n       end function ouch\n end module cyclic"}, {"sha": "622bb515e03f83b3aa4995966f3842605d1c61fe", "filename": "gcc/testsuite/gfortran.dg/array_constructor_26.f03", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_26.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_26.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_26.f03?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do compile }\n+! { dg-options \"-std=gnu\" }\n \n ! PR fortran/36492\n ! Check for incorrect error message with -std=f2003.\n@@ -10,8 +11,8 @@ MODULE WinData\n   integer :: i\n   TYPE TWindowData\n     CHARACTER (MAX_FLD_HED, 1) :: DWFdHd(MAXFLD) = [(\" \", i = 1, MAXFLD)]\n-    ! { dg-error \"no IMPLICIT type\" \"\" { target *-*-* } 12 }\n-    ! { dg-error \"specification expression\" \"\" { target *-*-* } 12 }\n+    ! { dg-error \"no IMPLICIT type\" \"\" { target *-*-* } 13 }\n+    ! { dg-error \"specification expression\" \"\" { target *-*-* } 13 }\n   END TYPE TWindowData\n END MODULE WinData\n "}, {"sha": "8068364ce4a0f792fda8ca1e9cd7ad60a4f3054e", "filename": "gcc/testsuite/gfortran.dg/array_constructor_27.f03", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_27.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_27.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_27.f03?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do compile }\n+! { dg-options \"-std=gnu\" }\n \n ! PR fortran/36492\n ! Check for incorrect error message with -std=f2003.\n@@ -8,8 +9,8 @@\n \n type t\n   character (a) :: arr (1) = [ \"a\" ]\n-  ! { dg-error \"no IMPLICIT type\" \"\" { target *-*-* } 10 }\n-  ! { dg-error \"specification expression\" \"\" { target *-*-* } 10 }\n+  ! { dg-error \"no IMPLICIT type\" \"\" { target *-*-* } 11 }\n+  ! { dg-error \"specification expression\" \"\" { target *-*-* } 11 }\n end type t\n \n end"}, {"sha": "5cf3d1f42fba05a1f1435da4c22e49b31e2b85aa", "filename": "gcc/testsuite/gfortran.dg/blockdata_4.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fblockdata_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fblockdata_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblockdata_4.f90?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do compile }\n+! { dg-options \"-std=gnu\" }\n ! PR33152 Initialization/declaration problems in block data\n ! Test case prepared by Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n blockdata bab"}, {"sha": "3b99a1f5471df5f9f15e28dd68ba5c8606edaba3", "filename": "gcc/testsuite/gfortran.dg/bound_2.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_2.f90?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do run }\n+! { dg-options \"-std=gnu\" }\n ! PR fortran/29391\n ! This file is here to check that LBOUND and UBOUND return correct values\n !\n@@ -165,7 +166,7 @@\n contains\n \n   subroutine sub1(a,n)\n-    integer :: a(2:n+1,4:*), n\n+    integer :: n, a(2:n+1,4:*)\n \n     if (any([lbound(a,1), lbound(a,2)] /= [2, 4])) call abort\n     if (any(lbound(a) /= [2, 4])) call abort"}, {"sha": "cbeb60f2d82efa100cbd238935814aab77c34c9c", "filename": "gcc/testsuite/gfortran.dg/result_in_spec_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fresult_in_spec_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fresult_in_spec_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fresult_in_spec_1.f90?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -35,8 +35,8 @@ program test\n   if (any (myfunc (test2(1)) .ne. \"ABC\")) call abort ()\n contains\n   function myfunc (ch) result (chr)\n-    character(len(ch)) :: chr(4)\n     character (*) :: ch(:)\n+    character(len(ch)) :: chr(4)\n     if (len (ch) .ne. 3) call abort ()\n     if (any (ch .ne. \"ABC\")) call abort ()\n     chr = test2 (1)"}, {"sha": "972a16742989193970ad2c2e7f17d9ea852ee09b", "filename": "gcc/testsuite/gfortran.dg/used_before_typed_1.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_1.f90?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+\n+! PR fortran/32095\n+! PR fortran/34228\n+! Check that standards-conforming mode rejects uses of variables that\n+! are used before they are typed.\n+\n+SUBROUTINE test1 (n, arr, m, arr2, k, arr3, a) ! { dg-error \"has no IMPLICIT\" }\n+  IMPLICIT NONE\n+\n+  INTEGER :: arr(n) ! { dg-error \"used before it is typed\" }\n+  INTEGER :: n\n+  INTEGER :: m, arr2(m) ! { dg-bogus \"used before it is typed\" }\n+  INTEGER, DIMENSION(k) :: arr3 ! { dg-error \"used before it is typed\" }\n+  INTEGER :: k\n+  CHARACTER(len=LEN(a)) :: a ! { dg-error \"'a' is used before it is typed\" }\n+\n+  REAL(KIND=l) :: x ! { dg-error \"has no IMPLICIT type\" }\n+  REAL(KIND=KIND(y)) :: y ! { dg-error \"has no IMPLICIT type\" }\n+\n+  DATA str/'abc'/ ! { dg-error \"used before it is typed\" }\n+  CHARACTER(len=3) :: str, str2\n+  DATA str2/'abc'/ ! { dg-bogus \"used before it is typed\" }\n+END SUBROUTINE test1\n+\n+SUBROUTINE test2 (n, arr, m, arr2)\n+  IMPLICIT INTEGER(a-z)\n+\n+  INTEGER :: arr(n)\n+  REAL :: n ! { dg-error \"already has basic type\" }\n+  INTEGER :: m, arr2(m) ! { dg-bogus \"already has an IMPLICIT type\" }\n+END SUBROUTINE test2\n+\n+SUBROUTINE test3 (n, arr, m, arr2)\n+  IMPLICIT REAL(a-z)\n+\n+  INTEGER :: arr(n) ! { dg-error \"must be of INTEGER type\" }\n+  INTEGER :: m, arr2(m) ! { dg-bogus \"must be of INTEGER type\" }\n+END SUBROUTINE test3"}, {"sha": "6f3031fcd7dee53bc8ed0dad0c50d0c4ed4a728f", "filename": "gcc/testsuite/gfortran.dg/used_before_typed_2.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_2.f90?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do compile }\n+! { dg-options \"-std=gnu\" }\n+\n+! PR fortran/32095\n+! PR fortran/34228\n+! This program used to segfault, check this is fixed.\n+! Also check that -std=gnu behaves as expected.\n+\n+SUBROUTINE test1 (n, arr)\n+  IMPLICIT NONE\n+\n+  INTEGER :: arr(n) ! { dg-bogus \"used before it is typed\" }\n+  INTEGER :: n\n+  CHARACTER(len=LEN(a)) :: a ! { dg-error \"used before it is typed\" }\n+END SUBROUTINE test1\n+\n+SUBROUTINE test2 ()\n+  IMPLICIT NONE\n+\n+  DATA str/'abc'/ ! { dg-bogus \"used before it is typed\" }\n+  CHARACTER(len=3) :: str\n+END SUBROUTINE test2"}, {"sha": "ab1b2a91f0ae05a751458d6c4c5265c07410c4b9", "filename": "gcc/testsuite/gfortran.dg/used_before_typed_3.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e928ca481ce81aeae79ae9fb9504f2d13b3a1/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_3.f90?ref=f37e928ca481ce81aeae79ae9fb9504f2d13b3a1", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+\n+! PR fortran/32095\n+! PR fortran/34228\n+! Check for a special case when the return-type of a function is given outside\n+! its \"body\" and contains symbols defined inside.\n+\n+MODULE testmod\n+  IMPLICIT REAL(a-z)\n+\n+CONTAINS\n+\n+  CHARACTER(len=x) FUNCTION test1 (x) ! { dg-error \"of INTEGER\" }\n+    IMPLICIT REAL(a-z)\n+    INTEGER :: x ! { dg-error \"already has basic type\" }\n+    test1 = \"foobar\"\n+  END FUNCTION test1\n+\n+  CHARACTER(len=x) FUNCTION test2 (x) ! { dg-bogus \"used before|of INTEGER\" }\n+    IMPLICIT INTEGER(a-z)\n+    test2 = \"foobar\"\n+  END FUNCTION test2\n+\n+END MODULE testmod\n+  \n+CHARACTER(len=i) FUNCTION test3 (i) ! { dg-bogus \"used before|of INTEGER\" }\n+  ! i is IMPLICIT INTEGER by default\n+  test3 = \"foobar\"\n+END FUNCTION test3\n+\n+CHARACTER(len=g) FUNCTION test4 (g) ! { dg-error \"of INTEGER\" }\n+  ! g is REAL, unless declared INTEGER.\n+  test4 = \"foobar\"\n+END FUNCTION test4\n+\n+! Test an empty function works, too.\n+INTEGER FUNCTION test5 ()\n+END FUNCTION test5\n+\n+! { dg-final { cleanup-modules \"testmod\" } }"}]}