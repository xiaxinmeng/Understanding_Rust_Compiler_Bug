{"sha": "df838ef0f1a11355a217ab11ed8546dd97873870", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY4MzhlZjBmMWExMTM1NWEyMTdhYjExZWQ4NTQ2ZGQ5Nzg3Mzg3MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-11-07T10:10:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-11-07T10:10:44Z"}, "message": "Move const char * -> int/fp folds to fold-const-call.c\n\nThis patch moves folds that deal with constant string arguments and\nreturn a constant integer or floating-point value.  For example, it\nhandles strcmp (\"foo\", \"bar\") but not strstr (\"foobar\", \"bar\"),\nwhich wouldn't currently be accepted by the gimple folders.\n\nThe builtins.c folding for strlen (via c_strlen) is a bit more general\nthan what the fold-const-call.c code does (and more general than we need\nfor the gimple folders).  I've therefore left it as-is, even though it\npartially duplicates the new code.\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu and arm-linux-gnueabi.\n\ngcc/\n\t* builtins.c (fold_builtin_nan): Delete.\n\t(fold_builtin_memcmp): Remove case where both arguments are constant.\n\t(fold_builtin_strcmp, fold_builtin_strncmp): Likewise.\n\t(fold_builtin_strspn, fold_builtin_strcspn): Likewise.\n\t(fold_builtin_1): Remove BUILT_IN_NAN* handling.\n\t* fold-const-call.c: Include fold-const.h.\n\t(host_size_t_cst_p): New function.\n\t(build_cmp_result, fold_const_builtin_nan): Likewise.\n\t(fold_const_call_1): New function, split out from...\n\t(fold_const_call): ...here (for all three interfaces).  Handle\n\tconstant nan, nans, strlen, strcmp, strncmp, strspn and strcspn.\n\nFrom-SVN: r229922", "tree": {"sha": "0a6fba6186ee90f2710a360da3bcb509e1e7f047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a6fba6186ee90f2710a360da3bcb509e1e7f047"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df838ef0f1a11355a217ab11ed8546dd97873870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df838ef0f1a11355a217ab11ed8546dd97873870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df838ef0f1a11355a217ab11ed8546dd97873870", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df838ef0f1a11355a217ab11ed8546dd97873870/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "db9bd5d5752356a71b1ce6986f30c164c39cf51d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db9bd5d5752356a71b1ce6986f30c164c39cf51d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db9bd5d5752356a71b1ce6986f30c164c39cf51d"}], "stats": {"total": 274, "additions": 162, "deletions": 112}, "files": [{"sha": "443066d97c6fbb1070e6ba8547a72c407f595010", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df838ef0f1a11355a217ab11ed8546dd97873870/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df838ef0f1a11355a217ab11ed8546dd97873870/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df838ef0f1a11355a217ab11ed8546dd97873870", "patch": "@@ -1,3 +1,17 @@\n+2015-11-07  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* builtins.c (fold_builtin_nan): Delete.\n+\t(fold_builtin_memcmp): Remove case where both arguments are constant.\n+\t(fold_builtin_strcmp, fold_builtin_strncmp): Likewise.\n+\t(fold_builtin_strspn, fold_builtin_strcspn): Likewise.\n+\t(fold_builtin_1): Remove BUILT_IN_NAN* handling.\n+\t* fold-const-call.c: Include fold-const.h.\n+\t(host_size_t_cst_p): New function.\n+\t(build_cmp_result, fold_const_builtin_nan): Likewise.\n+\t(fold_const_call_1): New function, split out from...\n+\t(fold_const_call): ...here (for all three interfaces).  Handle\n+\tconstant nan, nans, strlen, strcmp, strncmp, strspn and strcspn.\n+\n 2015-11-07  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* builtins.c (fold_builtin_bitop, fold_builtin_bswap): Delete."}, {"sha": "add9fc8484f778b24c4ffcef60cf6fe2f32b893a", "filename": "gcc/builtins.c", "status": "modified", "additions": 6, "deletions": 99, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df838ef0f1a11355a217ab11ed8546dd97873870/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df838ef0f1a11355a217ab11ed8546dd97873870/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=df838ef0f1a11355a217ab11ed8546dd97873870", "patch": "@@ -143,7 +143,6 @@ static tree fold_builtin_constant_p (tree);\n static tree fold_builtin_classify_type (tree);\n static tree fold_builtin_strlen (location_t, tree, tree);\n static tree fold_builtin_inf (location_t, tree, int);\n-static tree fold_builtin_nan (tree, tree, int);\n static tree rewrite_call_expr (location_t, tree, int, tree, int, ...);\n static bool validate_arg (const_tree, enum tree_code code);\n static rtx expand_builtin_fabs (tree, rtx, rtx);\n@@ -7264,26 +7263,6 @@ fold_builtin_inf (location_t loc, tree type, int warn)\n   return build_real (type, real);\n }\n \n-/* Fold a call to __builtin_nan or __builtin_nans with argument ARG.  */\n-\n-static tree\n-fold_builtin_nan (tree arg, tree type, int quiet)\n-{\n-  REAL_VALUE_TYPE real;\n-  const char *str;\n-\n-  if (!validate_arg (arg, POINTER_TYPE))\n-    return NULL_TREE;\n-  str = c_getstr (arg);\n-  if (!str)\n-    return NULL_TREE;\n-\n-  if (!real_nan (&real, str, quiet, TYPE_MODE (type)))\n-    return NULL_TREE;\n-\n-  return build_real (type, real);\n-}\n-\n /* Fold function call to builtin sincos, sincosf, or sincosl.  Return\n    NULL_TREE if no simplification can be made.  */\n \n@@ -7378,8 +7357,6 @@ fold_builtin_memchr (location_t loc, tree arg1, tree arg2, tree len, tree type)\n static tree\n fold_builtin_memcmp (location_t loc, tree arg1, tree arg2, tree len)\n {\n-  const char *p1, *p2;\n-\n   if (!validate_arg (arg1, POINTER_TYPE)\n       || !validate_arg (arg2, POINTER_TYPE)\n       || !validate_arg (len, INTEGER_TYPE))\n@@ -7394,25 +7371,6 @@ fold_builtin_memcmp (location_t loc, tree arg1, tree arg2, tree len)\n   if (operand_equal_p (arg1, arg2, 0))\n     return omit_one_operand_loc (loc, integer_type_node, integer_zero_node, len);\n \n-  p1 = c_getstr (arg1);\n-  p2 = c_getstr (arg2);\n-\n-  /* If all arguments are constant, and the value of len is not greater\n-     than the lengths of arg1 and arg2, evaluate at compile-time.  */\n-  if (tree_fits_uhwi_p (len) && p1 && p2\n-      && compare_tree_int (len, strlen (p1) + 1) <= 0\n-      && compare_tree_int (len, strlen (p2) + 1) <= 0)\n-    {\n-      const int r = memcmp (p1, p2, tree_to_uhwi (len));\n-\n-      if (r > 0)\n-\treturn integer_one_node;\n-      else if (r < 0)\n-\treturn integer_minus_one_node;\n-      else\n-\treturn integer_zero_node;\n-    }\n-\n   /* If len parameter is one, return an expression corresponding to\n      (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n   if (tree_fits_uhwi_p (len) && tree_to_uhwi (len) == 1)\n@@ -7445,8 +7403,6 @@ fold_builtin_memcmp (location_t loc, tree arg1, tree arg2, tree len)\n static tree\n fold_builtin_strcmp (location_t loc, tree arg1, tree arg2)\n {\n-  const char *p1, *p2;\n-\n   if (!validate_arg (arg1, POINTER_TYPE)\n       || !validate_arg (arg2, POINTER_TYPE))\n     return NULL_TREE;\n@@ -7455,21 +7411,8 @@ fold_builtin_strcmp (location_t loc, tree arg1, tree arg2)\n   if (operand_equal_p (arg1, arg2, 0))\n     return integer_zero_node;\n \n-  p1 = c_getstr (arg1);\n-  p2 = c_getstr (arg2);\n-\n-  if (p1 && p2)\n-    {\n-      const int i = strcmp (p1, p2);\n-      if (i < 0)\n-\treturn integer_minus_one_node;\n-      else if (i > 0)\n-\treturn integer_one_node;\n-      else\n-\treturn integer_zero_node;\n-    }\n-\n   /* If the second arg is \"\", return *(const unsigned char*)arg1.  */\n+  const char *p2 = c_getstr (arg2);\n   if (p2 && *p2 == '\\0')\n     {\n       tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n@@ -7484,6 +7427,7 @@ fold_builtin_strcmp (location_t loc, tree arg1, tree arg2)\n     }\n \n   /* If the first arg is \"\", return -*(const unsigned char*)arg2.  */\n+  const char *p1 = c_getstr (arg1);\n   if (p1 && *p1 == '\\0')\n     {\n       tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n@@ -7508,8 +7452,6 @@ fold_builtin_strcmp (location_t loc, tree arg1, tree arg2)\n static tree\n fold_builtin_strncmp (location_t loc, tree arg1, tree arg2, tree len)\n {\n-  const char *p1, *p2;\n-\n   if (!validate_arg (arg1, POINTER_TYPE)\n       || !validate_arg (arg2, POINTER_TYPE)\n       || !validate_arg (len, INTEGER_TYPE))\n@@ -7524,22 +7466,9 @@ fold_builtin_strncmp (location_t loc, tree arg1, tree arg2, tree len)\n   if (operand_equal_p (arg1, arg2, 0))\n     return omit_one_operand_loc (loc, integer_type_node, integer_zero_node, len);\n \n-  p1 = c_getstr (arg1);\n-  p2 = c_getstr (arg2);\n-\n-  if (tree_fits_uhwi_p (len) && p1 && p2)\n-    {\n-      const int i = strncmp (p1, p2, tree_to_uhwi (len));\n-      if (i > 0)\n-\treturn integer_one_node;\n-      else if (i < 0)\n-\treturn integer_minus_one_node;\n-      else\n-\treturn integer_zero_node;\n-    }\n-\n   /* If the second arg is \"\", and the length is greater than zero,\n      return *(const unsigned char*)arg1.  */\n+  const char *p2 = c_getstr (arg2);\n   if (p2 && *p2 == '\\0'\n       && TREE_CODE (len) == INTEGER_CST\n       && tree_int_cst_sgn (len) == 1)\n@@ -7557,6 +7486,7 @@ fold_builtin_strncmp (location_t loc, tree arg1, tree arg2, tree len)\n \n   /* If the first arg is \"\", and the length is greater than zero,\n      return -*(const unsigned char*)arg2.  */\n+  const char *p1 = c_getstr (arg1);\n   if (p1 && *p1 == '\\0'\n       && TREE_CODE (len) == INTEGER_CST\n       && tree_int_cst_sgn (len) == 1)\n@@ -8261,15 +8191,6 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n     CASE_FLT_FN (BUILT_IN_CARG):\n       return fold_builtin_carg (loc, arg0, type);\n \n-    CASE_FLT_FN (BUILT_IN_NAN):\n-    case BUILT_IN_NAND32:\n-    case BUILT_IN_NAND64:\n-    case BUILT_IN_NAND128:\n-      return fold_builtin_nan (arg0, type, true);\n-\n-    CASE_FLT_FN (BUILT_IN_NANS):\n-      return fold_builtin_nan (arg0, type, false);\n-\n     case BUILT_IN_ISASCII:\n       return fold_builtin_isascii (loc, arg0);\n \n@@ -9075,13 +8996,6 @@ fold_builtin_strspn (location_t loc, tree s1, tree s2)\n     {\n       const char *p1 = c_getstr (s1), *p2 = c_getstr (s2);\n \n-      /* If both arguments are constants, evaluate at compile-time.  */\n-      if (p1 && p2)\n-\t{\n-\t  const size_t r = strspn (p1, p2);\n-\t  return build_int_cst (size_type_node, r);\n-\t}\n-\n       /* If either argument is \"\", return NULL_TREE.  */\n       if ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0'))\n \t/* Evaluate and ignore both arguments in case either one has\n@@ -9118,16 +9032,8 @@ fold_builtin_strcspn (location_t loc, tree s1, tree s2)\n     return NULL_TREE;\n   else\n     {\n-      const char *p1 = c_getstr (s1), *p2 = c_getstr (s2);\n-\n-      /* If both arguments are constants, evaluate at compile-time.  */\n-      if (p1 && p2)\n-\t{\n-\t  const size_t r = strcspn (p1, p2);\n-\t  return build_int_cst (size_type_node, r);\n-\t}\n-\n       /* If the first argument is \"\", return NULL_TREE.  */\n+      const char *p1 = c_getstr (s1);\n       if (p1 && *p1 == '\\0')\n \t{\n \t  /* Evaluate and ignore argument s2 in case it has\n@@ -9137,6 +9043,7 @@ fold_builtin_strcspn (location_t loc, tree s1, tree s2)\n \t}\n \n       /* If the second argument is \"\", return __builtin_strlen(s1).  */\n+      const char *p2 = c_getstr (s2);\n       if (p2 && *p2 == '\\0')\n \t{\n \t  tree fn = builtin_decl_implicit (BUILT_IN_STRLEN);"}, {"sha": "49793a5ab6f3ff1a6a7d91d87d20ecd34cf561e5", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 142, "deletions": 13, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df838ef0f1a11355a217ab11ed8546dd97873870/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df838ef0f1a11355a217ab11ed8546dd97873870/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=df838ef0f1a11355a217ab11ed8546dd97873870", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"stor-layout.h\"\n #include \"options.h\"\n+#include \"fold-const.h\"\n #include \"fold-const-call.h\"\n #include \"tm.h\" /* For C[LT]Z_DEFINED_AT_ZERO.  */\n \n@@ -48,6 +49,31 @@ complex_cst_p (tree t)\n   return TREE_CODE (t) == COMPLEX_CST;\n }\n \n+/* Return true if ARG is a constant in the range of the host size_t.\n+   Store it in *SIZE_OUT if so.  */\n+\n+static inline bool\n+host_size_t_cst_p (tree t, size_t *size_out)\n+{\n+  if (integer_cst_p (t)\n+      && wi::min_precision (t, UNSIGNED) <= sizeof (size_t) * CHAR_BIT)\n+    {\n+      *size_out = tree_to_uhwi (t);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* RES is the result of a comparison in which < 0 means \"less\", 0 means\n+   \"equal\" and > 0 means \"more\".  Canonicalize it to -1, 0 or 1 and\n+   return it in type TYPE.  */\n+\n+static inline tree\n+build_cmp_result (tree type, int res)\n+{\n+  return build_int_cst (type, res < 0 ? -1 : res > 0 ? 1 : 0);\n+}\n+\n /* M is the result of trying to constant-fold an expression (starting\n    with clear MPFR flags) and INEXACT says whether the result in M is\n    exact or inexact.  Return true if M can be used as a constant-folded\n@@ -527,6 +553,20 @@ fold_const_builtin_load_exponent (real_value *result, const real_value *arg0,\n   return real_equal (&initial_result, result);\n }\n \n+/* Fold a call to __builtin_nan or __builtin_nans with argument ARG and\n+   return type TYPE.  QUIET is true if a quiet rather than signalling\n+   NaN is required.  */\n+\n+static tree\n+fold_const_builtin_nan (tree type, tree arg, bool quiet)\n+{\n+  REAL_VALUE_TYPE real;\n+  const char *str = c_getstr (arg);\n+  if (str && real_nan (&real, str, quiet, TYPE_MODE (type)))\n+    return build_real (type, real);\n+  return NULL_TREE;\n+}\n+\n /* Try to evaluate:\n \n       *RESULT = FN (*ARG)\n@@ -971,11 +1011,11 @@ fold_const_call_cc (real_value *result_real, real_value *result_imag,\n     }\n }\n \n-/* Try to fold FN (ARG) to a constant.  Return the constant on success,\n-   otherwise return null.  TYPE is the type of the return value.  */\n+/* Subroutine of fold_const_call, with the same interface.  Handle cases\n+   where the arguments and result are numerical.  */\n \n-tree\n-fold_const_call (built_in_function fn, tree type, tree arg)\n+static tree\n+fold_const_call_1 (built_in_function fn, tree type, tree arg)\n {\n   machine_mode mode = TYPE_MODE (type);\n   machine_mode arg_mode = TYPE_MODE (TREE_TYPE (arg));\n@@ -1066,6 +1106,33 @@ fold_const_call (built_in_function fn, tree type, tree arg)\n   return NULL_TREE;\n }\n \n+/* Try to fold FN (ARG) to a constant.  Return the constant on success,\n+   otherwise return null.  TYPE is the type of the return value.  */\n+\n+tree\n+fold_const_call (built_in_function fn, tree type, tree arg)\n+{\n+  switch (fn)\n+    {\n+    case BUILT_IN_STRLEN:\n+      if (const char *str = c_getstr (arg))\n+\treturn build_int_cst (type, strlen (str));\n+      return NULL_TREE;\n+\n+    CASE_FLT_FN (BUILT_IN_NAN):\n+    case BUILT_IN_NAND32:\n+    case BUILT_IN_NAND64:\n+    case BUILT_IN_NAND128:\n+      return fold_const_builtin_nan (type, arg, true);\n+\n+    CASE_FLT_FN (BUILT_IN_NANS):\n+      return fold_const_builtin_nan (type, arg, false);\n+\n+    default:\n+      return fold_const_call_1 (fn, type, arg);\n+    }\n+}\n+\n /* Try to evaluate:\n \n       *RESULT = FN (*ARG0, *ARG1)\n@@ -1194,11 +1261,11 @@ fold_const_call_ccc (real_value *result_real, real_value *result_imag,\n     }\n }\n \n-/* Try to fold FN (ARG0, ARG1) to a constant.  Return the constant on success,\n-   otherwise return null.  TYPE is the type of the return value.  */\n+/* Subroutine of fold_const_call, with the same interface.  Handle cases\n+   where the arguments and result are numerical.  */\n \n-tree\n-fold_const_call (built_in_function fn, tree type, tree arg0, tree arg1)\n+static tree\n+fold_const_call_1 (built_in_function fn, tree type, tree arg0, tree arg1)\n {\n   machine_mode mode = TYPE_MODE (type);\n   machine_mode arg0_mode = TYPE_MODE (TREE_TYPE (arg0));\n@@ -1286,6 +1353,35 @@ fold_const_call (built_in_function fn, tree type, tree arg0, tree arg1)\n   return NULL_TREE;\n }\n \n+/* Try to fold FN (ARG0, ARG1) to a constant.  Return the constant on success,\n+   otherwise return null.  TYPE is the type of the return value.  */\n+\n+tree\n+fold_const_call (built_in_function fn, tree type, tree arg0, tree arg1)\n+{\n+  const char *p0, *p1;\n+  switch (fn)\n+    {\n+    case BUILT_IN_STRSPN:\n+      if ((p0 = c_getstr (arg0)) && (p1 = c_getstr (arg1)))\n+\treturn build_int_cst (type, strspn (p0, p1));\n+      return NULL_TREE;\n+\n+    case BUILT_IN_STRCSPN:\n+      if ((p0 = c_getstr (arg0)) && (p1 = c_getstr (arg1)))\n+\treturn build_int_cst (type, strcspn (p0, p1));\n+      return NULL_TREE;\n+\n+    case BUILT_IN_STRCMP:\n+      if ((p0 = c_getstr (arg0)) && (p1 = c_getstr (arg1)))\n+\treturn build_cmp_result (type, strcmp (p0, p1));\n+      return NULL_TREE;\n+\n+    default:\n+      return fold_const_call_1 (fn, type, arg0, arg1);\n+    }\n+}\n+\n /* Try to evaluate:\n \n       *RESULT = FN (*ARG0, *ARG1, *ARG2)\n@@ -1307,12 +1403,12 @@ fold_const_call_ssss (real_value *result, built_in_function fn,\n     }\n }\n \n-/* Try to fold FN (ARG0, ARG1, ARG2) to a constant.  Return the constant on\n-   success, otherwise return null.  TYPE is the type of the return value.  */\n+/* Subroutine of fold_const_call, with the same interface.  Handle cases\n+   where the arguments and result are numerical.  */\n \n-tree\n-fold_const_call (built_in_function fn, tree type, tree arg0, tree arg1,\n-\t\t tree arg2)\n+static tree\n+fold_const_call_1 (built_in_function fn, tree type, tree arg0, tree arg1,\n+\t\t   tree arg2)\n {\n   machine_mode mode = TYPE_MODE (type);\n   machine_mode arg0_mode = TYPE_MODE (TREE_TYPE (arg0));\n@@ -1342,6 +1438,39 @@ fold_const_call (built_in_function fn, tree type, tree arg0, tree arg1,\n   return NULL_TREE;\n }\n \n+/* Try to fold FN (ARG0, ARG1, ARG2) to a constant.  Return the constant on\n+   success, otherwise return null.  TYPE is the type of the return value.  */\n+\n+tree\n+fold_const_call (built_in_function fn, tree type, tree arg0, tree arg1,\n+\t\t tree arg2)\n+{\n+  const char *p0, *p1;\n+  size_t s2;\n+  switch (fn)\n+    {\n+    case BUILT_IN_STRNCMP:\n+      if ((p0 = c_getstr (arg0))\n+\t  && (p1 = c_getstr (arg1))\n+\t  && host_size_t_cst_p (arg2, &s2))\n+\treturn build_int_cst (type, strncmp (p0, p1, s2));\n+      return NULL_TREE;\n+\n+    case BUILT_IN_BCMP:\n+    case BUILT_IN_MEMCMP:\n+      if ((p0 = c_getstr (arg0))\n+\t  && (p1 = c_getstr (arg1))\n+\t  && host_size_t_cst_p (arg2, &s2)\n+\t  && s2 <= strlen (p0)\n+\t  && s2 <= strlen (p1))\n+\treturn build_cmp_result (type, memcmp (p0, p1, s2));\n+      return NULL_TREE;\n+\n+    default:\n+      return fold_const_call_1 (fn, type, arg0, arg1, arg2);\n+    }\n+}\n+\n /* Fold a fma operation with arguments ARG[012].  */\n \n tree"}]}