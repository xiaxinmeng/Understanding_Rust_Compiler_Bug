{"sha": "8d218b6742d2cd67c639ad6668431a56ccca0705", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyMThiNjc0MmQyY2Q2N2M2MzlhZDY2Njg0MzFhNTZjY2NhMDcwNQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-11-03T03:58:05Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-11-03T03:58:05Z"}, "message": "AbstractList.java (SubList): Make it a top-level private class.\n\n2000-11-03  Bryce McKinlay  <bryce@albatross.co.nz>\n\n\t* java/util/AbstractList.java (SubList): Make it a top-level private\n\tclass.\n\t* java/util/LinkedList.java (remove): Do update modCount and\n\tknownMod.\n\t(add): Ditto.\n\t* Makefile.am (ordinary_java_source_files): Add LinkedList.java.\n\t* Makefile.in: Rebuilt.\n\nFrom-SVN: r37218", "tree": {"sha": "513ddc423b9316dfe96f3d5e79a6ca4749279337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/513ddc423b9316dfe96f3d5e79a6ca4749279337"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d218b6742d2cd67c639ad6668431a56ccca0705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d218b6742d2cd67c639ad6668431a56ccca0705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d218b6742d2cd67c639ad6668431a56ccca0705", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d218b6742d2cd67c639ad6668431a56ccca0705/comments", "author": null, "committer": null, "parents": [{"sha": "19944601d69c0777c1aec481792c201a3b58b960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19944601d69c0777c1aec481792c201a3b58b960", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19944601d69c0777c1aec481792c201a3b58b960"}], "stats": {"total": 527, "additions": 268, "deletions": 259}, "files": [{"sha": "24e84fa5e75b3516baee60360d521a9a81ab3313", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d218b6742d2cd67c639ad6668431a56ccca0705/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d218b6742d2cd67c639ad6668431a56ccca0705/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8d218b6742d2cd67c639ad6668431a56ccca0705", "patch": "@@ -1,3 +1,12 @@\n+2000-11-03  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/util/AbstractList.java (SubList): Make it a top-level private\n+\tclass.\n+\t* java/util/LinkedList.java (remove): Do update modCount and knownMod.\n+\t(add): Ditto.\n+\t* Makefile.am (ordinary_java_source_files): Add LinkedList.java.\n+\t* Makefile.in: Rebuilt.\n+\n 2000-11-02  Tom Tromey  <tromey@cygnus.com>\n \n \t* Makefile.in: Rebuilt."}, {"sha": "649bd5cf86000cab647aff5b88398cf1a91b0e00", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d218b6742d2cd67c639ad6668431a56ccca0705/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d218b6742d2cd67c639ad6668431a56ccca0705/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=8d218b6742d2cd67c639ad6668431a56ccca0705", "patch": "@@ -935,6 +935,7 @@ java/util/GregorianCalendar.java \\\n java/util/HashMap.java \\\n java/util/Hashtable.java \\\n java/util/Iterator.java\t\\\n+java/util/LinkedList.java \\\n java/util/List.java \\\n java/util/ListIterator.java \\\n java/util/ListResourceBundle.java \\"}, {"sha": "34cd42f03a6f299f3fd315cfc8278452486d1ecb", "filename": "libjava/Makefile.in", "status": "modified", "additions": 25, "deletions": 40, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d218b6742d2cd67c639ad6668431a56ccca0705/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d218b6742d2cd67c639ad6668431a56ccca0705/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=8d218b6742d2cd67c639ad6668431a56ccca0705", "patch": "@@ -119,43 +119,29 @@ here = @here@\n libgcj_basedir = @libgcj_basedir@\n \n AUTOMAKE_OPTIONS = foreign no-installinfo\n-@TESTSUBDIR_TRUE@SUBDIRS = \\\n-@TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n-@TESTSUBDIR_FALSE@SUBDIRS = \\\n-@TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n-@USE_LIBDIR_TRUE@toolexeclibdir = \\\n-@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = \\\n-@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = \\\n-@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n-@NO_X_TRUE@cond_x_ltlibrary = \\\n-@NO_X_FALSE@cond_x_ltlibrary = \\\n-@NO_X_FALSE@libgcjx.la\n+@TESTSUBDIR_TRUE@SUBDIRS = @TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n+@TESTSUBDIR_FALSE@SUBDIRS = @TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n+@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@NO_X_TRUE@cond_x_ltlibrary = \n+@NO_X_FALSE@cond_x_ltlibrary = @NO_X_FALSE@libgcjx.la\n \n toolexeclib_LTLIBRARIES = libgcj.la $(cond_x_ltlibrary)\n toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.zip\n \n-@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.a\n-@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.c\n+@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = @NEEDS_DATA_START_TRUE@libgcjdata.a\n+@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = @NEEDS_DATA_START_TRUE@libgcjdata.c\n \n-@NATIVE_TRUE@bin_PROGRAMS = \\\n-@NATIVE_TRUE@jv-convert gij\n+@NATIVE_TRUE@bin_PROGRAMS = @NATIVE_TRUE@jv-convert gij\n \n bin_SCRIPTS = addr2name.awk\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@zip\n-@CANADIAN_FALSE@ZIP = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n-@CANADIAN_TRUE@GCJH = \\\n-@CANADIAN_TRUE@gcjh\n-@CANADIAN_FALSE@GCJH = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_FALSE@zip\n+@CANADIAN_FALSE@ZIP = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = @CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n \n GCJCOMPILE = $(LIBTOOL) --tag=GCJ --mode=compile $(GCJ) -fassume-compiled -fclasspath=$(here) -L$(here) $(JC1FLAGS) -MD -MT $@ -MF $(@:.lo=.d) -c\n GCJLINK = $(LIBTOOL) --mode=link $(GCJ) -L$(here) $(JC1FLAGS) $(LDFLAGS) -o $@\n@@ -170,10 +156,8 @@ AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fasynchronous-exceptions \\\n \t-fdollars-in-identifiers \\\n \t@LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE\n \n-@USING_GCC_TRUE@AM_CFLAGS = \\\n-@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n-@USING_GCC_FALSE@AM_CFLAGS = \\\n-@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+@USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n \n JCFLAGS = -g\n JC1FLAGS = -g @LIBGCJ_JAVAFLAGS@\n@@ -240,8 +224,7 @@ extra_headers = java/lang/Object.h java/lang/Class.h\n \n NM = nm\n \n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n \n CONVERT_DIR = gnu/gcj/convert\n \n@@ -704,6 +687,7 @@ java/util/GregorianCalendar.java \\\n java/util/HashMap.java \\\n java/util/Hashtable.java \\\n java/util/Iterator.java\t\\\n+java/util/LinkedList.java \\\n java/util/List.java \\\n java/util/ListIterator.java \\\n java/util/ListResourceBundle.java \\\n@@ -1176,7 +1160,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -1653,9 +1637,10 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/EventListener.P .deps/java/util/EventObject.P \\\n .deps/java/util/GregorianCalendar.P .deps/java/util/HashMap.P \\\n .deps/java/util/Hashtable.P .deps/java/util/Iterator.P \\\n-.deps/java/util/List.P .deps/java/util/ListIterator.P \\\n-.deps/java/util/ListResourceBundle.P .deps/java/util/Locale.P \\\n-.deps/java/util/Map.P .deps/java/util/MissingResourceException.P \\\n+.deps/java/util/LinkedList.P .deps/java/util/List.P \\\n+.deps/java/util/ListIterator.P .deps/java/util/ListResourceBundle.P \\\n+.deps/java/util/Locale.P .deps/java/util/Map.P \\\n+.deps/java/util/MissingResourceException.P \\\n .deps/java/util/NoSuchElementException.P .deps/java/util/Observable.P \\\n .deps/java/util/Observer.P .deps/java/util/Properties.P \\\n .deps/java/util/PropertyPermission.P \\\n@@ -2062,7 +2047,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "ba589e335e74ba572efcda4bf78b53c3d8f8fc89", "filename": "libjava/java/util/AbstractList.java", "status": "modified", "additions": 210, "deletions": 212, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d218b6742d2cd67c639ad6668431a56ccca0705/libjava%2Fjava%2Futil%2FAbstractList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d218b6742d2cd67c639ad6668431a56ccca0705/libjava%2Fjava%2Futil%2FAbstractList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractList.java?ref=8d218b6742d2cd67c639ad6668431a56ccca0705", "patch": "@@ -309,232 +309,230 @@ public void add(Object o)\n       knownMod++;\n     }\n   }\t\t\t\t// AbstractList.Iterator\n+}\n+\n+\n+\n+class SubList extends AbstractList\n+{\n+  private AbstractList backingList;\n+  private int offset;\n+  private int size;\n \n-  static class SubList extends AbstractList\n+  public SubList(AbstractList backing, int fromIndex, int toIndex)\n   {\n-    private AbstractList backingList;\n-    private int offset;\n-    private int size;\n+    backingList = backing;\n+    modCount = backingList.modCount;\n+    offset = fromIndex;\n+    size = toIndex - fromIndex;\n+  }\n \n-    public SubList(AbstractList backing, int fromIndex, int toIndex)\n-    {\n-      backingList = backing;\n-      // FIXME: The `this' prefixes in this class are a workaround for a\n-      // gcj bug. They should be removed later.\n-      this.modCount = backingList.modCount;\n-      offset = fromIndex;\n-      size = toIndex - fromIndex;\n-    }\n+  /**\n+   * This method checks the two modCount fields to ensure that there has\n+   * not been a concurrent modification. It throws an exception if there\n+   * has been, and otherwise returns normally.\n+   * Note that since this method is private, it will be inlined.\n+   *\n+   * @exception ConcurrentModificationException if there has been a\n+   *   concurrent modification.\n+   */\n+  private void checkMod()\n+  {\n+    if (modCount != backingList.modCount)\n+      throw new ConcurrentModificationException();\n+  }\n \n-    /**\n-     * This method checks the two modCount fields to ensure that there has\n-     * not been a concurrent modification. It throws an exception if there\n-     * has been, and otherwise returns normally.\n-     * Note that since this method is private, it will be inlined.\n-     *\n-     * @exception ConcurrentModificationException if there has been a\n-     *   concurrent modification.\n-     */\n-    private void checkMod()\n-    {\n-      if (this.modCount != backingList.modCount)\n-\tthrow new ConcurrentModificationException();\n-    }\n+  /**\n+   * This method checks that a value is between 0 and size (inclusive). If\n+   * it is not, an exception is thrown.\n+   * Note that since this method is private, it will be inlined.\n+   *\n+   * @exception IndexOutOfBoundsException if the value is out of range.\n+   */\n+  private void checkBoundsInclusive(int index)\n+  {\n+    if (index < 0 || index > size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+  }\n \n-    /**\n-     * This method checks that a value is between 0 and size (inclusive). If\n-     * it is not, an exception is thrown.\n-     * Note that since this method is private, it will be inlined.\n-     *\n-     * @exception IndexOutOfBoundsException if the value is out of range.\n-     */\n-    private void checkBoundsInclusive(int index)\n-    {\n-      if (index < 0 || index > size)\n-\tthrow new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                            size);\n-    }\n+  /**\n+   * This method checks that a value is between 0 (inclusive) and size\n+   * (exclusive). If it is not, an exception is thrown.\n+   * Note that since this method is private, it will be inlined.\n+   *\n+   * @exception IndexOutOfBoundsException if the value is out of range.\n+   */\n+  private void checkBoundsExclusive(int index)\n+  {\n+    if (index < 0 || index >= size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+  }\n \n-    /**\n-     * This method checks that a value is between 0 (inclusive) and size\n-     * (exclusive). If it is not, an exception is thrown.\n-     * Note that since this method is private, it will be inlined.\n-     *\n-     * @exception IndexOutOfBoundsException if the value is out of range.\n-     */\n-    private void checkBoundsExclusive(int index)\n-    {\n-      if (index < 0 || index >= size)\n-\tthrow new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                            size);\n-    }\n+  public int size()\n+  {\n+    checkMod();\n+    return size;\n+  }\n \n-    public int size()\n-    {\n-      checkMod();\n-      return size;\n-    }\n+  public Object set(int index, Object o)\n+  {\n+    checkMod();\n+    checkBoundsExclusive(index);\n+    o = backingList.set(index + offset, o);\n+    return o;\n+  }\n \n-    public Object set(int index, Object o)\n-    {\n-      checkMod();\n-      checkBoundsExclusive(index);\n-      o = backingList.set(index + offset, o);\n-      return o;\n-    }\n+  public Object get(int index)\n+  {\n+    checkMod();\n+    checkBoundsExclusive(index);\n+    return backingList.get(index + offset);\n+  }\n \n-    public Object get(int index)\n-    {\n-      checkMod();\n-      checkBoundsExclusive(index);\n-      return backingList.get(index + offset);\n-    }\n+  public void add(int index, Object o)\n+  {\n+    checkMod();\n+    checkBoundsInclusive(index);\n+    backingList.add(index + offset, o);\n+    this.modCount++;\n+    size++;\n+  }\n \n-    public void add(int index, Object o)\n-    {\n-      checkMod();\n-      checkBoundsInclusive(index);\n-      backingList.add(index + offset, o);\n-      this.modCount++;\n-      size++;\n-    }\n+  public Object remove(int index)\n+  {\n+    checkMod();\n+    checkBoundsExclusive(index);\n+    Object o = backingList.remove(index + offset);\n+    this.modCount++;\n+    size--;\n+    return o;\n+  }\n \n-    public Object remove(int index)\n-    {\n-      checkMod();\n-      checkBoundsExclusive(index);\n-      Object o = backingList.remove(index + offset);\n-      this.modCount++;\n-      size--;\n-      return o;\n-    }\n+  public void removeRange(int fromIndex, int toIndex)\n+  {\n+    checkMod();\n+    checkBoundsExclusive(fromIndex);\n+    checkBoundsInclusive(toIndex);\n+\n+    // this call will catch the toIndex < fromIndex condition\n+    backingList.removeRange(offset + fromIndex, offset + toIndex);\n+    this.modCount = backingList.modCount;\n+    size -= toIndex - fromIndex;\n+  }\n \n-    public void removeRange(int fromIndex, int toIndex)\n-    {\n-      checkMod();\n-      checkBoundsExclusive(fromIndex);\n-      checkBoundsInclusive(toIndex);\n+  public boolean addAll(int index, Collection c)\n+  {\n+    checkMod();\n+    checkBoundsInclusive(index);\n+    int csize = c.size();\n+    boolean result = backingList.addAll(offset + index, c);\n+    this.modCount = backingList.modCount;\n+    size += csize;\n+    return result;\n+  }\n \n-      // this call will catch the toIndex < fromIndex condition\n-      backingList.removeRange(offset + fromIndex, offset + toIndex);\n-      this.modCount = backingList.modCount;\n-      size -= toIndex - fromIndex;\n-    }\n-    \n-    public boolean addAll(int index, Collection c)\n-    {\n-      checkMod();\n-      checkBoundsInclusive(index);\n-      int csize = c.size();\n-      boolean result = backingList.addAll(offset + index, c);\n-      this.modCount = backingList.modCount;\n-      size += csize;\n-      return result;\n-    }\n-    \n-    public Iterator iterator()\n+  public Iterator iterator()\n+  {\n+    return listIterator(0);\n+  }\n+\n+  public ListIterator listIterator(final int index)\n+  {      \n+    checkMod();\n+    checkBoundsInclusive(index);\n+\n+    return new ListIterator() \n     {\n-      return listIterator(0);\n-    }\n+      ListIterator i = backingList.listIterator(index + offset);\n+      int position = index;\n \n-    public ListIterator listIterator(final int index)\n-    {      \n-      checkMod();\n-      checkBoundsInclusive(index);\n-      \n-      return new ListIterator() \n+      public boolean hasNext()\n       {\n-        ListIterator i = backingList.listIterator(index + offset);\n-        int position = index;\n-        \n-        public boolean hasNext()\n-\t{\n-          checkMod();\n-          return position < size;\n-        }\n-        \n-        public boolean hasPrevious()\n-\t{\n-          checkMod();\n-          return position > 0;\n-        }\n-        \n-        public Object next()\n-\t{\n-          if (position < size)\n-\t    {\n-              Object o = i.next();\n-              position++;\n-              return o;\n-            }\n-\t  else\n-            throw new NoSuchElementException();\n-\t}\n-        \n-        public Object previous()\n-\t{\n-          if (position > 0)\n-\t    {\n-              Object o = i.previous();\n-              position--;\n-              return o;\n-            }\n-\t  else\n-            throw new NoSuchElementException();\n-        }\n-        \n-        public int nextIndex()\n-\t{\n-          return offset + i.nextIndex();\n-        }\n-        \n-        public int previousIndex()\n-\t{\n-          return offset + i.previousIndex();\n-        }\n+        checkMod();\n+        return position < size;\n+      }\n \n-        public void remove()\n-\t{\n-          i.remove();\n-\t  // FIXME: Uncomment the following line once the compiler is fixed.\n-\t  //SubList.this.modCount++;\n-          size--;\n-          position = nextIndex();\n-        }\n-        \n-        public void set(Object o)\n-\t{\n-          i.set(o);\n-        }\n-        \n-        public void add(Object o)\n-\t{\n-          i.add(o);\n-\t  // FIXME: Uncomment the following line once the compiler is fixed.\n-\t  //SubList.this.modCount++;\n-          size++;\n-          position++;\n-        }\n-\n-        // Here is the reason why the various modCount fields are mostly\n-        // ignored in this wrapper listIterator.\n-        // IF the backing listIterator is failfast, then the following holds:\n-        //   Using any other method on this list will call a corresponding\n-        //   method on the backing list *after* the backing listIterator\n-        //   is created, which will in turn cause a ConcurrentModException\n-        //   when this listIterator comes to use the backing one. So it is\n-        //   implicitly failfast.\n-        // If the backing listIterator is NOT failfast, then the whole of\n-        //   this list isn't failfast, because the modCount field of the\n-        //   backing list is not valid. It would still be *possible* to\n-        //   make the iterator failfast wrt modifications of the sublist\n-        //   only, but somewhat pointless when the list can be changed under\n-        //   us.\n-        // Either way, no explicit handling of modCount is needed.\n-        // However modCount++ must be executed in add and remove, and size\n-        // must also be updated in these two methods, since they do not go\n-        // through the corresponding methods of the subList.\n-      };\n-    }\n-  }  // AbstractList.SubList\n-}\n+      public boolean hasPrevious()\n+      {\n+        checkMod();\n+        return position > 0;\n+      }\n+\n+      public Object next()\n+      {\n+        if (position < size)\n+\t  {\n+            Object o = i.next();\n+            position++;\n+            return o;\n+          }\n+\telse\n+          throw new NoSuchElementException();\n+      }\n+\n+      public Object previous()\n+      {\n+        if (position > 0)\n+\t  {\n+            Object o = i.previous();\n+            position--;\n+            return o;\n+          }\n+\telse\n+          throw new NoSuchElementException();\n+      }\n+\n+      public int nextIndex()\n+      {\n+        return offset + i.nextIndex();\n+      }\n+\n+      public int previousIndex()\n+      {\n+        return offset + i.previousIndex();\n+      }\n+\n+      public void remove()\n+      {\n+        i.remove();\n+\tmodCount++;\n+        size--;\n+        position = nextIndex();\n+      }\n+\n+      public void set(Object o)\n+      {\n+        i.set(o);\n+      }\n+\n+      public void add(Object o)\n+      {\n+        i.add(o);\n+\tmodCount++;\n+        size++;\n+        position++;\n+      }\n+\n+      // Here is the reason why the various modCount fields are mostly\n+      // ignored in this wrapper listIterator.\n+      // IF the backing listIterator is failfast, then the following holds:\n+      //   Using any other method on this list will call a corresponding\n+      //   method on the backing list *after* the backing listIterator\n+      //   is created, which will in turn cause a ConcurrentModException\n+      //   when this listIterator comes to use the backing one. So it is\n+      //   implicitly failfast.\n+      // If the backing listIterator is NOT failfast, then the whole of\n+      //   this list isn't failfast, because the modCount field of the\n+      //   backing list is not valid. It would still be *possible* to\n+      //   make the iterator failfast wrt modifications of the sublist\n+      //   only, but somewhat pointless when the list can be changed under\n+      //   us.\n+      // Either way, no explicit handling of modCount is needed.\n+      // However modCount++ must be executed in add and remove, and size\n+      // must also be updated in these two methods, since they do not go\n+      // through the corresponding methods of the subList.\n+    };\n+  }\n+}  // SubList"}, {"sha": "22219294479586591314b6e5bc57eee4d72357c2", "filename": "libjava/java/util/LinkedList.java", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d218b6742d2cd67c639ad6668431a56ccca0705/libjava%2Fjava%2Futil%2FLinkedList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d218b6742d2cd67c639ad6668431a56ccca0705/libjava%2Fjava%2Futil%2FLinkedList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLinkedList.java?ref=8d218b6742d2cd67c639ad6668431a56ccca0705", "patch": "@@ -322,7 +322,7 @@ public boolean addAll(int index, Collection c)\n \tprev.next = e;\n \tprev = e;\n       }\n-    // Fix up the links between the last new entry and the following entry.\n+    // Link the new chain of entries into the list.\n     prev.next = after;\n     if (after != null)\n       after.previous = e;\n@@ -541,7 +541,7 @@ class LinkedListItr implements ListIterator\n      * position, in a list of given size.\n      */\n     LinkedListItr(int index)\n-    {      \n+    {\n       if (index == size)\n         {\n           next = null;\n@@ -621,8 +621,8 @@ public void remove()\n \n       next = lastReturned.next;\n       previous = lastReturned.previous;\n-      // Because the list is being manipulated directly, there's no need to \n-      // touch either modCount or knownMod here.\n+      modCount++;\n+      knownMod++;\n       removeEntry(lastReturned);\n       \n       lastReturned = null;\n@@ -631,11 +631,27 @@ public void remove()\n     public void add(Object o)\n     {\n       checkMod();\n-      // Because the list is being manipulated directly, there's no need to \n-      // touch either modCount or knownMod here.\n+      modCount++;\n+      knownMod++;\n       Entry e = new Entry(o);\n-      addEntry(position, e);\n+      e.previous = previous;\n+      e.next = next;\n+\n+      if (previous != null)\n+\tprevious.next = e;\n+      else\n+\tfirst = e;\n+\n+      if (next != null)\n+        {\n+\t  next.previous = e;\n+\t  next = next.next;\n+\t}\n+      else\n+\tlast = e;\n+\n       previous = e;\n+      size++;\n       position++;\n       lastReturned = null;\n     }"}]}