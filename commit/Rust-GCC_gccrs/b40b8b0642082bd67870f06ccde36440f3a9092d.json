{"sha": "b40b8b0642082bd67870f06ccde36440f3a9092d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQwYjhiMDY0MjA4MmJkNjc4NzBmMDZjY2RlMzY0NDBmM2E5MDkyZA==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-10-05T05:48:02Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-10-05T05:48:02Z"}, "message": "(move_for_stack_reg): If the 387 regstack is not full when doing an XFmode write from 387 to MEM...\n\n(move_for_stack_reg): If the 387 regstack is not full when doing an XFmode\nwrite from 387 to MEM, copy the source reg and write the copy.\n\nFrom-SVN: r5598", "tree": {"sha": "df9f87807211728104ca217f0da45bf92cb3031b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df9f87807211728104ca217f0da45bf92cb3031b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b40b8b0642082bd67870f06ccde36440f3a9092d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40b8b0642082bd67870f06ccde36440f3a9092d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b40b8b0642082bd67870f06ccde36440f3a9092d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40b8b0642082bd67870f06ccde36440f3a9092d/comments", "author": null, "committer": null, "parents": [{"sha": "a8683de70b540a7b40dedf4222677226a5c52b48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8683de70b540a7b40dedf4222677226a5c52b48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8683de70b540a7b40dedf4222677226a5c52b48"}], "stats": {"total": 20, "additions": 19, "deletions": 1}, "files": [{"sha": "005f55493ea0dadad62e81ca5fa0bf9f8caf2198", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40b8b0642082bd67870f06ccde36440f3a9092d/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40b8b0642082bd67870f06ccde36440f3a9092d/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=b40b8b0642082bd67870f06ccde36440f3a9092d", "patch": "@@ -230,7 +230,7 @@ static rtx FP_mode_reg[FIRST_PSEUDO_REGISTER][(int) MAX_MACHINE_MODE];\n     : block_number)[INSN_UID (INSN)])\n \n extern rtx gen_jump ();\n-extern rtx gen_movdf ();\n+extern rtx gen_movdf (), gen_movxf ();\n extern rtx find_regno_note ();\n extern rtx emit_jump_insn_before ();\n extern rtx emit_label_after ();\n@@ -1723,6 +1723,24 @@ move_for_stack_reg (insn, regstack, pat)\n \t  regstack->top--;\n \t  CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src));\n \t}\n+      else if (GET_MODE (*src) == XFmode && regstack->top != REG_STACK_SIZE)\n+\t{\n+\t  /* A 387 cannot write an XFmode value to a MEM without\n+\t     clobbering the source reg.  The output code can handle\n+\t     this by reading back the value from the MEM.\n+\t     But it is more efficient to use a temp register if one is\n+\t     available.  Push the source value here if the register\n+\t     stack is not full, and then write the value to memory via\n+\t     a pop.  */\n+\t  rtx push_rtx, push_insn;\n+\t  rtx top_stack_reg = FP_mode_reg[FIRST_STACK_REG][(int) XFmode];\n+\n+\t  push_rtx = gen_movxf (top_stack_reg, top_stack_reg);\n+\t  push_insn = emit_insn_before (push_rtx, insn);\n+\t  PUT_MODE (push_insn, QImode);\n+\t  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD, top_stack_reg,\n+\t\t\t\t      REG_NOTES (insn));\n+\t}\n \n       replace_reg (src, FIRST_STACK_REG);\n     }"}]}