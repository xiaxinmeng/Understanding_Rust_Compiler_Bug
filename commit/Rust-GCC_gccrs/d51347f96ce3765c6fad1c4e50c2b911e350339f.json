{"sha": "d51347f96ce3765c6fad1c4e50c2b911e350339f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUxMzQ3Zjk2Y2UzNzY1YzZmYWQxYzRlNTBjMmI5MTFlMzUwMzM5Zg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2007-04-12T08:46:30Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-04-12T08:46:30Z"}, "message": "re PR fortran/31472 (gfortran does not detect the illegal use of an access specification in a program, subroutine, or function)\n\n2007-04-12  Tobias Burnus  <burnus@net-b.de>\n\n\tPR fortran/31472\n\t* decl.c (match_attr_spec): Allow PRIVATE/PUBLIC\n\tattribute in type definitions.\n\t(gfc_match_private): Allow PRIVATE statement only\n\tin specification part of modules.\n\t(gfc_match_public): Ditto for PUBLIC.\n\t(gfc_match_derived_decl): Allow PRIVATE/PUBLIC attribute only in\n\tspecificification part of modules.\n\n2007-04-12  Tobias Burnus  <burnus@net-b.de>\n\n\tPR fortran/31472\n\t* gfortran.dg/access_spec_1.f90: New test.\n\t* gfortran.dg/access_spec_2.f90: New test.\n\t* gfortran.dg/non_module_public.f90: Match new error message.\n\nFrom-SVN: r123735", "tree": {"sha": "755477f23d921c3c54dc432a7c6885bbc8a94363", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/755477f23d921c3c54dc432a7c6885bbc8a94363"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d51347f96ce3765c6fad1c4e50c2b911e350339f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d51347f96ce3765c6fad1c4e50c2b911e350339f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d51347f96ce3765c6fad1c4e50c2b911e350339f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d51347f96ce3765c6fad1c4e50c2b911e350339f/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c5e065b53c2a1e2ec1351654939891f52a102b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c5e065b53c2a1e2ec1351654939891f52a102b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c5e065b53c2a1e2ec1351654939891f52a102b4"}], "stats": {"total": 231, "additions": 171, "deletions": 60}, "files": [{"sha": "3bc5b394af6cca2534b3c70e8a0bfb832607a7ce", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d51347f96ce3765c6fad1c4e50c2b911e350339f", "patch": "@@ -1,3 +1,14 @@\n+2007-04-12  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/31472\n+\t* decl.c (match_attr_spec): Allow PRIVATE/PUBLIC\n+\tattribute in type definitions.\n+\t(gfc_match_private): Allow PRIVATE statement only\n+\tin specification part of modules.\n+\t(gfc_match_public): Ditto for PUBLIC.\n+\t(gfc_match_derived_decl): Allow PRIVATE/PUBLIC attribute only in\n+\tspecificification part of modules.\n+\n 2007-04-07  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/31257"}, {"sha": "67d05b850ea5d3c7f8a009bceb2997dc7180030d", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 94, "deletions": 59, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=d51347f96ce3765c6fad1c4e50c2b911e350339f", "patch": "@@ -477,7 +477,7 @@ match_old_style_init (const char *name)\n \n /* Match the stuff following a DATA statement. If ERROR_FLAG is set,\n    we are matching a DATA statement and are therefore issuing an error\n-   if we encounter something unexpected, if not, we're trying to match \n+   if we encounter something unexpected, if not, we're trying to match\n    an old-style initialization expression of the form INTEGER I /2/.  */\n \n match\n@@ -624,9 +624,9 @@ find_special (const char *name, gfc_symbol **result)\n   int i;\n \n   i = gfc_get_symbol (name, NULL, result);\n-  if (i == 0) \n+  if (i == 0)\n     goto end;\n-  \n+\n   if (gfc_current_state () != COMP_SUBROUTINE\n       && gfc_current_state () != COMP_FUNCTION)\n     goto end;\n@@ -812,15 +812,15 @@ gfc_set_constant_character_len (int len, gfc_expr *expr, bool array)\n }\n \n \n-/* Function to create and update the enumerator history \n+/* Function to create and update the enumerator history\n    using the information passed as arguments.\n-   Pointer \"max_enum\" is also updated, to point to \n-   enum history node containing largest initializer.  \n+   Pointer \"max_enum\" is also updated, to point to\n+   enum history node containing largest initializer.\n \n    SYM points to the symbol node of enumerator.\n    INIT points to its enumerator value.   */\n \n-static void \n+static void\n create_enum_history (gfc_symbol *sym, gfc_expr *init)\n {\n   enumerator_history *new_enum_history;\n@@ -842,20 +842,20 @@ create_enum_history (gfc_symbol *sym, gfc_expr *init)\n       new_enum_history->next = enum_history;\n       enum_history = new_enum_history;\n \n-      if (mpz_cmp (max_enum->initializer->value.integer, \n+      if (mpz_cmp (max_enum->initializer->value.integer,\n \t\t   new_enum_history->initializer->value.integer) < 0)\n \tmax_enum = new_enum_history;\n     }\n }\n \n \n-/* Function to free enum kind history.  */ \n+/* Function to free enum kind history.  */\n \n-void \n+void\n gfc_free_enum_history (void)\n {\n-  enumerator_history *current = enum_history;  \n-  enumerator_history *next;  \n+  enumerator_history *current = enum_history;\n+  enumerator_history *next;\n \n   while (current != NULL)\n     {\n@@ -1215,22 +1215,22 @@ variable_decl (int elem)\n \t\t{\n \t\t  if (gfc_set_array_spec (sym, cp_as, &var_locus) == FAILURE)\n \t\t    gfc_internal_error (\"Couldn't set pointee array spec.\");\n-\t      \n+\n \t\t  /* Fix the array spec.  */\n-\t\t  m = gfc_mod_pointee_as (sym->as);  \n+\t\t  m = gfc_mod_pointee_as (sym->as);\n \t\t  if (m == MATCH_ERROR)\n \t\t    goto cleanup;\n \t\t}\n-\t    }     \n+\t    }\n \t  goto cleanup;\n \t}\n       else\n \t{\n \t  gfc_free_array_spec (cp_as);\n \t}\n     }\n-  \n-    \n+\n+\n   /* OK, we've successfully matched the declaration.  Now put the\n      symbol in the current namespace, because it might be used in the\n      optional initialization expression for this symbol, e.g. this is\n@@ -1294,7 +1294,7 @@ variable_decl (int elem)\n       if (gfc_notify_std (GFC_STD_GNU, \"Extension: Old-style \"\n \t\t\t  \"initialization at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n-     \n+ \n       return match_old_style_init (name);\n     }\n \n@@ -1667,7 +1667,7 @@ match_char_spec (gfc_typespec *ts)\n    to the matched specification.  This is necessary for FUNCTION and\n    IMPLICIT statements.\n \n-   If implicit_flag is nonzero, then we don't check for the optional \n+   If implicit_flag is nonzero, then we don't check for the optional\n    kind specification.  Not doing so is needed for matching an IMPLICIT\n    statement correctly.  */\n \n@@ -1683,7 +1683,7 @@ match_type_spec (gfc_typespec *ts, int implicit_flag)\n \n   if (gfc_match (\" byte\") == MATCH_YES)\n     {\n-      if (gfc_notify_std(GFC_STD_GNU, \"Extension: BYTE type at %C\") \n+      if (gfc_notify_std(GFC_STD_GNU, \"Extension: BYTE type at %C\")\n \t  == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -1693,7 +1693,7 @@ match_type_spec (gfc_typespec *ts, int implicit_flag)\n \t\t     \"is not available on the target machine\");\n \t  return MATCH_ERROR;\n \t}\n-      \n+\n       ts->type = BT_INTEGER;\n       ts->kind = 1;\n       return MATCH_YES;\n@@ -2082,7 +2082,7 @@ gfc_match_import (void)\n \t      return MATCH_ERROR;\n \t    }\n \n-\t  if (gfc_find_symtree (gfc_current_ns->sym_root,name)) \n+\t  if (gfc_find_symtree (gfc_current_ns->sym_root,name))\n \t    {\n \t      gfc_warning (\"'%s' is already IMPORTed from host scoping unit \"\n \t\t\t   \"at %C.\", name);\n@@ -2189,7 +2189,7 @@ match_attr_spec (void)\n       d = (decl_types) gfc_match_strings (decls);\n       if (d == DECL_NONE || d == DECL_COLON)\n \tbreak;\n-       \n+\n       seen[d]++;\n       seen_at[d] = gfc_current_locus;\n \n@@ -2292,13 +2292,14 @@ match_attr_spec (void)\n \n       if (gfc_current_state () == COMP_DERIVED\n \t  && d != DECL_DIMENSION && d != DECL_POINTER\n-\t  && d != DECL_COLON && d != DECL_NONE)\n+\t  && d != DECL_COLON     && d != DECL_PRIVATE\n+\t  && d != DECL_PUBLIC    && d != DECL_NONE)\n \t{\n \t  if (d == DECL_ALLOCATABLE)\n \t    {\n \t      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ALLOCATABLE \"\n \t\t\t\t  \"attribute at %C in a TYPE definition\")\n-\t\t  == FAILURE)\t \n+\t\t  == FAILURE)\n \t\t{\n \t\t  m = MATCH_ERROR;\n \t\t  goto cleanup;\n@@ -2307,7 +2308,7 @@ match_attr_spec (void)\n \t  else\n \t    {\n \t      gfc_error (\"Attribute at %L is not allowed in a TYPE definition\",\n-\t\t\t  &seen_at[d]);\n+\t\t\t &seen_at[d]);\n \t      m = MATCH_ERROR;\n \t      goto cleanup;\n \t    }\n@@ -2320,11 +2321,26 @@ match_attr_spec (void)\n \t    attr = \"PRIVATE\";\n \t  else\n \t    attr = \"PUBLIC\";\n-\n-\t  gfc_error (\"%s attribute at %L is not allowed outside of a MODULE\",\n-\t\t     attr, &seen_at[d]);\n-\t  m = MATCH_ERROR;\n-\t  goto cleanup;\n+\t  if (gfc_current_state () == COMP_DERIVED\n+\t      && gfc_state_stack->previous\n+\t      && gfc_state_stack->previous->state == COMP_MODULE)\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Attribute %s \"\n+\t\t\t\t  \"at %L in a TYPE definition\", attr,\n+\t\t\t\t  &seen_at[d])\n+\t\t  == FAILURE)\n+\t\t{\n+\t\t  m = MATCH_ERROR;\n+\t\t  goto cleanup;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      gfc_error (\"%s attribute at %L is not allowed outside of the \"\n+\t\t\t \"specification part of a module\", attr, &seen_at[d]);\n+\t      m = MATCH_ERROR;\n+\t      goto cleanup;\n+\t    }\n \t}\n \n       switch (d)\n@@ -3146,7 +3162,7 @@ contained_procedure (void)\n   return 0;\n }\n \n-/* Set the kind of each enumerator.  The kind is selected such that it is \n+/* Set the kind of each enumerator.  The kind is selected such that it is\n    interoperable with the corresponding C enumeration type, making\n    sure that -fshort-enums is honored.  */\n \n@@ -3161,14 +3177,14 @@ set_enum_kind(void)\n     return;\n \n   if (!gfc_option.fshort_enums)\n-    return; \n-  \n+    return;\n+\n   i = 0;\n   do\n     {\n       kind = gfc_integer_kinds[i++].kind;\n     }\n-  while (kind < gfc_c_int_kind \n+  while (kind < gfc_c_int_kind\n \t && gfc_check_integer_range (max_enum->initializer->value.integer,\n \t\t\t\t     kind) != ARITH_OK);\n \n@@ -3438,7 +3454,7 @@ attr_decl1 (void)\n       m = MATCH_ERROR;\n       goto cleanup;\n     }\n-    \n+\n   if (sym->attr.cray_pointee && sym->as != NULL)\n     {\n       /* Fix the array spec.  */\n@@ -3508,14 +3524,14 @@ attr_decl (void)\n /* This routine matches Cray Pointer declarations of the form:\n    pointer ( <pointer>, <pointee> )\n    or\n-   pointer ( <pointer1>, <pointee1> ), ( <pointer2>, <pointee2> ), ...   \n-   The pointer, if already declared, should be an integer.  Otherwise, we \n+   pointer ( <pointer1>, <pointee1> ), ( <pointer2>, <pointee2> ), ...\n+   The pointer, if already declared, should be an integer.  Otherwise, we\n    set it as BT_INTEGER with kind gfc_index_integer_kind.  The pointee may\n    be either a scalar, or an array declaration.  No space is allocated for\n-   the pointee.  For the statement \n+   the pointee.  For the statement\n    pointer (ipt, ar(10))\n    any subsequent uses of ar will be translated (in C-notation) as\n-   ar(i) => ((<type> *) ipt)(i)   \n+   ar(i) => ((<type> *) ipt)(i)\n    After gimplification, pointee variable will disappear in the code.  */\n \n static match\n@@ -3533,32 +3549,32 @@ cray_pointer_decl (void)\n       if (gfc_match_char ('(') != MATCH_YES)\n \t{\n \t  gfc_error (\"Expected '(' at %C\");\n-\t  return MATCH_ERROR;   \n+\t  return MATCH_ERROR;\n \t}\n- \n+\n       /* Match pointer.  */\n       var_locus = gfc_current_locus;\n       gfc_clear_attr (&current_attr);\n       gfc_add_cray_pointer (&current_attr, &var_locus);\n       current_ts.type = BT_INTEGER;\n       current_ts.kind = gfc_index_integer_kind;\n \n-      m = gfc_match_symbol (&cptr, 0);  \n+      m = gfc_match_symbol (&cptr, 0);\n       if (m != MATCH_YES)\n \t{\n \t  gfc_error (\"Expected variable name at %C\");\n \t  return m;\n \t}\n-  \n+\n       if (gfc_add_cray_pointer (&cptr->attr, &var_locus) == FAILURE)\n \treturn MATCH_ERROR;\n \n-      gfc_set_sym_referenced (cptr);      \n+      gfc_set_sym_referenced (cptr);\n \n       if (cptr->ts.type == BT_UNKNOWN) /* Override the type, if necessary.  */\n \t{\n \t  cptr->ts.type = BT_INTEGER;\n-\t  cptr->ts.kind = gfc_index_integer_kind; \n+\t  cptr->ts.kind = gfc_index_integer_kind;\n \t}\n       else if (cptr->ts.type != BT_INTEGER)\n \t{\n@@ -3573,10 +3589,10 @@ cray_pointer_decl (void)\n       if (gfc_match_char (',') != MATCH_YES)\n \t{\n \t  gfc_error (\"Expected \\\",\\\" at %C\");\n-\t  return MATCH_ERROR;    \n+\t  return MATCH_ERROR;\n \t}\n \n-      /* Match Pointee.  */  \n+      /* Match Pointee.  */\n       var_locus = gfc_current_locus;\n       gfc_clear_attr (&current_attr);\n       gfc_add_cray_pointee (&current_attr, &var_locus);\n@@ -3589,7 +3605,7 @@ cray_pointer_decl (void)\n \t  gfc_error (\"Expected variable name at %C\");\n \t  return m;\n \t}\n-       \n+\n       /* Check for an optional array spec.  */\n       m = gfc_match_array_spec (&as);\n       if (m == MATCH_ERROR)\n@@ -3916,6 +3932,16 @@ gfc_match_private (gfc_statement *st)\n   if (gfc_match (\"private\") != MATCH_YES)\n     return MATCH_NO;\n \n+  if (gfc_current_state () != COMP_MODULE\n+      && (gfc_current_state () != COMP_DERIVED\n+          || !gfc_state_stack->previous\n+          || gfc_state_stack->previous->state != COMP_MODULE))\n+    {\n+      gfc_error (\"PRIVATE statement at %C is only allowed in the \"\n+\t\t \"specification part of a module\");\n+      return MATCH_ERROR;\n+    }\n+\n   if (gfc_current_state () == COMP_DERIVED)\n     {\n       if (gfc_match_eos () == MATCH_YES)\n@@ -3946,6 +3972,13 @@ gfc_match_public (gfc_statement *st)\n   if (gfc_match (\"public\") != MATCH_YES)\n     return MATCH_NO;\n \n+  if (gfc_current_state () != COMP_MODULE)\n+    {\n+      gfc_error (\"PUBLIC statement at %C is only allowed in the \"\n+\t\t \"specification part of a module\");\n+      return MATCH_ERROR;\n+    }\n+\n   if (gfc_match_eos () == MATCH_YES)\n     {\n       *st = ST_PUBLIC;\n@@ -4315,9 +4348,10 @@ gfc_match_derived_decl (void)\n loop:\n   if (gfc_match (\" , private\") == MATCH_YES)\n     {\n-      if (gfc_find_state (COMP_MODULE) == FAILURE)\n+      if (gfc_current_state () != COMP_MODULE)\n \t{\n-\t  gfc_error (\"Derived type at %C can only be PRIVATE within a MODULE\");\n+\t  gfc_error (\"Derived type at %C can only be PRIVATE in the \"\n+\t\t     \"specification part of a module\");\n \t  return MATCH_ERROR;\n \t}\n \n@@ -4328,9 +4362,10 @@ gfc_match_derived_decl (void)\n \n   if (gfc_match (\" , public\") == MATCH_YES)\n     {\n-      if (gfc_find_state (COMP_MODULE) == FAILURE)\n+      if (gfc_current_state () != COMP_MODULE)\n \t{\n-\t  gfc_error (\"Derived type at %C can only be PUBLIC within a MODULE\");\n+\t  gfc_error (\"Derived type at %C can only be PUBLIC in the \"\n+\t\t     \"specification part of a module\");\n \t  return MATCH_ERROR;\n \t}\n \n@@ -4510,12 +4545,12 @@ enumerator_decl (void)\n      by 1 and is used to initialize the current enumerator.  */\n   if (initializer == NULL)\n     initializer = gfc_enum_initializer (last_initializer, old_locus);\n- \n+\n   if (initializer == NULL || initializer->ts.type != BT_INTEGER)\n     {\n       gfc_error(\"ENUMERATOR %L not initialized with integer expression\",\n \t\t&var_locus);\n-      m = MATCH_ERROR; \n+      m = MATCH_ERROR;\n       gfc_free_enum_history ();\n       goto cleanup;\n     }\n@@ -4547,9 +4582,9 @@ gfc_match_enumerator_def (void)\n {\n   match m;\n   try t;\n-  \n+\n   gfc_clear_ts (&current_ts);\n-  \n+\n   m = gfc_match (\" enumerator\");\n   if (m != MATCH_YES)\n     return m;\n@@ -4559,7 +4594,7 @@ gfc_match_enumerator_def (void)\n     return m;\n \n   colon_seen = (m == MATCH_YES);\n-  \n+\n   if (gfc_current_state () != COMP_ENUM)\n     {\n       gfc_error (\"ENUM definition statement expected before %C\");\n@@ -4569,7 +4604,7 @@ gfc_match_enumerator_def (void)\n \n   (&current_ts)->type = BT_INTEGER;\n   (&current_ts)->kind = gfc_c_int_kind;\n-  \n+\n   gfc_clear_attr (&current_attr);\n   t = gfc_add_flavor (&current_attr, FL_PARAMETER, NULL, NULL);\n   if (t == FAILURE)"}, {"sha": "dfe1f300a21786c34875b92addbc7ff4b83c912c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d51347f96ce3765c6fad1c4e50c2b911e350339f", "patch": "@@ -1,3 +1,10 @@\n+2007-04-12  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/31472\n+\t* gfortran.dg/access_spec_1.f90: New test.\n+\t* gfortran.dg/access_spec_2.f90: New test.\n+\t* gfortran.dg/non_module_public.f90: Match new error message.\n+\n 2007-04-11  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR testsuite/31538"}, {"sha": "2c080c9c62fdff12dbc38de913c136b920f7cafe", "filename": "gcc/testsuite/gfortran.dg/access_spec_1.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ftestsuite%2Fgfortran.dg%2Faccess_spec_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ftestsuite%2Fgfortran.dg%2Faccess_spec_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Faccess_spec_1.f90?ref=d51347f96ce3765c6fad1c4e50c2b911e350339f", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! PR fortran/31472\n+! Access specifications: Valid Fortran 2003 code\n+module mod\n+  implicit none\n+  private\n+  integer, public :: i\n+  integer, private :: z\n+  integer :: j, x\n+  private :: j\n+  public  :: x\n+  type, public :: bar\n+    PRIVATE\n+    integer, public :: y  ! Fortran 2003\n+    integer, private :: z  ! Fortran 2003\n+  end type\n+end module\n+! { dg-final { cleanup-modules \"mod\" } }"}, {"sha": "7b67e6c85979d12d8eb0fb91828d73674d5ad980", "filename": "gcc/testsuite/gfortran.dg/access_spec_2.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ftestsuite%2Fgfortran.dg%2Faccess_spec_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ftestsuite%2Fgfortran.dg%2Faccess_spec_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Faccess_spec_2.f90?ref=d51347f96ce3765c6fad1c4e50c2b911e350339f", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+! PR fortran/31472\n+! Access specifications: Invalid Fortran 95 code\n+\n+module test\n+  implicit none\n+  integer, public :: x\n+  public :: x  ! { dg-error \"was already specified\" }\n+  private :: x ! { dg-error \"was already specified\" }\n+end module test\n+\n+module mod\n+  implicit none\n+  private\n+  type, public :: bar\n+    PRIVATE\n+    integer, public :: y  ! { dg-error \"Fortran 2003: Attribute PUBLIC\" }\n+    integer, public :: z  ! { dg-error \"Fortran 2003: Attribute PUBLIC\" }\n+  end type ! { dg-error \"Derived type definition at\" }\n+contains\n+  subroutine foo\n+     integer :: x\n+     private :: x ! { dg-error \"only allowed in the specification part of a module\" }\n+     type, private :: t ! { dg-error \"only be PRIVATE in the specification part of a module\" }\n+        integer :: z\n+     end type t ! { dg-error \"Expecting END SUBROUTINE statement\" }\n+     type :: ttt\n+        integer,public :: z ! { dg-error \"not allowed outside of the specification part of a module\" }\n+     end type ttt ! { dg-error \"Derived type definition at\" }\n+  end subroutine\n+end module\n+\n+program x\n+  implicit none\n+  integer :: i\n+  public  :: i ! { dg-error \"only allowed in the specification part of a module\" }\n+  integer,public :: j ! { dg-error \"not allowed outside of the specification part of a module\" }\n+end program x\n+! { dg-final { cleanup-modules \"test mod\" } }"}, {"sha": "3201a1598e57815e935118105ff3c9170023c4c9", "filename": "gcc/testsuite/gfortran.dg/non_module_public.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnon_module_public.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d51347f96ce3765c6fad1c4e50c2b911e350339f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnon_module_public.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnon_module_public.f90?ref=d51347f96ce3765c6fad1c4e50c2b911e350339f", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n ! PR20837 - A symbol may not be declared PUBLIC or PRIVATE outside a module.\n ! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n-integer, parameter, public :: i=1 ! { dg-error \"allowed outside of a MODULE\" }\n+integer, parameter, public :: i=1 ! { dg-error \"outside of the specification part of a module\" }\n END"}]}