{"sha": "06d65050301eddeb22be71443899ef3cf1b3ed61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZkNjUwNTAzMDFlZGRlYjIyYmU3MTQ0Mzg5OWVmM2NmMWIzZWQ2MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-31T12:26:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-31T12:26:32Z"}, "message": "ipa-prop.c (ipa_set_jf_known_type): Check that we add only records.\n\n\n\t* ipa-prop.c (ipa_set_jf_known_type): Check that we add\n\tonly records.\n\t(detect_type_change_1): Rename to ...\n\t(detect_type_change): ... this one; early return on non-polymorphic\n\ttypes.\n\t(detect_type_change_ssa): Add comp_type parameter; update\t\n\tuse of detect_type_change.\n\t(compute_complex_assign_jump_func): Add param_type parameter;\n\tupdate use of detect_type_change_ssa.\n\t(compute_complex_ancestor_jump_func): Likewise.\n\t(ipa_get_callee_param_type): New function.\n\t(ipa_compute_jump_functions_for_edge): Compute parameter type;\n\tupdate calls to the jump function computation functions.\n\nFrom-SVN: r202126", "tree": {"sha": "78757a2d1252fe99e8efd096196fdc884b1c20e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78757a2d1252fe99e8efd096196fdc884b1c20e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06d65050301eddeb22be71443899ef3cf1b3ed61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d65050301eddeb22be71443899ef3cf1b3ed61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d65050301eddeb22be71443899ef3cf1b3ed61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d65050301eddeb22be71443899ef3cf1b3ed61/comments", "author": null, "committer": null, "parents": [{"sha": "600b5b1d5cb381a652a9b57445b27793304e954f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600b5b1d5cb381a652a9b57445b27793304e954f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/600b5b1d5cb381a652a9b57445b27793304e954f"}], "stats": {"total": 161, "additions": 114, "deletions": 47}, "files": [{"sha": "030fa85e8b51a0d1da4287e722222a0690fc23cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d65050301eddeb22be71443899ef3cf1b3ed61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d65050301eddeb22be71443899ef3cf1b3ed61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06d65050301eddeb22be71443899ef3cf1b3ed61", "patch": "@@ -1,3 +1,19 @@\n+2013-08-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-prop.c (ipa_set_jf_known_type): Check that we add\n+\tonly records.\n+\t(detect_type_change_1): Rename to ...\n+\t(detect_type_change): ... this one; early return on non-polymorphic\n+\ttypes.\n+\t(detect_type_change_ssa): Add comp_type parameter; update\t\n+\tuse of detect_type_change.\n+\t(compute_complex_assign_jump_func): Add param_type parameter;\n+\tupdate use of detect_type_change_ssa.\n+\t(compute_complex_ancestor_jump_func): Likewise.\n+\t(ipa_get_callee_param_type): New function.\n+\t(ipa_compute_jump_functions_for_edge): Compute parameter type;\n+\tupdate calls to the jump function computation functions.\n+\n 2013-08-30  Teresa Johnson  <tejohnson@google.com>\n \t    Steven Bosscher  <steven@gcc.gnu.org>\n "}, {"sha": "fee5d1834d15861d18de1f7dd3cae8843a604f85", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 98, "deletions": 47, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d65050301eddeb22be71443899ef3cf1b3ed61/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d65050301eddeb22be71443899ef3cf1b3ed61/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=06d65050301eddeb22be71443899ef3cf1b3ed61", "patch": "@@ -371,6 +371,8 @@ static void\n ipa_set_jf_known_type (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n \t\t       tree base_type, tree component_type)\n {\n+  gcc_assert (TREE_CODE (component_type) == RECORD_TYPE\n+\t      && TYPE_BINFO (component_type));\n   jfunc->type = IPA_JF_KNOWN_TYPE;\n   jfunc->value.known_type.offset = offset,\n   jfunc->value.known_type.base_type = base_type;\n@@ -633,13 +635,16 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n \n \n \n-/* Like detect_type_change but with extra argument COMP_TYPE which will become\n-   the component type part of new JFUNC of dynamic type change is detected and\n-   the new base type is identified.  */\n+/* Detect whether the dynamic type of ARG of COMP_TYPE has changed (before\n+   callsite CALL) by looking for assignments to its virtual table pointer.  If\n+   it is, return true and fill in the jump function JFUNC with relevant type\n+   information or set it to unknown.  ARG is the object itself (not a pointer\n+   to it, unless dereferenced).  BASE is the base of the memory access as\n+   returned by get_ref_base_and_extent, as is the offset.  */\n \n static bool\n-detect_type_change_1 (tree arg, tree base, tree comp_type, gimple call,\n-\t\t      struct ipa_jump_func *jfunc, HOST_WIDE_INT offset)\n+detect_type_change (tree arg, tree base, tree comp_type, gimple call,\n+\t\t    struct ipa_jump_func *jfunc, HOST_WIDE_INT offset)\n {\n   struct type_change_info tci;\n   ao_ref ao;\n@@ -649,7 +654,12 @@ detect_type_change_1 (tree arg, tree base, tree comp_type, gimple call,\n \t\t       || handled_component_p (arg));\n   /* Const calls cannot call virtual methods through VMT and so type changes do\n      not matter.  */\n-  if (!flag_devirtualize || !gimple_vuse (call))\n+  if (!flag_devirtualize || !gimple_vuse (call)\n+      /* Be sure expected_type is polymorphic.  */\n+      || !comp_type\n+      || TREE_CODE (comp_type) != RECORD_TYPE\n+      || !TYPE_BINFO (comp_type)\n+      || !BINFO_VTABLE (TYPE_BINFO (comp_type)))\n     return false;\n \n   ao_ref_init (&ao, arg);\n@@ -679,40 +689,23 @@ detect_type_change_1 (tree arg, tree base, tree comp_type, gimple call,\n   return true;\n }\n \n-/* Detect whether the dynamic type of ARG has changed (before callsite CALL) by\n-   looking for assignments to its virtual table pointer.  If it is, return true\n-   and fill in the jump function JFUNC with relevant type information or set it\n-   to unknown.  ARG is the object itself (not a pointer to it, unless\n-   dereferenced).  BASE is the base of the memory access as returned by\n-   get_ref_base_and_extent, as is the offset.  */\n-\n-static bool\n-detect_type_change (tree arg, tree base, gimple call,\n-\t\t    struct ipa_jump_func *jfunc, HOST_WIDE_INT offset)\n-{\n-  return detect_type_change_1 (arg, base, TREE_TYPE (arg), call, jfunc, offset);\n-}\n-\n /* Like detect_type_change but ARG is supposed to be a non-dereferenced pointer\n    SSA name (its dereference will become the base and the offset is assumed to\n    be zero).  */\n \n static bool\n-detect_type_change_ssa (tree arg, gimple call, struct ipa_jump_func *jfunc)\n+detect_type_change_ssa (tree arg, tree comp_type,\n+\t\t\tgimple call, struct ipa_jump_func *jfunc)\n {\n-  tree comp_type;\n-\n   gcc_checking_assert (TREE_CODE (arg) == SSA_NAME);\n   if (!flag_devirtualize\n-      || !POINTER_TYPE_P (TREE_TYPE (arg))\n-      || TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) != RECORD_TYPE)\n+      || !POINTER_TYPE_P (TREE_TYPE (arg)))\n     return false;\n \n-  comp_type = TREE_TYPE (TREE_TYPE (arg));\n   arg = build2 (MEM_REF, ptr_type_node, arg,\n \t\tbuild_int_cst (ptr_type_node, 0));\n \n-  return detect_type_change_1 (arg, arg, comp_type, call, jfunc, 0);\n+  return detect_type_change (arg, arg, comp_type, call, jfunc, 0);\n }\n \n /* Callback of walk_aliased_vdefs.  Flags that it has been invoked to the\n@@ -988,7 +981,8 @@ static void\n compute_complex_assign_jump_func (struct ipa_node_params *info,\n \t\t\t\t  struct param_analysis_info *parms_ainfo,\n \t\t\t\t  struct ipa_jump_func *jfunc,\n-\t\t\t\t  gimple call, gimple stmt, tree name)\n+\t\t\t\t  gimple call, gimple stmt, tree name,\n+\t\t\t\t  tree param_type)\n {\n   HOST_WIDE_INT offset, size, max_size;\n   tree op1, tc_ssa, base, ssa;\n@@ -1030,7 +1024,11 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n \t{\n \t  bool agg_p = parm_ref_data_pass_through_p (&parms_ainfo[index],\n \t\t\t\t\t\t     call, tc_ssa);\n-\t  bool type_p = !detect_type_change_ssa (tc_ssa, call, jfunc);\n+\t  bool type_p = false;\n+\n+\t  if (param_type && POINTER_TYPE_P (param_type))\n+\t    type_p = !detect_type_change_ssa (tc_ssa, TREE_TYPE (param_type),\n+\t\t\t\t\t      call, jfunc);\n \t  if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n \t    ipa_set_jf_simple_pass_through (jfunc, index, agg_p, type_p);\n \t}\n@@ -1057,9 +1055,10 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n \n   /* Dynamic types are changed in constructors and destructors.  */\n   index = ipa_get_param_decl_index (info, SSA_NAME_VAR (ssa));\n-  if (index >= 0)\n+  if (index >= 0 && param_type && POINTER_TYPE_P (param_type))\n     {\n-      bool type_p = !detect_type_change (op1, base, call, jfunc, offset);\n+      bool type_p = !detect_type_change (op1, base, TREE_TYPE (param_type),\n+\t\t\t\t\t call, jfunc, offset);\n       if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n \tipa_set_ancestor_jf (jfunc, offset, TREE_TYPE (op1), index,\n \t\t\t     parm_ref_data_pass_through_p (&parms_ainfo[index],\n@@ -1137,7 +1136,7 @@ static void\n compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n \t\t\t\t    struct param_analysis_info *parms_ainfo,\n \t\t\t\t    struct ipa_jump_func *jfunc,\n-\t\t\t\t    gimple call, gimple phi)\n+\t\t\t\t    gimple call, gimple phi, tree param_type)\n {\n   HOST_WIDE_INT offset;\n   gimple assign, cond;\n@@ -1188,7 +1187,10 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n \treturn;\n     }\n \n-  bool type_p = !detect_type_change (obj, expr, call, jfunc, offset);\n+  bool type_p = false;\n+  if (param_type && POINTER_TYPE_P (param_type))\n+    type_p = !detect_type_change (obj, expr, TREE_TYPE (param_type),\n+\t\t\t\t  call, jfunc, offset);\n   if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n     ipa_set_ancestor_jf (jfunc, offset, TREE_TYPE (obj), index,\n \t\t\t parm_ref_data_pass_through_p (&parms_ainfo[index],\n@@ -1197,18 +1199,24 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n \n /* Given OP which is passed as an actual argument to a called function,\n    determine if it is possible to construct a KNOWN_TYPE jump function for it\n-   and if so, create one and store it to JFUNC.  */\n+   and if so, create one and store it to JFUNC.\n+   EXPECTED_TYPE represents a type the argument should be in  */\n \n static void\n compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc,\n-\t\t\t      gimple call)\n+\t\t\t      gimple call, tree expected_type)\n {\n   HOST_WIDE_INT offset, size, max_size;\n   tree base;\n \n   if (!flag_devirtualize\n       || TREE_CODE (op) != ADDR_EXPR\n-      || TREE_CODE (TREE_TYPE (TREE_TYPE (op))) != RECORD_TYPE)\n+      || TREE_CODE (TREE_TYPE (TREE_TYPE (op))) != RECORD_TYPE\n+      /* Be sure expected_type is polymorphic.  */\n+      || !expected_type\n+      || TREE_CODE (expected_type) != RECORD_TYPE\n+      || !TYPE_BINFO (expected_type)\n+      || !BINFO_VTABLE (TYPE_BINFO (expected_type)))\n     return;\n \n   op = TREE_OPERAND (op, 0);\n@@ -1220,11 +1228,11 @@ compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc,\n       || is_global_var (base))\n     return;\n \n-  if (!TYPE_BINFO (TREE_TYPE (base))\n-      || detect_type_change (op, base, call, jfunc, offset))\n+  if (detect_type_change (op, base, expected_type, call, jfunc, offset))\n     return;\n \n-  ipa_set_jf_known_type (jfunc, offset, TREE_TYPE (base), TREE_TYPE (op));\n+  ipa_set_jf_known_type (jfunc, offset, TREE_TYPE (base),\n+\t\t\t expected_type);\n }\n \n /* Inspect the given TYPE and return true iff it has the same structure (the\n@@ -1495,6 +1503,37 @@ determine_known_aggregate_parts (gimple call, tree arg,\n     }\n }\n \n+static tree\n+ipa_get_callee_param_type (struct cgraph_edge *e, int i)\n+{\n+  int n;\n+  tree type = (e->callee\n+\t       ? TREE_TYPE (e->callee->symbol.decl)\n+\t       : gimple_call_fntype (e->call_stmt));\n+  tree t = TYPE_ARG_TYPES (type);\n+\n+  for (n = 0; n < i; n++)\n+    {\n+      if (!t)\n+        break;\n+      t = TREE_CHAIN (t);\n+    }\n+  if (t)\n+    return TREE_VALUE (t);\n+  if (!e->callee)\n+    return NULL;\n+  t = DECL_ARGUMENTS (e->callee->symbol.decl);\n+  for (n = 0; n < i; n++)\n+    {\n+      if (!t)\n+\treturn NULL;\n+      t = TREE_CHAIN (t);\n+    }\n+  if (t)\n+    return TREE_TYPE (t);\n+  return NULL;\n+}\n+\n /* Compute jump function for all arguments of callsite CS and insert the\n    information in the jump_functions array in the ipa_edge_args corresponding\n    to this callsite.  */\n@@ -1519,6 +1558,7 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n     {\n       struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, n);\n       tree arg = gimple_call_arg (call, n);\n+      tree param_type = ipa_get_callee_param_type (cs, n);\n \n       if (is_gimple_ip_invariant (arg))\n \tipa_set_jf_constant (jfunc, arg, cs);\n@@ -1547,24 +1587,33 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n \t\t  bool agg_p, type_p;\n \t\t  agg_p = parm_ref_data_pass_through_p (&parms_ainfo[index],\n \t\t\t\t\t\t\tcall, arg);\n-\t\t  type_p = !detect_type_change_ssa (arg, call, jfunc);\n+\t\t  if (param_type && POINTER_TYPE_P (param_type))\n+\t\t    type_p = !detect_type_change_ssa (arg, TREE_TYPE (param_type),\n+\t\t\t\t\t\t      call, jfunc);\n+\t\t  else\n+\t\t    type_p = false;\n \t\t  if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n-\t\t    ipa_set_jf_simple_pass_through (jfunc, index, agg_p,\t\t\t\t\t\t    type_p);\n+\t\t    ipa_set_jf_simple_pass_through (jfunc, index, agg_p,\n+\t\t\t\t\t\t    type_p);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      gimple stmt = SSA_NAME_DEF_STMT (arg);\n \t      if (is_gimple_assign (stmt))\n \t\tcompute_complex_assign_jump_func (info, parms_ainfo, jfunc,\n-\t\t\t\t\t\t  call, stmt, arg);\n+\t\t\t\t\t\t  call, stmt, arg, param_type);\n \t      else if (gimple_code (stmt) == GIMPLE_PHI)\n \t\tcompute_complex_ancestor_jump_func (info, parms_ainfo, jfunc,\n-\t\t\t\t\t\t    call, stmt);\n+\t\t\t\t\t\t    call, stmt, param_type);\n \t    }\n \t}\n       else\n-\tcompute_known_type_jump_func (arg, jfunc, call);\n+\tcompute_known_type_jump_func (arg, jfunc, call,\n+\t\t\t\t      param_type\n+\t\t\t\t      && POINTER_TYPE_P (param_type)\n+\t\t\t\t      ? TREE_TYPE (param_type)\n+\t\t\t\t      : NULL);\n \n       if ((jfunc->type != IPA_JF_PASS_THROUGH\n \t      || !ipa_get_jf_pass_through_agg_preserved (jfunc))\n@@ -1908,7 +1957,8 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n       anc_offset = 0;\n       index = ipa_get_param_decl_index (info, SSA_NAME_VAR (obj));\n       gcc_assert (index >= 0);\n-      if (detect_type_change_ssa (obj, call, &jfunc))\n+      if (detect_type_change_ssa (obj, obj_type_ref_class (target),\n+\t\t\t\t  call, &jfunc))\n \treturn;\n     }\n   else\n@@ -1922,7 +1972,8 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n       index = ipa_get_param_decl_index (info,\n \t\t\t\t\tSSA_NAME_VAR (TREE_OPERAND (expr, 0)));\n       gcc_assert (index >= 0);\n-      if (detect_type_change (obj, expr, call, &jfunc, anc_offset))\n+      if (detect_type_change (obj, expr, obj_type_ref_class (target),\n+\t\t\t      call, &jfunc, anc_offset))\n \treturn;\n     }\n \n@@ -2134,7 +2185,7 @@ ipa_intraprocedural_devirtualization (gimple call)\n \n   jfunc.type = IPA_JF_UNKNOWN;\n   compute_known_type_jump_func (OBJ_TYPE_REF_OBJECT (otr), &jfunc,\n-\t\t\t\tcall);\n+\t\t\t\tcall, obj_type_ref_class (otr));\n   if (jfunc.type != IPA_JF_KNOWN_TYPE)\n     return NULL_TREE;\n   binfo = ipa_binfo_from_known_type_jfunc (&jfunc);"}]}