{"sha": "155c9907017722a07f215f57b5717209a9f203f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU1Yzk5MDcwMTc3MjJhMDdmMjE1ZjU3YjU3MTcyMDlhOWYyMDNmNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-12-15T20:51:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-12-15T20:51:39Z"}, "message": "ipa-cp.c (class ipcp_bits_lattice): Formatting fixes.\n\n\t* ipa-cp.c (class ipcp_bits_lattice): Formatting fixes.\n\t(print_ipcp_constant_value): Likewise.\n\t(ipcp_cloning_candidate_p): Likewise.\n\t(ipcp_bits_lattice::get_value_and_mask): Likewise.\n\t(ipcp_bits_lattice::meet_with_1): Likewise.\n\t(ipcp_bits_lattice::meet_with): Likewise.\n\t(initialize_node_lattices): Likewise.\n\t(ipcp_lattice::add_value): Likewise.\n\t(propagate_vals_accross_pass_through): Renamed to ...\n\t(propagate_vals_across_pass_through): ... this function.\n\t(propagate_vals_accross_ancestor): Renamed to ...\n\t(propagate_vals_across_ancestor): ... this.\n\t(propagate_scalar_accross_jump_function): Renamed to ...\n\t(propagate_scalar_across_jump_function): ... this.\n\tAdjust calls to above functions.\n\t(propagate_context_accross_jump_function): Renamed to ...\n\t(propagate_context_across_jump_function): ... this.\n\t(propagate_bits_accross_jump_function): Renamed to ...\n\t(propagate_bits_accross_jump_function): ... this.  Formatting fixes.\n\t(propagate_vr_accross_jump_function): Renamed to ...\n\t(propagate_vr_across_jump_function): ... this.\n\t(merge_agg_lats_step): Formatting fixes.\n\t(propagate_constants_accross_call): Renamed to ...\n\t(propagate_constants_across_call): ... this.  Adjust calls to above\n\tfunctions.\n\t(ipa_get_indirect_edge_target_1): Formatting fixes.\n\t(gather_context_independent_values): Likewise.\n\t(estimate_local_effects): Likewise.\n\t(add_all_node_vals_to_toposort): Likewise.\n\t(propagate_constants_topo): Adjust calls to above functions.\n\t(get_replacement_map): Formatting fixes.\n\t(dump_profile_updates): Likewise.\n\t(update_profiling_info): Likewise.\n\t(update_specialized_profile): Likewise.\n\t(create_specialized_node): Likewise.\n\t(find_more_contexts_for_caller_subset): Likewise.\n\t(decide_whether_version_node): Likewise.\n\t(identify_dead_nodes): Likewise.\n\t(ipcp_decision_stage): Likewise.\n\t(ipcp_store_bits_results): Likewise.\n\t(ipcp_store_vr_results): Likewise.\n\t(ipcp_driver): Likewise.\n\nFrom-SVN: r243725", "tree": {"sha": "d9828ab972dbac3e058419f0644ed0a2c8eff76b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9828ab972dbac3e058419f0644ed0a2c8eff76b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/155c9907017722a07f215f57b5717209a9f203f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155c9907017722a07f215f57b5717209a9f203f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/155c9907017722a07f215f57b5717209a9f203f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155c9907017722a07f215f57b5717209a9f203f6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ce7888dae8bfce7f3049727d31d8b7ae4e83c88d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce7888dae8bfce7f3049727d31d8b7ae4e83c88d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce7888dae8bfce7f3049727d31d8b7ae4e83c88d"}], "stats": {"total": 449, "additions": 245, "deletions": 204}, "files": [{"sha": "57ec02b71bb330eb3ac8e9cd62c17fed07593e8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155c9907017722a07f215f57b5717209a9f203f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155c9907017722a07f215f57b5717209a9f203f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=155c9907017722a07f215f57b5717209a9f203f6", "patch": "@@ -1,3 +1,48 @@\n+2016-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* ipa-cp.c (class ipcp_bits_lattice): Formatting fixes.\n+\t(print_ipcp_constant_value): Likewise.\n+\t(ipcp_cloning_candidate_p): Likewise.\n+\t(ipcp_bits_lattice::get_value_and_mask): Likewise.\n+\t(ipcp_bits_lattice::meet_with_1): Likewise.\n+\t(ipcp_bits_lattice::meet_with): Likewise.\n+\t(initialize_node_lattices): Likewise.\n+\t(ipcp_lattice::add_value): Likewise.\n+\t(propagate_vals_accross_pass_through): Renamed to ...\n+\t(propagate_vals_across_pass_through): ... this function.\n+\t(propagate_vals_accross_ancestor): Renamed to ...\n+\t(propagate_vals_across_ancestor): ... this.\n+\t(propagate_scalar_accross_jump_function): Renamed to ...\n+\t(propagate_scalar_across_jump_function): ... this.\n+\tAdjust calls to above functions.\n+\t(propagate_context_accross_jump_function): Renamed to ...\n+\t(propagate_context_across_jump_function): ... this.\n+\t(propagate_bits_accross_jump_function): Renamed to ...\n+\t(propagate_bits_accross_jump_function): ... this.  Formatting fixes.\n+\t(propagate_vr_accross_jump_function): Renamed to ...\n+\t(propagate_vr_across_jump_function): ... this.\n+\t(merge_agg_lats_step): Formatting fixes.\n+\t(propagate_constants_accross_call): Renamed to ...\n+\t(propagate_constants_across_call): ... this.  Adjust calls to above\n+\tfunctions.\n+\t(ipa_get_indirect_edge_target_1): Formatting fixes.\n+\t(gather_context_independent_values): Likewise.\n+\t(estimate_local_effects): Likewise.\n+\t(add_all_node_vals_to_toposort): Likewise.\n+\t(propagate_constants_topo): Adjust calls to above functions.\n+\t(get_replacement_map): Formatting fixes.\n+\t(dump_profile_updates): Likewise.\n+\t(update_profiling_info): Likewise.\n+\t(update_specialized_profile): Likewise.\n+\t(create_specialized_node): Likewise.\n+\t(find_more_contexts_for_caller_subset): Likewise.\n+\t(decide_whether_version_node): Likewise.\n+\t(identify_dead_nodes): Likewise.\n+\t(ipcp_decision_stage): Likewise.\n+\t(ipcp_store_bits_results): Likewise.\n+\t(ipcp_store_vr_results): Likewise.\n+\t(ipcp_driver): Likewise.\n+\n 2016-12-15  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR preprocessor/78680"}, {"sha": "d3b50524457df5a6cef542ca3e15916f6958ba0a", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 200, "deletions": 204, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155c9907017722a07f215f57b5717209a9f203f6/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155c9907017722a07f215f57b5717209a9f203f6/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=155c9907017722a07f215f57b5717209a9f203f6", "patch": "@@ -61,7 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n    values:\n \n    Pass through - the caller's formal parameter is passed as an actual\n-                  argument, plus an operation on it can be performed.\n+\t\t  argument, plus an operation on it can be performed.\n    Constant - a constant is passed as an actual argument.\n    Unknown - neither of the above.\n \n@@ -268,8 +268,8 @@ class ipcp_bits_lattice\n   bool top_p () { return m_lattice_val == IPA_BITS_UNDEFINED; }\n   bool constant_p () { return m_lattice_val == IPA_BITS_CONSTANT; }\n   bool set_to_bottom ();\n-  bool set_to_constant (widest_int, widest_int); \n- \n+  bool set_to_constant (widest_int, widest_int);\n+\n   widest_int get_value () { return m_value; }\n   widest_int get_mask () { return m_mask; }\n \n@@ -288,9 +288,9 @@ class ipcp_bits_lattice\n      value is known to be constant.  */\n   widest_int m_value, m_mask;\n \n-  bool meet_with_1 (widest_int, widest_int, unsigned); \n+  bool meet_with_1 (widest_int, widest_int, unsigned);\n   void get_value_and_mask (tree, widest_int *, widest_int *);\n-}; \n+};\n \n /* Lattice of value ranges.  */\n \n@@ -424,7 +424,7 @@ static void\n print_ipcp_constant_value (FILE * f, tree v)\n {\n   if (TREE_CODE (v) == ADDR_EXPR\n-\t   && TREE_CODE (TREE_OPERAND (v, 0)) == CONST_DECL)\n+      && TREE_CODE (TREE_OPERAND (v, 0)) == CONST_DECL)\n     {\n       fprintf (f, \"& \");\n       print_generic_expr (f, DECL_INITIAL (TREE_OPERAND (v, 0)), 0);\n@@ -684,18 +684,18 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   if (!opt_for_fn (node->decl, flag_ipa_cp_clone))\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Not considering %s for cloning; \"\n+\tfprintf (dump_file, \"Not considering %s for cloning; \"\n \t\t \"-fipa-cp-clone disabled.\\n\",\n- \t         node->name ());\n+ \t\t node->name ());\n       return false;\n     }\n \n   if (node->optimize_for_size_p ())\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Not considering %s for cloning; \"\n+\tfprintf (dump_file, \"Not considering %s for cloning; \"\n \t\t \"optimizing it for size.\\n\",\n- \t         node->name ());\n+ \t\t node->name ());\n       return false;\n     }\n \n@@ -705,8 +705,8 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   if (inline_summaries->get (node)->self_size < stats.n_calls)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Considering %s for cloning; code might shrink.\\n\",\n- \t         node->name ());\n+\tfprintf (dump_file, \"Considering %s for cloning; code might shrink.\\n\",\n+ \t\t node->name ());\n       return true;\n     }\n \n@@ -722,7 +722,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n \t\t     \"usually called directly.\\n\",\n \t\t     node->name ());\n \t  return true;\n-        }\n+\t}\n     }\n   if (!stats.n_hot_calls)\n     {\n@@ -979,7 +979,7 @@ ipcp_bits_lattice::get_value_and_mask (tree operand, widest_int *valuep, widest_\n \n   if (TREE_CODE (operand) == INTEGER_CST)\n     {\n-      *valuep = wi::to_widest (operand); \n+      *valuep = wi::to_widest (operand);\n       *maskp = 0;\n     }\n   else\n@@ -999,8 +999,8 @@ ipcp_bits_lattice::meet_with_1 (widest_int value, widest_int mask,\n \t\t\t\tunsigned precision)\n {\n   gcc_assert (constant_p ());\n-  \n-  widest_int old_mask = m_mask; \n+\n+  widest_int old_mask = m_mask;\n   m_mask = (m_mask | mask) | (m_value ^ value);\n \n   if (wi::sext (m_mask, precision) == -1)\n@@ -1023,7 +1023,7 @@ ipcp_bits_lattice::meet_with (widest_int value, widest_int mask,\n     {\n       if (wi::sext (mask, precision) == -1)\n \treturn set_to_bottom ();\n-      return set_to_constant (value, mask); \n+      return set_to_constant (value, mask);\n     }\n \n   return meet_with_1 (value, mask, precision);\n@@ -1077,7 +1077,7 @@ ipcp_bits_lattice::meet_with (ipcp_bits_lattice& other, unsigned precision,\n     {\n       if (wi::sext (adjusted_mask, precision) == -1)\n \treturn set_to_bottom ();\n-      return set_to_constant (adjusted_value, adjusted_mask); \n+      return set_to_constant (adjusted_value, adjusted_mask);\n     }\n   else\n     return meet_with_1 (adjusted_value, adjusted_mask, precision);\n@@ -1165,15 +1165,15 @@ initialize_node_lattices (struct cgraph_node *node)\n \tdisable = true;\n     }\n \n-  for (i = 0; i < ipa_get_param_count (info) ; i++)\n+  for (i = 0; i < ipa_get_param_count (info); i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       plats->m_value_range.init ();\n     }\n \n   if (disable || variable)\n     {\n-      for (i = 0; i < ipa_get_param_count (info) ; i++)\n+      for (i = 0; i < ipa_get_param_count (info); i++)\n \t{\n \t  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n \t  if (disable)\n@@ -1196,7 +1196,7 @@ initialize_node_lattices (struct cgraph_node *node)\n \n   for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n     if (ie->indirect_info->polymorphic\n-        && ie->indirect_info->param_index >= 0)\n+\t&& ie->indirect_info->param_index >= 0)\n       {\n \tgcc_checking_assert (ie->indirect_info->param_index >= 0);\n \tipa_get_parm_lattices (info,\n@@ -1509,7 +1509,7 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n \tif (ipa_edge_within_scc (cs))\n \t  {\n \t    ipcp_value_source<valtype> *s;\n-\t    for (s = val->sources; s ; s = s->next)\n+\t    for (s = val->sources; s; s = s->next)\n \t      if (s->cs == cs)\n \t\tbreak;\n \t    if (s)\n@@ -1551,11 +1551,9 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n    is the index of the source parameter.  */\n \n static bool\n-propagate_vals_accross_pass_through (cgraph_edge *cs,\n-\t\t\t\t     ipa_jump_func *jfunc,\n-\t\t\t\t     ipcp_lattice<tree> *src_lat,\n-\t\t\t\t     ipcp_lattice<tree> *dest_lat,\n-\t\t\t\t     int src_idx)\n+propagate_vals_across_pass_through (cgraph_edge *cs, ipa_jump_func *jfunc,\n+\t\t\t\t    ipcp_lattice<tree> *src_lat,\n+\t\t\t\t    ipcp_lattice<tree> *dest_lat, int src_idx)\n {\n   ipcp_value<tree> *src_val;\n   bool ret = false;\n@@ -1585,11 +1583,10 @@ propagate_vals_accross_pass_through (cgraph_edge *cs,\n    is the index of the source parameter.  */\n \n static bool\n-propagate_vals_accross_ancestor (struct cgraph_edge *cs,\n-\t\t\t\t struct ipa_jump_func *jfunc,\n-\t\t\t\t ipcp_lattice<tree> *src_lat,\n-\t\t\t\t ipcp_lattice<tree> *dest_lat,\n-\t\t\t\t int src_idx)\n+propagate_vals_across_ancestor (struct cgraph_edge *cs,\n+\t\t\t\tstruct ipa_jump_func *jfunc,\n+\t\t\t\tipcp_lattice<tree> *src_lat,\n+\t\t\t\tipcp_lattice<tree> *dest_lat, int src_idx)\n {\n   ipcp_value<tree> *src_val;\n   bool ret = false;\n@@ -1614,9 +1611,9 @@ propagate_vals_accross_ancestor (struct cgraph_edge *cs,\n    edge CS and put the values into DEST_LAT.  */\n \n static bool\n-propagate_scalar_accross_jump_function (struct cgraph_edge *cs,\n-\t\t\t\t\tstruct ipa_jump_func *jfunc,\n-\t\t\t\t\tipcp_lattice<tree> *dest_lat)\n+propagate_scalar_across_jump_function (struct cgraph_edge *cs,\n+\t\t\t\t       struct ipa_jump_func *jfunc,\n+\t\t\t\t       ipcp_lattice<tree> *dest_lat)\n {\n   if (dest_lat->bottom)\n     return false;\n@@ -1650,11 +1647,11 @@ propagate_scalar_accross_jump_function (struct cgraph_edge *cs,\n \treturn dest_lat->set_contains_variable ();\n \n       if (jfunc->type == IPA_JF_PASS_THROUGH)\n-\tret = propagate_vals_accross_pass_through (cs, jfunc, src_lat,\n-\t\t\t\t\t\t   dest_lat, src_idx);\n+\tret = propagate_vals_across_pass_through (cs, jfunc, src_lat,\n+\t\t\t\t\t\t  dest_lat, src_idx);\n       else\n-\tret = propagate_vals_accross_ancestor (cs, jfunc, src_lat, dest_lat,\n-\t\t\t\t\t       src_idx);\n+\tret = propagate_vals_across_ancestor (cs, jfunc, src_lat, dest_lat,\n+\t\t\t\t\t      src_idx);\n \n       if (src_lat->contains_variable)\n \tret |= dest_lat->set_contains_variable ();\n@@ -1671,7 +1668,7 @@ propagate_scalar_accross_jump_function (struct cgraph_edge *cs,\n    edge CS and describes argument IDX and put the values into DEST_LAT.  */\n \n static bool\n-propagate_context_accross_jump_function (cgraph_edge *cs,\n+propagate_context_across_jump_function (cgraph_edge *cs,\n \t\t\t  ipa_jump_func *jfunc, int idx,\n \t\t\t  ipcp_lattice<ipa_polymorphic_call_context> *dest_lat)\n {\n@@ -1758,8 +1755,9 @@ propagate_context_accross_jump_function (cgraph_edge *cs,\n    edge cs and update dest_lattice accordingly.  */\n \n bool\n-propagate_bits_accross_jump_function (cgraph_edge *cs, int idx, ipa_jump_func *jfunc,\n-\t\t\t\t      ipcp_bits_lattice *dest_lattice)\n+propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n+\t\t\t\t     ipa_jump_func *jfunc,\n+\t\t\t\t     ipcp_bits_lattice *dest_lattice)\n {\n   if (dest_lattice->bottom_p ())\n     return false;\n@@ -1801,7 +1799,7 @@ propagate_bits_accross_jump_function (cgraph_edge *cs, int idx, ipa_jump_func *j\n \t}\n       else\n \t{\n-\t  code = POINTER_PLUS_EXPR; \n+\t  code = POINTER_PLUS_EXPR;\n \t  src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n \t  unsigned HOST_WIDE_INT offset = ipa_get_jf_ancestor_offset (jfunc) / BITS_PER_UNIT;\n \t  operand = build_int_cstu (size_type_node, offset);\n@@ -1832,9 +1830,9 @@ propagate_bits_accross_jump_function (cgraph_edge *cs, int idx, ipa_jump_func *j\n   else if (jfunc->type == IPA_JF_ANCESTOR)\n     return dest_lattice->set_to_bottom ();\n \n-  else if (jfunc->bits.known) \n+  else if (jfunc->bits.known)\n     return dest_lattice->meet_with (jfunc->bits.value, jfunc->bits.mask, precision);\n-  \n+\n   else\n     return dest_lattice->set_to_bottom ();\n }\n@@ -1844,10 +1842,9 @@ propagate_bits_accross_jump_function (cgraph_edge *cs, int idx, ipa_jump_func *j\n    accordingly.  */\n \n static bool\n-propagate_vr_accross_jump_function (cgraph_edge *cs,\n-\t\t\t\t    ipa_jump_func *jfunc,\n-\t\t\t\t    struct ipcp_param_lattices *dest_plats,\n-\t\t\t\t    tree param_type)\n+propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n+\t\t\t\t   struct ipcp_param_lattices *dest_plats,\n+\t\t\t\t   tree param_type)\n {\n   struct ipcp_param_lattices *src_lats;\n   ipcp_vr_lattice *dest_lat = &dest_plats->m_value_range;\n@@ -1966,8 +1963,8 @@ merge_agg_lats_step (struct ipcp_param_lattices *dest_plats,\n   if (**aglat && (**aglat)->offset == offset)\n     {\n       if ((**aglat)->size != val_size\n-          || ((**aglat)->next\n-              && (**aglat)->next->offset < offset + val_size))\n+\t  || ((**aglat)->next\n+\t      && (**aglat)->next->offset < offset + val_size))\n \t{\n \t  set_agg_lats_to_bottom (dest_plats);\n \t  return false;\n@@ -2090,9 +2087,9 @@ agg_pass_through_permissible_p (struct ipcp_param_lattices *src_plats,\n    edge CS and put the values into DEST_LAT.  */\n \n static bool\n-propagate_aggs_accross_jump_function (struct cgraph_edge *cs,\n-\t\t\t\t      struct ipa_jump_func *jfunc,\n-\t\t\t\t      struct ipcp_param_lattices *dest_plats)\n+propagate_aggs_across_jump_function (struct cgraph_edge *cs,\n+\t\t\t\t     struct ipa_jump_func *jfunc,\n+\t\t\t\t     struct ipcp_param_lattices *dest_plats)\n {\n   bool ret = false;\n \n@@ -2192,7 +2189,7 @@ call_passes_through_thunk_p (cgraph_edge *cs)\n    caller.  */\n \n static bool\n-propagate_constants_accross_call (struct cgraph_edge *cs)\n+propagate_constants_across_call (struct cgraph_edge *cs)\n {\n   struct ipa_node_params *callee_info;\n   enum availability availability;\n@@ -2254,18 +2251,18 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n \tret |= set_all_contains_variable (dest_plats);\n       else\n \t{\n-\t  ret |= propagate_scalar_accross_jump_function (cs, jump_func,\n-\t\t\t\t\t\t\t &dest_plats->itself);\n-\t  ret |= propagate_context_accross_jump_function (cs, jump_func, i,\n-\t\t\t\t\t\t\t  &dest_plats->ctxlat);\n-\t  ret |= propagate_bits_accross_jump_function (cs, i, jump_func,\n-\t\t\t\t\t\t       &dest_plats->bits_lattice);\n-\t  ret |= propagate_aggs_accross_jump_function (cs, jump_func,\n-\t\t\t\t\t\t       dest_plats);\n+\t  ret |= propagate_scalar_across_jump_function (cs, jump_func,\n+\t\t\t\t\t\t\t&dest_plats->itself);\n+\t  ret |= propagate_context_across_jump_function (cs, jump_func, i,\n+\t\t\t\t\t\t\t &dest_plats->ctxlat);\n+\t  ret\n+\t    |= propagate_bits_across_jump_function (cs, i, jump_func,\n+\t\t\t\t\t\t    &dest_plats->bits_lattice);\n+\t  ret |= propagate_aggs_across_jump_function (cs, jump_func,\n+\t\t\t\t\t\t      dest_plats);\n \t  if (opt_for_fn (callee->decl, flag_ipa_vrp))\n-\t    ret |= propagate_vr_accross_jump_function (cs,\n-\t\t\t\t\t\t       jump_func, dest_plats,\n-\t\t\t\t\t\t       param_type);\n+\t    ret |= propagate_vr_across_jump_function (cs, jump_func,\n+\t\t\t\t\t\t      dest_plats, param_type);\n \t  else\n \t    ret |= dest_plats->m_value_range.set_to_bottom ();\n \t}\n@@ -2341,8 +2338,8 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n       else\n \tt = known_csts[param_index];\n \n-      if (t &&\n-\t  TREE_CODE (t) == ADDR_EXPR\n+      if (t\n+\t  && TREE_CODE (t) == ADDR_EXPR\n \t  && TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL)\n \treturn TREE_OPERAND (t, 0);\n       else\n@@ -2378,11 +2375,10 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n   if (!t && known_aggs.length () > (unsigned int) param_index\n       && !ie->indirect_info->by_ref)\n     {\n-       struct ipa_agg_jump_function *agg;\n-       agg = known_aggs[param_index];\n-       t = ipa_find_agg_cst_for_param (agg, known_csts[param_index],\n-\t\t\t\t       ie->indirect_info->offset,\n-\t\t\t\t       true);\n+      struct ipa_agg_jump_function *agg;\n+      agg = known_aggs[param_index];\n+      t = ipa_find_agg_cst_for_param (agg, known_csts[param_index],\n+\t\t\t\t      ie->indirect_info->offset, true);\n     }\n \n   /* If we found the virtual table pointer, lookup the target.  */\n@@ -2408,9 +2404,9 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t\t    return NULL;\n \t\t  target = ipa_impossible_devirt_target (ie, target);\n \t\t}\n-              *speculative = ie->indirect_info->vptr_changed;\n+\t      *speculative = ie->indirect_info->vptr_changed;\n \t      if (!*speculative)\n-\t        return target;\n+\t\treturn target;\n \t    }\n \t}\n     }\n@@ -2702,7 +2698,7 @@ gather_context_independent_values (struct ipa_node_params *info,\n   if (removable_params_cost)\n     *removable_params_cost = 0;\n \n-  for (i = 0; i < count ; i++)\n+  for (i = 0; i < count; i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n@@ -2885,10 +2881,10 @@ estimate_local_effects (struct cgraph_node *node)\n       else if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"   Not cloning for all contexts because \"\n \t\t \"!good_cloning_opportunity_p.\\n\");\n-\t\n+\n     }\n \n-  for (i = 0; i < count ; i++)\n+  for (i = 0; i < count; i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n@@ -2957,7 +2953,7 @@ estimate_local_effects (struct cgraph_node *node)\n       known_contexts[i] = ipa_polymorphic_call_context ();\n     }\n \n-  for (i = 0; i < count ; i++)\n+  for (i = 0; i < count; i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       struct ipa_agg_jump_function *ajf;\n@@ -2993,7 +2989,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t  fprintf (dump_file, \" - estimates for value \");\n \t\t  print_ipcp_constant_value (dump_file, val->value);\n \t\t  fprintf (dump_file, \" for \");\n-\t          ipa_dump_param (dump_file, info, i);\n+\t\t  ipa_dump_param (dump_file, info, i);\n \t\t  fprintf (dump_file, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC\n \t\t\t   \"]: time_benefit: %i, size: %i\\n\",\n \t\t\t   plats->aggs_by_ref ? \"ref \" : \"\",\n@@ -3006,7 +3002,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t}\n     }\n \n-  for (i = 0; i < count ; i++)\n+  for (i = 0; i < count; i++)\n     vec_free (known_aggs[i].items);\n \n   known_csts.release ();\n@@ -3079,7 +3075,7 @@ add_all_node_vals_to_toposort (cgraph_node *node, ipa_topo_info *topo)\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n \n-  for (i = 0; i < count ; i++)\n+  for (i = 0; i < count; i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n@@ -3141,7 +3137,7 @@ propagate_constants_topo (struct ipa_topo_info *topo)\n \t    if (ipa_edge_within_scc (cs))\n \t      {\n \t\tIPA_NODE_REF (v)->node_within_scc = true;\n-\t\tif (propagate_constants_accross_call (cs))\n+\t\tif (propagate_constants_across_call (cs))\n \t\t  push_node_to_stack (topo, cs->callee->function_symbol ());\n \t      }\n \t  v = pop_node_from_stack (topo);\n@@ -3159,7 +3155,7 @@ propagate_constants_topo (struct ipa_topo_info *topo)\n \t    add_all_node_vals_to_toposort (v, topo);\n \t    for (cs = v->callees; cs; cs = cs->next_callee)\n \t      if (!ipa_edge_within_scc (cs))\n-\t\tpropagate_constants_accross_call (cs);\n+\t\tpropagate_constants_across_call (cs);\n \t  }\n       cycle_nodes.release ();\n     }\n@@ -3589,7 +3585,7 @@ get_replacement_map (struct ipa_node_params *info, tree value, int parm_num)\n     {\n       fprintf (dump_file, \"    replacing \");\n       ipa_dump_param (dump_file, info, parm_num);\n-  \n+\n       fprintf (dump_file, \" with const \");\n       print_generic_expr (dump_file, value, 0);\n       fprintf (dump_file, \"\\n\");\n@@ -3613,14 +3609,14 @@ dump_profile_updates (struct cgraph_node *orig_node,\n \n   fprintf (dump_file, \"    setting count of the specialized node to \"\n \t   HOST_WIDE_INT_PRINT_DEC \"\\n\", (HOST_WIDE_INT) new_node->count);\n-  for (cs = new_node->callees; cs ; cs = cs->next_callee)\n+  for (cs = new_node->callees; cs; cs = cs->next_callee)\n     fprintf (dump_file, \"      edge to %s has count \"\n \t     HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t     cs->callee->name (), (HOST_WIDE_INT) cs->count);\n \n   fprintf (dump_file, \"    setting count of the original node to \"\n \t   HOST_WIDE_INT_PRINT_DEC \"\\n\", (HOST_WIDE_INT) orig_node->count);\n-  for (cs = orig_node->callees; cs ; cs = cs->next_callee)\n+  for (cs = orig_node->callees; cs; cs = cs->next_callee)\n     fprintf (dump_file, \"      edge to %s is left with \"\n \t     HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t     cs->callee->name (), (HOST_WIDE_INT) cs->count);\n@@ -3671,18 +3667,18 @@ update_profiling_info (struct cgraph_node *orig_node,\n   remainder = orig_node_count - new_sum;\n   orig_node->count = remainder;\n \n-  for (cs = new_node->callees; cs ; cs = cs->next_callee)\n+  for (cs = new_node->callees; cs; cs = cs->next_callee)\n     if (cs->frequency)\n       cs->count = apply_probability (cs->count,\n-                                     GCOV_COMPUTE_SCALE (new_sum,\n-                                                         orig_node_count));\n+\t\t\t\t     GCOV_COMPUTE_SCALE (new_sum,\n+\t\t\t\t\t\t\t orig_node_count));\n     else\n       cs->count = 0;\n \n-  for (cs = orig_node->callees; cs ; cs = cs->next_callee)\n+  for (cs = orig_node->callees; cs; cs = cs->next_callee)\n     cs->count = apply_probability (cs->count,\n-                                   GCOV_COMPUTE_SCALE (remainder,\n-                                                       orig_node_count));\n+\t\t\t\t   GCOV_COMPUTE_SCALE (remainder,\n+\t\t\t\t\t\t       orig_node_count));\n \n   if (dump_file)\n     dump_profile_updates (orig_node, new_node);\n@@ -3712,19 +3708,19 @@ update_specialized_profile (struct cgraph_node *new_node,\n   new_node->count += redirected_sum;\n   orig_node->count -= redirected_sum;\n \n-  for (cs = new_node->callees; cs ; cs = cs->next_callee)\n+  for (cs = new_node->callees; cs; cs = cs->next_callee)\n     if (cs->frequency)\n       cs->count += apply_probability (cs->count,\n-                                      GCOV_COMPUTE_SCALE (redirected_sum,\n-                                                          new_node_count));\n+\t\t\t\t      GCOV_COMPUTE_SCALE (redirected_sum,\n+\t\t\t\t\t\t\t  new_node_count));\n     else\n       cs->count = 0;\n \n-  for (cs = orig_node->callees; cs ; cs = cs->next_callee)\n+  for (cs = orig_node->callees; cs; cs = cs->next_callee)\n     {\n       gcov_type dec = apply_probability (cs->count,\n-                                         GCOV_COMPUTE_SCALE (redirected_sum,\n-                                                             orig_node_count));\n+\t\t\t\t\t GCOV_COMPUTE_SCALE (redirected_sum,\n+\t\t\t\t\t\t\t     orig_node_count));\n       if (dec < cs->count)\n \tcs->count -= dec;\n       else\n@@ -3773,7 +3769,7 @@ create_specialized_node (struct cgraph_node *node,\n \tfprintf (dump_file, \"      cannot change function signature\\n\");\n     }\n \n-  for (i = 0; i < count ; i++)\n+  for (i = 0; i < count; i++)\n     {\n       tree t = known_csts[i];\n       if (t)\n@@ -3799,7 +3795,7 @@ create_specialized_node (struct cgraph_node *node,\n \t       new_node->name (), new_node->order);\n       if (known_contexts.exists ())\n \t{\n-\t  for (i = 0; i < count ; i++)\n+\t  for (i = 0; i < count; i++)\n \t    if (!known_contexts[i].useless_p ())\n \t      {\n \t\tfprintf (dump_file, \"     known ctx %i is \", i);\n@@ -3833,7 +3829,7 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n \n-  for (i = 0; i < count ; i++)\n+  for (i = 0; i < count; i++)\n     {\n       struct cgraph_edge *cs;\n       tree newval = NULL_TREE;\n@@ -3848,15 +3844,15 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t  struct ipa_jump_func *jump_func;\n \t  tree t;\n \n-          if (i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n+\t  if (i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n \t      || (i == 0\n \t\t  && call_passes_through_thunk_p (cs))\n \t      || (!cs->callee->instrumentation_clone\n \t\t  && cs->callee->function_symbol ()->instrumentation_clone))\n-            {\n-              newval = NULL_TREE;\n-              break;\n-            }\n+\t    {\n+\t      newval = NULL_TREE;\n+\t      break;\n+\t    }\n \t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n \t  t = ipa_value_from_jfunc (IPA_NODE_REF (cs->caller), jump_func);\n \t  if (!t\n@@ -3901,7 +3897,7 @@ find_more_contexts_for_caller_subset (cgraph_node *node,\n   ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n \n-  for (i = 0; i < count ; i++)\n+  for (i = 0; i < count; i++)\n     {\n       cgraph_edge *cs;\n \n@@ -4235,7 +4231,7 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n \tcount = c;\n     }\n \n-  for (i = 0; i < count ; i++)\n+  for (i = 0; i < count; i++)\n     {\n       struct cgraph_edge *cs;\n       vec<ipa_agg_jf_item> inter = vNULL;\n@@ -4646,7 +4642,7 @@ decide_whether_version_node (struct cgraph_node *node)\n \t\t\t\t  info->do_clone_for_all_contexts ? &known_aggs\n \t\t\t\t  : NULL, NULL);\n \n-  for (i = 0; i < count ;i++)\n+  for (i = 0; i < count;i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n@@ -4685,7 +4681,7 @@ decide_whether_version_node (struct cgraph_node *node)\n \t\t\t\t       known_contexts);\n \t}\n \n-        info = IPA_NODE_REF (node);\n+\tinfo = IPA_NODE_REF (node);\n     }\n \n   if (info->do_clone_for_all_contexts)\n@@ -4711,7 +4707,7 @@ decide_whether_version_node (struct cgraph_node *node)\n       info = IPA_NODE_REF (node);\n       info->do_clone_for_all_contexts = false;\n       IPA_NODE_REF (clone)->is_all_contexts_clone = true;\n-      for (i = 0; i < count ; i++)\n+      for (i = 0; i < count; i++)\n \tvec_free (known_aggs[i].items);\n       known_aggs.release ();\n       ret = true;\n@@ -4754,7 +4750,7 @@ spread_undeadness (struct cgraph_node *node)\n \n static bool\n has_undead_caller_from_outside_scc_p (struct cgraph_node *node,\n-\t\t\t\t     void *data ATTRIBUTE_UNUSED)\n+\t\t\t\t      void *data ATTRIBUTE_UNUSED)\n {\n   struct cgraph_edge *cs;\n \n@@ -4777,19 +4773,19 @@ static void\n identify_dead_nodes (struct cgraph_node *node)\n {\n   struct cgraph_node *v;\n-  for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n+  for (v = node; v; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n     if (v->local.local\n \t&& !v->call_for_symbol_thunks_and_aliases\n \t     (has_undead_caller_from_outside_scc_p, NULL, true))\n       IPA_NODE_REF (v)->node_dead = 1;\n \n-  for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n+  for (v = node; v; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n     if (!IPA_NODE_REF (v)->node_dead)\n       spread_undeadness (v);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n+      for (v = node; v; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n \tif (IPA_NODE_REF (v)->node_dead)\n \t  fprintf (dump_file, \"  Marking node as dead: %s/%i.\\n\",\n \t\t   v->name (), v->order);\n@@ -4816,7 +4812,7 @@ ipcp_decision_stage (struct ipa_topo_info *topo)\n \t{\n \t  struct cgraph_node *v;\n \t  iterate = false;\n-\t  for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n+\t  for (v = node; v; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n \t    if (v->has_gimple_body_p ()\n \t\t&& ipcp_versionable_function_p (v))\n \t      iterate |= decide_whether_version_node (v);\n@@ -4865,42 +4861,42 @@ ipcp_store_bits_results (void)\n \t    }\n \t}\n \n-    if (!found_useful_result)\n-      continue;\n+      if (!found_useful_result)\n+\tcontinue;\n \n-    ipcp_grow_transformations_if_necessary ();\n-    ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n-    vec_safe_reserve_exact (ts->bits, count);\n+      ipcp_grow_transformations_if_necessary ();\n+      ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n+      vec_safe_reserve_exact (ts->bits, count);\n \n-    for (unsigned i = 0; i < count; i++)\n-      {\n-\tipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-\tipa_bits bits_jfunc;\t\t\t \n+      for (unsigned i = 0; i < count; i++)\n+\t{\n+\t  ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+\t  ipa_bits bits_jfunc;\n \n-\tif (plats->bits_lattice.constant_p ())\n-\t  {\n-\t    bits_jfunc.known = true;\n-\t    bits_jfunc.value = plats->bits_lattice.get_value ();\n-\t    bits_jfunc.mask = plats->bits_lattice.get_mask ();\n-\t  }\n-\telse\n-\t  bits_jfunc.known = false;\n+\t  if (plats->bits_lattice.constant_p ())\n+\t    {\n+\t      bits_jfunc.known = true;\n+\t      bits_jfunc.value = plats->bits_lattice.get_value ();\n+\t      bits_jfunc.mask = plats->bits_lattice.get_mask ();\n+\t    }\n+\t  else\n+\t    bits_jfunc.known = false;\n \n-\tts->bits->quick_push (bits_jfunc);\n-\tif (!dump_file || !bits_jfunc.known)\n-\t  continue;\n-\tif (!dumped_sth)\n-\t  {\n-\t    fprintf (dump_file, \"Propagated bits info for function %s/%i:\\n\",\n-\t\t\t\tnode->name (), node->order);\n-\t    dumped_sth = true;\n-\t  }\n-\tfprintf (dump_file, \" param %i: value = \", i);\n-\tprint_hex (bits_jfunc.value, dump_file);\n-\tfprintf (dump_file, \", mask = \");\n-\tprint_hex (bits_jfunc.mask, dump_file);\n-\tfprintf (dump_file, \"\\n\");\n-      }\n+\t  ts->bits->quick_push (bits_jfunc);\n+\t  if (!dump_file || !bits_jfunc.known)\n+\t    continue;\n+\t  if (!dumped_sth)\n+\t    {\n+\t      fprintf (dump_file, \"Propagated bits info for function %s/%i:\\n\",\n+\t\t       node->name (), node->order);\n+\t      dumped_sth = true;\n+\t    }\n+\t  fprintf (dump_file, \" param %i: value = \", i);\n+\t  print_hex (bits_jfunc.value, dump_file);\n+\t  fprintf (dump_file, \", mask = \");\n+\t  print_hex (bits_jfunc.mask, dump_file);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n     }\n }\n \n@@ -4913,62 +4909,62 @@ ipcp_store_vr_results (void)\n   cgraph_node *node;\n \n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n-  {\n-    ipa_node_params *info = IPA_NODE_REF (node);\n-    bool found_useful_result = false;\n+    {\n+      ipa_node_params *info = IPA_NODE_REF (node);\n+      bool found_useful_result = false;\n \n-    if (!opt_for_fn (node->decl, flag_ipa_vrp))\n-      {\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"Not considering %s for VR discovery \"\n-\t\t   \"and propagate; -fipa-ipa-vrp: disabled.\\n\",\n-\t\t   node->name ());\n-\tcontinue;\n-      }\n+      if (!opt_for_fn (node->decl, flag_ipa_vrp))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not considering %s for VR discovery \"\n+\t\t     \"and propagate; -fipa-ipa-vrp: disabled.\\n\",\n+\t\t     node->name ());\n+\t  continue;\n+\t}\n \n-   if (info->ipcp_orig_node)\n-      info = IPA_NODE_REF (info->ipcp_orig_node);\n+      if (info->ipcp_orig_node)\n+\tinfo = IPA_NODE_REF (info->ipcp_orig_node);\n \n-   unsigned count = ipa_get_param_count (info);\n-   for (unsigned i = 0; i < count ; i++)\n-     {\n-       ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-       if (!plats->m_value_range.bottom_p ()\n-\t   && !plats->m_value_range.top_p ())\n-\t {\n-\t   found_useful_result = true;\n-\t   break;\n-\t }\n-     }\n-   if (!found_useful_result)\n-     continue;\n+      unsigned count = ipa_get_param_count (info);\n+      for (unsigned i = 0; i < count; i++)\n+\t{\n+\t  ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+\t  if (!plats->m_value_range.bottom_p ()\n+\t      && !plats->m_value_range.top_p ())\n+\t    {\n+\t      found_useful_result = true;\n+\t      break;\n+\t    }\n+\t}\n+      if (!found_useful_result)\n+\tcontinue;\n \n-   ipcp_grow_transformations_if_necessary ();\n-   ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n-   vec_safe_reserve_exact (ts->m_vr, count);\n+      ipcp_grow_transformations_if_necessary ();\n+      ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n+      vec_safe_reserve_exact (ts->m_vr, count);\n \n-   for (unsigned i = 0; i < count ; i++)\n-     {\n-       ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-       ipa_vr vr;\n+      for (unsigned i = 0; i < count; i++)\n+\t{\n+\t  ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+\t  ipa_vr vr;\n \n-       if (!plats->m_value_range.bottom_p ()\n-\t   && !plats->m_value_range.top_p ())\n-\t {\n-\t   vr.known = true;\n-\t   vr.type = plats->m_value_range.m_vr.type;\n-\t   vr.min = plats->m_value_range.m_vr.min;\n-\t   vr.max = plats->m_value_range.m_vr.max;\n-\t }\n-       else\n-\t {\n-\t   vr.known = false;\n-\t   vr.type = VR_VARYING;\n-\t   vr.min = vr.max = wi::zero (INT_TYPE_SIZE);\n-\t }\n-       ts->m_vr->quick_push (vr);\n-     }\n-  }\n+\t  if (!plats->m_value_range.bottom_p ()\n+\t      && !plats->m_value_range.top_p ())\n+\t    {\n+\t      vr.known = true;\n+\t      vr.type = plats->m_value_range.m_vr.type;\n+\t      vr.min = plats->m_value_range.m_vr.min;\n+\t      vr.max = plats->m_value_range.m_vr.max;\n+\t    }\n+\t  else\n+\t    {\n+\t      vr.known = false;\n+\t      vr.type = VR_VARYING;\n+\t      vr.min = vr.max = wi::zero (INT_TYPE_SIZE);\n+\t    }\n+\t  ts->m_vr->quick_push (vr);\n+\t}\n+    }\n }\n \n /* The IPCP driver.  */\n@@ -4983,16 +4979,16 @@ ipcp_driver (void)\n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n   grow_edge_clone_vectors ();\n-  edge_duplication_hook_holder =\n-    symtab->add_edge_duplication_hook (&ipcp_edge_duplication_hook, NULL);\n-  edge_removal_hook_holder =\n-    symtab->add_edge_removal_hook (&ipcp_edge_removal_hook, NULL);\n+  edge_duplication_hook_holder\n+    = symtab->add_edge_duplication_hook (&ipcp_edge_duplication_hook, NULL);\n+  edge_removal_hook_holder\n+    = symtab->add_edge_removal_hook (&ipcp_edge_removal_hook, NULL);\n \n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nIPA structures before propagation:\\n\");\n       if (dump_flags & TDF_DETAILS)\n-        ipa_print_all_params (dump_file);\n+\tipa_print_all_params (dump_file);\n       ipa_print_all_jump_functions (dump_file);\n     }\n "}]}