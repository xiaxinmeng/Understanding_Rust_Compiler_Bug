{"sha": "0b27284847b2547bcd4e8fce52ad0e906563af4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIyNzI4NDg0N2IyNTQ3YmNkNGU4ZmNlNTJhZDBlOTA2NTYzYWY0Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-12-12T18:22:13Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-12-12T18:22:13Z"}, "message": "re PR tree-optimization/50569 (unaligned memory accesses generated for memcpy)\n\n\tPR tree-optimization/50569\n\t* tree-sra.c (build_ref_for_model): Replicate a chain of COMPONENT_REFs\n\tin the expression of MODEL instead of just the last one.\n\nFrom-SVN: r182252", "tree": {"sha": "1701bcdbcbbe05ab413e97138bebf0988508e893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1701bcdbcbbe05ab413e97138bebf0988508e893"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b27284847b2547bcd4e8fce52ad0e906563af4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b27284847b2547bcd4e8fce52ad0e906563af4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b27284847b2547bcd4e8fce52ad0e906563af4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b27284847b2547bcd4e8fce52ad0e906563af4b/comments", "author": null, "committer": null, "parents": [{"sha": "f7c8a2da7791fefb361db7f4e1a25cecb0a2b7e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7c8a2da7791fefb361db7f4e1a25cecb0a2b7e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7c8a2da7791fefb361db7f4e1a25cecb0a2b7e8"}], "stats": {"total": 113, "additions": 94, "deletions": 19}, "files": [{"sha": "0d1dea37ae03f38dd9f14b35c377763bb36f57b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27284847b2547bcd4e8fce52ad0e906563af4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27284847b2547bcd4e8fce52ad0e906563af4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b27284847b2547bcd4e8fce52ad0e906563af4b", "patch": "@@ -1,7 +1,12 @@\n+2011-12-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR tree-optimization/50569\n+\t* tree-sra.c (build_ref_for_model): Replicate a chain of COMPONENT_REFs\n+\tin the expression of MODEL instead of just the last one.\n+\n 2011-12-12  Dmitry Vyukov  <dvyukov@google.com>\n \n-\t* cgraphunit.c (init_lowered_empty_function):\n-\tFix flags for new edges.\n+\t* cgraphunit.c (init_lowered_empty_function): Fix flags for new edges.\n \n 2011-12-12  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "dbe8ac619f5adfe78cf69a2a5dfba09e4b9fd51d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27284847b2547bcd4e8fce52ad0e906563af4b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27284847b2547bcd4e8fce52ad0e906563af4b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b27284847b2547bcd4e8fce52ad0e906563af4b", "patch": "@@ -1,3 +1,7 @@\n+2011-12-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.c-torture/execute/20111212-1.c: New test.\n+\n 2011-12-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR testsuite/51511"}, {"sha": "c46e6e94636efbaae07f115768b10d839fd9a2f0", "filename": "gcc/testsuite/gcc.c-torture/execute/20111212-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27284847b2547bcd4e8fce52ad0e906563af4b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20111212-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27284847b2547bcd4e8fce52ad0e906563af4b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20111212-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20111212-1.c?ref=0b27284847b2547bcd4e8fce52ad0e906563af4b", "patch": "@@ -0,0 +1,34 @@\n+/* PR tree-optimization/50569 */\n+/* Reported by Paul Koning <pkoning@gcc.gnu.org> */\n+/* Reduced testcase by Mikael Pettersson <mikpe@it.uu.se> */\n+\n+struct event {\n+    struct {\n+\tunsigned int sec;\n+    } sent __attribute__((packed));\n+};\n+\n+void __attribute__((noinline,noclone)) frob_entry(char *buf)\n+{\n+    struct event event;\n+\n+    __builtin_memcpy(&event, buf, sizeof(event));\n+    if (event.sent.sec < 64) {\n+\tevent.sent.sec = -1U;\n+\t__builtin_memcpy(buf, &event, sizeof(event));\n+    }\n+}\n+\n+int main(void)\n+{\n+    union {\n+\tchar buf[1 + sizeof(struct event)];\n+\tint align;\n+    } u;\n+\n+    __builtin_memset(&u, 0, sizeof u);\n+\n+    frob_entry(&u.buf[1]);\n+\n+    return 0;\n+}"}, {"sha": "b921c76377397b5447e67a205d6fa3712845c57b", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b27284847b2547bcd4e8fce52ad0e906563af4b/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b27284847b2547bcd4e8fce52ad0e906563af4b/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=0b27284847b2547bcd4e8fce52ad0e906563af4b", "patch": "@@ -1492,33 +1492,65 @@ build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n   return fold_build2_loc (loc, MEM_REF, exp_type, base, off);\n }\n \n+DEF_VEC_ALLOC_P_STACK (tree);\n+#define VEC_tree_stack_alloc(alloc) VEC_stack_alloc (tree, alloc)\n+\n /* Construct a memory reference to a part of an aggregate BASE at the given\n-   OFFSET and of the same type as MODEL.  In case this is a reference to a\n-   component, the function will replicate the last COMPONENT_REF of model's\n-   expr to access it.  GSI and INSERT_AFTER have the same meaning as in\n-   build_ref_for_offset.  */\n+   OFFSET and of the type of MODEL.  In case this is a chain of references\n+   to component, the function will replicate the chain of COMPONENT_REFs of\n+   the expression of MODEL to access it.  GSI and INSERT_AFTER have the same\n+   meaning as in build_ref_for_offset.  */\n \n static tree\n build_ref_for_model (location_t loc, tree base, HOST_WIDE_INT offset,\n \t\t     struct access *model, gimple_stmt_iterator *gsi,\n \t\t     bool insert_after)\n {\n+  tree type = model->type, t;\n+  VEC(tree,stack) *cr_stack = NULL;\n+\n   if (TREE_CODE (model->expr) == COMPONENT_REF)\n     {\n-      tree t, exp_type, fld = TREE_OPERAND (model->expr, 1);\n-      tree cr_offset = component_ref_field_offset (model->expr);\n-\n-      gcc_assert (cr_offset && host_integerp (cr_offset, 1));\n-      offset -= TREE_INT_CST_LOW (cr_offset) * BITS_PER_UNIT;\n-      offset -= TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (fld));\n-      exp_type = TREE_TYPE (TREE_OPERAND (model->expr, 0));\n-      t = build_ref_for_offset (loc, base, offset, exp_type, gsi, insert_after);\n-      return fold_build3_loc (loc, COMPONENT_REF, TREE_TYPE (fld), t, fld,\n-\t\t\t      TREE_OPERAND (model->expr, 2));\n+      tree expr = model->expr;\n+\n+      /* Create a stack of the COMPONENT_REFs so later we can walk them in\n+\t order from inner to outer.  */\n+      cr_stack = VEC_alloc (tree, stack, 6);\n+\n+      do {\n+\ttree field = TREE_OPERAND (expr, 1);\n+\ttree cr_offset = component_ref_field_offset (expr);\n+\tgcc_assert (cr_offset && host_integerp (cr_offset, 1));\n+\n+\toffset -= TREE_INT_CST_LOW (cr_offset) * BITS_PER_UNIT;\n+\toffset -= TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field));\n+\n+\tVEC_safe_push (tree, stack, cr_stack, expr);\n+\n+\texpr = TREE_OPERAND (expr, 0);\n+\ttype = TREE_TYPE (expr);\n+      } while (TREE_CODE (expr) == COMPONENT_REF);\n     }\n-  else\n-    return build_ref_for_offset (loc, base, offset, model->type,\n-\t\t\t\t gsi, insert_after);\n+\n+  t = build_ref_for_offset (loc, base, offset, type, gsi, insert_after);\n+\n+  if (TREE_CODE (model->expr) == COMPONENT_REF)\n+    {\n+      unsigned i;\n+      tree expr;\n+\n+      /* Now replicate the chain of COMPONENT_REFs from inner to outer.  */\n+      FOR_EACH_VEC_ELT_REVERSE (tree, cr_stack, i, expr)\n+\t{\n+\t  tree field = TREE_OPERAND (expr, 1);\n+\t  t = fold_build3_loc (loc, COMPONENT_REF, TREE_TYPE (field), t, field,\n+\t\t\t       TREE_OPERAND (expr, 2));\n+\t}\n+\n+      VEC_free (tree, stack, cr_stack);\n+    }\n+\n+  return t;\n }\n \n /* Construct a memory reference consisting of component_refs and array_refs to"}]}