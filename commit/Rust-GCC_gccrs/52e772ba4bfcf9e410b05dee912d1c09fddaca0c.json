{"sha": "52e772ba4bfcf9e410b05dee912d1c09fddaca0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJlNzcyYmE0YmZjZjllNDEwYjA1ZGVlOTEyZDFjMDlmZGRhY2EwYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-08-26T21:57:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-08-26T21:57:25Z"}, "message": "re PR rtl-optimization/23560 (Strength-reduction breaking unsigned COMPARE)\n\n\tPR rtl-opt/23560\n\t* loop.c (biased_biv_may_wrap_p): New.\n\t(maybe_eliminate_biv_1): Use it to suppress non-equality\n\tcomparison transformations.  Delete disabled code.\n\nFrom-SVN: r103539", "tree": {"sha": "174fae0bf578b77b0abb8b4b98a3e5badcc030f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/174fae0bf578b77b0abb8b4b98a3e5badcc030f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52e772ba4bfcf9e410b05dee912d1c09fddaca0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52e772ba4bfcf9e410b05dee912d1c09fddaca0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52e772ba4bfcf9e410b05dee912d1c09fddaca0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52e772ba4bfcf9e410b05dee912d1c09fddaca0c/comments", "author": null, "committer": null, "parents": [{"sha": "12d347da5ce883030d292c536990c1cd38f327f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12d347da5ce883030d292c536990c1cd38f327f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12d347da5ce883030d292c536990c1cd38f327f8"}], "stats": {"total": 289, "additions": 107, "deletions": 182}, "files": [{"sha": "53d7aa05c83b294013ea3e3853bdaf8188acdef4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52e772ba4bfcf9e410b05dee912d1c09fddaca0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52e772ba4bfcf9e410b05dee912d1c09fddaca0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52e772ba4bfcf9e410b05dee912d1c09fddaca0c", "patch": "@@ -1,3 +1,10 @@\n+2005-08-26  Richard Henderson  <rth@redhat.com>\n+\n+\tPR rtl-opt/23560\n+\t* loop.c (biased_biv_may_wrap_p): New.\n+\t(maybe_eliminate_biv_1): Use it to suppress non-equality\n+\tcomparison transformations.  Delete disabled code.\n+\n 2005-08-26  Ian Lance Taylor  <ian@airs.com>\n \n \t* combine.c (make_extraction): Avoid reference outside object."}, {"sha": "8142f63f5afb035bbeb1f5125e3a4b0e60a3fdba", "filename": "gcc/loop.c", "status": "modified", "additions": 100, "deletions": 182, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52e772ba4bfcf9e410b05dee912d1c09fddaca0c/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52e772ba4bfcf9e410b05dee912d1c09fddaca0c/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=52e772ba4bfcf9e410b05dee912d1c09fddaca0c", "patch": "@@ -8800,6 +8800,63 @@ biv_fits_mode_p (const struct loop *loop, struct iv_class *bl,\n }\n \n \n+/* Return false iff it is provable that biv BL plus BIAS will not wrap\n+   at any point in its update sequence.  Note that at the rtl level we\n+   may not have information about the signedness of BL; in that case,\n+   check for both signed and unsigned overflow.  */\n+\n+static bool\n+biased_biv_may_wrap_p (const struct loop *loop, struct iv_class *bl,\n+\t\t       unsigned HOST_WIDE_INT bias)\n+{\n+  HOST_WIDE_INT incr;\n+  bool check_signed, check_unsigned;\n+  enum machine_mode mode;\n+\n+  /* If the increment is not monotonic, we'd have to check separately\n+     at each increment step.  Not Worth It.  */\n+  incr = get_monotonic_increment (bl);\n+  if (incr == 0)\n+    return true;\n+\n+  /* If this biv is the loop iteration variable, then we may be able to\n+     deduce a sign based on the loop condition.  */\n+  /* ??? This is not 100% reliable; consider an unsigned biv that is cast\n+     to signed for the comparison.  However, this same bug appears all\n+     through loop.c.  */\n+  check_signed = check_unsigned = true;\n+  if (bl->biv->src_reg == LOOP_INFO (loop)->iteration_var)\n+    {\n+      switch (LOOP_INFO (loop)->comparison_code)\n+\t{\n+\tcase GTU: case GEU: case LTU: case LEU:\n+\t  check_signed = false;\n+\t  break;\n+\tcase GT: case GE: case LT: case LE:\n+\t  check_unsigned = false;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  mode = GET_MODE (bl->biv->src_reg);\n+\n+  if (check_unsigned\n+      && !biased_biv_fits_mode_p (loop, bl, incr, mode, bias))\n+    return true;\n+\n+  if (check_signed)\n+    {\n+      bias += (GET_MODE_MASK (mode) >> 1) + 1;\n+      if (!biased_biv_fits_mode_p (loop, bl, incr, mode, bias))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+\n /* Given that X is an extension or truncation of BL, return true\n    if it is unaffected by overflow.  LOOP is the loop to which\n    BL belongs and INCR is its per-iteration increment.  */\n@@ -10210,195 +10267,56 @@ maybe_eliminate_biv_1 (const struct loop *loop, rtx x, rtx insn,\n       else\n \tbreak;\n \n-      if (CONSTANT_P (arg))\n-\t{\n-\t  /* First try to replace with any giv that has constant positive\n-\t     mult_val and constant add_val.  We might be able to support\n-\t     negative mult_val, but it seems complex to do it in general.  */\n-\n-\t  for (v = bl->giv; v; v = v->next_iv)\n-\t    if (GET_CODE (v->mult_val) == CONST_INT\n-\t\t&& INTVAL (v->mult_val) > 0\n-\t\t&& (GET_CODE (v->add_val) == SYMBOL_REF\n-\t\t    || GET_CODE (v->add_val) == LABEL_REF\n-\t\t    || GET_CODE (v->add_val) == CONST\n-\t\t    || (REG_P (v->add_val)\n-\t\t\t&& REG_POINTER (v->add_val)))\n-\t\t&& ! v->ignore && ! v->maybe_dead && v->always_computable\n-\t\t&& v->mode == mode)\n-\t      {\n-\t\tif (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n-\t\t  continue;\n-\n-\t\t/* Don't eliminate if the linear combination that makes up\n-\t\t   the giv overflows when it is applied to ARG.  */\n-\t\tif (GET_CODE (arg) == CONST_INT)\n-\t\t  {\n-\t\t    rtx add_val;\n-\n-\t\t    if (GET_CODE (v->add_val) == CONST_INT)\n-\t\t      add_val = v->add_val;\n-\t\t    else\n-\t\t      add_val = const0_rtx;\n-\n-\t\t    if (const_mult_add_overflow_p (arg, v->mult_val,\n-\t\t\t\t\t\t   add_val, mode, 1))\n-\t\t      continue;\n-\t\t  }\n-\n-\t\tif (! eliminate_p)\n-\t\t  return 1;\n-\n-\t\t/* Replace biv with the giv's reduced reg.  */\n-\t\tvalidate_change (insn, &XEXP (x, 1 - arg_operand), v->new_reg, 1);\n-\n-\t\t/* If all constants are actually constant integers and\n-\t\t   the derived constant can be directly placed in the COMPARE,\n-\t\t   do so.  */\n-\t\tif (GET_CODE (arg) == CONST_INT\n-\t\t    && GET_CODE (v->add_val) == CONST_INT)\n-\t\t  {\n-\t\t    tem = expand_mult_add (arg, NULL_RTX, v->mult_val,\n-\t\t\t\t\t   v->add_val, mode, 1);\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    /* Otherwise, load it into a register.  */\n-\t\t    tem = gen_reg_rtx (mode);\n-\t\t    loop_iv_add_mult_emit_before (loop, arg,\n-\t\t\t\t\t\t  v->mult_val, v->add_val,\n-\t\t\t\t\t\t  tem, where_bb, where_insn);\n-\t\t  }\n-\n-\t\tvalidate_change (insn, &XEXP (x, arg_operand), tem, 1);\n-\n-\t\tif (apply_change_group ())\n-\t\t  return 1;\n-\t      }\n-\n-\t  /* Look for giv with positive constant mult_val and nonconst add_val.\n-\t     Insert insns to calculate new compare value.\n-\t     ??? Turn this off due to possible overflow.  */\n-\n-\t  for (v = bl->giv; v; v = v->next_iv)\n-\t    if (GET_CODE (v->mult_val) == CONST_INT\n-\t\t&& INTVAL (v->mult_val) > 0\n-\t\t&& ! v->ignore && ! v->maybe_dead && v->always_computable\n-\t\t&& v->mode == mode\n-\t\t&& 0)\n-\t      {\n-\t\trtx tem;\n-\n-\t\tif (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n-\t\t  continue;\n-\n-\t\tif (! eliminate_p)\n-\t\t  return 1;\n-\n-\t\ttem = gen_reg_rtx (mode);\n-\n-\t\t/* Replace biv with giv's reduced register.  */\n-\t\tvalidate_change (insn, &XEXP (x, 1 - arg_operand),\n-\t\t\t\t v->new_reg, 1);\n-\n-\t\t/* Compute value to compare against.  */\n-\t\tloop_iv_add_mult_emit_before (loop, arg,\n-\t\t\t\t\t      v->mult_val, v->add_val,\n-\t\t\t\t\t      tem, where_bb, where_insn);\n-\t\t/* Use it in this insn.  */\n-\t\tvalidate_change (insn, &XEXP (x, arg_operand), tem, 1);\n-\t\tif (apply_change_group ())\n-\t\t  return 1;\n-\t      }\n-\t}\n-      else if (REG_P (arg) || MEM_P (arg))\n-\t{\n-\t  if (loop_invariant_p (loop, arg) == 1)\n-\t    {\n-\t      /* Look for giv with constant positive mult_val and nonconst\n-\t\t add_val. Insert insns to compute new compare value.\n-\t\t ??? Turn this off due to possible overflow.  */\n-\n-\t      for (v = bl->giv; v; v = v->next_iv)\n-\t\tif (GET_CODE (v->mult_val) == CONST_INT && INTVAL (v->mult_val) > 0\n-\t\t    && ! v->ignore && ! v->maybe_dead && v->always_computable\n-\t\t    && v->mode == mode\n-\t\t    && 0)\n-\t\t  {\n-\t\t    rtx tem;\n-\n-\t\t    if (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n-\t\t      continue;\n-\n-\t\t    if (! eliminate_p)\n-\t\t      return 1;\n-\n-\t\t    tem = gen_reg_rtx (mode);\n-\n-\t\t    /* Replace biv with giv's reduced register.  */\n-\t\t    validate_change (insn, &XEXP (x, 1 - arg_operand),\n-\t\t\t\t     v->new_reg, 1);\n-\n-\t\t    /* Compute value to compare against.  */\n-\t\t    loop_iv_add_mult_emit_before (loop, arg,\n-\t\t\t\t\t\t  v->mult_val, v->add_val,\n-\t\t\t\t\t\t  tem, where_bb, where_insn);\n-\t\t    validate_change (insn, &XEXP (x, arg_operand), tem, 1);\n-\t\t    if (apply_change_group ())\n-\t\t      return 1;\n-\t\t  }\n-\t    }\n-\n-\t  /* This code has problems.  Basically, you can't know when\n-\t     seeing if we will eliminate BL, whether a particular giv\n-\t     of ARG will be reduced.  If it isn't going to be reduced,\n-\t     we can't eliminate BL.  We can try forcing it to be reduced,\n-\t     but that can generate poor code.\n+      if (GET_CODE (arg) != CONST_INT)\n+\treturn 0;\n \n-\t     The problem is that the benefit of reducing TV, below should\n-\t     be increased if BL can actually be eliminated, but this means\n-\t     we might have to do a topological sort of the order in which\n-\t     we try to process biv.  It doesn't seem worthwhile to do\n-\t     this sort of thing now.  */\n+      /* Unless we're dealing with an equality comparison, if we can't\n+\t determine that the original biv doesn't wrap, then we must not\n+\t apply the transformation.  */\n+      /* ??? Actually, what we must do is verify that the transformed\n+\t giv doesn't wrap.  But the general case of this transformation\n+\t was disabled long ago due to wrapping problems, and there's no\n+\t point reviving it this close to end-of-life for loop.c.  The\n+\t only case still enabled is known (via the check on add_val) to\n+\t be pointer arithmetic, which in theory never overflows for\n+\t valid programs.  */\n+      /* Without lifetime analysis, we don't know how COMPARE will be\n+\t used, so we must assume the worst.  */\n+      if (code != EQ && code != NE\n+\t  && biased_biv_may_wrap_p (loop, bl, INTVAL (arg)))\n+\treturn 0;\n \n-#if 0\n-\t  /* Otherwise the reg compared with had better be a biv.  */\n-\t  if (!REG_P (arg)\n-\t      || REG_IV_TYPE (ivs, REGNO (arg)) != BASIC_INDUCT)\n-\t    return 0;\n+      /* Try to replace with any giv that has constant positive mult_val\n+         and a pointer add_val.  */\n+      for (v = bl->giv; v; v = v->next_iv)\n+\tif (GET_CODE (v->mult_val) == CONST_INT\n+\t    && INTVAL (v->mult_val) > 0\n+\t    && (GET_CODE (v->add_val) == SYMBOL_REF\n+\t\t|| GET_CODE (v->add_val) == LABEL_REF\n+\t\t|| GET_CODE (v->add_val) == CONST\n+\t\t|| (REG_P (v->add_val) && REG_POINTER (v->add_val)))\n+\t    && ! v->ignore && ! v->maybe_dead && v->always_computable\n+\t    && v->mode == mode)\n+\t  {\n+\t    if (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n+\t      continue;\n \n-\t  /* Look for a pair of givs, one for each biv,\n-\t     with identical coefficients.  */\n-\t  for (v = bl->giv; v; v = v->next_iv)\n-\t    {\n-\t      struct induction *tv;\n+\t    if (! eliminate_p)\n+\t      return 1;\n \n-\t      if (v->ignore || v->maybe_dead || v->mode != mode)\n-\t\tcontinue;\n+\t    /* Replace biv with the giv's reduced reg.  */\n+\t    validate_change (insn, &XEXP (x, 1 - arg_operand), v->new_reg, 1);\n \n-\t      for (tv = REG_IV_CLASS (ivs, REGNO (arg))->giv; tv;\n-\t\t   tv = tv->next_iv)\n-\t\tif (! tv->ignore && ! tv->maybe_dead\n-\t\t    && rtx_equal_p (tv->mult_val, v->mult_val)\n-\t\t    && rtx_equal_p (tv->add_val, v->add_val)\n-\t\t    && tv->mode == mode)\n-\t\t  {\n-\t\t    if (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n-\t\t      continue;\n+\t    /* Load the value into a register.  */\n+\t    tem = gen_reg_rtx (mode);\n+\t    loop_iv_add_mult_emit_before (loop, arg, v->mult_val, v->add_val,\n+\t\t\t\t\t  tem, where_bb, where_insn);\n \n-\t\t    if (! eliminate_p)\n-\t\t      return 1;\n+\t    validate_change (insn, &XEXP (x, arg_operand), tem, 1);\n \n-\t\t    /* Replace biv with its giv's reduced reg.  */\n-\t\t    XEXP (x, 1 - arg_operand) = v->new_reg;\n-\t\t    /* Replace other operand with the other giv's\n-\t\t       reduced reg.  */\n-\t\t    XEXP (x, arg_operand) = tv->new_reg;\n-\t\t    return 1;\n-\t\t  }\n-\t    }\n-#endif\n-\t}\n+\t    if (apply_change_group ())\n+\t      return 1;\n+\t  }\n \n       /* If we get here, the biv can't be eliminated.  */\n       return 0;"}]}