{"sha": "fd3cd001d57652cb50451eaa7763e1bd29bac8c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQzY2QwMDFkNTc2NTJjYjUwNDUxZWFhNzc2M2UxYmQyOWJhYzhjNA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-01-24T17:10:22Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-01-24T17:10:22Z"}, "message": "configure.in (HAVE_AS_TLS): Add s390-*-* and s390x-*-* cases.\n\n\t* configure.in (HAVE_AS_TLS): Add s390-*-* and s390x-*-* cases.\n\t* configure: Regenerate.\n\n\t* config/s390/s390-protos.h (tls_symbolic_operand): Add prototype.\n\t(tls_symbolic_reference_mentioned_p): Add prototype.\n\t(s390_tls_get_offset): Add prototype.\n\t(emit_pic_move): Remove prototype, replace by ...\n\t(emit_symbolic_move): .. this new prototype.\n\n\t* config/s390/s390.c (TARGET_HAVE_TLS): Conditionally define.\n\t(tls_model_chars): New global variable.\n\t(s390_encode_section_info): Encode TLS model.\n\tUse targetm.binds_local_p to check for local symbols.\n\t(s390_strip_name_encoding): New function.\n\t(TARGET_STRIP_NAME_ENCODING): Define.\n\n\t(get_thread_pointer): New function.\n\t(legitimize_tls_address): New function.\n\t(legitimize_address): Call it.\n\t(emit_pic_move): Remove, replace by ...\n\t(emit_symbolic_move): ... this new function.\n\n\t(larl_operand): Handle TLS operands.\n\t(legitimate_constant_p): Likewise.\n\t(s390_decompose_address): Likewise.\n\t(s390_cannot_force_const_mem): New function.\n\t(TARGET_CANNOT_FORCE_CONST_MEM): Define.\n\n\t(s390_output_symbolic_const): Handle TLS unspecs.\n\t(print_operand): New code 'J'.\n\t(machine_function): Add struct member 'some_ld_name'.\n\t(get_some_local_dynamic_name, get_some_local_dynamic_name_1): New.\n\n\t(enum s390_builtin): New type.\n\t(code_for_builtin_64, code_for_builtin_31): New global variables.\n\t(s390_init_builtins, s390_expand_builtin): New functions.\n\t(TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN): Define.\n\n\t* config/s390/s390.h (TLS_SYMBOLIC_CONST): New macro.\n\t(ASM_OUTPUT_LABELREF): Define.\n\t(ASM_OUTPUT_SPECIAL_POOL_ENTRY): Handle TLS constants.\n\n\t* config/s390/s390.md: Define TLS UNSPEC constants.\n\t(\"movdi\", \"movsi\"): Handle TLS operands.\n\t(\"get_tp_64\", \"get_tp_31\", \"set_tp_64\", \"set_tp_31\"): New insns.\n\t(\"*tls_load_64\", \"*tls_load_31\"): New insns.\n\t(\"call_value_tls\", \"call_value_tls_exp\"): New expanders.\n\t(\"brasl_tls\", \"bras_tls\", \"basr_tls_64\", \"basr_tls_31\",\n\t\"bas_tls_64\", \"bas_tls_31\"): New insns.\n\nFrom-SVN: r61714", "tree": {"sha": "1af0519cb86e6b24b68cb792349305cb90e0a1bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1af0519cb86e6b24b68cb792349305cb90e0a1bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd3cd001d57652cb50451eaa7763e1bd29bac8c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd3cd001d57652cb50451eaa7763e1bd29bac8c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd3cd001d57652cb50451eaa7763e1bd29bac8c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/comments", "author": null, "committer": null, "parents": [{"sha": "475c1d0989ece5c8991c24a1c8055b50705b7a23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/475c1d0989ece5c8991c24a1c8055b50705b7a23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/475c1d0989ece5c8991c24a1c8055b50705b7a23"}], "stats": {"total": 1101, "additions": 1040, "deletions": 61}, "files": [{"sha": "f054621f3843987423ff24da1f8444730c0df025", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd3cd001d57652cb50451eaa7763e1bd29bac8c4", "patch": "@@ -1,3 +1,55 @@\n+2003-01-24  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* configure.in (HAVE_AS_TLS): Add s390-*-* and s390x-*-* cases.\n+\t* configure: Regenerate.\n+\n+\t* config/s390/s390-protos.h (tls_symbolic_operand): Add prototype.\n+\t(tls_symbolic_reference_mentioned_p): Add prototype.\n+\t(s390_tls_get_offset): Add prototype.\n+\t(emit_pic_move): Remove prototype, replace by ...\n+\t(emit_symbolic_move): .. this new prototype.\n+\n+\t* config/s390/s390.c (TARGET_HAVE_TLS): Conditionally define.\n+\t(tls_model_chars): New global variable.\n+\t(s390_encode_section_info): Encode TLS model.\n+\tUse targetm.binds_local_p to check for local symbols.\n+\t(s390_strip_name_encoding): New function.\n+\t(TARGET_STRIP_NAME_ENCODING): Define.\n+\n+\t(get_thread_pointer): New function.\n+\t(legitimize_tls_address): New function.\t\n+\t(legitimize_address): Call it.\n+\t(emit_pic_move): Remove, replace by ...\n+\t(emit_symbolic_move): ... this new function.\n+\n+\t(larl_operand): Handle TLS operands.\n+\t(legitimate_constant_p): Likewise.\n+\t(s390_decompose_address): Likewise.\n+\t(s390_cannot_force_const_mem): New function.\n+\t(TARGET_CANNOT_FORCE_CONST_MEM): Define.\n+\n+\t(s390_output_symbolic_const): Handle TLS unspecs.\n+\t(print_operand): New code 'J'.\n+\t(machine_function): Add struct member 'some_ld_name'.\n+\t(get_some_local_dynamic_name, get_some_local_dynamic_name_1): New.\n+\n+\t(enum s390_builtin): New type.\n+\t(code_for_builtin_64, code_for_builtin_31): New global variables.\n+\t(s390_init_builtins, s390_expand_builtin): New functions.\n+\t(TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN): Define.\n+\n+\t* config/s390/s390.h (TLS_SYMBOLIC_CONST): New macro.\n+\t(ASM_OUTPUT_LABELREF): Define.\n+\t(ASM_OUTPUT_SPECIAL_POOL_ENTRY): Handle TLS constants.\n+\n+\t* config/s390/s390.md: Define TLS UNSPEC constants.\n+\t(\"movdi\", \"movsi\"): Handle TLS operands.\n+\t(\"get_tp_64\", \"get_tp_31\", \"set_tp_64\", \"set_tp_31\"): New insns.\n+\t(\"*tls_load_64\", \"*tls_load_31\"): New insns.\n+\t(\"call_value_tls\", \"call_value_tls_exp\"): New expanders.\n+\t(\"brasl_tls\", \"bras_tls\", \"basr_tls_64\", \"basr_tls_31\", \n+\t\"bas_tls_64\", \"bas_tls_31\"): New insns.\n+\n 2003-01-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/rs6000/rs6000.c (rs6000_parse_abi_options): Make sure"}, {"sha": "3e315dd369a1b9e9803b65699dd3db6144394286", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=fd3cd001d57652cb50451eaa7763e1bd29bac8c4", "patch": "@@ -43,11 +43,14 @@ extern int s390_single_hi PARAMS ((rtx, enum machine_mode, int));\n extern int s390_extract_hi PARAMS ((rtx, enum machine_mode, int));\n extern int s390_single_qi PARAMS ((rtx, enum machine_mode, int));\n extern int s390_extract_qi PARAMS ((rtx, enum machine_mode, int));\n+extern int tls_symbolic_operand PARAMS ((rtx));\n \n extern int s390_match_ccmode PARAMS ((rtx, enum machine_mode));\n extern enum machine_mode s390_tm_ccmode PARAMS ((rtx, rtx, int));\n extern enum machine_mode s390_select_ccmode PARAMS ((enum rtx_code, rtx, rtx));\n extern int symbolic_reference_mentioned_p PARAMS ((rtx));\n+extern int tls_symbolic_reference_mentioned_p PARAMS ((rtx));\n+extern rtx s390_tls_get_offset PARAMS ((void));\n extern int legitimate_la_operand_p PARAMS ((rtx));\n extern int preferred_la_operand_p PARAMS ((rtx));\n extern int legitimate_pic_operand_p PARAMS ((rtx));\n@@ -60,7 +63,7 @@ extern enum reg_class s390_preferred_reload_class PARAMS ((rtx, enum reg_class))\n extern enum reg_class s390_secondary_input_reload_class PARAMS ((enum reg_class, enum machine_mode, rtx));\n extern int s390_plus_operand PARAMS ((rtx, enum machine_mode));\n extern void s390_expand_plus_operand PARAMS ((rtx, rtx, rtx));\n-extern void emit_pic_move PARAMS ((rtx *, enum machine_mode));\n+extern void emit_symbolic_move PARAMS ((rtx *));\n extern void s390_load_address PARAMS ((rtx, rtx));\n extern void s390_expand_movstr PARAMS ((rtx, rtx, rtx));\n extern void s390_expand_clrstr PARAMS ((rtx, rtx));"}, {"sha": "b22c9c420d90cfda9cb495ae0f9fee37a138fe56", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 670, "deletions": 29, "changes": 699, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=fd3cd001d57652cb50451eaa7763e1bd29bac8c4", "patch": "@@ -54,6 +54,11 @@ static bool s390_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void s390_select_rtx_section PARAMS ((enum machine_mode, rtx, \n \t\t\t\t\t     unsigned HOST_WIDE_INT));\n static void s390_encode_section_info PARAMS ((tree, int));\n+static const char *s390_strip_name_encoding PARAMS ((const char *));\n+static bool s390_cannot_force_const_mem PARAMS ((rtx));\n+static void s390_init_builtins PARAMS ((void));\n+static rtx s390_expand_builtin PARAMS ((tree, rtx, rtx, \n+\t\t\t\t\tenum machine_mode, int));\n static void s390_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t  HOST_WIDE_INT, tree));\n static enum attr_type s390_safe_attr_type PARAMS ((rtx));\n@@ -81,6 +86,20 @@ static int s390_use_dfa_pipeline_interface PARAMS ((void));\n \n #undef\tTARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO s390_encode_section_info\n+#undef  TARGET_STRIP_NAME_ENCODING\n+#define TARGET_STRIP_NAME_ENCODING s390_strip_name_encoding\n+\n+#ifdef HAVE_AS_TLS\n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS true\n+#endif\n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM s390_cannot_force_const_mem\n+\n+#undef  TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS s390_init_builtins\n+#undef  TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN s390_expand_builtin\n \n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK s390_output_mi_thunk\n@@ -106,6 +125,9 @@ static int s390_sr_alias_set = 0;\n    emitted.  */\n rtx s390_compare_op0, s390_compare_op1;\n \n+/* The encoding characters for the four TLS models present in ELF.  */\n+static char const tls_model_chars[] = \" GLil\";\n+\n /* Structure used to hold the components of a S/390 memory\n    address.  A legitimate address on S/390 is of the general\n    form\n@@ -149,6 +171,9 @@ struct machine_function GTY(())\n \n   /* Size of stack frame.  */\n   HOST_WIDE_INT frame_size;\n+\n+  /* Some local-dynamic TLS symbol name.  */\n+  const char *some_ld_name;\n };\n \n static int s390_match_ccmode_set PARAMS ((rtx, enum machine_mode));\n@@ -157,6 +182,10 @@ static const char *s390_branch_condition_mnemonic PARAMS ((rtx, int));\n static int check_mode PARAMS ((rtx, enum machine_mode *));\n static int general_s_operand PARAMS ((rtx, enum machine_mode, int));\n static int s390_decompose_address PARAMS ((rtx, struct s390_address *));\n+static rtx get_thread_pointer PARAMS ((void));\n+static rtx legitimize_tls_address PARAMS ((rtx, rtx));\n+static const char *get_some_local_dynamic_name PARAMS ((void));\n+static int get_some_local_dynamic_name_1 PARAMS ((rtx *, void *));\n static int reg_used_in_mem_p PARAMS ((int, rtx));\n static int addr_generation_dependency_p PARAMS ((rtx, rtx));\n static int s390_split_branches PARAMS ((rtx, bool *));\n@@ -1012,6 +1041,7 @@ larl_operand (op, mode)\n   if (GET_CODE (op) == LABEL_REF)\n     return 1;\n   if (GET_CODE (op) == SYMBOL_REF\n+      && !tls_symbolic_operand (op)\n       && (!flag_pic || SYMBOL_REF_FLAG (op) \n           || CONSTANT_POOL_ADDRESS_P (op)))\n     return 1;\n@@ -1034,17 +1064,22 @@ larl_operand (op, mode)\n   if (GET_CODE (op) == LABEL_REF)\n     return 1;\n   if (GET_CODE (op) == SYMBOL_REF\n+      && !tls_symbolic_operand (op)\n       && (!flag_pic || SYMBOL_REF_FLAG (op)\n           || CONSTANT_POOL_ADDRESS_P (op)))\n     return 1;\n \n-  /* Now we must have a @GOTENT offset or @PLT stub.  */\n+  /* Now we must have a @GOTENT offset or @PLT stub\n+     or an @INDNTPOFF TLS offset.  */\n   if (GET_CODE (op) == UNSPEC\n       && XINT (op, 1) == 111)\n     return 1;\n   if (GET_CODE (op) == UNSPEC\n       && XINT (op, 1) == 113)\n     return 1;\n+  if (GET_CODE (op) == UNSPEC\n+      && XINT (op, 1) == UNSPEC_INDNTPOFF)\n+    return 1;\n \n   return 0;\n }\n@@ -1193,6 +1228,23 @@ bras_sym_operand (op, mode)\n   return 0;\n }\n \n+/* If OP is a SYMBOL_REF of a thread-local symbol, return its TLS mode,\n+   otherwise return 0.  */\n+\n+int\n+tls_symbolic_operand (op)\n+     register rtx op;\n+{\n+  const char *symbol_str;\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+  symbol_str = XSTR (op, 0);\n+\n+  if (symbol_str[0] != '%')\n+    return 0;\n+  return strchr (tls_model_chars, symbol_str[1]) - tls_model_chars;\n+}\n \f\n /* Return true if OP is a load multiple operation.  It is known to be a\n    PARALLEL and the first section will be tested. \n@@ -1352,6 +1404,37 @@ symbolic_reference_mentioned_p (op)\n   return 0;\n }\n \n+/* Return true if OP contains a reference to a thread-local symbol.  */\n+\n+int\n+tls_symbolic_reference_mentioned_p (op)\n+     rtx op;\n+{\n+  register const char *fmt;\n+  register int i;\n+\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return tls_symbolic_operand (op);\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (op));\n+  for (i = GET_RTX_LENGTH (GET_CODE (op)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n+\t    if (tls_symbolic_reference_mentioned_p (XVECEXP (op, i, j)))\n+\t      return 1;\n+\t}\n+\n+      else if (fmt[i] == 'e' && tls_symbolic_reference_mentioned_p (XEXP (op, i)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n \n /* Return true if OP is a legitimate general operand when \n    generating PIC code.  It is given that flag_pic is on \n@@ -1366,7 +1449,7 @@ legitimate_pic_operand_p (op)\n     return 1;\n \n   /* Reject everything else; must be handled \n-     via emit_pic_move.  */\n+     via emit_symbolic_move.  */\n   return 0;\n }\n \n@@ -1381,22 +1464,87 @@ legitimate_constant_p (op)\n   if (!SYMBOLIC_CONST (op))\n     return 1;\n \n+  /* Accept immediate LARL operands.  */\n+  if (TARGET_64BIT && larl_operand (op, VOIDmode))\n+    return 1;\n+\n+  /* Thread-local symbols are never legal constants.  This is\n+     so that emit_call knows that computing such addresses\n+     might require a function call.  */\n+  if (TLS_SYMBOLIC_CONST (op))\n+    return 0;\n+\n   /* In the PIC case, symbolic constants must *not* be\n      forced into the literal pool.  We accept them here,\n-     so that they will be handled by emit_pic_move.  */\n+     so that they will be handled by emit_symbolic_move.  */\n   if (flag_pic)\n     return 1;\n \n-  /* Even in the non-PIC case, we can accept immediate\n-     LARL operands here.  */\n-  if (TARGET_64BIT)\n-    return larl_operand (op, VOIDmode);\n-\n   /* All remaining non-PIC symbolic constants are\n      forced into the literal pool.  */\n   return 0;\n }\n \n+/* Determine if it's legal to put X into the constant pool.  This\n+   is not possible if X contains the address of a symbol that is\n+   not constant (TLS) or not known at final link time (PIC).  */\n+\n+static bool\n+s390_cannot_force_const_mem (x)\n+     rtx x;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+      /* Accept all non-symbolic constants.  */\n+      return false;\n+\n+    case LABEL_REF:\n+      /* Labels are OK iff we are non-PIC.  */\n+      return flag_pic != 0;\n+\n+    case SYMBOL_REF:\n+      /* 'Naked' TLS symbol references are never OK,\n+         non-TLS symbols are OK iff we are non-PIC.  */\n+      if (tls_symbolic_operand (x))\n+\treturn true;\n+      else\n+\treturn flag_pic != 0;\n+\n+    case CONST:\n+      return s390_cannot_force_const_mem (XEXP (x, 0));\n+    case PLUS:\n+    case MINUS:\n+      return s390_cannot_force_const_mem (XEXP (x, 0))\n+\t     || s390_cannot_force_const_mem (XEXP (x, 1));\n+\n+    case UNSPEC:\n+      switch (XINT (x, 1))\n+\t{\n+\t/* Only lt-relative or GOT-relative UNSPECs are OK.  */\n+\tcase 100:\n+\tcase 104:\n+\tcase 112:\n+\tcase 114:\n+\tcase UNSPEC_TLSGD:\n+\tcase UNSPEC_TLSLDM:\n+\tcase UNSPEC_NTPOFF:\n+\tcase UNSPEC_DTPOFF:\n+\tcase UNSPEC_GOTNTPOFF:\n+\tcase UNSPEC_INDNTPOFF:\n+\t  return false;\n+\n+\tdefault:\n+\t  return true;\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n /* Returns true if the constant value OP is a legitimate general\n    operand during and after reload.  The difference to \n    legitimate_constant_p is that this function will not accept\n@@ -1726,10 +1874,11 @@ s390_decompose_address (addr, out)\n         }\n \n       /* In the small-PIC case, the linker converts @GOT12 \n-         offsets to possible displacements.  */\n+         and @GOTNTPOFF offsets to possible displacements.  */\n       else if (GET_CODE (disp) == CONST\n                && GET_CODE (XEXP (disp, 0)) == UNSPEC\n-               && XINT (XEXP (disp, 0), 1) == 110)\n+               && (XINT (XEXP (disp, 0), 1) == 110\n+\t\t   || XINT (XEXP (disp, 0), 1) == UNSPEC_GOTNTPOFF))\n         {\n           if (flag_pic != 1)\n             return FALSE;\n@@ -1779,12 +1928,6 @@ s390_decompose_address (addr, out)\n               || !CONSTANT_POOL_ADDRESS_P (disp))\n             return FALSE;\n \n-          /* In 64-bit PIC mode we cannot accept symbolic \n-             constants in the constant pool.  */\n-          if (TARGET_64BIT && flag_pic\n-              && SYMBOLIC_CONST (get_pool_constant (disp)))\n-            return FALSE;\n-\n           /* If we have an offset, make sure it does not\n              exceed the size of the constant pool entry.  */\n           if (offset && offset >= GET_MODE_SIZE (get_pool_mode (disp)))\n@@ -2196,18 +2339,237 @@ legitimize_pic_address (orig, reg)\n   return new;\n }\n \n+/* Load the thread pointer into a register.  */\n+\n+static rtx\n+get_thread_pointer ()\n+{\n+  rtx tp;\n+\n+  tp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx), UNSPEC_TP);\n+  tp = force_reg (Pmode, tp);\n+  mark_reg_pointer (tp, BITS_PER_WORD);\n+\n+  return tp;\n+}\n+\n+/* Construct the SYMBOL_REF for the tls_get_offset function.  */\n+\n+static GTY(()) rtx s390_tls_symbol;\n+rtx\n+s390_tls_get_offset ()\n+{\n+  if (!s390_tls_symbol)\n+    s390_tls_symbol = gen_rtx_SYMBOL_REF (Pmode, \"__tls_get_offset\");\n+\n+  return s390_tls_symbol;\n+}\n+\n+/* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute\n+   this (thread-local) address.  REG may be used as temporary.  */\n+\n+static rtx\n+legitimize_tls_address (addr, reg)\n+     rtx addr;\n+     rtx reg;\n+{\n+  rtx new, tls_call, temp, base, r2, insn;\n+\n+  if (GET_CODE (addr) == SYMBOL_REF)\n+    switch (tls_symbolic_operand (addr))\n+      {\n+      case TLS_MODEL_GLOBAL_DYNAMIC:\n+\tstart_sequence ();\n+\tr2 = gen_rtx_REG (Pmode, 2);\n+\ttls_call = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_TLSGD);\n+\tnew = gen_rtx_CONST (Pmode, tls_call);\n+\tnew = force_const_mem (Pmode, new);\n+\temit_move_insn (r2, new);\n+\temit_call_insn (gen_call_value_tls (r2, tls_call));\n+\tinsn = get_insns ();\n+\tend_sequence ();\n+\n+\tnew = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_NTPOFF);\n+\ttemp = gen_reg_rtx (Pmode);\n+\temit_libcall_block (insn, temp, r2, new);\n+\n+\tnew = gen_rtx_PLUS (Pmode, get_thread_pointer (), temp);\n+\tif (reg != 0)\n+\t  {\n+\t    s390_load_address (reg, new);\n+\t    new = reg;\n+\t  }\n+\tbreak;\n+\n+      case TLS_MODEL_LOCAL_DYNAMIC:\n+\tstart_sequence ();\n+\tr2 = gen_rtx_REG (Pmode, 2);\n+\ttls_call = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx), UNSPEC_TLSLDM);\n+\tnew = gen_rtx_CONST (Pmode, tls_call);\n+\tnew = force_const_mem (Pmode, new);\n+\temit_move_insn (r2, new);\n+\temit_call_insn (gen_call_value_tls (r2, tls_call));\n+\tinsn = get_insns ();\n+\tend_sequence ();\n+\n+\tnew = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx), UNSPEC_TLSLDM_NTPOFF);\n+\ttemp = gen_reg_rtx (Pmode);\n+\temit_libcall_block (insn, temp, r2, new);\n+\n+\tnew = gen_rtx_PLUS (Pmode, get_thread_pointer (), temp);\n+\tbase = gen_reg_rtx (Pmode);\n+\ts390_load_address (base, new);\n+\n+\tnew = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_DTPOFF);\n+\tnew = gen_rtx_CONST (Pmode, new);\n+\tnew = force_const_mem (Pmode, new);\n+\ttemp = gen_reg_rtx (Pmode);\n+\temit_move_insn (temp, new);\n+\n+\tnew = gen_rtx_PLUS (Pmode, base, temp);\n+\tif (reg != 0)\n+\t  {\n+\t    s390_load_address (reg, new);\n+\t    new = reg;\n+\t  }\n+\tbreak;\n+\n+      case TLS_MODEL_INITIAL_EXEC:\n+\tif (flag_pic == 1)\n+\t  {\n+\t    /* Assume GOT offset < 4k.  This is handled the same way\n+\t       in both 31- and 64-bit code.  */\n+\n+\t    if (reload_in_progress || reload_completed)\n+\t      regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\n+\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTNTPOFF);\n+\t    new = gen_rtx_CONST (Pmode, new);\n+\t    new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n+\t    new = gen_rtx_MEM (Pmode, new);\n+\t    RTX_UNCHANGING_P (new) = 1;\n+\t    temp = gen_reg_rtx (Pmode);\n+\t    emit_move_insn (temp, new);\n+\t  }\n+\telse if (TARGET_64BIT)\n+\t  {\n+\t    /* If the GOT offset might be >= 4k, we determine the position\n+\t       of the GOT entry via a PC-relative LARL.  */\n+\n+\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_INDNTPOFF);\n+\t    new = gen_rtx_CONST (Pmode, new);\n+\t    temp = gen_reg_rtx (Pmode);\n+\t    emit_move_insn (temp, new);\n+\n+\t    new = gen_rtx_MEM (Pmode, temp);\n+\t    RTX_UNCHANGING_P (new) = 1;\n+\t    temp = gen_reg_rtx (Pmode);\n+\t    emit_move_insn (temp, new);\n+\t  }\n+\telse if (flag_pic)\n+\t  {\n+\t    /* If the GOT offset might be >= 4k, we have to load it \n+\t       from the literal pool.  */\n+\n+\t    if (reload_in_progress || reload_completed)\n+\t      regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\n+\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTNTPOFF);\n+\t    new = gen_rtx_CONST (Pmode, new);\n+\t    new = force_const_mem (Pmode, new);\n+\t    temp = gen_reg_rtx (Pmode);\n+\t    emit_move_insn (temp, new);\n+\n+            new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n+\t    new = gen_rtx_MEM (Pmode, new);\n+\t    RTX_UNCHANGING_P (new) = 1;\n+\n+\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, new, addr), UNSPEC_TLS_LOAD);\n+\t    temp = gen_reg_rtx (Pmode);\n+\t    emit_insn (gen_rtx_SET (Pmode, temp, new));\n+\t  }\n+\telse\n+\t  {\n+\t    /* In position-dependent code, load the absolute address of\n+\t       the GOT entry from the literal pool.  */\n+\n+\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_INDNTPOFF);\n+\t    new = gen_rtx_CONST (Pmode, new);\n+\t    new = force_const_mem (Pmode, new);\n+\t    temp = gen_reg_rtx (Pmode);\n+\t    emit_move_insn (temp, new);\n+\n+\t    new = temp;\n+\t    new = gen_rtx_MEM (Pmode, new);\n+\t    RTX_UNCHANGING_P (new) = 1;\n+\n+\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, new, addr), UNSPEC_TLS_LOAD);\n+\t    temp = gen_reg_rtx (Pmode);\n+\t    emit_insn (gen_rtx_SET (Pmode, temp, new));\n+\t  }\n+\n+\tnew = gen_rtx_PLUS (Pmode, get_thread_pointer (), temp);\n+\tif (reg != 0)\n+\t  {\n+\t    s390_load_address (reg, new);\n+\t    new = reg;\n+\t  }\n+\tbreak;\n+\n+      case TLS_MODEL_LOCAL_EXEC:\n+\tnew = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_NTPOFF);\n+\tnew = gen_rtx_CONST (Pmode, new);\n+\tnew = force_const_mem (Pmode, new);\n+        temp = gen_reg_rtx (Pmode);\n+\temit_move_insn (temp, new);\n+\n+\tnew = gen_rtx_PLUS (Pmode, get_thread_pointer (), temp);\n+\tif (reg != 0)\n+\t  {\n+\t    s390_load_address (reg, new);\n+\t    new = reg;\n+\t  }\n+\tbreak;\n+\n+      default:\n+\tabort ();\n+      }\n+\n+  else if (GET_CODE (addr) == CONST && GET_CODE (XEXP (addr, 0)) == UNSPEC)\n+    {\n+      switch (XINT (XEXP (addr, 0), 1))\n+\t{\n+\tcase UNSPEC_INDNTPOFF:\n+\t  if (TARGET_64BIT)\n+\t    new = addr;\n+\t  else\n+\t    abort ();\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n+  else\n+    abort ();  /* for now ... */\n+\n+  return new;\n+}\n+\n /* Emit insns to move operands[1] into operands[0].  */\n \n void\n-emit_pic_move (operands, mode)\n+emit_symbolic_move (operands)\n      rtx *operands;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   rtx temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n \n-  if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1]))\n+  if (GET_CODE (operands[0]) == MEM)\n     operands[1] = force_reg (Pmode, operands[1]);\n-  else\n+  else if (TLS_SYMBOLIC_CONST (operands[1]))\n+    operands[1] = legitimize_tls_address (operands[1], temp);\n+  else if (flag_pic)\n     operands[1] = legitimize_pic_address (operands[1], temp);\n }\n \n@@ -2230,7 +2592,14 @@ legitimize_address (x, oldx, mode)\n {\n   rtx constant_term = const0_rtx;\n \n-  if (flag_pic)\n+  if (TLS_SYMBOLIC_CONST (x))\n+    {\n+      x = legitimize_tls_address (x, 0);\n+\n+      if (legitimate_address_p (mode, x, FALSE))\n+\treturn x;\n+    }\n+  else if (flag_pic)\n     {\n       if (SYMBOLIC_CONST (x)\n           || (GET_CODE (x) == PLUS \n@@ -2642,6 +3011,48 @@ s390_simplify_dwarf_addr (orig_x)\n   return orig_x;      \n }\n \n+/* Locate some local-dynamic symbol still in use by this function\n+   so that we can print its name in local-dynamic base patterns.  */\n+\n+static const char *\n+get_some_local_dynamic_name ()\n+{\n+  rtx insn;\n+\n+  if (cfun->machine->some_ld_name)\n+    return cfun->machine->some_ld_name;\n+\n+  for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn)\n+        && for_each_rtx (&PATTERN (insn), get_some_local_dynamic_name_1, 0))\n+      return cfun->machine->some_ld_name;\n+\n+  abort ();\n+}\n+\n+static int\n+get_some_local_dynamic_name_1 (px, data)\n+     rtx *px;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  rtx x = *px;\n+\n+  if (GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))\n+    {\n+      x = get_pool_constant (x);\n+      return for_each_rtx (&x, get_some_local_dynamic_name_1, 0);\n+    }\n+\n+  if (GET_CODE (x) == SYMBOL_REF\n+      && tls_symbolic_operand (x) == TLS_MODEL_LOCAL_DYNAMIC)\n+    {\n+      cfun->machine->some_ld_name = XSTR (x, 0);\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n /* Output symbolic constant X in assembler syntax to \n    stdio stream FILE.  */\n \n@@ -2714,6 +3125,30 @@ s390_output_symbolic_const (file, x)\n           fprintf (file, \"@PLT-\");\n \t  s390_output_symbolic_const (file, cfun->machine->literal_pool_label);\n \t  break;\n+\tcase UNSPEC_TLSGD:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+\t  fprintf (file, \"@TLSGD\");\n+\t  break;\n+\tcase UNSPEC_TLSLDM:\n+\t  assemble_name (file, get_some_local_dynamic_name ());\n+\t  fprintf (file, \"@TLSLDM\");\n+\t  break;\n+\tcase UNSPEC_DTPOFF:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+\t  fprintf (file, \"@DTPOFF\");\n+\t  break;\n+\tcase UNSPEC_NTPOFF:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+\t  fprintf (file, \"@NTPOFF\");\n+\t  break;\n+\tcase UNSPEC_GOTNTPOFF:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+\t  fprintf (file, \"@GOTNTPOFF\");\n+\t  break;\n+\tcase UNSPEC_INDNTPOFF:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+\t  fprintf (file, \"@INDNTPOFF\");\n+\t  break;\n \tdefault:\n \t  output_operand_lossage (\"invalid UNSPEC as operand (2)\");\n \t  break;\n@@ -2759,6 +3194,7 @@ print_operand_address (file, addr)\n \n     'C': print opcode suffix for branch condition.\n     'D': print opcode suffix for inverse branch condition.\n+    'J': print tls_load/tls_gdcall/tls_ldcall suffix\n     'O': print only the displacement of a memory reference.\n     'R': print only the base register of a memory reference.\n     'N': print the second word of a DImode operand.\n@@ -2784,6 +3220,26 @@ print_operand (file, x, code)\n       fprintf (file, s390_branch_condition_mnemonic (x, TRUE));\n       return;\n \n+    case 'J':\n+      if (GET_CODE (x) == SYMBOL_REF)\n+\t{\n+\t  fprintf (file, \"%s\", \":tls_load:\");\n+\t  output_addr_const (file, x);\n+\t}\n+      else if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_TLSGD)\n+\t{\n+\t  fprintf (file, \"%s\", \":tls_gdcall:\");\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t}\n+      else if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_TLSLDM)\n+\t{\n+\t  fprintf (file, \"%s\", \":tls_ldcall:\");\n+\t  assemble_name (file, get_some_local_dynamic_name ());\n+\t}\n+      else\n+\tabort ();\n+      return;\n+\n     case 'O':\n       {\n         struct s390_address ad;\n@@ -5530,6 +5986,134 @@ s390_va_arg (valist, type)\n }\n \n \n+/* Builtins.  */\n+\n+enum s390_builtin\n+{\n+  S390_BUILTIN_THREAD_POINTER,\n+  S390_BUILTIN_SET_THREAD_POINTER,\n+\n+  S390_BUILTIN_max\n+};\n+\n+static unsigned int const code_for_builtin_64[S390_BUILTIN_max] = {\n+  CODE_FOR_get_tp_64,\n+  CODE_FOR_set_tp_64\n+};\n+\n+static unsigned int const code_for_builtin_31[S390_BUILTIN_max] = {\n+  CODE_FOR_get_tp_31,\n+  CODE_FOR_set_tp_31\n+};\n+\n+static void\n+s390_init_builtins ()\n+{\n+  tree ftype;\n+\n+  ftype = build_function_type (ptr_type_node, void_list_node);\n+  builtin_function (\"__builtin_thread_pointer\", ftype,\n+\t\t    S390_BUILTIN_THREAD_POINTER, BUILT_IN_MD,\n+\t\t    NULL, NULL_TREE);\n+\n+  ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n+  builtin_function (\"__builtin_set_thread_pointer\", ftype,\n+\t\t    S390_BUILTIN_SET_THREAD_POINTER, BUILT_IN_MD,\n+\t\t    NULL, NULL_TREE);\n+}\n+\n+/* Expand an expression EXP that calls a built-in function,\n+   with result going to TARGET if that's convenient\n+   (and in mode MODE if that's convenient).\n+   SUBTARGET may be used as the target for computing one of EXP's operands.\n+   IGNORE is nonzero if the value is to be ignored.  */\n+\n+static rtx\n+s390_expand_builtin (exp, target, subtarget, mode, ignore)\n+     tree exp;\n+     rtx target;\n+     rtx subtarget ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     int ignore ATTRIBUTE_UNUSED;\n+{\n+#define MAX_ARGS 2\n+\n+  unsigned int const *code_for_builtin = \n+    TARGET_64BIT ? code_for_builtin_64 : code_for_builtin_31;\n+\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  enum insn_code icode;\n+  rtx op[MAX_ARGS], pat;\n+  int arity;\n+  bool nonvoid;\n+\n+  if (fcode >= S390_BUILTIN_max)\n+    internal_error (\"bad builtin fcode\");\n+  icode = code_for_builtin[fcode];\n+  if (icode == 0)\n+    internal_error (\"bad builtin fcode\");\n+\n+  nonvoid = TREE_TYPE (TREE_TYPE (fndecl)) != void_type_node;\n+\n+  for (arglist = TREE_OPERAND (exp, 1), arity = 0;\n+       arglist;\n+       arglist = TREE_CHAIN (arglist), arity++)\n+    {\n+      const struct insn_operand_data *insn_op;\n+\n+      tree arg = TREE_VALUE (arglist);\n+      if (arg == error_mark_node)\n+\treturn NULL_RTX;\n+      if (arity > MAX_ARGS)\n+\treturn NULL_RTX;\n+\n+      insn_op = &insn_data[icode].operand[arity + nonvoid];\n+\n+      op[arity] = expand_expr (arg, NULL_RTX, insn_op->mode, 0);\n+\n+      if (!(*insn_op->predicate) (op[arity], insn_op->mode))\n+\top[arity] = copy_to_mode_reg (insn_op->mode, op[arity]);\n+    }\n+\n+  if (nonvoid)\n+    {\n+      enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+      if (!target\n+\t  || GET_MODE (target) != tmode\n+\t  || !(*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+    }\n+\n+  switch (arity)\n+    {\n+    case 0:\n+      pat = GEN_FCN (icode) (target);\n+      break;\n+    case 1:\n+      if (nonvoid)\n+        pat = GEN_FCN (icode) (target, op[0]);\n+      else\n+\tpat = GEN_FCN (icode) (op[0]);\n+      break;\n+    case 2:\n+      pat = GEN_FCN (icode) (target, op[0], op[1]);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  if (!pat)\n+    return NULL_RTX;\n+  emit_insn (pat);\n+\n+  if (nonvoid)\n+    return target;\n+  else\n+    return const0_rtx;\n+}\n+\n+\n /* Output assembly code for the trampoline template to\n    stdio stream FILE.\n \n@@ -5689,28 +6273,85 @@ s390_select_rtx_section (mode, x, align)\n     function_section (current_function_decl);\n }\n \n-/* If using PIC, mark a SYMBOL_REF for a non-global symbol so that we\n-   may access it directly in the GOT.  */\n+/* Encode symbol attributes (local vs. global, tls model) of a SYMBOL_REF\n+   into its name and SYMBOL_REF_FLAG.  */\n \n static void\n s390_encode_section_info (decl, first)\n      tree decl;\n      int first ATTRIBUTE_UNUSED;\n {\n+  bool local_p = (*targetm.binds_local_p) (decl);\n+  rtx rtl, symbol;\n+\n+  rtl = DECL_P (decl) ? DECL_RTL (decl) : TREE_CST_RTL (decl);\n+  if (GET_CODE (rtl) != MEM)\n+    return;\n+  symbol = XEXP (rtl, 0);\n+  if (GET_CODE (symbol) != SYMBOL_REF)\n+    return;\n+\n+  /* When using PIC, SYMBOL_REF_FLAG marks non-global symbols\n+     that can be accessed directly.  */\n   if (flag_pic)\n+    SYMBOL_REF_FLAG (symbol) = local_p;\n+\n+  /* Encode thread-local data with %[GLil] for \"global dynamic\",\n+     \"local dynamic\", \"initial exec\" or \"local exec\" TLS models,\n+     respectively.  */\n+\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))\n     {\n-      rtx rtl = (TREE_CODE_CLASS (TREE_CODE (decl)) != 'd'\n-\t\t ? TREE_CST_RTL (decl) : DECL_RTL (decl));\n+      const char *symbol_str = XSTR (symbol, 0);\n+      char *newstr;\n+      size_t len;\n+      enum tls_model kind = decl_tls_model (decl);\n \n-      if (GET_CODE (rtl) == MEM)\n+      if (!flag_pic)\n \t{\n-\t  SYMBOL_REF_FLAG (XEXP (rtl, 0))\n-\t    = (TREE_CODE_CLASS (TREE_CODE (decl)) != 'd'\n-\t       || ! TREE_PUBLIC (decl));\n+\t  /* We don't allow non-pic code for shared libraries,\n+\t     so don't generate GD/LD TLS models for non-pic code.  */\n+\t  switch (kind)\n+\t    {\n+\t    case TLS_MODEL_GLOBAL_DYNAMIC:\n+\t      kind = TLS_MODEL_INITIAL_EXEC; break;\n+\t    case TLS_MODEL_LOCAL_DYNAMIC:\n+\t      kind = TLS_MODEL_LOCAL_EXEC; break;\n+\t    default:\n+\t      break;\n+\t    }\n \t}\n+\n+      if (symbol_str[0] == '%')\n+\t{\n+\t  if (symbol_str[1] == tls_model_chars[kind])\n+\t    return;\n+\t  symbol_str += 2;\n+\t}\n+      len = strlen (symbol_str) + 1;\n+      newstr = alloca (len + 2);\n+\n+      newstr[0] = '%';\n+      newstr[1] = tls_model_chars[kind];\n+      memcpy (newstr + 2, symbol_str, len);\n+\n+      XSTR (symbol, 0) = ggc_alloc_string (newstr, len + 2 - 1);\n     }\n }\n \n+/* Undo the above when printing symbol names.  */\n+\n+static const char *\n+s390_strip_name_encoding (str)\n+     const char *str;\n+{\n+  if (str[0] == '%')\n+    str += 2;\n+  if (str[0] == '*')\n+    str += 1;\n+  return str;\n+}\n+\n /* Output thunk to FILE that implements a C++ virtual function call (with\n    multiple inheritance) to FUNCTION.  The thunk adjusts the this pointer \n    by DELTA, and unless VCALL_OFFSET is zero, applies an additional adjustment"}, {"sha": "b9ea747c96349c5237437f068c32504f05b6f39c", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=fd3cd001d57652cb50451eaa7763e1bd29bac8c4", "patch": "@@ -793,6 +793,10 @@ CUMULATIVE_ARGS;\n  || GET_CODE (X) == LABEL_REF                                           \\\n  || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n \n+#define TLS_SYMBOLIC_CONST(X)\t\\\n+((GET_CODE (X) == SYMBOL_REF && tls_symbolic_operand (X))\t\\\n+ || (GET_CODE (X) == CONST && tls_symbolic_reference_mentioned_p (X)))\n+\n \n /* Condition codes.  */\n \n@@ -970,6 +974,10 @@ extern int flag_pic;\n #define ASM_OUTPUT_SKIP(FILE, SIZE) \\\n   fprintf ((FILE), \"\\t.set\\t.,.+%u\\n\", (SIZE))\n \n+/* Output a reference to a user-level label named NAME.  */\n+#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n+  asm_fprintf ((FILE), \"%U%s\", (*targetm.strip_name_encoding) (NAME))\n+\n /* The LOCAL_LABEL_PREFIX variable is used by dbxelf.h.  */\n #define LOCAL_LABEL_PREFIX \".\"\n \n@@ -1051,10 +1059,9 @@ extern int s390_nr_constants;\n \t\t\t\t\t\t\t\t\t    \\\n     case MODE_INT:\t\t\t\t\t\t\t    \\\n     case MODE_PARTIAL_INT:\t\t\t\t\t\t    \\\n-      if (flag_pic\t\t\t\t\t\t\t    \\\n-\t  && (GET_CODE (EXP) == CONST\t\t\t\t\t    \\\n-\t      || GET_CODE (EXP) == SYMBOL_REF\t\t\t\t    \\\n-\t      || GET_CODE (EXP) == LABEL_REF ))\t\t\t\t    \\\n+      if (GET_CODE (EXP) == CONST\t\t\t\t\t    \\\n+\t  || GET_CODE (EXP) == SYMBOL_REF\t\t\t\t    \\\n+\t  || GET_CODE (EXP) == LABEL_REF)\t\t\t\t    \\\n         {\t\t\t\t\t\t\t\t    \\\n \t  fputs (integer_asm_op (UNITS_PER_WORD, TRUE), FILE);\t\t    \\\n           s390_output_symbolic_const (FILE, EXP);\t\t\t    \\"}, {"sha": "fc8e33bfe238e9d54f6d08f1ab3d93dee231627b", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 218, "deletions": 12, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=fd3cd001d57652cb50451eaa7763e1bd29bac8c4", "patch": "@@ -44,6 +44,35 @@\n ;;   s_operand -- Matches a valid S operand in a RS, SI or SS type instruction.\n ;;\n \n+;;\n+;; UNSPEC usage\n+;;\n+\n+(define_constants\n+  [; TLS relocation specifiers\n+   (UNSPEC_TLSGD\t\t500)\n+   (UNSPEC_TLSLDM\t\t501)\n+   (UNSPEC_NTPOFF               502)\n+   (UNSPEC_DTPOFF               503)\n+   (UNSPEC_GOTNTPOFF            504)\n+   (UNSPEC_INDNTPOFF            505)\n+\n+   ; TLS support\n+   (UNSPEC_TP\t\t\t510)\n+   (UNSPEC_TLSLDM_NTPOFF\t511)\n+   (UNSPEC_TLS_LOAD\t\t512)\n+ ])\n+\n+;;\n+;; UNSPEC_VOLATILE usage\n+;;\n+\n+(define_constants\n+  [; TLS support\n+   (UNSPECV_SET_TP\t\t500)\n+  ])\n+\n+\n ;; Processor type.  This attribute must exactly match the processor_type\n ;; enumeration in s390.h.\n \n@@ -938,18 +967,15 @@\n ; movdi instruction pattern(s).\n ;\n \n-;; If generating PIC code and operands[1] is a symbolic CONST, emit a\n-;; move to get the address of the symbolic object from the GOT.\n-\n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  /* Handle PIC symbolic constants.  */\n-  if (TARGET_64BIT && flag_pic && SYMBOLIC_CONST (operands[1]))\n-    emit_pic_move (operands, DImode);\n+  /* Handle symbolic constants.  */\n+  if (TARGET_64BIT && SYMBOLIC_CONST (operands[1]))\n+    emit_symbolic_move (operands);\n \n   /* During and after reload, we need to force constants\n      to the literal pool ourselves, if necessary.  */\n@@ -1099,18 +1125,15 @@\n ; movsi instruction pattern(s).\n ;\n \n-;; If generating PIC code and operands[1] is a symbolic CONST, emit a\n-;; move to get the address of the symbolic object from the GOT.\n-\n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n         (match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  /* Handle PIC symbolic constants.  */\n-  if (!TARGET_64BIT && flag_pic && SYMBOLIC_CONST (operands[1]))\n-    emit_pic_move (operands, SImode);\n+  /* Handle symbolic constants.  */\n+  if (!TARGET_64BIT && SYMBOLIC_CONST (operands[1]))\n+    emit_symbolic_move (operands);\n \n   /* expr.c tries to load an effective address using \n      force_reg.  This fails because we don't have a \n@@ -6461,6 +6484,189 @@\n     (set_attr \"type\"    \"jsr\")])\n \n \n+;;\n+;;- Thread-local storage support.\n+;;\n+\n+(define_insn \"get_tp_64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=??d,Q\")\n+        (unspec:DI [(const_int 0)] UNSPEC_TP))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   ear\\\\t%0,%%a0\\;sllg\\\\t%0,%0,32\\;ear\\\\t%0,%%a1\n+   stam\\\\t%%a0,%%a1,%0\"\n+  [(set_attr \"op_type\" \"NN,RS\")\n+   (set_attr \"atype\"   \"reg,*\")\n+   (set_attr \"type\"    \"o3,*\")\n+   (set_attr \"length\"  \"14,*\")])\n+\n+(define_insn \"get_tp_31\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,Q\")\n+        (unspec:SI [(const_int 0)] UNSPEC_TP))]\n+  \"!TARGET_64BIT\"\n+  \"@\n+   ear\\\\t%0,%%a0\n+   stam\\\\t%%a0,%%a0,%0\"\n+  [(set_attr \"op_type\" \"RRE,RS\")])\n+\n+(define_insn \"set_tp_64\"\n+  [(unspec_volatile [(match_operand:DI 0 \"general_operand\" \"??d,Q\")] UNSPECV_SET_TP)\n+   (clobber (match_scratch:SI 1 \"=d,X\"))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   sar\\\\t%%a1,%0\\;srlg\\\\t%1,%0,32\\;sar\\\\t%%a0,%1\n+   lam\\\\t%%a0,%%a1,%0\"\n+  [(set_attr \"op_type\" \"NN,RS\")\n+   (set_attr \"atype\"   \"reg,*\")\n+   (set_attr \"type\"    \"o3,*\")\n+   (set_attr \"length\"  \"14,*\")])\n+\n+(define_insn \"set_tp_31\"\n+  [(unspec_volatile [(match_operand:SI 0 \"general_operand\" \"d,Q\")] UNSPECV_SET_TP)]\n+  \"!TARGET_64BIT\"\n+  \"@\n+   sar\\\\t%%a0,%0\n+   lam\\\\t%%a0,%%a0,%0\"\n+  [(set_attr \"op_type\" \"RRE,RS\")])\n+  \n+(define_insn \"*tls_load_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")\n+                    (match_operand:DI 2 \"\" \"\")]\n+\t\t   UNSPEC_TLS_LOAD))]\n+  \"TARGET_64BIT\"\n+  \"lg\\\\t%0,%1%J2\"\n+  [(set_attr \"op_type\" \"RXE\")])\n+\n+(define_insn \"*tls_load_31\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")\n+                    (match_operand:SI 2 \"\" \"\")]\n+\t\t   UNSPEC_TLS_LOAD))]\n+  \"!TARGET_64BIT\"\n+  \"l\\\\t%0,%1%J2\"\n+  [(set_attr \"op_type\" \"RX\")])\n+\n+(define_expand \"call_value_tls\"\n+  [(set (match_operand 0 \"\" \"\")\n+        (call (const_int 0) (const_int 0)))\n+   (use (match_operand 1 \"\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  rtx insn, sym;\n+\n+  if (!flag_pic)\n+    abort ();\n+\n+  sym = s390_tls_get_offset ();\n+  sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), 113);\n+  sym = gen_rtx_CONST (Pmode, sym);\n+\n+  /* Unless we can use the bras(l) insn, force the \n+     routine address into a register.  */\n+  if (!TARGET_SMALL_EXEC && !TARGET_64BIT)\n+    {\n+      rtx target = gen_reg_rtx (Pmode);\n+      emit_move_insn (target, sym);\n+      sym = target;\n+    }\n+\n+  sym = gen_rtx_MEM (QImode, sym);\n+\n+  /* Emit insn.  */\n+  insn = emit_call_insn (\n+\t    gen_call_value_tls_exp (operands[0], sym, const0_rtx,\n+  \t\t\t\t    gen_rtx_REG (Pmode, RETURN_REGNUM),\n+\t\t\t\t    operands[1]));\n+\n+  /* The calling convention of __tls_get_offset uses the\n+     GOT register implicitly.  */\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), operands[0]);\n+  CONST_OR_PURE_CALL_P (insn) = 1;\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"call_value_tls_exp\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+                   (call (match_operand 1 \"\" \"\")\n+                         (match_operand 2 \"\" \"\")))\n+              (clobber (match_operand 3 \"\" \"\"))\n+\t      (use (match_operand 4 \"\" \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"brasl_tls\"\n+  [(set (match_operand 0 \"register_operand\" \"=df\")\n+        (call (mem:QI (match_operand:DI 1 \"bras_sym_operand\" \"X\"))\n+              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_operand:DI 3 \"register_operand\" \"=r\"))\n+   (use (match_operand:DI 4 \"\" \"\"))]\n+  \"TARGET_64BIT\"\n+  \"brasl\\\\t%3,%1%J4\"\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"    \"jsr\")])\n+\n+(define_insn \"bras_tls\"\n+  [(set (match_operand 0 \"register_operand\" \"=df\")\n+        (call (mem:QI (match_operand:SI 1 \"bras_sym_operand\" \"X\"))\n+              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))\n+   (use (match_operand:SI 4 \"\" \"\"))]\n+  \"TARGET_SMALL_EXEC\"\n+  \"bras\\\\t%3,%1%J4\"\n+  [(set_attr \"op_type\" \"RI\")\n+   (set_attr \"type\"    \"jsr\")])\n+\n+(define_insn \"basr_tls_64\"\n+  [(set (match_operand 0 \"register_operand\" \"=df\")\n+        (call (mem:QI (match_operand:DI 1 \"register_operand\" \"a\"))\n+              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_operand:DI 3 \"register_operand\" \"=r\"))\n+   (use (match_operand:DI 4 \"\" \"\"))]\n+  \"TARGET_64BIT\"\n+  \"basr\\\\t%3,%1%J4\"\n+  [(set_attr \"op_type\" \"RR\")\n+   (set_attr \"type\"    \"jsr\")])\n+\n+(define_insn \"basr_tls_31\"\n+  [(set (match_operand 0 \"register_operand\" \"=df\")\n+        (call (mem:QI (match_operand:SI 1 \"register_operand\" \"a\"))\n+              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))\n+   (use (match_operand:SI 4 \"\" \"\"))]\n+  \"!TARGET_64BIT\"\n+  \"basr\\\\t%3,%1%J4\"\n+  [(set_attr \"op_type\" \"RR\")\n+   (set_attr \"type\"    \"jsr\")\n+   (set_attr \"atype\"   \"agen\")])\n+\n+(define_insn \"bas_tls_64\"\n+  [(set (match_operand 0 \"register_operand\" \"=df\")\n+        (call (mem:QI (match_operand:QI 1 \"address_operand\" \"p\"))\n+              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_operand:DI 3 \"register_operand\" \"=r\"))\n+   (use (match_operand:DI 4 \"\" \"\"))]\n+  \"TARGET_64BIT\"\n+  \"bas\\\\t%3,%a1%J4\"\n+  [(set_attr \"op_type\" \"RX\")\n+   (set_attr \"type\"    \"jsr\")\n+   (set_attr \"atype\"   \"agen\")])\n+\n+(define_insn \"bas_tls_31\"\n+  [(set (match_operand 0 \"register_operand\" \"=df\")\n+        (call (mem:QI (match_operand:QI 1 \"address_operand\" \"p\"))\n+              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))\n+   (use (match_operand:SI 4 \"\" \"\"))]\n+  \"!TARGET_64BIT\"\n+  \"bas\\\\t%3,%a1%J4\"\n+   [(set_attr \"op_type\" \"RX\")\n+    (set_attr \"type\"    \"jsr\")\n+    (set_attr \"atype\"   \"agen\")])\n+\n ;;\n ;;- Miscellaneous instructions.\n ;;"}, {"sha": "060b1359061e7b3eea579d2e297a5435380fffa9", "filename": "gcc/configure", "status": "modified", "additions": 50, "deletions": 15, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=fd3cd001d57652cb50451eaa7763e1bd29bac8c4", "patch": "@@ -7942,6 +7942,41 @@ foo:\tdata8\t25\n \ttls_first_major=2\n \ttls_first_minor=13\n \t;;\n+  s390-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\t.long\tfoo@TLSGD\n+\t.long\tfoo@TLSLDM\n+\t.long\tfoo@DTPOFF\n+\t.long\tfoo@NTPOFF\n+\t.long\tfoo@GOTNTPOFF\n+\t.long\tfoo@INDNTPOFF\n+\tl\t%r1,foo@GOTNTPOFF(%r12)\n+\tl\t%r1,0(%r1):tls_load:foo\n+\tbas\t%r14,0(%r1,%r13):tls_gdcall:foo\n+\tbas\t%r14,0(%r1,%r13):tls_ldcall:foo'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n+\t;;\n+  s390x-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\t.quad\tfoo@TLSGD\n+\t.quad\tfoo@TLSLDM\n+\t.quad\tfoo@DTPOFF\n+\t.quad\tfoo@NTPOFF\n+\t.quad\tfoo@GOTNTPOFF\n+\tlg\t%r1,foo@GOTNTPOFF(%r12)\n+\tlarl\t%r1,foo@INDNTPOFF\n+\tbrasl\t%r14,__tls_get_offset@PLT:tls_gdcall:foo\n+\tbrasl\t%r14,__tls_get_offset@PLT:tls_ldcall:foo'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n+\t;;\n esac\n if test -z \"$tls_first_major\"; then\n   :\n@@ -7972,7 +8007,7 @@ case \"$target\" in\n   # All TARGET_ABI_OSF targets.\n   alpha*-*-osf* | alpha*-*-linux* | alpha*-*-*bsd*)\n     echo $ac_n \"checking assembler supports explicit relocations\"\"... $ac_c\" 1>&6\n-echo \"configure:7976: checking assembler supports explicit relocations\" >&5\n+echo \"configure:8011: checking assembler supports explicit relocations\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_explicit_relocs'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8022,7 +8057,7 @@ EOF\n     ;;\n   sparc*-*-*)\n     echo $ac_n \"checking assembler .register pseudo-op support\"\"... $ac_c\" 1>&6\n-echo \"configure:8026: checking assembler .register pseudo-op support\" >&5\n+echo \"configure:8061: checking assembler .register pseudo-op support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_register_pseudo_op'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8050,7 +8085,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler supports -relax\"\"... $ac_c\" 1>&6\n-echo \"configure:8054: checking assembler supports -relax\" >&5\n+echo \"configure:8089: checking assembler supports -relax\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_relax_opt'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8078,7 +8113,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:8082: checking assembler and linker support unaligned pc related relocs\" >&5\n+echo \"configure:8117: checking assembler and linker support unaligned pc related relocs\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8105,7 +8140,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs against hidden symbols\"\"... $ac_c\" 1>&6\n-echo \"configure:8109: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n+echo \"configure:8144: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel_hidden'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8145,7 +8180,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking for assembler offsetable %lo() support\"\"... $ac_c\" 1>&6\n-echo \"configure:8149: checking for assembler offsetable %lo() support\" >&5\n+echo \"configure:8184: checking for assembler offsetable %lo() support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_offsetable_lo10'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8184,7 +8219,7 @@ EOF\n \n   i[34567]86-*-* | x86_64-*-*)\n     echo $ac_n \"checking assembler instructions\"\"... $ac_c\" 1>&6\n-echo \"configure:8188: checking assembler instructions\" >&5\n+echo \"configure:8223: checking assembler instructions\" >&5\n     gcc_cv_as_instructions=\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n       if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 9 -o \"$gcc_cv_gas_major_version\" -gt 2; then\n@@ -8211,7 +8246,7 @@ EOF\n     echo \"$ac_t\"\"$gcc_cv_as_instructions\" 1>&6\n \n     echo $ac_n \"checking assembler GOTOFF in data directives\"\"... $ac_c\" 1>&6\n-echo \"configure:8215: checking assembler GOTOFF in data directives\" >&5\n+echo \"configure:8250: checking assembler GOTOFF in data directives\" >&5\n     gcc_cv_as_gotoff_in_data=no\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x\n     then\n@@ -8241,7 +8276,7 @@ EOF\n esac\n \n echo $ac_n \"checking assembler dwarf2 debug_line support\"\"... $ac_c\" 1>&6\n-echo \"configure:8245: checking assembler dwarf2 debug_line support\" >&5\n+echo \"configure:8280: checking assembler dwarf2 debug_line support\" >&5\n gcc_cv_as_dwarf2_debug_line=no\n # ??? Not all targets support dwarf2 debug_line, even within a version\n # of gas.  Moreover, we need to emit a valid instruction to trigger any\n@@ -8298,7 +8333,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_dwarf2_debug_line\" 1>&6\n \n echo $ac_n \"checking assembler --gdwarf2 support\"\"... $ac_c\" 1>&6\n-echo \"configure:8302: checking assembler --gdwarf2 support\" >&5\n+echo \"configure:8337: checking assembler --gdwarf2 support\" >&5\n gcc_cv_as_gdwarf2_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -8327,7 +8362,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gdwarf2_flag\" 1>&6\n \n echo $ac_n \"checking assembler --gstabs support\"\"... $ac_c\" 1>&6\n-echo \"configure:8331: checking assembler --gstabs support\" >&5\n+echo \"configure:8366: checking assembler --gstabs support\" >&5\n gcc_cv_as_gstabs_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -8355,7 +8390,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gstabs_flag\" 1>&6\n \n echo $ac_n \"checking linker read-only and read-write section mixing\"\"... $ac_c\" 1>&6\n-echo \"configure:8359: checking linker read-only and read-write section mixing\" >&5\n+echo \"configure:8394: checking linker read-only and read-write section mixing\" >&5\n gcc_cv_ld_ro_rw_mix=unknown\n if test x$gcc_cv_gld_major_version != x -a x$gcc_cv_gld_minor_version != x; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 10 -o \"$gcc_cv_gld_major_version\" -gt 2 && grep 'EMUL = elf' ../ld/Makefile > /dev/null; then\n@@ -8393,7 +8428,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_ld_ro_rw_mix\" 1>&6\n \n echo $ac_n \"checking linker PT_GNU_EH_FRAME support\"\"... $ac_c\" 1>&6\n-echo \"configure:8397: checking linker PT_GNU_EH_FRAME support\" >&5\n+echo \"configure:8432: checking linker PT_GNU_EH_FRAME support\" >&5\n gcc_cv_ld_eh_frame_hdr=no\n if test x$gcc_cv_gld_major_version != x -a x$gcc_cv_gld_minor_version != x; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 12 -o \"$gcc_cv_gld_major_version\" -gt 2 && grep 'EMUL = elf' ../ld/Makefile > /dev/null; then\n@@ -8417,7 +8452,7 @@ echo \"$ac_t\"\"$gcc_cv_ld_eh_frame_hdr\" 1>&6\n case \"$target\" in\n   mips*-*-*)\n     echo $ac_n \"checking whether libgloss uses STARTUP directives consistently\"\"... $ac_c\" 1>&6\n-echo \"configure:8421: checking whether libgloss uses STARTUP directives consistently\" >&5\n+echo \"configure:8456: checking whether libgloss uses STARTUP directives consistently\" >&5\n     gcc_cv_mips_libgloss_startup=no\n     gcc_cv_libgloss_srcdir=`echo $srcdir | sed -e 's,/gcc$,,'`/libgloss\n     if test \"x$exec_prefix\" = xNONE; then\n@@ -8621,7 +8656,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:8625: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:8660: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\""}, {"sha": "4ec16ea3dcd3a4efd155132363d4606c62c7675c", "filename": "gcc/configure.in", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3cd001d57652cb50451eaa7763e1bd29bac8c4/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=fd3cd001d57652cb50451eaa7763e1bd29bac8c4", "patch": "@@ -1944,6 +1944,41 @@ foo:\tdata8\t25\n \ttls_first_major=2\n \ttls_first_minor=13\n \t;;\n+  s390-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\t.long\tfoo@TLSGD\n+\t.long\tfoo@TLSLDM\n+\t.long\tfoo@DTPOFF\n+\t.long\tfoo@NTPOFF\n+\t.long\tfoo@GOTNTPOFF\n+\t.long\tfoo@INDNTPOFF\n+\tl\t%r1,foo@GOTNTPOFF(%r12)\n+\tl\t%r1,0(%r1):tls_load:foo\n+\tbas\t%r14,0(%r1,%r13):tls_gdcall:foo\n+\tbas\t%r14,0(%r1,%r13):tls_ldcall:foo'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n+\t;;\n+  s390x-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\t.quad\tfoo@TLSGD\n+\t.quad\tfoo@TLSLDM\n+\t.quad\tfoo@DTPOFF\n+\t.quad\tfoo@NTPOFF\n+\t.quad\tfoo@GOTNTPOFF\n+\tlg\t%r1,foo@GOTNTPOFF(%r12)\n+\tlarl\t%r1,foo@INDNTPOFF\n+\tbrasl\t%r14,__tls_get_offset@PLT:tls_gdcall:foo\n+\tbrasl\t%r14,__tls_get_offset@PLT:tls_ldcall:foo'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n+\t;;\n esac\n if test -z \"$tls_first_major\"; then\n   :"}]}