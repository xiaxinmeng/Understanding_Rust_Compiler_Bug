{"sha": "f8710242d38de963d4d8204af1058cef8c05472b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg3MTAyNDJkMzhkZTk2M2Q0ZDgyMDRhZjEwNThjZWY4YzA1NDcyYg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-05-23T22:50:28Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-05-23T22:50:28Z"}, "message": "cpp.texi: Update for handling of charconsts.\n\n\t* cpp.texi: Update for handling of charconsts.\n\t* cpplex.c (maybe_read_ucs): Don't accept D800-DFFF.  Update\n\tdiagnostics.  Skip to the end if the UCS is too short.\n\t(cpp_interpret_charconst): Long charconsts issue a warning\n\tnot an error.\n\n\t* gcc.dg/cpp/charconst.c: New tests.\n\t* gcc.dg/cpp/escape.c: New tests.\n\t* gcc.dg/cpp/escape-1.c: New tests.\n\t* gcc.dg/cpp/escape-2.c: New tests.\n\t* gcc.dg/cpp/ucs.c: New tests.\n\nFrom-SVN: r42514", "tree": {"sha": "6ccc83b80dfb184aeb83b9ad4fb992c103b4b1b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ccc83b80dfb184aeb83b9ad4fb992c103b4b1b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8710242d38de963d4d8204af1058cef8c05472b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8710242d38de963d4d8204af1058cef8c05472b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8710242d38de963d4d8204af1058cef8c05472b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8710242d38de963d4d8204af1058cef8c05472b/comments", "author": null, "committer": null, "parents": [{"sha": "75f3e3c8d6d152e9876857a0e0b3b717115dede9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75f3e3c8d6d152e9876857a0e0b3b717115dede9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75f3e3c8d6d152e9876857a0e0b3b717115dede9"}], "stats": {"total": 249, "additions": 207, "deletions": 42}, "files": [{"sha": "14102e11d027805bb3be7f82b4441e68022870bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8710242d38de963d4d8204af1058cef8c05472b", "patch": "@@ -1,3 +1,11 @@\n+2001-05-23  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpp.texi: Update for handling of charconsts.\n+\t* cpplex.c (maybe_read_ucs): Don't accept D800-DFFF.  Update\n+\tdiagnostics.  Skip to the end if the UCS is too short.\n+\t(cpp_interpret_charconst): Long charconsts issue a warning\n+\tnot an error.\n+\n 2001-05-23  Richard Henderson  <rth@redhat.com>\n \n \t* doc/install.texi (alpha-linux): Require binutils 2.11."}, {"sha": "a5dc889ae922691e183ba0f30ce10b9e147b49ef", "filename": "gcc/cpp.texi", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=f8710242d38de963d4d8204af1058cef8c05472b", "patch": "@@ -2889,22 +2889,17 @@ same column as it did in the original source file.\n \n @item The numeric value of character constants in preprocessor expressions.\n \n-The preprocessor interprets character constants in preprocessing\n-directives on the host machine.  Expressions outside preprocessing\n-directives are compiled to be interpreted on the target machine.  In the\n-normal case of a native compiler, these two environments are the same\n-and so character constants will be evaluated identically in both cases.\n-However, in the case of a cross compiler, the values may be different.\n+The preprocessor and compiler interpret character constants in the same\n+way; escape sequences such as @code{\\a} are given the values they would\n+have on the target machine.\n \n Multi-character character constants are interpreted a character at a\n time, shifting the previous result left by the number of bits per\n character on the host, and adding the new character.  For example, 'ab'\n on an 8-bit host would be interpreted as 'a' * 256 + 'b'.  If there are\n more characters in the constant than can fit in the widest native\n-integer type on the host, usually a @samp{long}, the behavior is\n-undefined.\n-\n-Evaluation of wide character constants is not properly implemented yet.\n+integer type on the host, usually a @samp{long}, the excess characters\n+are ignored and a diagnostic is given.\n \n @item Source file inclusion.\n "}, {"sha": "3185accece0ce1f7df9b9564d511be2990ef71f4", "filename": "gcc/cpplex.c", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=f8710242d38de963d4d8204af1058cef8c05472b", "patch": "@@ -1706,46 +1706,48 @@ maybe_read_ucs (pfile, pstr, limit, pc)\n \n   if (CPP_WTRADITIONAL (pfile))\n     cpp_warning (pfile, \"the meaning of '\\\\%c' varies with -traditional\", c);\n-  \n-  for (length = (c == 'u' ? 4: 8); length; --length)\n-    {\n-      if (p >= limit)\n-\t{\n-\t  cpp_error (pfile, \"incomplete universal-character-name\");\n-\t  break;\n-\t}\n \n-      c = *p;\n-      if (ISXDIGIT (c))\n-\t{\n-\t  code = (code << 4) + hex_digit_value (c);\n-\t  p++;\n-\t}\n-      else\n+  length = (c == 'u' ? 4: 8);\n+\n+  if ((size_t) (limit - p) < length)\n+    {\n+      cpp_error (pfile, \"incomplete universal-character-name\");\n+      /* Skip to the end to avoid more diagnostics.  */\n+      p = limit;\n+    }\n+  else\n+    {\n+      for (; length; length--, p++)\n \t{\n-\t  cpp_error (pfile,\n-\t\t     \"non-hex digit '%c' in universal-character-name\", c);\n-\t  break;\n+\t  c = *p;\n+\t  if (ISXDIGIT (c))\n+\t    code = (code << 4) + hex_digit_value (c);\n+\t  else\n+\t    {\n+\t      cpp_error (pfile,\n+\t\t\t \"non-hex digit '%c' in universal-character-name\", c);\n+\t      /* We shouldn't skip in case there are multibyte chars.  */\n+\t      break;\n+\t    }\n \t}\n-\n     }\n \n #ifdef TARGET_EBCDIC\n   cpp_error (pfile, \"universal-character-name on EBCDIC target\");\n   code = 0x3f;  /* EBCDIC invalid character */\n #else\n-  if (code > 0x9f && !(code & 0x80000000))\n-    ; /* True extended character, OK.  */\n-  else if (code >= 0x20 && code < 0x7f)\n-    {\n-      /* ASCII printable character.  The C character set consists of all of\n-\t these except $, @ and `.  We use hex escapes so that this also\n-\t works with EBCDIC hosts.  */\n-      if (code != 0x24 && code != 0x40 && code != 0x60)\n-\tcpp_error (pfile, \"universal-character-name used for '%c'\", code);\n-    }\n-  else\n-    cpp_error (pfile, \"invalid universal-character-name\");\n+ /* True extended characters are OK.  */\n+  if (code >= 0xa0\n+      && !(code & 0x80000000)\n+      && !(code >= 0xD800 && code <= 0xDFFF))\n+    ;\n+  /* The standard permits $, @ and ` to be specified as UCNs.  We use\n+     hex escapes so that this also works with EBCDIC hosts.  */\n+  else if (code == 0x24 || code == 0x40 || code == 0x60)\n+    ;\n+  /* Don't give another error if one occurred above.  */\n+  else if (length == 0)\n+    cpp_error (pfile, \"universal-character-name out of range\");\n #endif\n \n   *pstr = p;\n@@ -1970,7 +1972,7 @@ cpp_interpret_charconst (pfile, token, warn_multi, traditional, pchars_seen)\n   else if (chars_seen > max_chars)\n     {\n       chars_seen = max_chars;\n-      cpp_error (pfile, \"character constant too long\");\n+      cpp_warning (pfile, \"character constant too long\");\n     }\n   else if (chars_seen > 1 && !traditional && warn_multi)\n     cpp_warning (pfile, \"multi-character character constant\");"}, {"sha": "826918ea64e18a6ee55ac4240787bd6255c79ede", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8710242d38de963d4d8204af1058cef8c05472b", "patch": "@@ -1,3 +1,11 @@\n+2001-05-23  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/charconst.c: New tests.\n+\t* gcc.dg/cpp/escape.c: New tests.\n+\t* gcc.dg/cpp/escape-1.c: New tests.\n+\t* gcc.dg/cpp/escape-2.c: New tests.\n+\t* gcc.dg/cpp/ucs.c: New tests.\n+\n 2001-05-23  David.Billinghurst <David.Billinghurst@riotinto.com>\n \n \t* gcc.misc-tests/linkage.exp:  Pass appropriate flags to "}, {"sha": "d8a178b7a9f6dcf07d552b5bedf1689b5a0eacd7", "filename": "gcc/testsuite/gcc.dg/cpp/charconst.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fcharconst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fcharconst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fcharconst.c?ref=f8710242d38de963d4d8204af1058cef8c05472b", "patch": "@@ -0,0 +1,33 @@\n+/* Copyright (C) 2001 Free Software Foundation, Inc.  */\n+\n+/* { dg-do compile } */\n+\n+/* This tests various diagnostics about character constants, for both\n+   the preprocessor and the compiler.\n+\n+   Neil Booth, 22 May 2001.  */\n+\n+#if ''\t\t\t/* { dg-warning \"empty\" \"empty charconst\" } */\n+#endif\n+#if L''\t\t\t/* { dg-warning \"empty\" \"empty wide charconst\" } */\n+#endif\n+#if 'very long'\t\t/* { dg-warning \"too long\" \"long charconst\" } */\n+#endif\n+#if L'very long'\t/* { dg-warning \"too long\" \"long wide charconst\" } */\n+#endif\n+/* Don't do this test for L'ab'; it depends upon sizeof (wchar_t).  */\n+#if 'ab'\t\t/* { dg-warning \"multi-char\" \"multi-character\" } */\n+#endif\n+\n+void foo ()\n+{\n+  int c = '';\t\t/* { dg-warning \"empty\" \"empty charconst\" } */\n+  c = L'';\t\t/* { dg-warning \"empty\" \"empty wide charconst\" } */\n+\n+  c = 'very long';\t/* { dg-warning \"too long\" \"long charconst\" } */\n+  c = L'very long';\t/* { dg-warning \"too long\" \"long wide charconst\" } */\n+\n+  /* Don't do this test for L'ab'; it depends upon sizeof (wchar_t).  */\n+  c = 'ab';\t\t/* { dg-warning \"multi-char\" \"multi-character\" } */\n+ \n+}"}, {"sha": "52d7414f3ae9f879abf8857a3afef22c0d37e492", "filename": "gcc/testsuite/gcc.dg/cpp/escape-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape-1.c?ref=f8710242d38de963d4d8204af1058cef8c05472b", "patch": "@@ -0,0 +1,39 @@\n+/* Copyright (C) 2001 Free Software Foundation, Inc.  */\n+\n+/* { dg-do compile } */\n+\n+/* This tests various diagnostics about escape sequences, for both\n+   the preprocessor and the compiler.\n+\n+   Neil Booth, 22 May 2001.  */\n+\n+#if '\\x'\t/* { dg-error \"no following\" \"\\x with no digits\" } */\n+#endif\n+#if '\\x400'\t/* { dg-warning \"out of range\" \"\\x out of range\" } */\n+#endif\n+#if '\\x0ff'\t/* { dg-bogus \"out of range\" \"\\x out of range\" } */\n+#endif\n+#if '\\400'\t/* { dg-warning \"out of range\" \"\\x out of range\" } */\n+#endif\n+#if '\\377'\t/* { dg-bogus \"out of range\" \"bogus \\x out of range\" } */\n+#endif\n+#if '\\177' != 0x7f /* { dg-bogus \"out of range\" \"bogus \\x out of range\" } */\n+#error bad octal /* { dg-bogus \"bad\" \"bad octal evaluation\" } */\n+#endif\n+#if '\\0377'\t/* { dg-warning \"multi\" \"too long octal\" } */\n+#endif\n+#if '\\p'\t/* { dg-error \"unknown escape\" \"unknown escape seq\" } */\n+#endif\n+\n+void foo ()\n+{\n+  int c;\n+\n+  c = '\\x';\t/* { dg-error \"no following\" \"\\x with no digits\" } */\n+  c = '\\x100';\t/* { dg-warning \"out of range\" \"\\x out of range\" } */\n+  c = '\\x0ff';\t/* { dg-bogus \"out of range\" \"\\x out of range\" } */\n+  c = '\\400';\t/* { dg-warning \"out of range\" \"\\x out of range\" } */\n+  c = '\\377';\t/* { dg-bogus \"out of range\" \"bogus \\x out of range\" } */\n+  c = '\\0377';\t/* { dg-warning \"multi\" \"too long octal\" } */\n+  c = '\\p';\t/* { dg-error \"unknown escape\" \"unknown escape seq\" } */\n+}"}, {"sha": "31bf882c7211b4e934df4762e40952f15c50f0a0", "filename": "gcc/testsuite/gcc.dg/cpp/escape-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape-2.c?ref=f8710242d38de963d4d8204af1058cef8c05472b", "patch": "@@ -0,0 +1,20 @@\n+/* Copyright (C) 2001 Free Software Foundation, Inc.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-pedantic -std=c99 -fno-show-column\" } */\n+\n+/* This tests various diagnostics with -pedantic about escape\n+   sequences, for both the preprocessor and the compiler.\n+\n+   Neil Booth, 22 May 2001.  */\n+\n+#if '\\e'\t\t/* { dg-warning \"non-ISO\" \"non-ISO \\\\e\" } */\n+#endif\n+#if '\\u00a0'\t\t/* { dg-bogus \"unknown\" \"\\\\u is known in C99\" } */\n+#endif\n+\n+void foo ()\n+{\n+  int c = '\\E';\t\t/* { dg-warning \"non-ISO\" \"non-ISO \\\\E\" } */\n+  c = '\\u00a0';\t\t/* { dg-bogus \"unknown\" \"\\\\u is known in C99\" } */\n+}"}, {"sha": "44ad4c1d2bf2fd1069dafc5dbde2fdefbe3da919", "filename": "gcc/testsuite/gcc.dg/cpp/escape.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape.c?ref=f8710242d38de963d4d8204af1058cef8c05472b", "patch": "@@ -0,0 +1,25 @@\n+/* Copyright (C) 2001 Free Software Foundation, Inc.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wtraditional -std=c89 -fno-show-column\" } */\n+\n+/* This tests various diagnostics with -Wtraditioanl about escape\n+   sequences, for both the preprocessor and the compiler.\n+\n+   Neil Booth, 22 May 2001.  */\n+\n+#if '\\a'\t\t/* { dg-warning \"traditional\" \"traditional bell\" } */\n+#endif\n+#if '\\x1a' != 26\t/* { dg-warning \"traditional\" \"traditional hex\" } */\n+ #error bad hex\t\t/* { dg-bogus \"bad\" \"bad hexadecimal evaluation\" } */\n+#endif\n+#if '\\u'\t\t/* { dg-warning \"unknown\" \"\\u is unknown in C89\" } */\n+#endif\n+\n+void foo ()\n+{\n+  int c = '\\a';\t\t/* { dg-warning \"traditional\" \"traditional bell\" } */\n+\n+  c = '\\xa1';\t\t/* { dg-warning \"traditional\" \"traditional hex\" } */\n+  c = '\\u';\t\t/* { dg-warning \"unknown\" \"\\u is unknown in C89\" } */\n+}"}, {"sha": "d131b0b5b93c6720f77505091af004429800db6c", "filename": "gcc/testsuite/gcc.dg/cpp/ucs.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8710242d38de963d4d8204af1058cef8c05472b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucs.c?ref=f8710242d38de963d4d8204af1058cef8c05472b", "patch": "@@ -0,0 +1,35 @@\n+/* Copyright (C) 2001 Free Software Foundation, Inc.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+/* This tests universal character sequences.\n+\n+   Neil Booth, 22 May 2001.  */\n+\n+#if L'\\u1234' != 0x1234\n+#error bad short ucs\t/* { dg-bogus \"bad\" \"bad \\u1234 evaluation\" } */\n+#endif\n+#if L'\\U1234abcd' != 0x1234abcd\n+#error bad long ucs\t/* { dg-bogus \"bad\" \"bad \\U1234abcd evaluation\" } */\n+#endif\n+\n+void foo ()\n+{\n+  int c;\n+\n+  c = L'\\ubad';\t\t/* { dg-error \"incomplete\" \"incompete UCN 1\" } */\n+  c = L\"\\U1234\"[0];\t/* { dg-error \"incomplete\" \"incompete UCN 2\" } */\n+\n+  c = L'\\u000x';\t/* { dg-error \"non-hex\" \"non-hex digit in UCN\" } */\n+\t\t\t/* { dg-warning \"too long\" \"\" { target *-*-* } 24 } */\n+\n+  c = '\\u0024';\t\t/* { dg-bogus \"invalid\" \"0024 is a valid UCN\" } */\n+  c = \"\\u0040\"[0];\t/* { dg-bogus \"invalid\" \"0040 is a valid UCN\" } */\n+  c = '\\u00a0';\t\t/* { dg-bogus \"invalid\" \"00a0 is a valid UCN\" } */\n+  c = '\\U00000060';\t/* { dg-bogus \"invalid\" \"0060 is a valid UCN\" } */\n+\n+  c = '\\u0025';\t\t/* { dg-error \"range\" \"0025 is an invalid UCN\" } */\n+  c = L\"\\uD800\"[0];\t/* { dg-error \"range\" \"D800 is an invalid UCN\" } */\n+  c = L'\\U0000DFFF';\t/* { dg-error \"range\" \"DFFF is an invalid UCN\" } */\n+}"}]}