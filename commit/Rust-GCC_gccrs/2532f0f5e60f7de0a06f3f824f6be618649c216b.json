{"sha": "2532f0f5e60f7de0a06f3f824f6be618649c216b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUzMmYwZjVlNjBmN2RlMGEwNmYzZjgyNGY2YmU2MTg2NDljMjE2Yg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-08-22T21:29:49Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-08-22T21:29:49Z"}, "message": "gfortran.texi: Mention that asynchronous I/O does not work on systems which lack condition...\n\n2018-08-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* gfortran.texi: Mention that asynchronous I/O does\n\tnot work on systems which lack condition variables, such\n\tas AIX.\n\n2018-08-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* async.h: Set ASYNC_IO to zero if _AIX is defined.\n\t(struct adv_cond): If ASYNC_IO is zero, the struct has no members.\n\t(async_unit): If ASYNC_IO is zero, remove unneeded members.\n\nFrom-SVN: r263788", "tree": {"sha": "b91d1a612866680c53415ca99b53c32ffcde9d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b91d1a612866680c53415ca99b53c32ffcde9d8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2532f0f5e60f7de0a06f3f824f6be618649c216b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2532f0f5e60f7de0a06f3f824f6be618649c216b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2532f0f5e60f7de0a06f3f824f6be618649c216b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2532f0f5e60f7de0a06f3f824f6be618649c216b/comments", "author": null, "committer": null, "parents": [{"sha": "bcddf743dd356082eca0a580881da0df683fe5ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcddf743dd356082eca0a580881da0df683fe5ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcddf743dd356082eca0a580881da0df683fe5ea"}], "stats": {"total": 38, "additions": 27, "deletions": 11}, "files": [{"sha": "56e9c952795849522dc143982602c2a1520f2bd1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2532f0f5e60f7de0a06f3f824f6be618649c216b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2532f0f5e60f7de0a06f3f824f6be618649c216b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2532f0f5e60f7de0a06f3f824f6be618649c216b", "patch": "@@ -1,3 +1,9 @@\n+2018-08-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* gfortran.texi: Mention that asynchronous I/O does\n+\tnot work on systems which lack condition variables, such\n+\tas AIX.\n+\n 2018-08-22  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/86935"}, {"sha": "30934046a49f78c07ea4888ab5f6289660298b05", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2532f0f5e60f7de0a06f3f824f6be618649c216b/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2532f0f5e60f7de0a06f3f824f6be618649c216b/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=2532f0f5e60f7de0a06f3f824f6be618649c216b", "patch": "@@ -1509,7 +1509,8 @@ end program main\n \n Asynchronous I/O is supported if the program is linked against the\n POSIX thread library. If that is not the case, all I/O is performed\n-as synchronous.\n+as synchronous. On systems which do not support pthread condition\n+variables, such as AIX, I/O is also performed as synchronous.\n \n On some systems, such as Darwin or Solaris, the POSIX thread library\n is always linked in, so asynchronous I/O is always performed. On other"}, {"sha": "8f5211866acab1cc0b711abd6369bc146f1dc811", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2532f0f5e60f7de0a06f3f824f6be618649c216b/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2532f0f5e60f7de0a06f3f824f6be618649c216b/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=2532f0f5e60f7de0a06f3f824f6be618649c216b", "patch": "@@ -1,3 +1,9 @@\n+2018-08-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* async.h: Set ASYNC_IO to zero if _AIX is defined.\n+\t(struct adv_cond): If ASYNC_IO is zero, the struct has no members.\n+\t(async_unit): If ASYNC_IO is zero, remove unneeded members.\n+\n 2018-08-21  Nicolas Koenig  <koenigni@gcc.gnu.org>\n \tThomas Koenig <tkoenig@gcc.gnu.org>\n "}, {"sha": "47081a151519fa911c2ce9eee08c8daebc249a82", "filename": "libgfortran/io/async.h", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2532f0f5e60f7de0a06f3f824f6be618649c216b/libgfortran%2Fio%2Fasync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2532f0f5e60f7de0a06f3f824f6be618649c216b/libgfortran%2Fio%2Fasync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fasync.h?ref=2532f0f5e60f7de0a06f3f824f6be618649c216b", "patch": "@@ -29,7 +29,7 @@\n    __gthread_cond_t and __gthread_equal / __gthread_self.  Check\n    this.  */\n \n-#if defined(__GTHREAD_HAS_COND) && defined(__GTHREADS_CXX0X)\n+#if defined(__GTHREAD_HAS_COND) && defined(__GTHREADS_CXX0X) && !defined(_AIX)\n #define ASYNC_IO 1\n #else\n #define ASYNC_IO 0\n@@ -328,21 +328,18 @@ typedef union transfer_args\n \n struct adv_cond\n {\n+#if ASYNC_IO\n   int pending;\n   __gthread_mutex_t lock;\n   __gthread_cond_t signal;\n+#endif\n };\n \n typedef struct async_unit\n {\n-  pthread_mutex_t lock;      /* Lock for manipulating the queue structure.  */\n   pthread_mutex_t io_lock;   /* Lock for doing actual I/O. */\n-  struct adv_cond work;\n-  struct adv_cond emptysignal;\n-  struct st_parameter_dt *pdt;\n-  pthread_t thread;\n-  struct transfer_queue *head;\n-  struct transfer_queue *tail;\n+  pthread_mutex_t lock;      /* Lock for manipulating the queue structure.  */\n+  bool empty;\n   struct\n   {\n     int waiting;\n@@ -351,7 +348,13 @@ typedef struct async_unit\n     struct adv_cond done;\n   } id;\n \n-  bool empty;\n+#if ASYNC_IO\n+  struct adv_cond work;\n+  struct adv_cond emptysignal;\n+  struct st_parameter_dt *pdt;\n+  pthread_t thread;\n+  struct transfer_queue *head;\n+  struct transfer_queue *tail;\n \n   struct {\n     const char *message;\n@@ -361,7 +364,7 @@ typedef struct async_unit\n     int family;\n     bool fatal_error;\n   } error;\n-\n+#endif\n } async_unit;\n \n void init_async_unit (gfc_unit *);"}]}