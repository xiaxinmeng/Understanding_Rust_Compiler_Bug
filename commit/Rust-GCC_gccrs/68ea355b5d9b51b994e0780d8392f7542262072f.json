{"sha": "68ea355b5d9b51b994e0780d8392f7542262072f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhlYTM1NWI1ZDliNTFiOTk0ZTA3ODBkODM5MmY3NTQyMjYyMDcyZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-01-21T09:08:54Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-01-21T09:08:54Z"}, "message": "PR25024, PR20881, PR23308, PR25538 and PR25710 - Procedure references\n\n2005-01-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25124\n\tPR fortran/25625\n\t* decl.c (get_proc_name): If there is an existing\n\tsymbol in the encompassing namespace, call errors\n\tif it is a procedure of the same name or the kind\n\tfield is set, indicating a type declaration.\n\n\tPR fortran/20881\n\tPR fortran/23308\n\tPR fortran/25538\n\tPR fortran/25710\n\t* decl.c (add_global_entry): New function to check\n\tfor existing global symbol with this name and to\n\tcreate new one if none exists.\n\t(gfc_match_entry): Call add_global_entry before\n\tmatching argument lists for subroutine and function\n\tentries.\n\t* gfortran.h: Prototype for existing function,\n\tglobal_used.\n\t* resolve.c (resolve_global_procedure): New function\n\tto check global symbols for procedures.\n\t(resolve_call, resolve_function): Calls to this\n\tnew function for non-contained and non-module\n\tprocedures.\n\t* match.c (match_common): Add check for existing\n\tglobal symbol, creat one if none exists and emit\n\terror if there is a clash.\n\t* parse.c (global_used): Remove static and use the\n\tgsymbol name rather than the new_block name, so that\n\tthe function can be called from resolve.c.\n\t(parse_block_data, parse_module, add_global_procedure):\n\tImprove checks for existing gsymbols.  Emit error if\n\talready defined or if references were to another type.\n\tSet defined flag.\n\n\tPR fortran/PR24276\n\t* trans-expr.c (gfc_conv_aliased_arg): New function called by \n\tgfc_conv_function_call that coverts an expression for an aliased\n\tcomponent reference to a derived type array into a temporary array\n\tof the same type as the component.  The temporary is passed as an\n\tactual argument for the procedure call and is copied back to the\n\tderived type after the call.\n\t(is_aliased_array): New function that detects an array reference\n\tthat is followed by a component reference.\n\t(gfc_conv_function_call): Detect an aliased actual argument with\n\tis_aliased_array and convert it to a temporary and back again\n\tusing gfc_conv_aliased_arg.\n\n2005-01-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25124\n\tPR fortran/25625\n\t* gfortran.dg/internal_references_1.f90: New test.\n\t  PR fortran/20881\n\tPR fortran/23308\n\tPR fortran/25538\n\tPR fortran/25710\n\t* gfortran.dg/global_references_1.f90: New test.\n\t* gfortran.dg/g77/19990905-1.f: Restore the error that\n\tthere is a clash between the common block name and\n\tthe name of a subroutine reference.\n\n\tPR fortran/PR24276\n\t* gfortran.dg/aliasing_dummy_1.f90: New test.\n\nFrom-SVN: r110063", "tree": {"sha": "d96186ed49727fa545b68d7e5eaffe6789ccb236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d96186ed49727fa545b68d7e5eaffe6789ccb236"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68ea355b5d9b51b994e0780d8392f7542262072f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ea355b5d9b51b994e0780d8392f7542262072f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ea355b5d9b51b994e0780d8392f7542262072f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ea355b5d9b51b994e0780d8392f7542262072f/comments", "author": null, "committer": null, "parents": [{"sha": "4e27a177f8a488fc1f9a3462672582715e164f0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e27a177f8a488fc1f9a3462672582715e164f0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e27a177f8a488fc1f9a3462672582715e164f0d"}], "stats": {"total": 665, "additions": 641, "deletions": 24}, "files": [{"sha": "23e5c66222875a6a3e077737351226cfeffbdeca", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -1,3 +1,53 @@\n+2005-01-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25124\n+\tPR fortran/25625\n+\t* decl.c (get_proc_name): If there is an existing\n+\tsymbol in the encompassing namespace, call errors\n+\tif it is a procedure of the same name or the kind\n+\tfield is set, indicating a type declaration.\n+\n+\tPR fortran/20881\n+\tPR fortran/23308\n+\tPR fortran/25538\n+\tPR fortran/25710\n+\t* decl.c (add_global_entry): New function to check\n+\tfor existing global symbol with this name and to\n+\tcreate new one if none exists.\n+\t(gfc_match_entry): Call add_global_entry before\n+\tmatching argument lists for subroutine and function\n+\tentries.\n+\t* gfortran.h: Prototype for existing function,\n+\tglobal_used.\n+\t* resolve.c (resolve_global_procedure): New function\n+\tto check global symbols for procedures.\n+\t(resolve_call, resolve_function): Calls to this\n+\tnew function for non-contained and non-module\n+\tprocedures.\n+\t* match.c (match_common): Add check for existing\n+\tglobal symbol, creat one if none exists and emit\n+\terror if there is a clash.\n+\t* parse.c (global_used): Remove static and use the\n+\tgsymbol name rather than the new_block name, so that\n+\tthe function can be called from resolve.c.\n+\t(parse_block_data, parse_module, add_global_procedure):\n+\tImprove checks for existing gsymbols.  Emit error if\n+\talready defined or if references were to another type.\n+\tSet defined flag.\n+\n+\tPR fortran/PR24276\n+\t* trans-expr.c (gfc_conv_aliased_arg): New function called by \n+\tgfc_conv_function_call that coverts an expression for an aliased\n+\tcomponent reference to a derived type array into a temporary array\n+\tof the same type as the component.  The temporary is passed as an\n+\tactual argument for the procedure call and is copied back to the\n+\tderived type after the call.\n+\t(is_aliased_array): New function that detects an array reference\n+\tthat is followed by a component reference.\n+\t(gfc_conv_function_call): Detect an aliased actual argument with\n+\tis_aliased_array and convert it to a temporary and back again\n+\tusing gfc_conv_aliased_arg.\n+\n 2006-01-19  Tobias Schl\ufffd\ufffdter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* gfortranspec.c: Update copyright years."}, {"sha": "282ca730aa40cf8467ec4fc2bfebf7a8e63e2246", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -603,17 +603,38 @@ get_proc_name (const char *name, gfc_symbol ** result)\n   int rc;\n \n   if (gfc_current_ns->parent == NULL)\n-    return gfc_get_symbol (name, NULL, result);\n+    rc = gfc_get_symbol (name, NULL, result);\n+  else\n+    rc = gfc_get_symbol (name, gfc_current_ns->parent, result);\n \n-  rc = gfc_get_symbol (name, gfc_current_ns->parent, result);\n-  if (*result == NULL)\n-    return rc;\n+  sym = *result;\n \n-  /* ??? Deal with ENTRY problem */\n+  if (sym && !sym->new && gfc_current_state () != COMP_INTERFACE)\n+    {\n+      /* Trap another encompassed procedure with the same name.  */\n+      if (sym->attr.flavor != 0\n+\t    && sym->attr.proc != 0\n+\t    && (sym->attr.subroutine || sym->attr.function))\n+\tgfc_error_now (\"Procedure '%s' at %C is already defined at %L\",\n+\t\t       name, &sym->declared_at);\n+\n+      /* Trap declarations of attributes in encompassing scope.  The\n+\t signature for this is that ts.kind is set.  Legitimate\n+\t references only set ts.type.  */\n+      if (sym->ts.kind != 0\n+\t    && sym->attr.proc == 0\n+\t    && gfc_current_ns->parent != NULL\n+\t    && sym->attr.access == 0)\n+\tgfc_error_now (\"Procedure '%s' at %C has an explicit interface\"\n+\t\t       \" and must not have attributes declared at %L\",\n+\t\t       name, &sym->declared_at);\n+    }\n+\n+  if (gfc_current_ns->parent == NULL || *result == NULL)\n+    return rc;\n \n   st = gfc_new_symtree (&gfc_current_ns->sym_root, name);\n \n-  sym = *result;\n   st->n.sym = sym;\n   sym->refs++;\n \n@@ -2606,6 +2627,29 @@ gfc_match_function_decl (void)\n   return m;\n }\n \n+/* This is mostly a copy of parse.c(add_global_procedure) but modified to pass the\n+   name of the entry, rather than the gfc_current_block name, and to return false\n+   upon finding an existing global entry.  */\n+\n+static bool\n+add_global_entry (const char * name, int sub)\n+{\n+  gfc_gsymbol *s;\n+\n+  s = gfc_get_gsymbol(name);\n+\n+  if (s->defined\n+\t|| (s->type != GSYM_UNKNOWN && s->type != (sub ? GSYM_SUBROUTINE : GSYM_FUNCTION)))\n+    global_used(s, NULL);\n+  else\n+    {\n+      s->type = sub ? GSYM_SUBROUTINE : GSYM_FUNCTION;\n+      s->where = gfc_current_locus;\n+      s->defined = 1;\n+      return true;\n+    }\n+  return false;\n+}\n \n /* Match an ENTRY statement.  */\n \n@@ -2697,6 +2741,9 @@ gfc_match_entry (void)\n   if (state == COMP_SUBROUTINE)\n     {\n       /* An entry in a subroutine.  */\n+      if (!add_global_entry (name, 1))\n+\treturn MATCH_ERROR;\n+\n       m = gfc_match_formal_arglist (entry, 0, 1);\n       if (m != MATCH_YES)\n \treturn MATCH_ERROR;\n@@ -2716,6 +2763,9 @@ gfc_match_entry (void)\n             ENTRY f() RESULT (r)\n          can't be written as\n             ENTRY f RESULT (r).  */\n+      if (!add_global_entry (name, 0))\n+\treturn MATCH_ERROR;\n+\n       old_loc = gfc_current_locus;\n       if (gfc_match_eos () == MATCH_YES)\n \t{"}, {"sha": "9e5d303afd27ea48182ac970cd3854b22692b933", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -1962,5 +1962,6 @@ void gfc_show_namespace (gfc_namespace *);\n \n /* parse.c */\n try gfc_parse_file (void);\n+void global_used (gfc_gsymbol *, locus *);\n \n #endif /* GCC_GFORTRAN_H  */"}, {"sha": "40355d21aabf6306e97deab8443413cf26d2bc28", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -2250,6 +2250,7 @@ gfc_match_common (void)\n   gfc_array_spec *as;\n   gfc_equiv * e1, * e2;\n   match m;\n+  gfc_gsymbol *gsym;\n \n   old_blank_common = gfc_current_ns->blank_common.head;\n   if (old_blank_common)\n@@ -2266,6 +2267,23 @@ gfc_match_common (void)\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n \n+      gsym = gfc_get_gsymbol (name);\n+      if (gsym->type != GSYM_UNKNOWN && gsym->type != GSYM_COMMON)\n+\t{\n+\t  gfc_error (\"Symbol '%s' at %C is already an external symbol that is not COMMON\",\n+\t\t     sym->name);\n+\t  goto cleanup;\n+\t}\n+\n+      if (gsym->type == GSYM_UNKNOWN)\n+\t{\n+\t  gsym->type = GSYM_COMMON;\n+\t  gsym->where = gfc_current_locus;\n+\t  gsym->defined = 1;\n+\t}\n+\n+      gsym->used = 1;\n+\n       if (name[0] == '\\0')\n \t{\n \t  t = &gfc_current_ns->blank_common;"}, {"sha": "4fb690baa0ac5baea0ba4dcfb3898b2870b2f3da", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -1,5 +1,5 @@\n /* Main parser.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, \n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, \n    Inc.\n    Contributed by Andy Vaught\n \n@@ -2396,7 +2396,7 @@ parse_progunit (gfc_statement st)\n /* Come here to complain about a global symbol already in use as\n    something else.  */\n \n-static void\n+void\n global_used (gfc_gsymbol *sym, locus *where)\n {\n   const char *name;\n@@ -2430,7 +2430,7 @@ global_used (gfc_gsymbol *sym, locus *where)\n     }\n \n   gfc_error(\"Global name '%s' at %L is already being used as a %s at %L\",\n-           gfc_new_block->name, where, name, &sym->where);\n+\t      sym->name, where, name, &sym->where);\n }\n \n \n@@ -2461,12 +2461,13 @@ parse_block_data (void)\n   else\n     {\n       s = gfc_get_gsymbol (gfc_new_block->name);\n-      if (s->type != GSYM_UNKNOWN)\n+      if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_BLOCK_DATA))\n        global_used(s, NULL);\n       else\n        {\n          s->type = GSYM_BLOCK_DATA;\n          s->where = gfc_current_locus;\n+\t s->defined = 1;\n        }\n     }\n \n@@ -2491,12 +2492,13 @@ parse_module (void)\n   gfc_gsymbol *s;\n \n   s = gfc_get_gsymbol (gfc_new_block->name);\n-  if (s->type != GSYM_UNKNOWN)\n+  if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_MODULE))\n     global_used(s, NULL);\n   else\n     {\n       s->type = GSYM_MODULE;\n       s->where = gfc_current_locus;\n+      s->defined = 1;\n     }\n \n   st = parse_spec (ST_NONE);\n@@ -2535,12 +2537,14 @@ add_global_procedure (int sub)\n \n   s = gfc_get_gsymbol(gfc_new_block->name);\n \n-  if (s->type != GSYM_UNKNOWN)\n+  if (s->defined\n+\t|| (s->type != GSYM_UNKNOWN && s->type != (sub ? GSYM_SUBROUTINE : GSYM_FUNCTION)))\n     global_used(s, NULL);\n   else\n     {\n       s->type = sub ? GSYM_SUBROUTINE : GSYM_FUNCTION;\n       s->where = gfc_current_locus;\n+      s->defined = 1;\n     }\n }\n \n@@ -2556,12 +2560,13 @@ add_global_program (void)\n     return;\n   s = gfc_get_gsymbol (gfc_new_block->name);\n \n-  if (s->type != GSYM_UNKNOWN)\n+  if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_PROGRAM))\n     global_used(s, NULL);\n   else\n     {\n       s->type = GSYM_PROGRAM;\n       s->where = gfc_current_locus;\n+      s->defined = 1;\n     }\n }\n "}, {"sha": "1d8a71b371db1b421de66a6d8a19fb4610b54379", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -885,6 +885,36 @@ find_noncopying_intrinsics (gfc_symbol * fnsym, gfc_actual_arglist * actual)\n       ap->expr->inline_noncopying_intrinsic = 1;\n }\n \n+/* This function does the checking of references to global procedures\n+   as defined in sections 18.1 and 14.1, respectively, of the Fortran\n+   77 and 95 standards.  It checks for a gsymbol for the name, making\n+   one if it does not already exist.  If it already exists, then the\n+   reference being resolved must correspond to the type of gsymbol.\n+   Otherwise, the new symbol is equipped with the attributes of the \n+   reference.  The corresponding code that is called in creating\n+   global entities is parse.c.  */\n+\n+static void\n+resolve_global_procedure (gfc_symbol *sym, locus *where, int sub)\n+{\n+  gfc_gsymbol * gsym;\n+  uint type;\n+\n+  type = sub ? GSYM_SUBROUTINE : GSYM_FUNCTION;\n+\n+  gsym = gfc_get_gsymbol (sym->name);\n+\n+  if ((gsym->type != GSYM_UNKNOWN && gsym->type != type))\n+    global_used (gsym, where);\n+\n+  if (gsym->type == GSYM_UNKNOWN)\n+    {\n+      gsym->type = type;\n+      gsym->where = *where;\n+    }\n+\n+  gsym->used = 1;\n+}\n \n /************* Function resolution *************/\n \n@@ -1157,6 +1187,14 @@ resolve_function (gfc_expr * expr)\n   try t;\n   int temp;\n \n+  /* If the procedure is not internal or module, it must be external and\n+     should be checked for usage.  */\n+  if (expr->symtree && expr->symtree->n.sym\n+\t&& !expr->symtree->n.sym->attr.dummy\n+\t&& !expr->symtree->n.sym->attr.contained\n+\t&& !expr->symtree->n.sym->attr.use_assoc)\n+    resolve_global_procedure (expr->symtree->n.sym, &expr->where, 0);\n+\n   /* Switch off assumed size checking and do this again for certain kinds\n      of procedure, once the procedure itself is resolved.  */\n   need_full_assumed_size++;\n@@ -1511,6 +1549,14 @@ resolve_call (gfc_code * c)\n {\n   try t;\n \n+  /* If the procedure is not internal or module, it must be external and\n+     should be checked for usage.  */\n+  if (c->symtree && c->symtree->n.sym\n+\t&& !c->symtree->n.sym->attr.dummy\n+\t&& !c->symtree->n.sym->attr.contained\n+\t&& !c->symtree->n.sym->attr.use_assoc)\n+    resolve_global_procedure (c->symtree->n.sym, &c->loc, 1);\n+\n   /* Switch off assumed size checking and do this again for certain kinds\n      of procedure, once the procedure itself is resolved.  */\n   need_full_assumed_size++;\n@@ -4805,6 +4851,18 @@ resolve_symbol (gfc_symbol * sym)\n \t}\n       break;\n \n+    case FL_PROCEDURE:\n+      /* An external symbol may not have an intializer because it is taken to be\n+\t a procedure.  */\n+      if (sym->attr.external && sym->value)\n+\t{\n+\t  gfc_error (\"External object '%s' at %L may not have an initializer\",\n+\t\t     sym->name, &sym->declared_at);\n+\t  return;\n+\t}\n+\n+      break;\n+\n     case FL_DERIVED:\n       /* Add derived type to the derived type list.  */\n       {\n@@ -4818,14 +4876,6 @@ resolve_symbol (gfc_symbol * sym)\n \n     default:\n \n-      /* An external symbol falls through to here if it is not referenced.  */\n-      if (sym->attr.external && sym->value)\n-\t{\n-\t  gfc_error (\"External object '%s' at %L may not have an initializer\",\n-\t\t     sym->name, &sym->declared_at);\n-\t  return;\n-\t}\n-\n       break;\n     }\n "}, {"sha": "b30a12182241b15b23f13923cfadd0d9957fd580", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 229, "deletions": 1, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -1529,6 +1529,226 @@ gfc_apply_interface_mapping (gfc_interface_mapping * mapping,\n   gfc_free_expr (expr);\n }\n \n+/* Returns a reference to a temporary array into which a component of\n+   an actual argument derived type array is copied and then returned\n+   after the function call.\n+   TODO Get rid of this kludge, when array descriptors are capable of\n+   handling aliased arrays.  */\n+\n+static void\n+gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr, int g77)\n+{\n+  gfc_se lse;\n+  gfc_se rse;\n+  gfc_ss *lss;\n+  gfc_ss *rss;\n+  gfc_loopinfo loop;\n+  gfc_loopinfo loop2;\n+  gfc_ss_info *info;\n+  tree offset;\n+  tree tmp_index;\n+  tree tmp;\n+  tree base_type;\n+  stmtblock_t body;\n+  int n;\n+\n+  gcc_assert (expr->expr_type == EXPR_VARIABLE);\n+\n+  gfc_init_se (&lse, NULL);\n+  gfc_init_se (&rse, NULL);\n+\n+  /* Walk the argument expression.  */\n+  rss = gfc_walk_expr (expr);\n+\n+  gcc_assert (rss != gfc_ss_terminator);\n+ \n+  /* Initialize the scalarizer.  */\n+  gfc_init_loopinfo (&loop);\n+  gfc_add_ss_to_loop (&loop, rss);\n+\n+  /* Calculate the bounds of the scalarization.  */\n+  gfc_conv_ss_startstride (&loop);\n+\n+  /* Build an ss for the temporary.  */\n+  base_type = gfc_typenode_for_spec (&expr->ts);\n+  if (GFC_ARRAY_TYPE_P (base_type)\n+\t\t|| GFC_DESCRIPTOR_TYPE_P (base_type))\n+    base_type = gfc_get_element_type (base_type);\n+\n+  loop.temp_ss = gfc_get_ss ();;\n+  loop.temp_ss->type = GFC_SS_TEMP;\n+  loop.temp_ss->data.temp.type = base_type;\n+\n+  if (expr->ts.type == BT_CHARACTER)\n+    loop.temp_ss->string_length = expr->ts.cl->backend_decl;\n+\n+  loop.temp_ss->data.temp.dimen = loop.dimen;\n+  loop.temp_ss->next = gfc_ss_terminator;\n+\n+  /* Associate the SS with the loop.  */\n+  gfc_add_ss_to_loop (&loop, loop.temp_ss);\n+\n+  /* Setup the scalarizing loops.  */\n+  gfc_conv_loop_setup (&loop);\n+\n+  /* Pass the temporary descriptor back to the caller.  */\n+  info = &loop.temp_ss->data.info;\n+  parmse->expr = info->descriptor;\n+\n+  /* Setup the gfc_se structures.  */\n+  gfc_copy_loopinfo_to_se (&lse, &loop);\n+  gfc_copy_loopinfo_to_se (&rse, &loop);\n+\n+  rse.ss = rss;\n+  lse.ss = loop.temp_ss;\n+  gfc_mark_ss_chain_used (rss, 1);\n+  gfc_mark_ss_chain_used (loop.temp_ss, 1);\n+\n+  /* Start the scalarized loop body.  */\n+  gfc_start_scalarized_body (&loop, &body);\n+\n+  /* Translate the expression.  */\n+  gfc_conv_expr (&rse, expr);\n+\n+  gfc_conv_tmp_array_ref (&lse);\n+  gfc_advance_se_ss_chain (&lse);\n+\n+  tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts.type);\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  gcc_assert (rse.ss == gfc_ss_terminator);\n+\n+  gfc_trans_scalarizing_loops (&loop, &body);\n+\n+  /* Add the post block after the second loop, so that any\n+     freeing of allocated memory is done at the right time.  */\n+  gfc_add_block_to_block (&parmse->pre, &loop.pre);\n+\n+  /**********Copy the temporary back again.*********/\n+\n+  gfc_init_se (&lse, NULL);\n+  gfc_init_se (&rse, NULL);\n+\n+  /* Walk the argument expression.  */\n+  lss = gfc_walk_expr (expr);\n+  rse.ss = loop.temp_ss;\n+  lse.ss = lss;\n+\n+  /* Initialize the scalarizer.  */\n+  gfc_init_loopinfo (&loop2);\n+  gfc_add_ss_to_loop (&loop2, lss);\n+\n+  /* Calculate the bounds of the scalarization.  */\n+  gfc_conv_ss_startstride (&loop2);\n+\n+  /* Setup the scalarizing loops.  */\n+  gfc_conv_loop_setup (&loop2);\n+\n+  gfc_copy_loopinfo_to_se (&lse, &loop2);\n+  gfc_copy_loopinfo_to_se (&rse, &loop2);\n+\n+  gfc_mark_ss_chain_used (lss, 1);\n+  gfc_mark_ss_chain_used (loop.temp_ss, 1);\n+\n+  /* Declare the variable to hold the temporary offset and start the\n+     scalarized loop body.  */\n+  offset = gfc_create_var (gfc_array_index_type, NULL);\n+  gfc_start_scalarized_body (&loop2, &body);\n+\n+  /* Build the offsets for the temporary from the loop variables.  The\n+     temporary array has lbounds of zero and strides of one in all\n+     dimensions, so this is very simple.  The offset is only computed\n+     outside the innermost loop, so the overall transfer could be\n+     optimised further.  */\n+  info = &rse.ss->data.info;\n+\n+  tmp_index = gfc_index_zero_node;\n+  for (n = info->dimen - 1; n > 0; n--)\n+    {\n+      tree tmp_str;\n+      tmp = rse.loop->loopvar[n];\n+      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t tmp, rse.loop->from[n]);\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t tmp, tmp_index);\n+\n+      tmp_str = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     rse.loop->to[n-1], rse.loop->from[n-1]);\n+      tmp_str = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp_str, gfc_index_one_node);\n+\n+      tmp_index = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t       tmp, tmp_str);\n+    }\n+\n+  tmp_index = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+  \t\t\t   tmp_index, rse.loop->from[0]);\n+  gfc_add_modify_expr (&rse.loop->code[0], offset, tmp_index);\n+\n+  tmp_index = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t   rse.loop->loopvar[0], offset);\n+\n+  /* Now use the offset for the reference.  */\n+  tmp = build_fold_indirect_ref (info->data);\n+  rse.expr = gfc_build_array_ref (tmp, tmp_index);\n+\n+  if (expr->ts.type == BT_CHARACTER)\n+    rse.string_length = expr->ts.cl->backend_decl;\n+\n+  gfc_conv_expr (&lse, expr);\n+\n+  gcc_assert (lse.ss == gfc_ss_terminator);\n+\n+  tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts.type);\n+  gfc_add_expr_to_block (&body, tmp);\n+  \n+  /* Generate the copying loops.  */\n+  gfc_trans_scalarizing_loops (&loop2, &body);\n+\n+  /* Wrap the whole thing up by adding the second loop to the post-block\n+     and following it by the post-block of the fist loop.  In this way,\n+     if the temporary needs freeing, it is done after use!  */\n+  gfc_add_block_to_block (&parmse->post, &loop2.pre);\n+  gfc_add_block_to_block (&parmse->post, &loop2.post);\n+\n+  gfc_add_block_to_block (&parmse->post, &loop.post);\n+\n+  gfc_cleanup_loop (&loop);\n+  gfc_cleanup_loop (&loop2);\n+\n+  /* Pass the string length to the argument expression.  */\n+  if (expr->ts.type == BT_CHARACTER)\n+    parmse->string_length = expr->ts.cl->backend_decl;\n+\n+  /* We want either the address for the data or the address of the descriptor,\n+     depending on the mode of passing array arguments.  */\n+  if (g77)\n+    parmse->expr = gfc_conv_descriptor_data_get (parmse->expr);\n+  else\n+    parmse->expr = build_fold_addr_expr (parmse->expr);\n+\n+  return;\n+}\n+\n+/* Is true if the last array reference is followed by a component reference.  */\n+\n+static bool\n+is_aliased_array (gfc_expr * e)\n+{\n+  gfc_ref * ref;\n+  bool seen_array;\n+\n+  seen_array = false;\t\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_ARRAY)\n+\tseen_array = true;\n+\n+      if (ref->next == NULL && ref->type == REF_COMPONENT)\n+\treturn seen_array;\n+    }\n+  return false;\n+}\n \n /* Generate code for a procedure call.  Note can return se->post != NULL.\n    If se->direct_byref is set then se->expr contains the return parameter.\n@@ -1655,7 +1875,15 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t  && !formal->sym->attr.pointer\n \t\t  && formal->sym->as->type != AS_ASSUMED_SHAPE;\n \t      f = f || !sym->attr.always_explicit;\n-\t      gfc_conv_array_parameter (&parmse, arg->expr, argss, f);\n+\t      if (arg->expr->expr_type == EXPR_VARIABLE\n+\t\t    && is_aliased_array (arg->expr))\n+\t\t/* The actual argument is a component reference to an\n+\t\t   array of derived types.  In this case, the argument\n+\t\t   is converted to a temporary, which is passed and then\n+\t\t   written back after the procedure call.  */\n+\t\tgfc_conv_aliased_arg (&parmse, arg->expr, f);\n+\t      else\n+\t        gfc_conv_array_parameter (&parmse, arg->expr, argss, f);\n \t    } \n \t}\n "}, {"sha": "7c28e0ee25b0f817985676dc1feacdf75ac8e77b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -1,3 +1,20 @@\n+2005-01-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25124\n+\tPR fortran/25625\n+\t* gfortran.dg/internal_references_1.f90: New test.\n+\t  PR fortran/20881\n+\tPR fortran/23308\n+\tPR fortran/25538\n+\tPR fortran/25710\n+\t* gfortran.dg/global_references_1.f90: New test.\n+\t* gfortran.dg/g77/19990905-1.f: Restore the error that\n+\tthere is a clash between the common block name and\n+\tthe name of a subroutine reference.\n+\n+\tPR fortran/PR24276\n+\t* gfortran.dg/aliasing_dummy_1.f90: New test.\n+\n 2006-01-21  Alan Modra  <amodra@bigpond.net.au>\n \n \t* gcc.dg/vmx/1b-01.c: Warning fix."}, {"sha": "0d0b588fc105c30387e9eb8947c8332d25e015b7", "filename": "gcc/testsuite/gfortran.dg/aliasing_dummy_1.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_dummy_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_dummy_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_dummy_1.f90?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+! This tests the fix for PR24276, which originated from the Loren P. Meissner example,\n+! Array_List.  The PR concerns dummy argument aliassing of components of arrays of derived\n+! types as arrays of the type of the component.  gfortran would compile and run this\n+! example but the stride used did not match the actual argument.  This test case exercises\n+! a procedure call (to foo2, below) that is identical to Array_List's.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+\n+program test_lex\n+  type :: dtype\n+    integer :: n\n+    character*5 :: word\n+  end type dtype\n+\n+  type :: list\n+    type(dtype), dimension(4) :: list\n+    integer :: l = 4\n+  end type list\n+ \n+  type(list) :: table\n+  type(dtype) :: elist(2,2)\n+\n+  table%list = (/dtype (1 , \"one  \"), dtype (2 , \"two  \"), dtype (3 , \"three\"), dtype (4 , \"four \")/)\n+\n+! Test 1D with assumed shape (original bug) and assumed size.\n+  call bar (table, 2, 4)\n+  if (any (table%list%word.ne.(/\"one  \",\"i=  2\",\"three\",\"i=  4\"/))) call abort ()\n+\n+  elist = reshape (table%list, (/2,2/))\n+\n+! Check 2D is OK with assumed shape and assumed size.\n+  call foo3 (elist%word, 1)\n+  call foo1 (elist%word, 3)\n+  if (any (elist%word.ne.reshape ((/\"i=  1\",\"i=  2\",\"i=  3\",\"i=  4\"/), (/2,2/)))) call abort ()\n+\n+contains\n+\n+  subroutine bar (table, n, m)\n+    type(list) :: table\n+    integer n, m\n+    call foo1 (table%list(:table%l)%word, n)\n+    call foo2 (table%list(:table%l)%word, m)\n+  end subroutine bar\n+\n+  subroutine foo1 (slist, i)\n+    character(*), dimension(*) :: slist\n+    integer i\n+    write (slist(i), '(2hi=,i3)') i\n+  end subroutine foo1\n+\n+  subroutine foo2 (slist, i)\n+    character(5), dimension(:) :: slist\n+    integer i\n+    write (slist(i), '(2hi=,i3)') i\n+  end subroutine foo2\n+\n+  subroutine foo3 (slist, i)\n+    character(5), dimension(:,:) :: slist\n+    integer i\n+    write (slist(1,1), '(2hi=,i3)') i\n+  end subroutine foo3\n+\n+end program test_lex\n\\ No newline at end of file"}, {"sha": "b69d66ed266ac742d3a30d0175487e9dd39f020b", "filename": "gcc/testsuite/gfortran.dg/g77/19990905-1.f", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990905-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990905-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990905-1.f?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -12,8 +12,8 @@\n * =foo7.f in Burley's g77 test suite.\n       subroutine x\n       real a(n)\n-      common /foo/n\n+      common /foo/n  ! { dg-error \"is already being used as a COMMON\" }\n       continue\n       entry y(a)\n-      call foo(a(1))\n+      call foo(a(1)) ! { dg-error \"is already being used as a COMMON\" }\n       end"}, {"sha": "d8728d3b08db156f1de96f932f95793f9ab8a503", "filename": "gcc/testsuite/gfortran.dg/global_references_1.f90", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_references_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_references_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_references_1.f90?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -0,0 +1,98 @@\n+! { dg-do compile }\n+! This program tests the patch for PRs 20881, 23308, 25538 & 25710\n+! Assembled from PRs by Paul Thomas  <pault@gcc.gnu.org>\n+module m\n+contains\n+  subroutine g(x)   ! Local entity\n+    REAL :: x\n+    x = 1.0\n+  end subroutine g\n+end module m\n+! Error only appears once but testsuite associates with both lines.\n+function f(x)       ! { dg-error \"is already being used as a FUNCTION\" }\n+  REAL :: f, x\n+  f = x\n+end function f\n+\n+function g(x)       ! Global entity\n+  REAL :: g, x\n+  g = x\n+\n+! PR25710==========================================================\n+! Lahey -2607-S: \"SOURCE.F90\", line 26: \n+! Function 'f' cannot be referenced as a subroutine. The previous\n+! definition is in 'line 12'.\n+\n+  call f(g) ! { dg-error \"is already being used as a FUNCTION\" }\n+end function g\n+! Error only appears once but testsuite associates with both lines.\n+function h(x)       ! { dg-error \"is already being used as a FUNCTION\" }\n+  REAL :: h, x\n+  h = x\n+end function h\n+\n+SUBROUTINE TT()\n+  CHARACTER(LEN=10), EXTERNAL :: j\n+  CHARACTER(LEN=10)          :: T\n+! PR20881=========================================================== \n+! Error only appears once but testsuite associates with both lines.\n+  T = j () ! { dg-error \"is already being used as a FUNCTION\" }\n+  print *, T\n+END SUBROUTINE TT\n+\n+  use m             ! Main program\n+  real x\n+  integer a(10)\n+\n+! PR23308===========================================================\n+! Lahey - 2604-S: \"SOURCE.F90\", line 52:\n+! The name 'foo' cannot be specified as both external procedure name\n+! and common block name. The previous appearance is in 'line 68'.\n+! Error only appears once but testsuite associates with both lines.\n+  common /foo/ a    ! { dg-error \"is already being used as a COMMON\" }\n+\n+  call f (x)        ! OK - reference to local entity\n+  call g (x)        !             -ditto-\n+\n+! PR25710===========================================================\n+! Lahey - 2607-S: \"SOURCE.F90\", line 62:\n+! Function 'h' cannot be referenced as a subroutine. The previous\n+! definition is in 'line 29'.\n+\n+  call h (x) ! { dg-error \"is already being used as a FUNCTION\" }\n+\n+! PR23308===========================================================\n+! Lahey - 2521-S: \"SOURCE.F90\", line 68: Intrinsic procedure name or\n+! external procedure name same as common block name 'foo'.\n+\n+  call foo () ! { dg-error \"is already being used as a COMMON\" }\n+\n+contains\n+  SUBROUTINE f (x)  ! Local entity\n+    real x\n+    x = 2\n+  end SUBROUTINE f\n+end\n+\n+! PR20881=========================================================== \n+! Lahey - 2636-S: \"SOURCE.F90\", line 81:\n+! Subroutine 'j' is previously referenced as a function in 'line 39'.\n+\n+SUBROUTINE j (x)    ! { dg-error \"is already being used as a FUNCTION\" }\n+  integer a(10)\n+  common /bar/ a    ! Global entity foo\n+  real x\n+  x = bar(1.0)      ! OK for local procedure to have common block name\n+contains\n+  function bar (x)\n+    real bar, x\n+    bar = 2.0*x\n+  end function bar\n+END SUBROUTINE j\n+\n+! PR25538===========================================================\n+! would ICE with entry and procedure having same names.\n+  subroutine link2 (namef) ! { dg-error \"is already being used as a SUBROUTINE\" }\n+    entry link2 (nameg)    ! { dg-error \"is already being used as a SUBROUTINE\" }\n+    return\n+  end"}, {"sha": "461fbfa92c9e4379259212014cec3df80861adad", "filename": "gcc/testsuite/gfortran.dg/internal_references_1.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_references_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68ea355b5d9b51b994e0780d8392f7542262072f/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_references_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_references_1.f90?ref=68ea355b5d9b51b994e0780d8392f7542262072f", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+! This tests the patch for PRs 24327, 25024 & 25625, which\n+! are all connected with references to internal procedures.\n+! This is a composite of the PR testcases; and each is\n+! labelled by PR.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+! PR25625 - would neglect to point out that there were 2 subroutines p.\n+module m\n+  implicit none\n+contains\n+\n+  subroutine p (i)   ! { dg-error \"is already defined\" }\n+    integer :: i\n+  end subroutine\n+\n+  subroutine p (i)   ! { dg-error \"is already defined\" }\n+   integer :: i\n+  end subroutine\n+end module\n+!\n+! PR25124 - would happily ignore the declaration of foo in the main program.\n+program test\n+real :: foo, x      ! { dg-error \"explicit interface and must not have attributes declared\" }\n+x = bar ()          ! This is OK because it is a regular reference.\n+x = foo ()\n+contains\n+    function foo () ! { dg-error \"explicit interface and must not have attributes declared\" }\n+      foo = 1.0\n+    end function foo\n+    function bar ()\n+      bar = 1.0\n+    end function bar\n+end program test\n+"}]}