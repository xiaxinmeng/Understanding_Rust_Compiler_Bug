{"sha": "77ce5555480140ec57c4d39169dfff19ad4a7d96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdjZTU1NTU0ODAxNDBlYzU3YzRkMzkxNjlkZmZmMTlhZDRhN2Q5Ng==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2019-12-18T17:02:37Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2019-12-18T17:02:37Z"}, "message": "[OpenACC] Refactor 'goacc_enter_data' so that it can be called from 'goacc_insert_pointer', \"present\" case, and simplify\n\nNo functional changes.\n\n\tlibgomp/\n\t* oacc-mem.c (goacc_enter_data): Refactor, so that it can be\n\tcalled...\n\t(goacc_insert_pointer): ... from here, \"present\" case.\n\t(goacc_insert_pointer): Inline function into...\n\t(GOACC_enter_exit_data): ... here, and simplify.\n\nFrom-SVN: r279540", "tree": {"sha": "2a20d97a998b6cc06951965af1c73e08ab2bc8c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a20d97a998b6cc06951965af1c73e08ab2bc8c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77ce5555480140ec57c4d39169dfff19ad4a7d96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77ce5555480140ec57c4d39169dfff19ad4a7d96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77ce5555480140ec57c4d39169dfff19ad4a7d96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77ce5555480140ec57c4d39169dfff19ad4a7d96/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9444a299fa135cae638eed3b2644747f105351c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9444a299fa135cae638eed3b2644747f105351c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9444a299fa135cae638eed3b2644747f105351c8"}], "stats": {"total": 98, "additions": 46, "deletions": 52}, "files": [{"sha": "779f276ca991a242ae8aeb39c3b9af8af61757a1", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ce5555480140ec57c4d39169dfff19ad4a7d96/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ce5555480140ec57c4d39169dfff19ad4a7d96/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=77ce5555480140ec57c4d39169dfff19ad4a7d96", "patch": "@@ -1,5 +1,11 @@\n 2019-12-18  Thomas Schwinge  <thomas@codesourcery.com>\n \n+\t* oacc-mem.c (goacc_enter_data): Refactor, so that it can be\n+\tcalled...\n+\t(goacc_insert_pointer): ... from here, \"present\" case.\n+\t(goacc_insert_pointer): Inline function into...\n+\t(GOACC_enter_exit_data): ... here, and simplify.\n+\n \t* oacc-mem.c (goacc_enter_data): Refactor, so that it can be\n \tcalled...\n \t(goacc_insert_pointer): ... from here, \"not present\" case."}, {"sha": "15eb17b846ef9c000347e0d05d4f2ab1b4fcd78d", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 40, "deletions": 52, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ce5555480140ec57c4d39169dfff19ad4a7d96/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ce5555480140ec57c4d39169dfff19ad4a7d96/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=77ce5555480140ec57c4d39169dfff19ad4a7d96", "patch": "@@ -513,6 +513,9 @@ goacc_enter_data (size_t mapnum, void **hostaddrs, size_t *sizes, void *kinds,\n   if (mapnum == 1\n       && (!hostaddrs[0] || !sizes[0]))\n     gomp_fatal (\"[%p,+%d] is a bad range\", hostaddrs[0], (int) sizes[0]);\n+  else if (mapnum > 1\n+\t   && !hostaddrs[0])\n+    return /* n/a */ (void *) -1;\n \n   goacc_lazy_initialize ();\n \n@@ -539,9 +542,8 @@ goacc_enter_data (size_t mapnum, void **hostaddrs, size_t *sizes, void *kinds,\n   gomp_mutex_lock (&acc_dev->lock);\n \n   n = lookup_host (acc_dev, hostaddrs[0], sizes[0]);\n-  if (n)\n+  if (n && mapnum == 1)\n     {\n-      assert (mapnum == 1);\n       void *h = hostaddrs[0];\n       size_t s = sizes[0];\n \n@@ -561,6 +563,32 @@ goacc_enter_data (size_t mapnum, void **hostaddrs, size_t *sizes, void *kinds,\n \n       gomp_mutex_unlock (&acc_dev->lock);\n     }\n+  else if (n && mapnum > 1)\n+    {\n+      d = /* n/a */ (void *) -1;\n+\n+      assert (n->refcount != REFCOUNT_INFINITY\n+\t      && n->refcount != REFCOUNT_LINK);\n+\n+      bool processed = false;\n+\n+      struct target_mem_desc *tgt = n->tgt;\n+      for (size_t i = 0; i < tgt->list_count; i++)\n+\tif (tgt->list[i].key == n)\n+\t  {\n+\t    for (size_t j = 0; j < mapnum; j++)\n+\t      if (i + j < tgt->list_count && tgt->list[i + j].key)\n+\t\t{\n+\t\t  tgt->list[i + j].key->refcount++;\n+\t\t  tgt->list[i + j].key->dynamic_refcount++;\n+\t\t}\n+\t    processed = true;\n+\t  }\n+\n+      gomp_mutex_unlock (&acc_dev->lock);\n+      if (!processed)\n+\tgomp_fatal (\"dynamic refcount incrementing failed for pointer/pset\");\n+    }\n   else\n     {\n       gomp_mutex_unlock (&acc_dev->lock);\n@@ -894,45 +922,6 @@ acc_update_self_async (void *h, size_t s, int async)\n    ones implicitly follow suit.  Similarly, 'copyout' is done only for the\n    first mapping.  */\n \n-static void\n-goacc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n-\t\t      void *kinds, int async)\n-{\n-  struct target_mem_desc *tgt;\n-  struct goacc_thread *thr = goacc_thread ();\n-  struct gomp_device_descr *acc_dev = thr->dev;\n-\n-  if (*hostaddrs == NULL)\n-    return;\n-\n-  if (acc_is_present (*hostaddrs, *sizes))\n-    {\n-      splay_tree_key n;\n-      gomp_mutex_lock (&acc_dev->lock);\n-      n = lookup_host (acc_dev, *hostaddrs, *sizes);\n-      assert (n->refcount != REFCOUNT_INFINITY\n-\t      && n->refcount != REFCOUNT_LINK);\n-      gomp_mutex_unlock (&acc_dev->lock);\n-\n-      tgt = n->tgt;\n-      for (size_t i = 0; i < tgt->list_count; i++)\n-\tif (tgt->list[i].key == n)\n-\t  {\n-\t    for (size_t j = 0; j < mapnum; j++)\n-\t      if (i + j < tgt->list_count && tgt->list[i + j].key)\n-\t\t{\n-\t\t  tgt->list[i + j].key->refcount++;\n-\t\t  tgt->list[i + j].key->dynamic_refcount++;\n-\t\t}\n-\t    return;\n-\t  }\n-      /* Should not reach here.  */\n-      gomp_fatal (\"Dynamic refcount incrementing failed for pointer/pset\");\n-    }\n-\n-  goacc_enter_data (mapnum, hostaddrs, sizes, kinds, async);\n-}\n-\n static void\n goacc_remove_pointer (void *h, size_t s, unsigned short kind, int async)\n {\n@@ -1190,18 +1179,17 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum, void **hostaddrs,\n \t\t  break;\n \t\t}\n \n-\t      goacc_enter_data (1, &hostaddrs[i], &sizes[i], &kinds[i], async);\n-\t    }\n-\t  else\n-\t    {\n-\t      goacc_insert_pointer (pointer, &hostaddrs[i], &sizes[i], &kinds[i],\n-\t\t\t\t    async);\n-\t      /* Increment 'i' by two because OpenACC requires fortran\n-\t\t arrays to be contiguous, so each PSET is associated with\n-\t\t one of MAP_FORCE_ALLOC/MAP_FORCE_PRESET/MAP_FORCE_TO, and\n-\t\t one MAP_POINTER.  */\n-\t      i += pointer - 1;\n+\t      /* We actually have one mapping.  */\n+\t      pointer = 1;\n \t    }\n+\n+\t  goacc_enter_data (pointer, &hostaddrs[i], &sizes[i], &kinds[i],\n+\t\t\t    async);\n+\t  /* If applicable, increment 'i' further; OpenACC requires fortran\n+\t     arrays to be contiguous, so each PSET is associated with\n+\t     one of MAP_FORCE_ALLOC/MAP_FORCE_PRESET/MAP_FORCE_TO, and\n+\t     one MAP_POINTER.  */\n+\t  i += pointer - 1;\n \t}\n     }\n   else"}]}