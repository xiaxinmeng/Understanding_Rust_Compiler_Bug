{"sha": "cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IwZGJiOWEwMWE0YTNjMmMyYTVhOTQ2MDFiNzJjMmM2M2NjMmE1MQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-06-25T03:28:35Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-06-25T03:28:35Z"}, "message": "cp-tree.h (CP_DECL_CONTEXT): New macro.\n\n\t* cp-tree.h (CP_DECL_CONTEXT): New macro.\n\t* decl2.c (is_namespace_ancestor, lookup_using_namespace): Use it.\n\t* method.c (build_overload_nested_name): Likewise.\n\t* sig.c (build_signature_pointer_or_reference_type): Don't set\n\tDECL_CONTEXT.\n\tSet DECL_CONTEXT for globals to NULL_TREE instead of global_namespace.\n\t* cp-tree.h (FROB_CONTEXT): New macro.\n\t(DECL_MAIN_P): ::main should have a DECL_CONTEXT of NULL_TREE.\n\t* decl.c (namespace_binding): Replace NULL_TREE with\n\tglobal_namespace.\n\t(set_namespace_binding, pop_namespace, lookup_name_real): Likewise.\n\t* decl2.c (is_namespace_ancestor, lookup_using_namespace):\n\tLikewise.\n\t* decl.c (pushtag): Use FROB_CONTEXT.\n\t(pushdecl, make_typename_type, define_function, grokdeclarator):\n\tLikewise.\n\t* decl2.c (set_decl_namespace, do_namespace_alias): Likewise.\n\t* pt.c (push_template_decl_real, lookup_template_class, tsubst):\n\tLikewise.\n\t* decl2.c (decl_namespace): Return global_namespace if no context.\n\t* method.c (build_overload_nested_name): Expect null as context.\n\t* pt.c (mangle_class_name_for_template): Do nothing for null\n\tcontexts.\n\t(lookup_template_class): Allow for null id_context.\n\nFrom-SVN: r20710", "tree": {"sha": "9200dfe8e80bc424f27eb57bd93f73389e249e39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9200dfe8e80bc424f27eb57bd93f73389e249e39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/comments", "author": null, "committer": null, "parents": [{"sha": "acd9204960d4417b564e75ce036618359ce5eeda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd9204960d4417b564e75ce036618359ce5eeda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acd9204960d4417b564e75ce036618359ce5eeda"}], "stats": {"total": 1479, "additions": 758, "deletions": 721}, "files": [{"sha": "699d6bca82d9fa4e63bec2b448677cbedac34297", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "patch": "@@ -1,3 +1,33 @@\n+1998-06-25  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h (CP_DECL_CONTEXT): New macro.\n+\t* decl2.c (is_namespace_ancestor, lookup_using_namespace): Use it.\n+\t* method.c (build_overload_nested_name): Likewise.\n+\t* sig.c (build_signature_pointer_or_reference_type): Don't set\n+\tDECL_CONTEXT.\n+\n+1998-06-24  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n+\n+\tSet DECL_CONTEXT for globals to NULL_TREE instead of global_namespace.\n+\t* cp-tree.h (FROB_CONTEXT): New macro.\n+\t(DECL_MAIN_P): ::main should have a DECL_CONTEXT of NULL_TREE.\n+\t* decl.c (namespace_binding): Replace NULL_TREE with\n+\tglobal_namespace.\n+\t(set_namespace_binding, pop_namespace, lookup_name_real): Likewise.\n+\t* decl2.c (is_namespace_ancestor, lookup_using_namespace):\n+\tLikewise.\n+\t* decl.c (pushtag): Use FROB_CONTEXT.\n+\t(pushdecl, make_typename_type, define_function, grokdeclarator):\n+\tLikewise.\n+\t* decl2.c (set_decl_namespace, do_namespace_alias): Likewise.\n+\t* pt.c (push_template_decl_real, lookup_template_class, tsubst):\n+\tLikewise.\n+\t* decl2.c (decl_namespace): Return global_namespace if no context.\n+\t* method.c (build_overload_nested_name): Expect null as context.\n+\t* pt.c (mangle_class_name_for_template): Do nothing for null\n+\tcontexts.\n+\t(lookup_template_class): Allow for null id_context.\n+\n 1998-06-25  Richard Henderson  <rth@cygnus.com>\n \n \t* method.c (emit_thunk): Set current_function_is_thunk for the"}, {"sha": "34048a75f50893a9a17b66b72cffb41677143317", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "patch": "@@ -214,7 +214,7 @@ parse.o : $(PARSE_C) $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h \\\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n   `echo $(PARSE_C) | sed 's,^\\./,,'`\n \n-CONFLICTS = expect 21 shift/reduce conflicts and 39 reduce/reduce conflicts.\n+CONFLICTS = expect 21 shift/reduce conflicts and 42 reduce/reduce conflicts.\n $(PARSE_H) : $(PARSE_C)\n $(PARSE_C) : $(srcdir)/parse.y\n \t@echo $(CONFLICTS)"}, {"sha": "5d0e25bcafea69da2b4922f82d99f51de04f2abb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "patch": "@@ -1184,7 +1184,12 @@ struct lang_decl\n #define DECL_CLASS_CONTEXT(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.context)\n #define DECL_REAL_CONTEXT(NODE) \\\n   ((TREE_CODE (NODE) == FUNCTION_DECL && DECL_FUNCTION_MEMBER_P (NODE)) \\\n-   ? DECL_CLASS_CONTEXT (NODE) : DECL_CONTEXT (NODE))\n+   ? DECL_CLASS_CONTEXT (NODE) : CP_DECL_CONTEXT (NODE))\n+\n+/* NULL_TREE in DECL_CONTEXT represents the global namespace. */\n+#define CP_DECL_CONTEXT(NODE) \\\n+  (DECL_CONTEXT (NODE) ? DECL_CONTEXT (NODE) : global_namespace)\n+#define FROB_CONTEXT(NODE)   ((NODE) == global_namespace ? NULL_TREE : (NODE))\n \n /* 1 iff NODE has namespace scope, including the global namespace.  */\n #define DECL_NAMESPACE_SCOPE_P(NODE) \\\n@@ -2027,8 +2032,7 @@ extern int current_function_parms_stored;\n    `main'.  */\n #define DECL_MAIN_P(NODE)\t\t\t\t\\\n    (TREE_CODE (NODE) == FUNCTION_DECL\t\t\t\\\n-    && (DECL_CONTEXT (NODE) == global_namespace \t\\\n-\t|| DECL_CONTEXT (NODE) == NULL_TREE)\t\t\\\n+    && DECL_CONTEXT (NODE) == NULL_TREE \t\t\\\n     && DECL_NAME (NODE) != NULL_TREE\t\t\t\\\n     && MAIN_NAME_P (DECL_NAME (NODE)))\n "}, {"sha": "2c4d1a5ddd0eb62b380a00910f26b7804a14d23f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "patch": "@@ -1719,6 +1719,8 @@ namespace_binding (name, scope)\n   tree b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n   if (b == NULL_TREE)\n     return NULL_TREE;\n+  if (scope == NULL_TREE)\n+    scope = global_namespace;\n   if (TREE_CODE (b) != CPLUS_BINDING)\n     return (scope == global_namespace) ? b : NULL_TREE;\n   name = find_binding (name,scope);\n@@ -1737,6 +1739,10 @@ set_namespace_binding (name, scope, val)\n      tree val;\n {\n   tree b;\n+\n+  if (scope == NULL_TREE)\n+    scope = global_namespace;\n+  \n   if (scope == global_namespace)\n     {\n       b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n@@ -1837,7 +1843,7 @@ pop_namespace ()\n       in_std--;\n       return;\n     }\n-  current_namespace = DECL_CONTEXT (current_namespace);\n+  current_namespace = CP_DECL_CONTEXT (current_namespace);\n   /* The binding level is not popped, as it might be re-opened later.  */\n   suspend_binding_level ();\n }\n@@ -2263,7 +2269,7 @@ pushtag (name, type, globalize)\n \t    d = TYPE_MAIN_DECL (d);\n \n \t  TYPE_NAME (type) = d;\n-\t  DECL_CONTEXT (d) = context;\n+\t  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n \n \t  if (processing_template_parmlist)\n \t    /* You can't declare a new template type in a template\n@@ -3241,7 +3247,7 @@ pushdecl (x)\n       && ! DECL_CONTEXT (x))\n     DECL_CONTEXT (x) = current_function_decl;\n   if (!DECL_CONTEXT (x))\n-    DECL_CONTEXT (x) = current_namespace;\n+    DECL_CONTEXT (x) = FROB_CONTEXT (current_namespace);\n \n   /* Type are looked up using the DECL_NAME, as that is what the rest of the\n      compiler wants to use.  */\n@@ -4687,10 +4693,10 @@ make_typename_type (context, name)\n   if (processing_template_decl)\n     pop_obstacks ();\n \n-  TYPE_CONTEXT (t) = context;\n+  TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n   TYPE_NAME (TREE_TYPE (d)) = d;\n   TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n-  DECL_CONTEXT (d) = context;\n+  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n   CLASSTYPE_GOT_SEMICOLON (t) = 1;\n \n   return t;\n@@ -4920,6 +4926,8 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t  if (scope == global_namespace)\n \t    break;\n \t  scope = DECL_CONTEXT (scope);\n+          if (scope == NULL_TREE)\n+            scope = global_namespace;\n \t}\n     }\n \n@@ -5980,7 +5988,7 @@ define_function (name, type, function_code, pfn, library_name)\n   DECL_ARTIFICIAL (decl) = 1;\n \n   my_friendly_assert (DECL_CONTEXT (decl) == NULL_TREE, 392);\n-  DECL_CONTEXT (decl) = current_namespace;\n+  DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n \n   /* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,\n      we cannot change DECL_ASSEMBLER_NAME until we have installed this\n@@ -9707,7 +9715,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  if (current_class_type)\n \t    DECL_CONTEXT (decl) = current_class_type;\n \t  else\n-\t    DECL_CONTEXT (decl) = current_namespace;\n+\t    DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n \n \t  DECL_ASSEMBLER_NAME (decl) = DECL_NAME (decl);\n \t  DECL_ASSEMBLER_NAME (decl)"}, {"sha": "87f65fa665f0e648c45e51024368ae6e05fec0c4", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "patch": "@@ -3806,7 +3806,7 @@ is_namespace_ancestor (root, child)\n     return 1;\n   if (child == global_namespace)\n     return 0;\n-  return is_namespace_ancestor (root, DECL_CONTEXT (child));\n+  return is_namespace_ancestor (root, CP_DECL_CONTEXT (child));\n }\n   \n \n@@ -3950,7 +3950,7 @@ lookup_using_namespace (name, val, current, scope)\n \t  }\n       if (current == scope)\n \tbreak;\n-      current = DECL_CONTEXT (current);\n+      current = CP_DECL_CONTEXT (current);\n     }\n   return val != error_mark_node;\n }\n@@ -4013,7 +4013,7 @@ set_decl_namespace (decl, scope)\n   if (!is_namespace_ancestor (current_namespace, scope))\n     cp_error (\"declaration of `%D' not in a namespace surrounding `%D'\",\n \t      decl, scope);\n-  DECL_CONTEXT (decl) = scope;\n+  DECL_CONTEXT (decl) = FROB_CONTEXT (scope);\n   if (scope != current_namespace)\n     {\n       /* See whether this has been declared in the namespace. */\n@@ -4056,9 +4056,7 @@ decl_namespace (decl)\n       my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd', 390);\n     }\n \n-  /* We should always find the namespace. */\n-  my_friendly_abort (390);\n-  return NULL_TREE;\n+  return global_namespace;\n }\n \n /* Return the namespace where the current declaration is declared. */\n@@ -4388,7 +4386,7 @@ do_namespace_alias (alias, namespace)\n       /* Build the alias. */\n       alias = build_lang_decl (NAMESPACE_DECL, alias, void_type_node);     \n       DECL_NAMESPACE_ALIAS (alias) = namespace;\n-      DECL_CONTEXT (alias) = current_namespace;\n+      DECL_CONTEXT (alias) = FROB_CONTEXT (current_namespace);\n       BINDING_VALUE (binding) = alias;\n     }\n }"}, {"sha": "51a4abaab8d7af45ffaf9fd9d8a97d8ef47d42b6", "filename": "gcc/cp/method.c", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "patch": "@@ -416,34 +416,31 @@ build_overload_nested_name (decl)\n      tree decl;\n {\n \n+  tree context;\n+\n   if (ktypelist && issue_ktype (decl))\n       return;\n \n   if (decl == global_namespace)\n     return;\n \n-   if (DECL_CONTEXT (decl))\n-    {\n-      tree context = DECL_CONTEXT (decl);\n+  context = CP_DECL_CONTEXT (decl);\n \n-      /* try to issue a K type, and if we can't continue the normal path */\n-      if (!(ktypelist && issue_ktype (context)))\n-        {\n-          /* For a template type parameter, we want to output an 'Xn'\n-             rather than 'T' or some such. */\n-          if (TREE_CODE (context) == TEMPLATE_TYPE_PARM\n-              || TREE_CODE (context) == TEMPLATE_TEMPLATE_PARM)\n-            build_mangled_name (context, 0, 0);\n-          else\n-            {\n-              if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n-                context = TYPE_NAME (context);\n-              build_overload_nested_name (context);\n-            }\n-        }\n+  /* try to issue a K type, and if we can't continue the normal path */\n+  if (!(ktypelist && issue_ktype (context)))\n+  {\n+    /* For a template type parameter, we want to output an 'Xn'\n+       rather than 'T' or some such. */\n+    if (TREE_CODE (context) == TEMPLATE_TYPE_PARM\n+        || TREE_CODE (context) == TEMPLATE_TEMPLATE_PARM)\n+      build_mangled_name (context, 0, 0);\n+    else\n+    {\n+      if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n+        context = TYPE_NAME (context);\n+      build_overload_nested_name (context);\n     }\n-  else \n-    my_friendly_abort (392);\n+  }\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {"}, {"sha": "a6d658bcfa409c28f70626ffa9d2f5daed5d3b0d", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 671, "deletions": 671, "changes": 1342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51"}, {"sha": "7bec357427d56945f073d21879a4f6061d45d0bb", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "patch": "@@ -280,13 +280,14 @@ empty_parms ()\n \f\n %{\n /* List of types and structure classes of the current declaration.  */\n-static tree current_declspecs = NULL_TREE;\n+static tree current_declspecs;\n+\n /* List of prefix attributes in effect.\n    Prefix attributes are parsed by the reserved_declspecs and declmods\n    rules.  They create a list that contains *both* declspecs and attrs.  */\n /* ??? It is not clear yet that all cases where an attribute can now appear in\n    a declspec list have been updated.  */\n-static tree prefix_attributes = NULL_TREE;\n+static tree prefix_attributes;\n \n /* When defining an aggregate, this is the most recent one being defined.  */\n static tree current_aggr;"}, {"sha": "32a7715f84c109147a13a858b61fa472ea3f0326", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "patch": "@@ -1662,7 +1662,7 @@ push_template_decl_real (decl, is_friend)\n     ctx = NULL_TREE;\n \n   if (!DECL_CONTEXT (decl))\n-    DECL_CONTEXT (decl) = current_namespace;\n+    DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n \n   /* For determining whether this is a primary template or not, we're really\n      interested in the lexical context, not the true context.  */\n@@ -2748,10 +2748,10 @@ mangle_class_name_for_template (name, parms, arglist, ctx)\n \t    {\n \t      /* Already substituted with real template.  Just output \n \t\t the template name here */\n-\t      my_friendly_assert (TREE_CODE (DECL_CONTEXT (arg)) \n-\t\t\t\t  == NAMESPACE_DECL, 980422);\n-\t      if (DECL_CONTEXT (arg) != global_namespace)\n+              tree context = DECL_CONTEXT (arg);\n+\t      if (context)\n \t\t{\n+                  my_friendly_assert (TREE_CODE (context) == NAMESPACE_DECL, 980422);\n \t\t  cat(decl_as_string (DECL_CONTEXT (arg), 0));\n \t\t  cat(\"::\");\n \t\t}\n@@ -2980,7 +2980,8 @@ lookup_template_class (d1, arglist, in_decl, context)\n     id_context = context;\n   else\n     id_context = DECL_CONTEXT (template);\n-  my_friendly_assert (id_context != NULL_TREE, 980410);\n+  if (id_context == NULL_TREE)\n+    id_context = global_namespace;\n \n   if (TREE_CODE (template) != TEMPLATE_DECL)\n     {\n@@ -3097,8 +3098,8 @@ lookup_template_class (d1, arglist, in_decl, context)\n \t     build_overload_name into creating a new name.  */\n \t  tree type_decl = TYPE_STUB_DECL (t);\n \n-\t  TYPE_CONTEXT (t) = context;\n-\t  DECL_CONTEXT (type_decl) = context;\n+\t  TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n+\t  DECL_CONTEXT (type_decl) = FROB_CONTEXT (context);\n \t  DECL_ASSEMBLER_NAME (type_decl) = DECL_NAME (type_decl);\n \t  DECL_ASSEMBLER_NAME (type_decl) = \n \t    get_identifier (build_overload_name (t, 1, 1));\n@@ -5025,7 +5026,7 @@ tsubst (t, args, in_decl)\n \t  {\n \t    fntype = make_node (TREE_CODE (t));\n \t    TREE_TYPE (fntype) = type;\n-\t    TYPE_CONTEXT (fntype) = context;\n+\t    TYPE_CONTEXT (fntype) = FROB_CONTEXT (context);\n \t    TYPE_VALUES (fntype) = values;\n \t    TYPE_SIZE (fntype) = TYPE_SIZE (t);\n \t    TYPE_ALIGN (fntype) = TYPE_ALIGN (t);"}, {"sha": "65350db79625580c69f0ae996b91d6f6acb898a1", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=cb0dbb9a01a4a3c2c2a5a94601b72c2c63cc2a51", "patch": "@@ -96,8 +96,6 @@ build_signature_pointer_or_reference_decl (type, name)\n   decl = build_decl (TYPE_DECL, name, type);\n   TYPE_NAME (type) = decl;\n   TREE_CHAIN (type) = decl;\n-  /* But we mangle it, so it needs a scope. */\n-  DECL_CONTEXT (decl) = global_namespace;\n }\n \n /* Construct, lay out and return the type of pointers or references"}]}