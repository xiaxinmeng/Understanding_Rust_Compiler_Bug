{"sha": "0592046e2397a7206383190f84017e9bbe1dd7bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU5MjA0NmUyMzk3YTcyMDYzODMxOTBmODQwMTdlOWJiZTFkZDdiYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T13:05:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T13:05:30Z"}, "message": "[multiple changes]\n\n2010-10-26  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_prag.adb (Process_Import_Or_Interface): Skip primitives of\n\tinterface types when processing all the entities in the homonym chain\n\tthat are declared in the same declarative part.\n\n2010-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Process_Range_In_Decl): If the range is part of a\n\tquantified expression, the insertion point for range checks will be\n\tarbitrarily far in the tree.\n\t* sem_ch5.adb (One_Bound): Use Insert_Actions for the declaration of\n\tthe temporary that holds the value of the bounds.\n\t* sem_res.adb (Resolve_Quantified_Expressions): Disable expansion of\n\tcondition until the full expression is expanded.\n\nFrom-SVN: r165957", "tree": {"sha": "84180c9964f9e5e162ea1c8f5517138d11181e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84180c9964f9e5e162ea1c8f5517138d11181e87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0592046e2397a7206383190f84017e9bbe1dd7bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0592046e2397a7206383190f84017e9bbe1dd7bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0592046e2397a7206383190f84017e9bbe1dd7bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0592046e2397a7206383190f84017e9bbe1dd7bc/comments", "author": null, "committer": null, "parents": [{"sha": "880dabb586a7da7a9198319daef82bf87df7422c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880dabb586a7da7a9198319daef82bf87df7422c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/880dabb586a7da7a9198319daef82bf87df7422c"}], "stats": {"total": 129, "additions": 92, "deletions": 37}, "files": [{"sha": "69ae440f1b6de2f60fed32b40489d80431b1a126", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0592046e2397a7206383190f84017e9bbe1dd7bc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0592046e2397a7206383190f84017e9bbe1dd7bc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0592046e2397a7206383190f84017e9bbe1dd7bc", "patch": "@@ -1,3 +1,19 @@\n+2010-10-26  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_prag.adb (Process_Import_Or_Interface): Skip primitives of\n+\tinterface types when processing all the entities in the homonym chain\n+\tthat are declared in the same declarative part.\n+\n+2010-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Process_Range_In_Decl): If the range is part of a\n+\tquantified expression, the insertion point for range checks will be\n+\tarbitrarily far in the tree.\n+\t* sem_ch5.adb (One_Bound): Use Insert_Actions for the declaration of\n+\tthe temporary that holds the value of the bounds.\n+\t* sem_res.adb (Resolve_Quantified_Expressions): Disable expansion of\n+\tcondition until the full expression is expanded.\n+\n 2010-10-26  Robert Dewar  <dewar@adacore.com>\n \n \t* opt.ads: Comment fix."}, {"sha": "62aee52b674d915d022542a430a5d03a724544ef", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 54, "deletions": 30, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0592046e2397a7206383190f84017e9bbe1dd7bc/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0592046e2397a7206383190f84017e9bbe1dd7bc/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=0592046e2397a7206383190f84017e9bbe1dd7bc", "patch": "@@ -17627,10 +17627,10 @@ package body Sem_Ch3 is\n       Check_List  : List_Id := Empty_List;\n       R_Check_Off : Boolean := False)\n    is\n-      Lo, Hi    : Node_Id;\n-      R_Checks  : Check_Result;\n-      Type_Decl : Node_Id;\n-      Def_Id    : Entity_Id;\n+      Lo, Hi      : Node_Id;\n+      R_Checks    : Check_Result;\n+      Insert_Node : Node_Id;\n+      Def_Id      : Entity_Id;\n \n    begin\n       Analyze_And_Resolve (R, Base_Type (T));\n@@ -17738,32 +17738,43 @@ package body Sem_Ch3 is\n             if not R_Check_Off then\n                R_Checks := Get_Range_Checks (R, T);\n \n-               --  Look up tree to find an appropriate insertion point.\n-               --  This seems really junk code, and very brittle, couldn't\n-               --  we just use an insert actions call of some kind ???\n-\n-               Type_Decl := Parent (R);\n-               while Present (Type_Decl) and then not\n-                 (Nkind_In (Type_Decl, N_Full_Type_Declaration,\n-                                       N_Subtype_Declaration,\n-                                       N_Loop_Statement,\n-                                       N_Task_Type_Declaration)\n-                    or else\n-                  Nkind_In (Type_Decl, N_Single_Task_Declaration,\n-                                       N_Protected_Type_Declaration,\n-                                       N_Single_Protected_Declaration))\n-               loop\n-                  Type_Decl := Parent (Type_Decl);\n+               --  Look up tree to find an appropriate insertion point. We\n+               --  can't just use insert_actions because later processing\n+               --  depends on the insertion node. Prior to Ada2012 the\n+               --  insertion point could only be a declaration or a loop, but\n+               --  quantified expressions can appear within any context in an\n+               --  expression, and the insertion point can be any statement,\n+               --  pragma, or declaration.\n+\n+               Insert_Node := Parent (R);\n+               while Present (Insert_Node) loop\n+                  exit when\n+                    Nkind (Insert_Node) in N_Declaration\n+                    and then\n+                      not Nkind_In\n+                        (Insert_Node, N_Component_Declaration,\n+                                      N_Loop_Parameter_Specification,\n+                                      N_Function_Specification,\n+                                      N_Procedure_Specification);\n+\n+                  exit when Nkind (Insert_Node) in N_Later_Decl_Item\n+                    or else Nkind (Insert_Node) in\n+                              N_Statement_Other_Than_Procedure_Call\n+                    or else Nkind_In (Insert_Node, N_Procedure_Call_Statement,\n+                                                   N_Pragma);\n+\n+                  Insert_Node := Parent (Insert_Node);\n                end loop;\n \n                --  Why would Type_Decl not be present???  Without this test,\n                --  short regression tests fail.\n \n-               if Present (Type_Decl) then\n+               if Present (Insert_Node) then\n \n-                  --  Case of loop statement (more comments ???)\n+                  --  Case of loop statement. Verify that the range is part\n+                  --  of the subtype indication of the iteration scheme.\n \n-                  if Nkind (Type_Decl) = N_Loop_Statement then\n+                  if Nkind (Insert_Node) = N_Loop_Statement then\n                      declare\n                         Indic : Node_Id;\n \n@@ -17780,18 +17791,20 @@ package body Sem_Ch3 is\n \n                            Insert_Range_Checks\n                              (R_Checks,\n-                              Type_Decl,\n+                              Insert_Node,\n                               Def_Id,\n-                              Sloc (Type_Decl),\n+                              Sloc (Insert_Node),\n                               R,\n                               Do_Before => True);\n                         end if;\n                      end;\n \n-                  --  All other cases (more comments ???)\n+                  --  Insertion before a declaration. If the declaration\n+                  --  includes discriminants, the list of applicable checks\n+                  --  is given by the caller.\n \n-                  else\n-                     Def_Id := Defining_Identifier (Type_Decl);\n+                  elsif Nkind (Insert_Node) in N_Declaration then\n+                     Def_Id := Defining_Identifier (Insert_Node);\n \n                      if (Ekind (Def_Id) = E_Record_Type\n                           and then Depends_On_Discriminant (R))\n@@ -17800,18 +17813,29 @@ package body Sem_Ch3 is\n                           and then Has_Discriminants (Def_Id))\n                      then\n                         Append_Range_Checks\n-                          (R_Checks, Check_List, Def_Id, Sloc (Type_Decl), R);\n+                          (R_Checks,\n+                            Check_List, Def_Id, Sloc (Insert_Node), R);\n \n                      else\n                         Insert_Range_Checks\n-                          (R_Checks, Type_Decl, Def_Id, Sloc (Type_Decl), R);\n+                          (R_Checks,\n+                            Insert_Node, Def_Id, Sloc (Insert_Node), R);\n \n                      end if;\n+\n+                  --  Insertion before a statement. Range appears in the\n+                  --  context of a quantified expression. Insertion will\n+                  --  take place when expression is expanded.\n+\n+                  else\n+                     null;\n                   end if;\n                end if;\n             end if;\n          end if;\n \n+      --  Case of other than an explicit N_Range node\n+\n       elsif Expander_Active then\n          Get_Index_Bounds (R, Lo, Hi);\n          Force_Evaluation (Lo);"}, {"sha": "68305d6e80cd42a2bae7653a401553acda72cfff", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0592046e2397a7206383190f84017e9bbe1dd7bc/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0592046e2397a7206383190f84017e9bbe1dd7bc/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=0592046e2397a7206383190f84017e9bbe1dd7bc", "patch": "@@ -1538,8 +1538,11 @@ package body Sem_Ch5 is\n                    Object_Definition   => New_Occurrence_Of (Typ, Loc),\n                    Expression          => Relocate_Node (Original_Bound));\n \n-               Insert_Before (Parent (N), Decl);\n-               Analyze (Decl);\n+               --  Insert declaration at proper place. If loop comes from an\n+               --  enclosing quantified expression, the insertion point is\n+               --  arbitrarily far up in the tree.\n+\n+               Insert_Action (Parent (N), Decl);\n                Rewrite (Original_Bound, New_Occurrence_Of (Id, Loc));\n                return Expression (Decl);\n             end if;"}, {"sha": "acc68474f3559421164959365cf0554e64b2ae39", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0592046e2397a7206383190f84017e9bbe1dd7bc/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0592046e2397a7206383190f84017e9bbe1dd7bc/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0592046e2397a7206383190f84017e9bbe1dd7bc", "patch": "@@ -3928,6 +3928,14 @@ package body Sem_Prag is\n                then\n                   null;\n \n+               --  The pragma does not apply to primitives of interfaces\n+\n+               elsif Is_Dispatching_Operation (Def_Id)\n+                 and then Present (Find_Dispatching_Type (Def_Id))\n+                 and then Is_Interface (Find_Dispatching_Type (Def_Id))\n+               then\n+                  null;\n+\n                --  Verify that the homonym is in the same declarative part (not\n                --  just the same scope).\n \n@@ -4047,10 +4055,10 @@ package body Sem_Prag is\n            and then C = Convention_CPP\n          then\n             --  Types treated as CPP classes are treated as limited, but we\n-            --  don't require them to be declared this way. A warning is\n-            --  issued to encourage the user to declare them as limited.\n-            --  This is not an error, for compatibility reasons, because\n-            --  these types have been supported this way for some time.\n+            --  don't require them to be declared this way. A warning is issued\n+            --  to encourage the user to declare them as limited. This is not\n+            --  an error, for compatibility reasons, because these types have\n+            --  been supported this way for some time.\n \n             if not Is_Limited_Type (Def_Id) then\n                Error_Msg_N"}, {"sha": "8dd8a525955f72a356f136ed8fd82ab7f4eed081", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0592046e2397a7206383190f84017e9bbe1dd7bc/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0592046e2397a7206383190f84017e9bbe1dd7bc/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=0592046e2397a7206383190f84017e9bbe1dd7bc", "patch": "@@ -7809,9 +7809,13 @@ package body Sem_Res is\n    procedure Resolve_Quantified_Expression (N : Node_Id; Typ : Entity_Id) is\n    begin\n       --  The loop structure is already resolved during its analysis, only the\n-      --  resolution of the condition needs to be done.\n+      --  resolution of the condition needs to be done. Expansion is disabled\n+      --  so that checks and other generated code are inserted in the tree\n+      --  after expression has been rewritten as a loop.\n \n+      Expander_Mode_Save_And_Set (False);\n       Resolve (Condition (N), Typ);\n+      Expander_Mode_Restore;\n    end Resolve_Quantified_Expression;\n \n    -------------------"}]}