{"sha": "208e5afa4bb3d5bf8f3f187777756815f7845bb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA4ZTVhZmE0YmIzZDViZjhmM2YxODc3Nzc3NTY4MTVmNzg0NWJiNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-01-12T09:28:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-01-12T09:28:15Z"}, "message": "re PR ipa/63967 (r217633 caused internal compiler error: in estimate_edge_growth, at ipa-inline.h:299)\n\n\n\tPR ipa/63967\n\tPR ipa/64425\n\t* ipa-inline.c (compute_uninlined_call_time,\n\tcompute_inlined_call_time): Use counts for extra precision when\n\tneeded possible.\n\t(big_speedup_p): Fix formating.\n\t(RELATIVE_TIME_BENEFIT_RANGE): Remove.\n\t(relative_time_benefit): Remove.\n\t(edge_badness): Turn DECL_DISREGARD_INLINE_LIMITS into hint;\n\tmerge guessed and read profile paths.\n\t(inline_small_functions): Count only !optimize_size functions into\n\tinitial size; be more lax about sanity check when profile is used;\n\tbe sure to update inlined function profile when profile is read.\n\nFrom-SVN: r219452", "tree": {"sha": "b49d8ccd1432c3d72a5f5871247d1a2a69d22a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b49d8ccd1432c3d72a5f5871247d1a2a69d22a41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/208e5afa4bb3d5bf8f3f187777756815f7845bb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208e5afa4bb3d5bf8f3f187777756815f7845bb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/208e5afa4bb3d5bf8f3f187777756815f7845bb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208e5afa4bb3d5bf8f3f187777756815f7845bb6/comments", "author": null, "committer": null, "parents": [{"sha": "d8d5aef10080e5c96414ba48fa31e41e823a95f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8d5aef10080e5c96414ba48fa31e41e823a95f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8d5aef10080e5c96414ba48fa31e41e823a95f7"}], "stats": {"total": 206, "additions": 97, "deletions": 109}, "files": [{"sha": "406b42683fd90b9768c4780006db04a504889942", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208e5afa4bb3d5bf8f3f187777756815f7845bb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208e5afa4bb3d5bf8f3f187777756815f7845bb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=208e5afa4bb3d5bf8f3f187777756815f7845bb6", "patch": "@@ -1,3 +1,19 @@\n+2015-01-12  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/63967\n+\tPR ipa/64425\n+\t* ipa-inline.c (compute_uninlined_call_time,\n+\tcompute_inlined_call_time): Use counts for extra precision when\n+\tneeded possible.\n+\t(big_speedup_p): Fix formating.\n+\t(RELATIVE_TIME_BENEFIT_RANGE): Remove.\n+\t(relative_time_benefit): Remove.\n+\t(edge_badness): Turn DECL_DISREGARD_INLINE_LIMITS into hint;\n+\tmerge guessed and read profile paths.\n+\t(inline_small_functions): Count only !optimize_size functions into\n+\tinitial size; be more lax about sanity check when profile is used;\n+\tbe sure to update inlined function profile when profile is read.\n+\n 2015-01-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/63470"}, {"sha": "a99001ad484da5e31395bdbd7c7f1058996c072a", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 81, "deletions": 109, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208e5afa4bb3d5bf8f3f187777756815f7845bb6/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208e5afa4bb3d5bf8f3f187777756815f7845bb6/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=208e5afa4bb3d5bf8f3f187777756815f7845bb6", "patch": "@@ -530,12 +530,19 @@ inline sreal\n compute_uninlined_call_time (struct inline_summary *callee_info,\n \t\t\t     struct cgraph_edge *edge)\n {\n-  sreal uninlined_call_time = (sreal)callee_info->time\n-\t\t\t      * MAX (edge->frequency, 1)\n-\t\t\t      * cgraph_freq_base_rec;\n-  int caller_time = inline_summaries->get (edge->caller->global.inlined_to\n-\t\t\t\t           ? edge->caller->global.inlined_to\n-\t\t\t\t           : edge->caller)->time;\n+  sreal uninlined_call_time = (sreal)callee_info->time;\n+  cgraph_node *caller = (edge->caller->global.inlined_to \n+\t\t\t ? edge->caller->global.inlined_to\n+\t\t\t : edge->caller);\n+\n+  if (edge->count && caller->count)\n+    uninlined_call_time *= (sreal)edge->count / caller->count;\n+  if (edge->frequency)\n+    uninlined_call_time *= cgraph_freq_base_rec * edge->frequency;\n+  else\n+    uninlined_call_time = uninlined_call_time >> 11;\n+\n+  int caller_time = inline_summaries->get (caller)->time;\n   return uninlined_call_time + caller_time;\n }\n \n@@ -546,13 +553,28 @@ inline sreal\n compute_inlined_call_time (struct cgraph_edge *edge,\n \t\t\t   int edge_time)\n {\n-  int caller_time = inline_summaries->get (edge->caller->global.inlined_to\n-\t\t\t\t           ? edge->caller->global.inlined_to\n-\t\t\t\t           : edge->caller)->time;\n-  sreal time = (sreal)caller_time\n-\t       + ((sreal) (edge_time - inline_edge_summary (edge)->call_stmt_time)\n-\t          * MAX (edge->frequency, 1)\n-\t          * cgraph_freq_base_rec);\n+  cgraph_node *caller = (edge->caller->global.inlined_to \n+\t\t\t ? edge->caller->global.inlined_to\n+\t\t\t : edge->caller);\n+  int caller_time = inline_summaries->get (caller)->time;\n+  sreal time = edge_time;\n+\n+  if (edge->count && caller->count)\n+    time *= (sreal)edge->count / caller->count;\n+  if (edge->frequency)\n+    time *= cgraph_freq_base_rec * edge->frequency;\n+  else\n+    time = time >> 11;\n+\n+  /* This calculation should match one in ipa-inline-analysis.\n+     FIXME: Once ipa-inline-analysis is converted to sreal this can be\n+     simplified.  */\n+  time -= (sreal) ((gcov_type) edge->frequency\n+\t\t   * inline_edge_summary (edge)->call_stmt_time\n+\t           * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE)) / INLINE_TIME_SCALE;\n+  time += caller_time;\n+  if (time <= 0)\n+    time = ((sreal) 1) >> 8;\n   gcc_checking_assert (time >= 0);\n   return time;\n }\n@@ -563,8 +585,10 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n static bool\n big_speedup_p (struct cgraph_edge *e)\n {\n-  sreal time = compute_uninlined_call_time (inline_summaries->get (e->callee), e);\n+  sreal time = compute_uninlined_call_time (inline_summaries->get (e->callee),\n+\t\t\t\t\t    e);\n   sreal inlined_time = compute_inlined_call_time (e, estimate_edge_time (e));\n+\n   if (time - inlined_time\n       > (sreal) time * PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP)\n \t * percent_rec)\n@@ -862,49 +886,6 @@ want_inline_function_to_all_callers_p (struct cgraph_node *node, bool cold)\n   return true;\n }\n \n-#define RELATIVE_TIME_BENEFIT_RANGE (INT_MAX / 64)\n-\n-/* Return relative time improvement for inlining EDGE in range\n-   as value NUMERATOR/DENOMINATOR.  */\n-\n-static inline void\n-relative_time_benefit (struct inline_summary *callee_info,\n-\t\t       struct cgraph_edge *edge,\n-\t\t       int edge_time,\n-\t\t       sreal *numerator,\n-\t\t       sreal *denominator)\n-{\n-  /* Inlining into extern inline function is not a win.  */\n-  if (DECL_EXTERNAL (edge->caller->global.inlined_to\n-\t\t     ? edge->caller->global.inlined_to->decl\n-\t\t     : edge->caller->decl))\n-    {\n-      *numerator = (sreal) 1;\n-      *denominator = (sreal) 1024;\n-      return;\n-    }\n-\n-  sreal uninlined_call_time = compute_uninlined_call_time (callee_info, edge);\n-  sreal inlined_call_time = compute_inlined_call_time (edge, edge_time);\n-\n-  /* Compute relative time benefit, i.e. how much the call becomes faster.\n-     ??? perhaps computing how much the caller+calle together become faster\n-     would lead to more realistic results.  */\n-  if (uninlined_call_time == (sreal) 0)\n-    uninlined_call_time = 1;\n-\n-  /* Avoid zeros, these are not useful later in calculations.  */\n-  if (uninlined_call_time == inlined_call_time)\n-    *numerator = ((sreal) 1)>>8;\n-  else\n-    *numerator = uninlined_call_time - inlined_call_time;\n-  *denominator = uninlined_call_time;\n-#ifdef ENABLE_CHECKING\n-  gcc_checking_assert (*numerator >= 0);\n-  gcc_checking_assert (*denominator >= 0);\n-#endif\n-}\n-\n /* A cost model driving the inlining heuristics in a way so the edges with\n    smallest badness are inlined first.  After each inlining is performed\n    the costs of all caller edges of nodes affected are recomputed so the\n@@ -919,9 +900,9 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n   struct inline_summary *callee_info = inline_summaries->get (callee);\n   inline_hints hints;\n-\n-  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n-    return sreal::min ();\n+  cgraph_node *caller = (edge->caller->global.inlined_to \n+\t\t\t ? edge->caller->global.inlined_to\n+\t\t\t : edge->caller);\n \n   growth = estimate_edge_growth (edge);\n   edge_time = estimate_edge_time (edge);\n@@ -954,74 +935,52 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \tfprintf (dump_file, \"      %f: Growth %d <= 0\\n\", badness.to_double (),\n \t\t growth);\n     }\n-\n-  /* When profiling is available, compute badness as:\n-\n-\t        edge_count * relative_time_benefit\n-     goodness = -------------------------------------------\n-\t\tgrowth_of_caller\n-     badness = - goodness \n-\n-    The fraction is upside down, because on edge counts and time beneits\n-    the bounds are known. Edge growth is essentially unlimited.  */\n-\n-  else if (max_count)\n+   /* Inlining into EXTERNAL functions is not going to change anything unless\n+      they are themselves inlined.  */\n+   else if (DECL_EXTERNAL (caller->decl))\n     {\n-      sreal numerator, denominator;\n-      relative_time_benefit (callee_info, edge, edge_time, &numerator,\n-\t\t\t     &denominator);\n-\n-      if (edge->count)\n-        numerator *= edge->count;\n-      denominator *= growth;\n-\n-      badness = - numerator / denominator;\n- \n       if (dump)\n-\t{\n-\t  sreal num,den;\n-          relative_time_benefit (callee_info, edge, edge_time, &num, &den);\n-\t  fprintf (dump_file,\n-\t\t   \"      %f: profile info. count %\"PRId64\n-\t\t   \" * Relative benefit %f / growth %i\\n\",\n-\t\t   badness.to_double (), (int64_t)edge->count,\n-\t\t   (num / den * 100).to_double (), growth);\n-\t}\n+\tfprintf (dump_file, \"      max: function is external\\n\");\n+      return sreal::max ();\n     }\n-\n-  /* When function local profile is available. Compute badness as:\n+  /* When profile is available. Compute badness as:\n      \n-                 relative_time_benefit\n+                 time_saved * caller_count\n      goodness =  ---------------------------------\n \t         growth_of_caller * overall_growth\n \n      badness = - goodness\n \n-     compensated by the inline hints.\n+     Again use negative value to make calls with profile appear hotter\n+     then calls without.\n   */\n-  /* TODO: We ought suport mixing units where some functions are profiled\n-     and some not.  */\n-  else if (flag_guess_branch_prob)\n+  else if (opt_for_fn (caller->decl, flag_guess_branch_prob) || caller->count)\n     {\n       sreal numerator, denominator;\n-      relative_time_benefit (callee_info, edge, edge_time, &numerator,\n-\t\t\t     &denominator);\n-      denominator *= growth;\n+\n+      numerator = (compute_uninlined_call_time (callee_info, edge)\n+\t\t   - compute_inlined_call_time (edge, edge_time));\n+      if (numerator == 0)\n+\tnumerator = ((sreal) 1 >> 8);\n+      if (caller->count)\n+\tnumerator *= caller->count;\n+      else if (opt_for_fn (caller->decl, flag_branch_probabilities))\n+\tnumerator = numerator >> 11;\n+      denominator = growth;\n       if (callee_info->growth > 0)\n \tdenominator *= callee_info->growth;\n \n       badness = - numerator / denominator;\n \n       if (dump)\n \t{\n-\t  sreal num,den;\n-          relative_time_benefit (callee_info, edge, edge_time, &num, &den);\n \t  fprintf (dump_file,\n-\t\t   \"      %f: guessed profile. frequency %f,\"\n-\t\t   \" benefit %f%%, time w/o inlining %f, time w inlining %f\"\n+\t\t   \"      %f: guessed profile. frequency %f, count %\"PRId64\n+\t\t   \" caller count %\"PRId64\n+\t\t   \" time w/o inlining %f, time w inlining %f\"\n \t\t   \" overall growth %i (current) %i (original)\\n\",\n \t\t   badness.to_double (), (double)edge->frequency / CGRAPH_FREQ_BASE,\n-\t\t   (num/den).to_double () * 100, \n+\t\t   edge->count, caller->count,\n \t\t   compute_uninlined_call_time (callee_info, edge).to_double (),\n \t\t   compute_inlined_call_time (edge, edge_time).to_double (),\n \t\t   estimate_growth (callee),\n@@ -1062,7 +1021,9 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n     badness = badness.shift (badness > 0 ? 2 : -2);\n   else if (hints & (INLINE_HINT_cross_module))\n     badness = badness.shift (badness > 0 ? 1 : -1);\n-  if ((hints & INLINE_HINT_declared_inline))\n+  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n+    badness = badness.shift (badness > 0 ? -4 : 4);\n+  else if ((hints & INLINE_HINT_declared_inline))\n     badness = badness.shift (badness > 0 ? -3 : 3);\n   if (dump)\n     fprintf (dump_file, \"      Adjusted by hints %f\\n\", badness.to_double ());\n@@ -1592,6 +1553,7 @@ inline_small_functions (void)\n \t    /* Do not account external functions, they will be optimized out\n \t       if not inlined.  Also only count the non-cold portion of program.  */\n \t    if (!DECL_EXTERNAL (node->decl)\n+\t\t&& !opt_for_fn (node->decl, optimize_size)\n \t\t&& node->frequency != NODE_FREQUENCY_UNLIKELY_EXECUTED)\n \t      initial_size += info->size;\n \t    info->growth = estimate_growth (node);\n@@ -1696,8 +1658,10 @@ inline_small_functions (void)\n \t Increases of badness are handled lazilly; when we see key with out\n \t of date value on it, we re-insert it now.  */\n       current_badness = edge_badness (edge, false);\n-      gcc_assert (cached_badness == current_badness);\n-      gcc_assert (current_badness >= badness);\n+      /* Disable checking for profile because roundoff errors may cause slight\n+         deviations in the order.  */\n+      gcc_assert (max_count || cached_badness == current_badness);\n+      gcc_assert (max_count || current_badness >= badness);\n #else\n       current_badness = edge_badness (edge, false);\n #endif\n@@ -1835,6 +1799,14 @@ inline_small_functions (void)\n \t called by function we inlined (since number of it inlinable callers\n \t might change).  */\n       update_caller_keys (&edge_heap, where, updated_nodes, NULL);\n+      /* Offline copy count has possibly changed, recompute if profile is\n+\t available.  */\n+      if (max_count)\n+        {\n+\t  struct cgraph_node *n = cgraph_node::get (edge->callee->decl);\n+\t  if (n != edge->callee && n->analyzed)\n+\t    update_callee_keys (&edge_heap, n, updated_nodes);\n+        }\n       bitmap_clear (updated_nodes);\n \n       if (dump_file)"}]}