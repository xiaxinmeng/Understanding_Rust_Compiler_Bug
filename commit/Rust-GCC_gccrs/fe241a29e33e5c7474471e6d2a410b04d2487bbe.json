{"sha": "fe241a29e33e5c7474471e6d2a410b04d2487bbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUyNDFhMjllMzNlNWM3NDc0NDcxZTZkMmE0MTBiMDRkMjQ4N2JiZQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-06T13:14:03Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-06T13:14:03Z"}, "message": "(storehi_bigend): New expansion pattern.\n\n(storeinthi): Rework to generate better code, add big-endian support.\n(movhi): Add support for processors running in big-endian mode.\n(movhi_bigend): New expansion pattern.\n(matcher for movhi): Remove incorrect alternative for storing HImode to\nmemory.  Only match when little endian.\n(matcher for big-endian movhi): New pattern.\n(matchers/peepholes for extended pre/post increment HImode loads): Only\nmatch when little-endian.\n(matcher for operating on adjacent memory locations): Load operation into\narith operands.\n(peepholes for extended pre-increment byte loads): New patterns.\n\nFrom-SVN: r7448", "tree": {"sha": "e83992ccba1bebcf8201a7e4363b3752bc59b974", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e83992ccba1bebcf8201a7e4363b3752bc59b974"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe241a29e33e5c7474471e6d2a410b04d2487bbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe241a29e33e5c7474471e6d2a410b04d2487bbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe241a29e33e5c7474471e6d2a410b04d2487bbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe241a29e33e5c7474471e6d2a410b04d2487bbe/comments", "author": null, "committer": null, "parents": [{"sha": "9c8728721e9f5bb6c95061409a85e9cbb0b3a585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c8728721e9f5bb6c95061409a85e9cbb0b3a585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c8728721e9f5bb6c95061409a85e9cbb0b3a585"}], "stats": {"total": 236, "additions": 166, "deletions": 70}, "files": [{"sha": "d860edabe09c6f34f9b9c8434c3c057123d7a1d9", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 166, "deletions": 70, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe241a29e33e5c7474471e6d2a410b04d2487bbe/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe241a29e33e5c7474471e6d2a410b04d2487bbe/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=fe241a29e33e5c7474471e6d2a410b04d2487bbe", "patch": "@@ -1983,30 +1983,69 @@\n }\n \")\n \n-;; Subroutine to store a half word integer constant into memory.\n-;; Operand 0 is the constant\n-;; Operand 1 is the destination address in a register (SImode)\n-\n-(define_expand \"storeinthi\"\n-  [;; store the low byte\n-   (set (mem:QI (match_operand:SI 1 \"\" \"\")) (match_operand 0 \"\" \"\"))\n-   ;; store the high byte\n-   (set (mem:QI (match_dup 3)) (match_dup 2))]\n+(define_expand \"storehi_bigend\"\n+  [(set (mem:QI (match_dup 4)) (match_dup 3))\n+   (set (match_dup 2)\n+\t(ashiftrt:SI (match_operand 0 \"\" \"\") (const_int 8)))\n+   (set (mem:QI (match_operand 1 \"\" \"\"))\n+\t(subreg:QI (match_dup 2) 0))]\n   \"\"\n   \"\n {\n-  int value = INTVAL (operands[0]);\n   enum rtx_code code = GET_CODE (operands[1]);\n-\n   if ((code == PLUS || code == MINUS)\n       && (GET_CODE (XEXP (operands[1], 1)) == REG\n \t  || GET_CODE (XEXP (operands[1], 0)) != REG))\n-  operands[1] = force_reg (SImode, operands[1]);\n+    operands[1] = force_reg (SImode, operands[1]);\n \n-  operands[0] = force_reg (QImode, gen_rtx (CONST_INT, VOIDmode, value & 255));\n-  operands[2] = force_reg (QImode,\n-\t\t\t   gen_rtx (CONST_INT, VOIDmode,(value>>8) & 255));\n-  operands[3] = plus_constant (operands[1], 1);\n+  operands[4] = plus_constant (operands[1], 1);\n+  operands[3] = gen_lowpart (QImode, operands[0]);\n+  operands[0] = gen_lowpart (SImode, operands[0]);\n+  operands[2] = gen_reg_rtx (SImode);\n+}\n+\")\n+\n+;; Subroutine to store a half word integer constant into memory.\n+(define_expand \"storeinthi\"\n+  [(set (mem:QI (match_operand:SI 0 \"\" \"\"))\n+\t(subreg:QI (match_operand 1 \"\" \"\") 0))\n+   (set (mem:QI (match_dup 3)) (subreg:QI (match_dup 2) 0))]\n+  \"\"\n+  \"\n+{\n+  HOST_WIDE_INT value = INTVAL (operands[1]);\n+  enum rtx_code code = GET_CODE (operands[0]);\n+\n+  if ((code == PLUS || code == MINUS)\n+      && (GET_CODE (XEXP (operands[0], 1)) == REG\n+\t  || GET_CODE (XEXP (operands[0], 0)) != REG))\n+  operands[0] = force_reg (SImode, operands[0]);\n+\n+  operands[1] = gen_reg_rtx (SImode);\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      emit_insn (gen_movsi (operands[1], GEN_INT ((value >> 8) & 255)));\n+      if ((value & 255) == ((value >> 8) & 255))\n+\toperands[2] = operands[1];\n+      else\n+\t{\n+\t  operands[2] = gen_reg_rtx (SImode);\n+\t  emit_insn (gen_movsi (operands[2], GEN_INT (value & 255)));\n+\t}\n+    }\n+  else\n+    {\n+      emit_insn (gen_movsi (operands[1], GEN_INT (value & 255)));\n+      if ((value & 255) == ((value >> 8) & 255))\n+\toperands[2] = operands[1];\n+      else\n+\t{\n+\t  operands[2] = gen_reg_rtx (SImode);\n+\t  emit_insn (gen_movsi (operands[2], GEN_INT ((value >> 8) & 255)));\n+\t}\n+    }\n+\n+  operands[3] = plus_constant (operands[0], 1);\n }\n \")\n \n@@ -2018,74 +2057,105 @@\n {\n   rtx insn;\n \n-  if (reload_in_progress || reload_completed)\n-    insn = gen_rtx (SET, VOIDmode, operands[0], operands[1]);\n-  else\n+  if (! (reload_in_progress || reload_completed))\n     {\n       if (GET_CODE (operands[0]) == MEM)\n \t{\n \t  if (GET_CODE (operands[1]) == CONST_INT)\n-\t    {\n-\t      insn = gen_storeinthi (operands[1], XEXP (operands[0],0));\n-\t    }\n+\t    emit_insn (gen_storeinthi (XEXP (operands[0], 0), operands[1]));\n \t  else\n \t    {\n \t      if (GET_CODE (operands[1]) == MEM)\n \t\toperands[1] = force_reg (HImode, operands[1]);\n-\t      insn = gen_storehi (operands[1], XEXP (operands[0], 0));\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\temit_insn (gen_storehi_bigend (operands[1],\n+\t\t\t\t\t       XEXP (operands[0], 0)));\n+\t      else\n+\t\temit_insn (gen_storehi (operands[1], XEXP (operands[0], 0)));\n \t    }\n+\t  DONE;\n \t}\n-      else if (GET_CODE (operands[1]) == CONST_INT\n-\t       && !(const_ok_for_arm (INTVAL (operands[1]))\n-\t\t   || const_ok_for_arm (~INTVAL (operands[1]))))\n+      /* Sign extend a constant, and keep it in an SImode reg.  */\n+      else if (GET_CODE (operands[1]) == CONST_INT)\n \t{\n-\t  rtx reg, reg2;\n+\t  rtx reg = gen_reg_rtx (SImode);\n+\t  HOST_WIDE_INT val = INTVAL (operands[1]) & 0xffff;\n \n-\t  /* no need to be clever, this will always take two insns.\n-\t     The top sixteen bits should be all zeros or all ones. */\n-\t  if (INTVAL (operands[1]) < 0)\n-\t    {\n-\t      emit_insn (gen_movsi (reg = gen_reg_rtx (SImode),\n-\t\t\t\t    GEN_INT (INTVAL (operands[1])\n-\t\t\t\t\t     | ~(0x0ff00))));\n-\t      emit_insn (gen_addsi3 (reg2 = gen_reg_rtx (SImode), reg,\n-\t\t\t\t     GEN_INT (-((~INTVAL (operands[1]))\n-\t\t\t\t\t        & 0xff))));\n-\t    }\n-\t  else\n+\t  /* If the constant is already valid, leave it alone.  */\n+\t  if (! const_ok_for_arm (val))\n \t    {\n-\t      emit_insn (gen_movsi (reg = gen_reg_rtx (SImode),\n-\t\t\t\t    GEN_INT (INTVAL (operands[1]) & 0xff00)));\n-\t      emit_insn (gen_addsi3 (reg2 = gen_reg_rtx (SImode), reg,\n-\t\t\t\t     GEN_INT (INTVAL (operands[1]) & 0x00ff)));\n+\t      /* If setting all the top bits will make the constant \n+\t\t loadable in a single instruction, then set them.  \n+\t\t Otherwise, sign extend the number.  */\n+\n+\t      if (const_ok_for_arm (~ (val | ~0xffff)))\n+\t\tval |= ~0xffff;\n+\t      else if (val & 0x8000)\n+\t\tval |= ~0xffff;\n \t    }\n-\t  insn = gen_rtx (SET, HImode, operands[0],\n-\t\t\t  gen_rtx (SUBREG, HImode, reg2, 0));\n+\n+\t  emit_insn (gen_movsi (reg, GEN_INT (val)));\n+\t  operands[1] = gen_rtx (SUBREG, HImode, reg, 0);\n+\t}\n+      else if (BYTES_BIG_ENDIAN && GET_CODE (operands[1]) == MEM)\n+\t{\n+\t  emit_insn (gen_movhi_bigend (operands[0], operands[1]));\n+\t  DONE;\n \t}\n-      else\n-\tinsn = gen_rtx (SET, VOIDmode, operands[0], operands[1]);\n     }\n+}\n+\")\n \n-  emit_insn (insn);\n-  DONE;\n-}\")\n+(define_expand \"movhi_bigend\"\n+  [(set (match_dup 2)\n+\t(rotate:SI (subreg:SI (match_operand:HI 1 \"memory_operand\" \"\") 0)\n+\t\t   (const_int 16)))\n+   (set (match_dup 3)\n+\t(ashiftrt:SI (match_dup 2) (const_int 16)))\n+   (set (match_operand:HI 0 \"s_register_operand\" \"\")\n+\t(subreg:HI (match_dup 3) 0))]\n+  \"\"\n+  \"\n+  operands[2] = gen_reg_rtx (SImode);\n+  operands[3] = gen_reg_rtx (SImode);\n+\")\n \n ;; Pattern to recognise insn generated default case above\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,r,m\")\n-\t(match_operand:HI 1 \"general_operand\"  \"rI,K,m,r\"))]\n-  \"(register_operand (operands[0], HImode)\n-    && (GET_CODE (operands[1]) != CONST_INT\n-\t|| const_ok_for_arm (INTVAL (operands[1]))\n-\t|| const_ok_for_arm (~INTVAL (operands[1]))))\n-   || register_operand (operands[1], HImode)\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,r\")\n+\t(match_operand:HI 1 \"general_operand\"  \"rI,K,m\"))]\n+  \"(! BYTES_BIG_ENDIAN)\n+   && (GET_CODE (operands[1]) != CONST_INT\n+       || const_ok_for_arm (INTVAL (operands[1]))\n+       || const_ok_for_arm (~INTVAL (operands[1])))\"\n   \"@\n    mov%?\\\\t%0, %1\\\\t%@ movhi\n    mvn%?\\\\t%0, #%B1\\\\t%@ movhi\n-   ldr%?\\\\t%0, %1\\\\t%@ movhi\n-   bogus code str%?\\\\t%1, %0\\\\t%@ movhi\"\n-[(set_attr \"type\" \"*,*,load,store1\")])\n+   ldr%?\\\\t%0, %1\\\\t%@ movhi\"\n+[(set_attr \"type\" \"*,*,load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"s_register_operand\" \"=r,r,r\")\n+\t(match_operand:HI 1 \"general_operand\"  \"rI,K,m\"))]\n+  \"BYTES_BIG_ENDIAN\n+   && (GET_CODE (operands[1]) != CONST_INT\n+       || const_ok_for_arm (INTVAL (operands[1]))\n+       || const_ok_for_arm (~INTVAL (operands[1])))\"\n+  \"@\n+   mov%?\\\\t%0, %1\\\\t%@ movhi\n+   mvn%?\\\\t%0, #%B1\\\\t%@ movhi\n+   ldr%?\\\\t%0, %1\\\\t%@ movhi_bigend\\;mov%?\\\\t%0, %0, asr #16\"\n+[(set_attr \"type\" \"*,*,load\")\n+ (set_attr \"length\" \"4,4,8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(rotate:SI (subreg:SI (match_operand:HI 1 \"memory_operand\" \"m\") 0)\n+\t\t   (const_int 16)))]\n+  \"BYTES_BIG_ENDIAN\"\n+  \"ldr%?\\\\t%0, %1\\\\t%@ movhi_bigend\"\n+[(set_attr \"type\" \"load\")])\n \n (define_expand \"reload_outhi\"\n   [(parallel [(match_operand:HI 0 \"reload_memory_operand\" \"=o\")\n@@ -2106,10 +2176,11 @@\n \n   if (!(reload_in_progress || reload_completed))\n     {\n-      rtx reg;\n       if (GET_CODE (operands[1]) == CONST_INT)\n \t{\n-\t  emit_insn (gen_movsi (reg = gen_reg_rtx (SImode), operands[1]));\n+\t  rtx reg = gen_reg_rtx (SImode);\n+\n+\t  emit_insn (gen_movsi (reg, operands[1]));\n \t  operands[1] = gen_rtx (SUBREG, QImode, reg, 0);\n \t}\n     }\n@@ -4335,7 +4406,7 @@\n   \"*\n {\n   rtx ldm[3];\n-  rtx arith[3];\n+  rtx arith[4];\n   int val1 = 0, val2 = 0;\n \n   if (REGNO (operands[0]) > REGNO (operands[4]))\n@@ -4353,6 +4424,7 @@\n   if (GET_CODE (XEXP (operands[3], 0)) != REG)\n     val2 = INTVAL (XEXP (XEXP (operands[3], 0), 1));\n   arith[0] = operands[0];\n+  arith[3] = operands[1];\n   if (val1 < val2)\n     {\n       arith[1] = ldm[1];\n@@ -4391,7 +4463,7 @@\n       else\n \toutput_asm_insn (\\\"ldm%?da\\\\t%0, {%1, %2}\\\", ldm);\n     }\n-  output_asm_insn (\\\"%I1%?\\\\t%0, %1, %2\\\", arith);\n+  output_asm_insn (\\\"%I3%?\\\\t%0, %1, %2\\\", arith);\n   return \\\"\\\";\n }\n \"\n@@ -4546,7 +4618,8 @@\n \t\t\t (match_operand:SI 2 \"index_operand\" \"rJ\"))))\n    (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"REGNO (operands[0]) != FRAME_POINTER_REGNUM\n+  \"(! BYTES_BIG_ENDIAN)\n+   && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && (GET_CODE (operands[2]) != REG\n        || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n@@ -4559,7 +4632,8 @@\n \t\t\t  (match_operand:SI 2 \"s_register_operand\" \"r\"))))\n    (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(minus:SI (match_dup 1) (match_dup 2)))]\n-  \"REGNO (operands[0]) != FRAME_POINTER_REGNUM\n+  \"(!BYTES_BIG_ENDIAN)\n+   && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && (GET_CODE (operands[2]) != REG\n        || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n@@ -4695,7 +4769,8 @@\n    (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(plus:SI (match_op_dup 2 [(match_dup 3)\t(match_dup 4)])\n \t\t (match_dup 1)))]\n-  \"REGNO (operands[0]) != FRAME_POINTER_REGNUM\n+  \"(! BYTES_BIG_ENDIAN)\n+   && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n   \"ldr%?\\\\t%5, [%0, %3, %S2]!\\\\t%@ loadhi\"\n@@ -4710,7 +4785,8 @@\n    (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(minus:SI (match_dup 1) (match_op_dup 2 [(match_dup 3)\n \t\t\t\t\t\t (match_dup 4)])))]\n-  \"REGNO (operands[0]) != FRAME_POINTER_REGNUM\n+  \"(! BYTES_BIG_ENDIAN)\n+   && REGNO (operands[0]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n   \"ldr%?\\\\t%5, [%0, -%3, %S2]!\\\\t%@ loadhi\"\n@@ -4730,7 +4806,7 @@\n    (set (match_dup 0)\n \t(plus:SI (match_dup 0) (match_operand:SI 1 \"index_operand\" \"rJ\")))]\n   \"\"\n-  \"strb\\\\t%2, [%0], %1\")\n+  \"str%?b\\\\t%2, [%0], %1\")\n \n (define_peephole\n   [(set (match_operand:QI 0 \"s_register_operand\" \"=r\")\n@@ -4755,7 +4831,8 @@\n \t(mem:HI (match_operand:SI 1 \"s_register_operand\" \"+r\")))\n    (set (match_dup 1)\n \t(plus:SI (match_dup 1) (match_operand:SI 2 \"index_operand\" \"rJ\")))]\n-  \"REGNO(operands[0]) != REGNO(operands[1])\n+  \"(! BYTES_BIG_ENDIAN)\n+   && REGNO(operands[0]) != REGNO(operands[1])\n    && (GET_CODE (operands[2]) != REG\n        || REGNO(operands[0]) != REGNO (operands[2]))\"\n   \"ldr%?\\\\t%0, [%1], %2\\\\t%@ loadhi\")\n@@ -4770,6 +4847,25 @@\n        || REGNO(operands[0]) != REGNO (operands[2]))\"\n   \"ldr%?\\\\t%0, [%1], %2\")\n \n+(define_peephole\n+  [(set (mem:QI (plus:SI (match_operand:SI 0 \"s_register_operand\" \"+r\")\n+\t\t\t (match_operand:SI 1 \"index_operand\" \"rJ\")))\n+\t(match_operand:QI 2 \"s_register_operand\" \"r\"))\n+   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 1)))]\n+  \"\"\n+  \"str%?b\\\\t%2, [%0, %1]!\")\n+\n+(define_peephole\n+  [(set (mem:QI (plus:SI (match_operator:SI 4 \"shift_operator\"\n+\t\t\t  [(match_operand:SI 0 \"s_register_operand\" \"r\")\n+\t\t\t   (match_operand 1 \"const_int_operand\" \"n\")])\n+\t\t\t (match_operand:SI 2 \"s_register_operand\" \"+r\")))\n+\t(match_operand:QI 3 \"s_register_operand\" \"r\"))\n+   (set (match_dup 2) (plus:SI (match_op_dup 4 [(match_dup 0) (match_dup 1)])\n+\t\t\t       (match_dup 2)))]\n+  \"\"\n+  \"str%?b\\\\t%3, [%2, %0, %S4]!\")\n+\n ; This pattern is never tried by combine, so do it as a peephole\n \n (define_peephole"}]}