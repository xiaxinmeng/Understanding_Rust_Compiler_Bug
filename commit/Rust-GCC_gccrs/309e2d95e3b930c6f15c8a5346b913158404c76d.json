{"sha": "309e2d95e3b930c6f15c8a5346b913158404c76d", "node_id": "C_kwDOANBUbNoAKDMwOWUyZDk1ZTNiOTMwYzZmMTVjOGE1MzQ2YjkxMzE1ODQwNGM3NmQ", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2022-11-15T03:40:12Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2022-11-25T18:13:22Z"}, "message": "OpenMP: Generate SIMD clones for functions with \"declare target\"\n\nThis patch causes the IPA simdclone pass to generate clones for\nfunctions with the \"omp declare target\" attribute as if they had\n\"omp declare simd\", provided the function appears to be suitable for\nSIMD execution.  The filter is conservative, rejecting functions\nthat write memory or that call other functions not known to be safe.\nA new option -fopenmp-target-simd-clone is added to control this\ntransformation; it's enabled for offload processing at -O2 and higher.\n\ngcc/ChangeLog:\n\n\t* common.opt (fopenmp-target-simd-clone): New option.\n\t(target_simd_clone_device): New enum to go with it.\n\t* doc/invoke.texi (-fopenmp-target-simd-clone): Document.\n\t* flag-types.h (enum omp_target_simd_clone_device_kind): New.\n\t* omp-simd-clone.cc (auto_simd_fail): New function.\n\t(auto_simd_check_stmt): New function.\n\t(plausible_type_for_simd_clone): New function.\n\t(ok_for_auto_simd_clone): New function.\n\t(simd_clone_create): Add force_local argument, make the symbol\n\thave internal linkage if it is true.\n\t(expand_simd_clones): Also check for cloneable functions with\n\t\"omp declare target\".  Pass explicit_p argument to\n\tsimd_clone.compute_vecsize_and_simdlen target hook.\n\t* opts.cc (default_options_table): Add -fopenmp-target-simd-clone.\n\t* target.def (TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN):\n\tAdd bool explicit_p argument.\n\t* doc/tm.texi: Regenerated.\n\t* config/aarch64/aarch64.cc\n\t(aarch64_simd_clone_compute_vecsize_and_simdlen): Update.\n\t* config/gcn/gcn.cc\n\t(gcn_simd_clone_compute_vecsize_and_simdlen): Update.\n\t* config/i386/i386.cc\n\t(ix86_simd_clone_compute_vecsize_and_simdlen): Update.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/gomp/target-simd-clone-1.C: New.\n\t* g++.dg/gomp/target-simd-clone-2.C: New.\n\t* gcc.dg/gomp/target-simd-clone-1.c: New.\n\t* gcc.dg/gomp/target-simd-clone-2.c: New.\n\t* gcc.dg/gomp/target-simd-clone-3.c: New.\n\t* gcc.dg/gomp/target-simd-clone-4.c: New.\n\t* gcc.dg/gomp/target-simd-clone-5.c: New.\n\t* gcc.dg/gomp/target-simd-clone-6.c: New.\n\t* gcc.dg/gomp/target-simd-clone-7.c: New.\n\t* gcc.dg/gomp/target-simd-clone-8.c: New.\n\t* lib/scanoffloadipa.exp: New.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/lib/libgomp.exp: Load scanoffloadipa.exp library.\n\t* testsuite/libgomp.c/target-simd-clone-1.c: New.\n\t* testsuite/libgomp.c/target-simd-clone-2.c: New.\n\t* testsuite/libgomp.c/target-simd-clone-3.c: New.", "tree": {"sha": "0f205d914d696e4f3c73d5fc08fcd05b5f85b3c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f205d914d696e4f3c73d5fc08fcd05b5f85b3c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/309e2d95e3b930c6f15c8a5346b913158404c76d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309e2d95e3b930c6f15c8a5346b913158404c76d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/309e2d95e3b930c6f15c8a5346b913158404c76d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309e2d95e3b930c6f15c8a5346b913158404c76d/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3de627ffe4b51b3d82acdb5fb04c189978697832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3de627ffe4b51b3d82acdb5fb04c189978697832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3de627ffe4b51b3d82acdb5fb04c189978697832"}], "stats": {"total": 939, "additions": 887, "deletions": 52}, "files": [{"sha": "c458b71680c773ad64c5bcbee3c375c3f988b8f6", "filename": "gcc/common.opt", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -2218,6 +2218,28 @@ fomit-frame-pointer\n Common Var(flag_omit_frame_pointer) Optimization\n When possible do not generate stack frames.\n \n+fopenmp-target-simd-clone\n+Common Alias(fopenmp-target-simd-clone=,any,none)\n+\n+fopenmp-target-simd-clone=\n+Common Joined RejectNegative Enum(target_simd_clone_device) Var(flag_openmp_target_simd_clone) Init(OMP_TARGET_SIMD_CLONE_NONE) Optimization\n+Generate SIMD clones for functions with the OpenMP declare target directive.\n+\n+Enum\n+Name(target_simd_clone_device) Type(int)\n+\n+EnumValue\n+Enum(target_simd_clone_device) String(none) Value(OMP_TARGET_SIMD_CLONE_NONE)\n+\n+EnumValue\n+Enum(target_simd_clone_device) String(host) Value(OMP_TARGET_SIMD_CLONE_HOST)\n+\n+EnumValue\n+Enum(target_simd_clone_device) String(nohost) Value(OMP_TARGET_SIMD_CLONE_NOHOST)\n+\n+EnumValue\n+Enum(target_simd_clone_device) String(any) Value(OMP_TARGET_SIMD_CLONE_ANY)\n+\n fopt-info\n Common Var(flag_opt_info) Optimization\n Enable all optimization info dumps on stderr."}, {"sha": "e97f3b32f7c7f43564d6a4207eae5a34b9e9bfe7", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -26867,7 +26867,8 @@ currently_supported_simd_type (tree t, tree b)\n static int\n aarch64_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n \t\t\t\t\tstruct cgraph_simd_clone *clonei,\n-\t\t\t\t\ttree base_type, int num)\n+\t\t\t\t\ttree base_type, int num,\n+\t\t\t\t\tbool explicit_p)\n {\n   tree t, ret_type;\n   unsigned int elt_bits, count;\n@@ -26885,16 +26886,19 @@ aarch64_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n \t  || const_simdlen > 1024\n \t  || (const_simdlen & (const_simdlen - 1)) != 0))\n     {\n-      warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n-\t\t  \"unsupported simdlen %wd\", const_simdlen);\n+      if (explicit_p)\n+\twarning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t    \"unsupported simdlen %wd\", const_simdlen);\n       return 0;\n     }\n \n   ret_type = TREE_TYPE (TREE_TYPE (node->decl));\n   if (TREE_CODE (ret_type) != VOID_TYPE\n       && !currently_supported_simd_type (ret_type, base_type))\n     {\n-      if (TYPE_SIZE (ret_type) != TYPE_SIZE (base_type))\n+      if (!explicit_p)\n+\t;\n+      else if (TYPE_SIZE (ret_type) != TYPE_SIZE (base_type))\n \twarning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n \t\t    \"GCC does not currently support mixed size types \"\n \t\t    \"for %<simd%> functions\");\n@@ -26921,7 +26925,9 @@ aarch64_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n       if (clonei->args[i].arg_type != SIMD_CLONE_ARG_TYPE_UNIFORM\n \t  && !currently_supported_simd_type (arg_type, base_type))\n \t{\n-\t  if (TYPE_SIZE (arg_type) != TYPE_SIZE (base_type))\n+\t  if (!explicit_p)\n+\t    ;\n+\t  else if (TYPE_SIZE (arg_type) != TYPE_SIZE (base_type))\n \t    warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n \t\t\t\"GCC does not currently support mixed size types \"\n \t\t\t\"for %<simd%> functions\");\n@@ -26951,9 +26957,11 @@ aarch64_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n       if (clonei->simdlen.is_constant (&const_simdlen)\n \t  && maybe_ne (vec_bits, 64U) && maybe_ne (vec_bits, 128U))\n \t{\n-\t  warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n-\t\t      \"GCC does not currently support simdlen %wd for type %qT\",\n-\t\t      const_simdlen, base_type);\n+\t  if (explicit_p)\n+\t    warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t\t\"GCC does not currently support simdlen %wd for \"\n+\t\t\t\"type %qT\",\n+\t\t\tconst_simdlen, base_type);\n \t  return 0;\n \t}\n     }"}, {"sha": "6fb261318c431d193cbceb737c60410e7b3add42", "filename": "gcc/config/gcn/gcn.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.cc?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -5143,17 +5143,19 @@ static int\n gcn_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *ARG_UNUSED (node),\n \t\t\t\t\t    struct cgraph_simd_clone *clonei,\n \t\t\t\t\t    tree ARG_UNUSED (base_type),\n-\t\t\t\t\t    int ARG_UNUSED (num))\n+\t\t\t\t\t    int ARG_UNUSED (num),\n+\t\t\t\t\t    bool explicit_p)\n {\n   if (known_eq (clonei->simdlen, 0U))\n     clonei->simdlen = 64;\n   else if (maybe_ne (clonei->simdlen, 64U))\n     {\n       /* Note that x86 has a similar message that is likely to trigger on\n \t sizes that are OK for gcn; the user can't win.  */\n-      warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n-\t\t  \"unsupported simdlen %wd (amdgcn)\",\n-\t\t  clonei->simdlen.to_constant ());\n+      if (explicit_p)\n+\twarning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t    \"unsupported simdlen %wd (amdgcn)\",\n+\t\t    clonei->simdlen.to_constant ());\n       return 0;\n     }\n "}, {"sha": "95babd93c9d21314e73268daf0c82a4d08e46e4c", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -23632,7 +23632,8 @@ ix86_memmodel_check (unsigned HOST_WIDE_INT val)\n static int\n ix86_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n \t\t\t\t\t     struct cgraph_simd_clone *clonei,\n-\t\t\t\t\t     tree base_type, int num)\n+\t\t\t\t\t     tree base_type, int num,\n+\t\t\t\t\t     bool explicit_p)\n {\n   int ret = 1;\n \n@@ -23641,8 +23642,9 @@ ix86_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n \t  || clonei->simdlen > 1024\n \t  || (clonei->simdlen & (clonei->simdlen - 1)) != 0))\n     {\n-      warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n-\t\t  \"unsupported simdlen %wd\", clonei->simdlen.to_constant ());\n+      if (explicit_p)\n+\twarning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t    \"unsupported simdlen %wd\", clonei->simdlen.to_constant ());\n       return 0;\n     }\n \n@@ -23662,8 +23664,9 @@ ix86_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n \t  break;\n \t/* FALLTHRU */\n       default:\n-\twarning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n-\t\t    \"unsupported return type %qT for simd\", ret_type);\n+\tif (explicit_p)\n+\t  warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t      \"unsupported return type %qT for simd\", ret_type);\n \treturn 0;\n       }\n \n@@ -23692,13 +23695,14 @@ ix86_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n \tdefault:\n \t  if (clonei->args[i].arg_type == SIMD_CLONE_ARG_TYPE_UNIFORM)\n \t    break;\n-\t  warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n-\t\t      \"unsupported argument type %qT for simd\", arg_type);\n+\t  if (explicit_p)\n+\t    warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t\t\"unsupported argument type %qT for simd\", arg_type);\n \t  return 0;\n \t}\n     }\n \n-  if (!TREE_PUBLIC (node->decl))\n+  if (!TREE_PUBLIC (node->decl) || !explicit_p)\n     {\n       /* If the function isn't exported, we can pick up just one ISA\n \t for the clones.  */\n@@ -23769,9 +23773,10 @@ ix86_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n \tcnt /= clonei->vecsize_float;\n       if (cnt > (TARGET_64BIT ? 16 : 8))\n \t{\n-\t  warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n-\t\t      \"unsupported simdlen %wd\",\n-\t\t      clonei->simdlen.to_constant ());\n+\t  if (explicit_p)\n+\t    warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t\t\"unsupported simdlen %wd\",\n+\t\t\tclonei->simdlen.to_constant ());\n \t  return 0;\n \t}\n       }"}, {"sha": "e312b5cef3d27e311ce0a1385d98b8f4cb9f690e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -204,7 +204,7 @@ in the following sections.\n -flax-vector-conversions  -fms-extensions @gol\n -foffload=@var{arg}  -foffload-options=@var{arg} @gol\n -fopenacc  -fopenacc-dim=@var{geom} @gol\n--fopenmp  -fopenmp-simd @gol\n+-fopenmp  -fopenmp-simd  -fopenmp-target-simd-clone@r{[}=@var{device-type}@r{]} @gol\n -fpermitted-flt-eval-methods=@var{standard} @gol\n -fplan9-extensions  -fsigned-bitfields  -funsigned-bitfields @gol\n -fsigned-char  -funsigned-char -fstrict-flex-arrays[=@var{n}] @gol\n@@ -2743,6 +2743,27 @@ Enable handling of OpenMP's @code{simd}, @code{declare simd},\n @code{[[omp::directive(...)]]} and @code{[[omp::sequence(...)]]} in C++\n and @code{!$omp} in Fortran.  Other OpenMP directives are ignored.\n \n+@item -fopenmp-target-simd-clone\n+@item -fopenmp-target-simd-clone=@var{device-type}\n+@opindex fopenmp-target-simd-clone\n+@cindex OpenMP target SIMD clone\n+In addition to generating SIMD clones for functions marked with the\n+@code{declare simd} directive, GCC also generates clones\n+for functions marked with the OpenMP @code{declare target} directive\n+that are suitable for vectorization when this option is in effect.  The\n+@var{device-type} may be one of @code{none}, @code{host}, @code{nohost},\n+and @code{any}, which correspond to keywords for the @code{device_type}\n+clause of the @code{declare target} directive; clones are generated for\n+the intersection of devices specified.\n+@option{-fopenmp-target-simd-clone} is equivalent to\n+@option{-fopenmp-target-simd-clone=any} and\n+@option{-fno-openmp-target-simd-clone} is equivalent to\n+@option{-fopenmp-target-simd-clone=none}.\n+\n+At @option{-O2} and higher (but not @option{-Os} or @option{-Og}) this\n+optimization defaults to @option{-fopenmp-target-simd-clone=nohost}; otherwise\n+it is disabled by default.\n+\n @item -fpermitted-flt-eval-methods=@var{style}\n @opindex fpermitted-flt-eval-methods\n @opindex fpermitted-flt-eval-methods=c11"}, {"sha": "8fe49c2ba3dbb4efd6143772082c4f8f5cc9728d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -6290,7 +6290,7 @@ The default is @code{NULL_TREE} which means to not vectorize scatter\n stores.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN (struct cgraph_node *@var{}, struct cgraph_simd_clone *@var{}, @var{tree}, @var{int})\n+@deftypefn {Target Hook} int TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN (struct cgraph_node *@var{}, struct cgraph_simd_clone *@var{}, @var{tree}, @var{int}, @var{bool})\n This hook should set @var{vecsize_mangle}, @var{vecsize_int}, @var{vecsize_float}\n fields in @var{simd_clone} structure pointed by @var{clone_info} argument and also\n @var{simdlen} field if it was previously 0."}, {"sha": "60dff0a38e94ec73c7955886a73ee9579e98f06f", "filename": "gcc/flag-types.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -494,6 +494,15 @@ enum openacc_privatization\n   OPENACC_PRIVATIZATION_NOISY\n };\n \n+/* Targets for -fopenmp-target-simd-clone.  */\n+enum omp_target_simd_clone_device_kind\n+{\n+  OMP_TARGET_SIMD_CLONE_NONE = 0,\n+  OMP_TARGET_SIMD_CLONE_HOST = 1,\n+  OMP_TARGET_SIMD_CLONE_NOHOST = 2,\n+  OMP_TARGET_SIMD_CLONE_ANY = 3\n+};\n+\n #endif\n \n #endif /* ! GCC_FLAG_TYPES_H */"}, {"sha": "21d69aa874702600e0f92ad53528a7277840df4a", "filename": "gcc/omp-simd-clone.cc", "status": "modified", "additions": 283, "deletions": 26, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fomp-simd-clone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fomp-simd-clone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.cc?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -51,6 +51,210 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"omp-simd-clone.h\"\n+#include \"omp-low.h\"\n+#include \"omp-general.h\"\n+\n+/* Print debug info for ok_for_auto_simd_clone to the dump file, logging\n+   failure reason EXCUSE for function DECL.  Always returns false.  */\n+static bool\n+auto_simd_fail (tree decl, const char *excuse)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\nNot auto-cloning %s because %s\\n\",\n+\t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n+\t     excuse);\n+  return false;\n+}\n+\n+/* Helper function for ok_for_auto_simd_clone; return false if the statement\n+   violates restrictions for an \"omp declare simd\" function.  Specifically,\n+   the function must not\n+   - throw or call setjmp/longjmp\n+   - write memory that could alias parallel calls\n+   - read volatile memory\n+   - include openmp directives or calls\n+   - call functions that might do those things */\n+\n+static bool\n+auto_simd_check_stmt (gimple *stmt, tree outer)\n+{\n+  tree decl;\n+\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_CALL:\n+\n+      /* Calls to functions that are CONST or PURE are ok, even if they\n+\t are internal functions without a decl.  Reject other internal\n+\t functions.  */\n+      if (gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE))\n+\tbreak;\n+      if (gimple_call_internal_p (stmt))\n+\treturn auto_simd_fail (outer,\n+\t\t\t       \"body contains internal function call\");\n+\n+      decl = gimple_call_fndecl (stmt);\n+\n+      /* We can't know whether indirect calls are safe.  */\n+      if (decl == NULL_TREE)\n+\treturn auto_simd_fail (outer, \"body contains indirect call\");\n+\n+      /* Calls to functions that are already marked \"omp declare simd\" are\n+\t OK.  */\n+      if (lookup_attribute (\"omp declare simd\", DECL_ATTRIBUTES (decl)))\n+\tbreak;\n+\n+      /* Let recursive calls to the current function through.  */\n+      if (decl == outer)\n+\tbreak;\n+\n+      /* Other function calls are not permitted.  This covers all calls to\n+\t the libgomp API and setjmp/longjmp, too, as well as things like\n+\t __cxa_throw_ related to exception handling.  */\n+      return auto_simd_fail (outer, \"body contains unsafe function call\");\n+\n+      /* Reject EH-related constructs.  Most of the EH gimple codes are\n+\talready lowered by the time this pass runs during IPA.\n+\t GIMPLE_EH_DISPATCH and GIMPLE_RESX remain and are lowered by\n+\t pass_lower_eh_dispatch and pass_lower_resx, respectively; those\n+\t passes run later.  */\n+    case GIMPLE_EH_DISPATCH:\n+    case GIMPLE_RESX:\n+      return auto_simd_fail (outer, \"body contains EH constructs\");\n+\n+      /* Asms are not permitted since we don't know what they do.  */\n+    case GIMPLE_ASM:\n+      return auto_simd_fail (outer, \"body contains inline asm\");\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Memory writes are not permitted.\n+     FIXME: this could be relaxed a little to permit writes to\n+     function-local variables that could not alias other instances\n+     of the function running in parallel.  */\n+  if (gimple_store_p (stmt))\n+    return auto_simd_fail (outer, \"body includes memory write\");\n+\n+  /* Volatile reads are not permitted.  */\n+  if (gimple_has_volatile_ops (stmt))\n+    return auto_simd_fail (outer, \"body includes volatile op\");\n+\n+  /* Otherwise OK.  */\n+  return true;\n+}\n+\n+/* Helper function for ok_for_auto_simd_clone:  return true if type T is\n+   plausible for a cloneable function argument or return type.  */\n+static bool\n+plausible_type_for_simd_clone (tree t)\n+{\n+  if (TREE_CODE (t) == VOID_TYPE)\n+    return true;\n+  else if (RECORD_OR_UNION_TYPE_P (t) || !is_a <scalar_mode> (TYPE_MODE (t)))\n+    /* Small record/union types may fit into a scalar mode, but are\n+       still not suitable.  */\n+    return false;\n+  else if (TYPE_ATOMIC (t))\n+    /* Atomic types trigger warnings in simd_clone_clauses_extract.  */\n+    return false;\n+  else\n+    return true;\n+}\n+\n+/* Check if the function NODE appears suitable for auto-annotation\n+   with \"declare simd\".  */\n+\n+static bool\n+ok_for_auto_simd_clone (struct cgraph_node *node)\n+{\n+  tree decl = node->decl;\n+  tree t;\n+  basic_block bb;\n+\n+  /* Nothing to do if the function isn't a definition or doesn't\n+     have a body.  */\n+  if (!node->definition || !node->has_gimple_body_p ())\n+    return auto_simd_fail (decl, \"no definition or body\");\n+\n+  /* No point in trying to generate implicit clones if the function\n+     isn't used in the compilation unit.  */\n+  if (!node->callers)\n+    return auto_simd_fail (decl, \"function is not used\");\n+\n+  /* Nothing to do if the function already has the \"omp declare simd\"\n+     attribute, is marked noclone, or is not \"omp declare target\".  */\n+  if (lookup_attribute (\"omp declare simd\", DECL_ATTRIBUTES (decl))\n+      || lookup_attribute (\"noclone\", DECL_ATTRIBUTES (decl))\n+      || !lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (decl)))\n+    return auto_simd_fail (decl, \"incompatible attributes\");\n+\n+  /* Check whether the function is restricted host/nohost via the\n+     \"omp declare target device_type\" clause, and that doesn't match\n+     what we're compiling for.  Internally, these translate into\n+     \"omp declare target [no]host\" attributes on the decl; \"any\"\n+     translates into both attributes, but the default (which is supposed\n+     to be equivalent to \"any\") is neither.  */\n+  tree host = lookup_attribute (\"omp declare target host\",\n+\t\t\t\tDECL_ATTRIBUTES (decl));\n+  tree nohost = lookup_attribute (\"omp declare target nohost\",\n+\t\t\t\t  DECL_ATTRIBUTES (decl));\n+#ifdef ACCEL_COMPILER\n+  if (host && !nohost)\n+    return auto_simd_fail (decl, \"device doesn't match for accel compiler\");\n+#else\n+  if (nohost && !host)\n+    return auto_simd_fail (decl, \"device doesn't match for host compiler\");\n+#endif\n+\n+  /* Backends will check for vectorizable arguments/return types in a\n+     target-specific way, but we can immediately filter out functions\n+     that have implausible argument/return types.  */\n+  t = TREE_TYPE (TREE_TYPE (decl));\n+  if (!plausible_type_for_simd_clone (t))\n+    return auto_simd_fail (decl, \"return type fails sniff test\");\n+\n+  if (TYPE_ARG_TYPES (TREE_TYPE (decl)))\n+    {\n+      for (tree temp = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+\t   temp; temp = TREE_CHAIN (temp))\n+\t{\n+\t  t = TREE_VALUE (temp);\n+\t  if (!plausible_type_for_simd_clone (t))\n+\t    return auto_simd_fail (decl, \"argument type fails sniff test\");\n+\t}\n+    }\n+  else if (DECL_ARGUMENTS (decl))\n+    {\n+      for (tree temp = DECL_ARGUMENTS (decl); temp; temp = DECL_CHAIN (temp))\n+\t{\n+\t  t = TREE_TYPE (temp);\n+\t  if (!plausible_type_for_simd_clone (t))\n+\t    return auto_simd_fail (decl, \"argument type fails sniff test\");\n+\t}\n+    }\n+  else\n+    return auto_simd_fail (decl, \"function has no arguments\");\n+\n+  /* Scan the function body to see if it is suitable for SIMD-ization.  */\n+  node->get_body ();\n+\n+  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (decl))\n+    {\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\tif (!auto_simd_check_stmt (gsi_stmt (gsi), decl))\n+\t  return false;\n+    }\n+\n+  /* All is good.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nMarking %s for auto-cloning\\n\",\n+\t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n+  return true;\n+}\n+\n \n /* Return the number of elements in vector type VECTYPE, which is associated\n    with a SIMD clone.  At present these always have a constant length.  */\n@@ -430,10 +634,12 @@ simd_clone_mangle (struct cgraph_node *node,\n   return get_identifier (str);\n }\n \n-/* Create a simd clone of OLD_NODE and return it.  */\n+/* Create a simd clone of OLD_NODE and return it.  If FORCE_LOCAL is true,\n+   create it as a local symbol, otherwise copy the symbol linkage and\n+   visibility attributes from OLD_NODE.  */\n \n static struct cgraph_node *\n-simd_clone_create (struct cgraph_node *old_node)\n+simd_clone_create (struct cgraph_node *old_node, bool force_local)\n {\n   struct cgraph_node *new_node;\n   if (old_node->definition)\n@@ -463,23 +669,38 @@ simd_clone_create (struct cgraph_node *old_node)\n     return new_node;\n \n   set_decl_built_in_function (new_node->decl, NOT_BUILT_IN, 0);\n-  TREE_PUBLIC (new_node->decl) = TREE_PUBLIC (old_node->decl);\n-  DECL_COMDAT (new_node->decl) = DECL_COMDAT (old_node->decl);\n-  DECL_WEAK (new_node->decl) = DECL_WEAK (old_node->decl);\n-  DECL_EXTERNAL (new_node->decl) = DECL_EXTERNAL (old_node->decl);\n-  DECL_VISIBILITY_SPECIFIED (new_node->decl)\n-    = DECL_VISIBILITY_SPECIFIED (old_node->decl);\n-  DECL_VISIBILITY (new_node->decl) = DECL_VISIBILITY (old_node->decl);\n-  DECL_DLLIMPORT_P (new_node->decl) = DECL_DLLIMPORT_P (old_node->decl);\n-  if (DECL_ONE_ONLY (old_node->decl))\n-    make_decl_one_only (new_node->decl, DECL_ASSEMBLER_NAME (new_node->decl));\n-\n-  /* The method cgraph_version_clone_with_body () will force the new\n-     symbol local.  Undo this, and inherit external visibility from\n-     the old node.  */\n-  new_node->local = old_node->local;\n-  new_node->externally_visible = old_node->externally_visible;\n-  new_node->calls_declare_variant_alt = old_node->calls_declare_variant_alt;\n+  if (force_local)\n+    {\n+      TREE_PUBLIC (new_node->decl) = 0;\n+      DECL_COMDAT (new_node->decl) = 0;\n+      DECL_WEAK (new_node->decl) = 0;\n+      DECL_EXTERNAL (new_node->decl) = 0;\n+      DECL_VISIBILITY_SPECIFIED (new_node->decl) = 0;\n+      DECL_VISIBILITY (new_node->decl) = VISIBILITY_DEFAULT;\n+      DECL_DLLIMPORT_P (new_node->decl) = 0;\n+    }\n+  else\n+    {\n+      TREE_PUBLIC (new_node->decl) = TREE_PUBLIC (old_node->decl);\n+      DECL_COMDAT (new_node->decl) = DECL_COMDAT (old_node->decl);\n+      DECL_WEAK (new_node->decl) = DECL_WEAK (old_node->decl);\n+      DECL_EXTERNAL (new_node->decl) = DECL_EXTERNAL (old_node->decl);\n+      DECL_VISIBILITY_SPECIFIED (new_node->decl)\n+\t= DECL_VISIBILITY_SPECIFIED (old_node->decl);\n+      DECL_VISIBILITY (new_node->decl) = DECL_VISIBILITY (old_node->decl);\n+      DECL_DLLIMPORT_P (new_node->decl) = DECL_DLLIMPORT_P (old_node->decl);\n+      if (DECL_ONE_ONLY (old_node->decl))\n+\tmake_decl_one_only (new_node->decl,\n+\t\t\t    DECL_ASSEMBLER_NAME (new_node->decl));\n+\n+      /* The method cgraph_version_clone_with_body () will force the new\n+\t symbol local.  Undo this, and inherit external visibility from\n+\t the old node.  */\n+      new_node->local = old_node->local;\n+      new_node->externally_visible = old_node->externally_visible;\n+      new_node->calls_declare_variant_alt\n+\t= old_node->calls_declare_variant_alt;\n+    }\n \n   return new_node;\n }\n@@ -1683,13 +1904,42 @@ simd_clone_adjust (struct cgraph_node *node)\n void\n expand_simd_clones (struct cgraph_node *node)\n {\n-  tree attr = lookup_attribute (\"omp declare simd\",\n-\t\t\t\tDECL_ATTRIBUTES (node->decl));\n-  if (attr == NULL_TREE\n-      || node->inlined_to\n+  tree attr;\n+  bool explicit_p = true;\n+\n+  if (node->inlined_to\n       || lookup_attribute (\"noclone\", DECL_ATTRIBUTES (node->decl)))\n     return;\n \n+  attr = lookup_attribute (\"omp declare simd\",\n+\t\t\t   DECL_ATTRIBUTES (node->decl));\n+\n+  /* See if we can add an \"omp declare simd\" directive implicitly\n+     before giving up.  */\n+  /* FIXME: OpenACC \"#pragma acc routine\" translates into\n+     \"omp declare target\", but appears also to have some other effects\n+     that conflict with generating SIMD clones, causing ICEs.  So don't\n+     do this if we've got OpenACC instead of OpenMP.  */\n+  if (attr == NULL_TREE\n+#ifdef ACCEL_COMPILER\n+      && (flag_openmp_target_simd_clone == OMP_TARGET_SIMD_CLONE_ANY\n+\t  || flag_openmp_target_simd_clone == OMP_TARGET_SIMD_CLONE_NOHOST)\n+#else\n+      && (flag_openmp_target_simd_clone == OMP_TARGET_SIMD_CLONE_ANY\n+\t  || flag_openmp_target_simd_clone == OMP_TARGET_SIMD_CLONE_HOST)\n+#endif\n+      && !oacc_get_fn_attrib (node->decl)\n+      && ok_for_auto_simd_clone (node))\n+    {\n+      attr = tree_cons (get_identifier (\"omp declare simd\"), NULL,\n+\t\t\tDECL_ATTRIBUTES (node->decl));\n+      DECL_ATTRIBUTES (node->decl) = attr;\n+      explicit_p = false;\n+    }\n+\n+  if (attr == NULL_TREE)\n+    return;\n+\n   /* Ignore\n      #pragma omp declare simd\n      extern int foo ();\n@@ -1714,13 +1964,15 @@ expand_simd_clones (struct cgraph_node *node)\n \n       poly_uint64 orig_simdlen = clone_info->simdlen;\n       tree base_type = simd_clone_compute_base_data_type (node, clone_info);\n+\n       /* The target can return 0 (no simd clones should be created),\n \t 1 (just one ISA of simd clones should be created) or higher\n \t count of ISA variants.  In that case, clone_info is initialized\n \t for the first ISA variant.  */\n       int count\n \t= targetm.simd_clone.compute_vecsize_and_simdlen (node, clone_info,\n-\t\t\t\t\t\t\t  base_type, 0);\n+\t\t\t\t\t\t\t  base_type, 0,\n+\t\t\t\t\t\t\t  explicit_p);\n       if (count == 0)\n \tcontinue;\n \n@@ -1745,7 +1997,8 @@ expand_simd_clones (struct cgraph_node *node)\n \t      /* And call the target hook again to get the right ISA.  */\n \t      targetm.simd_clone.compute_vecsize_and_simdlen (node, clone,\n \t\t\t\t\t\t\t      base_type,\n-\t\t\t\t\t\t\t      i / 2);\n+\t\t\t\t\t\t\t      i / 2,\n+\t\t\t\t\t\t\t      explicit_p);\n \t      if ((i & 1) != 0)\n \t\tclone->inbranch = 1;\n \t    }\n@@ -1763,7 +2016,7 @@ expand_simd_clones (struct cgraph_node *node)\n \t  /* Only when we are sure we want to create the clone actually\n \t     clone the function (or definitions) or create another\n \t     extern FUNCTION_DECL (for prototypes without definitions).  */\n-\t  struct cgraph_node *n = simd_clone_create (node);\n+\t  struct cgraph_node *n = simd_clone_create (node, !explicit_p);\n \t  if (n == NULL)\n \t    {\n \t      if (i == 0)\n@@ -1798,6 +2051,10 @@ expand_simd_clones (struct cgraph_node *node)\n \t      simd_clone_adjust_return_type (n);\n \t      simd_clone_adjust_argument_types (n);\n \t    }\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"\\nGenerated %s clone %s\\n\",\n+\t\t     (TREE_PUBLIC (n->decl) ? \"global\" : \"local\"),\n+\t\t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (n->decl)));\n \t}\n     }\n   while ((attr = lookup_attribute (\"omp declare simd\", TREE_CHAIN (attr))));"}, {"sha": "73fc97756e4935be2a18212e3e182be166f118e7", "filename": "gcc/opts.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fopts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Fopts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.cc?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -658,6 +658,8 @@ static const struct default_options default_options_table[] =\n       REORDER_BLOCKS_ALGORITHM_STC },\n     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_ftree_loop_vectorize, NULL, 1 },\n     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_ftree_slp_vectorize, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_fopenmp_target_simd_clone_, NULL,\n+      OMP_TARGET_SIMD_CLONE_NOHOST },\n #ifdef INSN_SCHEDULING\n   /* Only run the pre-regalloc scheduling pass if optimizing for speed.  */\n     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_fschedule_insns, NULL, 1 },"}, {"sha": "082a7c62f34d7e73abb046bf949f4b8cc1ed3cf6", "filename": "gcc/target.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -1634,7 +1634,7 @@ fields in @var{simd_clone} structure pointed by @var{clone_info} argument and al\n not determined by the bitsize (in which case @var{simdlen} is always used).\\n\\\n The hook should return 0 if SIMD clones shouldn't be emitted,\\n\\\n or number of @var{vecsize_mangle} variants that should be emitted.\",\n-int, (struct cgraph_node *, struct cgraph_simd_clone *, tree, int), NULL)\n+int, (struct cgraph_node *, struct cgraph_simd_clone *, tree, int, bool), NULL)\n \n DEFHOOK\n (adjust,"}, {"sha": "10b5ac38812a05bb60a14f319f2e435754c61ec6", "filename": "gcc/testsuite/g++.dg/gomp/target-simd-clone-1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-simd-clone-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-simd-clone-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-simd-clone-1.C?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-fopenmp -O2\" } */\n+/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details\" } */\n+\n+/* Test that simd clones are generated for functions with \"declare target\".  */\n+\n+#pragma omp declare target\n+__attribute__ ((__noinline__)) int addit (int a, int b)\n+{\n+  return a + b;\n+}\n+#pragma omp end declare target\n+\n+void callit (int *a, int *b, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (a[i], b[i]);\n+}\n+\n+/* Although addit has external linkage, we expect clones to be generated as\n+   for a function with internal linkage.  */\n+\n+/* { dg-final { scan-ipa-dump \"Generated local clone _ZGV.*N.*__Z5additii\" \"simdclone\" { target x86_64-*-* } } } */\n+/* { dg-final { scan-ipa-dump \"Generated local clone _ZGV.*M.*__Z5additii\" \"simdclone\" { target x86_64-*-* } } } */"}, {"sha": "08c0539dc638e5b507a79c512df1ec520e5d3a03", "filename": "gcc/testsuite/g++.dg/gomp/target-simd-clone-2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-simd-clone-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-simd-clone-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-simd-clone-2.C?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-options \"-fopenmp -O2\" } */\n+/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details\" } */\n+\n+/* Test that simd clones are not generated for \"declare target\"\n+   functions that throw.  */\n+\n+#pragma omp declare target\n+__attribute__ ((__noinline__)) int addit (int a, int b)\n+{\n+  if (a < 0) throw -1;\n+  return a + b;\n+}\n+#pragma omp end declare target\n+\n+void callit (int *a, int *b, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (a[i], b[i]);\n+}\n+\n+/* { dg-final { scan-ipa-dump-not \"Generated .* clone\" \"simdclone\" { target x86_64-*-* } } } */"}, {"sha": "388dc2a956cafdb7b36734b9a3f5619c4866e7c2", "filename": "gcc/testsuite/gcc.dg/gomp/target-simd-clone-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-1.c?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-fopenmp -O2\" } */\n+/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details\" } */\n+\n+/* Test that simd clones are generated for functions with \"declare target\".  */\n+\n+#pragma omp declare target\n+__attribute__ ((__noinline__)) int addit (int a, int b)\n+{\n+  return a + b;\n+}\n+#pragma omp end declare target\n+\n+void callit (int *a, int *b, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (a[i], b[i]);\n+}\n+\n+/* Although addit has external linkage, we expect clones to be generated as\n+   for a function with internal linkage.  */\n+\n+/* { dg-final { scan-ipa-dump \"Generated local clone _ZGV.*N.*_addit\" \"simdclone\" { target x86_64-*-* } } } */\n+/* { dg-final { scan-ipa-dump \"Generated local clone _ZGV.*M.*_addit\" \"simdclone\" { target x86_64-*-* } } } */"}, {"sha": "acdc241db46cee87a981243b93959e456ef068b5", "filename": "gcc/testsuite/gcc.dg/gomp/target-simd-clone-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-2.c?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-options \"-fopenmp -O2\" } */\n+/* { dg-additional-options \"-fdump-ipa-simdclone-details\" } */\n+\n+/* Test that host simd clones are not generated for functions with \n+   \"declare target\" by default at -O2.  */\n+\n+#pragma omp declare target\n+__attribute__ ((__noinline__)) int addit (int a, int b)\n+{\n+  return a + b;\n+}\n+#pragma omp end declare target\n+\n+void callit (int *a, int *b, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (a[i], b[i]);\n+}\n+\n+/* { dg-final { scan-ipa-dump-not \"Generated .* clone\" \"simdclone\" { target x86_64-*-* } } } */"}, {"sha": "e90d49ce7f2c90eea39b9ca1ff5ea3f63d907c0e", "filename": "gcc/testsuite/gcc.dg/gomp/target-simd-clone-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-3.c?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-options \"-fopenmp -O2\" } */\n+/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details\" } */\n+\n+/* Test that host simd clones are not generated for functions with the nohost\n+   \"declare target\" clause.  */\n+\n+__attribute__ ((__noinline__)) int addit (int a, int b)\n+{\n+  return a + b;\n+}\n+#pragma omp declare target to(addit) device_type(nohost)\n+\n+void callit (int *a, int *b, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (a[i], b[i]);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"device doesn't match\" \"simdclone\" { target x86_64-*-* } } } */\n+/* { dg-final { scan-ipa-dump-not \"Generated .* clone\" \"simdclone\" { target x86_64-*-* } } } */"}, {"sha": "141097bdce8fd3c1dce0e1e6fb2363d964bf78a1", "filename": "gcc/testsuite/gcc.dg/gomp/target-simd-clone-4.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-4.c?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-options \"-fopenmp -O2\" } */\n+/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details\" } */\n+\n+/* Test that simd clones are not generated for functions with \n+   \"declare target\" but that write memory in the body.  */\n+\n+extern int save;\n+\n+#pragma omp declare target\n+__attribute__ ((__noinline__)) int addit(int a, int b)\n+{\n+  save = a;\n+  return a + b;\n+}\n+#pragma omp end declare target\n+\n+void callit (int *a, int *b, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (a[i], b[i]);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"body includes memory write\" \"simdclone\" { target x86_64-*-* } } } */\n+/* { dg-final { scan-ipa-dump-not \"Generated .* clone\" \"simdclone\" { target x86_64-*-* } } } */"}, {"sha": "93f9774f83190f7a1f234cc38d2f5aa487195be6", "filename": "gcc/testsuite/gcc.dg/gomp/target-simd-clone-5.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-5.c?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-options \"-fopenmp -O2\" } */\n+/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details\" } */\n+\n+/* Test that simd clones are not generated for functions with \n+   \"declare target\" but unsuitable arguments.  */\n+\n+struct s {\n+  int a;\n+  int b;\n+};\n+  \n+#pragma omp declare target\n+__attribute__ ((__noinline__)) int addit (struct s x)\n+{\n+  return x.a + x.b;\n+}\n+#pragma omp end declare target\n+\n+void callit (struct s *ss, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (ss[i]);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"argument type fails sniff test\" \"simdclone\" { target x86_64-*-* } } } */\n+/* { dg-final { scan-ipa-dump-not \"Generated .* clone\" \"simdclone\" { target x86_64-*-* } } } */"}, {"sha": "4c34967af95f083902f060612a2b4c07a34344d5", "filename": "gcc/testsuite/gcc.dg/gomp/target-simd-clone-6.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-6.c?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-options \"-fopenmp -O2\" } */\n+/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details\" } */\n+\n+/* Test that simd clones are not generated for functions with \n+   \"declare target\" but that call possibly side-effecting functions \n+   in the body.  */\n+\n+extern int f (int);\n+\n+#pragma omp declare target\n+__attribute__ ((__noinline__)) int addit(int a, int b)\n+{\n+  return f(a) + b;\n+}\n+#pragma omp end declare target\n+\n+void callit (int *a, int *b, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (a[i], b[i]);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"body contains unsafe function call\" \"simdclone\" { target x86_64-*-* } } } */\n+/* { dg-final { scan-ipa-dump-not \"Generated .* clone\" \"simdclone\" { target x86_64-*-* } } } */\n+"}, {"sha": "78c60f9f6bcd34dee9d714452a8c056f96e8bf20", "filename": "gcc/testsuite/gcc.dg/gomp/target-simd-clone-7.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-7.c?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-fopenmp -O2\" } */\n+/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details\" } */\n+\n+/* Test that simd clones are not generated for functions with \n+   \"declare target\" that have no callers in the same compilation unit.  */\n+\n+#pragma omp declare target\n+__attribute__ ((__noinline__)) int addit (int a, int b)\n+{\n+  return a + b;\n+}\n+#pragma omp end declare target\n+\n+/* { dg-final { scan-ipa-dump \"function is not used\" \"simdclone\" { target x86_64-*-* } } } */\n+/* { dg-final { scan-ipa-dump-not \"Generated .* clone\" \"simdclone\" { target x86_64-*-* } } } */"}, {"sha": "561766cb128d37094738f1c8c5eb140e7e13cc99", "filename": "gcc/testsuite/gcc.dg/gomp/target-simd-clone-8.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-8.c?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-fopenmp -O2\" } */\n+/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details\" } */\n+\n+/* Test that simd clones are not generated for functions with \n+   \"declare target\" but that read volatile memory in the body.  */\n+\n+extern volatile int save;\n+\n+#pragma omp declare target\n+__attribute__ ((__noinline__)) int addit(int a, int b)\n+{\n+  return save + a + b;\n+}\n+#pragma omp end declare target\n+\n+void callit (int *a, int *b, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (a[i], b[i]);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"body includes volatile op\" \"simdclone\" { target x86_64-*-* } } } */\n+/* { dg-final { scan-ipa-dump-not \"Generated .* clone\" \"simdclone\" { target x86_64-*-* } } } */"}, {"sha": "615cbf46ef8fd702a697b39c49095ed5dcdb624d", "filename": "gcc/testsuite/lib/scanoffloadipa.exp", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Flib%2Fscanoffloadipa.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/gcc%2Ftestsuite%2Flib%2Fscanoffloadipa.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fscanoffloadipa.exp?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,148 @@\n+#   Copyright (C) 2018-2022 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Various utilities for scanning offloading ipa dump output, used by\n+# libgomp.exp.\n+\n+load_lib scandump.exp\n+load_lib scanoffload.exp\n+\n+# Utility for scanning compiler result, invoked via dg-final.\n+# Call pass if pattern is present, otherwise fail.\n+#\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped ipa pass\n+# Argument 2 handles expected failures and the like\n+proc scan-offload-ipa-dump { args } {\n+\n+    if { [llength $args] < 2 } {\n+\terror \"scan-offload-ipa-dump: too few arguments\"\n+\treturn\n+    }\n+    if { [llength $args] > 3 } {\n+\terror \"scan-offload-ipa-dump: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 3 } {\n+\tscoff end-1 scan-dump \"offload-ipa\" [lindex $args 0] \\\n+\t    \"\\[0-9\\]\\[0-9\\]\\[0-9]i.[lindex $args 1]\" \"\" \\\n+\t    [lindex $args 2]\n+    } else {\n+\tscoff end scan-dump \"offload-ipa\" [lindex $args 0] \\\n+\t    \"\\[0-9\\]\\[0-9\\]\\[0-9]i.[lindex $args 1]\" \"\"\n+    }\n+}\n+\n+# Call pass if pattern is present given number of times, otherwise fail.\n+# Argument 0 is the regexp to match\n+# Argument 1 is number of times the regexp must be found\n+# Argument 2 is the name of the dumped ipa pass\n+# Argument 3 handles expected failures and the like\n+proc scan-offload-ipa-dump-times { args } {\n+\n+    if { [llength $args] < 3 } {\n+\terror \"scan-offload-ipa-dump-times: too few arguments\"\n+\treturn\n+    }\n+    if { [llength $args] > 4 } {\n+\terror \"scan-offload-ipa-dump-times: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 4 } {\n+\tscoff end-1 scan-dump-times \"offload-ipa\" [lindex $args 0] \\\n+\t    [lindex $args 1] \"\\[0-9\\]\\[0-9\\]\\[0-9]i.[lindex $args 2]\" \"\" \\\n+\t    [lindex $args 3]\n+    } else {\n+\tscoff end scan-dump-times \"offload-ipa\" [lindex $args 0] \\\n+\t    [lindex $args 1] \"\\[0-9\\]\\[0-9\\]\\[0-9]i.[lindex $args 2]\" \"\"\n+    }\n+}\n+\n+# Call pass if pattern is not present, otherwise fail.\n+#\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped ipa pass\n+# Argument 2 handles expected failures and the like\n+proc scan-offload-ipa-dump-not { args } {\n+\n+    if { [llength $args] < 2 } {\n+\terror \"scan-offload-ipa-dump-not: too few arguments\"\n+\treturn\n+    }\n+    if { [llength $args] > 3 } {\n+\terror \"scan-offload-ipa-dump-not: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 3 } {\n+\tscoff end-1 scan-dump-not \"offload-ipa\" [lindex $args 0] \\\n+\t    \"\\[0-9\\]\\[0-9\\]\\[0-9]i.[lindex $args 1]\" \"\" \\\n+\t    [lindex $args 2]\n+    } else {\n+\tscoff end scan-dump-not \"offload-ipa\" [lindex $args 0] \\\n+\t    \"\\[0-9\\]\\[0-9\\]\\[0-9]i.[lindex $args 1]\" \"\"\n+    }\n+}\n+\n+# Utility for scanning demangled compiler result, invoked via dg-final.\n+# Call pass if pattern is present, otherwise fail.\n+#\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped ipa pass\n+# Argument 2 handles expected failures and the like\n+proc scan-offload-ipa-dump-dem { args } {\n+\n+    if { [llength $args] < 2 } {\n+\terror \"scan-offload-ipa-dump-dem: too few arguments\"\n+\treturn\n+    }\n+    if { [llength $args] > 3 } {\n+\terror \"scan-offload-ipa-dump-dem: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 3 } {\n+\tscoff end-1 scan-dump-dem \"offload-ipa\" [lindex $args 0] \\\n+\t    \"\\[0-9\\]\\[0-9\\]\\[0-9]i.[lindex $args 1]\" \"\" \\\n+\t    [lindex $args 2]\n+    } else {\n+\tscoff end scan-dump-dem \"offload-ipa\" [lindex $args 0] \\\n+\t    \"\\[0-9\\]\\[0-9\\]\\[0-9]i.[lindex $args 1]\" \"\"\n+    }\n+}\n+\n+# Call pass if demangled pattern is not present, otherwise fail.\n+#\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped ipa pass\n+# Argument 2 handles expected failures and the like\n+proc scan-offload-ipa-dump-dem-not { args } {\n+\n+    if { [llength $args] < 2 } {\n+\terror \"scan-offload-ipa-dump-dem-not: too few arguments\"\n+\treturn\n+    }\n+    if { [llength $args] > 3 } {\n+\terror \"scan-offload-ipa-dump-dem-not: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 3 } {\n+\tscoff end-1 scan-dump-dem-not \"offload-ipa\" [lindex $args 0] \\\n+\t    \"\\[0-9\\]\\[0-9\\]\\[0-9]i.[lindex $args 1]\" \"\" \\\n+\t    [lindex $args 2]\n+    } else {\n+\tscoff end scan-dump-dem-not \"offload-ipa\" [lindex $args 0] \\\n+\t    \"\\[0-9\\]\\[0-9\\]\\[0-9]i.[lindex $args 1]\" \"\"\n+    }\n+}"}, {"sha": "e12236e9083c6c1945269b75b38b44109fde1e0b", "filename": "libgomp/testsuite/lib/libgomp.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -32,6 +32,7 @@ load_gcc_lib scansarif.exp\n load_gcc_lib scantree.exp\n load_gcc_lib scanltranstree.exp\n load_gcc_lib scanoffload.exp\n+load_gcc_lib scanoffloadipa.exp\n load_gcc_lib scanoffloadtree.exp\n load_gcc_lib scanoffloadrtl.exp\n load_gcc_lib scanipa.exp"}, {"sha": "a9defc4cdd6fdee61f5808ee64c3faf601f55a26", "filename": "libgomp/testsuite/libgomp.c/target-simd-clone-1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-simd-clone-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-simd-clone-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-simd-clone-1.c?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do link { target { offload_target_amdgcn } } } */\n+/* { dg-additional-options \"-O2 -foffload-options=-fdump-ipa-simdclone-details\" } */\n+\n+/* Test that simd clones for the offload processor are generated for\n+   functions with \"declare target\" when enabled by default at -O2.  */\n+\n+#pragma omp declare target\n+__attribute__ ((__noinline__)) int addit (int a, int b)\n+{\n+  return a + b;\n+}\n+\n+__attribute__ ((__noinline__))\n+void callit (int *a, int *b, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (a[i], b[i]);\n+}\n+#pragma omp end declare target\n+\n+int main (void)\n+{\n+  int aa[16], bb[16], cc[16];\n+  int i;\n+  for (i = 0; i < 16; i++)\n+    {\n+      aa[i] = i;\n+      bb[i] = -i;\n+    }\n+  callit (aa, bb, cc);\n+  for (i = 0; i < 16; i++)\n+    if (cc[i] != 0)\n+      return 1;\n+  return 0;\n+}\n+\n+/* Although addit has external linkage, we expect clones to be generated as\n+   for a function with internal linkage.  */\n+\n+/* { dg-final { scan-offload-ipa-dump \"Generated local clone _ZGV.*N.*_addit\" \"simdclone\" } } */\n+/* { dg-final { scan-offload-ipa-dump \"Generated local clone _ZGV.*M.*_addit\" \"simdclone\" } } */"}, {"sha": "05a38ae2bc588f9638d57cc63d6a8f90caa7af1d", "filename": "libgomp/testsuite/libgomp.c/target-simd-clone-2.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-simd-clone-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-simd-clone-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-simd-clone-2.c?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do link { target { offload_target_amdgcn } } } */\n+/* { dg-additional-options \"-foffload-options=-fdump-ipa-simdclone-details -foffload-options=-fno-openmp-target-simd-clone\" } */\n+\n+/* Test that simd clones for the offload processor are not generated for\n+   functions with \"declare target\" when explicitly disabled.  */\n+\n+#pragma omp declare target\n+__attribute__ ((__noinline__)) int addit (int a, int b)\n+{\n+  return a + b;\n+}\n+\n+__attribute__ ((__noinline__))\n+void callit (int *a, int *b, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (a[i], b[i]);\n+}\n+#pragma omp end declare target\n+\n+int main (void)\n+{\n+  int aa[16], bb[16], cc[16];\n+  int i;\n+  for (i = 0; i < 16; i++)\n+    {\n+      aa[i] = i;\n+      bb[i] = -i;\n+    }\n+  callit (aa, bb, cc);\n+  for (i = 0; i < 16; i++)\n+    if (cc[i] != 0)\n+      return 1;\n+  return 0;\n+}\n+\n+/* { dg-final { scan-offload-ipa-dump-not \"Generated .* clone\" \"simdclone\" } } */"}, {"sha": "bde091e24ba1a7569da50e54d83351ede2b88cdd", "filename": "libgomp/testsuite/libgomp.c/target-simd-clone-3.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309e2d95e3b930c6f15c8a5346b913158404c76d/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-simd-clone-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309e2d95e3b930c6f15c8a5346b913158404c76d/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-simd-clone-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-simd-clone-3.c?ref=309e2d95e3b930c6f15c8a5346b913158404c76d", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do link { target { offload_target_amdgcn } } } */\n+/* { dg-additional-options \"-O2 -foffload-options=-fdump-ipa-simdclone-details\" } */\n+\n+/* Test that device simd clones are not generated for functions with the host\n+   \"declare target\" clause only.  */\n+\n+__attribute__ ((__noinline__)) int addit (int a, int b)\n+{\n+  return a + b;\n+}\n+#pragma omp declare target to(addit) device_type(host)\n+\n+#pragma omp declare target\n+void callit (int *a, int *b, int *c)\n+{\n+  int i;\n+  #pragma omp for simd\n+  for (i = 0; i < 16; i++)\n+    c[i] = addit (a[i], b[i]);\n+}\n+#pragma omp end declare target\n+\n+int main (void)\n+{\n+  int aa[16], bb[16], cc[16];\n+  int i;\n+  for (i = 0; i < 16; i++)\n+    {\n+      aa[i] = i;\n+      bb[i] = -i;\n+    }\n+  callit (aa, bb, cc);\n+  for (i = 0; i < 16; i++)\n+    if (cc[i] != 0)\n+      return 1;\n+  return 0;\n+}\n+\n+/* { dg-final { scan-offload-ipa-dump \"device doesn't match\" \"simdclone\" { target x86_64-*-* } } } */\n+/* { dg-final { scan-offload-ipa-dump-not \"Generated .* clone\" \"simdclone\" { target x86_64-*-* } } } */"}]}