{"sha": "9beafc83cabd13b4ad5783209db8f32998363e08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJlYWZjODNjYWJkMTNiNGFkNTc4MzIwOWRiOGYzMjk5ODM2M2UwOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-08-01T20:04:57Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-08-01T20:04:57Z"}, "message": "re PR c++/28523 (Throw of a derived class casted to its base class using a C-style cast)\n\n\tPR c++/28523\n\t* tree.c (stabilize_expr): Tweak documentation.  Add assertion.\n\t(stabilize_call): Tweak documentation.\n\t(stabilize_init): Only call stabilize_call for calls.\n\tPR c++/28523\n\t* g++.dg/eh/cast1.C: New test.\n\nFrom-SVN: r115862", "tree": {"sha": "dd3912200eeffd0b29ac6d29d2a8302828c500fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd3912200eeffd0b29ac6d29d2a8302828c500fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9beafc83cabd13b4ad5783209db8f32998363e08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9beafc83cabd13b4ad5783209db8f32998363e08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9beafc83cabd13b4ad5783209db8f32998363e08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9beafc83cabd13b4ad5783209db8f32998363e08/comments", "author": null, "committer": null, "parents": [{"sha": "8218f92fdf6d1b1c6cf64a03967b7ae8e9b83361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8218f92fdf6d1b1c6cf64a03967b7ae8e9b83361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8218f92fdf6d1b1c6cf64a03967b7ae8e9b83361"}], "stats": {"total": 107, "additions": 70, "deletions": 37}, "files": [{"sha": "1e327c22e76efb8775a257336dc79c8b7adc863f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9beafc83cabd13b4ad5783209db8f32998363e08/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9beafc83cabd13b4ad5783209db8f32998363e08/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9beafc83cabd13b4ad5783209db8f32998363e08", "patch": "@@ -1,3 +1,10 @@\n+2006-07-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/28523\n+\t* tree.c (stabilize_expr): Tweak documentation.  Add assertion.\n+\t(stabilize_call): Tweak documentation.\n+\t(stabilize_init): Only call stabilize_call for calls.\n+\n 2006-08-01  Steve Ellcey  <sje@cup.hp.com>\n \n \tPR c++/28432"}, {"sha": "53d37beca68a3755109c1385759695b0e80ddfc5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 48, "deletions": 37, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9beafc83cabd13b4ad5783209db8f32998363e08/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9beafc83cabd13b4ad5783209db8f32998363e08/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9beafc83cabd13b4ad5783209db8f32998363e08", "patch": "@@ -2229,19 +2229,19 @@ decl_linkage (tree decl)\n   return lk_internal;\n }\n \f\n-/* EXP is an expression that we want to pre-evaluate.  Returns via INITP an\n-   expression to perform the pre-evaluation, and returns directly an\n-   expression to use the precalculated result.  */\n+/* EXP is an expression that we want to pre-evaluate.  Returns (in\n+   *INITP) an expression that will perform the pre-evaluation.  The\n+   value returned by this function is a side-effect free expression\n+   equivalent to the pre-evaluated expression.  Callers must ensure\n+   that *INITP is evaluated before EXP.  */\n \n tree\n stabilize_expr (tree exp, tree* initp)\n {\n   tree init_expr;\n \n   if (!TREE_SIDE_EFFECTS (exp))\n-    {\n-      init_expr = NULL_TREE;\n-    }\n+    init_expr = NULL_TREE;\n   else if (!real_lvalue_p (exp)\n \t   || !TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (exp)))\n     {\n@@ -2255,8 +2255,9 @@ stabilize_expr (tree exp, tree* initp)\n       exp = TARGET_EXPR_SLOT (init_expr);\n       exp = build_indirect_ref (exp, 0);\n     }\n-\n   *initp = init_expr;\n+\n+  gcc_assert (!TREE_SIDE_EFFECTS (exp));\n   return exp;\n }\n \n@@ -2273,8 +2274,10 @@ add_stmt_to_compound (tree orig, tree new)\n   return build2 (COMPOUND_EXPR, void_type_node, orig, new);\n }\n \n-/* Like stabilize_expr, but for a call whose args we want to\n-   pre-evaluate.  */\n+/* Like stabilize_expr, but for a call whose arguments we want to\n+   pre-evaluate.  CALL is modified in place to use the pre-evaluated\n+   arguments, while, upon return, *INITP contains an expression to\n+   compute the arguments.  */\n \n void\n stabilize_call (tree call, tree *initp)\n@@ -2299,50 +2302,58 @@ stabilize_call (tree call, tree *initp)\n   *initp = inits;\n }\n \n-/* Like stabilize_expr, but for an initialization.  If we are initializing\n-   an object of class type, we don't want to introduce an extra temporary,\n-   so we look past the TARGET_EXPR and stabilize the arguments of the call\n-   instead.  */\n+/* Like stabilize_expr, but for an initialization.  \n+\n+   If the initialization is for an object of class type, this function\n+   takes care not to introduce additional temporaries.\n+\n+   Returns TRUE iff the expression was successfully pre-evaluated,\n+   i.e., if INIT is now side-effect free, except for, possible, a\n+   single call to a constructor.  */\n \n bool\n stabilize_init (tree init, tree *initp)\n {\n   tree t = init;\n \n+  *initp = NULL_TREE;\n+\n   if (t == error_mark_node)\n     return true;\n \n   if (TREE_CODE (t) == INIT_EXPR\n       && TREE_CODE (TREE_OPERAND (t, 1)) != TARGET_EXPR)\n-    TREE_OPERAND (t, 1) = stabilize_expr (TREE_OPERAND (t, 1), initp);\n-  else\n     {\n-      if (TREE_CODE (t) == INIT_EXPR)\n-\tt = TREE_OPERAND (t, 1);\n-      if (TREE_CODE (t) == TARGET_EXPR)\n-\tt = TARGET_EXPR_INITIAL (t);\n-      if (TREE_CODE (t) == COMPOUND_EXPR)\n-\tt = expr_last (t);\n-      if (TREE_CODE (t) == CONSTRUCTOR\n-\t  && EMPTY_CONSTRUCTOR_P (t))\n-\t{\n-\t  /* Default-initialization.  */\n-\t  *initp = NULL_TREE;\n-\t  return true;\n-\t}\n+      TREE_OPERAND (t, 1) = stabilize_expr (TREE_OPERAND (t, 1), initp);\n+      return true;\n+    }\n \n-      /* If the initializer is a COND_EXPR, we can't preevaluate\n-\t anything.  */\n-      if (TREE_CODE (t) == COND_EXPR)\n-\treturn false;\n+  if (TREE_CODE (t) == INIT_EXPR)\n+    t = TREE_OPERAND (t, 1);\n+  if (TREE_CODE (t) == TARGET_EXPR)\n+    t = TARGET_EXPR_INITIAL (t);\n+  if (TREE_CODE (t) == COMPOUND_EXPR)\n+    t = expr_last (t);\n+  if (TREE_CODE (t) == CONSTRUCTOR\n+      && EMPTY_CONSTRUCTOR_P (t))\n+    /* Default-initialization.  */\n+    return true;\n+\n+  /* If the initializer is a COND_EXPR, we can't preevaluate\n+     anything.  */\n+  if (TREE_CODE (t) == COND_EXPR)\n+    return false;\n \n-      /* The TARGET_EXPR might be initializing via bitwise copy from\n-\t another variable; leave that alone.  */\n-      if (TREE_SIDE_EFFECTS (t))\n-\tstabilize_call (t, initp);\n+  if (TREE_CODE (t) == CALL_EXPR\n+      || TREE_CODE (t) == AGGR_INIT_EXPR)\n+    {\n+      stabilize_call (t, initp);\n+      return true;\n     }\n \n-  return true;\n+  /* The initialization is being performed via a bitwise copy -- and\n+     the item copied may have side effects.  */\n+  return TREE_SIDE_EFFECTS (init);\n }\n \n /* Like \"fold\", but should be used whenever we might be processing the"}, {"sha": "1e1effcfbc6b863390bd6c0cf5b217389b085650", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9beafc83cabd13b4ad5783209db8f32998363e08/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9beafc83cabd13b4ad5783209db8f32998363e08/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9beafc83cabd13b4ad5783209db8f32998363e08", "patch": "@@ -1,3 +1,8 @@\n+2006-07-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/28523\n+\t* g++.dg/eh/cast1.C: New test.\n+\n 2006-08-01  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR libfortran/28452"}, {"sha": "964dd698d30943f0bcdbda424652d774b0cd6254", "filename": "gcc/testsuite/g++.dg/eh/cast1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9beafc83cabd13b4ad5783209db8f32998363e08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fcast1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9beafc83cabd13b4ad5783209db8f32998363e08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fcast1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fcast1.C?ref=9beafc83cabd13b4ad5783209db8f32998363e08", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/28523\n+\n+class A {};\n+class B : public A {};\n+\n+int main()\n+{\n+  throw (A) B();\n+  return 0;\n+}"}]}