{"sha": "6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEzZjIwM2MzY2M4ZTBmMDc1N2Y3ZWQwMzhiM2NiMzQwNjM5MzZiYQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-06-15T03:29:39Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-06-15T03:29:39Z"}, "message": "spellcheck.h: add best_match template; implement early-reject\n\ngcc/c/ChangeLog:\n\t* c-typeck.c: Include spellcheck-tree.h rather than spellcheck.h.\n\ngcc/cp/ChangeLog:\n\t* search.c: Include spellcheck-tree.h rather than spellcheck.h.\n\ngcc/ChangeLog:\n\t* spellcheck-tree.c: Include spellcheck-tree.h rather than\n\tspellcheck.h.\n\t(find_closest_identifier): Reimplement in terms of\n\tbest_match<tree,tree>.\n\t* spellcheck-tree.h: New file.\n\t* spellcheck.c (struct edit_distance_traits<const char *>): New\n\tstruct.\n\t(find_closest_string): Reimplement in terms of\n\tbest_match<const char *, const char *>.\n\t* spellcheck.h (levenshtein_distance): Move prototype of tree-based\n\toverload to spellcheck-tree.h.\n\t(find_closest_identifier): Likewise.\n\t(struct edit_distance_traits<T>): New template.\n\t(class best_match): New class.\n\nFrom-SVN: r237471", "tree": {"sha": "e99b8b2be80b721ed128799b811f4eccae4a9f64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e99b8b2be80b721ed128799b811f4eccae4a9f64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e990b5d19d930bd1769d6db455fcbda8e7eae11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e990b5d19d930bd1769d6db455fcbda8e7eae11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e990b5d19d930bd1769d6db455fcbda8e7eae11"}], "stats": {"total": 256, "additions": 208, "deletions": 48}, "files": [{"sha": "907bb06bee90f23505b96431b9dbf074461ba6d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "patch": "@@ -1,3 +1,20 @@\n+2016-06-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* spellcheck-tree.c: Include spellcheck-tree.h rather than\n+\tspellcheck.h.\n+\t(find_closest_identifier): Reimplement in terms of\n+\tbest_match<tree,tree>.\n+\t* spellcheck-tree.h: New file.\n+\t* spellcheck.c (struct edit_distance_traits<const char *>): New\n+\tstruct.\n+\t(find_closest_string): Reimplement in terms of\n+\tbest_match<const char *, const char *>.\n+\t* spellcheck.h (levenshtein_distance): Move prototype of tree-based\n+\toverload to spellcheck-tree.h.\n+\t(find_closest_identifier): Likewise.\n+\t(struct edit_distance_traits<T>): New template.\n+\t(class best_match): New class.\n+\n 2016-06-14  David Malcolm  <dmalcolm@redhat.com>\n \n \t* selftest-run-tests.c (selftest::run_tests): Call"}, {"sha": "e5d84bb308ea26840e24e687828c3ff24bea24a4", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "patch": "@@ -1,3 +1,7 @@\n+2016-06-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-typeck.c: Include spellcheck-tree.h rather than spellcheck.h.\n+\n 2016-06-14  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-typeck.c (build_component_ref): Simplify fixit code by"}, {"sha": "f03c07bb7f15d2e78c1579ac6a281e5a3dc695e4", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "patch": "@@ -47,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-ubsan.h\"\n #include \"cilk.h\"\n #include \"gomp-constants.h\"\n-#include \"spellcheck.h\"\n+#include \"spellcheck-tree.h\"\n #include \"gcc-rich-location.h\"\n \n /* Possible cases of implicit bad conversions.  Used to select"}, {"sha": "775b61482d496d27e17c8fbdc4f6d19900a30fa1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "patch": "@@ -1,3 +1,7 @@\n+2016-06-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* search.c: Include spellcheck-tree.h rather than spellcheck.h.\n+\n 2016-06-14  David Malcolm  <dmalcolm@redhat.com>\n \n \t* typeck.c: Include \"gcc-rich-location.h\"."}, {"sha": "990c3fe748dad387210f45bd2a083d03d4f8b238", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cp-tree.h\"\n #include \"intl.h\"\n #include \"toplev.h\"\n-#include \"spellcheck.h\"\n+#include \"spellcheck-tree.h\"\n \n static int is_subobject_of_p (tree, tree);\n static tree dfs_lookup_base (tree, void *);"}, {"sha": "63fb1a878ac099285d0a125260ac6d48960cac53", "filename": "gcc/spellcheck-tree.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fspellcheck-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fspellcheck-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck-tree.c?ref=6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n-#include \"spellcheck.h\"\n+#include \"spellcheck-tree.h\"\n #include \"selftest.h\"\n #include \"stringpool.h\"\n \n@@ -53,32 +53,16 @@ find_closest_identifier (tree target, const auto_vec<tree> *candidates)\n {\n   gcc_assert (TREE_CODE (target) == IDENTIFIER_NODE);\n \n+  best_match<tree, tree> bm (target);\n   int i;\n   tree identifier;\n-  tree best_identifier = NULL_TREE;\n-  edit_distance_t best_distance = MAX_EDIT_DISTANCE;\n   FOR_EACH_VEC_ELT (*candidates, i, identifier)\n     {\n       gcc_assert (TREE_CODE (identifier) == IDENTIFIER_NODE);\n-      edit_distance_t dist = levenshtein_distance (target, identifier);\n-      if (dist < best_distance)\n-\t{\n-\t  best_distance = dist;\n-\t  best_identifier = identifier;\n-\t}\n+      bm.consider (identifier);\n     }\n \n-  /* If more than half of the letters were misspelled, the suggestion is\n-     likely to be meaningless.  */\n-  if (best_identifier)\n-    {\n-      unsigned int cutoff = MAX (IDENTIFIER_LENGTH (target),\n-\t\t\t\t IDENTIFIER_LENGTH (best_identifier)) / 2;\n-      if (best_distance > cutoff)\n-\treturn NULL_TREE;\n-    }\n-\n-  return best_identifier;\n+  return bm.get_best_meaningful_candidate ();\n }\n \n #if CHECKING_P"}, {"sha": "0d5e253562f6a691ce683e88c4deb2d881330992", "filename": "gcc/spellcheck-tree.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fspellcheck-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fspellcheck-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck-tree.h?ref=6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "patch": "@@ -0,0 +1,51 @@\n+/* Find near-matches for identifiers.\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SPELLCHECK_TREE_H\n+#define GCC_SPELLCHECK_TREE_H\n+\n+#include \"spellcheck.h\"\n+\n+/* spellcheck-tree.c  */\n+\n+extern edit_distance_t\n+levenshtein_distance (tree ident_s, tree ident_t);\n+\n+extern tree\n+find_closest_identifier (tree target, const auto_vec<tree> *candidates);\n+\n+/* Specialization of edit_distance_traits for identifiers.  */\n+\n+template <>\n+struct edit_distance_traits<tree>\n+{\n+  static size_t get_length (tree id)\n+  {\n+    gcc_assert (TREE_CODE (id) == IDENTIFIER_NODE);\n+    return IDENTIFIER_LENGTH (id);\n+  }\n+\n+  static const char *get_string (tree id)\n+  {\n+    gcc_assert (TREE_CODE (id) == IDENTIFIER_NODE);\n+    return IDENTIFIER_POINTER (id);\n+  }\n+};\n+\n+#endif  /* GCC_SPELLCHECK_TREE_H  */"}, {"sha": "2648f3a0bbb9adc52523e9f071e794e72d134b09", "filename": "gcc/spellcheck.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fspellcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fspellcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck.c?ref=6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "patch": "@@ -121,6 +121,24 @@ levenshtein_distance (const char *s, const char *t)\n   return levenshtein_distance (s, strlen (s), t, strlen (t));\n }\n \n+/* Specialization of edit_distance_traits for C-style strings.  */\n+\n+template <>\n+struct edit_distance_traits<const char *>\n+{\n+  static size_t get_length (const char *str)\n+  {\n+    gcc_assert (str);\n+    return strlen (str);\n+  }\n+\n+  static const char *get_string (const char *str)\n+  {\n+    gcc_assert (str);\n+    return str;\n+  }\n+};\n+\n /* Given TARGET, a non-NULL string, and CANDIDATES, a non-NULL ptr to\n    an autovec of non-NULL strings, determine which element within\n    CANDIDATES has the lowest edit distance to TARGET.  If there are\n@@ -139,32 +157,14 @@ find_closest_string (const char *target,\n \n   int i;\n   const char *candidate;\n-  const char *best_candidate = NULL;\n-  edit_distance_t best_distance = MAX_EDIT_DISTANCE;\n-  size_t len_target = strlen (target);\n+  best_match<const char *, const char *> bm (target);\n   FOR_EACH_VEC_ELT (*candidates, i, candidate)\n     {\n       gcc_assert (candidate);\n-      edit_distance_t dist\n-\t= levenshtein_distance (target, len_target,\n-\t\t\t\tcandidate, strlen (candidate));\n-      if (dist < best_distance)\n-\t{\n-\t  best_distance = dist;\n-\t  best_candidate = candidate;\n-\t}\n-    }\n-\n-  /* If more than half of the letters were misspelled, the suggestion is\n-     likely to be meaningless.  */\n-  if (best_candidate)\n-    {\n-      unsigned int cutoff = MAX (len_target, strlen (best_candidate)) / 2;\n-      if (best_distance > cutoff)\n-\treturn NULL;\n+      bm.consider (candidate);\n     }\n \n-  return best_candidate;\n+  return bm.get_best_meaningful_candidate ();\n }\n \n #if CHECKING_P"}, {"sha": "7379399f1fd24937c1d3017ac2beabf4a284f1d1", "filename": "gcc/spellcheck.h", "status": "modified", "additions": 105, "deletions": 5, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fspellcheck.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a3f203c3cc8e0f0757f7ed038b3cb34063936ba/gcc%2Fspellcheck.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck.h?ref=6a3f203c3cc8e0f0757f7ed038b3cb34063936ba", "patch": "@@ -35,12 +35,112 @@ extern const char *\n find_closest_string (const char *target,\n \t\t     const auto_vec<const char *> *candidates);\n \n-/* spellcheck-tree.c  */\n+/* A traits class for describing a string-like type usable by\n+   class best_match.\n+   Specializations should provide the implementations of the following:\n \n-extern edit_distance_t\n-levenshtein_distance (tree ident_s, tree ident_t);\n+     static size_t get_length (TYPE);\n+     static const char *get_string (TYPE);\n+\n+   get_string should return a non-NULL ptr, which does not need to be\n+   0-terminated.  */\n+\n+template <typename TYPE>\n+struct edit_distance_traits {};\n+\n+/* A type for use when determining the best match against a string,\n+   expressed as a template so that we can match against various\n+   string-like types (const char *, frontend identifiers, and preprocessor\n+   macros).\n+\n+   This type accumulates the best possible match against GOAL_TYPE for\n+   a sequence of elements of CANDIDATE_TYPE, whilst minimizing the\n+   number of calls to levenshtein_distance and to\n+   edit_distance_traits<T>::get_length.  */\n+\n+template <typename GOAL_TYPE, typename CANDIDATE_TYPE>\n+class best_match\n+{\n+ public:\n+  typedef GOAL_TYPE goal_t;\n+  typedef CANDIDATE_TYPE candidate_t;\n+  typedef edit_distance_traits<goal_t> goal_traits;\n+  typedef edit_distance_traits<candidate_t> candidate_traits;\n+\n+  /* Constructor.  */\n+\n+  best_match (goal_t goal)\n+  : m_goal (goal_traits::get_string (goal)),\n+    m_goal_len (goal_traits::get_length (goal)),\n+    m_best_candidate (NULL),\n+    m_best_distance (MAX_EDIT_DISTANCE)\n+  {}\n+\n+  /* Compare the edit distance between CANDIDATE and m_goal,\n+     and if it's the best so far, record it.  */\n+\n+  void consider (candidate_t candidate)\n+  {\n+    size_t candidate_len = candidate_traits::get_length (candidate);\n+\n+    /* Calculate a lower bound on the candidate's distance to the goal,\n+       based on the difference in lengths; it will require at least\n+       this many insertions/deletions.  */\n+    edit_distance_t min_candidate_distance\n+      = abs ((ssize_t)candidate_len - (ssize_t)m_goal_len);\n+\n+    /* If the candidate's length is sufficiently different to that\n+       of the goal string, then the number of insertions/deletions\n+       may be >= the best distance so far.  If so, we can reject\n+       the candidate immediately without needing to compute\n+       the exact distance, since it won't be an improvement.  */\n+    if (min_candidate_distance >= m_best_distance)\n+      return;\n+\n+    /* If the candidate will be unable to beat the criterion in\n+       get_best_meaningful_candidate, reject it without computing\n+       the exact distance.  */\n+    unsigned int cutoff = MAX (m_goal_len, candidate_len) / 2;\n+    if (min_candidate_distance > cutoff)\n+      return;\n+\n+    /* Otherwise, compute the distance and see if the candidate\n+       has beaten the previous best value.  */\n+    edit_distance_t dist\n+      = levenshtein_distance (m_goal, m_goal_len,\n+\t\t\t      candidate_traits::get_string (candidate),\n+\t\t\t      candidate_len);\n+    if (dist < m_best_distance)\n+      {\n+\tm_best_distance = dist;\n+\tm_best_candidate = candidate;\n+\tm_best_candidate_len = candidate_len;\n+      }\n+  }\n+\n+  /* Get the best candidate so far, but applying a filter to ensure\n+     that we return NULL if none of the candidates are close to the goal,\n+     to avoid offering nonsensical suggestions to the user.  */\n+\n+  candidate_t get_best_meaningful_candidate () const\n+  {\n+    /* If more than half of the letters were misspelled, the suggestion is\n+       likely to be meaningless.  */\n+    if (m_best_candidate)\n+      {\n+\tunsigned int cutoff = MAX (m_goal_len, m_best_candidate_len) / 2;\n+\tif (m_best_distance > cutoff)\n+\t  return NULL;\n+    }\n+    return m_best_candidate;\n+  }\n \n-extern tree\n-find_closest_identifier (tree target, const auto_vec<tree> *candidates);\n+ private:\n+  const char *m_goal;\n+  size_t m_goal_len;\n+  candidate_t m_best_candidate;\n+  edit_distance_t m_best_distance;\n+  size_t m_best_candidate_len;\n+};\n \n #endif  /* GCC_SPELLCHECK_H  */"}]}