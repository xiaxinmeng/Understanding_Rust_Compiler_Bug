{"sha": "25e4379fe54884cd49f653bc97ddf98f89d8c796", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlNDM3OWZlNTQ4ODRjZDQ5ZjY1M2JjOTdkZGY5OGY4OWQ4Yzc5Ng==", "commit": {"author": {"name": "Michael Matz", "email": "matzmich@cs.tu-berlin.de", "date": "2000-11-30T21:40:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-30T21:40:33Z"}, "message": "flow.c (make_edge): Early out, if no flags to set.\n\n        * flow.c (make_edge): Early out, if no flags to set.\n        (calculate_global_regs_live): Clear out garbage only when necessary.\n\n        * simplify-rtx.c (varray_type used_regs): New.\n        (clear_table): Use it to only clear necessary items.\n        (cselib_lookup, cselib_record_set): Remember newly set items.\n        (cselib_update_varray_sizes, cselib_init): Initialize and grow\n        used_regs.\n\n        * local-alloc.c (update_equiv_regs): New local `cleared_regs'.\n        Move clearing of dead regs out of insn-loop.\n\nFrom-SVN: r37899", "tree": {"sha": "85bc1efd0f69f6554f716ba134eaafceffa2538b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85bc1efd0f69f6554f716ba134eaafceffa2538b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25e4379fe54884cd49f653bc97ddf98f89d8c796", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e4379fe54884cd49f653bc97ddf98f89d8c796", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e4379fe54884cd49f653bc97ddf98f89d8c796", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e4379fe54884cd49f653bc97ddf98f89d8c796/comments", "author": null, "committer": null, "parents": [{"sha": "41c395330242369ea5d33c544ad41f8833df782c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c395330242369ea5d33c544ad41f8833df782c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41c395330242369ea5d33c544ad41f8833df782c"}], "stats": {"total": 128, "additions": 99, "deletions": 29}, "files": [{"sha": "dbb46a562185cbabef4686579686f59cd538166a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e4379fe54884cd49f653bc97ddf98f89d8c796/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e4379fe54884cd49f653bc97ddf98f89d8c796/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25e4379fe54884cd49f653bc97ddf98f89d8c796", "patch": "@@ -1,3 +1,17 @@\n+2000-11-30  Michael Matz  <matzmich@cs.tu-berlin.de>\n+\n+\t* flow.c (make_edge): Early out, if no flags to set.\n+\t(calculate_global_regs_live): Clear out garbage only when necessary.\n+\n+\t* simplify-rtx.c (varray_type used_regs): New.\n+\t(clear_table): Use it to only clear necessary items.\n+\t(cselib_lookup, cselib_record_set): Remember newly set items.\n+\t(cselib_update_varray_sizes, cselib_init): Initialize and grow\n+\tused_regs.\n+\n+\t* local-alloc.c (update_equiv_regs): New local `cleared_regs'.\n+\tMove clearing of dead regs out of insn-loop.\n+\n 2000-11-30  Richard Henderson  <rth@redhat.com>\n \n \t* calls.c (expand_call): Emit queued insns before creating"}, {"sha": "4aacbf8413e2a41a4f7fef241965d6d2e87c6e44", "filename": "gcc/flow.c", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e4379fe54884cd49f653bc97ddf98f89d8c796/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e4379fe54884cd49f653bc97ddf98f89d8c796/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=25e4379fe54884cd49f653bc97ddf98f89d8c796", "patch": "@@ -1262,13 +1262,27 @@ make_edge (edge_cache, src, dst, flags)\n \t\t    && dst != EXIT_BLOCK_PTR);\n \n   /* Make sure we don't add duplicate edges.  */\n-  if (! use_edge_cache || TEST_BIT (edge_cache[src->index], dst->index))\n-    for (e = src->succ; e; e = e->succ_next)\n-      if (e->dest == dst)\n-\t{\n-\t  e->flags |= flags;\n-\t  return;\n-\t}\n+  switch (use_edge_cache)\n+    {\n+    default:\n+      /* Quick test for non-existance of the edge.  */\n+      if (! TEST_BIT (edge_cache[src->index], dst->index))\n+\tbreak;\n+\n+      /* The edge exists; early exit if no work to do.  */\n+      if (flags == 0)\n+\treturn;\n+\n+      /* FALLTHRU */\n+    case 0:\n+      for (e = src->succ; e; e = e->succ_next)\n+\tif (e->dest == dst)\n+\t  {\n+\t    e->flags |= flags;\n+\t    return;\n+\t  }\n+      break;\n+    }\n \n   e = (edge) xcalloc (1, sizeof (*e));\n   n_edges++;\n@@ -3306,15 +3320,15 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n   qtail = queue;\n   qhead = qend = queue + n_basic_blocks + 2;\n \n-  /* Clear out the garbage that might be hanging out in bb->aux.  */\n-  for (i = n_basic_blocks - 1; i >= 0; --i)\n-    BASIC_BLOCK (i)->aux = NULL;\n-\n   /* Queue the blocks set in the initial mask.  Do this in reverse block\n      number order so that we are more likely for the first round to do\n      useful work.  We use AUX non-null to flag that the block is queued.  */\n   if (blocks_in)\n     {\n+      /* Clear out the garbage that might be hanging out in bb->aux.  */\n+      for (i = n_basic_blocks - 1; i >= 0; --i)\n+\tBASIC_BLOCK (i)->aux = NULL;\n+\n       EXECUTE_IF_SET_IN_SBITMAP (blocks_in, 0, i,\n \t{\n \t  basic_block bb = BASIC_BLOCK (i);"}, {"sha": "62142f04c38085ccc2abde51afc23a0940d9e9fe", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e4379fe54884cd49f653bc97ddf98f89d8c796/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e4379fe54884cd49f653bc97ddf98f89d8c796/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=25e4379fe54884cd49f653bc97ddf98f89d8c796", "patch": "@@ -804,8 +804,11 @@ update_equiv_regs ()\n   rtx insn;\n   int block;\n   int loop_depth;\n+  regset_head cleared_regs;\n+  int clear_regnos = 0;\n \n   reg_equiv = (struct equivalence *) xcalloc (max_regno, sizeof *reg_equiv);\n+  INIT_REG_SET (&cleared_regs);\n \n   init_alias_analysis ();\n \n@@ -1135,7 +1138,6 @@ update_equiv_regs ()\n \t\t INSN.  Update the flow information.  */\n \t      else if (PREV_INSN (insn) != equiv_insn)\n \t\t{\n-\t\t  int l;\n \t\t  rtx new_insn;\n \n \t\t  new_insn = emit_insn_before (copy_rtx (PATTERN (equiv_insn)),\n@@ -1156,22 +1158,43 @@ update_equiv_regs ()\n \t\t  if (block >= 0 && insn == BLOCK_HEAD (block))\n \t\t    BLOCK_HEAD (block) = PREV_INSN (insn);\n \n-\t\t  for (l = 0; l < n_basic_blocks; l++)\n-\t\t    {\n-\t\t      CLEAR_REGNO_REG_SET (\n-\t\t\t\t\tBASIC_BLOCK (l)->global_live_at_start,\n-\t\t\t\t\t   regno);\n-\t\t      CLEAR_REGNO_REG_SET (\n-\t\t\t\t\tBASIC_BLOCK (l)->global_live_at_end,\n-\t\t\t\t\t   regno);\n-\t\t    }\n+\t\t  /* Remember to clear REGNO from all basic block's live\n+\t\t     info.  */\n+\t\t  SET_REGNO_REG_SET (&cleared_regs, regno);\n+\t\t  clear_regnos++;\n \t\t}\n \t    }\n \t}\n     }\n \n+  /* Clear all dead REGNOs from all basic block's live info.  */\n+  if (clear_regnos)\n+    {\n+      int j, l;\n+      if (clear_regnos > 8)\n+        {\n+\t  for (l = 0; l < n_basic_blocks; l++)\n+\t    {\n+\t      AND_COMPL_REG_SET (BASIC_BLOCK (l)->global_live_at_start,\n+\t                         &cleared_regs);\n+\t      AND_COMPL_REG_SET (BASIC_BLOCK (l)->global_live_at_end,\n+\t                         &cleared_regs);\n+\t    }\n+\t}\n+      else\n+        EXECUTE_IF_SET_IN_REG_SET (&cleared_regs, 0, j,\n+          {\n+\t    for (l = 0; l < n_basic_blocks; l++)\n+\t      {\n+\t        CLEAR_REGNO_REG_SET (BASIC_BLOCK (l)->global_live_at_start, j);\n+\t        CLEAR_REGNO_REG_SET (BASIC_BLOCK (l)->global_live_at_end, j);\n+\t      }\n+\t  });\n+    }\n+\n   /* Clean up.  */\n   end_alias_analysis ();\n+  CLEAR_REG_SET (&cleared_regs);\n   free (reg_equiv);\n }\n "}, {"sha": "ae15b087d4df505b73d6411cf14bb5ab2bec625e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e4379fe54884cd49f653bc97ddf98f89d8c796/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e4379fe54884cd49f653bc97ddf98f89d8c796/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=25e4379fe54884cd49f653bc97ddf98f89d8c796", "patch": "@@ -111,7 +111,7 @@ static struct elt_loc_list *new_elt_loc_list PARAMS ((struct elt_loc_list *,\n static void unchain_one_value\t\tPARAMS ((cselib_val *));\n static void unchain_one_elt_list\tPARAMS ((struct elt_list **));\n static void unchain_one_elt_loc_list\tPARAMS ((struct elt_loc_list **));\n-static void clear_table\t\t\tPARAMS ((void));\n+static void clear_table\t\t\tPARAMS ((int));\n static int discard_useless_locs\t\tPARAMS ((void **, void *));\n static int discard_useless_values\tPARAMS ((void **, void *));\n static void remove_useless_values\tPARAMS ((void));\n@@ -168,6 +168,10 @@ static int n_useless_values;\n static varray_type reg_values;\n #define REG_VALUES(I) VARRAY_ELT_LIST (reg_values, (I))\n \n+/* Here the set of indices I with REG_VALUES(I) != 0 is saved.  This is used\n+   in clear_table() for fast emptying.  */\n+static varray_type used_regs;\n+\n /* We pass this to cselib_invalidate_mem to invalidate all of\n    memory for a non-const call instruction.  */\n static rtx callmem;\n@@ -2200,15 +2204,23 @@ unchain_one_value (v)\n }\n \n /* Remove all entries from the hash table.  Also used during\n-   initialization.  */\n+   initialization.  If CLEAR_ALL isn't set, then only clear the entries\n+   which are known to have been used.  */\n \n static void\n-clear_table ()\n+clear_table (clear_all)\n+     int clear_all;\n {\n   unsigned int i;\n \n-  for (i = 0; i < cselib_nregs; i++)\n-    REG_VALUES (i) = 0;\n+  if (clear_all)\n+    for (i = 0; i < cselib_nregs; i++)\n+      REG_VALUES (i) = 0;\n+  else\n+    for (i = 0; i < VARRAY_ACTIVE_SIZE (used_regs); i++)\n+      REG_VALUES (VARRAY_UINT (used_regs, i)) = 0;\n+\n+  VARRAY_POP_ALL (used_regs);\n \n   htab_empty (hash_table);\n   obstack_free (&cselib_obstack, cselib_startobj);\n@@ -2867,6 +2879,8 @@ cselib_lookup (x, mode, create)\n \n       e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n       e->locs = new_elt_loc_list (e->locs, x);\n+      if (REG_VALUES (i) == 0)\n+        VARRAY_PUSH_UINT (used_regs, i);\n       REG_VALUES (i) = new_elt_list (REG_VALUES (i), e);\n       slot = htab_find_slot_with_hash (hash_table, x, e->value, INSERT);\n       *slot = e;\n@@ -3133,6 +3147,9 @@ cselib_record_set (dest, src_elt, dest_addr_elt)\n \n   if (dreg >= 0)\n     {\n+      if (REG_VALUES (dreg) == 0)\n+        VARRAY_PUSH_UINT (used_regs, dreg);\n+\n       REG_VALUES (dreg) = new_elt_list (REG_VALUES (dreg), src_elt);\n       if (src_elt->locs == 0)\n \tn_useless_values--;\n@@ -3249,7 +3266,7 @@ cselib_process_insn (insn)\n \t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n \t  && MEM_VOLATILE_P (PATTERN (insn))))\n     {\n-      clear_table ();\n+      clear_table (0);\n       return;\n     }\n \n@@ -3309,6 +3326,7 @@ cselib_update_varray_sizes ()\n \n   cselib_nregs = nregs;\n   VARRAY_GROW (reg_values, nregs);\n+  VARRAY_GROW (used_regs, nregs);\n }\n \n /* Initialize cselib for one pass.  The caller must also call\n@@ -3329,15 +3347,16 @@ cselib_init ()\n \n   cselib_nregs = max_reg_num ();\n   VARRAY_ELT_LIST_INIT (reg_values, cselib_nregs, \"reg_values\");\n+  VARRAY_UINT_INIT (used_regs, cselib_nregs, \"used_regs\");\n   hash_table = htab_create (31, get_value_hash, entry_and_rtx_equal_p, NULL);\n-  clear_table ();\n+  clear_table (1);\n }\n \n /* Called when the current user is done with cselib.  */\n \n void\n cselib_finish ()\n {\n-  clear_table ();\n+  clear_table (0);\n   htab_delete (hash_table);\n }"}]}