{"sha": "07ffa034dd509e6838f565d51ee8b25292f79d1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdmZmEwMzRkZDUwOWU2ODM4ZjU2NWQ1MWVlOGIyNTI5MmY3OWQxYQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-09-17T11:35:38Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-09-17T11:35:38Z"}, "message": "common.opt (fipa-sra): New switch.\n\n2009-09-17  Martin Jambor  <mjambor@suse.cz>\n\n\t* common.opt (fipa-sra): New switch.\n\t* opts.c (decode_options): Turn flag_ipa_sra on for opt2.\n\t* timevar.def (TV_IPA_SRA): New timevar.\n\t* params.def (ipa-sra-ptr-growth-factor): New parameter.\n\t* doc/invoke.texi: Document -fipa-sra and ipa-sra-ptr-growth-factor.\n\t* tree-sra.c: Include cgraph.c.\n\t(enum sra_mode): Added SRA_MODE_EARLY_IPA.\n\t(struct access): Added fields stmt, grp_maybe_modified, grp_scalar_ptr\n\tand grp_not_necessarilly_dereferenced.\n\t(func_param_count): New variable.\n\t(encountered_apply_args): New variable.\n\t(bb_dereferences): New variable.\n\t(final_bbs): New variable.\n\t(no_accesses_representant): New variable.\n\t(no_accesses_p): New function.\n\t(dump_access): Dump the new fields.\n\t(sra_initialize): Set encountered_apply_args to false.\n\t(get_ssa_base_param): New function.\n\t(mark_parm_dereference): New function.\n\t(create_access): Caring for INIDRECT_REFs and different handling of\n\tvarialble length accesses in early IPA SRA.  Store the stmt - a new\n\tparameter - to the new access.\n\t(build_access_from_expr_1): New parameter stmt, passed to\n\tcreate_access.  Handle INDIRECT_REFs.\n\t(build_access_from_expr): Pass the current statement to\n\tbuild_access_from_expr_1.\n\t(disqualify_ops_if_throwing_stmt): Trigger only in intraprocedural\n\tpasses.\n\t(build_accesses_from_assign): Pass the current statement to\n\tbuild_access_from_expr_1.  Do not create assign links in IPA-SRA.\n\t(scan_function): Call handle_ssa_defs on phi nodes.  Set bits in\n\tfinal_bbs when necessary.  Check for calls to __builtin_apply_args.\n\tFixup EH info if anythng was changed.\n\t(is_unused_scalar_param): New function.\n\t(ptr_parm_has_direct_uses): New function.\n\t(find_param_candidates): New function.\n\t(mark_maybe_modified): New function.\n\t(analyze_modified_params): New function.\n\t(propagate_dereference_distances): New function.\n\t(dump_dereferences_table): New function.\n\t(analyze_caller_dereference_legality): New function.\n\t(unmodified_by_ref_scalar_representative): New function.\n\t(splice_param_accesses): New function.\n\t(decide_one_param_reduction): New function.\n\t(enum ipa_splicing_result): New type.\n\t(splice_all_param_accesses): New function.\n\t(get_param_index): New function.\n\t(turn_representatives_into_adjustments): New function.\n\t(analyze_all_param_acesses): New function.\n\t(get_replaced_param_substitute): New function.\n\t(get_adjustment_for_base): New function.\n\t(replace_removed_params_ssa_names): New function.\n\t(sra_ipa_reset_debug_stmts): New function.\n\t(sra_ipa_modify_expr): New function.\n\t(sra_ipa_modify_assign): New function.\n\t(convert_callers): New function.\n\t(modify_function): New function.\n\t(ipa_sra_preliminary_function_checks): New function.\n\t(ipa_early_sra): New function.\n\t(ipa_early_sra_gate): New function.\n\t(pass_early_ipa_sra): New variable.\n\t* Makefile.in (tree-sra.o): Add cgraph.h to dependencies.\n\t\n\tTestsuite:\n\n\t* gcc.dg/struct/wo_prof_escape_arg_to_local.c: Do not run IPA-SRA.\n\t* gcc.dg/ipa/ipa-sra-1.c: New test.\n\t* gcc.dg/ipa/ipa-sra-2.c: New test.\n\t* gcc.dg/ipa/ipa-sra-3.c: New test.\n\t* gcc.dg/ipa/ipa-sra-4.c: New test.\n\t* gcc.dg/ipa/ipa-sra-5.c: New test.\n\t* gcc.c-torture/execute/ipa-sra-1.c: New test.\n\t* gcc.c-torture/execute/ipa-sra-2.c: New test.\n\nFrom-SVN: r151800", "tree": {"sha": "883a255833d281a80e44214a178bfb568672d674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/883a255833d281a80e44214a178bfb568672d674"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07ffa034dd509e6838f565d51ee8b25292f79d1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ffa034dd509e6838f565d51ee8b25292f79d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07ffa034dd509e6838f565d51ee8b25292f79d1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ffa034dd509e6838f565d51ee8b25292f79d1a/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "040c6d51daadf242937549fb7bc0e5a375fa1666", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040c6d51daadf242937549fb7bc0e5a375fa1666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/040c6d51daadf242937549fb7bc0e5a375fa1666"}], "stats": {"total": 1842, "additions": 1801, "deletions": 41}, "files": [{"sha": "eaf3bafa48638161925a3eb04dcb76bf004e0327", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -1,3 +1,68 @@\n+2009-09-17  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* common.opt (fipa-sra): New switch.\n+\t* opts.c (decode_options): Turn flag_ipa_sra on for opt2.\n+\t* timevar.def (TV_IPA_SRA): New timevar.\n+\t* params.def (ipa-sra-ptr-growth-factor): New parameter.\n+\t* doc/invoke.texi: Document -fipa-sra and ipa-sra-ptr-growth-factor.\n+\t* tree-sra.c: Include cgraph.c.\n+\t(enum sra_mode): Added SRA_MODE_EARLY_IPA.\n+\t(struct access): Added fields stmt, grp_maybe_modified, grp_scalar_ptr\n+\tand grp_not_necessarilly_dereferenced.\n+\t(func_param_count): New variable.\n+\t(encountered_apply_args): New variable.\n+\t(bb_dereferences): New variable.\n+\t(final_bbs): New variable.\n+\t(no_accesses_representant): New variable.\n+\t(no_accesses_p): New function.\n+\t(dump_access): Dump the new fields.\n+\t(sra_initialize): Set encountered_apply_args to false.\n+\t(get_ssa_base_param): New function.\n+\t(mark_parm_dereference): New function.\n+\t(create_access): Caring for INIDRECT_REFs and different handling of\n+\tvarialble length accesses in early IPA SRA.  Store the stmt - a new\n+\tparameter - to the new access.\n+\t(build_access_from_expr_1): New parameter stmt, passed to\n+\tcreate_access.  Handle INDIRECT_REFs.\n+\t(build_access_from_expr): Pass the current statement to\n+\tbuild_access_from_expr_1.\n+\t(disqualify_ops_if_throwing_stmt): Trigger only in intraprocedural\n+\tpasses.\n+\t(build_accesses_from_assign): Pass the current statement to\n+\tbuild_access_from_expr_1.  Do not create assign links in IPA-SRA.\n+\t(scan_function): Call handle_ssa_defs on phi nodes.  Set bits in\n+\tfinal_bbs when necessary.  Check for calls to __builtin_apply_args.\n+\tFixup EH info if anythng was changed.\n+\t(is_unused_scalar_param): New function.\n+\t(ptr_parm_has_direct_uses): New function.\n+\t(find_param_candidates): New function.\n+\t(mark_maybe_modified): New function.\n+\t(analyze_modified_params): New function.\n+\t(propagate_dereference_distances): New function.\n+\t(dump_dereferences_table): New function.\n+\t(analyze_caller_dereference_legality): New function.\n+\t(unmodified_by_ref_scalar_representative): New function.\n+\t(splice_param_accesses): New function.\n+\t(decide_one_param_reduction): New function.\n+\t(enum ipa_splicing_result): New type.\n+\t(splice_all_param_accesses): New function.\n+\t(get_param_index): New function.\n+\t(turn_representatives_into_adjustments): New function.\n+\t(analyze_all_param_acesses): New function.\n+\t(get_replaced_param_substitute): New function.\n+\t(get_adjustment_for_base): New function.\n+\t(replace_removed_params_ssa_names): New function.\n+\t(sra_ipa_reset_debug_stmts): New function.\n+\t(sra_ipa_modify_expr): New function.\n+\t(sra_ipa_modify_assign): New function.\n+\t(convert_callers): New function.\n+\t(modify_function): New function.\n+\t(ipa_sra_preliminary_function_checks): New function.\n+\t(ipa_early_sra): New function.\n+\t(ipa_early_sra_gate): New function.\n+\t(pass_early_ipa_sra): New variable.\n+\t* Makefile.in (tree-sra.o): Add cgraph.h to dependencies.\n+\t\n 2009-09-17  Michael Matz  <matz@suse.de>\n \n \tPR middle-end/41347"}, {"sha": "7c0a2355482738d298251a45dffbc6198c9b7bff", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -2891,8 +2891,9 @@ tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(TREE_DUMP_H) $(BASIC_BLOCK_H) $(TREE_PASS_H) langhooks.h \\\n    tree-ssa-propagate.h value-prof.h $(FLAGS_H) $(TARGET_H) $(TOPLEV_H)\n tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) coretypes.h alloc-pool.h \\\n-   $(TM_H) $(TREE_H) $(GIMPLE_H) $(TREE_FLOW_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n-   statistics.h $(TREE_DUMP_H) $(TIMEVAR_H) $(PARAMS_H) $(TARGET_H) $(FLAGS_H)\n+   $(TM_H) $(TREE_H) $(GIMPLE_H) $(CGRAPH_H) $(TREE_FLOW_H) $(IPA_PROP_H) \\\n+   $(DIAGNOSTIC_H) statistics.h $(TREE_DUMP_H) $(TIMEVAR_H) $(PARAMS_H) \\\n+   $(TARGET_H) $(FLAGS_H)\n tree-switch-conversion.o : tree-switch-conversion.c $(CONFIG_H) $(SYSTEM_H) \\\n     $(TREE_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \\\n     $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(GIMPLE_H) \\"}, {"sha": "0befadd9d254c9cdb638944df95b5b954636754a", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -486,6 +486,10 @@ feliminate-dwarf2-dups\n Common Report Var(flag_eliminate_dwarf2_dups)\n Perform DWARF2 duplicate elimination\n \n+fipa-sra\n+Common Report Var(flag_ipa_sra) Init(0) Optimization\n+Perform interprocedural reduction of aggregates\n+\n feliminate-unused-debug-symbols\n Common Report Var(flag_debug_only_used_symbols)\n Perform unused type elimination in debug info"}, {"sha": "5a96820ba14d5ae2c28cf9ef22b5088025bac6a2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -335,7 +335,7 @@ Objective-C and Objective-C++ Dialects}.\n -fcse-follow-jumps -fcse-skip-blocks -fcx-fortran-rules -fcx-limited-range @gol\n -fdata-sections -fdce -fdce @gol\n -fdelayed-branch -fdelete-null-pointer-checks -fdse -fdse @gol\n--fearly-inlining -fexpensive-optimizations -ffast-math @gol\n+-fearly-inlining -fipa-sra -fexpensive-optimizations -ffast-math @gol\n -ffinite-math-only -ffloat-store -fexcess-precision=@var{style} @gol\n -fforward-propagate -ffunction-sections @gol\n -fgcse -fgcse-after-reload -fgcse-las -fgcse-lm @gol\n@@ -5659,6 +5659,7 @@ also turns on the following optimization flags:\n -fgcse  -fgcse-lm  @gol\n -finline-small-functions @gol\n -findirect-inlining @gol\n+-fipa-sra @gol\n -foptimize-sibling-calls @gol\n -fpeephole2 @gol\n -fregmove @gol\n@@ -5819,6 +5820,14 @@ having large chains of nested wrapper functions.\n \n Enabled by default.\n \n+@item -fipa-sra\n+@opindex fipa-sra\n+Perform interprocedural scalar replacement of aggregates, removal of\n+unused parameters and replacement of parameters passed by reference\n+by parameters passed by value.\n+\n+Enabled at levels @option{-O2}, @option{-O3} and @option{-Os}.\n+\n @item -finline-limit=@var{n}\n @opindex finline-limit\n By default, GCC limits the size of functions that can be inlined.  This flag\n@@ -8127,6 +8136,12 @@ the parameter is reserved exclusively for debug insns created by\n @option{-fvar-tracking-assignments}, but debug insns may get\n (non-overlapping) uids above it if the reserved range is exhausted.\n \n+@item ipa-sra-ptr-growth-factor\n+IPA-SRA will replace a pointer to an aggregate with one or more new\n+parameters only when their cumulative size is less or equal to\n+@option{ipa-sra-ptr-growth-factor} times the size of the original\n+pointer parameter.\n+\n @end table\n @end table\n "}, {"sha": "cf49ef8f36c57d8429af0ee94a26014c753bdbea", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -898,6 +898,7 @@ decode_options (unsigned int argc, const char **argv)\n   flag_tree_pre = opt2;\n   flag_tree_switch_conversion = 1;\n   flag_ipa_cp = opt2;\n+  flag_ipa_sra = opt2;\n \n   /* Track fields in field-sensitive alias analysis.  */\n   set_param_value (\"max-fields-for-field-sensitive\","}, {"sha": "051398573e69aa8fe773c95a7b16c990563314ed", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -759,6 +759,12 @@ DEFPARAM (PARAM_MIN_NONDEBUG_INSN_UID,\n \t  \"The minimum UID to be used for a nondebug insn\",\n \t  0, 1, 0)\n \n+DEFPARAM (PARAM_IPA_SRA_PTR_GROWTH_FACTOR,\n+\t  \"ipa-sra-ptr-growth-factor\",\n+\t  \"maximum allowed growth of size of new parameters ipa-sra replaces \"\n+\t  \"a pointer to an aggregate with\",\n+\t  2, 0, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "abfa04b912779885f3df68bc910397778029bb42", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -566,6 +566,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_copy_prop);\n \t  NEXT_PASS (pass_merge_phi);\n \t  NEXT_PASS (pass_cd_dce);\n+\t  NEXT_PASS (pass_early_ipa_sra);\n \t  NEXT_PASS (pass_tail_recursion);\n \t  NEXT_PASS (pass_convert_switch);\n           NEXT_PASS (pass_cleanup_eh);"}, {"sha": "5245de8199b88479b338cb2cd3d6f7dcfae162d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -1,3 +1,14 @@\n+2009-09-17  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/struct/wo_prof_escape_arg_to_local.c: Do not run IPA-SRA.\n+\t* gcc.dg/ipa/ipa-sra-1.c: New test.\n+\t* gcc.dg/ipa/ipa-sra-2.c: New test.\n+\t* gcc.dg/ipa/ipa-sra-3.c: New test.\n+\t* gcc.dg/ipa/ipa-sra-4.c: New test.\n+\t* gcc.dg/ipa/ipa-sra-5.c: New test.\n+\t* gcc.c-torture/execute/ipa-sra-1.c: New test.\n+\t* gcc.c-torture/execute/ipa-sra-2.c: New test.\n+\n 2009-09-17  Michael Matz  <matz@suse.de>\n \n \tPR middle-end/41347"}, {"sha": "777ed2a83d9f0a21407b718cd3bef364bd8b2b12", "filename": "gcc/testsuite/gcc.c-torture/execute/ipa-sra-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fipa-sra-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fipa-sra-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fipa-sra-1.c?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -0,0 +1,29 @@\n+/* Trivially making sure IPA-SRA does not introduce segfaults where they should\n+   not be.  */\n+\n+struct bovid\n+{\n+  float red;\n+  int green;\n+  void *blue;\n+};\n+\n+static int\n+__attribute__((noinline))\n+ox (int fail, struct bovid *cow)\n+{\n+  int r;\n+  if (fail)\n+    r = cow->red;\n+  else\n+    r = 0;\n+  return r;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int r;\n+\n+  r = ox ((argc > 2000), (void *) 0);\n+  return r;\n+}"}, {"sha": "9d5ae440975a56938aa7ac70960c26ab4d50d747", "filename": "gcc/testsuite/gcc.c-torture/execute/ipa-sra-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fipa-sra-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fipa-sra-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fipa-sra-2.c?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -0,0 +1,41 @@\n+struct big\n+{\n+  int data[1000000];\n+};\n+\n+struct small\n+{\n+  int data[10];\n+};\n+\n+union both\n+{\n+  struct big big;\n+  struct small small;\n+};\n+\n+extern void *malloc(__SIZE_TYPE__);\n+extern void free (void *);\n+\n+static int\n+__attribute__((noinline))\n+foo (int fail, union both *agg)\n+{\n+  int r;\n+  if (fail)\n+    r = agg->big.data[999999];\n+  else\n+    r = agg->small.data[0];\n+  return r;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  union both *agg = malloc (sizeof (struct small));\n+  int r;\n+\n+  r = foo ((argc > 2000), agg);\n+\n+  free (agg);\n+  return r;\n+}"}, {"sha": "2dea78ddd1cec668892d331e558887f768bdbb7b", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-1.c?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-eipa_sra-details\"  } */\n+\n+struct bovid\n+{\n+  float red;\n+  int green;\n+  void *blue;\n+};\n+\n+extern int printf (const char *, ...);\n+extern void abort (void);\n+\n+static int\n+__attribute__((noinline))\n+ox (struct bovid cow)\n+{\n+  if (cow.green != 6)\n+    abort ();\n+\n+  printf (\"green: %f\\nblue: %p\\nblue again: %p\\n\", cow.green,\n+\t  cow.blue, cow.blue);\n+  return 0;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  struct bovid cow;\n+\n+  cow.red = 7.4;\n+  cow.green = 6;\n+  cow.blue = &cow;\n+\n+  ox (cow);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"About to replace expr cow.green with ISRA\" \"eipa_sra\"  } } */\n+/* { dg-final { scan-tree-dump \"About to replace expr cow.blue with ISRA\" \"eipa_sra\"  } } */\n+/* { dg-final { cleanup-tree-dump \"eipa_sra\" } } */"}, {"sha": "0e3820156866d5aea5f9711304287cfebe420c18", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-2.c?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-eipa_sra-details\"  } */\n+\n+struct bovid\n+{\n+  float red;\n+  int green;\n+  void *blue;\n+};\n+\n+static int\n+__attribute__((noinline))\n+ox (struct bovid *cow)\n+{\n+  cow->red = cow->red + cow->green + cow->green;\n+  return 0;\n+}\n+\n+int something;\n+\n+static int\n+__attribute__((noinline))\n+ox_improved (struct bovid *calf)\n+{\n+  if (something > 0)\n+    calf->red = calf->red + calf->green;\n+  else\n+    calf->red = calf->green + 87;\n+  something = 77;\n+  return 0;\n+}\n+\n+\n+int main (int argc, char *argv[])\n+{\n+  struct bovid cow;\n+\n+  cow.red = 7.4;\n+  cow.green = 6;\n+  cow.blue = &cow;\n+\n+  ox (&cow);\n+\n+  ox_improved (&cow);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"About to replace expr cow_.*D.->red with \\\\*ISRA\" \"eipa_sra\"  } } */\n+/* { dg-final { scan-tree-dump \"About to replace expr cow_.*D.->green with ISRA\" \"eipa_sra\"  } } */\n+/* { dg-final { scan-tree-dump \"About to replace expr calf_.*D.->red with \\\\*ISRA\" \"eipa_sra\"  } } */\n+/* { dg-final { scan-tree-dump \"About to replace expr calf_.*D.->green with ISRA\" \"eipa_sra\"  } } */\n+/* { dg-final { cleanup-tree-dump \"eipa_sra\" } } */"}, {"sha": "f4e91bbe563bdad01d7ed7b2493e310fb4d2a473", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-3.c?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-eipa_sra-details\" } */\n+\n+struct bovid\n+{\n+  float red;\n+  int green;\n+  void *blue;\n+};\n+\n+extern void foo (float, void *, void *, long);\n+\n+static int\n+__attribute__((noinline))\n+ox (struct bovid cow, int z, struct bovid calf, long l)\n+{\n+  foo (cow.red, cow.blue, cow.blue, l);\n+  return 0;\n+}\n+\n+void caller (void)\n+{\n+  struct bovid cow, calf;\n+\n+  cow.red = 7.4;\n+  cow.green = 6;\n+  cow.blue = &cow;\n+\n+  calf.red = 8.4;\n+  calf.green = 5;\n+  calf.blue = &cow;\n+\n+  ox (cow,4,calf,2);\n+  return;\n+}\n+\n+/* { dg-final { scan-tree-dump \"base: z, remove_param\" \"eipa_sra\"  } } */\n+/* { dg-final { scan-tree-dump \"base: calf, remove_param\" \"eipa_sra\"  } } */\n+/* { dg-final { cleanup-tree-dump \"eipa_sra\" } } */"}, {"sha": "a832329b6ae0c09b3bf461de00a957d598ff931b", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-4.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-4.c?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-eipa_sra-details\" } */\n+\n+static int\n+__attribute__((noinline))\n+ox (int *i)\n+{\n+  return *i+4**i;\n+}\n+\n+int *holder;\n+\n+static int\n+__attribute__((noinline))\n+ox_ctrl_1 (int *j)\n+{\n+  holder = j;\n+  return *j+4 * *j+1;\n+}\n+\n+static void\n+__attribute__((noinline))\n+ox_ctrl_2 (int *k)\n+{\n+  *k = 8;\n+}\n+\n+static int zzz[10];\n+\n+static int\n+__attribute__((noinline))\n+ox_improved (int recurse, int *l)\n+{\n+  int r = 0;\n+\n+  r = *l;\n+\n+  if (recurse)\n+    {\n+      if (recurse > 2)\n+\tl = &zzz[3];\n+      else\n+\tl = zzz;\n+\n+      ox_improved (0, l);\n+    }\n+\n+  return r;\n+}\n+\n+void caller (void)\n+{\n+  int a = 1;\n+  int b = 10;\n+  int c;\n+\n+  ox (&a);\n+  ox_ctrl_1 (&a);\n+  ox_ctrl_2 (&a);\n+  *holder = ox_improved (1, &b);\n+  return;\n+}\n+\n+/* { dg-final { scan-tree-dump \"About to replace expr \\\\*i_.*D. with ISRA\" \"eipa_sra\"  } } */\n+/* { dg-final { scan-tree-dump \"About to replace expr \\\\*l_.*D. with ISRA\" \"eipa_sra\"  } } */\n+/* { dg-final { scan-tree-dump-times \"About to replace expr \\*j_.*D. with ISRA\" 0 \"eipa_sra\"  } } */\n+/* { dg-final { scan-tree-dump-times \"About to replace expr \\*k_.*D. with ISRA\" 0 \"eipa_sra\"  } } */\n+/* { dg-final { cleanup-tree-dump \"eipa_sra\" } } */"}, {"sha": "317e9b5aedd0a5e28ed2ce525fc6e01dc28b9823", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-5.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-5.c?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-eipa_sra-details\" } */\n+\n+static int *\n+__attribute__((noinline,used))\n+  ox (int *i, int *j)\n+{\n+  return i;\n+}\n+\n+int a;\n+\n+int *caller (void)\n+{\n+  int b = 10;\n+\n+  return ox (&a, &b);\n+}\n+/* { dg-final { scan-tree-dump-times \"base: j, remove_param\" 0 \"eipa_sra\"  } } */\n+/* { dg-final { cleanup-tree-dump \"eipa_sra\" } } */"}, {"sha": "29630252e00acb2d6e547e1cf1f65363a5400a4c", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_arg_to_local.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_arg_to_local.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_arg_to_local.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_arg_to_local.c?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O3 -fno-inline -fipa-type-escape -fdump-ipa-all -fipa-struct-reorg -fwhole-program -combine\" } */\n+/* { dg-options \"-O3 -fno-inline -fno-ipa-sra -fipa-type-escape -fdump-ipa-all -fipa-struct-reorg -fwhole-program -combine\" } */\n /* { dg-do compile } */\n /* { dg-do run } */\n "}, {"sha": "92f280d4a73d3cac40e4ed7e6bdb50fb5dcb5873", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -46,6 +46,7 @@ DEFTIMEVAR (TV_IPA_REFERENCE         , \"ipa reference\")\n DEFTIMEVAR (TV_IPA_PURE_CONST        , \"ipa pure const\")\n DEFTIMEVAR (TV_IPA_TYPE_ESCAPE       , \"ipa type escape\")\n DEFTIMEVAR (TV_IPA_PTA               , \"ipa points-to\")\n+DEFTIMEVAR (TV_IPA_SRA               , \"ipa SRA\")\n DEFTIMEVAR (TV_IPA_FREE_LANG_DATA    , \"ipa free lang data\")\n /* Time spent by constructing CFG.  */\n DEFTIMEVAR (TV_CFG                   , \"cfg construction\")"}, {"sha": "97f1d340a1577aa566bcce6202e5165c4e3d791e", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -327,6 +327,7 @@ extern struct gimple_opt_pass pass_cleanup_eh;\n extern struct gimple_opt_pass pass_fixup_cfg;\n extern struct gimple_opt_pass pass_sra;\n extern struct gimple_opt_pass pass_sra_early;\n+extern struct gimple_opt_pass pass_early_ipa_sra;\n extern struct gimple_opt_pass pass_tail_recursion;\n extern struct gimple_opt_pass pass_tail_calls;\n extern struct gimple_opt_pass pass_tree_loop;"}, {"sha": "92dab57a2f8582b3c61e23cdd60c74b0bd2dbe89", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1401, "deletions": 37, "changes": 1438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ffa034dd509e6838f565d51ee8b25292f79d1a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=07ffa034dd509e6838f565d51ee8b25292f79d1a", "patch": "@@ -78,6 +78,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n+#include \"cgraph.h\"\n #include \"tree-flow.h\"\n #include \"ipa-prop.h\"\n #include \"diagnostic.h\"\n@@ -89,8 +90,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n \n /* Enumeration of all aggregate reductions we can do.  */\n-enum sra_mode { SRA_MODE_EARLY_INTRA, /* early intraprocedural SRA */\n-\t\tSRA_MODE_INTRA };\t     /* late intraprocedural SRA */\n+enum sra_mode { SRA_MODE_EARLY_IPA,   /* early call regularization */\n+\t\tSRA_MODE_EARLY_INTRA, /* early intraprocedural SRA */\n+\t\tSRA_MODE_INTRA };     /* late intraprocedural SRA */\n \n /* Global variable describing which aggregate reduction we are performing at\n    the moment.  */\n@@ -128,6 +130,9 @@ struct access\n   /* Type.  */\n   tree type;\n \n+  /* The statement this access belongs to.  */\n+  gimple stmt;\n+\n   /* Next group representative for this aggregate. */\n   struct access *next_grp;\n \n@@ -159,26 +164,33 @@ struct access\n \n   /* Is this access currently in the work queue?  */\n   unsigned grp_queued : 1;\n+\n   /* Does this group contain a write access?  This flag is propagated down the\n      access tree.  */\n   unsigned grp_write : 1;\n+\n   /* Does this group contain a read access?  This flag is propagated down the\n      access tree.  */\n   unsigned grp_read : 1;\n+\n   /* Other passes of the analysis use this bit to make function\n      analyze_access_subtree create scalar replacements for this group if\n      possible.  */\n   unsigned grp_hint : 1;\n+\n   /* Is the subtree rooted in this access fully covered by scalar\n      replacements?  */\n   unsigned grp_covered : 1;\n+\n   /* If set to true, this access and all below it in an access tree must not be\n      scalarized.  */\n   unsigned grp_unscalarizable_region : 1;\n+\n   /* Whether data have been written to parts of the aggregate covered by this\n      access which is not to be scalarized.  This flag is propagated up in the\n      access tree.  */\n   unsigned grp_unscalarized_data : 1;\n+\n   /* Does this access and/or group contain a write access through a\n      BIT_FIELD_REF?  */\n   unsigned grp_partial_lhs : 1;\n@@ -187,6 +199,19 @@ struct access\n      the decision and creation at different places because create_tmp_var\n      cannot be called from within FOR_EACH_REFERENCED_VAR. */\n   unsigned grp_to_be_replaced : 1;\n+\n+  /* Is it possible that the group refers to data which might be (directly or\n+     otherwise) modified?  */\n+  unsigned grp_maybe_modified : 1;\n+\n+  /* Set when this is a representative of a pointer to scalar (i.e. by\n+     reference) parameter which we consider for turning into a plain scalar\n+     (i.e. a by value parameter).  */\n+  unsigned grp_scalar_ptr : 1;\n+\n+  /* Set when we discover that this pointer is not safe to dereference in the\n+     caller.  */\n+  unsigned grp_not_necessarilly_dereferenced : 1;\n };\n \n typedef struct access *access_p;\n@@ -212,21 +237,52 @@ static alloc_pool link_pool;\n /* Base (tree) -> Vector (VEC(access_p,heap) *) map.  */\n static struct pointer_map_t *base_access_vec;\n \n-/* Bitmap of bases (candidates).  */\n+/* Bitmap of candidates.  */\n static bitmap candidate_bitmap;\n+\n /* Obstack for creation of fancy names.  */\n static struct obstack name_obstack;\n \n /* Head of a linked list of accesses that need to have its subaccesses\n    propagated to their assignment counterparts. */\n static struct access *work_queue_head;\n \n+/* Number of parameters of the analyzed function when doing early ipa SRA.  */\n+static int func_param_count;\n+\n+/* scan_function sets the following to true if it encounters a call to\n+   __builtin_apply_args.  */\n+static bool encountered_apply_args;\n+\n+/* This is a table in which for each basic block and parameter there is a\n+   distance (offset + size) in that parameter which is dereferenced and\n+   accessed in that BB.  */\n+static HOST_WIDE_INT *bb_dereferences;\n+/* Bitmap of BBs that can cause the function to \"stop\" progressing by\n+   returning, throwing externally, looping infinitely or calling a function\n+   which might abort etc.. */\n+static bitmap final_bbs;\n+\n+/* Representative of no accesses at all. */\n+static struct access  no_accesses_representant;\n+\n+/* Predicate to test the special value.  */\n+\n+static inline bool\n+no_accesses_p (struct access *access)\n+{\n+  return access == &no_accesses_representant;\n+}\n+\n /* Dump contents of ACCESS to file F in a human friendly way.  If GRP is true,\n    representative fields are dumped, otherwise those which only describe the\n    individual access are.  */\n \n static struct\n {\n+  /* Number of processed aggregates is readily available in\n+     analyze_all_variable_accesses and so is not stored here.  */\n+\n   /* Number of created scalar replacements.  */\n   int replacements;\n \n@@ -248,8 +304,19 @@ static struct\n      references.  */\n   int separate_lhs_rhs_handling;\n \n-  /* Number of processed aggregates is readily available in\n-     analyze_all_variable_accesses and so is not stored here.  */\n+  /* Number of parameters that were removed because they were unused.  */\n+  int deleted_unused_parameters;\n+\n+  /* Number of scalars passed as parameters by reference that have been\n+     converted to be passed by value.  */\n+  int scalar_by_ref_to_by_val;\n+\n+  /* Number of aggregate parameters that were replaced by one or more of their\n+     components.  */\n+  int aggregate_params_reduced;\n+\n+  /* Numbber of components created when splitting aggregate parameters.  */\n+  int param_reductions_created;\n } sra_stats;\n \n static void\n@@ -268,11 +335,13 @@ dump_access (FILE *f, struct access *access, bool grp)\n     fprintf (f, \", grp_write = %d, grp_read = %d, grp_hint = %d, \"\n \t     \"grp_covered = %d, grp_unscalarizable_region = %d, \"\n \t     \"grp_unscalarized_data = %d, grp_partial_lhs = %d, \"\n-\t     \"grp_to_be_replaced = %d\\n\",\n+\t     \"grp_to_be_replaced = %d\\n grp_maybe_modified = %d, \"\n+\t     \"grp_not_necessarilly_dereferenced = %d\\n\",\n \t     access->grp_write, access->grp_read, access->grp_hint,\n \t     access->grp_covered, access->grp_unscalarizable_region,\n \t     access->grp_unscalarized_data, access->grp_partial_lhs,\n-\t     access->grp_to_be_replaced);\n+\t     access->grp_to_be_replaced, access->grp_maybe_modified,\n+\t     access->grp_not_necessarilly_dereferenced);\n   else\n     fprintf (f, \", write = %d, grp_partial_lhs = %d\\n\", access->write,\n \t     access->grp_partial_lhs);\n@@ -471,6 +540,7 @@ sra_initialize (void)\n   link_pool = create_alloc_pool (\"SRA links\", sizeof (struct assign_link), 16);\n   base_access_vec = pointer_map_create ();\n   memset (&sra_stats, 0, sizeof (sra_stats));\n+  encountered_apply_args = false;\n }\n \n /* Hook fed to pointer_map_traverse, deallocate stored vectors.  */\n@@ -560,34 +630,105 @@ type_internals_preclude_sra_p (tree type)\n     }\n }\n \n+/* If T is an SSA_NAME, return NULL if it is not a default def or return its\n+   base variable if it is.  Return T if it is not an SSA_NAME.  */\n+\n+static tree\n+get_ssa_base_param (tree t)\n+{\n+  if (TREE_CODE (t) == SSA_NAME)\n+    {\n+      if (SSA_NAME_IS_DEFAULT_DEF (t))\n+\treturn SSA_NAME_VAR (t);\n+      else\n+\treturn NULL_TREE;\n+    }\n+  return t;\n+}\n+\n+/* Mark a dereference of BASE of distance DIST in a basic block tht STMT\n+   belongs to, unless the BB has already been marked as a potentially\n+   final.  */\n+\n+static void\n+mark_parm_dereference (tree base, HOST_WIDE_INT dist, gimple stmt)\n+{\n+  basic_block bb = gimple_bb (stmt);\n+  int idx, parm_index = 0;\n+  tree parm;\n+\n+  if (bitmap_bit_p (final_bbs, bb->index))\n+    return;\n+\n+  for (parm = DECL_ARGUMENTS (current_function_decl);\n+       parm && parm != base;\n+       parm = TREE_CHAIN (parm))\n+    parm_index++;\n+\n+  gcc_assert (parm_index < func_param_count);\n+\n+  idx = bb->index * func_param_count + parm_index;\n+  if (bb_dereferences[idx] < dist)\n+    bb_dereferences[idx] = dist;\n+}\n+\n /* Create and insert access for EXPR. Return created access, or NULL if it is\n    not possible.  */\n \n static struct access *\n-create_access (tree expr, bool write)\n+create_access (tree expr, gimple stmt, bool write)\n {\n   struct access *access;\n   void **slot;\n   VEC (access_p,heap) *vec;\n   HOST_WIDE_INT offset, size, max_size;\n   tree base = expr;\n-  bool unscalarizable_region = false;\n+  bool ptr, unscalarizable_region = false;\n \n   base = get_ref_base_and_extent (expr, &offset, &size, &max_size);\n \n+  if (sra_mode == SRA_MODE_EARLY_IPA && INDIRECT_REF_P (base))\n+    {\n+      base = get_ssa_base_param (TREE_OPERAND (base, 0));\n+      if (!base)\n+\treturn NULL;\n+      ptr = true;\n+    }\n+  else\n+    ptr = false;\n+\n   if (!DECL_P (base) || !bitmap_bit_p (candidate_bitmap, DECL_UID (base)))\n     return NULL;\n \n-  if (size != max_size)\n+  if (sra_mode == SRA_MODE_EARLY_IPA)\n     {\n-      size = max_size;\n-      unscalarizable_region = true;\n-    }\n+      if (size < 0 || size != max_size)\n+\t{\n+\t  disqualify_candidate (base, \"Encountered a variable sized access.\");\n+\t  return NULL;\n+\t}\n+      if ((offset % BITS_PER_UNIT) != 0 || (size % BITS_PER_UNIT) != 0)\n+\t{\n+\t  disqualify_candidate (base,\n+\t\t\t\t\"Encountered an acces not aligned to a byte.\");\n+\t  return NULL;\n+\t}\n \n-  if (size < 0)\n+      if (ptr)\n+\tmark_parm_dereference (base, offset + size, stmt);\n+    }\n+  else\n     {\n-      disqualify_candidate (base, \"Encountered an unconstrained access.\");\n-      return NULL;\n+      if (size != max_size)\n+\t{\n+\t  size = max_size;\n+\t  unscalarizable_region = true;\n+\t}\n+      if (size < 0)\n+\t{\n+\t  disqualify_candidate (base, \"Encountered an unconstrained access.\");\n+\t  return NULL;\n+\t}\n     }\n \n   access = (struct access *) pool_alloc (access_pool);\n@@ -600,6 +741,7 @@ create_access (tree expr, bool write)\n   access->type = TREE_TYPE (expr);\n   access->write = write;\n   access->grp_unscalarizable_region = unscalarizable_region;\n+  access->stmt = stmt;\n \n   slot = pointer_map_contains (base_access_vec, base);\n   if (slot)\n@@ -625,7 +767,14 @@ disqualify_base_of_expr (tree t, const char *reason)\n   while (handled_component_p (t))\n     t = TREE_OPERAND (t, 0);\n \n-  if (DECL_P (t))\n+  if (sra_mode == SRA_MODE_EARLY_IPA)\n+    {\n+      if (INDIRECT_REF_P (t))\n+\tt = TREE_OPERAND (t, 0);\n+      t = get_ssa_base_param (t);\n+    }\n+\n+  if (t && DECL_P (t))\n     disqualify_candidate (t, reason);\n }\n \n@@ -634,7 +783,7 @@ disqualify_base_of_expr (tree t, const char *reason)\n    created.  */\n \n static struct access *\n-build_access_from_expr_1 (tree *expr_ptr, bool write)\n+build_access_from_expr_1 (tree *expr_ptr, gimple stmt, bool write)\n {\n   struct access *ret = NULL;\n   tree expr = *expr_ptr;\n@@ -666,13 +815,17 @@ build_access_from_expr_1 (tree *expr_ptr, bool write)\n \n   switch (TREE_CODE (expr))\n     {\n+    case INDIRECT_REF:\n+      if (sra_mode != SRA_MODE_EARLY_IPA)\n+\treturn NULL;\n+      /* fall through */\n     case VAR_DECL:\n     case PARM_DECL:\n     case RESULT_DECL:\n     case COMPONENT_REF:\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n-      ret = create_access (expr, write);\n+      ret = create_access (expr, stmt, write);\n       break;\n \n     default:\n@@ -694,7 +847,7 @@ build_access_from_expr (tree *expr_ptr,\n \t\t\tgimple_stmt_iterator *gsi ATTRIBUTE_UNUSED, bool write,\n \t\t\tvoid *data ATTRIBUTE_UNUSED)\n {\n-  return build_access_from_expr_1 (expr_ptr, write) != NULL;\n+  return build_access_from_expr_1 (expr_ptr, gsi_stmt (*gsi), write) != NULL;\n }\n \n /* Disqualify LHS and RHS for scalarization if STMT must end its basic block in\n@@ -705,7 +858,8 @@ build_access_from_expr (tree *expr_ptr,\n static bool\n disqualify_ops_if_throwing_stmt (gimple stmt, tree lhs, tree rhs)\n {\n-  if (stmt_can_throw_internal (stmt) || stmt_ends_bb_p (stmt))\n+  if ((sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA)\n+      && (stmt_can_throw_internal (stmt) || stmt_ends_bb_p (stmt)))\n     {\n       disqualify_base_of_expr (lhs, \"LHS of a throwing stmt.\");\n       if (rhs)\n@@ -746,10 +900,11 @@ build_accesses_from_assign (gimple *stmt_ptr,\n   if (disqualify_ops_if_throwing_stmt (stmt, *lhs_ptr, *rhs_ptr))\n     return SRA_SA_NONE;\n \n-  racc = build_access_from_expr_1 (rhs_ptr, false);\n-  lacc = build_access_from_expr_1 (lhs_ptr, true);\n+  racc = build_access_from_expr_1 (rhs_ptr, stmt, false);\n+  lacc = build_access_from_expr_1 (lhs_ptr, stmt, true);\n \n   if (lacc && racc\n+      && (sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA)\n       && !lacc->grp_unscalarizable_region\n       && !racc->grp_unscalarizable_region\n       && AGGREGATE_TYPE_P (TREE_TYPE (*lhs_ptr))\n@@ -792,12 +947,11 @@ asm_visit_addr (gimple stmt ATTRIBUTE_UNUSED, tree op,\n    those deemed entirely unsuitable for some reason (all operands in such\n    statements and expression are removed from candidate_bitmap).  SCAN_ASSIGN\n    is a callback called on all assign statements, HANDLE_SSA_DEFS is a callback\n-   called on assign statements and those call statements which have a lhs and\n-   it is the only callback which can be NULL. ANALYSIS_STAGE is true when\n-   running in the analysis stage of a pass and thus no statement is being\n-   modified.  DATA is a pointer passed to all callbacks.  If any single\n-   callback returns true, this function also returns true, otherwise it returns\n-   false.  */\n+   called on assign statements and those call statements which have a lhs, it\n+   can be NULL.  ANALYSIS_STAGE is true when running in the analysis stage of a\n+   pass and thus no statement is being modified.  DATA is a pointer passed to\n+   all callbacks.  If any single callback returns true, this function also\n+   returns true, otherwise it returns false.  */\n \n static bool\n scan_function (bool (*scan_expr) (tree *, gimple_stmt_iterator *, bool, void *),\n@@ -817,19 +971,27 @@ scan_function (bool (*scan_expr) (tree *, gimple_stmt_iterator *, bool, void *),\n     {\n       bool bb_changed = false;\n \n+      if (handle_ssa_defs)\n+\tfor (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  ret |= handle_ssa_defs (gsi_stmt (gsi), data);\n+\n       gsi = gsi_start_bb (bb);\n       while (!gsi_end_p (gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n \t  enum scan_assign_result assign_result;\n \t  bool any = false, deleted = false;\n \n+\t  if (analysis_stage && final_bbs && stmt_can_throw_external (stmt))\n+\t    bitmap_set_bit (final_bbs, bb->index);\n \t  switch (gimple_code (stmt))\n \t    {\n \t    case GIMPLE_RETURN:\n \t      t = gimple_return_retval_ptr (stmt);\n \t      if (*t != NULL_TREE)\n \t\tany |= scan_expr (t, &gsi, false, data);\n+\t      if (analysis_stage && final_bbs)\n+\t\tbitmap_set_bit (final_bbs, bb->index);\n \t      break;\n \n \t    case GIMPLE_ASSIGN:\n@@ -848,6 +1010,21 @@ scan_function (bool (*scan_expr) (tree *, gimple_stmt_iterator *, bool, void *),\n \t\t  any |= scan_expr (argp, &gsi, false, data);\n \t\t}\n \n+\t      if (analysis_stage)\n+\t\t{\n+\t\t  tree dest = gimple_call_fndecl (stmt);\n+\t\t  int flags = gimple_call_flags (stmt);\n+\n+\t\t  if (dest\n+\t\t      && DECL_BUILT_IN_CLASS (dest) == BUILT_IN_NORMAL\n+\t\t      && DECL_FUNCTION_CODE (dest) == BUILT_IN_APPLY_ARGS)\n+\t\t    encountered_apply_args = true;\n+\n+\t\t  if (final_bbs\n+\t\t      && (flags & (ECF_CONST | ECF_PURE)) == 0)\n+\t\t    bitmap_set_bit (final_bbs, bb->index);\n+\t\t}\n+\n \t      if (gimple_call_lhs (stmt))\n \t\t{\n \t\t  tree *lhs_ptr = gimple_call_lhs_ptr (stmt);\n@@ -863,10 +1040,13 @@ scan_function (bool (*scan_expr) (tree *, gimple_stmt_iterator *, bool, void *),\n \t      break;\n \n \t    case GIMPLE_ASM:\n-\n \t      if (analysis_stage)\n-\t\twalk_stmt_load_store_addr_ops (stmt, NULL, NULL, NULL,\n-\t\t\t\t\t       asm_visit_addr);\n+\t\t{\n+\t\t  walk_stmt_load_store_addr_ops (stmt, NULL, NULL, NULL,\n+\t\t\t\t\t\t asm_visit_addr);\n+\t\t  if (final_bbs)\n+\t\t    bitmap_set_bit (final_bbs, bb->index);\n+\t\t}\n \t      for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n \t\t{\n \t\t  tree *op = &TREE_VALUE (gimple_asm_input_op (stmt, i));\n@@ -877,6 +1057,7 @@ scan_function (bool (*scan_expr) (tree *, gimple_stmt_iterator *, bool, void *),\n \t\t  tree *op = &TREE_VALUE (gimple_asm_output_op (stmt, i));\n \t\t  any |= scan_expr (op, &gsi, true, data);\n \t\t}\n+\t      break;\n \n \t    default:\n \t      break;\n@@ -885,10 +1066,10 @@ scan_function (bool (*scan_expr) (tree *, gimple_stmt_iterator *, bool, void *),\n \t  if (any)\n \t    {\n \t      ret = true;\n-\t      bb_changed = true;\n \n \t      if (!analysis_stage)\n \t\t{\n+\t\t  bb_changed = true;\n \t\t  update_stmt (stmt);\n \t\t  maybe_clean_eh_stmt (stmt);\n \t\t}\n@@ -901,7 +1082,7 @@ scan_function (bool (*scan_expr) (tree *, gimple_stmt_iterator *, bool, void *),\n \t      ret = true;\n \t    }\n \t}\n-      if (!analysis_stage && bb_changed)\n+      if (!analysis_stage && bb_changed && sra_mode == SRA_MODE_EARLY_IPA)\n \tgimple_purge_dead_eh_edges (bb);\n     }\n \n@@ -2372,8 +2553,7 @@ perform_intra_sra (void)\n   if (!analyze_all_variable_accesses ())\n     goto out;\n \n-  scan_function (sra_modify_expr, sra_modify_assign, NULL,\n-\t\t false, NULL);\n+  scan_function (sra_modify_expr, sra_modify_assign, NULL, false, NULL);\n   initialize_parameter_reductions ();\n \n   statistics_counter_event (cfun, \"Scalar replacements created\",\n@@ -2440,7 +2620,6 @@ struct gimple_opt_pass pass_sra_early =\n  }\n };\n \n-\n struct gimple_opt_pass pass_sra =\n {\n  {\n@@ -2462,3 +2641,1188 @@ struct gimple_opt_pass pass_sra =\n   | TODO_verify_ssa\t\t\t/* todo_flags_finish */\n  }\n };\n+\n+\n+/* Return true iff PARM (which must be a parm_decl) is an unused scalar\n+   parameter.  */\n+\n+static bool\n+is_unused_scalar_param (tree parm)\n+{\n+  tree name;\n+  return (is_gimple_reg (parm)\n+\t  && (!(name = gimple_default_def (cfun, parm))\n+\t      || has_zero_uses (name)));\n+}\n+\n+/* Scan immediate uses of a default definition SSA name of a parameter PARM and\n+   examine whether there are any direct or otherwise infeasible ones.  If so,\n+   return true, otherwise return false.  PARM must be a gimple register with a\n+   non-NULL default definition.  */\n+\n+static bool\n+ptr_parm_has_direct_uses (tree parm)\n+{\n+  imm_use_iterator ui;\n+  gimple stmt;\n+  tree name = gimple_default_def (cfun, parm);\n+  bool ret = false;\n+\n+  FOR_EACH_IMM_USE_STMT (stmt, ui, name)\n+    {\n+      if (gimple_assign_single_p (stmt))\n+\t{\n+\t  tree rhs = gimple_assign_rhs1 (stmt);\n+\t  if (rhs == name)\n+\t    ret = true;\n+\t  else if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  rhs = TREE_OPERAND (rhs, 0);\n+\t\t}\n+\t      while (handled_component_p (rhs));\n+\t      if (INDIRECT_REF_P (rhs) && TREE_OPERAND (rhs, 0) == name)\n+\t\tret = true;\n+\t    }\n+\t}\n+      else if (gimple_code (stmt) == GIMPLE_RETURN)\n+\t{\n+\t  tree t = gimple_return_retval (stmt);\n+\t  if (t == name)\n+\t    ret = true;\n+\t}\n+      else if (is_gimple_call (stmt))\n+\t{\n+\t  unsigned i;\n+\t  for (i = 0; i < gimple_call_num_args (stmt); i++)\n+\t    {\n+\t      tree arg = gimple_call_arg (stmt, i);\n+\t      if (arg == name)\n+\t\t{\n+\t\t  ret = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else if (!is_gimple_debug (stmt))\n+\tret = true;\n+\n+      if (ret)\n+\tBREAK_FROM_IMM_USE_STMT (ui);\n+    }\n+\n+  return ret;\n+}\n+\n+/* Identify candidates for reduction for IPA-SRA based on their type and mark\n+   them in candidate_bitmap.  Note that these do not necessarily include\n+   parameter which are unused and thus can be removed.  Return true iff any\n+   such candidate has been found.  */\n+\n+static bool\n+find_param_candidates (void)\n+{\n+  tree parm;\n+  int count = 0;\n+  bool ret = false;\n+\n+  for (parm = DECL_ARGUMENTS (current_function_decl);\n+       parm;\n+       parm = TREE_CHAIN (parm))\n+    {\n+      tree type;\n+\n+      count++;\n+      if (TREE_THIS_VOLATILE (parm)\n+\t  || TREE_ADDRESSABLE (parm))\n+\tcontinue;\n+\n+      if (is_unused_scalar_param (parm))\n+\t{\n+\t  ret = true;\n+\t  continue;\n+\t}\n+\n+      type = TREE_TYPE (parm);\n+      if (POINTER_TYPE_P (type))\n+\t{\n+\t  type = TREE_TYPE (type);\n+\n+\t  if (TREE_CODE (type) == FUNCTION_TYPE\n+\t      || TYPE_VOLATILE (type)\n+\t      || !is_gimple_reg (parm)\n+\t      || ptr_parm_has_direct_uses (parm))\n+\t    continue;\n+\t}\n+      else if (!AGGREGATE_TYPE_P (type))\n+\tcontinue;\n+\n+      if (!COMPLETE_TYPE_P (type)\n+\t  || !host_integerp (TYPE_SIZE (type), 1)\n+          || tree_low_cst (TYPE_SIZE (type), 1) == 0\n+\t  || (AGGREGATE_TYPE_P (type)\n+\t      && type_internals_preclude_sra_p (type)))\n+\tcontinue;\n+\n+      bitmap_set_bit (candidate_bitmap, DECL_UID (parm));\n+      ret = true;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Candidate (%d): \", DECL_UID (parm));\n+\t  print_generic_expr (dump_file, parm, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+\n+  func_param_count = count;\n+  return ret;\n+}\n+\n+/* Callback of walk_aliased_vdefs, marks the access passed as DATA as\n+   maybe_modified. */\n+\n+static bool\n+mark_maybe_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n+\t\t     void *data)\n+{\n+  struct access *repr = (struct access *) data;\n+\n+  repr->grp_maybe_modified = 1;\n+  return true;\n+}\n+\n+/* Analyze what representatives (in linked lists accessible from\n+   REPRESENTATIVES) can be modified by side effects of statements in the\n+   current function.  */\n+\n+static void\n+analyze_modified_params (VEC (access_p, heap) *representatives)\n+{\n+  int i;\n+\n+  for (i = 0; i < func_param_count; i++)\n+    {\n+      struct access *repr = VEC_index (access_p, representatives, i);\n+      VEC (access_p, heap) *access_vec;\n+      int j, access_count;\n+      tree parm;\n+\n+      if (!repr || no_accesses_p (repr))\n+\tcontinue;\n+      parm = repr->base;\n+      if (!POINTER_TYPE_P (TREE_TYPE (parm))\n+\t  || repr->grp_maybe_modified)\n+\tcontinue;\n+\n+      access_vec = get_base_access_vector (parm);\n+      access_count = VEC_length (access_p, access_vec);\n+      for (j = 0; j < access_count; j++)\n+\t{\n+\t  struct access *access;\n+\t  ao_ref ar;\n+\n+\t  /* All accesses are read ones, otherwise grp_maybe_modified would be\n+\t     trivially set.  */\n+\t  access = VEC_index (access_p, access_vec, j);\n+\t  ao_ref_init (&ar, access->expr);\n+\t  walk_aliased_vdefs (&ar, gimple_vuse (access->stmt),\n+\t\t\t      mark_maybe_modified, repr, NULL);\n+\t  if (repr->grp_maybe_modified)\n+\t    break;\n+\t}\n+    }\n+}\n+\n+/* Propagate distances in bb_dereferences in the opposite direction than the\n+   control flow edges, in each step storing the maximum of the current value\n+   and the minimum of all successors.  These steps are repeated until the table\n+   stabilizes.  Note that BBs which might terminate the functions (according to\n+   final_bbs bitmap) never updated in this way.  */\n+\n+static void\n+propagate_dereference_distances (void)\n+{\n+  VEC (basic_block, heap) *queue;\n+  basic_block bb;\n+\n+  queue = VEC_alloc (basic_block, heap, last_basic_block_for_function (cfun));\n+  VEC_quick_push (basic_block, queue, ENTRY_BLOCK_PTR);\n+  FOR_EACH_BB (bb)\n+    {\n+      VEC_quick_push (basic_block, queue, bb);\n+      bb->aux = bb;\n+    }\n+\n+  while (!VEC_empty (basic_block, queue))\n+    {\n+      edge_iterator ei;\n+      edge e;\n+      bool change = false;\n+      int i;\n+\n+      bb = VEC_pop (basic_block, queue);\n+      bb->aux = NULL;\n+\n+      if (bitmap_bit_p (final_bbs, bb->index))\n+\tcontinue;\n+\n+      for (i = 0; i < func_param_count; i++)\n+\t{\n+\t  int idx = bb->index * func_param_count + i;\n+\t  bool first = true;\n+\t  HOST_WIDE_INT inh = 0;\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t  {\n+\t    int succ_idx = e->dest->index * func_param_count + i;\n+\n+\t    if (e->src == EXIT_BLOCK_PTR)\n+\t      continue;\n+\n+\t    if (first)\n+\t      {\n+\t\tfirst = false;\n+\t\tinh = bb_dereferences [succ_idx];\n+\t      }\n+\t    else if (bb_dereferences [succ_idx] < inh)\n+\t      inh = bb_dereferences [succ_idx];\n+\t  }\n+\n+\t  if (!first && bb_dereferences[idx] < inh)\n+\t    {\n+\t      bb_dereferences[idx] = inh;\n+\t      change = true;\n+\t    }\n+\t}\n+\n+      if (change && !bitmap_bit_p (final_bbs, bb->index))\n+\tFOR_EACH_EDGE (e, ei, bb->preds)\n+\t  {\n+\t    if (e->src->aux)\n+\t      continue;\n+\n+\t    e->src->aux = e->src;\n+\t    VEC_quick_push (basic_block, queue, e->src);\n+\t  }\n+    }\n+\n+  VEC_free (basic_block, heap, queue);\n+}\n+\n+/* Dump a dereferences TABLE with heading STR to file F.  */\n+\n+static void\n+dump_dereferences_table (FILE *f, const char *str, HOST_WIDE_INT *table)\n+{\n+  basic_block bb;\n+\n+  fprintf (dump_file, str);\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+    {\n+      fprintf (f, \"%4i  %i   \", bb->index, bitmap_bit_p (final_bbs, bb->index));\n+      if (bb != EXIT_BLOCK_PTR)\n+\t{\n+\t  int i;\n+\t  for (i = 0; i < func_param_count; i++)\n+\t    {\n+\t      int idx = bb->index * func_param_count + i;\n+\t      fprintf (f, \" %4\" HOST_WIDE_INT_PRINT \"d\", table[idx]);\n+\t    }\n+\t}\n+      fprintf (f, \"\\n\");\n+    }\n+  fprintf (dump_file, \"\\n\");\n+}\n+\n+/* Determine what (parts of) parameters passed by reference that are not\n+   assigned to are not certainly dereferenced in this function and thus the\n+   dereferencing cannot be safely moved to the caller without potentially\n+   introducing a segfault.  Mark such REPRESENTATIVES as\n+   grp_not_necessarilly_dereferenced.\n+\n+   The dereferenced maximum \"distance,\" i.e. the offset + size of the accessed\n+   part is calculated rather than simple booleans are calculated for each\n+   pointer parameter to handle cases when only a fraction of the whole\n+   aggregate is allocated (see testsuite/gcc.c-torture/execute/ipa-sra-2.c for\n+   an example).\n+\n+   The maximum dereference distances for each pointer parameter and BB are\n+   already stored in bb_dereference.  This routine simply propagates these\n+   values upwards by propagate_dereference_distances and then compares the\n+   distances of individual parameters in the ENTRY BB to the equivalent\n+   distances of each representative of a (fraction of a) parameter.  */\n+\n+static void\n+analyze_caller_dereference_legality (VEC (access_p, heap) *representatives)\n+{\n+  int i;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_dereferences_table (dump_file,\n+\t\t\t     \"Dereference table before propagation:\\n\",\n+\t\t\t     bb_dereferences);\n+\n+  propagate_dereference_distances ();\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_dereferences_table (dump_file,\n+\t\t\t     \"Dereference table after propagation:\\n\",\n+\t\t\t     bb_dereferences);\n+\n+  for (i = 0; i < func_param_count; i++)\n+    {\n+      struct access *repr = VEC_index (access_p, representatives, i);\n+      int idx = ENTRY_BLOCK_PTR->index * func_param_count + i;\n+\n+      if (!repr || no_accesses_p (repr))\n+\tcontinue;\n+\n+      do\n+\t{\n+\t  if ((repr->offset + repr->size) > bb_dereferences[idx])\n+\t    repr->grp_not_necessarilly_dereferenced = 1;\n+\t  repr = repr->next_grp;\n+\t}\n+      while (repr);\n+    }\n+}\n+\n+/* Return the representative access for the parameter declaration PARM if it is\n+   a scalar passed by reference which is not written to and the pointer value\n+   is not used directly.  Thus, if it is legal to dereference it in the caller\n+   and we can rule out modifications through aliases, such parameter should be\n+   turned into one passed by value.  Return NULL otherwise.  */\n+\n+static struct access *\n+unmodified_by_ref_scalar_representative (tree parm)\n+{\n+  int i, access_count;\n+  struct access *access;\n+  VEC (access_p, heap) *access_vec;\n+\n+  access_vec = get_base_access_vector (parm);\n+  gcc_assert (access_vec);\n+  access_count = VEC_length (access_p, access_vec);\n+\n+  for (i = 0; i < access_count; i++)\n+    {\n+      access = VEC_index (access_p, access_vec, i);\n+      if (access->write)\n+\treturn NULL;\n+    }\n+\n+  access = VEC_index (access_p, access_vec, 0);\n+  access->grp_read = 1;\n+  access->grp_scalar_ptr = 1;\n+  return access;\n+}\n+\n+/* Sort collected accesses for parameter PARM, identify representatives for\n+   each accessed region and link them together.  Return NULL if there are\n+   different but overlapping accesses, return the special ptr value meaning\n+   there are no accesses for this parameter if that is the case and return the\n+   first representative otherwise.  Set *RO_GRP if there is a group of accesses\n+   with only read (i.e. no write) accesses.  */\n+\n+static struct access *\n+splice_param_accesses (tree parm, bool *ro_grp)\n+{\n+  int i, j, access_count, group_count;\n+  int agg_size, total_size = 0;\n+  struct access *access, *res, **prev_acc_ptr = &res;\n+  VEC (access_p, heap) *access_vec;\n+\n+  access_vec = get_base_access_vector (parm);\n+  if (!access_vec)\n+    return &no_accesses_representant;\n+  access_count = VEC_length (access_p, access_vec);\n+\n+  qsort (VEC_address (access_p, access_vec), access_count, sizeof (access_p),\n+\t compare_access_positions);\n+\n+  i = 0;\n+  total_size = 0;\n+  group_count = 0;\n+  while (i < access_count)\n+    {\n+      bool modification;\n+      access = VEC_index (access_p, access_vec, i);\n+      modification = access->write;\n+\n+      /* Access is about to become group representative unless we find some\n+\t nasty overlap which would preclude us from breaking this parameter\n+\t apart. */\n+\n+      j = i + 1;\n+      while (j < access_count)\n+\t{\n+\t  struct access *ac2 = VEC_index (access_p, access_vec, j);\n+\t  if (ac2->offset != access->offset)\n+\t    {\n+\t      /* All or nothing law for parameters. */\n+\t      if (access->offset + access->size > ac2->offset)\n+\t\treturn NULL;\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t  else if (ac2->size != access->size)\n+\t    return NULL;\n+\n+\t  modification |= ac2->write;\n+\t  j++;\n+\t}\n+\n+      group_count++;\n+      access->grp_maybe_modified = modification;\n+      if (!modification)\n+\t*ro_grp = true;\n+      *prev_acc_ptr = access;\n+      prev_acc_ptr = &access->next_grp;\n+      total_size += access->size;\n+      i = j;\n+    }\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (parm)))\n+    agg_size = tree_low_cst (TYPE_SIZE (TREE_TYPE (TREE_TYPE (parm))), 1);\n+  else\n+    agg_size = tree_low_cst (TYPE_SIZE (TREE_TYPE (parm)), 1);\n+  if (total_size >= agg_size)\n+    return NULL;\n+\n+  gcc_assert (group_count > 0);\n+  return res;\n+}\n+\n+/* Decide whether parameters with representative accesses given by REPR should\n+   be reduced into components.  */\n+\n+static int\n+decide_one_param_reduction (struct access *repr)\n+{\n+  int total_size, cur_parm_size, agg_size, new_param_count, parm_size_limit;\n+  bool by_ref;\n+  tree parm;\n+\n+  parm = repr->base;\n+  cur_parm_size = tree_low_cst (TYPE_SIZE (TREE_TYPE (parm)), 1);\n+  gcc_assert (cur_parm_size > 0);\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (parm)))\n+    {\n+      by_ref = true;\n+      agg_size = tree_low_cst (TYPE_SIZE (TREE_TYPE (TREE_TYPE (parm))), 1);\n+    }\n+  else\n+    {\n+      by_ref = false;\n+      agg_size = cur_parm_size;\n+    }\n+\n+  if (dump_file)\n+    {\n+      struct access *acc;\n+      fprintf (dump_file, \"Evaluating PARAM group sizes for \");\n+      print_generic_expr (dump_file, parm, 0);\n+      fprintf (dump_file, \" (UID: %u): \\n\", DECL_UID (parm));\n+      for (acc = repr; acc; acc = acc->next_grp)\n+\tdump_access (dump_file, acc, true);\n+    }\n+\n+  total_size = 0;\n+  new_param_count = 0;\n+\n+  for (; repr; repr = repr->next_grp)\n+    {\n+      gcc_assert (parm == repr->base);\n+      new_param_count++;\n+\n+      if (!by_ref || (!repr->grp_maybe_modified\n+\t\t      && !repr->grp_not_necessarilly_dereferenced))\n+\ttotal_size += repr->size;\n+      else\n+\ttotal_size += cur_parm_size;\n+    }\n+\n+  gcc_assert (new_param_count > 0);\n+\n+  if (optimize_function_for_size_p (cfun))\n+    parm_size_limit = cur_parm_size;\n+  else\n+    parm_size_limit = (PARAM_VALUE (PARAM_IPA_SRA_PTR_GROWTH_FACTOR)\n+                       * cur_parm_size);\n+\n+  if (total_size < agg_size\n+      && total_size <= parm_size_limit)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"    ....will be split into %i components\\n\",\n+\t\t new_param_count);\n+      return new_param_count;\n+    }\n+  else\n+    return 0;\n+}\n+\n+/* The order of the following enums is important, we need to do extra work for\n+   UNUSED_PARAMS, BY_VAL_ACCESSES and UNMODIF_BY_REF_ACCESSES.  */\n+enum ipa_splicing_result { NO_GOOD_ACCESS, UNUSED_PARAMS, BY_VAL_ACCESSES,\n+\t\t\t  MODIF_BY_REF_ACCESSES, UNMODIF_BY_REF_ACCESSES };\n+\n+/* Identify representatives of all accesses to all candidate parameters for\n+   IPA-SRA.  Return result based on what representatives have been found. */\n+\n+static enum ipa_splicing_result\n+splice_all_param_accesses (VEC (access_p, heap) **representatives)\n+{\n+  enum ipa_splicing_result result = NO_GOOD_ACCESS;\n+  tree parm;\n+  struct access *repr;\n+\n+  *representatives = VEC_alloc (access_p, heap, func_param_count);\n+\n+  for (parm = DECL_ARGUMENTS (current_function_decl);\n+       parm;\n+       parm = TREE_CHAIN (parm))\n+    {\n+      if (is_unused_scalar_param (parm))\n+\t{\n+\t  VEC_quick_push (access_p, *representatives,\n+\t\t\t  &no_accesses_representant);\n+\t  if (result == NO_GOOD_ACCESS)\n+\t    result = UNUSED_PARAMS;\n+\t}\n+      else if (POINTER_TYPE_P (TREE_TYPE (parm))\n+\t       && is_gimple_reg_type (TREE_TYPE (TREE_TYPE (parm)))\n+\t       && bitmap_bit_p (candidate_bitmap, DECL_UID (parm)))\n+\t{\n+\t  repr = unmodified_by_ref_scalar_representative (parm);\n+\t  VEC_quick_push (access_p, *representatives, repr);\n+\t  if (repr)\n+\t    result = UNMODIF_BY_REF_ACCESSES;\n+\t}\n+      else if (bitmap_bit_p (candidate_bitmap, DECL_UID (parm)))\n+\t{\n+\t  bool ro_grp = false;\n+\t  repr = splice_param_accesses (parm, &ro_grp);\n+\t  VEC_quick_push (access_p, *representatives, repr);\n+\n+\t  if (repr && !no_accesses_p (repr))\n+\t    {\n+\t      if (POINTER_TYPE_P (TREE_TYPE (parm)))\n+\t\t{\n+\t\t  if (ro_grp)\n+\t\t    result = UNMODIF_BY_REF_ACCESSES;\n+\t\t  else if (result < MODIF_BY_REF_ACCESSES)\n+\t\t    result = MODIF_BY_REF_ACCESSES;\n+\t\t}\n+\t      else if (result < BY_VAL_ACCESSES)\n+\t\tresult = BY_VAL_ACCESSES;\n+\t    }\n+\t  else if (no_accesses_p (repr) && (result == NO_GOOD_ACCESS))\n+\t    result = UNUSED_PARAMS;\n+\t}\n+      else\n+\tVEC_quick_push (access_p, *representatives, NULL);\n+    }\n+\n+  if (result == NO_GOOD_ACCESS)\n+    {\n+      VEC_free (access_p, heap, *representatives);\n+      *representatives = NULL;\n+      return NO_GOOD_ACCESS;\n+    }\n+\n+  return result;\n+}\n+\n+/* Return the index of BASE in PARMS.  Abort if it is not found.  */\n+\n+static inline int\n+get_param_index (tree base, VEC(tree, heap) *parms)\n+{\n+  int i, len;\n+\n+  len = VEC_length (tree, parms);\n+  for (i = 0; i < len; i++)\n+    if (VEC_index (tree, parms, i) == base)\n+      return i;\n+  gcc_unreachable ();\n+}\n+\n+/* Convert the decisions made at the representative level into compact\n+   parameter adjustments.  REPRESENTATIVES are pointers to first\n+   representatives of each param accesses, ADJUSTMENTS_COUNT is the expected\n+   final number of adjustments.  */\n+\n+static ipa_parm_adjustment_vec\n+turn_representatives_into_adjustments (VEC (access_p, heap) *representatives,\n+\t\t\t\t       int adjustments_count)\n+{\n+  VEC (tree, heap) *parms;\n+  ipa_parm_adjustment_vec adjustments;\n+  tree parm;\n+  int i;\n+\n+  gcc_assert (adjustments_count > 0);\n+  parms = ipa_get_vector_of_formal_parms (current_function_decl);\n+  adjustments = VEC_alloc (ipa_parm_adjustment_t, heap, adjustments_count);\n+  parm = DECL_ARGUMENTS (current_function_decl);\n+  for (i = 0; i < func_param_count; i++, parm = TREE_CHAIN (parm))\n+    {\n+      struct access *repr = VEC_index (access_p, representatives, i);\n+\n+      if (!repr || no_accesses_p (repr))\n+\t{\n+\t  struct ipa_parm_adjustment *adj;\n+\n+\t  adj = VEC_quick_push (ipa_parm_adjustment_t, adjustments, NULL);\n+\t  memset (adj, 0, sizeof (*adj));\n+\t  adj->base_index = get_param_index (parm, parms);\n+\t  adj->base = parm;\n+\t  if (!repr)\n+\t    adj->copy_param = 1;\n+\t  else\n+\t    adj->remove_param = 1;\n+\t}\n+      else\n+\t{\n+\t  struct ipa_parm_adjustment *adj;\n+\t  int index = get_param_index (parm, parms);\n+\n+\t  for (; repr; repr = repr->next_grp)\n+\t    {\n+\t      adj = VEC_quick_push (ipa_parm_adjustment_t, adjustments, NULL);\n+\t      memset (adj, 0, sizeof (*adj));\n+\t      gcc_assert (repr->base == parm);\n+\t      adj->base_index = index;\n+\t      adj->base = repr->base;\n+\t      adj->type = repr->type;\n+\t      adj->offset = repr->offset;\n+\t      adj->by_ref = (POINTER_TYPE_P (TREE_TYPE (repr->base))\n+\t\t\t     && (repr->grp_maybe_modified\n+\t\t\t\t || repr->grp_not_necessarilly_dereferenced));\n+\n+\t    }\n+\t}\n+    }\n+  VEC_free (tree, heap, parms);\n+  return adjustments;\n+}\n+\n+/* Analyze the collected accesses and produce a plan what to do with the\n+   parameters in the form of adjustments, NULL meaning nothing.  */\n+\n+static ipa_parm_adjustment_vec\n+analyze_all_param_acesses (void)\n+{\n+  enum ipa_splicing_result repr_state;\n+  bool proceed = false;\n+  int i, adjustments_count = 0;\n+  VEC (access_p, heap) *representatives;\n+  ipa_parm_adjustment_vec adjustments;\n+\n+  repr_state = splice_all_param_accesses (&representatives);\n+  if (repr_state == NO_GOOD_ACCESS)\n+    return NULL;\n+\n+  /* If there are any parameters passed by reference which are not modified\n+     directly, we need to check whether they can be modified indirectly.  */\n+  if (repr_state == UNMODIF_BY_REF_ACCESSES)\n+    {\n+      analyze_caller_dereference_legality (representatives);\n+      analyze_modified_params (representatives);\n+    }\n+\n+  for (i = 0; i < func_param_count; i++)\n+    {\n+      struct access *repr = VEC_index (access_p, representatives, i);\n+\n+      if (repr && !no_accesses_p (repr))\n+\t{\n+\t  if (repr->grp_scalar_ptr)\n+\t    {\n+\t      adjustments_count++;\n+\t      if (repr->grp_not_necessarilly_dereferenced\n+\t\t  || repr->grp_maybe_modified)\n+\t\tVEC_replace (access_p, representatives, i, NULL);\n+\t      else\n+\t\t{\n+\t\t  proceed = true;\n+\t\t  sra_stats.scalar_by_ref_to_by_val++;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      int new_components = decide_one_param_reduction (repr);\n+\n+\t      if (new_components == 0)\n+\t\t{\n+\t\t  VEC_replace (access_p, representatives, i, NULL);\n+\t\t  adjustments_count++;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  adjustments_count += new_components;\n+\t\t  sra_stats.aggregate_params_reduced++;\n+\t\t  sra_stats.param_reductions_created += new_components;\n+\t\t  proceed = true;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (no_accesses_p (repr))\n+\t    {\n+\t      proceed = true;\n+\t      sra_stats.deleted_unused_parameters++;\n+\t    }\n+\t  adjustments_count++;\n+\t}\n+    }\n+\n+  if (!proceed && dump_file)\n+    fprintf (dump_file, \"NOT proceeding to change params.\\n\");\n+\n+  if (proceed)\n+    adjustments = turn_representatives_into_adjustments (representatives,\n+\t\t\t\t\t\t\t adjustments_count);\n+  else\n+    adjustments = NULL;\n+\n+  VEC_free (access_p, heap, representatives);\n+  return adjustments;\n+}\n+\n+/* If a parameter replacement identified by ADJ does not yet exist in the form\n+   of declaration, create it and record it, otherwise return the previously\n+   created one.  */\n+\n+static tree\n+get_replaced_param_substitute (struct ipa_parm_adjustment *adj)\n+{\n+  tree repl;\n+  if (!adj->new_ssa_base)\n+    {\n+      char *pretty_name = make_fancy_name (adj->base);\n+\n+      repl = make_rename_temp (TREE_TYPE (adj->base), \"ISR\");\n+      DECL_NAME (repl) = get_identifier (pretty_name);\n+      obstack_free (&name_obstack, pretty_name);\n+\n+      get_var_ann (repl);\n+      add_referenced_var (repl);\n+      adj->new_ssa_base = repl;\n+    }\n+  else\n+    repl = adj->new_ssa_base;\n+  return repl;\n+}\n+\n+/* Find the first adjustment for a particular parameter BASE in a vector of\n+   ADJUSTMENTS which is not a copy_param.  Return NULL if there is no such\n+   adjustment. */\n+\n+static struct ipa_parm_adjustment *\n+get_adjustment_for_base (ipa_parm_adjustment_vec adjustments, tree base)\n+{\n+  int i, len;\n+\n+  len = VEC_length (ipa_parm_adjustment_t, adjustments);\n+  for (i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj;\n+\n+      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+      if (!adj->copy_param && adj->base == base)\n+\treturn adj;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Callback for scan_function.  If the statement STMT defines an SSA_NAME of a\n+   parameter which is to be removed because its value is not used, replace the\n+   SSA_NAME with a one relating to a created VAR_DECL and replace all of its\n+   uses too.  DATA is a pointer to an adjustments vector.  */\n+\n+static bool\n+replace_removed_params_ssa_names (gimple stmt, void *data)\n+{\n+  VEC (ipa_parm_adjustment_t, heap) *adjustments;\n+  struct ipa_parm_adjustment *adj;\n+  tree lhs, decl, repl, name;\n+\n+  adjustments = (VEC (ipa_parm_adjustment_t, heap) *) data;\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    lhs = gimple_phi_result (stmt);\n+  else if (is_gimple_assign (stmt))\n+    lhs = gimple_assign_lhs (stmt);\n+  else if (is_gimple_call (stmt))\n+    lhs = gimple_call_lhs (stmt);\n+  else\n+    gcc_unreachable ();\n+\n+  if (TREE_CODE (lhs) != SSA_NAME)\n+    return false;\n+  decl = SSA_NAME_VAR (lhs);\n+  if (TREE_CODE (decl) != PARM_DECL)\n+    return false;\n+\n+  adj = get_adjustment_for_base (adjustments, decl);\n+  if (!adj)\n+    return false;\n+\n+  repl = get_replaced_param_substitute (adj);\n+  name = make_ssa_name (repl, stmt);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"replacing an SSA name of a removed param \");\n+      print_generic_expr (dump_file, lhs, 0);\n+      fprintf (dump_file, \" with \");\n+      print_generic_expr (dump_file, name, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (is_gimple_assign (stmt))\n+    gimple_assign_set_lhs (stmt, name);\n+  else if (is_gimple_call (stmt))\n+    gimple_call_set_lhs (stmt, name);\n+  else\n+    gimple_phi_set_result (stmt, name);\n+\n+  replace_uses_by (lhs, name);\n+  return true;\n+}\n+\n+/* Callback for scan_function.  If the expression *EXPR should be replaced by a\n+   reduction of a parameter, do so.  DATA is a pointer to a vector of\n+   adjustments.  */\n+\n+static bool\n+sra_ipa_modify_expr (tree *expr, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n+\t\t     bool write ATTRIBUTE_UNUSED, void *data)\n+{\n+  ipa_parm_adjustment_vec adjustments;\n+  int i, len;\n+  struct ipa_parm_adjustment *adj, *cand = NULL;\n+  HOST_WIDE_INT offset, size, max_size;\n+  tree base, src;\n+\n+  adjustments = (VEC (ipa_parm_adjustment_t, heap) *) data;\n+  len = VEC_length (ipa_parm_adjustment_t, adjustments);\n+\n+  if (TREE_CODE (*expr) == BIT_FIELD_REF\n+      || TREE_CODE (*expr) == IMAGPART_EXPR\n+      || TREE_CODE (*expr) == REALPART_EXPR)\n+    expr = &TREE_OPERAND (*expr, 0);\n+  while (TREE_CODE (*expr) == NOP_EXPR\n+\t || TREE_CODE (*expr) == VIEW_CONVERT_EXPR)\n+    expr = &TREE_OPERAND (*expr, 0);\n+\n+  base = get_ref_base_and_extent (*expr, &offset, &size, &max_size);\n+  if (!base || size == -1 || max_size == -1)\n+    return false;\n+\n+  if (INDIRECT_REF_P (base))\n+    base = TREE_OPERAND (base, 0);\n+\n+  base = get_ssa_base_param (base);\n+  if (!base || TREE_CODE (base) != PARM_DECL)\n+    return false;\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+\n+      if (adj->base == base &&\n+\t  (adj->offset == offset || adj->remove_param))\n+\t{\n+\t  cand = adj;\n+\t  break;\n+\t}\n+    }\n+  if (!cand || cand->copy_param || cand->remove_param)\n+    return false;\n+\n+  if (cand->by_ref)\n+    {\n+      tree folded;\n+      src = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (cand->reduction)),\n+\t\t    cand->reduction);\n+      folded = gimple_fold_indirect_ref (src);\n+      if (folded)\n+        src = folded;\n+    }\n+  else\n+    src = cand->reduction;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"About to replace expr \");\n+      print_generic_expr (dump_file, *expr, 0);\n+      fprintf (dump_file, \" with \");\n+      print_generic_expr (dump_file, src, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (!useless_type_conversion_p (TREE_TYPE (*expr), cand->type))\n+    {\n+      tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*expr), src);\n+      *expr = vce;\n+    }\n+    else\n+      *expr = src;\n+  return true;\n+}\n+\n+/* Callback for scan_function to process assign statements.  Performs\n+   essentially the same function like sra_ipa_modify_expr.  */\n+\n+static enum scan_assign_result\n+sra_ipa_modify_assign (gimple *stmt_ptr,\n+\t\t       gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED, void *data)\n+{\n+  gimple stmt = *stmt_ptr;\n+  bool any = false;\n+\n+  if (!gimple_assign_single_p (stmt))\n+    return SRA_SA_NONE;\n+\n+  any |= sra_ipa_modify_expr (gimple_assign_rhs1_ptr (stmt), gsi, false,\n+\t\t\t      data);\n+  any |= sra_ipa_modify_expr (gimple_assign_lhs_ptr (stmt), gsi, true, data);\n+\n+  return any ? SRA_SA_PROCESSED : SRA_SA_NONE;\n+}\n+\n+/* Call gimple_debug_bind_reset_value on all debug statements describing\n+   gimple register parameters that are being removed or replaced.  */\n+\n+static void\n+sra_ipa_reset_debug_stmts (ipa_parm_adjustment_vec adjustments)\n+{\n+  int i, len;\n+\n+  len = VEC_length (ipa_parm_adjustment_t, adjustments);\n+  for (i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj;\n+      imm_use_iterator ui;\n+      gimple stmt;\n+      tree name;\n+\n+      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+      if (adj->copy_param || !is_gimple_reg (adj->base))\n+\tcontinue;\n+      name = gimple_default_def (cfun, adj->base);\n+      if (!name)\n+\tcontinue;\n+      FOR_EACH_IMM_USE_STMT (stmt, ui, name)\n+\t{\n+\t  /* All other users must have been removed by scan_function.  */\n+\t  gcc_assert (is_gimple_debug (stmt));\n+\t  gimple_debug_bind_reset_value (stmt);\n+\t  update_stmt (stmt);\n+\t}\n+    }\n+}\n+\n+/* Convert all callers of NODE to pass parameters as given in ADJUSTMENTS.  */\n+\n+static void\n+convert_callers (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)\n+{\n+  tree old_cur_fndecl = current_function_decl;\n+  struct cgraph_edge *cs;\n+  basic_block this_block;\n+\n+  for (cs = node->callers; cs; cs = cs->next_caller)\n+    {\n+      current_function_decl = cs->caller->decl;\n+      push_cfun (DECL_STRUCT_FUNCTION (cs->caller->decl));\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"Adjusting call %s -> %s\\n\",\n+\t\t cgraph_node_name (cs->caller),\n+\t\t cgraph_node_name (cs->callee));\n+\n+      ipa_modify_call_arguments (cs, cs->call_stmt, adjustments);\n+      compute_inline_parameters (cs->caller);\n+\n+      pop_cfun ();\n+    }\n+  current_function_decl = old_cur_fndecl;\n+  FOR_EACH_BB (this_block)\n+    {\n+      gimple_stmt_iterator gsi;\n+\n+      for (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi))\n+        {\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  if (gimple_code (stmt) == GIMPLE_CALL\n+\t      && gimple_call_fndecl (stmt) == node->decl)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Adjusting recursive call\");\n+\t      ipa_modify_call_arguments (NULL, stmt, adjustments);\n+\t    }\n+\t}\n+    }\n+\n+  return;\n+}\n+\n+/* Perform all the modification required in IPA-SRA for NODE to have parameters\n+   as given in ADJUSTMENTS.  */\n+\n+static void\n+modify_function (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)\n+{\n+  ipa_modify_formal_parameters (current_function_decl, adjustments, \"ISRA\");\n+  scan_function (sra_ipa_modify_expr, sra_ipa_modify_assign,\n+\t\t replace_removed_params_ssa_names, false, adjustments);\n+  sra_ipa_reset_debug_stmts (adjustments);\n+  convert_callers (node, adjustments);\n+  cgraph_make_node_local (node);\n+  return;\n+}\n+\n+/* Return false the function is apparently unsuitable for IPA-SRA based on it's\n+   attributes, return true otherwise.  NODE is the cgraph node of the current\n+   function.  */\n+\n+static bool\n+ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n+{\n+  if (!cgraph_node_can_be_local_p (node))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function not local to this compilation unit.\\n\");\n+      return false;\n+    }\n+\n+  if (DECL_VIRTUAL_P (current_function_decl))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function is a virtual method.\\n\");\n+      return false;\n+    }\n+\n+  if ((DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl))\n+      && node->global.size >= MAX_INLINE_INSNS_AUTO)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function too big to be made truly local.\\n\");\n+      return false;\n+    }\n+\n+  if (!node->callers)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Function has no callers in this compilation unit.\\n\");\n+      return false;\n+    }\n+\n+  if (cfun->stdarg)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function uses stdarg. \\n\");\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Perform early interprocedural SRA.  */\n+\n+static unsigned int\n+ipa_early_sra (void)\n+{\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  ipa_parm_adjustment_vec adjustments;\n+  int ret = 0;\n+\n+  if (!ipa_sra_preliminary_function_checks (node))\n+    return 0;\n+\n+  sra_initialize ();\n+  sra_mode = SRA_MODE_EARLY_IPA;\n+\n+  if (!find_param_candidates ())\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function has no IPA-SRA candidates.\\n\");\n+      goto simple_out;\n+    }\n+\n+  bb_dereferences = XCNEWVEC (HOST_WIDE_INT,\n+\t\t\t\t func_param_count\n+\t\t\t\t * last_basic_block_for_function (cfun));\n+  final_bbs = BITMAP_ALLOC (NULL);\n+\n+  scan_function (build_access_from_expr, build_accesses_from_assign,\n+\t\t NULL, true, NULL);\n+  if (encountered_apply_args)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function calls  __builtin_apply_args().\\n\");\n+      goto out;\n+    }\n+\n+  adjustments = analyze_all_param_acesses ();\n+  if (!adjustments)\n+    goto out;\n+  if (dump_file)\n+    ipa_dump_param_adjustments (dump_file, adjustments, current_function_decl);\n+\n+  modify_function (node, adjustments);\n+  VEC_free (ipa_parm_adjustment_t, heap, adjustments);\n+  ret = TODO_update_ssa;\n+\n+  statistics_counter_event (cfun, \"Unused parameters deleted\",\n+\t\t\t    sra_stats.deleted_unused_parameters);\n+  statistics_counter_event (cfun, \"Scalar parameters converted to by-value\",\n+\t\t\t    sra_stats.scalar_by_ref_to_by_val);\n+  statistics_counter_event (cfun, \"Aggregate parameters broken up\",\n+\t\t\t    sra_stats.aggregate_params_reduced);\n+  statistics_counter_event (cfun, \"Aggregate parameter components created\",\n+\t\t\t    sra_stats.param_reductions_created);\n+\n+ out:\n+  BITMAP_FREE (final_bbs);\n+  free (bb_dereferences);\n+ simple_out:\n+  sra_deinitialize ();\n+  return ret;\n+}\n+\n+/* Return if early ipa sra shall be performed.  */\n+static bool\n+ipa_early_sra_gate (void)\n+{\n+  return flag_ipa_sra;\n+}\n+\n+struct gimple_opt_pass pass_early_ipa_sra =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"eipa_sra\",\t \t\t\t/* name */\n+  ipa_early_sra_gate,\t\t\t/* gate */\n+  ipa_early_sra,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_IPA_SRA,\t\t\t\t/* tv_id */\n+  0,\t                                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_dump_cgraph \t/* todo_flags_finish */\n+ }\n+};\n+\n+"}]}