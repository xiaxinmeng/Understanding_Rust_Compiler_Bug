{"sha": "6acf25e4b380e5ad738ffe2830a71635bc5230d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFjZjI1ZTRiMzgwZTVhZDczOGZmZTI4MzBhNzE2MzViYzUyMzBkMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-23T15:15:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-23T15:15:58Z"}, "message": "peel-1.c: New testcase.\n\n\n\t* gcc.dg/tree-prof/peel-1.c: New testcase.\n\t* loop-unroll.c (decide_peel_simple): Simple peeling makes sense even\n\twith simple loops; bound number of branches only when FDO is not\n\tavailable.\n\t(decide_unroll_stupid): Mention that num_loop_branches heuristics\n\tis off.\n\nFrom-SVN: r192718", "tree": {"sha": "0f15c07165dd8eb1e94225c4f167441e61fadd00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f15c07165dd8eb1e94225c4f167441e61fadd00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6acf25e4b380e5ad738ffe2830a71635bc5230d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6acf25e4b380e5ad738ffe2830a71635bc5230d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6acf25e4b380e5ad738ffe2830a71635bc5230d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6acf25e4b380e5ad738ffe2830a71635bc5230d1/comments", "author": null, "committer": null, "parents": [{"sha": "2dc34a12e3edfc32133e6e000155ea7d66c9c706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dc34a12e3edfc32133e6e000155ea7d66c9c706", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dc34a12e3edfc32133e6e000155ea7d66c9c706"}], "stats": {"total": 67, "additions": 51, "deletions": 16}, "files": [{"sha": "41e004b44cb8db2009a136e531f4032b1a184e57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6acf25e4b380e5ad738ffe2830a71635bc5230d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6acf25e4b380e5ad738ffe2830a71635bc5230d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6acf25e4b380e5ad738ffe2830a71635bc5230d1", "patch": "@@ -1,3 +1,11 @@\n+2012-10-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* loop-unroll.c (decide_peel_simple): Simple peeling makes sense even\n+\twith simple loops; bound number of branches only when FDO is not\n+\tavailable.\n+\t(decide_unroll_stupid): Mention that num_loop_branches heuristics\n+\tis off.\n+\n 2012-10-23  Nick Clifton  <nickc@redhat.com>\n \n \tPR target/54660"}, {"sha": "92e3c1a127cd522f987ea47c4c48123639105478", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6acf25e4b380e5ad738ffe2830a71635bc5230d1/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6acf25e4b380e5ad738ffe2830a71635bc5230d1/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=6acf25e4b380e5ad738ffe2830a71635bc5230d1", "patch": "@@ -1228,7 +1228,6 @@ static void\n decide_peel_simple (struct loop *loop, int flags)\n {\n   unsigned npeel;\n-  struct niter_desc *desc;\n   double_int iterations;\n \n   if (!(flags & UAP_PEEL))\n@@ -1253,20 +1252,17 @@ decide_peel_simple (struct loop *loop, int flags)\n       return;\n     }\n \n-  /* Check for simple loops.  */\n-  desc = get_simple_loop_desc (loop);\n-\n-  /* Check number of iterations.  */\n-  if (desc->simple_p && !desc->assumptions && desc->const_iter)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Loop iterates constant times\\n\");\n-      return;\n-    }\n-\n   /* Do not simply peel loops with branches inside -- it increases number\n-     of mispredicts.  */\n-  if (num_loop_branches (loop) > 1)\n+     of mispredicts.  \n+     Exception is when we do have profile and we however have good chance\n+     to peel proper number of iterations loop will iterate in practice.\n+     TODO: this heuristic needs tunning; while for complette unrolling\n+     the branch inside loop mostly eliminates any improvements, for\n+     peeling it is not the case.  Also a function call inside loop is\n+     also branch from branch prediction POV (and probably better reason\n+     to not unroll/peel).  */\n+  if (num_loop_branches (loop) > 1\n+      && profile_status != PROFILE_READ)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not peeling, contains branches\\n\");\n@@ -1435,7 +1431,9 @@ decide_unroll_stupid (struct loop *loop, int flags)\n     }\n \n   /* Do not unroll loops with branches inside -- it increases number\n-     of mispredicts.  */\n+     of mispredicts. \n+     TODO: this heuristic needs tunning; call inside the loop body\n+     is also relatively good reason to not unroll.  */\n   if (num_loop_branches (loop) > 1)\n     {\n       if (dump_file)"}, {"sha": "ddfef9753f192412eea9f19560a57b7e7ee61391", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6acf25e4b380e5ad738ffe2830a71635bc5230d1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6acf25e4b380e5ad738ffe2830a71635bc5230d1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6acf25e4b380e5ad738ffe2830a71635bc5230d1", "patch": "@@ -1,7 +1,11 @@\n+2012-10-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-prof/peel-1.c: New testcase.\n+\n 2012-10-23  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \n \tPR gcc/52945\n-\t* testsuite/gcc.dg/lto/pr52634_0.c: skip the test on Darwin.\n+\t* gcc.dg/lto/pr52634_0.c: skip the test on Darwin.\n \n 2012-10-23  Joseph Myers  <joseph@codesourcery.com>\n "}, {"sha": "baa601dc1ec8cb9ae70cab106037a9ab54cac704", "filename": "gcc/testsuite/gcc.dg/tree-prof/peel-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6acf25e4b380e5ad738ffe2830a71635bc5230d1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpeel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6acf25e4b380e5ad738ffe2830a71635bc5230d1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpeel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpeel-1.c?ref=6acf25e4b380e5ad738ffe2830a71635bc5230d1", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-O3 -fdump-rtl-loop2_unroll -fno-unroll-loops -fpeel-loops\" } */\n+void abort();\n+\n+int a[1000];\n+int\n+__attribute__ ((noinline))\n+t()\n+{\n+  int i;\n+  for (i=0;i<1000;i++)\n+    if (!a[i])\n+      return 1;\n+  abort ();\n+}\n+main()\n+{\n+  int i;\n+  for (i=0;i<1000;i++)\n+    t();\n+  return 0;\n+}\n+/* { dg-final-use { scan-rtl-dump \"Considering simply peeling loop\" \"loop2_unroll\" } } */\n+/* In fact one peeling is enough; we however mispredict number of iterations of the loop\n+   at least until loop_ch is schedule ahead of profiling pass.  */\n+/* { dg-final-use { cleanup-rtl-dump \"Decided to simply peel the loop 2 times\" } } */"}]}