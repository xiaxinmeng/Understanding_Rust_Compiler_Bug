{"sha": "c9ec4f99bcd101ef4266f5476498187f270859fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzllYzRmOTliY2QxMDFlZjQyNjZmNTQ3NjQ5ODE4N2YyNzA4NTlmYQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@tanya.rutgers.edu", "date": "1998-01-17T22:39:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-01-17T22:39:10Z"}, "message": "explow.c (optimize_save_area_alloca): New function for targets where SETJMP_VIA_SAVE_AREA is true.\n\n        * explow.c (optimize_save_area_alloca): New function for targets\n        where SETJMP_VIA_SAVE_AREA is true.\n        (allocate_dynamic_stack_space): On SETJMP_VIA_SAVE_AREA targets,\n        compute the amount of stack space needed should we find later that\n        setjmp is never called by this function, stuff rtl for this inside\n        a REG_NOTE of the final SET of stack_pointer_rtx.\n        * toplev.c (rest_of_compilation): If SETJMP_VIA_SAVE_AREA and\n        current_function_calls_alloca, call optimize_save_area_alloca.\nCVS ----------------------------------------------------------------------\n\nFrom-SVN: r17402", "tree": {"sha": "1f934b95444c015d58fbf51e1ea0158ab47cbbea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f934b95444c015d58fbf51e1ea0158ab47cbbea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9ec4f99bcd101ef4266f5476498187f270859fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9ec4f99bcd101ef4266f5476498187f270859fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9ec4f99bcd101ef4266f5476498187f270859fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9ec4f99bcd101ef4266f5476498187f270859fa/comments", "author": null, "committer": null, "parents": [{"sha": "ca097615db39da2a40bc790d6e8b7ebb0d620844", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca097615db39da2a40bc790d6e8b7ebb0d620844", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca097615db39da2a40bc790d6e8b7ebb0d620844"}], "stats": {"total": 150, "additions": 150, "deletions": 0}, "files": [{"sha": "b77d6688ce39224843137102c82d23e7f3eccb98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ec4f99bcd101ef4266f5476498187f270859fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ec4f99bcd101ef4266f5476498187f270859fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9ec4f99bcd101ef4266f5476498187f270859fa", "patch": "@@ -1,3 +1,14 @@\n+Sat Jan 17 23:41:36 1998  David S. Miller  <davem@tanya.rutgers.edu>\n+\n+\t* explow.c (optimize_save_area_alloca): New function for targets\n+\twhere SETJMP_VIA_SAVE_AREA is true.\n+\t(allocate_dynamic_stack_space): On SETJMP_VIA_SAVE_AREA targets,\n+\tcompute the amount of stack space needed should we find later that\n+\tsetjmp is never called by this function, stuff rtl for this inside\n+\ta REG_NOTE of the final SET of stack_pointer_rtx.\n+\t* toplev.c (rest_of_compilation): If SETJMP_VIA_SAVE_AREA and\n+\tcurrent_function_calls_alloca, call optimize_save_area_alloca.\n+\n Sat Jan 17 23:22:59 1998  John Wehle  (john@feith.com)\n \n \t* i386.md: Remove redundant integer push patterns."}, {"sha": "0fcc547ff56d77a8fe4f428718e71bd06fc32118", "filename": "gcc/explow.c", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ec4f99bcd101ef4266f5476498187f270859fa/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ec4f99bcd101ef4266f5476498187f270859fa/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=c9ec4f99bcd101ef4266f5476498187f270859fa", "patch": "@@ -1004,6 +1004,86 @@ emit_stack_restore (save_level, sa, after)\n     emit_insn (fcn (stack_pointer_rtx, sa));\n }\n \f\n+#ifdef SETJMP_VIA_SAVE_AREA\n+/* Optimize RTL generated by allocate_dynamic_stack_space for targets\n+   where SETJMP_VIA_SAVE_AREA is true.  The problem is that on these\n+   platforms, the dynamic stack space used can corrupt the original\n+   frame, thus causing a crash if a longjmp unwinds to it.  */\n+\n+void\n+optimize_save_area_alloca (insns)\n+     rtx insns;\n+{\n+  rtx insn;\n+\n+  for (insn = insns; insn; insn = NEXT_INSN(insn))\n+    {\n+      rtx note;\n+\n+      if (GET_CODE (insn) != INSN)\n+\tcontinue;\n+\n+      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t{\n+\t  if (REG_NOTE_KIND (note) != REG_SAVE_AREA)\n+\t    continue;\n+\n+\t  if (!current_function_calls_setjmp)\n+\t    {\n+\t      rtx pat = PATTERN (insn);\n+\n+\t      /* If we do not see the note in a pattern matching\n+\t\t these precise characteristics, we did something\n+\t\t entirely wrong in allocate_dynamic_stack_space. \n+\n+\t\t Note, one way this could happen if if SETJMP_VIA_SAVE_AREA\n+\t\t was defined on a machine where stacks grow towards higher\n+\t\t addresses.\n+\n+\t\t Right now only supported port with stack that grow upward\n+\t\t is the HPPA and it does not define SETJMP_VIA_SAVE_AREA.  */\n+\t      if (GET_CODE (pat) != SET\n+\t\t  || SET_DEST (pat) != stack_pointer_rtx\n+\t\t  || GET_CODE (SET_SRC (pat)) != MINUS\n+\t\t  || XEXP (SET_SRC (pat), 0) != stack_pointer_rtx)\n+\t\tabort ();\n+\n+\t      /* This will now be transformed into a (set REG REG)\n+\t\t so we can just blow away all the other notes.  */\n+\t      XEXP (SET_SRC (pat), 1) = XEXP (note, 0);\n+\t      REG_NOTES (insn) = NULL_RTX;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* setjmp was called, we must remove the REG_SAVE_AREA\n+\t\t note so that later passes do not get confused by its\n+\t\t presence.  */\n+\t      if (note == REG_NOTES (insn))\n+\t\t{\n+\t\t  REG_NOTES (insn) = XEXP (note, 1);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx srch;\n+\n+\t\t  for (srch = REG_NOTES (insn); srch; srch = XEXP (srch, 1))\n+\t\t    if (XEXP (srch, 1) == note)\n+\t\t      break;\n+\n+\t\t  if (srch == NULL_RTX)\n+\t\t    abort();\n+\n+\t\t  XEXP (srch, 1) = XEXP (note, 1);\n+\t\t}\n+\t    }\n+\t  /* Once we've seen the note of interest, we need not look at\n+\t     the rest of them.  */\n+\t  break;\n+\t}\n+    }\n+}\n+#endif /* SETJMP_VIA_SAVE_AREA */\n+\n /* Return an rtx representing the address of an area of memory dynamically\n    pushed on the stack.  This region of memory is always aligned to\n    a multiple of BIGGEST_ALIGNMENT.\n@@ -1021,6 +1101,10 @@ allocate_dynamic_stack_space (size, target, known_align)\n      rtx target;\n      int known_align;\n {\n+#ifdef SETJMP_VIA_SAVE_AREA\n+  rtx setjmpless_size = NULL_RTX;\n+#endif\n+\n   /* If we're asking for zero bytes, it doesn't matter what we point\n      to since we can't dereference it.  But return a reasonable\n      address anyway.  */\n@@ -1074,6 +1158,45 @@ allocate_dynamic_stack_space (size, target, known_align)\n     rtx dynamic_offset\n       = expand_binop (Pmode, sub_optab, virtual_stack_dynamic_rtx,\n \t\t      stack_pointer_rtx, NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\n+    if (!current_function_calls_setjmp)\n+      {\n+\tint align = STACK_BOUNDARY / BITS_PER_UNIT;\n+\n+\t/* See optimize_save_area_alloca to understand what is being\n+\t   set up here.  */\n+\n+#if !defined(STACK_BOUNDARY) || !defined(MUST_ALIGN) || (STACK_BOUNDARY != BIGGEST_ALIGNMENT)\n+\t/* If anyone creates a target with these characteristics, let them\n+\t   know that our optimization cannot work correctly in such a case.  */\n+\tabort();\n+#endif\n+\n+\tif (GET_CODE (size) == CONST_INT)\n+\t  {\n+\t    int new = INTVAL (size) / align * align;\n+\n+\t    if (INTVAL (size) != new)\n+\t      setjmpless_size = GEN_INT (new);\n+\t    else\n+\t      setjmpless_size = size;\n+\t  }\n+\telse\n+\t  {\n+\t    /* Since we know overflow is not possible, we avoid using\n+\t       CEIL_DIV_EXPR and use TRUNC_DIV_EXPR instead.  */\n+\t    setjmpless_size = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, size,\n+\t\t\t\t\t     GEN_INT (align), NULL_RTX, 1);\n+\t    setjmpless_size = expand_mult (Pmode, setjmpless_size,\n+\t\t\t\t\t   GEN_INT (align), NULL_RTX, 1);\n+\t  }\n+\t/* Our optimization works based upon being able to perform a simple\n+\t   transformation of this RTL into a (set REG REG) so make sure things\n+\t   did in fact end up in a REG.  */\n+\tif (!arith_operand (setjmpless_size, Pmode))\n+\t  setjmpless_size = force_reg (Pmode, setjmpless_size);\n+      }\n+\n     size = expand_binop (Pmode, add_optab, size, dynamic_offset,\n \t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n   }\n@@ -1145,6 +1268,16 @@ allocate_dynamic_stack_space (size, target, known_align)\n #endif\n       size = convert_modes (Pmode, ptr_mode, size, 1);\n       anti_adjust_stack (size);\n+#ifdef SETJMP_VIA_SAVE_AREA\n+      if (setjmpless_size != NULL_RTX)\n+\t{\n+ \t  rtx note_target = get_last_insn ();\n+\n+\t  REG_NOTES (note_target) = gen_rtx (EXPR_LIST, REG_SAVE_AREA,\n+\t\t\t\t\t     setjmpless_size,\n+\t\t\t\t\t     REG_NOTES (note_target));\n+\t}\n+#endif /* SETJMP_VIA_SAVE_AREA */\n #ifdef STACK_GROWS_DOWNWARD\n   emit_move_insn (target, virtual_stack_dynamic_rtx);\n #endif"}, {"sha": "86a6c63f7fe904467d249bd398d190db0ced18b1", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ec4f99bcd101ef4266f5476498187f270859fa/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ec4f99bcd101ef4266f5476498187f270859fa/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c9ec4f99bcd101ef4266f5476498187f270859fa", "patch": "@@ -3242,6 +3242,12 @@ rest_of_compilation (decl)\n \n   unshare_all_rtl (insns);\n \n+#ifdef SETJMP_VIA_SAVE_AREA\n+  /* This must be performed before virutal register instantiation.  */\n+  if (current_function_calls_alloca)\n+    optimize_save_area_alloca (insns);\n+#endif\n+\n   /* Instantiate all virtual registers.  */\n \n   instantiate_virtual_regs (current_function_decl, get_insns ());"}]}