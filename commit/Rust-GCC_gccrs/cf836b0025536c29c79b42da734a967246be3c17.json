{"sha": "cf836b0025536c29c79b42da734a967246be3c17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y4MzZiMDAyNTUzNmMyOWM3OWI0MmRhNzM0YTk2NzI0NmJlM2MxNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-03T09:40:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-03T09:40:46Z"}, "message": "Delete questionable files\n\nFrom-SVN: r28463", "tree": {"sha": "b78d3c832f5dd5f57161d8d8fb9d25448f5d134b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b78d3c832f5dd5f57161d8d8fb9d25448f5d134b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf836b0025536c29c79b42da734a967246be3c17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf836b0025536c29c79b42da734a967246be3c17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf836b0025536c29c79b42da734a967246be3c17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf836b0025536c29c79b42da734a967246be3c17/comments", "author": null, "committer": null, "parents": [{"sha": "392dccb7d395282562649fd3a5e213c79f2b9e0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/392dccb7d395282562649fd3a5e213c79f2b9e0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/392dccb7d395282562649fd3a5e213c79f2b9e0c"}], "stats": {"total": 373, "additions": 0, "deletions": 373}, "files": [{"sha": "13298febe4d6be2c7aff3a28c5bcdf24c1be84fc", "filename": "gcc/testsuite/g++.old-deja/g++.pt/expr4.C", "status": "removed", "additions": 0, "deletions": 373, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392dccb7d395282562649fd3a5e213c79f2b9e0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392dccb7d395282562649fd3a5e213c79f2b9e0c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr4.C?ref=392dccb7d395282562649fd3a5e213c79f2b9e0c", "patch": "@@ -1,373 +0,0 @@\n-template<class View, class W>\n-class TinyContainer {\n-public:\n-\n-  typedef W T_Wrapped;\n-\n-  TinyContainer() { }\n-  TinyContainer(View data) : m_data(data) { }\n-\n-  T_Wrapped &unwrap() \n-  { \n-    return *static_cast<T_Wrapped *>(this);\n-  }\n-  const T_Wrapped &unwrap() const \n-  { \n-    return *static_cast<const T_Wrapped *>(this);\n-  }\n-\n-protected:\n-\n-  mutable View m_data;\n-};\n-\n-template<class Op, class Left, class Right>\n-class TinyBinaryExpr :\n-  public TinyContainer< Op, TinyBinaryExpr<Op, Left, Right> > {\n-public:\n-\n-  typedef typename Left::T_Return T_Return;\n-  typedef TinyBinaryExpr<Op, Left, Right> T_Expr;\n-  \n-  T_Expr makeExpr() const { return *this; }\n-\n-  TinyBinaryExpr(const Op &op, const Left &left, const Right &right)\n-  : TinyContainer< Op, TinyBinaryExpr<Op, Left, Right> >(op),\n-    m_left(left), m_right(right)\n-  { }\n-\n-  TinyBinaryExpr(const Left &left, const Right &right)\n-  : m_left(left), m_right(right)\n-  { }\n-  \n-  Op op() const { return m_data; }\n-  Left left() const { return m_left; }\n-  Right right() const { return m_right; }\n-\n-private:\n-\n-  Left m_left;\n-  Right m_right;\n-};\n-\n-struct OpAdd {\n-\n-  template<class T1, class T2>\n-  static T1 apply(const T1 &l, const T2 &r)\n-  {\n-    return l + r;\n-  }\n-\n-};\n-\n-template<class V1, class T1, class V2, class T2>\n-inline TinyBinaryExpr<OpAdd, typename T1::T_Expr, typename T2::T_Expr>\n-operator+(const TinyContainer<V1,T1>& l, const TinyContainer<V2,T2>& r)\n-{\n-  typedef TinyBinaryExpr<OpAdd, typename T1::T_Expr, typename T2::T_Expr> ret;\n-  return ret(l.unwrap().makeExpr(), r.unwrap().makeExpr());\n-}\n-\n-\n-template<class Op, class T1, class T2, class Functor>\n-inline\n-typename T1::T_Return\n-for_each(const TinyBinaryExpr<Op,T1,T2>& node, Functor f)\n-{\n-  return Op::apply(for_each(node.left(),f), for_each(node.right(),f));\n-}\n-\n-template<class T, unsigned Nrows, unsigned Ncols, unsigned S1, unsigned S2>\n-class DenseDataView\n-  : public TinyContainer< T*, DenseDataView<T, Nrows, Ncols, S1, S2> > {\n-public:\n-\n-  typedef T T_Return;\n-  typedef DenseDataView<T, Nrows, Ncols, S1, S2> T_Expr;\n-\n-  T_Expr makeExpr() const { return *this; }\n-\n-  T *beginLoc(unsigned i, unsigned j) const \n-  { return m_data + S1 * i + S2 * j; }\n-\n-  DenseDataView(T *pData) \n-  : TinyContainer< T*, DenseDataView<T, Nrows, Ncols, S1, S2> >(pData) { }\n-\n-  T &offset(unsigned i, unsigned j)\n-  {\n-    return m_data[S1 * i + S2 * j];\n-  }\n-\n-  T offset(unsigned i, unsigned j) const\n-  {\n-    return m_data[S1 * i + S2 * j];\n-  }\n-\n-  template<unsigned I, unsigned J>\n-  struct Offset {\n-\n-    static T &apply(DenseDataView<T, Nrows, Ncols, S1, S2> &d)\n-    {\n-      return d.m_data[S1 * I + S2 * J];\n-    }\n-\n-    static T constApply(const DenseDataView<T, Nrows, Ncols, S1, S2> &d)\n-    {\n-      return d.m_data[S1 * I + S2 * J];\n-    }\n-\n-  };\n-\n-};\n-\n-template<unsigned I, unsigned J>\n-struct Eval2 { };\n-\n-template<class T, unsigned Nrows, unsigned Ncols, unsigned S1, unsigned S2,\n-  unsigned I, unsigned J>\n-inline T\n-for_each(const DenseDataView<T, Nrows, Ncols, S1, S2> &d, \n-  const Eval2<I,J> &e)\n-{\n-  return d.offset(I, J);\n-}\n-\n-template<class T, unsigned Nrows, unsigned Ncols>\n-class DenseData\n-  : public TinyContainer< T[Nrows * Ncols], DenseData<T, Nrows, Ncols> > {\n-public:\n-\n-  typedef T T_Return;\n-  typedef DenseDataView<T, Nrows, Ncols, 1, Nrows> T_Expr;\n-\n-  T_Expr makeExpr() const { return T_Expr(m_data); }\n-\n-  T *beginLoc(unsigned i, unsigned j) const \n-  { return &m_data[i + Nrows * j]; }\n-\n-  T &operator[](unsigned i)\n-  {\n-    return m_data[i];\n-  }\n-\n-  T operator[](unsigned i) const\n-  {\n-    return m_data[i];\n-  }\n-\n-  T &offset(unsigned i, unsigned j)\n-  {\n-    return m_data[i + Nrows * j];\n-  }\n-\n-  T offset(unsigned i, unsigned j) const\n-  {\n-    return m_data[i + Nrows * j];\n-  }\n-\n-  template<unsigned I, unsigned J>\n-  struct Offset {\n-\n-    static T &apply(DenseData<T, Nrows, Ncols> &d)\n-    {\n-      return d.m_data[I + Nrows * J];\n-    }\n-\n-    static T constApply(const DenseData<T, Nrows, Ncols> &d)\n-    {\n-      return d.m_data[I + Nrows * J];\n-    }\n-\n-  };\n-\n-};\n-\n-template<class T, unsigned Nrc>\n-class DiagonalData {\n-public:\n-\n-  T &offset(unsigned i, unsigned j)\n-  {\n-    assert(i == j);\n-    return m_data[i];\n-  }\n-\n-  T offset(unsigned i, unsigned j) const\n-  {\n-    return (i == j) ? m_data[i] : T(0);\n-  }\n-\n-  template<unsigned I, unsigned J>\n-  struct Offset {\n-\n-    static T &apply(DiagonalData<T,Nrc> &d)\n-    {\n-      assert(I == J);\n-      return d.m_data[I];\n-    }\n-\n-    static T constApply(const DiagonalData<T,Nrc> &d)\n-    {\n-      return (I == J) ? d.m_data[I] : T(0);\n-    }\n-\n-  };\n-\n-private:\n-  \n-  T m_data[Nrc];\n-};\n-\n-template<unsigned I, unsigned J, unsigned C1>\n-struct InnerLoop {\n-\n-  template<class LHS, class RHS>\n-  static inline void eval(LHS &l, const RHS &r)\n-  {\n-    l.offset(I,J) = for_each(r, Eval2<I,J>());\n-    InnerLoop<I + 1, J, C1 - 1>::eval(l, r);\n-  }\n-\n-};\n-\n-template<unsigned I, unsigned J>\n-struct InnerLoop<I, J, 0> {\n-\n-  template<class LHS, class RHS>\n-  static inline void eval(LHS &, const RHS &) { }\n-\n-};\n-\n-template<unsigned I, unsigned J, unsigned C1, unsigned C2>\n-struct Loop2 {\n-\n-  template<class LHS, class RHS>\n-  static inline void eval(LHS &l, const RHS &r)\n-  {\n-    InnerLoop<I, J, C1>::eval(l, r);\n-    Loop2<I, J + 1, C1, C2 - 1>::eval(l, r);\n-  }\n-};\n-\n-template<unsigned I, unsigned J, unsigned C1>\n-struct Loop2<I, J, C1, 0> {\n-\n-  template<class LHS, class RHS>\n-  static inline void eval(LHS &l, const RHS &r) { }\n-\n-};\n-\n-\n-template<unsigned Begin, unsigned End, unsigned Stride = 1>\n-class TinyRange {\n-public:\n-\n-  static const unsigned b = Begin;\n-  static const unsigned e = End;\n-  static const unsigned s = Stride;\n-  static const unsigned n = (End - Begin) / Stride + 1;\n-\n-  static unsigned index(unsigned i)\n-    {\n-      return b + s * i;\n-    }\n-};\n-\n-template<class Range1, class Range2, class Data>\n-struct Merge { };\n-\n-template<class Range1, class Range2, class T, unsigned Nrows, unsigned Ncols>\n-struct Merge<Range1, Range2, DenseData<T, Nrows, Ncols> >\n-{\n-  static const unsigned s2 = Nrows * Range2::s;\n-  typedef \n-    DenseDataView<T, Range1::n, Range2::n, Range1::s, s2> type;\n-};\n-\n-template<class Range1, class Range2, class T, unsigned Nrows, unsigned Ncols,\n-  unsigned S1, unsigned S2>\n-struct Merge<Range1, Range2, DenseDataView<T, Nrows, Ncols, S1, S2> >\n-{\n-  static const unsigned s1 = S1 * Range1::s;\n-  static const unsigned s2 = S2 * Range2::s;\n-\n-  typedef\n-    DenseDataView<T, Range1::n, Range2::n, s1, s2> type;\n-};\n-\n-template<class T, unsigned Nrows, unsigned Ncols, \n-  class Data = DenseData<T, Nrows, Ncols> >\n-class TinyMatrix :\n-  public TinyContainer< Data, TinyMatrix<T, Nrows, Ncols, Data> > {\n-public:\n-\n-  typedef T T_Return;\n-  typedef typename Data::T_Expr T_Expr;\n-  typedef TinyContainer< Data, TinyMatrix<T, Nrows, Ncols, Data> > T_Base;\n-  \n-  T_Expr makeExpr() const { return m_data.makeExpr(); }\n-\n-  TinyMatrix() { }\n-\n-  TinyMatrix(const T &a0, const T &a1, const T &a2, \n-\t     const T &a3, const T &a4, const T &a5)\n-  {\n-    m_data[0] = a0; m_data[1] = a1; m_data[2] = a2;\n-    m_data[3] = a3; m_data[4] = a4; m_data[5] = a5;\n-  }\n-\n-  TinyMatrix(const T &a0, const T &a1)\n-  {\n-    m_data[0] = a0; m_data[1] = a1;\n-  }\n-\n-  TinyMatrix(const Data &d) : T_Base(d) { }\n-\n-  T operator()(unsigned i, unsigned j) const\n-  {\n-    return m_data.offset(i, j);\n-  }\n-\n-  template<unsigned B1, unsigned E1, unsigned S1,\n-    unsigned B2, unsigned E2, unsigned S2>\n-  TinyMatrix<T, TinyRange<B1, E1, S1>::n,\n-      TinyRange<B2, E2, S2>::n, \n-      typename \n-      Merge< TinyRange<B1, E1, S1>, TinyRange<B2, E2, S2>, Data>::type>  \n-  operator()(const TinyRange<B1, E1, S1> &r1, const TinyRange<B2, E2, S2> &r2)\n-  {\n-    typedef typename \n-      Merge< TinyRange<B1, E1, S1>, TinyRange<B2, E2, S2>, Data>::type\n-      T_DataType;\n-    typedef TinyMatrix<T, TinyRange<B1, E1, S1>::n,\n-      TinyRange<B2, E2, S2>::n, T_DataType> T_RetType;\n-\n-    return T_RetType(T_DataType(m_data.beginLoc(B1, B2)));\n-  }\n-\n-  template<class V1, class T1>\n-  void operator=(const TinyContainer<V1, T1> &rhs)\n-  {\n-    Loop2<0, 0, Nrows, Ncols>::eval(m_data, rhs.unwrap().makeExpr());\n-  }\n-\n-};\n-\n-    \n-int main()\n-{\n-  TinyMatrix<double, 2, 3> a, b(1.0, 2.0, 3.0, 4.0, 5.0, 6.0),\n-    c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6), d(0.01, 0.02, 0.03, 0.04, 0.05, 0.06);\n-  TinyMatrix<double, 1, 2> e, f(17.0, 48.3);\n-\n-  a = b + c + d;\n-\n-  a(TinyRange<0,1>(), TinyRange<0,2,2>());\n-  \n-  a(TinyRange<0,1>(), TinyRange<0,2,2>())\n-    (TinyRange<0,0>(), TinyRange<0,1>());\n-  \n-  e = f + a(TinyRange<0,1>(), TinyRange<0,2,2>())\n-    (TinyRange<0,0>(), TinyRange<0,1>());\n-}\n-"}]}