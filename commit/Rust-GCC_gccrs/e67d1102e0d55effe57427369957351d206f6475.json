{"sha": "e67d1102e0d55effe57427369957351d206f6475", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY3ZDExMDJlMGQ1NWVmZmU1NzQyNzM2OTk1NzM1MWQyMDZmNjQ3NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-06-06T13:14:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-06-06T13:14:45Z"}, "message": "emit-rtl.c, [...]: Replace rtx base types with more derived ones.\n\ngcc/\n\t* emit-rtl.c, expr.c, gcse.c, optabs.c, optabs.h, print-rtl.c,\n\trtl.h, bb-reorder.c, builtins.c, calls.c, cfgbuild.c, cfgexpand.c,\n\tcfgrtl.c, cilk-common.c, config/i386/i386.md, cse.c, dwarf2cfi.c,\n\texcept.c, final.c, function.c, gcse-common.c, genemit.c,\n\thaifa-sched.c, ifcvt.c, jump.c, loop-invariant.c, loop-iv.c,\n\tlra-constraints.c, lra.c, reload1.c, resource.c, rtlanal.c,\n\tsched-deps.c, sched-ebb.c, sel-sched-ir.c, sel-sched.c,\n\tshrink-wrap.c, stmt.c, store-motion.c: Replace rtx base types with\n\tmore derived ones.\n\nFrom-SVN: r224187", "tree": {"sha": "ae5222f0b206b4fe1455b6bf791013c65d7bdbb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae5222f0b206b4fe1455b6bf791013c65d7bdbb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e67d1102e0d55effe57427369957351d206f6475", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67d1102e0d55effe57427369957351d206f6475", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e67d1102e0d55effe57427369957351d206f6475", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67d1102e0d55effe57427369957351d206f6475/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad42dbbebaca32f857812b2285c8e4462bb0c688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad42dbbebaca32f857812b2285c8e4462bb0c688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad42dbbebaca32f857812b2285c8e4462bb0c688"}], "stats": {"total": 335, "additions": 154, "deletions": 181}, "files": [{"sha": "0084d749fd67b9eee89e773f314672e9456206e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -1,3 +1,15 @@\n+2015-06-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* emit-rtl.c, expr.c, gcse.c, optabs.c, optabs.h, print-rtl.c,\n+\trtl.h, bb-reorder.c, builtins.c, calls.c, cfgbuild.c, cfgexpand.c,\n+\tcfgrtl.c, cilk-common.c, config/i386/i386.md, cse.c, dwarf2cfi.c,\n+\texcept.c, final.c, function.c, gcse-common.c, genemit.c,\n+\thaifa-sched.c, ifcvt.c, jump.c, loop-invariant.c, loop-iv.c,\n+\tlra-constraints.c, lra.c, reload1.c, resource.c, rtlanal.c,\n+\tsched-deps.c, sched-ebb.c, sel-sched-ir.c, sel-sched.c,\n+\tshrink-wrap.c, stmt.c, store-motion.c: Replace rtx base types with\n+\tmore derived ones.\n+\n 2015-06-06  Mikhail Maltsev  <maltsevm@gmail.com>\n \n \t* combine.c (combine_split_insns): Remove cast."}, {"sha": "318e357d4f6672c8591a630c22ff0795b5f190fd", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -1391,12 +1391,11 @@ copy_bb_p (const_basic_block bb, int code_may_grow)\n int\n get_uncond_jump_length (void)\n {\n-  rtx_insn *label, *jump;\n   int length;\n \n   start_sequence ();\n-  label = emit_label (gen_label_rtx ());\n-  jump = emit_jump_insn (gen_jump (label));\n+  rtx_code_label *label = emit_label (gen_label_rtx ());\n+  rtx_insn *jump = emit_jump_insn (gen_jump (label));\n   length = get_attr_min_length (jump);\n   end_sequence ();\n \n@@ -1412,8 +1411,7 @@ fix_up_crossing_landing_pad (eh_landing_pad old_lp, basic_block old_bb)\n {\n   eh_landing_pad new_lp;\n   basic_block new_bb, last_bb, post_bb;\n-  rtx_insn *new_label, *jump;\n-  rtx post_label;\n+  rtx_insn *jump;\n   unsigned new_partition;\n   edge_iterator ei;\n   edge e;\n@@ -1425,13 +1423,13 @@ fix_up_crossing_landing_pad (eh_landing_pad old_lp, basic_block old_bb)\n   LABEL_PRESERVE_P (new_lp->landing_pad) = 1;\n \n   /* Put appropriate instructions in new bb.  */\n-  new_label = emit_label (new_lp->landing_pad);\n+  rtx_code_label *new_label = emit_label (new_lp->landing_pad);\n \n   expand_dw2_landing_pad_for_region (old_lp->region);\n \n   post_bb = BLOCK_FOR_INSN (old_lp->landing_pad);\n   post_bb = single_succ (post_bb);\n-  post_label = block_label (post_bb);\n+  rtx_code_label *post_label = block_label (post_bb);\n   jump = emit_jump_insn (gen_jump (post_label));\n   JUMP_LABEL (jump) = post_label;\n \n@@ -1754,14 +1752,13 @@ add_labels_and_missing_jumps (vec<edge> crossing_edges)\n     {\n       basic_block src = e->src;\n       basic_block dest = e->dest;\n-      rtx label;\n-      rtx_insn *new_jump;\n+      rtx_jump_insn *new_jump;\n \n       if (dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n \n       /* Make sure dest has a label.  */\n-      label = block_label (dest);\n+      rtx_code_label *label = block_label (dest);\n \n       /* Nothing to do for non-fallthru edges.  */\n       if (src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n@@ -1812,7 +1809,7 @@ fix_up_fall_thru_edges (void)\n   bool cond_jump_crosses;\n   int invert_worked;\n   rtx_insn *old_jump;\n-  rtx fall_thru_label;\n+  rtx_code_label *fall_thru_label;\n \n   FOR_EACH_BB_FN (cur_bb, cfun)\n     {"}, {"sha": "b3bc3500561f654f51a470da45dd472414e534d0", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -1560,11 +1560,10 @@ expand_builtin_apply_args (void)\n        saved on entry to this function.  So we migrate the\n        call to the first insn of this function.  */\n     rtx temp;\n-    rtx seq;\n \n     start_sequence ();\n     temp = expand_builtin_apply_args_1 ();\n-    seq = get_insns ();\n+    rtx_insn *seq = get_insns ();\n     end_sequence ();\n \n     apply_args_value = temp;\n@@ -6397,7 +6396,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \t  rtx buf_addr = expand_expr (CALL_EXPR_ARG (exp, 0), subtarget,\n \t\t\t\t      VOIDmode, EXPAND_NORMAL);\n \t  tree label = TREE_OPERAND (CALL_EXPR_ARG (exp, 1), 0);\n-\t  rtx label_r = label_rtx (label);\n+\t  rtx_insn *label_r = label_rtx (label);\n \n \t  /* This is copied from the handling of non-local gotos.  */\n \t  expand_builtin_setjmp_setup (buf_addr, label_r);\n@@ -6417,7 +6416,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       if (validate_arglist (exp, POINTER_TYPE, VOID_TYPE))\n \t{\n \t  tree label = TREE_OPERAND (CALL_EXPR_ARG (exp, 0), 0);\n-\t  rtx label_r = label_rtx (label);\n+\t  rtx_insn *label_r = label_rtx (label);\n \n \t  expand_builtin_setjmp_receiver (label_r);\n \t  return const0_rtx;"}, {"sha": "da2c8f614f86ba112b3d2143203760c2a28cf1dc", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -309,7 +309,6 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n \t     cumulative_args_t args_so_far ATTRIBUTE_UNUSED)\n {\n   rtx rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n-  rtx_insn *call_insn;\n   rtx call, funmem;\n   int already_popped = 0;\n   HOST_WIDE_INT n_popped\n@@ -435,7 +434,7 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n     gcc_unreachable ();\n \n   /* Find the call we just emitted.  */\n-  call_insn = last_call_insn ();\n+  rtx_call_insn *call_insn = last_call_insn ();\n \n   /* Some target create a fresh MEM instead of reusing the one provided\n      above.  Set its MEM_EXPR.  */\n@@ -4437,9 +4436,9 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n   if (flag_ipa_ra)\n     {\n-      rtx last, datum = orgfun;\n+      rtx datum = orgfun;\n       gcc_assert (GET_CODE (datum) == SYMBOL_REF);\n-      last = last_call_insn ();\n+      rtx_call_insn *last = last_call_insn ();\n       add_reg_note (last, REG_CALL_DECL, datum);\n     }\n "}, {"sha": "45de5281c87bd29abd250a88b94970a14103cf1b", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -174,7 +174,7 @@ rtl_make_eh_edge (sbitmap edge_cache, basic_block src, rtx insn)\n \n   if (lp)\n     {\n-      rtx label = lp->landing_pad;\n+      rtx_insn *label = lp->landing_pad;\n \n       /* During initial rtl generation, use the post_landing_pad.  */\n       if (label == NULL)"}, {"sha": "e9840b100049dd7d6d99c8c405ccea433538514c", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -2900,7 +2900,7 @@ expand_asm_stmt (gasm *stmt)\n       for (i = 0; i < nlabels; ++i)\n \t{\n \t  tree label = TREE_VALUE (gimple_asm_label_op (stmt, i));\n-\t  rtx r;\n+\t  rtx_insn *r;\n \t  /* If asm goto has any labels in the fallthru basic block, use\n \t     a label that we emit immediately after the asm goto.  Expansion\n \t     may insert further instructions into the same basic block after"}, {"sha": "13f8372735ef72a697cf9c3f36d343ca5bfbd86f", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -92,7 +92,6 @@ static GTY(()) rtx_insn *cfg_layout_function_header;\n \n static rtx_insn *skip_insns_after_block (basic_block);\n static void record_effective_endpoints (void);\n-static rtx label_for_bb (basic_block);\n static void fixup_reorder_chain (void);\n \n void verify_insn_chain (void);\n@@ -1120,7 +1119,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   /* Or replace possibly complicated jump insn by simple jump insn.  */\n   else\n     {\n-      rtx target_label = block_label (target);\n+      rtx_code_label *target_label = block_label (target);\n       rtx_insn *barrier;\n       rtx label;\n       rtx_jump_table_data *table;\n@@ -1203,7 +1202,7 @@ patch_jump_insn (rtx_insn *insn, rtx_insn *old_label, basic_block new_bb)\n     {\n       rtvec vec;\n       int j;\n-      rtx new_label = block_label (new_bb);\n+      rtx_code_label *new_label = block_label (new_bb);\n \n       if (new_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \treturn false;\n@@ -1233,11 +1232,11 @@ patch_jump_insn (rtx_insn *insn, rtx_insn *old_label, basic_block new_bb)\n   else if ((tmp = extract_asm_operands (PATTERN (insn))) != NULL)\n     {\n       int i, n = ASM_OPERANDS_LABEL_LENGTH (tmp);\n-      rtx new_label, note;\n+      rtx note;\n \n       if (new_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \treturn false;\n-      new_label = block_label (new_bb);\n+      rtx_code_label *new_label = block_label (new_bb);\n \n       for (i = 0; i < n; ++i)\n \t{\n@@ -1722,7 +1721,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n     }\n   else\n     {\n-      rtx label = block_label (target);\n+      rtx_code_label *label = block_label (target);\n       emit_jump_insn_after_setloc (gen_jump (label), BB_END (jump_block), loc);\n       JUMP_LABEL (BB_END (jump_block)) = label;\n       LABEL_NUSES (label)++;\n@@ -3464,10 +3463,10 @@ skip_insns_after_block (basic_block bb)\n \n /* Locate or create a label for a given basic block.  */\n \n-static rtx\n+static rtx_insn *\n label_for_bb (basic_block bb)\n {\n-  rtx label = BB_HEAD (bb);\n+  rtx_insn *label = BB_HEAD (bb);\n \n   if (!LABEL_P (label))\n     {"}, {"sha": "8b358378799c75bedb95f5567d128bf29f39a9aa", "filename": "gcc/cilk-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcilk-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcilk-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk-common.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -370,7 +370,7 @@ expand_builtin_cilk_pop_frame (tree exp)\n void\n expand_builtin_cilk_detach (tree exp)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   tree fptr = get_frame_arg (exp);\n \n   if (fptr == NULL_TREE)"}, {"sha": "564e9fa7c595b24b07d18fa2f198f7322bb9e021", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -7186,7 +7186,7 @@\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"TARGET_QIMODE_MATH\"\n {\n-  rtx div, mod, insn;\n+  rtx div, mod;\n   rtx tmp0, tmp1;\n   \n   tmp0 = gen_reg_rtx (HImode);\n@@ -7199,7 +7199,7 @@\n \n   /* Extract remainder from AH.  */\n   tmp1 = gen_rtx_SIGN_EXTRACT (QImode, tmp0, GEN_INT (8), GEN_INT (8));\n-  insn = emit_move_insn (operands[3], tmp1);\n+  rtx_insn *insn = emit_move_insn (operands[3], tmp1);\n \n   mod = gen_rtx_MOD (QImode, operands[1], operands[2]);\n   set_unique_reg_note (insn, REG_EQUAL, mod);\n@@ -7358,7 +7358,7 @@\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"TARGET_QIMODE_MATH\"\n {\n-  rtx div, mod, insn;\n+  rtx div, mod;\n   rtx tmp0, tmp1;\n   \n   tmp0 = gen_reg_rtx (HImode);\n@@ -7372,7 +7372,7 @@\n   /* Extract remainder from AH.  */\n   tmp1 = gen_rtx_ZERO_EXTRACT (SImode, tmp0, GEN_INT (8), GEN_INT (8));\n   tmp1 = simplify_gen_subreg (QImode, tmp1, SImode, 0);\n-  insn = emit_move_insn (operands[3], tmp1);\n+  rtx_insn *insn = emit_move_insn (operands[3], tmp1);\n \n   mod = gen_rtx_UMOD (QImode, operands[1], operands[2]);\n   set_unique_reg_note (insn, REG_EQUAL, mod);"}, {"sha": "0453accefdc2e8ba820c899d93f470b7779b7cf6", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -5487,7 +5487,7 @@ cse_insn (rtx_insn *insn)\n \t     and hope for the best.  */\n \t  if (n_sets == 1)\n \t    {\n-\t      rtx_insn *new_rtx;\n+\t      rtx_jump_insn *new_rtx;\n \t      rtx note;\n \n \t      new_rtx = emit_jump_insn_before (gen_jump (XEXP (src, 0)), insn);\n@@ -6845,7 +6845,7 @@ static bool\n set_live_p (rtx set, rtx_insn *insn ATTRIBUTE_UNUSED, /* Only used with HAVE_cc0.  */\n \t    int *counts)\n {\n-  rtx tem;\n+  rtx_insn *tem;\n \n   if (set_noop_p (set))\n     ;"}, {"sha": "5176f72c6dec1827f8bda806bcd06eae444214d3", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -2242,7 +2242,6 @@ add_cfis_to_fde (void)\n \t      int num = dwarf2out_cfi_label_num;\n \t      const char *label = dwarf2out_cfi_label ();\n \t      dw_cfi_ref xcfi;\n-\t      rtx tmp;\n \n \t      /* Set the location counter to the new label.  */\n \t      xcfi = new_cfi ();\n@@ -2251,7 +2250,7 @@ add_cfis_to_fde (void)\n \t      xcfi->dw_cfi_oprnd1.dw_cfi_addr = label;\n \t      vec_safe_push (fde->dw_fde_cfi, xcfi);\n \n-\t      tmp = emit_note_before (NOTE_INSN_CFI_LABEL, insn);\n+\t      rtx_note *tmp = emit_note_before (NOTE_INSN_CFI_LABEL, insn);\n \t      NOTE_LABEL_NUMBER (tmp) = num;\n \t    }\n "}, {"sha": "fb8d0bf11c5cf3ce4521ab4b8f06505b4710bb35", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -3662,7 +3662,7 @@ try_split (rtx pat, rtx_insn *trial, int last)\n   int probability;\n   rtx_insn *insn_last, *insn;\n   int njumps = 0;\n-  rtx call_insn = NULL_RTX;\n+  rtx_insn *call_insn = NULL;\n \n   /* We're not good at redistributing frame information.  */\n   if (RTX_FRAME_RELATED_P (trial))\n@@ -4684,10 +4684,10 @@ emit_pattern_after_setloc (rtx pattern, rtx uncast_after, int loc,\n \t\t\t   rtx_insn *(*make_raw) (rtx))\n {\n   rtx_insn *after = safe_as_a <rtx_insn *> (uncast_after);\n-  rtx last = emit_pattern_after_noloc (pattern, after, NULL, make_raw);\n+  rtx_insn *last = emit_pattern_after_noloc (pattern, after, NULL, make_raw);\n \n   if (pattern == NULL_RTX || !loc)\n-    return safe_as_a <rtx_insn *> (last);\n+    return last;\n \n   after = NEXT_INSN (after);\n   while (1)\n@@ -4700,7 +4700,7 @@ emit_pattern_after_setloc (rtx pattern, rtx uncast_after, int loc,\n \tbreak;\n       after = NEXT_INSN (after);\n     }\n-  return safe_as_a <rtx_insn *> (last);\n+  return last;\n }\n \n /* Insert PATTERN after AFTER.  MAKE_RAW indicates how to turn PATTERN"}, {"sha": "c946efb570c0192ac877907c8e589c541667f335", "filename": "gcc/except.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -1299,9 +1299,8 @@ sjlj_emit_dispatch_table (rtx_code_label *dispatch_label, int num_dispatch)\n   machine_mode unwind_word_mode = targetm.unwind_word_mode ();\n   machine_mode filter_mode = targetm.eh_return_filter_mode ();\n   eh_landing_pad lp;\n-  rtx mem, fc, before, exc_ptr_reg, filter_reg;\n+  rtx mem, fc, exc_ptr_reg, filter_reg;\n   rtx_insn *seq;\n-  rtx first_reachable_label;\n   basic_block bb;\n   eh_region r;\n   edge e;\n@@ -1348,7 +1347,7 @@ sjlj_emit_dispatch_table (rtx_code_label *dispatch_label, int num_dispatch)\n   /* Jump to one of the directly reachable regions.  */\n \n   disp_index = 0;\n-  first_reachable_label = NULL;\n+  rtx_code_label *first_reachable_label = NULL;\n \n   /* If there's exactly one call site in the function, don't bother\n      generating a switch statement.  */\n@@ -1391,7 +1390,7 @@ sjlj_emit_dispatch_table (rtx_code_label *dispatch_label, int num_dispatch)\n \tseq2 = get_insns ();\n \tend_sequence ();\n \n-\tbefore = label_rtx (lp->post_landing_pad);\n+\trtx_insn *before = label_rtx (lp->post_landing_pad);\n \tbb = emit_to_new_bb_before (seq2, before);\n \te = make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n \te->count = bb->count;\n@@ -1684,7 +1683,7 @@ for_each_eh_label (void (*callback) (rtx))\n     {\n       if (lp)\n \t{\n-\t  rtx lab = lp->landing_pad;\n+\t  rtx_code_label *lab = lp->landing_pad;\n \t  if (lab && LABEL_P (lab))\n \t    (*callback) (lab);\n \t}\n@@ -2518,7 +2517,7 @@ convert_to_eh_region_ranges (void)\n   rtx_insn *first_no_action_insn = NULL;\n   int call_site = 0;\n   int cur_sec = 0;\n-  rtx section_switch_note = NULL_RTX;\n+  rtx_insn *section_switch_note = NULL;\n   rtx_insn *first_no_action_insn_before_switch = NULL;\n   rtx_insn *last_no_action_insn_before_switch = NULL;\n   int saved_call_site_base = call_site_base;\n@@ -2532,7 +2531,7 @@ convert_to_eh_region_ranges (void)\n \teh_region region;\n \tbool nothrow;\n \tint this_action;\n-\trtx this_landing_pad;\n+\trtx_code_label *this_landing_pad;\n \n \tinsn = iter;\n \tif (NONJUMP_INSN_P (insn)\n@@ -2563,7 +2562,7 @@ convert_to_eh_region_ranges (void)\n \tif (this_action >= 0)\n \t  this_landing_pad = lp->landing_pad;\n \telse\n-\t  this_landing_pad = NULL_RTX;\n+\t  this_landing_pad = NULL;\n \n \t/* Differing actions or landing pads implies a change in call-site\n \t   info, which implies some EH_REGION note should be emitted.  */\n@@ -3266,7 +3265,7 @@ dump_eh_tree (FILE * out, struct function *fun)\n \t\t    fprintf (out, \"(nil),\");\n \t\t  if (lp->post_landing_pad)\n \t\t    {\n-\t\t      rtx lab = label_rtx (lp->post_landing_pad);\n+\t\t      rtx_insn *lab = label_rtx (lp->post_landing_pad);\n \t\t      fprintf (out, \"%i%s}\", INSN_UID (lab),\n \t\t\t       NOTE_P (lab) ? \"(del)\" : \"\");\n \t\t    }"}, {"sha": "dd37ab85e0f2d91da558fae4e21375d473637dcc", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -10559,7 +10559,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t      if ((icode = optab_handler (movmisalign_optab, mode))\n \t\t  != CODE_FOR_nothing)\n \t\t{\n-\t\t  rtx reg, insn;\n+\t\t  rtx reg;\n \n \t\t  op0 = adjust_address (op0, mode, 0);\n \t\t  /* We've already validated the memory, and we're creating a\n@@ -10568,7 +10568,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t  reg = gen_reg_rtx (mode);\n \n \t\t  /* Nor can the insn generator.  */\n-\t\t  insn = GEN_FCN (icode) (reg, op0);\n+\t\t  rtx_insn *insn = GEN_FCN (icode) (reg, op0);\n \t\t  emit_insn (insn);\n \t\t  return reg;\n \t\t}"}, {"sha": "f1b791ad1d8230b1a53d0fcfc741f7febb49af65", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -657,13 +657,13 @@ align_fuzz (rtx start, rtx end, int known_align_log, unsigned int growth)\n int\n insn_current_reference_address (rtx_insn *branch)\n {\n-  rtx dest, seq;\n+  rtx dest;\n   int seq_uid;\n \n   if (! INSN_ADDRESSES_SET_P ())\n     return 0;\n \n-  seq = NEXT_INSN (PREV_INSN (branch));\n+  rtx_insn *seq = NEXT_INSN (PREV_INSN (branch));\n   seq_uid = INSN_UID (seq);\n   if (!JUMP_P (branch))\n     /* This can happen for example on the PA; the objective is to know the"}, {"sha": "aec8af6d89364ca092553e9ee2d5e910c9d6847a", "filename": "gcc/function.c", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -3109,8 +3109,8 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t    }\n \t  else\n \t    t = op1;\n-\t  rtx pat = gen_extend_insn (op0, t, promoted_nominal_mode,\n-\t\t\t\t     data->passed_mode, unsignedp);\n+\t  rtx_insn *pat = gen_extend_insn (op0, t, promoted_nominal_mode,\n+\t\t\t\t\t   data->passed_mode, unsignedp);\n \t  emit_insn (pat);\n \t  insns = get_insns ();\n \n@@ -5290,8 +5290,6 @@ set_insn_locations (rtx_insn *insn, int loc)\n void\n expand_function_end (void)\n {\n-  rtx clobber_after;\n-\n   /* If arg_pointer_save_area was referenced only from a nested\n      function, we will not have initialized it yet.  Do that now.  */\n   if (arg_pointer_save_area && ! crtl->arg_pointer_save_area_init)\n@@ -5340,7 +5338,7 @@ expand_function_end (void)\n \n      We delay actual code generation after the current_function_value_rtx\n      is computed.  */\n-  clobber_after = get_last_insn ();\n+  rtx_insn *clobber_after = get_last_insn ();\n \n   /* Output the label for the actual return from the function.  */\n   emit_label (return_label);\n@@ -5490,11 +5488,9 @@ expand_function_end (void)\n      certainly doesn't fall thru into the exit block.  */\n   if (!BARRIER_P (clobber_after))\n     {\n-      rtx seq;\n-\n       start_sequence ();\n       clobber_return_register ();\n-      seq = get_insns ();\n+      rtx_insn *seq = get_insns ();\n       end_sequence ();\n \n       emit_insn_after (seq, clobber_after);\n@@ -5521,11 +5517,11 @@ expand_function_end (void)\n   if (! EXIT_IGNORE_STACK\n       && cfun->calls_alloca)\n     {\n-      rtx tem = 0, seq;\n+      rtx tem = 0;\n \n       start_sequence ();\n       emit_stack_save (SAVE_FUNCTION, &tem);\n-      seq = get_insns ();\n+      rtx_insn *seq = get_insns ();\n       end_sequence ();\n       emit_insn_before (seq, parm_birth_insn);\n \n@@ -5552,15 +5548,13 @@ get_arg_pointer_save_area (void)\n \n   if (! crtl->arg_pointer_save_area_init)\n     {\n-      rtx seq;\n-\n       /* Save the arg pointer at the beginning of the function.  The\n \t generated stack slot may not be a valid memory address, so we\n \t have to check it and fix it if necessary.  */\n       start_sequence ();\n       emit_move_insn (validize_mem (copy_rtx (ret)),\n                       crtl->args.internal_arg_pointer);\n-      seq = get_insns ();\n+      rtx_insn *seq = get_insns ();\n       end_sequence ();\n \n       push_topmost_sequence ();\n@@ -5653,13 +5647,11 @@ prologue_epilogue_contains (const_rtx insn)\n static void\n emit_use_return_register_into_block (basic_block bb)\n {\n-  rtx seq;\n- rtx_insn *insn;\n   start_sequence ();\n   use_return_register ();\n-  seq = get_insns ();\n+  rtx_insn *seq = get_insns ();\n   end_sequence ();\n-  insn = BB_END (bb);\n+  rtx_insn *insn = BB_END (bb);\n   if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n     insn = prev_cc0_setter (insn);\n \n@@ -5686,9 +5678,9 @@ gen_return_pattern (bool simple_p)\n void\n emit_return_into_block (bool simple_p, basic_block bb)\n {\n-  rtx jump, pat;\n-  jump = emit_jump_insn_after (gen_return_pattern (simple_p), BB_END (bb));\n-  pat = PATTERN (jump);\n+  rtx_jump_insn *jump = emit_jump_insn_after (gen_return_pattern (simple_p),\n+\t\t\t\t\t      BB_END (bb));\n+  rtx pat = PATTERN (jump);\n   if (GET_CODE (pat) == PARALLEL)\n     pat = XVECEXP (pat, 0, 0);\n   gcc_assert (ANY_RETURN_P (pat));\n@@ -5733,7 +5725,6 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n {\n   int i;\n   basic_block bb;\n-  rtx label;\n   edge_iterator ei;\n   edge e;\n   auto_vec<basic_block> src_bbs (EDGE_COUNT (last_bb->preds));\n@@ -5742,7 +5733,7 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n     if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n       src_bbs.quick_push (e->src);\n \n-  label = BB_HEAD (last_bb);\n+  rtx_insn *label = BB_HEAD (last_bb);\n \n   FOR_EACH_VEC_ELT (src_bbs, i, bb)\n     {"}, {"sha": "00a8ba7af6f43e33727fb6a9c5df4862fa470a05", "filename": "gcc/gcse-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fgcse-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fgcse-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse-common.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -40,7 +40,7 @@\n void\n canon_list_insert (rtx dest, const_rtx x ATTRIBUTE_UNUSED, void *data)\n {\n-  rtx dest_addr, insn;\n+  rtx dest_addr;\n   int bb;\n   modify_pair pair;\n \n@@ -58,7 +58,7 @@ canon_list_insert (rtx dest, const_rtx x ATTRIBUTE_UNUSED, void *data)\n \n   dest_addr = get_addr (XEXP (dest, 0));\n   dest_addr = canon_rtx (dest_addr);\n-  insn = ((struct gcse_note_stores_info *)data)->insn;\n+  rtx_insn *insn = ((struct gcse_note_stores_info *)data)->insn;\n   bb = BLOCK_FOR_INSN (insn)->index;\n \n   pair.dest = dest;"}, {"sha": "2d456b516199338b15f1db51bd694168b87cf7b7", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -540,7 +540,6 @@ static void trim_ld_motion_mems (void);\n static void update_ld_motion_stores (struct gcse_expr *);\n static void clear_modify_mem_tables (void);\n static void free_modify_mem_tables (void);\n-static rtx gcse_emit_move_after (rtx, rtx, rtx_insn *);\n static bool is_too_expensive (const char *);\n \n #define GNEW(T)\t\t\t((T *) gmalloc (sizeof (T)))\n@@ -2434,7 +2433,7 @@ single_set_gcse (rtx_insn *insn)\n /* Emit move from SRC to DEST noting the equivalence with expression computed\n    in INSN.  */\n \n-static rtx\n+static rtx_insn *\n gcse_emit_move_after (rtx dest, rtx src, rtx_insn *insn)\n {\n   rtx_insn *new_rtx;\n@@ -3960,7 +3959,6 @@ update_ld_motion_stores (struct gcse_expr * expr)\n \t  rtx pat = PATTERN (insn);\n \t  rtx src = SET_SRC (pat);\n \t  rtx reg = expr->reaching_reg;\n-\t  rtx copy;\n \n \t  /* If we've already copied it, continue.  */\n \t  if (expr->reaching_reg == src)\n@@ -3975,7 +3973,7 @@ update_ld_motion_stores (struct gcse_expr * expr)\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n-\t  copy = gen_move_insn (reg, copy_rtx (SET_SRC (pat)));\n+\t  rtx_insn *copy = gen_move_insn (reg, copy_rtx (SET_SRC (pat)));\n \t  emit_insn_before (copy, insn);\n \t  SET_SRC (pat) = reg;\n \t  df_insn_rescan (insn);"}, {"sha": "3e3dff7c4bd30e029479e7eaf6d41a6d75bad2b5", "filename": "gcc/genemit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -450,7 +450,7 @@ gen_expand (rtx expand)\n     printf (\"  rtx operand%d;\\n\", i);\n   for (; i <= stats.max_scratch_opno; i++)\n     printf (\"  rtx operand%d ATTRIBUTE_UNUSED;\\n\", i);\n-  printf (\"  rtx _val = 0;\\n\");\n+  printf (\"  rtx_insn *_val = 0;\\n\");\n   printf (\"  start_sequence ();\\n\");\n \n   /* The fourth operand of DEFINE_EXPAND is some code to be executed"}, {"sha": "0d10f8a70a15462b1d0a70fc43b5a21e4152882e", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -8096,8 +8096,6 @@ init_before_recovery (basic_block *before_recovery_ptr)\n          Between these two blocks recovery blocks will be emitted.  */\n \n       basic_block single, empty;\n-      rtx_insn *x;\n-      rtx label;\n \n       /* If the fallthrough edge to exit we've found is from the block we've\n \t created before, don't do anything more.  */\n@@ -8128,8 +8126,9 @@ init_before_recovery (basic_block *before_recovery_ptr)\n       make_single_succ_edge (empty, EXIT_BLOCK_PTR_FOR_FN (cfun),\n \t\t\t     EDGE_FALLTHRU);\n \n-      label = block_label (empty);\n-      x = emit_jump_insn_after (gen_jump (label), BB_END (single));\n+      rtx_code_label *label = block_label (empty);\n+      rtx_jump_insn *x = emit_jump_insn_after (gen_jump (label),\n+\t\t\t\t\t       BB_END (single));\n       JUMP_LABEL (x) = label;\n       LABEL_NUSES (label)++;\n       haifa_init_insn (x);\n@@ -8160,7 +8159,6 @@ init_before_recovery (basic_block *before_recovery_ptr)\n basic_block\n sched_create_recovery_block (basic_block *before_recovery_ptr)\n {\n-  rtx label;\n   rtx_insn *barrier;\n   basic_block rec;\n \n@@ -8172,7 +8170,7 @@ sched_create_recovery_block (basic_block *before_recovery_ptr)\n   barrier = get_last_bb_insn (before_recovery);\n   gcc_assert (BARRIER_P (barrier));\n \n-  label = emit_label_after (gen_label_rtx (), barrier);\n+  rtx_insn *label = emit_label_after (gen_label_rtx (), barrier);\n \n   rec = create_basic_block (label, label, before_recovery);\n \n@@ -8195,8 +8193,6 @@ void\n sched_create_recovery_edges (basic_block first_bb, basic_block rec,\n \t\t\t     basic_block second_bb)\n {\n-  rtx label;\n-  rtx jump;\n   int edge_flags;\n \n   /* This is fixing of incoming edge.  */\n@@ -8208,8 +8204,8 @@ sched_create_recovery_edges (basic_block first_bb, basic_block rec,\n     edge_flags = 0;\n \n   make_edge (first_bb, rec, edge_flags);\n-  label = block_label (second_bb);\n-  jump = emit_jump_insn_after (gen_jump (label), BB_END (rec));\n+  rtx_code_label *label = block_label (second_bb);\n+  rtx_jump_insn *jump = emit_jump_insn_after (gen_jump (label), BB_END (rec));\n   JUMP_LABEL (jump) = label;\n   LABEL_NUSES (label)++;\n "}, {"sha": "f3616d793c7743603c9dd2275b39a121a4f5033a", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -3767,7 +3767,7 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n   basic_block else_bb = else_edge->dest;\n   basic_block other_bb, trap_bb;\n   rtx_insn *trap, *jump;\n-  rtx cond, seq;\n+  rtx cond;\n   rtx_insn *cond_earliest;\n   enum rtx_code code;\n \n@@ -3812,9 +3812,9 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n     }\n \n   /* Attempt to generate the conditional trap.  */\n-  seq = gen_cond_trap (code, copy_rtx (XEXP (cond, 0)),\n-\t\t       copy_rtx (XEXP (cond, 1)),\n-\t\t       TRAP_CODE (PATTERN (trap)));\n+  rtx_insn *seq = gen_cond_trap (code, copy_rtx (XEXP (cond, 0)),\n+\t\t\t\t copy_rtx (XEXP (cond, 1)),\n+\t\t\t\t TRAP_CODE (PATTERN (trap)));\n   if (seq == NULL)\n     return FALSE;\n \n@@ -3839,10 +3839,9 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n   else if (trap_bb == then_bb)\n     {\n       rtx lab;\n-      rtx_insn *newjump;\n \n       lab = JUMP_LABEL (jump);\n-      newjump = emit_jump_insn_after (gen_jump (lab), jump);\n+      rtx_jump_insn *newjump = emit_jump_insn_after (gen_jump (lab), jump);\n       LABEL_NUSES (lab) += 1;\n       JUMP_LABEL (newjump) = lab;\n       emit_barrier_after (newjump);"}, {"sha": "96e7b53fa266b66cb77f3a362be2ffff885eee7c", "filename": "gcc/jump.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -441,7 +441,6 @@ reversed_comparison_code_parts (enum rtx_code code, const_rtx arg0,\n \n   if (GET_MODE_CLASS (mode) == MODE_CC || CC0_P (arg0))\n     {\n-      const_rtx prev;\n       /* Try to search for the comparison to determine the real mode.\n          This code is expensive, but with sane machine description it\n          will be never used, since REVERSIBLE_CC_MODE will return true\n@@ -452,9 +451,9 @@ reversed_comparison_code_parts (enum rtx_code code, const_rtx arg0,\n       /* These CONST_CAST's are okay because prev_nonnote_insn just\n \t returns its argument and we assign it to a const_rtx\n \t variable.  */\n-      for (prev = prev_nonnote_insn (CONST_CAST_RTX (insn));\n+      for (rtx_insn *prev = prev_nonnote_insn (CONST_CAST_RTX (insn));\n \t   prev != 0 && !LABEL_P (prev);\n-\t   prev = prev_nonnote_insn (CONST_CAST_RTX (prev)))\n+\t   prev = prev_nonnote_insn (prev))\n \t{\n \t  const_rtx set = set_of (arg0, prev);\n \t  if (set && GET_CODE (set) == SET"}, {"sha": "4a020a03e9751c00bc1ec104e0e8ba682882d161", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -882,14 +882,13 @@ pre_check_invariant_p (bool simple, rtx dest)\n   if (simple && REG_P (dest) && DF_REG_DEF_COUNT (REGNO (dest)) > 1)\n     {\n       df_ref use;\n-      rtx ref;\n       unsigned int i = REGNO (dest);\n       struct df_insn_info *insn_info;\n       df_ref def_rec;\n \n       for (use = DF_REG_USE_CHAIN (i); use; use = DF_REF_NEXT_REG (use))\n \t{\n-\t  ref = DF_REF_INSN (use);\n+\t  rtx_insn *ref = DF_REF_INSN (use);\n \t  insn_info = DF_INSN_INFO_GET (ref);\n \n \t  FOR_EACH_INSN_INFO_DEF (def_rec, insn_info)"}, {"sha": "81603e53e6c2a7e9ffb85543b76cfbb408f5f991", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -2036,7 +2036,7 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \n \t      for (pnote = &cond_list; *pnote; pnote = pnote_next)\n \t\t{\n-\t\t  rtx note = *pnote;\n+\t\t  rtx_expr_list *note = *pnote;\n \t\t  rtx old_cond = XEXP (note, 0);\n \n \t\t  pnote_next = (rtx_expr_list **)&XEXP (note, 1);\n@@ -2070,7 +2070,7 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \t      /* Likewise for the conditions.  */\n \t      for (pnote = &cond_list; *pnote; pnote = pnote_next)\n \t\t{\n-\t\t  rtx note = *pnote;\n+\t\t  rtx_expr_list *note = *pnote;\n \t\t  rtx old_cond = XEXP (note, 0);\n \n \t\t  pnote_next = (rtx_expr_list **)&XEXP (note, 1);"}, {"sha": "756871b4814f37136a69f40c4755d81c9b65d6d4", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -871,7 +871,7 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t      rtx_insn **before, rtx_insn **after)\n {\n   int i, in;\n-  rtx new_in_reg, new_out_reg, reg, clobber;\n+  rtx new_in_reg, new_out_reg, reg;\n   machine_mode inmode, outmode;\n   rtx in_rtx = *curr_id->operand_loc[ins[0]];\n   rtx out_rtx = out < 0 ? in_rtx : *curr_id->operand_loc[out];\n@@ -912,7 +912,7 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t     NEW_OUT_REG living above.  We add clobber clause for\n \t     this.  This is just a temporary clobber.  We can remove\n \t     it at the end of LRA work.  */\n-\t  clobber = emit_clobber (new_out_reg);\n+\t  rtx_insn *clobber = emit_clobber (new_out_reg);\n \t  LRA_TEMP_CLOBBER_P (PATTERN (clobber)) = 1;\n \t  LRA_SUBREG_P (new_in_reg) = 1;\n \t  if (GET_CODE (in_rtx) == SUBREG)\n@@ -5558,7 +5558,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t\t\t   || reg_renumber[src_regno] >= 0)\n \t\t    {\n \t\t      bool before_p;\n-\t\t      rtx use_insn = curr_insn;\n+\t\t      rtx_insn *use_insn = curr_insn;\n \n \t\t      before_p = (JUMP_P (curr_insn)\n \t\t\t\t  || (CALL_P (curr_insn) && reg->type == OP_IN));"}, {"sha": "03c73925827395589835a157b88154a9f6b93905", "filename": "gcc/lra.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -306,7 +306,7 @@ lra_delete_dead_insn (rtx_insn *insn)\n /* Emit insn x = y + z.  Return NULL if we failed to do it.\n    Otherwise, return the insn.  We don't use gen_add3_insn as it might\n    clobber CC.  */\n-static rtx\n+static rtx_insn *\n emit_add3_insn (rtx x, rtx y, rtx z)\n {\n   rtx_insn *last;\n@@ -315,7 +315,7 @@ emit_add3_insn (rtx x, rtx y, rtx z)\n \n   if (have_addptr3_insn (x, y, z))\n     {\n-      rtx insn = gen_addptr3_insn (x, y, z);\n+      rtx_insn *insn = gen_addptr3_insn (x, y, z);\n \n       /* If the target provides an \"addptr\" pattern it hopefully does\n \t for a reason.  So falling back to the normal add would be\n@@ -337,12 +337,10 @@ emit_add3_insn (rtx x, rtx y, rtx z)\n \n /* Emit insn x = x + y.  Return the insn.  We use gen_add2_insn as the\n    last resort.  */\n-static rtx\n+static rtx_insn *\n emit_add2_insn (rtx x, rtx y)\n {\n-  rtx insn;\n-\n-  insn = emit_add3_insn (x, x, y);\n+  rtx_insn *insn = emit_add3_insn (x, x, y);\n   if (insn == NULL_RTX)\n     {\n       insn = gen_add2_insn (x, y);\n@@ -370,7 +368,7 @@ lra_emit_add (rtx x, rtx y, rtx z)\n   rtx a1, a2, base, index, disp, scale, index_scale;\n   bool ok_p;\n \n-  rtx add3_insn = emit_add3_insn (x, y, z);\n+  rtx_insn *add3_insn = emit_add3_insn (x, y, z);\n   old = max_reg_num ();\n   if (add3_insn != NULL)\n     ;\n@@ -423,7 +421,7 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t     adding the address segment to register.  */\n \t  lra_assert (x != y && x != z);\n \t  emit_move_insn (x, y);\n-\t  rtx insn = emit_add2_insn (x, z);\n+\t  rtx_insn *insn = emit_add2_insn (x, z);\n \t  lra_assert (insn != NULL_RTX);\n \t}\n       else\n@@ -435,7 +433,7 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t      /* Generate x = index_scale; x = x + base.  */\n \t      lra_assert (index_scale != NULL_RTX && base != NULL_RTX);\n \t      emit_move_insn (x, index_scale);\n-\t      rtx insn = emit_add2_insn (x, base);\n+\t      rtx_insn *insn = emit_add2_insn (x, base);\n \t      lra_assert (insn != NULL_RTX);\n \t    }\n \t  else if (scale == NULL_RTX)\n@@ -450,13 +448,13 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t\t  delete_insns_since (last);\n \t\t  /* Generate x = disp; x = x + base.  */\n \t\t  emit_move_insn (x, disp);\n-\t\t  rtx add2_insn = emit_add2_insn (x, base);\n+\t\t  rtx_insn *add2_insn = emit_add2_insn (x, base);\n \t\t  lra_assert (add2_insn != NULL_RTX);\n \t\t}\n \t      /* Generate x = x + index.  */\n \t      if (index != NULL_RTX)\n \t\t{\n-\t\t  rtx insn = emit_add2_insn (x, index);\n+\t\t  rtx_insn *insn = emit_add2_insn (x, index);\n \t\t  lra_assert (insn != NULL_RTX);\n \t\t}\n \t    }\n@@ -468,7 +466,7 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t      ok_p = false;\n \t      if (recog_memoized (move_insn) >= 0)\n \t\t{\n-\t\t  rtx insn = emit_add2_insn (x, disp);\n+\t\t  rtx_insn *insn = emit_add2_insn (x, disp);\n \t\t  if (insn != NULL_RTX)\n \t\t    {\n \t\t      insn = emit_add2_insn (x, base);\n@@ -481,7 +479,7 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t\t  delete_insns_since (last);\n \t\t  /* Generate x = disp; x = x + base; x = x + index_scale.  */\n \t\t  emit_move_insn (x, disp);\n-\t\t  rtx insn = emit_add2_insn (x, base);\n+\t\t  rtx_insn *insn = emit_add2_insn (x, base);\n \t\t  lra_assert (insn != NULL_RTX);\n \t\t  insn = emit_add2_insn (x, index_scale);\n \t\t  lra_assert (insn != NULL_RTX);"}, {"sha": "b523f4889f36f598cb22c1c1482fd34a43e44658", "filename": "gcc/optabs.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -2048,7 +2048,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  if (optab_handler (mov_optab, mode) != CODE_FOR_nothing\n \t      || ! rtx_equal_p (target, xtarget))\n \t    {\n-\t      rtx temp = emit_move_insn (target, xtarget);\n+\t      rtx_insn *temp = emit_move_insn (target, xtarget);\n \n \t      set_dst_reg_note (temp, REG_EQUAL,\n \t\t\t\tgen_rtx_fmt_ee (optab_to_code (binoptab),\n@@ -4720,7 +4720,7 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n /* Generate and return an insn body to add Y to X.  */\n \n-rtx\n+rtx_insn *\n gen_add2_insn (rtx x, rtx y)\n {\n   enum insn_code icode = optab_handler (add_optab, GET_MODE (x));\n@@ -4735,7 +4735,7 @@ gen_add2_insn (rtx x, rtx y)\n /* Generate and return an insn body to add r1 and c,\n    storing the result in r0.  */\n \n-rtx\n+rtx_insn *\n gen_add3_insn (rtx r0, rtx r1, rtx c)\n {\n   enum insn_code icode = optab_handler (add_optab, GET_MODE (r0));\n@@ -4744,7 +4744,7 @@ gen_add3_insn (rtx r0, rtx r1, rtx c)\n       || !insn_operand_matches (icode, 0, r0)\n       || !insn_operand_matches (icode, 1, r1)\n       || !insn_operand_matches (icode, 2, c))\n-    return NULL_RTX;\n+    return NULL;\n \n   return GEN_FCN (icode) (r0, r1, c);\n }\n@@ -4771,7 +4771,7 @@ have_add2_insn (rtx x, rtx y)\n \n /* Generate and return an insn body to add Y to X.  */\n \n-rtx\n+rtx_insn *\n gen_addptr3_insn (rtx x, rtx y, rtx z)\n {\n   enum insn_code icode = optab_handler (addptr3_optab, GET_MODE (x));\n@@ -4808,7 +4808,7 @@ have_addptr3_insn (rtx x, rtx y, rtx z)\n \n /* Generate and return an insn body to subtract Y from X.  */\n \n-rtx\n+rtx_insn *\n gen_sub2_insn (rtx x, rtx y)\n {\n   enum insn_code icode = optab_handler (sub_optab, GET_MODE (x));\n@@ -4823,7 +4823,7 @@ gen_sub2_insn (rtx x, rtx y)\n /* Generate and return an insn body to subtract r1 and c,\n    storing the result in r0.  */\n \n-rtx\n+rtx_insn *\n gen_sub3_insn (rtx r0, rtx r1, rtx c)\n {\n   enum insn_code icode = optab_handler (sub_optab, GET_MODE (r0));\n@@ -4832,7 +4832,7 @@ gen_sub3_insn (rtx r0, rtx r1, rtx c)\n       || !insn_operand_matches (icode, 0, r0)\n       || !insn_operand_matches (icode, 1, r1)\n       || !insn_operand_matches (icode, 2, c))\n-    return NULL_RTX;\n+    return NULL;\n \n   return GEN_FCN (icode) (r0, r1, c);\n }\n@@ -4878,7 +4878,7 @@ can_extend_p (machine_mode to_mode, machine_mode from_mode,\n /* Generate the body of an insn to extend Y (with mode MFROM)\n    into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */\n \n-rtx\n+rtx_insn *\n gen_extend_insn (rtx x, rtx y, machine_mode mto,\n \t\t machine_mode mfrom, int unsignedp)\n {\n@@ -6395,12 +6395,12 @@ debug_optab_libfuncs (void)\n /* Generate insns to trap with code TCODE if OP1 and OP2 satisfy condition\n    CODE.  Return 0 on failure.  */\n \n-rtx\n+rtx_insn *\n gen_cond_trap (enum rtx_code code, rtx op1, rtx op2, rtx tcode)\n {\n   machine_mode mode = GET_MODE (op1);\n   enum insn_code icode;\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx trap_rtx;\n \n   if (mode == VOIDmode)\n@@ -6419,7 +6419,7 @@ gen_cond_trap (enum rtx_code code, rtx op1, rtx op2, rtx tcode)\n   prepare_cmp_insn (op1, op2, code, NULL_RTX, false, OPTAB_DIRECT,\n \t\t    &trap_rtx, &mode);\n   if (!trap_rtx)\n-    insn = NULL_RTX;\n+    insn = NULL;\n   else\n     insn = GEN_FCN (icode) (trap_rtx, XEXP (trap_rtx, 0), XEXP (trap_rtx, 1),\n \t\t\t    tcode);\n@@ -8382,7 +8382,7 @@ bool\n maybe_expand_insn (enum insn_code icode, unsigned int nops,\n \t\t   struct expand_operand *ops)\n {\n-  rtx pat = maybe_gen_insn (icode, nops, ops);\n+  rtx_insn *pat = maybe_gen_insn (icode, nops, ops);\n   if (pat)\n     {\n       emit_insn (pat);\n@@ -8397,7 +8397,7 @@ bool\n maybe_expand_jump_insn (enum insn_code icode, unsigned int nops,\n \t\t\tstruct expand_operand *ops)\n {\n-  rtx pat = maybe_gen_insn (icode, nops, ops);\n+  rtx_insn *pat = maybe_gen_insn (icode, nops, ops);\n   if (pat)\n     {\n       emit_jump_insn (pat);"}, {"sha": "95f5cbcf56af7e3fea7d5cb305f84a4b788de50f", "filename": "gcc/optabs.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -377,22 +377,21 @@ rtx emit_conditional_add (rtx, enum rtx_code, rtx, rtx, machine_mode,\n /* Create but don't emit one rtl instruction to perform certain operations.\n    Modes must match; operands must meet the operation's predicates.\n    Likewise for subtraction and for just copying.  */\n-extern rtx gen_add2_insn (rtx, rtx);\n-extern rtx gen_add3_insn (rtx, rtx, rtx);\n+extern rtx_insn *gen_add2_insn (rtx, rtx);\n+extern rtx_insn *gen_add3_insn (rtx, rtx, rtx);\n extern int have_add2_insn (rtx, rtx);\n-extern rtx gen_addptr3_insn (rtx, rtx, rtx);\n+extern rtx_insn *gen_addptr3_insn (rtx, rtx, rtx);\n extern int have_addptr3_insn (rtx, rtx, rtx);\n-extern rtx gen_sub2_insn (rtx, rtx);\n-extern rtx gen_sub3_insn (rtx, rtx, rtx);\n+extern rtx_insn *gen_sub2_insn (rtx, rtx);\n+extern rtx_insn *gen_sub3_insn (rtx, rtx, rtx);\n extern int have_sub2_insn (rtx, rtx);\n \n /* Return the INSN_CODE to use for an extend operation.  */\n extern enum insn_code can_extend_p (machine_mode, machine_mode, int);\n \n /* Generate the body of an insn to extend Y (with mode MFROM)\n    into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */\n-extern rtx gen_extend_insn (rtx, rtx, machine_mode,\n-\t\t\t    machine_mode, int);\n+extern rtx_insn *gen_extend_insn (rtx, rtx, machine_mode, machine_mode, int);\n \n /* Return the insn_code for a FLOAT_EXPR.  */\n enum insn_code can_float_p (machine_mode, machine_mode, int);\n@@ -488,7 +487,7 @@ extern void init_tree_optimization_optabs (tree);\n extern void init_sync_libfuncs (int max);\n \n /* Generate a conditional trap instruction.  */\n-extern rtx gen_cond_trap (enum rtx_code, rtx, rtx, rtx);\n+extern rtx_insn *gen_cond_trap (enum rtx_code, rtx, rtx, rtx);\n \n /* Return true if target supports vector operations for VEC_PERM_EXPR.  */\n extern bool can_vec_perm_p (machine_mode, bool, const unsigned char *);"}, {"sha": "d2b2f73f8c875c764e1d9c35a7af43351e211718", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -769,7 +769,7 @@ debug_rtx_range (const rtx_insn *start, const rtx_insn *end)\n    and then call debug_rtx_list to print it, using DEBUG_RTX_COUNT.\n    The found insn is returned to enable further debugging analysis.  */\n \n-DEBUG_FUNCTION const_rtx\n+DEBUG_FUNCTION const rtx_insn *\n debug_rtx_find (const rtx_insn *x, int uid)\n {\n   while (x != 0 && INSN_UID (x) != uid)"}, {"sha": "7c57227ae01224790f4c854ac1fdba5d62d328e7", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -1649,7 +1649,7 @@ calculate_elim_costs_all_insns (void)\n \t\t      || reg_equiv_invariant (REGNO (SET_DEST (set)))))\n \t\t{\n \t\t  unsigned regno = REGNO (SET_DEST (set));\n-\t\t  rtx init = reg_equiv_init (regno);\n+\t\t  rtx_insn_list *init = reg_equiv_init (regno);\n \t\t  if (init)\n \t\t    {\n \t\t      rtx t = eliminate_regs_1 (SET_SRC (set), VOIDmode, insn,\n@@ -8226,7 +8226,7 @@ emit_reload_insns (struct insn_chain *chain)\n \n   for (j = 0; j < reload_n_operands; j++)\n     {\n-      rtx x = emit_insn_after (outaddr_address_reload_insns[j], insn);\n+      rtx_insn *x = emit_insn_after (outaddr_address_reload_insns[j], insn);\n       x = emit_insn_after (output_address_reload_insns[j], x);\n       x = emit_insn_after (output_reload_insns[j], x);\n       emit_insn_after (other_output_reload_insns[j], x);"}, {"sha": "8a2d3581038b4b51771f6ac91345533db55503b4", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -894,7 +894,6 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n   unsigned int i;\n   struct target_info *tinfo = NULL;\n   rtx_insn *insn;\n-  rtx jump_insn = 0;\n   rtx jump_target;\n   HARD_REG_SET scratch;\n   struct resources set, needed;\n@@ -1122,8 +1121,8 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n   CLEAR_RESOURCE (&set);\n   CLEAR_RESOURCE (&needed);\n \n-  jump_insn = find_dead_or_set_registers (target, res, &jump_target, 0,\n-\t\t\t\t\t  set, needed);\n+  rtx_insn *jump_insn = find_dead_or_set_registers (target, res, &jump_target,\n+\t\t\t\t\t\t    0, set, needed);\n \n   /* If we hit an unconditional branch, we have another way of finding out\n      what is live: we can see what is live at the branch target and include"}, {"sha": "8994f897c67f22cf8ab1ca4eea939c9695d62017", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -3525,7 +3525,7 @@ extern void debug (const rtx_def *ptr);\n extern void debug_rtx (const_rtx);\n extern void debug_rtx_list (const rtx_insn *, int);\n extern void debug_rtx_range (const rtx_insn *, const rtx_insn *);\n-extern const_rtx debug_rtx_find (const rtx_insn *, int);\n+extern const rtx_insn *debug_rtx_find (const rtx_insn *, int);\n extern void print_mem_expr (FILE *, const_tree);\n extern void print_rtl (FILE *, const_rtx);\n extern void print_simple_rtl (FILE *, const_rtx);"}, {"sha": "28a042af205edf238dbb7dc2ed9e17d35d33412c", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -2226,7 +2226,7 @@ void\n remove_node_from_expr_list (const_rtx node, rtx_expr_list **listp)\n {\n   rtx_expr_list *temp = *listp;\n-  rtx prev = NULL_RTX;\n+  rtx_expr_list *prev = NULL;\n \n   while (temp)\n     {\n@@ -2255,7 +2255,7 @@ void\n remove_node_from_insn_list (const rtx_insn *node, rtx_insn_list **listp)\n {\n   rtx_insn_list *temp = *listp;\n-  rtx prev = NULL;\n+  rtx_insn_list *prev = NULL;\n \n   while (temp)\n     {"}, {"sha": "fea2704686cdc164d06c19a5da88b472b50977d7", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -3003,8 +3003,7 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \n   if (JUMP_P (insn))\n     {\n-      rtx next;\n-      next = next_nonnote_nondebug_insn (insn);\n+      rtx_insn *next = next_nonnote_nondebug_insn (insn);\n       if (next && BARRIER_P (next))\n \treg_pending_barrier = MOVE_BARRIER;\n       else\n@@ -3591,8 +3590,6 @@ call_may_noreturn_p (rtx_insn *insn)\n static bool\n chain_to_prev_insn_p (rtx_insn *insn)\n {\n-  rtx prev, x;\n-\n   /* INSN forms a group with the previous instruction.  */\n   if (SCHED_GROUP_P (insn))\n     return true;\n@@ -3601,13 +3598,13 @@ chain_to_prev_insn_p (rtx_insn *insn)\n      part of R, the clobber was added specifically to help us track the\n      liveness of R.  There's no point scheduling the clobber and leaving\n      INSN behind, especially if we move the clobber to another block.  */\n-  prev = prev_nonnote_nondebug_insn (insn);\n+  rtx_insn *prev = prev_nonnote_nondebug_insn (insn);\n   if (prev\n       && INSN_P (prev)\n       && BLOCK_FOR_INSN (prev) == BLOCK_FOR_INSN (insn)\n       && GET_CODE (PATTERN (prev)) == CLOBBER)\n     {\n-      x = XEXP (PATTERN (prev), 0);\n+      rtx x = XEXP (PATTERN (prev), 0);\n       if (set_of (x, insn))\n \treturn true;\n     }"}, {"sha": "6be775f89871fbe708bb70886cbed8867b1de318", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -183,9 +183,7 @@ begin_move_insn (rtx_insn *insn, rtx_insn *last)\n \t\t\t   && BB_END (last_bb) == insn);\n \n       {\n-\trtx x;\n-\n-\tx = NEXT_INSN (insn);\n+\trtx_insn *x = NEXT_INSN (insn);\n \tif (e)\n \t  gcc_checking_assert (NOTE_P (x) || LABEL_P (x));\n \telse"}, {"sha": "1c3614b1f18af43acf8344f65294cd566c1056d0", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -4560,9 +4560,7 @@ sel_bb_head (basic_block bb)\n     }\n   else\n     {\n-      insn_t note;\n-\n-      note = bb_note (bb);\n+      rtx_note *note = bb_note (bb);\n       head = next_nonnote_insn (note);\n \n       if (head && (BARRIER_P (head) || BLOCK_FOR_INSN (head) != bb))\n@@ -4983,7 +4981,7 @@ clear_outdated_rtx_info (basic_block bb)\n static void\n return_bb_to_pool (basic_block bb)\n {\n-  rtx note = bb_note (bb);\n+  rtx_note *note = bb_note (bb);\n \n   gcc_assert (NOTE_BASIC_BLOCK (note) == bb\n \t      && bb->aux == NULL);"}, {"sha": "5c49d8e0e9a5a03b987ef98720428c62cfedcbea", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -4726,11 +4726,10 @@ static int\n find_seqno_for_bookkeeping (insn_t place_to_insert, insn_t join_point)\n {\n   int seqno;\n-  rtx next;\n \n   /* Check if we are about to insert bookkeeping copy before a jump, and use\n      jump's seqno for the copy; otherwise, use JOIN_POINT's seqno.  */\n-  next = NEXT_INSN (place_to_insert);\n+  rtx_insn *next = NEXT_INSN (place_to_insert);\n   if (INSN_P (next)\n       && JUMP_P (next)\n       && BLOCK_FOR_INSN (next) == BLOCK_FOR_INSN (place_to_insert))\n@@ -5151,11 +5150,11 @@ find_sequential_best_exprs (bnd_t bnd, expr_t expr_vliw, bool for_moveop)\n static void ATTRIBUTE_UNUSED\n move_nop_to_previous_block (insn_t nop, basic_block prev_bb)\n {\n-  insn_t prev_insn, next_insn, note;\n+  insn_t prev_insn, next_insn;\n \n   gcc_assert (sel_bb_head_p (nop)\n               && prev_bb == BLOCK_FOR_INSN (nop)->prev_bb);\n-  note = bb_note (BLOCK_FOR_INSN (nop));\n+  rtx_note *note = bb_note (BLOCK_FOR_INSN (nop));\n   prev_insn = sel_bb_end (prev_bb);\n   next_insn = NEXT_INSN (nop);\n   gcc_assert (prev_insn != NULL_RTX\n@@ -6741,10 +6740,11 @@ static void\n init_seqno_1 (basic_block bb, sbitmap visited_bbs, bitmap blocks_to_reschedule)\n {\n   int bbi = BLOCK_TO_BB (bb->index);\n-  insn_t insn, note = bb_note (bb);\n+  insn_t insn;\n   insn_t succ_insn;\n   succ_iterator si;\n \n+  rtx_note *note = bb_note (bb);\n   bitmap_set_bit (visited_bbs, bbi);\n   if (blocks_to_reschedule)\n     bitmap_clear_bit (blocks_to_reschedule, bb->index);"}, {"sha": "542ab9b5fef964f186ad17417a00964814aca1e9", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -813,7 +813,6 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n \t    FOR_EACH_BB_REVERSE_FN (bb, cfun)\n \t      {\n \t\tbasic_block copy_bb, tbb;\n-\t\trtx_insn *insert_point;\n \t\tint eflags;\n \n \t\tif (!bitmap_clear_bit (&bb_tail, bb->index))\n@@ -843,8 +842,8 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n \t\t    BB_COPY_PARTITION (copy_bb, bb);\n \t\t  }\n \n-\t\tinsert_point = emit_note_after (NOTE_INSN_DELETED,\n-\t\t\t\t\t\tBB_END (copy_bb));\n+\t\trtx_note *insert_point = emit_note_after (NOTE_INSN_DELETED,\n+\t\t\t\t\t\t\t  BB_END (copy_bb));\n \t\temit_barrier_after (BB_END (copy_bb));\n \n \t\ttbb = bb;\n@@ -1008,12 +1007,11 @@ convert_to_simple_return (edge entry_edge, edge orig_entry_edge,\n \t  else if (*pdest_bb == NULL)\n \t    {\n \t      basic_block bb;\n-\t      rtx_insn *start;\n \n \t      bb = create_basic_block (NULL, NULL, exit_pred);\n \t      BB_COPY_PARTITION (bb, e->src);\n-\t      start = emit_jump_insn_after (gen_simple_return (),\n-\t\t\t\t\t    BB_END (bb));\n+\t      rtx_jump_insn *start = emit_jump_insn_after (gen_simple_return (),\n+\t\t\t\t\t\t\t   BB_END (bb));\n \t      JUMP_LABEL (start) = simple_return_rtx;\n \t      emit_barrier_after (start);\n "}, {"sha": "86d3d002a6a46bb784c31cbf8d640beb716dcf1b", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -980,7 +980,7 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n   int i, ncases;\n   struct case_node *n;\n   rtx *labelvec;\n-  rtx fallback_label = label_rtx (case_list->code_label);\n+  rtx_insn *fallback_label = label_rtx (case_list->code_label);\n   rtx_code_label *table_label = gen_label_rtx ();\n   bool has_gaps = false;\n   edge default_edge = stmt_bb ? EDGE_SUCC (stmt_bb, 0) : NULL;"}, {"sha": "42392cb8c7453ebfb3a0a08b45e55047933e6702", "filename": "gcc/store-motion.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d1102e0d55effe57427369957351d206f6475/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=e67d1102e0d55effe57427369957351d206f6475", "patch": "@@ -304,10 +304,10 @@ store_ops_ok (const_rtx x, int *regs_set)\n /* Returns a list of registers mentioned in X.\n    FIXME: A regset would be prettier and less expensive.  */\n \n-static rtx\n+static rtx_expr_list *\n extract_mentioned_regs (rtx x)\n {\n-  rtx mentioned_regs = NULL;\n+  rtx_expr_list *mentioned_regs = NULL;\n   subrtx_var_iterator::array_type array;\n   FOR_EACH_SUBRTX_VAR (iter, array, x, NONCONST)\n     {"}]}