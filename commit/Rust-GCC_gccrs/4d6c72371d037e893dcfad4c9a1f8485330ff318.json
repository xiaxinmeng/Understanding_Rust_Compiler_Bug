{"sha": "4d6c72371d037e893dcfad4c9a1f8485330ff318", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ2YzcyMzcxZDAzN2U4OTNkY2ZhZDRjOWExZjg0ODUzMzBmZjMxOA==", "commit": {"author": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-12-11T19:35:41Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-12-11T19:35:41Z"}, "message": "[multiple changes]\n\n2008-12-11  Harsha Jagasia  <harsha.jagasia@amd.com>\n\n\tPR tree-optimization/38446\n\t* graphite.c (register_bb_in_sese): New.\n\t(bb_in_sese_p): Check if bb belongs to sese region by explicitly\n\tlooking at the bbs in the region.\n\t* graphite.h (sese): Add region_basic_blocks pointer set to\n\tstructure and initialize at the time of defining new scop.\n\n2008-12-11  Tobias Grosser  <grosser@fim.uni-passau.de>\n\n\t* graphite.c (new_graphite_bb): Initialize GBB_STATIC_SCHEDULE.\n\t(find_params_in_bb): Do not free data refs.\n\t(free_graphite_bb): Add FIXME on disabled free_data_refs.\n\n2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite.c (struct ivtype_map_elt): New.\n\t(debug_ivtype_elt, debug_ivtype_map_1, debug_ivtype_map,\n\tnew_ivtype_map_elt, ivtype_map_elt_info, eq_ivtype_map_elts,\n\tgcc_type_for_cloog_iv): New.\n\t(loop_iv_stack_patch_for_consts): Use the type of the induction\n\tvariable from the original loop, except for the automatically\n\tgenerated loops, i.e., in the case of a strip-mined loop, in\n\twhich case there is no original loop: in that case just use\n\tinteger_type_node.\n\t(new_graphite_bb): Initialize GBB_CLOOG_IV_TYPES.\n\t(free_graphite_bb): Free GBB_CLOOG_IV_TYPES.\n\t(clast_name_to_gcc): Accept params to be NULL.\n\t(clast_to_gcc_expression): Take an extra parameter for the type.\n\tConvert to that type all the expressions built by this function.\n\t(gcc_type_for_clast_expr, gcc_type_for_clast_eq): New.\n\t(graphite_translate_clast_equation): Compute the type of the\n\tclast_equation before translating its LHS and RHS.\n\t(clast_get_body_of_loop, gcc_type_for_iv_of_clast_loop): New.\n\t(graphite_create_new_loop): Compute the type of the induction\n\tvariable before translating the lower and upper bounds and before\n\tcreating the induction variable.\n\t(rename_variables_from_edge, rename_phis_end_scop): New.\n\t(copy_bb_and_scalar_dependences): Call rename_phis_end_scop.\n\t(sese_add_exit_phis_edge): Do not use integer_zero_node.\n\t(find_cloog_iv_in_expr, compute_cloog_iv_types_1,\n\tcompute_cloog_iv_types): New.\n\t(gloog): Call compute_cloog_iv_types before starting the\n\ttranslation of the clast.\n\n\t* graphite.h (struct graphite_bb): New field cloog_iv_types.\n\t(GBB_CLOOG_IV_TYPES): New.\n\t(debug_ivtype_map): Declared.\n\t(oldiv_for_loop): New.\n\n2008-12-10  Tobias Grosser  <grosser@fim.uni-passau.de>\n\n\tPR middle-end/38459\n\t* graphite.c (new_scop): Initialize SCOP_ADD_PARAMS.\n\t(param_index): Assert if parameter is not know after parameter\n\tdetection.\n\t(find_params_in_bb): Detect params directly in GBB_CONDITIONS.\n\t(find_scop_parameters): Mark, that we have finished parameter\n\tdetection.\n\t(graphite_transform_loops): Move condition detection before parameter\n\tdetection.\n\t* graphite.h (struct scop): Add SCOP_ADD_PARAMS.\n\n2008-12-11  Harsha Jagasia  <harsha.jagasia@amd.com>\n\n\tPR tree-optimization/38446\n\t* gcc.dg/graphite/pr38446.c: New.\n\n2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* gcc.dg/graphite/scop-16.c: Test only scop specific info.\n\t* gcc.dg/graphite/scop-17.c: Same.\n\t* gcc.dg/graphite/block-5.c: New.\n\t* gcc.dg/graphite/block-6.c: New.\n\t* gcc.dg/graphite/pr37485.c: Clean dump file after.\n\t* gcc.dg/graphite/pr37684.c: Same.\n\t* gcc.dg/graphite/block-2.c: Same.\n\n2008-12-10  Tobias Grosser  <grosser@fim.uni-passau.de>\n\n\tPR middle-end/38459\n\t* gfortran.dg/graphite/pr38459.f90: New.\n\nFrom-SVN: r142688", "tree": {"sha": "04c4f68f06c094df9aae98b66d89ca341a444b4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04c4f68f06c094df9aae98b66d89ca341a444b4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d6c72371d037e893dcfad4c9a1f8485330ff318", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6c72371d037e893dcfad4c9a1f8485330ff318", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d6c72371d037e893dcfad4c9a1f8485330ff318", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6c72371d037e893dcfad4c9a1f8485330ff318/comments", "author": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6b561e4c253e654d60d7a155c9eb315457c7449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6b561e4c253e654d60d7a155c9eb315457c7449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6b561e4c253e654d60d7a155c9eb315457c7449"}], "stats": {"total": 765, "additions": 684, "deletions": 81}, "files": [{"sha": "64a7b927315e91e52833ffac0f2c9242623bef64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -1,3 +1,67 @@\n+2008-12-11  Harsha Jagasia  <harsha.jagasia@amd.com>\n+\n+\tPR tree-optimization/38446\n+\t* graphite.c (register_bb_in_sese): New.\n+\t(bb_in_sese_p): Check if bb belongs to sese region by explicitly\n+\tlooking at the bbs in the region.\n+\t* graphite.h (sese): Add region_basic_blocks pointer set to\n+\tstructure and initialize at the time of defining new scop.\n+\n+2008-12-11  Tobias Grosser  <grosser@fim.uni-passau.de>\n+\n+\t* graphite.c (new_graphite_bb): Initialize GBB_STATIC_SCHEDULE.\n+\t(find_params_in_bb): Do not free data refs.\n+\t(free_graphite_bb): Add FIXME on disabled free_data_refs.\n+\n+2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite.c (struct ivtype_map_elt): New.\n+\t(debug_ivtype_elt, debug_ivtype_map_1, debug_ivtype_map,\n+\tnew_ivtype_map_elt, ivtype_map_elt_info, eq_ivtype_map_elts,\n+\tgcc_type_for_cloog_iv): New.\n+\t(loop_iv_stack_patch_for_consts): Use the type of the induction\n+\tvariable from the original loop, except for the automatically\n+\tgenerated loops, i.e., in the case of a strip-mined loop, in\n+\twhich case there is no original loop: in that case just use\n+\tinteger_type_node.\n+\t(new_graphite_bb): Initialize GBB_CLOOG_IV_TYPES.\n+\t(free_graphite_bb): Free GBB_CLOOG_IV_TYPES.\n+\t(clast_name_to_gcc): Accept params to be NULL.\n+\t(clast_to_gcc_expression): Take an extra parameter for the type.\n+\tConvert to that type all the expressions built by this function.\n+\t(gcc_type_for_clast_expr, gcc_type_for_clast_eq): New.\n+\t(graphite_translate_clast_equation): Compute the type of the\n+\tclast_equation before translating its LHS and RHS.\n+\t(clast_get_body_of_loop, gcc_type_for_iv_of_clast_loop): New.\n+\t(graphite_create_new_loop): Compute the type of the induction\n+\tvariable before translating the lower and upper bounds and before\n+\tcreating the induction variable.\n+\t(rename_variables_from_edge, rename_phis_end_scop): New.\n+\t(copy_bb_and_scalar_dependences): Call rename_phis_end_scop.\n+\t(sese_add_exit_phis_edge): Do not use integer_zero_node.\n+\t(find_cloog_iv_in_expr, compute_cloog_iv_types_1,\n+\tcompute_cloog_iv_types): New.\n+\t(gloog): Call compute_cloog_iv_types before starting the\n+\ttranslation of the clast.\n+\n+\t* graphite.h (struct graphite_bb): New field cloog_iv_types.\n+\t(GBB_CLOOG_IV_TYPES): New.\n+\t(debug_ivtype_map): Declared.\n+\t(oldiv_for_loop): New.\n+\n+2008-12-10  Tobias Grosser  <grosser@fim.uni-passau.de>\n+\n+\tPR middle-end/38459\n+\t* graphite.c (new_scop): Initialize SCOP_ADD_PARAMS.\n+\t(param_index): Assert if parameter is not know after parameter\n+\tdetection.\n+\t(find_params_in_bb): Detect params directly in GBB_CONDITIONS.\n+\t(find_scop_parameters): Mark, that we have finished parameter\n+\tdetection.\n+\t(graphite_transform_loops): Move condition detection before parameter\n+\tdetection.\n+\t* graphite.h (struct scop): Add SCOP_ADD_PARAMS.\n+\n 2008-12-11  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR testsuite/35677"}, {"sha": "877dffe2816c7de1389d01394b6431c0d8425a06", "filename": "gcc/graphite.c", "status": "modified", "additions": 453, "deletions": 74, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -64,9 +64,9 @@ static VEC (scop_p, heap) *current_scops;\n /* Converts a GMP constant V to a tree and returns it.  */\n \n static tree\n-gmp_cst_to_tree (Value v)\n+gmp_cst_to_tree (tree type, Value v)\n {\n-  return build_int_cst (integer_type_node, value_get_si (v));\n+  return build_int_cst (type, value_get_si (v));\n }\n \n /* Debug the list of old induction variables for this SCOP.  */\n@@ -244,6 +244,98 @@ free_loop_iv_stack (loop_iv_stack stack)\n   VEC_free (iv_stack_entry_p, heap, *stack);\n }\n \n+\f\n+\n+/* Structure containing the mapping between the CLooG's induction\n+   variable and the type of the old induction variable.  */\n+typedef struct ivtype_map_elt\n+{\n+  tree type;\n+  const char *cloog_iv;\n+} *ivtype_map_elt;\n+\n+/* Print to stderr the element ELT.  */\n+\n+static void\n+debug_ivtype_elt (ivtype_map_elt elt)\n+{\n+  fprintf (stderr, \"(%s, \", elt->cloog_iv);\n+  print_generic_expr (stderr, elt->type, 0);\n+  fprintf (stderr, \")\\n\");\n+}\n+\n+/* Helper function for debug_ivtype_map.  */\n+\n+static int\n+debug_ivtype_map_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n+{\n+  struct ivtype_map_elt *entry = (struct ivtype_map_elt *) *slot;\n+  debug_ivtype_elt (entry);\n+  return 1;\n+}\n+\n+/* Print to stderr all the elements of MAP.  */\n+\n+void\n+debug_ivtype_map (htab_t map)\n+{\n+  htab_traverse (map, debug_ivtype_map_1, NULL);\n+}\n+\n+/* Constructs a new SCEV_INFO_STR structure for VAR and INSTANTIATED_BELOW.  */\n+\n+static inline ivtype_map_elt\n+new_ivtype_map_elt (const char *cloog_iv, tree type)\n+{\n+  ivtype_map_elt res;\n+  \n+  res = XNEW (struct ivtype_map_elt);\n+  res->cloog_iv = cloog_iv;\n+  res->type = type;\n+\n+  return res;\n+}\n+\n+/* Computes a hash function for database element ELT.  */\n+\n+static hashval_t\n+ivtype_map_elt_info (const void *elt)\n+{\n+  return htab_hash_pointer (((const struct ivtype_map_elt *) elt)->cloog_iv);\n+}\n+\n+/* Compares database elements E1 and E2.  */\n+\n+static int\n+eq_ivtype_map_elts (const void *e1, const void *e2)\n+{\n+  const struct ivtype_map_elt *elt1 = (const struct ivtype_map_elt *) e1;\n+  const struct ivtype_map_elt *elt2 = (const struct ivtype_map_elt *) e2;\n+\n+  return (elt1->cloog_iv == elt2->cloog_iv);\n+}\n+\n+\f\n+\n+/* Given a CLOOG_IV, returns the type that it should have in GCC land.\n+   If the information is not available, i.e. in the case one of the\n+   transforms created the loop, just return integer_type_node.  */\n+\n+static tree\n+gcc_type_for_cloog_iv (const char *cloog_iv, graphite_bb_p gbb)\n+{\n+  struct ivtype_map_elt tmp;\n+  PTR *slot;\n+\n+  tmp.cloog_iv = cloog_iv;\n+  slot = htab_find_slot (GBB_CLOOG_IV_TYPES (gbb), &tmp, NO_INSERT);\n+\n+  if (slot && *slot)\n+    return ((ivtype_map_elt) *slot)->type;\n+\n+  return integer_type_node;\n+}\n+\n /* Inserts constants derived from the USER_STMT argument list into the\n    STACK.  This is needed to map old ivs to constants when loops have\n    been eliminated.  */\n@@ -254,16 +346,23 @@ loop_iv_stack_patch_for_consts (loop_iv_stack stack,\n {\n   struct clast_stmt *t;\n   int index = 0;\n+  CloogStatement *cs = user_stmt->statement;\n+  graphite_bb_p gbb = (graphite_bb_p) cloog_statement_usr (cs);\n+\n   for (t = user_stmt->substitutions; t; t = t->next) \n     {\n-      struct clast_term *term = (struct clast_term*) \n+      struct clast_expr *expr = (struct clast_expr *) \n \t((struct clast_assignment *)t)->RHS;\n+      struct clast_term *term = (struct clast_term *) expr;\n \n       /* FIXME: What should be done with expr_bin, expr_red?  */\n-      if (((struct clast_assignment *)t)->RHS->type == expr_term\n+      if (expr->type == expr_term\n \t  && !term->var)\n \t{\n-\t  tree value = gmp_cst_to_tree (term->val);\n+\t  loop_p loop = gbb_loop_at_index (gbb, index);\n+\t  tree oldiv = oldiv_for_loop (GBB_SCOP (gbb), loop);\n+\t  tree type = oldiv ? TREE_TYPE (oldiv) : integer_type_node;\n+\t  tree value = gmp_cst_to_tree (type, term->val);\n \t  loop_iv_stack_insert_constant (stack, index, value);\n \t}\n       index = index + 1;\n@@ -1056,6 +1155,8 @@ new_graphite_bb (scop_p scop, basic_block bb)\n   GBB_CONDITIONS (gbb) = NULL;\n   GBB_CONDITION_CASES (gbb) = NULL;\n   GBB_LOOPS (gbb) = NULL;\n+  GBB_STATIC_SCHEDULE (gbb) = NULL;\n+  GBB_CLOOG_IV_TYPES (gbb) = NULL;\n   VEC_safe_push (graphite_bb_p, heap, SCOP_BBS (scop), gbb);\n }\n \n@@ -1067,13 +1168,41 @@ free_graphite_bb (struct graphite_bb *gbb)\n   if (GBB_DOMAIN (gbb))\n     cloog_matrix_free (GBB_DOMAIN (gbb));\n \n+  if (GBB_CLOOG_IV_TYPES (gbb))\n+    htab_delete (GBB_CLOOG_IV_TYPES (gbb));\n+\n+  /* FIXME: free_data_refs is disabled for the moment, but should be\n+     enabled.\n+\n+     free_data_refs (GBB_DATA_REFS (gbb)); */\n+\n   VEC_free (gimple, heap, GBB_CONDITIONS (gbb));\n   VEC_free (gimple, heap, GBB_CONDITION_CASES (gbb));\n   VEC_free (loop_p, heap, GBB_LOOPS (gbb));\n   GBB_BB (gbb)->aux = 0;\n   XDELETE (gbb);\n }\n \n+/* Register basic blocks belonging to a region in a pointer set.  */\n+\n+static void\n+register_bb_in_sese (basic_block entry_bb, basic_block exit_bb, sese region)\n+{\n+  edge_iterator ei;\n+  edge e;\n+  basic_block bb = entry_bb;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      if (!pointer_set_contains (SESE_REGION_BBS (region), e->dest) &&\n+\t  e->dest->index != exit_bb->index)\n+\t{\t\n+\t  pointer_set_insert (SESE_REGION_BBS (region), e->dest);\n+\t  register_bb_in_sese (e->dest, exit_bb, region);\n+\t}\n+    }\n+}\n+\n /* Creates a new scop starting with ENTRY.  */\n \n static scop_p\n@@ -1086,6 +1215,9 @@ new_scop (edge entry, edge exit)\n   SCOP_REGION (scop) = XNEW (struct sese);\n   SESE_ENTRY (SCOP_REGION (scop)) = entry;\n   SESE_EXIT (SCOP_REGION (scop)) = exit;\n+  SESE_REGION_BBS (SCOP_REGION (scop)) = pointer_set_create ();\n+  register_bb_in_sese (SCOP_ENTRY (scop), SCOP_EXIT (scop),\n+\t\t       SCOP_REGION (scop));\n   SCOP_BBS (scop) = VEC_alloc (graphite_bb_p, heap, 3);\n   SCOP_OLDIVS (scop) = VEC_alloc (name_tree, heap, 3);\n   SCOP_BBS_B (scop) = BITMAP_ALLOC (NULL);\n@@ -1513,7 +1645,6 @@ scopdet_basic_block_info (basic_block bb, VEC (sd_region, heap) **scops,\n static struct scopdet_info \n build_scops_1 (basic_block current, VEC (sd_region, heap) **scops, loop_p loop)\n {\n-\n   bool in_scop = false;\n   sd_region open_scop;\n   struct scopdet_info sinfo;\n@@ -2465,7 +2596,6 @@ find_params_in_bb (scop_p scop, graphite_bb_p gb)\n       irp.loop = father;\n       irp.scop = scop;\n       for_each_index (&dr->ref, idx_record_params, &irp);\n-      free_data_ref (dr);\n     }\n \n   /* Find parameters in conditional statements.  */ \n@@ -3277,9 +3407,10 @@ clast_name_to_gcc (const char *name, VEC (name_tree, heap) *params,\n   name_tree t;\n   tree iv;\n \n-  for (i = 0; VEC_iterate (name_tree, params, i, t); i++)\n-    if (!strcmp (name, t->name))\n-      return t->t;\n+  if (params)\n+    for (i = 0; VEC_iterate (name_tree, params, i, t); i++)\n+      if (!strcmp (name, t->name))\n+\treturn t->t;\n \n   iv = loop_iv_stack_get_iv_from_name (ivstack, name);\n   if (iv)\n@@ -3288,24 +3419,24 @@ clast_name_to_gcc (const char *name, VEC (name_tree, heap) *params,\n   gcc_unreachable ();\n }\n \n-/* A union needed to convert from CLAST expressions to GMP values.  */\n+/* Returns the maximal precision type for expressions E1 and E2.  */\n \n-typedef union {\n-  struct clast_expr *c;\n-  Value v;\n-} value_clast;\n+static inline tree\n+max_precision_type (tree e1, tree e2)\n+{\n+  tree type1 = TREE_TYPE (e1);\n+  tree type2 = TREE_TYPE (e2);\n+  return TYPE_PRECISION (type1) > TYPE_PRECISION (type2) ? type1 : type2;\n+}\n \n-/* Converts a Cloog AST expression E back to a GCC expression tree.   */\n+/* Converts a Cloog AST expression E back to a GCC expression tree\n+   of type TYPE.  */\n \n static tree\n-clast_to_gcc_expression (struct clast_expr *e,\n+clast_to_gcc_expression (tree type, struct clast_expr *e,\n \t\t\t VEC (name_tree, heap) *params,\n \t\t\t loop_iv_stack ivstack)\n {\n-  tree type = integer_type_node;\n-\n-  gcc_assert (e);\n-\n   switch (e->type)\n     {\n     case expr_term:\n@@ -3315,53 +3446,62 @@ clast_to_gcc_expression (struct clast_expr *e,\n \tif (t->var)\n \t  {\n \t    if (value_one_p (t->val))\n- \t      return clast_name_to_gcc (t->var, params, ivstack);\n+\t      {\n+\t\ttree name = clast_name_to_gcc (t->var, params, ivstack);\n+\t\treturn fold_convert (type, name);\n+\t      }\n \n \t    else if (value_mone_p (t->val))\n-\t      return fold_build1 (NEGATE_EXPR, type,\n-\t\t\t\t  clast_name_to_gcc (t->var, params, ivstack));\n+\t      {\n+\t\ttree name = clast_name_to_gcc (t->var, params, ivstack);\n+\t\tname = fold_convert (type, name);\n+\t\treturn fold_build1 (NEGATE_EXPR, type, name);\n+\t      }\n \t    else\n-\t      return fold_build2 (MULT_EXPR, type,\n-\t\t\t\t  gmp_cst_to_tree (t->val),\n-\t\t\t\t  clast_name_to_gcc (t->var, params, ivstack));\n+\t      {\n+\t\ttree name = clast_name_to_gcc (t->var, params, ivstack);\n+\t\ttree cst = gmp_cst_to_tree (type, t->val);\n+\t\tname = fold_convert (type, name);\n+\t\treturn fold_build2 (MULT_EXPR, type, cst, name);\n+\t      }\n \t  }\n \telse\n-\t  return gmp_cst_to_tree (t->val);\n+\t  return gmp_cst_to_tree (type, t->val);\n       }\n \n     case expr_red:\n       {\n         struct clast_reduction *r = (struct clast_reduction *) e;\n-        tree left, right;\n \n         switch (r->type)\n           {\n \t  case clast_red_sum:\n \t    if (r->n == 1)\n-\t      return clast_to_gcc_expression (r->elts[0], params, ivstack);\n+\t      return clast_to_gcc_expression (type, r->elts[0], params, ivstack);\n \n \t    else \n \t      {\n+\t\ttree tl = clast_to_gcc_expression (type, r->elts[0], params, ivstack);\n+\t\ttree tr = clast_to_gcc_expression (type, r->elts[1], params, ivstack);\n+\n \t\tgcc_assert (r->n >= 1\n \t\t\t    && r->elts[0]->type == expr_term\n \t\t\t    && r->elts[1]->type == expr_term);\n \n-\t\tleft = clast_to_gcc_expression (r->elts[0], params, ivstack);\n-\t\tright = clast_to_gcc_expression (r->elts[1], params, ivstack);\n-\t\treturn fold_build2 (PLUS_EXPR, type, left, right);\n+\t\treturn fold_build2 (PLUS_EXPR, type, tl, tr);\n \t      }\n \n \t    break;\n \n \t  case clast_red_min:\n \t    if (r->n == 1)\n-\t      return clast_to_gcc_expression (r->elts[0], params, ivstack);\n+\t      return clast_to_gcc_expression (type, r->elts[0], params, ivstack);\n \n \t    else if (r->n == 2)\n \t      {\n-\t\tleft = clast_to_gcc_expression (r->elts[0], params, ivstack);\n-\t\tright = clast_to_gcc_expression (r->elts[1], params, ivstack);\n-\t\treturn fold_build2 (MIN_EXPR, type, left, right);\n+\t\ttree tl = clast_to_gcc_expression (type, r->elts[0], params, ivstack);\n+\t\ttree tr = clast_to_gcc_expression (type, r->elts[1], params, ivstack);\n+\t\treturn fold_build2 (MIN_EXPR, type, tl, tr);\n \t      }\n \n \t    else\n@@ -3371,13 +3511,13 @@ clast_to_gcc_expression (struct clast_expr *e,\n \n \t  case clast_red_max:\n \t    if (r->n == 1)\n-\t      return clast_to_gcc_expression (r->elts[0], params, ivstack);\n+\t      return clast_to_gcc_expression (type, r->elts[0], params, ivstack);\n \n \t    else if (r->n == 2)\n \t      {\n-\t\tleft = clast_to_gcc_expression (r->elts[0], params, ivstack);\n-\t\tright = clast_to_gcc_expression (r->elts[1], params, ivstack);\n-\t\treturn fold_build2 (MAX_EXPR, type, left, right);\n+\t\ttree tl = clast_to_gcc_expression (type, r->elts[0], params, ivstack);\n+\t\ttree tr = clast_to_gcc_expression (type, r->elts[1], params, ivstack);\n+\t\treturn fold_build2 (MAX_EXPR, type, tl, tr);\n \t      }\n \n \t    else\n@@ -3395,12 +3535,8 @@ clast_to_gcc_expression (struct clast_expr *e,\n       {\n \tstruct clast_binary *b = (struct clast_binary *) e;\n \tstruct clast_expr *lhs = (struct clast_expr *) b->LHS;\n-\ttree tl = clast_to_gcc_expression (lhs, params, ivstack);\n-\tvalue_clast r;\n-\ttree tr;\n-\n-\tr.c = (struct clast_expr *) b->RHS;\n-\ttr = gmp_cst_to_tree (r.v);\n+\ttree tl = clast_to_gcc_expression (type, lhs, params, ivstack);\n+\ttree tr = gmp_cst_to_tree (type, b->RHS);\n \n \tswitch (b->type)\n \t  {\n@@ -3428,6 +3564,72 @@ clast_to_gcc_expression (struct clast_expr *e,\n   return NULL_TREE;\n }\n \n+/* Returns the type for the expression E.  */\n+\n+static tree\n+gcc_type_for_clast_expr (struct clast_expr *e,\n+\t\t\t VEC (name_tree, heap) *params,\n+\t\t\t loop_iv_stack ivstack)\n+{\n+  switch (e->type)\n+    {\n+    case expr_term:\n+      {\n+\tstruct clast_term *t = (struct clast_term *) e;\n+\n+\tif (t->var)\n+\t  return TREE_TYPE (clast_name_to_gcc (t->var, params, ivstack));\n+\telse\n+\t  return NULL_TREE;\n+      }\n+\n+    case expr_red:\n+      {\n+        struct clast_reduction *r = (struct clast_reduction *) e;\n+\n+\tif (r->n == 1)\n+\t  return gcc_type_for_clast_expr (r->elts[0], params, ivstack);\n+\telse \n+\t  {\n+\t    int i;\n+\t    for (i = 0; i < r->n; i++)\n+\t      {\n+\t\ttree type = gcc_type_for_clast_expr (r->elts[i], params, ivstack);\n+\t\tif (type)\n+\t\t  return type;\n+\t      }\n+\t    return NULL_TREE;\n+\t  }\n+      }\n+\n+    case expr_bin:\n+      {\n+\tstruct clast_binary *b = (struct clast_binary *) e;\n+\tstruct clast_expr *lhs = (struct clast_expr *) b->LHS;\n+\treturn gcc_type_for_clast_expr (lhs, params, ivstack);\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Returns the type for the equation CLEQ.  */\n+\n+static tree\n+gcc_type_for_clast_eq (struct clast_equation *cleq,\n+\t\t       VEC (name_tree, heap) *params,\n+\t\t       loop_iv_stack ivstack)\n+{\n+  tree type = gcc_type_for_clast_expr (cleq->LHS, params, ivstack);\n+  if (type)\n+    return type;\n+\n+  return gcc_type_for_clast_expr (cleq->RHS, params, ivstack);\n+}\n+\n /* Translates a clast equation CLEQ to a tree.  */\n \n static tree\n@@ -3436,8 +3638,9 @@ graphite_translate_clast_equation (scop_p scop,\n \t\t\t\t   loop_iv_stack ivstack)\n {\n   enum tree_code comp;\n-  tree lhs = clast_to_gcc_expression (cleq->LHS, SCOP_PARAMS (scop), ivstack);\n-  tree rhs = clast_to_gcc_expression (cleq->RHS, SCOP_PARAMS (scop), ivstack);\n+  tree type = gcc_type_for_clast_eq (cleq, SCOP_PARAMS (scop), ivstack);\n+  tree lhs = clast_to_gcc_expression (type, cleq->LHS, SCOP_PARAMS (scop), ivstack);\n+  tree rhs = clast_to_gcc_expression (type, cleq->RHS, SCOP_PARAMS (scop), ivstack);\n \n   if (cleq->sign == 0)\n     comp = EQ_EXPR;\n@@ -3448,7 +3651,7 @@ graphite_translate_clast_equation (scop_p scop,\n   else\n     comp = LE_EXPR;\n \n-  return fold_build2 (comp, integer_type_node, lhs, rhs);\n+  return fold_build2 (comp, type, lhs, rhs);\n }\n \n /* Creates the test for the condition in STMT.  */\n@@ -3465,7 +3668,7 @@ graphite_create_guard_cond_expr (scop_p scop, struct clast_guard *stmt,\n       tree eq = graphite_translate_clast_equation (scop, &stmt->eq[i], ivstack);\n \n       if (cond)\n-\tcond = fold_build2 (TRUTH_AND_EXPR, integer_type_node, cond, eq);\n+\tcond = fold_build2 (TRUTH_AND_EXPR, TREE_TYPE (eq), cond, eq);\n       else\n \tcond = eq;\n     }\n@@ -3485,6 +3688,41 @@ graphite_create_new_guard (scop_p scop, edge entry_edge,\n   return exit_edge;\n }\n \n+/* Walks a CLAST and returns the first statement in the body of a\n+   loop.  */\n+\n+static struct clast_user_stmt *\n+clast_get_body_of_loop (struct clast_stmt *stmt)\n+{\n+  if (!stmt\n+      || CLAST_STMT_IS_A (stmt, stmt_user))\n+    return (struct clast_user_stmt *) stmt;\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_for))\n+    return clast_get_body_of_loop (((struct clast_for *) stmt)->body);\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n+    return clast_get_body_of_loop (((struct clast_guard *) stmt)->then);\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_block))\n+    return clast_get_body_of_loop (((struct clast_block *) stmt)->body);\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Returns the induction variable for the loop that gets translated to\n+   STMT.  */\n+\n+static tree\n+gcc_type_for_iv_of_clast_loop (struct clast_for *stmt_for)\n+{\n+  struct clast_user_stmt *stmt = clast_get_body_of_loop ((struct clast_stmt *) stmt_for);\n+  const char *cloog_iv = stmt_for->iterator;\n+  CloogStatement *cs = stmt->statement;\n+  graphite_bb_p gbb = (graphite_bb_p) cloog_statement_usr (cs);\n+\n+  return gcc_type_for_cloog_iv (cloog_iv, gbb);\n+}\n \n /* Creates a new LOOP corresponding to Cloog's STMT.  Inserts an induction \n    variable for the new LOOP.  New LOOP is attached to CFG starting at\n@@ -3496,26 +3734,19 @@ graphite_create_new_loop (scop_p scop, edge entry_edge,\n \t\t\t  struct clast_for *stmt, loop_iv_stack ivstack,\n \t\t\t  loop_p outer)\n {\n-  struct loop *loop;\n-  tree ivvar;\n-  tree stride, lowb, upb;\n+  tree type = gcc_type_for_iv_of_clast_loop (stmt);\n+  VEC (name_tree, heap) *params = SCOP_PARAMS (scop);\n+  tree lb = clast_to_gcc_expression (type, stmt->LB, params, ivstack);\n+  tree ub = clast_to_gcc_expression (type, stmt->UB, params, ivstack);\n+  tree stride = gmp_cst_to_tree (type, stmt->stride);\n+  tree ivvar = create_tmp_var (type, \"graphiteIV\");\n   tree iv_before;\n+  loop_p loop = create_empty_loop_on_edge\n+    (entry_edge, lb, stride, ub, ivvar, &iv_before,\n+     outer ? outer : entry_edge->src->loop_father);\n \n-  gcc_assert (stmt->LB\n-\t      && stmt->UB);\n-\n-  stride = gmp_cst_to_tree (stmt->stride);\n-  lowb = clast_to_gcc_expression (stmt->LB, SCOP_PARAMS (scop), ivstack);\n-  ivvar = create_tmp_var (integer_type_node, \"graphiteIV\");\n   add_referenced_var (ivvar);\n-\n-  upb = clast_to_gcc_expression (stmt->UB, SCOP_PARAMS (scop), ivstack);\n-  loop = create_empty_loop_on_edge (entry_edge, lowb, stride, upb, ivvar,\n-\t\t\t\t    &iv_before, outer ? outer\n-\t\t\t\t    : entry_edge->src->loop_father);\n-\n   loop_iv_stack_push_iv (ivstack, iv_before, stmt->iterator);\n-\n   return loop;\n }\n \n@@ -3786,9 +4017,7 @@ expand_scalar_variables (basic_block bb, scop_p scop,\n     }\n }\n \n-/* Rename all the SSA_NAMEs from block BB that appear in IVSTACK in\n-   terms of new induction variables.  OLD is the original loop that\n-   contained BB.  */\n+/* Rename all the SSA_NAMEs from block BB according to the MAP.  */\n \n static void \n rename_variables (basic_block bb, htab_t map)\n@@ -3799,6 +4028,38 @@ rename_variables (basic_block bb, htab_t map)\n     rename_variables_in_stmt (gsi_stmt (gsi), map);\n }\n \n+/* Rename following the information from MAP the PHI node argument\n+   corresponding to the edge E.  In order to allow several renames of\n+   that argument, we match the original SSA_NAME on the argument\n+   coming from the edge different than E.  */\n+\n+static void\n+rename_variables_from_edge (edge e, gimple phi, htab_t map)\n+{\n+  int n = e->dest_idx == 0 ? 1 : 0;\n+  tree old_name = gimple_phi_arg_def (phi, n);\n+  tree new_name = get_new_name_from_old_name (map, old_name);\n+\n+  gcc_assert (gimple_phi_num_args (phi) == 2\n+\t      && gimple_phi_arg_edge (phi, e->dest_idx) == e);\n+\n+  SET_PHI_ARG_DEF (phi, n, new_name);\n+}\n+\n+/* Rename all the phi arguments for the edges comming from the scop\n+   according to the MAP.  */\n+\n+static void\n+rename_phis_end_scop (scop_p scop, htab_t map)\n+{\n+  basic_block after_scop = SCOP_EXIT (scop);\n+  edge e = SESE_EXIT (SCOP_REGION (scop));\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_phis (after_scop); !gsi_end_p (gsi); gsi_next (&gsi))\n+    rename_variables_from_edge (e, gsi_stmt (gsi), map);\n+}\n+\n /* Remove condition from BB.  */\n \n static void\n@@ -3950,6 +4211,7 @@ copy_bb_and_scalar_dependences (basic_block bb, scop_p scop,\n   rename_variables (new_bb, map);\n   remove_phi_nodes (new_bb);\n   expand_scalar_variables (new_bb, scop, context_loop, map);\n+  rename_phis_end_scop (scop, map);\n \n   return next_e;\n }\n@@ -4447,8 +4709,7 @@ move_sese_in_condition (sese region)\n static bool\n bb_in_sese_p (basic_block bb, sese region)\n {\n-  return (dominated_by_p (CDI_DOMINATORS, bb, SESE_ENTRY (region)->src)\n-\t  && dominated_by_p (CDI_POST_DOMINATORS, bb, SESE_EXIT (region)->dest));\n+  return pointer_set_contains (SESE_REGION_BBS (region), bb);\n }\n \n /* For USE in BB, if it is used outside of the REGION it is defined in,\n@@ -4505,7 +4766,7 @@ sese_find_uses_to_rename_bb (sese region, basic_block bb,\n       sese_find_uses_to_rename_use (region, bb, var, use_blocks, need_phis);\n }\n \n-/* Add exit phis for the USE on EXIT.  */\n+/* Add exit phis for USE on EXIT.  */\n \n static void\n sese_add_exit_phis_edge (basic_block exit, tree use, edge false_e, edge true_e)\n@@ -4515,7 +4776,7 @@ sese_add_exit_phis_edge (basic_block exit, tree use, edge false_e, edge true_e)\n   create_new_def_for (gimple_phi_result (phi), phi,\n \t\t      gimple_phi_result_ptr (phi));\n   add_phi_arg (phi, use, false_e);\n-  add_phi_arg (phi, integer_zero_node, true_e);\n+  add_phi_arg (phi, use, true_e);\n }\n \n /* Add phi nodes for VAR that is used in LIVEIN.  Phi nodes are\n@@ -4573,6 +4834,123 @@ rewrite_into_sese_closed_ssa (sese region, basic_block where,\n   BITMAP_FREE (names_to_rename);\n }\n \n+/* Returns the first cloog name used in EXPR.  */\n+\n+static const char *\n+find_cloog_iv_in_expr (struct clast_expr *expr)\n+{\n+  struct clast_term *term = (struct clast_term *) expr;\n+\n+  if (expr->type == expr_term\n+      && !term->var)\n+    return NULL;\n+\n+  if (expr->type == expr_term)\n+    return term->var;\n+\n+  if (expr->type == expr_red)\n+    {\n+      int i;\n+      struct clast_reduction *red = (struct clast_reduction *) expr;\n+\n+      for (i = 0; i < red->n; i++)\n+\t{\n+\t  const char *res = find_cloog_iv_in_expr ((red)->elts[i]);\n+\n+\t  if (res)\n+\t    return res;\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Build for a clast_user_stmt USER_STMT a map between the CLAST\n+   induction variables and the corresponding GCC old induction\n+   variables.  This information is stored on each GRAPHITE_BB.  */\n+\n+static void\n+compute_cloog_iv_types_1 (graphite_bb_p gbb,\n+\t\t\t  struct clast_user_stmt *user_stmt)\n+{\n+  struct clast_stmt *t;\n+  int index = 0;\n+\n+  for (t = user_stmt->substitutions; t; t = t->next, index++)\n+    {\n+      PTR *slot;\n+      struct ivtype_map_elt tmp;\n+      struct clast_expr *expr = (struct clast_expr *) \n+\t((struct clast_assignment *)t)->RHS;\n+\n+      /* Create an entry (clast_var, type).  */\n+      tmp.cloog_iv = find_cloog_iv_in_expr (expr);\n+      if (!tmp.cloog_iv)\n+\tcontinue;\n+\n+      slot = htab_find_slot (GBB_CLOOG_IV_TYPES (gbb), &tmp, INSERT);\n+\n+      if (!*slot)\n+\t{\n+\t  loop_p loop = gbb_loop_at_index (gbb, index);\n+\t  tree oldiv = oldiv_for_loop (GBB_SCOP (gbb), loop);\n+\t  tree type = oldiv ? TREE_TYPE (oldiv) : integer_type_node;\n+\t  *slot = new_ivtype_map_elt (tmp.cloog_iv, type);\n+\t}\n+    }\n+}\n+\n+/* Walk the CLAST tree starting from STMT and build for each\n+   clast_user_stmt a map between the CLAST induction variables and the\n+   corresponding GCC old induction variables.  This information is\n+   stored on each GRAPHITE_BB.  */\n+\n+static void\n+compute_cloog_iv_types (struct clast_stmt *stmt)\n+{\n+  if (!stmt)\n+    return;\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_root))\n+    goto next;\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_user))\n+    {\n+      CloogStatement *cs = ((struct clast_user_stmt *) stmt)->statement;\n+      graphite_bb_p gbb = (graphite_bb_p) cloog_statement_usr (cs);\n+      GBB_CLOOG_IV_TYPES (gbb) = htab_create (10, ivtype_map_elt_info,\n+\t\t\t\t\t      eq_ivtype_map_elts, free);\n+      compute_cloog_iv_types_1 (gbb, (struct clast_user_stmt *) stmt);\n+      goto next;\n+    }\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_for))\n+    {\n+      struct clast_stmt *s = ((struct clast_for *) stmt)->body;\n+      compute_cloog_iv_types (s);\n+      goto next;\n+    }\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n+    {\n+      struct clast_stmt *s = ((struct clast_guard *) stmt)->then;\n+      compute_cloog_iv_types (s);\n+      goto next;\n+    }\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_block))\n+    {\n+      struct clast_stmt *s = ((struct clast_block *) stmt)->body;\n+      compute_cloog_iv_types (s);\n+      goto next;\n+    }\n+\n+  gcc_unreachable ();\n+\n+ next:\n+  compute_cloog_iv_types (stmt->next);\n+}\n+\n /* GIMPLE Loop Generator: generates loops from STMT in GIMPLE form for\n    the given SCOP.  */\n \n@@ -4598,6 +4976,7 @@ gloog (scop_p scop, struct clast_stmt *stmt)\n \t\t\t\tif_region->true_region->exit);\n   graphite_verify ();\n   context_loop = SESE_ENTRY (SCOP_REGION (scop))->src->loop_father;\n+  compute_cloog_iv_types (stmt);\n   new_scop_exit_edge = translate_clast (scop, context_loop,\n \t\t\t\t\tstmt, if_region->true_region->entry,\n \t\t\t\t\t&ivstack);"}, {"sha": "92a68167f22af8eaf2cf43bfe6b7df292b1b00d2", "filename": "gcc/graphite.h", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -193,6 +193,7 @@ typedef struct graphite_bb\n   lambda_vector compressed_alpha_matrix;\n   CloogMatrix *dynamic_schedule;\n   VEC (data_reference_p, heap) *data_refs;\n+  htab_t cloog_iv_types;\n } *gbb_p;\n \n #define GBB_BB(GBB) GBB->bb\n@@ -205,6 +206,7 @@ typedef struct graphite_bb\n #define GBB_CONDITIONS(GBB) GBB->conditions\n #define GBB_CONDITION_CASES(GBB) GBB->condition_cases\n #define GBB_LOOPS(GBB) GBB->loops\n+#define GBB_CLOOG_IV_TYPES(GBB) GBB->cloog_iv_types\n \n /* Return the loop that contains the basic block GBB.  */\n \n@@ -274,10 +276,12 @@ DEF_VEC_ALLOC_P (name_tree, heap);\n typedef struct sese\n {\n   edge entry, exit;\n+  struct pointer_set_t *region_basic_blocks;\n } *sese;\n \n #define SESE_ENTRY(S) (S->entry)\n #define SESE_EXIT(S) (S->exit)\n+#define SESE_REGION_BBS(S) (S->region_basic_blocks)\n \n /* A SCOP is a Static Control Part of the program, simple enough to be\n    represented in polyhedral form.  */\n@@ -327,6 +331,7 @@ struct scop\n    but just a boundary.  SCOP_ENTRY is considered part of the scop.  */\n #define SCOP_ENTRY(S) (SESE_ENTRY (SCOP_REGION (S))->dest)\n #define SCOP_EXIT(S) (SESE_EXIT (SCOP_REGION (S))->dest)\n+#define SCOP_REGION_BBS(S) (SESE_REGION_BBS (SCOP_REGION (S)))\n #define SCOP_STATIC_SCHEDULE(S) S->static_schedule\n #define SCOP_LOOPS(S) S->loops\n #define SCOP_LOOP_NEST(S) S->loop_nest\n@@ -345,7 +350,8 @@ extern void dot_scop (scop_p);\n extern void dot_all_scops (void);\n extern void debug_clast_stmt (struct clast_stmt *);\n extern void debug_rename_map (htab_t);\n-extern void debug_loop_vec (graphite_bb_p gb);\n+extern void debug_ivtype_map (htab_t);\n+extern void debug_loop_vec (graphite_bb_p);\n extern void debug_oldivs (scop_p);\n \n /* Describes the type of an iv stack entry.  */\n@@ -377,6 +383,25 @@ DEF_VEC_ALLOC_P(iv_stack_entry_p,heap);\n typedef VEC(iv_stack_entry_p, heap) **loop_iv_stack;\n extern void debug_loop_iv_stack (loop_iv_stack);\n \n+/* Return the old induction variable of the LOOP that is in normal\n+   form in SCOP.  */\n+\n+static inline tree\n+oldiv_for_loop (scop_p scop, loop_p loop)\n+{\n+  int i;\n+  name_tree iv;\n+\n+  if (!loop)\n+    return NULL_TREE;\n+\n+  for (i = 0; VEC_iterate (name_tree, SCOP_OLDIVS (scop), i, iv); i++)\n+    if (iv->loop == loop)\n+      return iv->t;\n+\n+  return NULL_TREE;\n+}\n+\n /* Return the number of gimple loops contained in SCOP.  */\n \n static inline int"}, {"sha": "cdf137fd33dfcd791e7604bc2300dd70c974d0ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -1,3 +1,23 @@\n+2008-12-11  Harsha Jagasia  <harsha.jagasia@amd.com>\n+\n+\tPR tree-optimization/38446\n+\t* gcc.dg/graphite/pr38446.c: New.\n+\n+2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* gcc.dg/graphite/scop-16.c: Test only scop specific info.\n+\t* gcc.dg/graphite/scop-17.c: Same.\n+\t* gcc.dg/graphite/block-5.c: New.\n+\t* gcc.dg/graphite/block-6.c: New.\n+\t* gcc.dg/graphite/pr37485.c: Clean dump file after.\n+\t* gcc.dg/graphite/pr37684.c: Same.\n+\t* gcc.dg/graphite/block-2.c: Same.\n+\n+2008-12-10  Tobias Grosser  <grosser@fim.uni-passau.de>\n+\n+\tPR middle-end/38459\n+\t* gfortran.dg/graphite/pr38459.f90: New.\n+\n 2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR middle-end/37852"}, {"sha": "cf0969bac1d9693807399d24615ac27759f83178", "filename": "gcc/testsuite/gcc.dg/graphite/block-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-2.c?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+\n+typedef unsigned char   UChar;\n+typedef int             Int32;\n+typedef unsigned int    UInt32;\n+\n+void fallbackSort ( UInt32* fmap, \n+                    UInt32* eclass, \n+                    Int32   nblock,\n+                    Int32   verb )\n+{\n+   Int32 ftab[257];\n+   Int32 ftabCopy[256];\n+   Int32 H, i, j, k, l, r, cc, cc1;\n+   Int32 nNotDone;\n+   Int32 nBhtab;\n+   UChar* eclass8 = (UChar*)eclass;\n+\n+   if (verb >= 4)\n+      VPrintf0 ( \"        bucket sorting ...\\n\" );\n+   for (i = 0; i < 257;    i++) ftab[i] = 0;\n+   for (i = 0; i < nblock; i++) ftab[eclass8[i]]++;\n+   for (i = 0; i < 256;    i++) ftabCopy[i] = ftab[i];\n+   for (i = 1; i < 257;    i++) ftab[i] += ftab[i-1];\n+\n+   for (i = 0; i < nblock; i++) {\n+      j = eclass8[i] + ftab [i];\n+   }\n+   AssertH ( j < 256, 1005 );\n+}\n+/* { dg-final { scan-tree-dump-times \"Loop blocked\" 1 \"graphite\" { xfail *-*-* }} } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "e0bd4688d399e9936eb3ee58b77dc7fff9a95442", "filename": "gcc/testsuite/gcc.dg/graphite/block-5.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-5.c?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+\n+#define N 10000\n+void foo (int);\n+int test ()\n+{\n+  int a[N][N];\n+  int b[N][N];\n+  unsigned i, j;\n+\n+  for (i = 0; i < N; i++) \n+    for (j = 0; j < N; j++)\n+      a[i][j] = i*j;\n+\n+  for (j = 1; j < N; j++) \n+    for (i = 0; i < N; i++)\n+      a[i][j] = a[i][j-1] + b[i][j];\n+\n+  for (i = 0; i < N; i++) \n+    for (j = 0; j < N; j++) \n+      foo (a[i][j]); \n+}\n+\n+/* Interchange is legal for loops 0 and 1 of the first two SCoPs */\n+/* { dg-final { scan-tree-dump-times \"Interchange valid for loops 0 and 1:\" 2 \"graphite\"} } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "77429f1cb83e6ea8c6f2b8538865aff398fb7596", "filename": "gcc/testsuite/gcc.dg/graphite/block-6.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-6.c?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+\n+#define N 10000\n+void foo (int);\n+int test ()\n+{\n+  int a[N][N];\n+  unsigned i, j;\n+\n+  for (i = 0; i < N; i++) \n+    for (j = 0; j < N; j++)\n+\ta[i][j] = i*j;\n+\n+  for (i = 1; i < N; i++) \n+    for (j = 1; j < (N-1) ; j++)\n+\ta[i][j] = a[i-1][j+1] * a[i-1][j+1]/2;\n+\n+  for (i = 0; i < N; i++) \n+    for (j = 0; j < N; j++)\n+      foo (a[i][j]); \n+}\n+\n+/* Interchange is not legal for loops 0 and 1 of SCoP 2.  */\n+/* { dg-final { scan-tree-dump-times \"Interchange not valid for loops 0 and 1:\" 1 \"graphite\"} } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "cf0969bac1d9693807399d24615ac27759f83178", "filename": "gcc/testsuite/gcc.dg/graphite/pr37485.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -29,3 +29,4 @@ void fallbackSort ( UInt32* fmap,\n    AssertH ( j < 256, 1005 );\n }\n /* { dg-final { scan-tree-dump-times \"Loop blocked\" 1 \"graphite\" { xfail *-*-* }} } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "a9e6f5a4a59550ffc76948f0062272f12d93878c", "filename": "gcc/testsuite/gcc.dg/graphite/pr37684.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37684.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37684.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37684.c?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -63,3 +63,5 @@ int BZ2_bzCompressInit\n    }\n    prepare_new_block ( s );\n }\n+\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "b7b346cd98bc7f05117994f5e30a61c21e9cd29e", "filename": "gcc/testsuite/gcc.dg/graphite/pr38446.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38446.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38446.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38446.c?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n+\n+void copy_data()\n+{\n+  int ****source;\n+  int ****dest;\n+\n+  int i, j, k, l;\n+  for (i = 0; i < 10; i++)\n+      for (k = 0; k < 2; k++)\n+        for (l = 0; l < 65; l++)\n+          source[i][j][k][l] = dest[i][j][k][l];\n+}\n+"}, {"sha": "9324631e2fdcf03fb44bb22f9d6a13de0bc6732e", "filename": "gcc/testsuite/gcc.dg/graphite/scop-15.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-15.c?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -48,5 +48,6 @@ int longest_match(IPos cur_match)\n \t     && --chain_length != 0);\n     return best_len;\n }\n+\n /* { dg-final { scan-tree-dump-times \"number of SCoPs: 0\" 1 \"graphite\"} } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "d0b32f639737afcf2de6d1258e7e652b621eb5af", "filename": "gcc/testsuite/gcc.dg/graphite/scop-16.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-16.c?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -1,4 +1,5 @@\n-/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n #define N 10000\n void foo (int);\n int test ()\n@@ -20,6 +21,5 @@ int test ()\n       foo (a[i][j]); \n }\n \n-/* Interchange is legal for loops 0 and 1 of the first two SCoPs */\n-/* { dg-final { scan-tree-dump-times \"Interchange valid for loops 0 and 1:\" 2 \"graphite\"} } */\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 2\" 1 \"graphite\"} } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "c2fec3fccaf37f084fed23ca6434bdb1e4dfa80e", "filename": "gcc/testsuite/gcc.dg/graphite/scop-17.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-17.c?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -1,4 +1,5 @@\n-/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+\n #define N 10000\n void foo (int);\n int test ()\n@@ -19,6 +20,5 @@ int test ()\n       foo (a[i][j]); \n }\n \n-/* Interchange is not legal for loops 0 and 1 of SCoP 2.  */\n-/* { dg-final { scan-tree-dump-times \"Interchange not valid for loops 0 and 1:\" 1 \"graphite\"} } */\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 2\" 1 \"graphite\"} } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "1feb6e503eb9d7314d3a9ebdf4bb2679c33856c1", "filename": "gcc/testsuite/gfortran.dg/graphite/pr38459.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr38459.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c72371d037e893dcfad4c9a1f8485330ff318/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr38459.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr38459.f90?ref=4d6c72371d037e893dcfad4c9a1f8485330ff318", "patch": "@@ -0,0 +1,14 @@\n+! { dg-options \"-O2 -fgraphite-identity\" }\n+# 1 \"mltfftsg.F\"\n+# 1 \"<built-in>\"\n+SUBROUTINE mltfftsg ( a, ldax, lday, b, ldbx, ldby, &\n+                      n, m)\n+  INTEGER, PARAMETER :: dbl = SELECTED_REAL_KIND ( 14, 200 )\n+\n+! Arguments\n+  INTEGER, INTENT ( IN ) :: ldbx, ldby, n, m\n+  COMPLEX ( dbl ), INTENT ( INOUT ) :: b ( ldbx, ldby )\n+\n+   B(N+1:LDBX,1:M) = CMPLX(0._dbl,0._dbl,dbl)\n+    \n+END SUBROUTINE mltfftsg"}]}