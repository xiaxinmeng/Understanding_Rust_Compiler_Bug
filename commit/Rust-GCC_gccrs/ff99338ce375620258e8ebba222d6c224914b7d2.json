{"sha": "ff99338ce375620258e8ebba222d6c224914b7d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY5OTMzOGNlMzc1NjIwMjU4ZThlYmJhMjIyZDZjMjI0OTE0YjdkMg==", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2019-03-12T17:08:27Z"}, "committer": {"name": "Robin Dapp", "email": "rdapp@gcc.gnu.org", "date": "2019-03-12T17:08:27Z"}, "message": "S/390: Rework instruction scheduling.\n\nThis patch set adds new pipeline descriptions for z13 and z14.  Based\non that, the scoring and some properties are handled differently in\nthe scheduler hooks.\n\nThe patch before (r269620) also belongs to this set but I accidentally\napplied it separately.\n\nFrom-SVN: r269622", "tree": {"sha": "a86aee1a4b78d13a552feb0803c489dc2e92ba66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a86aee1a4b78d13a552feb0803c489dc2e92ba66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff99338ce375620258e8ebba222d6c224914b7d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff99338ce375620258e8ebba222d6c224914b7d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff99338ce375620258e8ebba222d6c224914b7d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff99338ce375620258e8ebba222d6c224914b7d2/comments", "author": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2380e042774fb2d6c3ab9d3f5fc97bad3b831684", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2380e042774fb2d6c3ab9d3f5fc97bad3b831684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2380e042774fb2d6c3ab9d3f5fc97bad3b831684"}], "stats": {"total": 618, "additions": 503, "deletions": 115}, "files": [{"sha": "3c2499b0946610c9005beab6da4080b6cc60c239", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff99338ce375620258e8ebba222d6c224914b7d2", "patch": "@@ -1,3 +1,27 @@\n+2019-03-12  Robin Dapp  <rdapp@linux.ibm.com>\n+\n+\t* config/s390/3906.md: New file.\n+\t* config/s390/s390.c (MAX_SCHED_UNITS): Increase.\n+\t(LONGRUNNING_THRESHOLD): Remove.\n+\t(MAX_SCHED_MIX_SCORE): Decrease.\n+\t(MAX_SCHED_MIX_DISTANCE): Decrease.\n+\t(s390_bb_fallthru_entry_likely): Assume fallthru for less than likely.\n+\t(struct s390_sched_state): New struct to hold scheduling state.\n+\t(S390_SCHED_STATE_NORMAL): Remove.\n+\t(S390_SCHED_STATE_CRACKED): Remove.\n+\t(S390_SCHED_ATTR_MASK_GROUPOFTWO): Add.\n+\t(s390_get_sched_attrmask): Use new attribute.\n+\t(s390_get_unit_mask): Use new units.\n+\t(s390_is_fpd): New function.\n+\t(s390_is_fxd): New function.\n+\t(s390_is_longrunning): New function.\n+\t(s390_sched_score): Use new functions.\n+\t(s390_sched_reorder): Likewise.\n+\t(s390_sched_variable_issue): Rework and use new functions.\n+\t(s390_sched_init): Use new functions.\n+\t* config/s390/s390.h (s390_tune_attr):  Add z14.\n+\t* config/s390/s390.md: Add z14.\n+\n 2019-03-12  Robin Dapp  <rdapp@linux.ibm.com>\n \n \t* config/s390/2964.md: Update pipeline description."}, {"sha": "8cb4565ee22b9b01852f5d6fa7050c97d1ec676d", "filename": "gcc/config/s390/3906.md", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Fconfig%2Fs390%2F3906.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Fconfig%2Fs390%2F3906.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2F3906.md?ref=ff99338ce375620258e8ebba222d6c224914b7d2", "patch": "@@ -0,0 +1,282 @@\n+;; Scheduling description for z14.\n+;;   Copyright (C) 2019 Free Software Foundation, Inc.\n+;;   Contributed by Robin Dapp (rdapp@linux.ibm.com)\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_attr \"z14_unit_fpd\" \"\"\n+(cond [(eq_attr \"mnemonic\" \"ddb,ddbr,deb,debr,dxbr,sqdb,sqdbr,sqeb,\\\n+sqebr,sqxbr,vfddb,vfdsb,vfsqdb,vfsqsb,wfddb,wfdsb,wfdxb,wfsqdb,wfsqxb\")\n+ (const_int 1)] (const_int 0)))\n+\n+(define_attr \"z14_unit_fxa\" \"\"\n+(cond [(eq_attr \"mnemonic\" \"a,afi,ag,agf,agfi,agfr,agh,aghi,aghik,\\\n+agr,agrk,ahi,ahik,al,alc,alcg,alcgr,alcr,alfi,alg,algf,algfi,algfr,\\\n+alghsik,algr,alhsik,alr,alrk,aly,ark,ay,bras,brasl,etnd,exrl,flogr,ic,icm,\\\n+icmh,icmy,icy,iihf,iilf,ipm,la,larl,lay,lb,lbr,lcgr,lcr,lgb,lgbr,lgf,lgfi,\\\n+lgfr,lgfrl,lgh,lghi,lghr,lghrl,lgr,lh,lhi,lhr,lhrl,lhy,llcr,llgfr,llghr,\\\n+llgtr,llhr,llihf,llihh,llihl,llilf,llilh,llill,lngr,lnr,loc,locg,locghi,\\\n+locgr,lochi,locr,lpgr,lpr,lr,lrv,lrvg,lrvgr,lrvh,lrvr,lt,ltg,ltgf,ltgfr,\\\n+ltgr,ltr,m,mfy,mg,mgh,mghi,mgrk,mh,mhi,mhy,ml,mlg,mlgr,mlr,mr,ms,msfi,msg,\\\n+msgf,msgfi,msgfr,msgr,msgrkc,msr,msrkc,msy,n,ng,ngr,ngrk,nihf,nihh,nihl,\\\n+nilf,nilh,nill,nr,nrk,ny,o,og,ogr,ogrk,oihf,oihh,oihl,oilf,oilh,oill,or,\\\n+ork,oy,pfpo,popcnt,risbg,risbgn,rll,rllg,s,sg,sgf,sgfr,sgh,sgr,sgrk,sh,\\\n+shy,sl,slb,slbg,slbgr,slbr,slfi,slg,slgf,slgfi,slgfr,slgr,slgrk,sll,sllg,\\\n+sllk,slr,slrk,sly,sr,sra,srag,srak,srl,srlg,srlk,sy,x,xg,xgr,xgrk,xihf,\\\n+xilf,xr,xrk,xy\")\n+ (const_int 1)] (const_int 0)))\n+\n+(define_attr \"z14_unit_fxb\" \"\"\n+(cond [(eq_attr \"mnemonic\" \"agsi,algsi,alsi,asi,b,bc,bcr,bi,br,brcl,\\\n+c,cfi,cg,cgf,cgfi,cgfr,cgfrl,cgh,cghi,cghrl,cghsi,cgit,cgr,cgrl,cgrt,ch,\\\n+chi,chrl,chsi,chy,cit,cl,clfhsi,clfi,clfit,clg,clgf,clgfi,clgfr,clgfrl,\\\n+clghsi,clgit,clgr,clgrl,clgrt,clgt,clhhsi,clhrl,cli,cliy,clm,clmy,clr,clrl,\\\n+clrt,clt,cly,cr,crl,crt,cy,j,jg,laa,laag,lan,lang,lao,laog,lat,lax,laxg,\\\n+lcdfr,ldgr,ldr,lgat,lgdr,lndfr,lpdfr,lzdr,lzer,mvghi,mvhhi,mvhi,mvi,mviy,ni,\\\n+niy,nop,nopr,ntstg,oi,oiy,ppa,st,stc,stcy,std,stdy,ste,stey,stg,stgrl,sth,\\\n+sthrl,sthy,stoc,stocg,strl,strv,strvg,strvh,sty,tend,tm,tmh,tmhh,tmhl,tml,\\\n+tmlh,tmll,tmy,vlgvf,vlgvg,vlgvh,vlr,vlvgb,vlvgf,vlvgg,vlvgh,vlvgp,vst,vstl,\\\n+vstrl,vstrlr,xi,xiy\")\n+ (const_int 1)] (const_int 0)))\n+\n+(define_attr \"z14_unit_fxd\" \"\"\n+(cond [(eq_attr \"mnemonic\" \"dlgr,dlr,dr,dsgfr,dsgr\")\n+ (const_int 1)] (const_int 0)))\n+\n+(define_attr \"z14_unit_lsu\" \"\"\n+(cond [(eq_attr \"mnemonic\" \"a,adb,aeb,ag,agf,agh,agsi,al,alc,alcg,\\\n+alg,algf,algsi,alsi,aly,asi,ay,c,cdb,cg,cgf,cgfrl,cgh,cghrl,cghsi,cgrl,ch,\\\n+chrl,chsi,chy,cl,clc,clfhsi,clg,clgf,clgfrl,clghsi,clgrl,clgt,clhhsi,clhrl,\\\n+cli,cliy,clm,clmy,clrl,clt,cly,crl,cy,ddb,deb,ear,ic,icm,icmh,icmy,icy,l,\\\n+laa,laag,lan,lang,lao,laog,lat,lax,laxg,lb,lcbb,ld,lde,ldeb,ldy,le,ley,lg,\\\n+lgat,lgb,lgf,lgfrl,lgh,lghrl,lgrl,lh,lhrl,lhy,llc,llgc,llgf,llgfrl,llgh,\\\n+llghrl,llgt,llh,llhrl,loc,locg,lrl,lrv,lrvg,lrvh,lt,ltg,ltgf,ly,m,madb,maeb,\\\n+meeb,mfy,mg,mgh,mh,mhy,ml,mlg,ms,msdb,mseb,msg,msgf,msy,mvghi,mvhhi,mvhi,\\\n+mvi,mviy,n,ng,ni,niy,ntstg,ny,o,og,oi,oiy,oy,s,sar,sdb,seb,sfpc,sg,sgf,\\\n+sgh,sh,shy,sl,slb,slbg,slg,slgf,sly,sqdb,sqeb,st,stc,stcy,std,stdy,ste,\\\n+stey,stg,stgrl,sth,sthrl,sthy,stoc,stocg,strl,strv,strvg,strvh,sty,sy,\\\n+tabort,tm,tmy,vl,vlbb,vleb,vlef,vleg,vleh,vll,vllezb,vllezf,vllezg,vllezh,\\\n+vllezlf,vlrepb,vlrepf,vlrepg,vlreph,vlrl,vlrlr,vst,vstl,vstrl,vstrlr,x,xg,xi,\\\n+xiy,xy\")\n+ (const_int 1)] (const_int 0)))\n+\n+(define_attr \"z14_unit_vfu\" \"\"\n+(cond [(eq_attr \"mnemonic\" \"adb,adbr,adtr,aeb,aebr,axbr,axtr,cdb,\\\n+cdbr,cdtr,cebr,cpsdr,cxbr,cxtr,ddtr,dxtr,fidbr,fidbra,fidtr,fiebr,fiebra,\\\n+fixbr,fixbra,fixtr,lcdbr,lcebr,lcxbr,ldeb,ldebr,ldetr,le,ledbr,ledtr,ler,\\\n+ley,lndbr,lnebr,lnxbr,lpdbr,lpebr,lpxbr,ltdbr,ltebr,ltxbr,ltxtr,lxdb,\\\n+lxdbr,lxdtr,lxeb,lxebr,madb,madbr,maeb,maebr,mdbr,mdtr,meeb,meebr,msdb,\\\n+msdbr,mseb,msebr,mxbr,mxtr,sdb,sdbr,sdtr,seb,sebr,sxbr,sxtr,tcdb,tceb,tcxb,\\\n+tdcdt,tdcet,tdcxt,vab,vaccb,vacccq,vaccf,vaccg,vacch,vaccq,vacq,vaf,vag,vah,\\\n+vaq,vavgb,vavgf,vavgg,vavgh,vavglb,vavglf,vavglg,vavglh,vbperm,vcdgb,\\\n+vcdlgb,vceqb,vceqbs,vceqf,vceqfs,vceqg,vceqgs,vceqh,vceqhs,vcgdb,vchb,vchbs,\\\n+vchf,vchfs,vchg,vchgs,vchh,vchhs,vchlb,vchlbs,vchlf,vchlfs,vchlg,vchlgs,\\\n+vchlh,vchlhs,vcksm,vclgdb,vclzf,vctzb,vctzf,vctzg,vctzh,verimb,verimf,\\\n+verimg,verimh,verllb,verllf,verllg,verllh,verllvb,verllvf,verllvg,verllvh,\\\n+veslb,veslf,veslg,veslh,veslvb,veslvf,veslvg,veslvh,vesrab,vesraf,vesrag,\\\n+vesrah,vesravb,vesravf,vesravg,vesravh,vesrlb,vesrlf,vesrlg,vesrlh,vesrlvb,\\\n+vesrlvf,vesrlvg,vesrlvh,vfadb,vfasb,vfcedb,vfcedbs,vfcesb,vfcesbs,vfchdb,\\\n+vfchdbs,vfchedb,vfchedbs,vfchesb,vfchesbs,vfchsb,vfchsbs,vfeeb,vfeef,vfeeh,\\\n+vfeezbs,vfeezhs,vfeneb,vfenef,vfeneh,vfenezb,vfenezf,vfenezh,vfidb,vfisb,\\\n+vflcdb,vflcsb,vflndb,vflnsb,vflpdb,vfmadb,vfmasb,vfmaxdb,vfmaxsb,vfmdb,\\\n+vfmindb,vfminsb,vfmsb,vfmsdb,vfmssb,vfnmadb,vfnmsdb,vfnmssb,vfsdb,vfssb,\\\n+vftcidb,vftcisb,vgbm,vgfmab,vgfmaf,vgfmag,vgfmah,vgfmb,vgfmf,vgfmg,vgfmh,vgm,\\\n+vgmb,vgmf,vgmg,vgmh,vistrb,vistrbs,vistrf,vistrfs,vistrh,vlcb,vlcf,vlcg,\\\n+vlch,vldeb,vleb,vledb,vlef,vleg,vleh,vleib,vleif,vleig,vleih,vlpb,vlpf,\\\n+vlpg,vlph,vmaeb,vmaef,vmaeh,vmahb,vmahf,vmahh,vmalb,vmaleb,vmalef,vmaleh,\\\n+vmalf,vmalhb,vmalhf,vmalhh,vmalhw,vmalob,vmalof,vmaloh,vmaob,vmaof,vmaoh,\\\n+vmeb,vmef,vmeh,vmhb,vmhf,vmhh,vmlb,vmleb,vmlef,vmleh,vmlf,vmlhb,vmlhf,\\\n+vmlhh,vmlhw,vmlob,vmlof,vmloh,vmnb,vmnf,vmng,vmnh,vmnlb,vmnlf,vmnlg,vmnlh,\\\n+vmob,vmof,vmoh,vmrhb,vmrhf,vmrhg,vmrhh,vmrlb,vmrlf,vmrlg,vmrlh,vmxb,vmxf,\\\n+vmxg,vmxh,vn,vnc,vnn,vno,vnot,vnx,vo,voc,vone,vpdi,vperm,vpkf,vpkg,vpkh,\\\n+vpklsf,vpklsfs,vpklsg,vpklsgs,vpklsh,vpklshs,vpksf,vpksfs,vpksg,vpksgs,vpksh,\\\n+vpkshs,vpopct,vpopctb,vpopctf,vpopctg,vpopcth,vrepb,vrepf,vrepg,vreph,vrepib,\\\n+vrepif,vrepig,vrepih,vsb,vsbiq,vscbib,vscbif,vscbig,vscbih,vscbiq,vsegb,\\\n+vsegf,vsegh,vsel,vsf,vsg,vsh,vsl,vslb,vsldb,vsq,vsra,vsrab,vsrl,vsrlb,vsumb,\\\n+vsumgf,vsumgh,vsumh,vsumqf,vsumqg,vtm,vuphb,vuphf,vuphh,vuplb,vuplf,vuplhb,\\\n+vuplhf,vuplhh,vuplhw,vupllb,vupllf,vupllh,vx,vzero,wcdgb,wcdlgb,wcgdb,wclgdb,\\\n+wfadb,wfasb,wfaxb,wfcdb,wfcedb,wfcesb,wfcexbs,wfchdb,wfchedb,wfchesb,\\\n+wfchexb,wfchexbs,wfchsb,wfchxb,wfchxbs,wfcsb,wfisb,wfixb,wflcdb,wflcsb,wflcxb,\\\n+wflld,wflndb,wflnsb,wflnxb,wflpdb,wflpsb,wflpxb,wfmadb,wfmasb,wfmaxb,\\\n+wfmaxxb,wfmdb,wfminxb,wfmsb,wfmsdb,wfmssb,wfmsxb,wfmxb,wfnmaxb,wfnmsxb,wfsdb,\\\n+wfssb,wfsxb,wldeb,wledb\")\n+ (const_int 1)] (const_int 0)))\n+\n+(define_attr \"z14_cracked\" \"\"\n+(cond [(eq_attr \"mnemonic\" \"bas,basr,cdfbr,cdftr,cdgbr,cdgtr,cdlfbr,\\\n+cdlftr,cdlgbr,cdlgtr,cefbr,cegbr,celfbr,celgbr,cfdbr,cfebr,cfxbr,cgdbr,cgdtr,\\\n+cgebr,cgxbr,cgxtr,chhsi,clfdbr,clfebr,clfxbr,clfxtr,clgdbr,clgdtr,clgebr,\\\n+clgxbr,clgxtr,cs,csg,csy,d,efpc,ex,lcgfr,lngfr,lpgfr,lpq,lxr,lzxr,rxsbg,stpq,\\\n+vgef,vgeg,vscef,vsceg,vsteb\")\n+ (const_int 1)] (const_int 0)))\n+\n+(define_attr \"z14_expanded\" \"\"\n+(cond [(eq_attr \"mnemonic\" \"cds,cdsg,cdsy,cxfbr,cxftr,cxgbr,cxgtr,\\\n+cxlftr,cxlgbr,cxlgtr,dl,dlg,dsg,dsgf,lam,lm,lmg,lmy,sldl,srda,srdl,stam,stm,\\\n+stmg,stmy,tbegin,tbeginc\")\n+ (const_int 1)] (const_int 0)))\n+\n+(define_attr \"z14_groupalone\" \"\"\n+(cond [(eq_attr \"mnemonic\" \"alc,alcg,alcgr,alcr,axbr,axtr,clc,cxbr,\\\n+cxtr,dlgr,dlr,dr,dsgfr,dsgr,dxbr,dxtr,fixbr,fixbra,fixtr,flogr,lcxbr,lnxbr,\\\n+lpxbr,ltxbr,ltxtr,lxdb,lxdbr,lxdtr,lxeb,lxebr,m,madb,maeb,maebr,mfy,mg,mgrk,\\\n+ml,mlg,mlgr,mlr,mr,msdb,mseb,msebr,mvc,mxbr,mxtr,oc,ppa,sfpc,slb,slbg,\\\n+slbgr,slbr,sqxbr,sxbr,sxtr,tabort,tcxb,tdcxt,tend,xc\")\n+ (const_int 1)] (const_int 0)))\n+\n+(define_attr \"z14_endgroup\" \"\"\n+(cond [(eq_attr \"mnemonic\" \"bras,brasl,exrl,ipm\")\n+ (const_int 1)] (const_int 0)))\n+\n+(define_attr \"z14_groupoftwo\" \"\"\n+(cond [(eq_attr \"mnemonic\" \"vacccq,vacq,vfmadb,vfmasb,vfmsdb,vfmssb,\\\n+vfnmadb,vfnmsdb,vfnmssb,vgfmab,vgfmaf,vgfmag,vgfmah,vmaeb,vmaef,vmaeh,vmahb,\\\n+vmahf,vmahh,vmalb,vmaleb,vmalef,vmaleh,vmalf,vmalhb,vmalhf,vmalhh,vmalhw,\\\n+vmalob,vmalof,vmaloh,vmaob,vmaof,vmaoh,vperm,vsbiq,vsel,wfmadb,wfmasb,wfmaxb,\\\n+wfmsdb,wfmssb,wfmsxb,wfnmaxb,wfnmsxb\")\n+ (const_int 1)] (const_int 0)))\n+\n+(define_insn_reservation \"z14_0\" 0\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"a,afi,ag,agfi,aghi,aghik,agr,agrk,ahi,ahik,al,\\\n+alfi,alg,algf,algfi,algfr,alghsik,algr,alhsik,alr,alrk,aly,ark,ay,b,bc,bcr,\\\n+bi,br,bras,brasl,brcl,c,cfi,cg,cgfi,cghi,cghsi,cgit,cgr,cgrl,cgrt,chi,\\\n+chsi,cit,cl,clfhsi,clfi,clfit,clg,clgf,clgfi,clgfr,clgfrl,clghsi,clgit,\\\n+clgr,clgrl,clgrt,clgt,clhhsi,clhrl,cli,cliy,clr,clrl,clrt,clt,cly,cr,crl,\\\n+crt,cy,etnd,exrl,ic,icm,icmh,icmy,icy,iihf,iilf,j,jg,la,larl,lat,lay,lb,\\\n+lbr,lcdfr,lcgr,lcr,ldgr,ldr,lgat,lgb,lgbr,lgf,lgfi,lgfr,lgfrl,lgh,lghi,\\\n+lghr,lghrl,lgr,lh,lhi,lhr,lhrl,lhy,llcr,llgfr,llghr,llgtr,llhr,llihf,llihh,\\\n+llihl,llilf,llilh,llill,lndfr,lngr,lnr,lpdfr,lpgr,lpr,lr,lrv,lrvg,lrvgr,\\\n+lrvh,lrvr,lt,ltg,ltgf,ltgfr,ltgr,ltr,lzdr,lzer,n,ng,ngr,ngrk,nihf,nihh,\\\n+nihl,nilf,nilh,nill,nop,nopr,nr,nrk,ny,o,og,ogr,ogrk,oihf,oihh,oihl,oilf,\\\n+oilh,oill,or,ork,oy,pfpo,risbg,risbgn,rll,rllg,rnsbg,rosbg,s,sg,sgr,sgrk,\\\n+sl,sldl,slfi,slg,slgf,slgfi,slgfr,slgr,slgrk,sll,sllg,sllk,slr,slrk,sly,\\\n+sr,sra,srag,srak,srda,srdl,srl,srlg,srlk,sy,tm,tmh,tmhh,tmhl,tml,tmlh,\\\n+tmll,tmy,vlr,vlvgb,vlvgf,vlvgg,vlvgh,x,xg,xgr,xgrk,xihf,xilf,xr,xrk,xy\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_1\" 1\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"agf,agfr,agh,agsi,algsi,alsi,asi,cgf,cgfr,cgfrl,\\\n+cgh,cghrl,ch,chrl,chy,clm,clmy,cpsdr,laa,laag,lan,lang,lao,laog,lax,laxg,\\\n+le,ler,ley,loc,locg,locghi,locgr,lochi,locr,mvghi,mvhhi,mvhi,mvi,mviy,ni,\\\n+niy,ntstg,oi,oiy,sgf,sgfr,sgh,sh,shy,st,stc,stcy,stg,stgrl,sth,sthrl,sthy,\\\n+stoc,stocg,strl,strv,strvg,strvh,sty,vab,vaccb,vacccq,vaccf,vaccg,vacch,\\\n+vaccq,vacq,vaf,vag,vah,vaq,vavgb,vavgf,vavgg,vavgh,vavglb,vavglf,vavglg,\\\n+vavglh,vbperm,vceqb,vceqf,vceqg,vceqh,vchb,vchf,vchg,vchh,vchlb,vchlf,vchlg,\\\n+vchlh,vclzf,vctzb,vctzf,vctzg,vctzh,verimb,verimf,verimg,verimh,verllb,\\\n+verllf,verllg,verllh,verllvb,verllvf,verllvg,verllvh,veslb,veslf,veslg,veslh,\\\n+veslvb,veslvf,veslvg,veslvh,vesrab,vesraf,vesrag,vesrah,vesravb,vesravf,\\\n+vesravg,vesravh,vesrlb,vesrlf,vesrlg,vesrlh,vesrlvb,vesrlvf,vesrlvg,vesrlvh,\\\n+vfcedb,vfcesb,vfchdb,vfchedb,vfchesb,vfchsb,vflcdb,vflcsb,vflndb,vflnsb,\\\n+vflpdb,vfmaxdb,vfmaxsb,vfmindb,vfminsb,vgbm,vgm,vgmb,vgmf,vgmg,vgmh,vlcb,\\\n+vlcf,vlcg,vlch,vleb,vlef,vleg,vleh,vleib,vleif,vleig,vleih,vlpb,vlpf,vlpg,\\\n+vlph,vmnb,vmnf,vmng,vmnh,vmnlb,vmnlf,vmnlg,vmnlh,vmrhb,vmrhf,vmrhg,vmrhh,\\\n+vmrlb,vmrlf,vmrlg,vmrlh,vmxb,vmxf,vmxg,vmxh,vn,vnc,vnn,vno,vnot,vnx,vo,voc,\\\n+vone,vpdi,vperm,vpkf,vpkg,vpkh,vpklsf,vpklsg,vpklsh,vpksf,vpksg,vpksh,\\\n+vpopct,vpopctb,vpopctf,vpopctg,vpopcth,vrepb,vrepf,vrepg,vreph,vrepib,vrepif,\\\n+vrepig,vrepih,vsb,vsbiq,vscbib,vscbif,vscbig,vscbih,vscbiq,vsegb,vsegf,vsegh,\\\n+vsel,vsf,vsg,vsh,vsl,vslb,vsldb,vsq,vsra,vsrab,vsrl,vsrlb,vuphb,vuphf,\\\n+vuphh,vuplb,vuplf,vuplhb,vuplhf,vuplhh,vuplhw,vupllb,vupllf,vupllh,vx,vzero,\\\n+wfcedb,wfcesb,wfchdb,wfchedb,wfchesb,wfchexb,wfchsb,wfchxb,wflcdb,wflcsb,\\\n+wflcxb,wflndb,wflnsb,wflnxb,wflpdb,wflpsb,wflpxb,wfmaxxb,wfminxb,xi,xiy\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_2\" 2\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"cdb,cdbr,cebr,ear,ipm,l,lcbb,lcdbr,lcebr,ld,lde,\\\n+ldy,lg,lgdr,lgrl,llc,llgc,llgf,llgfrl,llgh,llghrl,llgt,llh,llhrl,lm,lmg,\\\n+lmy,lndbr,lnebr,lpdbr,lpebr,lrl,ltdbr,ltebr,ly,popcnt,sar,tcdb,tceb,\\\n+vceqbs,vceqfs,vceqgs,vceqhs,vchbs,vchfs,vchgs,vchhs,vchlbs,vchlfs,vchlgs,\\\n+vchlhs,vfcedbs,vfcesbs,vfchdbs,vfchedbs,vfchesbs,vfchsbs,vfeeb,vfeef,vfeeh,\\\n+vfeneb,vfenef,vfeneh,vfenezb,vfenezf,vfenezh,vftcidb,vftcisb,vistrb,vistrf,\\\n+vistrh,vlgvf,vlgvg,vlgvh,vllezb,vllezf,vllezg,vllezh,vllezlf,vlrepb,vlrepf,\\\n+vlrepg,vlreph,vlrl,vlvgp,vpklsfs,vpklsgs,vpklshs,vpksfs,vpksgs,vpkshs,wfcdb,\\\n+wfcexbs,wfchexbs,wfchxbs,wfcsb\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_3\" 3\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"cds,cdsy,mgh,mghi,mh,mhi,mhy,std,stdy,ste,stey,\\\n+vcksm,vfeezbs,vfeezhs,vgfmab,vgfmaf,vgfmag,vgfmah,vgfmb,vgfmf,vgfmg,vgfmh,\\\n+vistrbs,vistrfs,vl,vlbb,vll,vlrlr,vmaeb,vmaef,vmaeh,vmahb,vmahf,vmahh,vmalb,\\\n+vmaleb,vmalef,vmaleh,vmalf,vmalhb,vmalhf,vmalhh,vmalhw,vmalob,vmalof,vmaloh,\\\n+vmaob,vmaof,vmaoh,vmeb,vmef,vmeh,vmhb,vmhf,vmhh,vmlb,vmleb,vmlef,vmleh,vmlf,\\\n+vmlhb,vmlhf,vmlhh,vmlhw,vmlob,vmlof,vmloh,vmob,vmof,vmoh,vsumb,vsumgf,\\\n+vsumgh,vsumh,vsumqf,vsumqg,vtm\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_4\" 4\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"bas,basr,chhsi,clc,ex,lam,lcgfr,lngfr,lpgfr,lxr,\\\n+lzxr,ms,msfi,msgf,msgfi,msgfr,msr,msy,mvc,oc,ppa,rxsbg,tabort,tbegin,\\\n+tbeginc,tend,vst,vstl,vstrl,vstrlr,xc\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_5\" 5\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"alc,alcg,alcgr,alcr,cs,csg,csy,msrkc,slb,slbg,\\\n+slbgr,slbr,stm,stmg,stmy\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_6\" 6\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"adb,adbr,aeb,aebr,fidbr,fidbra,fiebr,fiebra,\\\n+ldeb,ldebr,ledbr,madbr,mdbr,meeb,meebr,msdbr,msg,msgr,sdb,sdbr,seb,sebr,\\\n+sfpc,vcdgb,vcdlgb,vcgdb,vclgdb,vfadb,vfidb,vfmadb,vfmdb,vfmsdb,vfnmadb,\\\n+vfnmsdb,vfsdb,vldeb,vledb,wcdgb,wcdlgb,wcgdb,wclgdb,wfadb,wfasb,wfisb,wfmadb,\\\n+wfmasb,wfmdb,wfmsb,wfmsdb,wfmssb,wfsdb,wfssb,wldeb,wledb\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_7\" 7\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"adtr,cdtr,fidtr,ldetr,msgrkc,sdtr,tdcdt,tdcet,\\\n+vfasb,vfisb,vfmasb,vfmsb,vfmssb,vfnmssb,vfssb,vgef,vgeg,wflld\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_8\" 8\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"cdsg,flogr,lpq,stpq,vsteb\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_9\" 9\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"cxfbr,cxgbr,cxlgbr,m,mfy,ml,mlr,mr,stam,wfaxb,\\\n+wfixb,wfsxb\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_10\" 10\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"cdfbr,cdgbr,cdlfbr,cdlgbr,cefbr,cegbr,celfbr,\\\n+celgbr,madb,maeb,maebr,msdb,mseb,msebr,vscef,vsceg\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_11\" 11\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"lxdb,lxdbr,lxeb,lxebr,mg,mgrk,mlg,mlgr\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_12\" 12\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"cfdbr,cfebr,cgdbr,cgebr,clfdbr,clfebr,clgdbr,\\\n+clgebr,cxbr,cxtr,tcxb,tdcxt\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_13\" 13\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"axbr,axtr,fixbr,fixbra,fixtr,lcxbr,lnxbr,lpxbr,\\\n+ltxbr,ltxtr,lxdtr,sxbr,sxtr\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_14\" 14\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"cfxbr,cgxbr,clfxbr,clgxbr,ledtr\")) \"nothing\")\n+\n+(define_insn_reservation \"z14_20\" 20\n+  (and (eq_attr \"cpu\" \"z14\")\n+(eq_attr \"mnemonic\" \"cdftr,cdgtr,cdlftr,cdlgtr,cgdtr,cgxtr,clfxtr,\\\n+clgdtr,clgxtr,cxftr,cxgtr,cxlftr,cxlgtr,d,ddb,ddbr,ddtr,deb,debr,dl,dlg,dlgr,\\\n+dlr,dr,dsg,dsgf,dsgfr,dsgr,dxbr,dxtr,efpc,mdtr,mxbr,mxtr,sqdb,sqdbr,sqeb,\\\n+sqebr,sqxbr,vfddb,vfdsb,vfsqdb,vfsqsb,wfddb,wfdsb,wfdxb,wfmaxb,wfmsxb,wfmxb,\\\n+wfnmaxb,wfnmsxb,wfsqdb,wfsqxb\")) \"nothing\")\n+"}, {"sha": "70a7034c300bb66e9df5977cc6913b85ca46cc7b", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 186, "deletions": 111, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=ff99338ce375620258e8ebba222d6c224914b7d2", "patch": "@@ -344,28 +344,26 @@ extern int reload_completed;\n \n /* Kept up to date using the SCHED_VARIABLE_ISSUE hook.  */\n static rtx_insn *last_scheduled_insn;\n-#define MAX_SCHED_UNITS 4\n-static int last_scheduled_unit_distance[MAX_SCHED_UNITS];\n-\n #define NUM_SIDES 2\n-static int current_side = 1;\n-#define LONGRUNNING_THRESHOLD 20\n+\n+#define MAX_SCHED_UNITS 4\n+static int last_scheduled_unit_distance[MAX_SCHED_UNITS][NUM_SIDES];\n \n /* Estimate of number of cycles a long-running insn occupies an\n    execution unit.  */\n-static unsigned fxd_longrunning[NUM_SIDES];\n-static unsigned fpd_longrunning[NUM_SIDES];\n+static int fxd_longrunning[NUM_SIDES];\n+static int fpd_longrunning[NUM_SIDES];\n \n /* The maximum score added for an instruction whose unit hasn't been\n    in use for MAX_SCHED_MIX_DISTANCE steps.  Increase this value to\n    give instruction mix scheduling more priority over instruction\n    grouping.  */\n-#define MAX_SCHED_MIX_SCORE      8\n+#define MAX_SCHED_MIX_SCORE      2\n \n /* The maximum distance up to which individual scores will be\n    calculated.  Everything beyond this gives MAX_SCHED_MIX_SCORE.\n    Increase this with the OOO windows size of the machine.  */\n-#define MAX_SCHED_MIX_DISTANCE 100\n+#define MAX_SCHED_MIX_DISTANCE 70\n \n /* Structure used to hold the components of a S/390 memory\n    address.  A legitimate address on S/390 is of the general\n@@ -14243,7 +14241,7 @@ s390_z10_prevent_earlyload_conflicts (rtx_insn **ready, int *nready_p)\n }\n \n /* Returns TRUE if BB is entered via a fallthru edge and all other\n-   incoming edges are less than unlikely.  */\n+   incoming edges are less than likely.  */\n static bool\n s390_bb_fallthru_entry_likely (basic_block bb)\n {\n@@ -14259,28 +14257,29 @@ s390_bb_fallthru_entry_likely (basic_block bb)\n \n   FOR_EACH_EDGE (e, ei, bb->preds)\n     if (e != fallthru_edge\n-\t&& e->probability >= profile_probability::unlikely ())\n+\t&& e->probability >= profile_probability::likely ())\n       return false;\n \n   return true;\n }\n \n-/* The s390_sched_state variable tracks the state of the current or\n-   the last instruction group.\n-\n-   0,1,2 number of instructions scheduled in the current group\n-   3     the last group is complete - normal insns\n-   4     the last group was a cracked/expanded insn */\n-\n-static int s390_sched_state = 0;\n+struct s390_sched_state\n+{\n+  /* Number of insns in the group.  */\n+  int group_state;\n+  /* Execution side of the group.  */\n+  int side;\n+  /* Group can only hold two insns.  */\n+  bool group_of_two;\n+} s390_sched_state;\n \n-#define S390_SCHED_STATE_NORMAL  3\n-#define S390_SCHED_STATE_CRACKED 4\n+static struct s390_sched_state sched_state = {0, 1, false};\n \n #define S390_SCHED_ATTR_MASK_CRACKED    0x1\n #define S390_SCHED_ATTR_MASK_EXPANDED   0x2\n #define S390_SCHED_ATTR_MASK_ENDGROUP   0x4\n #define S390_SCHED_ATTR_MASK_GROUPALONE 0x8\n+#define S390_SCHED_ATTR_MASK_GROUPOFTWO 0x10\n \n static unsigned int\n s390_get_sched_attrmask (rtx_insn *insn)\n@@ -14300,7 +14299,6 @@ s390_get_sched_attrmask (rtx_insn *insn)\n \tmask |= S390_SCHED_ATTR_MASK_GROUPALONE;\n       break;\n     case PROCESSOR_2964_Z13:\n-    case PROCESSOR_3906_Z14:\n       if (get_attr_z13_cracked (insn))\n \tmask |= S390_SCHED_ATTR_MASK_CRACKED;\n       if (get_attr_z13_expanded (insn))\n@@ -14309,6 +14307,20 @@ s390_get_sched_attrmask (rtx_insn *insn)\n \tmask |= S390_SCHED_ATTR_MASK_ENDGROUP;\n       if (get_attr_z13_groupalone (insn))\n \tmask |= S390_SCHED_ATTR_MASK_GROUPALONE;\n+      if (get_attr_z13_groupoftwo (insn))\n+\tmask |= S390_SCHED_ATTR_MASK_GROUPOFTWO;\n+      break;\n+    case PROCESSOR_3906_Z14:\n+      if (get_attr_z14_cracked (insn))\n+\tmask |= S390_SCHED_ATTR_MASK_CRACKED;\n+      if (get_attr_z14_expanded (insn))\n+\tmask |= S390_SCHED_ATTR_MASK_EXPANDED;\n+      if (get_attr_z14_endgroup (insn))\n+\tmask |= S390_SCHED_ATTR_MASK_ENDGROUP;\n+      if (get_attr_z14_groupalone (insn))\n+\tmask |= S390_SCHED_ATTR_MASK_GROUPALONE;\n+      if (get_attr_z14_groupoftwo (insn))\n+\tmask |= S390_SCHED_ATTR_MASK_GROUPOFTWO;\n       break;\n     default:\n       gcc_unreachable ();\n@@ -14324,7 +14336,6 @@ s390_get_unit_mask (rtx_insn *insn, int *units)\n   switch (s390_tune)\n     {\n     case PROCESSOR_2964_Z13:\n-    case PROCESSOR_3906_Z14:\n       *units = 4;\n       if (get_attr_z13_unit_lsu (insn))\n \tmask |= 1 << 0;\n@@ -14335,22 +14346,62 @@ s390_get_unit_mask (rtx_insn *insn, int *units)\n       if (get_attr_z13_unit_vfu (insn))\n \tmask |= 1 << 3;\n       break;\n+    case PROCESSOR_3906_Z14:\n+      *units = 4;\n+      if (get_attr_z14_unit_lsu (insn))\n+\tmask |= 1 << 0;\n+      if (get_attr_z14_unit_fxa (insn))\n+\tmask |= 1 << 1;\n+      if (get_attr_z14_unit_fxb (insn))\n+\tmask |= 1 << 2;\n+      if (get_attr_z14_unit_vfu (insn))\n+\tmask |= 1 << 3;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n   return mask;\n }\n \n+static bool\n+s390_is_fpd (rtx_insn *insn)\n+{\n+  if (insn == NULL_RTX)\n+    return false;\n+\n+  return get_attr_z13_unit_fpd (insn) || get_attr_z14_unit_fpd (insn);\n+}\n+\n+static bool\n+s390_is_fxd (rtx_insn *insn)\n+{\n+  if (insn == NULL_RTX)\n+    return false;\n+\n+  return get_attr_z13_unit_fxd (insn) || get_attr_z14_unit_fxd (insn);\n+}\n+\n+/* Returns TRUE if INSN is a long-running instruction.  */\n+static bool\n+s390_is_longrunning (rtx_insn *insn)\n+{\n+  if (insn == NULL_RTX)\n+    return false;\n+\n+  return s390_is_fxd (insn) || s390_is_fpd (insn);\n+}\n+\n+\n /* Return the scheduling score for INSN.  The higher the score the\n    better.  The score is calculated from the OOO scheduling attributes\n-   of INSN and the scheduling state s390_sched_state.  */\n+   of INSN and the scheduling state sched_state.  */\n static int\n s390_sched_score (rtx_insn *insn)\n {\n   unsigned int mask = s390_get_sched_attrmask (insn);\n   int score = 0;\n \n-  switch (s390_sched_state)\n+  switch (sched_state.group_state)\n     {\n     case 0:\n       /* Try to put insns into the first slot which would otherwise\n@@ -14360,7 +14411,7 @@ s390_sched_score (rtx_insn *insn)\n \tscore += 5;\n       if ((mask & S390_SCHED_ATTR_MASK_GROUPALONE) != 0)\n \tscore += 10;\n-      /* fallthrough */\n+      break;\n     case 1:\n       /* Prefer not cracked insns while trying to put together a\n \t group.  */\n@@ -14370,6 +14421,11 @@ s390_sched_score (rtx_insn *insn)\n \tscore += 10;\n       if ((mask & S390_SCHED_ATTR_MASK_ENDGROUP) == 0)\n \tscore += 5;\n+      /* If we are in a group of two already, try to schedule another\n+\t group-of-two insn to avoid shortening another group.  */\n+      if (sched_state.group_of_two\n+\t  && (mask & S390_SCHED_ATTR_MASK_GROUPOFTWO) != 0)\n+\tscore += 15;\n       break;\n     case 2:\n       /* Prefer not cracked insns while trying to put together a\n@@ -14381,21 +14437,10 @@ s390_sched_score (rtx_insn *insn)\n       /* Prefer endgroup insns in the last slot.  */\n       if ((mask & S390_SCHED_ATTR_MASK_ENDGROUP) != 0)\n \tscore += 10;\n-      break;\n-    case S390_SCHED_STATE_NORMAL:\n-      /* Prefer not cracked insns if the last was not cracked.  */\n-      if ((mask & S390_SCHED_ATTR_MASK_CRACKED) == 0\n-\t  && (mask & S390_SCHED_ATTR_MASK_EXPANDED) == 0)\n-\tscore += 5;\n-      if ((mask & S390_SCHED_ATTR_MASK_GROUPALONE) != 0)\n-\tscore += 10;\n-      break;\n-    case S390_SCHED_STATE_CRACKED:\n-      /* Try to keep cracked insns together to prevent them from\n-\t interrupting groups.  */\n-      if ((mask & S390_SCHED_ATTR_MASK_CRACKED) != 0\n-\t  || (mask & S390_SCHED_ATTR_MASK_EXPANDED) != 0)\n-\tscore += 5;\n+      /* Try to avoid group-of-two insns in the last slot as they will\n+\t shorten this group as well as the next one.  */\n+      if ((mask & S390_SCHED_ATTR_MASK_GROUPOFTWO) != 0)\n+\tscore = MAX (0, score - 15);\n       break;\n     }\n \n@@ -14413,23 +14458,37 @@ s390_sched_score (rtx_insn *insn)\n \t CPU.  */\n       for (i = 0; i < units; i++, m <<= 1)\n \tif (m & unit_mask)\n-\t  score += (last_scheduled_unit_distance[i] * MAX_SCHED_MIX_SCORE /\n-\t\t    MAX_SCHED_MIX_DISTANCE);\n-\n-      unsigned latency = insn_default_latency (insn);\n+\t  score += (last_scheduled_unit_distance[i][sched_state.side]\n+\t      * MAX_SCHED_MIX_SCORE / MAX_SCHED_MIX_DISTANCE);\n \n-      int other_side = 1 - current_side;\n+      int other_side = 1 - sched_state.side;\n \n       /* Try to delay long-running insns when side is busy.  */\n-      if (latency > LONGRUNNING_THRESHOLD)\n+      if (s390_is_longrunning (insn))\n \t{\n-\t  if (get_attr_z13_unit_fxu (insn) && fxd_longrunning[current_side]\n-\t      && fxd_longrunning[other_side] <= fxd_longrunning[current_side])\n-\t    score = MAX (0, score - 10);\n+\t  if (s390_is_fxd (insn))\n+\t    {\n+\t      if (fxd_longrunning[sched_state.side]\n+\t\t  && fxd_longrunning[other_side]\n+\t\t  <= fxd_longrunning[sched_state.side])\n+\t\tscore = MAX (0, score - 10);\n+\n+\t      else if (fxd_longrunning[other_side]\n+\t\t  >= fxd_longrunning[sched_state.side])\n+\t\tscore += 10;\n+\t    }\n \n-\t  if (get_attr_z13_unit_vfu (insn) && fpd_longrunning[current_side]\n-\t      && fpd_longrunning[other_side] <= fpd_longrunning[current_side])\n-\t    score = MAX (0, score - 10);\n+\t  if (s390_is_fpd (insn))\n+\t    {\n+\t      if (fpd_longrunning[sched_state.side]\n+\t\t  && fpd_longrunning[other_side]\n+\t\t  <= fpd_longrunning[sched_state.side])\n+\t\tscore = MAX (0, score - 10);\n+\n+\t      else if (fpd_longrunning[other_side]\n+\t\t  >= fpd_longrunning[sched_state.side])\n+\t\tscore += 10;\n+\t    }\n \t}\n     }\n \n@@ -14500,7 +14559,7 @@ s390_sched_reorder (FILE *file, int verbose,\n       if (verbose > 5)\n \t{\n \t  fprintf (file, \"ready list ooo attributes - sched state: %d\\n\",\n-\t\t   s390_sched_state);\n+\t\t   sched_state.group_state);\n \n \t  for (i = last_index; i >= 0; i--)\n \t    {\n@@ -14551,45 +14610,39 @@ s390_sched_variable_issue (FILE *file, int verbose, rtx_insn *insn, int more)\n {\n   last_scheduled_insn = insn;\n \n-  bool starts_group = false;\n+  bool ends_group = false;\n \n   if (s390_tune >= PROCESSOR_2827_ZEC12\n       && reload_completed\n       && recog_memoized (insn) >= 0)\n     {\n       unsigned int mask = s390_get_sched_attrmask (insn);\n \n-      if ((mask & S390_SCHED_ATTR_MASK_CRACKED) != 0\n-\t  || (mask & S390_SCHED_ATTR_MASK_EXPANDED) != 0\n-\t  || (mask & S390_SCHED_ATTR_MASK_GROUPALONE) != 0)\n-\tstarts_group = true;\n+      if ((mask & S390_SCHED_ATTR_MASK_GROUPOFTWO) != 0)\n+\tsched_state.group_of_two = true;\n \n-      if ((mask & S390_SCHED_ATTR_MASK_CRACKED) != 0\n-\t  || (mask & S390_SCHED_ATTR_MASK_EXPANDED) != 0)\n-\ts390_sched_state = S390_SCHED_STATE_CRACKED;\n-      else if ((mask & S390_SCHED_ATTR_MASK_ENDGROUP) != 0\n-\t       || (mask & S390_SCHED_ATTR_MASK_GROUPALONE) != 0)\n-\ts390_sched_state = S390_SCHED_STATE_NORMAL;\n-      else\n+      /* If this is a group-of-two insn, we actually ended the last group\n+\t and this insn is the first one of the new group.  */\n+      if (sched_state.group_state == 2 && sched_state.group_of_two)\n \t{\n-\t  /* Only normal insns are left (mask == 0).  */\n-\t  switch (s390_sched_state)\n-\t    {\n-\t    case 0:\n-\t      starts_group = true;\n-\t      /* fallthrough */\n-\t    case 1:\n-\t    case 2:\n-\t      s390_sched_state++;\n-\t      break;\n-\t    case S390_SCHED_STATE_NORMAL:\n-\t      starts_group = true;\n-\t      s390_sched_state = 1;\n-\t      break;\n-\t    case S390_SCHED_STATE_CRACKED:\n-\t      s390_sched_state = S390_SCHED_STATE_NORMAL;\n-\t      break;\n-\t    }\n+\t  sched_state.side = sched_state.side ? 0 : 1;\n+\t  sched_state.group_state = 0;\n+\t}\n+\n+      /* Longrunning and side bookkeeping.  */\n+      for (int i = 0; i < 2; i++)\n+\t{\n+\t  fxd_longrunning[i] = MAX (0, fxd_longrunning[i] - 1);\n+\t  fpd_longrunning[i] = MAX (0, fpd_longrunning[i] - 1);\n+\t}\n+\n+      unsigned latency = insn_default_latency (insn);\n+      if (s390_is_longrunning (insn))\n+\t{\n+\t  if (s390_is_fxd (insn))\n+\t    fxd_longrunning[sched_state.side] = latency;\n+\t  else\n+\t    fpd_longrunning[sched_state.side] = latency;\n \t}\n \n       if (s390_tune >= PROCESSOR_2964_Z13)\n@@ -14602,30 +14655,40 @@ s390_sched_variable_issue (FILE *file, int verbose, rtx_insn *insn, int more)\n \n \t  for (i = 0; i < units; i++, m <<= 1)\n \t    if (m & unit_mask)\n-\t      last_scheduled_unit_distance[i] = 0;\n-\t    else if (last_scheduled_unit_distance[i] < MAX_SCHED_MIX_DISTANCE)\n-\t      last_scheduled_unit_distance[i]++;\n+\t      last_scheduled_unit_distance[i][sched_state.side] = 0;\n+\t    else if (last_scheduled_unit_distance[i][sched_state.side]\n+\t\t< MAX_SCHED_MIX_DISTANCE)\n+\t      last_scheduled_unit_distance[i][sched_state.side]++;\n \t}\n \n-      /* If this insn started a new group, the side flipped.  */\n-      if (starts_group)\n-\tcurrent_side = current_side ? 0 : 1;\n-\n-      for (int i = 0; i < 2; i++)\n+      if ((mask & S390_SCHED_ATTR_MASK_CRACKED) != 0\n+\t  || (mask & S390_SCHED_ATTR_MASK_EXPANDED) != 0\n+\t  || (mask & S390_SCHED_ATTR_MASK_GROUPALONE) != 0\n+\t  || (mask & S390_SCHED_ATTR_MASK_ENDGROUP) != 0)\n \t{\n-\t  if (fxd_longrunning[i] >= 1)\n-\t    fxd_longrunning[i] -= 1;\n-\t  if (fpd_longrunning[i] >= 1)\n-\t    fpd_longrunning[i] -= 1;\n+\t  sched_state.group_state = 0;\n+\t  ends_group = true;\n \t}\n-\n-      unsigned latency = insn_default_latency (insn);\n-      if (latency > LONGRUNNING_THRESHOLD)\n+      else\n \t{\n-\t  if (get_attr_z13_unit_fxu (insn))\n-\t    fxd_longrunning[current_side] = latency;\n-\t  else\n-\t    fpd_longrunning[current_side] = latency;\n+\t  switch (sched_state.group_state)\n+\t    {\n+\t    case 0:\n+\t      sched_state.group_state++;\n+\t      break;\n+\t    case 1:\n+\t      sched_state.group_state++;\n+\t      if (sched_state.group_of_two)\n+\t\t{\n+\t\t  sched_state.group_state = 0;\n+\t\t  ends_group = true;\n+\t\t}\n+\t      break;\n+\t    case 2:\n+\t      sched_state.group_state++;\n+\t      ends_group = true;\n+\t      break;\n+\t    }\n \t}\n \n       if (verbose > 5)\n@@ -14654,20 +14717,29 @@ s390_sched_variable_issue (FILE *file, int verbose, rtx_insn *insn, int more)\n \t\t  fprintf (file, \" %d\", j);\n \t      fprintf (file, \")\");\n \t    }\n-\t  fprintf (file, \" sched state: %d\\n\", s390_sched_state);\n+\t  fprintf (file, \" sched state: %d\\n\", sched_state.group_state);\n \n \t  if (s390_tune >= PROCESSOR_2964_Z13)\n \t    {\n \t      int units, j;\n \n \t      s390_get_unit_mask (insn, &units);\n \n-\t      fprintf (file, \";;\\t\\tBACKEND: units unused for: \");\n+\t      fprintf (file, \";;\\t\\tBACKEND: units on this side unused for: \");\n \t      for (j = 0; j < units; j++)\n-\t\tfprintf (file, \"%d:%d \", j, last_scheduled_unit_distance[j]);\n+\t\tfprintf (file, \"%d:%d \", j,\n+\t\t    last_scheduled_unit_distance[j][sched_state.side]);\n \t      fprintf (file, \"\\n\");\n \t    }\n \t}\n+\n+      /* If this insn ended a group, the next will be on the other side.  */\n+      if (ends_group)\n+\t{\n+\t  sched_state.group_state = 0;\n+\t  sched_state.side = sched_state.side ? 0 : 1;\n+\t  sched_state.group_of_two = false;\n+\t}\n     }\n \n   if (GET_CODE (PATTERN (insn)) != USE\n@@ -14682,13 +14754,10 @@ s390_sched_init (FILE *file ATTRIBUTE_UNUSED,\n \t\t int verbose ATTRIBUTE_UNUSED,\n \t\t int max_ready ATTRIBUTE_UNUSED)\n {\n-  last_scheduled_insn = NULL;\n-  memset (last_scheduled_unit_distance, 0, MAX_SCHED_UNITS * sizeof (int));\n-\n   /* If the next basic block is most likely entered via a fallthru edge\n      we keep the last sched state.  Otherwise we start a new group.\n      The scheduler traverses basic blocks in \"instruction stream\" ordering\n-     so if we see a fallthru edge here, s390_sched_state will be of its\n+     so if we see a fallthru edge here, sched_state will be of its\n      source block.\n \n      current_sched_info->prev_head is the insn before the first insn of the\n@@ -14698,7 +14767,13 @@ s390_sched_init (FILE *file ATTRIBUTE_UNUSED,\n     ? NEXT_INSN (current_sched_info->prev_head) : NULL;\n   basic_block bb = insn ? BLOCK_FOR_INSN (insn) : NULL;\n   if (s390_tune < PROCESSOR_2964_Z13 || !s390_bb_fallthru_entry_likely (bb))\n-    s390_sched_state = 0;\n+    {\n+      last_scheduled_insn = NULL;\n+      memset (last_scheduled_unit_distance, 0,\n+\t  MAX_SCHED_UNITS * NUM_SIDES * sizeof (int));\n+      sched_state.group_state = 0;\n+      sched_state.group_of_two = false;\n+    }\n }\n \n /* This target hook implementation for TARGET_LOOP_UNROLL_ADJUST calculates"}, {"sha": "fcb85d653a25d75f06dd18652cdd91a50930bfd3", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=ff99338ce375620258e8ebba222d6c224914b7d2", "patch": "@@ -44,7 +44,7 @@ enum processor_flags\n \n /* This is necessary to avoid a warning about comparing different enum\n    types.  */\n-#define s390_tune_attr ((enum attr_cpu)(s390_tune > PROCESSOR_2964_Z13 ? PROCESSOR_2964_Z13 : s390_tune ))\n+#define s390_tune_attr ((enum attr_cpu)(s390_tune > PROCESSOR_3906_Z14 ? PROCESSOR_3906_Z14 : s390_tune ))\n \n /* These flags indicate that the generated code should run on a cpu\n    providing the respective hardware facility regardless of the"}, {"sha": "b455b638134e6bf1a832415535f1da53c04d9f8c", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=ff99338ce375620258e8ebba222d6c224914b7d2", "patch": "@@ -595,6 +595,9 @@\n ;; Pipeline description for z13\n (include \"2964.md\")\n \n+;; Pipeline description for z14\n+(include \"3906.md\")\n+\n ;; Predicates\n (include \"predicates.md\")\n "}, {"sha": "a640b6a643b35ff33a9e33af0606083a51c87e04", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff99338ce375620258e8ebba222d6c224914b7d2", "patch": "@@ -1,3 +1,7 @@\n+2019-03-12  Robin Dapp  <rdapp@linux.ibm.com>\n+\n+\t* gcc.target/s390/memset-1.c: Adapt test case for new scheduling.\n+\n 2019-03-12  Martin Liska  <mliska@suse.cz>\n \n \t* gfortran.dg/abstract_type_3.f03: Amend test-case scan"}, {"sha": "9463a77208b2d67fa55961cdf43e35f789bf740c", "filename": "gcc/testsuite/gcc.target/s390/memset-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmemset-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff99338ce375620258e8ebba222d6c224914b7d2/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmemset-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmemset-1.c?ref=ff99338ce375620258e8ebba222d6c224914b7d2", "patch": "@@ -74,7 +74,7 @@ void\n   return __builtin_memset (s, c, 1029);\n }\n \n-/* 2 stc 1 stcy 3 mvc - displacement overflow after the first */\n+/* 3 stc 3 mvc - displacement overflow after the first */\n void\n *memset10(void *s, int c)\n {\n@@ -172,6 +172,6 @@ void\n /* { dg-final { scan-assembler-times \"mvi\\\\s\" 1 } } */\n /* { dg-final { scan-assembler-times \"mvc\\\\s\" 20 } } */\n /* { dg-final { scan-assembler-times \"xc\\\\s\" 28 } } */\n-/* { dg-final { scan-assembler-times \"stc\\\\s\" 21 } } */\n-/* { dg-final { scan-assembler-times \"stcy\\\\s\" 1 } } */\n+/* { dg-final { scan-assembler-times \"stc\\\\s\" 22 } } */\n+/* { dg-final { scan-assembler-times \"stcy\\\\s\" 0 } } */\n /* { dg-final { scan-assembler-times \"pfd\\\\s\" 2 } } */"}]}