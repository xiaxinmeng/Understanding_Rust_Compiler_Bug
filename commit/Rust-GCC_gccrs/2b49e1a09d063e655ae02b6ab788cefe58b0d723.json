{"sha": "2b49e1a09d063e655ae02b6ab788cefe58b0d723", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI0OWUxYTA5ZDA2M2U2NTVhZTAyYjZhYjc4OGNlZmU1OGIwZDcyMw==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2008-01-20T01:48:25Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-01-20T01:48:25Z"}, "message": "re PR tree-optimization/26854 (Inordinate compile times on large routines)\n\n2008-01-19  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\tPR rtl-optimization/26854\n\tPR rtl-optimization/34400\n\t* ddg.c (create_ddg_dep_from_intra_loop_link): Do not use\n\tDF_RD->gen.\n\t* df.h (df_changeable_flags.DF_RD_NO_TRIM): New.\n\t(df_rd_bb_info.expanded_lr_out): New.\n\t* loop_invariant.c (find_defs): Added DF_RD_NO_TRIM flag.\n\t* loop_iv.c (iv_analysis_loop_init): Ditto.\n\t* df-problems.c (df_rd_free_bb_info, df_rd_alloc, df_rd_confluence_n,\n\tdf_rd_bb_local_compute, df_rd_transfer_function, df_rd_free):\n\tAdded code to allocate, initialize or free expanded_lr_out.\n\t(df_rd_bb_local_compute_process_def): Restructured to make\n\tmore understandable.\n\t(df_rd_confluence_n): Add code to do nothing with fake edges and\n\tcode to no apply invalidate_by_call sets if the sets are being trimmed.\n\t(df_lr_local_finalize): Renamed to df_lr_finalize.\n\t(df_live_local_finalize): Renamed to df_live_finalize.\n\nFrom-SVN: r131670", "tree": {"sha": "586d89d9ceda6355a6a8d5fafc831147afd78ca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/586d89d9ceda6355a6a8d5fafc831147afd78ca0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b49e1a09d063e655ae02b6ab788cefe58b0d723", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b49e1a09d063e655ae02b6ab788cefe58b0d723", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b49e1a09d063e655ae02b6ab788cefe58b0d723", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b49e1a09d063e655ae02b6ab788cefe58b0d723/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1828e8e9bfa9526684899e422be914402b3ba960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1828e8e9bfa9526684899e422be914402b3ba960", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1828e8e9bfa9526684899e422be914402b3ba960"}], "stats": {"total": 231, "additions": 160, "deletions": 71}, "files": [{"sha": "28a4a5499731cdf2b7b12fa6ee1bc21d531367de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b49e1a09d063e655ae02b6ab788cefe58b0d723", "patch": "@@ -1,3 +1,23 @@\n+2008-01-19  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\tPR rtl-optimization/26854\n+\tPR rtl-optimization/34400\n+\t* ddg.c (create_ddg_dep_from_intra_loop_link): Do not use\n+\tDF_RD->gen.\n+\t* df.h (df_changeable_flags.DF_RD_NO_TRIM): New.\n+\t(df_rd_bb_info.expanded_lr_out): New.\n+\t* loop_invariant.c (find_defs): Added DF_RD_NO_TRIM flag.\n+\t* loop_iv.c (iv_analysis_loop_init): Ditto.\n+\t* df-problems.c (df_rd_free_bb_info, df_rd_alloc, df_rd_confluence_n,\n+\tdf_rd_bb_local_compute, df_rd_transfer_function, df_rd_free):\n+\tAdded code to allocate, initialize or free expanded_lr_out.\n+\t(df_rd_bb_local_compute_process_def): Restructured to make\n+\tmore understandable.\n+\t(df_rd_confluence_n): Add code to do nothing with fake edges and\n+\tcode to no apply invalidate_by_call sets if the sets are being trimmed.\n+\t(df_lr_local_finalize): Renamed to df_lr_finalize.\n+\t(df_live_local_finalize): Renamed to df_live_finalize.\n+\n 2008-01-20  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \tPR target/34831"}, {"sha": "c67b6c2486989f545a89436a0907ece8007d77a4", "filename": "gcc/ddg.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=2b49e1a09d063e655ae02b6ab788cefe58b0d723", "patch": "@@ -184,12 +184,13 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n         {\n           int regno = REGNO (SET_DEST (set));\n           struct df_ref *first_def;\n-          struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n+          struct df_ref *last_def;\n \n           first_def = df_bb_regno_first_def_find (g->bb, regno);\n           gcc_assert (first_def);\n \n-          if (bitmap_bit_p (bb_info->gen, first_def->id))\n+          last_def = df_bb_regno_last_def_find (g->bb, regno);\n+          if (first_def == last_def)\n             return;\n         }\n     }"}, {"sha": "f45c6d2ff36db0917c93be6de87cc6e1ea3401ee", "filename": "gcc/df-problems.c", "status": "modified", "additions": 84, "deletions": 54, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=2b49e1a09d063e655ae02b6ab788cefe58b0d723", "patch": "@@ -245,6 +245,8 @@ df_rd_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n   struct df_rd_bb_info *bb_info = (struct df_rd_bb_info *) vbb_info;\n   if (bb_info)\n     {\n+      if (bb_info->expanded_lr_out)\n+\tBITMAP_FREE (bb_info->expanded_lr_out);\n       BITMAP_FREE (bb_info->kill);\n       BITMAP_FREE (bb_info->sparse_kill);\n       BITMAP_FREE (bb_info->gen);\n@@ -298,6 +300,8 @@ df_rd_alloc (bitmap all_blocks)\n       struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n       if (bb_info)\n \t{ \n+\t  if (bb_info->expanded_lr_out)\n+\t    bitmap_clear (bb_info->expanded_lr_out);\n \t  bitmap_clear (bb_info->kill);\n \t  bitmap_clear (bb_info->sparse_kill);\n \t  bitmap_clear (bb_info->gen);\n@@ -306,6 +310,10 @@ df_rd_alloc (bitmap all_blocks)\n \t{ \n \t  bb_info = (struct df_rd_bb_info *) pool_alloc (df_rd->block_pool);\n \t  df_rd_set_bb_info (bb_index, bb_info);\n+\t  if (df->changeable_flags & DF_RD_NO_TRIM)\n+\t    bb_info->expanded_lr_out = NULL;\n+\t  else\n+\t    bb_info->expanded_lr_out = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n \t  bb_info->kill = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n \t  bb_info->sparse_kill = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n \t  bb_info->gen = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n@@ -320,56 +328,53 @@ df_rd_alloc (bitmap all_blocks)\n /* Process a list of DEFs for df_rd_bb_local_compute.  */\n \n static void\n-df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info, \n+df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n \t\t\t\t    struct df_ref **def_rec,\n \t\t\t\t    enum df_ref_flags top_flag)\n {\n-  while (*def_rec)\n+  for (; *def_rec; def_rec++)\n     {\n       struct df_ref *def = *def_rec;\n-      if (top_flag == (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n+      unsigned int regno = DF_REF_REGNO (def);\n+\n+      /* This makes sure we do the artificial defs in the right order\n+\t since they are all in the same list.  */\n+      if (top_flag != (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n+\tcontinue;\n+\n+      /* Skip over the hard regs if we do not care about them.  */\n+      if ((df->changeable_flags & DF_NO_HARD_REGS) && \n+\t  (regno < FIRST_PSEUDO_REGISTER))\n+\tcontinue;\n+\n+      /* Only the last def(s) for a regno in the block has any\n+\t effect.  */ \n+      if (bitmap_bit_p (seen_in_block, regno))\n+\tcontinue;\n+\n+      /* The first def for regno in insn gets to knock out the\n+\t defs from other instructions.  */\n+      if ((!bitmap_bit_p (seen_in_insn, regno))\n+\t  /* If the def is to only part of the reg, it does\n+\t     not kill the other defs that reach here.  */\n+\t  && (!(DF_REF_FLAGS (def) & \n+\t\t(DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER))))\n \t{\n-\t  unsigned int regno = DF_REF_REGNO (def);\n \t  unsigned int begin = DF_DEFS_BEGIN (regno);\n \t  unsigned int n_defs = DF_DEFS_COUNT (regno);\n-\t  \n-\t  if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n-\t      || (regno >= FIRST_PSEUDO_REGISTER))\n-\t    {\n-\t      /* Only the last def(s) for a regno in the block has any\n-\t\t effect.  */ \n-\t      if (!bitmap_bit_p (seen_in_block, regno))\n-\t\t{\n-\t\t  /* The first def for regno in insn gets to knock out the\n-\t\t     defs from other instructions.  */\n-\t\t  if ((!bitmap_bit_p (seen_in_insn, regno))\n-\t\t      /* If the def is to only part of the reg, it does\n-\t\t\t not kill the other defs that reach here.  */\n-\t\t      && (!(DF_REF_FLAGS (def) & \n-\t\t\t    (DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER))))\n-\t\t    {\n-\t\t      if (n_defs > DF_SPARSE_THRESHOLD)\n-\t\t\t{\n-\t\t\t  bitmap_set_bit (bb_info->sparse_kill, regno);\n-\t\t\t  bitmap_clear_range(bb_info->gen, begin, n_defs);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  bitmap_set_range (bb_info->kill, begin, n_defs);\n-\t\t\t  bitmap_clear_range (bb_info->gen, begin, n_defs);\n-\t\t\t}\n-\t\t    }\n-\t\t  \n-\t\t  bitmap_set_bit (seen_in_insn, regno);\n-\t\t  /* All defs for regno in the instruction may be put into\n-\t\t     the gen set.  */\n-\t\t  if (!(DF_REF_FLAGS (def) \n-\t\t\t& (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n-\t\t    bitmap_set_bit (bb_info->gen, DF_REF_ID (def));\n-\t\t}\n-\t    }\n+\t  if (n_defs > DF_SPARSE_THRESHOLD)\n+\t    bitmap_set_bit (bb_info->sparse_kill, regno);\n+\t  else\n+\t    bitmap_set_range (bb_info->kill, begin, n_defs);\n+\t  bitmap_clear_range(bb_info->gen, begin, n_defs);\n \t}\n-      def_rec++;\n+      \n+      bitmap_set_bit (seen_in_insn, regno);\n+      /* All defs for regno in the instruction may be put into\n+\t the gen set.  */\n+      if (!(DF_REF_FLAGS (def) \n+\t    & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n+\tbitmap_set_bit (bb_info->gen, DF_REF_ID (def));\n     }\n }\n \n@@ -380,14 +385,28 @@ df_rd_bb_local_compute (unsigned int bb_index)\n {\n   basic_block bb = BASIC_BLOCK (bb_index);\n   struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n+  struct df_lr_bb_info *lr_bb_info = df_lr_get_bb_info (bb_index);\n   rtx insn;\n \n   bitmap_clear (seen_in_block);\n   bitmap_clear (seen_in_insn);\n \n+  if (!(df->changeable_flags & DF_RD_NO_TRIM))\n+    {\n+      unsigned int regno;\n+      bitmap_iterator bi;\n+      int first_reg = (df->changeable_flags & DF_NO_HARD_REGS) ? FIRST_PSEUDO_REGISTER : 0;\n+      EXECUTE_IF_SET_IN_BITMAP (lr_bb_info->out, first_reg, regno, bi)\n+\t{\n+\t  unsigned int begin = DF_DEFS_BEGIN (regno);\n+\t  unsigned int n_defs = DF_DEFS_COUNT (regno);\n+\t  bitmap_set_range (bb_info->expanded_lr_out, begin, n_defs);\n+\t}\n+    }\n+\n   /* Artificials are only hard regs.  */\n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n-    df_rd_bb_local_compute_process_def (bb_info, \n+    df_rd_bb_local_compute_process_def (bb_info,\n \t\t\t\t\tdf_get_artificial_defs (bb_index),\n \t\t\t\t\t0);\n \n@@ -482,15 +501,21 @@ df_rd_confluence_n (edge e)\n   bitmap op1 = df_rd_get_bb_info (e->dest->index)->in;\n   bitmap op2 = df_rd_get_bb_info (e->src->index)->out;\n \n-  if (e->flags & EDGE_EH)\n+  if (e->flags & EDGE_FAKE) \n+    return;\n+\n+  /* If we are trimming the solution, the invalidated_by_call code in\n+     the lr problem makes this unnecessary.  However, if we do not\n+     trim, we must take this into account.  */\n+  if ((df->changeable_flags & DF_RD_NO_TRIM) && e->flags & EDGE_EH)\n     {\n       struct df_rd_problem_data *problem_data\n \t= (struct df_rd_problem_data *) df_rd->problem_data;\n       bitmap sparse_invalidated = problem_data->sparse_invalidated_by_call;\n       bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n       bitmap_iterator bi;\n       unsigned int regno;\n-      bitmap tmp = BITMAP_ALLOC (&df_bitmap_obstack);\n+      bitmap tmp = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n \n       bitmap_copy (tmp, op2);\n       bitmap_and_compl_into (tmp, dense_invalidated);\n@@ -522,13 +547,13 @@ df_rd_transfer_function (int bb_index)\n   bitmap gen = bb_info->gen;\n   bitmap kill = bb_info->kill;\n   bitmap sparse_kill = bb_info->sparse_kill;\n+  bool changed = false;\n \n-  if (bitmap_empty_p (sparse_kill))\n-    return  bitmap_ior_and_compl (out, gen, in, kill);\n+  if ((df->changeable_flags & DF_RD_NO_TRIM) && bitmap_empty_p (sparse_kill))\n+    changed = bitmap_ior_and_compl (out, gen, in, kill);\n   else \n     {\n       struct df_rd_problem_data *problem_data;\n-      bool changed = false;\n       bitmap tmp;\n \n       /* Note that TMP is _not_ a temporary bitmap if we end up replacing\n@@ -545,16 +570,19 @@ df_rd_transfer_function (int bb_index)\n \t}\n       bitmap_and_compl_into (tmp, kill);\n       bitmap_ior_into (tmp, gen);\n+      if (!(df->changeable_flags & DF_RD_NO_TRIM))\n+\tbitmap_and_into (tmp, bb_info->expanded_lr_out);\n       changed = !bitmap_equal_p (tmp, out);\n       if (changed)\n \t{\n \t  BITMAP_FREE (out);\n \t  bb_info->out = tmp;\n \t}\n       else \n-\t  BITMAP_FREE (tmp);\n-      return changed;\n+\tBITMAP_FREE (tmp);\n     }\n+\n+  return changed;\n }\n \n \n@@ -574,6 +602,8 @@ df_rd_free (void)\n \t  struct df_rd_bb_info *bb_info = df_rd_get_bb_info (i);\n \t  if (bb_info)\n \t    {\n+\t      if (bb_info->expanded_lr_out)\n+\t\tBITMAP_FREE (bb_info->expanded_lr_out);\n \t      BITMAP_FREE (bb_info->kill);\n \t      BITMAP_FREE (bb_info->sparse_kill);\n \t      BITMAP_FREE (bb_info->gen);\n@@ -1015,7 +1045,7 @@ df_lr_transfer_function (int bb_index)\n /* Run the fast dce as a side effect of building LR.  */\n \n static void\n-df_lr_local_finalize (bitmap all_blocks ATTRIBUTE_UNUSED)\n+df_lr_finalize (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   if (df->changeable_flags & DF_LR_RUN_DCE)\n     {\n@@ -1161,7 +1191,7 @@ df_lr_verify_solution_end (void)\n \n   if (df_lr->solutions_dirty)\n     /* Do not check if the solution is still dirty.  See the comment\n-       in df_lr_local_finalize for details.  */\n+       in df_lr_finalize for details.  */\n     df_lr->solutions_dirty = false;\n   else\n     FOR_ALL_BB (bb)\n@@ -1204,7 +1234,7 @@ static struct df_problem problem_LR =\n   df_lr_confluence_0,         /* Confluence operator 0.  */ \n   df_lr_confluence_n,         /* Confluence operator n.  */ \n   df_lr_transfer_function,    /* Transfer function.  */\n-  df_lr_local_finalize,       /* Finalize function.  */\n+  df_lr_finalize,             /* Finalize function.  */\n   df_lr_free,                 /* Free all of the problem information.  */\n   NULL,                       /* Remove this problem from the stack of dataflow problems.  */\n   NULL,                       /* Debugging.  */\n@@ -1560,7 +1590,7 @@ df_live_transfer_function (int bb_index)\n /* And the LR info with the must-initialized registers, to produce the LIVE info.  */\n \n static void\n-df_live_local_finalize (bitmap all_blocks)\n+df_live_finalize (bitmap all_blocks)\n {\n \n   if (df_live->solutions_dirty)\n@@ -1751,7 +1781,7 @@ static struct df_problem problem_LIVE =\n   NULL,                         /* Confluence operator 0.  */ \n   df_live_confluence_n,         /* Confluence operator n.  */ \n   df_live_transfer_function,    /* Transfer function.  */\n-  df_live_local_finalize,       /* Finalize function.  */\n+  df_live_finalize,             /* Finalize function.  */\n   df_live_free,                 /* Free all of the problem information.  */\n   df_live_free,                 /* Remove this problem from the stack of dataflow problems.  */\n   NULL,                         /* Debugging.  */"}, {"sha": "e5c6870cac37894b85517bc6d0b2c8912342d4d2", "filename": "gcc/df.h", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=2b49e1a09d063e655ae02b6ab788cefe58b0d723", "patch": "@@ -402,22 +402,30 @@ enum df_changeable_flags\n {\n   /* Scanning flags.  */\n   /* Flag to control the running of dce as a side effect of building LR.  */\n-  DF_LR_RUN_DCE           =  1, /* Run DCE.  */\n-  DF_NO_HARD_REGS         =  2, /* Skip hard registers in RD and CHAIN Building.  */\n-  DF_EQ_NOTES             =  4, /* Build chains with uses present in EQUIV/EQUAL notes. */\n-  DF_NO_REGS_EVER_LIVE    =  8, /* Do not compute the regs_ever_live.  */\n+  DF_LR_RUN_DCE           = 1 << 0, /* Run DCE.  */\n+  DF_NO_HARD_REGS         = 1 << 1, /* Skip hard registers in RD and CHAIN Building.  */\n+\n+  /* Do not trim the solution using the LR result.  This can make the\n+     solution take much longer and take more memory.  This is\n+     necessary for the loop optimizations, but has a very small time\n+     and space penalty because the loop optimizations process only a\n+     single loop at a time.  Any pass that looks at the entire\n+     function should not set this flag.  */\n+  DF_RD_NO_TRIM           = 1 << 2,\n+  DF_EQ_NOTES             = 1 << 3, /* Build chains with uses present in EQUIV/EQUAL notes. */\n+  DF_NO_REGS_EVER_LIVE    = 1 << 4, /* Do not compute the regs_ever_live.  */\n \n   /* Cause df_insn_rescan df_notes_rescan and df_insn_delete, to\n   return immediately.  This is used by passes that know how to update\n   the scanning them selves.  */\n-  DF_NO_INSN_RESCAN       = 16,\n+  DF_NO_INSN_RESCAN       = 1 << 5,\n \n   /* Cause df_insn_rescan df_notes_rescan and df_insn_delete, to\n   return after marking the insn for later processing.  This allows all\n   rescans to be batched.  */\n-  DF_DEFER_INSN_RESCAN    = 32,\n+  DF_DEFER_INSN_RESCAN    = 1 << 6,\n \n-  DF_VERIFY_SCHEDULED     = 64\n+  DF_VERIFY_SCHEDULED     = 1 << 7\n };\n \n /* Two of these structures are inline in df, one for the uses and one\n@@ -705,16 +713,43 @@ struct df_scan_bb_info\n \n \n /* Reaching definitions.  All bitmaps are indexed by the id field of\n-   the ref except sparse_kill (see above).  */\n+   the ref except sparse_kill which is indexed by regno.  */\n struct df_rd_bb_info \n {\n-  /* Local sets to describe the basic blocks.  See the note in the RU\n-     datastructures for kill and sparse_kill.  */\n+  /* Local sets to describe the basic blocks.   */\n   bitmap kill;  \n   bitmap sparse_kill;\n-  bitmap gen;   /* The set of defs generated in this block.  */\n \n-  /* The results of the dataflow problem.  */\n+  /* Expanded version of the DF_LT->out bitmap to match the positions\n+     of gen, in and out here.  Only allocated if DF_RD_NO_TRIM is\n+     false.  */\n+  bitmap expanded_lr_out;\n+\n+  /* The set of defs generated in this block.  This is not set unless\n+     the def reaches the end of the block.  */\n+  bitmap gen;\n+\n+  /* The results of the dataflow problem.  \n+\n+     If DF_RD_NO_TRIM is not set, these sets are SOMEWHAT trimmed by\n+     the output of the DF_LR problem.  The out set is precisely\n+     trimmed during propagation which means that the result is also\n+     trimmed when the propagation terminates.  The in set is not\n+     explicitly trimmed, because this is expensive (adding about 5% to\n+     the cost of a bootstrap).  However since the out sets are trimmed\n+     and the in sets are built from the out of the pred, the in set is\n+     MOSTLY trimmed.\n+\n+     The counter case happens at a branch where the variable V is in\n+     DF_LR->in the true branch but not the false branch.  If V is\n+     defined before the branch, RD will propagate that into the\n+     DF_RD_in sets of both branches.  When the block is processed, the\n+     DF_RD->out set will have V trimmed out of it but it will still be\n+     left in DF_RD->in.  \n+\n+     If this not a problem for the current optimizers since they were\n+     designed before any trimming was available.  This can be fixed by\n+     checking the DF_LR->in set directly.  */\n   bitmap in;    /* At the top of the block.  */\n   bitmap out;   /* At the bottom of the block.  */\n };"}, {"sha": "f056a776958d6211f26b9c777ee4cc1443585c80", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=2b49e1a09d063e655ae02b6ab788cefe58b0d723", "patch": "@@ -639,6 +639,7 @@ find_defs (struct loop *loop, basic_block *body)\n   df_remove_problem (df_chain);\n   df_process_deferred_rescans ();\n   df_chain_add_problem (DF_UD_CHAIN);\n+  df_set_flags (DF_RD_NO_TRIM);\n   df_set_blocks (blocks);\n   df_analyze ();\n "}, {"sha": "824629c0f6cc2dc2d46f73a934e1c7b9d0543815", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b49e1a09d063e655ae02b6ab788cefe58b0d723/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=2b49e1a09d063e655ae02b6ab788cefe58b0d723", "patch": "@@ -22,9 +22,10 @@ along with GCC; see the file COPYING3.  If not see\n    doloop optimization and branch prediction.  The iv information is computed\n    on demand.\n \n-   Induction variable is analyzed by walking the use-def chains.  When a biv\n-   is found, it is cached in the bivs hash table.  When register is proved\n-   to be a giv, its description is stored to DF_REF_DATA of the def reference.\n+   Induction variables are analyzed by walking the use-def chains.  When\n+   a basic induction variable (biv) is found, it is cached in the bivs\n+   hash table.  When register is proved to be a biv, its description\n+   is stored to DF_REF_DATA of the def reference.\n \n    The analysis works always with one loop -- you must call\n    iv_analysis_loop_init (loop) for it.  All the other functions then work with\n@@ -277,6 +278,7 @@ iv_analysis_loop_init (struct loop *loop)\n   df_remove_problem (df_chain);\n   df_process_deferred_rescans ();\n   df_chain_add_problem (DF_UD_CHAIN);\n+  df_set_flags (DF_RD_NO_TRIM);\n   df_set_blocks (blocks);\n   df_analyze ();\n   if (dump_file)"}]}