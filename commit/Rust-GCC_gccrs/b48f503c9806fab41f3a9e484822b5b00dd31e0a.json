{"sha": "b48f503c9806fab41f3a9e484822b5b00dd31e0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ4ZjUwM2M5ODA2ZmFiNDFmM2E5ZTQ4NDgyMmI1YjAwZGQzMWUwYQ==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2005-06-29T01:24:27Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2005-06-29T01:24:27Z"}, "message": "target.h (gcc_target): New field allocate_initial_value.\n\n\t* target.h (gcc_target): New field allocate_initial_value.\n\t* target-def.h (TARGET_ALLOCATE_INITIAL_VALUE): New macro.\n\t(TARGET_INITIALIZER): Include it.\n\t* integrate.c (allocate_initial_values): Use\n\ttargetm.allocate_initial_value.\n\t* system.h: Poison ALLOCATE_INITIAL_VALUE.\n\t* config/sh/sh-protos.h (sh_pr_n_sets): Delete.\n\t* config/sh/sh.c (sh_pr_n_sets): Make it static.\n\t(sh_allocate_initila_value): New function.\n\t(TARGET_ALLOCATE_INITIAL_VALUE): Override default.\n\t* config/sh/sh.h (ALLOCATE_INITIAL_VALUE): Delete.\n\t* doc/tm.texi (TARGET_ALLOCATE_INITIAL_VALUE): Rename and\n\tupdate from ALLOCATE_INITIAL_VALUE.\n\nFrom-SVN: r101411", "tree": {"sha": "6e5206234e2011fe87ca88acfe08dfbe38d900ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e5206234e2011fe87ca88acfe08dfbe38d900ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b48f503c9806fab41f3a9e484822b5b00dd31e0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48f503c9806fab41f3a9e484822b5b00dd31e0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48f503c9806fab41f3a9e484822b5b00dd31e0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48f503c9806fab41f3a9e484822b5b00dd31e0a/comments", "author": null, "committer": null, "parents": [{"sha": "dcb081fc082c2c6ba19b6d82f5fa067d987c30d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcb081fc082c2c6ba19b6d82f5fa067d987c30d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcb081fc082c2c6ba19b6d82f5fa067d987c30d6"}], "stats": {"total": 154, "additions": 99, "deletions": 55}, "files": [{"sha": "7c733de66ffa57c37030d2e960105edfca14e8d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b48f503c9806fab41f3a9e484822b5b00dd31e0a", "patch": "@@ -1,3 +1,19 @@\n+2005-06-29  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* target.h (gcc_target): New field allocate_initial_value.\n+\t* target-def.h (TARGET_ALLOCATE_INITIAL_VALUE): New macro.\n+\t(TARGET_INITIALIZER): Include it.\n+\t* integrate.c (allocate_initial_values): Use\n+\ttargetm.allocate_initial_value.\n+\t* system.h: Poison ALLOCATE_INITIAL_VALUE.\n+\t* config/sh/sh-protos.h (sh_pr_n_sets): Delete.\n+\t* config/sh/sh.c (sh_pr_n_sets): Make it static.\n+\t(sh_allocate_initila_value): New function.\n+\t(TARGET_ALLOCATE_INITIAL_VALUE): Override default.\n+\t* config/sh/sh.h (ALLOCATE_INITIAL_VALUE): Delete.\n+\t* doc/tm.texi (TARGET_ALLOCATE_INITIAL_VALUE): Rename and\n+\tupdate from ALLOCATE_INITIAL_VALUE.\n+\n 2005-06-28  Richard Henderson  <rth@redhat.com>\n \n \t* tree-vectorizer.c (vect_is_simple_reduction): Compare types"}, {"sha": "564c1bee2cf72b5adccb48447d7e063b0aabf6a1", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=b48f503c9806fab41f3a9e484822b5b00dd31e0a", "patch": "@@ -132,7 +132,6 @@ extern int sh_need_epilogue (void);\n extern void sh_set_return_address (rtx, rtx);\n extern int initial_elimination_offset (int, int);\n extern int fldi_ok (void);\n-extern int sh_pr_n_sets (void);\n extern int sh_hard_regno_rename_ok (unsigned int, unsigned int);\n extern int sh_cfun_interrupt_handler_p (void);\n extern int sh_attr_renesas_p (tree);"}, {"sha": "300c104d3b8b0a7163b86d8833d096abf9d5ffb2", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=b48f503c9806fab41f3a9e484822b5b00dd31e0a", "patch": "@@ -271,6 +271,8 @@ static int sh_address_cost (rtx);\n #ifdef TARGET_ADJUST_UNROLL_MAX\n static int sh_adjust_unroll_max (struct loop *, int, int, int, int);\n #endif\n+static int sh_pr_n_sets (void);\n+static rtx sh_allocate_initial_value (rtx);\n static int shmedia_target_regs_stack_space (HARD_REG_SET *);\n static int shmedia_reserve_space_for_target_registers_p (int, HARD_REG_SET *);\n static int shmedia_target_regs_stack_adjust (HARD_REG_SET *);\n@@ -422,6 +424,8 @@ static int hard_regs_intersect_p (HARD_REG_SET *, HARD_REG_SET *);\n #define TARGET_RTX_COSTS sh_rtx_costs\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST sh_address_cost\n+#undef TARGET_ALLOCATE_INITIAL_VALUE\n+#define TARGET_ALLOCATE_INITIAL_VALUE sh_allocate_initial_value\n \n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG sh_reorg\n@@ -8348,16 +8352,41 @@ flow_dependent_p_1 (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n     *pinsn = NULL_RTX;\n }\n \n-/* For use by ALLOCATE_INITIAL_VALUE.  Note that sh.md contains some\n+/* For use by sh_allocate_initial_value.  Note that sh.md contains some\n    'special function' patterns (type sfunc) that clobber pr, but that\n    do not look like function calls to leaf_function_p.  Hence we must\n    do this extra check.  */\n-int\n+static int\n sh_pr_n_sets (void)\n {\n   return REG_N_SETS (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n }\n \n+/* Return where to allocate pseudo for a given hard register initial\n+   value.  */\n+static rtx\n+sh_allocate_initial_value (rtx hard_reg)\n+{\n+  rtx x;\n+\n+  if (REGNO (hard_reg) == (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG))\n+    {\n+      if (current_function_is_leaf\n+\t  && ! sh_pr_n_sets ()\n+\t  && ! (TARGET_SHCOMPACT\n+\t\t&& ((current_function_args_info.call_cookie\n+\t\t     & ~ CALL_COOKIE_RET_TRAMP (1))\n+\t\t    || current_function_has_nonlocal_label)))\n+\tx = hard_reg;\n+      else\n+\tx = gen_rtx_MEM (Pmode, return_address_pointer_rtx);\n+    }\n+  else\n+    x = NULL_RTX;\n+\n+  return x;\n+}\n+\n /* This function returns \"2\" to indicate dual issue for the SH4\n    processor.  To be used by the DFA pipeline description.  */\n static int"}, {"sha": "c803d554d0ab3a8b915d9c9dd310832119156ef7", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=b48f503c9806fab41f3a9e484822b5b00dd31e0a", "patch": "@@ -3360,18 +3360,6 @@ extern struct rtx_def *sp_switch;\n 2:\\n\" TEXT_SECTION_ASM_OP);\n #endif /* (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__ */\n \n-#define ALLOCATE_INITIAL_VALUE(hard_reg) \\\n-  (REGNO (hard_reg) == (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG) \\\n-   ? (current_function_is_leaf \\\n-      && ! sh_pr_n_sets () \\\n-      && ! (TARGET_SHCOMPACT \\\n-\t    && ((current_function_args_info.call_cookie \\\n-\t\t & ~ CALL_COOKIE_RET_TRAMP (1)) \\\n-\t\t|| current_function_has_nonlocal_label)) \\\n-      ? (hard_reg) \\\n-      : gen_rtx_MEM (Pmode, return_address_pointer_rtx)) \\\n-   : NULL_RTX)\n-\n #define SIMULTANEOUS_PREFETCHES 2\n \n /* FIXME: middle-end support for highpart optimizations is missing.  */"}, {"sha": "2c51ef2fe37ed5f84145d4458148eee1915810cb", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b48f503c9806fab41f3a9e484822b5b00dd31e0a", "patch": "@@ -9445,25 +9445,27 @@ filling of delay slots can result in branches being redirected, and this\n may in turn cause a branch offset to overflow.\n @end defmac\n \n-@defmac ALLOCATE_INITIAL_VALUE (@var{hard_reg})\n+@deftypefn {Target Hook} rtx TARGET_ALLOCATE_INITIAL_VALUE (rtx @var{hard_reg})\n \n When the initial value of a hard register has been copied in a pseudo\n register, it is often not necessary to actually allocate another register\n to this pseudo register, because the original hard register or a stack slot\n-it has been saved into can be used.  @code{ALLOCATE_INITIAL_VALUE}, if\n-defined, is called at the start of register allocation once for each\n-hard register that had its initial value copied by using\n+it has been saved into can be used.  @code{TARGET_ALLOCATE_INITIAL_VALUE}\n+is called at the start of register allocation once for each hard register\n+that had its initial value copied by using\n @code{get_func_hard_reg_initial_val} or @code{get_hard_reg_initial_val}.\n Possible values are @code{NULL_RTX}, if you don't want\n to do any special allocation, a @code{REG} rtx---that would typically be\n the hard register itself, if it is known not to be clobbered---or a\n @code{MEM}.\n If you are returning a @code{MEM}, this is only a hint for the allocator;\n it might decide to use another register anyways.\n-You may use @code{current_function_leaf_function} in the definition of the\n-macro, functions that use @code{REG_N_SETS}, to determine if the hard\n+You may use @code{current_function_leaf_function} in the hook, functions\n+that use @code{REG_N_SETS}, to determine if the hard\n register in question will not be clobbered.\n-@end defmac\n+The default value of this hook is @code{NULL}, which disables any special\n+allocation.\n+@end deftypefn\n \n @defmac TARGET_OBJECT_SUFFIX\n Define this macro to be a C string representing the suffix for object"}, {"sha": "28da1157855ecb2307f5273876c18faccf89bdf1", "filename": "gcc/integrate.c", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=b48f503c9806fab41f3a9e484822b5b00dd31e0a", "patch": "@@ -376,47 +376,50 @@ emit_initial_value_sets (void)\n void\n allocate_initial_values (rtx *reg_equiv_memory_loc ATTRIBUTE_UNUSED)\n {\n-#ifdef ALLOCATE_INITIAL_VALUE\n-  struct initial_value_struct *ivs = cfun->hard_reg_initial_vals;\n-  int i;\n-\n-  if (ivs == 0)\n-    return;\n-\n-  for (i = 0; i < ivs->num_entries; i++)\n+  if (targetm.allocate_initial_value)\n     {\n-      int regno = REGNO (ivs->entries[i].pseudo);\n-      rtx x = ALLOCATE_INITIAL_VALUE (ivs->entries[i].hard_reg);\n+      struct initial_value_struct *ivs = cfun->hard_reg_initial_vals;\n+      int i;\n \n-      if (x && REG_N_SETS (REGNO (ivs->entries[i].pseudo)) <= 1)\n+      if (ivs == 0)\n+\treturn;\n+\n+      for (i = 0; i < ivs->num_entries; i++)\n \t{\n-\t  if (MEM_P (x))\n-\t    reg_equiv_memory_loc[regno] = x;\n-\t  else\n+\t  int regno = REGNO (ivs->entries[i].pseudo);\n+\t  rtx x = targetm.allocate_initial_value (ivs->entries[i].hard_reg);\n+  \n+\t  if (x && REG_N_SETS (REGNO (ivs->entries[i].pseudo)) <= 1)\n \t    {\n-\t      basic_block bb;\n-\t      int new_regno;\n-\n-\t      gcc_assert (REG_P (x));\n-\t      new_regno = REGNO (x);\n-\t      reg_renumber[regno] = new_regno;\n-\t      /* Poke the regno right into regno_reg_rtx so that even\n-\t     \t fixed regs are accepted.  */\n-\t      REGNO (ivs->entries[i].pseudo) = new_regno;\n-\t      /* Update global register liveness information.  */\n-\t      FOR_EACH_BB (bb)\n+\t      if (MEM_P (x))\n+\t\treg_equiv_memory_loc[regno] = x;\n+\t      else\n \t\t{\n-\t\t  struct rtl_bb_info *info = bb->il.rtl;\n-\n-\t\t  if (REGNO_REG_SET_P(info->global_live_at_start, regno))\n-\t\t    SET_REGNO_REG_SET (info->global_live_at_start, new_regno);\n-\t\t  if (REGNO_REG_SET_P(info->global_live_at_end, regno))\n-\t\t    SET_REGNO_REG_SET (info->global_live_at_end, new_regno);\n+\t\t  basic_block bb;\n+\t\t  int new_regno;\n+\n+\t\t  gcc_assert (REG_P (x));\n+\t\t  new_regno = REGNO (x);\n+\t\t  reg_renumber[regno] = new_regno;\n+\t\t  /* Poke the regno right into regno_reg_rtx so that even\n+\t\t     fixed regs are accepted.  */\n+\t\t  REGNO (ivs->entries[i].pseudo) = new_regno;\n+\t\t  /* Update global register liveness information.  */\n+\t\t  FOR_EACH_BB (bb)\n+\t\t    {\n+\t\t      struct rtl_bb_info *info = bb->il.rtl;\n+\n+\t\t      if (REGNO_REG_SET_P(info->global_live_at_start, regno))\n+\t\t\tSET_REGNO_REG_SET (info->global_live_at_start,\n+\t\t\t\t\t   new_regno);\n+\t\t      if (REGNO_REG_SET_P(info->global_live_at_end, regno))\n+\t\t\tSET_REGNO_REG_SET (info->global_live_at_end,\n+\t\t\t\t\t   new_regno);\n+\t\t    }\n \t\t}\n \t    }\n \t}\n     }\n-#endif\n }\n \n #include \"gt-integrate.h\""}, {"sha": "3b33db102bec17408471972f5441fe3784d9d88f", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=b48f503c9806fab41f3a9e484822b5b00dd31e0a", "patch": "@@ -692,7 +692,8 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tHANDLE_PRAGMA_REDEFINE_EXTNAME HANDLE_PRAGMA_EXTERN_PREFIX\t\\\n \tMUST_PASS_IN_STACK FUNCTION_ARG_PASS_BY_REFERENCE               \\\n         VECTOR_MODE_SUPPORTED_P TARGET_SUPPORTS_HIDDEN \t\t\t\\\n-\tFUNCTION_ARG_PARTIAL_NREGS ASM_OUTPUT_DWARF_DTPREL\n+\tFUNCTION_ARG_PARTIAL_NREGS ASM_OUTPUT_DWARF_DTPREL\t\t\\\n+\tALLOCATE_INITIAL_VALUE\n \n /* Other obsolete target macros, or macros that used to be in target\n    headers and were not used, and may be obsolete or may never have"}, {"sha": "18e3040874e996f1ed2d5ff08e949f0b0863ce61", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=b48f503c9806fab41f3a9e484822b5b00dd31e0a", "patch": "@@ -362,6 +362,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_ALIGN_ANON_BITFIELD hook_bool_void_false\n #define TARGET_RTX_COSTS hook_bool_rtx_int_int_intp_false\n #define TARGET_MANGLE_FUNDAMENTAL_TYPE hook_constcharptr_tree_null\n+#define TARGET_ALLOCATE_INITIAL_VALUE NULL\n \n #ifndef TARGET_INIT_LIBFUNCS\n #define TARGET_INIT_LIBFUNCS hook_void_void\n@@ -566,6 +567,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_VECTOR_OPAQUE_P,\t\t\t\\\n   TARGET_RTX_COSTS,\t\t\t\t\\\n   TARGET_ADDRESS_COST,\t\t\t\t\\\n+  TARGET_ALLOCATE_INITIAL_VALUE,\t\t\\\n   TARGET_DWARF_REGISTER_SPAN,                   \\\n   TARGET_FIXED_CONDITION_CODE_REGS,\t\t\\\n   TARGET_CC_MODES_COMPATIBLE,\t\t\t\\"}, {"sha": "b3c6ee9d78a458f9e01e5e8fabf4e050e771b677", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48f503c9806fab41f3a9e484822b5b00dd31e0a/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=b48f503c9806fab41f3a9e484822b5b00dd31e0a", "patch": "@@ -446,6 +446,10 @@ struct gcc_target\n      invalid addresses.  */\n   int (* address_cost) (rtx x);\n \n+  /* Return where to allocate pseudo for a given hard register initial\n+     value.  */\n+  rtx (* allocate_initial_value) (rtx x);\n+\n   /* Given a register, this hook should return a parallel of registers\n      to represent where to find the register pieces.  Define this hook\n      if the register and its mode are represented in Dwarf in"}]}