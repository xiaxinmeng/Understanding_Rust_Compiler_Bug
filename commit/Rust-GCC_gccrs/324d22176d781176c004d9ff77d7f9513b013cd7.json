{"sha": "324d22176d781176c004d9ff77d7f9513b013cd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI0ZDIyMTc2ZDc4MTE3NmMwMDRkOWZmNzdkN2Y5NTEzYjAxM2NkNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-10-29T21:16:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-10-29T21:16:45Z"}, "message": "passes.c (init_optimization_passes): Exchange store_copy_prop with copy_prop.\n\n2007-10-29  Richard Guenther  <rguenther@suse.de>\n\n\t* passes.c (init_optimization_passes): Exchange store_copy_prop\n\twith copy_prop.\n\t* tree-pass.h (pass_store_copy_prop): Remove.\n\t* tree-ssa-copy.c (do_store_copy_prop): Remove.\n\t(stmt_may_generate-copy): Do not handle store_copy_prop.\n\t(get_copy_of_val): Likewise.\n\t(set_copy_of_val): Likewise.\n\t(copy_prop_visit_assignment): Likewise.\n\t(copy_prop_visit_stmt): Likewise.\n\t(copy_prop_visit_phi_node): Likewise.\n\t(init_copy_prop): Likewise.\n\t(execute_copy_prop): Likewise.\n\t(do_copy_prop): Remove.\n\t(gate_store_copy_prop): Likewise.\n\t(store_copy_prop): Likewise.\n\t(pass_store_copy_prop): Likewise.\n\t(pass_copy_prop): Call execute_copy_prop.\n\t* opts.c (decode_options): Do not set flag_tree_store_copy_prop.\n\t* common.opt (ftree-store-copy-prop): Mark obsolete.\n\t* doc/invoke.texi (ftree-store-copy-prop): Remove documentation.\n\n\t* gcc.dg/tree-ssa/ssa-copyprop-1.c: Scan optimized dump.\n\nFrom-SVN: r129734", "tree": {"sha": "20f80ed4094259dc8207437c0001a978bc05aa3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20f80ed4094259dc8207437c0001a978bc05aa3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/324d22176d781176c004d9ff77d7f9513b013cd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/324d22176d781176c004d9ff77d7f9513b013cd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/324d22176d781176c004d9ff77d7f9513b013cd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/324d22176d781176c004d9ff77d7f9513b013cd7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "40abbf1f1737b16b1ae6a8d8094e825f6a3b41f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40abbf1f1737b16b1ae6a8d8094e825f6a3b41f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40abbf1f1737b16b1ae6a8d8094e825f6a3b41f2"}], "stats": {"total": 202, "additions": 51, "deletions": 151}, "files": [{"sha": "f8dd7fcb22fe990ccda4acd3ea58a0c8910e1e0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=324d22176d781176c004d9ff77d7f9513b013cd7", "patch": "@@ -1,3 +1,26 @@\n+2007-10-29  Richard Guenther  <rguenther@suse.de>\n+\n+\t* passes.c (init_optimization_passes): Exchange store_copy_prop\n+\twith copy_prop.\n+\t* tree-pass.h (pass_store_copy_prop): Remove.\n+\t* tree-ssa-copy.c (do_store_copy_prop): Remove.\n+\t(stmt_may_generate-copy): Do not handle store_copy_prop.\n+\t(get_copy_of_val): Likewise.\n+\t(set_copy_of_val): Likewise.\n+\t(copy_prop_visit_assignment): Likewise.\n+\t(copy_prop_visit_stmt): Likewise.\n+\t(copy_prop_visit_phi_node): Likewise.\n+\t(init_copy_prop): Likewise.\n+\t(execute_copy_prop): Likewise.\n+\t(do_copy_prop): Remove.\n+\t(gate_store_copy_prop): Likewise.\n+\t(store_copy_prop): Likewise.\n+\t(pass_store_copy_prop): Likewise.\n+\t(pass_copy_prop): Call execute_copy_prop.\n+\t* opts.c (decode_options): Do not set flag_tree_store_copy_prop.\n+\t* common.opt (ftree-store-copy-prop): Mark obsolete.\n+\t* doc/invoke.texi (ftree-store-copy-prop): Remove documentation.\n+\n 2007-10-29  Ian Lance Taylor  <iant@google.com>\n \n \t* ifcvt.c (noce_can_store_speculate_p): New static function."}, {"sha": "aba400b28c48bc9ead8a868c2136f077fd128553", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=324d22176d781176c004d9ff77d7f9513b013cd7", "patch": "@@ -1054,8 +1054,8 @@ Common Report Var(flag_tree_copy_prop) Optimization\n Enable copy propagation on trees\n \n ftree-store-copy-prop\n-Common Report Var(flag_tree_store_copy_prop) Optimization\n-Enable copy propagation for stores and loads\n+Common\n+This switch is obsolete\n \n ftree-cselim\n Common Report Var(flag_tree_cselim) Init(2) Optimization"}, {"sha": "ce1693ac1b05dc3759f9604435db4da72b0f0591", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=324d22176d781176c004d9ff77d7f9513b013cd7", "patch": "@@ -364,7 +364,7 @@ Objective-C and Objective-C++ Dialects}.\n -ftree-dominator-opts -ftree-dse -ftree-copyrename -ftree-sink @gol\n -ftree-ch -ftree-sra -ftree-ter -ftree-fre -ftree-vectorize @gol\n -ftree-vect-loop-version -fvect-cost-model -ftree-salias -fipa-pta -fweb @gol\n--ftree-copy-prop -ftree-store-ccp -ftree-store-copy-prop -ftree-vrp @gol\n+-ftree-copy-prop -ftree-store-ccp -ftree-vrp @gol\n -funit-at-a-time -fwhole-program @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os}\n@@ -5677,13 +5677,6 @@ Perform copy propagation on trees.  This pass eliminates unnecessary\n copy operations.  This flag is enabled by default at @option{-O} and\n higher.\n \n-@item -ftree-store-copy-prop\n-@opindex ftree-store-copy-prop\n-Perform copy propagation of memory loads and stores.  This pass\n-eliminates unnecessary copy operations in memory references\n-(structures, global variables, arrays, etc).  This flag is enabled by\n-default at @option{-O2} and higher.\n-\n @item -ftree-salias\n @opindex ftree-salias\n Perform structural alias analysis on trees.  This flag"}, {"sha": "90c9139abe080701206a681ec1769d6053387db3", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=324d22176d781176c004d9ff77d7f9513b013cd7", "patch": "@@ -844,7 +844,6 @@ decode_options (unsigned int argc, const char **argv)\n       flag_reorder_blocks = 1;\n       flag_reorder_functions = 1;\n       flag_tree_store_ccp = 1;\n-      flag_tree_store_copy_prop = 1;\n       flag_tree_vrp = 1;\n \n       if (!optimize_size)"}, {"sha": "48f78b42be8d2b8748d8f1750eb5fb661e60c186", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=324d22176d781176c004d9ff77d7f9513b013cd7", "patch": "@@ -602,7 +602,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_phiopt);\n       NEXT_PASS (pass_object_sizes);\n       NEXT_PASS (pass_store_ccp);\n-      NEXT_PASS (pass_store_copy_prop);\n+      NEXT_PASS (pass_copy_prop);\n       NEXT_PASS (pass_fold_builtins);\n       NEXT_PASS (pass_cse_sincos);\n       NEXT_PASS (pass_split_crit_edges);"}, {"sha": "3b2704314529b68ac87c909a03c957bd905404b2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=324d22176d781176c004d9ff77d7f9513b013cd7", "patch": "@@ -1,3 +1,7 @@\n+2007-10-29  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ssa-copyprop-1.c: Scan optimized dump.\n+\n 2007-10-29  Razya Ladelsky  <razya@il.ibm.com>\n \n \tAutomatic parallelization reduction tests."}, {"sha": "41ad6ce6e349c3e2dfde49d41a1cdb01dd1e0e3c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-copyprop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-copyprop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-copyprop-1.c?ref=324d22176d781176c004d9ff77d7f9513b013cd7", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-store_copyprop-details\" } */\n+/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-optimized\" } */\n \n typedef struct { int i; int j; } A;\n int foo(A *a, int i)\n@@ -8,5 +8,5 @@ int foo(A *a, int i)\n   return a->i;\n }\n \n-/* { dg-final { scan-tree-dump \"return i\" \"store_copyprop\" } } */\n-/* { dg-final { cleanup-tree-dump \"store_copyprop\" } } */\n+/* { dg-final { scan-tree-dump \"return i\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "3eda29ec44d1741101fc3acc59e2806b8282bf9f", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=324d22176d781176c004d9ff77d7f9513b013cd7", "patch": "@@ -321,7 +321,6 @@ extern struct tree_opt_pass pass_linear_transform;\n extern struct tree_opt_pass pass_check_data_deps;\n extern struct tree_opt_pass pass_copy_prop;\n extern struct tree_opt_pass pass_store_ccp;\n-extern struct tree_opt_pass pass_store_copy_prop;\n extern struct tree_opt_pass pass_vrp;\n extern struct tree_opt_pass pass_create_structure_vars;\n extern struct tree_opt_pass pass_uncprop;"}, {"sha": "9f58087cfacba37da819cc5edb96c3fd6823474b", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 17, "deletions": 135, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d22176d781176c004d9ff77d7f9513b013cd7/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=324d22176d781176c004d9ff77d7f9513b013cd7", "patch": "@@ -384,9 +384,6 @@ static prop_value_t *copy_of;\n    chain has changed.  */\n static tree *cached_last_copy_of;\n \n-/* True if we are doing copy propagation on loads and stores.  */\n-static bool do_store_copy_prop;\n-\n \n /* Return true if this statement may generate a useful copy.  */\n \n@@ -411,19 +408,15 @@ stmt_may_generate_copy (tree stmt)\n   if (ann->has_volatile_ops)\n     return false;\n \n-  /* If we are not doing store copy-prop, statements with loads and/or\n-     stores will never generate a useful copy.  */\n-  if (!do_store_copy_prop\n-      && !ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n+  /* Statements with loads and/or stores will never generate a useful copy.  */\n+  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n     return false;\n \n   /* Otherwise, the only statements that generate useful copies are\n      assignments whose RHS is just an SSA name that doesn't flow\n      through abnormal edges.  */\n-  return (do_store_copy_prop\n-\t  && TREE_CODE (lhs) == SSA_NAME)\n-\t || (TREE_CODE (rhs) == SSA_NAME\n-\t     && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs));\n+  return (TREE_CODE (rhs) == SSA_NAME\n+\t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs));\n }\n \n \n@@ -440,7 +433,6 @@ get_copy_of_val (tree var)\n       /* If the variable will never generate a useful copy relation,\n \t make it its own copy.  */\n       val->value = var;\n-      val->mem_ref = NULL_TREE;\n     }\n \n   return val;\n@@ -493,7 +485,7 @@ get_last_copy_of (tree var)\n    and stores.  */\n \n static inline bool\n-set_copy_of_val (tree dest, tree first, tree mem_ref)\n+set_copy_of_val (tree dest, tree first)\n {\n   unsigned int dest_ver = SSA_NAME_VERSION (dest);\n   tree old_first, old_last, new_last;\n@@ -502,7 +494,6 @@ set_copy_of_val (tree dest, tree first, tree mem_ref)\n      changed, return true.  */\n   old_first = copy_of[dest_ver].value;\n   copy_of[dest_ver].value = first;\n-  copy_of[dest_ver].mem_ref = mem_ref;\n \n   if (old_first != first)\n     return true;\n@@ -604,41 +595,12 @@ copy_prop_visit_assignment (tree stmt, tree *result_p)\n \t This is different from what we do in copy_prop_visit_phi_node. \n \t In those cases, we are interested in the copy-of chains.  */\n       *result_p = lhs;\n-      if (set_copy_of_val (*result_p, rhs_val->value, rhs_val->mem_ref))\n-\treturn SSA_PROP_INTERESTING;\n-      else\n-\treturn SSA_PROP_NOT_INTERESTING;\n-    }\n-  else if (stmt_makes_single_store (stmt))\n-    {\n-      /* Otherwise, set the names in VDEF operands to be a copy\n-\t of RHS.  */\n-      ssa_op_iter i;\n-      tree vdef;\n-      bool changed;\n-\n-      /* This should only be executed when doing store copy-prop.  */\n-      gcc_assert (do_store_copy_prop);\n-\n-      /* Set the value of every VDEF to RHS_VAL.  */\n-      changed = false;\n-      FOR_EACH_SSA_TREE_OPERAND (vdef, stmt, i, SSA_OP_VIRTUAL_DEFS)\n-\tchanged |= set_copy_of_val (vdef, rhs_val->value, lhs);\n-      \n-      /* Note that for propagation purposes, we are only interested in\n-\t visiting statements that load the exact same memory reference\n-\t stored here.  Those statements will have the exact same list\n-\t of virtual uses, so it is enough to set the output of this\n-\t statement to be its first virtual definition.  */\n-      *result_p = first_vdef (stmt);\n-\n-      if (changed)\n+      if (set_copy_of_val (*result_p, rhs_val->value))\n \treturn SSA_PROP_INTERESTING;\n       else\n \treturn SSA_PROP_NOT_INTERESTING;\n     }\n \n-\n   return SSA_PROP_VARYING;\n }\n \n@@ -721,41 +683,12 @@ copy_prop_visit_stmt (tree stmt, edge *taken_edge_p, tree *result_p)\n \n   if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n       && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == SSA_NAME\n-      && (do_store_copy_prop\n-\t  || TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME))\n+      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME)\n     {\n       /* If the statement is a copy assignment, evaluate its RHS to\n \t see if the lattice value of its output has changed.  */\n       retval = copy_prop_visit_assignment (stmt, result_p);\n     }\n-  else if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-\t   && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME\n-\t   && do_store_copy_prop\n-\t   && stmt_makes_single_load (stmt))\n-    {\n-      /* If the statement is a copy assignment with a memory load\n-\t on the RHS, see if we know the value of this load and\n-\t update the lattice accordingly.  */\n-      prop_value_t *val = get_value_loaded_by (stmt, copy_of);\n-      if (val\n-\t  && val->mem_ref\n-\t  && is_gimple_reg (val->value)\n-\t  && operand_equal_p (val->mem_ref, GIMPLE_STMT_OPERAND (stmt, 1), 0))\n-        {\n-\t  bool changed;\n-\t  changed = set_copy_of_val (GIMPLE_STMT_OPERAND (stmt, 0),\n-\t\t\t\t     val->value, val->mem_ref);\n-\t  if (changed)\n-\t    {\n-\t      *result_p = GIMPLE_STMT_OPERAND (stmt, 0);\n-\t      retval = SSA_PROP_INTERESTING;\n-\t    }\n-\t  else\n-\t    retval = SSA_PROP_NOT_INTERESTING;\n-\t}\n-      else\n-        retval = SSA_PROP_VARYING;\n-    }\n   else if (TREE_CODE (stmt) == COND_EXPR)\n     {\n       /* See if we can determine which edge goes out of a conditional\n@@ -779,7 +712,7 @@ copy_prop_visit_stmt (tree stmt, edge *taken_edge_p, tree *result_p)\n \t statement again and mark all the definitions in the statement\n \t to be copies of nothing.  */\n       FOR_EACH_SSA_TREE_OPERAND (def, stmt, i, SSA_OP_ALL_DEFS)\n-\tset_copy_of_val (def, def, NULL_TREE);\n+\tset_copy_of_val (def, def);\n     }\n \n   return retval;\n@@ -859,7 +792,6 @@ copy_prop_visit_phi_node (tree phi)\n       if (phi_val.value == NULL_TREE)\n \t{\n \t  phi_val.value = arg;\n-\t  phi_val.mem_ref = arg_val->mem_ref;\n \t  continue;\n \t}\n \n@@ -868,18 +800,14 @@ copy_prop_visit_phi_node (tree phi)\n \t copy propagating stores and these two arguments came from\n \t different memory references, they cannot be considered\n \t copies.  */\n-      if (get_last_copy_of (phi_val.value) != get_last_copy_of (arg)\n-\t  || (do_store_copy_prop\n-\t      && phi_val.mem_ref\n-\t      && arg_val->mem_ref\n-\t      && simple_cst_equal (phi_val.mem_ref, arg_val->mem_ref) != 1))\n+      if (get_last_copy_of (phi_val.value) != get_last_copy_of (arg))\n \t{\n \t  phi_val.value = lhs;\n \t  break;\n \t}\n     }\n \n-  if (phi_val.value && set_copy_of_val (lhs, phi_val.value, phi_val.mem_ref))\n+  if (phi_val.value && set_copy_of_val (lhs, phi_val.value))\n     retval = (phi_val.value != lhs) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n   else\n     retval = SSA_PROP_NOT_INTERESTING;\n@@ -948,21 +876,21 @@ init_copy_prop (void)\n \t     the copy of anything.  */\n \t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n \t    if (DONT_SIMULATE_AGAIN (stmt))\n-\t      set_copy_of_val (def, def, NULL_TREE);\n+\t      set_copy_of_val (def, def);\n \t    else\n \t      cached_last_copy_of[SSA_NAME_VERSION (def)] = def;\n \t}\n \n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \t{\n \t  def = PHI_RESULT (phi);\n-\t  if (!do_store_copy_prop && !is_gimple_reg (def))\n+\t  if (!is_gimple_reg (def))\n \t    DONT_SIMULATE_AGAIN (phi) = true;\n \t  else\n \t    DONT_SIMULATE_AGAIN (phi) = false;\n \n \t  if (DONT_SIMULATE_AGAIN (phi))\n-\t    set_copy_of_val (def, def, NULL_TREE);\n+\t    set_copy_of_val (def, def);\n \t  else\n \t    cached_last_copy_of[SSA_NAME_VERSION (def)] = def;\n \t}\n@@ -1104,34 +1032,26 @@ fini_copy_prop (void)\n    Once the propagator stabilizes, we end up with the desired result\n    x_53 and x_54 are both copies of x_898.  */\n \n-static void\n-execute_copy_prop (bool store_copy_prop)\n+static unsigned int\n+execute_copy_prop (void)\n {\n-  do_store_copy_prop = store_copy_prop;\n   init_copy_prop ();\n   ssa_propagate (copy_prop_visit_stmt, copy_prop_visit_phi_node);\n   fini_copy_prop ();\n+  return 0;\n }\n \n-\n static bool\n gate_copy_prop (void)\n {\n   return flag_tree_copy_prop != 0;\n }\n \n-static unsigned int\n-do_copy_prop (void)\n-{\n-  execute_copy_prop (false);\n-  return 0;\n-}\n-\n struct tree_opt_pass pass_copy_prop =\n {\n   \"copyprop\",\t\t\t\t/* name */\n   gate_copy_prop,\t\t\t/* gate */\n-  do_copy_prop,\t\t\t\t/* execute */\n+  execute_copy_prop,\t\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n@@ -1148,41 +1068,3 @@ struct tree_opt_pass pass_copy_prop =\n   0\t\t\t\t\t/* letter */\n };\n \n-static bool\n-gate_store_copy_prop (void)\n-{\n-  /* STORE-COPY-PROP is enabled only with -ftree-store-copy-prop, but\n-     when -fno-tree-store-copy-prop is specified, we should run\n-     regular COPY-PROP. That's why the pass is enabled with either\n-     flag.  */\n-  return flag_tree_store_copy_prop != 0 || flag_tree_copy_prop != 0;\n-}\n-\n-static unsigned int\n-store_copy_prop (void)\n-{\n-  /* If STORE-COPY-PROP is not enabled, we just run regular COPY-PROP.  */\n-  execute_copy_prop (flag_tree_store_copy_prop != 0);\n-  return 0;\n-}\n-\n-struct tree_opt_pass pass_store_copy_prop =\n-{\n-  \"store_copyprop\",\t\t\t/* name */\n-  gate_store_copy_prop,\t\t\t/* gate */\n-  store_copy_prop,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_STORE_COPY_PROP,\t\t/* tv_id */\n-  PROP_ssa | PROP_alias | PROP_cfg,\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func\n-    | TODO_cleanup_cfg\n-    | TODO_ggc_collect\n-    | TODO_verify_ssa\n-    | TODO_update_ssa,\t\t\t/* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */\n-};"}]}