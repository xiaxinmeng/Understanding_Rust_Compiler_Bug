{"sha": "a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBmNzlmY2M0Mzc2MGM4YjdmNzJlY2NjOTY4NmM2ZTVjYjc5OTVkOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-09-18T07:57:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-09-18T07:57:00Z"}, "message": "re PR tree-optimization/66142 (Loop is not vectorized because not sufficient support for GOMP_SIMD_LANE)\n\n2015-09-18  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/66142\n\t* fold-const.c (operand_equal_p): When OEP_ADDRESS_OF\n\ttreat MEM[&x] and x the same.\n\t* tree-ssa-sccvn.h (vn_reference_fold_indirect): Remove.\n\t* tree-ssa-sccvn.c (vn_reference_fold_indirect): Return true\n\twhen we simplified sth.\n\t(vn_reference_maybe_forwprop_address): Likewise.\n\t(valueize_refs_1): When we simplified through\n\tvn_reference_fold_indirect or vn_reference_maybe_forwprop_address\n\tset valueized_anything to true.\n\t(vn_reference_lookup_3): Use stmt_kills_ref_p to see whether\n\tone ref kills the other instead of just a offset-based test.\n\t* tree-ssa-alias.c (stmt_kills_ref_p): Use OEP_ADDRESS_OF\n\tfor the operand_equal_p test to compare bases and also compare\n\tsizes.\n\nFrom-SVN: r227896", "tree": {"sha": "5b63093bcc6c103adf789191e978d64af6c25cd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b63093bcc6c103adf789191e978d64af6c25cd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9ace6a87332fe24076e18706d8d2c7c9b56dcce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ace6a87332fe24076e18706d8d2c7c9b56dcce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ace6a87332fe24076e18706d8d2c7c9b56dcce9"}], "stats": {"total": 96, "additions": 74, "deletions": 22}, "files": [{"sha": "3ee1a2d589c2cdb8966c6d46d51dfdc9bd22323f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9", "patch": "@@ -1,3 +1,21 @@\n+2015-09-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/66142\n+\t* fold-const.c (operand_equal_p): When OEP_ADDRESS_OF\n+\ttreat MEM[&x] and x the same.\n+\t* tree-ssa-sccvn.h (vn_reference_fold_indirect): Remove.\n+\t* tree-ssa-sccvn.c (vn_reference_fold_indirect): Return true\n+\twhen we simplified sth.\n+\t(vn_reference_maybe_forwprop_address): Likewise.\n+\t(valueize_refs_1): When we simplified through\n+\tvn_reference_fold_indirect or vn_reference_maybe_forwprop_address\n+\tset valueized_anything to true.\n+\t(vn_reference_lookup_3): Use stmt_kills_ref_p to see whether\n+\tone ref kills the other instead of just a offset-based test.\n+\t* tree-ssa-alias.c (stmt_kills_ref_p): Use OEP_ADDRESS_OF\n+\tfor the operand_equal_p test to compare bases and also compare\n+\tsizes.\n+\n 2015-09-17  Christian Bruel  <christian.bruel@st.com>\n \n \t* config/arm/arm.md (*call_value_symbol): Fix operand for interworking."}, {"sha": "ce2c4690d61db526d95ccad1c70598999ae66515", "filename": "gcc/fold-const.c", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9", "patch": "@@ -2752,10 +2752,33 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t\t\t\t   TREE_OPERAND (arg1, 0), flags);\n     }\n \n-  if (TREE_CODE (arg0) != TREE_CODE (arg1)\n+  if (TREE_CODE (arg0) != TREE_CODE (arg1))\n+    {\n       /* NOP_EXPR and CONVERT_EXPR are considered equal.  */\n-      && !(CONVERT_EXPR_P (arg0) && CONVERT_EXPR_P (arg1)))\n-    return 0;\n+      if (CONVERT_EXPR_P (arg0) && CONVERT_EXPR_P (arg1))\n+\t;\n+      else if (flags & OEP_ADDRESS_OF)\n+\t{\n+\t  /* If we are interested in comparing addresses ignore\n+\t     MEM_REF wrappings of the base that can appear just for\n+\t     TBAA reasons.  */\n+\t  if (TREE_CODE (arg0) == MEM_REF\n+\t      && DECL_P (arg1)\n+\t      && TREE_CODE (TREE_OPERAND (arg0, 0)) == ADDR_EXPR\n+\t      && TREE_OPERAND (TREE_OPERAND (arg0, 0), 0) == arg1\n+\t      && integer_zerop (TREE_OPERAND (arg0, 1)))\n+\t    return 1;\n+\t  else if (TREE_CODE (arg1) == MEM_REF\n+\t\t   && DECL_P (arg0)\n+\t\t   && TREE_CODE (TREE_OPERAND (arg1, 0)) == ADDR_EXPR\n+\t\t   && TREE_OPERAND (TREE_OPERAND (arg1, 0), 0) == arg0\n+\t\t   && integer_zerop (TREE_OPERAND (arg1, 1)))\n+\t    return 1;\n+\t  return 0;\n+\t}\n+      else\n+\treturn 0;\n+    }\n \n   /* This is needed for conversions and for COMPONENT_REF.\n      Might as well play it safe and always test this.  */"}, {"sha": "bc4b52583adb42bca913604c9b196c3c9eb116d1", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9", "patch": "@@ -2282,9 +2282,16 @@ stmt_kills_ref_p (gimple stmt, ao_ref *ref)\n \t      if (saved_lhs0)\n \t\tTREE_OPERAND (lhs, 0) = saved_lhs0;\n \t    }\n-\t  /* Finally check if lhs is equal or equal to the base candidate\n-\t     of the access.  */\n-\t  if (operand_equal_p (lhs, base, 0))\n+\t  /* Finally check if the lhs has the same address and size as the\n+\t     base candidate of the access.  */\n+\t  if (lhs == base\n+\t      || (((TYPE_SIZE (TREE_TYPE (lhs))\n+\t\t    == TYPE_SIZE (TREE_TYPE (base)))\n+\t\t   || (TYPE_SIZE (TREE_TYPE (lhs))\n+\t\t       && TYPE_SIZE (TREE_TYPE (base))\n+\t\t       && operand_equal_p (TYPE_SIZE (TREE_TYPE (lhs)),\n+\t\t\t\t\t   TYPE_SIZE (TREE_TYPE (base)), 0)))\n+\t\t  && operand_equal_p (lhs, base, OEP_ADDRESS_OF)))\n \t    return true;\n \t}\n "}, {"sha": "ef477e1e4efb1c2422ddb072c9246b83ba33e306", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9", "patch": "@@ -1184,7 +1184,7 @@ copy_reference_ops_from_call (gcall *call,\n \n /* Fold *& at position *I_P in a vn_reference_op_s vector *OPS.  Updates\n    *I_P to point to the last element of the replacement.  */\n-void\n+static bool\n vn_reference_fold_indirect (vec<vn_reference_op_s> *ops,\n \t\t\t    unsigned int *i_p)\n {\n@@ -1210,12 +1210,14 @@ vn_reference_fold_indirect (vec<vn_reference_op_s> *ops,\n \tmem_op->off = tree_to_shwi (mem_op->op0);\n       else\n \tmem_op->off = -1;\n+      return true;\n     }\n+  return false;\n }\n \n /* Fold *& at position *I_P in a vn_reference_op_s vector *OPS.  Updates\n    *I_P to point to the last element of the replacement.  */\n-static void\n+static bool\n vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n \t\t\t\t     unsigned int *i_p)\n {\n@@ -1228,12 +1230,12 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n \n   def_stmt = SSA_NAME_DEF_STMT (op->op0);\n   if (!is_gimple_assign (def_stmt))\n-    return;\n+    return false;\n \n   code = gimple_assign_rhs_code (def_stmt);\n   if (code != ADDR_EXPR\n       && code != POINTER_PLUS_EXPR)\n-    return;\n+    return false;\n \n   off = offset_int::from (mem_op->op0, SIGNED);\n \n@@ -1265,11 +1267,11 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n \t  ops->pop ();\n \t  ops->safe_splice (tem);\n \t  --*i_p;\n-\t  return;\n+\t  return true;\n \t}\n       if (!addr_base\n \t  || TREE_CODE (addr_base) != MEM_REF)\n-\treturn;\n+\treturn false;\n \n       off += addr_offset;\n       off += mem_ref_offset (addr_base);\n@@ -1282,7 +1284,7 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n       ptroff = gimple_assign_rhs2 (def_stmt);\n       if (TREE_CODE (ptr) != SSA_NAME\n \t  || TREE_CODE (ptroff) != INTEGER_CST)\n-\treturn;\n+\treturn false;\n \n       off += wi::to_offset (ptroff);\n       op->op0 = ptr;\n@@ -1303,6 +1305,7 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n     vn_reference_maybe_forwprop_address (ops, i_p);\n   else if (TREE_CODE (op->op0) == ADDR_EXPR)\n     vn_reference_fold_indirect (ops, i_p);\n+  return true;\n }\n \n /* Optimize the reference REF to a constant if possible or return\n@@ -1475,11 +1478,17 @@ valueize_refs_1 (vec<vn_reference_op_s> orig, bool *valueized_anything)\n \t  && vro->op0\n \t  && TREE_CODE (vro->op0) == ADDR_EXPR\n \t  && orig[i - 1].opcode == MEM_REF)\n-\tvn_reference_fold_indirect (&orig, &i);\n+\t{\n+\t  if (vn_reference_fold_indirect (&orig, &i))\n+\t    *valueized_anything = true;\n+\t}\n       else if (i > 0\n \t       && vro->opcode == SSA_NAME\n \t       && orig[i - 1].opcode == MEM_REF)\n-\tvn_reference_maybe_forwprop_address (&orig, &i);\n+\t{\n+\t  if (vn_reference_maybe_forwprop_address (&orig, &i))\n+\t    *valueized_anything = true;\n+\t}\n       /* If it transforms a non-constant ARRAY_REF into a constant\n \t one, adjust the constant offset.  */\n       else if (vro->opcode == ARRAY_REF\n@@ -1880,7 +1889,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t       || handled_component_p (gimple_assign_rhs1 (def_stmt))))\n     {\n       tree base2;\n-      HOST_WIDE_INT offset2, size2, maxsize2;\n+      HOST_WIDE_INT maxsize2;\n       int i, j;\n       auto_vec<vn_reference_op_s> rhs;\n       vn_reference_op_t vro;\n@@ -1891,8 +1900,6 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \n       /* See if the assignment kills REF.  */\n       base2 = ao_ref_base (&lhs_ref);\n-      offset2 = lhs_ref.offset;\n-      size2 = lhs_ref.size;\n       maxsize2 = lhs_ref.max_size;\n       if (maxsize2 == -1\n \t  || (base != base2\n@@ -1901,8 +1908,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t\t  || TREE_OPERAND (base, 0) != TREE_OPERAND (base2, 0)\n \t\t  || !tree_int_cst_equal (TREE_OPERAND (base, 1),\n \t\t\t\t\t  TREE_OPERAND (base2, 1))))\n-\t  || offset2 > offset\n-\t  || offset2 + size2 < offset + maxsize)\n+\t  || !stmt_kills_ref_p (def_stmt, ref))\n \treturn (void *)-1;\n \n       /* Find the common base of ref and the lhs.  lhs_ops already"}, {"sha": "704663d538ec46c84d72b7120f8aa9836c4e08a4", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=a0f79fcc43760c8b7f72eccc9686c6e5cb7995d9", "patch": "@@ -204,8 +204,6 @@ vn_nary_op_t vn_nary_op_insert (tree, tree);\n vn_nary_op_t vn_nary_op_insert_stmt (gimple, tree);\n vn_nary_op_t vn_nary_op_insert_pieces (unsigned int, enum tree_code,\n \t\t\t\t       tree, tree *, tree, unsigned int);\n-void vn_reference_fold_indirect (vec<vn_reference_op_s> *,\n-\t\t\t\t unsigned int *);\n bool ao_ref_init_from_vn_reference (ao_ref *, alias_set_type, tree,\n \t\t\t\t    vec<vn_reference_op_s> );\n tree vn_reference_lookup_pieces (tree, alias_set_type, tree,"}]}