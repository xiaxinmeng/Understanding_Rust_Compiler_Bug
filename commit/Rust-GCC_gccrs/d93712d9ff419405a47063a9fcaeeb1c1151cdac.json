{"sha": "d93712d9ff419405a47063a9fcaeeb1c1151cdac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkzNzEyZDlmZjQxOTQwNWE0NzA2M2E5ZmNhZWViMWMxMTUxY2RhYw==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2008-05-16T03:41:17Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-05-16T03:41:17Z"}, "message": "[multiple changes]\n\n2008-05-15  Steven G. Kargl  <kargls@comcast.net>\n\n\t* simplify.c (gfc_simplify_dble, gfc_simplify_float,\n\tsimplify_bound, gfc_simplify_nearest, gfc_simplify_real): Plug\n\tpossible memory leaks.\n\t(gfc_simplify_reshape): Plug possible memory leaks and dereferencing\n\tof NULL pointers.\n\n2008-05-15  Steven G. Kargl  <kargls@comcast.net>\n\n\tPR fortran/36239\n\t* simplify.c (gfc_simplify_int, gfc_simplify_intconv): Replaced hand\n\trolled integer conversion with gfc_int2int, gfc_real2int, and\n\tgfc_complex2int.\n\t(gfc_simplify_intconv): Renamed to simplify_intconv.\n\t\n2008-05-15  Steven G. Kargl,   <kargl@comcast.net>\n\t* gfortran.dg/and_or_xor.f90: New test\n\n\t* fortran/simplify.c (gfc_simplify_and, gfc_simplify_or,\n\tgfc_simplify_xor): Don't range check logical results.\n\nFrom-SVN: r135408", "tree": {"sha": "06f05b3524b7e9fbf23e3061314bfdb8188ba0df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06f05b3524b7e9fbf23e3061314bfdb8188ba0df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d93712d9ff419405a47063a9fcaeeb1c1151cdac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d93712d9ff419405a47063a9fcaeeb1c1151cdac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d93712d9ff419405a47063a9fcaeeb1c1151cdac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d93712d9ff419405a47063a9fcaeeb1c1151cdac/comments", "author": null, "committer": null, "parents": [{"sha": "b362cad04548e826027712558b71fb88884e7261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b362cad04548e826027712558b71fb88884e7261", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b362cad04548e826027712558b71fb88884e7261"}], "stats": {"total": 148, "additions": 88, "deletions": 60}, "files": [{"sha": "cea13bae56ea1c10c7dfd0e20bdcdd067dc87f7d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93712d9ff419405a47063a9fcaeeb1c1151cdac/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93712d9ff419405a47063a9fcaeeb1c1151cdac/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d93712d9ff419405a47063a9fcaeeb1c1151cdac", "patch": "@@ -1,3 +1,25 @@\n+2008-05-15  Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* simplify.c (gfc_simplify_dble, gfc_simplify_float,\n+\tsimplify_bound, gfc_simplify_nearest, gfc_simplify_real): Plug\n+\tpossible memory leaks.\n+\t(gfc_simplify_reshape): Plug possible memory leaks and dereferencing\n+\tof NULL pointers.\n+\n+2008-05-15  Steven G. Kargl  <kargls@comcast.net>\n+\n+\tPR fortran/36239\n+\t* simplify.c (gfc_simplify_int, gfc_simplify_intconv): Replaced hand\n+\trolled integer conversion with gfc_int2int, gfc_real2int, and\n+\tgfc_complex2int.\n+\t(gfc_simplify_intconv): Renamed to simplify_intconv.\n+\t\n+2008-05-15  Steven G. Kargl,   <kargl@comcast.net>\n+\t* gfortran.dg/and_or_xor.f90: New test\n+\n+\t* fortran/simplify.c (gfc_simplify_and, gfc_simplify_or,\n+\tgfc_simplify_xor): Don't range check logical results.\n+\n 2008-05-15  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* trans-expr.c (gfc_conv_concat_op): Take care of nondefault"}, {"sha": "35400e23fbda9ba2d8b7e280e9906dd068136683", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93712d9ff419405a47063a9fcaeeb1c1151cdac/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93712d9ff419405a47063a9fcaeeb1c1151cdac/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=d93712d9ff419405a47063a9fcaeeb1c1151cdac", "patch": "@@ -1000,13 +1000,16 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n-@item @var{J} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n+@item @var{I} @tab The type shall be either a scalar @code{INTEGER(*)}\n+type or a scalar @code{LOGICAL} type.\n+@item @var{J} @tab The type shall be the same as the type of @var{I}.\n @end multitable\n \n @item @emph{Return value}:\n-The return type is either @code{INTEGER(*)} or @code{LOGICAL} after\n-cross-promotion of the arguments. \n+The return type is either a scalar @code{INTEGER(*)} or a scalar\n+@code{LOGICAL}.  If the kind type parameters differ, then the\n+smaller kind type is implicitly converted to larger kind, and the \n+return has the larger kind.\n \n @item @emph{Example}:\n @smallexample\n@@ -8250,13 +8253,16 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n-@item @var{Y} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n+@item @var{X} @tab The type shall be either a scalar @code{INTEGER(*)}\n+type or a scalar @code{LOGICAL} type.\n+@item @var{Y} @tab The type shall be the same as the type of @var{X}.\n @end multitable\n \n @item @emph{Return value}:\n-The return type is either @code{INTEGER(*)} or @code{LOGICAL} \n-after cross-promotion of the arguments.\n+The return type is either a scalar @code{INTEGER(*)} or a scalar\n+@code{LOGICAL}.  If the kind type parameters differ, then the\n+smaller kind type is implicitly converted to larger kind, and the \n+return has the larger kind.\n \n @item @emph{Example}:\n @smallexample\n@@ -10990,13 +10996,16 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n-@item @var{Y} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n+@item @var{X} @tab The type shall be either  a scalar @code{INTEGER(*)}\n+type or a scalar @code{LOGICAL} type.\n+@item @var{Y} @tab The type shall be the same as the type of @var{I}.\n @end multitable\n \n @item @emph{Return value}:\n-The return type is either @code{INTEGER(*)} or @code{LOGICAL}\n-after cross-promotion of the arguments.\n+The return type is either a scalar @code{INTEGER(*)} or a scalar\n+@code{LOGICAL}.  If the kind type parameters differ, then the\n+smaller kind type is implicitly converted to larger kind, and the \n+return has the larger kind.\n \n @item @emph{Example}:\n @smallexample"}, {"sha": "4159374f06e64ffec6b68f1c9861378d2dcbd1e1", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93712d9ff419405a47063a9fcaeeb1c1151cdac/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93712d9ff419405a47063a9fcaeeb1c1151cdac/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=d93712d9ff419405a47063a9fcaeeb1c1151cdac", "patch": "@@ -505,14 +505,15 @@ gfc_simplify_and (gfc_expr *x, gfc_expr *y)\n     {\n       result = gfc_constant_result (BT_INTEGER, kind, &x->where);\n       mpz_and (result->value.integer, x->value.integer, y->value.integer);\n+      return range_check (result, \"AND\");\n     }\n   else /* BT_LOGICAL */\n     {\n       result = gfc_constant_result (BT_LOGICAL, kind, &x->where);\n       result->value.logical = x->value.logical && y->value.logical;\n+      return result;\n     }\n \n-  return range_check (result, \"AND\");\n }\n \n \n@@ -1123,7 +1124,10 @@ gfc_simplify_dble (gfc_expr *e)\n       ts.kind = gfc_default_double_kind;\n       result = gfc_copy_expr (e);\n       if (!gfc_convert_boz (result, &ts))\n-\treturn &gfc_bad_expr;\n+\t{\n+\t  gfc_free_expr (result);\n+\t  return &gfc_bad_expr;\n+\t}\n     }\n \n   return range_check (result, \"DBLE\");\n@@ -1346,7 +1350,10 @@ gfc_simplify_float (gfc_expr *a)\n \n       result = gfc_copy_expr (a);\n       if (!gfc_convert_boz (result, &ts))\n-\treturn &gfc_bad_expr;\n+\t{\n+\t  gfc_free_expr (result);\n+\t  return &gfc_bad_expr;\n+\t}\n     }\n   else\n     result = gfc_int2real (a, gfc_default_real_kind);\n@@ -1866,7 +1873,7 @@ gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b, gfc_expr *kind)\n gfc_expr *\n gfc_simplify_int (gfc_expr *e, gfc_expr *k)\n {\n-  gfc_expr *rpart, *rtrunc, *result;\n+  gfc_expr *result = NULL;\n   int kind;\n \n   kind = get_kind (BT_INTEGER, k, \"INT\", gfc_default_integer_kind);\n@@ -1876,33 +1883,22 @@ gfc_simplify_int (gfc_expr *e, gfc_expr *k)\n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  result = gfc_constant_result (BT_INTEGER, kind, &e->where);\n-\n   switch (e->ts.type)\n     {\n     case BT_INTEGER:\n-      mpz_set (result->value.integer, e->value.integer);\n+      result = gfc_int2int (e, kind);\n       break;\n \n     case BT_REAL:\n-      rtrunc = gfc_copy_expr (e);\n-      mpfr_trunc (rtrunc->value.real, e->value.real);\n-      gfc_mpfr_to_mpz (result->value.integer, rtrunc->value.real);\n-      gfc_free_expr (rtrunc);\n+      result = gfc_real2int (e, kind);\n       break;\n \n     case BT_COMPLEX:\n-      rpart = gfc_complex2real (e, kind);\n-      rtrunc = gfc_copy_expr (rpart);\n-      mpfr_trunc (rtrunc->value.real, rpart->value.real);\n-      gfc_mpfr_to_mpz (result->value.integer, rtrunc->value.real);\n-      gfc_free_expr (rpart);\n-      gfc_free_expr (rtrunc);\n+      result = gfc_complex2int (e, kind);\n       break;\n \n     default:\n       gfc_error (\"Argument of INT at %L is not a valid type\", &e->where);\n-      gfc_free_expr (result);\n       return &gfc_bad_expr;\n     }\n \n@@ -1911,40 +1907,29 @@ gfc_simplify_int (gfc_expr *e, gfc_expr *k)\n \n \n static gfc_expr *\n-gfc_simplify_intconv (gfc_expr *e, int kind, const char *name)\n+simplify_intconv (gfc_expr *e, int kind, const char *name)\n {\n-  gfc_expr *rpart, *rtrunc, *result;\n+  gfc_expr *result = NULL;\n \n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  result = gfc_constant_result (BT_INTEGER, kind, &e->where);\n-\n   switch (e->ts.type)\n     {\n     case BT_INTEGER:\n-      mpz_set (result->value.integer, e->value.integer);\n+      result = gfc_int2int (e, kind);\n       break;\n \n     case BT_REAL:\n-      rtrunc = gfc_copy_expr (e);\n-      mpfr_trunc (rtrunc->value.real, e->value.real);\n-      gfc_mpfr_to_mpz (result->value.integer, rtrunc->value.real);\n-      gfc_free_expr (rtrunc);\n+      result = gfc_real2int (e, kind);\n       break;\n \n     case BT_COMPLEX:\n-      rpart = gfc_complex2real (e, kind);\n-      rtrunc = gfc_copy_expr (rpart);\n-      mpfr_trunc (rtrunc->value.real, rpart->value.real);\n-      gfc_mpfr_to_mpz (result->value.integer, rtrunc->value.real);\n-      gfc_free_expr (rpart);\n-      gfc_free_expr (rtrunc);\n+      result = gfc_complex2int (e, kind);\n       break;\n \n     default:\n       gfc_error (\"Argument of %s at %L is not a valid type\", name, &e->where);\n-      gfc_free_expr (result);\n       return &gfc_bad_expr;\n     }\n \n@@ -1955,21 +1940,21 @@ gfc_simplify_intconv (gfc_expr *e, int kind, const char *name)\n gfc_expr *\n gfc_simplify_int2 (gfc_expr *e)\n {\n-  return gfc_simplify_intconv (e, 2, \"INT2\");\n+  return simplify_intconv (e, 2, \"INT2\");\n }\n \n \n gfc_expr *\n gfc_simplify_int8 (gfc_expr *e)\n {\n-  return gfc_simplify_intconv (e, 8, \"INT8\");\n+  return simplify_intconv (e, 8, \"INT8\");\n }\n \n \n gfc_expr *\n gfc_simplify_long (gfc_expr *e)\n {\n-  return gfc_simplify_intconv (e, 4, \"LONG\");\n+  return simplify_intconv (e, 4, \"LONG\");\n }\n \n \n@@ -2378,7 +2363,10 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n       k = get_kind (BT_INTEGER, kind, upper ? \"UBOUND\" : \"LBOUND\",\n \t\t    gfc_default_integer_kind); \n       if (k == -1)\n-\treturn &gfc_bad_expr;\n+\t{\n+\t  gfc_free_expr (e);\n+\t  return &gfc_bad_expr;\n+\t}\n       e->ts.kind = k;\n \n       /* The result is a rank 1 array; its size is the rank of the first\n@@ -2999,6 +2987,7 @@ gfc_simplify_nearest (gfc_expr *x, gfc_expr *s)\n   if (mpfr_nan_p (result->value.real) && gfc_option.flag_range_check)\n     {\n       gfc_error (\"Result of NEAREST is NaN at %L\", &result->where);\n+      gfc_free_expr (result);\n       return &gfc_bad_expr;\n     }\n \n@@ -3109,14 +3098,14 @@ gfc_simplify_or (gfc_expr *x, gfc_expr *y)\n     {\n       result = gfc_constant_result (BT_INTEGER, kind, &x->where);\n       mpz_ior (result->value.integer, x->value.integer, y->value.integer);\n+      return range_check (result, \"OR\");\n     }\n   else /* BT_LOGICAL */\n     {\n       result = gfc_constant_result (BT_LOGICAL, kind, &x->where);\n       result->value.logical = x->value.logical || y->value.logical;\n+      return result;\n     }\n-\n-  return range_check (result, \"OR\");\n }\n \n \n@@ -3239,8 +3228,12 @@ gfc_simplify_real (gfc_expr *e, gfc_expr *k)\n       ts.kind = kind;\n       result = gfc_copy_expr (e);\n       if (!gfc_convert_boz (result, &ts))\n-\treturn &gfc_bad_expr;\n+\t{\n+\t  gfc_free_expr (result);\n+\t  return &gfc_bad_expr;\n+\t}\n     }\n+\n   return range_check (result, \"REAL\");\n }\n \n@@ -3449,23 +3442,23 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,\n \t  goto bad_reshape;\n \t}\n \n-      gfc_free_expr (e);\n-\n       if (rank >= GFC_MAX_DIMENSIONS)\n \t{\n \t  gfc_error (\"Too many dimensions in shape specification for RESHAPE \"\n \t\t     \"at %L\", &e->where);\n-\n+\t  gfc_free_expr (e);\n \t  goto bad_reshape;\n \t}\n \n       if (shape[rank] < 0)\n \t{\n \t  gfc_error (\"Shape specification at %L cannot be negative\",\n \t\t     &e->where);\n+\t  gfc_free_expr (e);\n \t  goto bad_reshape;\n \t}\n \n+      gfc_free_expr (e);\n       rank++;\n     }\n \n@@ -3505,12 +3498,11 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,\n \t      goto bad_reshape;\n \t    }\n \n-\t  gfc_free_expr (e);\n-\n \t  if (order[i] < 1 || order[i] > rank)\n \t    {\n \t      gfc_error (\"ORDER parameter of RESHAPE at %L is out of range\",\n \t\t\t &e->where);\n+\t      gfc_free_expr (e);\n \t      goto bad_reshape;\n \t    }\n \n@@ -3520,9 +3512,12 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,\n \t    {\n \t      gfc_error (\"Invalid permutation in ORDER parameter at %L\",\n \t\t\t &e->where);\n+\t      gfc_free_expr (e);\n \t      goto bad_reshape;\n \t    }\n \n+\t  gfc_free_expr (e);\n+\n \t  x[order[i]] = 1;\n \t}\n     }\n@@ -3562,7 +3557,7 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,\n \t}\n \n       if (mpz_cmp_ui (index, INT_MAX) > 0)\n-\tgfc_internal_error (\"Reshaped array too large at %L\", &e->where);\n+\tgfc_internal_error (\"Reshaped array too large at %C\");\n \n       j = mpz_get_ui (index);\n \n@@ -3694,6 +3689,7 @@ gfc_simplify_scale (gfc_expr *x, gfc_expr *i)\n       || mpz_cmp_si (i->value.integer, -exp_range - 2) < 0)\n     {\n       gfc_error (\"Result of SCALE overflows its kind at %L\", &result->where);\n+      gfc_free_expr (result);\n       return &gfc_bad_expr;\n     }\n \n@@ -4612,15 +4608,16 @@ gfc_simplify_xor (gfc_expr *x, gfc_expr *y)\n     {\n       result = gfc_constant_result (BT_INTEGER, kind, &x->where);\n       mpz_xor (result->value.integer, x->value.integer, y->value.integer);\n+      return range_check (result, \"XOR\");\n     }\n   else /* BT_LOGICAL */\n     {\n       result = gfc_constant_result (BT_LOGICAL, kind, &x->where);\n       result->value.logical = (x->value.logical && !y->value.logical)\n \t\t\t      || (!x->value.logical && y->value.logical);\n+      return result;\n     }\n \n-  return range_check (result, \"XOR\");\n }\n \n "}]}