{"sha": "9ef064430c72f88aec17b95501c9e1ce63070ccc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVmMDY0NDMwYzcyZjg4YWVjMTdiOTU1MDFjOWUxY2U2MzA3MGNjYw==", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@cygnus.com", "date": "1999-01-14T08:55:47Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "1999-01-14T08:55:47Z"}, "message": "i960.c (i960_function_prologue): New code (optimal solution) for saving global registers in local registers.\n\n1999-01-13  Vladimir N. Makarov  <vmakarov@cygnus.com>\n\t* config/i960/i960.c (i960_function_prologue): New code (optimal\n\tsolution) for saving global registers in local registers.\n\t(form_reg_groups, reg_group_compare, split_reg_group): New\n\tfunctions used by the code.\n\t(reg_group): New structure definition for the new code.\n\nFrom-SVN: r24661", "tree": {"sha": "af4dbd172e71acf9e39c231a9f0b080f67652e7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af4dbd172e71acf9e39c231a9f0b080f67652e7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ef064430c72f88aec17b95501c9e1ce63070ccc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ef064430c72f88aec17b95501c9e1ce63070ccc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ef064430c72f88aec17b95501c9e1ce63070ccc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ef064430c72f88aec17b95501c9e1ce63070ccc/comments", "author": null, "committer": null, "parents": [{"sha": "df0e5eeb257350953a9ffd1a660b108c0323f22c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df0e5eeb257350953a9ffd1a660b108c0323f22c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df0e5eeb257350953a9ffd1a660b108c0323f22c"}], "stats": {"total": 187, "additions": 137, "deletions": 50}, "files": [{"sha": "562a15fed893f4906bdc1cc304abb3cf4ff923d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef064430c72f88aec17b95501c9e1ce63070ccc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef064430c72f88aec17b95501c9e1ce63070ccc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ef064430c72f88aec17b95501c9e1ce63070ccc", "patch": "@@ -1,3 +1,11 @@\n+1999-01-13  Vladimir N. Makarov  <vmakarov@cygnus.com>\n+\n+\t* config/i960/i960.c (i960_function_prologue): New code (optimal\n+\tsolution) for saving global registers in local registers.\n+\t(form_reg_groups, reg_group_compare, split_reg_group): New\n+\tfunctions used by the code.\n+\t(reg_group): New structure definition for the new code.\n+\t\n Wed Jan 13 20:12:37 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* integrate.c (expand_inline_function): Recognize (mem (addressof))"}, {"sha": "3d62c3cc611b5c049d8f89e250175881f4b66f75", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 129, "deletions": 50, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef064430c72f88aec17b95501c9e1ce63070ccc/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef064430c72f88aec17b95501c9e1ce63070ccc/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=9ef064430c72f88aec17b95501c9e1ce63070ccc", "patch": "@@ -1184,6 +1184,95 @@ compute_frame_size (size)\n   return actual_fsize;\n }\n \n+/* Here register group is range of registers which can be moved by\n+   one i960 instruction. */\n+\n+struct reg_group\n+{\n+  char start_reg;\n+  char length;\n+};\n+\n+/* The following functions forms the biggest as possible register\n+   groups with registers in STATE.  REGS contain states of the\n+   registers in range [start, finish_reg).  The function returns the\n+   number of groups formed. */\n+static int\n+i960_form_reg_groups (start_reg, finish_reg, regs, state, reg_groups)\n+     int start_reg;\n+     int finish_reg;\n+     int *regs;\n+     int state;\n+     struct reg_group *reg_groups;\n+{\n+  int i;\n+  int nw = 0;\n+\n+  for (i = start_reg; i < finish_reg; )\n+    {\n+      if (regs [i] != state)\n+\t{\n+\t  i++;\n+\t  continue;\n+\t}\n+      else if (i % 2 != 0 || regs [i + 1] != state)\n+\treg_groups [nw].length = 1;\n+      else if (i % 4 != 0 || regs [i + 2] != state)\n+\treg_groups [nw].length = 2;\n+      else if (regs [i + 3] != state)\n+\treg_groups [nw].length = 3;\n+      else\n+\treg_groups [nw].length = 4;\n+      reg_groups [nw].start_reg = i;\n+      i += reg_groups [nw].length;\n+      nw++;\n+    }\n+  return nw;\n+}\n+\n+/* We sort register winodws in descending order by length. */\n+static int\n+i960_reg_group_compare (group1, group2)\n+     void *group1;\n+     void *group2;\n+{\n+  struct reg_group *w1 = group1;\n+  struct reg_group *w2 = group2;\n+\n+  if (w1->length > w2->length)\n+    return -1;\n+  else if (w1->length < w2->length)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Split the first register group in REG_GROUPS on subgroups one of\n+   which will contain SUBGROUP_LENGTH registers.  The function\n+   returns new number of winodws. */\n+static int\n+i960_split_reg_group (reg_groups, nw, subgroup_length)\n+     struct reg_group *reg_groups;\n+     int nw;\n+     int subgroup_length;\n+{\n+  if (subgroup_length < reg_groups->length - subgroup_length)\n+    /* This guarantees correct alignments of the two subgroups for\n+       i960 (see spliting for the group length 2, 3, 4).  More\n+       generalized algorithm would require splitting the group more\n+       two subgroups. */\n+    subgroup_length = reg_groups->length - subgroup_length;\n+  /* More generalized algorithm would require to try merging\n+     subgroups here.  But in case i960 it always results in failure\n+     because of register group alignment. */\n+  reg_groups[nw].length = reg_groups->length - subgroup_length;\n+  reg_groups[nw].start_reg = reg_groups->start_reg + subgroup_length;\n+  nw++;\n+  reg_groups->length = subgroup_length;\n+  qsort (reg_groups, nw, sizeof (struct reg_group), i960_reg_group_compare);\n+  return nw;\n+}\n+\n /* Output code for the function prologue.  */\n \n void\n@@ -1195,10 +1284,17 @@ i960_function_prologue (file, size)\n   int n_iregs = 0;\n   int rsize = 0;\n   int actual_fsize, offset;\n+  int gnw, lnw;\n+  struct reg_group *g, *l;\n   char tmpstr[1000];\n   /* -1 if reg must be saved on proc entry, 0 if available, 1 if saved\n      somewhere.  */\n   int regs[FIRST_PSEUDO_REGISTER];\n+  /* All global registers (which must be saved) divided by groups. */\n+  struct reg_group global_reg_groups [16];\n+  /* All local registers (which are available) divided by groups. */\n+  struct reg_group local_reg_groups [16];\n+\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (regs_ever_live[i]\n@@ -1226,62 +1322,43 @@ i960_function_prologue (file, size)\n \tregs[i] = -1;\n     }\n \n-  /* First look for local registers to save globals in.  */\n-  for (i = 0; i < 16; i++)\n+  gnw = i960_form_reg_groups (0, 16, regs, -1, global_reg_groups);\n+  lnw = i960_form_reg_groups (19, 32, regs, 0, local_reg_groups);\n+  qsort (global_reg_groups, gnw, sizeof (struct reg_group),\n+\t i960_reg_group_compare);\n+  qsort (local_reg_groups, lnw, sizeof (struct reg_group),\n+\t i960_reg_group_compare);\n+  for (g = global_reg_groups, l = local_reg_groups; lnw != 0 && gnw != 0;)\n     {\n-      if (regs[i] == 0)\n-\tcontinue;\n-\n-      /* Start at r4, not r3.  */\n-      for (j = 20; j < 32; j++)\n+      if (g->length == l->length)\n \t{\n-\t  if (regs[j] != 0)\n-\t    continue;\n-\n-\t  regs[i] = 1;\n-\t  regs[j] = -1;\n-\t  regs_ever_live[j] = 1;\n-\t  nr = 1;\n-\t  if (i <= 14 && i % 2 == 0 && j <= 30 && j % 2 == 0\n-\t      && regs[i+1] != 0 && regs[j+1] == 0)\n-\t    {\n-\t      nr = 2;\n-\t      regs[i+1] = 1;\n-\t      regs[j+1] = -1;\n-\t      regs_ever_live[j+1] = 1;\n-\t    }\n-\t  if (nr == 2 && i <= 12 && i % 4 == 0 && j <= 28 && j % 4 == 0\n-\t      && regs[i+2] != 0 && regs[j+2] == 0)\n-\t    {\n-\t      nr = 3;\n-\t      regs[i+2] = 1;\n-\t      regs[j+2] = -1;\n-\t      regs_ever_live[j+2] = 1;\n-\t    }\n-\t  if (nr == 3 && regs[i+3] != 0 && regs[j+3] == 0)\n-\t    {\n-\t      nr = 4;\n-\t      regs[i+3] = 1;\n-\t      regs[j+3] = -1;\n-\t      regs_ever_live[j+3] = 1;\n-\t    }\n-\n \t  fprintf (file, \"\\tmov%s\t%s,%s\\n\",\n-\t\t   ((nr == 4) ? \"q\" :\n-\t\t    (nr == 3) ? \"t\" :\n-\t\t    (nr == 2) ? \"l\" : \"\"),\n-\t\t   reg_names[i], reg_names[j]);\n+\t\t   ((g->length == 4) ? \"q\" :\n+\t\t    (g->length == 3) ? \"t\" :\n+\t\t    (g->length == 2) ? \"l\" : \"\"),\n+\t\t   reg_names[g->start_reg], reg_names[l->start_reg]);\n \t  sprintf (tmpstr, \"\\tmov%s\t%s,%s\\n\",\n-\t\t   ((nr == 4) ? \"q\" :\n-\t\t    (nr == 3) ? \"t\" :\n-\t\t    (nr == 2) ? \"l\" : \"\"),\n-\t\t   reg_names[j], reg_names[i]);\n+\t\t   ((g->length == 4) ? \"q\" :\n+\t\t    (g->length == 3) ? \"t\" :\n+\t\t    (g->length == 2) ? \"l\" : \"\"),\n+\t\t   reg_names[l->start_reg], reg_names[g->start_reg]);\n \t  strcat (epilogue_string, tmpstr);\n-\n-\t  n_iregs -= nr;\n-\t  i += nr-1;\n-\t  break;\n+\t  n_iregs -= g->length;\n+\t  for (i = 0; i < g->length; i++)\n+\t    {\n+\t      regs [i + g->start_reg] = 1;\n+\t      regs [i + l->start_reg] = -1;\n+\t      regs_ever_live [i + l->start_reg] = 1;\n+\t    }\n+\t  g++;\n+\t  l++;\n+\t  gnw--;\n+\t  lnw--;\n \t}\n+      else if (g->length > l->length)\n+\tgnw = i960_split_reg_group (g, gnw, l->length);\n+      else\n+\tlnw = i960_split_reg_group (l, lnw, g->length);\n     }\n \n   /* N_iregs is now the number of global registers that haven't been saved\n@@ -1314,6 +1391,8 @@ i960_function_prologue (file, size)\n      into account, but store them before the argument block area.  */\n   offset = 64 + actual_fsize - compute_frame_size (0) - rsize;\n   /* Save registers on stack if needed.  */\n+  /* ??? Is it worth to use the same algorithm as one for saving\n+     global registers in local registers? */\n   for (i = 0, j = n_iregs; j > 0 && i < 16; i++)\n     {\n       if (regs[i] != -1)"}]}