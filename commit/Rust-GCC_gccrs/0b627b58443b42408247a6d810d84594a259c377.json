{"sha": "0b627b58443b42408247a6d810d84594a259c377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI2MjdiNTg0NDNiNDI0MDgyNDdhNmQ4MTBkODQ1OTRhMjU5YzM3Nw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-01-08T11:20:33Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-01-08T11:20:33Z"}, "message": "re PR fortran/83611 ([PDT] Assignment of parameterized types causes double free error in runtime)\n\n2018-01-08  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/83611\n\t* decl.c (gfc_get_pdt_instance): If parameterized arrays have\n\tan initializer, convert the kind parameters and add to the\n\tcomponent if the instance.\n\t* trans-array.c (structure_alloc_comps): Add 'is_pdt_type' and\n\tuse it with case COPY_ALLOC_COMP. Call 'duplicate_allocatable'\n\tfor parameterized arrays. Clean up typos in comments. Convert\n\tparameterized array initializers and copy into the array.\n\t* trans-expr.c (gfc_trans_scalar_assign): Do a deep copy for\n\tparameterized types.\n\t*trans-stmt.c (trans_associate_var): Deallocate associate vars\n\tas necessary, when they are PDT function results for example.\n\n\tPR fortran/83731\n\t* trans-array.c (structure_alloc_comps): Only compare len parms\n\twhen they are declared explicitly.\n\n2018-01-08  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/83611\n\t* gfortran.dg/pdt_15.f03 : Bump count of 'n.data = 0B' to 8.\n\t* gfortran.dg/pdt_26.f03 : Bump count of '_malloc' to 9.\n\t* gfortran.dg/pdt_27.f03 : New test.\n\n\tPR fortran/83731\n\t* gfortran.dg/pdt_28.f03 : New test.\n\nFrom-SVN: r256335", "tree": {"sha": "0a0943697205f58503baa1da74a60f0afcde7e67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a0943697205f58503baa1da74a60f0afcde7e67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b627b58443b42408247a6d810d84594a259c377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b627b58443b42408247a6d810d84594a259c377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b627b58443b42408247a6d810d84594a259c377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b627b58443b42408247a6d810d84594a259c377/comments", "author": null, "committer": null, "parents": [{"sha": "efcc2e303fe5f0daff889c66dff59cfefe3859a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efcc2e303fe5f0daff889c66dff59cfefe3859a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efcc2e303fe5f0daff889c66dff59cfefe3859a1"}], "stats": {"total": 177, "additions": 163, "deletions": 14}, "files": [{"sha": "d150f67bcfe1d6f961cbca1b79da38aa6f5c3747", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0b627b58443b42408247a6d810d84594a259c377", "patch": "@@ -1,3 +1,22 @@\n+2018-01-08  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/83611\n+\t* decl.c (gfc_get_pdt_instance): If parameterized arrays have\n+\tan initializer, convert the kind parameters and add to the\n+\tcomponent if the instance.\n+\t* trans-array.c (structure_alloc_comps): Add 'is_pdt_type' and\n+\tuse it with case COPY_ALLOC_COMP. Call 'duplicate_allocatable'\n+\tfor parameterized arrays. Clean up typos in comments. Convert\n+\tparameterized array initializers and copy into the array.\n+\t* trans-expr.c (gfc_trans_scalar_assign): Do a deep copy for\n+\tparameterized types.\n+\t*trans-stmt.c (trans_associate_var): Deallocate associate vars\n+\tas necessary, when they are PDT function results for example.\n+\n+\tPR fortran/83731\n+\t* trans-array.c (structure_alloc_comps): Only compare len parms\n+\twhen they are declared explicitly.\n+\n 2018-01-06  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/50892"}, {"sha": "cb235343962964585a74abd94027f7cf35fbc8ce", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=0b627b58443b42408247a6d810d84594a259c377", "patch": "@@ -3562,6 +3562,12 @@ gfc_get_pdt_instance (gfc_actual_arglist *param_list, gfc_symbol **sym,\n \t      c2->as->upper[i] = e;\n \t    }\n \t  c2->attr.pdt_array = pdt_array ? 1 : c2->attr.pdt_string;\n+\t  if (c1->initializer)\n+\t    {\n+\t      c2->initializer = gfc_copy_expr (c1->initializer);\n+\t      gfc_insert_kind_parameter_exprs (c2->initializer);\n+\t      gfc_simplify_expr (c2->initializer, 1);\n+\t    }\n \t}\n \n       /* Recurse into this function for PDT components.  */"}, {"sha": "474a7d1a84eeb4d9aa3244da6611fef451c2879d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0b627b58443b42408247a6d810d84594a259c377", "patch": "@@ -8450,6 +8450,9 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       bool same_type = (c->ts.type == BT_DERIVED && der_type == c->ts.u.derived)\n \t|| (c->ts.type == BT_CLASS && der_type == CLASS_DATA (c)->ts.u.derived);\n \n+      bool is_pdt_type = c->ts.type == BT_DERIVED\n+\t\t\t && c->ts.u.derived->attr.pdt_type;\n+\n       cdecl = c->backend_decl;\n       ctype = TREE_TYPE (cdecl);\n \n@@ -8909,8 +8912,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t     components that are really allocated, the deep copy code has to\n \t     be generated first and then added to the if-block in\n \t     gfc_duplicate_allocatable ().  */\n-\t  if (cmp_has_alloc_comps && !c->attr.proc_pointer\n-\t      && !same_type)\n+\t  if (cmp_has_alloc_comps && !c->attr.proc_pointer && !same_type)\n \t    {\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = fold_convert (TREE_TYPE (dcmp), comp);\n@@ -8944,9 +8946,17 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t\t   false, false, size, NULL_TREE);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n-\t  else if (c->attr.allocatable && !c->attr.proc_pointer && !same_type\n-\t\t   && (!(cmp_has_alloc_comps && c->as) || c->attr.codimension\n-\t\t       || caf_in_coarray (caf_mode)))\n+\t  else if (c->attr.pdt_array)\n+\t    {\n+\t      tmp = duplicate_allocatable (dcmp, comp, ctype,\n+\t\t\t\t\t   c->as ? c->as->rank : 0,\n+\t\t\t\t\t   false, false, NULL_TREE, NULL_TREE);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t    }\n+\t  else if ((c->attr.allocatable)\n+\t\t    && !c->attr.proc_pointer && !same_type\n+\t\t    && (!(cmp_has_alloc_comps && c->as) || c->attr.codimension\n+\t\t\t|| caf_in_coarray (caf_mode)))\n \t    {\n \t      rank = c->as ? c->as->rank : 0;\n \t      if (c->attr.codimension)\n@@ -8969,7 +8979,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  else\n-\t    if (cmp_has_alloc_comps)\n+\t    if (cmp_has_alloc_comps || is_pdt_type)\n \t      gfc_add_expr_to_block (&fnblock, add_when_allocated);\n \n \t  break;\n@@ -9022,7 +9032,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t}\n \t      gfc_free_expr (e);\n \n-\t      /* Scalar parameterizied strings can be allocated now.  */\n+\t      /* Scalar parameterized strings can be allocated now.  */\n \t      if (!c->as)\n \t\t{\n \t\t  tmp = fold_convert (gfc_array_index_type, strlen);\n@@ -9033,7 +9043,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t}\n \t    }\n \n-\t  /* Allocate paramterized arrays of parameterized derived types.  */\n+\t  /* Allocate parameterized arrays of parameterized derived types.  */\n \t  if (!(c->attr.pdt_array && c->as && c->as->type == AS_EXPLICIT)\n \t      && !((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n \t\t   && (c->ts.u.derived && c->ts.u.derived->attr.pdt_type)))\n@@ -9111,6 +9121,23 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      gfc_conv_descriptor_data_set (&fnblock, comp, tmp);\n \t      tmp = gfc_conv_descriptor_dtype (comp);\n \t      gfc_add_modify (&fnblock, tmp, gfc_get_dtype (ctype));\n+\n+\t      if (c->initializer && c->initializer->rank)\n+\t\t{\n+\t\t  gfc_init_se (&tse, NULL);\n+\t\t  e = gfc_copy_expr (c->initializer);\n+\t\t  gfc_insert_parameter_exprs (e, pdt_param_list);\n+\t\t  gfc_conv_expr_descriptor (&tse, e);\n+\t\t  gfc_add_block_to_block (&fnblock, &tse.pre);\n+\t\t  gfc_free_expr (e);\n+\t\t  tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n+\t\t  tmp = build_call_expr_loc (input_location, tmp, 3,\n+\t\t\t\t     gfc_conv_descriptor_data_get (comp),\n+\t\t\t\t     gfc_conv_descriptor_data_get (tse.expr),\n+\t\t\t\t     fold_convert (size_type_node, size));\n+\t\t  gfc_add_expr_to_block (&fnblock, tmp);\n+\t\t  gfc_add_block_to_block (&fnblock, &tse.post);\n+\t\t}\n \t    }\n \n \t  /* Recurse in to PDT components.  */\n@@ -9212,7 +9239,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t      gfc_init_se (&tse, NULL);\n \t      for (; param; param = param->next)\n-\t\tif (!strcmp (c->name, param->name))\n+\t\tif (!strcmp (c->name, param->name)\n+\t\t    && param->spec_type == SPEC_EXPLICIT)\n \t\t  c_expr = param->expr;\n \n \t      if (c_expr)"}, {"sha": "add0d6991532f0daaa4987d1726b26e8ae5604a7", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0b627b58443b42408247a6d810d84594a259c377", "patch": "@@ -8826,7 +8826,9 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       gfc_trans_string_copy (&block, llen, lse->expr, ts.kind, rlen,\n \t\t\t     rse->expr, ts.kind);\n     }\n-  else if (gfc_bt_struct (ts.type) && ts.u.derived->attr.alloc_comp)\n+  else if (gfc_bt_struct (ts.type)\n+\t   && (ts.u.derived->attr.alloc_comp\n+\t\t|| (deep_copy && ts.u.derived->attr.pdt_type)))\n     {\n       tree tmp_var = NULL_TREE;\n       cond = NULL_TREE;"}, {"sha": "ff6e5914319303432536d1fec855c3692f5c59ad", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=0b627b58443b42408247a6d810d84594a259c377", "patch": "@@ -1634,6 +1634,16 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t  gfc_conv_descriptor_span_set (&se.pre, desc, tmp);\n \t}\n \n+      if (e->expr_type == EXPR_FUNCTION\n+\t  && sym->ts.type == BT_DERIVED\n+\t  && sym->ts.u.derived\n+\t  && sym->ts.u.derived->attr.pdt_type)\n+\t{\n+\t  tmp = gfc_deallocate_pdt_comp (sym->ts.u.derived, se.expr,\n+\t\t\t\t\t sym->as->rank);\n+\t  gfc_add_expr_to_block (&se.post, tmp);\n+\t}\n+\n       /* Done, register stuff as init / cleanup code.  */\n       gfc_add_init_cleanup (block, gfc_finish_block (&se.pre),\n \t\t\t    gfc_finish_block (&se.post));\n@@ -1810,10 +1820,31 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n   else\n     {\n       gfc_expr *lhs;\n+      tree res;\n \n       lhs = gfc_lval_expr_from_sym (sym);\n-      tmp = gfc_trans_assignment (lhs, e, false, true);\n-      gfc_add_init_cleanup (block, tmp, NULL_TREE);\n+      res = gfc_trans_assignment (lhs, e, false, true);\n+\n+      tmp = sym->backend_decl;\n+      if (e->expr_type == EXPR_FUNCTION\n+\t  && sym->ts.type == BT_DERIVED\n+\t  && sym->ts.u.derived\n+\t  && sym->ts.u.derived->attr.pdt_type)\n+\t{\n+\t  tmp = gfc_deallocate_pdt_comp (sym->ts.u.derived, tmp,\n+\t\t\t\t\t 0);\n+\t}\n+      else if (e->expr_type == EXPR_FUNCTION\n+\t       && sym->ts.type == BT_CLASS\n+\t       && CLASS_DATA (sym)->ts.u.derived\n+\t       && CLASS_DATA (sym)->ts.u.derived->attr.pdt_type)\n+\t{\n+\t  tmp = gfc_class_data_get (tmp);\n+\t  tmp = gfc_deallocate_pdt_comp (CLASS_DATA (sym)->ts.u.derived,\n+\t\t\t\t\t tmp, 0);\n+\t}\n+\n+      gfc_add_init_cleanup (block, res, tmp);\n     }\n \n   /* Set the stringlength, when needed.  */"}, {"sha": "4ff705196bd4e66b20b4a51c5f4a02edd4df9e96", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b627b58443b42408247a6d810d84594a259c377", "patch": "@@ -1,3 +1,13 @@\n+2018-01-08  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/83611\n+\t* gfortran.dg/pdt_15.f03 : Bump count of 'n.data = 0B' to 8.\n+\t* gfortran.dg/pdt_26.f03 : Bump count of '_malloc' to 9.\n+\t* gfortran.dg/pdt_27.f03 : New test.\n+\n+\tPR fortran/83731\n+\t* gfortran.dg/pdt_28.f03 : New test.\n+\n 2018-01-08  Tom de Vries  <tom@codesourcery.com>\n \n \t* c-c++-common/builtins.c: Require effective target alloca."}, {"sha": "f2f0b67ec7aad965c8afca740b2736030bfecafe", "filename": "gcc/testsuite/gfortran.dg/pdt_15.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_15.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_15.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_15.f03?ref=0b627b58443b42408247a6d810d84594a259c377", "patch": "@@ -102,5 +102,5 @@ subroutine foo\n   end subroutine\n end program ch2701\n ! { dg-final { scan-tree-dump-times \"Pdtlink_8._deallocate \" 5 \"original\" } }\n-! { dg-final { scan-tree-dump-times \".n.data = 0B\" 7 \"original\" } }\n+! { dg-final { scan-tree-dump-times \".n.data = 0B\" 8 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"__builtin_free\" 14 \"original\" } }"}, {"sha": "01ed64094a1306cb151e2c9f8abcdb523e02653f", "filename": "gcc/testsuite/gfortran.dg/pdt_26.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_26.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_26.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_26.f03?ref=0b627b58443b42408247a6d810d84594a259c377", "patch": "@@ -43,4 +43,4 @@ program test_pdt\n   if (any (c(1)%foo .ne. [13,15,17])) call abort\n end program test_pdt\n ! { dg-final { scan-tree-dump-times \"__builtin_free\" 8 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"__builtin_malloc\" 7 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_malloc\" 9 \"original\" } }"}, {"sha": "89eb63d53e3635c33f8f0a3edce7929420f2dc8e", "filename": "gcc/testsuite/gfortran.dg/pdt_27.f03", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_27.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_27.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_27.f03?ref=0b627b58443b42408247a6d810d84594a259c377", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR83611, in which the assignment caused a\n+! double free error and the initialization of 'foo' was not done.\n+!\n+module pdt_m\n+  implicit none\n+  type :: vec(k)\n+     integer, len :: k=3\n+     integer :: foo(k)=[1,2,3]\n+  end type vec\n+end module pdt_m\n+\n+program test_pdt\n+  use pdt_m\n+  implicit none\n+  type(vec) :: u,v\n+  if (any (u%foo .ne. [1,2,3])) call abort\n+  u%foo = [7,8,9]\n+  v = u\n+  if (any (v%foo .ne. [7,8,9])) call abort\n+end program test_pdt"}, {"sha": "da4c9d68dbd8eec70ad018057a7065504e4f92d5", "filename": "gcc/testsuite/gfortran.dg/pdt_28.f03", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_28.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b627b58443b42408247a6d810d84594a259c377/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_28.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_28.f03?ref=0b627b58443b42408247a6d810d84594a259c377", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+! ( dg-options \"-fbounds-check\" }\n+!\n+! Test the fix for PR83731, where the following failed on the check for the\n+! value of the parameter 'k'.\n+!\n+! Contributed by Berke Durak  <berke.durak@gmail.com>\n+!\n+module pdt_m\n+  implicit none\n+  type :: vec(k)\n+     integer, len :: k=10\n+     integer :: foo(k)\n+  end type vec\n+contains\n+  function total(a)\n+    type(vec(k=*)), intent(in) :: a ! Would compare with the default initializer.\n+    integer :: total\n+    \n+    total=sum(a%foo)\n+  end function total\n+end module pdt_m\n+\n+program test_pdt\n+  use pdt_m\n+  implicit none\n+  type(vec(k=123)) :: u\n+\n+  u%foo=1\n+  if (total(u) .ne. u%k) call abort\n+end program test_pdt"}]}