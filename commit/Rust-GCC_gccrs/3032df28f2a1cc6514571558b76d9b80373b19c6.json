{"sha": "3032df28f2a1cc6514571558b76d9b80373b19c6", "node_id": "C_kwDOANBUbNoAKDMwMzJkZjI4ZjJhMWNjNjUxNDU3MTU1OGI3NmQ5YjgwMzczYjE5YzY", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2022-03-29T09:24:49Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2022-03-29T16:37:15Z"}, "message": "arm: correctly handle zero-sized bit-fields in AAPCS [PR102024]\n\nOn arm the AAPCS states that an HFA is determined by the 'shape' of\nthe object after layout has been completed, so anything that adds no\nmembers and does not cause the layout to be modified should be ignored\nfor the purposes of determining which registers are used for parameter\npassing.\n\nA zero-sized bit-field falls into this category.  This was not handled\ncorrectly for C structs and in G++-11 only handled correctly because\nsuch fields were eliminated early by the front end.\n\ngcc/ChangeLog:\n\n\tPR target/102024\n\t* config/arm/arm.cc (aapcs_vfp_sub_candidate): Handle zero-sized\n\tbit-fields.  Detect cases where a warning may be needed.\n\t(aapcs_vfp_is_call_or_return_candidate): Emit a note if\n\ta zero-sized bit-field has caused parameter passing to change.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/102024\n\t* gcc.target/arm/aapcs/vfp26.c: New test.", "tree": {"sha": "8390eaa4c63e6aeb5509f665570fd38adbbc66ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8390eaa4c63e6aeb5509f665570fd38adbbc66ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3032df28f2a1cc6514571558b76d9b80373b19c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3032df28f2a1cc6514571558b76d9b80373b19c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3032df28f2a1cc6514571558b76d9b80373b19c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3032df28f2a1cc6514571558b76d9b80373b19c6/comments", "author": null, "committer": null, "parents": [{"sha": "1dca4ca1bf2f1b05537a1052e373d8b0ff11e53c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dca4ca1bf2f1b05537a1052e373d8b0ff11e53c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dca4ca1bf2f1b05537a1052e373d8b0ff11e53c"}], "stats": {"total": 66, "additions": 63, "deletions": 3}, "files": [{"sha": "14e2fdfeafa16aa6fb20ff064347778b8e5a3cbf", "filename": "gcc/config/arm/arm.cc", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3032df28f2a1cc6514571558b76d9b80373b19c6/gcc%2Fconfig%2Farm%2Farm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3032df28f2a1cc6514571558b76d9b80373b19c6/gcc%2Fconfig%2Farm%2Farm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.cc?ref=3032df28f2a1cc6514571558b76d9b80373b19c6", "patch": "@@ -6283,6 +6283,7 @@ aapcs_vfp_cum_init (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,\n       a HFA or HVA.  */\n const unsigned int WARN_PSABI_EMPTY_CXX17_BASE = 1U << 0;\n const unsigned int WARN_PSABI_NO_UNIQUE_ADDRESS = 1U << 1;\n+const unsigned int WARN_PSABI_ZERO_WIDTH_BITFIELD = 1U << 2;\n \n /* Walk down the type tree of TYPE counting consecutive base elements.\n    If *MODEP is VOIDmode, then set it to the first valid floating point\n@@ -6435,6 +6436,28 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep,\n \t\t    continue;\n \t\t  }\n \t      }\n+\t    /* A zero-width bitfield may affect layout in some\n+\t       circumstances, but adds no members.  The determination\n+\t       of whether or not a type is an HFA is performed after\n+\t       layout is complete, so if the type still looks like an\n+\t       HFA afterwards, it is still classed as one.  This is\n+\t       potentially an ABI break for the hard-float ABI.  */\n+\t    else if (DECL_BIT_FIELD (field)\n+\t\t     && integer_zerop (DECL_SIZE (field)))\n+\t      {\n+\t\t/* Prior to GCC-12 these fields were striped early,\n+\t\t   hiding them from the back-end entirely and\n+\t\t   resulting in the correct behaviour for argument\n+\t\t   passing.  Simulate that old behaviour without\n+\t\t   generating a warning.  */\n+\t\tif (DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD (field))\n+\t\t  continue;\n+\t\tif (warn_psabi_flags)\n+\t\t  {\n+\t\t    *warn_psabi_flags |= WARN_PSABI_ZERO_WIDTH_BITFIELD;\n+\t\t    continue;\n+\t\t  }\n+\t      }\n \n \t    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep,\n \t\t\t\t\t\t warn_psabi_flags);\n@@ -6547,8 +6570,10 @@ aapcs_vfp_is_call_or_return_candidate (enum arm_pcs pcs_variant,\n \t      && ((alt = aapcs_vfp_sub_candidate (type, &new_mode, NULL))\n \t\t  != ag_count))\n \t    {\n-\t      const char *url\n+\t      const char *url10\n \t\t= CHANGES_ROOT_URL \"gcc-10/changes.html#empty_base\";\n+\t      const char *url12\n+\t\t= CHANGES_ROOT_URL \"gcc-12/changes.html#zero_width_bitfields\";\n \t      gcc_assert (alt == -1);\n \t      last_reported_type_uid = uid;\n \t      /* Use TYPE_MAIN_VARIANT to strip any redundant const\n@@ -6557,12 +6582,16 @@ aapcs_vfp_is_call_or_return_candidate (enum arm_pcs pcs_variant,\n \t\tinform (input_location, \"parameter passing for argument of \"\n \t\t\t\"type %qT with %<[[no_unique_address]]%> members \"\n \t\t\t\"changed %{in GCC 10.1%}\",\n-\t\t\tTYPE_MAIN_VARIANT (type), url);\n+\t\t\tTYPE_MAIN_VARIANT (type), url10);\n \t      else if (warn_psabi_flags & WARN_PSABI_EMPTY_CXX17_BASE)\n \t\tinform (input_location, \"parameter passing for argument of \"\n \t\t\t\"type %qT when C++17 is enabled changed to match \"\n \t\t\t\"C++14 %{in GCC 10.1%}\",\n-\t\t\tTYPE_MAIN_VARIANT (type), url);\n+\t\t\tTYPE_MAIN_VARIANT (type), url10);\n+\t      else if (warn_psabi_flags & WARN_PSABI_ZERO_WIDTH_BITFIELD)\n+\t\tinform (input_location, \"parameter passing for argument of \"\n+\t\t\t\"type %qT changed %{in GCC 12.1%}\",\n+\t\t\tTYPE_MAIN_VARIANT (type), url12);\n \t    }\n \t  *count = ag_count;\n \t}"}, {"sha": "9b1e8aa39d662a4f62fca9b439679f4fde60b24d", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp26.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3032df28f2a1cc6514571558b76d9b80373b19c6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3032df28f2a1cc6514571558b76d9b80373b19c6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp26.c?ref=3032df28f2a1cc6514571558b76d9b80373b19c6", "patch": "@@ -0,0 +1,31 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm_eabi } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp26.c\"\n+\n+/* Anonymous bitfields do not add members; if they do not change the layout\n+   then the end result may still be an HFA.  */\n+struct z\n+{\n+  float a;\n+  int :0;\n+  float b;\n+};\n+\n+struct z a = { 5.0f, 6.0f };\n+struct z b = { 9.0f, 10.0f };\n+\n+#define MYFUNCTYPE struct z\n+\n+#include \"abitest.h\"\n+#else\n+  ARG(int, 7, R0)\n+  ARG(struct z, a, S0)\n+  LAST_ARG(struct z, b, S2)\n+#endif"}]}