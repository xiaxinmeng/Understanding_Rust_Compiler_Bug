{"sha": "34554d1a8ff28d42caf020a4e68982458fc9ad93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ1NTRkMWE4ZmYyOGQ0MmNhZjAyMGE0ZTY4OTgyNDU4ZmM5YWQ5Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-08-28T15:07:45Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-08-28T15:07:45Z"}, "message": "tree-ssa-threadedge.c (thread_around_empty_block): Remove checks for the number of predecessors and successors allowed.\n\n        * tree-ssa-threadedge.c (thread_around_empty_block): Remove\n        checks for the number of predecessors and successors allowed.\n        * tree-ssa-threadupdate.c (mark_threaded_blocks): Ignore requests\n        which require copying a joiner block if there is a request which\n        is a subpath that requires no joiner block copying.\n\nFrom-SVN: r202054", "tree": {"sha": "089b6bbb6feac49068fc164ef9c0ffc916a99955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/089b6bbb6feac49068fc164ef9c0ffc916a99955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34554d1a8ff28d42caf020a4e68982458fc9ad93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34554d1a8ff28d42caf020a4e68982458fc9ad93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34554d1a8ff28d42caf020a4e68982458fc9ad93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34554d1a8ff28d42caf020a4e68982458fc9ad93/comments", "author": null, "committer": null, "parents": [{"sha": "184799e76349bb0cc0f3193194d32d1edd405cf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/184799e76349bb0cc0f3193194d32d1edd405cf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/184799e76349bb0cc0f3193194d32d1edd405cf9"}], "stats": {"total": 65, "additions": 52, "deletions": 13}, "files": [{"sha": "3d87dbbb8a0fcf2b5601c19cccb787cea21b2838", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34554d1a8ff28d42caf020a4e68982458fc9ad93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34554d1a8ff28d42caf020a4e68982458fc9ad93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34554d1a8ff28d42caf020a4e68982458fc9ad93", "patch": "@@ -1,3 +1,11 @@\n+2013-08-28  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadedge.c (thread_around_empty_block): Remove\n+\tchecks for the number of predecessors and successors allowed.\n+\t* tree-ssa-threadupdate.c (mark_threaded_blocks): Ignore requests\n+\twhich require copying a joiner block if there is a request which\n+\tis a subpath that requires no joiner block copying.\n+\n 2013-08-28  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-streamer-out.c (DFS_write_tree_body): Drop"}, {"sha": "fc33647cfc8b3f011679fa3b3a1d1d2f4c5bef22", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34554d1a8ff28d42caf020a4e68982458fc9ad93/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34554d1a8ff28d42caf020a4e68982458fc9ad93/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=34554d1a8ff28d42caf020a4e68982458fc9ad93", "patch": "@@ -761,14 +761,6 @@ thread_around_empty_block (edge taken_edge,\n   gimple stmt;\n   tree cond;\n \n-  /* This block must have a single predecessor (E->dest).  */\n-  if (!single_pred_p (bb))\n-    return NULL;\n-\n-  /* This block must have more than one successor.  */\n-  if (single_succ_p (bb))\n-    return NULL;\n-\n   /* This block can have no PHI nodes.  This is overly conservative.  */\n   if (!gsi_end_p (gsi_start_phis (bb)))\n     return NULL;"}, {"sha": "8a872a3f9f79fab8ccb0702ad4292c375cf2e0d1", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34554d1a8ff28d42caf020a4e68982458fc9ad93/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34554d1a8ff28d42caf020a4e68982458fc9ad93/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=34554d1a8ff28d42caf020a4e68982458fc9ad93", "patch": "@@ -1146,17 +1146,56 @@ mark_threaded_blocks (bitmap threaded_blocks)\n   edge e;\n   edge_iterator ei;\n \n+  /* It is possible to have jump threads in which one is a subpath\n+     of the other.  ie, (A, B), (B, C), (C, D) where B is a joiner\n+     block and (B, C), (C, D) where no joiner block exists.\n+\n+     When this occurs ignore the jump thread request with the joiner\n+     block.  It's totally subsumed by the simpler jump thread request.\n+\n+     This results in less block copying, simpler CFGs.  More improtantly,\n+     when we duplicate the joiner block, B, in this case we will create\n+     a new threading opportunity that we wouldn't be able to optimize\n+     until the next jump threading iteration. \n+\n+     So first convert the jump thread requests which do not require a\n+     joiner block.  */\n   for (i = 0; i < threaded_edges.length (); i += 3)\n     {\n       edge e = threaded_edges[i];\n-      edge *x = XNEWVEC (edge, 2);\n \n-      e->aux = x;\n-      THREAD_TARGET (e) = threaded_edges[i + 1];\n-      THREAD_TARGET2 (e) = threaded_edges[i + 2];\n-      bitmap_set_bit (tmp, e->dest->index);\n+      if (threaded_edges[i + 2] == NULL)\n+\t{\n+\t  edge *x = XNEWVEC (edge, 2);\n+\n+\t  e->aux = x;\n+\t  THREAD_TARGET (e) = threaded_edges[i + 1];\n+\t  THREAD_TARGET2 (e) = NULL;\n+\t  bitmap_set_bit (tmp, e->dest->index);\n+\t}\n     }\n \n+\n+  /* Now iterate again, converting cases where we threaded through\n+     a joiner block, but ignoring those where we have already\n+     threaded through the joiner block.  */\n+  for (i = 0; i < threaded_edges.length (); i += 3)\n+    {\n+      edge e = threaded_edges[i];\n+\n+      if (threaded_edges[i + 2] != NULL\n+\t  && threaded_edges[i + 1]->aux == NULL)\n+\t{\n+\t  edge *x = XNEWVEC (edge, 2);\n+\n+\t  e->aux = x;\n+\t  THREAD_TARGET (e) = threaded_edges[i + 1];\n+\t  THREAD_TARGET2 (e) = threaded_edges[i + 2];\n+\t  bitmap_set_bit (tmp, e->dest->index);\n+\t}\n+    }\n+\n+\n   /* If optimizing for size, only thread through block if we don't have\n      to duplicate it or it's an otherwise empty redirection block.  */\n   if (optimize_function_for_size_p (cfun))"}]}