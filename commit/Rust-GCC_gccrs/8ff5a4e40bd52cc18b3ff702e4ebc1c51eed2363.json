{"sha": "8ff5a4e40bd52cc18b3ff702e4ebc1c51eed2363", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZmNWE0ZTQwYmQ1MmNjMThiM2ZmNzAyZTRlYmMxYzUxZWVkMjM2Mw==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2013-10-15T15:41:37Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2013-10-15T15:41:37Z"}, "message": "[ARM] [Neon types 10/10] Remove neon-schedgen.ml\n\ngcc/\n\t* config/arm/neon-schedgen.ml: Remove.\n\t* config/arm/cortex-a9-neon.md: Remove comment regarding\n\tneon-schedgen.ml.\n\nFrom-SVN: r203621", "tree": {"sha": "b792effff0c120da8e5edf64458ca9c2a365410f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b792effff0c120da8e5edf64458ca9c2a365410f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ff5a4e40bd52cc18b3ff702e4ebc1c51eed2363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ff5a4e40bd52cc18b3ff702e4ebc1c51eed2363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ff5a4e40bd52cc18b3ff702e4ebc1c51eed2363", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ff5a4e40bd52cc18b3ff702e4ebc1c51eed2363/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52b69ad240f016b6a06a0b814a631ea782a63baa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52b69ad240f016b6a06a0b814a631ea782a63baa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52b69ad240f016b6a06a0b814a631ea782a63baa"}], "stats": {"total": 551, "additions": 6, "deletions": 545}, "files": [{"sha": "4142dd26efd85cff1e00310643ee447699d55241", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ff5a4e40bd52cc18b3ff702e4ebc1c51eed2363/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ff5a4e40bd52cc18b3ff702e4ebc1c51eed2363/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ff5a4e40bd52cc18b3ff702e4ebc1c51eed2363", "patch": "@@ -1,3 +1,9 @@\n+2013-10-15  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/arm/neon-schedgen.ml: Remove.\n+\t* config/arm/cortex-a9-neon.md: Remove comment regarding\n+\tneon-schedgen.ml.\n+\n 2013-10-15  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/arm/types: Remove old neon types."}, {"sha": "cd6b7a4fd36d40c50c78d5cdb7ca484652770cb4", "filename": "gcc/config/arm/cortex-a9-neon.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ff5a4e40bd52cc18b3ff702e4ebc1c51eed2363/gcc%2Fconfig%2Farm%2Fcortex-a9-neon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ff5a4e40bd52cc18b3ff702e4ebc1c51eed2363/gcc%2Fconfig%2Farm%2Fcortex-a9-neon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcortex-a9-neon.md?ref=8ff5a4e40bd52cc18b3ff702e4ebc1c51eed2363", "patch": "@@ -330,8 +330,6 @@\n        (eq_attr \"cortex_a9_neon_type\" \"neon_mrrc\"))\n   \"ca9_issue_vfp_neon + cortex_a9_neon_mcr\")\n \n-;; The remainder of this file is auto-generated by neon-schedgen.\n-\n ;; Instructions using this reservation read their source operands at N2, and\n ;; produce a result at N3.\n (define_insn_reservation \"cortex_a9_neon_int_1\" 3"}, {"sha": "b3699563d48881b7ab988d9eea389444f3a3d1d6", "filename": "gcc/config/arm/neon-schedgen.ml", "status": "removed", "additions": 0, "deletions": 543, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b69ad240f016b6a06a0b814a631ea782a63baa/gcc%2Fconfig%2Farm%2Fneon-schedgen.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b69ad240f016b6a06a0b814a631ea782a63baa/gcc%2Fconfig%2Farm%2Fneon-schedgen.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon-schedgen.ml?ref=52b69ad240f016b6a06a0b814a631ea782a63baa", "patch": "@@ -1,543 +0,0 @@\n-(* Emission of the core of the Cortex-A8 NEON scheduling description.\n-   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n-   Contributed by CodeSourcery.\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.\n-*)\n-\n-(* This scheduling description generator works as follows.\n-   - Each group of instructions has source and destination requirements\n-     specified and a list of cores supported. This is then filtered\n-     and per core scheduler descriptions are generated out.\n-     The reservations generated are prefixed by the name of the\n-     core and the check is performed on the basis of what the tuning\n-     string is. Running this will generate Neon scheduler descriptions\n-     for all cores supported.\n-\n-     The source requirements may be specified using\n-     Source (the stage at which all source operands not otherwise\n-     described are read), Source_m (the stage at which Rm operands are\n-     read), Source_n (likewise for Rn) and Source_d (likewise for Rd).\n-   - For each group of instructions the earliest stage where a source\n-     operand may be required is calculated.\n-   - Each group of instructions is selected in turn as a producer.\n-     The latencies between this group and every other group are then\n-     calculated, yielding up to four values for each combination:\n-\t1. Producer -> consumer Rn latency\n-\t2. Producer -> consumer Rm latency\n-\t3. Producer -> consumer Rd (as a source) latency\n-\t4. Producer -> consumer worst-case latency.\n-     Value 4 is calculated from the destination availability requirements\n-     of the consumer and the earliest source availability requirements\n-     of the producer.\n-   - The largest Value 4 calculated for the current producer is the\n-     worse-case latency, L, for that instruction group.  This value is written\n-     out in a define_insn_reservation for the producer group.\n-   - For each producer and consumer pair, the latencies calculated above\n-     are collated.  The average (of up to four values) is calculated and\n-     if this average is different from the worst-case latency, an\n-     unguarded define_bypass construction is issued for that pair.\n-     (For each pair only one define_bypass construction will be emitted,\n-     and at present we do not emit specific guards.)\n-*)\n-\n-let find_with_result fn lst =\n-  let rec scan = function\n-      [] -> raise Not_found\n-    | l::ls -> \n-      match fn l with\n-          Some result -> result\n-       | _ -> scan ls in\n-    scan lst\n-\n-let n1 = 1 and n2 = 2 and n3 = 3 and n4 = 4 and n5 = 5 and n6 = 6\n-    and n7 = 7 and n8 = 8 and n9 = 9\n-\n-type availability = Source of int\n-                  | Source_n of int\n-                  | Source_m of int\n-                  | Source_d of int\n-                  | Dest of int\n-\t\t  | Dest_n_after of int * int\n-\n-type guard = Guard_none | Guard_only_m | Guard_only_n | Guard_only_d\n-\n-(* Reservation behaviors.  All but the last row here correspond to one\n-   pipeline each.  Each constructor will correspond to one\n-   define_reservation.  *)\n-type reservation =\n-  Mul | Mul_2cycle | Mul_4cycle\n-| Shift | Shift_2cycle\n-| ALU | ALU_2cycle\n-| Fmul | Fmul_2cycle\n-| Fadd | Fadd_2cycle\n-(* | VFP *)\n-| Permute of int\n-| Ls of int\n-| Fmul_then_fadd | Fmul_then_fadd_2\n-\n-type core = CortexA8 | CortexA9\n-let allCores = [CortexA8; CortexA9]\n-let coreStr = function\n-    CortexA8 -> \"cortex_a8\"\n-  | CortexA9 -> \"cortex_a9\"\n-\n-let tuneStr = function\n-    CortexA8 -> \"cortexa8\"\n-   | CortexA9 -> \"cortexa9\"\n-\n-\n-(* This table must be kept as short as possible by conflating\n-   entries with the same availability behavior.\n-\n-   First components: instruction group names\n-   Second components: availability requirements, in the order in which\n-   they should appear in the comments in the .md file.\n-   Third components: reservation info\n-   Fourth components: List of supported cores.\n-*)\n-let availability_table = [\n-  (* NEON integer ALU instructions.  *)\n-  (* vbit vbif vbsl vorr vbic vnot vcls vclz vcnt vadd vand vorr\n-     veor vbic vorn ddd qqq *)\n-  \"neon_int_1\", [Source n2; Dest n3], ALU, allCores;\n-  (* vadd vsub qqd vsub ddd qqq *)\n-  \"neon_int_2\", [Source_m n1; Source_n n2; Dest n3], ALU, allCores;\n-  (* vsum vneg dd qq vadd vsub qdd *)\n-  \"neon_int_3\", [Source n1; Dest n3], ALU, allCores;\n-  (* vabs vceqz vcgez vcbtz vclez vcltz vadh vradh vsbh vrsbh dqq *)\n-  (* vhadd vrhadd vqadd vtst ddd qqq *)\n-  \"neon_int_4\", [Source n2; Dest n4], ALU, allCores;\n-  (* vabd qdd vhsub vqsub vabd vceq vcge vcgt vmax vmin vfmx vfmn ddd ddd *)\n-  \"neon_int_5\", [Source_m n1; Source_n n2; Dest n4], ALU, allCores;\n-  (* vqneg vqabs dd qq *)\n-  \"neon_vqneg_vqabs\", [Source n1; Dest n4], ALU, allCores;\n-  (* vmov vmvn *)\n-  \"neon_vmov\", [Dest n3], ALU, allCores;\n-  (* vaba *)\n-  \"neon_vaba\", [Source_n n2; Source_m n1; Source_d n3; Dest n6], ALU, allCores;\n-  \"neon_vaba_qqq\",\n-    [Source_n n2; Source_m n1; Source_d n3; Dest_n_after (1, n6)], \n-   ALU_2cycle, allCores;\n-  (* vsma *)\n-  \"neon_vsma\", [Source_m n1; Source_d n3; Dest n6], ALU, allCores;\n-\n-  (* NEON integer multiply instructions.  *)\n-  (* vmul, vqdmlh, vqrdmlh *)\n-  (* vmul, vqdmul, qdd 16/8 long 32/16 long *)\n-  \"neon_mul_ddd_8_16_qdd_16_8_long_32_16_long\", [Source n2; Dest n6], \n-   Mul, allCores;\n-  \"neon_mul_qqq_8_16_32_ddd_32\", [Source n2; Dest_n_after (1, n6)], \n-   Mul_2cycle, allCores;\n-  (* vmul, vqdmul again *)\n-  \"neon_mul_qdd_64_32_long_qqd_16_ddd_32_scalar_64_32_long_scalar\",\n-    [Source_n n2; Source_m n1; Dest_n_after (1, n6)], Mul_2cycle, allCores;\n-  (* vmla, vmls *)\n-  \"neon_mla_ddd_8_16_qdd_16_8_long_32_16_long\",\n-    [Source_n n2; Source_m n2; Source_d n3; Dest n6], Mul, allCores;\n-  \"neon_mla_qqq_8_16\",\n-    [Source_n n2; Source_m n2; Source_d n3; Dest_n_after (1, n6)], \n-   Mul_2cycle, allCores;\n-  \"neon_mla_ddd_32_qqd_16_ddd_32_scalar_qdd_64_32_long_scalar_qdd_64_32_long\",\n-    [Source_n n2; Source_m n1; Source_d n3; Dest_n_after (1, n6)], \n-   Mul_2cycle, allCores;\n-  \"neon_mla_qqq_32_qqd_32_scalar\",\n-    [Source_n n2; Source_m n1; Source_d n3; Dest_n_after (3, n6)], \n-   Mul_4cycle, allCores;\n-  (* vmul, vqdmulh, vqrdmulh *)\n-  (* vmul, vqdmul *)\n-  \"neon_mul_ddd_16_scalar_32_16_long_scalar\",\n-    [Source_n n2; Source_m n1; Dest n6], Mul, allCores;\n-  \"neon_mul_qqd_32_scalar\",\n-    [Source_n n2; Source_m n1; Dest_n_after (3, n6)], Mul_4cycle, allCores;\n-  (* vmla, vmls *)\n-  (* vmla, vmla, vqdmla, vqdmls *)\n-  \"neon_mla_ddd_16_scalar_qdd_32_16_long_scalar\",\n-    [Source_n n2; Source_m n1; Source_d n3; Dest n6], Mul, allCores;\n-\n-  (* NEON integer shift instructions.  *)\n-  (* vshr/vshl immediate, vshr_narrow, vshl_vmvh, vsli_vsri_ddd *)\n-  \"neon_shift_1\", [Source n1; Dest n3], Shift, allCores;\n-  (* vqshl, vrshr immediate; vqshr, vqmov, vrshr, vqrshr narrow, allCores;\n-     vqshl_vrshl_vqrshl_ddd *)\n-  \"neon_shift_2\", [Source n1; Dest n4], Shift, allCores;\n-  (* vsli, vsri and vshl for qqq *)\n-  \"neon_shift_3\", [Source n1; Dest_n_after (1, n3)], Shift_2cycle, allCores;\n-  \"neon_vshl_ddd\", [Source n1; Dest n1], Shift, allCores;\n-  \"neon_vqshl_vrshl_vqrshl_qqq\", [Source n1; Dest_n_after (1, n4)],\n-    Shift_2cycle, allCores;\n-  \"neon_vsra_vrsra\", [Source_m n1; Source_d n3; Dest n6], Shift, allCores;\n-\n-  (* NEON floating-point instructions.  *)\n-  (* vadd, vsub, vabd, vmul, vceq, vcge, vcgt, vcage, vcagt, vmax, vmin *)\n-  (* vabs, vneg, vceqz, vcgez, vcgtz, vclez, vcltz, vrecpe, vrsqrte, vcvt *)\n-  \"neon_fp_vadd_ddd_vabs_dd\", [Source n2; Dest n5], Fadd, allCores;\n-  \"neon_fp_vadd_qqq_vabs_qq\", [Source n2; Dest_n_after (1, n5)],\n-    Fadd_2cycle, allCores;\n-  (* vsum, fvmx, vfmn *)\n-  \"neon_fp_vsum\", [Source n1; Dest n5], Fadd, allCores;\n-  \"neon_fp_vmul_ddd\", [Source_n n2; Source_m n1; Dest n5], Fmul, allCores;\n-  \"neon_fp_vmul_qqd\", [Source_n n2; Source_m n1; Dest_n_after (1, n5)],\n-    Fmul_2cycle, allCores;\n-  (* vmla, vmls *)\n-  \"neon_fp_vmla_ddd\",\n-    [Source_n n2; Source_m n2; Source_d n3; Dest n9], Fmul_then_fadd, allCores;\n-  \"neon_fp_vmla_qqq\",\n-    [Source_n n2; Source_m n2; Source_d n3; Dest_n_after (1, n9)],\n-    Fmul_then_fadd_2, allCores;\n-  \"neon_fp_vmla_ddd_scalar\",\n-    [Source_n n2; Source_m n1; Source_d n3; Dest n9], Fmul_then_fadd, allCores;\n-  \"neon_fp_vmla_qqq_scalar\",\n-    [Source_n n2; Source_m n1; Source_d n3; Dest_n_after (1, n9)],\n-    Fmul_then_fadd_2, allCores;\n-  \"neon_fp_vrecps_vrsqrts_ddd\", [Source n2; Dest n9], Fmul_then_fadd, allCores;\n-  \"neon_fp_vrecps_vrsqrts_qqq\", [Source n2; Dest_n_after (1, n9)],\n-    Fmul_then_fadd_2, allCores;\n-\n-  (* NEON byte permute instructions.  *)\n-  (* vmov; vtrn and vswp for dd; vzip for dd; vuzp for dd; vrev; vext for dd *)\n-  \"neon_bp_simple\", [Source n1; Dest n2], Permute 1, allCores;\n-  (* vswp for qq; vext for qqq; vtbl with {Dn} or {Dn, Dn1}, allCores;\n-     similarly for vtbx *)\n-  \"neon_bp_2cycle\", [Source n1; Dest_n_after (1, n2)], Permute 2, allCores;\n-  (* all the rest *)\n-  \"neon_bp_3cycle\", [Source n1; Dest_n_after (2, n2)], Permute 3, allCores;\n-\n-  (* NEON load/store instructions.  *)\n-  \"neon_ldr\", [Dest n1], Ls 1, allCores;\n-  \"neon_str\", [Source n1], Ls 1, allCores;\n-  \"neon_vld1_1_2_regs\", [Dest_n_after (1, n1)], Ls 2, allCores;\n-  \"neon_vld1_3_4_regs\", [Dest_n_after (2, n1)], Ls 3, allCores;\n-  \"neon_vld2_2_regs_vld1_vld2_all_lanes\", [Dest_n_after (1, n2)], Ls 2, allCores;\n-  \"neon_vld2_4_regs\", [Dest_n_after (2, n2)], Ls 3, allCores;\n-  \"neon_vld3_vld4\", [Dest_n_after (3, n2)], Ls 4, allCores;\n-  \"neon_vst1_1_2_regs_vst2_2_regs\", [Source n1], Ls 2, allCores;\n-  \"neon_vst1_3_4_regs\", [Source n1], Ls 3, allCores;\n-  \"neon_vst2_4_regs_vst3_vst4\", [Source n1], Ls 4, allCores;\n-  \"neon_vst3_vst4\", [Source n1], Ls 4, allCores;\n-  \"neon_vld1_vld2_lane\", [Source n1; Dest_n_after (2, n2)], Ls 3, allCores;\n-  \"neon_vld3_vld4_lane\", [Source n1; Dest_n_after (4, n2)], Ls 5, allCores;\n-  \"neon_vst1_vst2_lane\", [Source n1], Ls 2, allCores;\n-  \"neon_vst3_vst4_lane\", [Source n1], Ls 3, allCores;\n-  \"neon_vld3_vld4_all_lanes\", [Dest_n_after (1, n2)], Ls 3, allCores;\n-\n-  (* NEON register transfer instructions.  *)\n-  \"neon_mcr\", [Dest n2], Permute 1, allCores;\n-  \"neon_mcr_2_mcrr\", [Dest n2], Permute 2, allCores;\n-  (* MRC instructions are in the .tpl file.  *)\n-]\n-\n-(* Augment the tuples in the availability table with an extra component\n-   that describes the earliest stage where a source operand may be\n-   required.  (It is also possible that an entry in the table has no\n-   source requirements.)  *)\n-let calculate_sources =\n-  List.map (fun (name, avail, res, cores) ->\n-              let earliest_stage =\n-                List.fold_left\n-                  (fun cur -> fun info ->\n-                     match info with\n-                       Source stage\n-                     | Source_n stage\n-                     | Source_m stage\n-                     | Source_d stage ->\n-                         (match cur with\n-                           None -> Some stage\n-                         | Some stage' when stage < stage' -> Some stage\n-                         | _ -> cur)\n-                     | _ -> cur) None avail\n-              in\n-                (name, avail, res, earliest_stage))\n-\n-(* Find the stage, if any, at the end of which a group produces a result.  *)\n-let find_dest (attr, avail, _, _) =\n-  try\n-    find_with_result\n-      (fun av -> match av with\n-                   Dest st -> Some (Some st)\n-                 | Dest_n_after (after, st) -> Some (Some (after + st))\n-                 | _ -> None) avail\n-  with Not_found -> None\n-\n-(* Find the worst-case latency between a producer and a consumer.  *)\n-let worst_case_latency producer (_, _, _, earliest_required) =\n-  let dest = find_dest producer in\n-    match earliest_required, dest with\n-      None, _ ->\n-        (* The consumer doesn't have any source requirements.  *)\n-        None\n-    | _, None ->\n-        (* The producer doesn't produce any results (e.g. a store insn).  *)\n-        None\n-    | Some consumed, Some produced -> Some (produced - consumed + 1)\n-\n-(* Helper function for below.  *)\n-let latency_calc f producer (_, avail, _, _) =\n-  try\n-    let source_avail = find_with_result f avail in\n-      match find_dest producer with\n-        None ->\n-          (* The producer does not produce a result.  *)\n-          Some 0\n-      | Some produced ->\n-          let latency = produced - source_avail + 1 in\n-            (* Latencies below zero are raised to zero since we don't have\n-               delay slots.  *)\n-            if latency < 0 then Some 0 else Some latency\n-  with Not_found -> None\n-\n-(* Find any Rm latency between a producer and a consumer.  If no\n-   Rm source requirement is explicitly specified for the consumer,\n-   return \"positive infinity\".  Also return \"positive infinity\" if\n-   the latency matches the supplied worst-case latency for this\n-   producer.  *)\n-let get_m_latency producer consumer =\n-  match latency_calc (fun av -> match av with Source_m stage -> Some stage\n-                                            | _ -> None) producer consumer\n-  with None -> [] | Some latency -> [(Guard_only_m, latency)]\n-\n-(* Likewise for Rn.  *)\n-let get_n_latency producer consumer =\n-  match latency_calc (fun av -> match av with Source_n stage -> Some stage\n-                                            | _ -> None) producer consumer\n-  with None -> [] | Some latency -> [(Guard_only_n, latency)]\n-\n-(* Likewise for Rd.  *)\n-let get_d_latency producer consumer =\n-  match\n-    latency_calc (fun av -> match av with Source_d stage -> Some stage\n-                                        | _ -> None) producer consumer\n-  with None -> [] | Some latency -> [(Guard_only_d, latency)]\n-\n-(* Given a producer and a consumer, work out the latency of the producer\n-   to the consumer in each of the four cases (availability information\n-   permitting) identified at the top of this file.  Return the\n-   consumer, the worst-case unguarded latency and any guarded latencies.  *)\n-let calculate_latencies producer consumer =\n-  let worst = worst_case_latency producer consumer in\n-  let m_latency = get_m_latency producer consumer in\n-  let n_latency = get_n_latency producer consumer in\n-  let d_latency = get_d_latency producer consumer in\n-    (consumer, worst, m_latency @ n_latency @ d_latency)\n-\n-(* Helper function for below.  *)\n-let pick_latency largest worst guards =\n-  let guards =\n-    match worst with\n-      None -> guards\n-    | Some worst -> (Guard_none, worst) :: guards\n-  in\n-  if List.length guards = 0 then None else\n-    let total_latency =\n-      List.fold_left (fun acc -> fun (_, latency) -> acc + latency) 0 guards\n-    in\n-    let average_latency = (float_of_int total_latency) /.\n-                          (float_of_int (List.length guards)) in\n-    let rounded_latency = int_of_float (ceil average_latency) in\n-      if rounded_latency = largest then None\n-      else Some (Guard_none, rounded_latency)\n-\n-(* Collate all bypasses for a particular producer as required in\n-   worst_case_latencies_and_bypasses.  (By this stage there is a maximum\n-   of one bypass from this producer to any particular consumer listed\n-   in LATENCIES.)  Use a hash table to collate bypasses with the\n-   same latency and guard.  *)\n-let collate_bypasses (producer_name, _, _, _) largest latencies core =\n-  let ht = Hashtbl.create 42 in\n-  let keys = ref [] in\n-    List.iter (\n-      fun ((consumer, _, _, _), worst, guards) ->\n-        (* Find out which latency to use.  Ignoring latencies that match\n-           the *overall* worst-case latency for this producer (which will\n-           be in define_insn_reservation), we have to examine:\n-\t   1. the latency with no guard between this producer and this\n-              consumer; and\n-\t   2. any guarded latency.  *)\n-        let guard_latency_opt = pick_latency largest worst guards in\n-          match guard_latency_opt with\n-            None -> ()\n-          | Some (guard, latency) ->\n-            begin\n-              (if (try ignore (Hashtbl.find ht (guard, latency)); false\n-                   with Not_found -> true) then\n-                 keys := (guard, latency) :: !keys);\n-              Hashtbl.add ht (guard, latency) ((coreStr core) ^ \"_\" ^ consumer)\n-            end\n-    ) latencies;\n-    (* The hash table now has bypasses collated so that ones with the\n-       same latency and guard have the same keys.  Walk through all the\n-       keys, extract the associated bypasses, and concatenate the names\n-       of the consumers for each bypass.  *)\n-    List.map (\n-      fun ((guard, latency) as key) ->\n-        let consumers = Hashtbl.find_all ht key in\n-          (producer_name,\n-           String.concat \",\\\\\\n               \" consumers,\n-           latency,\n-           guard)\n-      ) !keys\n-\n-(* For every producer, find the worst-case latency between it and\n-   *any* consumer.  Also determine (if such a thing exists) the\n-   lowest-latency bypass from each producer to each consumer.  Group\n-   the output in such a way that all bypasses with the same producer\n-   and latency are together, and so that bypasses with the worst-case\n-   latency are ignored.  *)\n-let worst_case_latencies_and_bypasses core =\n-  let rec f (worst_acc, bypasses_acc) prev xs =\n-    match xs with\n-      [] -> (worst_acc, bypasses_acc)\n-    | ((producer_name, producer_avail, res_string, _) as producer)::next ->\n-      (* For this particular producer, work out the latencies between\n-         it and every consumer.  *)\n-      let latencies =\n-        List.fold_left (fun acc -> fun consumer ->\n-                          (calculate_latencies producer consumer) :: acc)\n-                       [] (prev @ xs)\n-      in\n-        (* Now work out what the overall worst case latency was for this\n-           particular producer.  *)\n-        match latencies with\n-          [] -> assert false\n-        | _ ->\n-          let comp_fn (_, l1, _) (_, l2, _) =\n-            if l1 > l2 then -1 else if l1 = l2 then 0 else 1\n-          in\n-          let largest =\n-            match List.hd (List.sort comp_fn latencies) with\n-              (_, None, _) -> 0 (* Producer has no consumers. *)\n-            | (_, Some worst, _) -> worst\n-          in\n-          (* Having got the largest latency, collect all bypasses for\n-             this producer and filter out those with that larger\n-             latency.  Record the others for later emission.  *)\n-          let bypasses = collate_bypasses producer largest latencies core in\n-            (* Go on to process remaining producers, having noted\n-               the result for this one.  *)\n-            f ((producer_name, producer_avail, largest,\n-                res_string) :: worst_acc,\n-               bypasses @ bypasses_acc)\n-              (prev @ [producer]) next\n-  in\n-    f ([], []) []\n-\n-(* Emit a helpful comment for a define_insn_reservation.  *)\n-let write_comment producer avail =\n-  let seen_source = ref false in\n-  let describe info =\n-    let read = if !seen_source then \"\" else \"read \" in\n-    match info with\n-      Source stage ->\n-        seen_source := true;\n-\tPrintf.printf \"%stheir source operands at N%d\" read stage\n-    | Source_n stage ->\n-        seen_source := true;\n-\tPrintf.printf \"%stheir (D|Q)n operands at N%d\" read stage\n-    | Source_m stage ->\n-        seen_source := true;\n-\tPrintf.printf \"%stheir (D|Q)m operands at N%d\" read stage\n-    | Source_d stage ->\n-\tPrintf.printf \"%stheir (D|Q)d operands at N%d\" read stage\n-    | Dest stage ->\n-\tPrintf.printf \"produce a result at N%d\" stage\n-    | Dest_n_after (after, stage) ->\n-\tPrintf.printf \"produce a result at N%d on cycle %d\" stage (after + 1)\n-  in\n-    Printf.printf \";; Instructions using this reservation \";\n-    let rec f infos x =\n-      let sep = if x mod 2 = 1 then \"\" else \"\\n;;\" in\n-      match infos with\n-        [] -> assert false\n-      | [info] -> describe info; Printf.printf \".\\n\"\n-      | info::(_::[] as infos) ->\n-          describe info; Printf.printf \", and%s \" sep; f infos (x+1)\n-      | info::infos -> describe info; Printf.printf \",%s \" sep; f infos (x+1)\n-    in\n-      f avail 0\n-\n-\n-(* Emit a define_insn_reservation for each producer.  The latency\n-   written in will be its worst-case latency.  *)\n-let emit_insn_reservations core =\n-  let corestring = coreStr core in\n-  let tunestring = tuneStr core\n-  in  List.iter (\n-     fun (producer, avail, latency, reservation) ->\n-        write_comment producer avail;\n-        Printf.printf \"(define_insn_reservation \\\"%s_%s\\\" %d\\n\" \n-            corestring producer latency;\n-            Printf.printf \"  (and (eq_attr \\\"tune\\\" \\\"%s\\\")\\n\" tunestring;\n-        Printf.printf \"       (eq_attr \\\"type\\\" \\\"%s\\\"))\\n\" producer;\n-        let str =\n-          match reservation with\n-\t    Mul -> \"dp\" | Mul_2cycle -> \"dp_2\" | Mul_4cycle -> \"dp_4\"\n-\t  | Shift -> \"dp\" | Shift_2cycle -> \"dp_2\"\n-\t  | ALU -> \"dp\" | ALU_2cycle -> \"dp_2\"\n-\t  | Fmul -> \"dp\" | Fmul_2cycle -> \"dp_2\"\n-\t  | Fadd -> \"fadd\" | Fadd_2cycle -> \"fadd_2\"\n-\t  | Ls 1 -> \"ls\"\n-          | Ls n -> \"ls_\" ^ (string_of_int n)\n-\t  | Permute 1 -> \"perm\"\n-          | Permute n -> \"perm_\" ^ (string_of_int n)\n-\t  | Fmul_then_fadd -> \"fmul_then_fadd\"\n-\t  | Fmul_then_fadd_2 -> \"fmul_then_fadd_2\"\n-        in\n-          Printf.printf \"  \\\"%s_neon_%s\\\")\\n\\n\" corestring str\n-    )\n-\n-(* Given a guard description, return the name of the C function to\n-   be used as the guard for define_bypass.  *)\n-let guard_fn g =\n-  match g with\n-    Guard_only_m -> \"arm_neon_only_m_dependency\"\n-  | Guard_only_n -> \"arm_neon_only_n_dependency\"\n-  | Guard_only_d -> \"arm_neon_only_d_dependency\"\n-  | Guard_none -> assert false\n-\n-(* Emit a define_bypass for each bypass.  *)\n-let emit_bypasses core =\n-  List.iter (\n-      fun (producer, consumers, latency, guard) ->\n-        Printf.printf \"(define_bypass %d \\\"%s_%s\\\"\\n\" \n-\tlatency (coreStr core) producer;\n-\n-        if guard = Guard_none then\n-          Printf.printf \"               \\\"%s\\\")\\n\\n\" consumers\n-        else\n-          begin\n-            Printf.printf \"               \\\"%s\\\"\\n\" consumers;\n-            Printf.printf \"               \\\"%s\\\")\\n\\n\" (guard_fn guard)\n-          end\n-    )\n-\n-\n-let calculate_per_core_availability_table core availability_table =\n-  let table = calculate_sources availability_table in\n-  let worst_cases, bypasses = worst_case_latencies_and_bypasses core table in\n-    emit_insn_reservations core (List.rev worst_cases);\n-    Printf.printf \";; Exceptions to the default latencies.\\n\\n\";\n-    emit_bypasses core bypasses\n-\n-let calculate_core_availability_table core availability_table =\n-let filter_core = List.filter (fun (_, _, _, cores) \n-\t\t\t\t   -> List.exists ((=) core) cores)\n-in calculate_per_core_availability_table core (filter_core availability_table)\n-\n-\n-(* Program entry point.  *)\n-let main =\n-  List.map (fun core -> calculate_core_availability_table \n-\t\tcore availability_table) allCores"}]}