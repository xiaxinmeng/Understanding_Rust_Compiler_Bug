{"sha": "89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODljMWNmMjY5NWM3OTZhYWY5NjEwNjE1ZTlmMWVjZDFmMjE5OGRhMQ==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2018-12-24T18:26:25Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2018-12-24T18:26:25Z"}, "message": "re PR fortran/45513 (BOZ kinds differently handled, F2008: BOZ in bit intrinsics)\n\n2018-12-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/45513\n\tPR fortran/81509\n\t* check.c: Rename function gfc_check_iand to gfc_check_iand_ieor_ior.\n\t* check.c (boz_args_check): New function.  Check I and J not both BOZ.\n\t(gfc_check_dshift,gfc_check_iand_ieor_ior, gfc_check_ishft,\n\t gfc_check_and, gfc_check_merge_bits): Use it.\n\t* check.c (gfc_check_iand_ieor_ior): Force conversion of BOZ to kind\n\ttype of other agrument.  Remove silly GNU extension.\n\t(gfc_check_ieor, gfc_check_ior): Delete now unused functions.\n\t* intrinsic.c (add_functions): Use gfc_check_iand_ieor_ior. Wrap long\n\tline.\n\t* intrinsic.h: Rename gfc_check_iand to gfc_check_iand_ieor_ior.\n\tDelete prototype for bool gfc_check_ieor and gfc_check_ior\n\t* intrinsic.texi: Update documentation for boz-literal-constant.\n\n2018-12-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/45513\n\tPR fortran/81509\n\t* gfortran.dg/graphite/id-26.f03: Fix non-conforming use of IAND.\n\t* gfortran.dg/pr81509_1.f90: New test.\n\t* gfortran.dg/pr81509_2.f90: New test.\n\nFrom-SVN: r267415", "tree": {"sha": "fdf121265af2daee9fd6e271846f9eef4256a57e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdf121265af2daee9fd6e271846f9eef4256a57e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/comments", "author": null, "committer": null, "parents": [{"sha": "a8ed2b4f646a2c8e3b1032cabbc328a0ff2cb9ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ed2b4f646a2c8e3b1032cabbc328a0ff2cb9ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8ed2b4f646a2c8e3b1032cabbc328a0ff2cb9ea"}], "stats": {"total": 259, "additions": 162, "deletions": 97}, "files": [{"sha": "a93b99ee33332b86b4520e575e7989755649485d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "patch": "@@ -1,3 +1,20 @@\n+2018-12-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/45513\n+\tPR fortran/81509\n+\t* check.c: Rename function gfc_check_iand to gfc_check_iand_ieor_ior.\n+\t* check.c (boz_args_check): New function.  Check I and J not both BOZ.\n+\t(gfc_check_dshift,gfc_check_iand_ieor_ior, gfc_check_ishft,\n+\t gfc_check_and, gfc_check_merge_bits): Use it.\n+\t* check.c (gfc_check_iand_ieor_ior): Force conversion of BOZ to kind\n+\ttype of other agrument.  Remove silly GNU extension.\n+\t(gfc_check_ieor, gfc_check_ior): Delete now unused functions.\n+\t* intrinsic.c (add_functions): Use gfc_check_iand_ieor_ior. Wrap long\n+\tline.\n+\t* intrinsic.h: Rename gfc_check_iand to gfc_check_iand_ieor_ior.\n+\tDelete prototype for bool gfc_check_ieor and gfc_check_ior\n+\t* intrinsic.texi: Update documentation for boz-literal-constant.\n+\n 2018-12-23  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/77703"}, {"sha": "2f63c3ed2d54c7f55fe008aafa28d4f736a78e04", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 40, "deletions": 50, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "patch": "@@ -2168,6 +2168,21 @@ gfc_check_dprod (gfc_expr *x, gfc_expr *y)\n }\n \n \n+static bool\n+boz_args_check(gfc_expr *i, gfc_expr *j)\n+{\n+  if (i->is_boz && j->is_boz)\n+    {\n+      gfc_error (\"Arguments of %qs at %L and %L cannot both be BOZ \"\n+\t\t \"literal constants\", gfc_current_intrinsic, &i->where,\n+\t\t &j->where);\n+      return false;\n+\n+    }\n+  return true;\n+}\n+\n+\n bool\n gfc_check_dshift (gfc_expr *i, gfc_expr *j, gfc_expr *shift)\n {\n@@ -2177,12 +2192,8 @@ gfc_check_dshift (gfc_expr *i, gfc_expr *j, gfc_expr *shift)\n   if (!type_check (j, 1, BT_INTEGER))\n     return false;\n \n-  if (i->is_boz && j->is_boz)\n-    {\n-      gfc_error (\"%<I%> at %L and %<J%>' at %L cannot both be BOZ literal \"\n-\t\t   \"constants\", &i->where, &j->where);\n-      return false;\n-    }\n+  if (!boz_args_check (i, j))\n+    return false;\n \n   if (!i->is_boz && !j->is_boz && !same_type_check (i, 0, j, 1))\n     return false;\n@@ -2482,18 +2493,24 @@ gfc_check_i (gfc_expr *i)\n \n \n bool\n-gfc_check_iand (gfc_expr *i, gfc_expr *j)\n+gfc_check_iand_ieor_ior (gfc_expr *i, gfc_expr *j)\n {\n   if (!type_check (i, 0, BT_INTEGER))\n     return false;\n \n   if (!type_check (j, 1, BT_INTEGER))\n     return false;\n \n+  if (!boz_args_check (i, j))\n+    return false;\n+\n+  if (i->is_boz) i->ts.kind = j->ts.kind;\n+  if (j->is_boz) j->ts.kind = i->ts.kind;\n+\n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (!gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\",\n-\t\t\t   &i->where))\n+      gfc_error (\"Arguments of %qs have different kind type parameters \"\n+\t\t \"at %L\", gfc_current_intrinsic, &i->where);\n \treturn false;\n     }\n \n@@ -2607,26 +2624,6 @@ gfc_check_idnint (gfc_expr *a)\n }\n \n \n-bool\n-gfc_check_ieor (gfc_expr *i, gfc_expr *j)\n-{\n-  if (!type_check (i, 0, BT_INTEGER))\n-    return false;\n-\n-  if (!type_check (j, 1, BT_INTEGER))\n-    return false;\n-\n-  if (i->ts.kind != j->ts.kind)\n-    {\n-      if (!gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\",\n-\t\t\t   &i->where))\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n-\n bool\n gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back,\n \t\t gfc_expr *kind)\n@@ -2680,27 +2677,6 @@ gfc_check_intconv (gfc_expr *x)\n   return true;\n }\n \n-\n-bool\n-gfc_check_ior (gfc_expr *i, gfc_expr *j)\n-{\n-  if (!type_check (i, 0, BT_INTEGER))\n-    return false;\n-\n-  if (!type_check (j, 1, BT_INTEGER))\n-    return false;\n-\n-  if (i->ts.kind != j->ts.kind)\n-    {\n-      if (!gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\",\n-\t\t\t   &i->where))\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n-\n bool\n gfc_check_ishft (gfc_expr *i, gfc_expr *shift)\n {\n@@ -3584,6 +3560,12 @@ gfc_check_merge_bits (gfc_expr *i, gfc_expr *j, gfc_expr *mask)\n   if (!type_check (j, 1, BT_INTEGER))\n     return false;\n \n+  if (!boz_args_check (i, j))\n+    return false;\n+\n+  if (i->is_boz) i->ts.kind = j->ts.kind;\n+  if (j->is_boz) j->ts.kind = i->ts.kind;\n+\n   if (!type_check (mask, 2, BT_INTEGER))\n     return false;\n \n@@ -3593,6 +3575,8 @@ gfc_check_merge_bits (gfc_expr *i, gfc_expr *j, gfc_expr *mask)\n   if (!same_type_check (i, 0, mask, 2))\n     return false;\n \n+  if (mask->is_boz) mask->ts.kind = i->ts.kind;\n+\n   return true;\n }\n \n@@ -6719,6 +6703,12 @@ gfc_check_and (gfc_expr *i, gfc_expr *j)\n   if (!scalar_check (j, 1))\n     return false;\n \n+  if (!boz_args_check (i, j))\n+    return false;\n+\n+  if (i->is_boz) i->ts.kind = j->ts.kind;\n+  if (j->is_boz) j->ts.kind = i->ts.kind;\n+\n   return true;\n }\n "}, {"sha": "0c934e13dd7771c3aadba7b20a61aecbf183d12c", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "patch": "@@ -2025,8 +2025,9 @@ add_functions (void)\n \n   make_generic (\"iachar\", GFC_ISYM_IACHAR, GFC_STD_F95);\n \n-  add_sym_2 (\"iand\", GFC_ISYM_IAND, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n-\t     gfc_check_iand, gfc_simplify_iand, gfc_resolve_iand,\n+  add_sym_2 (\"iand\", GFC_ISYM_IAND, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di,\n+\t     GFC_STD_F95,\n+\t     gfc_check_iand_ieor_ior, gfc_simplify_iand, gfc_resolve_iand,\n \t     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);\n \n   if (flag_dec_intrinsic_ints)\n@@ -2114,8 +2115,9 @@ add_functions (void)\n \n   make_generic (\"ichar\", GFC_ISYM_ICHAR, GFC_STD_F77);\n \n-  add_sym_2 (\"ieor\", GFC_ISYM_IEOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n-\t     gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,\n+  add_sym_2 (\"ieor\", GFC_ISYM_IEOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di,\n+\t     GFC_STD_F95,\n+\t     gfc_check_iand_ieor_ior, gfc_simplify_ieor, gfc_resolve_ieor,\n \t     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);\n \n   if (flag_dec_intrinsic_ints)\n@@ -2192,8 +2194,9 @@ add_functions (void)\n \n   make_generic (\"long\", GFC_ISYM_LONG, GFC_STD_GNU);\n \n-  add_sym_2 (\"ior\", GFC_ISYM_IOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n-\t     gfc_check_ior, gfc_simplify_ior, gfc_resolve_ior,\n+  add_sym_2 (\"ior\", GFC_ISYM_IOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di,\n+\t     GFC_STD_F95,\n+\t     gfc_check_iand_ieor_ior, gfc_simplify_ior, gfc_resolve_ior,\n \t     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);\n \n   if (flag_dec_intrinsic_ints)"}, {"sha": "0ca3f92a73f5b5adb889de29c67cac154f140a4e", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "patch": "@@ -89,17 +89,15 @@ bool gfc_check_hostnm (gfc_expr *);\n bool gfc_check_huge (gfc_expr *);\n bool gfc_check_hypot (gfc_expr *, gfc_expr *);\n bool gfc_check_i (gfc_expr *);\n-bool gfc_check_iand (gfc_expr *, gfc_expr *);\n+bool gfc_check_iand_ieor_ior (gfc_expr *, gfc_expr *);\n bool gfc_check_and (gfc_expr *, gfc_expr *);\n bool gfc_check_ibits (gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_ichar_iachar (gfc_expr *, gfc_expr *);\n bool gfc_check_idnint (gfc_expr *);\n-bool gfc_check_ieor (gfc_expr *, gfc_expr *);\n bool gfc_check_image_status (gfc_expr *, gfc_expr *);\n bool gfc_check_index (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_int (gfc_expr *, gfc_expr *);\n bool gfc_check_intconv (gfc_expr *);\n-bool gfc_check_ior (gfc_expr *, gfc_expr *);\n bool gfc_check_irand (gfc_expr *);\n bool gfc_check_isatty (gfc_expr *);\n bool gfc_check_isnan (gfc_expr *);"}, {"sha": "8ea04c3839119547b987c35194010ae4154fec69", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "patch": "@@ -1144,15 +1144,20 @@ Function\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{I} @tab The type shall be either a scalar @code{INTEGER}\n-type or a scalar @code{LOGICAL} type.\n-@item @var{J} @tab The type shall be the same as the type of @var{I}.\n+type or a scalar @code{LOGICAL} type or a boz-literal-constant.\n+@item @var{J} @tab The type shall be the same as the type of @var{I} or\n+a boz-literal-constant. @var{I} and @var{J} shall not both be\n+boz-literal-constants.  If either @var{I} or @var{J} is a\n+boz-literal-constant, then the other argument must be a scalar @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n The return type is either a scalar @code{INTEGER} or a scalar\n @code{LOGICAL}.  If the kind type parameters differ, then the\n smaller kind type is implicitly converted to larger kind, and the \n-return has the larger kind.\n+return has the larger kind.  A boz-literal-constant is \n+converted to an @code{INTEGER} with the kind type parameter of\n+the other argument as-if a call to @ref{INT} occurred.\n \n @item @emph{Example}:\n @smallexample\n@@ -7523,16 +7528,17 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER}.\n-@item @var{J} @tab The type shall be @code{INTEGER}, of the same\n-kind as @var{I}.  (As a GNU extension, different kinds are also \n-permitted.)\n+@item @var{I} @tab The type shall be @code{INTEGER} or a boz-literal-constant.\n+@item @var{J} @tab The type shall be @code{INTEGER} with the same\n+kind type parameter as @var{I} or a boz-literal-constant.\n+@var{I} and @var{J} shall not both be boz-literal-constants.\n @end multitable\n \n @item @emph{Return value}:\n-The return type is @code{INTEGER}, of the same kind as the\n-arguments.  (If the argument kinds differ, it is of the same kind as\n-the larger argument.)\n+The return type is @code{INTEGER} with the kind type parameter of the\n+arguments.\n+A boz-literal-constant is converted to an @code{INTEGER} with the kind\n+type parameter of the other argument as-if a call to @ref{INT} occurred.\n \n @item @emph{Example}:\n @smallexample\n@@ -7973,16 +7979,17 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER}.\n-@item @var{J} @tab The type shall be @code{INTEGER}, of the same\n-kind as @var{I}.  (As a GNU extension, different kinds are also \n-permitted.)\n+@item @var{I} @tab The type shall be @code{INTEGER} or a boz-literal-constant.\n+@item @var{J} @tab The type shall be @code{INTEGER} with the same\n+kind type parameter as @var{I} or a boz-literal-constant.\n+@var{I} and @var{J} shall not both be boz-literal-constants.\n @end multitable\n \n @item @emph{Return value}:\n-The return type is @code{INTEGER}, of the same kind as the\n-arguments.  (If the argument kinds differ, it is of the same kind as\n-the larger argument.)\n+The return type is @code{INTEGER} with the kind type parameter of the\n+arguments.\n+A boz-literal-constant is converted to an @code{INTEGER} with the kind\n+type parameter of the other argument as-if a call to @ref{INT} occurred.\n \n @item @emph{Specific names}:\n @multitable @columnfractions .20 .20 .20 .25\n@@ -8291,16 +8298,17 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER}.\n-@item @var{J} @tab The type shall be @code{INTEGER}, of the same\n-kind as @var{I}.  (As a GNU extension, different kinds are also \n-permitted.)\n+@item @var{I} @tab The type shall be @code{INTEGER} or a boz-literal-constant.\n+@item @var{J} @tab The type shall be @code{INTEGER} with the same\n+kind type parameter as @var{I} or a boz-literal-constant.\n+@var{I} and @var{J} shall not both be boz-literal-constants.\n @end multitable\n \n @item @emph{Return value}:\n-The return type is @code{INTEGER}, of the same kind as the\n-arguments.  (If the argument kinds differ, it is of the same kind as\n-the larger argument.)\n+The return type is @code{INTEGER} with the kind type parameter of the\n+arguments.\n+A boz-literal-constant is converted to an @code{INTEGER} with the kind\n+type parameter of the other argument as-if a call to @ref{INT} occurred.\n \n @item @emph{Specific names}:\n @multitable @columnfractions .20 .20 .20 .25\n@@ -10296,11 +10304,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I}    @tab Shall be of type @code{INTEGER}.\n-@item @var{J}    @tab Shall be of type @code{INTEGER} and of the same\n-kind as @var{I}.\n-@item @var{MASK} @tab Shall be of type @code{INTEGER} and of the same\n-kind as @var{I}.\n+@item @var{I} @tab Shall be of type @code{INTEGER} or a boz-literal-constant.\n+@item @var{J} @tab Shall be of type @code{INTEGER} with the same\n+kind type parameter as @var{I} or a boz-literal-constant.\n+@var{I} and @var{J} shall not both be boz-literal-constants.\n+@item @var{MASK} @tab Shall be of type @code{INTEGER} or a boz-literal-constant\n+and of the same kind as @var{I}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -11125,15 +11134,20 @@ Function\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{I} @tab The type shall be either a scalar @code{INTEGER}\n-type or a scalar @code{LOGICAL} type.\n-@item @var{J} @tab The type shall be the same as the type of @var{J}.\n+type or a scalar @code{LOGICAL} type or a boz-literal-constant.\n+@item @var{J} @tab The type shall be the same as the type of @var{I} or\n+a boz-literal-constant. @var{I} and @var{J} shall not both be\n+boz-literal-constants.  If either @var{I} and @var{J} is a\n+boz-literal-constant, then the other argument must be a scalar @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n The return type is either a scalar @code{INTEGER} or a scalar\n @code{LOGICAL}.  If the kind type parameters differ, then the\n smaller kind type is implicitly converted to larger kind, and the \n-return has the larger kind.\n+return has the larger kind.  A boz-literal-constant is \n+converted to an @code{INTEGER} with the kind type parameter of\n+the other argument as-if a call to @ref{INT} occurred.\n \n @item @emph{Example}:\n @smallexample\n@@ -14639,16 +14653,21 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be either  a scalar @code{INTEGER}\n-type or a scalar @code{LOGICAL} type.\n-@item @var{J} @tab The type shall be the same as the type of @var{I}.\n+@item @var{I} @tab The type shall be either a scalar @code{INTEGER}\n+type or a scalar @code{LOGICAL} type or a boz-literal-constant.\n+@item @var{J} @tab The type shall be the same as the type of @var{I} or\n+a boz-literal-constant. @var{I} and @var{J} shall not both be\n+boz-literal-constants.  If either @var{I} and @var{J} is a\n+boz-literal-constant, then the other argument must be a scalar @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n The return type is either a scalar @code{INTEGER} or a scalar\n @code{LOGICAL}.  If the kind type parameters differ, then the\n smaller kind type is implicitly converted to larger kind, and the \n-return has the larger kind.\n+return has the larger kind.  A boz-literal-constant is \n+converted to an @code{INTEGER} with the kind type parameter of\n+the other argument as-if a call to @ref{INT} occurred.\n \n @item @emph{Example}:\n @smallexample"}, {"sha": "138866b98e3f72417a7e29ef65c58f2e19d2ca4f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "patch": "@@ -1,3 +1,11 @@\n+2018-12-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/45513\n+\tPR fortran/81509\n+\t* gfortran.dg/graphite/id-26.f03: Fix non-conforming use of IAND.\n+\t* gfortran.dg/pr81509_1.f90: New test.\n+\t* gfortran.dg/pr81509_2.f90: New test.\n+\n 2018-12-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* gfortran.dg/ieee/ieee_9.f90:  XFAIL on arm*-*-gnueabi[hf]."}, {"sha": "06aa7acc9d4535d8f71f385bf5abc3110b5cb419", "filename": "gcc/testsuite/gfortran.dg/graphite/id-26.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-26.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-26.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-26.f03?ref=89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "patch": "@@ -51,11 +51,11 @@ subroutine baz (x, c)\n   ! Attempt to create 64-byte aligned allocatable\n   do i = 1, 64\n     allocate (c(1023 + i))\n-    if (iand (loc (c(1)), 63) == 0) exit\n+    if (iand(int(loc(c(1)), 8), 63_8) == 0) exit\n     deallocate (c)\n     allocate (b(i)%a(1023 + i))\n     allocate (c(1023 + i))\n-    if (iand (loc (c(1)), 63) == 0) exit\n+    if (iand(int(loc(c(1)), 8), 63_8) == 0) exit\n     deallocate (c)\n   end do\n   if (allocated (c)) then"}, {"sha": "dc21197c3fe048be0159a1dac948a0f07df8a1a6", "filename": "gcc/testsuite/gfortran.dg/pr81509_1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81509_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81509_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81509_1.f90?ref=89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+! https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81509\n+program foo\n+logical :: a = .false.\n+integer :: i = 42\n+integer(8) :: k = 42\n+if (kind(ieor(z'ade',i)) /= 4) call abort\n+if (kind(ior(i,z'1111')) /= 4) call abort\n+if (kind(ior(1_8,k)) /= 8) call abort\n+if (kind(iand(k,b'1111')) /= 8) call abort\n+end program foo\n+"}, {"sha": "919cb4e07a5d973387a8c0c97befde80fa689aad", "filename": "gcc/testsuite/gfortran.dg/pr81509_2.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81509_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c1cf2695c796aaf9610615e9f1ecd1f2198da1/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81509_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81509_2.f90?ref=89c1cf2695c796aaf9610615e9f1ecd1f2198da1", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81509\n+!\n+program foo\n+logical :: a = .false.\n+integer :: i = 42\n+integer(8) :: k\n+k = iand(z'aaaa', z'1234')    ! { dg-error \"cannot both be BOZ literal\" }\n+k = and(z'aaaa', z'1234')     ! { dg-error \"cannot both be BOZ literal\" }\n+k = and(1, z'1234')\n+k = and(i, z'1234')\n+k = ieor(z'ade',i)\n+k = ior(i,z'1111')\n+k = ior(i,k)                  ! { dg-error \"different kind type parameters\" }\n+k = and(i,k)\n+k = and(a,z'1234')            ! { dg-error \"must have the same type\" }\n+end program foo\n+"}]}