{"sha": "f430bae8727f3b99f24001224ff9a18e3b31ea02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQzMGJhZTg3MjdmM2I5OWYyNDAwMTIyNGZmOWExOGUzYjMxZWEwMg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2005-04-05T19:05:20Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2005-04-05T19:05:20Z"}, "message": "lambda-code.c (lambda_loopnest_to_gcc_loopnest): Use update_stmt.\n\n\n\n2005-04-05  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* lambda-code.c (lambda_loopnest_to_gcc_loopnest): Use update_stmt.\n\tUse immediate use iterator.\n\t(stmt_is_bumper_for_loop): Use immediate use iterator.\n\t* predict.c (strip_builtin_expect): Use update_stmt.\n\t* tree-cfg.c (update_modified_stmts): New. Call update_stmt_if_modified\n\ton all elements of a STATEMENT_LIST.\n\t(bsi_insert_before, bsi_insert_after): Call update_modified_stmts.\n\t(bsi_remove): Remove imm_use links and mark the stmt as modified.\n\t(bsi_replace): Mark stmt as modified and the update it.\n\t* tree-complex.c (update_complex_assignment): Call mark_stmt_modified.\n\t(expand_complex_libcal): Call update_stmt.\n\t(expand_complex_comparison): Call mark_stmt_modified.\n\t(expand_complex_operations_1): Call update_stmt_if_modified.\n\t(expand_vector_operations_1): Call mark_stmt_modified.\n\t* tree-dfa.c (compute_immediate_uses, free_df_for_stmt, free_df,\n\tcompute_immediate_uses_for_phi, compute_immediate_uses_for_stmt,\n\tadd_immediate_use, redirect_immediate_use,\n\tredirect_immediate_uses, dump_immediate_uses, debug_immediate_uses,\n\tdump_immediate_uses_for, debug_immediate_uses_for): Delete.\n\t(mark_new_vars_to_rename): Call update_stmt.\n\t* tree-dump.c (dump_option_value_in): Add \"stmtaddr\".\n\t* tree-flow-inline.h (modify_stmt): Rename to mark_stmt_modified.\n\tIgnore PHI nodes.\n\t(unmodify_stmt): Delete.\n\t(update_stmt): New.  Force an update of a stmt.\n\t(update_stmt_if_modified): update a stmt if it is out of date.\n\t(get_stmt_operands): Verify stmt is NOT modified.\n\t(stmt_modified_p): Update comment.\n\t(delink_imm_use): Remove a use node from its immuse list.\n\t(link_imm_use_to_list): Link a use node to a specific list.\n\t(link_imm_use): Link a node to the correct list.\n\t(set_ssa_use_from_ptr): Set a use node to a specific value, and insert\n\tit in the correct list, if appropriate.\n\t(link_imm_use_stmt): Link a use node, and set the stmt pointer.\n\t(relink_imm_use): Link a use node in place of another node in a list.\n\t(relink_imm_use_stmt): LInk a node in place of another node, and set\n\tthe stmt pointer.\n\t(end_safe_imm_use_traverse): New.  Terminate a safe immuse iterator.\n\t(end_safe_imm_use_p): New.  Check for the end of a safe immuse iterator.\n\t(first_safe_imm_use): New.  Initialize a safe immuse iterator.\n\t(next_safe_imm_use): New.  Proceed to next safe immuse iterator value.\n\t(end_readonly_imm_use_p): New.  Check for end of a fast immuse iterator.\n\t(first_readonly_imm_use): New.  Initialize a fast immuse iterator.\n\t(next_readonly_imm_use): New.  Get the next fast immuse iterator value.\n\t(has_zero_uses): New.  Return true if there are no uses of a var.\n\t(has_single_use): New.  Return true if there is only a single use of a\n\tvariable.\n\t(single_imm_use): New.  Return the simgle immediate use.\n\t(num_imm_uses): New.  Return the number of immediate uses.\n\t(get_v_must_def_ops): Use is now a pointer.\n\t(use_operand_p, get_v_may_def_op_ptr, get_vuse_op_ptr,\n\tget_v_must_def_kill_ptr, get_phi_arg_def_ptr): Return the address of\n\tthe use node.\n\t(get_immediate_uses, num_immediate_uses, immediate_use): Delete.\n\t(delink_stmt_imm_use): Delink all immuses from a stmt.\n\t(phi_arg_index_from_use): New.  Return a phi arg index for a use.\n\t* tree-flow.h (struct dataflow_d): Delete.\n\t(immediate_use_iterator_d): New.  Immediate use iterator struct.\n\t(FOR_EACH_IMM_USE_FAST): New.  Macro for read only immuse iteration.\n\t(FOR_EACH_IMM_USE_SAFE): New.  Macro for write-safe immuse iteration.\n\t(BREAK_FROM_SAFE_IMM_USE): New.  Macro for earlyu exit from write-safe\n\titeration.\n\t(struct stmt_ann_d): Remove dataflow_t from struct.\n\t* tree-if-conv.c (tree_if_conversion).  Don't call free_df.\n\t(if_convertible_phi_p): Use FAST immuse iterator.\n\t(if_convertible_loop_p): Don't call compute_immediate_uses.\n\t(replace_phi_with_cond_modify_expr): Call update_stmt.\n\t* tree-into-ssa.c (mark_def_sites, ssa_mark_def_sites): Call\n\tupdate_stmt_if_modified.\n\t(rewrite_all_into_ssa): Initialize ssa operands.\n\t* tree-loop-linear.c (linear_transform_loops): Don't call free_df or\n\tcompute_immediate_uses.\n\t* tree-optimize.c (execute_todo): Call verify_ssa whenever the\n\tssa_property is available.\n\t(execute_one_pass):  Change parameters passed to execute_todo.\n\t* tree-outof-ssa.c (rewrite_trees): Don't call modify_stmt.\n\t(remove_ssa_form): Call fini_ssa_operands.\n\t(insert_backedge_copies): Delete call to modify_stmt.\n\t* tree-phinodes.c (make_phi_node): Initialize use nodes.\n\t(release_phi_node): Delink any use nodes before releasing.\n\t(resize_phi_node): Relink any use nodes.\n\t(remove_phi_arg_num): Delink the use node.\n\t(remove_phi_node): Release the ssa_name AFTER releasing the phi node.\n\t(remove_all_phi_nodes_for): Release phi node first.\n\t* tree-pretty-print.c (dump_generic_node): Print stmt address.\n\t* tree-sra.c (mark_all_v_defs): Call update_stmt_if_modified.\n\t(scalarize_use, scalarize_copy): Call update_stmt.\n\t* tree-ssa-alias.c (compute_may_aliases): Update all modified stmts.\n\t(compute_points_to_and_addr_escape): Call mark_stmt_modified.\n\t* tree-ssa-cpp.c (need_imm_uses_for): Delete.\n\t(ccp_initialize): Remove call to compute_immediate_uses.\n\t(substitute_and_fold, execute_fold_all_builtins): Call update_stmt.\n\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Update all modified\n\tstmts.\n\t(simplify_cond_and_lookup_avail_expr): Call mark_stmt_modified.\n\t(simplify_switch_and_lookup_avail_expr): Call mark_stmt_modified.\n\t(eliminate_redundant_computations): Call mark_stmt_modified.\n\t(cprop_operand): Call mark_stmt_modified.\n\t(optimize_stmt): Call update_stmt_if_modified and mark_stmt_modified.\n\t* tree-ssa-dse.c (fix_phi_uses, fix_stmt_v_may_defs): Delete.\n\t(dse_optimize_stmt): Use new immuse interface.\n\t(tree_ssa_dse): Remove calls to compute_immediate_uses and free_df.\n\t* tree-ssa-forwprop.c (need_imm_uses_for): Delete.\n\t(substitute_single_use_vars): Use new immuse interface.\n\t(tree_ssa_forward_propagate_single_use_vars): Remove calls to free_df\n\tand compute_immediate_uses.\n\t* tree-ssa-loop-im.c (single_reachable_address): Use new immuse\n\tinterface.\n\t(rewrite_mem_refs): Call update_stmt.\n\t(determine_lsm): Remove call to compute_imm_uses and free_df.\n\t* tree-ssa-loop-ivcanon.c (create_canonical_iv): Call update_stmt.\n\t(try_unroll_loop_completely): Call update_stmt.\n\t* tree-ssa-loop-ivopts.c (rewrite_address_base): Call update_stmt.\n\t(rewrite_use_compare): Call update_stmt.\n\t(compute_phi_arg_on_exit): Insert each stmt before trying to process.\n\t(rewrite_use) : Call update_stmt.\n\t* tree-ssa-loop-manip.c (verify_loop_closed_ssa): Add arg to call.\n\t* tree-ssa-loop-unswitch.c (tree_unswitch_single_loop): Call\n\tupdate_stmt.\n\t* tree-ssa-operands.c (NULL_USE_OPERAND_P): Remove declaration.\n\t(allocate_use_optype, allocate_vuse_optype): Adjust allocation size.\n\t(free_uses, free_vuses, free_v_may_defs, free_v_must_defs): Delink\n\tuse nodes.\n\t(initialize_vuse_operand): New.  Initialize a vuse operand.\n\t(initialize_v_may_def_operand): New.  Initialize a maydef operand.\n\t(initialize_v_must_def_operand): New.  Initialize a mustdef operand.\n\t(finalize_ssa_defs): Use stmt parameter.\n\t(correct_use_link): Ensure a use node is in the correct list, and has\n\tthe correct stmt pointer.\n\t(finalize_ssa_uses, finalize_ssa_v_may_defs, finalize_ssa_vuses,\n\tfinalize_ssa_v_must_defs): Also initialize use nodes.\n\t(finalize_ssa_stmt_operands): Pass extra stmt operands.\n\t(build_ssa_operands): Seperate parsing from final operand construction.\n\t(parse_ssa_operands): New.  Parse entry point for operand building.\n\t(swap_tree_operands): New.  Swap 2 tree operands.\n\t(update_stmt_operands): Ranamed from get_stmt_operands.  Always builds\n\toperands.\n\t(get_expr_operands): Call swap_tree_operands when needed.\n\t(copy_virtual_operands): Use initialize routines for virtual use ops.\n\t(create_ssa_artficial_load_stmt): Add extra stmt parameter.\n\t(verify_abort): New.  Issue imm_use error.\n\t(verify_imm_links): New Verify imm_use links for a var.\n\t(dump_immediate_uses_for): New.  Dump imm_uses for a var to file.\n\t(dump_immediate_uses): New.  Dump imm_uses for all vars to file.\n\t(debug_immediate_uses): New.  Dump imm_uses for all vars to stderr.\n\t(debug_immediate_uses_for): New.  Dump imm_uses for a var to stderr.\n\t* tree-ssa-operands.h (struct use_operand_ptr): Delete.\n\t(NULL_USE_OPERAND_P) Define.\n\t(use_optype_d, v_def_use_operand_type, vuse_optype_d): Add immediate\n\tuse node.\n\t(struct vuse_operand_type): New struct.\n\t(SET_USE): Call set_ssa_use_from_ptr.\n\t(USE_STMT): Define.\n\t(PHI_ARG_INDEX_FROM_USE): Define.\n\t* tree-ssa-phiopt.c (replace_phi_edge_with_variable): Set the phi\n\targument via SET_USE, not PHI_ARG_DEF_TREE.\n\t* tree-ssa-pre.c (eliminate): Call update_stmt.\n\t* tree-ssa-propagate.c (cfg_blocks_get): Use imm_use iterators.  Don't\n\tcall free_df.\n\t* tree-ssa-sink.c (all_immediate_uses_same_place): Use imm_use iterator.\n\t(nearest_common_dominator_of_uses): Use imm_use iterator.\n\t(statement_sink_location): Use imm_use iterator and interface.\n\t(execute_sink_code): Don't call compute_immediate_uses or free-df.\n\t* tree-ssa-threadupdate.c (create_edge_and_update_destination_phis): Use\n\tPHI_ARG_DEF, not PHI_ARG_DEF_TREE.\n\t* tree-ssa.c (verify_use, verify_phi_args): Verify some imm_use info.\n\t(verify_ssa): Ensure no stmt is marked modify after optimization pass\n\tif new parameter is true.\n\t(init_tree_ssa): Don't initialize operand cache here.\n\t(delete_tree_ssa): Don't destroy operand cache here.\n\t(propagate_into_addr): Pass in a use pointer, return true if anything\n\twas changed.\n\t(replace_immediate_uses): Use imm_use iterator, call update_stmt.\n\t(check_phi_redundancy): Use imm_use iterator.\n\t(kill_redundant_phi_nodes): Don't call compute_immediate_uses or\n\tfree_df.\n\t* tree-ssanames.c (make_ssa_name): Initialize imm_use node.\n\t(release_ssa_name): Delink node and all elements in its imm_use list.\n\t* tree-tailcall.c (adjust_return_value): Call update_stmt.\n\t* tree-vect-analyze.c (vect_stmt_relevant_p): Use imm_use iterator.\n\t* tree-vectorizer.c (need_imm_uses_for): Delete.\n\t(vectorize_loops): Dont call compute_immediate_uses or free_df.\n\t* tree.h (struct ssa_imm_use_d): Define.\n\t(SSA_NAME_IMM_USE_NODE): Define.\n\t(struct tree_ssa_name): Add imm_use node.\n\t(PHI_DF): Delete.\n\t(PHI_ARG_IMM_USE_NODE): Define.\n\t(struct phi_arg_d): Add imm_use node.\n\t(struct tree_phi_node): Remove struct dataflow_d element.\n\t(TDF_STMTADDR): Define.\n\nFrom-SVN: r97648", "tree": {"sha": "c2f966144654ed8ab54ea9c00b60cc5a1f6f0703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2f966144654ed8ab54ea9c00b60cc5a1f6f0703"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f430bae8727f3b99f24001224ff9a18e3b31ea02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f430bae8727f3b99f24001224ff9a18e3b31ea02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f430bae8727f3b99f24001224ff9a18e3b31ea02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f430bae8727f3b99f24001224ff9a18e3b31ea02/comments", "author": null, "committer": null, "parents": [{"sha": "7701dad790de89fc869cd402c3ced7083355851b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7701dad790de89fc869cd402c3ced7083355851b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7701dad790de89fc869cd402c3ced7083355851b"}], "stats": {"total": 2586, "additions": 1607, "deletions": 979}, "files": [{"sha": "8b51e091efe37884f98748412279c846eea4d166", "filename": "gcc/ChangeLog", "status": "modified", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -1,3 +1,196 @@\n+2005-04-05  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* lambda-code.c (lambda_loopnest_to_gcc_loopnest): Use update_stmt.\n+\tUse immediate use iterator.\n+\t(stmt_is_bumper_for_loop): Use immediate use iterator.\n+\t* predict.c (strip_builtin_expect): Use update_stmt.\n+\t* tree-cfg.c (update_modified_stmts): New. Call update_stmt_if_modified\n+\ton all elements of a STATEMENT_LIST.\n+\t(bsi_insert_before, bsi_insert_after): Call update_modified_stmts.\n+\t(bsi_remove): Remove imm_use links and mark the stmt as modified.\n+\t(bsi_replace): Mark stmt as modified and the update it.\n+\t* tree-complex.c (update_complex_assignment): Call mark_stmt_modified.\n+\t(expand_complex_libcal): Call update_stmt.\n+\t(expand_complex_comparison): Call mark_stmt_modified.\n+\t(expand_complex_operations_1): Call update_stmt_if_modified.\n+\t(expand_vector_operations_1): Call mark_stmt_modified.\n+\t* tree-dfa.c (compute_immediate_uses, free_df_for_stmt, free_df,\n+\tcompute_immediate_uses_for_phi, compute_immediate_uses_for_stmt,\n+\tadd_immediate_use, redirect_immediate_use,\n+\tredirect_immediate_uses, dump_immediate_uses, debug_immediate_uses,\n+\tdump_immediate_uses_for, debug_immediate_uses_for): Delete.\n+\t(mark_new_vars_to_rename): Call update_stmt.\n+\t* tree-dump.c (dump_option_value_in): Add \"stmtaddr\".\n+\t* tree-flow-inline.h (modify_stmt): Rename to mark_stmt_modified.  \n+\tIgnore PHI nodes.\n+\t(unmodify_stmt): Delete.\n+\t(update_stmt): New.  Force an update of a stmt.\n+\t(update_stmt_if_modified): update a stmt if it is out of date.\n+\t(get_stmt_operands): Verify stmt is NOT modified. \n+\t(stmt_modified_p): Update comment.\n+\t(delink_imm_use): Remove a use node from its immuse list.\n+\t(link_imm_use_to_list): Link a use node to a specific list.\n+\t(link_imm_use): Link a node to the correct list.\n+\t(set_ssa_use_from_ptr): Set a use node to a specific value, and insert\n+\tit in the correct list, if appropriate.\n+\t(link_imm_use_stmt): Link a use node, and set the stmt pointer.\n+\t(relink_imm_use): Link a use node in place of another node in a list.\n+\t(relink_imm_use_stmt): LInk a node in place of another node, and set\n+\tthe stmt pointer.\n+\t(end_safe_imm_use_traverse): New.  Terminate a safe immuse iterator.\n+\t(end_safe_imm_use_p): New.  Check for the end of a safe immuse iterator.\n+\t(first_safe_imm_use): New.  Initialize a safe immuse iterator.\n+\t(next_safe_imm_use): New.  Proceed to next safe immuse iterator value.\n+\t(end_readonly_imm_use_p): New.  Check for end of a fast immuse iterator.\n+\t(first_readonly_imm_use): New.  Initialize a fast immuse iterator.\n+\t(next_readonly_imm_use): New.  Get the next fast immuse iterator value.\n+\t(has_zero_uses): New.  Return true if there are no uses of a var.\n+\t(has_single_use): New.  Return true if there is only a single use of a\n+\tvariable.\n+\t(single_imm_use): New.  Return the simgle immediate use.\n+\t(num_imm_uses): New.  Return the number of immediate uses.\n+\t(get_v_must_def_ops): Use is now a pointer.\n+\t(use_operand_p, get_v_may_def_op_ptr, get_vuse_op_ptr,\n+\tget_v_must_def_kill_ptr, get_phi_arg_def_ptr): Return the address of \n+\tthe use node.\n+\t(get_immediate_uses, num_immediate_uses, immediate_use): Delete.\n+\t(delink_stmt_imm_use): Delink all immuses from a stmt.\n+\t(phi_arg_index_from_use): New.  Return a phi arg index for a use.\n+\t* tree-flow.h (struct dataflow_d): Delete.\n+\t(immediate_use_iterator_d): New.  Immediate use iterator struct.\n+\t(FOR_EACH_IMM_USE_FAST): New.  Macro for read only immuse iteration.\n+\t(FOR_EACH_IMM_USE_SAFE): New.  Macro for write-safe immuse iteration.\n+\t(BREAK_FROM_SAFE_IMM_USE): New.  Macro for earlyu exit from write-safe \n+\titeration.\n+\t(struct stmt_ann_d): Remove dataflow_t from struct.\n+\t* tree-if-conv.c (tree_if_conversion).  Don't call free_df.\n+\t(if_convertible_phi_p): Use FAST immuse iterator.\n+\t(if_convertible_loop_p): Don't call compute_immediate_uses.\n+\t(replace_phi_with_cond_modify_expr): Call update_stmt.\n+\t* tree-into-ssa.c (mark_def_sites, ssa_mark_def_sites): Call \n+\tupdate_stmt_if_modified.\n+\t(rewrite_all_into_ssa): Initialize ssa operands.\n+\t* tree-loop-linear.c (linear_transform_loops): Don't call free_df or\n+\tcompute_immediate_uses.\n+\t* tree-optimize.c (execute_todo): Call verify_ssa whenever the \n+\tssa_property is available.\n+\t(execute_one_pass):  Change parameters passed to execute_todo.\n+\t* tree-outof-ssa.c (rewrite_trees): Don't call modify_stmt.\n+\t(remove_ssa_form): Call fini_ssa_operands.\n+\t(insert_backedge_copies): Delete call to modify_stmt.\n+\t* tree-phinodes.c (make_phi_node): Initialize use nodes.\n+\t(release_phi_node): Delink any use nodes before releasing.\n+\t(resize_phi_node): Relink any use nodes.\n+\t(remove_phi_arg_num): Delink the use node.\n+\t(remove_phi_node): Release the ssa_name AFTER releasing the phi node.\n+\t(remove_all_phi_nodes_for): Release phi node first.\n+\t* tree-pretty-print.c (dump_generic_node): Print stmt address.\n+\t* tree-sra.c (mark_all_v_defs): Call update_stmt_if_modified.\n+\t(scalarize_use, scalarize_copy): Call update_stmt.\n+\t* tree-ssa-alias.c (compute_may_aliases): Update all modified stmts.\n+\t(compute_points_to_and_addr_escape): Call mark_stmt_modified.\n+\t* tree-ssa-cpp.c (need_imm_uses_for): Delete.\n+\t(ccp_initialize): Remove call to compute_immediate_uses.\n+\t(substitute_and_fold, execute_fold_all_builtins): Call update_stmt.\n+\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Update all modified \n+\tstmts.\n+\t(simplify_cond_and_lookup_avail_expr): Call mark_stmt_modified.\n+\t(simplify_switch_and_lookup_avail_expr): Call mark_stmt_modified.\n+\t(eliminate_redundant_computations): Call mark_stmt_modified.\n+\t(cprop_operand): Call mark_stmt_modified.\n+\t(optimize_stmt): Call update_stmt_if_modified and mark_stmt_modified.\n+\t* tree-ssa-dse.c (fix_phi_uses, fix_stmt_v_may_defs): Delete.\n+\t(dse_optimize_stmt): Use new immuse interface.\n+\t(tree_ssa_dse): Remove calls to compute_immediate_uses and free_df.\n+\t* tree-ssa-forwprop.c (need_imm_uses_for): Delete.\n+\t(substitute_single_use_vars): Use new immuse interface.\n+\t(tree_ssa_forward_propagate_single_use_vars): Remove calls to free_df\n+\tand compute_immediate_uses.\n+\t* tree-ssa-loop-im.c (single_reachable_address): Use new immuse \n+\tinterface.\n+\t(rewrite_mem_refs): Call update_stmt.\n+\t(determine_lsm): Remove call to compute_imm_uses and free_df.\n+\t* tree-ssa-loop-ivcanon.c (create_canonical_iv): Call update_stmt.\n+\t(try_unroll_loop_completely): Call update_stmt.\n+\t* tree-ssa-loop-ivopts.c (rewrite_address_base): Call update_stmt.\n+\t(rewrite_use_compare): Call update_stmt.\n+\t(compute_phi_arg_on_exit): Insert each stmt before trying to process.\n+\t(rewrite_use) : Call update_stmt.\n+\t* tree-ssa-loop-manip.c (verify_loop_closed_ssa): Add arg to call.\n+\t* tree-ssa-loop-unswitch.c (tree_unswitch_single_loop): Call \n+\tupdate_stmt.\n+\t* tree-ssa-operands.c (NULL_USE_OPERAND_P): Remove declaration.\n+\t(allocate_use_optype, allocate_vuse_optype): Adjust allocation size.\n+\t(free_uses, free_vuses, free_v_may_defs, free_v_must_defs): Delink\n+\tuse nodes.\n+\t(initialize_vuse_operand): New.  Initialize a vuse operand.\n+\t(initialize_v_may_def_operand): New.  Initialize a maydef operand.\n+\t(initialize_v_must_def_operand): New.  Initialize a mustdef operand.\n+\t(finalize_ssa_defs): Use stmt parameter.\n+\t(correct_use_link): Ensure a use node is in the correct list, and has\n+\tthe correct stmt pointer.\n+\t(finalize_ssa_uses, finalize_ssa_v_may_defs, finalize_ssa_vuses,\n+\tfinalize_ssa_v_must_defs): Also initialize use nodes.\n+\t(finalize_ssa_stmt_operands): Pass extra stmt operands.\n+\t(build_ssa_operands): Seperate parsing from final operand construction.\n+\t(parse_ssa_operands): New.  Parse entry point for operand building.\n+\t(swap_tree_operands): New.  Swap 2 tree operands.\n+\t(update_stmt_operands): Ranamed from get_stmt_operands.  Always builds\n+\toperands.\n+\t(get_expr_operands): Call swap_tree_operands when needed.\n+\t(copy_virtual_operands): Use initialize routines for virtual use ops.\n+\t(create_ssa_artficial_load_stmt): Add extra stmt parameter.\n+\t(verify_abort): New.  Issue imm_use error.\n+\t(verify_imm_links): New Verify imm_use links for a var.\n+\t(dump_immediate_uses_for): New.  Dump imm_uses for a var to file.\n+\t(dump_immediate_uses): New.  Dump imm_uses for all vars to file.\n+\t(debug_immediate_uses): New.  Dump imm_uses for all vars to stderr.\n+\t(debug_immediate_uses_for): New.  Dump imm_uses for a var to stderr.\n+\t* tree-ssa-operands.h (struct use_operand_ptr): Delete.\n+\t(NULL_USE_OPERAND_P) Define.\n+\t(use_optype_d, v_def_use_operand_type, vuse_optype_d): Add immediate\n+\tuse node.\n+\t(struct vuse_operand_type): New struct.\n+\t(SET_USE): Call set_ssa_use_from_ptr.\n+\t(USE_STMT): Define.\n+\t(PHI_ARG_INDEX_FROM_USE): Define.\n+\t* tree-ssa-phiopt.c (replace_phi_edge_with_variable): Set the phi \n+\targument via SET_USE, not PHI_ARG_DEF_TREE.\n+\t* tree-ssa-pre.c (eliminate): Call update_stmt.\n+\t* tree-ssa-propagate.c (cfg_blocks_get): Use imm_use iterators.  Don't\n+\tcall free_df.\n+\t* tree-ssa-sink.c (all_immediate_uses_same_place): Use imm_use iterator.\n+\t(nearest_common_dominator_of_uses): Use imm_use iterator.\n+\t(statement_sink_location): Use imm_use iterator and interface.\n+\t(execute_sink_code): Don't call compute_immediate_uses or free-df.\n+\t* tree-ssa-threadupdate.c (create_edge_and_update_destination_phis): Use\n+\tPHI_ARG_DEF, not PHI_ARG_DEF_TREE.\n+\t* tree-ssa.c (verify_use, verify_phi_args): Verify some imm_use info.\n+\t(verify_ssa): Ensure no stmt is marked modify after optimization pass\n+\tif new parameter is true.\n+\t(init_tree_ssa): Don't initialize operand cache here.\n+\t(delete_tree_ssa): Don't destroy operand cache here.\n+\t(propagate_into_addr): Pass in a use pointer, return true if anything\n+\twas changed.\n+\t(replace_immediate_uses): Use imm_use iterator, call update_stmt.\n+\t(check_phi_redundancy): Use imm_use iterator.\n+\t(kill_redundant_phi_nodes): Don't call compute_immediate_uses or \n+\tfree_df.\n+\t* tree-ssanames.c (make_ssa_name): Initialize imm_use node.\n+\t(release_ssa_name): Delink node and all elements in its imm_use list.\n+\t* tree-tailcall.c (adjust_return_value): Call update_stmt.\n+\t* tree-vect-analyze.c (vect_stmt_relevant_p): Use imm_use iterator.\n+\t* tree-vectorizer.c (need_imm_uses_for): Delete.\n+\t(vectorize_loops): Dont call compute_immediate_uses or free_df.\n+\t* tree.h (struct ssa_imm_use_d): Define.\n+\t(SSA_NAME_IMM_USE_NODE): Define.\n+\t(struct tree_ssa_name): Add imm_use node.\n+\t(PHI_DF): Delete.\n+\t(PHI_ARG_IMM_USE_NODE): Define.\n+\t(struct phi_arg_d): Add imm_use node.\n+\t(struct tree_phi_node): Remove struct dataflow_d element.\n+\t(TDF_STMTADDR): Define.\n+\n 2005-04-05  Dale Johannesen  <dalej@apple.com>\n \n \t* doc/invoke.texi (Optimization Options):  Remove"}, {"sha": "80e5478ec0d1417805385a9bb7db04ce456548c4", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -1939,7 +1939,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       COND_EXPR_COND (exitcond) = build (testtype,\n \t\t\t\t\t boolean_type_node,\n \t\t\t\t\t newupperbound, ivvarinced);\n-      modify_stmt (exitcond);\n+      update_stmt (exitcond);\n       VEC_replace (tree, new_ivs, i, ivvar);\n \n       i++;\n@@ -1951,11 +1951,21 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \n   for (i = 0; VEC_iterate (tree, old_ivs, i, oldiv); i++)\n     {\n-      int j;\n-      dataflow_t imm = get_immediate_uses (SSA_NAME_DEF_STMT (oldiv));\n-      for (j = 0; j < num_immediate_uses (imm); j++)\n+      imm_use_iterator imm_iter;\n+      use_operand_p imm_use;\n+      tree oldiv_def;\n+      tree oldiv_stmt = SSA_NAME_DEF_STMT (oldiv);\n+\n+      gcc_assert (TREE_CODE (oldiv_stmt) == PHI_NODE\n+\t\t  || NUM_DEFS (STMT_DEF_OPS (oldiv_stmt)) == 1);\n+      if (TREE_CODE (oldiv_stmt) == PHI_NODE)\n+\toldiv_def = PHI_RESULT (oldiv_stmt);\n+      else\n+\toldiv_def = DEF_OP (STMT_DEF_OPS (oldiv_stmt), 0);\n+\n+      FOR_EACH_IMM_USE_SAFE (imm_use, imm_iter, oldiv_def)\n \t{\n-\t  tree stmt = immediate_use (imm, j);\n+\t  tree stmt = USE_STMT (imm_use);\n \t  use_operand_p use_p;\n \t  ssa_op_iter iter;\n \t  gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n@@ -1980,7 +1990,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t\t     expression.  */\n \t\t  bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n \t\t  propagate_value (use_p, newiv);\n-\t\t  modify_stmt (stmt);\n+\t\t  update_stmt (stmt);\n \t\t  \n \t\t}\n \t    }\n@@ -2067,16 +2077,15 @@ stmt_is_bumper_for_loop (struct loop *loop, tree stmt)\n   tree use;\n   tree def;\n   def_optype defs = STMT_DEF_OPS (stmt);\n-  dataflow_t imm;\n-  int i;\n+  imm_use_iterator iter;\n+  use_operand_p use_p;\n   \n   if (NUM_DEFS (defs) != 1)\n     return false;\n   def = DEF_OP (defs, 0);\n-  imm = get_immediate_uses (stmt);\n-  for (i = 0; i < num_immediate_uses (imm); i++)\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, def)\n     {\n-      use = immediate_use (imm, i);\n+      use = USE_STMT (use_p);\n       if (TREE_CODE (use) == PHI_NODE)\n \t{\n \t  if (phi_loop_edge_uses_def (loop, use, def))"}, {"sha": "961a39526a15c3f6ec185c011240597892c73156", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -1013,7 +1013,7 @@ strip_builtin_expect (void)\n \t      && TREE_CHAIN (arglist))\n \t    {\n \t      TREE_OPERAND (stmt, 1) = TREE_VALUE (arglist);\n-\t      modify_stmt (stmt);\n+\t      update_stmt (stmt);\n \t    }\n \t}\n     }"}, {"sha": "bb8e256a50f18c76952a58da5cafd762bbb90d7e", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -3023,6 +3023,24 @@ bsi_for_stmt (tree stmt)\n   gcc_unreachable ();\n }\n \n+/* Mark statement T as modified, and update it.  */\n+static inline void\n+update_modified_stmts (tree t)\n+{\n+  if (TREE_CODE (t) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator i;\n+      tree stmt;\n+      for (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n+        {\n+\t  stmt = tsi_stmt (i);\n+\t  update_stmt_if_modified (stmt);\n+\t}\n+    }\n+  else\n+    update_stmt_if_modified (t);\n+}\n+\n /* Insert statement (or statement list) T before the statement\n    pointed-to by iterator I.  M specifies how to update iterator I\n    after insertion (see enum bsi_iterator_update).  */\n@@ -3031,8 +3049,8 @@ void\n bsi_insert_before (block_stmt_iterator *i, tree t, enum bsi_iterator_update m)\n {\n   set_bb_for_stmt (t, i->bb);\n+  update_modified_stmts (t);\n   tsi_link_before (&i->tsi, t, m);\n-  modify_stmt (t);\n }\n \n \n@@ -3044,8 +3062,8 @@ void\n bsi_insert_after (block_stmt_iterator *i, tree t, enum bsi_iterator_update m)\n {\n   set_bb_for_stmt (t, i->bb);\n+  update_modified_stmts (t);\n   tsi_link_after (&i->tsi, t, m);\n-  modify_stmt (t);\n }\n \n \n@@ -3057,7 +3075,9 @@ bsi_remove (block_stmt_iterator *i)\n {\n   tree t = bsi_stmt (*i);\n   set_bb_for_stmt (t, NULL);\n+  delink_stmt_imm_use (t);\n   tsi_delink (&i->tsi);\n+  mark_stmt_modified (t);\n }\n \n \n@@ -3121,7 +3141,8 @@ bsi_replace (const block_stmt_iterator *bsi, tree stmt, bool preserve_eh_info)\n     }\n \n   *bsi_stmt_ptr (*bsi) = stmt;\n-  modify_stmt (stmt);\n+  mark_stmt_modified (stmt);\n+  update_modified_stmts (stmt);\n }\n \n "}, {"sha": "e673aed4fce13a305b33fe9fb1d18ef87d7cd25a", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -84,7 +84,7 @@ update_complex_assignment (block_stmt_iterator *bsi, tree r, tree i)\n   \n   type = TREE_TYPE (TREE_OPERAND (stmt, 1));\n   TREE_OPERAND (stmt, 1) = build (COMPLEX_EXPR, type, r, i);\n-  modify_stmt (stmt);\n+  mark_stmt_modified (stmt);\n }\n \n /* Expand complex addition to scalars:\n@@ -136,7 +136,7 @@ expand_complex_libcall (block_stmt_iterator *bsi, tree ar, tree ai,\n \n   TREE_OPERAND (stmt, 1)\n     = build3 (CALL_EXPR, type, build_fold_addr_expr (fn), args, NULL);\n-  modify_stmt (stmt);\n+  update_stmt (stmt);\n }\n \n /* Expand complex multiplication to scalars:\n@@ -439,7 +439,7 @@ expand_complex_comparison (block_stmt_iterator *bsi, tree ar, tree ai,\n       gcc_unreachable ();\n     }\n \n-  modify_stmt (stmt);\n+  mark_stmt_modified (stmt);\n }\n \n /* Process one statement.  If we identify a complex operation, expand it.  */\n@@ -561,6 +561,7 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n     default:\n       gcc_unreachable ();\n     }\n+  update_stmt_if_modified (stmt);\n }\n \f\n /* Build a constant of type TYPE, made of VALUE's bits replicated\n@@ -931,7 +932,7 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n         *p_rhs = expand_vector_addition (bsi, do_binop, do_plus_minus, type,\n \t\t      \t\t         TREE_OPERAND (rhs, 0),\n \t\t\t\t         TREE_OPERAND (rhs, 1), code);\n-\tmodify_stmt (bsi_stmt (*bsi));\n+\tmark_stmt_modified (bsi_stmt (*bsi));\n         return;\n \n       case NEGATE_EXPR:\n@@ -941,7 +942,7 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n         *p_rhs = expand_vector_addition (bsi, do_unop, do_negate, type,\n \t\t      \t\t         TREE_OPERAND (rhs, 0),\n \t\t\t\t\t NULL_TREE, code);\n-\tmodify_stmt (bsi_stmt (*bsi));\n+\tmark_stmt_modified (bsi_stmt (*bsi));\n         return;\n \n       case BIT_AND_EXPR:\n@@ -950,14 +951,14 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n         *p_rhs = expand_vector_parallel (bsi, do_binop, type,\n \t\t      \t\t         TREE_OPERAND (rhs, 0),\n \t\t\t\t         TREE_OPERAND (rhs, 1), code);\n-\tmodify_stmt (bsi_stmt (*bsi));\n+\tmark_stmt_modified (bsi_stmt (*bsi));\n         return;\n \n       case BIT_NOT_EXPR:\n         *p_rhs = expand_vector_parallel (bsi, do_unop, type,\n \t\t      \t\t         TREE_OPERAND (rhs, 0),\n \t\t\t\t\t NULL_TREE, code);\n-\tmodify_stmt (bsi_stmt (*bsi));\n+\tmark_stmt_modified (bsi_stmt (*bsi));\n         return;\n \n       default:\n@@ -973,7 +974,7 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n \t\t\t\t      TREE_OPERAND (rhs, 0),\n \t\t\t\t      TREE_OPERAND (rhs, 1), code);\n \n-  modify_stmt (bsi_stmt (*bsi));\n+  mark_stmt_modified (bsi_stmt (*bsi));\n }\n \f\n static void"}, {"sha": "38d60c0a13687021c038a682200733c416436252", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 335, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -77,11 +77,8 @@ struct walk_state\n /* Local functions.  */\n static void collect_dfa_stats (struct dfa_stats_d *);\n static tree collect_dfa_stats_r (tree *, int *, void *);\n-static void add_immediate_use (tree, tree);\n static tree find_vars_r (tree *, int *, void *);\n static void add_referenced_var (tree, struct walk_state *);\n-static void compute_immediate_uses_for_phi (tree, bool (*)(tree));\n-static void compute_immediate_uses_for_stmt (tree, int, bool (*)(tree));\n \n \n /* Global declarations.  */\n@@ -141,263 +138,6 @@ struct tree_opt_pass pass_referenced_vars =\n };\n \n \n-/* Compute immediate uses.\n-\n-   CALC_FOR is an optional function pointer which indicates whether\n-      immediate uses information should be calculated for a given SSA\n-      variable.  If NULL, then information is computed for all\n-      variables.\n-\n-   FLAGS is one of {TDFA_USE_OPS, TDFA_USE_VOPS}.  It is used by\n-      compute_immediate_uses_for_stmt to determine whether to look at\n-      virtual and/or real operands while computing def-use chains.  */\n-\n-void\n-compute_immediate_uses (int flags, bool (*calc_for)(tree))\n-{\n-  basic_block bb;\n-  block_stmt_iterator si;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      tree phi;\n-\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  if (is_gimple_reg (PHI_RESULT (phi)))\n-\t    {\n-\t      if (!(flags & TDFA_USE_OPS))\n-\t\tcontinue;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (!(flags & TDFA_USE_VOPS))\n-\t\tcontinue;\n-\t    }\n-\n-\t  compute_immediate_uses_for_phi (phi, calc_for);\n-\t}\n-\n-      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n-        {\n-\t  tree stmt = bsi_stmt (si);\n-\t  get_stmt_operands (stmt);\n-\t  compute_immediate_uses_for_stmt (stmt, flags, calc_for);\n-\t}\n-    }\n-}\n-\n-\n-/* Invalidates dataflow information for a statement STMT.  */\n-\n-void\n-free_df_for_stmt (tree stmt)\n-{\n-  dataflow_t *df;\n-\n-  if (TREE_CODE (stmt) == PHI_NODE)\n-    df = &PHI_DF (stmt);\n-  else\n-    {\n-      stmt_ann_t ann = stmt_ann (stmt);\n-\n-      if (!ann)\n-\treturn;\n-\n-      df = &ann->df;\n-    }\n-\n-  if (!*df)\n-    return;\n-      \n-  /* If we have a varray of immediate uses, then go ahead and release\n-     it for re-use.  */\n-  if ((*df)->immediate_uses)\n-    ggc_free ((*df)->immediate_uses);\n-\n-  /* Similarly for the main dataflow structure.  */\n-  ggc_free (*df);\n-  *df = NULL;\n-}\n-\n-\n-/* Invalidate dataflow information for the whole function. \n-\n-   Note this only invalidates dataflow information on statements and\n-   PHI nodes which are reachable.\n-\n-   A deleted statement may still have attached dataflow information\n-   on it.  */\n-\n-void\n-free_df (void)\n-{\n-  basic_block bb;\n-  block_stmt_iterator si;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      tree phi;\n-\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\tfree_df_for_stmt (phi);\n-\n-      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n-        {\n-\t  tree stmt = bsi_stmt (si);\n-\t  free_df_for_stmt (stmt);\n-\t}\n-    }\n-}\n-\n-\n-/* Helper for compute_immediate_uses.  Check all the USE and/or VUSE\n-   operands in phi node PHI and add a def-use edge between their\n-   defining statement and PHI.  CALC_FOR is as in\n-   compute_immediate_uses.\n-\n-   PHI nodes are easy, we only need to look at their arguments.  */\n-\n-static void\n-compute_immediate_uses_for_phi (tree phi, bool (*calc_for)(tree))\n-{\n-  int i;\n-\n-  gcc_assert (TREE_CODE (phi) == PHI_NODE);\n-\n-  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-    {\n-      tree arg = PHI_ARG_DEF (phi, i);\n-\n-      if (TREE_CODE (arg) == SSA_NAME && (!calc_for || calc_for (arg)))\n-\t{\n-\t  tree imm_rdef_stmt = SSA_NAME_DEF_STMT (PHI_ARG_DEF (phi, i));\n-\t  if (!IS_EMPTY_STMT (imm_rdef_stmt))\n-\t    add_immediate_use (imm_rdef_stmt, phi);\n-\t}\n-    }\n-}\n-\n-\n-/* Another helper for compute_immediate_uses.  Depending on the value\n-   of FLAGS, check all the USE and/or VUSE operands in STMT and add a\n-   def-use edge between their defining statement and STMT.  CALC_FOR\n-   is as in compute_immediate_uses.  */\n-\n-static void\n-compute_immediate_uses_for_stmt (tree stmt, int flags, bool (*calc_for)(tree))\n-{\n-  tree use;\n-  ssa_op_iter iter;\n-\n-  /* PHI nodes are handled elsewhere.  */\n-  gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n-\n-  /* Look at USE_OPS or VUSE_OPS according to FLAGS.  */\n-  if (flags & TDFA_USE_OPS)\n-    {\n-      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n-\t{\n-\t  tree imm_stmt = SSA_NAME_DEF_STMT (use);\n-\t  if (!IS_EMPTY_STMT (imm_stmt) && (!calc_for || calc_for (use)))\n-\t    add_immediate_use (imm_stmt, stmt);\n-\t}\n-    }\n-\n-  if (flags & TDFA_USE_VOPS)\n-    {\n-      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_VIRTUAL_USES)\n-\t{\n-\t  tree imm_rdef_stmt = SSA_NAME_DEF_STMT (use);\n-\t  if (!IS_EMPTY_STMT (imm_rdef_stmt) && (!calc_for || calc_for (use)))\n-\t    add_immediate_use (imm_rdef_stmt, stmt);\n-\t}\n-      \n-      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_KILLS)\n-\t{\n-\t  tree imm_rdef_stmt = SSA_NAME_DEF_STMT (use);\n-\t  if (!IS_EMPTY_STMT (imm_rdef_stmt) && (!calc_for || calc_for (use)))\n-\t    add_immediate_use (imm_rdef_stmt, stmt);\n-\t}\n-    }  \n-}\n-\n-\n-/* Add statement USE_STMT to the list of statements that use definitions\n-    made by STMT.  */\n-\n-static void\n-add_immediate_use (tree stmt, tree use_stmt)\n-{\n-  struct dataflow_d **df;\n-\n-  if (TREE_CODE (stmt) == PHI_NODE)\n-    df = &PHI_DF (stmt);\n-  else\n-    {\n-      stmt_ann_t ann = get_stmt_ann (stmt);\n-      df = &ann->df;\n-    }\n-\n-  if (*df == NULL)\n-    {\n-      *df = ggc_alloc (sizeof (struct dataflow_d));\n-      memset ((void *) *df, 0, sizeof (struct dataflow_d));\n-      (*df)->uses[0] = use_stmt;\n-      return;\n-    }\n-\n-  if (!(*df)->uses[1])\n-    {\n-      (*df)->uses[1] = use_stmt;\n-      return;\n-    }\n-\n-  if ((*df)->immediate_uses == NULL)\n-    VARRAY_TREE_INIT ((*df)->immediate_uses, 4, \"immediate_uses\");\n-\n-  VARRAY_PUSH_TREE ((*df)->immediate_uses, use_stmt);\n-}\n-\n-\n-/* If the immediate use of USE points to OLD, then redirect it to NEW.  */\n-\n-static void\n-redirect_immediate_use (tree use, tree old, tree new)\n-{\n-  tree imm_stmt = SSA_NAME_DEF_STMT (use);\n-  struct dataflow_d *df = get_immediate_uses (imm_stmt);\n-  unsigned int num_uses = num_immediate_uses (df);\n-  unsigned int i;\n-\n-  for (i = 0; i < num_uses; i++)\n-    {\n-      if (immediate_use (df, i) == old)\n-\t{\n-\t  if (i == 0 || i == 1)\n-\t    df->uses[i] = new;\n-\t  else\n-\t    VARRAY_TREE (df->immediate_uses, i - 2) = new;\n-\t}\n-    }\n-}\n-\n-\n-/* Redirect all immediate uses for operands in OLD so that they point\n-   to NEW.  This routine should have no knowledge of how immediate\n-   uses are stored.  */\n-\n-void\n-redirect_immediate_uses (tree old, tree new)\n-{\n-  ssa_op_iter iter;\n-  tree val;\n-\n-  FOR_EACH_SSA_TREE_OPERAND (val, old, iter, SSA_OP_ALL_USES)\n-    redirect_immediate_use (val, old, new);\n-}\n-\n-\n /*---------------------------------------------------------------------------\n \t\t\t    Manage annotations\n ---------------------------------------------------------------------------*/\n@@ -590,79 +330,6 @@ debug_variable (tree var)\n }\n \n \n-/* Dump def-use edges on FILE.  */\n-\n-void\n-dump_immediate_uses (FILE *file)\n-{\n-  basic_block bb;\n-  block_stmt_iterator si;\n-  const char *funcname\n-    = lang_hooks.decl_printable_name (current_function_decl, 2);\n-\n-  fprintf (file, \"\\nDef-use edges for function %s\\n\", funcname);\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      tree phi;\n-\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\tdump_immediate_uses_for (file, phi);\n-\n-      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n-\tdump_immediate_uses_for (file, bsi_stmt (si));\n-    }\n-\n-  fprintf (file, \"\\n\");\n-}\n-\n-\n-/* Dump def-use edges on stderr.  */\n-\n-void\n-debug_immediate_uses (void)\n-{\n-  dump_immediate_uses (stderr);\n-}\n-\n-\n-/* Dump all immediate uses for STMT on FILE.  */\n-\n-void\n-dump_immediate_uses_for (FILE *file, tree stmt)\n-{\n-  dataflow_t df = get_immediate_uses (stmt);\n-  int num_imm_uses = num_immediate_uses (df);\n-\n-  if (num_imm_uses > 0)\n-    {\n-      int i;\n-\n-      fprintf (file, \"-> \");\n-      print_generic_stmt (file, stmt, TDF_SLIM);\n-      fprintf (file, \"\\n\");\n-\n-      for (i = 0; i < num_imm_uses; i++)\n-\t{\n-\t  fprintf (file, \"\\t\");\n-\t  print_generic_stmt (file, immediate_use (df, i), TDF_SLIM);\n-\t  fprintf (file, \"\\n\");\n-\t}\n-\n-      fprintf (file, \"\\n\");\n-    }\n-}\n-\n-\n-/* Dump immediate uses for STMT on stderr.  */\n-\n-void\n-debug_immediate_uses_for (tree stmt)\n-{\n-  dump_immediate_uses_for (stderr, stmt);\n-}\n-\n-\n /* Dump various DFA statistics to FILE.  */\n \n void\n@@ -987,8 +654,7 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n \n   /* Now force an operand re-scan on the statement and mark any newly\n      exposed variables.  */\n-  modify_stmt (stmt);\n-  get_stmt_operands (stmt);\n+  update_stmt (stmt);\n \n   v_may_defs_after = NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt));\n   v_must_defs_after = NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt));"}, {"sha": "d636c0c45cc607e374a0b64828e0145b9b74acb5", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -745,7 +745,9 @@ static const struct dump_option_value_info dump_options[] =\n   {\"vops\", TDF_VOPS},\n   {\"lineno\", TDF_LINENO},\n   {\"uid\", TDF_UID},\n-  {\"all\", ~(TDF_RAW | TDF_SLIM | TDF_LINENO | TDF_TREE | TDF_RTL | TDF_IPA)},\n+  {\"stmtaddr\", TDF_STMTADDR},\n+  {\"all\", ~(TDF_RAW | TDF_SLIM | TDF_LINENO | TDF_TREE | TDF_RTL | TDF_IPA \n+\t    | TDF_STMTADDR)},\n   {NULL, 0}\n };\n "}, {"sha": "d43812ef0fcce3b693fbcc03a44e188663309956", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 377, "deletions": 70, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -141,24 +141,56 @@ noreturn_call_p (tree t)\n \n /* Mark statement T as modified.  */\n static inline void\n-modify_stmt (tree t)\n+mark_stmt_modified (tree t)\n {\n-  stmt_ann_t ann = stmt_ann (t);\n+  stmt_ann_t ann;\n+  if (TREE_CODE (t) == PHI_NODE)\n+    return;\n+\n+  ann = stmt_ann (t);\n   if (ann == NULL)\n     ann = create_stmt_ann (t);\n   else if (noreturn_call_p (t))\n     VEC_safe_push (tree, modified_noreturn_calls, t);\n   ann->modified = 1;\n }\n \n-/* Mark statement T as unmodified.  */\n+/* Mark statement T as modified, and update it.  */\n static inline void\n-unmodify_stmt (tree t)\n+update_stmt (tree t)\n {\n-  stmt_ann_t ann = stmt_ann (t);\n-  if (ann == NULL)\n-    ann = create_stmt_ann (t);\n-  ann->modified = 0;\n+  if (TREE_CODE (t) == PHI_NODE)\n+    return;\n+  mark_stmt_modified (t);\n+  update_stmt_operands (t);\n+}\n+\n+static inline void\n+update_stmt_if_modified (tree t)\n+{\n+  if (stmt_modified_p (t))\n+    update_stmt_operands (t);\n+}\n+\n+static inline void \n+get_stmt_operands (tree stmt ATTRIBUTE_UNUSED)\n+{\n+#ifdef ENABLE_CHECKING\n+  stmt_ann_t ann;\n+                                                                                \n+  /* The optimizers cannot handle statements that are nothing but a\n+     _DECL.  This indicates a bug in the gimplifier.  */\n+  gcc_assert (!SSA_VAR_P (stmt));\n+                                                                                \n+  /* Ignore error statements.  */\n+  if (TREE_CODE (stmt) == ERROR_MARK)\n+    return;\n+                                                                                \n+  ann = get_stmt_ann (stmt);\n+  gcc_assert (!ann->modified);\n+\n+  return;\n+#endif\n }\n \n /* Return true if T is marked as modified, false otherwise.  */\n@@ -168,11 +200,286 @@ stmt_modified_p (tree t)\n   stmt_ann_t ann = stmt_ann (t);\n \n   /* Note that if the statement doesn't yet have an annotation, we consider it\n-     modified.  This will force the next call to get_stmt_operands to scan the\n-     statement.  */\n+     modified.  This will force the next call to update_stmt_operands to scan \n+     the statement.  */\n   return ann ? ann->modified : true;\n }\n \n+/* Delink an immediate_uses node from its chain.  */\n+static inline void\n+delink_imm_use (ssa_imm_use_t *linknode)\n+{\n+  /* Return if this node is not in a list.  */\n+  if (linknode->prev == NULL)\n+    return;\n+\n+  linknode->prev->next = linknode->next;\n+  linknode->next->prev = linknode->prev;\n+  linknode->prev = NULL;\n+  linknode->next = NULL;\n+}\n+\n+/* Link ssa_imm_use node LINKNODE into the chain for LIST.  */\n+static inline void\n+link_imm_use_to_list (ssa_imm_use_t *linknode, ssa_imm_use_t *list)\n+{\n+  /* Link the new node at the head of the list.  If we are in the process of \n+     traversing the list, we wont visit any new nodes added to it.  */\n+  linknode->prev = list;\n+  linknode->next = list->next;\n+  list->next->prev = linknode;\n+  list->next = linknode;\n+}\n+\n+/* Link ssa_imm_use node LINKNODE into the chain for DEF.  */\n+static inline void\n+link_imm_use (ssa_imm_use_t *linknode, tree def)\n+{\n+  ssa_imm_use_t *root;\n+\n+  if (!def || TREE_CODE (def) != SSA_NAME)\n+    linknode->prev = NULL;\n+  else\n+    {\n+      root = &(SSA_NAME_IMM_USE_NODE (def));\n+#ifdef ENABLE_CHECKING\n+      if (linknode->use)\n+        gcc_assert (*(linknode->use) == def);\n+#endif\n+      link_imm_use_to_list (linknode, root);\n+    }\n+}\n+\n+/* Set the value of a use pointed by USE to VAL.  */\n+static inline void\n+set_ssa_use_from_ptr (use_operand_p use, tree val)\n+{\n+  delink_imm_use (use);\n+  *(use->use) = val;\n+  link_imm_use (use, val);\n+}\n+\n+/* Link ssa_imm_use node LINKNODE into the chain for DEF, with use occuring \n+   in STMT.  */\n+static inline void\n+link_imm_use_stmt (ssa_imm_use_t *linknode, tree def, tree stmt)\n+{\n+  if (stmt)\n+    link_imm_use (linknode, def);\n+  else\n+    link_imm_use (linknode, NULL);\n+  linknode->stmt = stmt;\n+}\n+\n+/* Relink a new node in place of an old node in the list.  */\n+static inline void\n+relink_imm_use (ssa_imm_use_t *node, ssa_imm_use_t *old)\n+{\n+#ifdef ENABLE_CHECKING\n+  /* The node one had better be in the same list.  */\n+  if (*(old->use) != *(node->use))\n+    abort ();\n+#endif\n+  node->prev = old->prev;\n+  node->next = old->next;\n+  if (old->prev)\n+    {\n+      old->prev->next = node;\n+      old->next->prev = node;\n+      /* Remove the old node from the list.  */\n+      old->prev = NULL;\n+    }\n+\n+}\n+\n+/* Relink ssa_imm_use node LINKNODE into the chain for OLD, with use occuring \n+   in STMT.  */\n+static inline void\n+relink_imm_use_stmt (ssa_imm_use_t *linknode, ssa_imm_use_t *old, tree stmt)\n+{\n+  if (stmt)\n+    relink_imm_use (linknode, old);\n+  else\n+    link_imm_use (linknode, NULL);\n+  linknode->stmt = stmt;\n+}\n+\n+/* Finished the traverse of an immediate use list IMM by removing it from \n+   the list.  */\n+static inline void\n+end_safe_imm_use_traverse (imm_use_iterator *imm)\n+{\n+ delink_imm_use (&(imm->iter_node));\n+}\n+\n+/* Return true if IMM is at the end of the list.  */\n+static inline bool\n+end_safe_imm_use_p (imm_use_iterator *imm)\n+{\n+  return (imm->imm_use == imm->end_p);\n+}\n+\n+/* Initialize iterator IMM to process the list for VAR.  */\n+static inline use_operand_p\n+first_safe_imm_use (imm_use_iterator *imm, tree var)\n+{\n+  /* Set up and link the iterator node into the linked list for VAR.  */\n+  imm->iter_node.use = NULL;\n+  imm->iter_node.stmt = NULL_TREE;\n+  imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n+  /* Check if there are 0 elements.  */\n+  if (imm->end_p->next == imm->end_p)\n+    {\n+      imm->imm_use = imm->end_p;\n+      return NULL_USE_OPERAND_P;\n+    }\n+\n+  link_imm_use (&(imm->iter_node), var);\n+  imm->imm_use = imm->iter_node.next;\n+  return imm->imm_use;\n+}\n+\n+/* Bump IMM to then next use in the list.  */\n+static inline use_operand_p\n+next_safe_imm_use (imm_use_iterator *imm)\n+{\n+  ssa_imm_use_t *ptr;\n+  use_operand_p old;\n+\n+  old = imm->imm_use;\n+  /* If the next node following the iter_node is still the one refered to by\n+     imm_use, then the list hasnt changed, go to the next node.  */\n+  if (imm->iter_node.next == imm->imm_use)\n+    {\n+      ptr = &(imm->iter_node);\n+      /* Remove iternode fromn the list.  */\n+      delink_imm_use (ptr);\n+      imm->imm_use = imm->imm_use->next;\n+      if (! end_safe_imm_use_p (imm))\n+\t{\n+\t  /* This isnt the end, link iternode before the next use.  */\n+\t  ptr->prev = imm->imm_use->prev;\n+\t  ptr->next = imm->imm_use;\n+\t  imm->imm_use->prev->next = ptr;\n+\t  imm->imm_use->prev = ptr;\n+\t}\n+      else\n+\treturn old;\n+    }\n+  else\n+    {\n+      /* If the 'next' value after the iterator isn't the same as it was, then\n+\t a node has been deleted, so we sinply proceed to the node following \n+\t where the iterator is in the list.  */\n+      imm->imm_use = imm->iter_node.next;\n+      if (end_safe_imm_use_p (imm))\n+        {\n+\t  end_safe_imm_use_traverse (imm);\n+\t  return old;\n+\t}\n+    }\n+\n+  return imm->imm_use;\n+}\n+\n+/* Return true is IMM has reached the end of the immeidate use list.  */\n+static inline bool\n+end_readonly_imm_use_p (imm_use_iterator *imm)\n+{\n+  return (imm->imm_use == imm->end_p);\n+}\n+\n+/* Initialize iterator IMM to process the list for VAR.  */\n+static inline use_operand_p\n+first_readonly_imm_use (imm_use_iterator *imm, tree var)\n+{\n+  gcc_assert (TREE_CODE (var) == SSA_NAME);\n+\n+  imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n+  imm->imm_use = imm->end_p->next;\n+#ifdef ENABLE_CHECKING\n+  imm->iter_node.next = imm->imm_use->next;\n+#endif\n+  if (end_readonly_imm_use_p (imm))\n+    return NULL_USE_OPERAND_P;\n+  return imm->imm_use;\n+}\n+\n+/* Bump IMM to then next use in the list.  */\n+static inline use_operand_p\n+next_readonly_imm_use (imm_use_iterator *imm)\n+{\n+  use_operand_p old = imm->imm_use;\n+\n+#ifdef ENABLE_CHECKING\n+  /* If this assertion fails, it indicates the 'next' pointer has changed \n+     since we the last bump.  This indicates that the list is being modified\n+     via stmt changes, or SET_USE, or somesuch thing, and you need to be\n+     using the SAFE version of the iterator.  */\n+  gcc_assert (imm->iter_node.next == old->next);\n+  imm->iter_node.next = old->next->next;\n+#endif\n+\n+  imm->imm_use = old->next;\n+  if (end_readonly_imm_use_p (imm))\n+    return old;\n+  return imm->imm_use;\n+}\n+\n+/* Return true if VAR has no uses.  */\n+static inline bool\n+has_zero_uses (tree var)\n+{\n+  ssa_imm_use_t *ptr;\n+  ptr = &(SSA_NAME_IMM_USE_NODE (var));\n+  /* A single use means there is no items in the list.  */\n+  return (ptr == ptr->next);\n+}\n+\n+/* Return true if VAR has a single use.  */\n+static inline bool\n+has_single_use (tree var)\n+{\n+  ssa_imm_use_t *ptr;\n+  ptr = &(SSA_NAME_IMM_USE_NODE (var));\n+  /* A single use means there is one item in the list.  */\n+  return (ptr != ptr->next && ptr == ptr->next->next);\n+}\n+\n+/* If VAR has only a single immediate use, return true, and set USE_P and STMT\n+   to the use pointer and stmt of occurence.  */\n+static inline bool\n+single_imm_use (tree var, use_operand_p *use_p, tree *stmt)\n+{\n+  ssa_imm_use_t *ptr;\n+\n+  ptr = &(SSA_NAME_IMM_USE_NODE (var));\n+  if (ptr != ptr->next && ptr == ptr->next->next)\n+    {\n+      *use_p = ptr->next;\n+      *stmt = ptr->next->stmt;\n+      return true;\n+    }\n+  *use_p = NULL_USE_OPERAND_P;\n+  *stmt = NULL_TREE;\n+  return false;\n+}\n+\n+/* Return the number of immediate uses of VAR.  */\n+static inline unsigned int\n+num_imm_uses (tree var)\n+{\n+  ssa_imm_use_t *ptr, *start;\n+  unsigned int num;\n+\n+  start = &(SSA_NAME_IMM_USE_NODE (var));\n+  num = 0;\n+  for (ptr = start->next; ptr != start; ptr = ptr->next)\n+     num++;\n+\n+  return num;\n+}\n+\n /* Return the definitions present in ANN, a statement annotation.\n    Return NULL if this annotation contains no definitions.  */\n static inline def_optype\n@@ -218,7 +525,7 @@ get_v_must_def_ops (stmt_ann_t ann)\n static inline tree\n get_use_from_ptr (use_operand_p use)\n { \n-  return *(use.use);\n+  return *(use->use);\n } \n \n /* Return the tree pointer to by DEF.  */\n@@ -233,7 +540,7 @@ static inline use_operand_p\n get_use_op_ptr (use_optype uses, unsigned int index)\n {\n   gcc_assert (index < uses->num_uses);\n-  return uses->uses[index];\n+  return &(uses->uses[index]);\n }\n \n /* Return a def_operand_p pointer for element INDEX of DEFS.  */\n@@ -244,7 +551,6 @@ get_def_op_ptr (def_optype defs, unsigned int index)\n   return defs->defs[index];\n }\n \n-\n /* Return the def_operand_p that is the V_MAY_DEF_RESULT for the V_MAY_DEF\n    at INDEX in the V_MAY_DEFS array.  */\n static inline def_operand_p\n@@ -261,20 +567,16 @@ get_v_may_def_result_ptr(v_may_def_optype v_may_defs, unsigned int index)\n static inline use_operand_p\n get_v_may_def_op_ptr(v_may_def_optype v_may_defs, unsigned int index)\n {\n-  use_operand_p op;\n   gcc_assert (index < v_may_defs->num_v_may_defs);\n-  op.use = &(v_may_defs->v_may_defs[index].use);\n-  return op;\n+  return &(v_may_defs->v_may_defs[index].imm_use);\n }\n \n /* Return a use_operand_p that is at INDEX in the VUSES array.  */\n static inline use_operand_p\n get_vuse_op_ptr(vuse_optype vuses, unsigned int index)\n {\n-  use_operand_p op;\n   gcc_assert (index < vuses->num_vuses);\n-  op.use = &(vuses->vuses[index]);\n-  return op;\n+  return &(vuses->vuses[index].imm_use);\n }\n \n /* Return a def_operand_p that is the V_MUST_DEF_RESULT for the\n@@ -293,10 +595,8 @@ get_v_must_def_result_ptr (v_must_def_optype v_must_defs, unsigned int index)\n static inline use_operand_p\n get_v_must_def_kill_ptr (v_must_def_optype v_must_defs, unsigned int index)\n {\n-  use_operand_p op;\n   gcc_assert (index < v_must_defs->num_v_must_defs);\n-  op.use = &(v_must_defs->v_must_defs[index].use);\n-  return op;\n+  return &(v_must_defs->v_must_defs[index].imm_use);\n }\n \n /* Return a def_operand_p pointer for the result of PHI.  */\n@@ -312,64 +612,40 @@ get_phi_result_ptr (tree phi)\n static inline use_operand_p\n get_phi_arg_def_ptr (tree phi, int i)\n {\n-  use_operand_p op;\n-  op.use = &(PHI_ARG_DEF_TREE (phi, i));\n-  return op;\n-}\n- \n-/* Return the bitmap of addresses taken by STMT, or NULL if it takes\n-   no addresses.  */\n-static inline bitmap\n-addresses_taken (tree stmt)\n-{\n-  stmt_ann_t ann = stmt_ann (stmt);\n-  return ann ? ann->addresses_taken : NULL;\n+  return &(PHI_ARG_IMM_USE_NODE (phi,i));\n }\n \n-/* Return the immediate uses of STMT, or NULL if this information is\n-   not computed.  */\n-static dataflow_t\n-get_immediate_uses (tree stmt)\n+/* Delink all immediate_use information for STMT.  */\n+static inline void\n+delink_stmt_imm_use (tree stmt)\n {\n-  stmt_ann_t ann;\n+   unsigned int x;\n+   use_optype uses = STMT_USE_OPS (stmt);\n+   vuse_optype vuses = STMT_VUSE_OPS (stmt);\n+   v_may_def_optype v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n+   v_must_def_optype v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n \n-  if (TREE_CODE (stmt) == PHI_NODE)\n-    return PHI_DF (stmt);\n+   for (x = 0; x < NUM_USES (uses); x++)\n+     delink_imm_use (&(uses->uses[x]));\n \n-  ann = stmt_ann (stmt);\n-  return ann ? ann->df : NULL;\n-}\n+   for (x = 0; x < NUM_VUSES (vuses); x++)\n+     delink_imm_use (&(vuses->vuses[x].imm_use));\n \n-/* Return the number of immediate uses present in the dataflow\n-   information at DF.  */\n-static inline int\n-num_immediate_uses (dataflow_t df)\n-{\n-  varray_type imm;\n+   for (x = 0; x < NUM_V_MAY_DEFS (v_may_defs); x++)\n+     delink_imm_use (&(v_may_defs->v_may_defs[x].imm_use));\n \n-  if (!df)\n-    return 0;\n-\n-  imm = df->immediate_uses;\n-  if (!imm)\n-    return df->uses[1] ? 2 : 1;\n-\n-  return VARRAY_ACTIVE_SIZE (imm) + 2;\n+   for (x = 0; x < NUM_V_MUST_DEFS (v_must_defs); x++)\n+     delink_imm_use (&(v_must_defs->v_must_defs[x].imm_use));\n }\n \n-/* Return the tree that is at NUM in the immediate use DF array.  */\n-static inline tree\n-immediate_use (dataflow_t df, int num)\n-{\n-  if (!df)\n-    return NULL_TREE;\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (num < num_immediate_uses (df));\n-#endif\n-  if (num < 2)\n-    return df->uses[num];\n-  return VARRAY_TREE (df->immediate_uses, num - 2);\n+/* Return the bitmap of addresses taken by STMT, or NULL if it takes\n+   no addresses.  */\n+static inline bitmap\n+addresses_taken (tree stmt)\n+{\n+  stmt_ann_t ann = stmt_ann (stmt);\n+  return ann ? ann->addresses_taken : NULL;\n }\n \n /* Return the basic_block annotation for BB.  */\n@@ -399,6 +675,37 @@ set_phi_nodes (basic_block bb, tree l)\n     set_bb_for_stmt (phi, bb);\n }\n \n+/* Return the phi argument which contains the specified use.  */\n+\n+static inline int\n+phi_arg_index_from_use (use_operand_p use)\n+{\n+  struct phi_arg_d *element, *root;\n+  int index;\n+  tree phi;\n+\n+  /* Since the use is the first thing in a PHI arguemnt element, we can\n+     calculate its index based on casting it to an argument, and performing\n+     pointer arithmetic.  */\n+\n+  phi = USE_STMT (use);\n+  gcc_assert (TREE_CODE (phi) == PHI_NODE);\n+\n+  element = (struct phi_arg_d *)use;\n+  root = &(PHI_ARG_ELT (phi, 0));\n+  index = element - root;\n+\n+#ifdef ENABLE_CHECKING\n+  /* Make sure the calculation doesn't have any leftover bytes.  If it does, \n+     then imm_use is liekly not the first element in phi_arg_d.  */\n+  gcc_assert (\n+\t  (((char *)element - (char *)root) % sizeof (struct phi_arg_d)) == 0);\n+  gcc_assert (index >= 0 && index < PHI_ARG_CAPACITY (phi));\n+#endif\n+ \n+ return index;\n+}\n+\n /* Mark VAR as used, so that it'll be preserved during rtl expansion.  */\n \n static inline void"}, {"sha": "ebc31ab27f6ad6381a80055d21e362cf73efdf83", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 27, "deletions": 51, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -235,43 +235,33 @@ struct var_ann_d GTY(())\n };\n \n \n-struct dataflow_d GTY(())\n+typedef struct immediate_use_iterator_d\n {\n-  /* Immediate uses.  This is a list of all the statements and PHI nodes\n-     that are immediately reached by the definitions made in this\n-     statement.  */\n-  varray_type immediate_uses;\n-\n-  /* Use this array for very small numbers of uses instead of the varray.  */\n-  tree uses[2];\n-\n-  /* Reached uses.  This is a list of all the possible program statements\n-     that may be reached directly or indirectly by definitions made in this\n-     statement.  Notice that this is a superset of IMMEDIATE_USES.\n-     For instance, given the following piece of code:\n-\n-\t    1\ta1 = 10;\n-\t    2\tif (a1 > 3)\n-\t    3\t  a2 = a1 + 5;\n-\t    4\ta3 = PHI (a1, a2)\n-\t    5\tb1 = a3 - 2;\n-\n-     IMMEDIATE_USES for statement #1 are all those statements that use a1\n-     directly (i.e., #2, #3 and #4).  REACHED_USES for statement #1 also\n-     includes statement #5 because 'a1' could reach 'a3' via the PHI node\n-     at statement #4.  The set of REACHED_USES is then the transitive\n-     closure over all the PHI nodes in the IMMEDIATE_USES set.  */\n-\n-  /* Reaching definitions.  Similarly to REACHED_USES, the set\n-     REACHING_DEFS is the set of all the statements that make definitions\n-     that may reach this statement.  Notice that we don't need to have a\n-     similar entry for immediate definitions, as these are represented by\n-     the SSA_NAME nodes themselves (each SSA_NAME node contains a pointer\n-     to the statement that makes that definition).  */\n-};\n+  ssa_imm_use_t *imm_use;\n+  ssa_imm_use_t *end_p;\n+  ssa_imm_use_t iter_node;\n+} imm_use_iterator;\n+\n \n-typedef struct dataflow_d *dataflow_t;\n+/* Use this iterator when simply looking at stmts. Adding, deleteing or\n+   modifying stmts will cause this iterator to malfunction.  */\n+\n+#define FOR_EACH_IMM_USE_FAST(DEST, ITER, SSAVAR)\t\t\t\\\n+  for ((DEST) = first_readonly_imm_use (&(ITER), (SSAVAR));\t\\\n+       !end_readonly_imm_use_p (&(ITER));\t\t\t\\\n+       (DEST) = next_readonly_imm_use (&(ITER)))\n+  \n \n+#define FOR_EACH_IMM_USE_SAFE(DEST, ITER, SSAVAR)\t\t\\\n+  for ((DEST) = first_safe_imm_use (&(ITER), (SSAVAR));\t\t\\\n+       !end_safe_imm_use_p (&(ITER));\t\t\t\t\\\n+       (DEST) = next_safe_imm_use (&(ITER)))\n+\n+#define BREAK_FROM_SAFE_IMM_USE(ITER)\t\t\t\t\\\n+   {\t\t\t\t\t\t\t\t\\\n+     end_safe_imm_use_traverse (&(ITER));\t\t\t\\\n+     break;\t\t\t\t\t\t\t\\\n+   }\n \n struct stmt_ann_d GTY(())\n {\n@@ -297,11 +287,9 @@ struct stmt_ann_d GTY(())\n   /* Basic block that contains this statement.  */\n   basic_block GTY ((skip (\"\"))) bb;\n \n+  /* Operand cache for stmt.  */\n   struct stmt_operands_d operands;\n \n-  /* Dataflow information.  */\n-  dataflow_t df;\n-\n   /* Set of variables that have had their address taken in the statement.  */\n   bitmap addresses_taken;\n \n@@ -340,8 +328,7 @@ static inline enum tree_ann_type ann_type (tree_ann_t);\n static inline basic_block bb_for_stmt (tree);\n extern void set_bb_for_stmt (tree, basic_block);\n static inline bool noreturn_call_p (tree);\n-static inline void modify_stmt (tree);\n-static inline void unmodify_stmt (tree);\n+static inline void update_stmt (tree);\n static inline bool stmt_modified_p (tree);\n static inline varray_type may_aliases (tree);\n static inline int get_lineno (tree);\n@@ -353,9 +340,6 @@ static inline vuse_optype get_vuse_ops (stmt_ann_t);\n static inline use_optype get_use_ops (stmt_ann_t);\n static inline def_optype get_def_ops (stmt_ann_t);\n static inline bitmap addresses_taken (tree);\n-static inline int num_immediate_uses (dataflow_t);\n-static inline tree immediate_use (dataflow_t, int);\n-static inline dataflow_t get_immediate_uses (tree);\n static inline void set_default_def (tree, tree);\n static inline tree default_def (tree);\n \n@@ -435,7 +419,6 @@ extern bool aliases_computed_p;\n \n #define PERCENT(x,y) ((float)(x) * 100.0 / (float)(y))\n \n-\n /*---------------------------------------------------------------------------\n \t\t\t      Block iterators\n ---------------------------------------------------------------------------*/\n@@ -559,13 +542,6 @@ extern void debug_referenced_vars (void);\n extern void dump_referenced_vars (FILE *);\n extern void dump_variable (FILE *, tree);\n extern void debug_variable (tree);\n-extern void dump_immediate_uses (FILE *);\n-extern void debug_immediate_uses (void);\n-extern void dump_immediate_uses_for (FILE *, tree);\n-extern void debug_immediate_uses_for (tree);\n-extern void compute_immediate_uses (int, bool (*)(tree));\n-extern void free_df (void);\n-extern void free_df_for_stmt (tree);\n extern tree get_virtual_var (tree);\n extern void add_referenced_tmp_var (tree);\n extern void mark_new_vars_to_rename (tree, bitmap);\n@@ -621,7 +597,7 @@ extern edge ssa_redirect_edge (edge, basic_block);\n extern void flush_pending_stmts (edge);\n extern bool tree_ssa_useless_type_conversion (tree);\n extern bool tree_ssa_useless_type_conversion_1 (tree, tree);\n-extern void verify_ssa (void);\n+extern void verify_ssa (bool);\n extern void delete_tree_ssa (void);\n extern void register_new_def (tree, VEC (tree_on_heap) **);\n extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *, bool);"}, {"sha": "fe446d9b0ab06c58d869a94a525efcb15718dc85", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -160,7 +160,6 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n \t  ifc_bbs = NULL;\n \t}\n       free_dominance_info (CDI_POST_DOMINATORS);\n-      free_df ();\n       return false;\n     }\n \n@@ -205,7 +204,6 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n   clean_predicate_lists (loop);\n   free (ifc_bbs);\n   ifc_bbs = NULL;\n-  free_df ();\n \n   return true;\n }\n@@ -343,13 +341,11 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, tree phi)\n \n   if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n     {\n-      int j;\n-      dataflow_t df = get_immediate_uses (phi);\n-      int num_uses = num_immediate_uses (df);\n-      for (j = 0; j < num_uses; j++)\n+      imm_use_iterator imm_iter;\n+      use_operand_p use_p;\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, PHI_RESULT (phi))\n \t{\n-\t  tree use = immediate_use (df, j);\n-\t  if (TREE_CODE (use) == PHI_NODE)\n+\t  if (TREE_CODE (USE_STMT (use_p)) == PHI_NODE)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"Difficult to handle this virtual phi.\\n\");\n@@ -559,8 +555,6 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n \treturn false;\n     }\n \n-  compute_immediate_uses (TDFA_USE_OPS|TDFA_USE_VOPS, NULL);\n-\n   calculate_dominance_info (CDI_DOMINATORS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n \n@@ -798,7 +792,7 @@ replace_phi_with_cond_modify_expr (tree phi, tree cond, basic_block true_bb,\n   bsi_insert_after (bsi, new_stmt, BSI_SAME_STMT);\n   bsi_next (bsi);\n \n-  modify_stmt (new_stmt);\n+  update_stmt (new_stmt);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}, {"sha": "09e6d1f51ccf099c1ba4a44c50ffc636dba15e08", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -438,7 +438,7 @@ mark_def_sites (struct dom_walk_data *walk_data,\n   /* Mark all the blocks that have definitions for each variable in the\n      VARS_TO_RENAME bitmap.  */\n   stmt = bsi_stmt (bsi);\n-  get_stmt_operands (stmt);\n+  update_stmt_if_modified (stmt);\n \n   REWRITE_THIS_STMT (stmt) = 0;\n \n@@ -1346,6 +1346,7 @@ rewrite_into_ssa (bool all)\n static void\n rewrite_all_into_ssa (void)\n {\n+  init_ssa_operands ();\n   rewrite_into_ssa (true);\n }\n \n@@ -1583,7 +1584,7 @@ ssa_mark_def_sites (struct dom_walk_data *walk_data,\n   /* Mark all the blocks that have definitions for each variable in the\n      names_to_rename bitmap.  */\n   stmt = bsi_stmt (bsi);\n-  get_stmt_operands (stmt);\n+  update_stmt_if_modified (stmt);\n \n   /* If a variable is used before being set, then the variable is live\n      across a block boundary, so mark it live-on-entry to BB.  */"}, {"sha": "0835a451dcb9cf1649d4d4b03e25947e7a197f59", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -244,7 +244,6 @@ linear_transform_loops (struct loops *loops)\n {\n   unsigned int i;\n   \n-  compute_immediate_uses (TDFA_USE_OPS | TDFA_USE_VOPS, NULL);\n   for (i = 1; i < loops->num; i++)\n     {\n       unsigned int depth = 0;\n@@ -371,7 +370,6 @@ linear_transform_loops (struct loops *loops)\n       free_dependence_relations (dependence_relations);\n       free_data_refs (datarefs);\n     }\n-  free_df ();\n   scev_reset ();\n   rewrite_into_ssa (false);\n   rewrite_into_loop_closed_ssa (NULL);"}, {"sha": "e64391513033416d57bda64ba3238e891a7c8bc3", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -438,8 +438,11 @@ static void execute_pass_list (struct tree_opt_pass *);\n static unsigned int last_verified;\n \n static void\n-execute_todo (int properties, unsigned int flags)\n+execute_todo (struct tree_opt_pass *pass, unsigned int flags, bool use_required)\n {\n+  int properties \n+    = use_required ? pass->properties_required : pass->properties_provided;\n+\n   if (flags & TODO_rename_vars)\n     {\n       rewrite_into_ssa (false);\n@@ -475,11 +478,15 @@ execute_todo (int properties, unsigned int flags)\n     }\n \n   if (flags & TODO_ggc_collect)\n-    ggc_collect ();\n+    {\n+      ggc_collect ();\n+    }\n \n #ifdef ENABLE_CHECKING\n-  if (flags & TODO_verify_ssa)\n-    verify_ssa ();\n+  if ((pass->properties_required & PROP_ssa)\n+      && !(pass->properties_destroyed & PROP_ssa))\n+    verify_ssa  (true);\n+\n   if (flags & TODO_verify_flow)\n     verify_flow_info ();\n   if (flags & TODO_verify_stmts)\n@@ -503,7 +510,7 @@ execute_one_pass (struct tree_opt_pass *pass)\n   /* Run pre-pass verification.  */\n   todo = pass->todo_flags_start & ~last_verified;\n   if (todo)\n-    execute_todo (pass->properties_required, todo);\n+    execute_todo (pass, todo, true);\n \n   /* If a dump file name is present, open it if enabled.  */\n   if (pass->static_pass_number != -1)\n@@ -553,7 +560,7 @@ execute_one_pass (struct tree_opt_pass *pass)\n   todo = pass->todo_flags_finish;\n   last_verified = todo & TODO_verify_all;\n   if (todo)\n-    execute_todo (pass->properties_provided, todo);\n+    execute_todo (pass, todo, false);\n \n   /* Flush and close dump file.  */\n   if (dump_file_name)"}, {"sha": "ecbee58504d77e9d0159504b89b0964a6001e386", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -1928,8 +1928,6 @@ rewrite_trees (var_map map, tree *values)\n \t\t      && (DEF_FROM_PTR (def_p) == USE_OP (uses, 0)))\n \t\t    remove = 1;\n \t\t}\n-\t      if (changed & !remove)\n-\t\tmodify_stmt (stmt);\n \t    }\n \n \t  /* Remove any stmts marked for removal.  */\n@@ -2370,6 +2368,9 @@ remove_ssa_form (FILE *dump, var_map map, int flags)\n \t}\n     }\n \n+  /* we no longer maintain the SSA operand cache at this point.  */\n+  fini_ssa_operands ();\n+\n   /* If any copies were inserted on edges, analyze and insert them now.  */\n   perform_edge_inserts (dump_file);\n \n@@ -2457,7 +2458,6 @@ insert_backedge_copies (void)\n \t\t    bsi_insert_before (&bsi, stmt, BSI_NEW_STMT);\n \t\t  else\n \t\t    bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n-\t\t  modify_stmt (stmt);\n \t\t  SET_PHI_ARG_DEF (phi, i, name);\n \t\t}\n \t    }"}, {"sha": "963ef0a957849a20f3cd2fb3c220c0e0af227cd3", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -206,7 +206,7 @@ static tree\n make_phi_node (tree var, int len)\n {\n   tree phi;\n-  int capacity;\n+  int capacity, i;\n \n   capacity = ideal_phi_node_len (len);\n \n@@ -226,6 +226,15 @@ make_phi_node (tree var, int len)\n   else\n     SET_PHI_RESULT (phi, make_ssa_name (var, phi));\n \n+  for (i = 0; i < capacity; i++)\n+    {\n+      ssa_imm_use_t * imm;\n+      imm = &(PHI_ARG_IMM_USE_NODE (phi, i));\n+      imm->use = &(PHI_ARG_DEF_TREE (phi, i));\n+      imm->prev = NULL;\n+      imm->next = NULL;\n+      imm->stmt = phi;\n+    }\n   return phi;\n }\n \n@@ -236,6 +245,14 @@ release_phi_node (tree phi)\n {\n   int bucket;\n   int len = PHI_ARG_CAPACITY (phi);\n+  int x;\n+\n+  for (x = 0; x < PHI_NUM_ARGS (phi); x++)\n+    {\n+      ssa_imm_use_t * imm;\n+      imm = &(PHI_ARG_IMM_USE_NODE (phi, x));\n+      delink_imm_use (imm);\n+    }\n \n   bucket = len > NUM_BUCKETS - 1 ? NUM_BUCKETS - 1 : len;\n   bucket -= 2;\n@@ -250,7 +267,7 @@ release_phi_node (tree phi)\n static void\n resize_phi_node (tree *phi, int len)\n {\n-  int old_size;\n+  int old_size, i;\n   tree new_phi;\n \n   gcc_assert (len > PHI_ARG_CAPACITY (*phi));\n@@ -265,8 +282,28 @@ resize_phi_node (tree *phi, int len)\n \n   memcpy (new_phi, *phi, old_size);\n \n+  for (i = 0; i < PHI_NUM_ARGS (new_phi); i++)\n+    {\n+      ssa_imm_use_t *imm, *old_imm;\n+      imm = &(PHI_ARG_IMM_USE_NODE (new_phi, i));\n+      old_imm = &(PHI_ARG_IMM_USE_NODE (*phi, i));\n+      imm->use = &(PHI_ARG_DEF_TREE (new_phi, i));\n+      relink_imm_use_stmt (imm, old_imm, new_phi);\n+    }\n+\n   PHI_ARG_CAPACITY (new_phi) = len;\n \n+  for (i = PHI_NUM_ARGS (new_phi); i < len; i++)\n+    {\n+      ssa_imm_use_t * imm;\n+      imm = &(PHI_ARG_IMM_USE_NODE (new_phi, i));\n+      imm->use = &(PHI_ARG_DEF_TREE (new_phi, i));\n+      imm->prev = NULL;\n+      imm->next = NULL;\n+      imm->stmt = new_phi;\n+    }\n+\n+\n   *phi = new_phi;\n }\n \n@@ -372,6 +409,9 @@ remove_phi_arg_num (tree phi, int i)\n \n   gcc_assert (i < num_elem);\n \n+  /* Delink the last item, which is being removed.  */\n+  delink_imm_use (&(PHI_ARG_IMM_USE_NODE (phi, num_elem - 1)));\n+\n   /* If we are not at the last element, switch the last element\n      with the element we want to delete.  */\n   if (i != num_elem - 1)\n@@ -423,8 +463,8 @@ remove_phi_node (tree phi, tree prev)\n \n   /* If we are deleting the PHI node, then we should release the\n      SSA_NAME node so that it can be reused.  */\n-  release_ssa_name (PHI_RESULT (phi));\n   release_phi_node (phi);\n+  release_ssa_name (PHI_RESULT (phi));\n }\n \n \n@@ -461,8 +501,8 @@ remove_all_phi_nodes_for (bitmap vars)\n \t    {\n \t      /* If we are deleting the PHI node, then we should release the\n \t\t SSA_NAME node so that it can be reused.  */\n-\t      release_ssa_name (PHI_RESULT (phi));\n \t      release_phi_node (phi);\n+\t      release_ssa_name (PHI_RESULT (phi));\n \t    }\n \t}\n "}, {"sha": "c21766e7e5b1eb98aeeedec59e0061ecc4290114", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -271,6 +271,9 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       && stmt_ann (node))\n     dump_vops (buffer, node, spc, flags);\n \n+  if (is_stmt && (flags & TDF_STMTADDR))\n+    pp_printf (buffer, \"<&0x%x> \", (unsigned int)node);\n+\n   if (dumping_stmts\n       && (flags & TDF_LINENO)\n       && EXPR_HAS_LOCATION (node))"}, {"sha": "b933fbc32e06832beae2eae80def83f89d910106", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -1444,7 +1444,7 @@ mark_all_v_defs (tree stmt)\n   tree sym;\n   ssa_op_iter iter;\n \n-  get_stmt_operands (stmt);\n+  update_stmt_if_modified (stmt);\n \n   FOR_EACH_SSA_TREE_OPERAND (sym, stmt, iter, SSA_OP_ALL_VIRTUALS)\n     {\n@@ -1800,7 +1800,7 @@ scalarize_use (struct sra_elt *elt, tree *expr_p, block_stmt_iterator *bsi,\n       if (is_output)\n \tmark_all_v_defs (stmt);\n       *expr_p = elt->replacement;\n-      modify_stmt (stmt);\n+      update_stmt (stmt);\n     }\n   else\n     {\n@@ -1848,7 +1848,7 @@ scalarize_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n \n       TREE_OPERAND (stmt, 0) = lhs_elt->replacement;\n       TREE_OPERAND (stmt, 1) = rhs_elt->replacement;\n-      modify_stmt (stmt);\n+      update_stmt (stmt);\n     }\n   else if (lhs_elt->use_block_copy || rhs_elt->use_block_copy)\n     {"}, {"sha": "8e1b63265f8505b73bf7f5eef4eef72565a20e74", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -343,6 +343,19 @@ compute_may_aliases (void)\n \n   /* Deallocate memory used by aliasing data structures.  */\n   delete_alias_info (ai);\n+\n+  {\n+    block_stmt_iterator bsi;\n+    basic_block bb;\n+    FOR_EACH_BB (bb)\n+      {\n+        for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+          {\n+            update_stmt_if_modified (bsi_stmt (bsi));\n+          }\n+      }\n+  }\n+\n }\n \n struct tree_opt_pass pass_may_alias = \n@@ -766,7 +779,7 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t     need to re-scan most statements.  FIXME: Try to minimize the\n \t     number of statements re-scanned.  It's not really necessary to\n \t     re-scan *all* statements.  */\n-\t  modify_stmt (stmt);\n+\t  mark_stmt_modified (stmt);\n \t}\n     }\n "}, {"sha": "26e1a2ea1b86fb6c6eb5bcff3e3bed05812322aa", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -331,16 +331,6 @@ likely_value (tree stmt)\n }\n \n \n-/* Function indicating whether we ought to include information for VAR\n-   when calculating immediate uses.  */\n-\n-static bool\n-need_imm_uses_for (tree var)\n-{\n-  return get_value (var)->lattice_val != VARYING;\n-}\n-\n-\n /* Initialize local data structures for CCP.  */\n \n static void\n@@ -430,9 +420,6 @@ ccp_initialize (void)\n     }\n \n   sbitmap_free (is_may_def);\n-\n-  /* Compute immediate uses for variables we care about.  */\n-  compute_immediate_uses (TDFA_USE_OPS | TDFA_USE_VOPS, need_imm_uses_for);\n }\n \n \n@@ -591,7 +578,7 @@ substitute_and_fold (void)\n \t      if (maybe_clean_eh_stmt (stmt))\n \t\ttree_purge_dead_eh_edges (bb);\n \n-\t      modify_stmt (stmt);\n+\t      update_stmt (stmt);\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2211,7 +2198,7 @@ execute_fold_all_builtins (void)\n \t\t  gcc_assert (ok);\n \t\t}\n \t    }\n-\t  modify_stmt (*stmtp);\n+\t  update_stmt (*stmtp);\n \t  if (maybe_clean_eh_stmt (*stmtp)\n \t      && tree_purge_dead_eh_edges (bb))\n \t    cfg_changed = true;"}, {"sha": "ebb0aa3fbfa4bd193fa4ef4417acc0397894b0de", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -450,6 +450,17 @@ tree_ssa_dominator_optimize (void)\n \n       free_all_edge_infos ();\n \n+  {\n+    block_stmt_iterator bsi;\n+    basic_block bb;\n+    FOR_EACH_BB (bb)\n+      {\n+\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t  {\n+\t    update_stmt_if_modified (bsi_stmt (bsi));\n+\t  }\n+      }\n+  }\n       /* Thread jumps, creating duplicate blocks as needed.  */\n       cfg_altered |= thread_through_all_blocks ();\n \n@@ -2097,7 +2108,7 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \t\t  /* If this is not a real stmt, ann will be NULL and we\n \t\t     avoid processing the operands.  */\n \t\t  if (ann)\n-\t\t    modify_stmt (stmt);\n+\t\t    mark_stmt_modified (stmt);\n \n \t\t  /* Lookup the condition and return its known value if it\n \t\t     exists.  */\n@@ -2349,7 +2360,7 @@ simplify_switch_and_lookup_avail_expr (tree stmt, int insert)\n \t      if (!fail)\n \t\t{\n \t\t  SWITCH_COND (stmt) = def;\n-\t\t  modify_stmt (stmt);\n+\t\t  mark_stmt_modified (stmt);\n \n \t\t  return lookup_avail_expr (stmt, insert);\n \t\t}\n@@ -2709,7 +2720,7 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n \tretval = true;\n \n       propagate_tree_value (expr_p, cached_lhs);\n-      modify_stmt (stmt);\n+      mark_stmt_modified (stmt);\n     }\n   return retval;\n }\n@@ -2946,7 +2957,7 @@ cprop_operand (tree stmt, use_operand_p op_p)\n       /* And note that we modified this statement.  This is now\n \t safe, even if we changed virtual operands since we will\n \t rescan the statement and rewrite its operands again.  */\n-      modify_stmt (stmt);\n+      mark_stmt_modified (stmt);\n     }\n   return may_have_exposed_new_symbols;\n }\n@@ -3008,7 +3019,7 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n \n   stmt = bsi_stmt (si);\n \n-  get_stmt_operands (stmt);\n+  update_stmt_if_modified (stmt);\n   ann = stmt_ann (stmt);\n   opt_stats.num_stmts++;\n   may_have_exposed_new_symbols = false;\n@@ -3178,7 +3189,7 @@ update_rhs_and_lookup_avail_expr (tree stmt, tree new_rhs, bool insert)\n \n   /* And make sure we record the fact that we modified this\n      statement.  */\n-  modify_stmt (stmt);\n+  mark_stmt_modified (stmt);\n \n   return cached_lhs;\n }"}, {"sha": "edea6382ce3cc4c370054e0d7bc775b3a189c5f0", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 41, "deletions": 126, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -94,8 +94,6 @@ static void dse_optimize_stmt (struct dom_walk_data *,\n \t\t\t       block_stmt_iterator);\n static void dse_record_phis (struct dom_walk_data *, basic_block);\n static void dse_finalize_block (struct dom_walk_data *, basic_block);\n-static void fix_phi_uses (tree, tree);\n-static void fix_stmt_v_may_defs (tree, tree);\n static void record_voperand_set (bitmap, bitmap *, unsigned int);\n \n static unsigned max_stmt_uid;\t/* Maximal uid of a statement.  Uids to phi\n@@ -124,83 +122,6 @@ need_imm_uses_for (tree var)\n }\n \n \n-/* Replace uses in PHI which match V_MAY_DEF_RESULTs in STMT with the \n-   corresponding V_MAY_DEF_OP in STMT.  */\n-\n-static void\n-fix_phi_uses (tree phi, tree stmt)\n-{\n-  use_operand_p use_p;\n-  def_operand_p def_p;\n-  ssa_op_iter iter;\n-  int i;\n-  edge e;\n-  edge_iterator ei;\n-  \n-  FOR_EACH_EDGE (e, ei, PHI_BB (phi)->preds) \n-  if (e->flags & EDGE_ABNORMAL)\n-    break;\n-  \n-  get_stmt_operands (stmt);\n-\n-  FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)\n-    {\n-      tree v_may_def = DEF_FROM_PTR (def_p);\n-      tree v_may_use = USE_FROM_PTR (use_p);\n-\n-      /* Find any uses in the PHI which match V_MAY_DEF and replace\n-\t them with the appropriate V_MAY_DEF_OP.  */\n-      for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-\tif (v_may_def == PHI_ARG_DEF (phi, i))\n-\t  {\n-\t    SET_PHI_ARG_DEF (phi, i, v_may_use);\n-\t    /* Update if the new phi argument is an abnormal phi.  */\n-\t    if (e != NULL)\n-\t      SSA_NAME_OCCURS_IN_ABNORMAL_PHI (v_may_use) = 1;\n-\t  }\n-    }\n-}\n-\n-/* Replace the V_MAY_DEF_OPs in STMT1 which match V_MAY_DEF_RESULTs \n-   in STMT2 with the appropriate V_MAY_DEF_OPs from STMT2.  */\n-\n-static void\n-fix_stmt_v_may_defs (tree stmt1, tree stmt2)\n-{\n-  bool found = false;\n-  ssa_op_iter iter1;\n-  ssa_op_iter iter2;\n-  use_operand_p use1_p, use2_p;\n-  def_operand_p def1_p, def2_p;\n-\n-  get_stmt_operands (stmt1);\n-  get_stmt_operands (stmt2);\n-\n-  /* Walk each V_MAY_DEF_OP in stmt1.  */\n-  FOR_EACH_SSA_MAYDEF_OPERAND (def1_p, use1_p, stmt1, iter1)\n-    {\n-      tree use = USE_FROM_PTR (use1_p);\n-\n-      /* Find the appropriate V_MAY_DEF_RESULT in STMT2.  */\n-      FOR_EACH_SSA_MAYDEF_OPERAND (def2_p, use2_p, stmt2, iter2)\n-\t{\n-\t  tree def = DEF_FROM_PTR (def2_p);\n-\t  if (use == def)\n-\t    {\n-\t      /* Update.  */\n-\t      SET_USE (use1_p, USE_FROM_PTR (use2_p));\n-\t      found = true;\n-              break;\n-            }\n-\t}\n-\n-      /* If we did not find a corresponding V_MAY_DEF_RESULT,\n-\t then something has gone terribly wrong.  */\n-      gcc_assert (found);\n-    }\n-}\n-\n-\n /* Set bit UID in bitmaps GLOBAL and *LOCAL, creating *LOCAL as needed.  */\n static void\n record_voperand_set (bitmap global, bitmap *local, unsigned int uid)\n@@ -275,57 +196,66 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n \n   if (TREE_CODE (stmt) == MODIFY_EXPR)\n     {\n-      dataflow_t df = get_immediate_uses (stmt);\n-      unsigned int num_uses = num_immediate_uses (df);\n-      tree use;\n-      tree skipped_phi;\n+      unsigned int num_uses = 0, count = 0;\n+      use_operand_p first_use_p = NULL_USE_OPERAND_P;\n+      use_operand_p use_p;\n+      tree use, use_stmt;\n+      tree defvar = NULL_TREE, usevar = NULL_TREE;\n+      use_operand_p var2;\n+      def_operand_p var1;\n+      ssa_op_iter op_iter;\n+\n+      FOR_EACH_SSA_MAYDEF_OPERAND (var1, var2, stmt, op_iter)\n+        {\n+\t  defvar = DEF_FROM_PTR (var1);\n+\t  usevar = USE_FROM_PTR (var2);\n+\t  num_uses += num_imm_uses (defvar);\n+\t  count++;\n+\t  if (num_uses > 1 || count > 1)\n+\t    break;\n+\t}\n \n-      /* If there are no uses then there is nothing left to do.  */\n-      if (num_uses == 0)\n+      if (count == 1 && num_uses == 1)\n+        {\n+\t  single_imm_use (defvar, &use_p, &use_stmt);\n+\t  gcc_assert (use_p != NULL_USE_OPERAND_P);\n+\t  first_use_p = use_p;\n+\t  use = USE_FROM_PTR (use_p);\n+\t}\n+      else\n \t{\n \t  record_voperand_set (dse_gd->stores, &bd->stores, ann->uid);\n \t  return;\n \t}\n \n-      use = immediate_use (df, 0);\n-      skipped_phi = NULL;\n-\n       /* Skip through any PHI nodes we have already seen if the PHI\n \t represents the only use of this store.\n \n \t Note this does not handle the case where the store has\n \t multiple V_MAY_DEFs which all reach a set of PHI nodes in the\n \t same block.  */\n-      while (num_uses == 1\n-\t     && TREE_CODE (use) == PHI_NODE\n-\t     && bitmap_bit_p (dse_gd->stores, get_stmt_uid (use)))\n+      while (use_p != NULL_USE_OPERAND_P\n+\t     && TREE_CODE (use_stmt) == PHI_NODE\n+\t     && bitmap_bit_p (dse_gd->stores, get_stmt_uid (use_stmt)))\n \t{\n-\t  /* Record the first PHI we skip so that we can fix its\n-\t     uses if we find that STMT is a dead store.  */\n-\t  if (!skipped_phi)\n-\t    skipped_phi = use;\n-\n \t  /* Skip past this PHI and loop again in case we had a PHI\n \t     chain.  */\n-\t  df = get_immediate_uses (use);\n-\t  num_uses = num_immediate_uses (df);\n-\t  use = immediate_use (df, 0);\n+\t  if (single_imm_use (PHI_RESULT (use_stmt), &use_p, &use_stmt))\n+\t    use = USE_FROM_PTR (use_p);\n \t}\n \n       /* If we have precisely one immediate use at this point, then we may\n \t have found redundant store.  */\n-      if (num_uses == 1\n-\t  && bitmap_bit_p (dse_gd->stores, get_stmt_uid (use))\n+      if (use_p != NULL_USE_OPERAND_P\n+\t  && bitmap_bit_p (dse_gd->stores, get_stmt_uid (use_stmt))\n \t  && operand_equal_p (TREE_OPERAND (stmt, 0),\n-\t\t\t      TREE_OPERAND (use, 0), 0))\n+\t\t\t      TREE_OPERAND (use_stmt, 0), 0))\n \t{\n-\t  /* We need to fix the operands if either the first PHI we\n-\t     skipped, or the store which we are not deleting if we did\n-\t     not skip any PHIs.  */\n-\t  if (skipped_phi)\n-\t    fix_phi_uses (skipped_phi, stmt);\n-\t  else\n-\t    fix_stmt_v_may_defs (use, stmt);\n+\t  /* Make sure we propagate the ABNORMAL bit setting.  */\n+\t  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (USE_FROM_PTR (first_use_p)))\n+\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (usevar) = 1;\n+\t  /* Then we need to fix the operand of the consuming stmt.  */\n+\t  SET_USE (first_use_p, usevar);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n             {\n@@ -334,21 +264,12 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n               fprintf (dump_file, \"'\\n\");\n             }\n \n-\t  /* Any immediate uses which reference STMT need to instead\n-\t     reference the new consumer, either SKIPPED_PHI or USE.  \n-\t     This allows us to cascade dead stores.  */\n-\t  redirect_immediate_uses (stmt, skipped_phi ? skipped_phi : use);\n-\n-\t  /* Be sure to remove any dataflow information attached to\n-\t     this statement.  */\n-\t  free_df_for_stmt (stmt);\n+\t  /* Remove the dead store.  */\n+\t  bsi_remove (&bsi);\n \n \t  /* And release any SSA_NAMEs set in this statement back to the\n \t     SSA_NAME manager.  */\n \t  release_defs (stmt);\n-\n-\t  /* Finally remove the dead store.  */\n-\t  bsi_remove (&bsi);\n \t}\n \n       record_voperand_set (dse_gd->stores, &bd->stores, ann->uid);\n@@ -415,9 +336,6 @@ tree_ssa_dse (void)\n      dominators.  */\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n \n-  /* We also need immediate use information for virtual operands.  */\n-  compute_immediate_uses (TDFA_USE_VOPS, need_imm_uses_for);\n-\n   /* Dead store elimination is fundamentally a walk of the post-dominator\n      tree and a backwards walk of statements within each block.  */\n   walk_data.walk_stmts_backward = true;\n@@ -448,9 +366,6 @@ tree_ssa_dse (void)\n   /* Release the main bitmap.  */\n   BITMAP_FREE (dse_gd.stores);\n \n-  /* Free dataflow information.  It's probably out of date now anyway.  */\n-  free_df ();\n-\n   /* For now, just wipe the post-dominator information.  */\n   free_dominance_info (CDI_POST_DOMINATORS);\n }"}, {"sha": "02b41b6e6c8c2bc4b7b505089bdc1ace7a870153", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -113,22 +113,12 @@ Boston, MA 02111-1307, USA.  */\n    by record_single_argument_cond_exprs and tested in need_imm_uses_for.  */\n static bitmap vars;\n \n-static bool need_imm_uses_for (tree);\n static void tree_ssa_forward_propagate_single_use_vars (void);\n static void record_single_argument_cond_exprs (varray_type,\n \t\t\t\t\t       varray_type *,\n \t\t\t\t\t       bitmap);\n static void substitute_single_use_vars (varray_type *, varray_type);\n \n-/* Function indicating whether we ought to include information for 'var'\n-   when calculating immediate uses.  */\n-\n-static bool\n-need_imm_uses_for (tree var)\n-{\n-  return bitmap_bit_p (vars, SSA_NAME_VERSION (var));\n-}\n-\n /* Find all COND_EXPRs with a condition that is a naked SSA_NAME or\n    an equality comparison against a constant.\n \n@@ -323,35 +313,40 @@ static void\n substitute_single_use_vars (varray_type *cond_worklist,\n \t\t\t    varray_type vars_worklist)\n {\n+  use_operand_p use_p;\n   while (VARRAY_ACTIVE_SIZE (vars_worklist) > 0)\n     {\n       tree test_var = VARRAY_TOP_TREE (vars_worklist);\n-      tree def = SSA_NAME_DEF_STMT (test_var);\n-      dataflow_t df;\n-      int j, num_uses, propagated_uses;\n+      tree def_stmt = SSA_NAME_DEF_STMT (test_var);\n+      tree def;\n+      int num_uses, propagated_uses;\n+      imm_use_iterator imm_iter;\n \n       VARRAY_POP (vars_worklist);\n \n-      /* Now compute the immediate uses of TEST_VAR.  */\n-      df = get_immediate_uses (def);\n-      num_uses = num_immediate_uses (df);\n       propagated_uses = 0;\n+      num_uses = 0;\n+\n+      if (NUM_DEFS (STMT_DEF_OPS (def_stmt)) != 1)\n+\tcontinue;\n+\n+      def = DEF_OP (STMT_DEF_OPS (def_stmt), 0);\n \n       /* If TEST_VAR is used more than once and is not a boolean set\n \t via TRUTH_NOT_EXPR with another SSA_NAME as its argument, then\n \t we can not optimize.  */\n-      if (num_uses == 1\n+      if (has_single_use (def)\n \t  || (TREE_CODE (TREE_TYPE (test_var)) == BOOLEAN_TYPE\n-\t      && TREE_CODE (TREE_OPERAND (def, 1)) == TRUTH_NOT_EXPR\n-\t      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (def, 1), 0))\n+\t      && TREE_CODE (TREE_OPERAND (def_stmt, 1)) == TRUTH_NOT_EXPR\n+\t      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0))\n \t\t  == SSA_NAME)))\n \t;\n       else\n \tcontinue;\n \n       /* Walk over each use and try to forward propagate the RHS of\n \t DEF into the use.  */\n-      for (j = 0; j < num_uses; j++)\n+      FOR_EACH_IMM_USE_SAFE (use_p, imm_iter, def)\n \t{\n \t  tree cond_stmt;\n \t  tree cond;\n@@ -360,15 +355,16 @@ substitute_single_use_vars (varray_type *cond_worklist,\n \t  enum tree_code def_rhs_code;\n \t  tree new_cond;\n \n-\t  cond_stmt = immediate_use (df, j);\n+\t  cond_stmt = USE_STMT (use_p);\n+\t  num_uses++;\n \n \t  /* For now we can only propagate into COND_EXPRs.  */\n \t  if (TREE_CODE (cond_stmt) != COND_EXPR) \n \t    continue;\n \n \t  cond = COND_EXPR_COND (cond_stmt);\n \t  cond_code = TREE_CODE (cond);\n-\t  def_rhs = TREE_OPERAND (def, 1);\n+\t  def_rhs = TREE_OPERAND (def_stmt, 1);\n \t  def_rhs_code = TREE_CODE (def_rhs);\n \n \t  /* If the definition of the single use variable was from an\n@@ -456,7 +452,7 @@ substitute_single_use_vars (varray_type *cond_worklist,\n \n \t  /* Replace the condition.  */\n \t  COND_EXPR_COND (cond_stmt) = new_cond;\n-\t  modify_stmt (cond_stmt);\n+\t  update_stmt (cond_stmt);\n \t  propagated_uses++;\n \t  VARRAY_PUSH_TREE (*cond_worklist, cond_stmt);\n \t}\n@@ -466,7 +462,7 @@ substitute_single_use_vars (varray_type *cond_worklist,\n \t whatever block it might be in.  */\n       if (num_uses && num_uses == propagated_uses)\n \t{\n-\t  block_stmt_iterator bsi = bsi_for_stmt (def);\n+\t  block_stmt_iterator bsi = bsi_for_stmt (def_stmt);\n \t  bsi_remove (&bsi);\n \t}\n     }\n@@ -502,22 +498,13 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \n       if (VARRAY_ACTIVE_SIZE (vars_worklist) > 0)\n \t{\n-\t  /* Now compute immediate uses for all the variables we care about.  */\n-\t  compute_immediate_uses (TDFA_USE_OPS, need_imm_uses_for);\n-\n \t  /* We've computed immediate uses, so we can/must clear the VARS\n \t     bitmap for the next iteration.  */\n \t  bitmap_clear (vars);\n \n \t  /* And optimize.  This will drain VARS_WORKLIST and initialize\n \t     COND_WORKLIST for the next iteration.  */\n \t  substitute_single_use_vars (&cond_worklist, vars_worklist);\n-\n-\t  /* We do not incrementally update the dataflow information\n-\t     so we must free it here and recompute the necessary bits\n-\t     on the next iteration.  If this turns out to be expensive,\n-\t     methods for incrementally updating the dataflow are known.  */\n-\t  free_df ();\n \t}\n     }\n "}, {"sha": "7823e1711e7dfae285ea9f830a91af7941b7dfcd", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -971,12 +971,13 @@ single_reachable_address (struct loop *loop, tree stmt,\n   tree *queue = xmalloc (sizeof (tree) * max_uid);\n   sbitmap seen = sbitmap_alloc (max_uid);\n   unsigned in_queue = 1;\n-  dataflow_t df;\n-  unsigned i, n;\n+  unsigned i;\n   struct sra_data sra_data;\n   tree call;\n   tree val;\n   ssa_op_iter iter;\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n \n   sbitmap_zero (seen);\n \n@@ -1034,22 +1035,40 @@ single_reachable_address (struct loop *loop, tree stmt,\n \t}\n \n       /* Find uses of virtual names.  */\n-      df = get_immediate_uses (stmt);\n-      n = num_immediate_uses (df);\n+      if (TREE_CODE (stmt) == PHI_NODE)\n+        {\n+\t  if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (stmt))))\n+\t    FOR_EACH_IMM_USE_FAST (use_p, imm_iter, PHI_RESULT (stmt))\n+\t      {\t      \n+\t\ttree imm_stmt = USE_STMT (use_p);\n \n-      for (i = 0; i < n; i++)\n-\t{\n-\t  stmt = immediate_use (df, i);\n+\t\tif (TEST_BIT (seen, get_stmt_uid (imm_stmt)))\n+\t\t  continue;\n \n-\t  if (!flow_bb_inside_loop_p (loop, bb_for_stmt (stmt)))\n-\t    continue;\n+\t\tif (!flow_bb_inside_loop_p (loop, bb_for_stmt (imm_stmt)))\n+\t\t  continue;\n \n-\t  if (TEST_BIT (seen, get_stmt_uid (stmt)))\n-\t    continue;\n-\t  SET_BIT (seen, get_stmt_uid (stmt));\n+\t\tSET_BIT (seen, get_stmt_uid (imm_stmt));\n \n-\t  queue[in_queue++] = stmt;\n+\t\tqueue[in_queue++] = imm_stmt;\n+\t      }\n \t}\n+      else\n+\tFOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n+\t  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, val)\n+\t    {\n+\t      tree imm_stmt = USE_STMT (use_p);\n+\n+\t      if (TEST_BIT (seen, get_stmt_uid (imm_stmt)))\n+\t\tcontinue;\n+\n+\t      if (!flow_bb_inside_loop_p (loop, bb_for_stmt (imm_stmt)))\n+\t\tcontinue;\n+\n+\t      SET_BIT (seen, get_stmt_uid (imm_stmt));\n+\n+\t      queue[in_queue++] = imm_stmt;\n+\t    }\n     }\n \n   free (queue);\n@@ -1083,7 +1102,7 @@ rewrite_mem_refs (tree tmp_var, struct mem_ref *mem_refs)\n \t}\n \n       *mem_refs->ref = tmp_var;\n-      modify_stmt (mem_refs->stmt);\n+      update_stmt (mem_refs->stmt);\n     }\n }\n \n@@ -1337,8 +1356,6 @@ determine_lsm (struct loops *loops)\n \tstmt_ann (bsi_stmt (bsi))->uid = max_stmt_uid++;\n     }\n \n-  compute_immediate_uses (TDFA_USE_VOPS, NULL);\n-\n   /* Pass the loops from the outermost.  For each virtual operand loop phi node\n      check whether all the references inside the loop correspond to a single\n      address, and if so, move them.  */\n@@ -1358,7 +1375,6 @@ determine_lsm (struct loops *loops)\n \t  loop = loop->outer;\n \t  if (loop == loops->tree_root)\n \t    {\n-\t      free_df ();\n \t      loop_commit_inserts ();\n \t      return;\n \t    }"}, {"sha": "43f3c15f634626a2d0ebf73ba151cfee41fdf00f", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -97,7 +97,7 @@ create_canonical_iv (struct loop *loop, edge exit, tree niter)\n   COND_EXPR_COND (cond) = build2 (cmp, boolean_type_node,\n \t\t\t\t  var,\n \t\t\t\t  build_int_cst (type, 0));\n-  modify_stmt (cond);\n+  update_stmt (cond);\n }\n \n /* Computes an estimated number of insns in LOOP.  */\n@@ -170,19 +170,20 @@ try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n     {\n       old_cond = COND_EXPR_COND (cond);\n       COND_EXPR_COND (cond) = dont_exit;\n-      modify_stmt (cond);\n+      update_stmt (cond);\n \n       if (!tree_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t       loops, n_unroll, NULL,\n \t\t\t\t\t       NULL, NULL, NULL, 0))\n \t{\n \t  COND_EXPR_COND (cond) = old_cond;\n+\t  update_stmt (cond);\n \t  return false;\n \t}\n     }\n   \n   COND_EXPR_COND (cond) = do_exit;\n-  modify_stmt (cond);\n+  update_stmt (cond);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Unrolled loop %d completely.\\n\", loop->num);"}, {"sha": "d1bdb7add8eda214e6e3aaaff8b73439284680b1", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -4835,6 +4835,7 @@ rewrite_address_base (block_stmt_iterator *bsi, tree *op, tree with)\n       new_name = make_ssa_name (new_var, copy);\n     }\n   TREE_OPERAND (copy, 0) = new_name;\n+  update_stmt (copy);\n   bsi_insert_before (bsi, copy, BSI_SAME_STMT);\n   with = new_name;\n \n@@ -4898,7 +4899,7 @@ rewrite_use_compare (struct ivopts_data *data,\n \tbsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n \n       *use->op_p = build2 (compare, boolean_type_node, var, op);\n-      modify_stmt (use->stmt);\n+      update_stmt (use->stmt);\n       return;\n     }\n \n@@ -4999,19 +5000,24 @@ compute_phi_arg_on_exit (edge exit, tree stmts, tree op)\n   if (!single_pred_p (exit->dest))\n     split_loop_exit_edge (exit);\n \n+  /* Ensure there is label in exit->dest, so that we can\n+     insert after it.  */\n+  tree_block_label (exit->dest);\n+  bsi = bsi_after_labels (exit->dest);\n+\n   if (TREE_CODE (stmts) == STATEMENT_LIST)\n     {\n       for (tsi = tsi_start (stmts); !tsi_end_p (tsi); tsi_next (&tsi))\n-\tprotect_loop_closed_ssa_form (exit, tsi_stmt (tsi));\n+        {\n+\t  bsi_insert_after (&bsi, tsi_stmt (tsi), BSI_NEW_STMT);\n+\t  protect_loop_closed_ssa_form (exit, bsi_stmt (bsi));\n+\t}\n     }\n   else\n-    protect_loop_closed_ssa_form (exit, stmts);\n-\n-  /* Ensure there is label in exit->dest, so that we can\n-     insert after it.  */\n-  tree_block_label (exit->dest);\n-  bsi = bsi_after_labels (exit->dest);\n-  bsi_insert_after (&bsi, stmts, BSI_CONTINUE_LINKING);\n+    {\n+      bsi_insert_after (&bsi, stmts, BSI_NEW_STMT);\n+      protect_loop_closed_ssa_form (exit, bsi_stmt (bsi));\n+    }\n \n   if (!op)\n     return;\n@@ -5130,7 +5136,7 @@ rewrite_use (struct ivopts_data *data,\n       default:\n \tgcc_unreachable ();\n     }\n-  modify_stmt (use->stmt);\n+  update_stmt (use->stmt);\n }\n \n /* Rewrite the uses using the selected induction variables.  */"}, {"sha": "cbc1e69d430db77981cca57f3e9914b802bd8401", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -415,7 +415,7 @@ verify_loop_closed_ssa (void)\n   tree phi;\n   unsigned i;\n \n-  verify_ssa ();\n+  verify_ssa (false);\n \n   FOR_EACH_BB (bb)\n     {"}, {"sha": "9546342c9dc2f98e53c61eaba95c137e0ffca5a3", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -249,7 +249,7 @@ tree_unswitch_single_loop (struct loops *loops, struct loop *loop, int num)\n       else\n \tbreak;\n \n-      modify_stmt (stmt);\n+      update_stmt (stmt);\n       i++;\n     }\n "}, {"sha": "979337b12aee747db023e0ad7069c266d82af9b9", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 476, "deletions": 91, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -127,9 +127,9 @@ static GTY (()) varray_type ro_call_vuses;\n static bool clobbered_aliased_loads;\n static bool clobbered_aliased_stores;\n static bool ro_call_aliased_loads;\n+static stmt_operands_p parse_old_ops = NULL;\n \n def_operand_p NULL_DEF_OPERAND_P = { NULL };\n-use_operand_p NULL_USE_OPERAND_P = { NULL };\n \n static void note_addressable (tree, stmt_ann_t);\n static void get_expr_operands (tree, tree *, int);\n@@ -165,7 +165,7 @@ allocate_use_optype (unsigned num)\n {\n   use_optype use_ops;\n   unsigned size;\n-  size = sizeof (struct use_optype_d) + sizeof (tree *) * (num - 1);\n+  size = sizeof (struct use_optype_d) + sizeof (use_operand_type_t) * (num - 1);\n   use_ops =  ggc_alloc (size);\n   use_ops->num_uses = num;\n   return use_ops;\n@@ -194,7 +194,8 @@ allocate_vuse_optype (unsigned num)\n {\n   vuse_optype vuse_ops;\n   unsigned size;\n-  size = sizeof (struct vuse_optype_d) + sizeof (tree) * (num - 1);\n+  size = sizeof (struct vuse_optype_d) \n+       + sizeof (vuse_operand_type_t) * (num - 1);\n   vuse_ops =  ggc_alloc (size);\n   vuse_ops->num_vuses = num;\n   return vuse_ops;\n@@ -222,6 +223,10 @@ free_uses (use_optype *uses)\n {\n   if (*uses)\n     {\n+      unsigned int x;\n+      use_optype use = *uses;\n+      for (x = 0; x < use->num_uses; x++)\n+        delink_imm_use (&(use->uses[x]));\n       ggc_free (*uses);\n       *uses = NULL;\n     }\n@@ -248,6 +253,10 @@ free_vuses (vuse_optype *vuses)\n {\n   if (*vuses)\n     {\n+      unsigned int x;\n+      vuse_optype vuse = *vuses;\n+      for (x = 0; x < vuse->num_vuses; x++)\n+        delink_imm_use (&(vuse->vuses[x].imm_use));\n       ggc_free (*vuses);\n       *vuses = NULL;\n     }\n@@ -261,6 +270,10 @@ free_v_may_defs (v_may_def_optype *v_may_defs)\n {\n   if (*v_may_defs)\n     {\n+      unsigned int x;\n+      v_may_def_optype v_may_def = *v_may_defs;\n+      for (x = 0; x < v_may_def->num_v_may_defs; x++)\n+        delink_imm_use (&(v_may_def->v_may_defs[x].imm_use));\n       ggc_free (*v_may_defs);\n       *v_may_defs = NULL;\n     }\n@@ -274,6 +287,10 @@ free_v_must_defs (v_must_def_optype *v_must_defs)\n {\n   if (*v_must_defs)\n     {\n+      unsigned int x;\n+      v_must_def_optype v_must_def = *v_must_defs;\n+      for (x = 0; x < v_must_def->num_v_must_defs; x++)\n+        delink_imm_use (&(v_must_def->v_must_defs[x].imm_use));\n       ggc_free (*v_must_defs);\n       *v_must_defs = NULL;\n     }\n@@ -322,6 +339,62 @@ fini_ssa_operands (void)\n     }\n }\n \n+/* Initialize V_USES index INDEX to VAL for STMT.  If OLD is present, preserve\n+   the position of the may-def in the immediate_use list.  */\n+\n+static inline void\n+initialize_vuse_operand (vuse_optype vuses, unsigned int index, tree val, \n+\t\t\t tree stmt, ssa_imm_use_t *old)\n+{\n+  vuse_operand_type_t *ptr;\n+  ptr = &(vuses->vuses[index]);\n+  ptr->use = val;\n+  ptr->imm_use.use = &(ptr->use);\n+  if (old)\n+    relink_imm_use_stmt (&(ptr->imm_use), old, stmt);\n+  else\n+    link_imm_use_stmt (&(ptr->imm_use), ptr->use, stmt);\n+}\n+\n+\n+/* Initialize V_MAY_DEF_OPS index X to be DEF = MAY_DEF <USE> for STMT.  If\n+   OLD is present, preserve the position of the may-def in the immediate_use\n+   list.  */\n+\n+static inline void\n+initialize_v_may_def_operand (v_may_def_optype v_may_def_ops, unsigned int x, \n+\t\t\t      tree def, tree use, tree stmt, ssa_imm_use_t *old)\n+{\n+  v_def_use_operand_type_t *ptr;\n+  ptr = &(v_may_def_ops->v_may_defs[x]);\n+  ptr->def = def;\n+  ptr->use = use;\n+  ptr->imm_use.use = &(ptr->use);\n+  if (old)\n+    relink_imm_use_stmt (&(ptr->imm_use), old, stmt);\n+  else\n+    link_imm_use_stmt (&(ptr->imm_use), ptr->use, stmt);\n+}\n+\n+\n+/* Initialize V_MUST_DEF_OPS index X to be DEF = MUST_DEF <USE> for STMT.  If\n+   OLD is present, preserve the position of the may-def in the immediate_use\n+   list.  */\n+\n+static inline void\n+initialize_v_must_def_operand (v_must_def_optype v_must_def_ops, unsigned int x,\n+\t\t\t      tree def, tree use, tree stmt, ssa_imm_use_t *old)\n+{\n+  v_def_use_operand_type_t *ptr;\n+  ptr = &(v_must_def_ops->v_must_defs[x]);\n+  ptr->def = def;\n+  ptr->use = use;\n+  ptr->imm_use.use = &(ptr->use);\n+  if (old)\n+    relink_imm_use_stmt (&(ptr->imm_use), old, stmt);\n+  else\n+    link_imm_use_stmt (&(ptr->imm_use), ptr->use, stmt);\n+}\n \n /* All the finalize_ssa_* routines do the work required to turn the build_\n    VARRAY into an operand_vector of the appropriate type.  The original vector,\n@@ -332,7 +405,7 @@ fini_ssa_operands (void)\n /* Return a new def operand vector for STMT, comparing to OLD_OPS_P.  */\n \n static def_optype\n-finalize_ssa_defs (def_optype *old_ops_p, tree stmt ATTRIBUTE_UNUSED)\n+finalize_ssa_defs (def_optype *old_ops_p, tree stmt)\n {\n   unsigned num, x;\n   def_optype def_ops, old_ops;\n@@ -343,13 +416,13 @@ finalize_ssa_defs (def_optype *old_ops_p, tree stmt ATTRIBUTE_UNUSED)\n     return NULL;\n \n   /* There should only be a single real definition per assignment.  */\n-  gcc_assert (TREE_CODE (stmt) != MODIFY_EXPR || num <= 1);\n+  gcc_assert ((stmt && TREE_CODE (stmt) != MODIFY_EXPR) || num <= 1);\n \n   old_ops = *old_ops_p;\n \n   /* Compare old vector and new array.  */\n   build_diff = true;\n-  if (old_ops && old_ops->num_defs == num)\n+  if (stmt && old_ops && old_ops->num_defs == num)\n     {\n       build_diff = false;\n       for (x = 0; x < num; x++)\n@@ -378,12 +451,45 @@ finalize_ssa_defs (def_optype *old_ops_p, tree stmt ATTRIBUTE_UNUSED)\n }\n \n \n+/* Make sure PTR is inn the correct immediate use list.  Since uses are simply\n+   pointers into the stmt TREE, there is no way of telling if anyone has\n+   changed what this pointer points to via TREE_OPERANDS (exp, 0) = <...>.\n+   THe contents are different, but the the pointer is still the same.  This\n+   routine will check to make sure PTR is in the correct list, and if it isn't\n+   put it in the correct list.  */\n+\n+static inline void\n+correct_use_link (ssa_imm_use_t *ptr, tree stmt)\n+{\n+  ssa_imm_use_t *prev;\n+  tree root;\n+\n+  /*  Fold_stmt () may have changed the stmt pointers.  */\n+  if (ptr->stmt != stmt)\n+    ptr->stmt = stmt;\n+\n+  prev = ptr->prev;\n+  if (prev)\n+    {\n+      /* find the root, which has a non-NULL stmt, and a NULL use.  */\n+      while (prev->stmt == NULL || prev->use != NULL)\n+        prev = prev->prev;\n+      root = prev->stmt;\n+      if (root == *(ptr->use))\n+\treturn;\n+    }\n+  /* Its in the wrong list if we reach here.  */\n+  delink_imm_use (ptr);\n+  link_imm_use (ptr, *(ptr->use));\n+}\n+\n+\n /* Return a new use operand vector for STMT, comparing to OLD_OPS_P.  */\n \n static use_optype\n-finalize_ssa_uses (use_optype *old_ops_p, tree stmt ATTRIBUTE_UNUSED)\n+finalize_ssa_uses (use_optype *old_ops_p, tree stmt)\n {\n-  unsigned num, x;\n+  unsigned num, x, num_old, i;\n   use_optype use_ops, old_ops;\n   bool build_diff;\n \n@@ -403,30 +509,53 @@ finalize_ssa_uses (use_optype *old_ops_p, tree stmt ATTRIBUTE_UNUSED)\n   }\n #endif\n   old_ops = *old_ops_p;\n+  num_old = ((stmt && old_ops) ? old_ops->num_uses : 0);\n \n   /* Check if the old vector and the new array are the same.  */\n   build_diff = true;\n-  if (old_ops && old_ops->num_uses == num)\n+  if (stmt && old_ops && num_old == num)\n     {\n       build_diff = false;\n       for (x = 0; x < num; x++)\n-        if (old_ops->uses[x].use != VARRAY_TREE_PTR (build_uses, x))\n-\t  {\n-\t    build_diff = true;\n-\t    break;\n-\t  }\n+        {\n+\t  tree *var_p = VARRAY_TREE_PTR (build_uses, x);\n+\t  tree *node = old_ops->uses[x].use;\n+\t  /* Check the pointer values to see if they are the same. */\n+\t  if (node != var_p)\n+\t    {\n+\t      build_diff = true;\n+\t      break;\n+\t    }\n+\t}\n     }\n \n   if (!build_diff)\n     {\n       use_ops = old_ops;\n       *old_ops_p = NULL;\n+      for (i = 0; i < num_old; i++)\n+        correct_use_link (&(use_ops->uses[i]), stmt);\n     }\n   else\n     {\n       use_ops = allocate_use_optype (num);\n       for (x = 0; x < num ; x++)\n-\tuse_ops->uses[x].use = VARRAY_TREE_PTR (build_uses, x);\n+        {\n+\t  tree *var = VARRAY_TREE_PTR (build_uses, x);\n+\t  use_ops->uses[x].use = var;\n+\t  for (i = 0; i < num_old; i++)\n+\t    {\n+\t      ssa_imm_use_t *ptr = &(old_ops->uses[i]);\n+\t      if (ptr->use == var)\n+\t\t{\n+\t\t  relink_imm_use_stmt (&(use_ops->uses[x]), ptr, stmt);\n+\t\t  correct_use_link (&(use_ops->uses[x]), stmt);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (i == num_old)\n+\t    link_imm_use_stmt (&(use_ops->uses[x]), *var, stmt);\n+\t}\n     }\n   VARRAY_POP_ALL (build_uses);\n \n@@ -437,7 +566,7 @@ finalize_ssa_uses (use_optype *old_ops_p, tree stmt ATTRIBUTE_UNUSED)\n /* Return a new v_may_def operand vector for STMT, comparing to OLD_OPS_P.  */\n \n static v_may_def_optype\n-finalize_ssa_v_may_defs (v_may_def_optype *old_ops_p)\n+finalize_ssa_v_may_defs (v_may_def_optype *old_ops_p, tree stmt)\n {\n   unsigned num, x, i, old_num;\n   v_may_def_optype v_may_def_ops, old_ops;\n@@ -452,7 +581,7 @@ finalize_ssa_v_may_defs (v_may_def_optype *old_ops_p)\n \n   /* Check if the old vector and the new array are the same.  */\n   build_diff = true;\n-  if (old_ops && old_ops->num_v_may_defs == num)\n+  if (stmt && old_ops && old_ops->num_v_may_defs == num)\n     {\n       old_num = num;\n       build_diff = false;\n@@ -475,6 +604,8 @@ finalize_ssa_v_may_defs (v_may_def_optype *old_ops_p)\n     {\n       v_may_def_ops = old_ops;\n       *old_ops_p = NULL;\n+      for (x = 0; x < num; x++)\n+        correct_use_link (&(v_may_def_ops->v_may_defs[x].imm_use), stmt);\n     }\n   else\n     {\n@@ -490,14 +621,18 @@ finalize_ssa_v_may_defs (v_may_def_optype *old_ops_p)\n \t\tresult = SSA_NAME_VAR (result);\n \t      if (result == var)\n \t        {\n-\t\t  v_may_def_ops->v_may_defs[x] = old_ops->v_may_defs[i];\n+\t\t  initialize_v_may_def_operand (v_may_def_ops, x, \n+\t\t\t\t\t\told_ops->v_may_defs[i].def,\n+\t\t\t\t\t\told_ops->v_may_defs[i].use,\n+\t\t\t\t\t\tstmt, \n+\t\t\t\t\t\t&(old_ops->v_may_defs[i].imm_use));\n \t\t  break;\n \t\t}\n \t    }\n \t  if (i == old_num)\n \t    {\n-\t      v_may_def_ops->v_may_defs[x].def = var;\n-\t      v_may_def_ops->v_may_defs[x].use = var;\n+\t      initialize_v_may_def_operand (v_may_def_ops, x, var, var, stmt, \n+\t\t\t\t\t    NULL);\n \t    }\n \t}\n     }\n@@ -528,7 +663,7 @@ cleanup_v_may_defs (void)\n /* Return a new vuse operand vector, comparing to OLD_OPS_P.  */\n \n static vuse_optype\n-finalize_ssa_vuses (vuse_optype *old_ops_p)\n+finalize_ssa_vuses (vuse_optype *old_ops_p, tree stmt)\n {\n   unsigned num, x, i, num_v_may_defs, old_num;\n   vuse_optype vuse_ops, old_ops;\n@@ -613,14 +748,14 @@ finalize_ssa_vuses (vuse_optype *old_ops_p)\n \n   /* Determine whether vuses is the same as the old vector.  */\n   build_diff = true;\n-  if (old_ops && old_ops->num_vuses == num)\n+  if (stmt && old_ops && old_ops->num_vuses == num)\n     {\n       old_num = num;\n       build_diff = false;\n       for (x = 0; x < num ; x++)\n         {\n \t  tree v;\n-\t  v = old_ops->vuses[x];\n+\t  v = old_ops->vuses[x].use;\n \t  if (TREE_CODE (v) == SSA_NAME)\n \t    v = SSA_NAME_VAR (v);\n \t  if (v != VARRAY_TREE (build_vuses, x))\n@@ -637,6 +772,8 @@ finalize_ssa_vuses (vuse_optype *old_ops_p)\n     {\n       vuse_ops = old_ops;\n       *old_ops_p = NULL;\n+      for (x = 0; x < num; x++)\n+        correct_use_link (&(vuse_ops->vuses[x].imm_use), stmt);\n     }\n   else\n     {\n@@ -647,17 +784,18 @@ finalize_ssa_vuses (vuse_optype *old_ops_p)\n \t  /* Look for VAR in the old vector, and use that SSA_NAME.  */\n \t  for (i = 0; i < old_num; i++)\n \t    {\n-\t      result = old_ops->vuses[i];\n+\t      result = old_ops->vuses[i].use;\n \t      if (TREE_CODE (result) == SSA_NAME)\n \t\tresult = SSA_NAME_VAR (result);\n \t      if (result == var)\n \t        {\n-\t\t  vuse_ops->vuses[x] = old_ops->vuses[i];\n+\t\t  initialize_vuse_operand (vuse_ops, x, old_ops->vuses[i].use, \n+\t\t\t\t\t   stmt, &(old_ops->vuses[i].imm_use));\n \t\t  break;\n \t\t}\n \t    }\n \t  if (i == old_num)\n-\t    vuse_ops->vuses[x] = var;\n+\t    initialize_vuse_operand (vuse_ops, x, var, stmt, NULL);\n \t}\n     }\n \n@@ -672,11 +810,11 @@ finalize_ssa_vuses (vuse_optype *old_ops_p)\n /* Return a new v_must_def operand vector for STMT, comparing to OLD_OPS_P.  */\n \n static v_must_def_optype\n-finalize_ssa_v_must_defs (v_must_def_optype *old_ops_p, \n-\t\t\t  tree stmt ATTRIBUTE_UNUSED)\n+finalize_ssa_v_must_defs (v_must_def_optype *old_ops_p, tree stmt)\n {\n   unsigned num, x, i, old_num = 0;\n   v_must_def_optype v_must_def_ops, old_ops;\n+  tree result, var;\n   bool build_diff;\n \n   num = VARRAY_ACTIVE_SIZE (build_v_must_defs);\n@@ -694,7 +832,7 @@ finalize_ssa_v_must_defs (v_must_def_optype *old_ops_p,\n \n   /* Check if the old vector and the new array are the same.  */\n   build_diff = true;\n-  if (old_ops && old_ops->num_v_must_defs == num)\n+  if (stmt && old_ops && old_ops->num_v_must_defs == num)\n     {\n       old_num = num;\n       build_diff = false;\n@@ -717,13 +855,15 @@ finalize_ssa_v_must_defs (v_must_def_optype *old_ops_p,\n     {\n       v_must_def_ops = old_ops;\n       *old_ops_p = NULL;\n+      for (x = 0; x < num; x++)\n+        correct_use_link (&(v_must_def_ops->v_must_defs[x].imm_use), stmt);\n     }\n   else\n     {\n       v_must_def_ops = allocate_v_must_def_optype (num);\n       for (x = 0; x < num ; x++)\n \t{\n-\t  tree result, var = VARRAY_TREE (build_v_must_defs, x);\n+\t  var = VARRAY_TREE (build_v_must_defs, x);\n \t  /* Look for VAR in the original vector.  */\n \t  for (i = 0; i < old_num; i++)\n \t    {\n@@ -732,15 +872,18 @@ finalize_ssa_v_must_defs (v_must_def_optype *old_ops_p,\n \t\tresult = SSA_NAME_VAR (result);\n \t      if (result == var)\n \t        {\n-\t\t  v_must_def_ops->v_must_defs[x].def = old_ops->v_must_defs[i].def;\n-\t\t  v_must_def_ops->v_must_defs[x].use = old_ops->v_must_defs[i].use;\n+\t\t  initialize_v_must_def_operand (v_must_def_ops, x,\n+\t\t\t\t\t\t old_ops->v_must_defs[i].def,\n+\t\t\t\t\t\t old_ops->v_must_defs[i].use,\n+\t\t\t\t\t\t stmt,\n+\t\t\t\t\t\t &(old_ops->v_must_defs[i].imm_use));\n \t\t  break;\n \t\t}\n \t    }\n \t  if (i == old_num)\n \t    {\n-\t      v_must_def_ops->v_must_defs[x].def = var;\n-\t      v_must_def_ops->v_must_defs[x].use = var;\n+\t      initialize_v_must_def_operand (v_must_def_ops, x, var, var, stmt,\n+\t      \t\t\t\t     NULL);\n \t    }\n \t}\n     }\n@@ -760,8 +903,9 @@ finalize_ssa_stmt_operands (tree stmt, stmt_operands_p old_ops,\n   new_ops->use_ops = finalize_ssa_uses (&(old_ops->use_ops), stmt);\n   new_ops->v_must_def_ops \n     = finalize_ssa_v_must_defs (&(old_ops->v_must_def_ops), stmt);\n-  new_ops->v_may_def_ops = finalize_ssa_v_may_defs (&(old_ops->v_may_def_ops));\n-  new_ops->vuse_ops = finalize_ssa_vuses (&(old_ops->vuse_ops));\n+  new_ops->v_may_def_ops \n+    = finalize_ssa_v_may_defs (&(old_ops->v_may_def_ops), stmt);\n+  new_ops->vuse_ops = finalize_ssa_vuses (&(old_ops->vuse_ops), stmt);\n }\n \n \n@@ -847,46 +991,15 @@ append_v_must_def (tree var)\n   VARRAY_PUSH_TREE (build_v_must_defs, var);\n }\n \n-/* Create an operands cache for STMT, returning it in NEW_OPS. OLD_OPS are the\n-   original operands, and if ANN is non-null, appropriate stmt flags are set\n-   in the stmt's annotation.  Note that some fields in old_ops may \n-   change to NULL, although none of the memory they originally pointed to \n-   will be destroyed.  It is appropriate to call free_stmt_operands() on \n-   the value returned in old_ops.\n-\n-   The rationale for this: Certain optimizations wish to examine the difference\n-   between new_ops and old_ops after processing.  If a set of operands don't\n-   change, new_ops will simply assume the pointer in old_ops, and the old_ops\n-   pointer will be set to NULL, indicating no memory needs to be cleared.  \n-   Usage might appear something like:\n-\n-       old_ops_copy = old_ops = stmt_ann(stmt)->operands;\n-       build_ssa_operands (stmt, NULL, &old_ops, &new_ops);\n-          <* compare old_ops_copy and new_ops *>\n-       free_ssa_operands (old_ops);\t\t\t\t\t*/\n \n+/* Parse STMT looking for operands.  OLD_OPS is the original stmt operand\n+   cache for STMT, if it exested before.  When fniished, the various build_*\n+   operand vectors will have potential operands. in them.  */\n+                                                                                \n static void\n-build_ssa_operands (tree stmt, stmt_ann_t ann, stmt_operands_p old_ops, \n-\t\t    stmt_operands_p new_ops)\n+parse_ssa_operands (tree stmt)\n {\n   enum tree_code code;\n-  tree_ann_t saved_ann = stmt->common.ann;\n-  \n-  /* Replace stmt's annotation with the one passed in for the duration\n-     of the operand building process.  This allows \"fake\" stmts to be built\n-     and not be included in other data structures which can be built here.  */\n-  stmt->common.ann = (tree_ann_t) ann;\n-  \n-  /* Initially assume that the statement has no volatile operands, nor\n-     makes aliased loads or stores.  */\n-  if (ann)\n-    {\n-      ann->has_volatile_ops = false;\n-      ann->makes_aliased_stores = false;\n-      ann->makes_aliased_loads = false;\n-    }\n-\n-  start_ssa_stmt_operands ();\n \n   code = TREE_CODE (stmt);\n   switch (code)\n@@ -963,8 +1076,62 @@ build_ssa_operands (tree stmt, stmt_ann_t ann, stmt_operands_p old_ops,\n       get_expr_operands (stmt, &stmt, opf_none);\n       break;\n     }\n+}\n+\n+/* Create an operands cache for STMT, returning it in NEW_OPS. OLD_OPS are the\n+   original operands, and if ANN is non-null, appropriate stmt flags are set\n+   in the stmt's annotation.  If ANN is NULL, this is not considered a \"real\"\n+   stmt, and none of the operands will be entered into their respective\n+   immediate uses tables.  This is to allow stmts to be processed when they\n+   are not actually in the CFG.\n+\n+   Note that some fields in old_ops may change to NULL, although none of the\n+   memory they originally pointed to will be destroyed.  It is appropriate\n+   to call free_stmt_operands() on the value returned in old_ops.\n+\n+   The rationale for this: Certain optimizations wish to examine the difference\n+   between new_ops and old_ops after processing.  If a set of operands don't\n+   change, new_ops will simply assume the pointer in old_ops, and the old_ops\n+   pointer will be set to NULL, indicating no memory needs to be cleared.  \n+   Usage might appear something like:\n+\n+       old_ops_copy = old_ops = stmt_ann(stmt)->operands;\n+       build_ssa_operands (stmt, NULL, &old_ops, &new_ops);\n+          <* compare old_ops_copy and new_ops *>\n+       free_ssa_operands (old_ops);\t\t\t\t\t*/\n+\n+static void\n+build_ssa_operands (tree stmt, stmt_ann_t ann, stmt_operands_p old_ops, \n+\t\t    stmt_operands_p new_ops)\n+{\n+  tree_ann_t saved_ann = stmt->common.ann;\n+  \n+  /* Replace stmt's annotation with the one passed in for the duration\n+     of the operand building process.  This allows \"fake\" stmts to be built\n+     and not be included in other data structures which can be built here.  */\n+  stmt->common.ann = (tree_ann_t) ann;\n \n-  finalize_ssa_stmt_operands (stmt, old_ops, new_ops);\n+  parse_old_ops = old_ops;\n+  \n+  /* Initially assume that the statement has no volatile operands, nor\n+     makes aliased loads or stores.  */\n+  if (ann)\n+    {\n+      ann->has_volatile_ops = false;\n+      ann->makes_aliased_stores = false;\n+      ann->makes_aliased_loads = false;\n+    }\n+\n+  start_ssa_stmt_operands ();\n+\n+  parse_ssa_operands (stmt);\n+\n+  parse_old_ops = NULL;\n+\n+  if (ann)\n+    finalize_ssa_stmt_operands (stmt, old_ops, new_ops);\n+  else\n+    finalize_ssa_stmt_operands (NULL, old_ops, new_ops);\n   stmt->common.ann = saved_ann;\n }\n \n@@ -987,25 +1154,73 @@ free_ssa_operands (stmt_operands_p ops)\n }\n \n \n+/* Swap operands EXP0 and EXP1 in STMT.  */\n+\n+static void\n+swap_tree_operands (tree *exp0, tree *exp1)\n+{\n+  tree op0, op1;\n+  op0 = *exp0;\n+  op1 = *exp1;\n+\n+  /* If the operand cache is active, attempt to preserve the relative positions\n+     of these two operands in their respective immediate use lists.  */\n+  if (build_defs != NULL && op0 != op1 && parse_old_ops != NULL)\n+    {\n+      unsigned x, use0, use1;\n+      use_optype uses = parse_old_ops->use_ops;\n+      use0 = use1 = NUM_USES (uses);\n+      /* Find the 2 operands in the cache, if they are there.  */\n+      for (x = 0; x < NUM_USES (uses); x++)\n+\tif (USE_OP_PTR (uses, x)->use == exp0)\n+\t  {\n+\t    use0 = x;\n+\t    break;\n+\t  }\n+      for (x = 0; x < NUM_USES (uses); x++)\n+\tif (USE_OP_PTR (uses, x)->use == exp1)\n+\t  {\n+\t    use1 = x;\n+\t    break;\n+\t  }\n+      /* If both uses don't have operand entries, there isnt much we can do\n+         at this point. Presumably we dont need to worry about it.  */\n+      if (use0 != NUM_USES (uses) && use1 != NUM_USES (uses))\n+        {\n+\t  tree *tmp = USE_OP_PTR (uses, use1)->use;\n+\t  gcc_assert (use0 != use1);\n+\n+\t  USE_OP_PTR (uses, use1)->use = USE_OP_PTR (uses, use0)->use;\n+\t  USE_OP_PTR (uses, use0)->use = tmp;\n+\t}\n+    }\n+\n+  /* Now swap the data.  */\n+  *exp0 = op1;\n+  *exp1 = op0;\n+}\n+\n /* Get the operands of statement STMT.  Note that repeated calls to\n    get_stmt_operands for the same statement will do nothing until the\n-   statement is marked modified by a call to modify_stmt().  */\n+   statement is marked modified by a call to mark_stmt_modified().  */\n \n void\n-get_stmt_operands (tree stmt)\n+update_stmt_operands (tree stmt)\n {\n   stmt_ann_t ann;\n   stmt_operands_t old_operands;\n \n+  /* If get_stmt_operands is called before SSA is initialized, dont\n+  do anything.  */\n+  if (build_defs == NULL)\n+    return;\n   /* The optimizers cannot handle statements that are nothing but a\n      _DECL.  This indicates a bug in the gimplifier.  */\n   gcc_assert (!SSA_VAR_P (stmt));\n \n   ann = get_stmt_ann (stmt);\n \n-  /* If the statement has not been modified, the operands are still valid.  */\n-  if (!ann->modified)\n-    return;\n+  gcc_assert (ann->modified);\n \n   timevar_push (TV_TREE_OPS);\n \n@@ -1017,7 +1232,7 @@ get_stmt_operands (tree stmt)\n \n   /* Clear the modified bit for STMT.  Subsequent calls to\n      get_stmt_operands for this statement will do nothing until the\n-     statement is marked modified by a call to modify_stmt().  */\n+     statement is marked modified by a call to mark_stmt_modified().  */\n   ann->modified = 0;\n \n   timevar_pop (TV_TREE_OPS);\n@@ -1239,15 +1454,15 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \t\t|| code == GE_EXPR)\n \t      {\n \t\tTREE_SET_CODE (expr, swap_tree_comparison (code));\n-\t\tTREE_OPERAND (expr, 0) = op1;\n-\t\tTREE_OPERAND (expr, 1) = op0;\n+\t\tswap_tree_operands (&TREE_OPERAND (expr, 0),\t\t\t\n+\t\t\t\t    &TREE_OPERAND (expr, 1));\n \t      }\n \t  \n \t    /* For a commutative operator we can just swap the operands.  */\n \t    else if (commutative_tree_code (code))\n \t      {\n-\t\tTREE_OPERAND (expr, 0) = op1;\n-\t\tTREE_OPERAND (expr, 1) = op0;\n+\t\tswap_tree_operands (&TREE_OPERAND (expr, 0),\t\t\t\n+\t\t\t\t    &TREE_OPERAND (expr, 1));\n \t      }\n \t  }\n \n@@ -1884,27 +2099,31 @@ copy_virtual_operands (tree dst, tree src)\n     {\n       *vuses_new = allocate_vuse_optype (NUM_VUSES (vuses));\n       for (i = 0; i < NUM_VUSES (vuses); i++)\n-\tSET_VUSE_OP (*vuses_new, i, VUSE_OP (vuses, i));\n+\tinitialize_vuse_operand (*vuses_new, i, VUSE_OP (vuses, i), dst, NULL);\n     }\n \n   if (v_may_defs)\n     {\n       *v_may_defs_new = allocate_v_may_def_optype (NUM_V_MAY_DEFS (v_may_defs));\n       for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n \t{\n-\t  SET_V_MAY_DEF_OP (*v_may_defs_new, i, V_MAY_DEF_OP (v_may_defs, i));\n-\t  SET_V_MAY_DEF_RESULT (*v_may_defs_new, i, \n-\t\t\t\tV_MAY_DEF_RESULT (v_may_defs, i));\n+\t  initialize_v_may_def_operand (*v_may_defs_new, i, \n+\t\t\t\t\tV_MAY_DEF_RESULT (v_may_defs, i),\n+\t\t\t\t\tV_MAY_DEF_OP (v_may_defs, i), dst,\n+\t\t\t\t\tNULL);\n \t}\n     }\n \n   if (v_must_defs)\n     {\n-      *v_must_defs_new = allocate_v_must_def_optype (NUM_V_MUST_DEFS (v_must_defs));\n+      *v_must_defs_new \n+\t = allocate_v_must_def_optype (NUM_V_MUST_DEFS (v_must_defs));\n       for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n \t{\n-\t  SET_V_MUST_DEF_RESULT (*v_must_defs_new, i, V_MUST_DEF_RESULT (v_must_defs, i));\n-\t  SET_V_MUST_DEF_KILL (*v_must_defs_new, i, V_MUST_DEF_KILL (v_must_defs, i));\n+\t  initialize_v_must_def_operand (*v_must_defs_new, i, \n+\t\t\t\t\t V_MUST_DEF_RESULT (v_must_defs, i),\n+\t\t\t\t\t V_MUST_DEF_KILL (v_must_defs, i), dst,\n+\t\t\t\t\t NULL);\n \t}\n     }\n }\n@@ -1951,7 +2170,173 @@ create_ssa_artficial_load_stmt (stmt_operands_p old_ops, tree new_stmt)\n     }\n \n   /* Now set the vuses for this new stmt.  */\n-  ann->operands.vuse_ops = finalize_ssa_vuses (&(tmp.vuse_ops));\n+  ann->operands.vuse_ops = finalize_ssa_vuses (&(tmp.vuse_ops), NULL);\n+}\n+\n+\n+\n+/* Issue immediate use error for VAR to debug file F.  */\n+static void \n+verify_abort (FILE *f, ssa_imm_use_t *var)\n+{\n+  tree stmt;\n+  stmt = var->stmt;\n+  if (stmt)\n+    {\n+      if (stmt_modified_p(stmt))\n+\t{\n+\t  fprintf (f, \" STMT MODIFIED. - <0x%x> \", (unsigned int)stmt);\n+\t  print_generic_stmt (f, stmt, TDF_SLIM);\n+\t}\n+    }\n+  fprintf (f, \" IMM ERROR : (use_p : tree: 0x%X:0x%x)\", (unsigned int)var, \n+\t   (unsigned int)var->use);\n+  print_generic_expr (f, USE_FROM_PTR (var), TDF_SLIM);\n+  fprintf(f, \"\\n\");\n+}\n+\n+\n+/* Scan the immediate_use list for VAR making sure its linked properly.\n+   return RTUE iof there is a problem.  */\n+\n+bool\n+verify_imm_links (FILE *f, tree var)\n+{\n+  ssa_imm_use_t *ptr, *prev;\n+  ssa_imm_use_t *list;\n+  int count;\n+\n+  gcc_assert (TREE_CODE (var) == SSA_NAME);\n+\n+  list = &(SSA_NAME_IMM_USE_NODE (var));\n+  gcc_assert (list->use == NULL);\n+\n+  if (list->prev == NULL)\n+    {\n+      gcc_assert (list->next == NULL);\n+      return false;\n+    }\n+\n+  prev = list;\n+  count = 0;\n+  for (ptr = list->next; ptr != list; )\n+    {\n+      if (prev != ptr->prev)\n+        {\n+\t  verify_abort (f, ptr);\n+\t  return true;\n+\t}\n+\n+      if (ptr->use == NULL)\n+        {\n+\t  verify_abort (f, ptr); \t/* 2 roots, or SAFE guard node.  */\n+\t  return true;\n+\t}\n+      else\n+\tif (*(ptr->use) != var)\n+\t  {\n+\t    verify_abort (f, ptr);\n+\t    return true;\n+\t  }\n+\n+      prev = ptr;\n+      ptr = ptr->next;\n+      /* Avoid infinite loops.  */\n+      if (count++ > 30000)\n+\t{\n+\t  verify_abort (f, ptr);\n+\t  return true;\n+\t}\n+    }\n+\n+  /* Verify list in the other direction.  */\n+  prev = list;\n+  for (ptr = list->prev; ptr != list; )\n+    {\n+      if (prev != ptr->next)\n+\t{\n+\t  verify_abort (f, ptr);\n+\t  return true;\n+\t}\n+      prev = ptr;\n+      ptr = ptr->prev;\n+      if (count-- < 0)\n+\t{\n+\t  verify_abort (f, ptr);\n+\t  return true;\n+\t}\n+    }\n+\n+  if (count != 0)\n+    {\n+      verify_abort (f, ptr);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Dump all the immediate uses to FILE.  */\n+\n+void\n+dump_immediate_uses_for (FILE *file, tree var)\n+{\n+  imm_use_iterator iter;\n+  use_operand_p use_p;\n+\n+  gcc_assert (var && TREE_CODE (var) == SSA_NAME);\n+\n+  print_generic_expr (file, var, TDF_SLIM);\n+  fprintf (file, \" : -->\");\n+  if (has_zero_uses (var))\n+    fprintf (file, \" no uses.\\n\");\n+  else\n+    if (has_single_use (var))\n+      fprintf (file, \" single use.\\n\");\n+    else\n+      fprintf (file, \"%d uses.\\n\", num_imm_uses (var));\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n+    {\n+      print_generic_stmt (file, USE_STMT (use_p), TDF_SLIM);\n+    }\n+  fprintf(file, \"\\n\");\n+}\n+\n+/* Dump all the immediate uses to FILE.  */\n+\n+void\n+dump_immediate_uses (FILE *file)\n+{\n+  tree var;\n+  unsigned int x;\n+\n+  fprintf (file, \"Immediate_uses: \\n\\n\");\n+  for (x = 1; x < num_ssa_names; x++)\n+    {\n+      var = ssa_name(x);\n+      if (!var)\n+        continue;\n+      dump_immediate_uses_for (file, var);\n+    }\n+}\n+\n+\n+/* Dump def-use edges on stderr.  */\n+\n+void\n+debug_immediate_uses (void)\n+{\n+  dump_immediate_uses (stderr);\n+}\n+\n+/* Dump def-use edges on stderr.  */\n+\n+void\n+debug_immediate_uses_for (tree var)\n+{\n+  dump_immediate_uses_for (stderr, var);\n }\n \n #include \"gt-tree-ssa-operands.h\""}, {"sha": "e2a8a50a9def29fca1ed2a3877c3d8ae9710f9d9", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -31,13 +31,10 @@ typedef struct def_operand_ptr GTY(())\n } def_operand_p;\n \n /* This represents a pointer to a USE operand.  */\n-typedef struct use_operand_ptr GTY(())\n-{\n-  tree * GTY((skip(\"\"))) use;\n-} use_operand_p;\n+typedef ssa_imm_use_t *use_operand_p;\n \n+#define NULL_USE_OPERAND_P \t\tNULL\n extern def_operand_p NULL_DEF_OPERAND_P;\n-extern use_operand_p NULL_USE_OPERAND_P;\n \n /* This represents the DEF operands of a stmt.  */\n typedef struct def_optype_d GTY(())\n@@ -48,20 +45,24 @@ typedef struct def_optype_d GTY(())\n \n typedef def_optype_t *def_optype;\n \n+/* Operand type which uses a pointer to a tree ihn an immediate use.  */\n+typedef ssa_imm_use_t use_operand_type_t;\n+\n /* This represents the USE operands of a stmt.  */\n typedef struct use_optype_d GTY(())\n {\n   unsigned num_uses; \n-  struct use_operand_ptr GTY((length(\"%h.num_uses\"))) uses[1];\n+  struct ssa_imm_use_d GTY((length(\"%h.num_uses\"))) uses[1];\n } use_optype_t;\n \n typedef use_optype_t *use_optype;\n \n-/* Operand type which stores a def and a use tree.  */\n+/* Operand type which stores a def a use, and an immediate use.  */\n typedef struct v_def_use_operand_type GTY(())\n {\n   tree def;\n   tree use;\n+  ssa_imm_use_t imm_use;\n } v_def_use_operand_type_t;\n \n /* This represents the MAY_DEFS for a stmt.  */\n@@ -74,11 +75,18 @@ typedef struct v_may_def_optype_d GTY(())\n \n typedef v_may_def_optype_t *v_may_def_optype;\n \n+/* Operand type which stores a tree and an immeidate_use.  */\n+typedef struct vuse_operand_type GTY(())\n+{\n+  tree use;\n+  ssa_imm_use_t imm_use;\n+} vuse_operand_type_t;\n+\n /* This represents the VUSEs for a stmt.  */\n typedef struct vuse_optype_d GTY(()) \n {\n   unsigned num_vuses; \n-  tree GTY((length (\"%h.num_vuses\"))) vuses[1];\n+  struct vuse_operand_type GTY((length (\"%h.num_vuses\"))) vuses[1];\n } vuse_optype_t;\n \n typedef vuse_optype_t *vuse_optype;\n@@ -109,9 +117,10 @@ typedef stmt_operands_t *stmt_operands_p;\n \n #define USE_FROM_PTR(OP)\tget_use_from_ptr (OP)\n #define DEF_FROM_PTR(OP)\tget_def_from_ptr (OP)\n-#define SET_USE(OP, V)\t\t((*((OP).use)) = (V))\n+#define SET_USE(OP, V)\t\tset_ssa_use_from_ptr (OP, V)\n #define SET_DEF(OP, V)\t\t((*((OP).def)) = (V))\n \n+#define USE_STMT(OP)\t\t(OP)->stmt\n \n #define USE_OPS(ANN)\t\tget_use_ops (ANN)\n #define STMT_USE_OPS(STMT)\tget_use_ops (stmt_ann (STMT))\n@@ -178,14 +187,22 @@ typedef stmt_operands_t *stmt_operands_p;\n \t\t\t\tPHI_ARG_DEF ((PHI), (E)->dest_idx)\n #define PHI_ARG_DEF_PTR_FROM_EDGE(PHI, E)\t\t\t\t\\\n \t\t\t\tPHI_ARG_DEF_PTR ((PHI), (E)->dest_idx)\n+#define PHI_ARG_INDEX_FROM_USE(USE)   phi_arg_index_from_use (USE)\n \n \n extern void init_ssa_operands (void);\n extern void fini_ssa_operands (void);\n-extern void get_stmt_operands (tree);\n+extern void update_stmt_operands (tree);\n+extern bool verify_imm_links (FILE *f, tree var);\n+\n extern void copy_virtual_operands (tree, tree);\n extern void create_ssa_artficial_load_stmt (stmt_operands_p, tree);\n \n+extern void dump_immediate_uses (FILE *file);\n+extern void dump_immediate_uses_for (FILE *file, tree var);\n+extern void debug_immediate_uses (void);\n+extern void debug_immediate_uses_for (tree var);\n+\n extern bool ssa_call_clobbered_cache_valid;\n extern bool ssa_ro_call_cache_valid;\n "}, {"sha": "41370ed114ad7172a1317e0614efad5a942c79b2", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -313,7 +313,7 @@ replace_phi_edge_with_variable (basic_block cond_block, basic_block bb,\n   block_stmt_iterator bsi;\n \n   /* Change the PHI argument to new.  */\n-  PHI_ARG_DEF_TREE (phi, e->dest_idx) = new;\n+  SET_USE (PHI_ARG_DEF_PTR (phi, e->dest_idx), new);\n \n   /* Remove the empty basic block.  */\n   if (EDGE_SUCC (cond_block, 0)->dest == bb)"}, {"sha": "34b759cb8808a743cc60a07ae1d4762d53d5ca21", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -2056,7 +2056,7 @@ eliminate (void)\n \t\t    NECESSARY (SSA_NAME_DEF_STMT (sprime)) = 1;\n \t\t  pre_stats.eliminations++;\n \t\t  propagate_tree_value (rhs_p, sprime);\n-\t\t  modify_stmt (stmt);\n+\t\t  update_stmt (stmt);\n \n \t\t  /* If we removed EH side effects from the statement, clean\n \t\t     its EH information.  */"}, {"sha": "c57c9f8695ae1884d8031385db6f2a0b6de94ecf", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -232,14 +232,12 @@ cfg_blocks_get (void)\n static void\n add_ssa_edge (tree var, bool is_varying)\n {\n-  tree stmt = SSA_NAME_DEF_STMT (var);\n-  dataflow_t df = get_immediate_uses (stmt);\n-  int num_uses = num_immediate_uses (df);\n-  int i;\n+  imm_use_iterator iter;\n+  use_operand_p use_p;\n \n-  for (i = 0; i < num_uses; i++)\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n     {\n-      tree use_stmt = immediate_use (df, i);\n+      tree use_stmt = USE_STMT (use_p);\n \n       if (!DONT_SIMULATE_AGAIN (use_stmt)\n \t  && !STMT_IN_SSA_EDGE_WORKLIST (use_stmt))\n@@ -507,7 +505,6 @@ ssa_prop_fini (void)\n   cfg_blocks = NULL;\n   sbitmap_free (bb_in_list);\n   sbitmap_free (executable_blocks);\n-  free_df ();\n }\n \n "}, {"sha": "af72e17ae98789a6dc284c884be0dc3bbcc09644", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 63, "deletions": 42, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -109,21 +109,26 @@ find_bb_for_arg (tree phi, tree def)\n    used in, so that you only have one place you can sink it to.  */\n \n static bool\n-all_immediate_uses_same_place (dataflow_t imm)\n+all_immediate_uses_same_place (tree stmt)\n {\n-  int i;\n-  tree firstuse;\n-\n-  if (imm == NULL || num_immediate_uses (imm) < 2)\n-    return true;\n-  firstuse = immediate_use (imm, 0);\n+  tree firstuse = NULL_TREE;\n+  ssa_op_iter op_iter;\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  tree var;\n \n-  for (i = 1; i < num_immediate_uses (imm); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, op_iter, SSA_OP_ALL_DEFS)\n     {\n-      tree immuse = immediate_use (imm, i);\n-      if (immuse != firstuse)\n-\treturn false;\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n+        {\n+\t  if (firstuse == NULL_TREE)\n+\t    firstuse = USE_STMT (use_p);\n+\t  else\n+\t    if (firstuse != USE_STMT (use_p))\n+\t      return false;\n+\t}\n     }\n+\n   return true;\n }\n \n@@ -215,24 +220,43 @@ is_hidden_global_store (tree stmt)\n /* Find the nearest common dominator of all of the immediate uses in IMM.  */\n \n static basic_block\n-nearest_common_dominator_of_uses (dataflow_t imm)\n+nearest_common_dominator_of_uses (tree stmt)\n {  \n   bitmap blocks = BITMAP_ALLOC (NULL);\n   basic_block commondom;\n-  int i;\n   unsigned int j;\n   bitmap_iterator bi;\n+  ssa_op_iter op_iter;\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  tree var;\n+\n   bitmap_clear (blocks);\n-  for (i = 0; i < num_immediate_uses (imm); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, op_iter, SSA_OP_ALL_DEFS)\n     {\n-      tree usestmt = immediate_use (imm, i);\n-      basic_block useblock;\n-      if (TREE_CODE (usestmt) == PHI_NODE)\n-\t{\n-\t  int j;\n-\t  for (j = 0; j < PHI_NUM_ARGS (usestmt); j++)\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n+        {\n+\t  tree usestmt = USE_STMT (use_p);\n+\t  basic_block useblock;\n+\t  if (TREE_CODE (usestmt) == PHI_NODE)\n+\t    {\n+\t      int j;\n+\t      for (j = 0; j < PHI_NUM_ARGS (usestmt); j++)\n+\t\t{\n+\t\t  useblock = PHI_ARG_EDGE (usestmt, j)->src;\n+\t\t  /* Short circuit. Nothing dominates the entry block.  */\n+\t\t  if (useblock == ENTRY_BLOCK_PTR)\n+\t\t    {\n+\t\t      BITMAP_FREE (blocks);\n+\t\t      return NULL;\n+\t\t    }\n+\t\t  bitmap_set_bit (blocks, useblock->index);\n+\t\t}\n+\t    }\n+\t  else\n \t    {\n-\t      useblock = PHI_ARG_EDGE (usestmt, j)->src;\n+\t      useblock = bb_for_stmt (usestmt);\n+\n \t      /* Short circuit. Nothing dominates the entry block.  */\n \t      if (useblock == ENTRY_BLOCK_PTR)\n \t\t{\n@@ -242,18 +266,6 @@ nearest_common_dominator_of_uses (dataflow_t imm)\n \t      bitmap_set_bit (blocks, useblock->index);\n \t    }\n \t}\n-      else\n-\t{\n-\t  useblock = bb_for_stmt (usestmt);\n-\n-\t  /* Short circuit. Nothing dominates the entry block.  */\n-\t  if (useblock == ENTRY_BLOCK_PTR)\n-\t    {\n-\t      BITMAP_FREE (blocks);\n-\t      return NULL;\n-\t    }\n-\t  bitmap_set_bit (blocks, useblock->index);\n-\t}\n     }\n   commondom = BASIC_BLOCK (bitmap_first_set_bit (blocks));\n   EXECUTE_IF_SET_IN_BITMAP (blocks, 0, j, bi)\n@@ -271,16 +283,28 @@ nearest_common_dominator_of_uses (dataflow_t imm)\n static tree\n statement_sink_location (tree stmt, basic_block frombb)\n {\n-  dataflow_t imm = get_immediate_uses (stmt);\n   tree use, def;\n+  use_operand_p one_use = NULL_USE_OPERAND_P;\n   basic_block sinkbb;\n   use_operand_p use_p;\n   def_operand_p def_p;\n   ssa_op_iter iter;\n   stmt_ann_t ann;\n   tree rhs;\n+  imm_use_iterator imm_iter;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n+    {\n+      FOR_EACH_IMM_USE_FAST (one_use, imm_iter, def)\n+\t{\n+\t  break;\n+\t}\n+      if (one_use != NULL_USE_OPERAND_P)\n+        break;\n+    }\n \n-  if (imm == NULL)\n+  /* Return if there are no immediate uses of this stmt.  */\n+  if (one_use == NULL_USE_OPERAND_P)\n     return NULL;\n \n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n@@ -314,8 +338,7 @@ statement_sink_location (tree stmt, basic_block frombb)\n       || TREE_CODE (rhs) == EXC_PTR_EXPR\n       || TREE_CODE (rhs) == FILTER_EXPR\n       || is_hidden_global_store (stmt)\n-      || ann->has_volatile_ops\n-      || num_immediate_uses (imm) == 0)\n+      || ann->has_volatile_ops)\n     return NULL;\n   \n   FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n@@ -337,9 +360,9 @@ statement_sink_location (tree stmt, basic_block frombb)\n      common dominator of all the immediate uses.  For PHI nodes, we have to\n      find the nearest common dominator of all of the predecessor blocks, since\n      that is where insertion would have to take place.  */\n-  if (!all_immediate_uses_same_place (imm))\n+  if (!all_immediate_uses_same_place (stmt))\n     {\n-      basic_block commondom = nearest_common_dominator_of_uses (imm);\n+      basic_block commondom = nearest_common_dominator_of_uses (stmt);\n      \n       if (commondom == frombb)\n \treturn NULL;\n@@ -371,7 +394,7 @@ statement_sink_location (tree stmt, basic_block frombb)\n       return first_stmt (commondom);\n     }\n \n-  use = immediate_use (imm, 0);\n+  use = USE_STMT (one_use);\n   if (TREE_CODE (use) != PHI_NODE)\n     {\n       sinkbb = bb_for_stmt (use);\n@@ -527,13 +550,11 @@ execute_sink_code (void)\n   connect_infinite_loops_to_exit ();\n   memset (&sink_stats, 0, sizeof (sink_stats));\n   calculate_dominance_info (CDI_DOMINATORS | CDI_POST_DOMINATORS);\n-  compute_immediate_uses (TDFA_USE_OPS | TDFA_USE_VOPS, NULL);\n   sink_code_in_bb (EXIT_BLOCK_PTR); \n   if (dump_file && (dump_flags & TDF_STATS))\n     fprintf (dump_file, \"Sunk statements:%d\\n\", sink_stats.sunk);\n   free_dominance_info (CDI_POST_DOMINATORS);\n   remove_fake_exit_edges ();\n-  free_df ();\n   loop_optimizer_finalize (loops, dump_file);\n }\n "}, {"sha": "617467a4ef014c4c5deb491381325b3e24facc59", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -306,7 +306,7 @@ create_edge_and_update_destination_phis (struct redirection_data *rd)\n   for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n     {\n       int indx = rd->outgoing_edge->dest_idx;\n-      add_phi_arg (phi, PHI_ARG_DEF_TREE (phi, indx), e);\n+      add_phi_arg (phi, PHI_ARG_DEF (phi, indx), e);\n     }\n }\n "}, {"sha": "e23e665d42a19e5fcd8244cfcff9431c0ef834f2", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 92, "deletions": 68, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -215,13 +215,19 @@ verify_def (basic_block bb, basic_block *definition_block, tree ssa_name,\n      that are defined before STMT in basic block BB.  */\n \n static bool\n-verify_use (basic_block bb, basic_block def_bb, tree ssa_name,\n+verify_use (basic_block bb, basic_block def_bb, use_operand_p use_p,\n \t    tree stmt, bool check_abnormal, bool is_virtual,\n \t    bitmap names_defined_in_bb)\n {\n   bool err = false;\n+  tree ssa_name = USE_FROM_PTR (use_p);\n \n   err = verify_ssa_name (ssa_name, is_virtual);\n+\n+  if (!TREE_VISITED (ssa_name))\n+    if (verify_imm_links (stderr, ssa_name))\n+      err = true;\n+\n   TREE_VISITED (ssa_name) = 1;\n \n   if (IS_EMPTY_STMT (SSA_NAME_DEF_STMT (ssa_name))\n@@ -254,6 +260,27 @@ verify_use (basic_block bb, basic_block def_bb, tree ssa_name,\n       err = true;\n     }\n \n+  /* Make sure the use is in an appropriate list by checking the previous \n+     element to make sure its the same.  */\n+  if (use_p->prev == NULL)\n+    {\n+      error (\"No immediate_use list\");\n+      err = true;\n+    }\n+  else\n+    {\n+      tree listvar ;\n+      if (use_p->prev->use == NULL)\n+\tlistvar = use_p->prev->stmt;\n+      else\n+\tlistvar = USE_FROM_PTR (use_p->prev);\n+      if (listvar != ssa_name)\n+        {\n+\t  error (\"Wrong immediate use list\");\n+\t  err = true;\n+\t}\n+    }\n+\n   if (err)\n     {\n       fprintf (stderr, \"for SSA_NAME: \");\n@@ -289,7 +316,9 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n \n   for (i = 0; i < phi_num_args; i++)\n     {\n-      tree op = PHI_ARG_DEF (phi, i);\n+      use_operand_p op_p = PHI_ARG_DEF_PTR (phi, i);\n+      tree op = USE_FROM_PTR (op_p);\n+\n \n       e = EDGE_PRED (bb, i);\n \n@@ -309,7 +338,7 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n \t}\n \n       if (TREE_CODE (op) == SSA_NAME)\n-\terr = verify_use (e->src, definition_block[SSA_NAME_VERSION (op)], op,\n+\terr = verify_use (e->src, definition_block[SSA_NAME_VERSION (op)], op_p,\n \t\t\t  phi, e->flags & EDGE_ABNORMAL,\n \t\t\t  !is_gimple_reg (PHI_RESULT (phi)),\n \t\t\t  NULL);\n@@ -601,7 +630,7 @@ verify_alias_info (void)\n    TODO: verify the variable annotations.  */\n \n void\n-verify_ssa (void)\n+verify_ssa (bool check_modified_stmt)\n {\n   size_t i;\n   basic_block bb;\n@@ -668,8 +697,16 @@ verify_ssa (void)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n+\t  use_operand_p use_p;\n+\n+\t  if (check_modified_stmt && stmt_modified_p (stmt))\n+\t    {\n+\t      error (\"Stmt (0x%x) marked modified after optimization pass : \",\n+\t\t     (unsigned long)stmt);\n+\t      print_generic_stmt (stderr, stmt, TDF_VOPS);\n+\t      goto err;\n+\t    }\n \n-\t      get_stmt_operands (stmt);\n \n \t      if (stmt_ann (stmt)->makes_aliased_stores \n \t\t  && NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) == 0)\n@@ -679,10 +716,11 @@ verify_ssa (void)\n \t\t  goto err;\n \t\t}\n \n-\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n \t    {\n+\t      op = USE_FROM_PTR (use_p);\n \t      if (verify_use (bb, definition_block[SSA_NAME_VERSION (op)],\n-\t\t\t      op, stmt, false, !is_gimple_reg (op),\n+\t\t\t      use_p, stmt, false, !is_gimple_reg (op),\n \t\t\t      names_defined_in_bb))\n \t\tgoto err;\n \t    }\n@@ -724,7 +762,6 @@ init_tree_ssa (void)\n   VARRAY_TREE_INIT (referenced_vars, 20, \"referenced_vars\");\n   call_clobbered_vars = BITMAP_ALLOC (NULL);\n   addressable_vars = BITMAP_ALLOC (NULL);\n-  init_ssa_operands ();\n   init_ssanames ();\n   init_phinodes ();\n   global_var = NULL_TREE;\n@@ -765,7 +802,6 @@ delete_tree_ssa (void)\n \n   fini_ssanames ();\n   fini_phinodes ();\n-  fini_ssa_operands ();\n \n   global_var = NULL_TREE;\n   BITMAP_FREE (call_clobbered_vars);\n@@ -994,41 +1030,43 @@ walk_use_def_chains (tree var, walk_use_def_chains_fn fn, void *data,\n \n \n /* Replaces VAR with REPL in memory reference expression *X in\n-   statement STMT.  */\n+   statement STMT at use location USE_P.  Return TRUE if Anything was done.  */\n \n-static void\n-propagate_into_addr (tree stmt, tree var, tree *x, tree repl)\n+static bool\n+propagate_into_addr (tree stmt, use_operand_p use_p, tree *x, tree repl)\n {\n   tree new_var, ass_stmt, addr_var;\n   basic_block bb;\n   block_stmt_iterator bsi;\n \n   /* There is nothing special to handle in the other cases.  */\n   if (TREE_CODE (repl) != ADDR_EXPR)\n-    return;\n+    return false;\n   addr_var = TREE_OPERAND (repl, 0);\n \n   while (handled_component_p (*x)\n \t || TREE_CODE (*x) == REALPART_EXPR\n \t || TREE_CODE (*x) == IMAGPART_EXPR)\n     x = &TREE_OPERAND (*x, 0);\n \n+  /* Heres a hack but since KRPhinodes is going away soon, Im not going to \n+     sweat it.  */\n   if (TREE_CODE (*x) != INDIRECT_REF\n-      || TREE_OPERAND (*x, 0) != var)\n-    return;\n+      || &(TREE_OPERAND (*x, 0)) != use_p->use)  /* HACK ALERT. */\n+    return false;\n \n   if (TREE_TYPE (*x) == TREE_TYPE (addr_var))\n     {\n       *x = addr_var;\n       mark_new_vars_to_rename (stmt, vars_to_rename);\n-      return;\n+      return true;\n     }\n \n \n   /* Frontends sometimes produce expressions like *&a instead of a[0].\n      Create a temporary variable to handle this case.  */\n   ass_stmt = build2 (MODIFY_EXPR, void_type_node, NULL_TREE, repl);\n-  new_var = duplicate_ssa_name (var, ass_stmt);\n+  new_var = duplicate_ssa_name (USE_FROM_PTR (use_p), ass_stmt);\n   TREE_OPERAND (*x, 0) = new_var;\n   TREE_OPERAND (ass_stmt, 0) = new_var;\n \n@@ -1038,65 +1076,61 @@ propagate_into_addr (tree stmt, tree var, tree *x, tree repl)\n   bsi_insert_after (&bsi, ass_stmt, BSI_NEW_STMT);\n \n   mark_new_vars_to_rename (stmt, vars_to_rename);\n+  return true;\n }\n \n /* Replaces immediate uses of VAR by REPL.  */\n \n static void\n replace_immediate_uses (tree var, tree repl)\n {\n-  int i, j, n;\n-  dataflow_t df;\n   tree stmt;\n   bool mark_new_vars;\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n+  use_operand_p imm_use;\n+  imm_use_iterator imm_iter;\n \n-  df = get_immediate_uses (SSA_NAME_DEF_STMT (var));\n-  n = num_immediate_uses (df);\n-\n-  for (i = 0; i < n; i++)\n+  FOR_EACH_IMM_USE_SAFE (imm_use, imm_iter, var)\n     {\n-      stmt = immediate_use (df, i);\n+      stmt = USE_STMT (imm_use);\n \n       if (TREE_CODE (stmt) == PHI_NODE)\n \t{\n-\t  for (j = 0; j < PHI_NUM_ARGS (stmt); j++)\n-\t    if (PHI_ARG_DEF (stmt, j) == var)\n-\t      {\n-\t\tSET_PHI_ARG_DEF (stmt, j, repl);\n-\t\tif (TREE_CODE (repl) == SSA_NAME\n-\t\t    && PHI_ARG_EDGE (stmt, j)->flags & EDGE_ABNORMAL)\n-\t\t  SSA_NAME_OCCURS_IN_ABNORMAL_PHI (repl) = 1;\n-\t      }\n-\n+\t  int index = PHI_ARG_INDEX_FROM_USE (imm_use);\n+#ifdef ENABLE_CHECKING\n+\t  gcc_assert (&(PHI_ARG_IMM_USE_NODE (stmt, index)) == imm_use);\n+#endif\n+\t    SET_USE (imm_use, repl);\n+\t  if (TREE_CODE (repl) == SSA_NAME\n+\t      && PHI_ARG_EDGE (stmt, index)->flags & EDGE_ABNORMAL)\n+\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (repl) = 1;\n \t  continue;\n \t}\n \n-      get_stmt_operands (stmt);\n+      gcc_assert (!stmt_modified_p (stmt));\n+\n       mark_new_vars = false;\n       if (is_gimple_reg (SSA_NAME_VAR (var)))\n \t{\n+\t  bool propagated = false;\n \t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n \t    {\n-\t      propagate_into_addr (stmt, var, &TREE_OPERAND (stmt, 0), repl);\n-\t      propagate_into_addr (stmt, var, &TREE_OPERAND (stmt, 1), repl);\n+\t      if (TREE_CODE (repl) == ADDR_EXPR)\n+\t\t{\n+\t\t  propagated =\n+\t\t    propagate_into_addr (stmt, imm_use, &TREE_OPERAND (stmt, 0),\n+\t\t\t\t\t repl);\n+\t\t  if (!propagated)\n+\t\t    propagated =\n+\t\t      propagate_into_addr (stmt, imm_use,\n+\t\t\t\t\t   &TREE_OPERAND (stmt, 1), repl);\n+\t\t}\n \t    }\n-\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n-\t    if (USE_FROM_PTR (use_p) == var)\n-\t      {\n-\t\tpropagate_value (use_p, repl);\n-\t\tmark_new_vars = POINTER_TYPE_P (TREE_TYPE (repl));\n-\t      }\n+\t  if (!propagated)\n+\t    propagate_value (imm_use, repl);\n+\t  mark_new_vars = POINTER_TYPE_P (TREE_TYPE (repl));\n \t}\n       else\n-\t{\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, \n-\t\t\t\t    SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS)\n-\t    if (USE_FROM_PTR (use_p) == var)\n-\t      propagate_value (use_p, repl);\n-\t}\n+        propagate_value (imm_use, repl);\n \n       /* FIXME.  If REPL is a constant, we need to fold STMT.\n \t However, fold_stmt wants a pointer to the statement, because\n@@ -1119,7 +1153,6 @@ replace_immediate_uses (tree var, tree repl)\n \t    {\n \t      block_stmt_iterator si = bsi_for_stmt (stmt);\n \t      mark_new_vars_to_rename (tmp, vars_to_rename);\n-\t      redirect_immediate_uses (stmt, tmp);\n \t      bsi_replace (&si, tmp, true);\n \t      stmt = bsi_stmt (si);\n \t    }\n@@ -1133,8 +1166,9 @@ replace_immediate_uses (tree var, tree repl)\n       if (mark_new_vars)\n \tmark_new_vars_to_rename (stmt, vars_to_rename);\n       else\n-\tmodify_stmt (stmt);\n+\tupdate_stmt (stmt);\n     }\n+\n }\n \n /* Gets the value VAR is equivalent to according to EQ_TO.  */\n@@ -1174,8 +1208,9 @@ static void\n check_phi_redundancy (tree phi, tree *eq_to)\n {\n   tree val = NULL_TREE, def, res = PHI_RESULT (phi), stmt;\n-  unsigned i, ver = SSA_NAME_VERSION (res), n;\n-  dataflow_t df;\n+  unsigned i, ver = SSA_NAME_VERSION (res);\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n \n   /* It is unlikely that such large phi node would be redundant.  */\n   if (PHI_NUM_ARGS (phi) > 16)\n@@ -1211,13 +1246,9 @@ check_phi_redundancy (tree phi, tree *eq_to)\n \n   eq_to[ver] = val;\n \n-  df = get_immediate_uses (SSA_NAME_DEF_STMT (res));\n-  n = num_immediate_uses (df);\n-\n-  for (i = 0; i < n; i++)\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, res)\n     {\n-      stmt = immediate_use (df, i);\n-\n+      stmt = USE_STMT (use_p);\n       if (TREE_CODE (stmt) == PHI_NODE)\n \tcheck_phi_redundancy (stmt, eq_to);\n     }\n@@ -1257,12 +1288,6 @@ kill_redundant_phi_nodes (void)\n      it safe).  */\n   eq_to = xcalloc (num_ssa_names, sizeof (tree));\n \n-  /* We have had cases where computing immediate uses takes a\n-     significant amount of compile time.  If we run into such\n-     problems here, we may want to only compute immediate uses for\n-     a subset of all the SSA_NAMEs instead of computing it for\n-     all of the SSA_NAMEs.  */\n-  compute_immediate_uses (TDFA_USE_OPS | TDFA_USE_VOPS, NULL);\n   old_num_ssa_names = num_ssa_names;\n \n   FOR_EACH_BB (bb)\n@@ -1296,7 +1321,6 @@ kill_redundant_phi_nodes (void)\n \t}\n     }\n \n-  free_df ();\n   free (eq_to);\n }\n "}, {"sha": "79e1a764e739150797dea14e265257fabbd2bb8e", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -172,6 +172,7 @@ tree\n make_ssa_name (tree var, tree stmt)\n {\n   tree t;\n+  ssa_imm_use_t *imm;\n \n   gcc_assert (DECL_P (var)\n \t      || TREE_CODE (var) == INDIRECT_REF);\n@@ -207,6 +208,11 @@ make_ssa_name (tree var, tree stmt)\n   SSA_NAME_DEF_STMT (t) = stmt;\n   SSA_NAME_PTR_INFO (t) = NULL;\n   SSA_NAME_IN_FREE_LIST (t) = 0;\n+  imm = &(SSA_NAME_IMM_USE_NODE (t));\n+  imm->use = NULL;\n+  imm->prev = imm;\n+  imm->next = imm;\n+  imm->stmt = t;\n \n   return t;\n }\n@@ -248,10 +254,26 @@ release_ssa_name (tree var)\n     {\n       tree saved_ssa_name_var = SSA_NAME_VAR (var);\n       int saved_ssa_name_version = SSA_NAME_VERSION (var);\n+      ssa_imm_use_t *imm = &(SSA_NAME_IMM_USE_NODE (var));\n+\n+#ifdef ENABLE_CHECKING\n+      verify_imm_links (stderr, var);\n+#endif\n+      while (imm->next != imm)\n+        {\n+\t  delink_imm_use (imm->next);\n+\t}\n+#ifdef ENABLE_CHECKING\n+      if (imm->next != imm)\n+        abort();\n+#endif\n \n       VARRAY_TREE (ssa_names, SSA_NAME_VERSION (var)) = NULL;\n       memset (var, 0, tree_size (var));\n \n+      imm->prev = imm;\n+      imm->next = imm;\n+      imm->stmt = var;\n       /* First put back the right tree node so that the tree checking\n \t macros do not complain.  */\n       TREE_SET_CODE (var, SSA_NAME);"}, {"sha": "3a9162ce4e0c2570f76799730c23020c9e798a2a", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -668,7 +668,7 @@ adjust_return_value (basic_block bb, tree m, tree a)\n     }\n \n   TREE_OPERAND (ret_stmt, 0) = var;\n-  modify_stmt (ret_stmt);\n+  update_stmt (ret_stmt);\n }\n \n /* Eliminates tail call described by T.  TMP_VARS is a list of"}, {"sha": "9ee81c81e169bb9fa1552e078999f3d1d95a8099", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -2054,9 +2054,10 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo)\n   v_may_def_optype v_may_defs;\n   v_must_def_optype v_must_defs;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  int i;\n-  dataflow_t df;\n-  int num_uses;\n+  ssa_op_iter op_iter;\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  tree var;\n \n   /* cond stmt other than loop exit cond.  */\n   if (is_ctrl_stmt (stmt) && (stmt != LOOP_VINFO_EXIT_COND (loop_vinfo)))\n@@ -2076,17 +2077,17 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo)\n     }\n \n   /* uses outside the loop.  */\n-  df = get_immediate_uses (stmt);\n-  num_uses = num_immediate_uses (df);\n-  for (i = 0; i < num_uses; i++)\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, op_iter, SSA_OP_DEF)\n     {\n-      tree use = immediate_use (df, i);\n-      basic_block bb = bb_for_stmt (use);\n-      if (!flow_bb_inside_loop_p (loop, bb))\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\t    fprintf (vect_dump, \"vec_stmt_relevant_p: used out of loop.\");\n-\t  return true;\n+\t  basic_block bb = bb_for_stmt (USE_STMT (use_p));\n+\t  if (!flow_bb_inside_loop_p (loop, bb))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t\tfprintf (vect_dump, \"vec_stmt_relevant_p: used out of loop.\");\n+\t      return true;\n+\t    }\n \t}\n     }\n "}, {"sha": "f3551f8528d31648b8bf37197e087ac179a6f146", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -170,7 +170,6 @@ static void rename_variables_in_loop (struct loop *);\n   General Vectorization Utilities\n  *************************************************************************/\n static void vect_set_dump_settings (void);\n-static bool need_imm_uses_for (tree);\n \n /* vect_dump will be set to stderr or dump_file if exist.  */\n FILE *vect_dump;\n@@ -1815,19 +1814,6 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n }\n \n \n-/* Function need_imm_uses_for.\n-\n-   Return whether we ought to include information for 'var'\n-   when calculating immediate uses.  For this pass we only want use\n-   information for non-virtual variables.  */\n-\n-static bool\n-need_imm_uses_for (tree var)\n-{\n-  return is_gimple_reg (var);\n-}\n-\n-\n /* Function vectorize_loops.\n    \n    Entry Point to loop vectorization phase.  */\n@@ -1854,8 +1840,6 @@ vectorize_loops (struct loops *loops)\n   verify_loop_closed_ssa ();\n #endif\n \n-  compute_immediate_uses (TDFA_USE_OPS, need_imm_uses_for);\n-\n   /*  ----------- Analyze loops. -----------  */\n \n   /* If some loop was duplicated, it gets bigger number \n@@ -1886,7 +1870,6 @@ vectorize_loops (struct loops *loops)\n \n   /*  ----------- Finalize. -----------  */\n \n-  free_df ();\n   for (i = 1; i < loops_num; i++)\n     {\n       struct loop *loop = loops->parray[i];"}, {"sha": "7c61e8fd8b47fbd863c94326a73e459660f1b7bf", "filename": "gcc/tree.h", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f430bae8727f3b99f24001224ff9a18e3b31ea02/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f430bae8727f3b99f24001224ff9a18e3b31ea02", "patch": "@@ -1348,6 +1348,21 @@ struct tree_exp GTY(())\n struct ptr_info_def;\n #endif\n \n+\n+\n+/* Immediate use linking structure. THis structure is used for maintaining\n+   a doubly linked list of uses of an SSA_NAME.  */\n+typedef struct ssa_imm_use_d GTY(())\n+{\n+  struct ssa_imm_use_d* GTY((skip(\"\"))) prev;\n+  struct ssa_imm_use_d* GTY((skip(\"\"))) next;\n+  tree GTY((skip(\"\"))) stmt;\n+  tree *GTY((skip(\"\"))) use;\n+} ssa_imm_use_t;\n+\n+/* Return the immediate_use information for an SSA_NAME. */\n+#define SSA_NAME_IMM_USE_NODE(NODE) SSA_NAME_CHECK (NODE)->ssa_name.imm_uses\n+\n struct tree_ssa_name GTY(())\n {\n   struct tree_common common;\n@@ -1370,9 +1385,19 @@ struct tree_ssa_name GTY(())\n \n   /* Auxiliary information stored with the ssa name.  */\n   PTR GTY((skip)) aux;\n+\n+  /* Immediate uses list for this SSA_NAME.  */\n+  struct ssa_imm_use_d imm_uses;\n };\n \f\n /* In a PHI_NODE node.  */\n+\n+/* These 2 macros should be considered off limits for use by developers.  If \n+   you wish to access the use or def fields of a PHI_NODE in the SSA \n+   optimizers, use the accessor macros found in tree-ssa-operands.h.  \n+   These two macros are to be used only by those accessor macros, and other \n+   select places where we *absolutly* must take the address of the tree.  */\n+\n #define PHI_RESULT_TREE(NODE)\t\tPHI_NODE_CHECK (NODE)->phi.result\n #define PHI_ARG_DEF_TREE(NODE, I)\tPHI_NODE_ELT_CHECK (NODE, I).def\n \n@@ -1390,12 +1415,13 @@ struct tree_ssa_name GTY(())\n #define PHI_ARG_EDGE(NODE, I) \t\t(EDGE_PRED (PHI_BB ((NODE)), (I)))\n #define PHI_ARG_NONZERO(NODE, I) \tPHI_NODE_ELT_CHECK (NODE, I).nonzero\n #define PHI_BB(NODE)\t\t\tPHI_NODE_CHECK (NODE)->phi.bb\n-#define PHI_DF(NODE)\t\t\tPHI_NODE_CHECK (NODE)->phi.df\n+#define PHI_ARG_IMM_USE_NODE(NODE, I)\tPHI_NODE_ELT_CHECK (NODE, I).imm_use\n \n struct edge_def;\n \n struct phi_arg_d GTY(())\n {\n+  struct ssa_imm_use_d imm_use;\t/* imm_use MUST be first element in struct.  */\n   tree def;\n   bool nonzero;\n };\n@@ -1414,9 +1440,6 @@ struct tree_phi_node GTY(())\n   /* Basic block to that the phi node belongs.  */\n   struct basic_block_def *bb;\n \n-  /* Dataflow information.  */\n-  struct dataflow_d *df;\n-\n   struct phi_arg_d GTY ((length (\"((tree)&%h)->phi.num_args\"))) a[1];\n };\n \f\n@@ -3895,6 +3918,7 @@ enum tree_dump_index\n #define TDF_TREE\t(1 << 9)\t/* is a tree dump */\n #define TDF_RTL\t\t(1 << 10)\t/* is a RTL dump */\n #define TDF_IPA\t\t(1 << 11)\t/* is an IPA dump */\n+#define TDF_STMTADDR\t(1 << 12)\t/* Address of stmt.  */\n \n typedef struct dump_info *dump_info_p;\n "}]}