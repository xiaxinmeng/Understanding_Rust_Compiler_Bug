{"sha": "5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZlY2ZkOGQ2MTRlN2ZmNjFhODIyYzZkYzMwYTBiZjhlMTcxYjNkZA==", "commit": {"author": {"name": "Marek Michalkiewicz", "email": "marekm@linux.org.pl", "date": "2000-09-03T07:37:48Z"}, "committer": {"name": "Denis Chertykov", "email": "denisc@gcc.gnu.org", "date": "2000-09-03T07:37:48Z"}, "message": "avr-protos.h, avr.c (unique_section, [...]): Add \"const\" as needed to remove warnings.\n\n\t* config/avr/avr-protos.h, config/avr/avr.c (unique_section,\n\tgas_output_limited_string, gas_output_ascii, output_movqi,\n\toutput_movhi, out_movqi_r_mr, out_movqi_mr_r, out_movhi_r_mr,\n\tout_movhi_mr_r, out_movsi_r_mr, out_movsi_mr_r, output_movsisf,\n\tout_tstsi, out_tsthi, ret_cond_branch, ashlqi3_out, ashlhi3_out,\n\tashlsi3_out, ashrqi3_out, ashrhi3_out, ashrsi3_out, lshrqi3_out,\n\tlshrhi3_out, lshrsi3_out, output_reload_inhi, output_reload_insisf,\n\tout_shift_with_cnt, ptrreg_to_str, cond_string, encode_section_info):\n\tAdd \"const\" as needed to remove warnings.\n\n\t* config/avr/avr.c (avr_override_options, avr_init_once,\n\tfunction_prologue, function_epilogue, frame_pointer_required_p,\n\tclass_likely_spilled_p, order_regs_for_local_alloc,\n\tavr_address_cost, avr_ret_register): Use K&R style arguments.\n\t(initial_elimination_offset, gas_output_limited_string):\n\tRemove ATTRIBUTE_UNUSED from the used arguments.\n\t(output_mov*, out_mov*_r_mr, out_mov*_mr_r, output_reload_insisf):\n\tUse local variables src, dest, base to access operands[].\n\tRename reg_dest to reg_src if that's what it is.\n\t(output_movhi, output_movsisf): Optimize loading 8-bit immediate\n\tconstants to LD_REGS if reg_was_0.\n\t(output_reload_insisf): Change arg 3 to insn length and set it.\n\t(out_movhi_r_mr, out_movhi_mr_r): Use in/out for more efficient\n\taccess to 16-bit I/O register pairs.\n\t(avr_address_cost): Lower cost for the above case.\n\t(out_tsthi): Use \"or\" (faster) instead of \"sbiw\" if the operand\n\tmay be clobbered, also for LD_REGS.\n\t(adjust_insn_length): Correct insn length for iorhi3 and iorsi3\n\twith a CONST_INT.\n\n\t* config/avr/avr.h (PTRDIFF_TYPE): Make signed.\n\n\t* config/avr/avr.md: Change all uses of the TEST_HARD_REG_CLASS\n\tmacro to test_hard_reg_class function.\n\t(*movsi, *movsf): Change \"cc\" attribute from \"clobber\" to \"none\"\n\tfor loading immediate constants to LD_REGS.\n\t(andsi3, cmphi, cmpsi): Add return statements to avoid warnings.\n\nFrom-SVN: r36117", "tree": {"sha": "91285beb3e673d99d20f2a59de9453ba6c521c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91285beb3e673d99d20f2a59de9453ba6c521c26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd/comments", "author": null, "committer": null, "parents": [{"sha": "bad3869abd1e226672ce5799a40e4362fa85de73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad3869abd1e226672ce5799a40e4362fa85de73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bad3869abd1e226672ce5799a40e4362fa85de73"}], "stats": {"total": 609, "additions": 353, "deletions": 256}, "files": [{"sha": "13beb1363410bbb0e8c3a1d3b574a598ff3ff23c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd", "patch": "@@ -1,3 +1,44 @@\n+2000-09-02  Marek Michalkiewicz  <marekm@linux.org.pl>\n+\n+\t* config/avr/avr-protos.h, config/avr/avr.c (unique_section,\n+\tgas_output_limited_string, gas_output_ascii, output_movqi,\n+\toutput_movhi, out_movqi_r_mr, out_movqi_mr_r, out_movhi_r_mr,\n+\tout_movhi_mr_r, out_movsi_r_mr, out_movsi_mr_r, output_movsisf,\n+\tout_tstsi, out_tsthi, ret_cond_branch, ashlqi3_out, ashlhi3_out,\n+\tashlsi3_out, ashrqi3_out, ashrhi3_out, ashrsi3_out, lshrqi3_out,\n+\tlshrhi3_out, lshrsi3_out, output_reload_inhi, output_reload_insisf,\n+\tout_shift_with_cnt, ptrreg_to_str, cond_string, encode_section_info):\n+\tAdd \"const\" as needed to remove warnings.\n+\n+\t* config/avr/avr.c (avr_override_options, avr_init_once,\n+\tfunction_prologue, function_epilogue, frame_pointer_required_p,\n+\tclass_likely_spilled_p, order_regs_for_local_alloc,\n+\tavr_address_cost, avr_ret_register): Use K&R style arguments.\n+\t(initial_elimination_offset, gas_output_limited_string):\n+\tRemove ATTRIBUTE_UNUSED from the used arguments.\n+\t(output_mov*, out_mov*_r_mr, out_mov*_mr_r, output_reload_insisf):\n+\tUse local variables src, dest, base to access operands[].\n+\tRename reg_dest to reg_src if that's what it is.\n+\t(output_movhi, output_movsisf): Optimize loading 8-bit immediate\n+\tconstants to LD_REGS if reg_was_0.\n+\t(output_reload_insisf): Change arg 3 to insn length and set it.\n+\t(out_movhi_r_mr, out_movhi_mr_r): Use in/out for more efficient\n+\taccess to 16-bit I/O register pairs.\n+\t(avr_address_cost): Lower cost for the above case.\n+\t(out_tsthi): Use \"or\" (faster) instead of \"sbiw\" if the operand\n+\tmay be clobbered, also for LD_REGS.\n+\t(adjust_insn_length): Correct insn length for iorhi3 and iorsi3\n+\twith a CONST_INT.\n+\n+\t* config/avr/avr.h (PTRDIFF_TYPE): Make signed.\n+\n+\t* config/avr/avr.md: Change all uses of the TEST_HARD_REG_CLASS\n+\tmacro to test_hard_reg_class function.\n+\t(*movsi, *movsf): Change \"cc\" attribute from \"clobber\" to \"none\"\n+\tfor loading immediate constants to LD_REGS.\n+\t(andsi3, cmphi, cmpsi): Add return statements to avoid warnings.\n+\n+\n Sat Sep  2 13:58:23 2000  Marek Michalkiewicz <marekm@linux.org.pl>\n \n \t* config/avr/avr.md (\"*negsi2\"): substitute %@ to __zero_reg__"}, {"sha": "8193d237145687d3672df87676ea35c9acad4f15", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd", "patch": "@@ -27,7 +27,7 @@ extern void   asm_file_end                      PARAMS ((FILE *file));\n extern void   avr_init_once                     PARAMS ((void));\n extern void   avr_override_options              PARAMS ((void));\n extern char * avr_change_section                PARAMS ((char *sect_name));\n-extern int    avr_ret_register                  PARAMS((void));\n+extern int    avr_ret_register                  PARAMS ((void));\n extern enum reg_class class_likely_spilled_p    PARAMS ((int c));\n extern enum reg_class avr_regno_reg_class       PARAMS ((int r));\n extern enum reg_class avr_reg_class_from_letter PARAMS ((int c));\n@@ -39,8 +39,8 @@ extern void   function_prologue           PARAMS ((FILE *file, int size));\n extern void   function_epilogue           PARAMS ((FILE *file, int size));\n extern void   progmem_section             PARAMS ((void));\n extern int    mask_one_bit_p              PARAMS ((HOST_WIDE_INT mask));\n-extern void   gas_output_limited_string   PARAMS ((FILE *file, char *str));\n-extern void   gas_output_ascii            PARAMS ((FILE *file, char * str,\n+extern void   gas_output_limited_string PARAMS ((FILE *file, const char *str));\n+extern void   gas_output_ascii          PARAMS ((FILE *file, const char *str,\n \t\t\t\t\t\t\t size_t length));\n \n \n@@ -86,30 +86,30 @@ extern int    legitimate_address_p    PARAMS ((enum machine_mode mode, rtx x,\n \t\t\t\t\tint strict));\n extern void   machine_dependent_reorg PARAMS ((rtx first_insn));\n extern int    compare_diff_p  PARAMS ((rtx insn));\n-extern char * output_movqi    PARAMS ((rtx insn, rtx operands[], int *l));\n-extern char * output_movhi    PARAMS ((rtx insn, rtx operands[], int *l));\n-extern char * out_movqi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n-extern char * out_movqi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n-extern char * out_movhi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n-extern char * out_movhi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n-extern char * out_movsi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n-extern char * out_movsi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n-extern char * output_movsisf  PARAMS ((rtx insn, rtx operands[], int *l));\n-extern char * out_tstsi       PARAMS ((rtx insn, int *l));\n-extern char * out_tsthi       PARAMS ((rtx insn, int *l));\n-extern char * ret_cond_branch PARAMS ((RTX_CODE cond, int len));\n-\n-extern char * ashlqi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n-extern char * ashlhi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n-extern char * ashlsi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n-\n-extern char * ashrqi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n-extern char * ashrhi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n-extern char * ashrsi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n-\n-extern char * lshrqi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n-extern char * lshrhi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n-extern char * lshrsi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n+extern const char * output_movqi    PARAMS ((rtx insn, rtx operands[], int *l));\n+extern const char * output_movhi    PARAMS ((rtx insn, rtx operands[], int *l));\n+extern const char * out_movqi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n+extern const char * out_movqi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n+extern const char * out_movhi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n+extern const char * out_movhi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n+extern const char * out_movsi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n+extern const char * out_movsi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n+extern const char * output_movsisf  PARAMS ((rtx insn, rtx operands[], int *l));\n+extern const char * out_tstsi       PARAMS ((rtx insn, int *l));\n+extern const char * out_tsthi       PARAMS ((rtx insn, int *l));\n+extern const char * ret_cond_branch PARAMS ((RTX_CODE cond, int len));\n+\n+extern const char * ashlqi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n+extern const char * ashlhi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n+extern const char * ashlsi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n+\n+extern const char * ashrqi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n+extern const char * ashrhi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n+extern const char * ashrsi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n+\n+extern const char * lshrqi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n+extern const char * lshrhi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n+extern const char * lshrsi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n \n extern enum reg_class preferred_reload_class PARAMS ((rtx x,\n \t\t\t\t\t\t     enum reg_class class));\n@@ -119,10 +119,10 @@ extern rtx    legitimize_address     PARAMS ((rtx x, rtx oldx,\n \t\t\t\t\t     enum machine_mode mode));\n extern int    adjust_insn_length     PARAMS ((rtx insn, int len));\n extern rtx    avr_libcall_value      PARAMS ((enum machine_mode mode));\n-extern char * output_reload_inhi     PARAMS ((rtx insn, rtx *operands,\n-\t\t\t\t\t     int *len));\n-extern char * output_reload_insisf   PARAMS ((rtx insn, rtx *operands,\n-\t\t\t\t\t     int which_alternative));\n+extern const char * output_reload_inhi PARAMS ((rtx insn, rtx *operands,\n+\t\t\t\t\t\tint *len));\n+extern const char * output_reload_insisf PARAMS ((rtx insn, rtx *operands,\n+\t\t\t\t\t\tint *len));\n extern int    default_rtx_costs      PARAMS ((rtx X, RTX_CODE code,\n \t\t\t\t\t     RTX_CODE outer_code));\n extern void   asm_output_char        PARAMS ((FILE *file, rtx value));\n@@ -151,7 +151,7 @@ extern int    avr_simplify_comparision_p PARAMS ((enum machine_mode mode,\n \t\t\t\t\t      RTX_CODE operator, rtx x));\n extern RTX_CODE avr_normalize_condition  PARAMS ((RTX_CODE condition));\n extern int    compare_eq_p           PARAMS ((rtx insn));\n-extern void   out_shift_with_cnt     PARAMS ((char * template, rtx insn,\n+extern void   out_shift_with_cnt     PARAMS ((const char *template, rtx insn,\n \t\t\t\t\t      rtx operands[], int *len));\n extern int    const_int_pow2_p       PARAMS ((rtx x));\n #endif /* RTX_CODE */"}, {"sha": "6f2ba181a4812faf2f831238c350ec874e028ae2", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 261, "deletions": 215, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd", "patch": "@@ -47,8 +47,8 @@ static int    avr_naked_function_p PARAMS ((tree));\n static int    interrupt_function_p PARAMS ((tree));\n static int    signal_function_p    PARAMS ((tree));\n static int    sequent_regs_live    PARAMS ((void));\n-static char * ptrreg_to_str        PARAMS ((int));\n-static char * cond_string          PARAMS ((enum rtx_code));\n+static const char * ptrreg_to_str  PARAMS ((int));\n+static const char * cond_string    PARAMS ((enum rtx_code));\n static int    avr_num_arg_regs     PARAMS ((enum machine_mode, tree));\n static int    out_adj_frame_ptr    PARAMS ((FILE *, int));\n static int    out_set_stack_ptr    PARAMS ((FILE *, int, int));\n@@ -161,7 +161,7 @@ static const struct mcu_type_s avr_mcu_types[] = {\n };\n \n void\n-avr_override_options (void)\n+avr_override_options ()\n {\n   const struct mcu_type_s *t;\n \n@@ -182,7 +182,7 @@ avr_override_options (void)\n     {\n       case AVR1:\n       default:\n-      fatal (\"MCU `%s' not supported\", avr_mcu_name);\n+\tfatal (\"MCU `%s' not supported\", avr_mcu_name);\n       case AVR2: avr_enhanced_p = 0; avr_mega_p = 0; break;\n       case AVR3: avr_enhanced_p = 0; avr_mega_p = 1; break;\n       case AVR4: avr_enhanced_p = 1; avr_mega_p = 0; break;\n@@ -193,7 +193,7 @@ avr_override_options (void)\n \n /* Initialize TMP_REG_RTX and ZERO_REG_RTX */\n void\n-avr_init_once (void)\n+avr_init_once ()\n {\n   tmp_reg_rtx = xmalloc (sizeof (struct rtx_def) + 1 * sizeof (rtunion));\n   memset (tmp_reg_rtx, 0, sizeof (struct rtx_def) + 1 * sizeof (rtunion));\n@@ -321,9 +321,9 @@ signal_function_p (func)\n /* Compute offset between arg_pointer and frame_pointer */\n \n int\n-initial_elimination_offset (from,to)\n-     int from ATTRIBUTE_UNUSED;\n-     int to ATTRIBUTE_UNUSED;\n+initial_elimination_offset (from, to)\n+     int from;\n+     int to;\n {\n   int reg;\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n@@ -517,7 +517,9 @@ out_set_stack_ptr (file, before, after)\n /* Output function prologue */\n \n void\n-function_prologue (FILE *file, int size)\n+function_prologue (file, size)\n+     FILE *file;\n+     int size;\n {\n   int reg;\n   int interrupt_func_p;\n@@ -651,7 +653,9 @@ function_prologue (FILE *file, int size)\n /* Output function epilogue */\n \n void\n-function_epilogue (FILE *file, int size)\n+function_epilogue (file, size)\n+     FILE *file;\n+     int size;\n {\n   int reg;\n   int interrupt_func_p;\n@@ -884,7 +888,7 @@ legitimize_address (x, oldx, mode)\n \n /* Return a pointer register name as a string */\n \n-static char *\n+static const char *\n ptrreg_to_str (regno)\n      int regno;\n {\n@@ -902,7 +906,7 @@ ptrreg_to_str (regno)\n /* Return the condition name as a string.\n    Used in conditional jump constructing  */\n \n-static char *\n+static const char *\n cond_string (code)\n      enum rtx_code code;\n {\n@@ -1147,7 +1151,7 @@ class_max_nregs (class, mode)\n    3 - absolute jump (only for ATmega[16]03).  */\n \n int\n-avr_jump_mode (x,insn)\n+avr_jump_mode (x, insn)\n      rtx x;                     /* jump operand */\n      rtx insn;                  /* jump insn */\n {\n@@ -1169,8 +1173,8 @@ avr_jump_mode (x,insn)\n /* return a AVR condition jump commands.\n  LEN is a number returned by avr_jump_mode function.  */\n \n-char *\n-ret_cond_branch (cond,len)\n+const char *\n+ret_cond_branch (cond, len)\n      RTX_CODE cond;\n      int len;\n {\n@@ -1289,8 +1293,7 @@ final_prescan_insn (insn, operand, num_operands)\n     }\n }\n \n-/* return 1 if undefined,\n-   1 if always true or always false  */\n+/* Return 0 if undefined, 1 if always true or always false.  */\n \n int\n avr_simplify_comparision_p (mode, operator, x)\n@@ -1416,7 +1419,7 @@ function_arg_advance (cum, mode, type, named)\n /***********************************************************************\n   Functions for outputting various mov's for a various modes\n ************************************************************************/\n-char *\n+const char *\n output_movqi (insn, operands, l)\n      rtx insn;\n      rtx operands[];\n@@ -1454,7 +1457,7 @@ output_movqi (insn, operands, l)\n \t\treturn AS1 (clr,%0);\n \t      else if (src == const1_rtx)\n \t\t{\n-\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t  if (reg_was_0 (insn, dest))\n \t\t    return AS1 (inc,%0 ; reg_was_0);\n \n \t\t  *l = 2;\n@@ -1463,7 +1466,7 @@ output_movqi (insn, operands, l)\n \t\t}\n \t      else if (src == const2_rtx)\n \t\t{\n-\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t  if (reg_was_0 (insn, dest))\n \t\t    {\n \t\t      *l = 2;\n \t\t      return (AS1 (inc,%0 ; reg_was_0) CR_TAB\n@@ -1478,7 +1481,7 @@ output_movqi (insn, operands, l)\n \t      else if (src == constm1_rtx)\n \t\t{\n \t\t  /* Immediate constants -1 to any register */\n-\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t  if (reg_was_0 (insn, dest))\n \t\t    return AS1 (dec,%0 ; reg_was_0);\n \n \t\t  *l = 2;\n@@ -1500,28 +1503,23 @@ output_movqi (insn, operands, l)\n     }\n   else if (GET_CODE (dest) == MEM)\n     {\n-      int save = 0;\n-      char *template;\n-      \n-      if (operands[1] == const0_rtx)\n-\t{\n-\t  operands[1] = zero_reg_rtx;\n-\t  save = 1;\n-\t}\n-      \n+      const char *template;\n+\n+      if (src == const0_rtx)\n+\toperands[1] = zero_reg_rtx;\n+\n       template = out_movqi_mr_r (insn, operands, real_l);\n \n       if (!real_l)\n \toutput_asm_insn (template, operands);\n-      \n-      if (save)\n-\toperands[1] = const0_rtx;\n+\n+      operands[1] = src;\n     }\n   return \"\";\n }\n \n \n-char *\n+const char *\n output_movhi (insn, operands, l)\n      rtx insn;\n      rtx operands[];\n@@ -1573,7 +1571,7 @@ output_movhi (insn, operands, l)\n \t      return (AS2 (movw,%0,%1));\n \t    }\n \n-\t  if (true_regnum (operands[0]) > true_regnum (operands[1]))\n+\t  if (true_regnum (dest) > true_regnum (src))\n \t    {\n \t      *l = 2;\n \t      return (AS2 (mov,%B0,%B1) CR_TAB\n@@ -1590,6 +1588,13 @@ output_movhi (insn, operands, l)\n \t{\n \t  if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n \t    {\n+\t      if (byte_immediate_operand (src, HImode)\n+\t\t  && reg_was_0 (insn, dest))\n+\t\t{\n+\t\t  *l = 1;\n+\t\t  return (AS2 (ldi,%A0,lo8(%1) ; reg_was_0));\n+\t\t}\n+\n \t      *l = 2;\n \t      return (AS2 (ldi,%A0,lo8(%1)) CR_TAB\n \t\t      AS2 (ldi,%B0,hi8(%1)));\n@@ -1605,7 +1610,7 @@ output_movhi (insn, operands, l)\n \t\t}\n \t      else if (src == const1_rtx)\n \t\t{\n-\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t  if (reg_was_0 (insn, dest))\n \t\t    {\n \t\t      *l = 1;\n \t\t      return AS1 (inc,%0 ; reg_was_0);\n@@ -1617,7 +1622,7 @@ output_movhi (insn, operands, l)\n \t\t}\n \t      else if (src == const2_rtx)\n \t\t{\n-\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t  if (reg_was_0 (insn, dest))\n \t\t    {\n \t\t      *l = 2;\n \t\t      return (AS1 (inc,%0 ; reg_was_0) CR_TAB\n@@ -1632,7 +1637,7 @@ output_movhi (insn, operands, l)\n \t      else if (src == constm1_rtx)\n \t\t{\n \t\t  /* Immediate constants -1 to any register */\n-\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t  if (reg_was_0 (insn, dest))\n \t\t    {\n \t\t      *l = 2;\n \t\t      return (AS1 (dec,%A0 ; reg_was_0) CR_TAB\n@@ -1678,40 +1683,36 @@ output_movhi (insn, operands, l)\n     }\n   else if (GET_CODE (dest) == MEM)\n     {\n-      int save = 0;\n-      char *template;\n-      \n-      if (operands[1] == const0_rtx)\n-\t{\n-\t  operands[1] = zero_reg_rtx;\n-\t  save = 1;\n-\t}\n-      \n+      const char *template;\n+\n+      if (src == const0_rtx)\n+\toperands[1] = zero_reg_rtx;\n+\n       template = out_movhi_mr_r (insn, operands, real_l);\n \n       if (!real_l)\n \toutput_asm_insn (template, operands);\n-      \n-      if (save)\n-\toperands[1] = const0_rtx;\n+\n+      operands[1] = src;\n       return \"\";\n     }\n   fatal_insn (\"Invalid insn:\", insn);\n   return \"\";\n }\n \n-char *\n+const char *\n out_movqi_r_mr (insn, op, l)\n      rtx insn;\n      rtx op[];\n      int *l; /* instruction length */\n {\n-  rtx x;\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx x = XEXP (src, 0);\n   int dummy;\n   \n   if (!l)\n     l = &dummy;\n-  x = XEXP (op[1],0);\n   \n   if (CONSTANT_ADDRESS_P (x))\n     {\n@@ -1728,12 +1729,12 @@ out_movqi_r_mr (insn, op, l)\n       && REG_P (XEXP (x,0))\n       && GET_CODE (XEXP (x,1)) == CONST_INT)\n     {\n-      if((INTVAL (XEXP (x,1)) - GET_MODE_SIZE (GET_MODE (op[1]))) >= 63)\n+      if ((INTVAL (XEXP (x,1)) - GET_MODE_SIZE (GET_MODE (src))) >= 63)\n \t{\n \t  int disp = INTVAL (XEXP (x,1));\n \t  if (REGNO (XEXP (x,0)) != REG_Y)\n \t    fatal_insn (\"Incorrect insn:\",insn);\n-\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[1])))\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (src)))\n \t    {\n \t      *l = 3;\n \t      op[4] = XEXP (x, 1);\n@@ -1757,7 +1758,7 @@ out_movqi_r_mr (insn, op, l)\n \t  op[4] = XEXP (x, 1);\n \t  /* This is a paranoid case LEGITIMIZE_RELOAD_ADDRESS must exclude\n \t     it but I have this situation with extremal optimizing options.  */\n-\t  if (reg_overlap_mentioned_p (op[0],XEXP (x,0))\n+\t  if (reg_overlap_mentioned_p (dest, XEXP (x,0))\n \t      || reg_unused_after (insn, XEXP (x,0)))\n \t    {\n \t      *l = 2;\n@@ -1776,14 +1777,17 @@ out_movqi_r_mr (insn, op, l)\n   return AS2 (ld,%0,%1);\n }\n \n-char *\n+const char *\n out_movhi_r_mr (insn, op, l)\n      rtx insn;\n      rtx op[];\n      int *l; /* instruction length */\n {\n-  int reg_dest = true_regnum (op[0]);\n-  int reg_base = true_regnum (XEXP (op[1], 0));\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (src, 0);\n+  int reg_dest = true_regnum (dest);\n+  int reg_base = true_regnum (base);\n   int tmp;\n \n   if (!l)\n@@ -1800,7 +1804,7 @@ out_movhi_r_mr (insn, op, l)\n \t}\n       else if (reg_base == REG_X)        /* (R26) */\n         {\n-          if (reg_unused_after (insn, XEXP (op[1],0)))\n+          if (reg_unused_after (insn, base))\n \t    {\n \t      *l = 2;\n \t      return (AS2 (ld,%A0,X+) CR_TAB\n@@ -1818,20 +1822,19 @@ out_movhi_r_mr (insn, op, l)\n \t\t  AS2 (ldd,%B0,%1+1));\n \t}\n     }\n-  else if (GET_CODE (XEXP (op[1],0)) == PLUS) /* (R + i) */\n+  else if (GET_CODE (base) == PLUS) /* (R + i) */\n     {\n-      int disp = INTVAL(XEXP (XEXP (op[1], 0), 1));\n-      int reg_base = true_regnum (XEXP (XEXP (op[1], 0), 0));\n+      int disp = INTVAL (XEXP (base, 1));\n+      int reg_base = true_regnum (XEXP (base, 0));\n       \n-      if (disp > MAX_LD_OFFSET (GET_MODE (op[1])))\n+      if (disp > MAX_LD_OFFSET (GET_MODE (src)))\n \t{\n-\t  rtx x = XEXP (op[1], 0);\n-\t  op[4] = XEXP (x, 1);\n+\t  op[4] = XEXP (base, 1);\n \n-\t  if (REGNO (XEXP (x,0)) != REG_Y)\n+\t  if (REGNO (XEXP (base, 0)) != REG_Y)\n \t    fatal_insn (\"Incorrect insn:\",insn);\n \t  \n-\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[1])))\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (src)))\n \t    {\n \t      *l = 4;\n \t      return (AS2 (adiw,r28,%4-62) CR_TAB\n@@ -1856,7 +1859,7 @@ out_movhi_r_mr (insn, op, l)\n \t     it but I have this situation with extremal\n \t     optimization options.  */\n \t  \n-\t  op[4] = XEXP (XEXP (op[1],0), 1);\n+\t  op[4] = XEXP (base, 1);\n \t  \n \t  if (reg_base == reg_dest)\n \t    {\n@@ -1895,26 +1898,32 @@ out_movhi_r_mr (insn, op, l)\n       return (AS2 (ldd,%A0,%A1) CR_TAB\n \t      AS2 (ldd,%B0,%B1));\n     }\n-  else if (GET_CODE (XEXP (op[1],0)) == PRE_DEC) /* (--R) */\n+  else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n     {\n-      if (reg_overlap_mentioned_p (op[0], XEXP (XEXP (op[1],0),0)))\n+      if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))\n \tfatal_insn (\"Incorrect insn:\", insn);\n \n       *l = 2;\n       return (AS2 (ld,%B0,%1) CR_TAB\n \t      AS2 (ld,%A0,%1));\n     }\n-  else if (GET_CODE (XEXP (op[1],0)) == POST_INC) /* (R++) */\n+  else if (GET_CODE (base) == POST_INC) /* (R++) */\n     {\n-      if (reg_overlap_mentioned_p (op[0], XEXP (XEXP (op[1],0),0)))\n+      if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))\n \tfatal_insn (\"Incorrect insn:\", insn);\n \n       *l = 2;\n       return (AS2 (ld,%A0,%1)  CR_TAB\n \t      AS2 (ld,%B0,%1));\n     }\n-  else if (CONSTANT_ADDRESS_P (XEXP (op[1],0)))\n+  else if (CONSTANT_ADDRESS_P (base))\n     {\n+      if (io_address_p (base, 2))\n+\t{\n+\t  *l = 2;\n+\t  return (AS2 (in,%A0,%A1-0x20) CR_TAB\n+\t\t  AS2 (in,%B0,%B1-0x20));\n+\t}\n       *l = 4;\n       return (AS2 (lds,%A0,%A1) CR_TAB\n \t      AS2 (lds,%B0,%B1));\n@@ -1924,14 +1933,17 @@ out_movhi_r_mr (insn, op, l)\n   return \"\";\n }\n \n-char *\n-out_movsi_r_mr (insn,op,l)\n+const char *\n+out_movsi_r_mr (insn, op, l)\n      rtx insn;\n      rtx op[];\n      int *l; /* instruction length */\n {\n-  int reg_dest=true_regnum (op[0]);\n-  int reg_base=true_regnum (XEXP (op[1],0));\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (src, 0);\n+  int reg_dest = true_regnum (dest);\n+  int reg_base = true_regnum (base);\n   int tmp;\n \n   if (!l)\n@@ -1954,7 +1966,7 @@ out_movsi_r_mr (insn,op,l)\n                           AS2 (ld,__tmp_reg__,X+)  CR_TAB\n                           AS2 (ld,%D0,X)  CR_TAB\n                           AS2 (mov,%C0,__tmp_reg__));\n-          else if (reg_unused_after (insn,XEXP (op[1],0)))\n+          else if (reg_unused_after (insn, base))\n             return  *l=4, (AS2 (ld,%A0,X+)  CR_TAB\n                            AS2 (ld,%B0,X+) CR_TAB\n                            AS2 (ld,%C0,X+) CR_TAB\n@@ -1987,16 +1999,15 @@ out_movsi_r_mr (insn,op,l)\n                           AS2 (ldd,%D0,%1+3));\n         }\n     }\n-  else if (GET_CODE (XEXP (op[1],0)) == PLUS) /* (R + i) */\n+  else if (GET_CODE (base) == PLUS) /* (R + i) */\n     {\n-      int disp = INTVAL(XEXP (XEXP (op[1],0), 1));\n+      int disp = INTVAL (XEXP (base, 1));\n       \n-      if (disp > MAX_LD_OFFSET (GET_MODE (op[1])))\n+      if (disp > MAX_LD_OFFSET (GET_MODE (src)))\n \t{\n-\t  rtx x = XEXP (op[1],0);\n-\t  if (REGNO (XEXP (x,0)) != REG_Y)\n+\t  if (REGNO (XEXP (base, 0)) != REG_Y)\n \t    fatal_insn (\"Incorrect insn:\",insn);\n-\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[1])))\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (src)))\n \t    {\n \t      op[4] = GEN_INT (disp - 60);\n \t      return *l=6,(AS2 (adiw, r28, %4) CR_TAB\n@@ -2008,7 +2019,7 @@ out_movsi_r_mr (insn,op,l)\n \t    }\n \t  else\n \t    {\n-\t      op[4] = XEXP (x,1);\n+\t      op[4] = XEXP (base, 1);\n \t      return *l=8,(AS2 (subi, r28, lo8(-%4))  CR_TAB\n \t\t\t   AS2 (sbci, r29, hi8(-%4)) CR_TAB\n \t\t\t   AS2 (ld, %A0,Y)             CR_TAB\n@@ -2020,7 +2031,7 @@ out_movsi_r_mr (insn,op,l)\n \t    }\n \t}\n \n-      reg_base = true_regnum (XEXP (XEXP (op[1],0), 0));\n+      reg_base = true_regnum (XEXP (base, 0));\n       if (reg_dest == reg_base)\n         return *l=5, (AS2 (ldd,%D0,%D1) CR_TAB\n                       AS2 (ldd,%C0,%C1) CR_TAB\n@@ -2038,17 +2049,17 @@ out_movsi_r_mr (insn,op,l)\n                     AS2 (ldd,%C0,%C1) CR_TAB\n                     AS2 (ldd,%D0,%D1));\n     }\n-  else if (GET_CODE (XEXP (op[1],0)) == PRE_DEC) /* (--R) */\n+  else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n     return *l=4, (AS2 (ld,%D0,%1) CR_TAB\n \t\t  AS2 (ld,%C0,%1) CR_TAB\n \t\t  AS2 (ld,%B0,%1) CR_TAB\n \t\t  AS2 (ld,%A0,%1));\n-  else if (GET_CODE (XEXP (op[1],0)) == POST_INC) /* (R++) */\n+  else if (GET_CODE (base) == POST_INC) /* (R++) */\n     return *l=4, (AS2 (ld,%A0,%1) CR_TAB\n \t\t  AS2 (ld,%B0,%1) CR_TAB\n \t\t  AS2 (ld,%C0,%1) CR_TAB\n \t\t  AS2 (ld,%D0,%1));\n-  else if (CONSTANT_ADDRESS_P (XEXP (op[1],0)))\n+  else if (CONSTANT_ADDRESS_P (base))\n       return *l=8, (AS2 (lds,%A0,%A1) CR_TAB\n \t\t    AS2 (lds,%B0,%B1) CR_TAB\n \t\t    AS2 (lds,%C0,%C1) CR_TAB\n@@ -2058,20 +2069,23 @@ out_movsi_r_mr (insn,op,l)\n   return \"\";\n }\n \n-char *\n-out_movsi_mr_r (insn,op,l)\n+const char *\n+out_movsi_mr_r (insn, op, l)\n      rtx insn;\n      rtx op[];\n      int *l;\n {\n-  int reg_base = true_regnum (XEXP (op[0],0));\n-  int reg_dest = true_regnum (op[1]);\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (dest, 0);\n+  int reg_base = true_regnum (base);\n+  int reg_src = true_regnum (src);\n   int tmp;\n   \n   if (!l)\n     l = &tmp;\n   \n-  if (CONSTANT_ADDRESS_P (XEXP (op[0],0)))\n+  if (CONSTANT_ADDRESS_P (base))\n     return *l=8,(AS2 (sts,%A0,%A1) CR_TAB\n \t\t AS2 (sts,%B0,%B1) CR_TAB\n \t\t AS2 (sts,%C0,%C1) CR_TAB\n@@ -2080,9 +2094,9 @@ out_movsi_mr_r (insn,op,l)\n     {\n       if (reg_base == REG_X)                /* (R26) */\n         {\n-          if (reg_dest == REG_X)\n+          if (reg_src == REG_X)\n             {\n-              if (reg_unused_after (insn,XEXP (op[0],0)))\n+              if (reg_unused_after (insn, base))\n                 return *l=5, (AS2 (mov,__tmp_reg__,%B1) CR_TAB\n                               AS2 (st,%0+,%A1) CR_TAB\n                               AS2 (st,%0+,__tmp_reg__)  CR_TAB\n@@ -2096,9 +2110,9 @@ out_movsi_mr_r (insn,op,l)\n                               AS2 (st,%0,%D1)  CR_TAB\n                               AS2 (sbiw,r26,3));\n             }\n-          else if (reg_base == reg_dest+2)\n+          else if (reg_base == reg_src + 2)\n             {\n-              if (reg_unused_after (insn,XEXP (op[0],0)))\n+              if (reg_unused_after (insn, base))\n                 return *l=7, (AS2 (mov,__zero_reg__,%C1) CR_TAB\n                               AS2 (mov,__tmp_reg__,%D1) CR_TAB\n                               AS2 (st,%0+,%A1) CR_TAB\n@@ -2128,15 +2142,14 @@ out_movsi_mr_r (insn,op,l)\n \t\t      AS2 (std,%0+2,%C1) CR_TAB\n \t\t      AS2 (std,%0+3,%D1));\n     }\n-  else if (GET_CODE (XEXP (op[0],0)) == PLUS) /* (R + i) */\n+  else if (GET_CODE (base) == PLUS) /* (R + i) */\n     {\n-      int disp = INTVAL(XEXP (XEXP (op[0],0), 1));\n-      if (disp > MAX_LD_OFFSET (GET_MODE (op[0])))\n+      int disp = INTVAL (XEXP (base, 1));\n+      if (disp > MAX_LD_OFFSET (GET_MODE (dest)))\n \t{\n-\t  rtx x = XEXP (op[0],0);\n-\t  if (REGNO (XEXP (x,0)) != REG_Y)\n+\t  if (REGNO (XEXP (base, 0)) != REG_Y)\n \t    fatal_insn (\"Incorrect insn:\",insn);\n-\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[0])))\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (dest)))\n \t    {\n \t      op[4] = GEN_INT (disp - 60);\n \t      return *l=6,(AS2 (adiw, r28, %4) CR_TAB\n@@ -2148,7 +2161,7 @@ out_movsi_mr_r (insn,op,l)\n \t    }\n \t  else\n \t    {\n-\t      op[4] = XEXP (x,1);\n+\t      op[4] = XEXP (base, 1);\n \t      return *l=8,(AS2 (subi, r28, lo8(-%4))  CR_TAB\n \t\t\t   AS2 (sbci, r29, hi8(-%4)) CR_TAB\n \t\t\t   AS2 (st, Y,%A1)             CR_TAB\n@@ -2164,12 +2177,12 @@ out_movsi_mr_r (insn,op,l)\n \t\t    AS2 (std,%C0,%C1) CR_TAB\n \t\t    AS2 (std,%D0,%D1));\n     }\n-  else if (GET_CODE (XEXP (op[0],0)) == PRE_DEC) /* (--R) */\n+  else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n     return *l=4, (AS2 (st,%0,%D1) CR_TAB\n \t\t  AS2 (st,%0,%C1) CR_TAB\n \t\t  AS2 (st,%0,%B1) CR_TAB\n \t\t  AS2 (st,%0,%A1));\n-  else if (GET_CODE (XEXP (op[0],0)) == POST_INC) /* (R++) */\n+  else if (GET_CODE (base) == POST_INC) /* (R++) */\n     return *l=4, (AS2 (st,%0,%A1)  CR_TAB\n \t\t  AS2 (st,%0,%B1) CR_TAB\n \t\t  AS2 (st,%0,%C1) CR_TAB\n@@ -2178,7 +2191,7 @@ out_movsi_mr_r (insn,op,l)\n   return \"\";\n }\n \n-char *\n+const char *\n output_movsisf(insn, operands, l)\n      rtx insn;\n      rtx operands[];\n@@ -2229,6 +2242,13 @@ output_movsisf(insn, operands, l)\n \t{\n \t  if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n \t    {\n+\t      if (byte_immediate_operand (src, SImode)\n+\t\t  && reg_was_0 (insn, dest))\n+\t\t{\n+\t\t  *l = 1;\n+\t\t  return (AS2 (ldi,%A0,lo8(%1) ; reg_was_0));\n+\t\t}\n+\n \t      *l = 4;\n \t      return (AS2 (ldi,%A0,lo8(%1))  CR_TAB\n \t\t      AS2 (ldi,%B0,hi8(%1))  CR_TAB\n@@ -2255,7 +2275,7 @@ output_movsisf(insn, operands, l)\n \t\t}\n \t      else if (src == const1_rtx)\n \t\t{\n-\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t  if (reg_was_0 (insn, dest))\n \t\t    {\n \t\t      *l = 1;\n \t\t      return AS1 (inc,%A0 ; reg_was_0);\n@@ -2269,7 +2289,7 @@ output_movsisf(insn, operands, l)\n \t\t}\n \t      else if (src == const2_rtx)\n \t\t{\n-\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t  if (reg_was_0 (insn, dest))\n \t\t    {\n \t\t      *l = 2;\n \t\t      return (AS1 (inc,%A0 ; reg_was_0) CR_TAB\n@@ -2296,7 +2316,7 @@ output_movsisf(insn, operands, l)\n \t      else if (src == constm1_rtx)\n \t\t{\n \t\t  /* Immediate constants -1 to any register */\n-\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t  if (reg_was_0 (insn, dest))\n \t\t    {\n \t\t      if (AVR_ENHANCED)\n \t\t\t{\n@@ -2346,41 +2366,36 @@ output_movsisf(insn, operands, l)\n     }\n   else if (GET_CODE (dest) == MEM)\n     {\n-      int save = 0;\n-      char *template;\n-      \n-      if (operands[1] == const0_rtx)\n-\t{\n+      const char *template;\n+\n+      if (src == const0_rtx)\n \t  operands[1] = zero_reg_rtx;\n-\t  save = 1;\n-\t}\n-      \n+\n       template = out_movsi_mr_r (insn, operands, real_l);\n \n       if (!real_l)\n \toutput_asm_insn (template, operands);\n-      \n-      if (save)\n-\toperands[1] = const0_rtx;\n+\n+      operands[1] = src;\n       return \"\";\n     }\n   fatal_insn (\"Invalid insn:\", insn);\n   return \"\";\n }\n \n-char *\n+const char *\n out_movqi_mr_r (insn, op, l)\n      rtx insn;\n      rtx op[];\n      int *l; /* instruction length */\n {\n-  rtx x;\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx x = XEXP (dest, 0);\n   int dummy;\n \n   if (!l)\n     l = &dummy;\n-    \n-  x = XEXP (op[0],0);\n   \n   if (CONSTANT_ADDRESS_P (x))\n     {\n@@ -2397,12 +2412,12 @@ out_movqi_mr_r (insn, op, l)\n       && REG_P (XEXP (x,0))\n       && GET_CODE (XEXP (x,1)) == CONST_INT)\n     {\n-      if ((INTVAL (XEXP (x,1)) - GET_MODE_SIZE (GET_MODE (op[0]))) >= 63)\n+      if ((INTVAL (XEXP (x,1)) - GET_MODE_SIZE (GET_MODE (dest))) >= 63)\n \t{\n \t  int disp = INTVAL (XEXP (x,1));\n \t  if (REGNO (XEXP (x,0)) != REG_Y)\n \t    fatal_insn (\"Incorrect insn:\",insn);\n-\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[0])))\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (dest)))\n \t    {\n \t      *l = 3;\n \t      op[4] = XEXP (x, 1);\n@@ -2424,7 +2439,7 @@ out_movqi_mr_r (insn, op, l)\n       else if (REGNO (XEXP (x,0)) == REG_X)\n \t{\n \t  op[4] = XEXP (x,1);\n-\t  if (reg_overlap_mentioned_p (op[1],XEXP (x,0)))\n+\t  if (reg_overlap_mentioned_p (src, XEXP (x, 0)))\n \t    {\n \t      if (reg_unused_after (insn, XEXP (x,0)))\n \t\t{\n@@ -2460,27 +2475,38 @@ out_movqi_mr_r (insn, op, l)\n   return AS2 (st,%0,%1);\n }\n \n-char *\n-out_movhi_mr_r (insn,op,l)\n+const char *\n+out_movhi_mr_r (insn, op, l)\n      rtx insn;\n      rtx op[];\n      int *l;\n {\n-  int reg_base = true_regnum (XEXP (op[0],0));\n-  int reg_dest = true_regnum (op[1]);\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (dest, 0);\n+  int reg_base = true_regnum (base);\n+  int reg_src = true_regnum (src);\n   int tmp;\n   if (!l)\n     l = &tmp;\n-  if (CONSTANT_ADDRESS_P (XEXP (op[0],0)))\n-    return *l=4,(AS2 (sts,%A0,%A1) CR_TAB\n-\t\t AS2 (sts,%B0,%B1));\n+  if (CONSTANT_ADDRESS_P (base))\n+    {\n+      if (io_address_p (base, 2))\n+\t{\n+\t  *l = 2;\n+\t  return (AS2 (out,%B0-0x20,%B1) CR_TAB\n+\t\t  AS2 (out,%A0-0x20,%A1));\n+\t}\n+      return *l = 4, (AS2 (sts,%B0,%B1) CR_TAB\n+\t\t      AS2 (sts,%A0,%A1));\n+    }\n   if (reg_base > 0)\n     {\n       if (reg_base == REG_X)\n         {\n-          if (reg_dest == REG_X)\n+          if (reg_src == REG_X)\n             {\n-              if (reg_unused_after (insn, op[1]))\n+              if (reg_unused_after (insn, src))\n                 return *l=3, (AS2 (mov,__tmp_reg__,r27) CR_TAB\n                               AS2 (st ,X+,r26) CR_TAB\n                               AS2 (st ,X,__tmp_reg__));\n@@ -2492,7 +2518,7 @@ out_movhi_mr_r (insn,op,l)\n             }\n           else\n             {\n-              if (reg_unused_after (insn, XEXP (op[0],0)))\n+              if (reg_unused_after (insn, base))\n                 return *l=2, (AS2 (st,X+,%A1) CR_TAB\n                               AS2 (st,X,%B1));\n               else\n@@ -2505,15 +2531,14 @@ out_movhi_mr_r (insn,op,l)\n         return  *l=2, (AS2 (st ,%0,%A1)    CR_TAB\n                        AS2 (std,%0+1,%B1));\n     }\n-  else if (GET_CODE (XEXP (op[0],0)) == PLUS)\n+  else if (GET_CODE (base) == PLUS)\n     {\n-      int disp = INTVAL(XEXP (XEXP (op[0],0), 1));\n-      if (disp > MAX_LD_OFFSET (GET_MODE (op[0])))\n+      int disp = INTVAL (XEXP (base, 1));\n+      if (disp > MAX_LD_OFFSET (GET_MODE (dest)))\n \t{\n-\t  rtx x = XEXP (op[0],0);\n-\t  if (REGNO (XEXP (x,0)) != REG_Y)\n+\t  if (REGNO (XEXP (base, 0)) != REG_Y)\n \t    fatal_insn (\"Incorrect insn:\",insn);\n-\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[0])))\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (dest)))\n \t    {\n \t      op[4] = GEN_INT (disp - 62);\n \t      return *l=4,(AS2 (adiw, r28, %4) CR_TAB\n@@ -2523,7 +2548,7 @@ out_movhi_mr_r (insn,op,l)\n \t    }\n \t  else\n \t    {\n-\t      op[4] = XEXP (x,1);\n+\t      op[4] = XEXP (base, 1);\n \t      return *l=6,(AS2 (subi, r28, lo8(-%4))  CR_TAB\n \t\t\t   AS2 (sbci, r29, hi8(-%4)) CR_TAB\n \t\t\t   AS2 (st, Y,%A1)           CR_TAB\n@@ -2535,10 +2560,10 @@ out_movhi_mr_r (insn,op,l)\n       return *l=2, (AS2 (std,%A0,%A1)    CR_TAB\n \t\t    AS2 (std,%B0,%B1));\n     }\n-  else if (GET_CODE (XEXP (op[0],0)) == PRE_DEC) /* (--R) */\n+  else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n     return *l=2, (AS2 (st,%0,%B1) CR_TAB\n \t\t  AS2 (st,%0,%A1));\n-  else if (GET_CODE (XEXP (op[0],0)) == POST_INC) /* (R++) */\n+  else if (GET_CODE (base) == POST_INC) /* (R++) */\n     return *l=2, (AS2 (st,%0,%A1)  CR_TAB\n \t\t  AS2 (st,%0,%B1));\n   fatal_insn (\"Unknown move insn:\",insn);\n@@ -2548,7 +2573,7 @@ out_movhi_mr_r (insn,op,l)\n /* Return 1 if frame pointer for current function required */\n \n int\n-frame_pointer_required_p(void)\n+frame_pointer_required_p ()\n {\n   return (current_function_calls_alloca\n \t  || current_function_args_info.nregs == 0\n@@ -2595,8 +2620,8 @@ compare_eq_p (insn)\n \n /* Output test instruction for HImode */\n \n-char *\n-out_tsthi (insn,l)\n+const char *\n+out_tsthi (insn, l)\n      rtx insn;\n      int *l;\n {\n@@ -2605,15 +2630,16 @@ out_tsthi (insn,l)\n       if (l) *l = 1;\n       return AS1 (tst,%B0);\n     }\n-  if (test_hard_reg_class (ADDW_REGS, SET_SRC (PATTERN (insn))))\n+  if (reg_unused_after (insn, SET_SRC (PATTERN (insn))))\n     {\n+      /* faster than sbiw if we can clobber the operand */\n       if (l) *l = 1;\n-      return AS2 (sbiw,%0,0);\n+      return AS2 (or,%A0,%B0);\n     }\n-  if (compare_eq_p (insn) && reg_unused_after (insn, SET_SRC (PATTERN (insn))))\n+  if (test_hard_reg_class (ADDW_REGS, SET_SRC (PATTERN (insn))))\n     {\n       if (l) *l = 1;\n-      return AS2 (or,%A0,%B0);\n+      return AS2 (sbiw,%0,0);\n     }\n   if (l) *l = 2;\n   return (AS2 (cp,%A0,__zero_reg__) CR_TAB\n@@ -2623,8 +2649,8 @@ out_tsthi (insn,l)\n \n /* Output test instruction for SImode */\n \n-char *\n-out_tstsi (insn,l)\n+const char *\n+out_tstsi (insn, l)\n      rtx insn;\n      int *l;\n {\n@@ -2652,8 +2678,8 @@ out_tstsi (insn,l)\n    Shift count are CONST_INT or REG.  */\n \n void\n-out_shift_with_cnt (template,insn,operands,len)\n-     char * template;\n+out_shift_with_cnt (template, insn, operands, len)\n+     const char *template;\n      rtx insn;\n      rtx operands[];\n      int *len;\n@@ -2729,8 +2755,8 @@ out_shift_with_cnt (template,insn,operands,len)\n \n /* 8bit shift left ((char)x << i)   */\n \n-char *\n-ashlqi3_out (insn,operands,len)\n+const char *\n+ashlqi3_out (insn, operands, len)\n      rtx insn;\n      rtx operands[];\n      int *len;\t\t\t/* insn length (may be NULL) */\n@@ -2828,8 +2854,8 @@ ashlqi3_out (insn,operands,len)\n \n /* 16bit shift left ((short)x << i)   */\n \n-char *\n-ashlhi3_out (insn,operands,len)\n+const char *\n+ashlhi3_out (insn, operands, len)\n      rtx insn;\n      rtx operands[];\n      int *len;\n@@ -2877,8 +2903,8 @@ ashlhi3_out (insn,operands,len)\n \n /* 32bit shift left ((long)x << i)   */\n \n-char *\n-ashlsi3_out (insn,operands,len)\n+const char *\n+ashlsi3_out (insn, operands, len)\n      rtx insn;\n      rtx operands[];\n      int *len;\n@@ -2982,8 +3008,8 @@ ashlsi3_out (insn,operands,len)\n \n /* 8bit arithmetic shift right  ((signed char)x >> i) */\n \n-char *\n-ashrqi3_out (insn,operands,len)\n+const char *\n+ashrqi3_out (insn, operands, len)\n      rtx insn;\n      rtx operands[];\n      int *len; /* insn length */\n@@ -3054,8 +3080,8 @@ ashrqi3_out (insn,operands,len)\n \n /* 16bit arithmetic shift right  ((signed short)x >> i) */\n \n-char *\n-ashrhi3_out (insn,operands,len)\n+const char *\n+ashrhi3_out (insn, operands, len)\n      rtx insn;\n      rtx operands[];\n      int *len;\n@@ -3112,8 +3138,8 @@ ashrhi3_out (insn,operands,len)\n \n /* 32bit arithmetic shift right  ((signed long)x >> i) */\n \n-char *\n-ashrsi3_out (insn,operands,len)\n+const char *\n+ashrsi3_out (insn, operands, len)\n      rtx insn;\n      rtx operands[];\n      int *len;\n@@ -3228,8 +3254,8 @@ ashrsi3_out (insn,operands,len)\n \n /* 8bit logic shift right ((unsigned char)x >> i) */\n \n-char *\n-lshrqi3_out (insn,operands,len)\n+const char *\n+lshrqi3_out (insn, operands, len)\n      rtx insn;\n      rtx operands[];\n      int *len;\n@@ -3325,8 +3351,8 @@ lshrqi3_out (insn,operands,len)\n \n /* 16bit logic shift right ((unsigned short)x >> i) */\n \n-char *\n-lshrhi3_out (insn,operands,len)\n+const char *\n+lshrhi3_out (insn, operands, len)\n      rtx insn;\n      rtx operands[];\n      int *len;\n@@ -3380,8 +3406,8 @@ lshrhi3_out (insn,operands,len)\n \n /* 32bit logic shift right ((unsigned int)x >> i) */\n \n-char *\n-lshrsi3_out (insn,operands,len)\n+const char *\n+lshrsi3_out (insn, operands, len)\n      rtx insn;\n      rtx operands[];\n      int *len;\n@@ -3477,7 +3503,7 @@ lshrsi3_out (insn,operands,len)\n  LEN is the initially computed length of the insn.  */\n \n int\n-adjust_insn_length (insn,len)\n+adjust_insn_length (insn, len)\n      rtx insn;\n      int len;\n {\n@@ -3537,13 +3563,13 @@ adjust_insn_length (insn,len)\n \t    {\n \t      HOST_WIDE_INT mask = INTVAL (XEXP (op[1],1));\n \t      if (GET_MODE (op[1]) == SImode)\n-\t\tlen = (((mask & 0xff) == 0)\n-\t\t       + ((mask & 0xff00) == 0)\n-\t\t       + ((mask & 0xff0000UL) == 0)\n-\t\t       + ((mask & 0xff000000UL) ==0));\n+\t\tlen = (((mask & 0xff) != 0)\n+\t\t       + ((mask & 0xff00) != 0)\n+\t\t       + ((mask & 0xff0000UL) != 0)\n+\t\t       + ((mask & 0xff000000UL) != 0));\n \t      else if (GET_MODE (op[1]) == HImode)\n-\t\tlen = (((mask & 0xff) == 0)\n-\t\t       + ((mask & 0xff00) == 0));\n+\t\tlen = (((mask & 0xff) != 0)\n+\t\t       + ((mask & 0xff00) != 0));\n \t    }\n \t}\n     }\n@@ -3718,7 +3744,7 @@ _reg_unused_after (insn, reg)\n /* Output rtx VALUE as .byte to file FILE */\n \n void\n-asm_output_char(file,value)\n+asm_output_char (file, value)\n      FILE *file;\n      rtx value;\n {\n@@ -3731,11 +3757,11 @@ asm_output_char(file,value)\n /* Output VALUE as .byte to file FILE */\n \n void\n-asm_output_byte (file,value)\n+asm_output_byte (file, value)\n      FILE *file;\n      int value;\n {\n-  fprintf (file, \"\\t.byte 0x%x\\n\",value & 0xff);\n+  fprintf (file, \"\\t.byte 0x%x\\n\", value & 0xff);\n }\n \n \n@@ -3773,7 +3799,7 @@ asm_output_float (file, n)\n   \n   REAL_VALUE_TO_TARGET_SINGLE (n, val);\n   REAL_VALUE_TO_DECIMAL (n, \"%g\", dstr);\n-  fprintf (file, \"\\t.long 0x%08lx\\t/* %s */\\n\",val, dstr);\n+  fprintf (file, \"\\t.long 0x%08lx\\t/* %s */\\n\", val, dstr);\n }\n \n /* Sets section name for declaration DECL */\n@@ -3784,8 +3810,8 @@ unique_section (decl, reloc)\n      int reloc ATTRIBUTE_UNUSED;\n {\n   int len;\n-  char *name,*string;\n-  char *prefix;\n+  const char *name, *prefix;\n+  char *string;\n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n   /* Strip off any encoding in name.  */\n   STRIP_NAME_ENCODING (name, name);\n@@ -3836,10 +3862,10 @@ asm_output_section_name(file, decl, name, reloc)\n \n void\n gas_output_limited_string(file, str)\n-     FILE * file ATTRIBUTE_UNUSED;\n-     char * str;\n+     FILE *file;\n+     const char * str;\n {\n-  unsigned char *_limited_str = (unsigned char *) str;\n+  const unsigned char *_limited_str = (unsigned char *) str;\n   unsigned ch;\n   fprintf (file, \"\\t%s\\t\\\"\", STRING_ASM_OP);\n   for (; (ch = *_limited_str); _limited_str++)\n@@ -3872,15 +3898,15 @@ gas_output_limited_string(file, str)\n void\n gas_output_ascii(file, str, length)\n      FILE * file;\n-     char * str;\n+     const char * str;\n      size_t length;\n {\n-  unsigned char *_ascii_bytes = (unsigned char *) str;\n-  unsigned char *limit = _ascii_bytes + length;\n+  const unsigned char *_ascii_bytes = (const unsigned char *) str;\n+  const unsigned char *limit = _ascii_bytes + length;\n   unsigned bytes_in_chunk = 0;\n   for (; _ascii_bytes < limit; _ascii_bytes++)\n     {\n-      register unsigned char *p;\n+      const unsigned char *p;\n       if (bytes_in_chunk >= 60)\n \t{\n \t  fprintf (file, \"\\\"\\n\");\n@@ -3931,7 +3957,8 @@ gas_output_ascii(file, str, length)\n    because registers of CLASS are needed for spill registers.  */\n \n enum reg_class\n-class_likely_spilled_p(int c)\n+class_likely_spilled_p (c)\n+     int c;\n {\n   return (c != ALL_REGS && c != ADDW_REGS);\n }\n@@ -4025,7 +4052,7 @@ encode_section_info (decl)\n       && TREE_CODE (decl) == VAR_DECL\n       && avr_progmem_p (decl))\n     {\n-      char * dsec = \".progmem.data\";\n+      const char *dsec = \".progmem.data\";\n       DECL_SECTION_NAME (decl) = build_string (strlen (dsec), dsec);\n       TREE_READONLY (decl) = 1;\n     }\n@@ -4077,7 +4104,7 @@ asm_file_end (file)\n    next register; and so on.  */\n \n void\n-order_regs_for_local_alloc (void)\n+order_regs_for_local_alloc ()\n {\n   unsigned int i;\n   int order_0[] = {\n@@ -4190,22 +4217,27 @@ default_rtx_costs (X, code, outer_code)\n /* Calculate the cost of a memory address */\n \n int\n-avr_address_cost (rtx x)\n+avr_address_cost (x)\n+     rtx x;\n {\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x,1)) == CONST_INT\n       && (REG_P (XEXP (x,0)) || GET_CODE (XEXP (x,0)) == SUBREG)\n       && INTVAL (XEXP (x,1)) >= 61)\n     return 18;\n   if (CONSTANT_ADDRESS_P (x))\n-    return 4;\n+    {\n+      if (io_address_p (x, 1))\n+\treturn 2;\n+      return 4;\n+    }\n   return 4;\n }\n \n /*  EXTRA_CONSTRAINT helper */\n \n int\n-extra_constraint (x,c)\n+extra_constraint (x, c)\n      rtx x;\n      int c;\n {\n@@ -4361,7 +4393,7 @@ machine_dependent_reorg (first_insn)\n /* Returns register number for function return value.*/\n \n int\n-avr_ret_register (void)\n+avr_ret_register ()\n {\n   return 24;\n }\n@@ -4383,7 +4415,7 @@ avr_libcall_value (mode)\n    function returns a value of data type VALTYPE.  */\n \n rtx\n-avr_function_value (type,func)\n+avr_function_value (type, func)\n      tree type;\n      tree func ATTRIBUTE_UNUSED;\n {\n@@ -4539,7 +4571,7 @@ const_int_pow2_p (x)\n   return 0;\n }\n \n-char *\n+const char *\n output_reload_inhi (insn, operands, len)\n      rtx insn ATTRIBUTE_UNUSED;\n      rtx *operands;\n@@ -4582,36 +4614,50 @@ output_reload_inhi (insn, operands, len)\n }\n \n \n-char *\n-output_reload_insisf (insn, operands, which_alternative)\n+const char *\n+output_reload_insisf (insn, operands, len)\n      rtx insn ATTRIBUTE_UNUSED;\n      rtx *operands;\n-     int which_alternative ATTRIBUTE_UNUSED;\n+     int *len;\n {\n-  int cnst = (GET_CODE (operands[1]) == CONST_INT);\n+  rtx src = operands[1];\n+  int cnst = (GET_CODE (src) == CONST_INT);\n+\n+  if (len)\n+    {\n+      if (cnst)\n+\t*len = 4 + ((INTVAL (src) & 0xff) != 0)\n+\t\t+ ((INTVAL (src) & 0xff00) != 0)\n+\t\t+ ((INTVAL (src) & 0xff0000) != 0)\n+\t\t+ ((INTVAL (src) & 0xff000000U) != 0);\n+      else\n+\t*len = 8;\n+\n+      return \"\";\n+    }\n \n-  if (cnst && ((INTVAL (operands[1]) & 0xff) == 0))\n+  if (cnst && ((INTVAL (src) & 0xff) == 0))\n     output_asm_insn (AS2 (mov, %A0, __zero_reg__), operands);\n   else\n     {\n       output_asm_insn (AS2 (ldi, %2, lo8(%1)), operands);\n       output_asm_insn (AS2 (mov, %A0, %2), operands);\n     }\n-  if (cnst && ((INTVAL (operands[1]) & 0xff00) == 0))\n+  if (cnst && ((INTVAL (src) & 0xff00) == 0))\n     output_asm_insn (AS2 (mov, %B0, __zero_reg__), operands);\n   else\n     {\n       output_asm_insn (AS2 (ldi, %2, hi8(%1)), operands);\n       output_asm_insn (AS2 (mov, %B0, %2), operands);\n     }\n-  if (cnst && ((INTVAL (operands[1]) & 0xff0000) == 0))\n+  if (cnst && ((INTVAL (src) & 0xff0000) == 0))\n     output_asm_insn (AS2 (mov, %C0, __zero_reg__), operands);\n   else\n     {\n       output_asm_insn (AS2 (ldi, %2, hlo8(%1)), operands);\n       output_asm_insn (AS2 (mov, %C0, %2), operands);\n     }\n-  if (cnst && ((INTVAL (operands[1]) & 0xff000000U) == 0))\n+  if (cnst && ((INTVAL (src) & 0xff000000U) == 0))\n     output_asm_insn (AS2 (mov, %D0, __zero_reg__), operands);\n   else\n     {"}, {"sha": "18f84f3c1d37550c1789a381056f96056f19917e", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd", "patch": "@@ -323,7 +323,7 @@ extern int avr_enhanced_p;\n    If you don't define this macro, the default is `\"long unsigned\n    int\"'.  */\n \n-#define PTRDIFF_TYPE (INT_TYPE_SIZE == 8 ? \"long unsigned int\" :\"unsigned int\")\n+#define PTRDIFF_TYPE (INT_TYPE_SIZE == 8 ? \"long int\" :\"int\")\n /* A C expression for a string describing the name of the data type\n    to use for the result of subtracting two pointers.  The typedef\n    name `ptrdiff_t' is defined using the contents of the string.  See"}, {"sha": "59f9aa72eff99c116c77d937c09297db5edeffb0", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=5fecfd8d614e7ff61a822c6dc30a0bf8e171b3dd", "patch": "@@ -271,7 +271,7 @@\n     || register_operand (operands[1],SImode) || const0_rtx == operands[1])\"\n   \"* return output_movsisf (insn, operands, NULL);\"\n   [(set_attr \"length\" \"4,4,8,8,4,10\")\n-   (set_attr \"cc\" \"none,set_zn,clobber,clobber,clobber,clobber\")])\n+   (set_attr \"cc\" \"none,set_zn,clobber,clobber,none,clobber\")])\n \n ;; fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n ;; move floating point numbers (32 bit)\n@@ -297,7 +297,7 @@\n    || register_operand (operands[1], SFmode)\"\n   \"* return output_movsisf (insn, operands, NULL);\"\n   [(set_attr \"length\" \"4,4,8,8,4,10\")\n-   (set_attr \"cc\" \"none,set_zn,clobber,clobber,clobber,clobber\")])\n+   (set_attr \"cc\" \"none,set_zn,clobber,clobber,none,clobber\")])\n \n ;;=========================================================================\n ;; move string (like memcpy)\n@@ -555,6 +555,7 @@\n   [(set_attr \"length\" \"2,1,1,2,3,3\")\n    (set_attr \"cc\" \"set_n,set_czn,set_czn,set_czn,set_n,set_n\")])\n \n+;; TODO: use \"movw\" if available\n (define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,!w,!w,d,r,r,&*!w,&*!w\")\n \t  (plus:SI\n@@ -734,7 +735,8 @@\n               AS2 (andi, %B0,hi8(%2)) CR_TAB\n \t      AS2 (andi, %C0,hlo8(%2)) CR_TAB\n \t      AS2 (andi, %D0,hhi8(%2)));\n-      }\n+    }\n+  return \\\"bug\\\";\n }\"\n   [(set_attr \"length\" \"4,4\")\n    (set_attr \"cc\" \"set_n,set_n\")])\n@@ -1076,6 +1078,7 @@\n   [(set_attr \"length\" \"5,6\")\n    (set_attr \"cc\" \"clobber,clobber\")])\n \n+;; TODO: use \"movw\" if available\n (define_insn \"extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\"               \"=r,&r\")\n         (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"0,*r\")))]\n@@ -1109,6 +1112,7 @@\n   [(set_attr \"length\" \"3,4\")\n    (set_attr \"cc\" \"set_n,set_n\")])\n \n+;; TODO: use \"movw\" if available\n (define_insn \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,&r\")\n         (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0,*r\")))]\n@@ -1211,7 +1215,7 @@\n     case 1:\n       if (reg_unused_after (insn, operands[0])\n           && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 63\n-          && TEST_HARD_REG_CLASS (ADDW_REGS, true_regnum (operands[0])))\n+          && test_hard_reg_class (ADDW_REGS, operands[0]))\n         return AS2 (sbiw,%0,%1);\n        else\n         return (AS2 (cpi,%0,%1) CR_TAB\n@@ -1235,6 +1239,7 @@\n               AS2 (ldi, %2,hi8(%1)) CR_TAB\n \t      AS2 (cpc, %B0,%2));\n     }\n+  return \\\"bug\\\";\n }\" \n   [(set_attr \"cc\" \"compare,compare,compare,compare,compare\")\n    (set_attr \"length\" \"2,2,3,3,4\")])\n@@ -1257,7 +1262,7 @@\n     case 1:\n       if (reg_unused_after (insn, operands[0])\n           && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 63\n-          && TEST_HARD_REG_CLASS (ADDW_REGS, true_regnum (operands[0])))\n+          && test_hard_reg_class (ADDW_REGS, operands[0]))\n         return (AS2 (sbiw,%0,%1) CR_TAB\n                 AS2 (cpc,%C0,__zero_reg__) CR_TAB\n                 AS2 (cpc,%D0,__zero_reg__));\n@@ -1295,7 +1300,8 @@\n \t       AS2 (cpc, %C0,%2)       CR_TAB\n \t       AS2 (ldi, %2,hhi8(%1)) CR_TAB\n \t       AS2 (cpc, %D0,%2));\n-   }\n+    }\n+  return \\\"bug\\\";\n }\"\n   [(set_attr \"cc\" \"compare,compare,compare,compare,compare\")\n    (set_attr \"length\" \"4,4,7,5,8\")])\n@@ -1610,6 +1616,7 @@\n   \"\"\n   \"\")\n \n+;; TODO: insn length for AVR_ENHANCED\n (define_insn \"call_insn\"\n   [(call (mem:HI (match_operand:HI 0 \"nonmemory_operand\" \"!z,*r,i\"))\n          (match_operand:HI 1 \"general_operand\" \"X,X,X\"))]\n@@ -1645,6 +1652,7 @@\n \t       (const_int 2)]\n \t(const_int 1)))])\n \n+;; TODO: insn length for AVR_ENHANCED\n (define_insn \"call_value_insn\"\n   [(set (match_operand 0 \"register_operand\" \"=r,r,r\")\n         (call (mem:HI (match_operand:HI 1 \"nonmemory_operand\" \"!z,*r,i\"))\n@@ -1705,6 +1713,8 @@\n   \"optimize\"\n   \"\")\n \n+;; TODO: jump to __tabjejump__ in libgcc\n+\n (define_insn \"*tablejump_enh\"\n    [(set (pc) (mem:HI\n \t       (plus:HI (match_operand:HI 0 \"register_operand\" \"=&z\")\n@@ -1798,7 +1808,7 @@\n     && test_hard_reg_class (LD_REGS, operands[1]))\"\n   \"*\n {\n-  if (TEST_HARD_REG_CLASS (ADDW_REGS, true_regnum (operands[0])))\n+  if (test_hard_reg_class (ADDW_REGS, operands[0]))\n     output_asm_insn (AS2 (sbiw,%0,1) CR_TAB\n \t\t     AS2 (sbc,%C0,__zero_reg__) CR_TAB\n \t\t     AS2 (sbc,%D0,__zero_reg__) \\\"\\\\n\\\", operands);\n@@ -1836,7 +1846,7 @@\n     && test_hard_reg_class (LD_REGS, operands[1]))\"\n   \"*\n {\n-  if (TEST_HARD_REG_CLASS (ADDW_REGS, true_regnum (operands[0])))\n+  if (test_hard_reg_class (ADDW_REGS, operands[0]))\n     output_asm_insn (AS2 (sbiw,%0,1), operands);\n   else\n     output_asm_insn (AS2 (subi,%A0,1) CR_TAB"}]}