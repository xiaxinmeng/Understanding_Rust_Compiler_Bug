{"sha": "bd8d431f44377efe110b02163d693e60421acdeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ4ZDQzMWY0NDM3N2VmZTExMGIwMjE2M2Q2OTNlNjA0MjFhY2RlYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-10-06T07:06:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-10-06T07:06:17Z"}, "message": "graphite-isl-ast-to-gimple.c: Include ssa.h and tree-ssa.h.\n\n2017-10-06  Richard Biener  <rguenther@suse.de>\n\n\t* graphite-isl-ast-to-gimple.c: Include ssa.h and tree-ssa.h.\n\t(translate_isl_ast_to_gimple::translate_pending_phi_nodes,\n\ttranslate_isl_ast_to_gimple::is_valid_rename,\n\ttranslate_isl_ast_to_gimple::get_rename,\n\ttranslate_isl_ast_to_gimple::get_def_bb_for_const,\n\ttranslate_isl_ast_to_gimple::get_new_name,\n\ttranslate_isl_ast_to_gimple::collect_all_ssa_names,\n\ttranslate_isl_ast_to_gimple::copy_loop_phi_args,\n\ttranslate_isl_ast_to_gimple::collect_all_ssa_names,\n\ttranslate_isl_ast_to_gimple::copy_loop_phi_args,\n\ttranslate_isl_ast_to_gimple::copy_loop_phi_nodes,\n\ttranslate_isl_ast_to_gimple::add_close_phis_to_merge_points,\n\ttranslate_isl_ast_to_gimple::add_close_phis_to_outer_loops,\n\ttranslate_isl_ast_to_gimple::copy_loop_close_phi_args,\n\ttranslate_isl_ast_to_gimple::copy_loop_close_phi_nodes,\n\ttranslate_isl_ast_to_gimple::copy_cond_phi_args,\n\ttranslate_isl_ast_to_gimple::copy_cond_phi_nodes,\n\ttranslate_isl_ast_to_gimple::edge_for_new_close_phis,\n\ttranslate_isl_ast_to_gimple::add_phi_arg_for_new_expr,\n\ttranslate_isl_ast_to_gimple::rename_uses,\n\ttranslate_isl_ast_to_gimple::rename_all_uses): Remove.\n\t(translate_isl_ast_to_gimple::get_rename_from_scev): Simplify.\n\t(set_rename_for_each_def): Likewise.\n\t(graphite_copy_stmts_from_block): Handle debug stmt resetting\n\there.  Handle rewriting SCEV analyzable uses here.\n\t(copy_bb_and_scalar_dependences): Generate code for PHI\n\tcopy-in/outs.\n\t(graphite_regenerate_ast_isl): Adjust.\n\t* graphite-scop-detection.c (trivially_empty_bb_p): Move to sese.[ch].\n\t(add_write, add_read): New functions.\n\t(build_cross_bb_scalars_def): Use it and simplify.\n\t(build_cross_bb_scalars_use): Likewise.\n\t(graphite_find_cross_bb_scalar_vars): Inline into...\n\t(try_generate_gimple_bb): ...here.  Add dependences for PHIs,\n\tsimulating out-of-SSA.  Compute liveout and add dependencies.\n\t(build_scops): Force an empty entry block.\n\t* sese.h (sese_info_t::liveout, sese_info_t::debug_liveout): New\n\tmembers.\n\t(sese_build_liveouts): Declare.\n\t(sese_trivially_empty_bb_p): Likewise.\n\t* sese.c (sese_build_liveouts_bb): Properly handle PHIs,\n\tcompute liveout and debug_liveout.\n\t(sese_bad_liveouts_use): Remove.\n\t(sese_reset_debug_liveouts_bb): Likewise.\n\t(sese_reset_debug_liveouts): Rewrite in terms of debug_liveout.\n\t(sese_build_liveouts): Build liveout and debug_liveout and store\n\tit in region.\n\t(new_sese_info): Adjust.\n\t(free_sese_info): Likewise.\n\t(sese_insert_phis_for_liveouts): Reset debug stmts from here,\n\tdo not build liveout here.\n\t(move_sese_in_condition): Adjust region entry.\n\t(scev_analyzable_p): Match up with chrec_apply requirements.\n\t(sese_trivially_empty_bb_p): New.\n\t* tree-into-ssa.c (get_reaching_def): Properly support generating\n\tdefault-defs for incremental rewrite of anonymous names.\n\n\t* gcc.dg/graphite/id-15.c: No longer expect a code generation error.\n\t* gcc.dg/graphite/id-16.c: Likewise.\n\t* gcc.dg/graphite/pr46168.c: Likewise.\n\t* gcc.dg/graphite/pr68756.c: Likewise.\n\t* gcc.dg/graphite/pr69728.c: Likewise.\n\t* gcc.dg/graphite/pr71575-2.c: Likewise.\n\t* gcc.dg/graphite/pr77362.c: Likewise.\n\t* gcc.dg/graphite/pr81373.c: Likewise.\n\t* gcc.dg/graphite/run-id-pr67700-1.c: Likewise.\n\t* gfortran.dg/graphite/interchange-1.f: Likewise.\n\t* gfortran.dg/graphite/pr42334-1.f: Likewise.\n\t* gfortran.dg/graphite/pr42393-1.f90: Likewise.\n\t* gfortran.dg/graphite/pr42393.f90: Likewise.\n\t* gfortran.dg/graphite/pr47019.f: Likewise.\n\t* gfortran.dg/graphite/id-17.f: Likewise.\n\t* gfortran.dg/graphite/id-19.f: Likewise.\n\t* gfortran.dg/graphite/run-id-2.f90: Likewise.\n\t* gfortran.dg/graphite/pr42326-1.f90: Likewise.\n\t* gfortran.dg/graphite/pr42326.f90: Likewise.\n\t* gfortran.dg/graphite/pr68550-2.f90: Likewise.\n\t* gfortran.dg/graphite/pr29581.f90: Likewise.  No longer expect\n\ta code generation error.\n\t* gfortran.dg/graphite/run-id-3.f90: Likewise.\n\t* gfortran.dg/graphite/pr29832.f90: Likewise.\n\nFrom-SVN: r253475", "tree": {"sha": "9f466b7e6ad425f1e3c4ebe0ce5cfca37581f726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f466b7e6ad425f1e3c4ebe0ce5cfca37581f726"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd8d431f44377efe110b02163d693e60421acdeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8d431f44377efe110b02163d693e60421acdeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd8d431f44377efe110b02163d693e60421acdeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8d431f44377efe110b02163d693e60421acdeb/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57cfa172280fd4a79a1d4120b69054457100af94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57cfa172280fd4a79a1d4120b69054457100af94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57cfa172280fd4a79a1d4120b69054457100af94"}], "stats": {"total": 2356, "additions": 522, "deletions": 1834}, "files": [{"sha": "218260c5109a758a55d86e166fa10ed61c01ebc7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,3 +1,62 @@\n+2017-10-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* graphite-isl-ast-to-gimple.c: Include ssa.h and tree-ssa.h.\n+\t(translate_isl_ast_to_gimple::translate_pending_phi_nodes,\n+\ttranslate_isl_ast_to_gimple::is_valid_rename,\n+\ttranslate_isl_ast_to_gimple::get_rename,\n+\ttranslate_isl_ast_to_gimple::get_def_bb_for_const,\n+\ttranslate_isl_ast_to_gimple::get_new_name,\n+\ttranslate_isl_ast_to_gimple::collect_all_ssa_names,\n+\ttranslate_isl_ast_to_gimple::copy_loop_phi_args,\n+\ttranslate_isl_ast_to_gimple::collect_all_ssa_names,\n+\ttranslate_isl_ast_to_gimple::copy_loop_phi_args,\n+\ttranslate_isl_ast_to_gimple::copy_loop_phi_nodes,\n+\ttranslate_isl_ast_to_gimple::add_close_phis_to_merge_points,\n+\ttranslate_isl_ast_to_gimple::add_close_phis_to_outer_loops,\n+\ttranslate_isl_ast_to_gimple::copy_loop_close_phi_args,\n+\ttranslate_isl_ast_to_gimple::copy_loop_close_phi_nodes,\n+\ttranslate_isl_ast_to_gimple::copy_cond_phi_args,\n+\ttranslate_isl_ast_to_gimple::copy_cond_phi_nodes,\n+\ttranslate_isl_ast_to_gimple::edge_for_new_close_phis,\n+\ttranslate_isl_ast_to_gimple::add_phi_arg_for_new_expr,\n+\ttranslate_isl_ast_to_gimple::rename_uses,\n+\ttranslate_isl_ast_to_gimple::rename_all_uses): Remove.\n+\t(translate_isl_ast_to_gimple::get_rename_from_scev): Simplify.\n+\t(set_rename_for_each_def): Likewise.\n+\t(graphite_copy_stmts_from_block): Handle debug stmt resetting\n+\there.  Handle rewriting SCEV analyzable uses here.\n+\t(copy_bb_and_scalar_dependences): Generate code for PHI\n+\tcopy-in/outs.\n+\t(graphite_regenerate_ast_isl): Adjust.\n+\t* graphite-scop-detection.c (trivially_empty_bb_p): Move to sese.[ch].\n+\t(add_write, add_read): New functions.\n+\t(build_cross_bb_scalars_def): Use it and simplify.\n+\t(build_cross_bb_scalars_use): Likewise.\n+\t(graphite_find_cross_bb_scalar_vars): Inline into...\n+\t(try_generate_gimple_bb): ...here.  Add dependences for PHIs,\n+\tsimulating out-of-SSA.  Compute liveout and add dependencies.\n+\t(build_scops): Force an empty entry block.\n+\t* sese.h (sese_info_t::liveout, sese_info_t::debug_liveout): New\n+\tmembers.\n+\t(sese_build_liveouts): Declare.\n+\t(sese_trivially_empty_bb_p): Likewise.\n+\t* sese.c (sese_build_liveouts_bb): Properly handle PHIs,\n+\tcompute liveout and debug_liveout.\n+\t(sese_bad_liveouts_use): Remove.\n+\t(sese_reset_debug_liveouts_bb): Likewise.\n+\t(sese_reset_debug_liveouts): Rewrite in terms of debug_liveout.\n+\t(sese_build_liveouts): Build liveout and debug_liveout and store\n+\tit in region.\n+\t(new_sese_info): Adjust.\n+\t(free_sese_info): Likewise.\n+\t(sese_insert_phis_for_liveouts): Reset debug stmts from here,\n+\tdo not build liveout here.\n+\t(move_sese_in_condition): Adjust region entry.\n+\t(scev_analyzable_p): Match up with chrec_apply requirements.\n+\t(sese_trivially_empty_bb_p): New.\n+\t* tree-into-ssa.c (get_reaching_def): Properly support generating\n+\tdefault-defs for incremental rewrite of anonymous names.\n+\n 2017-10-06  Richard Biener  <rguenther@suse.de>\n \n \t* graphite-sese-to-poly.c (extract_affine): For casts increasing"}, {"sha": "dddc07b5b433adf6d290f55407f8e77aa4236bbf", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 228, "deletions": 1623, "changes": 1851, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfghooks.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n+#include \"ssa.h\"\n #include \"params.h\"\n #include \"fold-const.h\"\n #include \"gimple-fold.h\"\n@@ -54,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"cfganal.h\"\n #include \"value-prof.h\"\n+#include \"tree-ssa.h\"\n #include \"graphite.h\"\n \n /* We always try to use signed 128 bit types, but fall back to smaller types\n@@ -190,55 +192,21 @@ class translate_isl_ast_to_gimple\n   void build_iv_mapping (vec<tree> iv_map, gimple_poly_bb_p gbb,\n \t\t\t __isl_keep isl_ast_expr *user_expr, ivs_params &ip,\n \t\t\t sese_l &region);\n-  void translate_pending_phi_nodes (void);\n   void add_parameters_to_ivs_params (scop_p scop, ivs_params &ip);\n   __isl_give isl_ast_build *generate_isl_context (scop_p scop);\n \n   __isl_give isl_ast_node * scop_to_isl_ast (scop_p scop);\n \n-  bool is_valid_rename (tree rename, basic_block def_bb, basic_block use_bb,\n-\t\t\tphi_node_kind, tree old_name, basic_block old_bb) const;\n-  tree get_rename (basic_block new_bb, tree old_name,\n-\t\t   basic_block old_bb, phi_node_kind) const;\n   tree get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n \t\t\t     basic_block new_bb, basic_block old_bb,\n \t\t\t     vec<tree> iv_map);\n-  basic_block get_def_bb_for_const (basic_block bb, basic_block old_bb) const;\n-  tree get_new_name (basic_block new_bb, tree op,\n-\t\t     basic_block old_bb, phi_node_kind) const;\n-  void collect_all_ssa_names (tree new_expr, vec<tree> *vec_ssa);\n-  bool copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n-\t\t\t   gphi *new_phi, init_back_edge_pair_t &ibp_new_bb,\n-\t\t\t   bool postpone);\n-  bool copy_loop_phi_nodes (basic_block bb, basic_block new_bb);\n-  bool add_close_phis_to_merge_points (gphi *old_phi, gphi *new_phi,\n-\t\t\t\t       tree default_value);\n-  tree add_close_phis_to_outer_loops (tree last_merge_name, edge merge_e,\n-\t\t\t\t      gimple *old_close_phi);\n-  bool copy_loop_close_phi_args (basic_block old_bb, basic_block new_bb,\n-\t\t\t\t vec<tree> iv_map, bool postpone);\n-  bool copy_loop_close_phi_nodes (basic_block old_bb, basic_block new_bb,\n-\t\t\t\t  vec<tree> iv_map);\n-  bool copy_cond_phi_args (gphi *phi, gphi *new_phi, vec<tree> iv_map,\n-\t\t\t   bool postpone);\n-  bool copy_cond_phi_nodes (basic_block bb, basic_block new_bb,\n-\t\t\t    vec<tree> iv_map);\n   bool graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n \t\t\t\t       vec<tree> iv_map);\n   edge copy_bb_and_scalar_dependences (basic_block bb, edge next_e,\n \t\t\t\t       vec<tree> iv_map);\n-  edge edge_for_new_close_phis (basic_block bb);\n-  bool add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n-\t\t\t\t edge old_bb_dominating_edge,\n-\t\t\t\t edge old_bb_non_dominating_edge,\n-\t\t\t\t gphi *phi, gphi *new_phi,\n-\t\t\t\t basic_block new_bb);\n-  bool rename_uses (gimple *copy, gimple_stmt_iterator *gsi_tgt,\n-\t\t    basic_block old_bb, loop_p loop, vec<tree> iv_map);\n   void set_rename (tree old_name, tree expr);\n   void set_rename_for_each_def (gimple *stmt);\n   void gsi_insert_earliest (gimple_seq seq);\n-  tree rename_all_uses (tree new_expr, basic_block new_bb, basic_block old_bb);\n   bool codegen_error_p () const { return codegen_error; }\n \n   void set_codegen_error ()\n@@ -955,206 +923,6 @@ translate_isl_ast (loop_p context_loop, __isl_keep isl_ast_node *node,\n     }\n }\n \n-/* Return true when BB contains loop close phi nodes.  A loop close phi node is\n-   at the exit of loop which takes one argument that is the last value of the\n-   variable being used out of the loop.  */\n-\n-static bool\n-bb_contains_loop_close_phi_nodes (basic_block bb)\n-{\n-  return single_pred_p (bb)\n-    && bb->loop_father != single_pred_edge (bb)->src->loop_father;\n-}\n-\n-/* Return true when BB contains loop phi nodes.  A loop phi node is the loop\n-   header containing phi nodes which has one init-edge and one back-edge.  */\n-\n-static bool\n-bb_contains_loop_phi_nodes (basic_block bb)\n-{\n-  if (EDGE_COUNT (bb->preds) != 2)\n-    return false;\n-\n-  unsigned depth = loop_depth (bb->loop_father);\n-\n-  edge preds[2] = { (*bb->preds)[0], (*bb->preds)[1] };\n-\n-  if (depth > loop_depth (preds[0]->src->loop_father)\n-      || depth > loop_depth (preds[1]->src->loop_father))\n-    return true;\n-\n-  /* When one of the edges correspond to the same loop father and other\n-     doesn't.  */\n-  if (bb->loop_father != preds[0]->src->loop_father\n-      && bb->loop_father == preds[1]->src->loop_father)\n-    return true;\n-\n-  if (bb->loop_father != preds[1]->src->loop_father\n-      && bb->loop_father == preds[0]->src->loop_father)\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Check if USE is defined in a basic block from where the definition of USE can\n-   propagate from all the paths.  FIXME: Verify checks for virtual operands.  */\n-\n-static bool\n-is_loop_closed_ssa_use (basic_block bb, tree use)\n-{\n-  if (TREE_CODE (use) != SSA_NAME || virtual_operand_p (use))\n-    return true;\n-\n-  /* For close-phi nodes def always comes from a loop which has a back-edge.  */\n-  if (bb_contains_loop_close_phi_nodes (bb))\n-    return true;\n-\n-  gimple *def = SSA_NAME_DEF_STMT (use);\n-  basic_block def_bb = gimple_bb (def);\n-  return (!def_bb\n-\t  || flow_bb_inside_loop_p (def_bb->loop_father, bb));\n-}\n-\n-/* Return the number of phi nodes in BB.  */\n-\n-static int\n-number_of_phi_nodes (basic_block bb)\n-{\n-  int num_phis = 0;\n-  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n-       gsi_next (&psi))\n-    num_phis++;\n-  return num_phis;\n-}\n-\n-/* Returns true if BB uses name in one of its PHIs.  */\n-\n-static bool\n-phi_uses_name (basic_block bb, tree name)\n-{\n-  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n-       gsi_next (&psi))\n-    {\n-      gphi *phi = psi.phi ();\n-      for (unsigned i = 0; i < gimple_phi_num_args (phi); i++)\n-\t{\n-\t  tree use_arg = gimple_phi_arg_def (phi, i);\n-\t  if (use_arg == name)\n-\t    return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* Return true if RENAME (defined in BB) is a valid use in NEW_BB.  The\n-   definition should flow into use, and the use should respect the loop-closed\n-   SSA form.  */\n-\n-bool translate_isl_ast_to_gimple::\n-is_valid_rename (tree rename, basic_block def_bb, basic_block use_bb,\n-\t\t phi_node_kind phi_kind, tree old_name, basic_block old_bb) const\n-{\n-  if (SSA_NAME_IS_DEFAULT_DEF (rename))\n-    return true;\n-\n-  /* The def of the rename must either dominate the uses or come from a\n-     back-edge.  Also the def must respect the loop closed ssa form.  */\n-  if (!is_loop_closed_ssa_use (use_bb, rename))\n-    {\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"[codegen] rename not in loop closed ssa: \");\n-\t  print_generic_expr (dump_file, rename);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      return false;\n-    }\n-\n-  if (dominated_by_p (CDI_DOMINATORS, use_bb, def_bb))\n-    return true;\n-\n-  if (bb_contains_loop_phi_nodes (use_bb) && phi_kind == loop_phi)\n-    {\n-      /* The loop-header dominates the loop-body.  */\n-      if (!dominated_by_p (CDI_DOMINATORS, def_bb, use_bb))\n-\treturn false;\n-\n-      /* RENAME would be used in loop-phi.  */\n-      gcc_assert (number_of_phi_nodes (use_bb));\n-\n-      /* For definitions coming from back edges, we should check that\n-\t old_name is used in a loop PHI node.\n-\t FIXME: Verify if this is true.  */\n-      if (phi_uses_name (old_bb, old_name))\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n-/* Returns the expression associated to OLD_NAME (which is used in OLD_BB), in\n-   NEW_BB from RENAME_MAP.  PHI_KIND determines the kind of phi node.  */\n-\n-tree translate_isl_ast_to_gimple::\n-get_rename (basic_block new_bb, tree old_name, basic_block old_bb,\n-\t    phi_node_kind phi_kind) const\n-{\n-  gcc_assert (TREE_CODE (old_name) == SSA_NAME);\n-  vec <tree> *renames = region->rename_map->get (old_name);\n-\n-  if (!renames || renames->is_empty ())\n-    return NULL_TREE;\n-\n-  if (1 == renames->length ())\n-    {\n-      tree rename = (*renames)[0];\n-      if (TREE_CODE (rename) == SSA_NAME)\n-\t{\n-\t  basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (rename));\n-\t  if (is_valid_rename (rename, bb, new_bb, phi_kind, old_name, old_bb)\n-\t      && (phi_kind == close_phi\n-\t\t  || ! bb\n-\t\t  || flow_bb_inside_loop_p (bb->loop_father, new_bb)))\n-\t    return rename;\n-\t  return NULL_TREE;\n-\t}\n-\n-      if (is_constant (rename))\n-\treturn rename;\n-\n-      return NULL_TREE;\n-    }\n-\n-  /* More than one renames corresponding to the old_name.  Find the rename for\n-     which the definition flows into usage at new_bb.  */\n-  int i;\n-  tree t1 = NULL_TREE, t2;\n-  basic_block t1_bb = NULL;\n-  FOR_EACH_VEC_ELT (*renames, i, t2)\n-    {\n-      basic_block t2_bb = gimple_bb (SSA_NAME_DEF_STMT (t2));\n-\n-      /* Defined in the same basic block as used.  */\n-      if (t2_bb == new_bb)\n-\treturn t2;\n-\n-      /* NEW_BB and T2_BB are in two unrelated if-clauses.  */\n-      if (!dominated_by_p (CDI_DOMINATORS, new_bb, t2_bb))\n-\tcontinue;\n-\n-      if (!flow_bb_inside_loop_p (t2_bb->loop_father, new_bb))\n-\tcontinue;\n-\n-      /* Compute the nearest dominator.  */\n-      if (!t1 || dominated_by_p (CDI_DOMINATORS, t2_bb, t1_bb))\n-\t{\n-\t  t1_bb = t2_bb;\n-\t  t1 = t2;\n-\t}\n-    }\n-\n-  return t1;\n-}\n-\n /* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).\n    When OLD_NAME and EXPR are the same we assert.  */\n \n@@ -1197,1239 +965,168 @@ set_rename (tree old_name, tree expr)\n    Either GSI1 and GSI2 should belong to the same basic block or one of their\n    respective basic blocks should dominate the other.  */\n \n-gimple_stmt_iterator\n-later_of_the_two (gimple_stmt_iterator gsi1, gimple_stmt_iterator gsi2)\n-{\n-  basic_block bb1 = gsi_bb (gsi1);\n-  basic_block bb2 = gsi_bb (gsi2);\n-\n-  /* Find the iterator which is the latest.  */\n-  if (bb1 == bb2)\n-    {\n-      gimple *stmt1 = gsi_stmt (gsi1);\n-      gimple *stmt2 = gsi_stmt (gsi2);\n-\n-      if (stmt1 != NULL && stmt2 != NULL)\n-\t{\n-\t  bool is_phi1 = gimple_code (stmt1) == GIMPLE_PHI;\n-\t  bool is_phi2 = gimple_code (stmt2) == GIMPLE_PHI;\n-\n-\t  if (is_phi1 != is_phi2)\n-\t    return is_phi1 ? gsi2 : gsi1;\n-\t}\n-\n-      /* For empty basic blocks gsis point to the end of the sequence.  Since\n-\t there is no operator== defined for gimple_stmt_iterator and for gsis\n-\t not pointing to a valid statement gsi_next would assert.  */\n-      gimple_stmt_iterator gsi = gsi1;\n-      do {\n-\tif (gsi_stmt (gsi) == gsi_stmt (gsi2))\n-\t  return gsi2;\n-\tgsi_next (&gsi);\n-      } while (!gsi_end_p (gsi));\n-\n-      return gsi1;\n-    }\n-\n-  /* Find the basic block closest to the basic block which defines stmt.  */\n-  if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))\n-    return gsi1;\n-\n-  gcc_assert (dominated_by_p (CDI_DOMINATORS, bb2, bb1));\n-  return gsi2;\n-}\n-\n-/* Insert each statement from SEQ at its earliest insertion p.  */\n-\n-void translate_isl_ast_to_gimple::\n-gsi_insert_earliest (gimple_seq seq)\n-{\n-  update_modified_stmts (seq);\n-  sese_l &codegen_region = region->if_region->true_region->region;\n-  basic_block begin_bb = get_entry_bb (codegen_region);\n-\n-  /* Inserting the gimple statements in a vector because gimple_seq behave\n-     in strage ways when inserting the stmts from it into different basic\n-     blocks one at a time.  */\n-  auto_vec<gimple *, 3> stmts;\n-  for (gimple_stmt_iterator gsi = gsi_start (seq); !gsi_end_p (gsi);\n-       gsi_next (&gsi))\n-    stmts.safe_push (gsi_stmt (gsi));\n-\n-  int i;\n-  gimple *use_stmt;\n-  FOR_EACH_VEC_ELT (stmts, i, use_stmt)\n-    {\n-      gcc_assert (gimple_code (use_stmt) != GIMPLE_PHI);\n-      gimple_stmt_iterator gsi_def_stmt = gsi_start_bb_nondebug (begin_bb);\n-\n-      use_operand_p use_p;\n-      ssa_op_iter op_iter;\n-      FOR_EACH_SSA_USE_OPERAND (use_p, use_stmt, op_iter, SSA_OP_USE)\n-\t{\n-\t  /* Iterator to the current def of use_p.  For function parameters or\n-\t     anything where def is not found, insert at the beginning of the\n-\t     generated region.  */\n-\t  gimple_stmt_iterator gsi_stmt = gsi_def_stmt;\n-\n-\t  tree op = USE_FROM_PTR (use_p);\n-\t  gimple *stmt = SSA_NAME_DEF_STMT (op);\n-\t  if (stmt && (gimple_code (stmt) != GIMPLE_NOP))\n-\t    gsi_stmt = gsi_for_stmt (stmt);\n-\n-\t  /* For region parameters, insert at the beginning of the generated\n-\t     region.  */\n-\t  if (!bb_in_sese_p (gsi_bb (gsi_stmt), codegen_region))\n-\t    gsi_stmt = gsi_def_stmt;\n-\n-\t  gsi_def_stmt = later_of_the_two (gsi_stmt, gsi_def_stmt);\n-\t}\n-\n-      if (!gsi_stmt (gsi_def_stmt))\n-\t{\n-\t  gimple_stmt_iterator gsi = gsi_after_labels (gsi_bb (gsi_def_stmt));\n-\t  gsi_insert_before (&gsi, use_stmt, GSI_NEW_STMT);\n-\t}\n-      else if (gimple_code (gsi_stmt (gsi_def_stmt)) == GIMPLE_PHI)\n-\t{\n-\t  gimple_stmt_iterator bsi\n-\t    = gsi_start_bb_nondebug (gsi_bb (gsi_def_stmt));\n-\t  /* Insert right after the PHI statements.  */\n-\t  gsi_insert_before (&bsi, use_stmt, GSI_NEW_STMT);\n-\t}\n-      else\n-\tgsi_insert_after (&gsi_def_stmt, use_stmt, GSI_NEW_STMT);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"[codegen] inserting statement: \");\n-\t  print_gimple_stmt (dump_file, use_stmt, 0, TDF_VOPS | TDF_MEMSYMS);\n-\t  print_loops_bb (dump_file, gimple_bb (use_stmt), 0, 3);\n-\t}\n-    }\n-}\n-\n-/* Collect all the operands of NEW_EXPR by recursively visiting each\n-   operand.  */\n-\n-void translate_isl_ast_to_gimple::\n-collect_all_ssa_names (tree new_expr, vec<tree> *vec_ssa)\n-{\n-  if (new_expr == NULL_TREE)\n-    return;\n-\n-  /* Rename all uses in new_expr.  */\n-  if (TREE_CODE (new_expr) == SSA_NAME)\n-    {\n-      vec_ssa->safe_push (new_expr);\n-      return;\n-    }\n-\n-  /* Iterate over SSA_NAMES in NEW_EXPR.  */\n-  for (int i = 0; i < (TREE_CODE_LENGTH (TREE_CODE (new_expr))); i++)\n-    {\n-      tree op = TREE_OPERAND (new_expr, i);\n-      collect_all_ssa_names (op, vec_ssa);\n-    }\n-}\n-\n-/* This is abridged version of the function copied from:\n-   tree.c:substitute_in_expr (tree exp, tree f, tree r).  */\n-\n-static tree\n-substitute_ssa_name (tree exp, tree f, tree r)\n-{\n-  enum tree_code code = TREE_CODE (exp);\n-  tree op0, op1, op2, op3;\n-  tree new_tree;\n-\n-  /* We handle TREE_LIST and COMPONENT_REF separately.  */\n-  if (code == TREE_LIST)\n-    {\n-      op0 = substitute_ssa_name (TREE_CHAIN (exp), f, r);\n-      op1 = substitute_ssa_name (TREE_VALUE (exp), f, r);\n-      if (op0 == TREE_CHAIN (exp) && op1 == TREE_VALUE (exp))\n-\treturn exp;\n-\n-      return tree_cons (TREE_PURPOSE (exp), op1, op0);\n-    }\n-  else if (code == COMPONENT_REF)\n-    {\n-      tree inner;\n-\n-      /* If this expression is getting a value from a PLACEHOLDER_EXPR\n-\t and it is the right field, replace it with R.  */\n-      for (inner = TREE_OPERAND (exp, 0);\n-\t   REFERENCE_CLASS_P (inner);\n-\t   inner = TREE_OPERAND (inner, 0))\n-\t;\n-\n-      /* The field.  */\n-      op1 = TREE_OPERAND (exp, 1);\n-\n-      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && op1 == f)\n-\treturn r;\n-\n-      /* If this expression hasn't been completed let, leave it alone.  */\n-      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && !TREE_TYPE (inner))\n-\treturn exp;\n-\n-      op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n-      if (op0 == TREE_OPERAND (exp, 0))\n-\treturn exp;\n-\n-      new_tree\n-\t= fold_build3 (COMPONENT_REF, TREE_TYPE (exp), op0, op1, NULL_TREE);\n-    }\n-  else\n-    switch (TREE_CODE_CLASS (code))\n-      {\n-      case tcc_constant:\n-\treturn exp;\n-\n-      case tcc_declaration:\n-\tif (exp == f)\n-\t  return r;\n-\telse\n-\t  return exp;\n-\n-      case tcc_expression:\n-\tif (exp == f)\n-\t  return r;\n-\n-\t/* Fall through.  */\n-\n-      case tcc_exceptional:\n-      case tcc_unary:\n-      case tcc_binary:\n-      case tcc_comparison:\n-      case tcc_reference:\n-\tswitch (TREE_CODE_LENGTH (code))\n-\t  {\n-\t  case 0:\n-\t    if (exp == f)\n-\t      return r;\n-\t    return exp;\n-\n-\t  case 1:\n-\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n-\t    if (op0 == TREE_OPERAND (exp, 0))\n-\t      return exp;\n-\n-\t    new_tree = fold_build1 (code, TREE_TYPE (exp), op0);\n-\t    break;\n-\n-\t  case 2:\n-\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n-\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n-\n-\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n-\t      return exp;\n-\n-\t    new_tree = fold_build2 (code, TREE_TYPE (exp), op0, op1);\n-\t    break;\n-\n-\t  case 3:\n-\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n-\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n-\t    op2 = substitute_ssa_name (TREE_OPERAND (exp, 2), f, r);\n-\n-\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n-\t\t&& op2 == TREE_OPERAND (exp, 2))\n-\t      return exp;\n-\n-\t    new_tree = fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);\n-\t    break;\n-\n-\t  case 4:\n-\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n-\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n-\t    op2 = substitute_ssa_name (TREE_OPERAND (exp, 2), f, r);\n-\t    op3 = substitute_ssa_name (TREE_OPERAND (exp, 3), f, r);\n-\n-\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n-\t\t&& op2 == TREE_OPERAND (exp, 2)\n-\t\t&& op3 == TREE_OPERAND (exp, 3))\n-\t      return exp;\n-\n-\t    new_tree\n-\t      = fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));\n-\t    break;\n-\n-\t  default:\n-\t    gcc_unreachable ();\n-\t  }\n-\tbreak;\n-\n-      case tcc_vl_exp:\n-      default:\n-\tgcc_unreachable ();\n-      }\n-\n-  TREE_READONLY (new_tree) |= TREE_READONLY (exp);\n-\n-  if (code == INDIRECT_REF || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n-    TREE_THIS_NOTRAP (new_tree) |= TREE_THIS_NOTRAP (exp);\n-\n-  return new_tree;\n-}\n-\n-/* Rename all the operands of NEW_EXPR by recursively visiting each operand.  */\n-\n-tree translate_isl_ast_to_gimple::\n-rename_all_uses (tree new_expr, basic_block new_bb, basic_block old_bb)\n-{\n-  auto_vec<tree, 2> ssa_names;\n-  collect_all_ssa_names (new_expr, &ssa_names);\n-  tree t;\n-  int i;\n-  FOR_EACH_VEC_ELT (ssa_names, i, t)\n-    if (tree r = get_rename (new_bb, t, old_bb, unknown_phi))\n-      new_expr = substitute_ssa_name (new_expr, t, r);\n-\n-  return new_expr;\n-}\n-\n-/* For ops which are scev_analyzeable, we can regenerate a new name from its\n-   scalar evolution around LOOP.  */\n-\n-tree translate_isl_ast_to_gimple::\n-get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n-\t\t      basic_block new_bb, basic_block old_bb,\n-\t\t      vec<tree> iv_map)\n-{\n-  tree scev = scalar_evolution_in_region (region->region, loop, old_name);\n-\n-  /* At this point we should know the exact scev for each\n-     scalar SSA_NAME used in the scop: all the other scalar\n-     SSA_NAMEs should have been translated out of SSA using\n-     arrays with one element.  */\n-  tree new_expr;\n-  if (chrec_contains_undetermined (scev))\n-    {\n-      set_codegen_error ();\n-      return build_zero_cst (TREE_TYPE (old_name));\n-    }\n-\n-  new_expr = chrec_apply_map (scev, iv_map);\n-\n-  /* The apply should produce an expression tree containing\n-     the uses of the new induction variables.  We should be\n-     able to use new_expr instead of the old_name in the newly\n-     generated loop nest.  */\n-  if (chrec_contains_undetermined (new_expr)\n-      || tree_contains_chrecs (new_expr, NULL))\n-    {\n-      set_codegen_error ();\n-      return build_zero_cst (TREE_TYPE (old_name));\n-    }\n-\n-  if (TREE_CODE (new_expr) == SSA_NAME)\n-    {\n-      basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (new_expr));\n-      if (bb && !dominated_by_p (CDI_DOMINATORS, new_bb, bb))\n-\t{\n-\t  set_codegen_error ();\n-\t  return build_zero_cst (TREE_TYPE (old_name));\n-\t}\n-    }\n-\n-  new_expr = rename_all_uses (new_expr, new_bb, old_bb);\n-\n-  /* We check all the operands and all of them should dominate the use at\n-     new_expr.  */\n-  auto_vec <tree, 2> new_ssa_names;\n-  collect_all_ssa_names (new_expr, &new_ssa_names);\n-  int i;\n-  tree new_ssa_name;\n-  FOR_EACH_VEC_ELT (new_ssa_names, i, new_ssa_name)\n-    {\n-      if (TREE_CODE (new_ssa_name) == SSA_NAME)\n-\t{\n-\t  basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (new_ssa_name));\n-\t  if (bb && !dominated_by_p (CDI_DOMINATORS, new_bb, bb))\n-\t    {\n-\t      set_codegen_error ();\n-\t      return build_zero_cst (TREE_TYPE (old_name));\n-\t    }\n-\t}\n-    }\n-\n-  /* Replace the old_name with the new_expr.  */\n-  return force_gimple_operand (unshare_expr (new_expr), stmts,\n-\t\t\t       true, NULL_TREE);\n-}\n-\n-/* Renames the scalar uses of the statement COPY, using the\n-   substitution map RENAME_MAP, inserting the gimplification code at\n-   GSI_TGT, for the translation REGION, with the original copied\n-   statement in LOOP, and using the induction variable renaming map\n-   IV_MAP.  Returns true when something has been renamed.  */\n-\n-bool translate_isl_ast_to_gimple::\n-rename_uses (gimple *copy, gimple_stmt_iterator *gsi_tgt, basic_block old_bb,\n-\t     loop_p loop, vec<tree> iv_map)\n-{\n-  bool changed = false;\n-\n-  if (is_gimple_debug (copy))\n-    {\n-      if (gimple_debug_bind_p (copy))\n-\tgimple_debug_bind_reset_value (copy);\n-      else if (gimple_debug_source_bind_p (copy))\n-\treturn false;\n-      else\n-\tgcc_unreachable ();\n-\n-      return false;\n-    }\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"[codegen] renaming uses of stmt: \");\n-      print_gimple_stmt (dump_file, copy, 0);\n-    }\n-\n-  use_operand_p use_p;\n-  ssa_op_iter op_iter;\n-  FOR_EACH_SSA_USE_OPERAND (use_p, copy, op_iter, SSA_OP_USE)\n-    {\n-      tree old_name = USE_FROM_PTR (use_p);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"[codegen] renaming old_name = \");\n-\t  print_generic_expr (dump_file, old_name);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      if (TREE_CODE (old_name) != SSA_NAME\n-\t  || SSA_NAME_IS_DEFAULT_DEF (old_name))\n-\tcontinue;\n-\n-      changed = true;\n-      tree new_expr = get_rename (gsi_tgt->bb, old_name,\n-\t\t\t\t  old_bb, unknown_phi);\n-\n-      if (new_expr)\n-\t{\n-\t  tree type_old_name = TREE_TYPE (old_name);\n-\t  tree type_new_expr = TREE_TYPE (new_expr);\n-\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"[codegen] from rename_map: new_name = \");\n-\t      print_generic_expr (dump_file, new_expr);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\n-\t  if (type_old_name != type_new_expr\n-\t      || TREE_CODE (new_expr) != SSA_NAME)\n-\t    {\n-\t      tree var = create_tmp_var (type_old_name, \"var\");\n-\n-\t      if (!useless_type_conversion_p (type_old_name, type_new_expr))\n-\t\tnew_expr = fold_convert (type_old_name, new_expr);\n-\n-\t      gimple_seq stmts;\n-\t      new_expr = force_gimple_operand (new_expr, &stmts, true, var);\n-\t      gsi_insert_earliest (stmts);\n-\t    }\n-\n-\t  replace_exp (use_p, new_expr);\n-\t  continue;\n-\t}\n-\n-      gimple_seq stmts;\n-      new_expr = get_rename_from_scev (old_name, &stmts, loop, gimple_bb (copy),\n-\t\t\t\t       old_bb, iv_map);\n-      if (!new_expr || codegen_error_p ())\n-\treturn false;\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"[codegen] not in rename map, scev: \");\n-\t  print_generic_expr (dump_file, new_expr);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      gsi_insert_earliest (stmts);\n-      replace_exp (use_p, new_expr);\n-\n-      if (TREE_CODE (new_expr) == INTEGER_CST\n-\t  && is_gimple_assign (copy))\n-\t{\n-\t  tree rhs = gimple_assign_rhs1 (copy);\n-\n-\t  if (TREE_CODE (rhs) == ADDR_EXPR)\n-\t    recompute_tree_invariant_for_addr_expr (rhs);\n-\t}\n-\n-      set_rename (old_name, new_expr);\n-    }\n-\n-  return changed;\n-}\n-\n-/* Returns a basic block that could correspond to where a constant was defined\n-   in the original code.  In the original code OLD_BB had the definition, we\n-   need to find which basic block out of the copies of old_bb, in the new\n-   region, should a definition correspond to if it has to reach BB.  */\n-\n-basic_block translate_isl_ast_to_gimple::\n-get_def_bb_for_const (basic_block bb, basic_block old_bb) const\n-{\n-  vec <basic_block> *bbs = region->copied_bb_map->get (old_bb);\n-\n-  if (!bbs || bbs->is_empty ())\n-    return NULL;\n-\n-  if (1 == bbs->length ())\n-    return (*bbs)[0];\n-\n-  int i;\n-  basic_block b1 = NULL, b2;\n-  FOR_EACH_VEC_ELT (*bbs, i, b2)\n-    {\n-      if (b2 == bb)\n-\treturn bb;\n-\n-      /* BB and B2 are in two unrelated if-clauses.  */\n-      if (!dominated_by_p (CDI_DOMINATORS, bb, b2))\n-\tcontinue;\n-\n-      /* Compute the nearest dominator.  */\n-      if (!b1 || dominated_by_p (CDI_DOMINATORS, b2, b1))\n-\tb1 = b2;\n-    }\n-\n-  return b1;\n-}\n-\n-/* Get the new name of OP (from OLD_BB) to be used in NEW_BB.  PHI_KIND\n-   determines the kind of phi node.  */\n-\n-tree translate_isl_ast_to_gimple::\n-get_new_name (basic_block new_bb, tree op,\n-\t      basic_block old_bb, phi_node_kind phi_kind) const\n-{\n-  /* For constants the names are the same.  */\n-  if (TREE_CODE (op) != SSA_NAME)\n-    return op;\n-\n-  return get_rename (new_bb, op, old_bb, phi_kind);\n-}\n-\n-/* Return a debug location for OP.  */\n-\n-static location_t\n-get_loc (tree op)\n-{\n-  location_t loc = UNKNOWN_LOCATION;\n-\n-  if (TREE_CODE (op) == SSA_NAME)\n-    loc = gimple_location (SSA_NAME_DEF_STMT (op));\n-  return loc;\n-}\n-\n-/* Returns the incoming edges of basic_block BB in the pair.  The first edge is\n-   the init edge (from outside the loop) and the second one is the back edge\n-   from the same loop.  */\n-\n-std::pair<edge, edge>\n-get_edges (basic_block bb)\n-{\n-  std::pair<edge, edge> edges;\n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (bb->loop_father != e->src->loop_father)\n-      edges.first = e;\n-    else\n-      edges.second = e;\n-  return edges;\n-}\n-\n-/* Copy the PHI arguments from OLD_PHI to the NEW_PHI.  The arguments to NEW_PHI\n-   must be found unless they can be POSTPONEd for later.  */\n-\n-bool translate_isl_ast_to_gimple::\n-copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n-\t\t    gphi *new_phi, init_back_edge_pair_t &ibp_new_bb,\n-\t\t    bool postpone)\n-{\n-  gcc_assert (gimple_phi_num_args (old_phi) == gimple_phi_num_args (new_phi));\n-\n-  basic_block new_bb = gimple_bb (new_phi);\n-  for (unsigned i = 0; i < gimple_phi_num_args (old_phi); i++)\n-    {\n-      edge e;\n-      if (gimple_phi_arg_edge (old_phi, i) == ibp_old_bb.first)\n-\te = ibp_new_bb.first;\n-      else\n-\te = ibp_new_bb.second;\n-\n-      tree old_name = gimple_phi_arg_def (old_phi, i);\n-      tree new_name = get_new_name (new_bb, old_name,\n-\t\t\t\t    gimple_bb (old_phi), loop_phi);\n-      if (new_name)\n-\t{\n-\t  add_phi_arg (new_phi, new_name, e, get_loc (old_name));\n-\t  continue;\n-\t}\n-\n-      gimple *old_def_stmt = SSA_NAME_DEF_STMT (old_name);\n-      if (!old_def_stmt || gimple_code (old_def_stmt) == GIMPLE_NOP)\n-\t/* If the phi arg was a function arg, or wasn't defined, just use the\n-\t   old name.  */\n-\tadd_phi_arg (new_phi, old_name, e, get_loc (old_name));\n-      else if (postpone)\n-\t{\n-\t  /* Postpone code gen for later for those back-edges we don't have the\n-\t     names yet.  */\n-\t  region->incomplete_phis.safe_push (std::make_pair (old_phi, new_phi));\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"[codegen] postpone loop phi nodes.\\n\");\n-\t}\n-      else\n-\t/* Either we should add the arg to phi or, we should postpone.  */\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n-/* Copy loop phi nodes from BB to NEW_BB.  */\n-\n-bool translate_isl_ast_to_gimple::\n-copy_loop_phi_nodes (basic_block bb, basic_block new_bb)\n-{\n-  if (dump_file)\n-    fprintf (dump_file, \"[codegen] copying loop phi nodes in bb_%d.\\n\",\n-\t     new_bb->index);\n-\n-  /* Loop phi nodes should have only two arguments.  */\n-  gcc_assert (2 == EDGE_COUNT (bb->preds));\n-\n-  /* First edge is the init edge and second is the back edge.  */\n-  init_back_edge_pair_t ibp_old_bb = get_edges (bb);\n-\n-  /* First edge is the init edge and second is the back edge.  */\n-  init_back_edge_pair_t ibp_new_bb = get_edges (new_bb);\n-\n-  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n-       gsi_next (&psi))\n-    {\n-      gphi *phi = psi.phi ();\n-      tree res = gimple_phi_result (phi);\n-      if (virtual_operand_p (res))\n-\tcontinue;\n-      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n-\tcontinue;\n-\n-      gphi *new_phi = create_phi_node (NULL_TREE, new_bb);\n-      tree new_res = create_new_def_for (res, new_phi,\n-\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n-      set_rename (res, new_res);\n-      if (!copy_loop_phi_args (phi, ibp_old_bb, new_phi, ibp_new_bb, true))\n-\tset_codegen_error ();\n-      update_stmt (new_phi);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"[codegen] creating loop-phi node: \");\n-\t  print_gimple_stmt (dump_file, new_phi, 0);\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n-/* Return the init value of PHI, the value coming from outside the loop.  */\n-\n-static tree\n-get_loop_init_value (gphi *phi)\n-{\n-\n-  loop_p loop = gimple_bb (phi)->loop_father;\n-\n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, gimple_bb (phi)->preds)\n-    if (e->src->loop_father != loop)\n-      return gimple_phi_arg_def (phi, e->dest_idx);\n-\n-  return NULL_TREE;\n-}\n-\n-/* Find the init value (the value which comes from outside the loop), of one of\n-   the operands of DEF which is defined by a loop phi.  */\n-\n-static tree\n-find_init_value (gimple *def)\n-{\n-  if (gimple_code (def) == GIMPLE_PHI)\n-    return get_loop_init_value (as_a <gphi*> (def));\n-\n-  if (gimple_vuse (def))\n-    return NULL_TREE;\n-\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-  FOR_EACH_SSA_USE_OPERAND (use_p, def, iter, SSA_OP_USE)\n-    {\n-      tree use = USE_FROM_PTR (use_p);\n-      if (TREE_CODE (use) == SSA_NAME)\n-\t{\n-\t  if (tree res = find_init_value (SSA_NAME_DEF_STMT (use)))\n-\t    return res;\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Return the init value, the value coming from outside the loop.  */\n-\n-static tree\n-find_init_value_close_phi (gphi *phi)\n-{\n-  gcc_assert (gimple_phi_num_args (phi) == 1);\n-  tree use_arg = gimple_phi_arg_def (phi, 0);\n-  gimple *def = SSA_NAME_DEF_STMT (use_arg);\n-  return find_init_value (def);\n-}\n-\n-\n-tree translate_isl_ast_to_gimple::\n-add_close_phis_to_outer_loops (tree last_merge_name, edge last_e,\n-\t\t\t       gimple *old_close_phi)\n-{\n-  sese_l &codegen_region = region->if_region->true_region->region;\n-  gimple *stmt = SSA_NAME_DEF_STMT (last_merge_name);\n-  basic_block bb = gimple_bb (stmt);\n-  if (!bb_in_sese_p (bb, codegen_region))\n-    return last_merge_name;\n-\n-  loop_p loop = bb->loop_father;\n-  if (!loop_in_sese_p (loop, codegen_region))\n-    return last_merge_name;\n-\n-  edge e = single_exit (loop);\n-\n-  if (dominated_by_p (CDI_DOMINATORS, e->dest, last_e->src))\n-    return last_merge_name;\n-\n-  tree old_name = gimple_phi_arg_def (old_close_phi, 0);\n-  tree old_close_phi_name = gimple_phi_result (old_close_phi);\n-\n-  bb = e->dest;\n-  if (!bb_contains_loop_close_phi_nodes (bb) || !single_succ_p (bb))\n-    bb = split_edge (e);\n-\n-  gphi *close_phi = create_phi_node (NULL_TREE, bb);\n-  tree res = create_new_def_for (last_merge_name, close_phi,\n-\t\t\t\t gimple_phi_result_ptr (close_phi));\n-  set_rename (old_close_phi_name, res);\n-  add_phi_arg (close_phi, last_merge_name, e, get_loc (old_name));\n-  last_merge_name = res;\n-\n-  return add_close_phis_to_outer_loops (last_merge_name, last_e, old_close_phi);\n-}\n-\n-/* Add phi nodes to all merge points of all the diamonds enclosing the loop of\n-   the close phi node PHI.  */\n-\n-bool translate_isl_ast_to_gimple::\n-add_close_phis_to_merge_points (gphi *old_close_phi, gphi *new_close_phi,\n-\t\t\t\ttree default_value)\n-{\n-  sese_l &codegen_region = region->if_region->true_region->region;\n-  basic_block default_value_bb = get_entry_bb (codegen_region);\n-  if (SSA_NAME == TREE_CODE (default_value))\n-    {\n-      gimple *stmt = SSA_NAME_DEF_STMT (default_value);\n-      if (!stmt || gimple_code (stmt) == GIMPLE_NOP)\n-\treturn false;\n-      default_value_bb = gimple_bb (stmt);\n-    }\n-\n-  basic_block new_close_phi_bb = gimple_bb (new_close_phi);\n-\n-  tree old_close_phi_name = gimple_phi_result (old_close_phi);\n-  tree new_close_phi_name = gimple_phi_result (new_close_phi);\n-  tree last_merge_name = new_close_phi_name;\n-  tree old_name = gimple_phi_arg_def (old_close_phi, 0);\n-\n-  int i;\n-  edge merge_e;\n-  FOR_EACH_VEC_ELT_REVERSE (merge_points, i, merge_e)\n-    {\n-      basic_block new_merge_bb = merge_e->src;\n-      if (!dominated_by_p (CDI_DOMINATORS, new_merge_bb, default_value_bb))\n-\tcontinue;\n-\n-      last_merge_name = add_close_phis_to_outer_loops (last_merge_name, merge_e,\n-\t\t\t\t\t\t       old_close_phi);\n-\n-      gphi *merge_phi = create_phi_node (NULL_TREE, new_merge_bb);\n-      tree merge_res = create_new_def_for (old_close_phi_name, merge_phi,\n-\t\t\t\t\t   gimple_phi_result_ptr (merge_phi));\n-      set_rename (old_close_phi_name, merge_res);\n-\n-      edge from_loop = NULL, from_default_value = NULL;\n-      edge e;\n-      edge_iterator ei;\n-      FOR_EACH_EDGE (e, ei, new_merge_bb->preds)\n-\tif (dominated_by_p (CDI_DOMINATORS, e->src, new_close_phi_bb))\n-\t  from_loop = e;\n-\telse\n-\t  from_default_value = e;\n-\n-      /* Because CDI_POST_DOMINATORS are not updated, we only rely on\n-\t CDI_DOMINATORS, which may not handle all cases where new_close_phi_bb\n-\t is contained in another condition.  */\n-      if (!from_default_value || !from_loop)\n-\treturn false;\n-\n-      add_phi_arg (merge_phi, last_merge_name, from_loop, get_loc (old_name));\n-      add_phi_arg (merge_phi, default_value, from_default_value, get_loc (old_name));\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"[codegen] Adding guard-phi: \");\n-\t  print_gimple_stmt (dump_file, merge_phi, 0);\n-\t}\n-\n-      update_stmt (merge_phi);\n-      last_merge_name = merge_res;\n-    }\n-\n-  return true;\n-}\n-\n-/* Copy all the loop-close phi args from BB to NEW_BB.  */\n-\n-bool translate_isl_ast_to_gimple::\n-copy_loop_close_phi_args (basic_block old_bb, basic_block new_bb,\n-\t\t\t  vec<tree> iv_map, bool postpone)\n-{\n-  for (gphi_iterator psi = gsi_start_phis (old_bb); !gsi_end_p (psi);\n-       gsi_next (&psi))\n-    {\n-      gphi *old_close_phi = psi.phi ();\n-      tree res = gimple_phi_result (old_close_phi);\n-      if (virtual_operand_p (res))\n-\tcontinue;\n-\n-      gphi *new_close_phi = create_phi_node (NULL_TREE, new_bb);\n-      tree new_res = create_new_def_for (res, new_close_phi,\n-\t\t\t\t\t gimple_phi_result_ptr (new_close_phi));\n-      set_rename (res, new_res);\n-\n-      tree old_name = gimple_phi_arg_def (old_close_phi, 0);\n-      tree new_name;\n-      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n-\t{\n-\t  gimple_seq stmts;\n-\t  new_name = get_rename_from_scev (old_name, &stmts,\n-\t\t\t\t\t   old_bb->loop_father,\n-\t\t\t\t\t   new_bb, old_bb, iv_map);\n-\t  if (! codegen_error_p ())\n-\t    gsi_insert_earliest (stmts);\n-\t}\n-      else\n-\tnew_name = get_new_name (new_bb, old_name, old_bb, close_phi);\n-\n-      /* Predecessor basic blocks of a loop close phi should have been code\n-\t generated before.  FIXME: This is fixable by merging PHIs from inner\n-\t loops as well.  See: gfortran.dg/graphite/interchange-3.f90.  */\n-      if (!new_name || codegen_error_p ())\n-\treturn false;\n-\n-      add_phi_arg (new_close_phi, new_name, single_pred_edge (new_bb),\n-\t\t   get_loc (old_name));\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"[codegen] Adding loop close phi: \");\n-\t  print_gimple_stmt (dump_file, new_close_phi, 0);\n-\t}\n-\n-      update_stmt (new_close_phi);\n-\n-      /* When there is no loop guard around this codegenerated loop, there is no\n-\t need to collect the close-phi arg.  */\n-      if (merge_points.is_empty ())\n-\tcontinue;\n-\n-      /* Add a PHI in the succ_new_bb for each close phi of the loop.  */\n-      tree default_value = find_init_value_close_phi (new_close_phi);\n-\n-      /* A close phi must come from a loop-phi having a default value.  */\n-      if (!default_value)\n-\t{\n-\t  if (!postpone)\n-\t    return false;\n-\n-\t  region->incomplete_phis.safe_push (std::make_pair (old_close_phi,\n-\t\t\t\t\t\t\t     new_close_phi));\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"[codegen] postpone close phi nodes: \");\n-\t      print_gimple_stmt (dump_file, new_close_phi, 0);\n-\t    }\n-\t  continue;\n-\t}\n-\n-      if (!add_close_phis_to_merge_points (old_close_phi, new_close_phi,\n-\t\t\t\t\t   default_value))\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n-/* Copy loop close phi nodes from BB to NEW_BB.  */\n-\n-bool translate_isl_ast_to_gimple::\n-copy_loop_close_phi_nodes (basic_block old_bb, basic_block new_bb,\n-\t\t\t   vec<tree> iv_map)\n-{\n-  if (dump_file)\n-    fprintf (dump_file, \"[codegen] copying loop close phi nodes in bb_%d.\\n\",\n-\t     new_bb->index);\n-  /* Loop close phi nodes should have only one argument.  */\n-  gcc_assert (1 == EDGE_COUNT (old_bb->preds));\n-\n-  return copy_loop_close_phi_args (old_bb, new_bb, iv_map, true);\n-}\n-\n-\n-/* Add NEW_NAME as the ARGNUM-th arg of NEW_PHI which is in NEW_BB.\n-   DOMINATING_PRED is the predecessor basic block of OLD_BB which dominates the\n-   other pred of OLD_BB as well.  If no such basic block exists then it is NULL.\n-   NON_DOMINATING_PRED is a pred which does not dominate OLD_BB, it cannot be\n-   NULL.\n-\n-   Case1: OLD_BB->preds {BB1, BB2} and BB1 does not dominate BB2 and vice versa.\n-   In this case DOMINATING_PRED = NULL.\n-\n-   Case2: OLD_BB->preds {BB1, BB2} and BB1 dominates BB2.\n-\n-   Returns true on successful copy of the args, false otherwise.  */\n-\n-bool translate_isl_ast_to_gimple::\n-add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n-\t\t\t  edge old_bb_dominating_edge,\n-\t\t\t  edge old_bb_non_dominating_edge,\n-\t\t\t  gphi *phi, gphi *new_phi,\n-\t\t\t  basic_block new_bb)\n-{\n-  basic_block def_pred[2] = { NULL, NULL };\n-  int not_found_bb_index = -1;\n-  for (int i = 0; i < 2; i++)\n-    {\n-      /* If the corresponding def_bb could not be found the entry will be\n-\t NULL.  */\n-      if (TREE_CODE (old_phi_args[i]) == INTEGER_CST)\n-\tdef_pred[i] = get_def_bb_for_const (new_bb,\n-\t\t\t\t\t    gimple_phi_arg_edge (phi, i)->src);\n-      else if (new_phi_args[i] && (TREE_CODE (new_phi_args[i]) == SSA_NAME))\n-\tdef_pred[i] = gimple_bb (SSA_NAME_DEF_STMT (new_phi_args[i]));\n-\n-      if (!def_pred[i])\n-\t{\n-\t  /* When non are available bail out.  */\n-\t  if (not_found_bb_index != -1)\n-\t    return false;\n-\t  not_found_bb_index = i;\n-\t}\n-    }\n-\n-  /* Here we are pattern matching on the structure of CFG w.r.t. old one.  */\n-  if (old_bb_dominating_edge)\n-    {\n-      if (not_found_bb_index != -1)\n-\treturn false;\n-\n-      basic_block new_pred1 = (*new_bb->preds)[0]->src;\n-      basic_block new_pred2 = (*new_bb->preds)[1]->src;\n-      vec <basic_block> *bbs\n-\t= region->copied_bb_map->get (old_bb_non_dominating_edge->src);\n-\n-      /* Could not find a mapping.  */\n-      if (!bbs)\n-\treturn false;\n-\n-      basic_block new_pred = NULL;\n-      basic_block b;\n-      int i;\n-      FOR_EACH_VEC_ELT (*bbs, i, b)\n-\t{\n-\t  if (dominated_by_p (CDI_DOMINATORS, new_pred1, b))\n-\t    {\n-\t      /* FIXME: If we have already found new_pred then we have to\n-\t\t disambiguate, bail out for now.  */\n-\t      if (new_pred)\n-\t\treturn false;\n-\t      new_pred = new_pred1;\n-\t    }\n-\t  if (dominated_by_p (CDI_DOMINATORS, new_pred2, b))\n-\t    {\n-\t      /* FIXME: If we have already found new_pred then we have to either\n-\t\t it dominates both or we have to disambiguate, bail out.  */\n-\t      if (new_pred)\n-\t\treturn false;\n-\t      new_pred = new_pred2;\n-\t    }\n-\t}\n-\n-      if (!new_pred)\n-\treturn false;\n-\n-      edge new_non_dominating_edge = find_edge (new_pred, new_bb);\n-      gcc_assert (new_non_dominating_edge);\n-      /* FIXME: Validate each args just like in loop-phis.  */\n-      /* By the process of elimination we first insert insert phi-edge for\n-\t non-dominating pred which is computed above and then we insert the\n-\t remaining one.  */\n-      int inserted_edge = 0;\n-      for (; inserted_edge < 2; inserted_edge++)\n-\t{\n-\t  edge new_bb_pred_edge = gimple_phi_arg_edge (new_phi, inserted_edge);\n-\t  if (new_non_dominating_edge == new_bb_pred_edge)\n-\t    {\n-\t      add_phi_arg (new_phi, new_phi_args[inserted_edge],\n-\t\t\t   new_non_dominating_edge,\n-\t\t\t   get_loc (old_phi_args[inserted_edge]));\n-\t      break;\n-\t    }\n-\t}\n-      if (inserted_edge == 2)\n-\treturn false;\n-\n-      int edge_dominating = inserted_edge == 0 ? 1 : 0;\n-\n-      edge new_dominating_edge = NULL;\n-      for (inserted_edge = 0; inserted_edge < 2; inserted_edge++)\n-\t{\n-\t  edge e = gimple_phi_arg_edge (new_phi, inserted_edge);\n-\t  if (e != new_non_dominating_edge)\n-\t    {\n-\t      new_dominating_edge = e;\n-\t      add_phi_arg (new_phi, new_phi_args[edge_dominating],\n-\t\t\t   new_dominating_edge,\n-\t\t\t   get_loc (old_phi_args[inserted_edge]));\n-\t      break;\n-\t    }\n-\t}\n-      gcc_assert (new_dominating_edge);\n-    }\n-  else\n-    {\n-      /* Classic diamond structure: both edges are non-dominating.  We need to\n-\t find one unique edge then the other can be found be elimination.  If\n-\t any definition (def_pred) dominates both the preds of new_bb then we\n-\t bail out.  Entries of def_pred maybe NULL, in that case we must\n-\t uniquely find pred with help of only one entry.  */\n-      edge new_e[2] = { NULL, NULL };\n-      for (int i = 0; i < 2; i++)\n-\t{\n-\t  edge e;\n-\t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, new_bb->preds)\n-\t    if (def_pred[i]\n-\t\t&& dominated_by_p (CDI_DOMINATORS, e->src, def_pred[i]))\n-\t      {\n-\t\tif (new_e[i])\n-\t\t  /* We do not know how to handle the case when def_pred\n-\t\t     dominates more than a predecessor.  */\n-\t\t  return false;\n-\t\tnew_e[i] = e;\n-\t      }\n-\t}\n+gimple_stmt_iterator\n+later_of_the_two (gimple_stmt_iterator gsi1, gimple_stmt_iterator gsi2)\n+{\n+  basic_block bb1 = gsi_bb (gsi1);\n+  basic_block bb2 = gsi_bb (gsi2);\n \n-      gcc_assert (new_e[0] || new_e[1]);\n+  /* Find the iterator which is the latest.  */\n+  if (bb1 == bb2)\n+    {\n+      gimple *stmt1 = gsi_stmt (gsi1);\n+      gimple *stmt2 = gsi_stmt (gsi2);\n \n-      /* Find the other edge by process of elimination.  */\n-      if (not_found_bb_index != -1)\n+      if (stmt1 != NULL && stmt2 != NULL)\n \t{\n-\t  gcc_assert (!new_e[not_found_bb_index]);\n-\t  int found_bb_index = not_found_bb_index == 1 ? 0 : 1;\n-\t  edge e;\n-\t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, new_bb->preds)\n-\t    {\n-\t      if (new_e[found_bb_index] == e)\n-\t\tcontinue;\n-\t      new_e[not_found_bb_index] = e;\n-\t    }\n+\t  bool is_phi1 = gimple_code (stmt1) == GIMPLE_PHI;\n+\t  bool is_phi2 = gimple_code (stmt2) == GIMPLE_PHI;\n+\n+\t  if (is_phi1 != is_phi2)\n+\t    return is_phi1 ? gsi2 : gsi1;\n \t}\n \n-      /* Add edges to phi args.  */\n-      for (int i = 0; i < 2; i++)\n-\tadd_phi_arg (new_phi, new_phi_args[i], new_e[i],\n-\t\t     get_loc (old_phi_args[i]));\n+      /* For empty basic blocks gsis point to the end of the sequence.  Since\n+\t there is no operator== defined for gimple_stmt_iterator and for gsis\n+\t not pointing to a valid statement gsi_next would assert.  */\n+      gimple_stmt_iterator gsi = gsi1;\n+      do {\n+\tif (gsi_stmt (gsi) == gsi_stmt (gsi2))\n+\t  return gsi2;\n+\tgsi_next (&gsi);\n+      } while (!gsi_end_p (gsi));\n+\n+      return gsi1;\n     }\n \n-  return true;\n+  /* Find the basic block closest to the basic block which defines stmt.  */\n+  if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))\n+    return gsi1;\n+\n+  gcc_assert (dominated_by_p (CDI_DOMINATORS, bb2, bb1));\n+  return gsi2;\n }\n \n-/* Copy the arguments of cond-phi node PHI, to NEW_PHI in the codegenerated\n-   region.  If postpone is true and it isn't possible to copy any arg of PHI,\n-   the PHI is added to the REGION->INCOMPLETE_PHIS to be codegenerated later.\n-   Returns false if the copying was unsuccessful.  */\n+/* Insert each statement from SEQ at its earliest insertion p.  */\n \n-bool translate_isl_ast_to_gimple::\n-copy_cond_phi_args (gphi *phi, gphi *new_phi, vec<tree> iv_map, bool postpone)\n+void translate_isl_ast_to_gimple::\n+gsi_insert_earliest (gimple_seq seq)\n {\n-  if (dump_file)\n-    fprintf (dump_file, \"[codegen] copying cond phi args.\\n\");\n-  gcc_assert (2 == gimple_phi_num_args (phi));\n+  update_modified_stmts (seq);\n+  sese_l &codegen_region = region->if_region->true_region->region;\n+  basic_block begin_bb = get_entry_bb (codegen_region);\n+\n+  /* Inserting the gimple statements in a vector because gimple_seq behave\n+     in strage ways when inserting the stmts from it into different basic\n+     blocks one at a time.  */\n+  auto_vec<gimple *, 3> stmts;\n+  for (gimple_stmt_iterator gsi = gsi_start (seq); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    stmts.safe_push (gsi_stmt (gsi));\n \n-  basic_block new_bb = gimple_bb (new_phi);\n-  loop_p loop = gimple_bb (phi)->loop_father;\n+  int i;\n+  gimple *use_stmt;\n+  FOR_EACH_VEC_ELT (stmts, i, use_stmt)\n+    {\n+      gcc_assert (gimple_code (use_stmt) != GIMPLE_PHI);\n+      gimple_stmt_iterator gsi_def_stmt = gsi_start_bb_nondebug (begin_bb);\n \n-  basic_block old_bb = gimple_bb (phi);\n-  edge old_bb_non_dominating_edge = NULL, old_bb_dominating_edge = NULL;\n+      use_operand_p use_p;\n+      ssa_op_iter op_iter;\n+      FOR_EACH_SSA_USE_OPERAND (use_p, use_stmt, op_iter, SSA_OP_USE)\n+\t{\n+\t  /* Iterator to the current def of use_p.  For function parameters or\n+\t     anything where def is not found, insert at the beginning of the\n+\t     generated region.  */\n+\t  gimple_stmt_iterator gsi_stmt = gsi_def_stmt;\n \n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, old_bb->preds)\n-    if (!dominated_by_p (CDI_DOMINATORS, old_bb, e->src))\n-      old_bb_non_dominating_edge = e;\n-    else\n-      old_bb_dominating_edge = e;\n+\t  tree op = USE_FROM_PTR (use_p);\n+\t  gimple *stmt = SSA_NAME_DEF_STMT (op);\n+\t  if (stmt && (gimple_code (stmt) != GIMPLE_NOP))\n+\t    gsi_stmt = gsi_for_stmt (stmt);\n \n-  gcc_assert (!dominated_by_p (CDI_DOMINATORS, old_bb,\n-\t\t\t       old_bb_non_dominating_edge->src));\n+\t  /* For region parameters, insert at the beginning of the generated\n+\t     region.  */\n+\t  if (!bb_in_sese_p (gsi_bb (gsi_stmt), codegen_region))\n+\t    gsi_stmt = gsi_def_stmt;\n \n-  tree new_phi_args[2];\n-  tree old_phi_args[2];\n+\t  gsi_def_stmt = later_of_the_two (gsi_stmt, gsi_def_stmt);\n+\t}\n \n-  for (unsigned i = 0; i < gimple_phi_num_args (phi); i++)\n-    {\n-      tree old_name = gimple_phi_arg_def (phi, i);\n-      tree new_name = get_new_name (new_bb, old_name, old_bb, cond_phi);\n-      old_phi_args[i] = old_name;\n-      if (new_name)\n+      if (!gsi_stmt (gsi_def_stmt))\n \t{\n-\t  new_phi_args [i] = new_name;\n-\t  continue;\n+\t  gimple_stmt_iterator gsi = gsi_after_labels (gsi_bb (gsi_def_stmt));\n+\t  gsi_insert_before (&gsi, use_stmt, GSI_NEW_STMT);\n \t}\n-\n-      /* If the phi-arg was a parameter.  */\n-      if (vec_find (region->params, old_name) != -1)\n+      else if (gimple_code (gsi_stmt (gsi_def_stmt)) == GIMPLE_PHI)\n \t{\n-\t  new_phi_args [i] = old_name;\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file,\n-\t\t       \"[codegen] parameter argument to phi, new_expr: \");\n-\t      print_generic_expr (dump_file, new_phi_args[i]);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t  continue;\n+\t  gimple_stmt_iterator bsi\n+\t    = gsi_start_bb_nondebug (gsi_bb (gsi_def_stmt));\n+\t  /* Insert right after the PHI statements.  */\n+\t  gsi_insert_before (&bsi, use_stmt, GSI_NEW_STMT);\n \t}\n+      else\n+\tgsi_insert_after (&gsi_def_stmt, use_stmt, GSI_NEW_STMT);\n \n-      gimple *old_def_stmt = SSA_NAME_DEF_STMT (old_name);\n-      if (!old_def_stmt || gimple_code (old_def_stmt) == GIMPLE_NOP)\n-\t/* FIXME: If the phi arg was a function arg, or wasn't defined, just use\n-\t   the old name.  */\n-\treturn false;\n-\n-      if (postpone)\n+      if (dump_file)\n \t{\n-\t  /* If the phi-arg is scev-analyzeable but only in the first stage.  */\n-\t  if (is_gimple_reg (old_name)\n-\t      && scev_analyzable_p (old_name, region->region))\n-\t    {\n-\t      gimple_seq stmts;\n-\t      tree new_expr = get_rename_from_scev (old_name, &stmts, loop,\n-\t\t\t\t\t\t    new_bb, old_bb, iv_map);\n-\t      if (codegen_error_p ())\n-\t\treturn false;\n-\n-\t      gcc_assert (new_expr);\n-\t      if (dump_file)\n-\t\t{\n-\t\t  fprintf (dump_file,\n-\t\t\t   \"[codegen] scev analyzeable, new_expr: \");\n-\t\t  print_generic_expr (dump_file, new_expr);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t      gsi_insert_earliest (stmts);\n-\t      new_phi_args[i] = new_expr;\n-\t      continue;\n-\t    }\n-\n-\t  /* Postpone code gen for later for back-edges.  */\n-\t  region->incomplete_phis.safe_push (std::make_pair (phi, new_phi));\n-\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"[codegen] postpone cond phi nodes: \");\n-\t      print_gimple_stmt (dump_file, new_phi, 0);\n-\t    }\n-\n-\t  new_phi_args [i] = NULL_TREE;\n-\t  continue;\n+\t  fprintf (dump_file, \"[codegen] inserting statement: \");\n+\t  print_gimple_stmt (dump_file, use_stmt, 0, TDF_VOPS | TDF_MEMSYMS);\n+\t  print_loops_bb (dump_file, gimple_bb (use_stmt), 0, 3);\n \t}\n-      else\n-\t/* Either we should add the arg to phi or, we should postpone.  */\n-\treturn false;\n     }\n-\n-  /* If none of the args have been determined in the first stage then wait until\n-     later.  */\n-  if (postpone && !new_phi_args[0] && !new_phi_args[1])\n-    return true;\n-\n-  return add_phi_arg_for_new_expr (old_phi_args, new_phi_args,\n-\t\t\t\t   old_bb_dominating_edge,\n-\t\t\t\t   old_bb_non_dominating_edge,\n-\t\t\t\t   phi, new_phi, new_bb);\n }\n \n-/* Copy cond phi nodes from BB to NEW_BB.  A cond-phi node is a basic block\n-   containing phi nodes coming from two predecessors, and none of them are back\n-   edges.  */\n+/* For ops which are scev_analyzeable, we can regenerate a new name from its\n+   scalar evolution around LOOP.  */\n \n-bool translate_isl_ast_to_gimple::\n-copy_cond_phi_nodes (basic_block bb, basic_block new_bb, vec<tree> iv_map)\n+tree translate_isl_ast_to_gimple::\n+get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n+\t\t      basic_block new_bb, basic_block,\n+\t\t      vec<tree> iv_map)\n {\n+  tree scev = scalar_evolution_in_region (region->region, loop, old_name);\n \n-  gcc_assert (!bb_contains_loop_close_phi_nodes (bb));\n-\n-  /* TODO: Handle cond phi nodes with more than 2 predecessors.  */\n-  if (EDGE_COUNT (bb->preds) != 2)\n-    return false;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"[codegen] copying cond phi nodes in bb_%d.\\n\",\n-\t     new_bb->index);\n-\n-  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n-       gsi_next (&psi))\n+  /* At this point we should know the exact scev for each\n+     scalar SSA_NAME used in the scop: all the other scalar\n+     SSA_NAMEs should have been translated out of SSA using\n+     arrays with one element.  */\n+  tree new_expr;\n+  if (chrec_contains_undetermined (scev))\n     {\n-      gphi *phi = psi.phi ();\n-      tree res = gimple_phi_result (phi);\n-      if (virtual_operand_p (res))\n-\tcontinue;\n+      set_codegen_error ();\n+      return build_zero_cst (TREE_TYPE (old_name));\n+    }\n \n-      gphi *new_phi = create_phi_node (NULL_TREE, new_bb);\n-      tree new_res = create_new_def_for (res, new_phi,\n-\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n-      set_rename (res, new_res);\n+  new_expr = chrec_apply_map (scev, iv_map);\n \n-      if (!copy_cond_phi_args (phi, new_phi, iv_map, true))\n-\treturn false;\n+  /* The apply should produce an expression tree containing\n+     the uses of the new induction variables.  We should be\n+     able to use new_expr instead of the old_name in the newly\n+     generated loop nest.  */\n+  if (chrec_contains_undetermined (new_expr)\n+      || tree_contains_chrecs (new_expr, NULL))\n+    {\n+      set_codegen_error ();\n+      return build_zero_cst (TREE_TYPE (old_name));\n+    }\n \n-      update_stmt (new_phi);\n+  if (TREE_CODE (new_expr) == SSA_NAME)\n+    {\n+      basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (new_expr));\n+      if (bb && !dominated_by_p (CDI_DOMINATORS, new_bb, bb))\n+\t{\n+\t  set_codegen_error ();\n+\t  return build_zero_cst (TREE_TYPE (old_name));\n+\t}\n     }\n \n-  return true;\n+  /* Replace the old_name with the new_expr.  */\n+  return force_gimple_operand (unshare_expr (new_expr), stmts,\n+\t\t\t       true, NULL_TREE);\n }\n \n+\n /* Return true if STMT should be copied from region to the new code-generated\n    region.  LABELs, CONDITIONS, induction-variables and region parameters need\n    not be copied.  */\n@@ -2473,8 +1170,7 @@ set_rename_for_each_def (gimple *stmt)\n   FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, op_iter, SSA_OP_ALL_DEFS)\n     {\n       tree old_name = DEF_FROM_PTR (def_p);\n-      tree new_name = create_new_def_for (old_name, stmt, def_p);\n-      set_rename (old_name, new_name);\n+      create_new_def_for (old_name, stmt, def_p);\n     }\n }\n \n@@ -2500,6 +1196,19 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n       gimple *copy = gimple_copy (stmt);\n       gsi_insert_after (&gsi_tgt, copy, GSI_NEW_STMT);\n \n+      /* Rather than not copying debug stmts we reset them.\n+         ???  Where we can rewrite uses without inserting new\n+\t stmts we could simply do that.  */\n+      if (is_gimple_debug (copy))\n+\t{\n+\t  if (gimple_debug_bind_p (copy))\n+\t    gimple_debug_bind_reset_value (copy);\n+\t  else if (gimple_debug_source_bind_p (copy))\n+\t    ;\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"[codegen] inserting statement: \");\n@@ -2512,13 +1221,6 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n       /* Crete new names for each def in the copied stmt.  */\n       set_rename_for_each_def (copy);\n \n-      loop_p loop = bb->loop_father;\n-      if (rename_uses (copy, &gsi_tgt, bb, loop, iv_map))\n-\t{\n-\t  fold_stmt_inplace (&gsi_tgt);\n-\t  gcc_assert (gsi_stmt (gsi_tgt) == copy);\n-\t}\n-\n       if (codegen_error_p ())\n \treturn false;\n \n@@ -2535,6 +1237,19 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n \t      continue;\n \n \t    tree *new_expr = region->parameter_rename_map->get (old_name);\n+\t    tree new_name;\n+\t    if (!new_expr\n+\t\t&& scev_analyzable_p (old_name, region->region))\n+\t      {\n+\t\tgimple_seq stmts = NULL;\n+\t\tnew_name = get_rename_from_scev (old_name, &stmts,\n+\t\t\t\t\t\t bb->loop_father,\n+\t\t\t\t\t\t new_bb, bb, iv_map);\n+\t\tif (! codegen_error_p ())\n+\t\t  gsi_insert_earliest (stmts);\n+\t\tnew_expr = &new_name;\n+\t      }\n+\n \t    if (!new_expr)\n \t      continue;\n \n@@ -2548,161 +1263,42 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n }\n \n \n-/* Given a basic block containing close-phi it returns the new basic block where\n-   to insert a copy of the close-phi nodes.  All the uses in close phis should\n-   come from a single loop otherwise it returns NULL.  */\n-\n-edge translate_isl_ast_to_gimple::\n-edge_for_new_close_phis (basic_block bb)\n-{\n-  /* Make sure that NEW_BB is the new_loop->exit->dest.  We find the definition\n-     of close phi in the original code and then find the mapping of basic block\n-     defining that variable.  If there are multiple close-phis and they are\n-     defined in different loops (in the original or in the new code) because of\n-     loop splitting, then we bail out.  */\n-  loop_p new_loop = NULL;\n-  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n-       gsi_next (&psi))\n-    {\n-      gphi *phi = psi.phi ();\n-      tree name = gimple_phi_arg_def (phi, 0);\n-      basic_block old_loop_bb = gimple_bb (SSA_NAME_DEF_STMT (name));\n-\n-      vec <basic_block> *bbs = region->copied_bb_map->get (old_loop_bb);\n-      if (!bbs || bbs->length () != 1)\n-\t/* This is one of the places which shows preserving original structure\n-\t   is not always possible, as we may need to insert close PHI for a loop\n-\t   where the latch does not have any mapping, or the mapping is\n-\t   ambiguous.  */\n-\treturn NULL;\n-\n-      if (!new_loop)\n-\tnew_loop = (*bbs)[0]->loop_father;\n-      else if (new_loop != (*bbs)[0]->loop_father)\n-\treturn NULL;\n-    }\n-\n-  if (!new_loop)\n-    return NULL;\n-\n-  return single_exit (new_loop);\n-}\n-\n /* Copies BB and includes in the copied BB all the statements that can\n    be reached following the use-def chains from the memory accesses,\n    and returns the next edge following this new block.  */\n \n edge translate_isl_ast_to_gimple::\n copy_bb_and_scalar_dependences (basic_block bb, edge next_e, vec<tree> iv_map)\n {\n-  int num_phis = number_of_phi_nodes (bb);\n-  basic_block new_bb = NULL;\n-  if (bb_contains_loop_close_phi_nodes (bb))\n+  basic_block new_bb = split_edge (next_e);\n+  gimple_stmt_iterator gsi_tgt = gsi_last_bb (new_bb);\n+  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n     {\n-      if (dump_file)\n-\tfprintf (dump_file, \"[codegen] bb_%d contains close phi nodes.\\n\",\n-\t\t bb->index);\n-\n-      edge e = edge_for_new_close_phis (bb);\n-      if (!e)\n-\t{\n-\t  set_codegen_error ();\n-\t  return NULL;\n-\t}\n-\n-      basic_block phi_bb = e->dest;\n-\n-      if (!bb_contains_loop_close_phi_nodes (phi_bb) || !single_succ_p (phi_bb))\n-\tphi_bb = split_edge (e);\n-\n-      gcc_assert (single_pred_edge (phi_bb)->src->loop_father\n-\t\t  != single_pred_edge (phi_bb)->dest->loop_father);\n+      gphi *phi = psi.phi ();\n+      tree res = gimple_phi_result (phi);\n+      if (virtual_operand_p (res)\n+\t  || scev_analyzable_p (res, region->region))\n+\tcontinue;\n \n-      if (!copy_loop_close_phi_nodes (bb, phi_bb, iv_map))\n+      tree new_phi_def;\n+      vec <tree> *renames = region->rename_map->get (res);\n+      if (! renames || renames->is_empty ())\n \t{\n-\t  set_codegen_error ();\n-\t  return NULL;\n+\t  new_phi_def = create_tmp_reg (TREE_TYPE (res));\n+\t  set_rename (res, new_phi_def);\n \t}\n-\n-      if (e == next_e)\n-\tnew_bb = phi_bb;\n       else\n-\tnew_bb = split_edge (next_e);\n-    }\n-  else\n-    {\n-      new_bb = split_edge (next_e);\n-      if (num_phis > 0 && bb_contains_loop_phi_nodes (bb))\n \t{\n-\t  basic_block phi_bb = next_e->dest->loop_father->header;\n-\n-\t  /* At this point we are unable to codegenerate by still preserving the SSA\n-\t     structure because maybe the loop is completely unrolled and the PHIs\n-\t     and cross-bb scalar dependencies are untrackable w.r.t. the original\n-\t     code.  See gfortran.dg/graphite/pr29832.f90.  */\n-\t  if (EDGE_COUNT (bb->preds) != EDGE_COUNT (phi_bb->preds))\n-\t    {\n-\t      set_codegen_error ();\n-\t      return NULL;\n-\t    }\n-\n-\t  /* In case isl did some loop peeling, like this:\n-\n-\t       S_8(0);\n-\t       for (int c1 = 1; c1 <= 5; c1 += 1) {\n-\t         S_8(c1);\n-\t       }\n-\t       S_8(6);\n-\n-\t     there should be no loop-phi nodes in S_8(0).\n-\n-\t     FIXME: We need to reason about dynamic instances of S_8, i.e., the\n-\t     values of all scalar variables: for the moment we instantiate only\n-\t     SCEV analyzable expressions on the iteration domain, and we need to\n-\t     extend that to reductions that cannot be analyzed by SCEV.  */\n-\t  if (!bb_in_sese_p (phi_bb, region->if_region->true_region->region))\n-\t    {\n-\t      set_codegen_error ();\n-\t      return NULL;\n-\t    }\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"[codegen] bb_%d contains loop phi nodes.\\n\",\n-\t\t     bb->index);\n-\t  if (!copy_loop_phi_nodes (bb, phi_bb))\n-\t    {\n-\t      set_codegen_error ();\n-\t      return NULL;\n-\t    }\n+\t  gcc_assert (renames->length () == 1);\n+\t  new_phi_def = (*renames)[0];\n \t}\n-      else if (num_phis > 0)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"[codegen] bb_%d contains cond phi nodes.\\n\",\n-\t\t     bb->index);\n-\n-\t  basic_block phi_bb = single_pred (new_bb);\n-\t  loop_p loop_father = new_bb->loop_father;\n \n-\t  /* Move back until we find the block with two predecessors.  */\n-\t  while (single_pred_p (phi_bb))\n-\t    phi_bb = single_pred_edge (phi_bb)->src;\n-\n-\t  /* If a corresponding merge-point was not found, then abort codegen.  */\n-\t  if (phi_bb->loop_father != loop_father\n-\t      || !bb_in_sese_p (phi_bb, region->if_region->true_region->region)\n-\t      || !copy_cond_phi_nodes (bb, phi_bb, iv_map))\n-\t    {\n-\t      set_codegen_error ();\n-\t      return NULL;\n-\t    }\n-\t}\n+      gassign *ass = gimple_build_assign (NULL_TREE, new_phi_def);\n+      create_new_def_for (res, ass, NULL);\n+      gsi_insert_after (&gsi_tgt, ass, GSI_NEW_STMT);\n     }\n \n-  if (dump_file)\n-    fprintf (dump_file, \"[codegen] copying from bb_%d to bb_%d.\\n\",\n-\t     bb->index, new_bb->index);\n-\n   vec <basic_block> *copied_bbs = region->copied_bb_map->get (bb);\n   if (copied_bbs)\n     copied_bbs->safe_push (new_bb);\n@@ -2720,57 +1316,66 @@ copy_bb_and_scalar_dependences (basic_block bb, edge next_e, vec<tree> iv_map)\n       return NULL;\n     }\n \n-  return single_succ_edge (new_bb);\n-}\n-\n-/* Patch the missing arguments of the phi nodes.  */\n-\n-void translate_isl_ast_to_gimple::\n-translate_pending_phi_nodes ()\n-{\n-  int i;\n-  phi_rename *rename;\n-  FOR_EACH_VEC_ELT (region->incomplete_phis, i, rename)\n+  /* Insert out-of SSA copies on the original BB outgoing edges.  */\n+  gsi_tgt = gsi_last_bb (new_bb);\n+  basic_block bb_for_succs = bb;\n+  if (bb_for_succs == bb_for_succs->loop_father->latch\n+      && bb_in_sese_p (bb_for_succs, region->region)\n+      && sese_trivially_empty_bb_p (bb_for_succs))\n+    bb_for_succs = NULL;\n+  while (bb_for_succs)\n     {\n-      gphi *old_phi = rename->first;\n-      gphi *new_phi = rename->second;\n-      basic_block old_bb = gimple_bb (old_phi);\n-      basic_block new_bb = gimple_bb (new_phi);\n-\n-      /* First edge is the init edge and second is the back edge.  */\n-      init_back_edge_pair_t ibp_old_bb = get_edges (old_bb);\n-      init_back_edge_pair_t ibp_new_bb = get_edges (new_bb);\n-\n-      if (dump_file)\n+      basic_block latch = NULL;\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, bb_for_succs->succs)\n \t{\n-\t  fprintf (dump_file, \"[codegen] translating pending old-phi: \");\n-\t  print_gimple_stmt (dump_file, old_phi, 0);\n-\t}\n+\t  for (gphi_iterator psi = gsi_start_phis (e->dest); !gsi_end_p (psi);\n+\t       gsi_next (&psi))\n+\t    {\n+\t      gphi *phi = psi.phi ();\n+\t      tree res = gimple_phi_result (phi);\n+\t      if (virtual_operand_p (res)\n+\t\t  || scev_analyzable_p (res, region->region))\n+\t\tcontinue;\n \n-      auto_vec <tree, 1> iv_map;\n-      if (bb_contains_loop_phi_nodes (new_bb)\n-\t  && bb_contains_loop_phi_nodes (old_bb))\n-\t{\n-\t  if (!copy_loop_phi_args (old_phi, ibp_old_bb, new_phi,\n-\t\t\t\t   ibp_new_bb, false))\n-\t    set_codegen_error ();\n-\t}\n-      else if (bb_contains_loop_close_phi_nodes (new_bb))\n-\t{\n-\t  if (!copy_loop_close_phi_args (old_bb, new_bb, iv_map, false))\n-\t    set_codegen_error ();\n-\t}\n-      else if (!copy_cond_phi_args (old_phi, new_phi, iv_map, false))\n-\tset_codegen_error ();\n+\t      tree new_phi_def;\n+\t      vec <tree> *renames = region->rename_map->get (res);\n+\t      if (! renames || renames->is_empty ())\n+\t\t{\n+\t\t  new_phi_def = create_tmp_reg (TREE_TYPE (res));\n+\t\t  set_rename (res, new_phi_def);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (renames->length () == 1);\n+\t\t  new_phi_def = (*renames)[0];\n+\t\t}\n \n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"[codegen] to new-phi: \");\n-\t  print_gimple_stmt (dump_file, new_phi, 0);\n+\t      tree arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+\t      if (TREE_CODE (arg) == SSA_NAME\n+\t\t  && scev_analyzable_p (arg, region->region))\n+\t\t{\n+\t\t  gimple_seq stmts = NULL;\n+\t\t  tree new_name = get_rename_from_scev (arg, &stmts,\n+\t\t\t\t\t\t\tbb->loop_father,\n+\t\t\t\t\t\t\tnew_bb, bb, iv_map);\n+\t\t  if (! codegen_error_p ())\n+\t\t    gsi_insert_earliest (stmts);\n+\t\t  arg = new_name;\n+\t\t}\n+\t      gassign *ass = gimple_build_assign (new_phi_def, arg);\n+\t      gsi_insert_after (&gsi_tgt, ass, GSI_NEW_STMT);\n+\t    }\n+\t  if (e->dest == bb_for_succs->loop_father->latch\n+\t      && bb_in_sese_p (e->dest, region->region)\n+\t      && sese_trivially_empty_bb_p (e->dest))\n+\t    latch = e->dest;\n \t}\n-      if (codegen_error_p ())\n-\treturn;\n+      bb_for_succs = latch;\n     }\n+\n+  return single_succ_edge (new_bb);\n }\n \n /* Add isl's parameter identifiers and corresponding trees to ivs_params.  */\n@@ -2952,8 +1557,6 @@ graphite_regenerate_ast_isl (scop_p scop)\n   region->if_region->true_region->region.exit = single_succ_edge (bb);\n \n   t.translate_isl_ast (context_loop, root_node, e, ip);\n-  if (! t.codegen_error_p ())\n-    t.translate_pending_phi_nodes ();\n   if (! t.codegen_error_p ())\n     {\n       sese_insert_phis_for_liveouts (region,\n@@ -2965,6 +1568,8 @@ graphite_regenerate_ast_isl (scop_p scop)\n \n       mark_virtual_operands_for_renaming (cfun);\n       update_ssa (TODO_update_ssa);\n+      checking_verify_ssa (true, true);\n+      rewrite_into_loop_closed_ssa (NULL, 0);\n     }\n \n   if (t.codegen_error_p ())"}, {"sha": "93ab0354efb9858e172397967b3475949cac543e", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 111, "deletions": 70, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -254,21 +254,6 @@ dot_cfg ()\n   scops.release ();\n }\n \n-/* Return true if BB is empty, contains only DEBUG_INSNs.  */\n-\n-static bool\n-trivially_empty_bb_p (basic_block bb)\n-{\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (gimple_code (gsi_stmt (gsi)) != GIMPLE_DEBUG\n-\t&& gimple_code (gsi_stmt (gsi)) != GIMPLE_LABEL)\n-      return false;\n-\n-  return true;\n-}\n-\n /* Can all ivs be represented by a signed integer?\n    As isl might generate negative values in its expressions, signed loop ivs\n    are required in the backend.  */\n@@ -471,7 +456,7 @@ scop_detection::get_sese (loop_p loop)\n      canonicalize_loop_closed_ssa makes sure that is in proper shape.  */\n   if (! single_pred_p (scop_end->dest)\n       || ! single_succ_p (scop_end->dest)\n-      || ! trivially_empty_bb_p (scop_end->dest))\n+      || ! sese_trivially_empty_bb_p (scop_end->dest))\n     gcc_unreachable ();\n   scop_end = single_succ_edge (scop_end->dest);\n \n@@ -1346,13 +1331,35 @@ find_scop_parameters (scop_p scop)\n   scop_set_nb_params (scop, nbp);\n }\n \n+static void\n+add_write (vec<tree> *writes, tree def)\n+{\n+  writes->safe_push (def);\n+  DEBUG_PRINT (dp << \"Adding scalar write: \";\n+\t       print_generic_expr (dump_file, def);\n+\t       dp << \"\\nFrom stmt: \";\n+\t       print_gimple_stmt (dump_file,\n+\t\t\t\t  SSA_NAME_DEF_STMT (def), 0));\n+}\n+\n+static void\n+add_read (vec<scalar_use> *reads, tree use, gimple *use_stmt)\n+{\n+  DEBUG_PRINT (dp << \"Adding scalar read: \";\n+\t       print_generic_expr (dump_file, use);\n+\t       dp << \"\\nFrom stmt: \";\n+\t       print_gimple_stmt (dump_file, use_stmt, 0));\n+  reads->safe_push (std::make_pair (use_stmt, use));\n+}\n+\n+\n /* Record DEF if it is used in other bbs different than DEF_BB in the SCOP.  */\n \n static void\n build_cross_bb_scalars_def (scop_p scop, tree def, basic_block def_bb,\n \t\t\t     vec<tree> *writes)\n {\n-  if (!def || !is_gimple_reg (def))\n+  if (!is_gimple_reg (def))\n     return;\n \n   bool scev_analyzable = scev_analyzable_p (def, scop->scop_info->region);\n@@ -1366,16 +1373,9 @@ build_cross_bb_scalars_def (scop_p scop, tree def, basic_block def_bb,\n \t /* But gather SESE liveouts as we otherwise fail to rewrite their\n \t    exit PHIs.  */\n \t || ! bb_in_sese_p (gimple_bb (use_stmt), scop->scop_info->region))\n-\t&& ((def_bb != gimple_bb (use_stmt) && !is_gimple_debug (use_stmt))\n-\t    /* PHIs have their effect at \"BBs\" on the edges.  See PR79622.  */\n-\t    || gimple_code (SSA_NAME_DEF_STMT (def)) == GIMPLE_PHI))\n+\t&& (def_bb != gimple_bb (use_stmt) && !is_gimple_debug (use_stmt)))\n       {\n-\twrites->safe_push (def);\n-\tDEBUG_PRINT (dp << \"Adding scalar write: \";\n-\t\t     print_generic_expr (dump_file, def);\n-\t\t     dp << \"\\nFrom stmt: \";\n-\t\t     print_gimple_stmt (dump_file,\n-\t\t\t\t\tSSA_NAME_DEF_STMT (def), 0));\n+\tadd_write (writes, def);\n \t/* This is required by the FOR_EACH_IMM_USE_STMT when we want to break\n \t   before all the uses have been visited.  */\n \tBREAK_FROM_IMM_USE_STMT (imm_iter);\n@@ -1389,7 +1389,6 @@ static void\n build_cross_bb_scalars_use (scop_p scop, tree use, gimple *use_stmt,\n \t\t\t    vec<scalar_use> *reads)\n {\n-  gcc_assert (use);\n   if (!is_gimple_reg (use))\n     return;\n \n@@ -1399,46 +1398,8 @@ build_cross_bb_scalars_use (scop_p scop, tree use, gimple *use_stmt,\n     return;\n \n   gimple *def_stmt = SSA_NAME_DEF_STMT (use);\n-  if (gimple_bb (def_stmt) != gimple_bb (use_stmt)\n-      /* PHIs have their effect at \"BBs\" on the edges.  See PR79622.  */\n-      || gimple_code (def_stmt) == GIMPLE_PHI)\n-    {\n-      DEBUG_PRINT (dp << \"Adding scalar read: \";\n-\t\t   print_generic_expr (dump_file, use);\n-\t\t   dp << \"\\nFrom stmt: \";\n-\t\t   print_gimple_stmt (dump_file, use_stmt, 0));\n-      reads->safe_push (std::make_pair (use_stmt, use));\n-    }\n-}\n-\n-/* Record all scalar variables that are defined and used in different BBs of the\n-   SCOP.  */\n-\n-static void\n-graphite_find_cross_bb_scalar_vars (scop_p scop, gimple *stmt,\n-\t\t\t\t    vec<scalar_use> *reads, vec<tree> *writes)\n-{\n-  tree def;\n-\n-  if (gimple_code (stmt) == GIMPLE_ASSIGN)\n-    def = gimple_assign_lhs (stmt);\n-  else if (gimple_code (stmt) == GIMPLE_CALL)\n-    def = gimple_call_lhs (stmt);\n-  else if (gimple_code (stmt) == GIMPLE_PHI)\n-    def = gimple_phi_result (stmt);\n-  else\n-    return;\n-\n-\n-  build_cross_bb_scalars_def (scop, def, gimple_bb (stmt), writes);\n-\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-  FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n-    {\n-      tree use = USE_FROM_PTR (use_p);\n-      build_cross_bb_scalars_use (scop, use, stmt, reads);\n-    }\n+  if (gimple_bb (def_stmt) != gimple_bb (use_stmt))\n+    add_read (reads, use, use_stmt);\n }\n \n /* Generates a polyhedral black box only if the bb contains interesting\n@@ -1467,13 +1428,89 @@ try_generate_gimple_bb (scop_p scop, basic_block bb)\n \tcontinue;\n \n       graphite_find_data_references_in_stmt (nest, loop, stmt, &drs);\n-      graphite_find_cross_bb_scalar_vars (scop, stmt, &reads, &writes);\n+\n+      tree def = gimple_get_lhs (stmt);\n+      if (def)\n+\tbuild_cross_bb_scalars_def (scop, def, gimple_bb (stmt), &writes);\n+\n+      ssa_op_iter iter;\n+      tree use;\n+      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+\tbuild_cross_bb_scalars_use (scop, use, stmt, &reads);\n     }\n \n+  /* Handle defs and uses in PHIs.  Those need special treatment given\n+     that we have to present ISL with sth that looks like we've rewritten\n+     the IL out-of-SSA.  */\n   for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n        gsi_next (&psi))\n-    if (!virtual_operand_p (gimple_phi_result (psi.phi ())))\n-      graphite_find_cross_bb_scalar_vars (scop, psi.phi (), &reads, &writes);\n+    {\n+      gphi *phi = psi.phi ();\n+      tree res = gimple_phi_result (phi);\n+      if (virtual_operand_p (res)\n+\t  || scev_analyzable_p (res, scop->scop_info->region))\n+\tcontinue;\n+      /* To simulate out-of-SSA the block containing the PHI node has\n+         reads of the PHI destination.  And to preserve SSA dependences\n+\t we also write to it (the out-of-SSA decl and the SSA result\n+\t are coalesced for dependence purposes which is good enough).  */\n+      add_read (&reads, res, phi);\n+      add_write (&writes, res);\n+    }\n+  basic_block bb_for_succs = bb;\n+  if (bb_for_succs == bb_for_succs->loop_father->latch\n+      && bb_in_sese_p (bb_for_succs, scop->scop_info->region)\n+      && sese_trivially_empty_bb_p (bb_for_succs))\n+    bb_for_succs = NULL;\n+  while (bb_for_succs)\n+    {\n+      basic_block latch = NULL;\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, bb_for_succs->succs)\n+\t{\n+\t  for (gphi_iterator psi = gsi_start_phis (e->dest); !gsi_end_p (psi);\n+\t       gsi_next (&psi))\n+\t    {\n+\t      gphi *phi = psi.phi ();\n+\t      tree res = gimple_phi_result (phi);\n+\t      if (virtual_operand_p (res))\n+\t\tcontinue;\n+\t      /* To simulate out-of-SSA the predecessor of edges into PHI nodes\n+\t\t has a copy from the PHI argument to the PHI destination.  */\n+\t      if (! scev_analyzable_p (res, scop->scop_info->region))\n+\t\tadd_write (&writes, res);\n+\t      tree use = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+\t      if (TREE_CODE (use) == SSA_NAME\n+\t\t  && ! SSA_NAME_IS_DEFAULT_DEF (use)\n+\t\t  && gimple_bb (SSA_NAME_DEF_STMT (use)) != bb_for_succs\n+\t\t  && ! scev_analyzable_p (use, scop->scop_info->region))\n+\t\tadd_read (&reads, use, phi);\n+\t    }\n+\t  if (e->dest == bb_for_succs->loop_father->latch\n+\t      && bb_in_sese_p (e->dest, scop->scop_info->region)\n+\t      && sese_trivially_empty_bb_p (e->dest))\n+\t    latch = e->dest;\n+\t}\n+      /* Handle empty latch block PHIs here, otherwise we confuse ISL\n+\t with extra conditional code where it then peels off the last\n+\t iteration just because of that.  It would be simplest if we\n+\t just didn't force simple latches (thus remove the forwarder).  */\n+      bb_for_succs = latch;\n+    }\n+\n+  /* For the region exit block add reads for all live-out vars.  */\n+  if (bb == scop->scop_info->region.exit->src)\n+    {\n+      sese_build_liveouts (scop->scop_info);\n+      unsigned i;\n+      bitmap_iterator bi;\n+      EXECUTE_IF_SET_IN_BITMAP (scop->scop_info->liveout, 0, i, bi)\n+\t{\n+\t  tree use = ssa_name (i);\n+\t  add_read (&reads, use, NULL);\n+\t}\n+    }\n \n   if (drs.is_empty () && writes.is_empty () && reads.is_empty ())\n     return NULL;\n@@ -1700,6 +1737,10 @@ build_scops (vec<scop_p> *scops)\n   sese_l *s;\n   FOR_EACH_VEC_ELT (scops_l, i, s)\n     {\n+      /* For our out-of-SSA we need a block on s->entry, similar to how\n+         we include the LCSSA block in the region.  */\n+      s->entry = single_pred_edge (split_edge (s->entry));\n+\n       scop_p scop = new_scop (s->entry, s->exit);\n \n       /* Record all basic blocks and their conditions in REGION.  */"}, {"sha": "b3bf6114fc78b8b3cb0f7f7891f89e32f3344e00", "filename": "gcc/sese.c", "status": "modified", "additions": 69, "deletions": 74, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -68,106 +68,80 @@ sese_build_liveouts_use (sese_info_p region, bitmap liveouts, basic_block bb,\n    used in BB that is outside of the REGION.  */\n \n static void\n-sese_build_liveouts_bb (sese_info_p region, bitmap liveouts, basic_block bb)\n+sese_build_liveouts_bb (sese_info_p region, basic_block bb)\n {\n-  edge e;\n-  edge_iterator ei;\n   ssa_op_iter iter;\n   use_operand_p use_p;\n \n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    for (gphi_iterator bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi);\n-\t gsi_next (&bsi))\n-      sese_build_liveouts_use (region, liveouts, bb,\n-\t\t\t       PHI_ARG_DEF_FROM_EDGE (bsi.phi (), e));\n+  for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);\n+       gsi_next (&bsi))\n+    FOR_EACH_PHI_ARG (use_p, bsi.phi (), iter, SSA_OP_USE)\n+      sese_build_liveouts_use (region, region->liveout,\n+\t\t\t       bb, USE_FROM_PTR (use_p));\n \n   for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n        gsi_next (&bsi))\n     {\n       gimple *stmt = gsi_stmt (bsi);\n \n+      bitmap liveouts = region->liveout;\n       if (is_gimple_debug (stmt))\n-\tcontinue;\n+\tliveouts = region->debug_liveout;\n \n-      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n \tsese_build_liveouts_use (region, liveouts, bb, USE_FROM_PTR (use_p));\n     }\n }\n \n-/* For a USE in BB, return true if BB is outside REGION and it's not\n-   in the LIVEOUTS set.  */\n-\n-static bool\n-sese_bad_liveouts_use (sese_info_p region, bitmap liveouts, basic_block bb,\n-\t\t       tree use)\n-{\n-  gcc_assert (!bb_in_sese_p (bb, region->region));\n-\n-  if (TREE_CODE (use) != SSA_NAME)\n-    return false;\n-\n-  unsigned ver = SSA_NAME_VERSION (use);\n-\n-  /* If it's in liveouts, the variable will get a new PHI node, and\n-     the debug use will be properly adjusted.  */\n-  if (bitmap_bit_p (liveouts, ver))\n-    return false;\n-\n-  basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));\n-\n-  if (!def_bb || !bb_in_sese_p (def_bb, region->region))\n-    return false;\n-\n-  return true;\n-}\n-\n /* Reset debug stmts that reference SSA_NAMES defined in REGION that\n    are not marked as liveouts.  */\n \n static void\n-sese_reset_debug_liveouts_bb (sese_info_p region, bitmap liveouts,\n-\t\t\t      basic_block bb)\n+sese_reset_debug_liveouts (sese_info_p region)\n {\n-  gimple_stmt_iterator bsi;\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-\n-  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+  bitmap_iterator bi;\n+  unsigned i;\n+  EXECUTE_IF_AND_COMPL_IN_BITMAP (region->debug_liveout, region->liveout,\n+\t\t\t\t  0, i, bi)\n     {\n-      gimple *stmt = gsi_stmt (bsi);\n-\n-      if (!is_gimple_debug (stmt))\n-\tcontinue;\n-\n-      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n-\tif (sese_bad_liveouts_use (region, liveouts, bb,\n-\t\t\t\t   USE_FROM_PTR (use_p)))\n-\t  {\n-\t    gimple_debug_bind_reset_value (stmt);\n-\t    update_stmt (stmt);\n-\t    break;\n-\t  }\n+      tree name = ssa_name (i);\n+      auto_vec<gimple *, 4> stmts;\n+      gimple *use_stmt;\n+      imm_use_iterator use_iter;\n+      FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, name)\n+\t{\n+\t  if (! is_gimple_debug (use_stmt)\n+\t      || bb_in_sese_p (gimple_bb (use_stmt), region->region))\n+\t    continue;\n+\t  stmts.safe_push (use_stmt);\n+\t}\n+      while (!stmts.is_empty ())\n+\t{\n+\t  gimple *stmt = stmts.pop ();\n+\t  gimple_debug_bind_reset_value (stmt);\n+\t  update_stmt (stmt);\n+\t}\n     }\n }\n \n /* Build the LIVEOUTS of REGION: the set of variables defined inside\n    and used outside the REGION.  */\n \n-static void\n-sese_build_liveouts (sese_info_p region, bitmap liveouts)\n+void\n+sese_build_liveouts (sese_info_p region)\n {\n   basic_block bb;\n \n+  gcc_assert (region->liveout == NULL\n+\t      && region->debug_liveout == NULL);\n+\n+  region->liveout = BITMAP_ALLOC (NULL);\n+  region->debug_liveout = BITMAP_ALLOC (NULL);\n+\n   /* FIXME: We could start iterating form the successor of sese.  */\n   FOR_EACH_BB_FN (bb, cfun)\n     if (!bb_in_sese_p (bb, region->region))\n-      sese_build_liveouts_bb (region, liveouts, bb);\n-\n-  /* FIXME: We could start iterating form the successor of sese.  */\n-  if (MAY_HAVE_DEBUG_STMTS)\n-    FOR_EACH_BB_FN (bb, cfun)\n-      if (!bb_in_sese_p (bb, region->region))\n-\tsese_reset_debug_liveouts_bb (region, liveouts, bb);\n+      sese_build_liveouts_bb (region, bb);\n }\n \n /* Builds a new SESE region from edges ENTRY and EXIT.  */\n@@ -179,6 +153,8 @@ new_sese_info (edge entry, edge exit)\n \n   region->region.entry = entry;\n   region->region.exit = exit;\n+  region->liveout = NULL;\n+  region->debug_liveout = NULL;\n   region->params.create (3);\n   region->rename_map = new rename_map_t;\n   region->parameter_rename_map = new parameter_rename_map_t;\n@@ -196,6 +172,8 @@ void\n free_sese_info (sese_info_p region)\n {\n   region->params.release ();\n+  BITMAP_FREE (region->liveout);\n+  BITMAP_FREE (region->debug_liveout);\n \n   for (rename_map_t::iterator it = region->rename_map->begin ();\n        it != region->rename_map->end (); ++it)\n@@ -246,17 +224,14 @@ void\n sese_insert_phis_for_liveouts (sese_info_p region, basic_block bb,\n \t\t\t       edge false_e, edge true_e)\n {\n+  if (MAY_HAVE_DEBUG_STMTS)\n+    sese_reset_debug_liveouts (region);\n+\n   unsigned i;\n   bitmap_iterator bi;\n-  bitmap liveouts = BITMAP_ALLOC (NULL);\n-\n-  sese_build_liveouts (region, liveouts);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (liveouts, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (region->liveout, 0, i, bi)\n     if (!virtual_operand_p (ssa_name (i)))\n       sese_add_exit_phis_edge (bb, ssa_name (i), false_e, true_e);\n-\n-  BITMAP_FREE (liveouts);\n }\n \n /* Returns the outermost loop in SCOP that contains BB.  */\n@@ -369,6 +344,8 @@ move_sese_in_condition (sese_info_p region)\n   if_region->true_region->region.exit\n     = single_succ_edge (split_edge (true_edge));\n \n+  region->region = if_region->false_region->region;\n+\n   return if_region;\n }\n \n@@ -471,7 +448,10 @@ scev_analyzable_p (tree def, sese_l &region)\n     && (TREE_CODE (scev) != SSA_NAME\n \t|| !defined_in_sese_p (scev, region))\n     && (tree_does_not_contain_chrecs (scev)\n-\t|| evolution_function_is_affine_p (scev));\n+\t|| evolution_function_is_affine_p (scev))\n+    && (! loop\n+\t|| ! loop_in_sese_p (loop, region)\n+\t|| ! chrec_contains_symbols_defined_in_loop (scev, loop->num));\n }\n \n /* Returns the scalar evolution of T in REGION.  Every variable that\n@@ -518,6 +498,21 @@ scalar_evolution_in_region (const sese_l &region, loop_p loop, tree t)\n   return instantiate_scev (before, loop, t);\n }\n \n+/* Return true if BB is empty, contains only DEBUG_INSNs.  */\n+\n+bool\n+sese_trivially_empty_bb_p (basic_block bb)\n+{         \n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    if (gimple_code (gsi_stmt (gsi)) != GIMPLE_DEBUG\n+\t&& gimple_code (gsi_stmt (gsi)) != GIMPLE_LABEL)\n+      return false;\n+\n+  return true;\n+}\n+\n /* Pretty print edge E to FILE.  */\n \n void"}, {"sha": "190deeda8afe75df075569b8e212ba9a0867d300", "filename": "gcc/sese.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -83,6 +83,12 @@ typedef struct sese_info_t\n   /* The SESE region.  */\n   sese_l region;\n \n+  /* Liveout vars.  */\n+  bitmap liveout;\n+\n+  /* Liveout in debug stmts.  */\n+  bitmap debug_liveout;\n+\n   /* Parameters used within the SCOP.  */\n   vec<tree> params;\n \n@@ -116,6 +122,8 @@ extern struct loop *outermost_loop_in_sese (sese_l &, basic_block);\n extern tree scalar_evolution_in_region (const sese_l &, loop_p, tree);\n extern bool scev_analyzable_p (tree, sese_l &);\n extern bool invariant_in_sese_p_rec (tree, const sese_l &, bool *);\n+extern void sese_build_liveouts (sese_info_p);\n+extern bool sese_trivially_empty_bb_p (basic_block);\n \n /* The number of parameters in REGION. */\n "}, {"sha": "f01325a3f0adc09c5a91ebe4af9bfd5992826ae6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,3 +1,30 @@\n+2017-10-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/graphite/id-15.c: No longer expect a code generation error.\n+\t* gcc.dg/graphite/id-16.c: Likewise.\n+\t* gcc.dg/graphite/pr46168.c: Likewise.\n+\t* gcc.dg/graphite/pr68756.c: Likewise.\n+\t* gcc.dg/graphite/pr69728.c: Likewise.\n+\t* gcc.dg/graphite/pr71575-2.c: Likewise.\n+\t* gcc.dg/graphite/pr77362.c: Likewise.\n+\t* gcc.dg/graphite/pr81373.c: Likewise.\n+\t* gcc.dg/graphite/run-id-pr67700-1.c: Likewise.\n+\t* gfortran.dg/graphite/interchange-1.f: Likewise.\n+\t* gfortran.dg/graphite/pr42334-1.f: Likewise.\n+\t* gfortran.dg/graphite/pr42393-1.f90: Likewise.\n+\t* gfortran.dg/graphite/pr42393.f90: Likewise.\n+\t* gfortran.dg/graphite/pr47019.f: Likewise.\n+\t* gfortran.dg/graphite/id-17.f: Likewise.\n+\t* gfortran.dg/graphite/id-19.f: Likewise.\n+\t* gfortran.dg/graphite/run-id-2.f90: Likewise.\n+\t* gfortran.dg/graphite/pr42326-1.f90: Likewise.\n+\t* gfortran.dg/graphite/pr42326.f90: Likewise.\n+\t* gfortran.dg/graphite/pr68550-2.f90: Likewise.\n+\t* gfortran.dg/graphite/pr29581.f90: Likewise.  No longer expect\n+\ta code generation error.\n+\t* gfortran.dg/graphite/run-id-3.f90: Likewise.\n+\t* gfortran.dg/graphite/pr29832.f90: Likewise.\n+\n 2017-10-06  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82436"}, {"sha": "d1cb2a2519bfc0d9264936106fcf428f0e8345ca", "filename": "gcc/testsuite/gcc.dg/graphite/id-15.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-15.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,5 +1,4 @@\n /* { dg-require-effective-target int32plus } */\n-/* { dg-additional-options \"--param graphite-allow-codegen-errors=1\" { target ilp32 } } */\n \n typedef long unsigned int size_t;\n extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));\n@@ -118,5 +117,3 @@ mul_double (l1, h1, l2, h2, lv, hv)\n     }\n   return (*hv < 0 ? ~(toplow & tophigh) : toplow | tophigh) != 0;\n }\n-\n-/* { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" { target ilp32 } } } */"}, {"sha": "faa685f8014b64b992458c3c7cd678466de26648", "filename": "gcc/testsuite/gcc.dg/graphite/id-16.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-16.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,5 +1,3 @@\n-/* { dg-additional-options \"--param graphite-allow-codegen-errors=1\" } */\n-\n int transformation[(2*19 - 1) * (2*19 - 1)][8];\n \n const int transformation2[8][2][2] = {\n@@ -44,5 +42,3 @@ transformation_init (void)\n \t}\n     }\n }\n-\n-/* { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } } */"}, {"sha": "28b48415d972f6a14ce48b9b99c91aa628759b73", "filename": "gcc/testsuite/gcc.dg/graphite/pr46168.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr46168.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr46168.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr46168.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -ftree-loop-linear -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" } */\n+/* { dg-options \"-O -ftree-loop-linear\" } */\n \n int\n foo (int a[4096], int mi, int mj)\n@@ -13,5 +13,3 @@ foo (int a[4096], int mi, int mj)\n     }\n   return i16;\n }\n-\n-/* { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } } */"}, {"sha": "ddb9789f133a86bd7c22694ac1fc1170520f8b68", "filename": "gcc/testsuite/gcc.dg/graphite/pr68756.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr68756.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr68756.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr68756.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -floop-nest-optimize -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" } */\n+/* { dg-options \"-O1 -floop-nest-optimize\" } */\n \n unsigned int z4, pz;\n int nn[2];\n@@ -24,5 +24,3 @@ la (void)\n       pz = xq (hn);\n     }\n }\n-\n-/* { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } } */"}, {"sha": "35ea5bd15bb7eccd68ce1db398b0f1a9fc899966", "filename": "gcc/testsuite/gcc.dg/graphite/pr69728.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr69728.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr69728.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr69728.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -floop-nest-optimize -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" } */\n+/* { dg-options \"-O3 -floop-nest-optimize\" } */\n \n int a[1];\n int b, c, d, e;\n@@ -19,5 +19,3 @@ fn1 ()\n \t}\n     }\n }\n-\n-/* { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } } */"}, {"sha": "24bc957b2d6d45091e5c88c22bb7d066c515c369", "filename": "gcc/testsuite/gcc.dg/graphite/pr71575-2.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr71575-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr71575-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr71575-2.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Ofast -floop-nest-optimize -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" } */\n+/* { dg-options \"-Ofast -floop-nest-optimize\" } */\n \n int *a;\n int b, c, d, e, g;\n@@ -14,5 +14,3 @@ void fn1() {\n \t}\n     }\n }\n-\n-/* { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } } */"}, {"sha": "c6a1e36ecd94e11a5dd3ae14f05450b3f72bad12", "filename": "gcc/testsuite/gcc.dg/graphite/pr77362.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr77362.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr77362.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr77362.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -floop-nest-optimize -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" } */\n+/* { dg-options \"-O2 -floop-nest-optimize\" } */\n \n int mc[2];\n int f2, sk;\n@@ -18,5 +18,3 @@ zm (void)\n \t++hm;\n     }\n }\n-\n-/* { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } } */"}, {"sha": "588b9d007326f37463512dc1e11234d213660909", "filename": "gcc/testsuite/gcc.dg/graphite/pr81373.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr81373.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr81373.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr81373.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-fno-tree-scev-cprop -fgraphite-identity -O -fdump-tree-graphite-all --param graphite-allow-codegen-errors=1\" } */\n+/* { dg-options \"-fno-tree-scev-cprop -fgraphite-identity -O -fdump-tree-graphite-all\" } */\n \n void bar (void);\n \n@@ -38,4 +38,3 @@ int toto()\n }\n \n /* { dg-final { scan-tree-dump-times \"number of SCoPs: 2\" 1 \"graphite\"} } */\n-/* { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } } */"}, {"sha": "f1fae716c066a02cc9abedc51bac9bf2ad791d9a", "filename": "gcc/testsuite/gcc.dg/graphite/run-id-pr67700-1.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr67700-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr67700-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr67700-1.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,5 +1,3 @@\n-/* { dg-additional-options \"--param graphite-allow-codegen-errors=1\" } */\n-\n #include <stdlib.h>\n #include <assert.h>\n \n@@ -47,5 +45,3 @@ int main()\n   assert (obj->elem1[8] == 45);\n   return 0;\n }\n-\n-/* { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } } */"}, {"sha": "4bebed016782973257988944e6b4dd2fbf400791", "filename": "gcc/testsuite/gfortran.dg/graphite/id-17.f", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-17.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-17.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-17.f?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,4 +1,3 @@\n-! { dg-additional-options \"-fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" { target ilp32 } }\n       SUBROUTINE SPECTOP(Dr,N)\n       DIMENSION d1(0:32,0:32) , Dr(0:32,0:32) , x(0:32)\n       DO k = 0 , N\n@@ -15,4 +14,3 @@ SUBROUTINE SPECTOP(Dr,N)\n          ENDDO\n       ENDDO\n       END\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" { target ilp32 } } }"}, {"sha": "e05f764b294a87480d8cd7dec4b103229c958a7a", "filename": "gcc/testsuite/gfortran.dg/graphite/id-19.f", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-19.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-19.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-19.f?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,4 +1,3 @@\n-! { dg-additional-options \"-fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" { target ilp32 } }\n       SUBROUTINE ECCODR(FPQR)\n       DIMENSION FPQR(25,25,25)\n       INTEGER P,Q,R\n@@ -14,4 +13,3 @@ SUBROUTINE ECCODR(FPQR)\n   140    QM2= QM2+TWO\n   150 PM2= PM2+TWO\n       END\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" { target ilp32 } } }"}, {"sha": "d19cf70c1661d9a1189aa2f40d381acd8729eb70", "filename": "gcc/testsuite/gfortran.dg/graphite/interchange-1.f", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-1.f?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,4 +1,3 @@\n-! { dg-additional-options \"--param graphite-allow-codegen-errors=1\" }\n       subroutine foo(f1,f2,f3,f4,f5,f6,f7,f8,f9,f0,g1,g2,g3)\n       implicit none\n       integer f4,f3,f2,f1\n@@ -43,4 +42,3 @@ subroutine foo(f1,f2,f3,f4,f5,f6,f7,f8,f9,f0,g1,g2,g3)\n ! kernel from bwaves.\n \n ! { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" { xfail *-*-* } } }\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } }"}, {"sha": "bfcb860215afa8c3919ed336b692265fcbcf7add", "filename": "gcc/testsuite/gfortran.dg/graphite/pr29581.f90", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29581.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29581.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29581.f90?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,6 +1,7 @@\n ! PR tree-optimization/29581\n ! { dg-do run }\n-! { dg-options \"-O2 -ftree-loop-linear -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" }\n+! { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } }\n+! { dg-additional-options \"-ftree-loop-linear\" }\n \n       SUBROUTINE FOO (K)\n       INTEGER I, J, K, A(5,5), B\n@@ -25,5 +26,3 @@ PROGRAM BAR\n         A(1,1) = 0\n         IF (ANY(A.NE.0)) CALL ABORT\n       END\n-\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } }"}, {"sha": "f98a7d36f3542be552347e11dcdba1e217b2346b", "filename": "gcc/testsuite/gfortran.dg/graphite/pr29832.f90", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29832.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29832.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29832.f90?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do run }\n-! { dg-options \"-O2 -ftree-loop-linear\" }\n-! { dg-additional-options \"-fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" { target ilp32 } }\n+! { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } }\n+! { dg-additional-options \"-ftree-loop-linear\" }\n \n ! Program to test the scalarizer\n program testarray\n@@ -24,5 +24,3 @@ program testarray\n       if (b(4, n) .ne. (6 - n)) call abort\n    end do\n end program\n-\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" { target ilp32 } } }"}, {"sha": "b2c3b9bbb7c25b7bf46863baccd184cc3cc461e8", "filename": "gcc/testsuite/gfortran.dg/graphite/pr42326-1.f90", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42326-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42326-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42326-1.f90?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,7 +1,7 @@\n ! { dg-do compile { target i?86-*-* x86_64-*-* } }\n ! { dg-require-effective-target ilp32 }\n ! { dg-require-effective-target sse2 }\n-! { dg-options \"-O2 -floop-parallelize-all -fprefetch-loop-arrays -msse2 -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" }\n+! { dg-options \"-O2 -floop-parallelize-all -fprefetch-loop-arrays -msse2\" }\n \n subroutine phasad(t,i,ium)\n   implicit none\n@@ -16,5 +16,3 @@ subroutine phasad(t,i,ium)\n   enddo\n   return\n end subroutine phasad\n-\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } }"}, {"sha": "e4d1936e3b5ca4cf76ed6b4a4cd37ecf4ec889c5", "filename": "gcc/testsuite/gfortran.dg/graphite/pr42326.f90", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42326.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42326.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42326.f90?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,7 +1,7 @@\n ! { dg-do compile { target i?86-*-* x86_64-*-* } }\n ! { dg-require-effective-target ilp32 }\n ! { dg-require-effective-target sse2 }\n-! { dg-options \"-O2 -floop-strip-mine -fprefetch-loop-arrays -msse2 -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" }\n+! { dg-options \"-O2 -floop-strip-mine -fprefetch-loop-arrays -msse2\" }\n \n subroutine blts ( ldmx, ldmy, v, tmp1, i, j, k)\n   implicit none\n@@ -33,5 +33,3 @@ subroutine phasad(t,i,ium)\n   enddo\n   return\n end subroutine phasad\n-\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } }"}, {"sha": "2503dc3e8f2ec1a116a847353a81748718c47c09", "filename": "gcc/testsuite/gfortran.dg/graphite/pr42334-1.f", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42334-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42334-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42334-1.f?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,4 +1,4 @@\n-! { dg-options \"-O2 -floop-interchange -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" }\n+! { dg-options \"-O2 -floop-interchange\" }\n \n       subroutine linel(icmdl,stre,anisox)\n       real*8 stre(6),tkl(3,3),ekl(3,3),anisox(3,3,3,3)\n@@ -14,5 +14,3 @@ subroutine linel(icmdl,stre,anisox)\n             enddo\n             stre(1)=tkl(1,1)\n       end\n-\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } }"}, {"sha": "fb62e20f45c8d4e7e92f3c4bf6ef10d503d06a65", "filename": "gcc/testsuite/gfortran.dg/graphite/pr42393-1.f90", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42393-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42393-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42393-1.f90?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,4 +1,4 @@\n-! { dg-options \"-O2 -fgraphite-identity -fno-loop-block -fno-loop-interchange -fno-loop-strip-mine -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" }\n+! { dg-options \"-O2 -fgraphite-identity -fno-loop-block -fno-loop-interchange -fno-loop-strip-mine\" }\n \n MODULE beta_gamma_psi\n   INTEGER, PARAMETER :: dp=KIND(0.0D0)\n@@ -22,5 +22,3 @@ FUNCTION basym () RESULT(fn_val)\n     fn_val = sum\n   END FUNCTION basym\n END MODULE beta_gamma_psi\n-\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } }"}, {"sha": "1fc708ef9673c5d1bd97ced5737227eeb82e54b7", "filename": "gcc/testsuite/gfortran.dg/graphite/pr42393.f90", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42393.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42393.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr42393.f90?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,4 +1,4 @@\n-! { dg-options \"-O2 -fgraphite-identity -fno-loop-block -fno-loop-interchange -fno-loop-strip-mine -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" }\n+! { dg-options \"-O2 -fgraphite-identity -fno-loop-block -fno-loop-interchange -fno-loop-strip-mine\" }\n \n MODULE beta_gamma_psi\n   INTEGER, PARAMETER :: dp=KIND(0.0D0)\n@@ -28,5 +28,3 @@ FUNCTION basym (a, b, lambda, eps) RESULT(fn_val)\n     fn_val = e0*t*u*sum\n   END FUNCTION basym\n END MODULE beta_gamma_psi\n-\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } }"}, {"sha": "69067e9c500e86cc563845d921f6ed5763e590f6", "filename": "gcc/testsuite/gfortran.dg/graphite/pr47019.f", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr47019.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr47019.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr47019.f?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,4 +1,4 @@\n-! { dg-options \"-O -ftree-pre -fgraphite-identity -fno-tree-copy-prop -fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" }\n+! { dg-options \"-O -ftree-pre -fgraphite-identity -fno-tree-copy-prop\" }\n \n       subroutine foo (ldmx,ldmy,v)\n       integer :: ldmx, ldmy, v, l, m\n@@ -10,5 +10,3 @@ subroutine foo (ldmx,ldmy,v)\n         v(m,3,2) = m\n       end do\n       end\n-\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" } }"}, {"sha": "fae0c92a7dc48c5594c02cf533ffa8f5575a626b", "filename": "gcc/testsuite/gfortran.dg/graphite/pr68550-2.f90", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68550-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68550-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68550-2.f90?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,6 +1,5 @@\n ! { dg-do compile }\n ! { dg-options \"-floop-nest-optimize -fcheck=bounds -O1\" }\n-! { dg-additional-options \"-fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" { target ilp32 } }\n \n SUBROUTINE PD2VAL(RES,NDERIV,TG1,TG2,C0)\n     INTEGER, PARAMETER :: dp=8\n@@ -13,5 +12,3 @@ SUBROUTINE PD2VAL(RES,NDERIV,TG1,TG2,C0)\n   RES(K)=RES(K)+DOT_PRODUCT(T1(0:3),C0(96:99,K))*T2(10)\n  ENDDO\n END SUBROUTINE PD2VAL\n-\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" { target ilp32 } } }"}, {"sha": "c4fa1d06141c7244d14661da1a6e93eb11bac204", "filename": "gcc/testsuite/gfortran.dg/graphite/run-id-2.f90", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Frun-id-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Frun-id-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Frun-id-2.f90?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,4 +1,3 @@\n-! { dg-additional-options \"-fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" { target ilp32 } }\n   IMPLICIT NONE\n   INTEGER, PARAMETER :: dp=KIND(0.0D0)\n   REAL(KIND=dp)      :: res\n@@ -65,4 +64,3 @@ FUNCTION exp_radius_very_extended(la_min,la_max,lb_min,lb_max,ra,rb,rp,&\n   END FUNCTION exp_radius_very_extended\n \n END\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" { target ilp32 } } }"}, {"sha": "ab16a44b949f4a940e61e27ecbb5244e5bf38c58", "filename": "gcc/testsuite/gfortran.dg/graphite/run-id-3.f90", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Frun-id-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Frun-id-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Frun-id-3.f90?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do run }\n-! { dg-options \"-ffrontend-optimize -floop-nest-optimize\" }\n-! { dg-additional-options \"-fdump-tree-graphite-details --param graphite-allow-codegen-errors=1\" { target ilp32 } }\n+! { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } }\n+! { dg-additional-options \"-ffrontend-optimize -floop-nest-optimize\" }\n ! PR 56872 - wrong front-end optimization with a single constructor.\n ! Original bug report by Rich Townsend.\n   integer :: k\n@@ -11,4 +11,3 @@\n   res = SUM([(s**(REAL(k-1)/REAL(m-1)),k=1,m)])\n   if (abs(res - 5.84732246) > 1e-6) call abort\n   end\n-! { dg-final { scan-tree-dump-times \"code generation error\" 1 \"graphite\" { target ilp32 } } }"}, {"sha": "a250f8159c0074b840e842547fce3cb4b7fe5c62", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d431f44377efe110b02163d693e60421acdeb/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=bd8d431f44377efe110b02163d693e60421acdeb", "patch": "@@ -1226,6 +1226,8 @@ get_reaching_def (tree var)\n   if (currdef == NULL_TREE)\n     {\n       tree sym = DECL_P (var) ? var : SSA_NAME_VAR (var);\n+      if (! sym)\n+\tsym = create_tmp_reg (TREE_TYPE (var));\n       currdef = get_or_create_ssa_default_def (cfun, sym);\n     }\n "}]}