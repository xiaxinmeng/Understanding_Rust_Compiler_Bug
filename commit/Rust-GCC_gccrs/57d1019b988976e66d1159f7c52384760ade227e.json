{"sha": "57d1019b988976e66d1159f7c52384760ade227e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdkMTAxOWI5ODg5NzZlNjZkMTE1OWY3YzUyMzg0NzYwYWRlMjI3ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-01-08T06:13:34Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-01-08T06:13:34Z"}, "message": "regrename.c (find_oldest_value_reg): Ignore the value chain if the original register was copied in a mode with a...\n\n        * regrename.c (find_oldest_value_reg): Ignore the value chain if\n        the original register was copied in a mode with a fewer number of\n        hard registers than the desired mode.\n        (copyprop_hardreg_forward_1): Likewise.\n        (debug_value_data): Fix loop test.\n        * toplev.c (parse_options_and_default_flags): Reenable\n        -fcprop-registers at -O1.\n\nFrom-SVN: r48624", "tree": {"sha": "8be94b41904aef428279cea50f3a0662e922a449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8be94b41904aef428279cea50f3a0662e922a449"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57d1019b988976e66d1159f7c52384760ade227e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d1019b988976e66d1159f7c52384760ade227e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57d1019b988976e66d1159f7c52384760ade227e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d1019b988976e66d1159f7c52384760ade227e/comments", "author": null, "committer": null, "parents": [{"sha": "70ec0b9b9faad0d709cd44be3247127caef73c12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70ec0b9b9faad0d709cd44be3247127caef73c12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70ec0b9b9faad0d709cd44be3247127caef73c12"}], "stats": {"total": 40, "additions": 37, "deletions": 3}, "files": [{"sha": "cfff16965f0b0a8354f175678bfd02d88b23629e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d1019b988976e66d1159f7c52384760ade227e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d1019b988976e66d1159f7c52384760ade227e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57d1019b988976e66d1159f7c52384760ade227e", "patch": "@@ -1,4 +1,14 @@\n-002-01-07  Aldy Hernandez  <aldyh@redhat.com>\n+2002-01-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* regrename.c (find_oldest_value_reg): Ignore the value chain if\n+\tthe original register was copied in a mode with a fewer number of\n+\thard registers than the desired mode.\n+\t(copyprop_hardreg_forward_1): Likewise.\n+\t(debug_value_data): Fix loop test.\n+\t* toplev.c (parse_options_and_default_flags): Reenable\n+\t-fcprop-registers at -O1.\n+\n+2002-01-07  Aldy Hernandez  <aldyh@redhat.com>\n \n         * config/rs6000/rs6000.c (bdesc_2arg): Add altivec predicates.\n         (altivec_init_builtins): New node v4si_ftype_v16qi_v16qi."}, {"sha": "45f5b8552ef692143d13c95af52667f1c3254f2c", "filename": "gcc/regrename.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d1019b988976e66d1159f7c52384760ade227e/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d1019b988976e66d1159f7c52384760ade227e/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=57d1019b988976e66d1159f7c52384760ade227e", "patch": "@@ -1282,6 +1282,20 @@ find_oldest_value_reg (class, reg, vd)\n   enum machine_mode mode = GET_MODE (reg);\n   unsigned int i;\n \n+  /* If we are accessing REG in some mode other that what we set it in,\n+     make sure that the replacement is valid.  In particular, consider\n+\t(set (reg:DI r11) (...))\n+\t(set (reg:SI r9) (reg:SI r11))\n+\t(set (reg:SI r10) (...))\n+\t(set (...) (reg:DI r9))\n+     Replacing r9 with r11 is invalid.  */\n+  if (mode != vd->e[regno].mode)\n+    {\n+      if (HARD_REGNO_NREGS (regno, mode)\n+\t  > HARD_REGNO_NREGS (regno, vd->e[regno].mode))\n+\treturn NULL_RTX;\n+    }\n+\n   for (i = vd->e[regno].oldest_regno; i != regno; i = vd->e[i].next_regno)\n     if (TEST_HARD_REG_BIT (reg_class_contents[class], i)\n \t&& (vd->e[i].mode == mode\n@@ -1544,6 +1558,15 @@ copyprop_hardreg_forward_1 (bb, vd)\n \t  unsigned int i;\n \t  rtx new;\n \n+\t  /* If we are accessing SRC in some mode other that what we\n+\t     set it in, make sure that the replacement is valid.  */\n+\t  if (mode != vd->e[regno].mode)\n+\t    {\n+\t      if (HARD_REGNO_NREGS (regno, mode)\n+\t\t  > HARD_REGNO_NREGS (regno, vd->e[regno].mode))\n+\t\tgoto no_move_special_case;\n+\t    }\n+\n \t  /* If the destination is also a register, try to find a source\n \t     register in the same class.  */\n \t  if (REG_P (SET_DEST (set)))\n@@ -1578,6 +1601,7 @@ copyprop_hardreg_forward_1 (bb, vd)\n \t\t  }\n \t      }\n \t}\n+      no_move_special_case:\n \n       /* For each input operand, replace a hard register with the\n \t eldest live copy that's in an appropriate register class.  */\n@@ -1735,7 +1759,7 @@ debug_value_data (vd)\n \t     j != INVALID_REGNUM;\n \t     j = vd->e[j].next_regno)\n \t  {\n-\t    if (TEST_HARD_REG_BIT (set, vd->e[j].next_regno))\n+\t    if (TEST_HARD_REG_BIT (set, j))\n \t      {\n \t\tfprintf (stderr, \"[%u] Loop in regno chain\\n\", j);\n \t\treturn;"}, {"sha": "da508a763f23c5e56e5fd1ba13314b1cf606dcd8", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d1019b988976e66d1159f7c52384760ade227e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d1019b988976e66d1159f7c52384760ade227e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=57d1019b988976e66d1159f7c52384760ade227e", "patch": "@@ -4663,7 +4663,7 @@ parse_options_and_default_flags (argc, argv)\n       flag_omit_frame_pointer = 1;\n #endif\n       flag_guess_branch_prob = 1;\n-      /* flag_cprop_registers = 1; */\n+      flag_cprop_registers = 1;\n     }\n \n   if (optimize >= 2)"}]}