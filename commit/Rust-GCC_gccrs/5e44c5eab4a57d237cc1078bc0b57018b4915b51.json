{"sha": "5e44c5eab4a57d237cc1078bc0b57018b4915b51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU0NGM1ZWFiNGE1N2QyMzdjYzEwNzhiYzBiNTcwMThiNDkxNWI1MQ==", "commit": {"author": {"name": "Doug Rupp", "email": "rupp@adacore.com", "date": "2009-04-16T09:34:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-16T09:34:40Z"}, "message": "2009-04-16  Doug Rupp  <rupp@adacore.com>\n\n\t* s-taprop-vxworks.adb, s-taprop-tru64.adb, s-taprop-mingw.adb,\n\ts-taprop-linux.adb, s-taprop-solaris.adb, s-taprop-irix.adb, \n\ts-taprop-hpux-dce.adb, s-taprop-posix.adb\n\t(Enter_Task): Move Known_Tasks initialization to s-tassta.adb\n\n\t* s-taprop-vms.adb (Enter_Task): Likewise.\n\t(Initialize): Import DBEXT, Debug_Register. Register DBGEXT callback.\n\n\t* s-tassta.adb (Activate_Tasks): After task creation set state to\n\tActivating, vice Runnable. Initialize Known_Tasks, moved here from\n\ts-taprop.adb (Enter_Task). Set Debug_Event_Activating for debugger.\n\tSet state to Runnable after above.\n\t(Task_Wrapper): Set Debug_Event_Run. In exception block set\n\tDebug_Event_Terminated.\n\n\t* s-taskin.ads (Task_States): Add new states Activiting and\n\tActivator_Delay_Sleep.\n\t(Bit_Array, Debug_Event_Array): New types.\n\t(Global_Task_Debug_Event_Set: New flag.\n\t(Common_ATCB): New field Debug_Events.\n\n\t* s-taskin.adb (Initialize_ATCB): Initialize Debug_Events.\n\n\t* s-tasren.adb (Timed_Selective_Wait): Set Activator_Delay_Sleep vice\n\tActivator_Sleep.\n\n\t* s-tasini.adb (Locked_Abort_To_Level): Add case alternatives for when\n\tActivating and when Acceptor_Delay_Sleep.\n\n\t* s-tasdeb.ads: Add constants for Debug_Events.\n\t(Debug_Event_Kind_Type): New subtype.\n\t(Signal_Debug_Event): New subprogram.\n\n\t* s-tasdeb.adb (Signal_Debug_Event): New null subprogram.\n\nFrom-SVN: r146155", "tree": {"sha": "9a03f0f199ae466677c31f5513d269b09fabed84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a03f0f199ae466677c31f5513d269b09fabed84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e44c5eab4a57d237cc1078bc0b57018b4915b51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e44c5eab4a57d237cc1078bc0b57018b4915b51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e44c5eab4a57d237cc1078bc0b57018b4915b51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e44c5eab4a57d237cc1078bc0b57018b4915b51/comments", "author": {"login": "Cementitious", "id": 115579865, "node_id": "U_kgDOBuOb2Q", "avatar_url": "https://avatars.githubusercontent.com/u/115579865?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Cementitious", "html_url": "https://github.com/Cementitious", "followers_url": "https://api.github.com/users/Cementitious/followers", "following_url": "https://api.github.com/users/Cementitious/following{/other_user}", "gists_url": "https://api.github.com/users/Cementitious/gists{/gist_id}", "starred_url": "https://api.github.com/users/Cementitious/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Cementitious/subscriptions", "organizations_url": "https://api.github.com/users/Cementitious/orgs", "repos_url": "https://api.github.com/users/Cementitious/repos", "events_url": "https://api.github.com/users/Cementitious/events{/privacy}", "received_events_url": "https://api.github.com/users/Cementitious/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "205c14b0d0312a81140313d7b9b9a257248851c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/205c14b0d0312a81140313d7b9b9a257248851c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/205c14b0d0312a81140313d7b9b9a257248851c1"}], "stats": {"total": 436, "additions": 243, "deletions": 193}, "files": [{"sha": "7c1000579f55578b8bc1b1e934ee00d464613329", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -1,3 +1,40 @@\n+2009-04-16  Doug Rupp  <rupp@adacore.com>\n+\n+\t* s-taprop-vxworks.adb, s-taprop-tru64.adb, s-taprop-mingw.adb,\n+\ts-taprop-linux.adb, s-taprop-solaris.adb, s-taprop-irix.adb, \n+\ts-taprop-hpux-dce.adb, s-taprop-posix.adb\n+\t(Enter_Task): Move Known_Tasks initialization to s-tassta.adb\n+\n+\t* s-taprop-vms.adb (Enter_Task): Likewise.\n+\t(Initialize): Import DBEXT, Debug_Register. Register DBGEXT callback.\n+\n+\t* s-tassta.adb (Activate_Tasks): After task creation set state to\n+\tActivating, vice Runnable. Initialize Known_Tasks, moved here from\n+\ts-taprop.adb (Enter_Task). Set Debug_Event_Activating for debugger.\n+\tSet state to Runnable after above.\n+\t(Task_Wrapper): Set Debug_Event_Run. In exception block set\n+\tDebug_Event_Terminated.\n+\n+\t* s-taskin.ads (Task_States): Add new states Activiting and\n+\tActivator_Delay_Sleep.\n+\t(Bit_Array, Debug_Event_Array): New types.\n+\t(Global_Task_Debug_Event_Set: New flag.\n+\t(Common_ATCB): New field Debug_Events.\n+\n+\t* s-taskin.adb (Initialize_ATCB): Initialize Debug_Events.\n+\n+\t* s-tasren.adb (Timed_Selective_Wait): Set Activator_Delay_Sleep vice\n+\tActivator_Sleep.\n+\n+\t* s-tasini.adb (Locked_Abort_To_Level): Add case alternatives for when\n+\tActivating and when Acceptor_Delay_Sleep.\n+\n+\t* s-tasdeb.ads: Add constants for Debug_Events.\n+\t(Debug_Event_Kind_Type): New subtype.\n+\t(Signal_Debug_Event): New subprogram.\n+\n+\t* s-tasdeb.adb (Signal_Debug_Event): New null subprogram.\n+\n 2009-04-16  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_elim.adb: Minor reformatting"}, {"sha": "0afd56b6360317e808a60c1725d86a420e0fc3fc", "filename": "gcc/ada/s-taprop-hpux-dce.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-hpux-dce.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -714,18 +714,6 @@ package body System.Task_Primitives.Operations is\n    begin\n       Self_ID.Common.LL.Thread := pthread_self;\n       Specific.Set (Self_ID);\n-\n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      Unlock_RTS;\n    end Enter_Task;\n \n    --------------"}, {"sha": "d3344b35eaaf67b78385acff0bb7e72969b1cee2", "filename": "gcc/ada/s-taprop-irix.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -709,18 +709,6 @@ package body System.Task_Primitives.Operations is\n            (To_Int (Self_ID.Common.Task_Info.Runon_CPU));\n          pragma Assert (Result = 0);\n       end if;\n-\n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      Unlock_RTS;\n    end Enter_Task;\n \n    --------------"}, {"sha": "d3597a2a242574f25b0fe5f1e5b36d5d2485c8a6", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -705,18 +705,6 @@ package body System.Task_Primitives.Operations is\n \n       Specific.Set (Self_ID);\n \n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      Unlock_RTS;\n-\n       if Use_Alternate_Stack then\n          declare\n             Stack  : aliased stack_t;"}, {"sha": "f32d426eda89dc83d8e1ccc0119bb076603f07c6", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -807,18 +807,6 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Self_ID.Common.LL.Thread_Id := GetCurrentThreadId;\n-\n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      Unlock_RTS;\n    end Enter_Task;\n \n    --------------"}, {"sha": "51f20a6cc9cb864a347cd09245809db0a606603b", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -788,18 +788,6 @@ package body System.Task_Primitives.Operations is\n \n       Specific.Set (Self_ID);\n \n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      Unlock_RTS;\n-\n       if Use_Alternate_Stack then\n          declare\n             Stack  : aliased stack_t;"}, {"sha": "4156e368b662caf11f1f6f4a232f1a77b8c9d483", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -900,18 +900,6 @@ package body System.Task_Primitives.Operations is\n \n       --  We need the above code even if we do direct fetch of Task_Id in Self\n       --  for the main task on Sun, x86 Solaris and for gcc 2.7.2.\n-\n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      Unlock_RTS;\n    end Enter_Task;\n \n    --------------"}, {"sha": "94649e2ae942d8b48013b2c9d1c25f12526855f6", "filename": "gcc/ada/s-taprop-tru64.adb", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-tru64.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -707,19 +707,8 @@ package body System.Task_Primitives.Operations is\n    begin\n       Hide_Unhide_Yellow_Zone (Hide => True);\n       Self_ID.Common.LL.Thread := pthread_self;\n-      Specific.Set (Self_ID);\n-\n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n \n-      Unlock_RTS;\n+      Specific.Set (Self_ID);\n    end Enter_Task;\n \n    --------------"}, {"sha": "cc640a8ac16fb9c6a52a186ad9811b1e3e99421a", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -689,20 +689,7 @@ package body System.Task_Primitives.Operations is\n    procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n       Self_ID.Common.LL.Thread := pthread_self;\n-\n       Specific.Set (Self_ID);\n-\n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      Unlock_RTS;\n    end Enter_Task;\n \n    --------------\n@@ -1238,6 +1225,25 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Initialize (Environment_Task : Task_Id) is\n+\n+      --  The DEC Ada facility code defined in Starlet\n+      Ada_Facility : constant := 49;\n+\n+      function DBGEXT (Control_Block : System.Address)\n+        return System.Aux_DEC.Unsigned_Word;\n+      --  DBGEXT is imported  from s-tasdeb.adb and its parameter re-typed\n+      --  as Address to avoid having a VMS specific s-tasdeb.ads.\n+      pragma Interface (C, DBGEXT);\n+      pragma Import_Function (DBGEXT, \"GNAT$DBGEXT\");\n+\n+      type Facility_Type is range 0 .. 65535;\n+\n+      procedure Debug_Register\n+        (ADBGEXT    : System.Address;\n+         ATCB_Key   : pthread_key_t;\n+         Facility   : Facility_Type;\n+         Std_Prolog : Integer);\n+      pragma Import (C, Debug_Register, \"CMA$DEBUG_REGISTER\");\n    begin\n       Environment_Task_Id := Environment_Task;\n \n@@ -1249,6 +1255,15 @@ package body System.Task_Primitives.Operations is\n \n       Specific.Initialize (Environment_Task);\n \n+      --  Pass the context key on to CMA along with the other parameters\n+      Debug_Register\n+       (\n+        DBGEXT'Address,    --  Our DEBUG handling entry point\n+        ATCB_Key,          --  CMA context key for our Ada TCB's\n+        Ada_Facility,      --  Out facility code\n+        0                  --  False, we don't have the std TCB prolog\n+       );\n+\n       Enter_Task (Environment_Task);\n    end Initialize;\n "}, {"sha": "5f6d8d482028f37f25e406a8ebef6c9f19465b0a", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -833,18 +833,6 @@ package body System.Task_Primitives.Operations is\n \n       Install_Signal_Handlers;\n \n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      Unlock_RTS;\n-\n       --  If stack checking is enabled, set the stack limit for this task\n \n       if Set_Stack_Limit_Hook /= null then"}, {"sha": "9fb0cd6e798eea3375c063eb321670c7c6f4f3d0", "filename": "gcc/ada/s-tasdeb.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-tasdeb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-tasdeb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasdeb.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -246,6 +246,18 @@ package body System.Tasking.Debug is\n       STPO.Self.User_State := Value;\n    end Set_User_State;\n \n+   ------------------------\n+   -- Signal_Debug_Event --\n+   ------------------------\n+\n+   procedure Signal_Debug_Event\n+     (Event_Kind : Event_Kind_Type;\n+      Task_Value : Task_Id)\n+   is\n+   begin\n+      null;\n+   end Signal_Debug_Event;\n+\n    --------------------\n    -- Stop_All_Tasks --\n    --------------------"}, {"sha": "806fe0ee7b6fbc1334f9c7b5570b9bfd86d8aac1", "filename": "gcc/ada/s-tasdeb.ads", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-tasdeb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-tasdeb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasdeb.ads?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -69,6 +69,26 @@ package System.Tasking.Debug is\n    --  Global array of tasks read by gdb, and updated by Create_Task and\n    --  Finalize_TCB\n \n+   Debug_Event_Activating           : constant := 1;\n+   Debug_Event_Run                  : constant := 2;\n+   Debug_Event_Suspended            : constant := 3;\n+   Debug_Event_Preempted            : constant := 4;\n+   Debug_Event_Terminated           : constant := 5;\n+   Debug_Event_Abort_Terminated     : constant := 6;\n+   Debug_Event_Exception_Terminated : constant := 7;\n+   Debug_Event_Rendezvous_Exception : constant := 8;\n+   Debug_Event_Handled              : constant := 9;\n+   Debug_Event_Dependents_Exception : constant := 10;\n+   Debug_Event_Handled_Others       : constant := 11;\n+\n+   subtype Event_Kind_Type is Positive range 1 .. 11;\n+   --  Event kinds currently defined for debugging, used globally\n+   --  below and on a per taak basis.\n+\n+   procedure Signal_Debug_Event\n+     (Event_Kind : Event_Kind_Type;\n+      Task_Value : Task_Id);\n+\n    ----------------------------------\n    -- VxWorks specific GDB support --\n    ----------------------------------"}, {"sha": "0a97fb09a252e75a06e10ecb86f8c92d16a1f351", "filename": "gcc/ada/s-tasini.adb", "status": "modified", "additions": 64, "deletions": 60, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-tasini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-tasini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -57,9 +57,9 @@ package body System.Tasking.Initialization is\n    use Task_Primitives.Operations;\n \n    Global_Task_Lock : aliased System.Task_Primitives.RTS_Lock;\n-   --  This is a global lock; it is used to execute in mutual exclusion\n-   --  from all other tasks. It is only used by Task_Lock,\n-   --  Task_Unlock, and Final_Task_Unlock.\n+   --  This is a global lock; it is used to execute in mutual exclusion from\n+   --  all other tasks. It is only used by Task_Lock, Task_Unlock, and\n+   --  Final_Task_Unlock.\n \n    ----------------------------------------------------------------------\n    -- Tasking versions of some services needed by non-tasking programs --\n@@ -103,11 +103,10 @@ package body System.Tasking.Initialization is\n    ----------------------------\n \n    procedure Init_RTS;\n-   --  This procedure completes the initialization of the GNARL. The first\n-   --  part of the initialization is done in the body of System.Tasking.\n-   --  It consists of initializing global locks, and installing tasking\n-   --  versions of certain operations used by the compiler. Init_RTS is called\n-   --  during elaboration.\n+   --  This procedure completes the initialization of the GNARL. The first part\n+   --  of the initialization is done in the body of System.Tasking. It consists\n+   --  of initializing global locks, and installing tasking versions of certain\n+   --  operations used by the compiler. Init_RTS is called during elaboration.\n \n    --------------------------\n    -- Change_Base_Priority --\n@@ -130,7 +129,8 @@ package body System.Tasking.Initialization is\n    function Check_Abort_Status return Integer is\n       Self_ID : constant Task_Id := Self;\n    begin\n-      if Self_ID /= null and then Self_ID.Deferral_Level = 0\n+      if Self_ID /= null\n+        and then Self_ID.Deferral_Level = 0\n         and then Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n       then\n          return 1;\n@@ -271,6 +271,7 @@ package body System.Tasking.Initialization is\n                   pragma Assert (not Self_ID.ATC_Hack);\n \n                elsif Self_ID.ATC_Hack then\n+\n                   --  The solution really belongs in the Abort_Signal handler\n                   --  for async. entry calls.  The present hack is very\n                   --  fragile. It relies that the very next point after\n@@ -296,13 +297,14 @@ package body System.Tasking.Initialization is\n    -- Final_Task_Unlock --\n    -----------------------\n \n-   --  This version is only for use in Terminate_Task, when the task\n-   --  is relinquishing further rights to its own ATCB.\n-   --  There is a very interesting potential race condition there, where\n-   --  the old task may run concurrently with a new task that is allocated\n-   --  the old tasks (now reused) ATCB.  The critical thing here is to\n-   --  not make any reference to the ATCB after the lock is released.\n-   --  See also comments on Terminate_Task and Unlock.\n+   --  This version is only for use in Terminate_Task, when the task is\n+   --  relinquishing further rights to its own ATCB.\n+\n+   --  There is a very interesting potential race condition there, where the\n+   --  old task may run concurrently with a new task that is allocated the old\n+   --  tasks (now reused) ATCB. The critical thing here is to not make any\n+   --  reference to the ATCB after the lock is released. See also comments on\n+   --  Terminate_Task and Unlock.\n \n    procedure Final_Task_Unlock (Self_ID : Task_Id) is\n    begin\n@@ -334,16 +336,17 @@ package body System.Tasking.Initialization is\n       Self_Id.Awake_Count := 1;\n       Self_Id.Alive_Count := 1;\n \n-      Self_Id.Master_Within := Library_Task_Level;\n-      --  Normally, a task starts out with internal master nesting level\n-      --  one larger than external master nesting level. It is incremented\n-      --  to one by Enter_Master, which is called in the task body only if\n-      --  the compiler thinks the task may have dependent tasks. There is no\n+      --  Normally, a task starts out with internal master nesting level one\n+      --  larger than external master nesting level. It is incremented to one\n+      --  by Enter_Master, which is called in the task body only if the\n+      --  compiler thinks the task may have dependent tasks. There is no\n       --  corresponding call to Enter_Master for the environment task, so we\n-      --  would need to increment it to 2 here.  Instead, we set it to 3.\n-      --  By doing this we reserve the level 2 for server tasks of the runtime\n+      --  would need to increment it to 2 here. Instead, we set it to 3. By\n+      --  doing this we reserve the level 2 for server tasks of the runtime\n       --  system. The environment task does not need to wait for these server\n \n+      Self_Id.Master_Within := Library_Task_Level;\n+\n       --  Initialize lock used to implement mutual exclusion between all tasks\n \n       Initialize_Lock (Global_Task_Lock'Access, STPO.Global_Task_Level);\n@@ -368,8 +371,8 @@ package body System.Tasking.Initialization is\n \n       SSL.Tasking.Init_Tasking_Soft_Links;\n \n-      --  Abort is deferred in a new ATCB, so we need to undefer abort\n-      --  at this stage to make the environment task abortable.\n+      --  Abort is deferred in a new ATCB, so we need to undefer abort at this\n+      --  stage to make the environment task abortable.\n \n       Undefer_Abort (Environment_Task);\n    end Init_RTS;\n@@ -381,40 +384,37 @@ package body System.Tasking.Initialization is\n    --  Abort a task to the specified ATC nesting level.\n    --  Call this only with T locked.\n \n-   --  An earlier version of this code contained a call to Wakeup. That\n-   --  should not be necessary here, if Abort_Task is implemented correctly,\n-   --  since Abort_Task should include the effect of Wakeup. However, the\n-   --  above call was in earlier versions of this file, and at least for\n-   --  some targets Abort_Task has not been doing Wakeup. It should not\n-   --  hurt to uncomment the above call, until the error is corrected for\n-   --  all targets.\n+   --  An earlier version of this code contained a call to Wakeup. That should\n+   --  not be necessary here, if Abort_Task is implemented correctly, since\n+   --  Abort_Task should include the effect of Wakeup. However, the above call\n+   --  was in earlier versions of this file, and at least for some targets\n+   --  Abort_Task has not been doing Wakeup. It should not hurt to uncomment\n+   --  the above call, until the error is corrected for all targets.\n \n    --  See extended comments in package body System.Tasking.Abort for the\n    --  overall design of the implementation of task abort.\n    --  ??? there is no such package ???\n \n-   --  If the task is sleeping it will be in an abort-deferred region, and\n-   --  will not have Abort_Signal raised by Abort_Task. Such an \"abort\n-   --  deferral\" is just to protect the RTS internals, and not necessarily\n-   --  required to enforce Ada semantics. Abort_Task should wake the task up\n-   --  and let it decide if it wants to complete the aborted construct\n-   --  immediately.\n+   --  If the task is sleeping it will be in an abort-deferred region, and will\n+   --  not have Abort_Signal raised by Abort_Task. Such an \"abort deferral\" is\n+   --  just to protect the RTS internals, and not necessarily required to\n+   --  enforce Ada semantics. Abort_Task should wake the task up and let it\n+   --  decide if it wants to complete the aborted construct immediately.\n \n    --  Note that the effect of the low-level Abort_Task is not persistent.\n    --  If the target task is not blocked, this wakeup will be missed.\n \n    --  We don't bother calling Abort_Task if this task is aborting itself,\n-   --  since we are inside the RTS and have abort deferred. Similarly, We\n-   --  don't bother to call Abort_Task if T is terminated, since there is\n-   --  no need to abort a terminated task, and it could be dangerous to try\n-   --  if the task has stopped executing.\n-\n-   --  Note that an earlier version of this code had some false reasoning\n-   --  about being able to reliably wake up a task that had suspended on\n-   --  a blocking system call that does not atomically release the task's\n-   --  lock (e.g., UNIX nanosleep, which we once thought could be used to\n-   --  implement delays). That still left the possibility of missed\n-   --  wakeups.\n+   --  since we are inside the RTS and have abort deferred. Similarly, We don't\n+   --  bother to call Abort_Task if T is terminated, since there is no need to\n+   --  abort a terminated task, and it could be dangerous to try if the task\n+   --  has stopped executing.\n+\n+   --  Note that an earlier version of this code had some false reasoning about\n+   --  being able to reliably wake up a task that had suspended on a blocking\n+   --  system call that does not atomically release the task's lock (e.g., UNIX\n+   --  nanosleep, which we once thought could be used to implement delays).\n+   --  That still left the possibility of missed wakeups.\n \n    --  We cannot safely call Vulnerable_Complete_Activation here, since that\n    --  requires locking Self_ID.Parent. The anti-deadlock lock ordering rules\n@@ -436,7 +436,8 @@ package body System.Tasking.Initialization is\n                pragma Assert (False);\n                null;\n \n-            when Runnable =>\n+            when Activating | Runnable =>\n+\n                --  This is needed to cancel an asynchronous protected entry\n                --  call during a requeue with abort.\n \n@@ -454,7 +455,7 @@ package body System.Tasking.Initialization is\n                  AST_Server_Sleep                         =>\n                Wakeup (T, T.Common.State);\n \n-            when Acceptor_Sleep =>\n+            when Acceptor_Sleep | Acceptor_Delay_Sleep =>\n                T.Open_Accepts := null;\n                Wakeup (T, T.Common.State);\n \n@@ -488,13 +489,17 @@ package body System.Tasking.Initialization is\n             --  value will not be set to False except with T also locked,\n             --  inside Exit_One_ATC_Level, so we should not miss wakeups.\n \n-            if T.Common.State = Acceptor_Sleep then\n+            if T.Common.State = Acceptor_Sleep\n+                 or else\n+               T.Common.State = Acceptor_Delay_Sleep\n+            then\n                T.Open_Accepts := null;\n             end if;\n \n          elsif T /= Self_ID and then\n            (T.Common.State = Runnable\n-            or else T.Common.State = Interrupt_Server_Blocked_On_Event_Flag)\n+             or else T.Common.State = Interrupt_Server_Blocked_On_Event_Flag)\n+\n             --  The task is blocked on a system call waiting for the\n             --  completion event. In this case Abort_Task may need to take\n             --  special action in order to succeed. Example system: VMS.\n@@ -519,7 +524,6 @@ package body System.Tasking.Initialization is\n \n       Previous := Null_Task;\n       C := All_Tasks_List;\n-\n       while C /= Null_Task loop\n          if C = T then\n             if Previous = Null_Task then\n@@ -565,7 +569,6 @@ package body System.Tasking.Initialization is\n \n    function Task_Name return String is\n       Self_Id : constant Task_Id := STPO.Self;\n-\n    begin\n       return Self_Id.Common.Task_Image (1 .. Self_Id.Common.Task_Image_Len);\n    end Task_Name;\n@@ -776,6 +779,7 @@ package body System.Tasking.Initialization is\n       New_State  : Entry_Call_State)\n    is\n       Caller : constant Task_Id := Entry_Call.Self;\n+\n    begin\n       pragma Debug (Debug.Trace\n         (Self_ID, \"Wakeup_Entry_Caller\", 'E', Caller));\n@@ -787,8 +791,8 @@ package body System.Tasking.Initialization is\n \n       if Entry_Call.Mode = Asynchronous_Call then\n \n-         --  Abort the caller in his abortable part,\n-         --  but do so only if call has been queued abortably\n+         --  Abort the caller in his abortable part, but do so only if call has\n+         --  been queued abortably.\n \n          if Entry_Call.State >= Was_Abortable or else New_State = Done then\n             Locked_Abort_To_Level (Self_ID, Caller, Entry_Call.Level - 1);\n@@ -804,9 +808,9 @@ package body System.Tasking.Initialization is\n    -----------------------\n \n    --  These are dummies for subprograms that are only needed by certain\n-   --  optional run-time system packages. If they are needed, the soft\n-   --  links will be redirected to the real subprogram by elaboration of\n-   --  the subprogram body where the real subprogram is declared.\n+   --  optional run-time system packages. If they are needed, the soft links\n+   --  will be redirected to the real subprogram by elaboration of the\n+   --  subprogram body where the real subprogram is declared.\n \n    procedure Finalize_Attributes (T : Task_Id) is\n       pragma Unreferenced (T);"}, {"sha": "8cc9d91df25345c22fc6666285c33e9661fd782d", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -62,9 +62,9 @@ package body System.Tasking is\n    function Detect_Blocking return Boolean is\n       GL_Detect_Blocking : Integer;\n       pragma Import (C, GL_Detect_Blocking, \"__gl_detect_blocking\");\n-      --  Global variable exported by the binder generated file.\n-      --  A value equal to 1 indicates that pragma Detect_Blocking is active,\n-      --  while 0 is used for the pragma not being present.\n+      --  Global variable exported by the binder generated file. A value equal\n+      --  to 1 indicates that pragma Detect_Blocking is active, while 0 is used\n+      --  for the pragma not being present.\n \n    begin\n       return GL_Detect_Blocking = 1;\n@@ -101,7 +101,8 @@ package body System.Tasking is\n       Task_Info        : System.Task_Info.Task_Info_Type;\n       Stack_Size       : System.Parameters.Size_Type;\n       T                : Task_Id;\n-      Success          : out Boolean) is\n+      Success          : out Boolean)\n+   is\n    begin\n       T.Common.State := Unactivated;\n \n@@ -128,14 +129,18 @@ package body System.Tasking is\n       T.Common.Global_Task_Lock_Nesting := 0;\n       T.Common.Fall_Back_Handler := null;\n       T.Common.Specific_Handler  := null;\n+      T.Common.Debug_Events :=\n+        (False, False, False, False, False, False, False, False,\n+         False, False, False, False, False, False, False, False);\n+      --  Wouldn't (others => False) be clearer ???\n \n       if T.Common.Parent = null then\n-         --  For the environment task, the adjusted stack size is\n-         --  meaningless. For example, an unspecified Stack_Size means\n-         --  that the stack size is determined by the environment, or\n-         --  can grow dynamically. The Stack_Checking algorithm\n-         --  therefore needs to use the requested size, or 0 in\n-         --  case of an unknown size.\n+\n+         --  For the environment task, the adjusted stack size is meaningless.\n+         --  For example, an unspecified Stack_Size means that the stack size\n+         --  is determined by the environment, or can grow dynamically. The\n+         --  Stack_Checking algorithm therefore needs to use the requested\n+         --  size, or 0 in case of an unknown size.\n \n          T.Common.Compiler_Data.Pri_Stack_Info.Size :=\n             Storage_Elements.Storage_Offset (Stack_Size);\n@@ -161,9 +166,9 @@ package body System.Tasking is\n \n    Main_Priority : Integer;\n    pragma Import (C, Main_Priority, \"__gl_main_priority\");\n-   --  Priority for main task. Note that this is of type Integer, not\n-   --  Priority, because we use the value -1 to indicate the default\n-   --  main priority, and that is of course not in Priority'range.\n+   --  Priority for main task. Note that this is of type Integer, not Priority,\n+   --  because we use the value -1 to indicate the default main priority, and\n+   --  that is of course not in Priority'range.\n \n    Initialized : Boolean := False;\n    --  Used to prevent multiple calls to Initialize"}, {"sha": "5912eac7f37dfc366a785254507d5260d1b040f5", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -128,18 +128,18 @@ package System.Tasking is\n \n    type Task_States is\n      (Unactivated,\n-      --  Task has been created but has not been activated.\n+      --  TCB initialized but not task has not been created.\n       --  It cannot be executing.\n \n+      Activating,\n+      --  Task has been created and is being made Runnable.\n+\n       --  Active states\n       --  For all states from here down, the task has been activated.\n       --  For all states from here down, except for Terminated, the task\n       --  may be executing.\n       --  Activator = null iff it has not yet completed activating.\n \n-      --  For all states from here down,\n-      --  the task has been activated, and may be executing.\n-\n       Runnable,\n       --  Task is not blocked for any reason known to Ada.\n       --  (It may be waiting for a mutex, though.)\n@@ -154,7 +154,10 @@ package System.Tasking is\n       --  Task is waiting for created tasks to complete activation\n \n       Acceptor_Sleep,\n-      --  Task is waiting on an accept or selective wait statement\n+      --  Task is waiting on an accept or select with terminate\n+\n+      Acceptor_Delay_Sleep,\n+      --  Task is waiting on an selective wait statement\n \n       Entry_Caller_Sleep,\n       --  Task is waiting on an entry call\n@@ -389,6 +392,15 @@ package System.Tasking is\n    --  is in general a non-static value that can depend on discriminants\n    --  of the task.\n \n+   type Bit_Array is array (Integer range <>) of Boolean;\n+   pragma Pack (Bit_Array);\n+\n+   subtype Debug_Event_Array is Bit_Array (1 .. 16);\n+\n+   Global_Task_Debug_Event_Set : Boolean := False;\n+   --  Set True when running under debugger control and a task debug\n+   --  event signal has been requested.\n+\n    ----------------------------------------------\n    -- Ada_Task_Control_Block (ATCB) definition --\n    ----------------------------------------------\n@@ -608,6 +620,10 @@ package System.Tasking is\n       --  any of its dependent tasks.\n       --\n       --  Protection: Self.L\n+\n+      Debug_Events : Debug_Event_Array;\n+      --  Word length array of per task debug events, of which 11 kinds are\n+      --  currently defined in System.Tasking.Debugging package.\n    end record;\n \n    ---------------------------------------"}, {"sha": "38f179d0e2e85b8101824c0605810f9290725ebb", "filename": "gcc/ada/s-tasren.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -1525,7 +1525,7 @@ package body System.Tasking.Rendezvous is\n             --  Wait for a normal call and a pending action until the\n             --  Wakeup_Time is reached.\n \n-            Self_Id.Common.State := Acceptor_Sleep;\n+            Self_Id.Common.State := Acceptor_Delay_Sleep;\n \n             --  Try to remove calls to Sleep in the loop below by letting the\n             --  caller a chance of getting ready immediately, using Unlock\n@@ -1557,7 +1557,7 @@ package body System.Tasking.Rendezvous is\n                exit when Self_Id.Open_Accepts = null;\n \n                if Timedout then\n-                  Sleep (Self_Id, Acceptor_Sleep);\n+                  Sleep (Self_Id, Acceptor_Delay_Sleep);\n                else\n                   if Parameters.Runtime_Traces then\n                      Send_Trace_Info (WT_Select,\n@@ -1567,7 +1567,7 @@ package body System.Tasking.Rendezvous is\n                   end if;\n \n                   STPO.Timed_Sleep (Self_Id, Timeout, Mode,\n-                    Acceptor_Sleep, Timedout, Yielded);\n+                    Acceptor_Delay_Sleep, Timedout, Yielded);\n                end if;\n \n                if Timedout then\n@@ -1613,9 +1613,9 @@ package body System.Tasking.Rendezvous is\n             --  3) Spurious wakeup\n \n             Self_Id.Open_Accepts := null;\n-            Self_Id.Common.State := Acceptor_Sleep;\n+            Self_Id.Common.State := Acceptor_Delay_Sleep;\n \n-            STPO.Timed_Sleep (Self_Id, Timeout, Mode, Acceptor_Sleep,\n+            STPO.Timed_Sleep (Self_Id, Timeout, Mode, Acceptor_Delay_Sleep,\n               Timedout, Yielded);\n \n             Self_Id.Common.State := Runnable;"}, {"sha": "5d4e7cbd9ada016d759b4b6238c4ff61c35bd453", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e44c5eab4a57d237cc1078bc0b57018b4915b51/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=5e44c5eab4a57d237cc1078bc0b57018b4915b51", "patch": "@@ -300,7 +300,7 @@ package body System.Tasking.Stages is\n             --  racing ahead.\n \n             if Success then\n-               C.Common.State := Runnable;\n+               C.Common.State := Activating;\n                C.Awake_Count := 1;\n                C.Alive_Count := 1;\n                P.Awake_Count := P.Awake_Count + 1;\n@@ -313,6 +313,21 @@ package body System.Tasking.Stages is\n                   P.Common.Wait_Count := P.Common.Wait_Count + 1;\n                end if;\n \n+               for J in System.Tasking.Debug.Known_Tasks'Range loop\n+                  if System.Tasking.Debug.Known_Tasks (J) = null then\n+                     System.Tasking.Debug.Known_Tasks (J) := C;\n+                     C.Known_Tasks_Index := J;\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               if Global_Task_Debug_Event_Set then\n+                  Debug.Signal_Debug_Event\n+                   (Debug.Debug_Event_Activating, C);\n+               end if;\n+\n+               C.Common.State := Runnable;\n+\n                Unlock (C);\n                Unlock (P);\n \n@@ -1130,6 +1145,11 @@ package body System.Tasking.Stages is\n          Self_ID.Deferral_Level := 0;\n       end if;\n \n+      if Global_Task_Debug_Event_Set then\n+         Debug.Signal_Debug_Event\n+          (Debug.Debug_Event_Run, Self_ID);\n+      end if;\n+\n       begin\n          --  We are separating the following portion of the code in order to\n          --  place the exception handlers in a different block. In this way,\n@@ -1168,8 +1188,18 @@ package body System.Tasking.Stages is\n \n             if Self_ID.Terminate_Alternative then\n                Cause := Normal;\n+\n+               if Global_Task_Debug_Event_Set then\n+                  Debug.Signal_Debug_Event\n+                   (Debug.Debug_Event_Terminated, Self_ID);\n+               end if;\n             else\n                Cause := Abnormal;\n+\n+               if Global_Task_Debug_Event_Set then\n+                  Debug.Signal_Debug_Event\n+                   (Debug.Debug_Event_Abort_Terminated, Self_ID);\n+               end if;\n             end if;\n          when others =>\n             --  ??? Using an E : others here causes CD2C11A to fail on Tru64\n@@ -1194,7 +1224,13 @@ package body System.Tasking.Stages is\n             --  procedure, as well as the associated Exception_Occurrence.\n \n             Cause := Unhandled_Exception;\n+\n             Save_Occurrence (EO, SSL.Get_Current_Excep.all.all);\n+\n+            if Global_Task_Debug_Event_Set then\n+               Debug.Signal_Debug_Event\n+                 (Debug.Debug_Event_Exception_Terminated, Self_ID);\n+            end if;\n       end;\n \n       --  Look for a task termination handler. This code is for all tasks but"}]}