{"sha": "53749ab75aacf4bccdeb129c3c024aa777e8d0f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM3NDlhYjc1YWFjZjRiY2NkZWIxMjljM2MwMjRhYTc3N2U4ZDBmNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-17T01:52:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-17T01:52:18Z"}, "message": "crtbegin.asm (__dso_handle): Mark hidden if the assembler supports it.\n\n        * config/ia64/crtbegin.asm (__dso_handle): Mark hidden if the\n        assembler supports it.\n        (.fini, .init): Use a gp-relative indirect call.\n        (__do_global_dtors_aux): Preserve the gp; rebundle.\n        (__do_frame_setup): Likewise.\n        * config/ia64/crtend.asm (.IA_64.unwind): Don't terminate with -1.\n        (.init): Use a gp-relative indirect call.\n        (__do_global_ctors_aux): Preserve the gp.\n\nFrom-SVN: r33951", "tree": {"sha": "e0927ec2cfbff106b48f31d082ee2e85890c06b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0927ec2cfbff106b48f31d082ee2e85890c06b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53749ab75aacf4bccdeb129c3c024aa777e8d0f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53749ab75aacf4bccdeb129c3c024aa777e8d0f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53749ab75aacf4bccdeb129c3c024aa777e8d0f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53749ab75aacf4bccdeb129c3c024aa777e8d0f7/comments", "author": null, "committer": null, "parents": [{"sha": "f5540cd4aacb0a614929b2afa0912d2f28ba00f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5540cd4aacb0a614929b2afa0912d2f28ba00f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5540cd4aacb0a614929b2afa0912d2f28ba00f1"}], "stats": {"total": 198, "additions": 128, "deletions": 70}, "files": [{"sha": "17dd13d330a2b245fcb96015f4c5f2f34182f9cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53749ab75aacf4bccdeb129c3c024aa777e8d0f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53749ab75aacf4bccdeb129c3c024aa777e8d0f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53749ab75aacf4bccdeb129c3c024aa777e8d0f7", "patch": "@@ -1,3 +1,14 @@\n+2000-05-16  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/crtbegin.asm (__dso_handle): Mark hidden if the\n+\tassembler supports it.\n+\t(.fini, .init): Use a gp-relative indirect call.\n+\t(__do_global_dtors_aux): Preserve the gp; rebundle.\n+\t(__do_frame_setup): Likewise.\n+\t* config/ia64/crtend.asm (.IA_64.unwind): Don't terminate with -1.\n+\t(.init): Use a gp-relative indirect call.\n+\t(__do_global_ctors_aux): Preserve the gp.\n+\n 2000-05-16  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (commit_one_edge_insertion): Be prepared for a return"}, {"sha": "5ccd7525b14f8f8cc88012822f20b698e40fb404", "filename": "gcc/config/ia64/crtbegin.asm", "status": "modified", "additions": 81, "deletions": 51, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53749ab75aacf4bccdeb129c3c024aa777e8d0f7/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53749ab75aacf4bccdeb129c3c024aa777e8d0f7/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm?ref=53749ab75aacf4bccdeb129c3c024aa777e8d0f7", "patch": "@@ -30,29 +30,35 @@ __DTOR_LIST__:\n __EH_FRAME_BEGIN__:\n \n .section .sdata\n-5:\tdata8\t@segrel(6f)\n \t.type dtor_ptr#,@object\n \t.size dtor_ptr#,8\n dtor_ptr:\n \tdata8\t__DTOR_LIST__# + 8\n \n-/* A handle for __cxa_finalize to manage c++ local destructors.  */\n+\t.type segrel_ofs#,@object\n+\t.size segrel_ofs#,8\n+segrel_ofs:\n+\tdata8\t@segrel(.Lsegrel_ref#)\n+\n+\t/* A handle for __cxa_finalize to manage c++ local destructors.  */\n \t.global __dso_handle#\n \t.type __dso_handle#,@object\n \t.size __dso_handle#,8\n #ifdef SHARED\n-.section .data\n+\t.section .data\n __dso_handle:\n \tdata8\t__dso_handle#\n #else\n-.section .bss\n+\t.section .bss\n __dso_handle:\n \tdata8\t0\n #endif\n+#ifdef HAVE_GAS_HIDDEN\n+\t.hidden __dso_handle#\n+#endif\n \n-/* The frame object.  */\n-/* ??? How can we rationally keep this size correct?  */\n-\n+\t/* The frame object.  */\n+\t/* ??? How can we rationally keep this size correct?  */\n .section .bss\n \t.type frame_object#,@object\n \t.size frame_object#,56\n@@ -63,20 +69,29 @@ frame_object:\n /*\n  * Fragment of the ELF _fini routine that invokes our dtor cleanup.\n  *\n- * The code going into .fini is spread all over the place, thus we need\n- * to save gp in order to make sure that other bits don't get into any\n- * nasty surprises by expecting a gp that has suddenly changed.\n+ * We make the call by indirection, because in large programs the \n+ * .fini and .init sections are not in range of the destination, and\n+ * we cannot allow the linker to insert a stub at the end of this\n+ * fragment of the _fini function.  Further, Itanium does not implement\n+ * the long branch instructions, and we do not wish every program to\n+ * trap to the kernel for emulation.\n+ *\n+ * Note that we require __do_global_dtors_aux to preserve the GP,\n+ * so that the next fragment in .fini gets the right value.\n  */\n .section .fini,\"ax\",\"progbits\"\n-\t{ .mfb\n-\t  st8 [r12] = gp, -16\n-\t  br.call.sptk.many b0 = __do_global_dtors_aux#\n+\t{ .mlx\n+\t  movl r2 = @gprel(__do_global_dtors_aux#)\n \t  ;;\n \t}\n-\t{ .mmi\n-\t  adds r12 = 16, r12\n+\t{ .mii\n+\t  nop.m 0\n+\t  add r2 = r2, gp\n \t  ;;\n-\t  ld8 gp = [r12]\n+\t  mov b6 = r2\n+\t}\n+\t{ .bbb\n+\t  br.call.sptk.many b0 = b6\n \t  ;;\n \t}\n \n@@ -85,15 +100,18 @@ frame_object:\n  */\n \n .section .init,\"ax\",\"progbits\"\n-\t{ .mfb\n-\t  st8 [r12] = gp, -16\n-\t  br.call.sptk.many b0 = __do_frame_setup#\n+\t{ .mlx\n+\t  movl r2 = @gprel(__do_frame_setup#)\n \t  ;;\n \t}\n-\t{ .mmi\n-\t  adds r12 = 16, r12\n+\t{ .mii\n+\t  nop.m 0\n+\t  add r2 = r2, gp\n \t  ;;\n-\t  ld8 gp = [r12]\n+\t  mov b6 = r2\n+\t}\n+\t{ .bbb\n+\t  br.call.sptk.many b0 = b6\n \t  ;;\n \t}\n \n@@ -107,7 +125,11 @@ __do_global_dtors_aux:\n \t  addl loc0 = @gprel(dtor_ptr#), gp\n \t  mov loc1 = b0\n \t}\n-\tmov loc2 = gp\n+\t{ .mib\n+\t  mov loc2 = gp\n+\t  br.sptk.few 1f\n+\t  ;;\n+\t}\n #else\n \t/*\n \t\tif (__cxa_finalize)\n@@ -119,7 +141,6 @@ __do_global_dtors_aux:\n \t  addl r16 = @ltoff(@fptr(__cxa_finalize#)), gp\n \t  ;;\n \t}\n-\tmov loc2 = gp\n \t{ .mmi\n \t  ld8 r16 = [r16]\n \t  ;;\n@@ -133,22 +154,25 @@ __do_global_dtors_aux:\n \t  mov loc1 = b0\n \t  ;;\n \t}\n-\t{ .mib\n-(p7)\t  ld8 gp = [r16]\n+\t{ .mfi\n+\t  mov loc2 = gp\n (p7)\t  mov b6 = r18\n+\t}\n+\t{\n+\t  .mfb\n+(p7)\t  ld8 gp = [r16]\n (p7)\t  br.call.sptk.many b0 = b6\n \t}\n+\t{ .mfb\n+\t  br.sptk.few 1f\n+\t}\n #endif\n \t/*\n \t\tdo {\n \t\t  dtor_ptr++;\n \t\t  (*(dtor_ptr-1)) ();\n \t\t} while (dtor_ptr);\n \t*/\n-\t{ .bbb\n-\t  br.sptk.few 1f\n-\t  ;;\n-\t}\n 0:\n \t{ .mmi\n \t  st8 [loc0] = r15\n@@ -171,13 +195,13 @@ __do_global_dtors_aux:\n \t  cmp.ne p6, p0 = r0, r16\n (p6)\t  br.cond.sptk.few 0b\n \t}\n-\tmov gp = loc2\n-\t;;\n \t/*\n \t\tif (__deregister_frame_info)\n \t\t  __deregister_frame_info(__EH_FRAME_BEGIN__)\n \t*/\n-\t{ .mii\n+\t{ .mmi\n+\t  mov gp = loc2\n+\t  ;;\n \t  addl r16 = @ltoff(@fptr(__deregister_frame_info#)), gp\n \t  addl out0 = @ltoff(__EH_FRAME_BEGIN__#), gp\n \t  ;;\n@@ -199,6 +223,7 @@ __do_global_dtors_aux:\n (p7)\t  br.call.sptk.many b0 = b6\n \t}\n \t{ .mii\n+\t  mov gp = loc2\n \t  mov b0 = loc1\n \t  mov ar.pfs = loc3\n \t}\n@@ -215,45 +240,50 @@ __do_frame_setup:\n \t\t  __register_frame_info(__EH_FRAME_BEGIN__)\n \t*/\n \t{ .mii\n-\t  alloc loc3 = ar.pfs, 0, 4, 2, 0\n+\t  alloc loc2 = ar.pfs, 0, 3, 2, 0\n \t  addl r16 = @ltoff(@fptr(__register_frame_info#)), gp\n \t  addl out0 = @ltoff(__EH_FRAME_BEGIN__#), gp\n-\t  ;;\n \t}\n-\taddl out1 = @ltoff(frame_object#), gp\n-\t;;\n \t/* frame_object.pc_base = segment_base_offset;\n-\t      pc_base is at offset 0 within frame_object.  */\n-6:\n-\tmov loc0 = ip\n-\taddl loc1 = @gprel(5b), gp\n-\t;;\n-\tld8 loc1 = [loc1]\n-\tld8 out1 = [out1]\n-\t;;\n-\tsub loc2 = loc0, loc1\n-\t;;\n-\tst8 [out1] = loc2\n+\t   pc_base is at offset 0 within frame_object.  */\n+.Lsegrel_ref:\n+\t{ .mmi\n+\t  addl out1 = @ltoff(frame_object#), gp\n+\t  ;;\n+\t  addl r2 = @gprel(segrel_ofs#), gp\n+\t  mov r3 = ip\n+\t  ;;\n+\t}\n \t{ .mmi\n+\t  ld8 r2 = [r2]\n \t  ld8 r16 = [r16]\n-\t  ld8 out0 = [out0]  \n \t  mov loc0 = b0\n \t  ;;\n \t}\n-\t{ .mmi\n+\t{ .mii\n+\t  ld8 out1 = [out1]\n \t  cmp.ne p7, p0 = r0, r16\n+\t  sub r3 = r3, r2\n \t  ;;\n+\t}\n+\t{ .mmi\n+\t  st8 [out1] = r3 \n (p7)\t  ld8 r18 = [r16], 8\n+\t  mov loc1 = gp\n \t  ;;\n \t}\n+\t{ .mfb\n+\t  ld8 out0 = [out0]  \n+\t}\n \t{ .mib\n (p7)\t  ld8 gp = [r16]\n (p7)\t  mov b6 = r18\n (p7)\t  br.call.sptk.many b0 = b6\n \t}\n \t{ .mii\n+\t  mov gp = loc1\n \t  mov b0 = loc0\n-\t  mov ar.pfs = loc3\n+\t  mov ar.pfs = loc2\n \t}\n \t{ .bbb\n \t  br.ret.sptk.many b0"}, {"sha": "4457298ecd4c4a614c306bc4d638b1861269fec2", "filename": "gcc/config/ia64/crtend.asm", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53749ab75aacf4bccdeb129c3c024aa777e8d0f7/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53749ab75aacf4bccdeb129c3c024aa777e8d0f7/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtend.asm?ref=53749ab75aacf4bccdeb129c3c024aa777e8d0f7", "patch": "@@ -28,25 +28,33 @@ __DTOR_END__:\n \n .section .IA_64.unwind\n __EH_FRAME_END__:\n-\tdata8\t-1\n \n /*\n  * Fragment of the ELF _init routine that invokes our dtor cleanup.\n  *\n- * The code going into .init is spread all over the place, thus we need\n- * to save gp in order to make sure that other bits don't get into any\n- * nasty surprises by expecting a gp that has suddenly changed.\n+ * We make the call by indirection, because in large programs the \n+ * .fini and .init sections are not in range of the destination, and\n+ * we cannot allow the linker to insert a stub at the end of this\n+ * fragment of the _fini function.  Further, Itanium does not implement\n+ * the long branch instructions, and we do not wish every program to\n+ * trap to the kernel for emulation.\n+ *\n+ * Note that we require __do_global_ctors_aux to preserve the GP,\n+ * so that the next fragment in .fini gets the right value.\n  */\n .section .init,\"ax\",\"progbits\"\n-\t{ .mfb\n-\t  st8 [r12] = gp, -16\n-\t  br.call.sptk.many b0 = __do_global_ctors_aux\n+\t{ .mlx\n+\t  movl r2 = @gprel(__do_global_ctors_aux#)\n \t  ;;\n \t}\n-\t{ .mmi\n-\t  adds r12 = 16, r12\n+\t{ .mii\n+\t  nop.m 0\n+\t  add r2 = r2, gp\n \t  ;;\n-\t  ld8 gp = [r12]\n+\t  mov b6 = r2\n+\t}\n+\t{ .bbb\n+\t  br.call.sptk.many b0 = b6\n \t  ;;\n \t}\n \n@@ -59,34 +67,43 @@ __do_global_ctors_aux:\n \t\t  (*p) ();\n \t*/\n \t{ .mii\n-\t  alloc loc2 = ar.pfs, 0, 4, 0, 0\n+\t  alloc loc4 = ar.pfs, 0, 5, 0, 0\n \t  addl loc0 = @ltoff(__CTOR_END__# - 8), gp\n-\t  cmp.ne p6, p0 = r0, r0\n+\t  mov loc1 = b0\n \t  ;;\n \t}\n-\t{ .mfi\n+\t{ .mmi\n \t  ld8 loc0 = [loc0]\n-\t  mov loc1 = b0\n+\t  ;;\n+\t  ld8 loc3 = [loc0], -8\n+\t  mov loc2 = gp\n+\t  ;;\n+\t}\n+\t{ .mfb\n+\t  cmp.eq p6, p0 = -1, loc3\n+(p6)\t  br.cond.spnt.few 2f\n \t}\n 0:\n \t{ .mmi\n-(p6)\t  ld8 r15 = [loc3], 8\n+\t  ld8 r15 = [loc3], 8\n \t  ;;\n-(p6)\t  ld8 gp = [loc3]\n-(p6)\t  mov b6 = r15\n+\t  ld8 gp = [loc3]\n+\t  mov b6 = r15\n \t}\n \t{ .mfb\n \t  ld8 loc3 = [loc0], -8\n-(p6)\t  br.call.sptk.many b0 = b6\n+\t  br.call.sptk.many b0 = b6\n \t  ;;\n \t}\n \t{ .mfb\n \t  cmp.ne p6, p0 = -1, loc3\n (p6)\t  br.cond.sptk.few 0b\n \t}\n+2:\n \t{ .mii\n-\t  mov ar.pfs = loc2\n+\t  mov gp = loc2\n \t  mov b0 = loc1\n+\t  mov ar.pfs = loc4\n \t}\n \t{ .bbb\n \t  br.ret.sptk.many b0"}]}