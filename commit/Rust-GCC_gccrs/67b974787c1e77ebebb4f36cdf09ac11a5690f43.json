{"sha": "67b974787c1e77ebebb4f36cdf09ac11a5690f43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdiOTc0Nzg3YzFlNzdlYmViYjRmMzZjZGYwOWFjMTFhNTY5MGY0Mw==", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2016-10-09T04:48:50Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh3492@gcc.gnu.org", "date": "2016-10-09T04:48:50Z"}, "message": "ipa-cp.c (ipcp_alignment_lattice): Remove.\n\n2016-10-09  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n\n\t* ipa-cp.c (ipcp_alignment_lattice): Remove.\n\t(ipcp_param_lattices): Remove field alignment.\n\t(print_all_lattices): Remove call to ipcp_alignment_lattice::print.\n\t(set_all_contains_variable): Remove call to\n\tipcp_alignment_lattice::set_to_bottom.\n\t(initialize_node_lattices): Likewise.\n\t(propagate_alignment_accross_jump_function): Remove.\n\t(propagate_constants_accross_call): Remove call to\n\tpropagate_alignment_accross_jump_function.\n\t(ipcp_store_alignment_results): Remove.\n\t(ipcp_driver): Remove call to ipcp_store_alignment_results.\n\t(propagate_bits_accross_jump_function): Handle ancestor jump function.\n\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Remove\n\tpretty-printing of alignment jump function.\n\t(ipa_set_jf_unknown): Remove assignment to jfunc->alignment.known.\n\t(ipa_compute_jump_functions_for_edge): Adjust ipa_bits jump function for\n\talignments and remove computing ipa_alignment jump function.\n\t(ipa_node_params_t::duplicate): Remove copying of src_trans->alignments.\n\t(ipa_write_jump_functions): Remove streaming for ipa_alignment.\n\t(ipa_read_jump_function): Remove reading of ipa_alignment.\n\t(write_ipcp_transformation_info): Remove streaming for alignment\n\tpropagation summary.\n\t(read_ipcp_transformation_info): Remove reading of alignment\n\tpropagation summary. \n\t(ipcp_update_alignments): Remove.\n\t(ipcp_update_bits): Adjust to set alignment for parameters of pointer\n\ttype.\n\t(ipcp_transform_function): Remove call to ipcp_update_alignments()\n\tand remove assignment to (*ipcp_transformations)[node->uid].alignments.\n\t* ipa-prop.h (ipa_alignment): Remove.\n\t(ipa_jump_func): Remove field alignment.\n\t(ipcp_transformation_summary): Remove field alignments. \n\t* doc/invoke.texi: Mark fipa-cp-alignment as obsolete.\n\t* opts.c (default_options_table): Remove entry for fipa-cp-alignment.\n\t(enable_fdo_optimizations): Remove checking for fipa-cp-alignment.\n\ntestsuite/\n\t* gcc.dg/ipa/propalign-1.c: Adjust scan-ipa-dump.\n\t* gcc.dg/ipa/propalign-2.c: Likewise\n\t* gcc.dg/ipa/propalign-3.c: Likewise.\n\t* gcc.dg/ipa/propalign-4.c: Likewise.\n\t* gcc.dg/ipa/propalign-5.c: Likewise.\n\nFrom-SVN: r240898", "tree": {"sha": "152594ddc68b650d1a9417e3b3ee8df10731b94a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/152594ddc68b650d1a9417e3b3ee8df10731b94a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67b974787c1e77ebebb4f36cdf09ac11a5690f43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67b974787c1e77ebebb4f36cdf09ac11a5690f43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67b974787c1e77ebebb4f36cdf09ac11a5690f43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67b974787c1e77ebebb4f36cdf09ac11a5690f43/comments", "author": null, "committer": null, "parents": [{"sha": "e525cfa7e30afee5c4c5a4224c5c340ae95cf75f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e525cfa7e30afee5c4c5a4224c5c340ae95cf75f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e525cfa7e30afee5c4c5a4224c5c340ae95cf75f"}], "stats": {"total": 619, "additions": 131, "deletions": 488}, "files": [{"sha": "9659fbf7f5d16ad7c61b662f43a6a14b17e7f031", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -1,3 +1,41 @@\n+2016-10-09  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\t* ipa-cp.c (ipcp_alignment_lattice): Remove.\n+\t(ipcp_param_lattices): Remove field alignment.\n+\t(print_all_lattices): Remove call to ipcp_alignment_lattice::print.\n+\t(set_all_contains_variable): Remove call to\n+\tipcp_alignment_lattice::set_to_bottom.\n+\t(initialize_node_lattices): Likewise.\n+\t(propagate_alignment_accross_jump_function): Remove.\n+\t(propagate_constants_accross_call): Remove call to\n+\tpropagate_alignment_accross_jump_function.\n+\t(ipcp_store_alignment_results): Remove.\n+\t(ipcp_driver): Remove call to ipcp_store_alignment_results.\n+\t(propagate_bits_accross_jump_function): Handle ancestor jump function.\n+\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Remove\n+\tpretty-printing of alignment jump function.\n+\t(ipa_set_jf_unknown): Remove assignment to jfunc->alignment.known.\n+\t(ipa_compute_jump_functions_for_edge): Adjust ipa_bits jump function for\n+\talignments and remove computing ipa_alignment jump function.\n+\t(ipa_node_params_t::duplicate): Remove copying of src_trans->alignments.\n+\t(ipa_write_jump_functions): Remove streaming for ipa_alignment.\n+\t(ipa_read_jump_function): Remove reading of ipa_alignment.\n+\t(write_ipcp_transformation_info): Remove streaming for alignment\n+\tpropagation summary.\n+\t(read_ipcp_transformation_info): Remove reading of alignment\n+\tpropagation summary. \n+\t(ipcp_update_alignments): Remove.\n+\t(ipcp_update_bits): Adjust to set alignment for parameters of pointer\n+\ttype.\n+\t(ipcp_transform_function): Remove call to ipcp_update_alignments()\n+\tand remove assignment to (*ipcp_transformations)[node->uid].alignments.\n+\t* ipa-prop.h (ipa_alignment): Remove.\n+\t(ipa_jump_func): Remove field alignment.\n+\t(ipcp_transformation_summary): Remove field alignments. \n+\t* doc/invoke.texi: Mark fipa-cp-alignment as obsolete.\n+\t* opts.c (default_options_table): Remove entry for fipa-cp-alignment.\n+\t(enable_fdo_optimizations): Remove checking for fipa-cp-alignment.\n+\n 2016-10-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc.h (FIXED_REGISTERS): Add %icc."}, {"sha": "b7a32b663ac83975c6d46009a9f6317e6224cbfe", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -7679,6 +7679,7 @@ parameters to support better vectorization and string operations.\n \n This flag is enabled by default at @option{-O2} and @option{-Os}.  It\n requires that @option{-fipa-cp} is enabled.\n+@option{-fipa-cp-alignment} is obsolete, use @option{-fipa-bit-cp} instead.\n \n @item -fipa-bit-cp\n @opindex -fipa-bit-cp"}, {"sha": "1dc5cb6749ab4f0d674f4ba70e93a7ebb539223c", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 18, "deletions": 293, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -238,36 +238,6 @@ class ipcp_agg_lattice : public ipcp_lattice<tree>\n   struct ipcp_agg_lattice *next;\n };\n \n-/* Lattice of pointer alignment.  Unlike the previous types of lattices, this\n-   one is only capable of holding one value.  */\n-\n-class ipcp_alignment_lattice\n-{\n-public:\n-  /* If bottom and top are both false, these two fields hold values as given by\n-     ptr_info_def and get_pointer_alignment_1.  */\n-  unsigned align;\n-  unsigned misalign;\n-\n-  inline bool bottom_p () const;\n-  inline bool top_p () const;\n-  inline bool set_to_bottom ();\n-  bool meet_with (unsigned new_align, unsigned new_misalign);\n-  bool meet_with (const ipcp_alignment_lattice &other, HOST_WIDE_INT offset);\n-  void print (FILE * f);\n-private:\n-  /* If set, this lattice is bottom and all other fields should be\n-     disregarded.  */\n-  bool bottom;\n-  /* If bottom and not_top are false, the lattice is TOP.  If not_top is true,\n-     the known alignment is stored in the fields align and misalign.  The field\n-     is negated so that memset to zero initializes the lattice to TOP\n-     state.  */\n-  bool not_top;\n-\n-  bool meet_with_1 (unsigned new_align, unsigned new_misalign);\n-};\n-\n /* Lattice of known bits, only capable of holding one value.\n    Bitwise constant propagation propagates which bits of a\n    value are constant.\n@@ -354,8 +324,6 @@ class ipcp_param_lattices\n   ipcp_lattice<ipa_polymorphic_call_context> ctxlat;\n   /* Lattices describing aggregate parts.  */\n   ipcp_agg_lattice *aggs;\n-  /* Lattice describing known alignment.  */\n-  ipcp_alignment_lattice alignment;\n   /* Lattice describing known bits.  */\n   ipcp_bits_lattice bits_lattice;\n   /* Lattice describing value range.  */\n@@ -534,19 +502,6 @@ ipcp_lattice<valtype>::print (FILE * f, bool dump_sources, bool dump_benefits)\n     fprintf (f, \"\\n\");\n }\n \n-/* Print alignment lattice to F.  */\n-\n-void\n-ipcp_alignment_lattice::print (FILE * f)\n-{\n-  if (top_p ())\n-    fprintf (f, \"         Alignment unknown (TOP)\\n\");\n-  else if (bottom_p ())\n-    fprintf (f, \"         Alignment unusable (BOTTOM)\\n\");\n-  else\n-    fprintf (f, \"         Alignment %u, misalignment %u\\n\", align, misalign);\n-}\n-\n void\n ipcp_bits_lattice::print (FILE *f)\n {\n@@ -595,7 +550,6 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n \t  plats->itself.print (f, dump_sources, dump_benefits);\n \t  fprintf (f, \"         ctxs: \");\n \t  plats->ctxlat.print (f, dump_sources, dump_benefits);\n-\t  plats->alignment.print (f);\n \t  plats->bits_lattice.print (f);\n \t  fprintf (f, \"         \");\n \t  plats->m_value_range.print (f);\n@@ -922,38 +876,6 @@ set_agg_lats_contain_variable (struct ipcp_param_lattices *plats)\n   return ret;\n }\n \n-/* Return true if alignment information in the lattice is yet unknown.  */\n-\n-bool\n-ipcp_alignment_lattice::top_p () const\n-{\n-  return !bottom && !not_top;\n-}\n-\n-/* Return true if alignment information in the lattice is known to be\n-   unusable.  */\n-\n-bool\n-ipcp_alignment_lattice::bottom_p () const\n-{\n-  return bottom;\n-}\n-\n-/* Set alignment information in the lattice to bottom.  Return true if it\n-   previously was in a different state.  */\n-\n-bool\n-ipcp_alignment_lattice::set_to_bottom ()\n-{\n-  if (bottom_p ())\n-    return false;\n-  bottom = true;\n-  return true;\n-}\n-\n-/* Meet the current value of the lattice with described by OTHER\n-   lattice.  */\n-\n bool\n ipcp_vr_lattice::meet_with (const ipcp_vr_lattice &other)\n {\n@@ -1022,82 +944,6 @@ ipcp_vr_lattice::set_to_bottom ()\n   return true;\n }\n \n-/* Meet the current value of the lattice with alignment described by NEW_ALIGN\n-   and NEW_MISALIGN, assuming that we know the current value is neither TOP nor\n-   BOTTOM.  Return true if the value of lattice has changed.  */\n-\n-bool\n-ipcp_alignment_lattice::meet_with_1 (unsigned new_align, unsigned new_misalign)\n-{\n-  gcc_checking_assert (new_align != 0);\n-  if (align == new_align && misalign == new_misalign)\n-    return false;\n-\n-  bool changed = false;\n-  if (align > new_align)\n-    {\n-      align = new_align;\n-      misalign = misalign % new_align;\n-      changed = true;\n-    }\n-  if (misalign != (new_misalign % align))\n-    {\n-      int diff = abs ((int) misalign - (int) (new_misalign % align));\n-      align = least_bit_hwi (diff);\n-      if (align)\n-\tmisalign = misalign % align;\n-      else\n-\tset_to_bottom ();\n-      changed = true;\n-    }\n-  gcc_checking_assert (bottom_p () || align != 0);\n-  return changed;\n-}\n-\n-/* Meet the current value of the lattice with alignment described by NEW_ALIGN\n-   and NEW_MISALIGN.  Return true if the value of lattice has changed.  */\n-\n-bool\n-ipcp_alignment_lattice::meet_with (unsigned new_align, unsigned new_misalign)\n-{\n-  gcc_assert (new_align != 0);\n-  if (bottom_p ())\n-    return false;\n-  if (top_p ())\n-    {\n-      not_top = true;\n-      align = new_align;\n-      misalign = new_misalign;\n-      return true;\n-    }\n-  return meet_with_1 (new_align, new_misalign);\n-}\n-\n-/* Meet the current value of the lattice with OTHER, taking into account that\n-   OFFSET has been added to the pointer value.  Return true if the value of\n-   lattice has changed.  */\n-\n-bool\n-ipcp_alignment_lattice::meet_with (const ipcp_alignment_lattice &other,\n-\t\t\t\t   HOST_WIDE_INT offset)\n-{\n-  if (other.bottom_p ())\n-    return set_to_bottom ();\n-  if (bottom_p () || other.top_p ())\n-    return false;\n-\n-  unsigned adjusted_misalign = (other.misalign + offset) % other.align;\n-  if (top_p ())\n-    {\n-      not_top = true;\n-      align = other.align;\n-      misalign = adjusted_misalign;\n-      return true;\n-    }\n-\n-  return meet_with_1 (other.align, adjusted_misalign);\n-}\n-\n /* Set lattice value to bottom, if it already isn't the case.  */\n \n bool\n@@ -1253,7 +1099,6 @@ set_all_contains_variable (struct ipcp_param_lattices *plats)\n   ret = plats->itself.set_contains_variable ();\n   ret |= plats->ctxlat.set_contains_variable ();\n   ret |= set_agg_lats_contain_variable (plats);\n-  ret |= plats->alignment.set_to_bottom ();\n   ret |= plats->bits_lattice.set_to_bottom ();\n   ret |= plats->m_value_range.set_to_bottom ();\n   return ret;\n@@ -1342,7 +1187,6 @@ initialize_node_lattices (struct cgraph_node *node)\n \t      plats->itself.set_to_bottom ();\n \t      plats->ctxlat.set_to_bottom ();\n \t      set_agg_lats_to_bottom (plats);\n-\t      plats->alignment.set_to_bottom ();\n \t      plats->bits_lattice.set_to_bottom ();\n \t      plats->m_value_range.set_to_bottom ();\n \t    }\n@@ -1910,59 +1754,6 @@ propagate_context_accross_jump_function (cgraph_edge *cs,\n   return ret;\n }\n \n-/* Propagate alignments across jump function JFUNC that is associated with\n-   edge CS and update DEST_LAT accordingly.  */\n-\n-static bool\n-propagate_alignment_accross_jump_function (cgraph_edge *cs,\n-\t\t\t\t\t   ipa_jump_func *jfunc,\n-\t\t\t\t\t   ipcp_alignment_lattice *dest_lat)\n-{\n-  if (dest_lat->bottom_p ())\n-    return false;\n-\n-  if (jfunc->type == IPA_JF_PASS_THROUGH\n-\t   || jfunc->type == IPA_JF_ANCESTOR)\n-    {\n-      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n-      HOST_WIDE_INT offset = 0;\n-      int src_idx;\n-\n-      if (jfunc->type == IPA_JF_PASS_THROUGH)\n-\t{\n-\t  enum tree_code op = ipa_get_jf_pass_through_operation (jfunc);\n-\t  if (op != NOP_EXPR)\n-\t    {\n-\t      if (op != POINTER_PLUS_EXPR\n-\t\t  && op != PLUS_EXPR)\n-\t\treturn dest_lat->set_to_bottom ();\n-\t      tree operand = ipa_get_jf_pass_through_operand (jfunc);\n-\t      if (!tree_fits_shwi_p (operand))\n-\t\treturn dest_lat->set_to_bottom ();\n-\t      offset = tree_to_shwi (operand);\n-\t    }\n-\t  src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n-\t}\n-      else\n-\t{\n-\t  src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n-\t  offset = ipa_get_jf_ancestor_offset (jfunc) / BITS_PER_UNIT;\n-\t}\n-\n-      struct ipcp_param_lattices *src_lats;\n-      src_lats = ipa_get_parm_lattices (caller_info, src_idx);\n-      return dest_lat->meet_with (src_lats->alignment, offset);\n-    }\n-  else\n-    {\n-      if (jfunc->alignment.known)\n-\treturn dest_lat->meet_with (jfunc->alignment.align,\n-\t\t\t\t    jfunc->alignment.misalign);\n-      else\n-\treturn dest_lat->set_to_bottom ();\n-    }\n-}\n-\n /* Propagate bits across jfunc that is associated with\n    edge cs and update dest_lattice accordingly.  */\n \n@@ -1993,16 +1784,29 @@ propagate_bits_accross_jump_function (cgraph_edge *cs, int idx, ipa_jump_func *j\n   unsigned precision = TYPE_PRECISION (parm_type);\n   signop sgn = TYPE_SIGN (parm_type);\n \n-  if (jfunc->type == IPA_JF_PASS_THROUGH)\n+  if (jfunc->type == IPA_JF_PASS_THROUGH\n+      || jfunc->type == IPA_JF_ANCESTOR)\n     {\n       struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n-      enum tree_code code = ipa_get_jf_pass_through_operation (jfunc);\n       tree operand = NULL_TREE;\n+      enum tree_code code;\n+      unsigned src_idx;\n \n-      if (code != NOP_EXPR)\n-\toperand = ipa_get_jf_pass_through_operand (jfunc);\n+      if (jfunc->type == IPA_JF_PASS_THROUGH)\n+\t{\n+\t  code = ipa_get_jf_pass_through_operation (jfunc);\n+\t  src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n+\t  if (code != NOP_EXPR)\n+\t    operand = ipa_get_jf_pass_through_operand (jfunc);\n+\t}\n+      else\n+\t{\n+\t  code = POINTER_PLUS_EXPR; \n+\t  src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n+\t  unsigned HOST_WIDE_INT offset = ipa_get_jf_ancestor_offset (jfunc) / BITS_PER_UNIT;\n+\t  operand = build_int_cstu (size_type_node, offset);\n+\t}\n \n-      int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n       struct ipcp_param_lattices *src_lats\n \t= ipa_get_parm_lattices (caller_info, src_idx);\n \n@@ -2426,8 +2230,6 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n \t\t\t\t\t\t\t &dest_plats->itself);\n \t  ret |= propagate_context_accross_jump_function (cs, jump_func, i,\n \t\t\t\t\t\t\t  &dest_plats->ctxlat);\n-\t  ret |= propagate_alignment_accross_jump_function (cs, jump_func,\n-\t\t\t\t\t\t\t &dest_plats->alignment);\n \t  ret |= propagate_bits_accross_jump_function (cs, i, jump_func,\n \t\t\t\t\t\t       &dest_plats->bits_lattice);\n \t  ret |= propagate_aggs_accross_jump_function (cs, jump_func,\n@@ -4997,81 +4799,6 @@ ipcp_decision_stage (struct ipa_topo_info *topo)\n     }\n }\n \n-/* Look up all alignment information that we have discovered and copy it over\n-   to the transformation summary.  */\n-\n-static void\n-ipcp_store_alignment_results (void)\n-{\n-  cgraph_node *node;\n-\n-  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n-  {\n-    ipa_node_params *info = IPA_NODE_REF (node);\n-    bool dumped_sth = false;\n-    bool found_useful_result = false;\n-\n-    if (!opt_for_fn (node->decl, flag_ipa_cp_alignment))\n-      {\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"Not considering %s for alignment discovery \"\n-\t\t   \"and propagate; -fipa-cp-alignment: disabled.\\n\",\n-\t\t   node->name ());\n-\tcontinue;\n-      }\n-\n-   if (info->ipcp_orig_node)\n-      info = IPA_NODE_REF (info->ipcp_orig_node);\n-\n-   unsigned count = ipa_get_param_count (info);\n-   for (unsigned i = 0; i < count ; i++)\n-     {\n-       ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-       if (!plats->alignment.bottom_p ()\n-\t   && !plats->alignment.top_p ())\n-\t {\n-\t   gcc_checking_assert (plats->alignment.align > 0);\n-\t   found_useful_result = true;\n-\t   break;\n-\t }\n-     }\n-   if (!found_useful_result)\n-     continue;\n-\n-   ipcp_grow_transformations_if_necessary ();\n-   ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n-   vec_safe_reserve_exact (ts->alignments, count);\n-\n-   for (unsigned i = 0; i < count ; i++)\n-     {\n-       ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-       ipa_alignment al;\n-\n-       if (!plats->alignment.bottom_p ()\n-\t   && !plats->alignment.top_p ())\n-\t {\n-\t   al.known = true;\n-\t   al.align = plats->alignment.align;\n-\t   al.misalign = plats->alignment.misalign;\n-\t }\n-       else\n-\t al.known = false;\n-\n-       ts->alignments->quick_push (al);\n-       if (!dump_file || !al.known)\n-\t continue;\n-       if (!dumped_sth)\n-\t {\n-\t   fprintf (dump_file, \"Propagated alignment info for function %s/%i:\\n\",\n-\t\t    node->name (), node->order);\n-\t   dumped_sth = true;\n-\t }\n-       fprintf (dump_file, \"  param %i: align: %u, misalign: %u\\n\",\n-\t\ti, al.align, al.misalign);\n-     }\n-  }\n-}\n-\n /* Look up all the bits information that we have discovered and copy it over\n    to the transformation summary.  */\n \n@@ -5246,8 +4973,6 @@ ipcp_driver (void)\n   ipcp_propagate_stage (&topo);\n   /* Decide what constant propagation and cloning should be performed.  */\n   ipcp_decision_stage (&topo);\n-  /* Store results of alignment propagation. */\n-  ipcp_store_alignment_results ();\n   /* Store results of bits propagation.  */\n   ipcp_store_bits_results ();\n   /* Store results of value range propagation.  */"}, {"sha": "a981efd5e62145def28afa1a872fb9b72fc9fc0f", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 60, "deletions": 169, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -294,15 +294,6 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t  ctx->dump (dump_file);\n \t}\n \n-      if (jump_func->alignment.known)\n-\t{\n-\t  fprintf (f, \"         Alignment: %u, misalignment: %u\\n\",\n-\t\t   jump_func->alignment.align,\n-\t\t   jump_func->alignment.misalign);\n-\t}\n-      else\n-\tfprintf (f, \"         Unknown alignment\\n\");\n-\n       if (jump_func->bits.known)\n \t{\n \t  fprintf (f, \"         value: \"); print_hex (jump_func->bits.value, f);\n@@ -402,7 +393,6 @@ static void\n ipa_set_jf_unknown (struct ipa_jump_func *jfunc)\n {\n   jfunc->type = IPA_JF_UNKNOWN;\n-  jfunc->alignment.known = false;\n   jfunc->bits.known = false;\n   jfunc->vr_known = false;\n }\n@@ -1678,25 +1668,7 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t    useful_context = true;\n \t}\n \n-      if (POINTER_TYPE_P (TREE_TYPE(arg)))\n-\t{\n-\t  unsigned HOST_WIDE_INT hwi_bitpos;\n-\t  unsigned align;\n-\n-\t  get_pointer_alignment_1 (arg, &align, &hwi_bitpos);\n-\t  if (align > BITS_PER_UNIT\n-\t      && align % BITS_PER_UNIT == 0\n-\t      && hwi_bitpos % BITS_PER_UNIT == 0)\n-\t    {\n-\t      jfunc->alignment.known = true;\n-\t      jfunc->alignment.align = align / BITS_PER_UNIT;\n-\t      jfunc->alignment.misalign = hwi_bitpos / BITS_PER_UNIT;\n-\t    }\n-\t  else\n-\t    gcc_assert (!jfunc->alignment.known);\n-\t  gcc_assert (!jfunc->vr_known);\n-\t}\n-      else\n+      if (!POINTER_TYPE_P (TREE_TYPE (arg)))\n \t{\n \t  wide_int min, max;\n \t  value_range_type type;\n@@ -1723,7 +1695,6 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t    }\n \t  else\n \t    gcc_assert (!jfunc->vr_known);\n-\t  gcc_assert (!jfunc->alignment.known);\n \t}\n \n       if (INTEGRAL_TYPE_P (TREE_TYPE (arg))\n@@ -1743,6 +1714,17 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t      jfunc->bits.mask = 0;\n \t    }\n \t}\n+      else if (POINTER_TYPE_P (TREE_TYPE (arg)))\n+\t{\n+\t  unsigned HOST_WIDE_INT bitpos;\n+\t  unsigned align;\n+\n+\t  jfunc->bits.known = true;\n+\t  get_pointer_alignment_1 (arg, &align, &bitpos);\n+\t  jfunc->bits.mask = wi::mask<widest_int>(TYPE_PRECISION (TREE_TYPE (arg)), false)\n+\t\t\t     .and_not (align / BITS_PER_UNIT - 1);\n+\t  jfunc->bits.value = bitpos / BITS_PER_UNIT;\n+\t}\n       else\n \tgcc_assert (!jfunc->bits.known);\n \n@@ -3755,18 +3737,9 @@ ipa_node_params_t::duplicate(cgraph_node *src, cgraph_node *dst,\n     {\n       ipcp_grow_transformations_if_necessary ();\n       src_trans = ipcp_get_transformation_summary (src);\n-      const vec<ipa_alignment, va_gc> *src_alignments = src_trans->alignments;\n       const vec<ipa_vr, va_gc> *src_vr = src_trans->m_vr;\n-      vec<ipa_alignment, va_gc> *&dst_alignments\n-\t= ipcp_get_transformation_summary (dst)->alignments;\n       vec<ipa_vr, va_gc> *&dst_vr\n \t= ipcp_get_transformation_summary (dst)->m_vr;\n-      if (vec_safe_length (src_trans->alignments) > 0)\n-\t{\n-\t  vec_safe_reserve_exact (dst_alignments, src_alignments->length ());\n-\t  for (unsigned i = 0; i < src_alignments->length (); ++i)\n-\t    dst_alignments->quick_push ((*src_alignments)[i]);\n-\t}\n       if (vec_safe_length (src_trans->m_vr) > 0)\n \t{\n \t  vec_safe_reserve_exact (dst_vr, src_vr->length ());\n@@ -4697,15 +4670,6 @@ ipa_write_jump_function (struct output_block *ob,\n       stream_write_tree (ob, item->value, true);\n     }\n \n-  bp = bitpack_create (ob->main_stream);\n-  bp_pack_value (&bp, jump_func->alignment.known, 1);\n-  streamer_write_bitpack (&bp);\n-  if (jump_func->alignment.known)\n-    {\n-      streamer_write_uhwi (ob, jump_func->alignment.align);\n-      streamer_write_uhwi (ob, jump_func->alignment.misalign);\n-    }\n-\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, jump_func->bits.known, 1);\n   streamer_write_bitpack (&bp);\n@@ -4790,17 +4754,6 @@ ipa_read_jump_function (struct lto_input_block *ib,\n     }\n \n   struct bitpack_d bp = streamer_read_bitpack (ib);\n-  bool alignment_known = bp_unpack_value (&bp, 1);\n-  if (alignment_known)\n-    {\n-      jump_func->alignment.known = true;\n-      jump_func->alignment.align = streamer_read_uhwi (ib);\n-      jump_func->alignment.misalign = streamer_read_uhwi (ib);\n-    }\n-  else\n-    jump_func->alignment.known = false;\n-\n-  bp = streamer_read_bitpack (ib);\n   bool bits_known = bp_unpack_value (&bp, 1);\n   if (bits_known)\n     {\n@@ -5166,30 +5119,6 @@ write_ipcp_transformation_info (output_block *ob, cgraph_node *node)\n     }\n \n   ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n-  if (ts && vec_safe_length (ts->alignments) > 0)\n-    {\n-      count = ts->alignments->length ();\n-\n-      streamer_write_uhwi (ob, count);\n-      for (unsigned i = 0; i < count; ++i)\n-\t{\n-\t  ipa_alignment *parm_al = &(*ts->alignments)[i];\n-\n-\t  struct bitpack_d bp;\n-\t  bp = bitpack_create (ob->main_stream);\n-\t  bp_pack_value (&bp, parm_al->known, 1);\n-\t  streamer_write_bitpack (&bp);\n-\t  if (parm_al->known)\n-\t    {\n-\t      streamer_write_uhwi (ob, parm_al->align);\n-\t      streamer_write_hwi_in_range (ob->main_stream, 0, parm_al->align,\n-\t\t\t\t\t   parm_al->misalign);\n-\t    }\n-\t}\n-    }\n-  else\n-    streamer_write_uhwi (ob, 0);\n-\n   if (ts && vec_safe_length (ts->m_vr) > 0)\n     {\n       count = ts->m_vr->length ();\n@@ -5260,32 +5189,7 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n       aggvals = av;\n     }\n   ipa_set_node_agg_value_chain (node, aggvals);\n-\n-  count = streamer_read_uhwi (ib);\n-  if (count > 0)\n-    {\n-      ipcp_grow_transformations_if_necessary ();\n-\n-      ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n-      vec_safe_grow_cleared (ts->alignments, count);\n-\n-      for (i = 0; i < count; i++)\n-\t{\n-\t  ipa_alignment *parm_al;\n-\t  parm_al = &(*ts->alignments)[i];\n-\t  struct bitpack_d bp;\n-\t  bp = streamer_read_bitpack (ib);\n-\t  parm_al->known = bp_unpack_value (&bp, 1);\n-\t  if (parm_al->known)\n-\t    {\n-\t      parm_al->align = streamer_read_uhwi (ib);\n-\t      parm_al->misalign\n-\t\t= streamer_read_hwi_in_range (ib, \"ipa-prop misalign\",\n-\t\t\t\t\t      0, parm_al->align);\n-\t    }\n-\t}\n-    }\n-\n+  \n   count = streamer_read_uhwi (ib);\n   if (count > 0)\n     {\n@@ -5579,58 +5483,6 @@ ipcp_modif_dom_walker::before_dom_children (basic_block bb)\n   return NULL;\n }\n \n-/* Update alignment of formal parameters as described in\n-   ipcp_transformation_summary.  */\n-\n-static void\n-ipcp_update_alignments (struct cgraph_node *node)\n-{\n-  tree fndecl = node->decl;\n-  tree parm = DECL_ARGUMENTS (fndecl);\n-  tree next_parm = parm;\n-  ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n-  if (!ts || vec_safe_length (ts->alignments) == 0)\n-    return;\n-  const vec<ipa_alignment, va_gc> &alignments = *ts->alignments;\n-  unsigned count = alignments.length ();\n-\n-  for (unsigned i = 0; i < count; ++i, parm = next_parm)\n-    {\n-      if (node->clone.combined_args_to_skip\n-\t  && bitmap_bit_p (node->clone.combined_args_to_skip, i))\n-\tcontinue;\n-      gcc_checking_assert (parm);\n-      next_parm = DECL_CHAIN (parm);\n-\n-      if (!alignments[i].known || !is_gimple_reg (parm))\n-\tcontinue;\n-      tree ddef = ssa_default_def (DECL_STRUCT_FUNCTION (node->decl), parm);\n-      if (!ddef)\n-\tcontinue;\n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"  Adjusting alignment of param %u to %u, \"\n-\t\t \"misalignment to %u\\n\", i, alignments[i].align,\n-\t\t alignments[i].misalign);\n-\n-      struct ptr_info_def *pi = get_ptr_info (ddef);\n-      gcc_checking_assert (pi);\n-      unsigned old_align;\n-      unsigned old_misalign;\n-      bool old_known = get_ptr_info_alignment (pi, &old_align, &old_misalign);\n-\n-      if (old_known\n-\t  && old_align >= alignments[i].align)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"    But the alignment was already %u.\\n\",\n-\t\t     old_align);\n-\t  continue;\n-\t}\n-      set_ptr_info_alignment (pi, alignments[i].align, alignments[i].misalign);\n-    }\n-}\n-\n /* Update bits info of formal parameters as described in\n    ipcp_transformation_summary.  */\n \n@@ -5657,7 +5509,7 @@ ipcp_update_bits (struct cgraph_node *node)\n       next_parm = DECL_CHAIN (parm);\n \n       if (!bits[i].known\n-\t  || !INTEGRAL_TYPE_P (TREE_TYPE (parm))\n+\t  || !(INTEGRAL_TYPE_P (TREE_TYPE (parm)) || POINTER_TYPE_P (TREE_TYPE (parm)))\n \t  || !is_gimple_reg (parm))\n \tcontinue;       \n \n@@ -5672,12 +5524,53 @@ ipcp_update_bits (struct cgraph_node *node)\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n-      unsigned prec = TYPE_PRECISION (TREE_TYPE (ddef));\n-      signop sgn = TYPE_SIGN (TREE_TYPE (ddef));\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (ddef)))\n+\t{\n+\t  unsigned prec = TYPE_PRECISION (TREE_TYPE (ddef));\n+\t  signop sgn = TYPE_SIGN (TREE_TYPE (ddef));\n+\n+\t  wide_int nonzero_bits = wide_int::from (bits[i].mask, prec, UNSIGNED)\n+\t\t\t\t  | wide_int::from (bits[i].value, prec, sgn);\n+\t  set_nonzero_bits (ddef, nonzero_bits);\n+\t}\n+      else\n+\t{\n+\t  unsigned tem = bits[i].mask.to_uhwi ();\n+\t  unsigned HOST_WIDE_INT bitpos = bits[i].value.to_uhwi (); \n+\t  unsigned align = tem & -tem;\n+\t  unsigned misalign = bitpos & (align - 1);\n \n-      wide_int nonzero_bits = wide_int::from (bits[i].mask, prec, UNSIGNED)\n-\t\t\t      | wide_int::from (bits[i].value, prec, sgn);\n-      set_nonzero_bits (ddef, nonzero_bits);\n+\t  if (align > 1)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Adjusting align: %u, misalign: %u\\n\", align, misalign); \n+\n+\t      unsigned old_align, old_misalign;\n+\t      struct ptr_info_def *pi = get_ptr_info (ddef);\n+\t      bool old_known = get_ptr_info_alignment (pi, &old_align, &old_misalign);\n+\n+\t      if (old_known\n+\t\t  && old_align > align)\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file, \"But alignment was already %u.\\n\", old_align);\n+\t\t      if ((old_misalign & (align - 1)) != misalign)\n+\t\t\tfprintf (dump_file, \"old_misalign (%u) and misalign (%u) mismatch\\n\",\n+\t\t\t\t old_misalign, misalign);\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (old_known\n+\t\t  && ((misalign & (old_align - 1)) != old_misalign)\n+\t\t  && dump_file)\n+\t\tfprintf (dump_file, \"old_misalign (%u) and misalign (%u) mismatch\\n\",\n+\t\t\t old_misalign, misalign);\n+\n+\t      set_ptr_info_alignment (pi, align, misalign); \n+\t    }\n+\t}\n     }\n }\n \n@@ -5752,7 +5645,6 @@ ipcp_transform_function (struct cgraph_node *node)\n     fprintf (dump_file, \"Modification phase of node %s/%i\\n\",\n \t     node->name (), node->order);\n \n-  ipcp_update_alignments (node);\n   ipcp_update_bits (node);\n   ipcp_update_vr (node);\n   aggval = ipa_get_agg_replacements_for_node (node);\n@@ -5785,7 +5677,6 @@ ipcp_transform_function (struct cgraph_node *node)\n   fbi.bb_infos.release ();\n   free_dominance_info (CDI_DOMINATORS);\n   (*ipcp_transformations)[node->uid].agg_values = NULL;\n-  (*ipcp_transformations)[node->uid].alignments = NULL;\n   descriptors.release ();\n \n   if (!something_changed)"}, {"sha": "4eeae882f5f36d3c99acf6d3cb8fb2b345a726c0", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -143,17 +143,6 @@ struct GTY(()) ipa_agg_jump_function\n \n typedef struct ipa_agg_jump_function *ipa_agg_jump_function_p;\n \n-/* Info about pointer alignments. */\n-struct GTY(()) ipa_alignment\n-{\n-  /* The data fields below are valid only if known is true.  */\n-  bool known;\n-  /* See ptr_info_def and get_pointer_alignment_1 for description of these\n-     two.  */\n-  unsigned align;\n-  unsigned misalign;\n-};\n-\n /* Information about zero/non-zero bits.  */\n struct GTY(()) ipa_bits\n {\n@@ -186,9 +175,6 @@ struct GTY (()) ipa_jump_func\n      description.  */\n   struct ipa_agg_jump_function agg;\n \n-  /* Information about alignment of pointers. */\n-  struct ipa_alignment alignment;\n-\n   /* Information about zero/non-zero bits.  */\n   struct ipa_bits bits;\n \n@@ -531,8 +517,6 @@ struct GTY(()) ipcp_transformation_summary\n {\n   /* Linked list of known aggregate values.  */\n   ipa_agg_replacement_value *agg_values;\n-  /* Alignment information for pointers.  */\n-  vec<ipa_alignment, va_gc> *alignments;\n   /* Known bits information.  */\n   vec<ipa_bits, va_gc> *bits;\n   /* Value range information.  */"}, {"sha": "90e6186e71101d01a9ef8bad72e50b6aad0f4d19", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -504,7 +504,6 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_ftree_pre, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_ftree_switch_conversion, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_cp, NULL, 1 },\n-    { OPT_LEVELS_2_PLUS, OPT_fipa_cp_alignment, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_bit_cp, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_vrp, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fdevirtualize, NULL, 1 },\n@@ -1423,9 +1422,6 @@ enable_fdo_optimizations (struct gcc_options *opts,\n   if (!opts_set->x_flag_ipa_cp_clone\n       && value && opts->x_flag_ipa_cp)\n     opts->x_flag_ipa_cp_clone = value;\n-  if (!opts_set->x_flag_ipa_cp_alignment\n-      && value && opts->x_flag_ipa_cp)\n-    opts->x_flag_ipa_cp_alignment = value;\n   if (!opts_set->x_flag_ipa_bit_cp\n       && value && opts->x_flag_ipa_cp)\n     opts->x_flag_ipa_bit_cp = value;"}, {"sha": "4e69c4dddf595cf63d8dfc6c10e7f3d7e11219d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -1,3 +1,11 @@\n+2016-10-09  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\t* gcc.dg/ipa/propalign-1.c: Adjust scan-ipa-dump.\n+\t* gcc.dg/ipa/propalign-2.c: Likewise\n+\t* gcc.dg/ipa/propalign-3.c: Likewise.\n+\t* gcc.dg/ipa/propalign-4.c: Likewise.\n+\t* gcc.dg/ipa/propalign-5.c: Likewise.\n+\n 2016-10-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-c++-common/Wimplicit-fallthrough-23.c (foo): Add further tests."}, {"sha": "1491de8d550e90613c7a18e0d9f035de9446ba04", "filename": "gcc/testsuite/gcc.dg/ipa/propalign-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-1.c?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -27,5 +27,5 @@ bar (void)\n }\n \n \n-/* { dg-final { scan-ipa-dump \"Adjusting alignment of param\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Adjusting align\" \"cp\" } } */\n /* { dg-final { scan-tree-dump-not \"fail_the_test\" \"optimized\" } } */"}, {"sha": "51799c7fbd10bddb9d851c6d05a7c986ef33ff72", "filename": "gcc/testsuite/gcc.dg/ipa/propalign-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-2.c?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -53,5 +53,5 @@ bar2 (void)\n   through (c.buf);\n }\n \n-/* { dg-final { scan-ipa-dump \"Adjusting alignment of param\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Adjusting align\" \"cp\" } } */\n /* { dg-final { scan-tree-dump-not \"fail_the_test\" \"optimized\" } } */"}, {"sha": "4f5df4aacf471162bf9e15b9c24117d3174c6bdc", "filename": "gcc/testsuite/gcc.dg/ipa/propalign-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-3.c?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-ipa-cp-alignment -fno-early-inlining -fdump-ipa-cp -fdump-tree-optimized\" } */\n+/* { dg-options \"-O2 -fno-ipa-bit-cp -fno-early-inlining -fdump-ipa-cp -fdump-tree-optimized\" } */\n /* { dg-skip-if \"No alignment restrictions\" { { ! natural_alignment_32 } && { ! natural_alignment_64 } } } */\n \n #include <stdint.h>\n@@ -53,5 +53,5 @@ bar2 (void)\n   through (c.buf);\n }\n \n-/* { dg-final { scan-ipa-dump-not \"Adjusting alignment of param\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-not \"align:\" \"cp\" } } */\n /* { dg-final { scan-tree-dump \"fail_the_test\" \"optimized\" } } */"}, {"sha": "bd32bf09241df1e389c8cc1f9fed4fbd1dff68ad", "filename": "gcc/testsuite/gcc.dg/ipa/propalign-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-4.c?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -20,4 +20,4 @@ main()\n   test (&aa[3]);\n   return 0;\n }\n-/* { dg-final { scan-ipa-dump \"Alignment 8, misalignment 4\"  \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"align: 8, misalign: 4\"  \"cp\"  } } */"}, {"sha": "68e57da30d7914236206ca36a3a7131fef5e655b", "filename": "gcc/testsuite/gcc.dg/ipa/propalign-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b974787c1e77ebebb4f36cdf09ac11a5690f43/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-5.c?ref=67b974787c1e77ebebb4f36cdf09ac11a5690f43", "patch": "@@ -20,4 +20,4 @@ main()\n   test (&bb);\n   return 0;\n }\n-/* { dg-final { scan-ipa-dump \"Alignment 2\"  \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"align: 2\"  \"cp\"  } } */"}]}