{"sha": "44bd2755a8bfd4c8849d97f058141c3d5a17647b", "node_id": "C_kwDOANBUbNoAKDQ0YmQyNzU1YThiZmQ0Yzg4NDlkOTdmMDU4MTQxYzNkNWExNzY0N2I", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2022-07-19T11:57:05Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-05T07:21:03Z"}, "message": "[Ada] Fix resolution of iterated component association\n\nFor iterator specification appearing inside an iterated component\nassociation, we just did ad-hoc, incomplete checks and delayed a proper\nanalysis until the iterated component association is expanded into loop (and\nthen reanalyzed).\n\nHowever, when the iterated component association is not expanded, e.g.\nbecause we are in semantic checking mode, GNATprove mode or inside a\ngeneric, then the AST lacked any processing or error reporting.\n\nThis is fixed by reusing the existing analysis of iterator specifications,\nas they also appear in other constructs, e.g. in quantified expressions.\n\ngcc/ada/\n\n\t* sem_aggr.adb (Resolve_Iterated_Component_Association): Split\n\tprocessing of cases with and without iterator specification; reuse\n\tanalysis of iterator specification; improve diagnostics for\n\tpremature usage of iterator index in discrete choices.", "tree": {"sha": "7c57e050ec18aaf8a2b3273c3d01744fc5fc9b01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c57e050ec18aaf8a2b3273c3d01744fc5fc9b01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44bd2755a8bfd4c8849d97f058141c3d5a17647b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44bd2755a8bfd4c8849d97f058141c3d5a17647b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44bd2755a8bfd4c8849d97f058141c3d5a17647b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44bd2755a8bfd4c8849d97f058141c3d5a17647b/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cde3f9417540cfc61ff8e3c58b76e7d182b40db5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde3f9417540cfc61ff8e3c58b76e7d182b40db5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cde3f9417540cfc61ff8e3c58b76e7d182b40db5"}], "stats": {"total": 68, "additions": 23, "deletions": 45}, "files": [{"sha": "ce3e2f4d39d420d07b2e3834b2e6df77871dd980", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44bd2755a8bfd4c8849d97f058141c3d5a17647b/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44bd2755a8bfd4c8849d97f058141c3d5a17647b/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=44bd2755a8bfd4c8849d97f058141c3d5a17647b", "patch": "@@ -1742,8 +1742,6 @@ package body Sem_Aggr is\n          Loc : constant Source_Ptr := Sloc (N);\n          Id  : constant Entity_Id  := Defining_Identifier (N);\n \n-         Id_Typ : Entity_Id := Any_Type;\n-\n          -----------------------\n          -- Remove_References --\n          -----------------------\n@@ -1779,37 +1777,29 @@ package body Sem_Aggr is\n       begin\n          Error_Msg_Ada_2022_Feature (\"iterated component\", Loc);\n \n-         if Present (Iterator_Specification (N)) then\n-            Analyze (Name (Iterator_Specification (N)));\n+         --  Create a scope in which to introduce an index, to make it visible\n+         --  for the analysis of component expression.\n \n-            --  We assume that the domain of iteration cannot be overloaded.\n+         Scop := New_Internal_Entity (E_Loop, Current_Scope, Loc, 'L');\n+         Set_Etype  (Scop, Standard_Void_Type);\n+         Set_Parent (Scop, Parent (N));\n+         Push_Scope (Scop);\n \n-            declare\n-               Domain : constant Node_Id := Name (Iterator_Specification (N));\n-               D_Type : constant Entity_Id := Etype (Domain);\n-               Elt    : Entity_Id;\n-            begin\n-               if Is_Array_Type (D_Type) then\n-                  Id_Typ := Component_Type (D_Type);\n+         --  If there is iterator specification, then its preanalysis will make\n+         --  the index visible.\n \n-               else\n-                  if Has_Aspect (D_Type, Aspect_Iterable) then\n-                     Elt :=\n-                       Get_Iterable_Type_Primitive (D_Type, Name_Element);\n-                     if No (Elt) then\n-                        Error_Msg_N\n-                          (\"missing Element primitive for iteration\", Domain);\n-                     else\n-                        Id_Typ := Etype (Elt);\n-                     end if;\n-                  else\n-                     Error_Msg_N (\"cannot iterate over\", Domain);\n-                  end if;\n-               end if;\n-            end;\n+         if Present (Iterator_Specification (N)) then\n+            Preanalyze (Iterator_Specification (N));\n+\n+         --  Otherwise, analyze discrete choices and make the index visible\n \n          else\n-            Id_Typ := Index_Typ;\n+            --  Insert index name into current scope but don't decorate it yet,\n+            --  so that a premature usage of this name in discrete choices will\n+            --  be nicely diagnosed.\n+\n+            Enter_Name (Id);\n+\n             Choice := First (Discrete_Choices (N));\n \n             while Present (Choice) loop\n@@ -1835,25 +1825,13 @@ package body Sem_Aggr is\n \n                Next (Choice);\n             end loop;\n-         end if;\n-\n-         --  Create a scope in which to introduce an index, which is usually\n-         --  visible in the expression for the component, and needed for its\n-         --  analysis.\n \n-         Scop := New_Internal_Entity (E_Loop, Current_Scope, Loc, 'L');\n-         Set_Etype  (Scop, Standard_Void_Type);\n-         Set_Parent (Scop, Parent (N));\n-         Push_Scope (Scop);\n+            --  Decorate the index variable\n \n-         --  Insert and decorate the index variable in the current scope.\n-         --  The expression has to be analyzed once the index variable is\n-         --  directly visible.\n-\n-         Enter_Name (Id);\n-         Set_Etype (Id, Id_Typ);\n-         Mutate_Ekind (Id, E_Variable);\n-         Set_Scope (Id, Scop);\n+            Set_Etype (Id, Index_Typ);\n+            Mutate_Ekind (Id, E_Variable);\n+            Set_Scope (Id, Scop);\n+         end if;\n \n          --  Analyze  expression without expansion, to verify legality.\n          --  When generating code, we then remove references to the index"}]}