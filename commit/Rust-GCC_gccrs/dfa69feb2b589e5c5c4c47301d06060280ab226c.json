{"sha": "dfa69feb2b589e5c5c4c47301d06060280ab226c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZhNjlmZWIyYjU4OWU1YzVjNGM0NzMwMWQwNjA2MDI4MGFiMjI2Yw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-05-29T17:36:29Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-05-29T17:36:29Z"}, "message": "entered into RCS\n\nFrom-SVN: r1122", "tree": {"sha": "d3773f64658b194abf02d726992a38a60c116f0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3773f64658b194abf02d726992a38a60c116f0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfa69feb2b589e5c5c4c47301d06060280ab226c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfa69feb2b589e5c5c4c47301d06060280ab226c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfa69feb2b589e5c5c4c47301d06060280ab226c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfa69feb2b589e5c5c4c47301d06060280ab226c/comments", "author": null, "committer": null, "parents": [{"sha": "fe751ebf30bc05707971f6ef91c31c24f928f16f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe751ebf30bc05707971f6ef91c31c24f928f16f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe751ebf30bc05707971f6ef91c31c24f928f16f"}], "stats": {"total": 192, "additions": 99, "deletions": 93}, "files": [{"sha": "3c1b7ae82ad41dad0a5028ebcf4415681dce814b", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 48, "deletions": 64, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa69feb2b589e5c5c4c47301d06060280ab226c/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa69feb2b589e5c5c4c47301d06060280ab226c/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=dfa69feb2b589e5c5c4c47301d06060280ab226c", "patch": "@@ -46,7 +46,7 @@ extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-static char out_sccs_id[] = \"@(#)m88k.c\t2.1.11.5 19 May 1992 08:15:15\";\n+static char out_sccs_id[] = \"@(#)m88k.c\t2.1.11.11 29 May 1992 11:12:23\";\n static char tm_sccs_id [] = TM_SCCS_ID;\n \n char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n@@ -840,25 +840,45 @@ mostly_false_jump (jump_insn, condition)\n   for (insnt = NEXT_INSN (target_label);\n        insnt;\n        insnt = NEXT_INSN (insnt))\n-    if (GET_CODE (insnt) == JUMP_INSN\n-\t|| (GET_CODE (insnt) == SEQUENCE\n-\t    && GET_CODE (XVECEXP (insnt, 0, 0)) == JUMP_INSN))\n-      break;\n-  if (insnt && GET_CODE (PATTERN (insnt)) == RETURN)\n+    {\n+      if (GET_CODE (insnt) == JUMP_INSN)\n+\tbreak;\n+      else if (GET_CODE (insnt) == SEQUENCE\n+\t       && GET_CODE (XVECEXP (insnt, 0, 0)) == JUMP_INSN)\n+\t{\n+\t  insnt = XVECEXP (insnt, 0, 0);\n+\t  break;\n+\t}\n+    }\n+  if (insnt\n+      && (GET_CODE (PATTERN (insnt)) == RETURN\n+\t  || (GET_CODE (PATTERN (insnt)) == SET\n+\t      && GET_CODE (SET_SRC (PATTERN (insnt))) == REG\n+\t      && REGNO (SET_SRC (PATTERN (insnt))) == 1)))\n     insnt = 0;\n \n   for (insnj = NEXT_INSN (jump_insn);\n        insnj;\n        insnj = NEXT_INSN (insnj))\n-    if (GET_CODE (insnj) == JUMP_INSN\n-\t|| (GET_CODE (insnj) == SEQUENCE\n-\t    && GET_CODE (XVECEXP (insnj, 0, 0)) == JUMP_INSN))\n-      break;\n-  if (insnj && GET_CODE (PATTERN (insnj)) == RETURN)\n-    insnj = 0;\n+    {\n+      if (GET_CODE (insnj) == JUMP_INSN)\n+\tbreak;\n+      else if (GET_CODE (insnj) == SEQUENCE\n+\t       && GET_CODE (XVECEXP (insnj, 0, 0)) == JUMP_INSN)\n+\t{\n+\t  insnj = XVECEXP (insnj, 0, 0);\n+\t  break;\n+\t}\n+    }\n+  if (insnj\n+      && (GET_CODE (PATTERN (insnj)) == RETURN\n+\t  || (GET_CODE (PATTERN (insnj)) == SET\n+\t      && GET_CODE (SET_SRC (PATTERN (insnj))) == REG\n+\t      && REGNO (SET_SRC (PATTERN (insnj))) == 1)))\n+    insnt = 0;\n \n   /* Predict to not return.  */\n-  if (insnt != insnj)\n+  if ((insnt == 0) != (insnj == 0))\n     return (insnt == 0);\n \n   /* Predict loops to loop.  */\n@@ -883,7 +903,8 @@ mostly_false_jump (jump_insn, condition)\n \n   /* EQ tests are usually false and NE tests are usually true.  Also,\n      most quantities are positive, so we can make the appropriate guesses\n-     about signed comparisons against zero.  */\n+     about signed comparisons against zero.  Consider unsigned comparsions\n+     to be a range check and assume quantities to be in range.  */\n   switch (GET_CODE (condition))\n     {\n     case CONST_INT:\n@@ -895,11 +916,15 @@ mostly_false_jump (jump_insn, condition)\n       return 0;\n     case LE:\n     case LT:\n+    case GEU:\n+    case GTU: /* Must get casesi right at least.  */\n       if (XEXP (condition, 1) == const0_rtx)\n         return 1;\n       break;\n     case GE:\n     case GT:\n+    case LEU:\n+    case LTU:\n       if (XEXP (condition, 1) == const0_rtx)\n \treturn 0;\n       break;\n@@ -908,51 +933,6 @@ mostly_false_jump (jump_insn, condition)\n   return 0;\n }\n \f\n-/* Report errors on floating point, if we are given NaN's, or such.  Leave\n-   the number as is, though, since we output the number in hex, and the\n-   assembler won't choke on it.  */\n-\n-void\n-check_float_value (mode, value)\n-     enum machine_mode mode;\n-     REAL_VALUE_TYPE value;\n-{\n-  union {\n-    REAL_VALUE_TYPE d;\n-    struct {\n-      unsigned sign\t    :  1;\n-      unsigned exponent  : 11;\n-      unsigned mantissa1 : 20;\n-      unsigned mantissa2;\n-    } s;\n-  } u;\n-\n-  if (mode == DFmode)\n-    {\n-      u.d = value;\n-      if (u.s.mantissa1 != 0 || u.s.mantissa2 != 0)\n-\t{\n-\t  if (u.s.exponent == 0x7ff)\t/* Not a Number */\n-\t    warning (\"floating point number is not valid for IEEE double precision\");\n-\t  else if (u.s.exponent == 0)\n-\t    warning (\"denormalized double precision floating point number\");\n-\t}\n-    }\n-  else if (mode == SFmode)\n-    {\n-      u.d = REAL_VALUE_TRUNCATE (mode, value);\n-      if (u.s.mantissa1 != 0 || u.s.mantissa2 != 0)\n-\t{\n-\t  if (u.s.exponent == 0x7ff)\t/* Not a Number */\n-\t    warning (\"floating point number is not valid for IEEE double precision\");\n-\t  else if (u.s.exponent == 0)\n-\t    warning (\"denormalized single precision floating point number\");\n-\t}\n-      else if (u.s.exponent == 0x7ff)\t/* Infinity */\n-\twarning (\"floating point number exceeds range of `float'\");\n-    }\n-}\n-\f\n /* Return true if the operand is a power of two and is a floating\n    point type (to optimize division by power of two into multiplication).  */\n \n@@ -1709,9 +1689,12 @@ m88k_layout_frame ()\n \n   /* If a frame is requested, save the previous FP, and the return\n      address (r1), so that a traceback can be done without using tdesc\n-     information.  */\n+     information.  Otherwise, simply save the FP if it is used as\n+     a preserve register.  */\n   if (frame_pointer_needed)\n     save_regs[FRAME_POINTER_REGNUM] = save_regs[1] = 1;\n+  else if (regs_ever_live[FRAME_POINTER_REGNUM])\n+    save_regs[FRAME_POINTER_REGNUM] = 1;\n \n   /* Figure out which extended register(s) needs to be saved.  */\n   for (regno = FIRST_EXTENDED_REGISTER + 1; regno < FIRST_PSEUDO_REGISTER;\n@@ -1872,7 +1855,6 @@ eligible_for_epilogue_delay (insn)\n     case TYPE_LOADA:\n     case TYPE_ARITH:\n     case TYPE_MARITH:\n-    case TYPE_MSTORE:\n       return ok_for_epilogue_p (PATTERN (insn));\n     default:\n       return 0;\n@@ -2625,8 +2607,7 @@ m88k_builtin_saveregs (arglist)\n \t\t\t\t\t\t 2 * UNITS_PER_WORD)),\n \t\t  copy_to_reg (XEXP (addr, 0)));\n \n-  /* Now store the incoming registers and return the address of the\n-     va_list constructor.  */\n+  /* Now store the incoming registers.  */\n   if (fixed < 8)\n       move_block_from_reg\n \t(2 + fixed,\n@@ -2635,7 +2616,10 @@ m88k_builtin_saveregs (arglist)\n \t\t\t\t\tfixed * UNITS_PER_WORD)),\n \t 8 - fixed);\n \n-  return copy_to_reg (XEXP (block, 0));\n+  /* Return the address of the va_list constructor, but don't put it in a\n+     register.  This fails when not optimizing and produces worse code when\n+     optimizing.  */\n+  return XEXP (block, 0);\n }\n \f\n /* If cmpsi has not been generated, emit code to do the test.  Return the"}, {"sha": "cd78bfb626612122dab42fac5267b27a005af11a", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa69feb2b589e5c5c4c47301d06060280ab226c/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa69feb2b589e5c5c4c47301d06060280ab226c/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=dfa69feb2b589e5c5c4c47301d06060280ab226c", "patch": "@@ -104,7 +104,6 @@ extern void m88k_handle_pragma_token ();\n \n extern void emit_bcnd ();\n extern void expand_block_move ();\n-extern void check_float_value ();\n extern void m88k_layout_frame ();\n extern void m88k_output_prologue ();\n extern void m88k_output_epilogue ();\n@@ -204,9 +203,9 @@ extern char * reg_names[];\n /* Print subsidiary information on the compiler version in use.\n    Redefined in m88kv4.h, and m88kluna.h.  */\n #define VERSION_INFO1\t\"88open OCS/BCS, \"\n-#define VERSION_INFO2\t\"19 May 1992\"\n+#define VERSION_INFO2\t\"29 May 1992\"\n #define VERSION_STRING\tversion_string\n-#define\tTM_SCCS_ID\t\"@(#)m88k.h\t2.1.11.5 19 May 1992 09:28:04\"\n+#define\tTM_SCCS_ID\t\"@(#)m88k.h\t2.1.11.11 29 May 1992 13:20:31\"\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n@@ -425,10 +424,10 @@ extern char * reg_names[];\n    replaces a BLKmode type. */\n /* #define MAX_FIXED_MODE_SIZE 0 */\n \n-/* Report errors on floating point, if we are given NaN's, or such.  Leave\n-   the number as is, though, since we output the number in hex, and the\n-   assembler won't choke on it.  */\n-#define CHECK_FLOAT_VALUE(MODE,VALUE) check_float_value (MODE, VALUE)\n+/* Check a `double' value for validity for a particular machine mode.\n+   This is defined to avoid crashes outputting certain constants.\n+   Since we output the number in hex, the assembler won't choke on it.  */\n+/* #define CHECK_FLOAT_VALUE(MODE,VALUE) */\n \n /* A code distinguishing the floating point format of the target machine.  */\n /* #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT */\n@@ -571,7 +570,7 @@ extern char * reg_names[];\n \t  that almost all registers be saved across calls anyway.  */\n \n #define FIXED_REGISTERS \\\n- {1, 1, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0,  0, 0, 0, 0, \\\n+ {1, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0,  0, 0, 0, 0, \\\n   0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 1, 1,  1, 1, 1, 1, \\\n   1, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0,  0, 0, 0, 0, \\\n   0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0,  0, 0, 1, 1}\n@@ -687,13 +686,36 @@ extern char * reg_names[];\n #define REG_ALLOC_ORDER\t\t  \\\n  {\t\t\t\t  \\\n   13, 12, 11, 10, 29, 28, 27, 26, \\\n-   1, 62, 63,  9,  8,  7,  6,  5, \\\n-   4,  3,  2, 53, 52, 51, 50, 49, \\\n+  62, 63,  9,  8,  7,  6,  5,  4, \\\n+   3,  2,  1, 53, 52, 51, 50, 49, \\\n   48, 47, 46, 45, 44, 43, 42, 41, \\\n   40, 39, 38, 37, 36, 35, 34, 33, \\\n   25, 24, 23, 22, 21, 20, 19, 18, \\\n   17, 16, 15, 14, 61, 60, 59, 58, \\\n   57, 56, 55, 54, 30, 31,  0, 32}\n+\n+/* Order for leaf functions.  */\n+#define REG_LEAF_ALLOC_ORDER\t  \\\n+ {\t\t\t\t  \\\n+   9,  8,  7,  6, 13, 12, 11, 10, \\\n+  29, 28, 27, 26, 62, 63,  5,  4, \\\n+   3,  2,  0, 53, 52, 51, 50, 49, \\\n+  48, 47, 46, 45, 44, 43, 42, 41, \\\n+  40, 39, 38, 37, 36, 35, 34, 33, \\\n+  25, 24, 23, 22, 21, 20, 19, 18, \\\n+  17, 16, 15, 14, 61, 60, 59, 58, \\\n+  57, 56, 55, 54, 30, 31,  1, 32}\n+\n+/* Switch between the leaf and non-leaf orderings.  The purpose is to avoid\n+   write-over scoreboard delays between caller and callee.  */\n+#define ORDER_REGS_FOR_LOCAL_ALLOC\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  static int leaf[] = REG_LEAF_ALLOC_ORDER;\t\t\t\\\n+  static int nonleaf[] = REG_ALLOC_ORDER;\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  bcopy (regs_ever_live[1] ? nonleaf : leaf, reg_alloc_order,\t\\\n+\t FIRST_PSEUDO_REGISTER * sizeof (int));\t\t\t\\\n+}\n \f\n /*** Register Classes ***/\n \n@@ -1365,6 +1387,11 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n   {\"equality_op\", {EQ, NE}},\t\t\t\t\t\t\\\n   {\"pc_or_label_ref\", {PC, LABEL_REF}},\n \n+/* The case table contains either words or branch instructions.  This says\n+   which.  We always claim that the vector is PC-relative.  It is position\n+   independent when -fpic is used.  */\n+#define CASE_VECTOR_INSNS (TARGET_88100 || flag_pic)\n+\n /* An alias for a machine mode name.  This is the machine mode that\n    elements of a jump-table should have.  */\n #define CASE_VECTOR_MODE SImode\n@@ -1933,11 +1960,6 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n   output_ascii (FILE, ASCII_DATA_ASM_OP, 48, P, SIZE)\n \n-/* The case table contains either words or branch instructions.  This says\n-   which.  We always claim that the vector is PC-relative.  It is position\n-   independent when -fpic is used.  */\n-#define CASE_VECTOR_INSNS (TARGET_88100 || flag_pic)\n-\n /* Epilogue for case labels.  This jump instruction is called by casesi\n    to transfer to the appropriate branch instruction within the table.\n    The label `@L<n>e' is coined to mark the end of the table.  */"}, {"sha": "e866893c7dd0abcdb979c7008a9f08d03946fc5a", "filename": "gcc/config/m88k/m88k.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa69feb2b589e5c5c4c47301d06060280ab226c/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa69feb2b589e5c5c4c47301d06060280ab226c/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=dfa69feb2b589e5c5c4c47301d06060280ab226c", "patch": "@@ -28,7 +28,7 @@\n (define_expand \"m88k_sccs_id\"\n   [(match_operand:SI 0 \"\" \"\")]\n   \"\"\n-  \"{ static char sccs_id[] = \\\"@(#)m88k.md\t2.1.11.3 19 May 1992 08:44:52\\\";\n+  \"{ static char sccs_id[] = \\\"@(#)m88k.md\t2.1.11.6 29 May 1992 10:55:49\\\";\n      FAIL; }\")\n \f\n ;; Attribute specifications\n@@ -45,22 +45,22 @@\n ;  spadd,dpadd,spcmp,dpcmp,spdiv,dpdiv,idiv, ; FPU add instructions\n ;  spmul,dpmul,imul,\t\t\t; FPU multiply instructions\n ;  arith,bit,mov\t\t\t; integer unit instructions\n-;  marith,mbit,mstore,mfp,weird\"\t; multi-word instructions\n+;  marith,mbit,mfp,weird\"\t\t; multi-word instructions\n \n ; Classification of each insn.  Some insns of TYPE_BRANCH are multi-word.\n (define_attr \"type\"\n-  \"branch,jump,call,load,store,loada,spadd,dpadd,spcmp,dpcmp,spdiv,dpdiv,idiv,spmul,dpmul,imul,arith,bit,mov,marith,mbit,mstore,mfp,weird\"\n+  \"branch,jump,call,load,store,loada,spadd,dpadd,spcmp,dpcmp,spdiv,dpdiv,idiv,spmul,dpmul,imul,arith,bit,mov,marith,mbit,mfp,weird\"\n   (const_string \"arith\"))\n \n ; Convenience attributes.\n (define_attr \"unit\" \"bit,memory,multiply,divide,fpadd,other\"\n   (cond [(eq_attr \"type\" \"bit,mbit\") (const_string \"bit\")\n-\t (eq_attr \"type\" \"load,store,mstore\") (const_string \"memory\")\n+\t (eq_attr \"type\" \"load,store\") (const_string \"memory\")\n \t (eq_attr \"type\" \"spmul,dpmul,imul\") (const_string \"multiply\")\n \t (eq_attr \"type\" \"spdiv,dpdiv,idiv\") (const_string \"divide\")\n \t (eq_attr \"type\" \"spadd,dpadd,spcmp,dpcmp,mfp\") (const_string \"fpadd\")]\n \t(const_string \"other\")))\n-\t \n+\n (define_attr \"fpu\" \"yes,no\"\n   (if_then_else\n    (eq_attr \"type\" \"spmul,dpmul,imul,spadd,dpadd,spcmp,dpcmp,spdiv,dpdiv,idiv,mfp\")\n@@ -69,7 +69,7 @@\n ; Length in # of instructions of each insn.  The values are not exact, but\n ; are safe.\n (define_attr \"length\" \"\"\n-  (cond [(eq_attr \"type\" \"marith,mbit,mstore,mfp\")\n+  (cond [(eq_attr \"type\" \"marith,mbit,mfp\")\n \t (const_int 2)]\n \t(const_int 1)))\n \n@@ -88,7 +88,7 @@\n (define_delay (eq_attr \"type\" \"branch,jump\")\n   [(and\n     (and\n-     (eq_attr \"type\" \"!branch,jump,call,marith,mbit,mstore,mfp,weird\") ; required.\n+     (eq_attr \"type\" \"!branch,jump,call,marith,mbit,mfp,weird\") ; required.\n      (eq_attr \"type\" \"!load\")) ; issue as-soon-as-possible.\n     (eq_attr \"fpu\" \"no\")) ; issue as-soon-as-possible.\n    (eq_attr \"type\" \"!call,branch,jump\") (nil)]) ; @@ was (const_int 1)\n@@ -97,7 +97,7 @@\n ; a call.  (@@ Support for this case is expected in reorg.c soon.)\n \n (define_delay (eq_attr \"type\" \"call\")\n-  [(eq_attr \"type\" \"!branch,call,marith,mbit,mstore,mfp,weird\") ; required.\n+  [(eq_attr \"type\" \"!branch,call,marith,mbit,mfp,weird\") ; required.\n    (nil) (nil)])\n \f\n ; An abstract block diagram of the function units for the m88100.\n@@ -145,7 +145,7 @@\n \n ; Describing the alu is currently not useful.\n ;(define_function_unit \"alu\" 1 0 (eq_attr \"type\"\n-;\t\t\t\t\t \"!store,mstore,marith,mbit,mfp,weird\") 1 0)\n+;\t\t\t\t\t \"!store,marith,mbit,mfp,weird\") 1 0)\n ;(define_function_unit \"alu\" 1 0 (eq_attr \"type\" \"marith,mbit,weird\") 2 0)\n \n (define_function_unit \"alu\" 1 0\n@@ -202,13 +202,13 @@\n \n ; Describing writeback contention is currently not useful.\n ;(define_function_unit \"writeback\" 1 1\n-;  (eq_attr \"type\" \"!store,mstore,branch,jump,call\") 0 1)\n+;  (eq_attr \"type\" \"!store,branch,jump,call\") 0 1)\n \n ; Describing stores is currently not useful.  The suggestion here is that the\n ; function unit ordering has already been established (writeback is last) and\n ; that store insns use the units in an unusual order.\n-;(define_function_unit \"writeback\" 1 1 (eq_attr \"type\" \"store,mstore\") 0 1)\n-;(define_function_unit \"memory\" 1 3 (eq_attr \"type\" \"store,mstore\") 1 2)\n+;(define_function_unit \"writeback\" 1 1 (eq_attr \"type\" \"store\") 0 1)\n+;(define_function_unit \"memory\" 1 3 (eq_attr \"type\" \"store\") 1 2)\n \f\n ;; This rich set of complex patterns are mostly due to Torbjorn Granlund\n ;; (tege@sics.se).  They've changed since then, so don't complain to him\n@@ -3063,13 +3063,13 @@\n   [(return)]\n   \"null_epilogue ()\"\n   \"jmp%. %#r1\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"jump\")])\n \n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n   \"\"\n   \"jmp%. %0\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"jump\")])\n \n (define_insn \"jump\"\n   [(set (pc)"}]}