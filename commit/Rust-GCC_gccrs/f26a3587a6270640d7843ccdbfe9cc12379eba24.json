{"sha": "f26a3587a6270640d7843ccdbfe9cc12379eba24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI2YTM1ODdhNjI3MDY0MGQ3ODQzY2NkYmZlOWNjMTIzNzllYmEyNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-22T10:05:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-22T10:05:04Z"}, "message": "[multiple changes]\n\n2016-06-22  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* lib-xref-spark_specific.adb, a-cuprqu.ads, sem_ch6.adb: Minor\n\treformatting.\n\n2016-06-22  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_util.ads (Address_Value): Declare new function.\n\t* sem_util.adb (Address_Value): New function extracted\n\tunmodified from Apply_Address_Clause_Check, which returns the\n\tunderlying value of the expression of an address clause.\n\t* checks.adb (Compile_Time_Bad_Alignment): Delete.\n\t(Apply_Address_Clause_Check): Call Address_Value on\n\tthe expression.  Do not issue the main warning here and\n\tissue the secondary warning only when the value of the\n\texpression is not known at compile time.\n\t* sem_ch13.adb (Address_Clause_Check_Record): Add A component and\n\tadjust the description.\n\t(Analyze_Attribute_Definition_Clause): In the case\n\tof an address, move up the code creating an entry in the table of\n\taddress clauses.  Also create an entry for an absolute address.\n\t(Validate_Address_Clauses): Issue the warning for absolute\n\taddresses here too.  Tweak condition associated with overlays\n\tfor consistency.\n\nFrom-SVN: r237688", "tree": {"sha": "44bc8267c9412d726ac51245ec3bb2935c5baca3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44bc8267c9412d726ac51245ec3bb2935c5baca3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f26a3587a6270640d7843ccdbfe9cc12379eba24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f26a3587a6270640d7843ccdbfe9cc12379eba24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f26a3587a6270640d7843ccdbfe9cc12379eba24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f26a3587a6270640d7843ccdbfe9cc12379eba24/comments", "author": null, "committer": null, "parents": [{"sha": "f24ea9120d7b97d0b6b047de94865f7f190e6daa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f24ea9120d7b97d0b6b047de94865f7f190e6daa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f24ea9120d7b97d0b6b047de94865f7f190e6daa"}], "stats": {"total": 314, "additions": 182, "deletions": 132}, "files": [{"sha": "9368c08b9f20dabd094bf77c983e7020baa435ef", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f26a3587a6270640d7843ccdbfe9cc12379eba24", "patch": "@@ -1,3 +1,28 @@\n+2016-06-22  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* lib-xref-spark_specific.adb, a-cuprqu.ads, sem_ch6.adb: Minor\n+\treformatting.\n+\n+2016-06-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_util.ads (Address_Value): Declare new function.\n+\t* sem_util.adb (Address_Value): New function extracted\n+\tunmodified from Apply_Address_Clause_Check, which returns the\n+\tunderlying value of the expression of an address clause.\n+\t* checks.adb (Compile_Time_Bad_Alignment): Delete.\n+\t(Apply_Address_Clause_Check): Call Address_Value on\n+\tthe expression.  Do not issue the main warning here and\n+\tissue the secondary warning only when the value of the\n+\texpression is not known at compile time.\n+\t* sem_ch13.adb (Address_Clause_Check_Record): Add A component and\n+\tadjust the description.\n+\t(Analyze_Attribute_Definition_Clause): In the case\n+\tof an address, move up the code creating an entry in the table of\n+\taddress clauses.  Also create an entry for an absolute address.\n+\t(Validate_Address_Clauses): Issue the warning for absolute\n+\taddresses here too.  Tweak condition associated with overlays\n+\tfor consistency.\n+\n 2016-06-22  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Is_Predicate_Static): An inherited predicate"}, {"sha": "591673e7d602b6fd78dda6522f1fc002f29b9842", "filename": "gcc/ada/a-cuprqu.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fa-cuprqu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fa-cuprqu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cuprqu.ads?ref=f26a3587a6270640d7843ccdbfe9cc12379eba24", "patch": "@@ -123,10 +123,10 @@ package Ada.Containers.Unbounded_Priority_Queues is\n       overriding function Peak_Use return Count_Type;\n \n    private\n-      Q_Elems              : Set;\n+      Q_Elems : Set;\n       --  Elements of the queue\n \n-      Max_Length           : Count_Type := 0;\n+      Max_Length : Count_Type := 0;\n       --  The current length of the queue is the Length of Q_Elems. This is the\n       --  maximum value of that, so far. Updated by Enqueue.\n "}, {"sha": "157bd065bd9ca13f62f431ffcb0fbe5634bc0d1b", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 12, "deletions": 71, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=f26a3587a6270640d7843ccdbfe9cc12379eba24", "patch": "@@ -638,36 +638,12 @@ package body Checks is\n       AC   : constant Node_Id    := Address_Clause (E);\n       Loc  : constant Source_Ptr := Sloc (AC);\n       Typ  : constant Entity_Id  := Etype (E);\n-      Aexp : constant Node_Id    := Expression (AC);\n \n       Expr : Node_Id;\n       --  Address expression (not necessarily the same as Aexp, for example\n       --  when Aexp is a reference to a constant, in which case Expr gets\n       --  reset to reference the value expression of the constant).\n \n-      procedure Compile_Time_Bad_Alignment;\n-      --  Post error warnings when alignment is known to be incompatible. Note\n-      --  that we do not go as far as inserting a raise of Program_Error since\n-      --  this is an erroneous case, and it may happen that we are lucky and an\n-      --  underaligned address turns out to be OK after all.\n-\n-      --------------------------------\n-      -- Compile_Time_Bad_Alignment --\n-      --------------------------------\n-\n-      procedure Compile_Time_Bad_Alignment is\n-      begin\n-         if Address_Clause_Overlay_Warnings then\n-            Error_Msg_FE\n-              (\"?o?specified address for& may be inconsistent with alignment\",\n-               Aexp, E);\n-            Error_Msg_FE\n-              (\"\\?o?program execution may be erroneous (RM 13.3(27))\",\n-               Aexp, E);\n-            Set_Address_Warning_Posted (AC);\n-         end if;\n-      end Compile_Time_Bad_Alignment;\n-\n    --  Start of processing for Apply_Address_Clause_Check\n \n    begin\n@@ -690,43 +666,11 @@ package body Checks is\n \n       --  Obtain expression from address clause\n \n-      Expr := Expression (AC);\n-\n-      --  The following loop digs for the real expression to use in the check\n-\n-      loop\n-         --  For constant, get constant expression\n-\n-         if Is_Entity_Name (Expr)\n-           and then Ekind (Entity (Expr)) = E_Constant\n-         then\n-            Expr := Constant_Value (Entity (Expr));\n-\n-         --  For unchecked conversion, get result to convert\n+      Expr := Address_Value (Expression (AC));\n \n-         elsif Nkind (Expr) = N_Unchecked_Type_Conversion then\n-            Expr := Expression (Expr);\n-\n-         --  For (common case) of To_Address call, get argument\n-\n-         elsif Nkind (Expr) = N_Function_Call\n-           and then Is_Entity_Name (Name (Expr))\n-           and then Is_RTE (Entity (Name (Expr)), RE_To_Address)\n-         then\n-            Expr := First (Parameter_Associations (Expr));\n-\n-            if Nkind (Expr) = N_Parameter_Association then\n-               Expr := Explicit_Actual_Parameter (Expr);\n-            end if;\n-\n-         --  We finally have the real expression\n-\n-         else\n-            exit;\n-         end if;\n-      end loop;\n-\n-      --  See if we know that Expr has a bad alignment at compile time\n+      --  See if we know that Expr has an acceptable value at compile time. If\n+      --  it hasn't or we don't know, we defer issuing the warning until the\n+      --  end of the compilation to take into account back end annotations.\n \n       if Compile_Time_Known_Value (Expr)\n         and then (Known_Alignment (E) or else Known_Alignment (Typ))\n@@ -742,9 +686,7 @@ package body Checks is\n                AL := Alignment (E);\n             end if;\n \n-            if Expr_Value (Expr) mod AL /= 0 then\n-               Compile_Time_Bad_Alignment;\n-            else\n+            if Expr_Value (Expr) mod AL = 0 then\n                return;\n             end if;\n          end;\n@@ -818,12 +760,11 @@ package body Checks is\n          Warning_Msg := No_Error_Msg;\n          Analyze (First (Actions (N)), Suppress => All_Checks);\n \n-         --  If the address clause generated a warning message (for example,\n+         --  If the above raise action generated a warning message (for example\n          --  from Warn_On_Non_Local_Exception mode with the active restriction\n          --  No_Exception_Propagation).\n \n          if Warning_Msg /= No_Error_Msg then\n-\n             --  If the expression has a known at compile time value, then\n             --  once we know the alignment of the type, we can check if the\n             --  exception will be raised or not, and if not, we don't need\n@@ -832,13 +773,13 @@ package body Checks is\n             if Compile_Time_Known_Value (Expr) then\n                Alignment_Warnings.Append\n                  ((E => E, A => Expr_Value (Expr), W => Warning_Msg));\n-            end if;\n-\n-            --  Add explanation of the warning that is generated by the check\n+            else\n+               --  Add explanation of the warning generated by the check\n \n-            Error_Msg_N\n-              (\"\\address value may be incompatible with alignment \"\n-               & \"of object?X?\", AC);\n+               Error_Msg_N\n+                 (\"\\address value may be incompatible with alignment \"\n+                  & \"of object?X?\", AC);\n+            end if;\n          end if;\n \n          return;"}, {"sha": "fca2eea1f6c1d5ba54c68785e2551f2d48737bcd", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=f26a3587a6270640d7843ccdbfe9cc12379eba24", "patch": "@@ -932,34 +932,34 @@ package body SPARK_Specific is\n             declare\n                Cunit1 : Node_Id renames Cunit (Sdep_Table (D1));\n                Cunit2 : Node_Id renames Cunit (Sdep_Table (D1 + 1));\n+\n             begin\n                --  Both Cunit point to compilation unit nodes\n-               pragma Assert (Nkind (Cunit1) = N_Compilation_Unit\n-                                and then\n-                              Nkind (Cunit2) = N_Compilation_Unit);\n+\n+               pragma Assert\n+                 (Nkind (Cunit1) = N_Compilation_Unit\n+                   and then Nkind (Cunit2) = N_Compilation_Unit);\n \n                --  Do not depend on the sorting order, which is based on\n                --  Unit_Name and for library-level instances of nested\n                --  generic-packages they are equal.\n \n                --  If declaration comes before the body then just set D2\n+\n                if Nkind (Unit (Cunit1)) = N_Package_Declaration\n-                 and then\n-                  Nkind (Unit (Cunit2)) = N_Package_Body\n+                 and then Nkind (Unit (Cunit2)) = N_Package_Body\n                then\n                   D2 := D1 + 1;\n \n                --  If body comes before declaration then set D2 and adjust D1\n \n                elsif Nkind (Unit (Cunit1)) = N_Package_Body\n-                       and then\n-                     Nkind (Unit (Cunit2)) = N_Package_Declaration\n+                 and then Nkind (Unit (Cunit2)) = N_Package_Declaration\n                then\n                   D2 := D1;\n                   D1 := D1 + 1;\n \n                else\n-\n                   raise Program_Error;\n                end if;\n             end;\n@@ -978,6 +978,8 @@ package body SPARK_Specific is\n                Dspec => D2);\n          end if;\n \n+         --  ??? this needs a comment\n+\n          D1 := Pos'Max (D1, D2) + 1;\n       end loop;\n "}, {"sha": "3c1c1b69e1a57252645a835c4fcf57f52cec2976", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 85, "deletions": 49, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f26a3587a6270640d7843ccdbfe9cc12379eba24", "patch": "@@ -273,9 +273,10 @@ package body Sem_Ch13 is\n \n    --    for X'Address use Expr\n \n-   --  where Expr is of the form Y'Address or recursively is a reference to a\n-   --  constant of either of these forms, and X and Y are entities of objects,\n-   --  then if Y has a smaller alignment than X, that merits a warning about\n+   --  where Expr has a value known at compile time or is of the form Y'Address\n+   --  or recursively is a reference to a constant initialized with either of\n+   --  these forms, and the value of Expr is not a multiple of X's alignment,\n+   --  or if Y has a smaller alignment than X, then that merits a warning about\n    --  possible bad alignment. The following table collects address clauses of\n    --  this kind. We put these in a table so that they can be checked after the\n    --  back end has completed annotation of the alignments of objects, since we\n@@ -286,13 +287,16 @@ package body Sem_Ch13 is\n       --  The address clause\n \n       X : Entity_Id;\n-      --  The entity of the object overlaying Y\n+      --  The entity of the object subject to the address clause\n+\n+      A : Uint;\n+      --  The value of the address in the first case\n \n       Y : Entity_Id;\n-      --  The entity of the object being overlaid\n+      --  The entity of the object being overlaid in the second case\n \n       Off : Boolean;\n-      --  Whether the address is offset within Y\n+      --  Whether the address is offset within Y in the second case\n    end record;\n \n    package Address_Clause_Checks is new Table.Table (\n@@ -4849,6 +4853,40 @@ package body Sem_Ch13 is\n                         Set_Overlays_Constant (U_Ent);\n                      end if;\n \n+                     --  If the address clause is of the form:\n+\n+                     --    for X'Address use Y'Address;\n+\n+                     --  or\n+\n+                     --    C : constant Address := Y'Address;\n+                     --    ...\n+                     --    for X'Address use C;\n+\n+                     --  then we make an entry in the table to check the size\n+                     --  and alignment of the overlaying variable. But we defer\n+                     --  this check till after code generation to take full\n+                     --  advantage of the annotation done by the back end.\n+\n+                     --  If the entity has a generic type, the check will be\n+                     --  performed in the instance if the actual type justifies\n+                     --  it, and we do not insert the clause in the table to\n+                     --  prevent spurious warnings.\n+\n+                     --  Note: we used to test Comes_From_Source and only give\n+                     --  this warning for source entities, but we have removed\n+                     --  this test. It really seems bogus to generate overlays\n+                     --  that would trigger this warning in generated code.\n+                     --  Furthermore, by removing the test, we handle the\n+                     --  aspect case properly.\n+\n+                     if Is_Object (O_Ent)\n+                       and then not Is_Generic_Type (Etype (U_Ent))\n+                       and then Address_Clause_Overlay_Warnings\n+                     then\n+                        Address_Clause_Checks.Append\n+                          ((N, U_Ent, No_Uint, O_Ent, Off));\n+                     end if;\n                   else\n                      --  If this is not an overlay, mark a variable as being\n                      --  volatile to prevent unwanted optimizations. It's a\n@@ -4861,6 +4899,21 @@ package body Sem_Ch13 is\n                      if Ekind (U_Ent) = E_Variable then\n                         Set_Treat_As_Volatile (U_Ent);\n                      end if;\n+\n+                     --  Make an entry in the table for an absolute address as\n+                     --  above to check that the value is compatible with the\n+                     --  alignment of the object.\n+\n+                     declare\n+                        Addr : constant Node_Id := Address_Value (Expr);\n+                     begin\n+                        if Compile_Time_Known_Value (Addr)\n+                          and then Address_Clause_Overlay_Warnings\n+                        then\n+                           Address_Clause_Checks.Append\n+                             ((N, U_Ent, Expr_Value (Addr), Empty, False));\n+                        end if;\n+                     end;\n                   end if;\n \n                   --  Overlaying controlled objects is erroneous. Emit warning\n@@ -4950,41 +5003,6 @@ package body Sem_Ch13 is\n                   --  the variable, it is somewhere else.\n \n                   Kill_Size_Check_Code (U_Ent);\n-\n-                  --  If the address clause is of the form:\n-\n-                  --    for Y'Address use X'Address\n-\n-                  --  or\n-\n-                  --    Const : constant Address := X'Address;\n-                  --    ...\n-                  --    for Y'Address use Const;\n-\n-                  --  then we make an entry in the table for checking the size\n-                  --  and alignment of the overlaying variable. We defer this\n-                  --  check till after code generation to take full advantage\n-                  --  of the annotation done by the back end.\n-\n-                  --  If the entity has a generic type, the check will be\n-                  --  performed in the instance if the actual type justifies\n-                  --  it, and we do not insert the clause in the table to\n-                  --  prevent spurious warnings.\n-\n-                  --  Note: we used to test Comes_From_Source and only give\n-                  --  this warning for source entities, but we have removed\n-                  --  this test. It really seems bogus to generate overlays\n-                  --  that would trigger this warning in generated code.\n-                  --  Furthermore, by removing the test, we handle the\n-                  --  aspect case properly.\n-\n-                  if Present (O_Ent)\n-                    and then Is_Object (O_Ent)\n-                    and then not Is_Generic_Type (Etype (U_Ent))\n-                    and then Address_Clause_Overlay_Warnings\n-                  then\n-                     Address_Clause_Checks.Append ((N, U_Ent, O_Ent, Off));\n-                  end if;\n                end;\n \n             --  Not a valid entity for an address clause\n@@ -13183,15 +13201,15 @@ package body Sem_Ch13 is\n             if not Address_Warning_Posted (ACCR.N) then\n                Expr := Original_Node (Expression (ACCR.N));\n \n-               --  Get alignments\n+               --  Get alignments, sizes and offset, if any\n \n                X_Alignment := Alignment (ACCR.X);\n-               Y_Alignment := Alignment (ACCR.Y);\n-\n-               --  Similarly obtain sizes and offset\n-\n                X_Size := Esize (ACCR.X);\n-               Y_Size := Esize (ACCR.Y);\n+\n+               if Present (ACCR.Y) then\n+                  Y_Alignment := Alignment (ACCR.Y);\n+                  Y_Size := Esize (ACCR.Y);\n+               end if;\n \n                if ACCR.Off\n                  and then Nkind (Expr) = N_Attribute_Reference\n@@ -13202,9 +13220,27 @@ package body Sem_Ch13 is\n                   X_Offs := Uint_0;\n                end if;\n \n+               --  Check for known value not multiple of alignment\n+\n+               if No (ACCR.Y) then\n+                  if not Alignment_Checks_Suppressed (ACCR.X)\n+                    and then X_Alignment /= 0\n+                    and then ACCR.A mod X_Alignment /= 0\n+                  then\n+                     Error_Msg_NE\n+                       (\"??specified address for& is inconsistent with \"\n+                        & \"alignment\", ACCR.N, ACCR.X);\n+                     Error_Msg_N\n+                       (\"\\??program execution may be erroneous (RM 13.3(27))\",\n+                        ACCR.N);\n+\n+                     Error_Msg_Uint_1 := X_Alignment;\n+                     Error_Msg_NE (\"\\??alignment of & is ^\", ACCR.N, ACCR.X);\n+                  end if;\n+\n                --  Check for large object overlaying smaller one\n \n-               if Y_Size > Uint_0\n+               elsif Y_Size > Uint_0\n                  and then X_Size > Uint_0\n                  and then X_Offs + X_Size > Y_Size\n                then\n@@ -13232,7 +13268,7 @@ package body Sem_Ch13 is\n                --  Note: we do not check the alignment if we gave a size\n                --  warning, since it would likely be redundant.\n \n-               elsif not Alignment_Checks_Suppressed (ACCR.Y)\n+               elsif not Alignment_Checks_Suppressed (ACCR.X)\n                  and then Y_Alignment /= Uint_0\n                  and then\n                    (Y_Alignment < X_Alignment"}, {"sha": "81b0ca787e4984558f930dabb0b02fdccf9d1e02", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f26a3587a6270640d7843ccdbfe9cc12379eba24", "patch": "@@ -10808,8 +10808,8 @@ package body Sem_Ch6 is\n                     and then not Is_Class_Wide_Type (Formal_Type)\n                   then\n                      if not Nkind_In\n-                       (Parent (T), N_Access_Function_Definition,\n-                                    N_Access_Procedure_Definition)\n+                              (Parent (T), N_Access_Function_Definition,\n+                                           N_Access_Procedure_Definition)\n                      then\n                         Append_Elmt (Current_Scope,\n                           Private_Dependents (Base_Type (Formal_Type)));"}, {"sha": "8ff3535c2b044f09c0cd002582f85920b7814064", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f26a3587a6270640d7843ccdbfe9cc12379eba24", "patch": "@@ -286,6 +286,49 @@ package body Sem_Util is\n       end if;\n    end Address_Integer_Convert_OK;\n \n+   -------------------\n+   -- Address_Value --\n+   -------------------\n+\n+   function Address_Value (N : Node_Id) return Node_Id is\n+      Expr : Node_Id := N;\n+\n+   begin\n+      loop\n+         --  For constant, get constant expression\n+\n+         if Is_Entity_Name (Expr)\n+           and then Ekind (Entity (Expr)) = E_Constant\n+         then\n+            Expr := Constant_Value (Entity (Expr));\n+\n+         --  For unchecked conversion, get result to convert\n+\n+         elsif Nkind (Expr) = N_Unchecked_Type_Conversion then\n+            Expr := Expression (Expr);\n+\n+         --  For (common case) of To_Address call, get argument\n+\n+         elsif Nkind (Expr) = N_Function_Call\n+           and then Is_Entity_Name (Name (Expr))\n+           and then Is_RTE (Entity (Name (Expr)), RE_To_Address)\n+         then\n+            Expr := First (Parameter_Associations (Expr));\n+\n+            if Nkind (Expr) = N_Parameter_Association then\n+               Expr := Explicit_Actual_Parameter (Expr);\n+            end if;\n+\n+         --  We finally have the real expression\n+\n+         else\n+            exit;\n+         end if;\n+      end loop;\n+\n+      return Expr;\n+   end Address_Value;\n+\n    -----------------\n    -- Addressable --\n    -----------------"}, {"sha": "711c321e1323336aa66173405f6acdaa43ed8bed", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26a3587a6270640d7843ccdbfe9cc12379eba24/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f26a3587a6270640d7843ccdbfe9cc12379eba24", "patch": "@@ -65,6 +65,9 @@ package Sem_Util is\n    --  and one of the types is (a descendant of) System.Address (and this type\n    --  is private), and the other type is any integer type.\n \n+   function Address_Value (N : Node_Id) return Node_Id;\n+   --  Return the underlying value of the expression N of an address clause\n+\n    function Addressable (V : Uint) return Boolean;\n    function Addressable (V : Int)  return Boolean;\n    pragma Inline (Addressable);"}]}