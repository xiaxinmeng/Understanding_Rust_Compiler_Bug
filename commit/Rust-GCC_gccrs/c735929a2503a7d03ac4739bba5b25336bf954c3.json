{"sha": "c735929a2503a7d03ac4739bba5b25336bf954c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzczNTkyOWEyNTAzYTdkMDNhYzQ3MzliYmE1YjI1MzM2YmY5NTRjMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-29T10:00:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-29T11:00:36Z"}, "message": "tree-optimization/95272 - add SLP_TREE_REPRESENTATIVE\n\nThis adds SLP_TREE_REPRESENTATIVE - a representative stmt-info that\nis used by SLP analysis and code generation.  This avoids the need\nfor the hack in vect_slp_rearrange_stmts which previously avoided\nto re-arrange stmts that might not have been isomorphic because\nof operand swapping.  It also plays nice with future directions of SLP\nand for the forseeable future is easier than replicating more and\nmore info in the SLP node as long as non-SLP is in-tree.\n\n2020-05-29  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/95272\n\t* tree-vectorizer.h (_slp_tree::representative): Add.\n\t(SLP_TREE_REPRESENTATIVE): Likewise.\n\t* tree-vect-loop.c (vectorizable_reduction): Adjust SLP\n\tnode gathering.\n\t(vectorizable_live_operation): Use the representative to\n\tattach the reduction info to.\n\t* tree-vect-slp.c (_slp_tree::_slp_tree): Initialize\n\tSLP_TREE_REPRESENTATIVE.\n\t(vect_create_new_slp_node): Likewise.\n\t(slp_copy_subtree): Copy it.\n\t(vect_slp_rearrange_stmts): Re-arrange even COND_EXPR stmts.\n\t(vect_slp_analyze_node_operations_1): Pass the representative\n\tto vect_analyze_stmt.\n\t(vect_schedule_slp_instance): Pass the representative to\n\tvect_transform_stmt.\n\n\t* gcc.dg/vect/pr95272.c: New testcase.", "tree": {"sha": "32a3c744207e5a93d1b9d156a2fb1caa6d2ff10c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32a3c744207e5a93d1b9d156a2fb1caa6d2ff10c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c735929a2503a7d03ac4739bba5b25336bf954c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c735929a2503a7d03ac4739bba5b25336bf954c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c735929a2503a7d03ac4739bba5b25336bf954c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c735929a2503a7d03ac4739bba5b25336bf954c3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddf90b72d2a723decc487db6d3131846b9a618de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddf90b72d2a723decc487db6d3131846b9a618de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddf90b72d2a723decc487db6d3131846b9a618de"}], "stats": {"total": 45, "additions": 33, "deletions": 12}, "files": [{"sha": "47698ff3e566afdf57886312a8186e340c7d4e65", "filename": "gcc/testsuite/gcc.dg/vect/pr95272.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735929a2503a7d03ac4739bba5b25336bf954c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr95272.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735929a2503a7d03ac4739bba5b25336bf954c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr95272.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr95272.c?ref=c735929a2503a7d03ac4739bba5b25336bf954c3", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+enum { a = 5, b };\n+typedef struct {\n+  int c[b];\n+} d;\n+extern d e[];\n+int f;\n+int g[6];\n+void h() {\n+  int i;\n+  for (; f; f++) {\n+    i = 0;\n+    for (; i < b; i++)\n+      if (e[f].c[i])\n+        g[i] = e[f].c[i];\n+  }\n+}"}, {"sha": "3c5c0ea9ebcf853729886d5cbf15688b7a86784c", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735929a2503a7d03ac4739bba5b25336bf954c3/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735929a2503a7d03ac4739bba5b25336bf954c3/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c735929a2503a7d03ac4739bba5b25336bf954c3", "patch": "@@ -6192,9 +6192,9 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n     {\n       slp_for_stmt_info = slp_node_instance->root;\n       /* And then there's reduction chain with a conversion ...  */\n-      if (SLP_TREE_SCALAR_STMTS (slp_for_stmt_info)[0] != stmt_info)\n+      if (SLP_TREE_REPRESENTATIVE (slp_for_stmt_info) != stmt_info)\n \tslp_for_stmt_info = SLP_TREE_CHILDREN (slp_for_stmt_info)[0];\n-      gcc_assert (SLP_TREE_SCALAR_STMTS (slp_for_stmt_info)[0] == stmt_info);\n+      gcc_assert (SLP_TREE_REPRESENTATIVE (slp_for_stmt_info) == stmt_info);\n     }\n   slp_tree *slp_op = XALLOCAVEC (slp_tree, op_type);\n   for (i = 0; i < op_type; i++)\n@@ -7952,6 +7952,10 @@ vectorizable_live_operation (loop_vec_info loop_vinfo,\n \t     all involved stmts together.  */\n \t  else if (slp_index != 0)\n \t    return true;\n+\t  else\n+\t    /* For SLP reductions the meta-info is attached to\n+\t       the representative.  */\n+\t    stmt_info = SLP_TREE_REPRESENTATIVE (slp_node);\n \t}\n       stmt_vec_info reduc_info = info_for_reduction (loop_vinfo, stmt_info);\n       gcc_assert (reduc_info->is_reduc_info);"}, {"sha": "836defce9901683b000216f98c809451c7c82c5d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735929a2503a7d03ac4739bba5b25336bf954c3/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735929a2503a7d03ac4739bba5b25336bf954c3/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c735929a2503a7d03ac4739bba5b25336bf954c3", "patch": "@@ -61,6 +61,7 @@ _slp_tree::_slp_tree ()\n   SLP_TREE_TWO_OPERATORS (this) = false;\n   SLP_TREE_DEF_TYPE (this) = vect_uninitialized_def;\n   SLP_TREE_VECTYPE (this) = NULL_TREE;\n+  SLP_TREE_REPRESENTATIVE (this) = NULL;\n   this->refcnt = 1;\n   this->max_nunits = 1;\n }\n@@ -132,6 +133,7 @@ vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts, unsigned nops)\n   SLP_TREE_SCALAR_STMTS (node) = scalar_stmts;\n   SLP_TREE_CHILDREN (node).create (nops);\n   SLP_TREE_DEF_TYPE (node) = vect_internal_def;\n+  SLP_TREE_REPRESENTATIVE (node) = scalar_stmts[0];\n \n   unsigned i;\n   stmt_vec_info stmt_info;\n@@ -1741,6 +1743,7 @@ slp_copy_subtree (slp_tree node, hash_map<slp_tree, slp_tree> &map)\n   slp_tree copy = copy_ref;\n   SLP_TREE_DEF_TYPE (copy) = SLP_TREE_DEF_TYPE (node);\n   SLP_TREE_VECTYPE (copy) = SLP_TREE_VECTYPE (node);\n+  SLP_TREE_REPRESENTATIVE (copy) = SLP_TREE_REPRESENTATIVE (node);\n   copy->max_nunits = node->max_nunits;\n   copy->refcnt = 0;\n   if (SLP_TREE_SCALAR_STMTS (node).exists ())\n@@ -1786,14 +1789,6 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n   if (SLP_TREE_SCALAR_STMTS (node).exists ())\n     {\n       gcc_assert (group_size == SLP_TREE_SCALAR_STMTS (node).length ());\n-      /* ???  Computation nodes are isomorphic and need no rearrangement.\n-\t This is a quick hack to cover those where rearrangement breaks\n-\t semantics because only the first stmt is guaranteed to have the\n-\t correct operation code due to others being swapped or inverted.  */\n-      stmt_vec_info first = SLP_TREE_SCALAR_STMTS (node)[0];\n-      if (is_gimple_assign (first->stmt)\n-\t  && gimple_assign_rhs_code (first->stmt) == COND_EXPR)\n-\treturn;\n       vec<stmt_vec_info> tmp_stmts;\n       tmp_stmts.create (group_size);\n       tmp_stmts.quick_grow (group_size);\n@@ -2664,7 +2659,7 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n \t\t\t\t    slp_instance node_instance,\n \t\t\t\t    stmt_vector_for_cost *cost_vec)\n {\n-  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n+  stmt_vec_info stmt_info = SLP_TREE_REPRESENTATIVE (node);\n   gcc_assert (STMT_SLP_TYPE (stmt_info) != loop_vect);\n \n   /* Calculate the number of vector statements to be created for the\n@@ -4079,7 +4074,7 @@ vect_schedule_slp_instance (vec_info *vinfo,\n \t  STMT_VINFO_DEF_TYPE (child_stmt_info) = SLP_TREE_DEF_TYPE (child);\n       }\n \n-  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n+  stmt_vec_info stmt_info = SLP_TREE_REPRESENTATIVE (node);\n \n   /* VECTYPE is the type of the destination.  */\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);"}, {"sha": "5a5648b37847c94334219717f4ca53720200db73", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735929a2503a7d03ac4739bba5b25336bf954c3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735929a2503a7d03ac4739bba5b25336bf954c3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c735929a2503a7d03ac4739bba5b25336bf954c3", "patch": "@@ -128,6 +128,9 @@ struct _slp_tree {\n   vec<stmt_vec_info> stmts;\n   /* A group of scalar operands to be vectorized together.  */\n   vec<tree> ops;\n+  /* The representative that should be used for analysis and\n+     code generation.  */\n+  stmt_vec_info representative;\n \n   /* Load permutation relative to the stores, NULL if there is no\n      permutation.  */\n@@ -193,6 +196,7 @@ typedef class _slp_instance {\n #define SLP_TREE_TWO_OPERATORS(S)\t\t (S)->two_operators\n #define SLP_TREE_DEF_TYPE(S)\t\t\t (S)->def_type\n #define SLP_TREE_VECTYPE(S)\t\t\t (S)->vectype\n+#define SLP_TREE_REPRESENTATIVE(S)\t\t (S)->representative\n \n /* Key for map that records association between\n    scalar conditions and corresponding loop mask, and"}]}