{"sha": "0e82f089719b464e4d5959b45555b3dd135ae745", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU4MmYwODk3MTliNDY0ZTRkNTk1OWI0NTU1NWIzZGQxMzVhZTc0NQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2014-10-10T17:19:25Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2014-10-10T17:19:25Z"}, "message": "asan.c (pass_sanopt::execute): Handle IFN_UBSAN_OBJECT_SIZE.\n\n\t* asan.c (pass_sanopt::execute): Handle IFN_UBSAN_OBJECT_SIZE.\n\t* doc/invoke.texi: Document -fsanitize=object-size.\n\t* flag-types.h (enum sanitize_code): Add SANITIZE_OBJECT_SIZE and\n\tor it into SANITIZE_UNDEFINED.\n\t* gimple-fold.c (gimple_fold_call): Optimize IFN_UBSAN_OBJECT_SIZE.\n\t* internal-fn.c (expand_UBSAN_OBJECT_SIZE): New function.\n\t* internal-fn.def (UBSAN_OBJECT_SIZE): Define.\n\t* opts.c (common_handle_option): Handle -fsanitize=object-size.\n\t* ubsan.c: Include tree-object-size.h.\n\t(ubsan_type_descriptor): Call tree_to_uhwi instead of tree_to_shwi. \n\t(ubsan_expand_bounds_ifn): Use false instead of 0.\n\t(ubsan_expand_objsize_ifn): New function.\n\t(instrument_object_size): New function.\n\t(pass_ubsan::execute): Add object size instrumentation.\n\t* ubsan.h (ubsan_expand_objsize_ifn): Declare.\ntestsuite/\n\t* c-c++-common/ubsan/object-size-1.c: New test.\n\t* c-c++-common/ubsan/object-size-2.c: New test.\n\t* c-c++-common/ubsan/object-size-3.c: New test.\n\t* c-c++-common/ubsan/object-size-4.c: New test.\n\t* c-c++-common/ubsan/object-size-5.c: New test.\n\t* c-c++-common/ubsan/object-size-6.c: New test.\n\t* c-c++-common/ubsan/object-size-7.c: New test.\n\t* c-c++-common/ubsan/object-size-8.c: New test.\n\t* c-c++-common/ubsan/object-size-9.c: New test.\n\t* g++.dg/ubsan/object-size-1.C: New test.\n\t* gcc.dg/ubsan/object-size-9.c: New test.\n\nFrom-SVN: r216099", "tree": {"sha": "eb4a7b7db8a68e97f6fffec5e090f0363f3e519d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb4a7b7db8a68e97f6fffec5e090f0363f3e519d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e82f089719b464e4d5959b45555b3dd135ae745", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e82f089719b464e4d5959b45555b3dd135ae745", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e82f089719b464e4d5959b45555b3dd135ae745", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e82f089719b464e4d5959b45555b3dd135ae745/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c95e71bef8bec02c1edea04bd332503075472071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c95e71bef8bec02c1edea04bd332503075472071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c95e71bef8bec02c1edea04bd332503075472071"}], "stats": {"total": 751, "additions": 745, "deletions": 6}, "files": [{"sha": "3190099126b52fab8766861657e1ab373140aa31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -1,3 +1,21 @@\n+2014-10-10  Marek Polacek  <polacek@redhat.com>\n+\n+\t* asan.c (pass_sanopt::execute): Handle IFN_UBSAN_OBJECT_SIZE.\n+\t* doc/invoke.texi: Document -fsanitize=object-size.\n+\t* flag-types.h (enum sanitize_code): Add SANITIZE_OBJECT_SIZE and\n+\tor it into SANITIZE_UNDEFINED.\n+\t* gimple-fold.c (gimple_fold_call): Optimize IFN_UBSAN_OBJECT_SIZE.\n+\t* internal-fn.c (expand_UBSAN_OBJECT_SIZE): New function.\n+\t* internal-fn.def (UBSAN_OBJECT_SIZE): Define.\n+\t* opts.c (common_handle_option): Handle -fsanitize=object-size.\n+\t* ubsan.c: Include tree-object-size.h.\n+\t(ubsan_type_descriptor): Call tree_to_uhwi instead of tree_to_shwi. \n+\t(ubsan_expand_bounds_ifn): Use false instead of 0.\n+\t(ubsan_expand_objsize_ifn): New function.\n+\t(instrument_object_size): New function.\n+\t(pass_ubsan::execute): Add object size instrumentation.\n+\t* ubsan.h (ubsan_expand_objsize_ifn): Declare.\n+\n 2014-10-10  Richard Henderson  <rth@redhat.com>\n \n \tPR target/63404"}, {"sha": "6ea3efe2f11a296ba124a77143b7758c6cd581cc", "filename": "gcc/asan.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -2879,6 +2879,9 @@ pass_sanopt::execute (function *fun)\n \t\tcase IFN_UBSAN_BOUNDS:\n \t\t  no_next = ubsan_expand_bounds_ifn (&gsi);\n \t\t  break;\n+\t\tcase IFN_UBSAN_OBJECT_SIZE:\n+\t\t  no_next = ubsan_expand_objsize_ifn (&gsi);\n+\t\t  break;\n \t\tcase IFN_ASAN_CHECK:\n \t\t  {\n \t\t    no_next = asan_expand_check_ifn (&gsi, use_calls);"}, {"sha": "2b62a73c9522146a6335f05fdbcd0245af279c05", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -5578,6 +5578,12 @@ This option enables checking of alignment of pointers when they are\n dereferenced, or when a reference is bound to insufficiently aligned target,\n or when a method or constructor is invoked on insufficiently aligned object.\n \n+@item -fsanitize=object-size\n+@opindex fsanitize=object-size\n+This option enables instrumentation of memory references using the\n+@code{__builtin_object_size} function.  Various out of bounds pointer\n+accesses are detected.\n+\n @item -fsanitize=float-divide-by-zero\n @opindex fsanitize=float-divide-by-zero\n Detect floating-point division by zero.  Unlike other similar options,"}, {"sha": "3d01c4981eb2d3c2b4540d15918eeeb7cad113b3", "filename": "gcc/flag-types.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -236,12 +236,14 @@ enum sanitize_code {\n   SANITIZE_ALIGNMENT = 1 << 17,\n   SANITIZE_NONNULL_ATTRIBUTE = 1 << 18,\n   SANITIZE_RETURNS_NONNULL_ATTRIBUTE = 1 << 19,\n+  SANITIZE_OBJECT_SIZE = 1 << 20,\n   SANITIZE_UNDEFINED = SANITIZE_SHIFT | SANITIZE_DIVIDE | SANITIZE_UNREACHABLE\n \t\t       | SANITIZE_VLA | SANITIZE_NULL | SANITIZE_RETURN\n \t\t       | SANITIZE_SI_OVERFLOW | SANITIZE_BOOL | SANITIZE_ENUM\n \t\t       | SANITIZE_BOUNDS | SANITIZE_ALIGNMENT\n \t\t       | SANITIZE_NONNULL_ATTRIBUTE\n-\t\t       | SANITIZE_RETURNS_NONNULL_ATTRIBUTE,\n+\t\t       | SANITIZE_RETURNS_NONNULL_ATTRIBUTE\n+\t\t       | SANITIZE_OBJECT_SIZE,\n   SANITIZE_NONDEFAULT = SANITIZE_FLOAT_DIVIDE | SANITIZE_FLOAT_CAST\n };\n "}, {"sha": "76441c746bc868ab6e127d69f357de359b266298", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -2662,6 +2662,19 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t\t\t\t\tgimple_call_arg (stmt, 1),\n \t\t\t\t\tgimple_call_arg (stmt, 2));\n \t  break;\n+\tcase IFN_UBSAN_OBJECT_SIZE:\n+\t  if (integer_all_onesp (gimple_call_arg (stmt, 2))\n+\t      || (TREE_CODE (gimple_call_arg (stmt, 1)) == INTEGER_CST\n+\t\t  && TREE_CODE (gimple_call_arg (stmt, 2)) == INTEGER_CST\n+\t\t  && tree_int_cst_le (gimple_call_arg (stmt, 1),\n+\t\t\t\t      gimple_call_arg (stmt, 2))))\n+\t    {\n+\t      gsi_replace (gsi, gimple_build_nop (), true);\n+\t      unlink_stmt_vdef (stmt);\n+\t      release_defs (stmt);\n+\t      return true;\n+\t    }\n+\t  break;\n \tcase IFN_UBSAN_CHECK_ADD:\n \t  subcode = PLUS_EXPR;\n \t  break;"}, {"sha": "c71259d197f817a0675699934e3c43a98faeaee9", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -183,6 +183,14 @@ expand_UBSAN_BOUNDS (gimple stmt ATTRIBUTE_UNUSED)\n \n /* This should get expanded in the sanopt pass.  */\n \n+static void\n+expand_UBSAN_OBJECT_SIZE (gimple stmt ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* This should get expanded in the sanopt pass.  */\n+\n static void\n expand_ASAN_CHECK (gimple stmt ATTRIBUTE_UNUSED)\n {"}, {"sha": "b8e457c509035385945d9bc50bfd5d8a3306486a", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -53,6 +53,7 @@ DEF_INTERNAL_FN (UBSAN_BOUNDS, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (UBSAN_CHECK_ADD, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (UBSAN_CHECK_SUB, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (UBSAN_CHECK_MUL, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (UBSAN_OBJECT_SIZE, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ABNORMAL_DISPATCHER, ECF_NORETURN, NULL)\n DEF_INTERNAL_FN (BUILTIN_EXPECT, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ASAN_CHECK, ECF_TM_PURE | ECF_LEAF | ECF_NOTHROW, \".W...\")"}, {"sha": "3d9b6a71830f3b8fcea291fa69ae20f737d2ab25", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -1513,6 +1513,8 @@ common_handle_option (struct gcc_options *opts,\n \t      { \"returns-nonnull-attribute\",\n \t\tSANITIZE_RETURNS_NONNULL_ATTRIBUTE,\n \t\tsizeof \"returns-nonnull-attribute\" - 1 },\n+\t      { \"object-size\", SANITIZE_OBJECT_SIZE,\n+\t\tsizeof \"object-size\" - 1 },\n \t      { NULL, 0, 0 }\n \t    };\n \t    const char *comma;"}, {"sha": "b8cd638dd7d0547699bee9c7a58ab264404d19ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -1,3 +1,17 @@\n+2014-10-10  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-c++-common/ubsan/object-size-1.c: New test.\n+\t* c-c++-common/ubsan/object-size-2.c: New test.\n+\t* c-c++-common/ubsan/object-size-3.c: New test.\n+\t* c-c++-common/ubsan/object-size-4.c: New test.\n+\t* c-c++-common/ubsan/object-size-5.c: New test.\n+\t* c-c++-common/ubsan/object-size-6.c: New test.\n+\t* c-c++-common/ubsan/object-size-7.c: New test.\n+\t* c-c++-common/ubsan/object-size-8.c: New test.\n+\t* c-c++-common/ubsan/object-size-9.c: New test.\n+\t* g++.dg/ubsan/object-size-1.C: New test.\n+\t* gcc.dg/ubsan/object-size-9.c: New test.\n+\n 2014-10-10  Max Ostapenko  <m.ostapenko@partner.samsung.com>\n \n \t* lib/asan-dg.exp (asan_link_flags): Save ld_library_path."}, {"sha": "7a3c87a9edd9ab4e682d41a3fead150a1191fa8a", "filename": "gcc/testsuite/c-c++-common/ubsan/object-size-1.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-1.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -0,0 +1,125 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } } */\n+/* { dg-options \"-fsanitize=undefined\" } */\n+\n+/* Sanity-test -fsanitize=object-size.  We use -fsanitize=undefined option\n+   to check that this feature doesn't clash with -fsanitize=bounds et al.  */\n+\n+#define N 20\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int i)\n+{\n+  volatile int j;\n+  char *p, *orig;\n+  orig = p = (char *) __builtin_calloc (N, 1);\n+  j = *(p + i);\n+  j = p[i];\n+  p++;\n+  j = p[i - 1];\n+  j = *(p + i - 1);\n+  __builtin_free (orig);\n+}\n+\n+/* { dg-output \"load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+\n+__attribute__((noinline, noclone)) void\n+f2 (int i)\n+{\n+  volatile int j;\n+  char a[N];\n+  __builtin_memset (a, 0, N);\n+  j = *(a + i);\n+  char *p = a;\n+  j = *(p + i);\n+  j = p[i];\n+  p += 10;\n+  j = *(p + i - 10);\n+  j = p[i - 10];\n+}\n+\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+\n+__attribute__((noinline, noclone)) void\n+f3 (int i)\n+{\n+  volatile int j;\n+  int *p = (int *) __builtin_calloc (N, sizeof (*p));\n+  int *o = &p[i];\n+  j = *o;\n+  j = o[0];\n+  __builtin_free (p);\n+}\n+\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+\n+__attribute__((noinline, noclone)) void\n+f4 (void)\n+{\n+  /* The second argument to __builtin_calloc is intentional.  */\n+  int *p = (int *) __builtin_calloc (3, 1);\n+  *p = 42;\n+  __builtin_free (p);\n+}\n+\n+/* { dg-output \"\\[^\\n\\r]*store to address \\[^\\n\\r]* with insufficient space for an object of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+\n+__attribute__((noinline, noclone)) void\n+f5 (int *p)\n+{\n+  /* This is not instrumented.  But don't ICE, etc.  */\n+  volatile int i = p[N];\n+}\n+\n+int\n+main ()\n+{\n+  f1 (N);\n+  f2 (N);\n+  f3 (N);\n+  f4 ();\n+  int *p = (int *) __builtin_calloc (N, sizeof (*p));\n+  f5 (p);\n+  __builtin_free (p);\n+  return 0;\n+}"}, {"sha": "dba12433c66affa6ad4aac6b21de155bfa6184e1", "filename": "gcc/testsuite/c-c++-common/ubsan/object-size-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-2.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } } */\n+/* { dg-options \"-fsanitize=undefined\" } */\n+\n+void\n+foo (unsigned long ul)\n+{\n+  unsigned int u;\n+  u = *(unsigned long *) ul;\n+}"}, {"sha": "62dc76f8b59e399c816d5df8d03f1b80ed543fb5", "filename": "gcc/testsuite/c-c++-common/ubsan/object-size-3.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-3.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } } */\n+/* { dg-options \"-fsanitize=object-size -fno-sanitize-recover\" } */\n+\n+/* Test valid uses.  */\n+\n+#define N 20\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int i)\n+{\n+  volatile int j;\n+  char *p, *orig;\n+  orig = p = (char *) __builtin_calloc (N, 1);\n+  j = *(p + i);\n+  j = p[i];\n+  p++;\n+  j = p[i - 1];\n+  j = *(p + i - 1);\n+  __builtin_free (orig);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (int i)\n+{\n+  volatile int j;\n+  char a[N];\n+  __builtin_memset (a, 0, N);\n+  j = *(a + i);\n+  char *p = a;\n+  j = *(p + i);\n+  j = p[i];\n+  p += 10;\n+  j = *(p + i - 10);\n+  j = p[i - 10];\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (int i)\n+{\n+  volatile int j;\n+  int *p = (int *) __builtin_calloc (N, sizeof (*p));\n+  int *o = &p[i];\n+  j = *o;\n+  j = o[0];\n+  __builtin_free (p);\n+}\n+\n+int\n+main ()\n+{\n+  f1 (N - 1);\n+  f2 (N - 1);\n+  f3 (N - 1);\n+  return 0;\n+}"}, {"sha": "8b95ec9c800e9e1f2aeb19256e47946d414695f5", "filename": "gcc/testsuite/c-c++-common/ubsan/object-size-4.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-4.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } } */\n+/* { dg-options \"-fsanitize=object-size\" } */\n+\n+/* Test that we instrument flexible array members.  */\n+\n+struct T { int l; int a[]; };\n+struct U { int l; int a[0]; };\n+\n+int\n+main (void)\n+{\n+  volatile int i;\n+  struct T *t = (struct T *) __builtin_calloc (sizeof (struct T)\n+\t\t\t\t\t       + sizeof (int), 1);\n+  i = t->a[1];\n+\n+  struct U *u = (struct U *) __builtin_calloc (sizeof (struct U)\n+\t\t\t\t\t       + sizeof (int), 1);\n+  i = u->a[1];\n+  return 0;\n+}\n+\n+/* { dg-output \"load of address \\[^\\n\\r]* with insufficient space for an object of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "3dada101befa42f612e798d290ee200653226a33", "filename": "gcc/testsuite/c-c++-common/ubsan/object-size-5.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-5.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } } */\n+/* { dg-options \"-fsanitize=object-size\" } */\n+\n+/* Test structures with -fsanitize=object-size.  */\n+\n+#define N 20\n+\n+struct S { char *p; int i; };\n+struct T { struct S *s; };\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int i)\n+{\n+  volatile int j;\n+  struct S s;\n+  s.p = (char *) __builtin_calloc (N, 1);\n+  j = s.p[i];\n+  j = *(s.p + i);\n+  __builtin_free (s.p);\n+}\n+\n+/* { dg-output \"load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+\n+int\n+main ()\n+{\n+  f1 (N);\n+  f1 (N - 1);\n+  return 0;\n+}"}, {"sha": "0e6035d0384d476e990f32dfaa9f4dcb4381ce35", "filename": "gcc/testsuite/c-c++-common/ubsan/object-size-6.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-6.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } } */\n+/* { dg-options \"-fsanitize=object-size\" } */\n+\n+char\n+foo (void *v)\n+{\n+  return *(char *) v;\n+}"}, {"sha": "f5b26e50c8a074d79f9581040353789ad0c18f21", "filename": "gcc/testsuite/c-c++-common/ubsan/object-size-7.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-7.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } } */\n+/* { dg-options \"-fsanitize=object-size\" } */\n+\n+#define N 20\n+\n+struct S { int a; };\n+\n+__attribute__((noinline, noclone)) struct S\n+f1 (int i)\n+{\n+  struct S a[N];\n+  struct S *p = a;\n+  struct S s;\n+  s = p[i];\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  f1 (N);\n+  return 0;\n+}\n+\n+/* { dg-output \"load of address \\[^\\n\\r]* with insufficient space for an object of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "ee0945b902c4ac5382f0bdf9fb6b3c04e4564a16", "filename": "gcc/testsuite/c-c++-common/ubsan/object-size-8.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-8.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } } */\n+/* { dg-options \"-fsanitize=undefined\" } */\n+\n+struct S { int a; int b; };\n+\n+static inline __attribute__((always_inline)) int\n+foo (struct S *p)\n+{\n+  volatile int a;\n+  a = p->a; /* OK */\n+  return p->b;\n+}\n+\n+int\n+bar (void)\n+{\n+  struct S *p = (struct S *) __builtin_calloc (sizeof (int) + sizeof (int) / 2, 1);\n+  return foo (p);\n+}\n+\n+int\n+main (void)\n+{\n+  bar ();\n+  return 0;\n+}\n+\n+/* { dg-output \"load of address \\[^\\n\\r]* with insufficient space for an object of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "829c822959228d5e4c9f0f784b59684bcb195c3b", "filename": "gcc/testsuite/c-c++-common/ubsan/object-size-9.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-9.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } } */\n+/* { dg-options \"-fsanitize=undefined\" } */\n+\n+/* Test PARM_DECLs and RESULT_DECLs.  */\n+\n+struct T { char d[8]; int e; };\n+struct T t = { \"abcdefg\", 1 };\n+#ifdef __cplusplus\n+struct C { C () : d(\"abcdefg\"), e(1) {} C (const C &x) { __builtin_memcpy (d, x.d, 8); e = x.e; } ~C () {} char d[8]; int e; };\n+#endif\n+struct U { int a : 5; int b : 19; int c : 8; };\n+struct S { struct U d[10]; };\n+struct S s;\n+\n+int\n+f1 (struct T x, int i)\n+{\n+  char *p = x.d;\n+  p += i;\n+  return *p;\n+}\n+\n+/* { dg-output \"load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+\n+#ifdef __cplusplus\n+struct C\n+f2 (int i)\n+{\n+  struct C x;\n+  x.d[i] = 'z';\n+  return x;\n+}\n+\n+/* { dg-output \"\\[^\\n\\r]*index 12 out of bounds for type 'char \\\\\\[8\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { c++ } } } */\n+/* { dg-output \"\\[^\\n\\r]*store to address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { c++ } } } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { c++ } } } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { c++ } } } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { c++ } } } */\n+\n+struct C\n+f3 (int i)\n+{\n+  struct C x;\n+  char *p = x.d;\n+  p += i;\n+  *p = 'z';\n+  return x;\n+}\n+\n+/* { dg-output \"\\[^\\n\\r]*store to address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { c++ } } } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { c++ } } } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { c++ } } } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { c++ } } } */\n+\n+#endif\n+\n+int\n+f4 (int i)\n+{\n+  return s.d[i].b;\n+}\n+\n+/* { dg-output \"\\[^\\n\\r]*index 12 out of bounds for type 'U \\\\\\[10\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+\n+int\n+f5 (int i)\n+{\n+  struct U *u = s.d;\n+  u += i;\n+  return u->b;\n+}\n+\n+/* { dg-output \"\\[^\\n\\r]*load of address \\[^\\n\\r]* with insufficient space for an object of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+\n+int\n+main (void)\n+{\n+  f1 (t, 12);\n+#ifdef __cplusplus\n+  f2 (12);\n+  f3 (12);\n+#endif\n+  f4 (12);\n+  f5 (12);\n+  return 0;\n+}"}, {"sha": "e2aad4670bbb16c3a84fa95eb6e7efe28a3f038a", "filename": "gcc/testsuite/g++.dg/ubsan/object-size-1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fobject-size-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fobject-size-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fobject-size-1.C?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile }\n+// { dg-options \"-fsanitize=undefined -fpermissive\" }\n+\n+struct T { int c; char d[]; };\n+\n+struct T t = { 1, \"a\" }; // { dg-warning \"initializer-string for array of chars is too long\" }\n+\n+int\n+baz (int i)\n+{\n+  return t.d[i];\n+}\n+\n+int\n+main (void)\n+{\n+  baz (3);\n+}"}, {"sha": "bb9aa1bb1606baf0205438d71101afb272205feb", "filename": "gcc/testsuite/gcc.dg/ubsan/object-size-9.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fobject-size-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fobject-size-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fobject-size-9.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } } */\n+/* { dg-options \"-fsanitize=undefined\" } */\n+\n+struct T { int c; char d[]; };\n+struct T t = { 1, \"a\" };\n+\n+int\n+baz (int i)\n+{\n+  return t.d[i];\n+}\n+\n+int\n+main (void)\n+{\n+  baz (2);\n+  return 0;\n+}\n+\n+/* { dg-output \"load of address \\[^\\n\\r]* with insufficient space for an object of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*note: pointer points here\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\\\^\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "dde0418dca305053c4a51d129cc8acac804a2a05", "filename": "gcc/ubsan.c", "status": "modified", "additions": 207, "deletions": 5, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"realmpfr.h\"\n #include \"dfp.h\"\n #include \"builtins.h\"\n+#include \"tree-object-size.h\"\n \n /* Map from a tree to a VAR_DECL tree.  */\n \n@@ -391,7 +392,7 @@ ubsan_type_descriptor (tree type, enum ubsan_print_style pstyle)\n \t  tree dom = TYPE_DOMAIN (t);\n \t  if (dom && TREE_CODE (TYPE_MAX_VALUE (dom)) == INTEGER_CST)\n \t    pos += sprintf (&pretty_name[pos], HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t    tree_to_shwi (TYPE_MAX_VALUE (dom)) + 1);\n+\t\t\t    tree_to_uhwi (TYPE_MAX_VALUE (dom)) + 1);\n \t  else\n \t    /* ??? We can't determine the variable name; print VLA unspec.  */\n \t    pretty_name[pos++] = '*';\n@@ -614,12 +615,12 @@ ubsan_expand_bounds_ifn (gimple_stmt_iterator *gsi)\n   /* Create condition \"if (index > bound)\".  */\n   basic_block then_bb, fallthru_bb;\n   gimple_stmt_iterator cond_insert_point\n-    = create_cond_insert_point (gsi, 0/*before_p*/, false, true,\n+    = create_cond_insert_point (gsi, false, false, true,\n \t\t\t\t&then_bb, &fallthru_bb);\n   index = fold_convert (TREE_TYPE (bound), index);\n   index = force_gimple_operand_gsi (&cond_insert_point, index,\n-\t\t\t\t    true/*simple_p*/, NULL_TREE,\n-\t\t\t\t    false/*before*/, GSI_NEW_STMT);\n+\t\t\t\t    true, NULL_TREE,\n+\t\t\t\t    false, GSI_NEW_STMT);\n   gimple g = gimple_build_cond (GT_EXPR, index, bound, NULL_TREE, NULL_TREE);\n   gimple_set_location (g, loc);\n   gsi_insert_after (&cond_insert_point, g, GSI_NEW_STMT);\n@@ -830,6 +831,76 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n   return false;\n }\n \n+/* Expand UBSAN_OBJECT_SIZE internal call.  */\n+\n+bool\n+ubsan_expand_objsize_ifn (gimple_stmt_iterator *gsi)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  location_t loc = gimple_location (stmt);\n+  gcc_assert (gimple_call_num_args (stmt) == 4);\n+\n+  tree ptr = gimple_call_arg (stmt, 0);\n+  tree offset = gimple_call_arg (stmt, 1);\n+  tree size = gimple_call_arg (stmt, 2);\n+  tree ckind = gimple_call_arg (stmt, 3);\n+  gimple_stmt_iterator gsi_orig = *gsi;\n+  gimple g;\n+\n+  /* See if we can discard the check.  */\n+  if (TREE_CODE (size) != INTEGER_CST\n+      || integer_all_onesp (size))\n+    /* Yes, __builtin_object_size couldn't determine the\n+       object size.  */;\n+  else\n+    {\n+      /* if (offset > objsize) */\n+      basic_block then_bb, fallthru_bb;\n+      gimple_stmt_iterator cond_insert_point\n+\t= create_cond_insert_point (gsi, false, false, true,\n+\t\t\t\t    &then_bb, &fallthru_bb);\n+      g = gimple_build_cond (GT_EXPR, offset, size, NULL_TREE, NULL_TREE);\n+      gimple_set_location (g, loc);\n+      gsi_insert_after (&cond_insert_point, g, GSI_NEW_STMT);\n+\n+      /* Generate __ubsan_handle_type_mismatch call.  */\n+      *gsi = gsi_after_labels (then_bb);\n+      if (flag_sanitize_undefined_trap_on_error)\n+\tg = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+      else\n+\t{\n+\t  tree data\n+\t    = ubsan_create_data (\"__ubsan_objsz_data\", 1, &loc,\n+\t\t\t\t ubsan_type_descriptor (TREE_TYPE (ptr),\n+\t\t\t\t\t\t\tUBSAN_PRINT_POINTER),\n+\t\t\t\t NULL_TREE,\n+\t\t\t\t build_zero_cst (pointer_sized_int_node),\n+\t\t\t\t ckind,\n+\t\t\t\t NULL_TREE);\n+\t  data = build_fold_addr_expr_loc (loc, data);\n+\t  enum built_in_function bcode\n+\t    = flag_sanitize_recover\n+\t      ? BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH\n+\t      : BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_ABORT;\n+\t  tree p = make_ssa_name (pointer_sized_int_node, NULL);\n+\t  g = gimple_build_assign_with_ops (NOP_EXPR, p, ptr, NULL_TREE);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t  g = gimple_build_call (builtin_decl_explicit (bcode), 2, data, p);\n+\t}\n+      gimple_set_location (g, loc);\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\n+      /* Point GSI to next logical statement.  */\n+      *gsi = gsi_start_bb (fallthru_bb);\n+    }\n+\n+  /* Get rid of the UBSAN_OBJECT_SIZE call from the IR.  */\n+  unlink_stmt_vdef (stmt);\n+  gsi_remove (&gsi_orig, true);\n+  return gsi_end_p (*gsi);\n+}\n+\n /* Instrument a memory reference.  BASE is the base of MEM, IS_LHS says\n    whether the pointer is on the left hand side of the assignment.  */\n \n@@ -1339,6 +1410,128 @@ instrument_nonnull_return (gimple_stmt_iterator *gsi)\n   flag_delete_null_pointer_checks = save_flag_delete_null_pointer_checks;\n }\n \n+/* Instrument memory references.  Here we check whether the pointer\n+   points to an out-of-bounds location.  */\n+\n+static void\n+instrument_object_size (gimple_stmt_iterator *gsi, bool is_lhs)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  location_t loc = gimple_location (stmt);\n+  tree t = is_lhs ? gimple_get_lhs (stmt) : gimple_assign_rhs1 (stmt);\n+  tree type;\n+  HOST_WIDE_INT size_in_bytes;\n+\n+  type = TREE_TYPE (t);\n+  if (VOID_TYPE_P (type))\n+    return;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case COMPONENT_REF:\n+      if (TREE_CODE (t) == COMPONENT_REF\n+\t  && DECL_BIT_FIELD_REPRESENTATIVE (TREE_OPERAND (t, 1)) != NULL_TREE)\n+\t{\n+\t  tree repr = DECL_BIT_FIELD_REPRESENTATIVE (TREE_OPERAND (t, 1));\n+\t  t = build3 (COMPONENT_REF, TREE_TYPE (repr), TREE_OPERAND (t, 0),\n+\t\t      repr, NULL_TREE);\n+\t}\n+      break;\n+    case ARRAY_REF:\n+    case INDIRECT_REF:\n+    case MEM_REF:\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+      break;\n+    default:\n+      return;\n+    }\n+\n+  size_in_bytes = int_size_in_bytes (type);\n+  if (size_in_bytes <= 0)\n+    return;\n+\n+  HOST_WIDE_INT bitsize, bitpos;\n+  tree offset;\n+  enum machine_mode mode;\n+  int volatilep = 0, unsignedp = 0;\n+  tree inner = get_inner_reference (t, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t    &unsignedp, &volatilep, false);\n+\n+  if (bitpos % BITS_PER_UNIT != 0\n+      || bitsize != size_in_bytes * BITS_PER_UNIT)\n+    return;\n+\n+  bool decl_p = DECL_P (inner);\n+  tree base = decl_p ? inner : TREE_OPERAND (inner, 0);\n+  tree ptr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (t)), t);\n+\n+  while (TREE_CODE (base) == SSA_NAME)\n+    {\n+      gimple def_stmt = SSA_NAME_DEF_STMT (base);\n+      if (gimple_assign_ssa_name_copy_p (def_stmt)\n+\t  || (gimple_assign_cast_p (def_stmt)\n+\t      && POINTER_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (def_stmt))))\n+\t  || (is_gimple_assign (def_stmt)\n+\t      && gimple_assign_rhs_code (def_stmt) == POINTER_PLUS_EXPR))\n+\tbase = gimple_assign_rhs1 (def_stmt);\n+      else\n+\tbreak;\n+    }\n+\n+  if (!POINTER_TYPE_P (TREE_TYPE (base)) && !DECL_P (base))\n+    return;\n+\n+  tree sizet;\n+  tree base_addr = base;\n+  if (decl_p)\n+    base_addr = build1 (ADDR_EXPR,\n+\t\t\tbuild_pointer_type (TREE_TYPE (base)), base);\n+  unsigned HOST_WIDE_INT size = compute_builtin_object_size (base_addr, 0);\n+  if (size != (unsigned HOST_WIDE_INT) -1)\n+    sizet = build_int_cst (sizetype, size);\n+  else if (optimize)\n+    {\n+      if (LOCATION_LOCUS (loc) == UNKNOWN_LOCATION)\n+\tloc = input_location;\n+      /* Generate __builtin_object_size call.  */\n+      sizet = builtin_decl_explicit (BUILT_IN_OBJECT_SIZE);\n+      sizet = build_call_expr_loc (loc, sizet, 2, base_addr,\n+\t\t\t\t   integer_zero_node);\n+      sizet = force_gimple_operand_gsi (gsi, sizet, false, NULL_TREE, true,\n+\t\t\t\t\tGSI_SAME_STMT);\n+    }\n+  else\n+    return;\n+\n+  /* Generate UBSAN_OBJECT_SIZE (ptr, ptr+sizeof(*ptr)-base, objsize, ckind)\n+     call.  */\n+  /* ptr + sizeof (*ptr) - base */\n+  t = fold_build2 (MINUS_EXPR, sizetype,\n+\t\t   fold_convert (pointer_sized_int_node, ptr),\n+\t\t   fold_convert (pointer_sized_int_node, base_addr));\n+  t = fold_build2 (PLUS_EXPR, sizetype, t, TYPE_SIZE_UNIT (type));\n+\n+  /* Perhaps we can omit the check.  */\n+  if (TREE_CODE (t) == INTEGER_CST\n+      && TREE_CODE (sizet) == INTEGER_CST\n+      && tree_int_cst_le (t, sizet))\n+    return;\n+\n+  /* Nope.  Emit the check.  */\n+  t = force_gimple_operand_gsi (gsi, t, true, NULL_TREE, true,\n+\t\t\t\tGSI_SAME_STMT);\n+  ptr = force_gimple_operand_gsi (gsi, ptr, true, NULL_TREE, true,\n+\t\t\t\t  GSI_SAME_STMT);\n+  tree ckind = build_int_cst (unsigned_char_type_node,\n+\t\t\t      is_lhs ? UBSAN_STORE_OF : UBSAN_LOAD_OF);\n+  gimple g = gimple_build_call_internal (IFN_UBSAN_OBJECT_SIZE, 4,\n+\t\t\t\t\t ptr, t, sizet, ckind);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+}\n+\n namespace {\n \n const pass_data pass_data_ubsan =\n@@ -1368,7 +1561,8 @@ class pass_ubsan : public gimple_opt_pass\n \t\t\t      | SANITIZE_BOOL | SANITIZE_ENUM\n \t\t\t      | SANITIZE_ALIGNMENT\n \t\t\t      | SANITIZE_NONNULL_ATTRIBUTE\n-\t\t\t      | SANITIZE_RETURNS_NONNULL_ATTRIBUTE)\n+\t\t\t      | SANITIZE_RETURNS_NONNULL_ATTRIBUTE\n+\t\t\t      | SANITIZE_OBJECT_SIZE)\n \t     && current_function_decl != NULL_TREE\n \t     && !lookup_attribute (\"no_sanitize_undefined\",\n \t\t\t\t   DECL_ATTRIBUTES (current_function_decl));\n@@ -1431,6 +1625,14 @@ pass_ubsan::execute (function *fun)\n \t      bb = gimple_bb (stmt);\n \t    }\n \n+\t  if (flag_sanitize & SANITIZE_OBJECT_SIZE)\n+\t    {\n+\t      if (gimple_store_p (stmt))\n+\t\tinstrument_object_size (&gsi, true);\n+\t      if (gimple_assign_load_p (stmt))\n+\t\tinstrument_object_size (&gsi, false);\n+\t    }\n+\n \t  gsi_next (&gsi);\n \t}\n     }"}, {"sha": "27c18eb00f8af3a2d49caae0733757e3f936a10d", "filename": "gcc/ubsan.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e82f089719b464e4d5959b45555b3dd135ae745/gcc%2Fubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.h?ref=0e82f089719b464e4d5959b45555b3dd135ae745", "patch": "@@ -40,6 +40,7 @@ enum ubsan_print_style {\n \n extern bool ubsan_expand_bounds_ifn (gimple_stmt_iterator *);\n extern bool ubsan_expand_null_ifn (gimple_stmt_iterator *);\n+extern bool ubsan_expand_objsize_ifn (gimple_stmt_iterator *);\n extern tree ubsan_instrument_unreachable (location_t);\n extern tree ubsan_create_data (const char *, int, const location_t *, ...);\n extern tree ubsan_type_descriptor (tree, enum ubsan_print_style = UBSAN_PRINT_NORMAL);"}]}