{"sha": "ba4619917b508b212f83883cd1b63fbb7e0e1ca6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0NjE5OTE3YjUwOGIyMTJmODM4ODNjZDFiNjNmYmI3ZTBlMWNhNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-03-03T17:49:53Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-03-03T17:49:53Z"}, "message": "re PR fortran/43243 ([4.4 Regression ?] Wrong-code due to missing array temp for DT with pointer component)\n\n2010-03-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43243\n\t* trans-array.c (gfc_conv_array_parameter): Contiguous refs to\n\tallocatable ultimate components do not need temporaries, whilst\n\tultimate pointer components do.\n\n2010-03-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43243\n\t* gfortran.dg/internal_pack_12.f90: New test.\n\nFrom-SVN: r157199", "tree": {"sha": "157d8e212af1fb4a1d54684eb6d052c7cb56e2eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/157d8e212af1fb4a1d54684eb6d052c7cb56e2eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba4619917b508b212f83883cd1b63fbb7e0e1ca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4619917b508b212f83883cd1b63fbb7e0e1ca6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba4619917b508b212f83883cd1b63fbb7e0e1ca6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4619917b508b212f83883cd1b63fbb7e0e1ca6/comments", "author": null, "committer": null, "parents": [{"sha": "a82ec6aa3c72f6445f0f3add370d9a25d32e61df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82ec6aa3c72f6445f0f3add370d9a25d32e61df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a82ec6aa3c72f6445f0f3add370d9a25d32e61df"}], "stats": {"total": 107, "additions": 99, "deletions": 8}, "files": [{"sha": "a0eaa3ab0f0594e99715b7a6721a9369aecf9677", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4619917b508b212f83883cd1b63fbb7e0e1ca6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4619917b508b212f83883cd1b63fbb7e0e1ca6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ba4619917b508b212f83883cd1b63fbb7e0e1ca6", "patch": "@@ -1,3 +1,10 @@\n+2010-03-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43243\n+\t* trans-array.c (gfc_conv_array_parameter): Contiguous refs to\n+\tallocatable ultimate components do not need temporaries, whilst\n+\tultimate pointer components do.\n+\n 2010-03-03  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/43169"}, {"sha": "8eea3aca716dd9e1e167fe98dbaf9d6cdd906dbd", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4619917b508b212f83883cd1b63fbb7e0e1ca6/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4619917b508b212f83883cd1b63fbb7e0e1ca6/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ba4619917b508b212f83883cd1b63fbb7e0e1ca6", "patch": "@@ -5474,18 +5474,30 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n   bool no_pack;\n   bool array_constructor;\n   bool good_allocatable;\n+  bool ultimate_ptr_comp;\n+  bool ultimate_alloc_comp;\n   gfc_symbol *sym;\n   stmtblock_t block;\n   gfc_ref *ref;\n \n+  ultimate_ptr_comp = false;\n+  ultimate_alloc_comp = false;\n   for (ref = expr->ref; ref; ref = ref->next)\n-    if (ref->next == NULL)\n-      break;\n+    {\n+      if (ref->next == NULL)\n+        break;\n+\n+      if (ref->type == REF_COMPONENT)\n+\t{\n+\t  ultimate_ptr_comp = ref->u.c.component->attr.pointer;\n+\t  ultimate_alloc_comp = ref->u.c.component->attr.allocatable;\n+\t}\n+    }\n \n   full_array_var = false;\n   contiguous = false;\n \n-  if (expr->expr_type == EXPR_VARIABLE && ref)\n+  if (expr->expr_type == EXPR_VARIABLE && ref && !ultimate_ptr_comp)\n     full_array_var = gfc_full_array_ref_p (ref, &contiguous);\n \n   sym = full_array_var ? expr->symtree->n.sym : NULL;\n@@ -5552,6 +5564,9 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n         }\n     }\n \n+  /* A convenient reduction in scope.  */\n+  contiguous = g77 && !this_array_result && contiguous;\n+\n   /* There is no need to pack and unpack the array, if it is contiguous\n      and not deferred or assumed shape.  */\n   no_pack = ((sym && sym->as\n@@ -5563,17 +5578,20 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n \t\t  && ref->u.ar.as->type != AS_DEFERRED\n \t\t  && ref->u.ar.as->type != AS_ASSUMED_SHAPE));\n \n-  no_pack = g77 && !this_array_result && contiguous && no_pack;\n+  no_pack = contiguous && no_pack;\n \n   /* Array constructors are always contiguous and do not need packing.  */\n   array_constructor = g77 && !this_array_result && expr->expr_type == EXPR_ARRAY;\n \n   /* Same is true of contiguous sections from allocatable variables.  */\n-  good_allocatable = (g77 && !this_array_result && contiguous\n-\t\t\t&& expr->symtree\n-\t\t\t&& expr->symtree->n.sym->attr.allocatable);\n+  good_allocatable = contiguous\n+\t\t       && expr->symtree\n+\t\t       && expr->symtree->n.sym->attr.allocatable;\n+\n+  /* Or ultimate allocatable components.  */\n+  ultimate_alloc_comp = contiguous && ultimate_alloc_comp; \n \n-  if (no_pack || array_constructor || good_allocatable)\n+  if (no_pack || array_constructor || good_allocatable || ultimate_alloc_comp)\n     {\n       gfc_conv_expr_descriptor (se, expr, ss);\n       if (expr->ts.type == BT_CHARACTER)"}, {"sha": "ba742fde47329e23970beb99e0985409918c1490", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4619917b508b212f83883cd1b63fbb7e0e1ca6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4619917b508b212f83883cd1b63fbb7e0e1ca6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ba4619917b508b212f83883cd1b63fbb7e0e1ca6", "patch": "@@ -1,3 +1,8 @@\n+2010-03-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43243\n+\t* gfortran.dg/internal_pack_12.f90: New test.\n+\n 2010-03-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.dg/pr36997.c: Adjust error message."}, {"sha": "32bacfa39302a75152b83bcbee527821515dcbd5", "filename": "gcc/testsuite/gfortran.dg/internal_pack_12.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4619917b508b212f83883cd1b63fbb7e0e1ca6/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4619917b508b212f83883cd1b63fbb7e0e1ca6/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_12.f90?ref=ba4619917b508b212f83883cd1b63fbb7e0e1ca6", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Test the fix for PR43243, where unnecessary calls to internal_pack/unpack\n+! were being produced below. These references are contiguous and so do not\n+! need a temporary. In addition, the final call to 'bar' required a pack/unpack\n+! which had been missing since r156680, at least.\n+!\n+! Contributed Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module m\n+  type t\n+    integer, allocatable :: a(:)\n+    integer, pointer :: b(:)\n+    integer :: c(5)\n+  end type t\n+end module m\n+\n+subroutine foo(a,d,e,n)\n+  use m\n+  implicit none\n+  integer :: n\n+  type(t) :: a\n+  type(t), allocatable :: d(:)\n+  type(t), pointer :: e(:)\n+  call bar(   a%a) ! OK - no array temp needed\n+  call bar(   a%c) ! OK - no array temp needed\n+\n+  call bar(   a%a(1:n)) ! Missed: No pack needed\n+  call bar(   a%b(1:n)) ! OK: pack needed\n+  call bar(   a%c(1:n)) ! Missed: No pack needed\n+\n+  call bar(d(1)%a(1:n)) ! Missed: No pack needed\n+  call bar(d(1)%b(1:n)) ! OK: pack needed\n+  call bar(d(1)%c(1:n)) ! Missed: No pack needed\n+\n+  call bar(e(1)%a(1:n)) ! Missed: No pack needed\n+  call bar(e(1)%b(1:n)) ! OK: pack needed\n+  call bar(e(1)%c(1:n)) ! Missed: No pack needed\n+end subroutine foo\n+\n+use m\n+implicit none\n+integer :: i\n+integer, target :: z(6)\n+type(t) :: y\n+\n+z = [(i, i=1,6)]\n+y%b => z(::2)\n+call bar(y%b)  ! Missed: Pack needed\n+end\n+\n+subroutine bar(x)\n+  integer :: x(1:*)\n+  print *, x(1:3)\n+  if (any (x(1:3) /= [1,3,5])) call abort ()\n+end subroutine bar\n+! { dg-final { scan-tree-dump-times \"unpack\" 4 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+! { dg-final { cleanup-modules \"m\" } }\n+"}]}