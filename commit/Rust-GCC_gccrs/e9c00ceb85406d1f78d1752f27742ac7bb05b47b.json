{"sha": "e9c00ceb85406d1f78d1752f27742ac7bb05b47b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTljMDBjZWI4NTQwNmQxZjc4ZDE3NTJmMjc3NDJhYzdiYjA1YjQ3Yg==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2004-11-23T19:43:11Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-11-23T19:43:11Z"}, "message": "tree-vectorizer.c (vect_analyze_operations): Don't vectorize if the vectorization factor is greater than the iteration count.\n\n        * tree-vectorizer.c (vect_analyze_operations): Don't vectorize if\n        the vectorization factor is greater than the iteration count.\n        (vect_gen_niters_for_prolog_loop): No need to calculate min if the\n        iteration count is known.\n\n        (vect_build_symbol_bound): Removed. Its functionality moved to\n        vect_generate_tmps_on_preheader.\n        (vect_generate_tmps_on_preheader): Moved content of\n        vect_build_symbol_bound here instead of calling it.  Changed some\n        variables names.\n\n        (vect_build_loop_niters): We don't expect a new_bb to be generated -\n        use gcc_assert.\n        (vect_gen_niters_for_prolog_loop): Likewise.\n        (vect_gen_niters_for_prolog_loo): Likewise.\n\n        (slpeel_make_loop_iterate_ntimes): Use buildN instead of build.\n        (slpeel_add_loop_guard): Likewise.\n        (slpeel_tree_peel_loop_to_edge): Likewise.\n        (vect_do_peeling_for_alignment): Likewise.\n\n        (vect_get_first_index): Missing space.\n\nFrom-SVN: r91100", "tree": {"sha": "051fe6494f4f78b5942bb1c15cdd16e09cf571a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/051fe6494f4f78b5942bb1c15cdd16e09cf571a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9c00ceb85406d1f78d1752f27742ac7bb05b47b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9c00ceb85406d1f78d1752f27742ac7bb05b47b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9c00ceb85406d1f78d1752f27742ac7bb05b47b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9c00ceb85406d1f78d1752f27742ac7bb05b47b/comments", "author": null, "committer": null, "parents": [{"sha": "bad82153ee2c6181ae07e72a6f9132f87102b0d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad82153ee2c6181ae07e72a6f9132f87102b0d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bad82153ee2c6181ae07e72a6f9132f87102b0d2"}], "stats": {"total": 181, "additions": 90, "deletions": 91}, "files": [{"sha": "533c8aafa50f15cf04c3fd2a51b41c13136c94a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c00ceb85406d1f78d1752f27742ac7bb05b47b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c00ceb85406d1f78d1752f27742ac7bb05b47b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9c00ceb85406d1f78d1752f27742ac7bb05b47b", "patch": "@@ -1,3 +1,28 @@\n+2004-11-23  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* tree-vectorizer.c (vect_analyze_operations): Don't vectorize if\n+\tthe vectorization factor is greater than the iteration count.\n+\t(vect_gen_niters_for_prolog_loop): No need to calculate min if the\n+\titeration count is known.\n+\n+\t(vect_build_symbol_bound): Removed. Its functionality moved to\n+\tvect_generate_tmps_on_preheader.\n+\t(vect_generate_tmps_on_preheader): Moved content of\n+\tvect_build_symbol_bound here instead of calling it.  Changed some\n+\tvariables names.\n+\n+\t(vect_build_loop_niters): We don't expect a new_bb to be generated -\n+\tuse gcc_assert.\n+\t(vect_gen_niters_for_prolog_loop): Likewise.\n+\t(vect_gen_niters_for_prolog_loo): Likewise.\n+\n+\t(slpeel_make_loop_iterate_ntimes): Use buildN instead of build.\n+\t(slpeel_add_loop_guard): Likewise.\n+\t(slpeel_tree_peel_loop_to_edge): Likewise.\n+\t(vect_do_peeling_for_alignment): Likewise.\n+\n+\t(vect_get_first_index): Missing space.\n+\n 2004-11-23  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.md (\"*iordi3\"): Mark commutative."}, {"sha": "8853e88da9c73f9b980ede80fe1490d01e1c6dba", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 65, "deletions": 91, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c00ceb85406d1f78d1752f27742ac7bb05b47b/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c00ceb85406d1f78d1752f27742ac7bb05b47b/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=e9c00ceb85406d1f78d1752f27742ac7bb05b47b", "patch": "@@ -244,7 +244,6 @@ static tree get_vectype_for_scalar_type (tree);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n static tree vect_get_vec_def_for_operand (tree, tree);\n static tree vect_init_vector (tree, tree);\n-static tree vect_build_symbol_bound (tree, int, struct loop *);\n static void vect_finish_stmt_generation \n   (tree stmt, tree vec_stmt, block_stmt_iterator *bsi);\n \n@@ -684,7 +683,7 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n \n   begin_label = build1 (GOTO_EXPR, void_type_node, begin_label);\n   exit_label = build1 (GOTO_EXPR, void_type_node, exit_label);\n-  cond_stmt = build (COND_EXPR, TREE_TYPE (orig_cond), cond,\n+  cond_stmt = build3 (COND_EXPR, TREE_TYPE (orig_cond), cond,\n \t\t     begin_label, exit_label);\n   bsi_insert_before (&loop_exit_bsi, cond_stmt, BSI_SAME_STMT);\n \n@@ -835,7 +834,7 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb,\n                        tree_block_label (exit_bb));\n   else_label = build1 (GOTO_EXPR, void_type_node,\n                        tree_block_label (enter_e->dest));\n-  cond_stmt = build (COND_EXPR, void_type_node, cond,\n+  cond_stmt = build3 (COND_EXPR, void_type_node, cond,\n    \t\t     then_label, else_label);\n   bsi_insert_after (&bsi, cond_stmt, BSI_NEW_STMT);\n   /* Add new edge to connect entry block to the second loop.  */\n@@ -1044,7 +1043,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   flow_loop_scan (second_loop, LOOP_ALL);\n \n   pre_condition =\n-        build (LE_EXPR, boolean_type_node, first_niters, integer_zero_node);\n+        build2 (LE_EXPR, boolean_type_node, first_niters, integer_zero_node);\n   skip_e = slpeel_add_loop_guard (bb_before_first_loop, pre_condition,\n                                   bb_before_second_loop, bb_before_first_loop);\n   slpeel_update_phi_nodes_for_guard (skip_e, first_loop, true /* entry-phis */,\n@@ -1084,7 +1083,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   flow_loop_scan (first_loop, LOOP_ALL);\n   flow_loop_scan (second_loop, LOOP_ALL);\n \n-  pre_condition = build (EQ_EXPR, boolean_type_node, first_niters, niters);\n+  pre_condition = build2 (EQ_EXPR, boolean_type_node, first_niters, niters);\n   skip_e = slpeel_add_loop_guard (bb_between_loops, pre_condition,\n                                   bb_after_second_loop, bb_before_first_loop);\n   slpeel_update_phi_nodes_for_guard (skip_e, second_loop, false /* exit-phis */,\n@@ -2754,7 +2753,6 @@ vect_build_loop_niters (loop_vec_info loop_vinfo)\n {\n   tree ni_name, stmt, var;\n   edge pe;\n-  basic_block new_bb = NULL;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree ni = unshare_expr (LOOP_VINFO_NITERS (loop_vinfo));\n \n@@ -2764,9 +2762,10 @@ vect_build_loop_niters (loop_vec_info loop_vinfo)\n \n   pe = loop_preheader_edge (loop);\n   if (stmt)\n-    new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n-  if (new_bb)\n-    add_bb_to_loop (new_bb, EDGE_PRED (new_bb, 0)->src->loop_father);\n+    {\n+      basic_block new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n+      gcc_assert (!new_bb);\n+    }\n       \n   return ni_name;\n }\n@@ -2781,102 +2780,64 @@ vect_build_loop_niters (loop_vec_info loop_vinfo)\n  and places them at the loop preheader edge.  */\n \n static void \n-vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo, tree *ni_name_p,\n-\t\t\t\t tree *ratio_mult_vf_name_p, tree *ratio_p)\n+vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo, \n+\t\t\t\t tree *ni_name_ptr,\n+\t\t\t\t tree *ratio_mult_vf_name_ptr, \n+\t\t\t\t tree *ratio_name_ptr)\n {\n \n   edge pe;\n   basic_block new_bb;\n   tree stmt, ni_name;\n-  tree ratio;\n-  tree ratio_mult_vf_name, ratio_mult_vf;\n+  tree var;\n+  tree ratio_name;\n+  tree ratio_mult_vf_name;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree ni = LOOP_VINFO_NITERS(loop_vinfo);\n-  \n-  int vf, i;\n+  tree ni = LOOP_VINFO_NITERS (loop_vinfo);\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  tree log_vf = build_int_cst (unsigned_type_node, exact_log2 (vf));\n+\n+  pe = loop_preheader_edge (loop);\n \n   /* Generate temporary variable that contains \n      number of iterations loop executes.  */\n \n   ni_name = vect_build_loop_niters (loop_vinfo);\n \n-  /* ratio = ni / vf.\n-     vf is power of 2; then if ratio =  = n >> log2 (vf).  */\n-  vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  ratio = vect_build_symbol_bound (ni_name, vf, loop);\n-       \n-  /* Update initial conditions of loop copy.  */\n-       \n-  /* ratio_mult_vf = ratio * vf;  \n-     then if ratio_mult_vf = ratio << log2 (vf).  */\n+  /* Create: ratio = ni >> log2(vf) */\n \n-  i = exact_log2 (vf);\n-  ratio_mult_vf = create_tmp_var (TREE_TYPE (ni), \"ratio_mult_vf\");\n-  add_referenced_tmp_var (ratio_mult_vf);\n+  var = create_tmp_var (TREE_TYPE (ni), \"bnd\");\n+  add_referenced_tmp_var (var);\n+  ratio_name = make_ssa_name (var, NULL_TREE);\n+  stmt = build2 (MODIFY_EXPR, void_type_node, ratio_name,\n+\t   build2 (RSHIFT_EXPR, TREE_TYPE (ni_name), ni_name, log_vf));\n+  SSA_NAME_DEF_STMT (ratio_name) = stmt;\n \n-  ratio_mult_vf_name = make_ssa_name (ratio_mult_vf, NULL_TREE);\n+  pe = loop_preheader_edge (loop);\n+  new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n+  gcc_assert (!new_bb);\n+       \n+  /* Create: ratio_mult_vf = ratio << log2 (vf).  */\n \n+  var = create_tmp_var (TREE_TYPE (ni), \"ratio_mult_vf\");\n+  add_referenced_tmp_var (var);\n+  ratio_mult_vf_name = make_ssa_name (var, NULL_TREE);\n   stmt = build2 (MODIFY_EXPR, void_type_node, ratio_mult_vf_name,\n-\t\tbuild2 (LSHIFT_EXPR, TREE_TYPE (ratio),\n-\t\t       ratio, build_int_cst (unsigned_type_node,\n-\t\t\t\t\t     i)));\n-\n+\t   build2 (LSHIFT_EXPR, TREE_TYPE (ratio_name), ratio_name, log_vf));\n   SSA_NAME_DEF_STMT (ratio_mult_vf_name) = stmt;\n \n   pe = loop_preheader_edge (loop);\n   new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n-  if (new_bb)\n-    add_bb_to_loop (new_bb, EDGE_PRED (new_bb, 0)->src->loop_father);\n+  gcc_assert (!new_bb);\n \n-  *ni_name_p = ni_name;\n-  *ratio_mult_vf_name_p = ratio_mult_vf_name;\n-  *ratio_p = ratio;\n+  *ni_name_ptr = ni_name;\n+  *ratio_mult_vf_name_ptr = ratio_mult_vf_name;\n+  *ratio_name_ptr = ratio_name;\n     \n   return;  \n }\n \n \n-/* This function generates stmt \n-   \n-   tmp = n / vf;\n-\n-   and attaches it to preheader of LOOP.  */\n-\n-static tree \n-vect_build_symbol_bound (tree n, int vf, struct loop * loop)\n-{\n-  tree var, stmt, var_name;\n-  edge pe;\n-  basic_block new_bb;\n-  int i;\n-\n-  /* create temporary variable */\n-  var = create_tmp_var (TREE_TYPE (n), \"bnd\");\n-  add_referenced_tmp_var (var);\n-\n-  var_name = make_ssa_name (var, NULL_TREE);\n-\n-  /* vf is power of 2; then n/vf = n >> log2 (vf).  */\n-\n-  i = exact_log2 (vf);\n-  stmt = build2 (MODIFY_EXPR, void_type_node, var_name,\n-\t\tbuild2 (RSHIFT_EXPR, TREE_TYPE (n),\n-\t\t       n, build_int_cst (unsigned_type_node,i)));\n-\n-  SSA_NAME_DEF_STMT (var_name) = stmt;\n-\n-  pe = loop_preheader_edge (loop);\n-  new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n-  if (new_bb)\n-    add_bb_to_loop (new_bb, EDGE_PRED (new_bb, 0)->src->loop_father);\n-  else\t\n-    if (vect_debug_details (NULL))\n-      fprintf (dump_file, \"New bb on preheader edge was not generated.\");\n-\n-  return var_name;\n-}\n-\n-\n /*   Function vect_update_ivs_after_vectorizer.\n \n      \"Advance\" the induction variables of LOOP to the value they should take\n@@ -3104,8 +3065,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n \n   pe = loop_preheader_edge (loop); \n   new_bb = bsi_insert_on_edge_immediate (pe, new_stmts); \n-  if (new_bb)\n-    add_bb_to_loop (new_bb, EDGE_PRED (new_bb, 0)->src->loop_father);\n+  gcc_assert (!new_bb);\n \n   /* Create:  byte_misalign = addr & (vectype_size - 1)  */\n   byte_misalign = build2 (BIT_AND_EXPR, type, start_addr, vectype_size_minus_1);\n@@ -3118,19 +3078,25 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   iters = build2 (MINUS_EXPR, unsigned_type_node, vf_tree, elem_misalign);\n   iters = build2 (BIT_AND_EXPR, unsigned_type_node, iters, vf_minus_1);\n   iters = fold_convert (niters_type, iters);\n-\n+  \n   /* Create:  prolog_loop_niters = min (iters, loop_niters) */\n-  iters = build2 (MIN_EXPR, niters_type, iters, loop_niters);\n+  /* If the loop bound is known at compile time we already verified that it is\n+     greater than vf; since the misalignment ('iters') is at most vf, there's\n+     no need to generate the MIN_EXPR in this case.  */\n+  if (!host_integerp (loop_niters, 0))\n+    iters = build2 (MIN_EXPR, niters_type, iters, loop_niters);\n+\n   var = create_tmp_var (niters_type, \"prolog_loop_niters\");\n   add_referenced_tmp_var (var);\n   iters_name = force_gimple_operand (iters, &stmt, false, var);\n \n   /* Insert stmt on loop preheader edge.  */\n   pe = loop_preheader_edge (loop);\n   if (stmt)\n-    new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n-  if (new_bb)\n-    add_bb_to_loop (new_bb, EDGE_PRED (new_bb, 0)->src->loop_father);\n+    {\n+      basic_block new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n+      gcc_assert (!new_bb);\n+    }\n \n   return iters_name; \n }\n@@ -3154,8 +3120,8 @@ vect_update_inits_of_dr (struct data_reference *dr, struct loop *loop,\n   step = evolution_part_in_loop_num (access_fn, loop->num);\n   init = initial_condition (access_fn);\n       \n-  init_new = build (PLUS_EXPR, TREE_TYPE (init),\n-\t\t  build (MULT_EXPR, TREE_TYPE (niters),\n+  init_new = build2 (PLUS_EXPR, TREE_TYPE (init),\n+\t\t  build2 (MULT_EXPR, TREE_TYPE (niters),\n \t\t\t niters, step), init);\n   DR_ACCESS_FN (dr, 0) = chrec_replace_initial_condition (access_fn, init_new);\n   \n@@ -3441,7 +3407,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n   block_stmt_iterator si;\n-  int vectorization_factor = 0;\n+  unsigned int vectorization_factor = 0;\n   int i;\n   bool ok;\n   tree scalar_type;\n@@ -3456,7 +3422,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t{\n \t  tree stmt = bsi_stmt (si);\n-\t  int nunits;\n+\t  unsigned int nunits;\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \t  tree vectype;\n \n@@ -3578,6 +3544,14 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n         \"vectorization_factor = %d, niters = \" HOST_WIDE_INT_PRINT_DEC,\n         vectorization_factor, LOOP_VINFO_INT_NITERS (loop_vinfo));\n \n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor)\n+    {\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\tfprintf (dump_file, \"not vectorized: iteration count too small.\");\n+      return false;\n+    }\n+\n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n     {\n@@ -3935,7 +3909,7 @@ vect_get_first_index (tree ref, tree *array_first_index)\n   else\n     {\n       array_start = array_ref_low_bound (ref);\n-      if (!host_integerp (array_start,0))\n+      if (!host_integerp (array_start, 0))\n \t{\n \t  if (vect_debug_details (NULL))\n \t    {"}]}