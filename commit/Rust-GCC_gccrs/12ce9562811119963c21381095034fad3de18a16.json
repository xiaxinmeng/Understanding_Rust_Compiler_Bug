{"sha": "12ce9562811119963c21381095034fad3de18a16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJjZTk1NjI4MTExMTk5NjNjMjEzODEwOTUwMzRmYWQzZGUxOGExNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-25T18:20:11Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-25T18:20:11Z"}, "message": "(move{si,hi,qi,di}): Changed into define_expands.\n\n(move{si,hi,qi,di}): Changed into define_expands.  Split insns into\nm68k and coldfire specific versions with appropriate constraints.\n\nFrom-SVN: r13789", "tree": {"sha": "db5f0dd2ca282e984e7d5cc698a124e210f4129f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db5f0dd2ca282e984e7d5cc698a124e210f4129f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12ce9562811119963c21381095034fad3de18a16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12ce9562811119963c21381095034fad3de18a16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12ce9562811119963c21381095034fad3de18a16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12ce9562811119963c21381095034fad3de18a16/comments", "author": null, "committer": null, "parents": [{"sha": "6901b6206b2b64674bcb41595a708a96b47ca331", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6901b6206b2b64674bcb41595a708a96b47ca331", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6901b6206b2b64674bcb41595a708a96b47ca331"}], "stats": {"total": 224, "additions": 82, "deletions": 142}, "files": [{"sha": "a516280ad3766c8c95f2dad74d39a21f41984f69", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 82, "deletions": 142, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12ce9562811119963c21381095034fad3de18a16/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12ce9562811119963c21381095034fad3de18a16/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=12ce9562811119963c21381095034fad3de18a16", "patch": "@@ -924,93 +924,39 @@\n   ;; We do allow y and x regs since fixed point is allowed in them.\n   [(set (match_operand:SI 0 \"general_operand\" \"=g,da,y,!*x*r*m\")\n \t(match_operand:SI 1 \"general_operand\" \"daymKs,i,g,*x*r*m\"))]\n-  \"\"\n+  \"!TARGET_5200\"\n   \"*\n {\n   if (which_alternative == 3)\n     return \\\"fpmove%.l %x1,fpa0\\;fpmove%.l fpa0,%x0\\\";\n   if (FPA_REG_P (operands[1]) || FPA_REG_P (operands[0]))\n     return \\\"fpmove%.l %x1,%x0\\\";\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    return output_move_simode_const (operands);\n-  else if ((GET_CODE (operands[1]) == SYMBOL_REF\n-\t    || GET_CODE (operands[1]) == CONST)\n-\t   && push_operand (operands[0], SImode))\n-    return \\\"pea %a1\\\";\n-  else if ((GET_CODE (operands[1]) == SYMBOL_REF\n-\t    || GET_CODE (operands[1]) == CONST)\n-\t   && ADDRESS_REG_P (operands[0]))\n-    return \\\"lea %a1,%0\\\";\n-  return \\\"move%.l %1,%0\\\";\n+  return output_move_simode (operands);\n }\")\n \n-(define_insn \"movhi\"\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r<>,g\")\n+\t(match_operand:SI 1 \"general_operand\" \"g,r<>\"))]\n+  \"TARGET_5200\"\n+  \"* return output_move_simode (operands);\")\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n \t(match_operand:HI 1 \"general_operand\" \"g\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      if (operands[1] == const0_rtx\n-\t  && (DATA_REG_P (operands[0])\n-\t      || GET_CODE (operands[0]) == MEM)\n-\t  /* clr insns on 68000 read before writing.\n-\t     This isn't so on the 68010, but we have no TARGET_68010.  */\n-\t  && ((TARGET_68020 || TARGET_5200)\n-\t      || !(GET_CODE (operands[0]) == MEM\n-\t\t   && MEM_VOLATILE_P (operands[0]))))\n-\treturn \\\"clr%.w %0\\\";\n-      else if (DATA_REG_P (operands[0])\n-\t       && INTVAL (operands[1]) < 128\n-\t       && INTVAL (operands[1]) >= -128)\n-        {\n-#if defined(MOTOROLA) && !defined(CRDS)\n-          return \\\"moveq%.l %1,%0\\\";\n-#else\n-\t  return \\\"moveq %1,%0\\\";\n-#endif\n-\t}\n-      else if (INTVAL (operands[1]) < 0x8000\n-\t       && INTVAL (operands[1]) >= -0x8000)\n-\treturn \\\"move%.w %1,%0\\\";\n-    }\n-  else if (CONSTANT_P (operands[1]))\n-    return \\\"move%.l %1,%0\\\";\n-#ifndef SGS_NO_LI\n-  /* Recognize the insn before a tablejump, one that refers\n-     to a table of offsets.  Such an insn will need to refer\n-     to a label on the insn.  So output one.  Use the label-number\n-     of the table of offsets to generate this label.  This code,\n-     and similar code below, assumes that there will be at most one\n-     reference to each table.  */\n-  if (GET_CODE (operands[1]) == MEM\n-      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == LABEL_REF\n-      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) != PLUS)\n-    {\n-      rtx labelref = XEXP (XEXP (operands[1], 0), 1);\n-#if defined (MOTOROLA) && !defined (SGS_SWITCH_TABLES)\n-#ifdef SGS\n-      asm_fprintf (asm_out_file, \\\"\\\\tset %LLI%d,.+2\\\\n\\\",\n-\t\t   CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-#else /* not SGS */\n-      asm_fprintf (asm_out_file, \\\"\\\\t.set %LLI%d,.+2\\\\n\\\",\n-\t           CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-#endif /* not SGS */\n-#else /* SGS_SWITCH_TABLES or not MOTOROLA */\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"LI\\\",\n-\t\t\t\t CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-#ifdef SGS_SWITCH_TABLES\n-      /* Set flag saying we need to define the symbol\n-\t LD%n (with value L%n-LI%n) at the end of the switch table.  */\n-      switch_table_difference_label_flag = 1;\n-#endif /* SGS_SWITCH_TABLES */\n-#endif /* SGS_SWITCH_TABLES or not MOTOROLA */\n-    }\n-#endif /* SGS_NO_LI */\n-  return \\\"move%.w %1,%0\\\";\n-}\")\n+  \"!TARGET_5200\"\n+  \"* return output_move_himode (operands);\")\n+\n+ (define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r<>,g\")\n+\t(match_operand:HI 1 \"general_operand\" \"g,r<>\"))]\n+  \"TARGET_5200\"\n+  \"* return output_move_himode (operands);\")\n \n (define_insn \"movstricthi\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+dm\"))\n@@ -1033,64 +979,23 @@\n   return \\\"move%.w %1,%0\\\";\n }\")\n \n-(define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d,*a,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"dmi*a,di*a,dmi\"))]\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"*\n-{\n-  rtx xoperands[4];\n+  \"\")\n \n-  /* This is probably useless, since it loses for pushing a struct\n-     of several bytes a byte at a time.  */\n-  if (GET_CODE (operands[0]) == MEM\n-      && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n-      && XEXP (XEXP (operands[0], 0), 0) == stack_pointer_rtx\n-      && ! ADDRESS_REG_P (operands[1]))\n-    {\n-      xoperands[1] = operands[1];\n-      xoperands[2]\n-        = gen_rtx (MEM, QImode,\n-\t\t   gen_rtx (PLUS, VOIDmode, stack_pointer_rtx, const1_rtx));\n-      /* Just pushing a byte puts it in the high byte of the halfword.  */\n-      /* We must put it in the low-order, high-numbered byte.  */\n-      output_asm_insn (\\\"move%.b %1,%-\\;move%.b %@,%2\\\", xoperands);\n-      return \\\"\\\";\n-    }\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d,*a,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"dmi*a,di*a,dmi\"))]\n+  \"!TARGET_5200\"\n+  \"* return output_move_qimode (operands);\")\n \n-  /* clr and st insns on 68000 read before writing.\n-     This isn't so on the 68010, but we have no TARGET_68010.  */\n-  if (!ADDRESS_REG_P (operands[0])\n-      && ((TARGET_68020 || TARGET_5200)\n-\t  || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))))\n-    {\n-      if (operands[1] == const0_rtx)\n-\treturn \\\"clr%.b %0\\\";\n-      if ((!TARGET_5200 || DATA_REG_P (operands[0]))\n-          && GET_CODE (operands[1]) == CONST_INT\n-\t  && (INTVAL (operands[1]) & 255) == 255)\n-\t{\n-\t  CC_STATUS_INIT;\n-\t  return \\\"st %0\\\";\n-\t}\n-    }\n-  if (GET_CODE (operands[1]) == CONST_INT\n-      && DATA_REG_P (operands[0])\n-      && INTVAL (operands[1]) < 128\n-      && INTVAL (operands[1]) >= -128)\n-    {\n-#if defined(MOTOROLA) && !defined(CRDS)\n-      return \\\"moveq%.l %1,%0\\\";\n-#else\n-      return \\\"moveq %1,%0\\\";\n-#endif\n-    }\n-  if (GET_CODE (operands[1]) != CONST_INT && CONSTANT_P (operands[1]))\n-    return \\\"move%.l %1,%0\\\";\n-  if (ADDRESS_REG_P (operands[0]) || ADDRESS_REG_P (operands[1]))\n-    return \\\"move%.w %1,%0\\\";\n-  return \\\"move%.b %1,%0\\\";\n-}\")\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r<>,g\")\n+\t(match_operand:QI 1 \"general_operand\" \"g,r<>\"))]\n+  \"TARGET_5200\"\n+  \"* return output_move_qimode (operands);\")\n \n (define_insn \"movstrictqi\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+dm\"))\n@@ -1107,12 +1012,18 @@\n   return \\\"move%.b %1,%0\\\";\n }\")\n \n-(define_insn \"movsf\"\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=rmf,x,y,rm,!x,!rm\")\n \t(match_operand:SF 1 \"general_operand\" \"rmfF,xH,rmF,y,rm,x\"))]\n ;  [(set (match_operand:SF 0 \"general_operand\" \"=rmf\")\n ;\t(match_operand:SF 1 \"general_operand\" \"rmfF\"))]\n-  \"\"\n+  \"!TARGET_5200\"\n   \"*\n {\n   if (which_alternative >= 4)\n@@ -1153,12 +1064,24 @@\n   return \\\"move%.l %1,%0\\\";\n }\")\n \n-(define_insn \"movdf\"\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=r,g\")\n+\t(match_operand:SF 1 \"general_operand\" \"g,r\"))]\n+  \"TARGET_5200\"\n+  \"* return \\\"move%.l %1,%0\\\";\")\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=rm,rf,rf,&rof<>,y,rm,x,!x,!rm\")\n \t(match_operand:DF 1 \"general_operand\" \"rf,m,0,rofE<>,rmE,y,xH,rm,x\"))]\n ;  [(set (match_operand:DF 0 \"general_operand\" \"=rm,&rf,&rof<>\")\n ;\t(match_operand:DF 1 \"general_operand\" \"rf,m,rofF<>\"))]\n-  \"\"\n+  \"!TARGET_5200\"\n   \"*\n {\n   if (which_alternative == 7)\n@@ -1206,8 +1129,13 @@\n         return \\\"fmove%.d %f1,%0\\\";\n     }\n   return output_move_double (operands);\n-}\n-\")\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=r,g\")\n+\t(match_operand:DF 1 \"general_operand\" \"g,r\"))]\n+  \"TARGET_5200\"\n+  \"* return output_move_double (operands);\")\n \n (define_expand \"movxf\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n@@ -1302,16 +1230,23 @@\n }\n \")\n \n+(define_expand \"movdi\"\n+  ;; Let's see if it really still needs to handle fp regs, and, if so, why.\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\")\n+\n ;; movdi can apply to fp regs in some cases\n-(define_insn \"movdi\"\n+(define_insn \"\"\n   ;; Let's see if it really still needs to handle fp regs, and, if so, why.\n   [(set (match_operand:DI 0 \"general_operand\" \"=rm,r,&ro<>,y,rm,!*x,!rm\")\n \t(match_operand:DI 1 \"general_operand\" \"rF,m,roi<>F,rmiF,y,rmF,*x\"))]\n ;  [(set (match_operand:DI 0 \"general_operand\" \"=rm,&r,&ro<>,!&rm,!&f,y,rm,x,!x,!rm\")\n ;\t(match_operand:DI 1 \"general_operand\" \"r,m,roi<>,fF,rfmF,rmi,y,rm,x\"))]\n ;  [(set (match_operand:DI 0 \"general_operand\" \"=rm,&rf,&ro<>,!&rm,!&f\")\n ;\t(match_operand:DI 1 \"general_operand\" \"r,m,roi<>,fF,rfF\"))]\n-  \"\"\n+  \"!TARGET_5200\"\n   \"*\n {\n   if (which_alternative == 8)\n@@ -1346,8 +1281,13 @@\n         return \\\"fmove%.d %f1,%0\\\";\n     }\n   return output_move_double (operands);\n-}\n-\")\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=r,g\")\n+\t(match_operand:DI 1 \"general_operand\" \"g,r\"))]\n+  \"TARGET_5200\"\n+  \"* return output_move_double (operands);\")\n \n ;; Thus goes after the move instructions\n ;; because the move instructions are better (require no spilling)"}]}