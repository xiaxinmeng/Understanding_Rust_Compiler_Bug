{"sha": "972da557463ec946a31577294764a186b9821012", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcyZGE1NTc0NjNlYzk0NmEzMTU3NzI5NDc2NGExODZiOTgyMTAxMg==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-09-15T07:24:47Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-09-15T07:24:47Z"}, "message": "OpenMP/Fortran: Fix (re)mapping of allocatable/pointer arrays [PR96668]\n\ngcc/cp/ChangeLog:\n\n\tPR fortran/96668\n\t* cp-gimplify.c (cxx_omp_finish_clause): Add bool openacc arg.\n\t* cp-tree.h (cxx_omp_finish_clause): Likewise\n\t* semantics.c (handle_omp_for_class_iterator): Update call.\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/96668\n\t* trans.h (gfc_omp_finish_clause): Add bool openacc arg.\n\t* trans-openmp.c (gfc_omp_finish_clause): Ditto. Use\n\tGOMP_MAP_ALWAYS_POINTER with PSET for pointers.\n\t(gfc_trans_omp_clauses): Like the latter and also if the always\n\tmodifier is used.\n\ngcc/ChangeLog:\n\n\tPR fortran/96668\n\t* gimplify.c (gimplify_omp_for): Add 'bool openacc' argument;\n\tupdate omp_finish_clause calls.\n\t(gimplify_adjust_omp_clauses_1, gimplify_adjust_omp_clauses,\n\tgimplify_expr, gimplify_omp_loop): Update omp_finish_clause\n\tand/or gimplify_for calls.\n\t* langhooks-def.h (lhd_omp_finish_clause): Add bool openacc arg.\n\t* langhooks.c (lhd_omp_finish_clause): Likewise.\n\t* langhooks.h (lhd_omp_finish_clause): Likewise.\n\t* omp-low.c (scan_sharing_clauses): Keep GOMP_MAP_TO_PSET cause for\n\t'declare target' vars.\n\ninclude/ChangeLog:\n\n\tPR fortran/96668\n\t* gomp-constants.h (GOMP_MAP_ALWAYS_POINTER_P): Define.\n\nlibgomp/ChangeLog:\n\n\tPR fortran/96668\n\t* libgomp.h (struct target_var_desc): Add has_null_ptr_assoc member.\n\t* target.c (gomp_map_vars_existing): Add always_to_flag flag.\n\t(gomp_map_vars_existing): Update call to it.\n\t(gomp_map_fields_existing): Likewise\n\t(gomp_map_vars_internal): Update PSET handling such that if a nullptr is\n\tnow allocated or if GOMP_MAP_POINTER is used PSET is updated and pointer\n\tremapped.\n\t(GOMP_target_enter_exit_data): Hanlde GOMP_MAP_ALWAYS_POINTER like\n\tGOMP_MAP_POINTER.\n\t* testsuite/libgomp.fortran/map-alloc-ptr-1.f90: New test.\n\t* testsuite/libgomp.fortran/map-alloc-ptr-2.f90: New test.", "tree": {"sha": "d0ab3a41af83955eccee4b164c805262939e022d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0ab3a41af83955eccee4b164c805262939e022d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/972da557463ec946a31577294764a186b9821012", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/972da557463ec946a31577294764a186b9821012", "html_url": "https://github.com/Rust-GCC/gccrs/commit/972da557463ec946a31577294764a186b9821012", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/972da557463ec946a31577294764a186b9821012/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9d2def016410a2095df6b399097b482f82064a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d2def016410a2095df6b399097b482f82064a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9d2def016410a2095df6b399097b482f82064a5"}], "stats": {"total": 463, "additions": 405, "deletions": 58}, "files": [{"sha": "b2befa7148da1702607b2cae8078ff9f6ac7d463", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -2357,7 +2357,7 @@ cxx_omp_predetermined_mapping (tree decl)\n /* Finalize an implicitly determined clause.  */\n \n void\n-cxx_omp_finish_clause (tree c, gimple_seq *)\n+cxx_omp_finish_clause (tree c, gimple_seq *, bool /* openacc */)\n {\n   tree decl, inner_type;\n   bool make_shared = false;"}, {"sha": "6e4de7d0c4b2addbb3a812880a8d32b6b3f1f0ab", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -7749,7 +7749,7 @@ extern tree cxx_omp_clause_default_ctor\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_copy_ctor\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_assign_op\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_dtor\t\t\t(tree, tree);\n-extern void cxx_omp_finish_clause\t\t(tree, gimple_seq *);\n+extern void cxx_omp_finish_clause\t\t(tree, gimple_seq *, bool);\n extern bool cxx_omp_privatize_by_reference\t(const_tree);\n extern bool cxx_omp_disregard_value_expr\t(tree, bool);\n extern void cp_fold_function\t\t\t(tree);"}, {"sha": "4ca2a2f0030c88adf4f629ffbda2d5ef618d1391", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -8770,7 +8770,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t{\n \t  tree ivc = build_omp_clause (locus, OMP_CLAUSE_FIRSTPRIVATE);\n \t  OMP_CLAUSE_DECL (ivc) = iter;\n-\t  cxx_omp_finish_clause (ivc, NULL);\n+\t  cxx_omp_finish_clause (ivc, NULL, false);\n \t  OMP_CLAUSE_CHAIN (ivc) = clauses;\n \t  clauses = ivc;\n \t}\n@@ -8802,7 +8802,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t  OMP_CLAUSE_CODE (loop_iv_seen) = OMP_CLAUSE_FIRSTPRIVATE;\n \t}\n       if (OMP_CLAUSE_CODE (loop_iv_seen) == OMP_CLAUSE_FIRSTPRIVATE)\n-\tcxx_omp_finish_clause (loop_iv_seen, NULL);\n+\tcxx_omp_finish_clause (loop_iv_seen, NULL, false);\n     }\n \n   orig_pre_body = *pre_body;"}, {"sha": "9ec0df204ac43c18525379cddbde6ea1393aaa1d", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -1276,7 +1276,7 @@ gfc_build_cond_assign_expr (stmtblock_t *block, tree cond_val,\n }\n \n void\n-gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n+gfc_omp_finish_clause (tree c, gimple_seq *pre_p, bool openacc)\n {\n   if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n     return;\n@@ -1357,6 +1357,16 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n       tree type = TREE_TYPE (decl);\n       tree ptr = gfc_conv_descriptor_data_get (decl);\n \n+      /* OpenMP: automatically map pointer targets with the pointer;\n+\t hence, always update the descriptor/pointer itself.\n+\t NOTE: This also remaps the pointer for allocatable arrays with\n+\t 'target' attribute which also don't have the 'restrict' qualifier.  */\n+      bool always_modifier = false;\n+\n+      if (!openacc\n+\t  && !(TYPE_QUALS (TREE_TYPE (ptr)) & TYPE_QUAL_RESTRICT))\n+\talways_modifier = true;\n+\n       if (present)\n \tptr = gfc_build_cond_assign_expr (&block, present, ptr,\n \t\t\t\t\t  null_pointer_node);\n@@ -1376,7 +1386,8 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n \tOMP_CLAUSE_DECL (c2) = decl;\n       OMP_CLAUSE_SIZE (c2) = TYPE_SIZE_UNIT (type);\n       c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n-      OMP_CLAUSE_SET_MAP_KIND (c3, GOMP_MAP_POINTER);\n+      OMP_CLAUSE_SET_MAP_KIND (c3, always_modifier ? GOMP_MAP_ALWAYS_POINTER\n+\t\t\t\t\t\t   : GOMP_MAP_POINTER);\n       if (present)\n \t{\n \t  ptr = gfc_conv_descriptor_data_get (decl);\n@@ -2549,11 +2560,19 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t      if (!n->sym->attr.referenced)\n \t\tcontinue;\n \n+\t      bool always_modifier = false;\n \t      tree node = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n \t      tree node2 = NULL_TREE;\n \t      tree node3 = NULL_TREE;\n \t      tree node4 = NULL_TREE;\n \n+\t      /* OpenMP: automatically map pointer targets with the pointer;\n+\t\t hence, always update the descriptor/pointer itself.  */\n+\t      if (!openacc\n+\t\t  && ((n->expr == NULL && n->sym->attr.pointer)\n+\t\t      || (n->expr && gfc_expr_attr (n->expr).pointer)))\n+\t\talways_modifier = true;\n+\n \t      switch (n->u.map_op)\n \t\t{\n \t\tcase OMP_MAP_ALLOC:\n@@ -2575,12 +2594,15 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_TOFROM);\n \t\t  break;\n \t\tcase OMP_MAP_ALWAYS_TO:\n+\t\t  always_modifier = true;\n \t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_TO);\n \t\t  break;\n \t\tcase OMP_MAP_ALWAYS_FROM:\n+\t\t  always_modifier = true;\n \t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_FROM);\n \t\t  break;\n \t\tcase OMP_MAP_ALWAYS_TOFROM:\n+\t\t  always_modifier = true;\n \t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_TOFROM);\n \t\t  break;\n \t\tcase OMP_MAP_RELEASE:\n@@ -2760,7 +2782,10 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t  goto finalize_map_clause;\n \t\t\t}\n \t\t      else\n-\t\t\tOMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_POINTER);\n+\t\t\tOMP_CLAUSE_SET_MAP_KIND (node3,\n+\t\t\t\t\t\t always_modifier\n+\t\t\t\t\t\t ? GOMP_MAP_ALWAYS_POINTER\n+\t\t\t\t\t\t : GOMP_MAP_POINTER);\n \n \t\t      /* We have to check for n->sym->attr.dimension because\n \t\t\t of scalar coarrays.  */"}, {"sha": "d257963d5f89c83ed85c7fe4a7df6f05e6ff4567", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -810,7 +810,7 @@ tree gfc_omp_clause_copy_ctor (tree, tree, tree);\n tree gfc_omp_clause_assign_op (tree, tree, tree);\n tree gfc_omp_clause_linear_ctor (tree, tree, tree, tree);\n tree gfc_omp_clause_dtor (tree, tree);\n-void gfc_omp_finish_clause (tree, gimple_seq *);\n+void gfc_omp_finish_clause (tree, gimple_seq *, bool);\n bool gfc_omp_scalar_p (tree);\n bool gfc_omp_disregard_value_expr (tree, bool);\n bool gfc_omp_private_debug_clause (tree, bool);"}, {"sha": "2dea03cce3d74360976d39ab5967c202a2799aa5", "filename": "gcc/gimplify.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -10123,13 +10123,15 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n       OMP_CLAUSE_CHAIN (clause) = nc;\n       struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n       gimplify_omp_ctxp = ctx->outer_context;\n-      lang_hooks.decls.omp_finish_clause (nc, pre_p);\n+      lang_hooks.decls.omp_finish_clause (nc, pre_p,\n+\t\t\t\t\t  (ctx->region_type & ORT_ACC) != 0);\n       gimplify_omp_ctxp = ctx;\n     }\n   *list_p = clause;\n   struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n   gimplify_omp_ctxp = ctx->outer_context;\n-  lang_hooks.decls.omp_finish_clause (clause, pre_p);\n+  lang_hooks.decls.omp_finish_clause (clause, pre_p,\n+\t\t\t\t      (ctx->region_type & ORT_ACC) != 0);\n   if (gimplify_omp_ctxp)\n     for (; clause != chain; clause = OMP_CLAUSE_CHAIN (clause))\n       if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n@@ -10539,7 +10541,9 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t\t  OMP_CLAUSE_SET_MAP_KIND (nc, GOMP_MAP_TOFROM);\n \t\t  OMP_CLAUSE_DECL (nc) = decl;\n \t\t  OMP_CLAUSE_CHAIN (c) = nc;\n-\t\t  lang_hooks.decls.omp_finish_clause (nc, pre_p);\n+\t\t  lang_hooks.decls.omp_finish_clause (nc, pre_p,\n+\t\t\t\t\t\t      (ctx->region_type\n+\t\t\t\t\t\t       & ORT_ACC) != 0);\n \t\t  while (1)\n \t\t    {\n \t\t      OMP_CLAUSE_MAP_IN_REDUCTION (nc) = 1;\n@@ -11040,6 +11044,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   int i;\n   bitmap has_decl_expr = NULL;\n   enum omp_region_type ort = ORT_WORKSHARE;\n+  bool openacc = TREE_CODE (*expr_p) == OACC_LOOP;\n \n   orig_for_stmt = for_stmt = *expr_p;\n \n@@ -11147,7 +11152,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\tOMP_CLAUSE_CHAIN (c) = OMP_FOR_CLAUSES (for_stmt);\n \t\tOMP_FOR_CLAUSES (for_stmt) = c;\n \t\tOMP_CLAUSE_CODE (*pc) = OMP_CLAUSE_FIRSTPRIVATE;\n-\t\tlang_hooks.decls.omp_finish_clause (*pc, pre_p);\n+\t\tlang_hooks.decls.omp_finish_clause (*pc, pre_p, openacc);\n \t      }\n \t    else\n \t      {\n@@ -11159,7 +11164,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\tOMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (*pc);\n \t\tOMP_CLAUSE_CHAIN (c) = *pc;\n \t\t*pc = c;\n-\t\tlang_hooks.decls.omp_finish_clause (*pc, pre_p);\n+\t\tlang_hooks.decls.omp_finish_clause (*pc, pre_p, openacc);\n \t      }\n \t    tree c = build_omp_clause (UNKNOWN_LOCATION,\n \t\t\t\t       OMP_CLAUSE_FIRSTPRIVATE);\n@@ -12115,7 +12120,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t  = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t      OMP_CLAUSE_FIRSTPRIVATE);\n \t\tOMP_CLAUSE_DECL (*gtask_clauses_ptr) = OMP_CLAUSE_DECL (c);\n-\t\tlang_hooks.decls.omp_finish_clause (*gtask_clauses_ptr, NULL);\n+\t\tlang_hooks.decls.omp_finish_clause (*gtask_clauses_ptr, NULL,\n+\t\t\t\t\t\t    openacc);\n \t\tgtask_clauses_ptr = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);\n \t\t*gforo_clauses_ptr = c;\n \t\tgforo_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n@@ -12154,7 +12160,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t  = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t      OMP_CLAUSE_FIRSTPRIVATE);\n \t\tOMP_CLAUSE_DECL (*gtask_clauses_ptr) = OMP_CLAUSE_DECL (c);\n-\t\tlang_hooks.decls.omp_finish_clause (*gtask_clauses_ptr, NULL);\n+\t\tlang_hooks.decls.omp_finish_clause (*gtask_clauses_ptr, NULL,\n+\t\t\t\t\t\t    openacc);\n \t\tgtask_clauses_ptr = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);\n \t\tOMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c) = 1;\n \t\t*gforo_clauses_ptr = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n@@ -12535,7 +12542,7 @@ gimplify_omp_loop (tree *expr_p, gimple_seq *pre_p)\n \t\t*pc = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\tOMP_CLAUSE_FIRSTPRIVATE);\n \t\tOMP_CLAUSE_DECL (*pc) = OMP_CLAUSE_DECL (c);\n-\t\tlang_hooks.decls.omp_finish_clause (*pc, NULL);\n+\t\tlang_hooks.decls.omp_finish_clause (*pc, NULL, false);\n \t\tpc = &OMP_CLAUSE_CHAIN (*pc);\n \t      }\n \t    *pc = copy_node (c);\n@@ -12546,7 +12553,7 @@ gimplify_omp_loop (tree *expr_p, gimple_seq *pre_p)\n \t\tif (pass != last)\n \t\t  OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (*pc) = 1;\n \t\telse\n-\t\t  lang_hooks.decls.omp_finish_clause (*pc, NULL);\n+\t\t  lang_hooks.decls.omp_finish_clause (*pc, NULL, false);\n \t\tOMP_CLAUSE_LASTPRIVATE_LOOP_IV (*pc) = 0;\n \t      }\n \t    pc = &OMP_CLAUSE_CHAIN (*pc);"}, {"sha": "a909915d018dd2249c0925ff8ccc327eb81aba00", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -81,7 +81,7 @@ extern int lhd_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n extern enum omp_clause_default_kind lhd_omp_predetermined_sharing (tree);\n extern enum omp_clause_defaultmap_kind lhd_omp_predetermined_mapping (tree);\n extern tree lhd_omp_assignment (tree, tree, tree);\n-extern void lhd_omp_finish_clause (tree, gimple_seq *);\n+extern void lhd_omp_finish_clause (tree, gimple_seq *, bool);\n struct gimplify_omp_ctx;\n extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n \t\t\t\t\t       tree);"}, {"sha": "8819a8859d422b1ea268af6c5d1d0f4d5f514226", "filename": "gcc/langhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -610,7 +610,7 @@ lhd_omp_assignment (tree clause ATTRIBUTE_UNUSED, tree dst, tree src)\n /* Finalize clause C.  */\n \n void\n-lhd_omp_finish_clause (tree, gimple_seq *)\n+lhd_omp_finish_clause (tree, gimple_seq *, bool)\n {\n }\n "}, {"sha": "a35cf21b67368e4f4e2e03a8a5e407bed4121ff5", "filename": "gcc/langhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -294,7 +294,7 @@ struct lang_hooks_for_decls\n   tree (*omp_clause_dtor) (tree clause, tree decl);\n \n   /* Do language specific checking on an implicitly determined clause.  */\n-  void (*omp_finish_clause) (tree clause, gimple_seq *pre_p);\n+  void (*omp_finish_clause) (tree clause, gimple_seq *pre_p, bool);\n \n   /* Return true if DECL is a scalar variable (for the purpose of\n      implicit firstprivatization).  */"}, {"sha": "3d2a9d77c1c8aacdf612a744cd6bcfa3117f6355", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -1351,6 +1351,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_TO\n \t      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_FROM\n \t      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_TOFROM\n+\t      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_TO_PSET\n \t      && is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx))\n \t      && varpool_node::get_create (decl)->offloadable\n \t      && !lookup_attribute (\"omp declare target link\","}, {"sha": "309cbcadd83b93dc38480359dd8a7176db610d84", "filename": "include/gomp-constants.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -171,6 +171,9 @@ enum gomp_map_kind\n   (!((X) & GOMP_MAP_FLAG_SPECIAL) \\\n    && ((X) & GOMP_MAP_FLAG_FROM))\n \n+#define GOMP_MAP_ALWAYS_POINTER_P(X) \\\n+  ((X) == GOMP_MAP_ALWAYS_POINTER)\n+\n #define GOMP_MAP_POINTER_P(X) \\\n   ((X) == GOMP_MAP_POINTER)\n "}, {"sha": "87f939a1f216c2c18bfcc9d78916f4d11cd2941c", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -954,6 +954,9 @@ struct target_var_desc {\n   bool always_copy_from;\n   /* True if this is for OpenACC 'attach'.  */\n   bool is_attach;\n+  /* If GOMP_MAP_TO_PSET had a NULL pointer; used for Fortran descriptors,\n+     which were initially unallocated.  */\n+  bool has_null_ptr_assoc;\n   /* Relative offset against key host_start.  */\n   uintptr_t offset;\n   /* Actual length.  */"}, {"sha": "69cdd9f14a9758f6ec1d61a04da57b6fb28e9878", "filename": "libgomp/target.c", "status": "modified", "additions": 146, "deletions": 38, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -355,7 +355,8 @@ static inline void\n gomp_map_vars_existing (struct gomp_device_descr *devicep,\n \t\t\tstruct goacc_asyncqueue *aq, splay_tree_key oldn,\n \t\t\tsplay_tree_key newn, struct target_var_desc *tgt_var,\n-\t\t\tunsigned char kind, struct gomp_coalesce_buf *cbuf)\n+\t\t\tunsigned char kind, bool always_to_flag,\n+\t\t\tstruct gomp_coalesce_buf *cbuf)\n {\n   assert (kind != GOMP_MAP_ATTACH);\n \n@@ -377,7 +378,7 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep,\n \t\t  (void *) oldn->host_start, (void *) oldn->host_end);\n     }\n \n-  if (GOMP_MAP_ALWAYS_TO_P (kind))\n+  if (GOMP_MAP_ALWAYS_TO_P (kind) || always_to_flag)\n     gomp_copy_host2dev (devicep, aq,\n \t\t\t(void *) (oldn->tgt->tgt_start + oldn->tgt_offset\n \t\t\t\t  + newn->host_start - oldn->host_start),\n@@ -456,8 +457,8 @@ gomp_map_fields_existing (struct target_mem_desc *tgt,\n       && n2->tgt == n->tgt\n       && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n     {\n-      gomp_map_vars_existing (devicep, aq, n2, &cur_node,\n-\t\t\t      &tgt->list[i], kind & typemask, cbuf);\n+      gomp_map_vars_existing (devicep, aq, n2, &cur_node, &tgt->list[i],\n+\t\t\t      kind & typemask, false, cbuf);\n       return;\n     }\n   if (sizes[i] == 0)\n@@ -472,8 +473,8 @@ gomp_map_fields_existing (struct target_mem_desc *tgt,\n \t      && n2->host_start - n->host_start\n \t\t == n2->tgt_offset - n->tgt_offset)\n \t    {\n-\t      gomp_map_vars_existing (devicep, aq, n2, &cur_node,\n-\t\t\t\t      &tgt->list[i], kind & typemask, cbuf);\n+\t      gomp_map_vars_existing (devicep, aq, n2, &cur_node, &tgt->list[i],\n+\t\t\t\t      kind & typemask, false, cbuf);\n \t      return;\n \t    }\n \t}\n@@ -485,7 +486,7 @@ gomp_map_fields_existing (struct target_mem_desc *tgt,\n \t  && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n \t{\n \t  gomp_map_vars_existing (devicep, aq, n2, &cur_node, &tgt->list[i],\n-\t\t\t\t  kind & typemask, cbuf);\n+\t\t\t\t  kind & typemask, false, cbuf);\n \t  return;\n \t}\n     }\n@@ -661,6 +662,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n {\n   size_t i, tgt_align, tgt_size, not_found_cnt = 0;\n   bool has_firstprivate = false;\n+  bool has_always_ptrset = false;\n   const int rshift = short_mapkind ? 8 : 3;\n   const int typemask = short_mapkind ? 0xff : 0x7;\n   struct splay_tree_s *mem_map = &devicep->mem_map;\n@@ -848,8 +850,55 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n       else\n \tn = splay_tree_lookup (mem_map, &cur_node);\n       if (n && n->refcount != REFCOUNT_LINK)\n-\tgomp_map_vars_existing (devicep, aq, n, &cur_node, &tgt->list[i],\n-\t\t\t\tkind & typemask, NULL);\n+\t{\n+\t  int always_to_cnt = 0;\n+\t  if ((kind & typemask) == GOMP_MAP_TO_PSET)\n+\t    {\n+\t      bool has_nullptr;\n+\t      size_t j;\n+\t      for (j = 0; j < n->tgt->list_count; j++)\n+\t\tif (n->tgt->list[j].key == n)\n+\t\t  {\n+\t\t    has_nullptr = n->tgt->list[j].has_null_ptr_assoc;\n+\t\t    break;\n+\t\t  }\n+\t      if (n->tgt->list_count == 0)\n+\t\t{\n+\t\t  /* 'declare target'; assume has_nullptr; it could also be\n+\t\t     statically assigned pointer, but that it should be to\n+\t\t     the equivalent variable on the host.  */\n+\t\t  assert (n->refcount == REFCOUNT_INFINITY);\n+\t\t  has_nullptr = true;\n+\t\t}\n+\t      else\n+\t\tassert (j < n->tgt->list_count);\n+\t      /* Re-map the data if there is an 'always' modifier or if it a\n+\t\t null pointer was there and non a nonnull has been found; that\n+\t\t permits transparent re-mapping for Fortran array descriptors\n+\t\t which were previously mapped unallocated.  */\n+\t      for (j = i + 1; j < mapnum; j++)\n+\t\t{\n+\t\t  int ptr_kind = get_kind (short_mapkind, kinds, j) & typemask;\n+\t\t  if (!GOMP_MAP_ALWAYS_POINTER_P (ptr_kind)\n+\t\t      && (!has_nullptr\n+\t\t\t  || !GOMP_MAP_POINTER_P (ptr_kind)\n+\t\t\t  || *(void **) hostaddrs[j] == NULL))\n+\t\t    break;\n+\t\t  else if ((uintptr_t) hostaddrs[j] < cur_node.host_start\n+\t\t\t   || ((uintptr_t) hostaddrs[j] + sizeof (void *)\n+\t\t\t       > cur_node.host_end))\n+\t\t    break;\n+\t\t  else\n+\t\t    {\n+\t\t      has_always_ptrset = true;\n+\t\t      ++always_to_cnt;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  gomp_map_vars_existing (devicep, aq, n, &cur_node, &tgt->list[i],\n+\t\t\t\t  kind & typemask, always_to_cnt > 0, NULL);\n+\t  i += always_to_cnt;\n+\t}\n       else\n \t{\n \t  tgt->list[i].key = NULL;\n@@ -881,9 +930,11 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t  if ((kind & typemask) == GOMP_MAP_TO_PSET)\n \t    {\n \t      size_t j;\n+\t      int kind;\n \t      for (j = i + 1; j < mapnum; j++)\n-\t\tif (!GOMP_MAP_POINTER_P (get_kind (short_mapkind, kinds, j)\n-\t\t\t\t\t & typemask))\n+\t\tif (!GOMP_MAP_POINTER_P ((kind = (get_kind (short_mapkind,\n+\t\t\t\t\t\t  kinds, j)) & typemask))\n+\t\t    && !GOMP_MAP_ALWAYS_POINTER_P (kind))\n \t\t  break;\n \t\telse if ((uintptr_t) hostaddrs[j] < cur_node.host_start\n \t\t\t || ((uintptr_t) hostaddrs[j] + sizeof (void *)\n@@ -951,7 +1002,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n     tgt_size = mapnum * sizeof (void *);\n \n   tgt->array = NULL;\n-  if (not_found_cnt || has_firstprivate)\n+  if (not_found_cnt || has_firstprivate || has_always_ptrset)\n     {\n       if (not_found_cnt)\n \ttgt->array = gomp_malloc (not_found_cnt * sizeof (*tgt->array));\n@@ -960,7 +1011,58 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n       uintptr_t field_tgt_base = 0;\n \n       for (i = 0; i < mapnum; i++)\n-\tif (tgt->list[i].key == NULL)\n+\tif (has_always_ptrset\n+\t    && tgt->list[i].key\n+\t    && (get_kind (short_mapkind, kinds, i) & typemask)\n+\t       == GOMP_MAP_TO_PSET)\n+\t  {\n+\t    splay_tree_key k = tgt->list[i].key;\n+\t    bool has_nullptr;\n+\t    size_t j;\n+\t    for (j = 0; j < k->tgt->list_count; j++)\n+\t      if (k->tgt->list[j].key == k)\n+\t\t{\n+\t\t  has_nullptr = k->tgt->list[j].has_null_ptr_assoc;\n+\t\t  break;\n+\t\t}\n+\t    if (k->tgt->list_count == 0)\n+\t      has_nullptr = true;\n+\t    else\n+\t      assert (j < k->tgt->list_count);\n+\n+\t    tgt->list[i].has_null_ptr_assoc = false;\n+\t    for (j = i + 1; j < mapnum; j++)\n+\t      {\n+\t\tint ptr_kind = get_kind (short_mapkind, kinds, j) & typemask;\n+\t\tif (!GOMP_MAP_ALWAYS_POINTER_P (ptr_kind)\n+\t\t    && (!has_nullptr\n+\t\t\t|| !GOMP_MAP_POINTER_P (ptr_kind)\n+\t\t\t|| *(void **) hostaddrs[j] == NULL))\n+\t\t  break;\n+\t\telse if ((uintptr_t) hostaddrs[j] < k->host_start\n+\t\t\t || ((uintptr_t) hostaddrs[j] + sizeof (void *)\n+\t\t\t     > k->host_end))\n+\t\t  break;\n+\t\telse\n+\t\t  {\n+\t\t    if (*(void **) hostaddrs[j] == NULL)\n+\t\t      tgt->list[i].has_null_ptr_assoc = true;\n+\t\t    tgt->list[j].key = k;\n+\t\t    tgt->list[j].copy_from = false;\n+\t\t    tgt->list[j].always_copy_from = false;\n+\t\t    tgt->list[j].is_attach = false;\n+\t\t    if (k->refcount != REFCOUNT_INFINITY)\n+\t\t      k->refcount++;\n+\t\t    gomp_map_pointer (k->tgt, aq,\n+\t\t\t\t      (uintptr_t) *(void **) hostaddrs[j],\n+\t\t\t\t      k->tgt_offset + ((uintptr_t) hostaddrs[j]\n+\t\t\t\t\t\t       - k->host_start),\n+\t\t\t\t      sizes[j], cbufp);\n+\t\t  }\n+\t      }\n+\t    i = j - 1;\n+\t  }\n+\telse if (tgt->list[i].key == NULL)\n \t  {\n \t    int kind = get_kind (short_mapkind, kinds, i);\n \t    if (hostaddrs[i] == NULL)\n@@ -1120,7 +1222,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t    splay_tree_key n = splay_tree_lookup (mem_map, k);\n \t    if (n && n->refcount != REFCOUNT_LINK)\n \t      gomp_map_vars_existing (devicep, aq, n, k, &tgt->list[i],\n-\t\t\t\t      kind & typemask, cbufp);\n+\t\t\t\t      kind & typemask, false, cbufp);\n \t    else\n \t      {\n \t\tk->aux = NULL;\n@@ -1192,32 +1294,37 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t\t\t\t  + k->tgt_offset),\n \t\t\t\t\t(void *) k->host_start,\n \t\t\t\t\tk->host_end - k->host_start, cbufp);\n+\t\t    tgt->list[i].has_null_ptr_assoc = false;\n \n \t\t    for (j = i + 1; j < mapnum; j++)\n-\t\t      if (!GOMP_MAP_POINTER_P (get_kind (short_mapkind, kinds,\n-\t\t\t\t\t\t\t j)\n-\t\t\t\t\t       & typemask))\n-\t\t\tbreak;\n-\t\t      else if ((uintptr_t) hostaddrs[j] < k->host_start\n-\t\t\t       || ((uintptr_t) hostaddrs[j] + sizeof (void *)\n-\t\t\t\t   > k->host_end))\n-\t\t\tbreak;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  tgt->list[j].key = k;\n-\t\t\t  tgt->list[j].copy_from = false;\n-\t\t\t  tgt->list[j].always_copy_from = false;\n-\t\t\t  tgt->list[j].is_attach = false;\n-\t\t\t  if (k->refcount != REFCOUNT_INFINITY)\n-\t\t\t    k->refcount++;\n-\t\t\t  gomp_map_pointer (tgt, aq,\n-\t\t\t\t\t    (uintptr_t) *(void **) hostaddrs[j],\n-\t\t\t\t\t    k->tgt_offset\n-\t\t\t\t\t    + ((uintptr_t) hostaddrs[j]\n-\t\t\t\t\t       - k->host_start),\n-\t\t\t\t\t    sizes[j], cbufp);\n-\t\t\t  i++;\n+\t\t      {\n+\t\t\tint ptr_kind = (get_kind (short_mapkind, kinds, j)\n+\t\t\t\t\t& typemask);\n+\t\t\tif (!GOMP_MAP_POINTER_P (ptr_kind)\n+\t\t\t    && !GOMP_MAP_ALWAYS_POINTER_P (ptr_kind))\n+\t\t\t  break;\n+\t\t\telse if ((uintptr_t) hostaddrs[j] < k->host_start\n+\t\t\t\t || ((uintptr_t) hostaddrs[j] + sizeof (void *)\n+\t\t\t\t     > k->host_end))\n+\t\t\t  break;\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    tgt->list[j].key = k;\n+\t\t\t    tgt->list[j].copy_from = false;\n+\t\t\t    tgt->list[j].always_copy_from = false;\n+\t\t\t    tgt->list[j].is_attach = false;\n+\t\t\t    tgt->list[i].has_null_ptr_assoc |= !(*(void **) hostaddrs[j]);\n+\t\t\t    if (k->refcount != REFCOUNT_INFINITY)\n+\t\t\t      k->refcount++;\n+\t\t\t    gomp_map_pointer (tgt, aq,\n+\t\t\t\t\t      (uintptr_t) *(void **) hostaddrs[j],\n+\t\t\t\t\t      k->tgt_offset\n+\t\t\t\t\t      + ((uintptr_t) hostaddrs[j]\n+\t\t\t\t\t\t - k->host_start),\n+\t\t\t\t\t      sizes[j], cbufp);\n+\t\t\t  }\n \t\t\t}\n+\t\t    i = j - 1;\n \t\t    break;\n \t\t  case GOMP_MAP_FORCE_PRESENT:\n \t\t    {\n@@ -2481,7 +2588,8 @@ GOMP_target_enter_exit_data (int device, size_t mapnum, void **hostaddrs,\n       else if ((kinds[i] & 0xff) == GOMP_MAP_TO_PSET)\n \t{\n \t  for (j = i + 1; j < mapnum; j++)\n-\t    if (!GOMP_MAP_POINTER_P (get_kind (true, kinds, j) & 0xff))\n+\t    if (!GOMP_MAP_POINTER_P (get_kind (true, kinds, j) & 0xff)\n+\t\t&& !GOMP_MAP_ALWAYS_POINTER_P (get_kind (true, kinds, j) & 0xff))\n \t      break;\n \t  gomp_map_vars (devicep, j-i, &hostaddrs[i], NULL, &sizes[i],\n \t\t\t &kinds[i], true, GOMP_MAP_VARS_ENTER_DATA);"}, {"sha": "a1ff1d6d1e5a00ac38f72b0f3c76198656f5b0e5", "filename": "libgomp/testsuite/libgomp.fortran/map-alloc-ptr-1.f90", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fmap-alloc-ptr-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fmap-alloc-ptr-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fmap-alloc-ptr-1.f90?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -0,0 +1,114 @@\n+! { dg-do run }\n+! \n+! PR fortran/96668\n+\n+implicit none\n+  integer, pointer :: p1(:), p2(:), p3(:)\n+  integer, allocatable :: a1(:), a2(:)\n+  p1 => null()\n+  p3 => null()\n+\n+  !$omp target enter data map(to:p3)\n+\n+  !$omp target data map(a1, a2, p1)\n+     !$omp target\n+       if (allocated (a1)) stop 1\n+       if (allocated (a2)) stop 1\n+       if (associated (p1)) stop 1\n+       if (associated (p3)) stop 1\n+     !$omp end target\n+\n+     allocate (a1, source=[10,11,12,13,14])\n+     allocate (a2, source=[10,11,12,13,14])\n+     allocate (p1, source=[9,8,7,6,5,4])\n+     allocate (p3, source=[4,5,6])\n+     p2 => p1\n+\n+     !$omp target enter data map(to:p3)\n+\n+     ! allocatable, TR9 requires 'always' modifier:\n+     !$omp target map(always, tofrom: a1)\n+       if (.not. allocated(a1)) stop 2\n+       if (size(a1) /= 5) stop 3\n+       if (any (a1 /= [10,11,12,13,14])) stop 5\n+       a1(:) = [101, 102, 103, 104, 105]\n+     !$omp end target\n+\n+     ! allocatable, extension (OpenMP 6.0?): without 'always'\n+     !$omp target\n+       if (.not. allocated(a2)) stop 2\n+       if (size(a2) /= 5) stop 3\n+       if (any (a2 /= [10,11,12,13,14])) stop 5\n+       a2(:) = [101, 102, 103, 104, 105]\n+     !$omp end target\n+\n+     ! pointer: target is automatically mapped\n+     ! without requiring an explicit mapping or even the always modifier\n+     !$omp target  !! map(always, tofrom: p1)\n+       if (.not. associated(p1)) stop 7\n+       if (size(p1) /= 6) stop 8\n+       if (any (p1 /= [9,8,7,6,5,4])) stop 10\n+       p1(:) = [-1, -2, -3, -4, -5, -6]\n+     !$omp end target\n+\n+     !$omp target  !! map(always, tofrom: p3)\n+       if (.not. associated(p3)) stop 7\n+       if (size(p3) /= 3) stop 8\n+       if (any (p3 /= [4,5,6])) stop 10\n+       p3(:) = [23,24,25]\n+     !$omp end target\n+\n+     if (any (p1 /= [-1, -2, -3, -4, -5, -6])) stop 141\n+\n+  !$omp target exit data map(from:p3)\n+  !$omp target exit data map(from:p3)\n+     if (any (p3 /= [23,24,25])) stop 141\n+\n+     allocate (p1, source=[99,88,77,66,55,44,33])\n+\n+     !$omp target  ! And this also should work\n+       if (.not. associated(p1)) stop 7\n+       if (size(p1) /= 7) stop 8\n+       if (any (p1 /= [99,88,77,66,55,44,33])) stop 10\n+       p1(:) = [-11, -22, -33, -44, -55, -66, -77]\n+     !$omp end target\n+  !$omp end target data\n+\n+  if (any (a1 /= [101, 102, 103, 104, 105])) stop 12\n+  if (any (a2 /= [101, 102, 103, 104, 105])) stop 12\n+\n+  if (any (p1 /= [-11, -22, -33, -44, -55, -66, -77])) stop 142\n+  if (any (p2 /= [-1, -2, -3, -4, -5, -6])) stop 143\n+\n+\n+  block\n+    integer, pointer :: tmp(:), tmp2(:), tmp3(:)\n+    tmp => p1\n+    tmp2 => p2\n+    tmp3 => p3\n+    !$omp target enter data map(to:p3)\n+\n+    !$omp target data map(to: p1, p2)\n+      p1 => null ()\n+      p2 => null ()\n+      p3 => null ()\n+      !$omp target map(always, tofrom: p1)\n+        if (associated (p1)) stop 22\n+      !$omp end target\n+      if (associated (p1)) stop 22\n+\n+      !$omp target\n+        if (associated (p2)) stop 22\n+      !$omp end target\n+      if (associated (p2)) stop 22\n+\n+      !$omp target\n+        if (associated (p3)) stop 22\n+      !$omp end target\n+      if (associated (p3)) stop 22\n+    !$omp end target data\n+    !$omp target exit data map(from:p3)\n+    deallocate(tmp, tmp2, tmp3) \n+  end block\n+  deallocate(a1, a2)\n+end"}, {"sha": "c69a9bf44ad1288fd2c3c49820fac5a823b846a6", "filename": "libgomp/testsuite/libgomp.fortran/map-alloc-ptr-2.f90", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972da557463ec946a31577294764a186b9821012/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fmap-alloc-ptr-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972da557463ec946a31577294764a186b9821012/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fmap-alloc-ptr-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fmap-alloc-ptr-2.f90?ref=972da557463ec946a31577294764a186b9821012", "patch": "@@ -0,0 +1,86 @@\n+! { dg-do run }\n+! \n+! PR fortran/96668\n+\n+module m\n+  implicit none\n+  integer, pointer :: p1(:) => null(), p3(:) => null()\n+  integer, allocatable :: a1(:), a2(:)\n+  !$omp declare target to(a1, a2, p1, p3)\n+end module m\n+\n+use m\n+implicit none\n+  integer, pointer :: p2(:)\n+\n+  !$omp target\n+    if (allocated (a1)) stop 1\n+    if (allocated (a2)) stop 1\n+    if (associated (p1)) stop 1\n+    if (associated (p3)) stop 1\n+  !$omp end target\n+\n+  allocate (a1, source=[10,11,12,13,14])\n+  allocate (a2, source=[10,11,12,13,14])\n+  allocate (p1, source=[9,8,7,6,5,4])\n+  allocate (p3, source=[4,5,6])\n+  p2 => p1\n+\n+  !$omp target enter data map(to:p3)\n+\n+  ! allocatable, TR9 requires 'always' modifier:\n+  !$omp target map(always, tofrom: a1)\n+    if (.not. allocated(a1)) stop 2\n+    if (size(a1) /= 5) stop 3\n+    if (any (a1 /= [10,11,12,13,14])) stop 5\n+    a1(:) = [101, 102, 103, 104, 105]\n+  !$omp end target\n+\n+  ! allocatable, extension (OpenMP 6.0?): without 'always'\n+  !$omp target\n+    if (.not. allocated(a2)) stop 2\n+    if (size(a2) /= 5) stop 3\n+    if (any (a2 /= [10,11,12,13,14])) stop 5\n+    a2(:) = [101, 102, 103, 104, 105]\n+  !$omp end target\n+\n+  ! pointer: target is automatically mapped\n+  ! without requiring an explicit mapping or even the always modifier\n+  !$omp target  !! map(always, tofrom: p1)\n+    if (.not. associated(p1)) stop 7\n+    if (size(p1) /= 6) stop 8\n+    if (any (p1 /= [9,8,7,6,5,4])) stop 10\n+    p1(:) = [-1, -2, -3, -4, -5, -6]\n+  !$omp end target\n+\n+  !$omp target  !! map(always, tofrom: p3)\n+    if (.not. associated(p3)) stop 7\n+    if (size(p3) /= 3) stop 8\n+    if (any (p3 /= [4,5,6])) stop 10\n+    p3(:) = [23,24,25]\n+  !$omp end target\n+\n+  !$omp target update from(p1)\n+  if (any (p1 /= [-1, -2, -3, -4, -5, -6])) stop 141\n+\n+  !$omp target exit data map(always, from:p3)\n+  if (any (p3 /= [23,24,25])) stop 141\n+\n+  allocate (p1, source=[99,88,77,66,55,44,33])\n+\n+  !$omp target  ! And this also should work\n+    if (.not. associated(p1)) stop 7\n+    if (size(p1) /= 7) stop 8\n+    if (any (p1 /= [99,88,77,66,55,44,33])) stop 10\n+    p1(:) = [-11, -22, -33, -44, -55, -66, -77]\n+  !$omp end target\n+  !$omp target update from(p1)\n+\n+  if (any (a1 /= [101, 102, 103, 104, 105])) stop 12\n+  if (any (a2 /= [101, 102, 103, 104, 105])) stop 12\n+\n+  if (any (p1 /= [-11, -22, -33, -44, -55, -66, -77])) stop 142\n+  if (any (p2 /= [-1, -2, -3, -4, -5, -6])) stop 143\n+\n+  deallocate(a1, a2, p1, p2, p3)\n+end"}]}