{"sha": "296799ba06ab9ff273038e9b4dd93ca9ba65bf1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk2Nzk5YmEwNmFiOWZmMjczMDM4ZTliNGRkOTNjYTliYTY1YmYxYw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-07-28T08:03:07Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-07-28T08:03:07Z"}, "message": "re PR target/49687 ([avr] Missed optimization for widening MUL)\n\n\t\n\tPR target/49687\n\t* config/avr/t-avr (LIB1ASMFUNCS): Remove _xmulhisi3_exit.\n\tAdd _muluhisi3, _mulshisi3, _usmulhisi3.\n\t* config/avr/libgcc.S (__mulsi3): Rewrite.\n\t(__mulhisi3): Rewrite.\n\t(__umulhisi3): Rewrite.\n\t(__usmulhisi3): New.\n\t(__muluhisi3): New.\n\t(__mulshisi3): New.\n\t(__mulohisi3): New.\n\t(__mulqi3, __mulqihi3, __umulqihi3, __mulhi3): Use DEFUN/ENDF to\n\tdeclare.\n\t* config/avr/predicates.md (pseudo_register_operand): Rewrite.\n\t(pseudo_register_or_const_int_operand): New.\n\t(combine_pseudo_register_operand): New.\n\t(u16_operand): New.\n\t(s16_operand): New.\n\t(o16_operand): New.\n\t* config/avr/avr.c (avr_rtx_costs): Handle costs for mult:SI.\n\t* config/avr/avr.md (QIHI, QIHI2): New mode iterators.\n\t(any_extend, any_extend2): New code iterators.\n\t(extend_prefix): New code attribute.\n\t(mulsi3): Rewrite. Turn insn to expander.\n\t(mulhisi3): Ditto.\n\t(umulhisi3): Ditto.\n\t(usmulhisi3): New expander.\n\t(*mulsi3): New insn-and-split.\n\t(mulu<mode>si3): New insn-and-split.\n\t(muls<mode>si3): New insn-and-split.\n\t(mulohisi3): New insn-and-split.\n\t(*uumulqihisi3, *uumulhiqisi3, *uumulhihisi3, *uumulqiqisi3,\n\t*usmulqihisi3, *usmulhiqisi3, *usmulhihisi3, *usmulqiqisi3,\n\t*sumulqihisi3, *sumulhiqisi3, *sumulhihisi3, *sumulqiqisi3,\n\t*ssmulqihisi3, *ssmulhiqisi3, *ssmulhihisi3, *ssmulqiqisi3): New\n\tinsn-and-split.\n\t(*mulsi3_call): Rewrite.\n\t(*mulhisi3_call): Rewrite.\n\t(*umulhisi3_call): Rewrite.\n\t(*usmulhisi3_call): New insn.\n\t(*muluhisi3_call): New insn.\n\t(*mulshisi3_call): New insn.\n\t(*mulohisi3_call): New insn.\n\t(extendqihi2): Use combine_pseudo_register_operand as predicate\n\tfor operand 1.\n\t(extendqisi2): Ditto.\n\t(zero_extendqihi2): Ditto.\n\t(zero_extendqisi2): Ditto.\n\t(zero_extendhisi2): Ditto.\n\t(extendhisi2): Ditto. Don't early-clobber operand 0.\n\nFrom-SVN: r176862", "tree": {"sha": "f33ec938c92290f1cfa8c36ab509c9b6189d3216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f33ec938c92290f1cfa8c36ab509c9b6189d3216"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2374a88acff100721223f7b944488e64279f0fb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2374a88acff100721223f7b944488e64279f0fb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2374a88acff100721223f7b944488e64279f0fb2"}], "stats": {"total": 879, "additions": 637, "deletions": 242}, "files": [{"sha": "3ac229fdc8a2f65fb1de4f2e89798eee9419552d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=296799ba06ab9ff273038e9b4dd93ca9ba65bf1c", "patch": "@@ -1,3 +1,55 @@\n+2011-07-28  Georg-Johann Lay  <avr@gjlay.de>\n+\t\n+\tPR target/49687\n+\t* config/avr/t-avr (LIB1ASMFUNCS): Remove _xmulhisi3_exit.\n+\tAdd _muluhisi3, _mulshisi3, _usmulhisi3.\n+\t* config/avr/libgcc.S (__mulsi3): Rewrite.\n+\t(__mulhisi3): Rewrite.\n+\t(__umulhisi3): Rewrite.\n+\t(__usmulhisi3): New.\n+\t(__muluhisi3): New.\n+\t(__mulshisi3): New.\n+\t(__mulohisi3): New.\n+\t(__mulqi3, __mulqihi3, __umulqihi3, __mulhi3): Use DEFUN/ENDF to\n+\tdeclare.\n+\t* config/avr/predicates.md (pseudo_register_operand): Rewrite.\n+\t(pseudo_register_or_const_int_operand): New.\n+\t(combine_pseudo_register_operand): New.\n+\t(u16_operand): New.\n+\t(s16_operand): New.\n+\t(o16_operand): New.\n+\t* config/avr/avr.c (avr_rtx_costs): Handle costs for mult:SI.\n+\t* config/avr/avr.md (QIHI, QIHI2): New mode iterators.\n+\t(any_extend, any_extend2): New code iterators.\n+\t(extend_prefix): New code attribute.\n+\t(mulsi3): Rewrite. Turn insn to expander.\n+\t(mulhisi3): Ditto.\n+\t(umulhisi3): Ditto.\n+\t(usmulhisi3): New expander.\n+\t(*mulsi3): New insn-and-split.\n+\t(mulu<mode>si3): New insn-and-split.\n+\t(muls<mode>si3): New insn-and-split.\n+\t(mulohisi3): New insn-and-split.\n+\t(*uumulqihisi3, *uumulhiqisi3, *uumulhihisi3, *uumulqiqisi3,\n+\t*usmulqihisi3, *usmulhiqisi3, *usmulhihisi3, *usmulqiqisi3,\n+\t*sumulqihisi3, *sumulhiqisi3, *sumulhihisi3, *sumulqiqisi3,\n+\t*ssmulqihisi3, *ssmulhiqisi3, *ssmulhihisi3, *ssmulqiqisi3): New\n+\tinsn-and-split.\n+\t(*mulsi3_call): Rewrite.\n+\t(*mulhisi3_call): Rewrite.\n+\t(*umulhisi3_call): Rewrite.\n+\t(*usmulhisi3_call): New insn.\n+\t(*muluhisi3_call): New insn.\n+\t(*mulshisi3_call): New insn.\n+\t(*mulohisi3_call): New insn.\n+\t(extendqihi2): Use combine_pseudo_register_operand as predicate\n+\tfor operand 1.\n+\t(extendqisi2): Ditto.\n+\t(zero_extendqihi2): Ditto.\n+\t(zero_extendqisi2): Ditto.\n+\t(zero_extendhisi2): Ditto.\n+\t(extendhisi2): Ditto. Don't early-clobber operand 0.\n+\n 2011-07-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (add->lea splitter): Add SWI mode to PLUS RTX."}, {"sha": "d9ed22489479355f9067472c390b022c0b803c38", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=296799ba06ab9ff273038e9b4dd93ca9ba65bf1c", "patch": "@@ -5515,6 +5515,34 @@ avr_rtx_costs (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED, int *total,\n \t    return false;\n \t  break;\n \n+\tcase SImode:\n+\t  if (AVR_HAVE_MUL)\n+            {\n+              if (!speed)\n+                {\n+                  /* Add some additional costs besides CALL like moves etc.  */\n+\n+                  *total = COSTS_N_INSNS (AVR_HAVE_JMP_CALL ? 5 : 4);\n+                }\n+              else\n+                {\n+                  /* Just a rough estimate.  Even with -O2 we don't want bulky\n+                     code expanded inline.  */\n+\n+                  *total = COSTS_N_INSNS (25);\n+                }\n+            }\n+          else\n+            {\n+              if (speed)\n+                *total = COSTS_N_INSNS (300);\n+              else\n+                /* Add some additional costs besides CALL like moves etc.  */\n+                *total = COSTS_N_INSNS (AVR_HAVE_JMP_CALL ? 5 : 4);\n+            }\n+          \n+          return true;\n+          \n \tdefault:\n \t  return false;\n \t}"}, {"sha": "3f3bb6a2b5b137982a7f54df0592e54bfd63a28a", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 305, "deletions": 44, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=296799ba06ab9ff273038e9b4dd93ca9ba65bf1c", "patch": "@@ -127,12 +127,25 @@\n \t\t       (const_int 2))]\n         (const_int 2)))\n \n-;; Define mode iterator\n+;; Define mode iterators\n+(define_mode_iterator QIHI  [(QI \"\") (HI \"\")])\n+(define_mode_iterator QIHI2 [(QI \"\") (HI \"\")])\n (define_mode_iterator QISI [(QI \"\") (HI \"\") (SI \"\")])\n (define_mode_iterator QIDI [(QI \"\") (HI \"\") (SI \"\") (DI \"\")])\n (define_mode_iterator HIDI [(HI \"\") (SI \"\") (DI \"\")])\n (define_mode_iterator HISI [(HI \"\") (SI \"\")])\n \n+;; Define code iterators\n+;; Define two incarnations so that we can build the cross product.\n+(define_code_iterator any_extend  [sign_extend zero_extend])\n+(define_code_iterator any_extend2 [sign_extend zero_extend])\n+\n+;; Define code attributes\n+(define_code_attr extend_prefix\n+  [(sign_extend \"s\")\n+   (zero_extend \"u\")])\n+\n+\n ;;========================================================================\n ;; The following is used by nonlocal_goto and setjmp.\n ;; The receiver pattern will create no instructions since internally\n@@ -1350,69 +1363,310 @@\n \n ;; Operand 2 (reg:SI 18) not clobbered on the enhanced core.\n ;; All call-used registers clobbered otherwise - normal library call.\n+;;    To support widening multiplicatioon with constant we postpone\n+;; expanding to the implicit library call until post combine and\n+;; prior to register allocation.  Clobber all hard registers that\n+;; might be used by the (widening) multiply until it is split and\n+;; it's final register footprint is worked out.\n+\n (define_expand \"mulsi3\"\n-  [(set (reg:SI 22) (match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (reg:SI 18) (match_operand:SI 2 \"register_operand\" \"\"))\n-   (parallel [(set (reg:SI 22) (mult:SI (reg:SI 22) (reg:SI 18)))\n-\t      (clobber (reg:HI 26))\n-\t      (clobber (reg:HI 30))])\n-   (set (match_operand:SI 0 \"register_operand\" \"\") (reg:SI 22))]\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+                   (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+                            (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+              (clobber (reg:DI 18))])]\n   \"AVR_HAVE_MUL\"\n-  \"\")\n+  {\n+    if (u16_operand (operands[2], SImode))\n+      {\n+        operands[2] = force_reg (HImode, gen_int_mode (INTVAL (operands[2]), HImode));\n+        emit_insn (gen_muluhisi3 (operands[0], operands[2], operands[1]));\n+        DONE;\n+      }\n \n-(define_insn \"*mulsi3_call\"\n-  [(set (reg:SI 22) (mult:SI (reg:SI 22) (reg:SI 18)))\n-   (clobber (reg:HI 26))\n-   (clobber (reg:HI 30))]\n-  \"AVR_HAVE_MUL\"\n-  \"%~call __mulsi3\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+    if (o16_operand (operands[2], SImode))\n+      {\n+        operands[2] = force_reg (HImode, gen_int_mode (INTVAL (operands[2]), HImode));\n+        emit_insn (gen_mulohisi3 (operands[0], operands[2], operands[1]));\n+        DONE;\n+      }\n+  })\n \n-(define_expand \"mulhisi3\"\n-  [(set (reg:HI 18)\n-        (match_operand:HI 1 \"register_operand\" \"\"))\n-   (set (reg:HI 20)\n-        (match_operand:HI 2 \"register_operand\" \"\"))\n+(define_insn_and_split \"*mulsi3\"\n+  [(set (match_operand:SI 0 \"pseudo_register_operand\"                      \"=r\")\n+        (mult:SI (match_operand:SI 1 \"pseudo_register_operand\"              \"r\")\n+                 (match_operand:SI 2 \"pseudo_register_or_const_int_operand\" \"rn\")))\n+   (clobber (reg:DI 18))]\n+  \"AVR_HAVE_MUL && !reload_completed\"\n+  { gcc_unreachable(); }\n+  \"&& 1\"\n+  [(set (reg:SI 18)\n+        (match_dup 1))\n    (set (reg:SI 22) \n-        (mult:SI (sign_extend:SI (reg:HI 18))\n-                 (sign_extend:SI (reg:HI 20))))\n-   (set (match_operand:SI 0 \"register_operand\" \"\") \n+        (match_dup 2))\n+   (parallel [(set (reg:SI 22)\n+                   (mult:SI (reg:SI 22)\n+                            (reg:SI 18)))\n+              (clobber (reg:HI 26))])\n+   (set (match_dup 0)\n+        (reg:SI 22))]\n+  {\n+    if (u16_operand (operands[2], SImode))\n+      {\n+        operands[2] = force_reg (HImode, gen_int_mode (INTVAL (operands[2]), HImode));\n+        emit_insn (gen_muluhisi3 (operands[0], operands[2], operands[1]));\n+        DONE;\n+      }\n+\n+    if (o16_operand (operands[2], SImode))\n+      {\n+        operands[2] = force_reg (HImode, gen_int_mode (INTVAL (operands[2]), HImode));\n+        emit_insn (gen_mulohisi3 (operands[0], operands[2], operands[1]));\n+        DONE;\n+      }\n+  })\n+\n+;; \"muluqisi3\"\n+;; \"muluhisi3\"\n+(define_insn_and_split \"mulu<mode>si3\"\n+  [(set (match_operand:SI 0 \"pseudo_register_operand\"                           \"=r\")\n+        (mult:SI (zero_extend:SI (match_operand:QIHI 1 \"pseudo_register_operand\" \"r\"))\n+                 (match_operand:SI 2 \"pseudo_register_or_const_int_operand\"      \"rn\")))\n+   (clobber (reg:DI 18))]\n+  \"AVR_HAVE_MUL && !reload_completed\"\n+  { gcc_unreachable(); }\n+  \"&& 1\"\n+  [(set (reg:HI 26)\n+        (match_dup 1))\n+   (set (reg:SI 18)\n+        (match_dup 2))\n+   (set (reg:SI 22)\n+        (mult:SI (zero_extend:SI (reg:HI 26))\n+                 (reg:SI 18)))\n+   (set (match_dup 0)\n+        (reg:SI 22))]\n+  {\n+    /* Do the QI -> HI extension explicitely before the multiplication.  */\n+    /* Do the HI -> SI extension implicitely and after the multiplication.  */\n+       \n+    if (QImode == <MODE>mode)\n+      operands[1] = gen_rtx_ZERO_EXTEND (HImode, operands[1]);\n+\n+    if (u16_operand (operands[2], SImode))\n+      {\n+        operands[1] = force_reg (HImode, operands[1]);\n+        operands[2] = force_reg (HImode, gen_int_mode (INTVAL (operands[2]), HImode));\n+        emit_insn (gen_umulhisi3 (operands[0], operands[1], operands[2]));\n+        DONE;\n+      }\n+  })\n+\n+;; \"mulsqisi3\"\n+;; \"mulshisi3\"\n+(define_insn_and_split \"muls<mode>si3\"\n+  [(set (match_operand:SI 0 \"pseudo_register_operand\"                           \"=r\")\n+        (mult:SI (sign_extend:SI (match_operand:QIHI 1 \"pseudo_register_operand\" \"r\"))\n+                 (match_operand:SI 2 \"pseudo_register_or_const_int_operand\"      \"rn\")))\n+   (clobber (reg:DI 18))]\n+  \"AVR_HAVE_MUL && !reload_completed\"\n+  { gcc_unreachable(); }\n+  \"&& 1\"\n+  [(set (reg:HI 26)\n+        (match_dup 1))\n+   (set (reg:SI 18)\n+        (match_dup 2))\n+   (set (reg:SI 22)\n+        (mult:SI (sign_extend:SI (reg:HI 26))\n+                 (reg:SI 18)))\n+   (set (match_dup 0)\n         (reg:SI 22))]\n+  {\n+    /* Do the QI -> HI extension explicitely before the multiplication.  */\n+    /* Do the HI -> SI extension implicitely and after the multiplication.  */\n+       \n+    if (QImode == <MODE>mode)\n+      operands[1] = gen_rtx_SIGN_EXTEND (HImode, operands[1]);\n+\n+    if (u16_operand (operands[2], SImode)\n+        || s16_operand (operands[2], SImode))\n+      {\n+        rtx xop2 = force_reg (HImode, gen_int_mode (INTVAL (operands[2]), HImode));\n+\n+        operands[1] = force_reg (HImode, operands[1]);\n+\n+        if (u16_operand (operands[2], SImode))\n+          emit_insn (gen_usmulhisi3 (operands[0], xop2, operands[1]));\n+        else\n+          emit_insn (gen_mulhisi3 (operands[0], operands[1], xop2));\n+\n+        DONE;\n+      }\n+  })\n+\n+;; One-extend operand 1\n+\n+(define_insn_and_split \"mulohisi3\"\n+  [(set (match_operand:SI 0 \"pseudo_register_operand\"                          \"=r\")\n+        (mult:SI (not:SI (zero_extend:SI \n+                          (not:HI (match_operand:HI 1 \"pseudo_register_operand\" \"r\"))))\n+                 (match_operand:SI 2 \"pseudo_register_or_const_int_operand\"     \"rn\")))\n+   (clobber (reg:DI 18))]\n+  \"AVR_HAVE_MUL && !reload_completed\"\n+  { gcc_unreachable(); }\n+  \"&& 1\"\n+  [(set (reg:HI 26)\n+        (match_dup 1))\n+   (set (reg:SI 18)\n+        (match_dup 2))\n+   (set (reg:SI 22)\n+        (mult:SI (not:SI (zero_extend:SI (not:HI (reg:HI 26))))\n+                 (reg:SI 18)))\n+   (set (match_dup 0)\n+        (reg:SI 22))]\n+  \"\")\n+\n+(define_expand \"mulhisi3\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+                   (mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n+                            (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"\"))))\n+              (clobber (reg:DI 18))])]\n   \"AVR_HAVE_MUL\"\n   \"\")\n \n (define_expand \"umulhisi3\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+                   (mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n+                            (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"\"))))\n+              (clobber (reg:DI 18))])]\n+  \"AVR_HAVE_MUL\"\n+  \"\")\n+\n+(define_expand \"usmulhisi3\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+                   (mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n+                            (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"\"))))\n+              (clobber (reg:DI 18))])]\n+  \"AVR_HAVE_MUL\"\n+  \"\")\n+\n+;; \"*uumulqihisi3\" \"*uumulhiqisi3\" \"*uumulhihisi3\" \"*uumulqiqisi3\"\n+;; \"*usmulqihisi3\" \"*usmulhiqisi3\" \"*usmulhihisi3\" \"*usmulqiqisi3\"\n+;; \"*sumulqihisi3\" \"*sumulhiqisi3\" \"*sumulhihisi3\" \"*sumulqiqisi3\"\n+;; \"*ssmulqihisi3\" \"*ssmulhiqisi3\" \"*ssmulhihisi3\" \"*ssmulqiqisi3\"\n+(define_insn_and_split\n+  \"*<any_extend:extend_prefix><any_extend2:extend_prefix>mul<QIHI:mode><QIHI2:mode>si3\"\n+  [(set (match_operand:SI 0 \"pseudo_register_operand\"                            \"=r\")\n+        (mult:SI (any_extend:SI (match_operand:QIHI 1 \"pseudo_register_operand\"   \"r\"))\n+                 (any_extend2:SI (match_operand:QIHI2 2 \"pseudo_register_operand\" \"r\"))))\n+   (clobber (reg:DI 18))]\n+  \"AVR_HAVE_MUL && !reload_completed\"\n+  { gcc_unreachable(); }\n+  \"&& 1\"\n   [(set (reg:HI 18)\n-        (match_operand:HI 1 \"register_operand\" \"\"))\n-   (set (reg:HI 20)\n-        (match_operand:HI 2 \"register_operand\" \"\"))\n-   (set (reg:SI 22) \n-        (mult:SI (zero_extend:SI (reg:HI 18))\n-                 (zero_extend:SI (reg:HI 20))))\n-   (set (match_operand:SI 0 \"register_operand\" \"\") \n+        (match_dup 1))\n+   (set (reg:HI 26)\n+        (match_dup 2))\n+   (set (reg:SI 22)\n+        (mult:SI (match_dup 3)\n+                 (match_dup 4)))\n+   (set (match_dup 0)\n         (reg:SI 22))]\n+  {\n+    rtx xop1 = operands[1];\n+    rtx xop2 = operands[2];\n+\n+    /* Do the QI -> HI extension explicitely before the multiplication.  */\n+    /* Do the HI -> SI extension implicitely and after the multiplication.  */\n+       \n+    if (QImode == <QIHI:MODE>mode)\n+      xop1 = gen_rtx_fmt_e (<any_extend:CODE>, HImode, xop1);\n+\n+    if (QImode == <QIHI2:MODE>mode)\n+      xop2 = gen_rtx_fmt_e (<any_extend2:CODE>, HImode, xop2);\n+\n+    if (<any_extend:CODE> == <any_extend2:CODE>\n+        || <any_extend:CODE> == ZERO_EXTEND)\n+      {\n+        operands[1] = xop1;\n+        operands[2] = xop2;\n+        operands[3] = gen_rtx_fmt_e (<any_extend:CODE>, SImode, gen_rtx_REG (HImode, 18));\n+        operands[4] = gen_rtx_fmt_e (<any_extend2:CODE>, SImode, gen_rtx_REG (HImode, 26));\n+      }\n+    else\n+      {\n+        /* <any_extend:CODE>  = SIGN_EXTEND */\n+        /* <any_extend2:CODE> = ZERO_EXTEND */\n+\n+        operands[1] = xop2;\n+        operands[2] = xop1;\n+        operands[3] = gen_rtx_ZERO_EXTEND (SImode, gen_rtx_REG (HImode, 18));\n+        operands[4] = gen_rtx_SIGN_EXTEND (SImode, gen_rtx_REG (HImode, 26));\n+      }\n+  })\n+\n+(define_insn \"*mulsi3_call\"\n+  [(set (reg:SI 22)\n+        (mult:SI (reg:SI 22)\n+                 (reg:SI 18)))\n+   (clobber (reg:HI 26))]\n   \"AVR_HAVE_MUL\"\n-  \"\")\n+  \"%~call __mulsi3\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"*mulhisi3_call\"\n-  [(set (reg:SI 22) \n+  [(set (reg:SI 22)\n         (mult:SI (sign_extend:SI (reg:HI 18))\n-                 (sign_extend:SI (reg:HI 20))))]\n+                 (sign_extend:SI (reg:HI 26))))]\n   \"AVR_HAVE_MUL\"\n   \"%~call __mulhisi3\"\n   [(set_attr \"type\" \"xcall\")\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"*umulhisi3_call\"\n-  [(set (reg:SI 22) \n+  [(set (reg:SI 22)\n         (mult:SI (zero_extend:SI (reg:HI 18))\n-                 (zero_extend:SI (reg:HI 20))))]\n+                 (zero_extend:SI (reg:HI 26))))]\n   \"AVR_HAVE_MUL\"\n   \"%~call __umulhisi3\"\n   [(set_attr \"type\" \"xcall\")\n    (set_attr \"cc\" \"clobber\")])\n \n+(define_insn \"*usmulhisi3_call\"\n+  [(set (reg:SI 22)\n+        (mult:SI (zero_extend:SI (reg:HI 18))\n+                 (sign_extend:SI (reg:HI 26))))]\n+  \"AVR_HAVE_MUL\"\n+  \"%~call __usmulhisi3\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*muluhisi3_call\"\n+  [(set (reg:SI 22)\n+        (mult:SI (zero_extend:SI (reg:HI 26))\n+                 (reg:SI 18)))]\n+  \"AVR_HAVE_MUL\"\n+  \"%~call __muluhisi3\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*mulshisi3_call\"\n+  [(set (reg:SI 22)\n+        (mult:SI (sign_extend:SI (reg:HI 26))\n+                 (reg:SI 18)))]\n+  \"AVR_HAVE_MUL\"\n+  \"%~call __mulshisi3\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*mulohisi3_call\"\n+  [(set (reg:SI 22)\n+        (mult:SI (not:SI (zero_extend:SI (not:HI (reg:HI 26))))\n+                 (reg:SI 18)))]\n+  \"AVR_HAVE_MUL\"\n+  \"%~call __mulohisi3\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n ; / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / %\n ; divmod\n \n@@ -2400,9 +2654,16 @@\n ;; xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x\n ;; sign extend\n \n+;; We keep combiner from inserting hard registers into the input of sign- and\n+;; zero-extends.  A hard register in the input operand is not wanted because\n+;; 32-bit multiply patterns clobber some hard registers and extends with a\n+;; hard register that overlaps these clobbers won't be combined to a widening\n+;; multiplication.  There is no need for combine to propagate hard registers,\n+;; register allocation can do it just as well.\n+\n (define_insn \"extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-        (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"0,*r\")))]\n+        (sign_extend:HI (match_operand:QI 1 \"combine_pseudo_register_operand\" \"0,*r\")))]\n   \"\"\n   \"@\n \tclr %B0\\;sbrc %0,7\\;com %B0\n@@ -2412,7 +2673,7 @@\n \n (define_insn \"extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-        (sign_extend:SI (match_operand:QI 1 \"register_operand\" \"0,*r\")))]\n+        (sign_extend:SI (match_operand:QI 1 \"combine_pseudo_register_operand\" \"0,*r\")))]\n   \"\"\n   \"@\n \tclr %B0\\;sbrc %A0,7\\;com %B0\\;mov %C0,%B0\\;mov %D0,%B0\n@@ -2421,8 +2682,8 @@\n    (set_attr \"cc\" \"set_n,set_n\")])\n \n (define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\"               \"=r,&r\")\n-        (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"0,*r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"                               \"=r,r\")\n+        (sign_extend:SI (match_operand:HI 1 \"combine_pseudo_register_operand\" \"0,*r\")))]\n   \"\"\n   \"@\n \tclr %C0\\;sbrc %B0,7\\;com %C0\\;mov %D0,%C0\n@@ -2439,7 +2700,7 @@\n \n (define_insn_and_split \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+        (zero_extend:HI (match_operand:QI 1 \"combine_pseudo_register_operand\" \"r\")))]\n   \"\"\n   \"#\"\n   \"reload_completed\"\n@@ -2455,7 +2716,7 @@\n \n (define_insn_and_split \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+        (zero_extend:SI (match_operand:QI 1 \"combine_pseudo_register_operand\" \"r\")))]\n   \"\"\n   \"#\"\n   \"reload_completed\"\n@@ -2470,8 +2731,8 @@\n })\n \n (define_insn_and_split \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"                               \"=r\")\n+        (zero_extend:SI (match_operand:HI 1 \"combine_pseudo_register_operand\" \"r\")))]\n   \"\"\n   \"#\"\n   \"reload_completed\""}, {"sha": "f6084a7051823d1b29578d8267eaa2fa40af368c", "filename": "gcc/config/avr/libgcc.S", "status": "modified", "additions": 208, "deletions": 195, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2Fconfig%2Favr%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2Fconfig%2Favr%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Flibgcc.S?ref=296799ba06ab9ff273038e9b4dd93ca9ba65bf1c", "patch": "@@ -72,20 +72,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n .endm\n \n \f\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n /* Note: mulqi3, mulhi3 are open-coded on the enhanced core.  */\n #if !defined (__AVR_HAVE_MUL__)\n /*******************************************************\n-               Multiplication  8 x 8\n+    Multiplication  8 x 8  without MUL\n *******************************************************/\n #if defined (L_mulqi3)\n \n #define\tr_arg2\tr22\t\t/* multiplicand */\n #define\tr_arg1 \tr24\t\t/* multiplier */\n #define r_res\t__tmp_reg__\t/* result */\n \n-\t.global\t__mulqi3\n-\t.func\t__mulqi3\n-__mulqi3:\n+DEFUN __mulqi3\n \tclr\tr_res\t\t; clear result\n __mulqi3_loop:\n \tsbrc\tr_arg1,0\n@@ -97,40 +96,36 @@ __mulqi3_loop:\n __mulqi3_exit:\t\n \tmov\tr_arg1,r_res\t; result to return register\n \tret\n+ENDF __mulqi3\n \n #undef r_arg2  \n #undef r_arg1  \n #undef r_res   \n \t\n-.endfunc\n #endif \t/* defined (L_mulqi3) */\n \n #if defined (L_mulqihi3)\n-\t.global\t__mulqihi3\n-\t.func\t__mulqihi3\n-__mulqihi3:\n+DEFUN __mulqihi3\n \tclr\tr25\n \tsbrc\tr24, 7\n \tdec\tr25\n \tclr\tr23\n \tsbrc\tr22, 7\n \tdec\tr22\n \trjmp\t__mulhi3\n-\t.endfunc\n+ENDF __mulqihi3:\n #endif /* defined (L_mulqihi3) */\n \n #if defined (L_umulqihi3)\n-\t.global\t__umulqihi3\n-\t.func\t__umulqihi3\n-__umulqihi3:\n+DEFUN __umulqihi3\n \tclr\tr25\n \tclr\tr23\n \trjmp\t__mulhi3\n-\t.endfunc\n+ENDF __umulqihi3\n #endif /* defined (L_umulqihi3) */\n \n /*******************************************************\n-               Multiplication  16 x 16\n+    Multiplication  16 x 16  without MUL\n *******************************************************/\n #if defined (L_mulhi3)\n #define\tr_arg1L\tr24\t\t/* multiplier Low */\n@@ -140,9 +135,7 @@ __umulqihi3:\n #define r_resL\t__tmp_reg__\t/* result Low */\n #define r_resH  r21\t\t/* result High */\n \n-\t.global\t__mulhi3\n-\t.func\t__mulhi3\n-__mulhi3:\n+DEFUN __mulhi3\n \tclr\tr_resH\t\t; clear result\n \tclr\tr_resL\t\t; clear result\n __mulhi3_loop:\n@@ -166,6 +159,7 @@ __mulhi3_exit:\n \tmov\tr_arg1H,r_resH\t; result to return register\n \tmov\tr_arg1L,r_resL\n \tret\n+ENDF __mulhi3\n \n #undef r_arg1L\n #undef r_arg1H\n@@ -174,168 +168,51 @@ __mulhi3_exit:\n #undef r_resL \t\n #undef r_resH \n \n-.endfunc\n #endif /* defined (L_mulhi3) */\n-#endif /* !defined (__AVR_HAVE_MUL__) */\n \n /*******************************************************\n-      Widening Multiplication  32 = 16 x 16\n+    Widening Multiplication  32 = 16 x 16  without MUL\n *******************************************************/\n-                              \n+\n #if defined (L_mulhisi3)\n DEFUN __mulhisi3\n-#if defined (__AVR_HAVE_MUL__)\n-\n-;; r25:r22 = r19:r18 * r21:r20\n-\n-#define A0 18\n-#define B0 20\n-#define C0 22\n-\n-#define A1 A0+1\n-#define B1 B0+1\n-#define C1 C0+1\n-#define C2 C0+2\n-#define C3 C0+3\n- \n-    ; C = (signed)A1 * (signed)B1\n-    muls  A1, B1\n-    movw  C2, R0\n-\n-    ; C += A0 * B0\n-    mul   A0, B0\n-    movw  C0, R0\n-\n-    ; C += (signed)A1 * B0\n-    mulsu A1, B0\n-    sbci  C3, 0\n-    add   C1, R0\n-    adc   C2, R1\n-    clr   __zero_reg__\n-    adc   C3, __zero_reg__\n-\n-    ; C += (signed)B1 * A0\n-    mulsu B1, A0\n-    sbci  C3, 0\n-    XJMP  __xmulhisi3_exit\n-\n-#undef A0\n-#undef A1\n-#undef B0\n-#undef B1\n-#undef C0\n-#undef C1\n-#undef C2\n-#undef C3\n-\n-#else /* !__AVR_HAVE_MUL__ */\n ;;; FIXME: This is dead code (noone calls it)\n-\tmov_l\tr18, r24\n-\tmov_h\tr19, r25\n-\tclr\tr24\n-\tsbrc\tr23, 7\n-\tdec\tr24\n-\tmov\tr25, r24\n-\tclr\tr20\n-\tsbrc\tr19, 7\n-\tdec\tr20\n-\tmov\tr21, r20\n-\tXJMP\t__mulsi3\n-#endif /* __AVR_HAVE_MUL__ */\n+    mov_l   r18, r24\n+    mov_h   r19, r25\n+    clr     r24\n+    sbrc    r23, 7\n+    dec     r24\n+    mov     r25, r24\n+    clr     r20\n+    sbrc    r19, 7\n+    dec     r20\n+    mov     r21, r20\n+    XJMP    __mulsi3\n ENDF __mulhisi3\n #endif /* defined (L_mulhisi3) */\n \n #if defined (L_umulhisi3)\n DEFUN __umulhisi3\n-#if defined (__AVR_HAVE_MUL__)\n-\n-;; r25:r22 = r19:r18 * r21:r20\n-\n-#define A0 18\n-#define B0 20\n-#define C0 22\n-\n-#define A1 A0+1\n-#define B1 B0+1\n-#define C1 C0+1\n-#define C2 C0+2\n-#define C3 C0+3\n-\n-    ; C = A1 * B1\n-    mul   A1, B1\n-    movw  C2, R0\n-\n-    ; C += A0 * B0\n-    mul   A0, B0\n-    movw  C0, R0\n-\n-    ; C += A1 * B0\n-    mul   A1, B0\n-    add   C1, R0\n-    adc   C2, R1\n-    clr   __zero_reg__\n-    adc   C3, __zero_reg__\n-\n-    ; C += B1 * A0\n-    mul   B1, A0\n-    XJMP  __xmulhisi3_exit\n-\n-#undef A0\n-#undef A1\n-#undef B0\n-#undef B1\n-#undef C0\n-#undef C1\n-#undef C2\n-#undef C3\n-\n-#else /* !__AVR_HAVE_MUL__ */\n ;;; FIXME: This is dead code (noone calls it)\n-\tmov_l\tr18, r24\n-\tmov_h\tr19, r25\n-\tclr\tr24\n-\tclr\tr25\n-\tclr\tr20\n-\tclr\tr21\n-\tXJMP\t__mulsi3\n-#endif /* __AVR_HAVE_MUL__ */\n+    mov_l   r18, r24\n+    mov_h   r19, r25\n+    clr     r24\n+    clr     r25\n+    mov_l   r20, r24\n+    mov_h   r21, r25\n+    XJMP    __mulsi3\n ENDF __umulhisi3\n #endif /* defined (L_umulhisi3) */\n \n-#if defined (L_xmulhisi3_exit)\n-\n-;;; Helper for __mulhisi3 resp. __umulhisi3.\n-\n-#define C0 22\n-#define C1 C0+1\n-#define C2 C0+2\n-#define C3 C0+3\n-\n-DEFUN __xmulhisi3_exit\n-    add   C1, R0\n-    adc   C2, R1\n-    clr   __zero_reg__\n-    adc   C3, __zero_reg__\n-    ret\n-ENDF __xmulhisi3_exit\n-\n-#undef C0\n-#undef C1\n-#undef C2\n-#undef C3\n-\n-#endif /* defined (L_xmulhisi3_exit) */\n-\n #if defined (L_mulsi3)\n /*******************************************************\n-               Multiplication  32 x 32\n+    Multiplication  32 x 32  without MUL\n *******************************************************/\n #define r_arg1L  r22\t\t/* multiplier Low */\n #define r_arg1H  r23\n #define\tr_arg1HL r24\n #define\tr_arg1HH r25\t\t/* multiplier High */\n \n-\n #define\tr_arg2L  r18\t\t/* multiplicand Low */\n #define\tr_arg2H  r19\t\n #define\tr_arg2HL r20\n@@ -346,43 +223,7 @@ ENDF __xmulhisi3_exit\n #define r_resHL\t r30\n #define r_resHH  r31\t\t/* result High */\n \n-\t\n-\t.global\t__mulsi3\n-\t.func\t__mulsi3\n-__mulsi3:\n-#if defined (__AVR_HAVE_MUL__)\n-\tmul\tr_arg1L, r_arg2L\n-\tmovw\tr_resL, r0\n-\tmul\tr_arg1H, r_arg2H\n-\tmovw\tr_resHL, r0\n-\tmul\tr_arg1HL, r_arg2L\n-\tadd\tr_resHL, r0\n-\tadc\tr_resHH, r1\n-\tmul\tr_arg1L, r_arg2HL\n-\tadd\tr_resHL, r0\n-\tadc\tr_resHH, r1\n-\tmul\tr_arg1HH, r_arg2L\n-\tadd\tr_resHH, r0\n-\tmul\tr_arg1HL, r_arg2H\n-\tadd\tr_resHH, r0\n-\tmul\tr_arg1H, r_arg2HL\n-\tadd\tr_resHH, r0\n-\tmul\tr_arg1L, r_arg2HH\n-\tadd\tr_resHH, r0\n-\tclr\tr_arg1HH\t; use instead of __zero_reg__ to add carry\n-\tmul\tr_arg1H, r_arg2L\n-\tadd\tr_resH, r0\n-\tadc\tr_resHL, r1\n-\tadc\tr_resHH, r_arg1HH ; add carry\n-\tmul\tr_arg1L, r_arg2H\n-\tadd\tr_resH, r0\n-\tadc\tr_resHL, r1\n-\tadc\tr_resHH, r_arg1HH ; add carry\n-\tmovw\tr_arg1L, r_resL\n-\tmovw\tr_arg1HL, r_resHL\n-\tclr\tr1\t\t; __zero_reg__ clobbered by \"mul\"\n-\tret\n-#else\n+DEFUN __mulsi3\n \tclr\tr_resHH\t\t; clear result\n \tclr\tr_resHL\t\t; clear result\n \tclr\tr_resH\t\t; clear result\n@@ -414,13 +255,13 @@ __mulsi3_exit:\n \tmov_h\tr_arg1H,r_resH\n \tmov_l\tr_arg1L,r_resL\n \tret\n-#endif /* defined (__AVR_HAVE_MUL__) */\n+ENDF __mulsi3\n+\n #undef r_arg1L \n #undef r_arg1H \n #undef r_arg1HL\n #undef r_arg1HH\n              \n-             \n #undef r_arg2L \n #undef r_arg2H \n #undef r_arg2HL\n@@ -431,9 +272,181 @@ __mulsi3_exit:\n #undef r_resHL \n #undef r_resHH \n \n-.endfunc\n #endif /* defined (L_mulsi3) */\n+\n+#endif /* !defined (__AVR_HAVE_MUL__) */\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\f\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+#if defined (__AVR_HAVE_MUL__)    \n+#define A0 26\n+#define B0 18\n+#define C0 22\n+\n+#define A1 A0+1\n+\n+#define B1 B0+1\n+#define B2 B0+2\n+#define B3 B0+3\n+\n+#define C1 C0+1\n+#define C2 C0+2\n+#define C3 C0+3\n+\n+/*******************************************************\n+    Widening Multiplication  32 = 16 x 16\n+*******************************************************/\n+                              \n+#if defined (L_mulhisi3)\n+;;; R25:R22 = (signed long) R27:R26 * (signed long) R19:R18\n+;;; C3:C0   = (signed long) A1:A0   * (signed long) B1:B0\n+;;; Clobbers: __tmp_reg__\n+DEFUN __mulhisi3\n+    XCALL   __umulhisi3\n+    ;; Sign-extend B\n+    tst     B1\n+    brpl    1f\n+    sub     C2, A0\n+    sbc     C3, A1\n+1:  ;; Sign-extend A\n+    XJMP __usmulhisi3_tail\n+ENDF __mulhisi3\n+#endif /* L_mulhisi3 */\n+\n+#if defined (L_usmulhisi3)\n+;;; R25:R22 = (signed long) R27:R26 * (unsigned long) R19:R18\n+;;; C3:C0   = (signed long) A1:A0   * (unsigned long) B1:B0\n+;;; Clobbers: __tmp_reg__\n+DEFUN __usmulhisi3\n+    XCALL   __umulhisi3\n+    ;; FALLTHRU\n+ENDF __usmulhisi3\n+\n+DEFUN __usmulhisi3_tail\n+    ;; Sign-extend A\n+    sbrs    A1, 7\n+    ret\n+    sub     C2, B0\n+    sbc     C3, B1\n+    ret\n+ENDF __usmulhisi3_tail\n+#endif /* L_usmulhisi3 */\n+\n+#if defined (L_umulhisi3)\n+;;; R25:R22 = (unsigned long) R27:R26 * (unsigned long) R19:R18\n+;;; C3:C0   = (unsigned long) A1:A0   * (unsigned long) B1:B0\n+;;; Clobbers: __tmp_reg__\n+DEFUN __umulhisi3\n+    mul     A0, B0\n+    movw    C0, r0\n+    mul     A1, B1\n+    movw    C2, r0\n+    mul     A0, B1\n+    rcall   1f\n+    mul     A1, B0\n+1:  add     C1, r0\n+    adc     C2, r1\n+    clr     __zero_reg__\n+    adc     C3, __zero_reg__\n+    ret\n+ENDF __umulhisi3\n+#endif /* L_umulhisi3 */\n+\n+/*******************************************************\n+    Widening Multiplication  32 = 16 x 32\n+*******************************************************/\n+\n+#if defined (L_mulshisi3)\n+;;; R25:R22 = (signed long) R27:R26 * R21:R18\n+;;; (C3:C0) = (signed long) A1:A0   * B3:B0\n+;;; Clobbers: __tmp_reg__\n+DEFUN __mulshisi3\n+#ifdef __AVR_HAVE_JMP_CALL__\n+    ;; Some cores have problem skipping 2-word instruction\n+    tst     A1\n+    brmi    __mulohisi3\n+#else\n+    sbrs    A1, 7\n+#endif /* __AVR_HAVE_JMP_CALL__ */\n+    XJMP    __muluhisi3\n+    ;; FALLTHRU\n+ENDF __mulshisi3\n+    \n+;;; R25:R22 = (one-extended long) R27:R26 * R21:R18\n+;;; (C3:C0) = (one-extended long) A1:A0   * B3:B0\n+;;; Clobbers: __tmp_reg__\n+DEFUN __mulohisi3\n+    XCALL   __muluhisi3\n+    ;; One-extend R27:R26 (A1:A0)\n+    sub     C2, B0\n+    sbc     C3, B1\n+    ret\n+ENDF __mulohisi3\n+#endif /* L_mulshisi3 */\n+\n+#if defined (L_muluhisi3)\n+;;; R25:R22 = (unsigned long) R27:R26 * R21:R18\n+;;; (C3:C0) = (unsigned long) A1:A0   * B3:B0\n+;;; Clobbers: __tmp_reg__\n+DEFUN __muluhisi3\n+    XCALL   __umulhisi3\n+    mul     A0, B3\n+    add     C3, r0\n+    mul     A1, B2\n+    add     C3, r0\n+    mul     A0, B2\n+    add     C2, r0\n+    adc     C3, r1\n+    clr     __zero_reg__\n+    ret\n+ENDF __muluhisi3\n+#endif /* L_muluhisi3 */\n+\n+/*******************************************************\n+    Multiplication  32 x 32\n+*******************************************************/\n+\n+#if defined (L_mulsi3)\n+;;; R25:R22 = R25:R22 * R21:R18\n+;;; (C3:C0) = C3:C0   * B3:B0\n+;;; Clobbers: R26, R27, __tmp_reg__\n+DEFUN __mulsi3\n+    movw    A0, C0\n+    push    C2\n+    push    C3\n+    XCALL   __muluhisi3\n+    pop     A1\n+    pop     A0\n+    ;; A1:A0 now contains the high word of A\n+    mul     A0, B0\n+    add     C2, r0\n+    adc     C3, r1\n+    mul     A0, B1\n+    add     C3, r0\n+    mul     A1, B0\n+    add     C3, r0\n+    clr     __zero_reg__\n+    ret\n+ENDF __mulsi3\n+#endif /* L_mulsi3 */\n+\n+#undef A0\n+#undef A1\n+\n+#undef B0\n+#undef B1\n+#undef B2\n+#undef B3\n+\n+#undef C0\n+#undef C1\n+#undef C2\n+#undef C3\n+\n+#endif /* __AVR_HAVE_MUL__ */\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \t\n+\f\n /*******************************************************\n        Division 8 / 8 => (result + remainder)\n *******************************************************/"}, {"sha": "98262d54f55e393881059bfe00b6832cbf38b9a6", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=296799ba06ab9ff273038e9b4dd93ca9ba65bf1c", "patch": "@@ -155,10 +155,34 @@\n        (ior (match_test \"register_operand (XEXP (op, 0), mode)\")\n             (match_test \"CONSTANT_ADDRESS_P (XEXP (op, 0))\"))))\n \n+;; For some insns we must ensure that no hard register is inserted\n+;; into their operands because the insns are split and the split\n+;; involves hard registers.  An example are divmod insn that are\n+;; split to insns that represent implicit library calls.\n+\n ;; True for register that is pseudo register.\n (define_predicate \"pseudo_register_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"!HARD_REGISTER_P (op)\")))\n+  (and (match_operand 0 \"register_operand\")\n+       (not (and (match_code \"reg\")\n+                 (match_test \"HARD_REGISTER_P (op)\")))))\n+\n+;; True for operand that is pseudo register or CONST_INT.\n+(define_predicate \"pseudo_register_or_const_int_operand\"\n+  (ior (match_operand 0 \"const_int_operand\")\n+       (match_operand 0 \"pseudo_register_operand\")))\n+\n+;; We keep combiner from inserting hard registers into the input of sign- and\n+;; zero-extends.  A hard register in the input operand is not wanted because\n+;; 32-bit multiply patterns clobber some hard registers and extends with a\n+;; hard register that overlaps these clobbers won't combine to a widening\n+;; multiplication.  There is no need for combine to propagate or insert\n+;; hard registers, register allocation can do it just as well.\n+\n+;; True for operand that is pseudo register at combine time.\n+(define_predicate \"combine_pseudo_register_operand\"\n+  (ior (match_operand 0 \"pseudo_register_operand\")\n+       (and (match_operand 0 \"register_operand\")\n+            (match_test \"reload_completed || reload_in_progress\"))))\n \n ;; Return true if OP is a constant integer that is either\n ;; 8 or 16 or 24.\n@@ -189,3 +213,18 @@\n (define_predicate \"register_or_s9_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"s9_operand\")))\n+\n+;; Unsigned CONST_INT that fits in 16 bits, i.e. 0..65536.\n+(define_predicate \"u16_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, (1<<16)-1)\")))\n+\n+;; Signed CONST_INT that fits in 16 bits, i.e. -32768..32767.\n+(define_predicate \"s16_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), -(1<<15), (1<<15)-1)\")))\n+\n+;; One-extended CONST_INT that fits in 16 bits, i.e. -65536..-1.\n+(define_predicate \"o16_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), -(1<<16), -1)\")))"}, {"sha": "d79dd5a47b6453273e9c0e049bcfb2a16cd428c1", "filename": "gcc/config/avr/t-avr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296799ba06ab9ff273038e9b4dd93ca9ba65bf1c/gcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-avr?ref=296799ba06ab9ff273038e9b4dd93ca9ba65bf1c", "patch": "@@ -41,7 +41,9 @@ LIB1ASMFUNCS = \\\n \t_mulhi3 \\\n \t_mulhisi3 \\\n \t_umulhisi3 \\\n-\t_xmulhisi3_exit \\\n+\t_usmulhisi3 \\\n+\t_muluhisi3 \\\n+\t_mulshisi3 \\\n \t_mulsi3 \\\n \t_udivmodqi4 \\\n \t_divmodqi4 \\"}]}