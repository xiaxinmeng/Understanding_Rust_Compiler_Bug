{"sha": "92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "node_id": "C_kwDOANBUbNoAKDkyYTVkZTNkZjJkYzk1OGQ2YjNkMThhMDQ2NjE4OWFkMzFmNWFlNzk", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-08-17T12:17:08Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-08-17T12:31:53Z"}, "message": "OpenMP/C++: Allow classes with static members to be mappable [PR104493]\n\nAs this is the last lang-specific user of the omp_mappable_type hook,\nthe hook is removed, keeping only a generic omp_mappable_type for\nincomplete types (or error_node).\n\n\tPR c++/104493\n\ngcc/c/ChangeLog:\n\n\t* c-decl.cc (c_decl_attributes, finish_decl): Call omp_mappable_type\n\tinstead of removed langhook.\n\t* c-typeck.cc (c_finish_omp_clauses): Likewise.\n\ngcc/cp/ChangeLog:\n\n\t* cp-objcp-common.h (LANG_HOOKS_OMP_MAPPABLE_TYPE): Remove.\n\t* cp-tree.h (cp_omp_mappable_type, cp_omp_emit_unmappable_type_notes):\n\tRemove.\n\t* decl2.cc (cp_omp_mappable_type_1, cp_omp_mappable_type,\n\tcp_omp_emit_unmappable_type_notes): Remove.\n\t(cplus_decl_attributes): Call omp_mappable_type instead of\n\tremoved langhook.\n\t* decl.cc (cp_finish_decl): Likewise; call cxx_incomplete_type_inform\n\tin lieu of cp_omp_emit_unmappable_type_notes.\n\t* semantics.cc (finish_omp_clauses): Likewise.\n\ngcc/ChangeLog:\n\n\t* gimplify.cc (omp_notice_variable): Call omp_mappable_type\n\tinstead of removed langhook.\n\t* omp-general.h (omp_mappable_type): New prototype.\n\t* omp-general.cc (omp_mappable_type):  New; moved from ...\n\t* langhooks.cc (lhd_omp_mappable_type): ... here.\n\t* langhooks-def.h (lhd_omp_mappable_type,\n\tLANG_HOOKS_OMP_MAPPABLE_TYPE): Remove.\n\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Remote the latter.\n\t* langhooks.h (struct lang_hooks_for_types): Remove\n\tomp_mappable_type.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/gomp/unmappable-1.C: Remove dg-error; remove dg-note no\n\tlonger shown as TYPE_MAIN_DECL is NULL.\n\t* c-c++-common/gomp/map-incomplete-type.c: New test.\n\nCo-authored-by: Chung-Lin Tang <cltang@codesourcery.com>", "tree": {"sha": "997b8dadc16fa5ffac4baa480b249d8505e775e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/997b8dadc16fa5ffac4baa480b249d8505e775e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06bca6950b154d7c85762acf1593d6792f8a2617", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bca6950b154d7c85762acf1593d6792f8a2617", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06bca6950b154d7c85762acf1593d6792f8a2617"}], "stats": {"total": 161, "additions": 61, "deletions": 100}, "files": [{"sha": "9e590c66dae7744d2858cd74eed2ea2d815751b0", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -5074,8 +5074,7 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n       && ((VAR_P (*node) && is_global_var (*node))\n \t  || TREE_CODE (*node) == FUNCTION_DECL))\n     {\n-      if (VAR_P (*node)\n-\t  && !lang_hooks.types.omp_mappable_type (TREE_TYPE (*node)))\n+      if (VAR_P (*node) && !omp_mappable_type (TREE_TYPE (*node)))\n \tattributes = tree_cons (get_identifier (\"omp declare target implicit\"),\n \t\t\t\tNULL_TREE, attributes);\n       else\n@@ -5701,7 +5700,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n       DECL_ATTRIBUTES (decl)\n \t= remove_attribute (\"omp declare target implicit\",\n \t\t\t    DECL_ATTRIBUTES (decl));\n-      if (!lang_hooks.types.omp_mappable_type (TREE_TYPE (decl)))\n+      if (!omp_mappable_type (TREE_TYPE (decl)))\n \terror (\"%q+D in declare target directive does not have mappable type\",\n \t       decl);\n       else if (!lookup_attribute (\"omp declare target\","}, {"sha": "de8780a1502d3a7083af50a0dbdcfa7d51c997a9", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -14955,7 +14955,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      else\n \t\t{\n \t\t  t = OMP_CLAUSE_DECL (c);\n-\t\t  if (!lang_hooks.types.omp_mappable_type (TREE_TYPE (t)))\n+\t\t  if (!omp_mappable_type (TREE_TYPE (t)))\n \t\t    {\n \t\t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\"array section does not have mappable type \"\n@@ -15092,7 +15092,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t\t  remove = true;\n \t\t}\n-\t      else if (!lang_hooks.types.omp_mappable_type (TREE_TYPE (t)))\n+\t      else if (!omp_mappable_type (TREE_TYPE (t)))\n \t\t{\n \t\t  error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t    \"%qE does not have a mappable type in %qs clause\",\n@@ -15173,7 +15173,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t || (OMP_CLAUSE_MAP_KIND (c)\n \t\t\t     == GOMP_MAP_FORCE_DEVICEPTR)))\n \t\t   && t == OMP_CLAUSE_DECL (c)\n-\t\t   && !lang_hooks.types.omp_mappable_type (TREE_TYPE (t)))\n+\t\t   && !omp_mappable_type (TREE_TYPE (t)))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qD does not have a mappable type in %qs clause\", t,\n@@ -15290,7 +15290,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\tcname);\n \t      remove = true;\n \t    }\n-\t  else if (!lang_hooks.types.omp_mappable_type (TREE_TYPE (t)))\n+\t  else if (!omp_mappable_type (TREE_TYPE (t)))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qD does not have a mappable type in %qs clause\", t,"}, {"sha": "1a67f14d9b38841ebcfcf307d196bcefa858ab3a", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -187,8 +187,6 @@ extern tree cxx_simulate_record_decl (location_t, const char *,\n #define LANG_HOOKS_OMP_FINISH_CLAUSE cxx_omp_finish_clause\n #undef LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE cxx_omp_privatize_by_reference\n-#undef LANG_HOOKS_OMP_MAPPABLE_TYPE\n-#define LANG_HOOKS_OMP_MAPPABLE_TYPE cp_omp_mappable_type\n #undef LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\n #define LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR cxx_omp_disregard_value_expr\n "}, {"sha": "cb23975484fad72f85b8a284a82b33fa25d50ea7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -6959,8 +6959,6 @@ extern bool possibly_inlined_p\t\t\t(tree);\n extern int parm_index                           (tree);\n extern tree vtv_start_verification_constructor_init_function (void);\n extern tree vtv_finish_verification_constructor_init_function (tree);\n-extern bool cp_omp_mappable_type\t\t(tree);\n-extern bool cp_omp_emit_unmappable_type_notes\t(tree);\n extern void cp_check_const_attributes (tree);\n \n /* in error.cc */"}, {"sha": "031be45e0be27b80c7dcdcc4b051fdb60a9d295d", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -8633,11 +8633,13 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t= remove_attribute (\"omp declare target implicit\",\n \t\t\t    DECL_ATTRIBUTES (decl));\n       complete_type (TREE_TYPE (decl));\n-      if (!cp_omp_mappable_type (TREE_TYPE (decl)))\n+      if (!omp_mappable_type (TREE_TYPE (decl)))\n \t{\n \t  error (\"%q+D in declare target directive does not have mappable\"\n \t\t \" type\", decl);\n-\t  cp_omp_emit_unmappable_type_notes (TREE_TYPE (decl));\n+\t  if (TREE_TYPE (decl) != error_mark_node\n+\t      && !COMPLETE_TYPE_P (TREE_TYPE (decl)))\n+\t    cxx_incomplete_type_inform (TREE_TYPE (decl));\n \t}\n       else if (!lookup_attribute (\"omp declare target\",\n \t\t\t\t  DECL_ATTRIBUTES (decl))"}, {"sha": "89ab2545d64f4b3079e4be11b3fb7e15bc977e0b", "filename": "gcc/cp/decl2.cc", "status": "modified", "additions": 2, "deletions": 57, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fcp%2Fdecl2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fcp%2Fdecl2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.cc?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-ada-spec.h\"\n #include \"asan.h\"\n #include \"optabs-query.h\"\n+#include \"omp-general.h\"\n \n /* Id for dumping the raw trees.  */\n int raw_dump_id;\n@@ -1578,62 +1579,6 @@ cp_check_const_attributes (tree attributes)\n     }\n }\n \n-/* Return true if TYPE is an OpenMP mappable type.\n-   If NOTES is non-zero, emit a note message for each problem.  */\n-static bool\n-cp_omp_mappable_type_1 (tree type, bool notes)\n-{\n-  bool result = true;\n-\n-  /* Mappable type has to be complete.  */\n-  if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n-    {\n-      if (notes && type != error_mark_node)\n-\t{\n-\t  tree decl = TYPE_MAIN_DECL (type);\n-\t  inform ((decl ? DECL_SOURCE_LOCATION (decl) : input_location),\n-\t\t  \"incomplete type %qT is not mappable\", type);\n-\t}\n-      result = false;\n-    }\n-  /* Arrays have mappable type if the elements have mappable type.  */\n-  while (TREE_CODE (type) == ARRAY_TYPE)\n-    type = TREE_TYPE (type);\n-  /* All data members must be non-static.  */\n-  if (CLASS_TYPE_P (type))\n-    {\n-      tree field;\n-      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n-\tif (VAR_P (field))\n-\t  {\n-\t    if (notes)\n-\t      inform (DECL_SOURCE_LOCATION (field),\n-\t\t      \"static field %qD is not mappable\", field);\n-\t    result = false;\n-\t  }\n-\t/* All fields must have mappable types.  */\n-\telse if (TREE_CODE (field) == FIELD_DECL\n-\t\t && !cp_omp_mappable_type_1 (TREE_TYPE (field), notes))\n-\t  result = false;\n-    }\n-  return result;\n-}\n-\n-/* Return true if TYPE is an OpenMP mappable type.  */\n-bool\n-cp_omp_mappable_type (tree type)\n-{\n-  return cp_omp_mappable_type_1 (type, false);\n-}\n-\n-/* Return true if TYPE is an OpenMP mappable type.\n-   Emit an error messages if not.  */\n-bool\n-cp_omp_emit_unmappable_type_notes (tree type)\n-{\n-  return cp_omp_mappable_type_1 (type, true);\n-}\n-\n /* Return the last pushed declaration for the symbol DECL or NULL\n    when no such declaration exists.  */\n \n@@ -1709,7 +1654,7 @@ cplus_decl_attributes (tree *decl, tree attributes, int flags)\n \t       *decl);\n       else if (VAR_P (*decl)\n \t       && (processing_template_decl\n-\t\t   || !cp_omp_mappable_type (TREE_TYPE (*decl))))\n+\t\t   || !omp_mappable_type (TREE_TYPE (*decl))))\n \tattributes = tree_cons (get_identifier (\"omp declare target implicit\"),\n \t\t\t\tNULL_TREE, attributes);\n       else"}, {"sha": "ae7c8ea7b1f466ac4bbf701a14e2a4bdedc50902", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -7992,13 +7992,15 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  t = OMP_CLAUSE_DECL (c);\n \t\t  if (TREE_CODE (t) != TREE_LIST\n \t\t      && !type_dependent_expression_p (t)\n-\t\t      && !cp_omp_mappable_type (TREE_TYPE (t)))\n+\t\t      && !omp_mappable_type (TREE_TYPE (t)))\n \t\t    {\n \t\t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\"array section does not have mappable type \"\n \t\t\t\t\"in %qs clause\",\n \t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n-\t\t      cp_omp_emit_unmappable_type_notes (TREE_TYPE (t));\n+\t\t      if (TREE_TYPE (t) != error_mark_node\n+\t\t\t  && !COMPLETE_TYPE_P (TREE_TYPE (t)))\n+\t\t\tcxx_incomplete_type_inform (TREE_TYPE (t));\n \t\t      remove = true;\n \t\t    }\n \t\t  while (TREE_CODE (t) == ARRAY_REF)\n@@ -8134,12 +8136,14 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t\t  remove = true;\n \t\t}\n-\t      else if (!cp_omp_mappable_type (TREE_TYPE (t)))\n+\t      else if (!omp_mappable_type (TREE_TYPE (t)))\n \t\t{\n \t\t  error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t    \"%qE does not have a mappable type in %qs clause\",\n \t\t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n-\t\t  cp_omp_emit_unmappable_type_notes (TREE_TYPE (t));\n+\t\t  if (TREE_TYPE (t) != error_mark_node\n+\t\t      && !COMPLETE_TYPE_P (TREE_TYPE (t)))\n+\t\t    cxx_incomplete_type_inform (TREE_TYPE (t));\n \t\t  remove = true;\n \t\t}\n \t      while (TREE_CODE (t) == COMPONENT_REF)\n@@ -8232,14 +8236,16 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t     == GOMP_MAP_FIRSTPRIVATE_POINTER)))\n \t\t   && t == OMP_CLAUSE_DECL (c)\n \t\t   && !type_dependent_expression_p (t)\n-\t\t   && !cp_omp_mappable_type (TYPE_REF_P (TREE_TYPE (t))\n-\t\t\t\t\t     ? TREE_TYPE (TREE_TYPE (t))\n-\t\t\t\t\t     : TREE_TYPE (t)))\n+\t\t   && !omp_mappable_type (TYPE_REF_P (TREE_TYPE (t))\n+\t\t\t\t\t  ? TREE_TYPE (TREE_TYPE (t))\n+\t\t\t\t\t  : TREE_TYPE (t)))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qD does not have a mappable type in %qs clause\", t,\n \t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n-\t      cp_omp_emit_unmappable_type_notes (TREE_TYPE (t));\n+\t      if (TREE_TYPE (t) != error_mark_node\n+\t\t  && !COMPLETE_TYPE_P (TREE_TYPE (t)))\n+\t\tcxx_incomplete_type_inform (TREE_TYPE (t));\n \t      remove = true;\n \t    }\n \t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n@@ -8409,12 +8415,14 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\tcname);\n \t      remove = true;\n \t    }\n-\t  else if (!cp_omp_mappable_type (TREE_TYPE (t)))\n+\t  else if (!omp_mappable_type (TREE_TYPE (t)))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qD does not have a mappable type in %qs clause\", t,\n \t\t\tcname);\n-\t      cp_omp_emit_unmappable_type_notes (TREE_TYPE (t));\n+\t      if (TREE_TYPE (t) != error_mark_node\n+\t\t  && !COMPLETE_TYPE_P (TREE_TYPE (t)))\n+\t\tcxx_incomplete_type_inform (TREE_TYPE (t));\n \t      remove = true;\n \t    }\n \t  if (remove)"}, {"sha": "f9e7060b2d8a9356d474193cb795305ace5ded72", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -7885,7 +7885,7 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n \t      if (gimplify_omp_ctxp->target_firstprivatize_array_bases\n \t\t  && omp_privatize_by_reference (decl))\n \t\ttype = TREE_TYPE (type);\n-\t      if (!lang_hooks.types.omp_mappable_type (type))\n+\t      if (!omp_mappable_type (type))\n \t\t{\n \t\t  error (\"%qD referenced in target region does not have \"\n \t\t\t \"a mappable type\", decl);"}, {"sha": "0f1bfbf255c97e494886303468e3857b16029dd2", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -88,7 +88,6 @@ extern tree lhd_omp_array_size (tree, gimple_seq *);\n struct gimplify_omp_ctx;\n extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n \t\t\t\t\t       tree);\n-extern bool lhd_omp_mappable_type (tree);\n extern bool lhd_omp_scalar_p (tree, bool);\n extern tree *lhd_omp_get_decl_init (tree);\n extern void lhd_omp_finish_decl_inits ();\n@@ -206,7 +205,6 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n #define LANG_HOOKS_TYPE_MAX_SIZE\tlhd_return_null_const_tree\n #define LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES \\\n   lhd_omp_firstprivatize_type_sizes\n-#define LANG_HOOKS_OMP_MAPPABLE_TYPE\tlhd_omp_mappable_type\n #define LANG_HOOKS_TYPE_HASH_EQ\t\tNULL\n #define LANG_HOOKS_COPY_LANG_QUALIFIERS NULL\n #define LANG_HOOKS_GET_ARRAY_DESCR_INFO\tNULL\n@@ -235,7 +233,6 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n   LANG_HOOKS_INCOMPLETE_TYPE_ERROR, \\\n   LANG_HOOKS_TYPE_MAX_SIZE, \\\n   LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES, \\\n-  LANG_HOOKS_OMP_MAPPABLE_TYPE, \\\n   LANG_HOOKS_TYPE_HASH_EQ, \\\n   LANG_HOOKS_COPY_LANG_QUALIFIERS, \\\n   LANG_HOOKS_GET_ARRAY_DESCR_INFO, \\"}, {"sha": "7d9756759900d6ad577d3fa14032a913450b9a33", "filename": "gcc/langhooks.cc", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Flanghooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Flanghooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.cc?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -686,17 +686,6 @@ lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *c ATTRIBUTE_UNUSED,\n {\n }\n \n-/* Return true if TYPE is an OpenMP mappable type.  */\n-\n-bool\n-lhd_omp_mappable_type (tree type)\n-{\n-  /* Mappable type has to be complete.  */\n-  if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n-    return false;\n-  return true;\n-}\n-\n /* Common function for add_builtin_function, add_builtin_function_ext_scope\n    and simulate_builtin_function_decl.  */\n "}, {"sha": "b1b2b0e10f097619790474f0fadd5052281538ab", "filename": "gcc/langhooks.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -128,9 +128,6 @@ struct lang_hooks_for_types\n      firstprivate variables.  */\n   void (*omp_firstprivatize_type_sizes) (struct gimplify_omp_ctx *, tree);\n \n-  /* Return true if TYPE is a mappable type.  */\n-  bool (*omp_mappable_type) (tree type);\n-\n   /* Return TRUE if TYPE1 and TYPE2 are identical for type hashing purposes.\n      Called only after doing all language independent checks.\n      At present, this function is only called when both TYPE1 and TYPE2 are"}, {"sha": "33792adc4de51abba81de23dd13d4092d1efc436", "filename": "gcc/omp-general.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fomp-general.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fomp-general.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.cc?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -80,6 +80,17 @@ omp_check_optional_argument (tree decl, bool for_present_check)\n   return lang_hooks.decls.omp_check_optional_argument (decl, for_present_check);\n }\n \n+/* Return true if TYPE is an OpenMP mappable type.  */\n+\n+bool\n+omp_mappable_type (tree type)\n+{\n+  /* Mappable type has to be complete.  */\n+  if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n+    return false;\n+  return true;\n+}\n+\n /* True if OpenMP should privatize what this DECL points to rather\n    than the DECL itself.  */\n "}, {"sha": "1b5455a0a8ff1c4f3d2861ca370bf0be936fc599", "filename": "gcc/omp-general.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -94,6 +94,7 @@ struct omp_for_data\n extern tree omp_find_clause (tree clauses, enum omp_clause_code kind);\n extern bool omp_is_allocatable_or_ptr (tree decl);\n extern tree omp_check_optional_argument (tree decl, bool for_present_check);\n+extern bool omp_mappable_type (tree type);\n extern bool omp_privatize_by_reference (tree decl);\n extern void omp_adjust_for_condition (location_t loc, enum tree_code *cond_code,\n \t\t\t\t      tree *n2, tree v, tree step);"}, {"sha": "29702defa6a6d78ac0391c510d71fa76c6b8f243", "filename": "gcc/testsuite/c-c++-common/gomp/map-incomplete-type.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-incomplete-type.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-incomplete-type.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-incomplete-type.c?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -0,0 +1,17 @@\n+struct incomplete_t;\n+/* { dg-note \"forward declaration of 'struct incomplete_t'\" \"\" { target c++ } .-1 } */\n+\n+/* Note: This note is only printed with C++ (trice); the loc is available due to TYPE_MAIN_DECL.  */\n+\n+struct incomplete_t *ptr;\n+int i;\n+\n+void\n+foo (void)\n+{\n+  #pragma omp target enter data map(to: i) map(to: ptr[0])\n+    /* All apply to the line above.  The first error is printed twice.  */\n+    /* { dg-error \"invalid use of undefined type 'struct incomplete_t'\" \"\" { target c } .-2 } */\n+    /* { dg-error \"invalid use of incomplete type 'struct incomplete_t'\" \"\" { target c++ } .-3 } */\n+    /* { dg-error \"array section does not have mappable type in 'map' clause\" \"\" { target *-*-* } .-4 } */\n+}"}, {"sha": "28ba184a57a5162caebf95631fa4ef5734bb6ca4", "filename": "gcc/testsuite/g++.dg/gomp/unmappable-1.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Funmappable-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a5de3df2dc958d6b3d18a0466189ad31f5ae79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Funmappable-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Funmappable-1.C?ref=92a5de3df2dc958d6b3d18a0466189ad31f5ae79", "patch": "@@ -4,7 +4,7 @@\n class C\n {\n public:\n-  static int static_member; /* { dg-message \"static field .C::static_member. is not mappable\" } */\n+  static int static_member;\n   virtual void f() {}\n };\n \n@@ -14,7 +14,6 @@ int\n main ()\n {\n #pragma omp target map(v) /* { dg-error \".v. does not have a mappable type in .map. clause\" } */\n-  /* { dg-message \"incomplete type .C \\\\\\[\\\\\\]. is not mappable\" \"\" { target *-*-* } .-1 } */\n   {\n   }\n }"}]}