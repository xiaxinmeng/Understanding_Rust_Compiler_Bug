{"sha": "46df282378908dff9219749cd4cd576c155b2971", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZkZjI4MjM3ODkwOGRmZjkyMTk3NDljZDRjZDU3NmMxNTViMjk3MQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2005-01-29T16:12:45Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-01-29T16:12:45Z"}, "message": "c-common.c (fix_string_type): Just use c_build_qualified_type to build string type.\n\n\t* c-common.c (fix_string_type): Just use c_build_qualified_type to\n\tbuild string type.\n\t(c_build_qualified_type): Build qualified array types with\n\tTYPE_MAIN_VARIANT pointing to corresponding unqualified type.\n\t* c-decl.c (c_make_fname_decl): Build unqualified array type\n\tbefore qualified type.\n\t(grokdeclarator): Use TYPE_MAIN_VARIANT of typedef type if element\n\ttype is qualified, not just if type itself is.  Don't apply\n\tqualifiers to array type when declarator is processed.  Apply\n\tqualifiers to field type whether or not it is an array type.\n\tDon't handle array types specially for applying qualifiers to\n\tvariables.\n\t* c-typeck.c (composite_type): Build unqualified element type and\n\tarray type when forming composite of array types.\n\t(common_pointer_type, comptypes, comp_target_types,\n\ttype_lists_compatible_p, build_indirect_ref, build_array_ref,\n\tconvert_for_assignment): Don't apply TYPE_MAIN_VARIANT to array\n\ttypes.\n\t(type_lists_compatible_p): Cache TREE_VALUE (args1) and TREE_VALUE\n\t(args2) in variables a1 and a2.\n\ntestsuite:\n\t* gcc.dg/Wwrite-strings-1.c, gcc.dg/array-quals-2.c,\n\tgcc.dg/lvalue-3.c: New tests.\n\t* gcc.dg/concat.c: Update expected messages.\n\nFrom-SVN: r94411", "tree": {"sha": "146eb63899ed165bd17ec164fc3ef99342b7f13b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/146eb63899ed165bd17ec164fc3ef99342b7f13b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46df282378908dff9219749cd4cd576c155b2971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46df282378908dff9219749cd4cd576c155b2971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46df282378908dff9219749cd4cd576c155b2971", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46df282378908dff9219749cd4cd576c155b2971/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24a09741e4e7ed510fc543cdf3136ebc6582db90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24a09741e4e7ed510fc543cdf3136ebc6582db90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24a09741e4e7ed510fc543cdf3136ebc6582db90"}], "stats": {"total": 268, "additions": 188, "deletions": 80}, "files": [{"sha": "3edb6156a3cae57edfe769715107ebae5b61a75e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46df282378908dff9219749cd4cd576c155b2971/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46df282378908dff9219749cd4cd576c155b2971/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46df282378908dff9219749cd4cd576c155b2971", "patch": "@@ -1,3 +1,26 @@\n+2005-01-29  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* c-common.c (fix_string_type): Just use c_build_qualified_type to\n+\tbuild string type.\n+\t(c_build_qualified_type): Build qualified array types with\n+\tTYPE_MAIN_VARIANT pointing to corresponding unqualified type.\n+\t* c-decl.c (c_make_fname_decl): Build unqualified array type\n+\tbefore qualified type.\n+\t(grokdeclarator): Use TYPE_MAIN_VARIANT of typedef type if element\n+\ttype is qualified, not just if type itself is.  Don't apply\n+\tqualifiers to array type when declarator is processed.  Apply\n+\tqualifiers to field type whether or not it is an array type.\n+\tDon't handle array types specially for applying qualifiers to\n+\tvariables.\n+\t* c-typeck.c (composite_type): Build unqualified element type and\n+\tarray type when forming composite of array types.\n+\t(common_pointer_type, comptypes, comp_target_types,\n+\ttype_lists_compatible_p, build_indirect_ref, build_array_ref,\n+\tconvert_for_assignment): Don't apply TYPE_MAIN_VARIANT to array\n+\ttypes.\n+\t(type_lists_compatible_p): Cache TREE_VALUE (args1) and TREE_VALUE\n+\t(args2) in variables a1 and a2.\n+\n 2005-01-29  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cse.c (n_elements_made, max_elements_made): Remove."}, {"sha": "72fd8466df78a047ed9b14c5b1e56e8d6e22b388", "filename": "gcc/c-common.c", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46df282378908dff9219749cd4cd576c155b2971/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46df282378908dff9219749cd4cd576c155b2971/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=46df282378908dff9219749cd4cd576c155b2971", "patch": "@@ -862,12 +862,7 @@ fix_string_type (tree value)\n   i_type = build_index_type (build_int_cst (NULL_TREE, nchars - 1));\n   a_type = build_array_type (e_type, i_type);\n   if (flag_const_strings)\n-    {\n-      /* bleah, c_build_qualified_type should set TYPE_MAIN_VARIANT.  */\n-      tree qa_type = c_build_qualified_type (a_type, TYPE_QUAL_CONST);\n-      TYPE_MAIN_VARIANT (qa_type) = a_type;\n-      a_type = qa_type;\n-    }\n+    a_type = c_build_qualified_type (a_type, TYPE_QUAL_CONST);\n \n   TREE_TYPE (value) = a_type;\n   TREE_CONSTANT (value) = 1;\n@@ -2483,9 +2478,28 @@ c_build_qualified_type (tree type, int type_quals)\n     return type;\n \n   if (TREE_CODE (type) == ARRAY_TYPE)\n-    return build_array_type (c_build_qualified_type (TREE_TYPE (type),\n-\t\t\t\t\t\t     type_quals),\n-\t\t\t     TYPE_DOMAIN (type));\n+    {\n+      tree t;\n+      tree element_type = c_build_qualified_type (TREE_TYPE (type),\n+\t\t\t\t\t\t  type_quals);\n+\n+      /* See if we already have an identically qualified type.  */\n+      for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n+\t{\n+\t  if (TYPE_QUALS (strip_array_types (t)) == type_quals\n+\t      && TYPE_NAME (t) == TYPE_NAME (type)\n+\t      && TYPE_CONTEXT (t) == TYPE_CONTEXT (type)\n+\t      && attribute_list_equal (TYPE_ATTRIBUTES (t),\n+\t\t\t\t       TYPE_ATTRIBUTES (type)))\n+\t    break;\n+\t}\n+      if (!t)\n+\t{\n+\t  t = build_variant_type_copy (type);\n+\t  TREE_TYPE (t) = element_type;\n+\t}\n+      return t;\n+    }\n \n   /* A restrict-qualified pointer type must be a pointer to object or\n      incomplete type.  Note that the use of POINTER_TYPE_P also allows"}, {"sha": "efb17e89f827e92338700fb24fe03b5d45ce0ee7", "filename": "gcc/c-decl.c", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46df282378908dff9219749cd4cd576c155b2971/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46df282378908dff9219749cd4cd576c155b2971/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=46df282378908dff9219749cd4cd576c155b2971", "patch": "@@ -2632,9 +2632,9 @@ c_make_fname_decl (tree id, int type_dep)\n   tree decl, type, init;\n   size_t length = strlen (name);\n \n-  type =  build_array_type\n-          (build_qualified_type (char_type_node, TYPE_QUAL_CONST),\n-\t   build_index_type (size_int (length)));\n+  type = build_array_type (char_type_node,\n+\t\t\t   build_index_type (size_int (length)));\n+  type = c_build_qualified_type (type, TYPE_QUAL_CONST);\n \n   decl = build_decl (VAR_DECL, id, type);\n \n@@ -3861,7 +3861,7 @@ grokdeclarator (const struct c_declarator *declarator,\n       if (volatilep > 1)\n \tpedwarn (\"duplicate %<volatile%>\");\n     }\n-  if (!flag_gen_aux_info && (TYPE_QUALS (type)))\n+  if (!flag_gen_aux_info && (TYPE_QUALS (element_type)))\n     type = TYPE_MAIN_VARIANT (type);\n   type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n \t\t| (restrictp ? TYPE_QUAL_RESTRICT : 0)\n@@ -3946,7 +3946,13 @@ grokdeclarator (const struct c_declarator *declarator,\n \n   /* Now figure out the structure of the declarator proper.\n      Descend through it, creating more complex types, until we reach\n-     the declared identifier (or NULL_TREE, in an absolute declarator).  */\n+     the declared identifier (or NULL_TREE, in an absolute declarator).\n+     At each stage we maintain an unqualified version of the type\n+     together with any qualifiers that should be applied to it with\n+     c_build_qualified_type; this way, array types including\n+     multidimensional array types are first built up in unqualified\n+     form and then the qualified form is created with\n+     TYPE_MAIN_VARIANT pointing to the unqualified form.  */\n \n   while (declarator && declarator->kind != cdk_id)\n     {\n@@ -4146,13 +4152,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    if (pedantic && !COMPLETE_TYPE_P (type))\n \t      pedwarn (\"array type has incomplete element type\");\n \n-\t    /* Build the array type itself, then merge any constancy\n-\t       or volatility into the target type.  We must do it in\n-\t       this order to ensure that the TYPE_MAIN_VARIANT field\n-\t       of the array type is set correctly.  */\n \t    type = build_array_type (type, itype);\n-\t    if (type_quals)\n-\t      type = c_build_qualified_type (type, type_quals);\n \n \t    if (size_varies)\n \t      C_TYPE_VARIABLE_SIZE (type) = 1;\n@@ -4278,7 +4278,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t}\n     }\n \n-  /* Now TYPE has the actual type.  */\n+  /* Now TYPE has the actual type, apart from any qualifiers in\n+     TYPE_QUALS.  */\n \n   /* Check the type and width of a bit-field.  */\n   if (bitfield)\n@@ -4447,11 +4448,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    error (\"field %qs has incomplete type\", name);\n \t    type = error_mark_node;\n \t  }\n-\t/* Move type qualifiers down to element of an array.  */\n-\tif (TREE_CODE (type) == ARRAY_TYPE && type_quals)\n-\t  type = build_array_type (c_build_qualified_type (TREE_TYPE (type),\n-\t\t\t\t\t\t\t   type_quals),\n-\t\t\t\t   TYPE_DOMAIN (type));\n+\ttype = c_build_qualified_type (type, type_quals);\n \tdecl = build_decl (FIELD_DECL, declarator->u.id, type);\n \tDECL_NONADDRESSABLE_P (decl) = bitfield;\n \n@@ -4556,17 +4553,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t/* An uninitialized decl with `extern' is a reference.  */\n \tint extern_ref = !initialized && storage_class == csc_extern;\n \n-\t/* Move type qualifiers down to element of an array.  */\n-\tif (TREE_CODE (type) == ARRAY_TYPE && type_quals)\n-\t  {\n-\t    int saved_align = TYPE_ALIGN(type);\n-\t    type = build_array_type (c_build_qualified_type (TREE_TYPE (type),\n-\t\t\t\t\t\t\t     type_quals),\n-\t\t\t\t     TYPE_DOMAIN (type));\n-\t    TYPE_ALIGN (type) = saved_align;\n-\t  }\n-\telse if (type_quals)\n-\t  type = c_build_qualified_type (type, type_quals);\n+\ttype = c_build_qualified_type (type, type_quals);\n \n \t/* C99 6.2.2p7: It is invalid (compile-time undefined\n \t   behavior) to create an 'extern' declaration for a"}, {"sha": "fed17f2484532d86b5f5ec27f6c97d6c6be9bcf2", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 83, "deletions": 41, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46df282378908dff9219749cd4cd576c155b2971/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46df282378908dff9219749cd4cd576c155b2971/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=46df282378908dff9219749cd4cd576c155b2971", "patch": "@@ -277,7 +277,9 @@ composite_type (tree t1, tree t2)\n     case ARRAY_TYPE:\n       {\n \ttree elt = composite_type (TREE_TYPE (t1), TREE_TYPE (t2));\n-\t\n+\tint quals;\n+\ttree unqual_elt;\n+\n \t/* We should not have any type quals on arrays at all.  */\n \tgcc_assert (!TYPE_QUALS (t1) && !TYPE_QUALS (t2));\n \t\n@@ -292,8 +294,16 @@ composite_type (tree t1, tree t2)\n \tif (elt == TREE_TYPE (t2) && !TYPE_DOMAIN (t2) && !TYPE_DOMAIN (t1))\n \t  return build_type_attribute_variant (t2, attributes);\n \t\n-\t/* Merge the element types, and have a size if either arg has one.  */\n-\tt1 = build_array_type (elt, TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n+\t/* Merge the element types, and have a size if either arg has\n+\t   one.  We may have qualifiers on the element types.  To set\n+\t   up TYPE_MAIN_VARIANT correctly, we need to form the\n+\t   composite of the unqualified types and add the qualifiers\n+\t   back at the end.  */\n+\tquals = TYPE_QUALS (strip_array_types (elt));\n+\tunqual_elt = c_build_qualified_type (elt, TYPE_UNQUALIFIED);\n+\tt1 = build_array_type (unqual_elt,\n+\t\t\t       TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n+\tt1 = c_build_qualified_type (t1, quals);\n \treturn build_type_attribute_variant (t1, attributes);\n       }\n \n@@ -415,8 +425,8 @@ static tree\n common_pointer_type (tree t1, tree t2)\n {\n   tree attributes;\n-  tree pointed_to_1;\n-  tree pointed_to_2;\n+  tree pointed_to_1, mv1;\n+  tree pointed_to_2, mv2;\n   tree target;\n \n   /* Save time if the two types are the same.  */\n@@ -436,11 +446,15 @@ common_pointer_type (tree t1, tree t2)\n   attributes = targetm.merge_type_attributes (t1, t2);\n \n   /* Find the composite type of the target types, and combine the\n-     qualifiers of the two types' targets.  */\n-  pointed_to_1 = TREE_TYPE (t1);\n-  pointed_to_2 = TREE_TYPE (t2);\n-  target = composite_type (TYPE_MAIN_VARIANT (pointed_to_1),\n-\t\t\t   TYPE_MAIN_VARIANT (pointed_to_2));\n+     qualifiers of the two types' targets.  Do not lose qualifiers on\n+     array element types by taking the TYPE_MAIN_VARIANT.  */\n+  mv1 = pointed_to_1 = TREE_TYPE (t1);\n+  mv2 = pointed_to_2 = TREE_TYPE (t2);\n+  if (TREE_CODE (mv1) != ARRAY_TYPE)\n+    mv1 = TYPE_MAIN_VARIANT (pointed_to_1);\n+  if (TREE_CODE (mv2) != ARRAY_TYPE)\n+    mv2 = TYPE_MAIN_VARIANT (pointed_to_2);\n+  target = composite_type (mv1, mv2);\n   t1 = build_pointer_type (c_build_qualified_type\n \t\t\t   (target,\n \t\t\t    TYPE_QUALS (pointed_to_1) |\n@@ -632,7 +646,8 @@ comptypes (tree type1, tree type2)\n      definition.  Note that we already checked for equality of the type\n      qualifiers (just above).  */\n \n-  if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n+  if (TREE_CODE (t1) != ARRAY_TYPE\n+      && TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n     return 1;\n \n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n@@ -734,13 +749,21 @@ static int\n comp_target_types (tree ttl, tree ttr, int reflexive)\n {\n   int val;\n+  tree mvl, mvr;\n \n   /* Give objc_comptypes a crack at letting these types through.  */\n   if ((val = objc_comptypes (ttl, ttr, reflexive)) >= 0)\n     return val;\n \n-  val = comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (ttl)),\n-\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (ttr)));\n+  /* Do not lose qualifiers on element types of array types that are\n+     pointer targets by taking their TYPE_MAIN_VARIANT.  */\n+  mvl = TREE_TYPE (ttl);\n+  mvr = TREE_TYPE (ttr);\n+  if (TREE_CODE (mvl) != ARRAY_TYPE)\n+    mvl = TYPE_MAIN_VARIANT (mvl);\n+  if (TREE_CODE (mvr) != ARRAY_TYPE)\n+    mvr = TYPE_MAIN_VARIANT (mvr);\n+  val = comptypes (mvl, mvr);\n \n   if (val == 2 && pedantic)\n     pedwarn (\"types are not quite compatible\");\n@@ -1042,61 +1065,67 @@ type_lists_compatible_p (tree args1, tree args2)\n \n   while (1)\n     {\n+      tree a1, mv1, a2, mv2;\n       if (args1 == 0 && args2 == 0)\n \treturn val;\n       /* If one list is shorter than the other,\n \t they fail to match.  */\n       if (args1 == 0 || args2 == 0)\n \treturn 0;\n+      mv1 = a1 = TREE_VALUE (args1);\n+      mv2 = a2 = TREE_VALUE (args2);\n+      if (mv1 && mv1 != error_mark_node && TREE_CODE (mv1) != ARRAY_TYPE)\n+\tmv1 = TYPE_MAIN_VARIANT (mv1);\n+      if (mv2 && mv2 != error_mark_node && TREE_CODE (mv2) != ARRAY_TYPE)\n+\tmv2 = TYPE_MAIN_VARIANT (mv2);\n       /* A null pointer instead of a type\n \t means there is supposed to be an argument\n \t but nothing is specified about what type it has.\n \t So match anything that self-promotes.  */\n-      if (TREE_VALUE (args1) == 0)\n+      if (a1 == 0)\n \t{\n-\t  if (c_type_promotes_to (TREE_VALUE (args2)) != TREE_VALUE (args2))\n+\t  if (c_type_promotes_to (a2) != a2)\n \t    return 0;\n \t}\n-      else if (TREE_VALUE (args2) == 0)\n+      else if (a2 == 0)\n \t{\n-\t  if (c_type_promotes_to (TREE_VALUE (args1)) != TREE_VALUE (args1))\n+\t  if (c_type_promotes_to (a1) != a1)\n \t    return 0;\n \t}\n       /* If one of the lists has an error marker, ignore this arg.  */\n-      else if (TREE_CODE (TREE_VALUE (args1)) == ERROR_MARK\n-\t       || TREE_CODE (TREE_VALUE (args2)) == ERROR_MARK)\n+      else if (TREE_CODE (a1) == ERROR_MARK\n+\t       || TREE_CODE (a2) == ERROR_MARK)\n \t;\n-      else if (!(newval = comptypes (TYPE_MAIN_VARIANT (TREE_VALUE (args1)),\n-\t\t\t\t     TYPE_MAIN_VARIANT (TREE_VALUE (args2)))))\n+      else if (!(newval = comptypes (mv1, mv2)))\n \t{\n \t  /* Allow  wait (union {union wait *u; int *i} *)\n \t     and  wait (union wait *)  to be compatible.  */\n-\t  if (TREE_CODE (TREE_VALUE (args1)) == UNION_TYPE\n-\t      && (TYPE_NAME (TREE_VALUE (args1)) == 0\n-\t\t  || TYPE_TRANSPARENT_UNION (TREE_VALUE (args1)))\n-\t      && TREE_CODE (TYPE_SIZE (TREE_VALUE (args1))) == INTEGER_CST\n-\t      && tree_int_cst_equal (TYPE_SIZE (TREE_VALUE (args1)),\n-\t\t\t\t     TYPE_SIZE (TREE_VALUE (args2))))\n+\t  if (TREE_CODE (a1) == UNION_TYPE\n+\t      && (TYPE_NAME (a1) == 0\n+\t\t  || TYPE_TRANSPARENT_UNION (a1))\n+\t      && TREE_CODE (TYPE_SIZE (a1)) == INTEGER_CST\n+\t      && tree_int_cst_equal (TYPE_SIZE (a1),\n+\t\t\t\t     TYPE_SIZE (a2)))\n \t    {\n \t      tree memb;\n-\t      for (memb = TYPE_FIELDS (TREE_VALUE (args1));\n+\t      for (memb = TYPE_FIELDS (a1);\n \t\t   memb; memb = TREE_CHAIN (memb))\n-\t\tif (comptypes (TREE_TYPE (memb), TREE_VALUE (args2)))\n+\t\tif (comptypes (TREE_TYPE (memb), a2))\n \t\t  break;\n \t      if (memb == 0)\n \t\treturn 0;\n \t    }\n-\t  else if (TREE_CODE (TREE_VALUE (args2)) == UNION_TYPE\n-\t\t   && (TYPE_NAME (TREE_VALUE (args2)) == 0\n-\t\t       || TYPE_TRANSPARENT_UNION (TREE_VALUE (args2)))\n-\t\t   && TREE_CODE (TYPE_SIZE (TREE_VALUE (args2))) == INTEGER_CST\n-\t\t   && tree_int_cst_equal (TYPE_SIZE (TREE_VALUE (args2)),\n-\t\t\t\t\t  TYPE_SIZE (TREE_VALUE (args1))))\n+\t  else if (TREE_CODE (a2) == UNION_TYPE\n+\t\t   && (TYPE_NAME (a2) == 0\n+\t\t       || TYPE_TRANSPARENT_UNION (a2))\n+\t\t   && TREE_CODE (TYPE_SIZE (a2)) == INTEGER_CST\n+\t\t   && tree_int_cst_equal (TYPE_SIZE (a2),\n+\t\t\t\t\t  TYPE_SIZE (a1)))\n \t    {\n \t      tree memb;\n-\t      for (memb = TYPE_FIELDS (TREE_VALUE (args2));\n+\t      for (memb = TYPE_FIELDS (a2);\n \t\t   memb; memb = TREE_CHAIN (memb))\n-\t\tif (comptypes (TREE_TYPE (memb), TREE_VALUE (args1)))\n+\t\tif (comptypes (TREE_TYPE (memb), a1))\n \t\t  break;\n \t      if (memb == 0)\n \t\treturn 0;\n@@ -1542,7 +1571,12 @@ build_indirect_ref (tree ptr, const char *errorstring)\n       else\n \t{\n \t  tree t = TREE_TYPE (type);\n-\t  tree ref = build1 (INDIRECT_REF, TYPE_MAIN_VARIANT (t), pointer);\n+\t  tree mvt = t;\n+\t  tree ref;\n+\n+\t  if (TREE_CODE (mvt) != ARRAY_TYPE)\n+\t    mvt = TYPE_MAIN_VARIANT (mvt);\n+\t  ref = build1 (INDIRECT_REF, mvt, pointer);\n \n \t  if (!COMPLETE_OR_VOID_TYPE_P (t) && TREE_CODE (t) != ARRAY_TYPE)\n \t    {\n@@ -1670,7 +1704,9 @@ build_array_ref (tree array, tree index)\n \t    pedwarn (\"ISO C90 forbids subscripting non-lvalue array\");\n \t}\n \n-      type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (array)));\n+      type = TREE_TYPE (TREE_TYPE (array));\n+      if (TREE_CODE (type) != ARRAY_TYPE)\n+\ttype = TYPE_MAIN_VARIANT (type);\n       rval = build4 (ARRAY_REF, type, array, index, NULL_TREE, NULL_TREE);\n       /* Array ref is const/volatile if the array elements are\n          or if the array is.  */\n@@ -3597,9 +3633,15 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n     {\n       tree ttl = TREE_TYPE (type);\n       tree ttr = TREE_TYPE (rhstype);\n+      tree mvl = ttl;\n+      tree mvr = ttr;\n       bool is_opaque_pointer;\n       int target_cmp = 0;   /* Cache comp_target_types () result.  */\n \n+      if (TREE_CODE (mvl) != ARRAY_TYPE)\n+\tmvl = TYPE_MAIN_VARIANT (mvl);\n+      if (TREE_CODE (mvr) != ARRAY_TYPE)\n+\tmvr = TYPE_MAIN_VARIANT (mvr);\n       /* Opaque pointers are treated like void pointers.  */\n       is_opaque_pointer = (targetm.vector_opaque_p (type)\n                            || targetm.vector_opaque_p (rhstype))\n@@ -3612,8 +3654,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n       if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n \t  || (target_cmp = comp_target_types (type, rhstype, 0))\n \t  || is_opaque_pointer\n-\t  || (c_common_unsigned_type (TYPE_MAIN_VARIANT (ttl))\n-\t      == c_common_unsigned_type (TYPE_MAIN_VARIANT (ttr))))\n+\t  || (c_common_unsigned_type (mvl)\n+\t      == c_common_unsigned_type (mvr)))\n \t{\n \t  if (pedantic\n \t      && ((VOID_TYPE_P (ttl) && TREE_CODE (ttr) == FUNCTION_TYPE)"}, {"sha": "e7ff37eeada2823e27dc00765b38d1950768b662", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46df282378908dff9219749cd4cd576c155b2971/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46df282378908dff9219749cd4cd576c155b2971/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46df282378908dff9219749cd4cd576c155b2971", "patch": "@@ -1,3 +1,9 @@\n+2005-01-29  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/Wwrite-strings-1.c, gcc.dg/array-quals-2.c,\n+\tgcc.dg/lvalue-3.c: New tests.\n+\t* gcc.dg/concat.c: Update expected messages.\n+\n 2005-01-29  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR libfortran/19595"}, {"sha": "9270e8f871269132d75ca0abd973ffbf0f5477eb", "filename": "gcc/testsuite/gcc.dg/Wwrite-strings-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46df282378908dff9219749cd4cd576c155b2971/gcc%2Ftestsuite%2Fgcc.dg%2FWwrite-strings-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46df282378908dff9219749cd4cd576c155b2971/gcc%2Ftestsuite%2Fgcc.dg%2FWwrite-strings-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWwrite-strings-1.c?ref=46df282378908dff9219749cd4cd576c155b2971", "patch": "@@ -0,0 +1,8 @@\n+/* Test pointer initialization and dereference don't lose qualifiers\n+   on array types.  This test wrongly failed to diagnose the loss of\n+   const.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wwrite-strings\" } */\n+typedef char T[1];\n+T *p = &\"\"; /* { dg-warning \"warning: initialization from incompatible pointer type\" } */"}, {"sha": "5d20244b3447fde9eb2800d15094cf8045ba9df0", "filename": "gcc/testsuite/gcc.dg/array-quals-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46df282378908dff9219749cd4cd576c155b2971/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46df282378908dff9219749cd4cd576c155b2971/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-2.c?ref=46df282378908dff9219749cd4cd576c155b2971", "patch": "@@ -0,0 +1,14 @@\n+/* Test that pointers to arrays of differently qualified types aren't\n+   permitted in conditional expressions, and that qualifiers aren't\n+   lost in forming composite types.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+typedef const char T[1];\n+typedef const char T2[1];\n+typedef volatile char U[1];\n+T *p;\n+T2 *p2;\n+U *q;\n+void *f(void) { return 1 ? p : q; } /* { dg-warning \"warning: pointer type mismatch in conditional expression\" } */\n+T *g(void) { return 1 ? p : p2; }"}, {"sha": "0b9d6f6a7c4d4d275fd8d96db71f9cb04626d34c", "filename": "gcc/testsuite/gcc.dg/concat.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46df282378908dff9219749cd4cd576c155b2971/gcc%2Ftestsuite%2Fgcc.dg%2Fconcat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46df282378908dff9219749cd4cd576c155b2971/gcc%2Ftestsuite%2Fgcc.dg%2Fconcat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fconcat.c?ref=46df282378908dff9219749cd4cd576c155b2971", "patch": "@@ -8,8 +8,8 @@\n \n void foo ()\n {\n-  char s1[] = __FUNCTION__\".\";\t     /* { dg-error \"(parse|syntax|expected|invalid)\" } */\n-  char s2[] = __PRETTY_FUNCTION__\".\";/* { dg-error \"(parse|syntax|expected|invalid)\" } */\n+  char s1[] = __FUNCTION__\".\";\t     /* { dg-error \"(parse|syntax|expected|invalid|array)\" } */\n+  char s2[] = __PRETTY_FUNCTION__\".\";/* { dg-error \"(parse|syntax|expected|invalid|array)\" } */\n   char s3[] = \".\"__FUNCTION__;\t     /* { dg-error \"(parse|syntax|expected|invalid)\" } */\n   char s4[] = \".\"__PRETTY_FUNCTION__;/* { dg-error \"(parse|syntax|expected|invalid)\" } */\n   char s5[] = \".\"\".\";                /* No error.  */"}, {"sha": "0745c7ec7e522e9c253fe642d7dc9ef300f27610", "filename": "gcc/testsuite/gcc.dg/lvalue-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46df282378908dff9219749cd4cd576c155b2971/gcc%2Ftestsuite%2Fgcc.dg%2Flvalue-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46df282378908dff9219749cd4cd576c155b2971/gcc%2Ftestsuite%2Fgcc.dg%2Flvalue-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flvalue-3.c?ref=46df282378908dff9219749cd4cd576c155b2971", "patch": "@@ -0,0 +1,14 @@\n+/* Test that assignment of a read-only variable that gets const-ness\n+   from a read-only field is diagnosed.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+struct s { const int a; } x;\n+typeof (x.a) b;\n+void\n+f (void)\n+{\n+  x.a = 1; /* { dg-error \"error: assignment of read-only member 'a'\" } */\n+  b = 1; /* { dg-error \"error: assignment of read-only variable 'b'\" } */\n+}"}]}