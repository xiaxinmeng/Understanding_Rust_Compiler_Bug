{"sha": "1bde3acee77c171117dfb988998daa8197c73b34", "node_id": "C_kwDOANBUbNoAKDFiZGUzYWNlZTc3YzE3MTExN2RmYjk4ODk5OGRhYTgxOTdjNzNiMzQ", "commit": {"author": {"name": "Andrew Jenner", "email": "andrew@codesourcery.com", "date": "2023-03-22T11:12:49Z"}, "committer": {"name": "Andrew Jenner", "email": "andrew@codesourcery.com", "date": "2023-03-22T11:12:49Z"}, "message": "amdgcn: Add instruction patterns for complex number operations.\n\ngcc/ChangeLog:\n\n\t* config/gcn/gcn-protos.h (gcn_expand_dpp_swap_pairs_insn)\n\t(gcn_expand_dpp_distribute_even_insn)\n\t(gcn_expand_dpp_distribute_odd_insn): Declare.\n\t* config/gcn/gcn-valu.md (@dpp_swap_pairs<mode>)\n\t(@dpp_distribute_even<mode>, @dpp_distribute_odd<mode>)\n\t(cmul<conj_op><mode>3, cml<addsub_as><mode>4, vec_addsub<mode>3)\n\t(cadd<rot><mode>3, vec_fmaddsub<mode>4, vec_fmsubadd<mode>4)\n\t(fms<mode>4<exec>, fms<mode>4_negop2<exec>, fms<mode>4)\n\t(fms<mode>4_negop2): New patterns.\n\t* config/gcn/gcn.cc (gcn_expand_dpp_swap_pairs_insn)\n\t(gcn_expand_dpp_distribute_even_insn)\n\t(gcn_expand_dpp_distribute_odd_insn): New functions.\n\t* config/gcn/gcn.md: Add entries to unspec enum.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/gcn/complex.c: New test.", "tree": {"sha": "a5762371cdfc5fa0105b3e373a873a8ea9afe119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5762371cdfc5fa0105b3e373a873a8ea9afe119"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bde3acee77c171117dfb988998daa8197c73b34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bde3acee77c171117dfb988998daa8197c73b34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bde3acee77c171117dfb988998daa8197c73b34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bde3acee77c171117dfb988998daa8197c73b34/comments", "author": {"login": "andrewjenner", "id": 35463391, "node_id": "MDQ6VXNlcjM1NDYzMzkx", "avatar_url": "https://avatars.githubusercontent.com/u/35463391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewjenner", "html_url": "https://github.com/andrewjenner", "followers_url": "https://api.github.com/users/andrewjenner/followers", "following_url": "https://api.github.com/users/andrewjenner/following{/other_user}", "gists_url": "https://api.github.com/users/andrewjenner/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewjenner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewjenner/subscriptions", "organizations_url": "https://api.github.com/users/andrewjenner/orgs", "repos_url": "https://api.github.com/users/andrewjenner/repos", "events_url": "https://api.github.com/users/andrewjenner/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewjenner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "andrewjenner", "id": 35463391, "node_id": "MDQ6VXNlcjM1NDYzMzkx", "avatar_url": "https://avatars.githubusercontent.com/u/35463391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewjenner", "html_url": "https://github.com/andrewjenner", "followers_url": "https://api.github.com/users/andrewjenner/followers", "following_url": "https://api.github.com/users/andrewjenner/following{/other_user}", "gists_url": "https://api.github.com/users/andrewjenner/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewjenner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewjenner/subscriptions", "organizations_url": "https://api.github.com/users/andrewjenner/orgs", "repos_url": "https://api.github.com/users/andrewjenner/repos", "events_url": "https://api.github.com/users/andrewjenner/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewjenner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb800d4f2f2b6790d337146013ac30bff8c56592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb800d4f2f2b6790d337146013ac30bff8c56592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb800d4f2f2b6790d337146013ac30bff8c56592"}], "stats": {"total": 975, "additions": 975, "deletions": 0}, "files": [{"sha": "d7862b21a2a43ac5f68c1975d9a9bd9eee885741", "filename": "gcc/config/gcn/gcn-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bde3acee77c171117dfb988998daa8197c73b34/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bde3acee77c171117dfb988998daa8197c73b34/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h?ref=1bde3acee77c171117dfb988998daa8197c73b34", "patch": "@@ -27,6 +27,11 @@ extern unsigned int gcn_dwarf_register_number (unsigned int regno);\n extern rtx get_exec (int64_t);\n extern rtx get_exec (machine_mode mode);\n extern char * gcn_expand_dpp_shr_insn (machine_mode, const char *, int, int);\n+extern char * gcn_expand_dpp_swap_pairs_insn (machine_mode, const char *, int);\n+extern char * gcn_expand_dpp_distribute_even_insn (machine_mode, const char *,\n+\t\t\t\t\t\t   int unspec);\n+extern char * gcn_expand_dpp_distribute_odd_insn (machine_mode, const char *,\n+\t\t\t\t\t\t  int unspec);\n extern void gcn_expand_epilogue ();\n extern rtx gcn_expand_scaled_offsets (addr_space_t as, rtx base, rtx offsets,\n \t\t\t\t      rtx scale, bool unsigned_p, rtx exec);"}, {"sha": "787d7709d0d536c919331eb62204d238b6f9160a", "filename": "gcc/config/gcn/gcn-valu.md", "status": "modified", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bde3acee77c171117dfb988998daa8197c73b34/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bde3acee77c171117dfb988998daa8197c73b34/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md?ref=1bde3acee77c171117dfb988998daa8197c73b34", "patch": "@@ -1224,6 +1224,45 @@\n   [(set_attr \"type\" \"vop_dpp\")\n    (set_attr \"length\" \"16\")])\n \n+(define_insn \"@dpp_swap_pairs<mode>\"\n+  [(set (match_operand:V_noHI 0 \"register_operand\"    \"=v\")\n+\t(unspec:V_noHI\n+\t  [(match_operand:V_noHI 1 \"register_operand\" \" v\")]\n+\t  UNSPEC_MOV_DPP_SWAP_PAIRS))]\n+  \"\"\n+  {\n+    return gcn_expand_dpp_swap_pairs_insn (<MODE>mode, \"v_mov_b32\",\n+\t                                   UNSPEC_MOV_DPP_SWAP_PAIRS);\n+  }\n+  [(set_attr \"type\" \"vop_dpp\")\n+   (set_attr \"length\" \"16\")])\n+\n+(define_insn \"@dpp_distribute_even<mode>\"\n+  [(set (match_operand:V_noHI 0 \"register_operand\"    \"=v\")\n+\t(unspec:V_noHI\n+\t  [(match_operand:V_noHI 1 \"register_operand\" \" v\")]\n+\t  UNSPEC_MOV_DPP_DISTRIBUTE_EVEN))]\n+  \"\"\n+  {\n+    return gcn_expand_dpp_distribute_even_insn (<MODE>mode, \"v_mov_b32\",\n+\t\t\t\t\t\tUNSPEC_MOV_DPP_DISTRIBUTE_EVEN);\n+  }\n+  [(set_attr \"type\" \"vop_dpp\")\n+   (set_attr \"length\" \"16\")])\n+\n+(define_insn \"@dpp_distribute_odd<mode>\"\n+  [(set (match_operand:V_noHI 0 \"register_operand\"    \"=v\")\n+\t(unspec:V_noHI\n+\t  [(match_operand:V_noHI 1 \"register_operand\" \" v\")]\n+\t  UNSPEC_MOV_DPP_DISTRIBUTE_EVEN))]\n+  \"\"\n+  {\n+    return gcn_expand_dpp_distribute_odd_insn (<MODE>mode, \"v_mov_b32\",\n+\t\t\t\t\t       UNSPEC_MOV_DPP_DISTRIBUTE_ODD);\n+  }\n+  [(set_attr \"type\" \"vop_dpp\")\n+   (set_attr \"length\" \"16\")])\n+\n ;; }}}\n ;; {{{ ALU special case: add/sub\n \n@@ -2185,6 +2224,180 @@\n     DONE;\n   })\n \n+(define_int_iterator UNSPEC_CMUL_OP [UNSPEC_CMUL UNSPEC_CMUL_CONJ])\n+(define_int_attr conj_op [(UNSPEC_CMUL \"\") (UNSPEC_CMUL_CONJ \"_conj\")])\n+(define_int_attr cmul_subadd [(UNSPEC_CMUL \"sub\") (UNSPEC_CMUL_CONJ \"add\")])\n+(define_int_attr cmul_addsub [(UNSPEC_CMUL \"add\") (UNSPEC_CMUL_CONJ \"sub\")])\n+\n+(define_expand \"cmul<conj_op><mode>3\"\n+  [(set (match_operand:V_noHI 0 \"register_operand\"    \"=&v\")\n+        (unspec:V_noHI\n+\t  [(match_operand:V_noHI 1 \"register_operand\" \"v\")\n+\t   (match_operand:V_noHI 2 \"register_operand\" \"v\")]\n+\t  UNSPEC_CMUL_OP))]\n+  \"\"\n+  {\n+    // operands[1]                                                  a   b\n+    // operands[2]                                                  c   d\n+    rtx t1 = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_mul<mode>3 (t1, operands[1], operands[2]));   // a*c b*d\n+\n+    rtx s2_perm = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_dpp_swap_pairs<mode> (s2_perm, operands[2])); // d   c\n+\n+    rtx t2 = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_mul<mode>3 (t2, operands[1], s2_perm));       // a*d b*c\n+\n+    rtx t1_perm = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_dpp_swap_pairs<mode> (t1_perm, t1));          // b*d a*c\n+\n+    rtx even = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (even, get_exec (0x5555555555555555UL));\n+    rtx dest = operands[0];\n+    emit_insn (gen_<cmul_subadd><mode>3_exec (dest, t1, t1_perm, dest, even));\n+                                                             // a*c-b*d 0\n+\n+    rtx t2_perm = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_dpp_swap_pairs<mode> (t2_perm, t2));          // b*c a*d\n+\n+    rtx odd = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (odd, get_exec (0xaaaaaaaaaaaaaaaaUL));\n+    emit_insn (gen_<cmul_addsub><mode>3_exec (dest, t2, t2_perm, dest, odd));\n+                                                                   // 0 a*d+b*c\n+    DONE;\n+  })\n+\n+(define_code_iterator addsub [plus minus])\n+(define_code_attr addsub_as [(plus \"a\") (minus \"s\")])\n+\n+(define_expand \"cml<addsub_as><mode>4\"\n+  [(set (match_operand:V_FP 0 \"register_operand\"      \"=&v\")\n+\t(addsub:V_FP\n+\t  (unspec:V_FP\n+\t    [(match_operand:V_FP 1 \"register_operand\" \"v\")\n+\t     (match_operand:V_FP 2 \"register_operand\" \"v\")]\n+\t    UNSPEC_CMUL)\n+\t  (match_operand:V_FP 3 \"register_operand\"    \"v\")))]\n+  \"\"\n+  {\n+    rtx a = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_dpp_distribute_even<mode> (a, operands[1]));    // a   a\n+\n+    rtx t1 = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_fm<addsub_as><mode>4 (t1, a, operands[2], operands[3]));\n+                                                                   // a*c a*d\n+\n+    rtx b = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_dpp_distribute_odd<mode> (b, operands[1]));     // b   b\n+\n+    rtx t2 = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_mul<mode>3 (t2, b, operands[2]));               // b*c b*d\n+\n+    rtx t2_perm = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_dpp_swap_pairs<mode> (t2_perm, t2));            // b*d b*c\n+\n+    rtx even = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (even, get_exec (0x5555555555555555UL));\n+    rtx dest = operands[0];\n+    emit_insn (gen_sub<mode>3_exec (dest, t1, t2_perm, dest, even));\n+\n+    rtx odd = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (odd, get_exec (0xaaaaaaaaaaaaaaaaUL));\n+    emit_insn (gen_add<mode>3_exec (dest, t1, t2_perm, dest, odd));\n+\n+    DONE;\n+  })\n+\n+(define_expand \"vec_addsub<mode>3\"\n+  [(set (match_operand:V_noHI 0 \"register_operand\"     \"=&v\")\n+        (vec_merge:V_noHI\n+          (minus:V_noHI\n+            (match_operand:V_noHI 1 \"register_operand\" \"v\")\n+            (match_operand:V_noHI 2 \"register_operand\" \"v\"))\n+          (plus:V_noHI (match_dup 1) (match_dup 2))\n+          (const_int 6148914691236517205)))]\n+  \"\"\n+  {\n+    rtx even = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (even, get_exec (0x5555555555555555UL));\n+    rtx dest = operands[0];\n+    rtx x = operands[1];\n+    rtx y = operands[2];\n+    emit_insn (gen_sub<mode>3_exec (dest, x, y, dest, even));\n+    rtx odd = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (odd, get_exec (0xaaaaaaaaaaaaaaaaUL));\n+    emit_insn (gen_add<mode>3_exec (dest, x, y, dest, odd));\n+\n+    DONE;\n+  })\n+\n+(define_int_iterator CADD [UNSPEC_CADD90 UNSPEC_CADD270])\n+(define_int_attr rot [(UNSPEC_CADD90 \"90\") (UNSPEC_CADD270 \"270\")])\n+(define_int_attr cadd_subadd [(UNSPEC_CADD90 \"sub\") (UNSPEC_CADD270 \"add\")])\n+(define_int_attr cadd_addsub [(UNSPEC_CADD90 \"add\") (UNSPEC_CADD270 \"sub\")])\n+\n+(define_expand \"cadd<rot><mode>3\"\n+  [(set (match_operand:V_noHI 0 \"register_operand\"                 \"=&v\")\n+        (unspec:V_noHI [(match_operand:V_noHI 1 \"register_operand\" \"v\")\n+                        (match_operand:V_noHI 2 \"register_operand\" \"v\")]\n+                        CADD))]\n+  \"\"\n+  {\n+    rtx dest = operands[0];\n+    rtx x = operands[1];\n+    rtx y = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_dpp_swap_pairs<mode> (y, operands[2]));\n+\n+    rtx even = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (even, get_exec (0x5555555555555555UL));\n+    emit_insn (gen_<cadd_subadd><mode>3_exec (dest, x, y, dest, even));\n+    rtx odd = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (odd, get_exec (0xaaaaaaaaaaaaaaaaUL));\n+    emit_insn (gen_<cadd_addsub><mode>3_exec (dest, x, y, dest, odd));\n+\n+    DONE;\n+  })\n+\n+(define_expand \"vec_fmaddsub<mode>4\"\n+  [(match_operand:V_noHI 0 \"register_operand\" \"=&v\")\n+   (match_operand:V_noHI 1 \"register_operand\" \"v\")\n+   (match_operand:V_noHI 2 \"register_operand\" \"v\")\n+   (match_operand:V_noHI 3 \"register_operand\" \"v\")]\n+  \"\"\n+  {\n+    rtx t1 = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_mul<mode>3 (t1, operands[1], operands[2]));\n+    rtx even = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (even, get_exec (0x5555555555555555UL));\n+    rtx dest = operands[0];\n+    emit_insn (gen_sub<mode>3_exec (dest, t1, operands[3], dest, even));\n+    rtx odd = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (odd, get_exec (0xaaaaaaaaaaaaaaaaUL));\n+    emit_insn (gen_add<mode>3_exec (dest, t1, operands[3], dest, odd));\n+\n+    DONE;\n+  })\n+\n+(define_expand \"vec_fmsubadd<mode>4\"\n+  [(match_operand:V_noHI 0 \"register_operand\" \"=&v\")\n+   (match_operand:V_noHI 1 \"register_operand\" \"v\")\n+   (match_operand:V_noHI 2 \"register_operand\" \"v\")\n+   (match_operand:V_noHI 3 \"register_operand\" \"v\")]\n+  \"\"\n+  {\n+    rtx t1 = gen_reg_rtx (<MODE>mode);\n+    emit_insn (gen_mul<mode>3 (t1, operands[1], operands[2]));\n+    rtx even = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (even, get_exec (0x5555555555555555UL));\n+    rtx dest = operands[0];\n+    emit_insn (gen_add<mode>3_exec (dest, t1, operands[3], dest, even));\n+    rtx odd = gen_rtx_REG (DImode, EXEC_REG);\n+    emit_move_insn (odd, get_exec (0xaaaaaaaaaaaaaaaaUL));\n+    emit_insn (gen_add<mode>3_exec (dest, t1, operands[3], dest, odd));\n+\n+    DONE;\n+  })\n+\n ;; }}}\n ;; {{{ ALU generic case\n \n@@ -2861,6 +3074,56 @@\n   [(set_attr \"type\" \"vop3a\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"fms<mode>4<exec>\"\n+  [(set (match_operand:V_FP 0 \"register_operand\"  \"=  v,   v\")\n+\t(fma:V_FP\n+\t  (match_operand:V_FP 1 \"gcn_alu_operand\" \"% vA,  vA\")\n+\t(match_operand:V_FP 2 \"gcn_alu_operand\"   \"  vA,vSvA\")\n+\t(neg:V_FP\n+\t  (match_operand:V_FP 3 \"gcn_alu_operand\" \"vSvA,  vA\"))))]\n+  \"\"\n+  \"v_fma%i0\\t%0, %1, %2, -%3\"\n+  [(set_attr \"type\" \"vop3a\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"fms<mode>4_negop2<exec>\"\n+  [(set (match_operand:V_FP 0 \"register_operand\"    \"=  v,   v,   v\")\n+\t(fma:V_FP\n+\t  (match_operand:V_FP 1 \"gcn_alu_operand\"   \"  vA,  vA,vSvA\")\n+\t  (neg:V_FP\n+\t    (match_operand:V_FP 2 \"gcn_alu_operand\" \"  vA,vSvA,  vA\"))\n+\t  (neg:V_FP\n+\t    (match_operand:V_FP 3 \"gcn_alu_operand\" \"vSvA,  vA,  vA\"))))]\n+  \"\"\n+  \"v_fma%i0\\t%0, %1, -%2, -%3\"\n+  [(set_attr \"type\" \"vop3a\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"fms<mode>4\"\n+  [(set (match_operand:FP 0 \"register_operand\"    \"=  v,   v\")\n+\t(fma:FP\n+\t  (match_operand:FP 1 \"gcn_alu_operand\"   \"% vA,  vA\")\n+\t  (match_operand:FP 2 \"gcn_alu_operand\"   \"  vA,vSvA\")\n+\t  (neg:FP\n+\t    (match_operand:FP 3 \"gcn_alu_operand\" \"vSvA,  vA\"))))]\n+  \"\"\n+  \"v_fma%i0\\t%0, %1, %2, -%3\"\n+  [(set_attr \"type\" \"vop3a\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"fms<mode>4_negop2\"\n+  [(set (match_operand:FP 0 \"register_operand\"    \"=  v,   v,   v\")\n+\t(fma:FP\n+\t  (match_operand:FP 1 \"gcn_alu_operand\"   \"  vA,  vA,vSvA\")\n+\t  (neg:FP\n+\t    (match_operand:FP 2 \"gcn_alu_operand\" \"  vA,vSvA,  vA\"))\n+\t  (neg:FP\n+\t    (match_operand:FP 3 \"gcn_alu_operand\" \"vSvA,  vA,  vA\"))))]\n+  \"\"\n+  \"v_fma%i0\\t%0, %1, -%2, -%3\"\n+  [(set_attr \"type\" \"vop3a\")\n+   (set_attr \"length\" \"8\")])\n+\n ;; }}}\n ;; {{{ FP division\n "}, {"sha": "aca17a19d84e3f10adaa8c2d9ac91b382c661a91", "filename": "gcc/config/gcn/gcn.cc", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bde3acee77c171117dfb988998daa8197c73b34/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bde3acee77c171117dfb988998daa8197c73b34/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.cc?ref=1bde3acee77c171117dfb988998daa8197c73b34", "patch": "@@ -5013,6 +5013,79 @@ gcn_vector_alignment_reachable (const_tree ARG_UNUSED (type), bool is_packed)\n   return !is_packed;\n }\n \n+/* Generate DPP pairwise swap instruction.\n+   This instruction swaps the values in each even lane with the value in the\n+   next one:\n+     a, b, c, d -> b, a, d, c.\n+   The opcode is given by INSN.  */\n+\n+char *\n+gcn_expand_dpp_swap_pairs_insn (machine_mode mode, const char *insn,\n+\t\t\t\tint ARG_UNUSED (unspec))\n+{\n+  static char buf[128];\n+  const char *dpp;\n+\n+  /* Add the DPP modifiers.  */\n+  dpp = \"quad_perm:[1,0,3,2]\";\n+\n+  if (vgpr_2reg_mode_p (mode))\n+    sprintf (buf, \"%s\\t%%L0, %%L1 %s\\n\\t%s\\t%%H0, %%H1 %s\",\n+\t     insn, dpp, insn, dpp);\n+  else\n+    sprintf (buf, \"%s\\t%%0, %%1 %s\", insn, dpp);\n+\n+  return buf;\n+}\n+\n+/* Generate DPP distribute even instruction.\n+   This instruction copies the value in each even lane to the next one:\n+     a, b, c, d -> a, a, c, c.\n+   The opcode is given by INSN.  */\n+\n+char *\n+gcn_expand_dpp_distribute_even_insn (machine_mode mode, const char *insn,\n+\t\t\t\t     int ARG_UNUSED (unspec))\n+{\n+  static char buf[128];\n+  const char *dpp;\n+\n+  /* Add the DPP modifiers.  */\n+  dpp = \"quad_perm:[0,0,2,2]\";\n+\n+  if (vgpr_2reg_mode_p (mode))\n+    sprintf (buf, \"%s\\t%%L0, %%L1 %s\\n\\t%s\\t%%H0, %%H1 %s\",\n+\t     insn, dpp, insn, dpp);\n+  else\n+    sprintf (buf, \"%s\\t%%0, %%1 %s\", insn, dpp);\n+\n+  return buf;\n+}\n+\n+/* Generate DPP distribute odd instruction.\n+   This isntruction copies the value in each odd lane to the previous one:\n+     a, b, c, d -> b, b, d, d.\n+   The opcode is given by INSN.  */\n+\n+char *\n+gcn_expand_dpp_distribute_odd_insn (machine_mode mode, const char *insn,\n+\t\t\t\t    int ARG_UNUSED (unspec))\n+{\n+  static char buf[128];\n+  const char *dpp;\n+\n+  /* Add the DPP modifiers.  */\n+  dpp = \"quad_perm:[1,1,3,3]\";\n+\n+  if (vgpr_2reg_mode_p (mode))\n+    sprintf (buf, \"%s\\t%%L0, %%L1 %s\\n\\t%s\\t%%H0, %%H1 %s\",\n+\t     insn, dpp, insn, dpp);\n+  else\n+    sprintf (buf, \"%s\\t%%0, %%1 %s\", insn, dpp);\n+\n+  return buf;\n+}\n+\n /* Generate DPP instructions used for vector reductions.\n \n    The opcode is given by INSN."}, {"sha": "c90303c54b5f6b6ec79837b18fa8f37ecd254a3c", "filename": "gcc/config/gcn/gcn.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bde3acee77c171117dfb988998daa8197c73b34/gcc%2Fconfig%2Fgcn%2Fgcn.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bde3acee77c171117dfb988998daa8197c73b34/gcc%2Fconfig%2Fgcn%2Fgcn.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.md?ref=1bde3acee77c171117dfb988998daa8197c73b34", "patch": "@@ -78,6 +78,13 @@\n   UNSPEC_PLUS_CARRY_DPP_SHR UNSPEC_PLUS_CARRY_IN_DPP_SHR\n   UNSPEC_AND_DPP_SHR UNSPEC_IOR_DPP_SHR UNSPEC_XOR_DPP_SHR\n   UNSPEC_MOV_DPP_SHR\n+  UNSPEC_MOV_DPP_SWAP_PAIRS\n+  UNSPEC_MOV_DPP_DISTRIBUTE_EVEN\n+  UNSPEC_MOV_DPP_DISTRIBUTE_ODD\n+  UNSPEC_CMUL UNSPEC_CMUL_CONJ\n+  UNSPEC_CMUL_ADD UNSPEC_CMUL_SUB\n+  UNSPEC_CADD90\n+  UNSPEC_CADD270\n   UNSPEC_GATHER\n   UNSPEC_SCATTER\n   UNSPEC_RCP"}, {"sha": "2304b986cf4f9d718f392d6ddc871d1fb8d48f54", "filename": "gcc/testsuite/gcc.target/gcn/complex.c", "status": "added", "additions": 627, "deletions": 0, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bde3acee77c171117dfb988998daa8197c73b34/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fcomplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bde3acee77c171117dfb988998daa8197c73b34/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fcomplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fcomplex.c?ref=1bde3acee77c171117dfb988998daa8197c73b34", "patch": "@@ -0,0 +1,627 @@\n+// { dg-do run }\n+// { dg-options \"-std=c99 -O3\" }\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#define COUNT 1000\n+#define MAX 1000\n+#define ALIGNMENT (2*1024*1024) // 2MB\n+\n+_Complex double conj(_Complex double);\n+_Complex float conjf(_Complex float);\n+\n+unsigned int device = 0;\n+\n+// cmul\n+\n+void cmulF(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  typedef _Complex float complexT;\n+  int array_size = tas/2;\n+  complexT *d = (complexT*)(td);\n+  complexT *e = (complexT*)(te);\n+  complexT *f = (complexT*)(tf);\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      d[i] = e[i] * f[i];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cmulFcheck(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      float a = te[i*2];\n+      float b = te[i*2+1];\n+      float c = tf[i*2];\n+      float d = tf[i*2+1];\n+      if (td[i*2] != a*c-b*d || td[i*2+1] != a*d+b*c)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+void cmulD(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  typedef _Complex double complexT;\n+  int array_size = tas/2;\n+  complexT *d = (complexT*)(td);\n+  complexT *e = (complexT*)(te);\n+  complexT *f = (complexT*)(tf);\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      d[i] = e[i] * f[i];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cmulDcheck(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      double a = te[i*2];\n+      double b = te[i*2+1];\n+      double c = tf[i*2];\n+      double d = tf[i*2+1];\n+      if (td[i*2] != a*c-b*d || td[i*2+1] != a*d+b*c)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+\n+// cmul_conj\n+\n+void cmul_conjF(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  typedef _Complex float complexT;\n+  int array_size = tas/2;\n+  complexT *d = (complexT*)(td);\n+  complexT *e = (complexT*)(te);\n+  complexT *f = (complexT*)(tf);\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      d[i] = e[i] * conj(f[i]);\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cmul_conjFcheck(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      float a = te[i*2];\n+      float b = te[i*2+1];\n+      float c = tf[i*2];\n+      float d = tf[i*2+1];\n+      if (td[i*2] != a*c+b*d || td[i*2+1] != b*c-a*d)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+void cmul_conjD(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  typedef _Complex double complexT;\n+  int array_size = tas/2;\n+  complexT *d = (complexT*)(td);\n+  complexT *e = (complexT*)(te);\n+  complexT *f = (complexT*)(tf);\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      d[i] = e[i] * conj(f[i]);\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cmul_conjDcheck(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      double a = te[i*2];\n+      double b = te[i*2+1];\n+      double c = tf[i*2];\n+      double d = tf[i*2+1];\n+      if (td[i*2] != a*c+b*d || td[i*2+1] != b*c-a*d)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+\n+// addsub\n+\n+void addsubF(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  typedef _Complex float complexT;\n+  int array_size = tas/2;\n+  complexT *d = (complexT*)(td);\n+  complexT *e = (complexT*)(te);\n+  complexT *f = (complexT*)(tf);\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      d[i] = e[i] - conjf(f[i]);\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool addsubFcheck(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      float a = te[i*2];\n+      float b = te[i*2+1];\n+      float c = tf[i*2];\n+      float d = tf[i*2+1];\n+      if (td[i*2] != a-c || td[i*2+1] != b+d)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+void addsubD(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  typedef _Complex double complexT;\n+  int array_size = tas/2;\n+  complexT *d = (complexT*)(td);\n+  complexT *e = (complexT*)(te);\n+  complexT *f = (complexT*)(tf);\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      d[i] = e[i] - conj(f[i]);\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool addsubDcheck(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      double a = te[i*2];\n+      double b = te[i*2+1];\n+      double c = tf[i*2];\n+      double d = tf[i*2+1];\n+      if (td[i*2] != a-c || td[i*2+1] != b+d)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+\n+// fmaddsub\n+\n+void fmaddsubF(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  int array_size = tas/2;\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      td[i*2] = te[i*2]*tf[i*2]-tg[i*2];\n+      td[i*2+1] = te[i*2+1]*tf[i*2+1]+tg[i*2+1];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool fmaddsubFcheck(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      float a = te[i*2];\n+      float b = te[i*2+1];\n+      float c = tf[i*2];\n+      float d = tf[i*2+1];\n+      float e = tg[i*2];\n+      float f = tg[i*2+1];\n+      if (td[i*2] != a*c-e || td[i*2+1] != b*d+f)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+void fmaddsubD(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  int array_size = tas/2;\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      td[i*2] = te[i*2]*tf[i*2]-tg[i*2];\n+      td[i*2+1] = te[i*2+1]*tf[i*2+1]+tg[i*2+1];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool fmaddsubDcheck(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      double a = te[i*2];\n+      double b = te[i*2+1];\n+      double c = tf[i*2];\n+      double d = tf[i*2+1];\n+      double e = tg[i*2];\n+      double f = tg[i*2+1];\n+      if (td[i*2] != a*c-e || td[i*2+1] != b*d+f)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+\n+// fmsubadd\n+\n+void fmsubaddF(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  int array_size = tas/2;\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      td[i*2] = te[i*2]*tf[i*2]+tg[i*2];\n+      td[i*2+1] = te[i*2+1]*tf[i*2+1]-tg[i*2+1];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool fmsubaddFcheck(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      float a = te[i*2];\n+      float b = te[i*2+1];\n+      float c = tf[i*2];\n+      float d = tf[i*2+1];\n+      float e = tg[i*2];\n+      float f = tg[i*2+1];\n+      if (td[i*2] != a*c+e || td[i*2+1] != b*d-f)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+void fmsubaddD(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  int array_size = tas/2;\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      td[i*2] = te[i*2]*tf[i*2]+tg[i*2];\n+      td[i*2+1] = te[i*2+1]*tf[i*2+1]-tg[i*2+1];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool fmsubaddDcheck(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      double a = te[i*2];\n+      double b = te[i*2+1];\n+      double c = tf[i*2];\n+      double d = tf[i*2+1];\n+      double e = tg[i*2];\n+      double f = tg[i*2+1];\n+      if (td[i*2] != a*c+e || td[i*2+1] != b*d-f)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+\n+// cadd90\n+\n+void cadd90F(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  int array_size = tas/2;\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      td[i*2] = te[i*2] - tf[i*2+1];\n+      td[i*2+1] = te[i*2+1] + tf[i*2];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cadd90Fcheck(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      float a = te[i*2];\n+      float b = te[i*2+1];\n+      float c = tf[i*2];\n+      float d = tf[i*2+1];\n+      if (td[i*2] != a-d || td[i*2+1] != b+c)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+void cadd90D(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  int array_size = tas/2;\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      td[i*2] = te[i*2] - tf[i*2+1];\n+      td[i*2+1] = te[i*2+1] + tf[i*2];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cadd90Dcheck(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      double a = te[i*2];\n+      double b = te[i*2+1];\n+      double c = tf[i*2];\n+      double d = tf[i*2+1];\n+      if (td[i*2] != a-d || td[i*2+1] != b+c)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+// cadd270\n+\n+void cadd270F(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  int array_size = tas/2;\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      td[i*2] = te[i*2] + tf[i*2+1];\n+      td[i*2+1] = te[i*2+1] - tf[i*2];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cadd270Fcheck(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      float a = te[i*2];\n+      float b = te[i*2+1];\n+      float c = tf[i*2];\n+      float d = tf[i*2+1];\n+      if (td[i*2] != a+d || td[i*2+1] != b-c)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+void cadd270D(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  int array_size = tas/2;\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      td[i*2] = te[i*2] + tf[i*2+1];\n+      td[i*2+1] = te[i*2+1] - tf[i*2];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cadd270Dcheck(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      double a = te[i*2];\n+      double b = te[i*2+1];\n+      double c = tf[i*2];\n+      double d = tf[i*2+1];\n+      if (td[i*2] != a+d || td[i*2+1] != b-c)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+\n+// cmla\n+\n+void cmlaF(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  typedef _Complex float complexT;\n+  int array_size = tas/2;\n+  complexT *d = (complexT*)(td);\n+  complexT *e = (complexT*)(te);\n+  complexT *f = (complexT*)(tf);\n+  complexT *g = (complexT*)(tg);\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      d[i] = e[i] * f[i] + g[i];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cmlaFcheck(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      float a = te[i*2];\n+      float b = te[i*2+1];\n+      float c = tf[i*2];\n+      float d = tf[i*2+1];\n+      float e = tg[i*2];\n+      float f = tg[i*2+1];\n+      if (td[i*2] != a*c-b*d+e || td[i*2+1] != a*d+b*c+f)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+void cmlaD(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  typedef _Complex double complexT;\n+  int array_size = tas/2;\n+  complexT *d = (complexT*)(td);\n+  complexT *e = (complexT*)(te);\n+  complexT *f = (complexT*)(tf);\n+  complexT *g = (complexT*)(tg);\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      d[i] = e[i] * f[i] + g[i];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cmlaDcheck(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      double a = te[i*2];\n+      double b = te[i*2+1];\n+      double c = tf[i*2];\n+      double d = tf[i*2+1];\n+      double e = tg[i*2];\n+      double f = tg[i*2+1];\n+      if (td[i*2] != a*c-b*d+e || td[i*2+1] != a*d+b*c+f)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+\n+// cmls\n+\n+void cmlsF(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  typedef _Complex float complexT;\n+  int array_size = tas/2;\n+  complexT *d = (complexT*)(td);\n+  complexT *e = (complexT*)(te);\n+  complexT *f = (complexT*)(tf);\n+  complexT *g = (complexT*)(tg);\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      d[i] = e[i] * f[i] - g[i];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cmlsFcheck(float *td, float *te, float *tf, float *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      float a = te[i*2];\n+      float b = te[i*2+1];\n+      float c = tf[i*2];\n+      float d = tf[i*2+1];\n+      float e = tg[i*2];\n+      float f = tg[i*2+1];\n+      if (td[i*2] != a*c-b*d-e || td[i*2+1] != a*d+b*c-f)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+void cmlsD(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  typedef _Complex double complexT;\n+  int array_size = tas/2;\n+  complexT *d = (complexT*)(td);\n+  complexT *e = (complexT*)(te);\n+  complexT *f = (complexT*)(tf);\n+  complexT *g = (complexT*)(tg);\n+  for (int i = 0; i < array_size; i++)\n+    {\n+      d[i] = e[i] * f[i] - g[i];\n+    }\n+}\n+\n+__attribute__((optimize(\"no-tree-vectorize\")))\n+bool cmlsDcheck(double *td, double *te, double *tf, double *tg, int tas)\n+{\n+  for (int i = 0; i < tas/2; ++i)\n+    {\n+      double a = te[i*2];\n+      double b = te[i*2+1];\n+      double c = tf[i*2];\n+      double d = tf[i*2+1];\n+      double e = tg[i*2];\n+      double f = tg[i*2+1];\n+      if (td[i*2] != a*c-b*d-e || td[i*2+1] != a*d+b*c-f)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+\n+typedef void(*runF)(float *td, float *te, float *tf, float *tg, int tas);\n+typedef void(*runD)(double *td, double *te, double *tf, double *tg, int tas);\n+typedef bool(*checkF)(float *td, float *te, float *tf, float *tg, int tas);\n+typedef bool(*checkD)(double *td, double *te, double *tf, double *tg, int tas);\n+\n+typedef struct\n+{\n+  runF rF;\n+  runD rD;\n+  checkF cF;\n+  checkD cD;\n+} operation;\n+\n+operation ops[] = {\n+  {cmulF, cmulD, cmulFcheck, cmulDcheck},\n+  {cmul_conjF, cmul_conjD, cmul_conjFcheck, cmul_conjDcheck},\n+  {addsubF, addsubD, addsubFcheck, addsubDcheck},\n+  {fmaddsubF, fmaddsubD, fmaddsubFcheck, fmaddsubDcheck},\n+  {fmsubaddF, fmsubaddD, fmsubaddFcheck, fmsubaddDcheck},\n+  {cadd90F, cadd90D, cadd90Fcheck, cadd90Dcheck},\n+  {cadd270F, cadd270D, cadd270Fcheck, cadd270Dcheck},\n+  {cmlaF, cmlaD, cmlaFcheck, cmlaDcheck},\n+  {cmlsF, cmlsD, cmlsFcheck, cmlsDcheck}\n+};\n+\n+void testF(operation* op)\n+{\n+  float* td;\n+  float* te;\n+  float* tf;\n+  float* tg;\n+  int array_size = COUNT;\n+  td = (float*)malloc(sizeof(float)*array_size);\n+  te = (float*)malloc(sizeof(float)*array_size);\n+  tf = (float*)malloc(sizeof(float)*array_size);\n+  tg = (float*)malloc(sizeof(float)*array_size);\n+  float* dd = td;\n+  float* ee = te;\n+  float* ff = tf;\n+  float* gg = tg;\n+  for (int i = 0; i < COUNT; ++i)\n+    {\n+      te[i] = (float)(rand() % MAX);\n+      tf[i] = (float)(rand() % MAX);\n+      tg[i] = (float)(rand() % MAX);\n+    }\n+  op->rF(td, te, tf, tg, COUNT);\n+  if (!op->cF(td, te, tf, tg, COUNT))\n+    abort();\n+}\n+\n+void testD(operation* op)\n+{\n+  double* td;\n+  double* te;\n+  double* tf;\n+  double* tg;\n+  int array_size = COUNT;\n+  td = (double*)malloc(sizeof(double)*array_size);\n+  te = (double*)malloc(sizeof(double)*array_size);\n+  tf = (double*)malloc(sizeof(double)*array_size);\n+  tg = (double*)malloc(sizeof(double)*array_size);\n+  double* dd = td;\n+  double* ee = te;\n+  double* ff = tf;\n+  double* gg = tg;\n+  for (int i = 0; i < COUNT; ++i)\n+    {\n+      te[i] = (double)(rand() % MAX);\n+      tf[i] = (double)(rand() % MAX);\n+      tg[i] = (double)(rand() % MAX);\n+    }\n+  op->rD(td, te, tf, tg, COUNT);\n+  if (!op->cD(td, te, tf, tg, COUNT))\n+    abort();\n+}\n+\n+int main()\n+{\n+   for (int i = 0; i < 9; ++i)\n+    {\n+      testF(&ops[i]);\n+      testD(&ops[i]);\n+    }\n+}\n+"}]}