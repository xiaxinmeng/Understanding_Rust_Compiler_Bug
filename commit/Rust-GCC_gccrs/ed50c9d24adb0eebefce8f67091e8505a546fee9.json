{"sha": "ed50c9d24adb0eebefce8f67091e8505a546fee9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ1MGM5ZDI0YWRiMGVlYmVmY2U4ZjY3MDkxZTg1MDVhNTQ2ZmVlOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:27:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:27:57Z"}, "message": "a-intnam-os2.ads, [...]: Removed, no longer used.\n\n\t* a-intnam-os2.ads, a-intnam-unixware.ads, g-soccon-unixware.ads,\n\tg-soliop-unixware.ads, i-os2err.ads, i-os2lib.adb, i-os2lib.ads,\n\ti-os2syn.ads, i-os2thr.ads, s-intman-irix-athread.adb,\n\ts-osinte-aix-fsu.ads, s-osinte-fsu.adb, s-parame-os2.adb,\n\ts-osinte-irix-athread.ads, s-osinte-linux-fsu.ads, s-osinte-os2.adb,\n\ts-osinte-os2.ads, s-osinte-solaris-fsu.ads, s-osinte-unixware.adb,\n\ts-osinte-unixware.ads, s-osprim-os2.adb, s-taprop-irix-athread.adb,\n\ts-taprop-os2.adb, s-tasinf-irix-athread.adb, s-tasinf-irix-athread.ads,\n\ts-taspri-os2.ads, system-os2.ads, system-unixware.ads: Removed,\n\tno longer used.\n\nFrom-SVN: r111021", "tree": {"sha": "4c429698f12bb7247b399c1a25e4593c6efebb47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c429698f12bb7247b399c1a25e4593c6efebb47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed50c9d24adb0eebefce8f67091e8505a546fee9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed50c9d24adb0eebefce8f67091e8505a546fee9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed50c9d24adb0eebefce8f67091e8505a546fee9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed50c9d24adb0eebefce8f67091e8505a546fee9/comments", "author": null, "committer": null, "parents": [{"sha": "5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17"}], "stats": {"total": 9510, "additions": 0, "deletions": 9510}, "files": [{"sha": "9f1099b0da381dfe444ee9a77457891bca080184", "filename": "gcc/ada/a-intnam-os2.ads", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fa-intnam-os2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fa-intnam-os2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-intnam-os2.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,43 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n---                                                                          --\n---                   A D A . I N T E R R U P T S . N A M E S                --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2005, AdaCore                     --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is an OS/2 version of this package\n-\n---  This target-dependent package spec contains names of interrupts\n---  supported by the local system.\n-\n---  This is a stub, for systems that do not support interrupts (or signals)\n-\n-package Ada.Interrupts.Names is\n-end Ada.Interrupts.Names;"}, {"sha": "ff8a6c801c4fe987654428a11905362a582f6939", "filename": "gcc/ada/a-intnam-unixware.ads", "status": "removed", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fa-intnam-unixware.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fa-intnam-unixware.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-intnam-unixware.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,164 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   A D A . I N T E R R U P T S . N A M E S                --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---          Copyright (C) 1991-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a SCO UnixWare version of this package\n-\n---  The following signals are reserved by the run time:\n-\n---  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGTRAP, SIGABRT, SIGINT,\n---  SIGWAITING, SIGLWP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF, SIGSTOP, SIGKILL\n-\n---  The pragma Unreserve_All_Interrupts affects the following signal(s):\n-\n---  SIGINT: made available for Ada handler\n-\n-with System.OS_Interface;\n---  used for names of interrupts\n-\n-package Ada.Interrupts.Names is\n-\n-   --  Beware that the mapping of names to signals may be many-to-one. There\n-   --  may be aliases.\n-\n-   SIGHUP : constant Interrupt_ID :=\n-     System.OS_Interface.SIGHUP;      --  hangup\n-\n-   SIGINT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGINT;      --  interrupt (rubout)\n-\n-   SIGQUIT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)\n-\n-   SIGILL : constant Interrupt_ID :=\n-     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)\n-\n-   SIGTRAP : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)\n-\n-   SIGIOT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGIOT;      --  IOT instruction\n-\n-   SIGABRT : constant Interrupt_ID := --  used by abort,\n-     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future\n-\n-   SIGEMT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGEMT;      --  EMT instruction\n-\n-   SIGFPE : constant Interrupt_ID :=\n-     System.OS_Interface.SIGFPE;      --  floating point exception\n-\n-   SIGKILL : constant Interrupt_ID :=\n-     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)\n-\n-   SIGBUS : constant Interrupt_ID :=\n-     System.OS_Interface.SIGBUS;      --  bus error\n-\n-   SIGSEGV : constant Interrupt_ID :=\n-     System.OS_Interface.SIGSEGV;     --  segmentation violation\n-\n-   SIGSYS : constant Interrupt_ID :=\n-     System.OS_Interface.SIGSYS;      --  bad argument to system call\n-\n-   SIGPIPE : constant Interrupt_ID := --  write on a pipe with\n-     System.OS_Interface.SIGPIPE;     --  no one to read it\n-\n-   SIGALRM : constant Interrupt_ID :=\n-     System.OS_Interface.SIGALRM;     --  alarm clock\n-\n-   SIGTERM : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTERM;     --  software termination signal from kill\n-\n-   SIGUSR1 : constant Interrupt_ID :=\n-     System.OS_Interface.SIGUSR1;     --  user defined signal 1\n-\n-   SIGUSR2 : constant Interrupt_ID :=\n-     System.OS_Interface.SIGUSR2;     --  user defined signal 2\n-\n-   SIGCLD : constant Interrupt_ID :=\n-     System.OS_Interface.SIGCLD;      --  child status change\n-\n-   SIGCHLD : constant Interrupt_ID :=\n-     System.OS_Interface.SIGCHLD;     --  4.3BSD's/POSIX name for SIGCLD\n-\n-   SIGPWR : constant Interrupt_ID :=\n-     System.OS_Interface.SIGPWR;      --  power-fail restart\n-\n-   SIGWINCH : constant Interrupt_ID :=\n-     System.OS_Interface.SIGWINCH;    --  window size change\n-\n-   SIGURG : constant Interrupt_ID :=\n-     System.OS_Interface.SIGURG;      --  urgent condition on IO channel\n-\n-   SIGPOLL : constant Interrupt_ID :=\n-     System.OS_Interface.SIGPOLL;     --  pollable event occurred\n-\n-   SIGIO : constant Interrupt_ID :=   --  input/output possible,\n-     System.OS_Interface.SIGIO;       --  SIGPOLL alias (Solaris)\n-\n-   SIGSTOP : constant Interrupt_ID :=\n-     System.OS_Interface.SIGSTOP;     --  stop (cannot be caught or ignored)\n-\n-   SIGTSTP : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTSTP;     --  user stop requested from tty\n-\n-   SIGCONT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGCONT;     --  stopped process has been continued\n-\n-   SIGTTIN : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTTIN;     --  background tty read attempted\n-\n-   SIGTTOU : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTTOU;     --  background tty write attempted\n-\n-   SIGVTALRM : constant Interrupt_ID :=\n-     System.OS_Interface.SIGVTALRM;   --  virtual timer expired\n-\n-   SIGPROF : constant Interrupt_ID :=\n-     System.OS_Interface.SIGPROF;     --  profiling timer expired\n-\n-   SIGXCPU : constant Interrupt_ID :=\n-     System.OS_Interface.SIGXCPU;     --  CPU time limit exceeded\n-\n-   SIGXFSZ : constant Interrupt_ID :=\n-     System.OS_Interface.SIGXFSZ;     --  filesize limit exceeded\n-\n-   SIGWAITING : constant Interrupt_ID :=\n-     System.OS_Interface.SIGWAITING;  --  process's lwps blocked (Solaris)\n-\n-   SIGLWP : constant Interrupt_ID :=\n-     System.OS_Interface.SIGLWP;      --  used by thread library (Solaris)\n-\n-   SIGAIO : constant Interrupt_ID :=\n-     System.OS_Interface.SIGAIO;      --  Asynchronous I/O signal\n-\n-end Ada.Interrupts.Names;"}, {"sha": "148989e032591139243a91285c4fedc2823dfcf4", "filename": "gcc/ada/g-soccon-unixware.ads", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fg-soccon-unixware.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fg-soccon-unixware.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-soccon-unixware.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,161 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---               G N A T . S O C K E T S . C O N S T A N T S                --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2000-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides target dependent definitions of constant for use\n---  by the GNAT.Sockets package (g-socket.ads). This package should not be\n---  directly with'ed by an applications program.\n-\n---  This is the version for UnixWare\n---  Do not edit this file by hand, instead edit and re-run gen-soccon.c\n-\n-package GNAT.Sockets.Constants is\n-\n-   --------------\n-   -- Families --\n-   --------------\n-\n-   AF_INET            : constant :=            2; --  IPv4 address family\n-   AF_INET6           : constant :=           27; --  IPv6 address family\n-\n-   -----------\n-   -- Modes --\n-   -----------\n-\n-   SOCK_STREAM        : constant :=            2; --  Stream socket\n-   SOCK_DGRAM         : constant :=            1; --  Datagram socket\n-\n-   -------------------\n-   -- Socket errors --\n-   -------------------\n-\n-   EACCES             : constant :=           13; --  Permission denied\n-   EADDRINUSE         : constant :=          125; --  Address already in use\n-   EADDRNOTAVAIL      : constant :=          126; --  Cannot assign address\n-   EAFNOSUPPORT       : constant :=          124; --  Addr family not supported\n-   EALREADY           : constant :=          149; --  Operation in progress\n-   EBADF              : constant :=            9; --  Bad file descriptor\n-   ECONNABORTED       : constant :=          130; --  Connection aborted\n-   ECONNREFUSED       : constant :=          146; --  Connection refused\n-   ECONNRESET         : constant :=          131; --  Connection reset by peer\n-   EDESTADDRREQ       : constant :=           96; --  Destination addr required\n-   EFAULT             : constant :=           14; --  Bad address\n-   EHOSTDOWN          : constant :=          147; --  Host is down\n-   EHOSTUNREACH       : constant :=          148; --  No route to host\n-   EINPROGRESS        : constant :=          150; --  Operation now in progress\n-   EINTR              : constant :=            4; --  Interrupted system call\n-   EINVAL             : constant :=           22; --  Invalid argument\n-   EIO                : constant :=            5; --  Input output error\n-   EISCONN            : constant :=          133; --  Socket already connected\n-   ELOOP              : constant :=           90; --  Too many symbolic lynks\n-   EMFILE             : constant :=           24; --  Too many open files\n-   EMSGSIZE           : constant :=           97; --  Message too long\n-   ENAMETOOLONG       : constant :=           78; --  Name too long\n-   ENETDOWN           : constant :=          127; --  Network is down\n-   ENETRESET          : constant :=          129; --  Disconn. on network reset\n-   ENETUNREACH        : constant :=          128; --  Network is unreachable\n-   ENOBUFS            : constant :=          132; --  No buffer space available\n-   ENOPROTOOPT        : constant :=           99; --  Protocol not available\n-   ENOTCONN           : constant :=          134; --  Socket not connected\n-   ENOTSOCK           : constant :=           95; --  Operation on non socket\n-   EOPNOTSUPP         : constant :=          122; --  Operation not supported\n-   EPFNOSUPPORT       : constant :=          123; --  Unknown protocol family\n-   EPROTONOSUPPORT    : constant :=          120; --  Unknown protocol\n-   EPROTOTYPE         : constant :=           98; --  Unknown protocol type\n-   ESHUTDOWN          : constant :=          143; --  Cannot send once shutdown\n-   ESOCKTNOSUPPORT    : constant :=          121; --  Socket type not supported\n-   ETIMEDOUT          : constant :=          145; --  Connection timed out\n-   ETOOMANYREFS       : constant :=          144; --  Too many references\n-   EWOULDBLOCK        : constant :=           11; --  Operation would block\n-\n-   -----------------\n-   -- Host errors --\n-   -----------------\n-\n-   HOST_NOT_FOUND     : constant :=            1; --  Unknown host\n-   TRY_AGAIN          : constant :=            2; --  Host name lookup failure\n-   NO_DATA            : constant :=            4; --  No data record for name\n-   NO_RECOVERY        : constant :=            3; --  Non recoverable errors\n-\n-   -------------------\n-   -- Control flags --\n-   -------------------\n-\n-   FIONBIO            : constant :=  -2147195266; --  Set/clear non-blocking io\n-   FIONREAD           : constant :=   1074030207; --  How many bytes to read\n-\n-   --------------------\n-   -- Shutdown modes --\n-   --------------------\n-\n-   SHUT_RD            : constant :=            0; --  No more recv\n-   SHUT_WR            : constant :=            1; --  No more send\n-   SHUT_RDWR          : constant :=            2; --  No more recv/send\n-\n-   ---------------------\n-   -- Protocol levels --\n-   ---------------------\n-\n-   SOL_SOCKET         : constant :=        65535; --  Options for socket level\n-   IPPROTO_IP         : constant :=            0; --  Dummy protocol for IP\n-   IPPROTO_UDP        : constant :=           17; --  UDP\n-   IPPROTO_TCP        : constant :=            6; --  TCP\n-\n-   -------------------\n-   -- Request flags --\n-   -------------------\n-\n-   MSG_OOB            : constant :=            1; --  Process out-of-band data\n-   MSG_PEEK           : constant :=            2; --  Peek at incoming data\n-   MSG_EOR            : constant :=            8; --  Send end of record\n-   MSG_WAITALL        : constant :=           64; --  Wait for full reception\n-   MSG_NOSIGNAL       : constant :=           -1; --  No SIGPIPE on send\n-   MSG_Forced_Flags   : constant :=            0;\n-\n-   --------------------\n-   -- Socket options --\n-   --------------------\n-\n-   TCP_NODELAY        : constant :=            1; --  Do not coalesce packets\n-   SO_SNDBUF          : constant :=         4097; --  Set/get send buffer size\n-   SO_RCVBUF          : constant :=         4098; --  Set/get recv buffer size\n-   SO_REUSEADDR       : constant :=            4; --  Bind reuse local address\n-   SO_KEEPALIVE       : constant :=            8; --  Enable keep-alive msgs\n-   SO_LINGER          : constant :=          128; --  Defer close to flush data\n-   SO_ERROR           : constant :=         4103; --  Get/clear error status\n-   SO_BROADCAST       : constant :=           32; --  Can send broadcast msgs\n-   IP_ADD_MEMBERSHIP  : constant :=           11; --  Join a multicast group\n-   IP_DROP_MEMBERSHIP : constant :=           12; --  Leave a multicast group\n-   IP_MULTICAST_TTL   : constant :=           16; --  Set/get multicast TTL\n-   IP_MULTICAST_LOOP  : constant :=           10; --  Set/get mcast loopback\n-\n-end GNAT.Sockets.Constants;"}, {"sha": "4f42edc3be46e8253b953721ba32c56ef644fe4e", "filename": "gcc/ada/g-soliop-unixware.ads", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fg-soliop-unixware.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fg-soliop-unixware.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-soliop-unixware.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,43 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---          G N A T . S O C K E T S . L I N K E R _ O P T I O N S           --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 2002-2005, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package is used to provide target specific linker_options for the\n---  support of scokets as required by the package GNAT.Sockets.\n-\n---  This is the UnixWare version of this package\n-\n-package GNAT.Sockets.Linker_Options is\n-private\n-   pragma Linker_Options (\"-lnsl\");\n-   pragma Linker_Options (\"-lsocket\");\n-end GNAT.Sockets.Linker_Options;"}, {"sha": "f837224ae6b4dd5adda4c514590b231e09345939", "filename": "gcc/ada/i-os2err.ads", "status": "removed", "additions": 0, "deletions": 655, "changes": 655, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fi-os2err.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fi-os2err.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-os2err.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,655 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---               I N T E R F A C E S . O S 2 L I B . E R R O R S            --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---          Copyright (C) 1993-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Definition of values for OS/2 error returns\n-\n-package Interfaces.OS2Lib.Errors is\n-   pragma Preelaborate;\n-\n-   NO_ERROR                        : constant :=     0;\n-   ERROR_INVALID_FUNCTION          : constant :=     1;\n-   ERROR_FILE_NOT_FOUND            : constant :=     2;\n-   ERROR_PATH_NOT_FOUND            : constant :=     3;\n-   ERROR_TOO_MANY_OPEN_FILES       : constant :=     4;\n-   ERROR_ACCESS_DENIED             : constant :=     5;\n-   ERROR_INVALID_HANDLE            : constant :=     6;\n-   ERROR_ARENA_TRASHED             : constant :=     7;\n-   ERROR_NOT_ENOUGH_MEMORY         : constant :=     8;\n-   ERROR_INVALID_BLOCK             : constant :=     9;\n-   ERROR_BAD_ENVIRONMENT           : constant :=    10;\n-   ERROR_BAD_FORMAT                : constant :=    11;\n-   ERROR_INVALID_ACCESS            : constant :=    12;\n-   ERROR_INVALID_DATA              : constant :=    13;\n-   ERROR_INVALID_DRIVE             : constant :=    15;\n-   ERROR_CURRENT_DIRECTORY         : constant :=    16;\n-   ERROR_NOT_SAME_DEVICE           : constant :=    17;\n-   ERROR_NO_MORE_FILES             : constant :=    18;\n-   ERROR_WRITE_PROTECT             : constant :=    19;\n-   ERROR_BAD_UNIT                  : constant :=    20;\n-   ERROR_NOT_READY                 : constant :=    21;\n-   ERROR_BAD_COMMAND               : constant :=    22;\n-   ERROR_CRC                       : constant :=    23;\n-   ERROR_BAD_LENGTH                : constant :=    24;\n-   ERROR_SEEK                      : constant :=    25;\n-   ERROR_NOT_DOS_DISK              : constant :=    26;\n-   ERROR_SECTOR_NOT_FOUND          : constant :=    27;\n-   ERROR_OUT_OF_PAPER              : constant :=    28;\n-   ERROR_WRITE_FAULT               : constant :=    29;\n-   ERROR_READ_FAULT                : constant :=    30;\n-   ERROR_GEN_FAILURE               : constant :=    31;\n-   ERROR_SHARING_VIOLATION         : constant :=    32;\n-   ERROR_LOCK_VIOLATION            : constant :=    33;\n-   ERROR_WRONG_DISK                : constant :=    34;\n-   ERROR_FCB_UNAVAILABLE           : constant :=    35;\n-   ERROR_SHARING_BUFFER_EXCEEDED   : constant :=    36;\n-   ERROR_CODE_PAGE_MISMATCHED      : constant :=    37;\n-   ERROR_HANDLE_EOF                : constant :=    38;\n-   ERROR_HANDLE_DISK_FULL          : constant :=    39;\n-   ERROR_NOT_SUPPORTED             : constant :=    50;\n-   ERROR_REM_NOT_LIST              : constant :=    51;\n-   ERROR_DUP_NAME                  : constant :=    52;\n-   ERROR_BAD_NETPATH               : constant :=    53;\n-   ERROR_NETWORK_BUSY              : constant :=    54;\n-   ERROR_DEV_NOT_EXIST             : constant :=    55;\n-   ERROR_TOO_MANY_CMDS             : constant :=    56;\n-   ERROR_ADAP_HDW_ERR              : constant :=    57;\n-   ERROR_BAD_NET_RESP              : constant :=    58;\n-   ERROR_UNEXP_NET_ERR             : constant :=    59;\n-   ERROR_BAD_REM_ADAP              : constant :=    60;\n-   ERROR_PRINTQ_FULL               : constant :=    61;\n-   ERROR_NO_SPOOL_SPACE            : constant :=    62;\n-   ERROR_PRINT_CANCELLED           : constant :=    63;\n-   ERROR_NETNAME_DELETED           : constant :=    64;\n-   ERROR_NETWORK_ACCESS_DENIED     : constant :=    65;\n-   ERROR_BAD_DEV_TYPE              : constant :=    66;\n-   ERROR_BAD_NET_NAME              : constant :=    67;\n-   ERROR_TOO_MANY_NAMES            : constant :=    68;\n-   ERROR_TOO_MANY_SESS             : constant :=    69;\n-   ERROR_SHARING_PAUSED            : constant :=    70;\n-   ERROR_REQ_NOT_ACCEP             : constant :=    71;\n-   ERROR_REDIR_PAUSED              : constant :=    72;\n-   ERROR_SBCS_ATT_WRITE_PROT       : constant :=    73;\n-   ERROR_SBCS_GENERAL_FAILURE      : constant :=    74;\n-   ERROR_XGA_OUT_MEMORY            : constant :=    75;\n-   ERROR_FILE_EXISTS               : constant :=    80;\n-   ERROR_DUP_FCB                   : constant :=    81;\n-   ERROR_CANNOT_MAKE               : constant :=    82;\n-   ERROR_FAIL_I24                  : constant :=    83;\n-   ERROR_OUT_OF_STRUCTURES         : constant :=    84;\n-   ERROR_ALREADY_ASSIGNED          : constant :=    85;\n-   ERROR_INVALID_PASSWORD          : constant :=    86;\n-   ERROR_INVALID_PARAMETER         : constant :=    87;\n-   ERROR_NET_WRITE_FAULT           : constant :=    88;\n-   ERROR_NO_PROC_SLOTS             : constant :=    89;\n-   ERROR_NOT_FROZEN                : constant :=    90;\n-   ERROR_SYS_COMP_NOT_LOADED       : constant :=    90;\n-   ERR_TSTOVFL                     : constant :=    91;\n-   ERR_TSTDUP                      : constant :=    92;\n-   ERROR_NO_ITEMS                  : constant :=    93;\n-   ERROR_INTERRUPT                 : constant :=    95;\n-   ERROR_DEVICE_IN_USE             : constant :=    99;\n-   ERROR_TOO_MANY_SEMAPHORES       : constant :=   100;\n-   ERROR_EXCL_SEM_ALREADY_OWNED    : constant :=   101;\n-   ERROR_SEM_IS_SET                : constant :=   102;\n-   ERROR_TOO_MANY_SEM_REQUESTS     : constant :=   103;\n-   ERROR_INVALID_AT_INTERRUPT_TIME : constant :=   104;\n-   ERROR_SEM_OWNER_DIED            : constant :=   105;\n-   ERROR_SEM_USER_LIMIT            : constant :=   106;\n-   ERROR_DISK_CHANGE               : constant :=   107;\n-   ERROR_DRIVE_LOCKED              : constant :=   108;\n-   ERROR_BROKEN_PIPE               : constant :=   109;\n-   ERROR_OPEN_FAILED               : constant :=   110;\n-   ERROR_BUFFER_OVERFLOW           : constant :=   111;\n-   ERROR_DISK_FULL                 : constant :=   112;\n-   ERROR_NO_MORE_SEARCH_HANDLES    : constant :=   113;\n-   ERROR_INVALID_TARGET_HANDLE     : constant :=   114;\n-   ERROR_PROTECTION_VIOLATION      : constant :=   115;\n-   ERROR_VIOKBD_REQUEST            : constant :=   116;\n-   ERROR_INVALID_CATEGORY          : constant :=   117;\n-   ERROR_INVALID_VERIFY_SWITCH     : constant :=   118;\n-   ERROR_BAD_DRIVER_LEVEL          : constant :=   119;\n-   ERROR_CALL_NOT_IMPLEMENTED      : constant :=   120;\n-   ERROR_SEM_TIMEOUT               : constant :=   121;\n-   ERROR_INSUFFICIENT_BUFFER       : constant :=   122;\n-   ERROR_INVALID_NAME              : constant :=   123;\n-   ERROR_INVALID_LEVEL             : constant :=   124;\n-   ERROR_NO_VOLUME_LABEL           : constant :=   125;\n-   ERROR_MOD_NOT_FOUND             : constant :=   126;\n-   ERROR_PROC_NOT_FOUND            : constant :=   127;\n-   ERROR_WAIT_NO_CHILDREN          : constant :=   128;\n-   ERROR_CHILD_NOT_COMPLETE        : constant :=   129;\n-   ERROR_DIRECT_ACCESS_HANDLE      : constant :=   130;\n-   ERROR_NEGATIVE_SEEK             : constant :=   131;\n-   ERROR_SEEK_ON_DEVICE            : constant :=   132;\n-   ERROR_IS_JOIN_TARGET            : constant :=   133;\n-   ERROR_IS_JOINED                 : constant :=   134;\n-   ERROR_IS_SUBSTED                : constant :=   135;\n-   ERROR_NOT_JOINED                : constant :=   136;\n-   ERROR_NOT_SUBSTED               : constant :=   137;\n-   ERROR_JOIN_TO_JOIN              : constant :=   138;\n-   ERROR_SUBST_TO_SUBST            : constant :=   139;\n-   ERROR_JOIN_TO_SUBST             : constant :=   140;\n-   ERROR_SUBST_TO_JOIN             : constant :=   141;\n-   ERROR_BUSY_DRIVE                : constant :=   142;\n-   ERROR_SAME_DRIVE                : constant :=   143;\n-   ERROR_DIR_NOT_ROOT              : constant :=   144;\n-   ERROR_DIR_NOT_EMPTY             : constant :=   145;\n-   ERROR_IS_SUBST_PATH             : constant :=   146;\n-   ERROR_IS_JOIN_PATH              : constant :=   147;\n-   ERROR_PATH_BUSY                 : constant :=   148;\n-   ERROR_IS_SUBST_TARGET           : constant :=   149;\n-   ERROR_SYSTEM_TRACE              : constant :=   150;\n-   ERROR_INVALID_EVENT_COUNT       : constant :=   151;\n-   ERROR_TOO_MANY_MUXWAITERS       : constant :=   152;\n-   ERROR_INVALID_LIST_FORMAT       : constant :=   153;\n-   ERROR_LABEL_TOO_LONG            : constant :=   154;\n-   ERROR_TOO_MANY_TCBS             : constant :=   155;\n-   ERROR_SIGNAL_REFUSED            : constant :=   156;\n-   ERROR_DISCARDED                 : constant :=   157;\n-   ERROR_NOT_LOCKED                : constant :=   158;\n-   ERROR_BAD_THREADID_ADDR         : constant :=   159;\n-   ERROR_BAD_ARGUMENTS             : constant :=   160;\n-   ERROR_BAD_PATHNAME              : constant :=   161;\n-   ERROR_SIGNAL_PENDING            : constant :=   162;\n-   ERROR_UNCERTAIN_MEDIA           : constant :=   163;\n-   ERROR_MAX_THRDS_REACHED         : constant :=   164;\n-   ERROR_MONITORS_NOT_SUPPORTED    : constant :=   165;\n-   ERROR_UNC_DRIVER_NOT_INSTALLED  : constant :=   166;\n-   ERROR_LOCK_FAILED               : constant :=   167;\n-   ERROR_SWAPIO_FAILED             : constant :=   168;\n-   ERROR_SWAPIN_FAILED             : constant :=   169;\n-   ERROR_BUSY                      : constant :=   170;\n-   ERROR_CANCEL_VIOLATION          : constant :=   173;\n-   ERROR_ATOMIC_LOCK_NOT_SUPPORTED : constant :=   174;\n-   ERROR_READ_LOCKS_NOT_SUPPORTED  : constant :=   175;\n-   ERROR_INVALID_SEGMENT_NUMBER    : constant :=   180;\n-   ERROR_INVALID_CALLGATE          : constant :=   181;\n-   ERROR_INVALID_ORDINAL           : constant :=   182;\n-   ERROR_ALREADY_EXISTS            : constant :=   183;\n-   ERROR_NO_CHILD_PROCESS          : constant :=   184;\n-   ERROR_CHILD_ALIVE_NOWAIT        : constant :=   185;\n-   ERROR_INVALID_FLAG_NUMBER       : constant :=   186;\n-   ERROR_SEM_NOT_FOUND             : constant :=   187;\n-   ERROR_INVALID_STARTING_CODESEG  : constant :=   188;\n-   ERROR_INVALID_STACKSEG          : constant :=   189;\n-   ERROR_INVALID_MODULETYPE        : constant :=   190;\n-   ERROR_INVALID_EXE_SIGNATURE     : constant :=   191;\n-   ERROR_EXE_MARKED_INVALID        : constant :=   192;\n-   ERROR_BAD_EXE_FORMAT            : constant :=   193;\n-   ERROR_ITERATED_DATA_EXCEEDS_64k : constant :=   194;\n-   ERROR_INVALID_MINALLOCSIZE      : constant :=   195;\n-   ERROR_DYNLINK_FROM_INVALID_RING : constant :=   196;\n-   ERROR_IOPL_NOT_ENABLED          : constant :=   197;\n-   ERROR_INVALID_SEGDPL            : constant :=   198;\n-   ERROR_AUTODATASEG_EXCEEDS_64k   : constant :=   199;\n-   ERROR_RING2SEG_MUST_BE_MOVABLE  : constant :=   200;\n-   ERROR_RELOC_CHAIN_XEEDS_SEGLIM  : constant :=   201;\n-   ERROR_INFLOOP_IN_RELOC_CHAIN    : constant :=   202;\n-   ERROR_ENVVAR_NOT_FOUND          : constant :=   203;\n-   ERROR_NOT_CURRENT_CTRY          : constant :=   204;\n-   ERROR_NO_SIGNAL_SENT            : constant :=   205;\n-   ERROR_FILENAME_EXCED_RANGE      : constant :=   206;\n-   ERROR_RING2_STACK_IN_USE        : constant :=   207;\n-   ERROR_META_EXPANSION_TOO_LONG   : constant :=   208;\n-   ERROR_INVALID_SIGNAL_NUMBER     : constant :=   209;\n-   ERROR_THREAD_1_INACTIVE         : constant :=   210;\n-   ERROR_INFO_NOT_AVAIL            : constant :=   211;\n-   ERROR_LOCKED                    : constant :=   212;\n-   ERROR_BAD_DYNALINK              : constant :=   213;\n-   ERROR_TOO_MANY_MODULES          : constant :=   214;\n-   ERROR_NESTING_NOT_ALLOWED       : constant :=   215;\n-   ERROR_CANNOT_SHRINK             : constant :=   216;\n-   ERROR_ZOMBIE_PROCESS            : constant :=   217;\n-   ERROR_STACK_IN_HIGH_MEMORY      : constant :=   218;\n-   ERROR_INVALID_EXITROUTINE_RING  : constant :=   219;\n-   ERROR_GETBUF_FAILED             : constant :=   220;\n-   ERROR_FLUSHBUF_FAILED           : constant :=   221;\n-   ERROR_TRANSFER_TOO_LONG         : constant :=   222;\n-   ERROR_FORCENOSWAP_FAILED        : constant :=   223;\n-   ERROR_SMG_NO_TARGET_WINDOW      : constant :=   224;\n-   ERROR_NO_CHILDREN               : constant :=   228;\n-   ERROR_INVALID_SCREEN_GROUP      : constant :=   229;\n-   ERROR_BAD_PIPE                  : constant :=   230;\n-   ERROR_PIPE_BUSY                 : constant :=   231;\n-   ERROR_NO_DATA                   : constant :=   232;\n-   ERROR_PIPE_NOT_CONNECTED        : constant :=   233;\n-   ERROR_MORE_DATA                 : constant :=   234;\n-   ERROR_VC_DISCONNECTED           : constant :=   240;\n-   ERROR_CIRCULARITY_REQUESTED     : constant :=   250;\n-   ERROR_DIRECTORY_IN_CDS          : constant :=   251;\n-   ERROR_INVALID_FSD_NAME          : constant :=   252;\n-   ERROR_INVALID_PATH              : constant :=   253;\n-   ERROR_INVALID_EA_NAME           : constant :=   254;\n-   ERROR_EA_LIST_INCONSISTENT      : constant :=   255;\n-   ERROR_EA_LIST_TOO_LONG          : constant :=   256;\n-   ERROR_NO_META_MATCH             : constant :=   257;\n-   ERROR_FINDNOTIFY_TIMEOUT        : constant :=   258;\n-   ERROR_NO_MORE_ITEMS             : constant :=   259;\n-   ERROR_SEARCH_STRUC_REUSED       : constant :=   260;\n-   ERROR_CHAR_NOT_FOUND            : constant :=   261;\n-   ERROR_TOO_MUCH_STACK            : constant :=   262;\n-   ERROR_INVALID_ATTR              : constant :=   263;\n-   ERROR_INVALID_STARTING_RING     : constant :=   264;\n-   ERROR_INVALID_DLL_INIT_RING     : constant :=   265;\n-   ERROR_CANNOT_COPY               : constant :=   266;\n-   ERROR_DIRECTORY                 : constant :=   267;\n-   ERROR_OPLOCKED_FILE             : constant :=   268;\n-   ERROR_OPLOCK_THREAD_EXISTS      : constant :=   269;\n-   ERROR_VOLUME_CHANGED            : constant :=   270;\n-   ERROR_FINDNOTIFY_HANDLE_IN_USE  : constant :=   271;\n-   ERROR_FINDNOTIFY_HANDLE_CLOSED  : constant :=   272;\n-   ERROR_NOTIFY_OBJECT_REMOVED     : constant :=   273;\n-   ERROR_ALREADY_SHUTDOWN          : constant :=   274;\n-   ERROR_EAS_DIDNT_FIT             : constant :=   275;\n-   ERROR_EA_FILE_CORRUPT           : constant :=   276;\n-   ERROR_EA_TABLE_FULL             : constant :=   277;\n-   ERROR_INVALID_EA_HANDLE         : constant :=   278;\n-   ERROR_NO_CLUSTER                : constant :=   279;\n-   ERROR_CREATE_EA_FILE            : constant :=   280;\n-   ERROR_CANNOT_OPEN_EA_FILE       : constant :=   281;\n-   ERROR_EAS_NOT_SUPPORTED         : constant :=   282;\n-   ERROR_NEED_EAS_FOUND            : constant :=   283;\n-   ERROR_DUPLICATE_HANDLE          : constant :=   284;\n-   ERROR_DUPLICATE_NAME            : constant :=   285;\n-   ERROR_EMPTY_MUXWAIT             : constant :=   286;\n-   ERROR_MUTEX_OWNED               : constant :=   287;\n-   ERROR_NOT_OWNER                 : constant :=   288;\n-   ERROR_PARAM_TOO_SMALL           : constant :=   289;\n-   ERROR_TOO_MANY_HANDLES          : constant :=   290;\n-   ERROR_TOO_MANY_OPENS            : constant :=   291;\n-   ERROR_WRONG_TYPE                : constant :=   292;\n-   ERROR_UNUSED_CODE               : constant :=   293;\n-   ERROR_THREAD_NOT_TERMINATED     : constant :=   294;\n-   ERROR_INIT_ROUTINE_FAILED       : constant :=   295;\n-   ERROR_MODULE_IN_USE             : constant :=   296;\n-   ERROR_NOT_ENOUGH_WATCHPOINTS    : constant :=   297;\n-   ERROR_TOO_MANY_POSTS            : constant :=   298;\n-   ERROR_ALREADY_POSTED            : constant :=   299;\n-   ERROR_ALREADY_RESET             : constant :=   300;\n-   ERROR_SEM_BUSY                  : constant :=   301;\n-   ERROR_INVALID_PROCID            : constant :=   303;\n-   ERROR_INVALID_PDELTA            : constant :=   304;\n-   ERROR_NOT_DESCENDANT            : constant :=   305;\n-   ERROR_NOT_SESSION_MANAGER       : constant :=   306;\n-   ERROR_INVALID_PCLASS            : constant :=   307;\n-   ERROR_INVALID_SCOPE             : constant :=   308;\n-   ERROR_INVALID_THREADID          : constant :=   309;\n-   ERROR_DOSSUB_SHRINK             : constant :=   310;\n-   ERROR_DOSSUB_NOMEM              : constant :=   311;\n-   ERROR_DOSSUB_OVERLAP            : constant :=   312;\n-   ERROR_DOSSUB_BADSIZE            : constant :=   313;\n-   ERROR_DOSSUB_BADFLAG            : constant :=   314;\n-   ERROR_DOSSUB_BADSELECTOR        : constant :=   315;\n-   ERROR_MR_MSG_TOO_LONG           : constant :=   316;\n-   MGS_MR_MSG_TOO_LONG             : constant :=   316;\n-   ERROR_MR_MID_NOT_FOUND          : constant :=   317;\n-   ERROR_MR_UN_ACC_MSGF            : constant :=   318;\n-   ERROR_MR_INV_MSGF_FORMAT        : constant :=   319;\n-   ERROR_MR_INV_IVCOUNT            : constant :=   320;\n-   ERROR_MR_UN_PERFORM             : constant :=   321;\n-   ERROR_TS_WAKEUP                 : constant :=   322;\n-   ERROR_TS_SEMHANDLE              : constant :=   323;\n-   ERROR_TS_NOTIMER                : constant :=   324;\n-   ERROR_TS_HANDLE                 : constant :=   326;\n-   ERROR_TS_DATETIME               : constant :=   327;\n-   ERROR_SYS_INTERNAL              : constant :=   328;\n-   ERROR_QUE_CURRENT_NAME          : constant :=   329;\n-   ERROR_QUE_PROC_NOT_OWNED        : constant :=   330;\n-   ERROR_QUE_PROC_OWNED            : constant :=   331;\n-   ERROR_QUE_DUPLICATE             : constant :=   332;\n-   ERROR_QUE_ELEMENT_NOT_EXIST     : constant :=   333;\n-   ERROR_QUE_NO_MEMORY             : constant :=   334;\n-   ERROR_QUE_INVALID_NAME          : constant :=   335;\n-   ERROR_QUE_INVALID_PRIORITY      : constant :=   336;\n-   ERROR_QUE_INVALID_HANDLE        : constant :=   337;\n-   ERROR_QUE_LINK_NOT_FOUND        : constant :=   338;\n-   ERROR_QUE_MEMORY_ERROR          : constant :=   339;\n-   ERROR_QUE_PREV_AT_END           : constant :=   340;\n-   ERROR_QUE_PROC_NO_ACCESS        : constant :=   341;\n-   ERROR_QUE_EMPTY                 : constant :=   342;\n-   ERROR_QUE_NAME_NOT_EXIST        : constant :=   343;\n-   ERROR_QUE_NOT_INITIALIZED       : constant :=   344;\n-   ERROR_QUE_UNABLE_TO_ACCESS      : constant :=   345;\n-   ERROR_QUE_UNABLE_TO_ADD         : constant :=   346;\n-   ERROR_QUE_UNABLE_TO_INIT        : constant :=   347;\n-   ERROR_VIO_INVALID_MASK          : constant :=   349;\n-   ERROR_VIO_PTR                   : constant :=   350;\n-   ERROR_VIO_APTR                  : constant :=   351;\n-   ERROR_VIO_RPTR                  : constant :=   352;\n-   ERROR_VIO_CPTR                  : constant :=   353;\n-   ERROR_VIO_LPTR                  : constant :=   354;\n-   ERROR_VIO_MODE                  : constant :=   355;\n-   ERROR_VIO_WIDTH                 : constant :=   356;\n-   ERROR_VIO_ATTR                  : constant :=   357;\n-   ERROR_VIO_ROW                   : constant :=   358;\n-   ERROR_VIO_COL                   : constant :=   359;\n-   ERROR_VIO_TOPROW                : constant :=   360;\n-   ERROR_VIO_BOTROW                : constant :=   361;\n-   ERROR_VIO_RIGHTCOL              : constant :=   362;\n-   ERROR_VIO_LEFTCOL               : constant :=   363;\n-   ERROR_SCS_CALL                  : constant :=   364;\n-   ERROR_SCS_VALUE                 : constant :=   365;\n-   ERROR_VIO_WAIT_FLAG             : constant :=   366;\n-   ERROR_VIO_UNLOCK                : constant :=   367;\n-   ERROR_SGS_NOT_SESSION_MGR       : constant :=   368;\n-   ERROR_SMG_INVALID_SGID          : constant :=   369;\n-   ERROR_SMG_INVALID_SESSION_ID    : constant :=   369;\n-   ERROR_SMG_NOSG                  : constant :=   370;\n-   ERROR_SMG_NO_SESSIONS           : constant :=   370;\n-   ERROR_SMG_GRP_NOT_FOUND         : constant :=   371;\n-   ERROR_SMG_SESSION_NOT_FOUND     : constant :=   371;\n-   ERROR_SMG_SET_TITLE             : constant :=   372;\n-   ERROR_KBD_PARAMETER             : constant :=   373;\n-   ERROR_KBD_NO_DEVICE             : constant :=   374;\n-   ERROR_KBD_INVALID_IOWAIT        : constant :=   375;\n-   ERROR_KBD_INVALID_LENGTH        : constant :=   376;\n-   ERROR_KBD_INVALID_ECHO_MASK     : constant :=   377;\n-   ERROR_KBD_INVALID_INPUT_MASK    : constant :=   378;\n-   ERROR_MON_INVALID_PARMS         : constant :=   379;\n-   ERROR_MON_INVALID_DEVNAME       : constant :=   380;\n-   ERROR_MON_INVALID_HANDLE        : constant :=   381;\n-   ERROR_MON_BUFFER_TOO_SMALL      : constant :=   382;\n-   ERROR_MON_BUFFER_EMPTY          : constant :=   383;\n-   ERROR_MON_DATA_TOO_LARGE        : constant :=   384;\n-   ERROR_MOUSE_NO_DEVICE           : constant :=   385;\n-   ERROR_MOUSE_INV_HANDLE          : constant :=   386;\n-   ERROR_MOUSE_INV_PARMS           : constant :=   387;\n-   ERROR_MOUSE_CANT_RESET          : constant :=   388;\n-   ERROR_MOUSE_DISPLAY_PARMS       : constant :=   389;\n-   ERROR_MOUSE_INV_MODULE          : constant :=   390;\n-   ERROR_MOUSE_INV_ENTRY_PT        : constant :=   391;\n-   ERROR_MOUSE_INV_MASK            : constant :=   392;\n-   NO_ERROR_MOUSE_NO_DATA          : constant :=   393;\n-   NO_ERROR_MOUSE_PTR_DRAWN        : constant :=   394;\n-   ERROR_INVALID_FREQUENCY         : constant :=   395;\n-   ERROR_NLS_NO_COUNTRY_FILE       : constant :=   396;\n-   ERROR_NLS_OPEN_FAILED           : constant :=   397;\n-   ERROR_NLS_NO_CTRY_CODE          : constant :=   398;\n-   ERROR_NO_COUNTRY_OR_CODEPAGE    : constant :=   398;\n-   ERROR_NLS_TABLE_TRUNCATED       : constant :=   399;\n-   ERROR_NLS_BAD_TYPE              : constant :=   400;\n-   ERROR_NLS_TYPE_NOT_FOUND        : constant :=   401;\n-   ERROR_VIO_SMG_ONLY              : constant :=   402;\n-   ERROR_VIO_INVALID_ASCIIZ        : constant :=   403;\n-   ERROR_VIO_DEREGISTER            : constant :=   404;\n-   ERROR_VIO_NO_POPUP              : constant :=   405;\n-   ERROR_VIO_EXISTING_POPUP        : constant :=   406;\n-   ERROR_KBD_SMG_ONLY              : constant :=   407;\n-   ERROR_KBD_INVALID_ASCIIZ        : constant :=   408;\n-   ERROR_KBD_INVALID_MASK          : constant :=   409;\n-   ERROR_KBD_REGISTER              : constant :=   410;\n-   ERROR_KBD_DEREGISTER            : constant :=   411;\n-   ERROR_MOUSE_SMG_ONLY            : constant :=   412;\n-   ERROR_MOUSE_INVALID_ASCIIZ      : constant :=   413;\n-   ERROR_MOUSE_INVALID_MASK        : constant :=   414;\n-   ERROR_MOUSE_REGISTER            : constant :=   415;\n-   ERROR_MOUSE_DEREGISTER          : constant :=   416;\n-   ERROR_SMG_BAD_ACTION            : constant :=   417;\n-   ERROR_SMG_INVALID_CALL          : constant :=   418;\n-   ERROR_SCS_SG_NOTFOUND           : constant :=   419;\n-   ERROR_SCS_NOT_SHELL             : constant :=   420;\n-   ERROR_VIO_INVALID_PARMS         : constant :=   421;\n-   ERROR_VIO_FUNCTION_OWNED        : constant :=   422;\n-   ERROR_VIO_RETURN                : constant :=   423;\n-   ERROR_SCS_INVALID_FUNCTION      : constant :=   424;\n-   ERROR_SCS_NOT_SESSION_MGR       : constant :=   425;\n-   ERROR_VIO_REGISTER              : constant :=   426;\n-   ERROR_VIO_NO_MODE_THREAD        : constant :=   427;\n-   ERROR_VIO_NO_SAVE_RESTORE_THD   : constant :=   428;\n-   ERROR_VIO_IN_BG                 : constant :=   429;\n-   ERROR_VIO_ILLEGAL_DURING_POPUP  : constant :=   430;\n-   ERROR_SMG_NOT_BASESHELL         : constant :=   431;\n-   ERROR_SMG_BAD_STATUSREQ         : constant :=   432;\n-   ERROR_QUE_INVALID_WAIT          : constant :=   433;\n-   ERROR_VIO_LOCK                  : constant :=   434;\n-   ERROR_MOUSE_INVALID_IOWAIT      : constant :=   435;\n-   ERROR_VIO_INVALID_HANDLE        : constant :=   436;\n-   ERROR_VIO_ILLEGAL_DURING_LOCK   : constant :=   437;\n-   ERROR_VIO_INVALID_LENGTH        : constant :=   438;\n-   ERROR_KBD_INVALID_HANDLE        : constant :=   439;\n-   ERROR_KBD_NO_MORE_HANDLE        : constant :=   440;\n-   ERROR_KBD_CANNOT_CREATE_KCB     : constant :=   441;\n-   ERROR_KBD_CODEPAGE_LOAD_INCOMPL : constant :=   442;\n-   ERROR_KBD_INVALID_CODEPAGE_ID   : constant :=   443;\n-   ERROR_KBD_NO_CODEPAGE_SUPPORT   : constant :=   444;\n-   ERROR_KBD_FOCUS_REQUIRED        : constant :=   445;\n-   ERROR_KBD_FOCUS_ALREADY_ACTIVE  : constant :=   446;\n-   ERROR_KBD_KEYBOARD_BUSY         : constant :=   447;\n-   ERROR_KBD_INVALID_CODEPAGE      : constant :=   448;\n-   ERROR_KBD_UNABLE_TO_FOCUS       : constant :=   449;\n-   ERROR_SMG_SESSION_NON_SELECT    : constant :=   450;\n-   ERROR_SMG_SESSION_NOT_FOREGRND  : constant :=   451;\n-   ERROR_SMG_SESSION_NOT_PARENT    : constant :=   452;\n-   ERROR_SMG_INVALID_START_MODE    : constant :=   453;\n-   ERROR_SMG_INVALID_RELATED_OPT   : constant :=   454;\n-   ERROR_SMG_INVALID_BOND_OPTION   : constant :=   455;\n-   ERROR_SMG_INVALID_SELECT_OPT    : constant :=   456;\n-   ERROR_SMG_START_IN_BACKGROUND   : constant :=   457;\n-   ERROR_SMG_INVALID_STOP_OPTION   : constant :=   458;\n-   ERROR_SMG_BAD_RESERVE           : constant :=   459;\n-   ERROR_SMG_PROCESS_NOT_PARENT    : constant :=   460;\n-   ERROR_SMG_INVALID_DATA_LENGTH   : constant :=   461;\n-   ERROR_SMG_NOT_BOUND             : constant :=   462;\n-   ERROR_SMG_RETRY_SUB_ALLOC       : constant :=   463;\n-   ERROR_KBD_DETACHED              : constant :=   464;\n-   ERROR_VIO_DETACHED              : constant :=   465;\n-   ERROR_MOU_DETACHED              : constant :=   466;\n-   ERROR_VIO_FONT                  : constant :=   467;\n-   ERROR_VIO_USER_FONT             : constant :=   468;\n-   ERROR_VIO_BAD_CP                : constant :=   469;\n-   ERROR_VIO_NO_CP                 : constant :=   470;\n-   ERROR_VIO_NA_CP                 : constant :=   471;\n-   ERROR_INVALID_CODE_PAGE         : constant :=   472;\n-   ERROR_CPLIST_TOO_SMALL          : constant :=   473;\n-   ERROR_CP_NOT_MOVED              : constant :=   474;\n-   ERROR_MODE_SWITCH_INIT          : constant :=   475;\n-   ERROR_CODE_PAGE_NOT_FOUND       : constant :=   476;\n-   ERROR_UNEXPECTED_SLOT_RETURNED  : constant :=   477;\n-   ERROR_SMG_INVALID_TRACE_OPTION  : constant :=   478;\n-   ERROR_VIO_INTERNAL_RESOURCE     : constant :=   479;\n-   ERROR_VIO_SHELL_INIT            : constant :=   480;\n-   ERROR_SMG_NO_HARD_ERRORS        : constant :=   481;\n-   ERROR_CP_SWITCH_INCOMPLETE      : constant :=   482;\n-   ERROR_VIO_TRANSPARENT_POPUP     : constant :=   483;\n-   ERROR_CRITSEC_OVERFLOW          : constant :=   484;\n-   ERROR_CRITSEC_UNDERFLOW         : constant :=   485;\n-   ERROR_VIO_BAD_RESERVE           : constant :=   486;\n-   ERROR_INVALID_ADDRESS           : constant :=   487;\n-   ERROR_ZERO_SELECTORS_REQUESTED  : constant :=   488;\n-   ERROR_NOT_ENOUGH_SELECTORS_AVA  : constant :=   489;\n-   ERROR_INVALID_SELECTOR          : constant :=   490;\n-   ERROR_SMG_INVALID_PROGRAM_TYPE  : constant :=   491;\n-   ERROR_SMG_INVALID_PGM_CONTROL   : constant :=   492;\n-   ERROR_SMG_INVALID_INHERIT_OPT   : constant :=   493;\n-   ERROR_VIO_EXTENDED_SG           : constant :=   494;\n-   ERROR_VIO_NOT_PRES_MGR_SG       : constant :=   495;\n-   ERROR_VIO_SHIELD_OWNED          : constant :=   496;\n-   ERROR_VIO_NO_MORE_HANDLES       : constant :=   497;\n-   ERROR_VIO_SEE_ERROR_LOG         : constant :=   498;\n-   ERROR_VIO_ASSOCIATED_DC         : constant :=   499;\n-   ERROR_KBD_NO_CONSOLE            : constant :=   500;\n-   ERROR_MOUSE_NO_CONSOLE          : constant :=   501;\n-   ERROR_MOUSE_INVALID_HANDLE      : constant :=   502;\n-   ERROR_SMG_INVALID_DEBUG_PARMS   : constant :=   503;\n-   ERROR_KBD_EXTENDED_SG           : constant :=   504;\n-   ERROR_MOU_EXTENDED_SG           : constant :=   505;\n-   ERROR_SMG_INVALID_ICON_FILE     : constant :=   506;\n-   ERROR_TRC_PID_NON_EXISTENT      : constant :=   507;\n-   ERROR_TRC_COUNT_ACTIVE          : constant :=   508;\n-   ERROR_TRC_SUSPENDED_BY_COUNT    : constant :=   509;\n-   ERROR_TRC_COUNT_INACTIVE        : constant :=   510;\n-   ERROR_TRC_COUNT_REACHED         : constant :=   511;\n-   ERROR_NO_MC_TRACE               : constant :=   512;\n-   ERROR_MC_TRACE                  : constant :=   513;\n-   ERROR_TRC_COUNT_ZERO            : constant :=   514;\n-   ERROR_SMG_TOO_MANY_DDS          : constant :=   515;\n-   ERROR_SMG_INVALID_NOTIFICATION  : constant :=   516;\n-   ERROR_LF_INVALID_FUNCTION       : constant :=   517;\n-   ERROR_LF_NOT_AVAIL              : constant :=   518;\n-   ERROR_LF_SUSPENDED              : constant :=   519;\n-   ERROR_LF_BUF_TOO_SMALL          : constant :=   520;\n-   ERROR_LF_BUFFER_CORRUPTED       : constant :=   521;\n-   ERROR_LF_BUFFER_FULL            : constant :=   521;\n-   ERROR_LF_INVALID_DAEMON         : constant :=   522;\n-   ERROR_LF_INVALID_RECORD         : constant :=   522;\n-   ERROR_LF_INVALID_TEMPL          : constant :=   523;\n-   ERROR_LF_INVALID_SERVICE        : constant :=   523;\n-   ERROR_LF_GENERAL_FAILURE        : constant :=   524;\n-   ERROR_LF_INVALID_ID             : constant :=   525;\n-   ERROR_LF_INVALID_HANDLE         : constant :=   526;\n-   ERROR_LF_NO_ID_AVAIL            : constant :=   527;\n-   ERROR_LF_TEMPLATE_AREA_FULL     : constant :=   528;\n-   ERROR_LF_ID_IN_USE              : constant :=   529;\n-   ERROR_MOU_NOT_INITIALIZED       : constant :=   530;\n-   ERROR_MOUINITREAL_DONE          : constant :=   531;\n-   ERROR_DOSSUB_CORRUPTED          : constant :=   532;\n-   ERROR_MOUSE_CALLER_NOT_SUBSYS   : constant :=   533;\n-   ERROR_ARITHMETIC_OVERFLOW       : constant :=   534;\n-   ERROR_TMR_NO_DEVICE             : constant :=   535;\n-   ERROR_TMR_INVALID_TIME          : constant :=   536;\n-   ERROR_PVW_INVALID_ENTITY        : constant :=   537;\n-   ERROR_PVW_INVALID_ENTITY_TYPE   : constant :=   538;\n-   ERROR_PVW_INVALID_SPEC          : constant :=   539;\n-   ERROR_PVW_INVALID_RANGE_TYPE    : constant :=   540;\n-   ERROR_PVW_INVALID_COUNTER_BLK   : constant :=   541;\n-   ERROR_PVW_INVALID_TEXT_BLK      : constant :=   542;\n-   ERROR_PRF_NOT_INITIALIZED       : constant :=   543;\n-   ERROR_PRF_ALREADY_INITIALIZED   : constant :=   544;\n-   ERROR_PRF_NOT_STARTED           : constant :=   545;\n-   ERROR_PRF_ALREADY_STARTED       : constant :=   546;\n-   ERROR_PRF_TIMER_OUT_OF_RANGE    : constant :=   547;\n-   ERROR_PRF_TIMER_RESET           : constant :=   548;\n-   ERROR_VDD_LOCK_USEAGE_DENIED    : constant :=   639;\n-   ERROR_TIMEOUT                   : constant :=   640;\n-   ERROR_VDM_DOWN                  : constant :=   641;\n-   ERROR_VDM_LIMIT                 : constant :=   642;\n-   ERROR_VDD_NOT_FOUND             : constant :=   643;\n-   ERROR_INVALID_CALLER            : constant :=   644;\n-   ERROR_PID_MISMATCH              : constant :=   645;\n-   ERROR_INVALID_VDD_HANDLE        : constant :=   646;\n-   ERROR_VLPT_NO_SPOOLER           : constant :=   647;\n-   ERROR_VCOM_DEVICE_BUSY          : constant :=   648;\n-   ERROR_VLPT_DEVICE_BUSY          : constant :=   649;\n-   ERROR_NESTING_TOO_DEEP          : constant :=   650;\n-   ERROR_VDD_MISSING               : constant :=   651;\n-   ERROR_BIDI_INVALID_LENGTH       : constant :=   671;\n-   ERROR_BIDI_INVALID_INCREMENT    : constant :=   672;\n-   ERROR_BIDI_INVALID_COMBINATION  : constant :=   673;\n-   ERROR_BIDI_INVALID_RESERVED     : constant :=   674;\n-   ERROR_BIDI_INVALID_EFFECT       : constant :=   675;\n-   ERROR_BIDI_INVALID_CSDREC       : constant :=   676;\n-   ERROR_BIDI_INVALID_CSDSTATE     : constant :=   677;\n-   ERROR_BIDI_INVALID_LEVEL        : constant :=   678;\n-   ERROR_BIDI_INVALID_TYPE_SUPPORT : constant :=   679;\n-   ERROR_BIDI_INVALID_ORIENTATION  : constant :=   680;\n-   ERROR_BIDI_INVALID_NUM_SHAPE    : constant :=   681;\n-   ERROR_BIDI_INVALID_CSD          : constant :=   682;\n-   ERROR_BIDI_NO_SUPPORT           : constant :=   683;\n-   NO_ERROR_BIDI_RW_INCOMPLETE     : constant :=   684;\n-   ERROR_IMP_INVALID_PARM          : constant :=   691;\n-   ERROR_IMP_INVALID_LENGTH        : constant :=   692;\n-   MSG_HPFS_DISK_ERROR_WARN        : constant :=   693;\n-   ERROR_MON_BAD_BUFFER            : constant :=   730;\n-   ERROR_MODULE_CORRUPTED          : constant :=   731;\n-   ERROR_SM_OUTOF_SWAPFILE         : constant :=  1477;\n-   ERROR_LF_TIMEOUT                : constant :=  2055;\n-   ERROR_LF_SUSPEND_SUCCESS        : constant :=  2057;\n-   ERROR_LF_RESUME_SUCCESS         : constant :=  2058;\n-   ERROR_LF_REDIRECT_SUCCESS       : constant :=  2059;\n-   ERROR_LF_REDIRECT_FAILURE       : constant :=  2060;\n-   ERROR_SWAPPER_NOT_ACTIVE        : constant := 32768;\n-   ERROR_INVALID_SWAPID            : constant := 32769;\n-   ERROR_IOERR_SWAP_FILE           : constant := 32770;\n-   ERROR_SWAP_TABLE_FULL           : constant := 32771;\n-   ERROR_SWAP_FILE_FULL            : constant := 32772;\n-   ERROR_CANT_INIT_SWAPPER         : constant := 32773;\n-   ERROR_SWAPPER_ALREADY_INIT      : constant := 32774;\n-   ERROR_PMM_INSUFFICIENT_MEMORY   : constant := 32775;\n-   ERROR_PMM_INVALID_FLAGS         : constant := 32776;\n-   ERROR_PMM_INVALID_ADDRESS       : constant := 32777;\n-   ERROR_PMM_LOCK_FAILED           : constant := 32778;\n-   ERROR_PMM_UNLOCK_FAILED         : constant := 32779;\n-   ERROR_PMM_MOVE_INCOMPLETE       : constant := 32780;\n-   ERROR_UCOM_DRIVE_RENAMED        : constant := 32781;\n-   ERROR_UCOM_FILENAME_TRUNCATED   : constant := 32782;\n-   ERROR_UCOM_BUFFER_LENGTH        : constant := 32783;\n-   ERROR_MON_CHAIN_HANDLE          : constant := 32784;\n-   ERROR_MON_NOT_REGISTERED        : constant := 32785;\n-   ERROR_SMG_ALREADY_TOP           : constant := 32786;\n-   ERROR_PMM_ARENA_MODIFIED        : constant := 32787;\n-   ERROR_SMG_PRINTER_OPEN          : constant := 32788;\n-   ERROR_PMM_SET_FLAGS_FAILED      : constant := 32789;\n-   ERROR_INVALID_DOS_DD            : constant := 32790;\n-   ERROR_BLOCKED                   : constant := 32791;\n-   ERROR_NOBLOCK                   : constant := 32792;\n-   ERROR_INSTANCE_SHARED           : constant := 32793;\n-   ERROR_NO_OBJECT                 : constant := 32794;\n-   ERROR_PARTIAL_ATTACH            : constant := 32795;\n-   ERROR_INCACHE                   : constant := 32796;\n-   ERROR_SWAP_IO_PROBLEMS          : constant := 32797;\n-   ERROR_CROSSES_OBJECT_BOUNDARY   : constant := 32798;\n-   ERROR_LONGLOCK                  : constant := 32799;\n-   ERROR_SHORTLOCK                 : constant := 32800;\n-   ERROR_UVIRTLOCK                 : constant := 32801;\n-   ERROR_ALIASLOCK                 : constant := 32802;\n-   ERROR_ALIAS                     : constant := 32803;\n-   ERROR_NO_MORE_HANDLES           : constant := 32804;\n-   ERROR_SCAN_TERMINATED           : constant := 32805;\n-   ERROR_TERMINATOR_NOT_FOUND      : constant := 32806;\n-   ERROR_NOT_DIRECT_CHILD          : constant := 32807;\n-   ERROR_DELAY_FREE                : constant := 32808;\n-   ERROR_GUARDPAGE                 : constant := 32809;\n-   ERROR_SWAPERROR                 : constant := 32900;\n-   ERROR_LDRERROR                  : constant := 32901;\n-   ERROR_NOMEMORY                  : constant := 32902;\n-   ERROR_NOACCESS                  : constant := 32903;\n-   ERROR_NO_DLL_TERM               : constant := 32904;\n-   ERROR_CPSIO_CODE_PAGE_INVALID   : constant := 65026;\n-   ERROR_CPSIO_NO_SPOOLER          : constant := 65027;\n-   ERROR_CPSIO_FONT_ID_INVALID     : constant := 65028;\n-   ERROR_CPSIO_INTERNAL_ERROR      : constant := 65033;\n-   ERROR_CPSIO_INVALID_PTR_NAME    : constant := 65034;\n-   ERROR_CPSIO_NOT_ACTIVE          : constant := 65037;\n-   ERROR_CPSIO_PID_FULL            : constant := 65039;\n-   ERROR_CPSIO_PID_NOT_FOUND       : constant := 65040;\n-   ERROR_CPSIO_READ_CTL_SEQ        : constant := 65043;\n-   ERROR_CPSIO_READ_FNT_DEF        : constant := 65045;\n-   ERROR_CPSIO_WRITE_ERROR         : constant := 65047;\n-   ERROR_CPSIO_WRITE_FULL_ERROR    : constant := 65048;\n-   ERROR_CPSIO_WRITE_HANDLE_BAD    : constant := 65049;\n-   ERROR_CPSIO_SWIT_LOAD           : constant := 65074;\n-   ERROR_CPSIO_INV_COMMAND         : constant := 65077;\n-   ERROR_CPSIO_NO_FONT_SWIT        : constant := 65078;\n-   ERROR_ENTRY_IS_CALLGATE         : constant := 65079;\n-\n-end Interfaces.OS2Lib.Errors;"}, {"sha": "93a56567e0ed0db0d989798ead445479df752c1d", "filename": "gcc/ada/i-os2lib.adb", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fi-os2lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fi-os2lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-os2lib.adb?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,66 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                     I N T E R F A C E S . O S 2 L I B                    --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---          Copyright (C) 1993-1999 Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Interfaces.OS2Lib.Errors;\n-\n-package body Interfaces.OS2Lib is\n-\n-   pragma Warnings (Off, Errors);\n-   package IOE renames Interfaces.OS2Lib.Errors;\n-\n-   -------------------\n-   -- Must_Not_Fail --\n-   -------------------\n-\n-   procedure Must_Not_Fail (Return_Code : APIRET) is\n-   begin\n-      pragma Assert (Return_Code = IOE.NO_ERROR);\n-      null;\n-   end Must_Not_Fail;\n-\n-   -----------------------\n-   -- Sem_Must_Not_Fail --\n-   -----------------------\n-\n-   procedure Sem_Must_Not_Fail (Return_Code : OS2Lib.APIRET) is\n-   begin\n-      pragma Assert\n-        (Return_Code = IOE.NO_ERROR\n-           or else\n-         Return_Code = IOE.ERROR_ALREADY_POSTED\n-           or else\n-         Return_Code = IOE.ERROR_ALREADY_RESET);\n-      null;\n-   end Sem_Must_Not_Fail;\n-\n-end Interfaces.OS2Lib;"}, {"sha": "ac5a65433ebfde8748db401ff5fdcda1e1ee02b0", "filename": "gcc/ada/i-os2lib.ads", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fi-os2lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fi-os2lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-os2lib.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,143 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                     I N T E R F A C E S . O S 2 L I B                    --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---          Copyright (C) 1993-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package (and children) provide interface definitions to the standard\n---  OS/2 Library. They are merely a translation of the various <bse*.h> files.\n-\n---  It is intended that higher level interfaces (with better names, and\n---  stronger typing!) be built on top of this one for Ada (i.e. clean)\n---  programming.\n-\n---  We have chosen to keep names, types, etc.  as close as possible to the\n---  C definition to provide easier reference to the documentation. The main\n---  exception is when a formal and its type (in C) differed only by the case\n---  of letters (like in HMUX hmux). In this case, we have prepended \"F_\" to\n---  the formal (i.e. F_hmux : HMUX).\n-\n-with Interfaces.C;\n-with Interfaces.C.Strings;\n-with System;\n-\n-package Interfaces.OS2Lib is\n-   pragma Preelaborate;\n-\n-   package IC  renames Interfaces.C;\n-   package ICS renames Interfaces.C.Strings;\n-\n-   -------------------\n-   -- General Types --\n-   -------------------\n-\n-   type    APIRET   is new IC.unsigned_long;\n-   type    APIRET16 is new IC.unsigned_short;\n-   subtype APIRET32 is     APIRET;\n-\n-   subtype PSZ    is ICS.chars_ptr;\n-   subtype PCHAR  is ICS.chars_ptr;\n-   subtype PVOID  is System.Address;\n-   type    PPVOID is access all PVOID;\n-\n-   type BOOL32 is new IC.unsigned_long;\n-   False32 : constant BOOL32 := 0;\n-   True32  : constant BOOL32 := 1;\n-\n-   type UCHAR   is new IC.unsigned_char;\n-   type USHORT  is new IC.unsigned_short;\n-   type ULONG   is new IC.unsigned_long;\n-   type PULONG  is access all ULONG;\n-\n-   --  Coprocessor stack register element\n-\n-   type FPREG is record\n-      losig             : ULONG;        --  Low 32-bits of the mantissa\n-      hisig             : ULONG;        --  High 32-bits of the mantissa\n-      signexp           : USHORT;       --  Sign and exponent\n-   end record;\n-   pragma Convention (C, FPREG);\n-\n-   type AULONG is array (IC.size_t range <>) of ULONG;\n-   type AFPREG is array (IC.size_t range <>) of FPREG;\n-\n-   type LHANDLE is new IC.unsigned_long;\n-\n-   NULLHANDLE : constant := 0;\n-\n-   ---------------------\n-   -- Time Management --\n-   ---------------------\n-\n-   function DosSleep (How_long : ULONG) return APIRET;\n-   pragma Import (C, DosSleep, \"DosSleep\");\n-\n-   type DATETIME is record\n-      hours      : UCHAR;\n-      minutes    : UCHAR;\n-      seconds    : UCHAR;\n-      hundredths : UCHAR;\n-      day        : UCHAR;\n-      month      : UCHAR;\n-      year       : USHORT;\n-      timezone   : IC.short;\n-      weekday    : UCHAR;\n-   end record;\n-\n-   type PDATETIME is access all DATETIME;\n-\n-   function DosGetDateTime (pdt : PDATETIME) return APIRET;\n-   pragma Import (C, DosGetDateTime, \"DosGetDateTime\");\n-\n-   function DosSetDateTime (pdt : PDATETIME) return APIRET;\n-   pragma Import (C, DosSetDateTime, \"DosSetDateTime\");\n-\n-   ----------------------------\n-   -- Miscelleneous Features --\n-   ----------------------------\n-\n-   --  Features which do not fit any child\n-\n-   function DosBeep (Freq : ULONG; Dur : ULONG) return APIRET;\n-   pragma Import (C, DosBeep, \"DosBeep\");\n-\n-   procedure Must_Not_Fail (Return_Code : OS2Lib.APIRET);\n-   pragma Inline (Must_Not_Fail);\n-   --  Many OS/2 functions return APIRET and are not supposed to fail. In C\n-   --  style, these would be called as procedures, disregarding the returned\n-   --  value. This procedure can be used to achieve the same effect with a\n-   --  call of the form: Must_Not_Fail (Some_OS2_Function (...));\n-\n-   procedure Sem_Must_Not_Fail (Return_Code : OS2Lib.APIRET);\n-   pragma Inline (Sem_Must_Not_Fail);\n-   --  Similar to Must_Not_Fail, but used in the case of DosPostEventSem,\n-   --  where the \"error\" code ERROR_ALREADY_POSTED is not really an error.\n-\n-end Interfaces.OS2Lib;"}, {"sha": "9dfa2c6dfe0d85b57d629a55b236afda2b223d83", "filename": "gcc/ada/i-os2syn.ads", "status": "removed", "additions": 0, "deletions": 267, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fi-os2syn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fi-os2syn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-os2syn.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,267 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---    I N T E R F A C E S . O S 2 L I B . S Y N C H R O N I Z A T I O N     --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---          Copyright (C) 1993-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Interfaces.OS2Lib.Threads;\n-\n-package Interfaces.OS2Lib.Synchronization is\n-   pragma Preelaborate;\n-\n-   package IC  renames Interfaces.C;\n-   package IOT renames Interfaces.OS2Lib.Threads;\n-   package S   renames System;\n-\n-   --  Semaphore Attributes\n-\n-   DC_SEM_SHARED : constant := 16#01#;\n-   --  DosCreateMutex, DosCreateEvent, and DosCreateMuxWait use it to indicate\n-   --  whether the semaphore is shared or private when the PSZ is null\n-\n-   SEM_INDEFINITE_WAIT  : constant ULONG := -1;\n-   SEM_IMMEDIATE_RETURN : constant ULONG :=  0;\n-\n-   type HSEM is new LHANDLE;\n-   type PHSEM is access all HSEM;\n-\n-   type SEMRECORD is record\n-      hsemCur : HSEM;\n-      ulUser  : ULONG;\n-   end record;\n-\n-   type PSEMRECORD is access all SEMRECORD;\n-\n-   --  Quad word structure\n-\n-   --  Originally QWORD is defined as a record containing two ULONGS,\n-   --  the first containing low word and the second for the high word,\n-   --  but it is cleaner to define it as follows:\n-\n-   type QWORD is delta 1.0 range -2.0**63 .. 2.0**63 - 1.0;\n-   type PQWORD is access all QWORD;\n-\n-   type HEV is new HSEM;\n-   type PHEV is access all HEV;\n-\n-   type HMTX  is new HSEM;\n-   type PHMTX is access all HMTX;\n-\n-   type HMUX  is new HSEM;\n-   type PHMUX is access all HMUX;\n-\n-   type HTIMER is new LHANDLE;\n-   type PHTIMER is access all HTIMER;\n-\n-   -----------------------\n-   -- Critical sections --\n-   -----------------------\n-\n-   function DosEnterCritSec return APIRET;\n-   pragma Import (C, DosEnterCritSec, \"DosEnterCritSec\");\n-\n-   function DosExitCritSec return APIRET;\n-   pragma Import (C, DosExitCritSec, \"DosExitCritSec\");\n-\n-   --------------\n-   -- EventSem --\n-   --------------\n-\n-   function DosCreateEventSem\n-     (pszName   : PSZ;\n-      f_phev    : PHEV;\n-      flAttr    : ULONG;\n-      fState    : BOOL32)\n-      return      APIRET;\n-   pragma Import (C, DosCreateEventSem, \"DosCreateEventSem\");\n-\n-   function DosOpenEventSem\n-     (pszName   : PSZ;\n-      F_phev    : PHEV)\n-      return      APIRET;\n-   pragma Import (C, DosOpenEventSem, \"DosOpenEventSem\");\n-\n-   function DosCloseEventSem\n-     (F_hev     : HEV)\n-      return      APIRET;\n-   pragma Import (C, DosCloseEventSem, \"DosCloseEventSem\");\n-\n-   function DosResetEventSem\n-     (F_hev     : HEV;\n-      pulPostCt : PULONG)\n-      return      APIRET;\n-   pragma Import (C, DosResetEventSem, \"DosResetEventSem\");\n-\n-   function DosPostEventSem\n-     (F_hev     : HEV)\n-      return      APIRET;\n-   pragma Import (C, DosPostEventSem, \"DosPostEventSem\");\n-\n-   function DosWaitEventSem\n-     (F_hev     : HEV;\n-      ulTimeout : ULONG)\n-      return      APIRET;\n-   pragma Import (C, DosWaitEventSem, \"DosWaitEventSem\");\n-\n-   function DosQueryEventSem\n-     (F_hev     : HEV;\n-      pulPostCt : PULONG)\n-      return      APIRET;\n-   pragma Import (C, DosQueryEventSem, \"DosQueryEventSem\");\n-\n-   --------------\n-   -- MutexSem --\n-   --------------\n-\n-   function DosCreateMutexSem\n-     (pszName   : PSZ;\n-      F_phmtx   : PHMTX;\n-      flAttr    : ULONG;\n-      fState    : BOOL32)\n-      return      APIRET;\n-   pragma Import (C, DosCreateMutexSem, \"DosCreateMutexSem\");\n-\n-   function DosOpenMutexSem\n-     (pszName   : PSZ;\n-      F_phmtx   : PHMTX)\n-      return      APIRET;\n-   pragma Import (C, DosOpenMutexSem, \"DosOpenMutexSem\");\n-\n-   function DosCloseMutexSem\n-     (F_hmtx    : HMTX)\n-      return      APIRET;\n-   pragma Import (C, DosCloseMutexSem, \"DosCloseMutexSem\");\n-\n-   function DosRequestMutexSem\n-     (F_hmtx    : HMTX;\n-      ulTimeout : ULONG)\n-      return      APIRET;\n-   pragma Import (C, DosRequestMutexSem, \"DosRequestMutexSem\");\n-\n-   function DosReleaseMutexSem\n-     (F_hmtx    : HMTX)\n-      return      APIRET;\n-   pragma Import (C, DosReleaseMutexSem, \"DosReleaseMutexSem\");\n-\n-   function DosQueryMutexSem\n-     (F_hmtx    : HMTX;\n-      F_ppid    : IOT.PPID;\n-      F_ptid    : IOT.PTID;\n-      pulCount  : PULONG)\n-      return      APIRET;\n-   pragma Import (C, DosQueryMutexSem, \"DosQueryMutexSem\");\n-\n-   ----------------\n-   -- MuxWaitSem --\n-   ----------------\n-\n-   function DosCreateMuxWaitSem\n-     (pszName   : PSZ;\n-      F_phmux   : PHMUX;\n-      cSemRec   : ULONG;\n-      pSemRec   : PSEMRECORD;\n-      flAttr    : ULONG)\n-      return      APIRET;\n-   pragma Import (C, DosCreateMuxWaitSem, \"DosCreateMuxWaitSem\");\n-\n-   DCMW_WAIT_ANY : constant := 16#02#;  -- wait on any event/mutex to occur\n-   DCMW_WAIT_ALL : constant := 16#04#;  -- wait on all events/mutexes to occur\n-   --  Values for \"flAttr\" parameter in DosCreateMuxWaitSem call\n-\n-   function DosOpenMuxWaitSem\n-     (pszName   : PSZ;\n-      F_phmux   : PHMUX)\n-      return      APIRET;\n-   pragma Import (C, DosOpenMuxWaitSem, \"DosOpenMuxWaitSem\");\n-\n-   function DosCloseMuxWaitSem\n-     (F_hmux    : HMUX)\n-      return      APIRET;\n-   pragma Import (C, DosCloseMuxWaitSem, \"DosCloseMuxWaitSem\");\n-\n-   function DosWaitMuxWaitSem\n-     (F_hmux    : HMUX;\n-      ulTimeout : ULONG;\n-      pulUser   : PULONG)\n-      return      APIRET;\n-   pragma Import (C, DosWaitMuxWaitSem, \"DosWaitMuxWaitSem\");\n-\n-   function DosAddMuxWaitSem\n-     (F_hmux    : HMUX;\n-      pSemRec   : PSEMRECORD)\n-      return      APIRET;\n-   pragma Import (C, DosAddMuxWaitSem, \"DosAddMuxWaitSem\");\n-\n-   function DosDeleteMuxWaitSem\n-     (F_hmux    : HMUX;\n-      F_hsem    : HSEM)\n-      return      APIRET;\n-   pragma Import (C, DosDeleteMuxWaitSem, \"DosDeleteMuxWaitSem\");\n-\n-   function DosQueryMuxWaitSem\n-     (F_hmux    : HMUX;\n-     pcSemRec   : PULONG;\n-     pSemRec    : PSEMRECORD;\n-     pflAttr    : PULONG)\n-     return       APIRET;\n-   pragma Import (C, DosQueryMuxWaitSem, \"DosQueryMuxWaitSem\");\n-\n-   -----------\n-   -- Timer --\n-   -----------\n-\n-   function DosAsyncTimer\n-    (msec      : ULONG;\n-     F_hsem    : HSEM;\n-     F_phtimer : PHTIMER)\n-     return      APIRET;\n-   pragma Import (C, DosAsyncTimer, \"DosAsyncTimer\");\n-\n-   function DosStartTimer\n-    (msec      : ULONG;\n-     F_hsem    : HSEM;\n-     F_phtimer : PHTIMER)\n-     return      APIRET;\n-   pragma Import (C, DosStartTimer, \"DosStartTimer\");\n-\n-   function DosStopTimer\n-     (F_htimer : HTIMER)\n-      return     APIRET;\n-   pragma Import (C, DosStopTimer, \"DosStopTimer\");\n-\n-   --  DosTmrQueryTime provides a snapshot of the time\n-   --  from the IRQ0 high resolution timer (Intel 8254)\n-\n-   function DosTmrQueryTime\n-     (pqwTmrTime : access QWORD)   --  Time in 8254 ticks (1_192_755.2 Hz)\n-      return       APIRET;\n-   pragma Import (C, DosTmrQueryTime, \"DosTmrQueryTime\");\n-\n-end Interfaces.OS2Lib.Synchronization;"}, {"sha": "97ac453d9fb507ab94fe988d18c50937dda8a01b", "filename": "gcc/ada/i-os2thr.ads", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fi-os2thr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fi-os2thr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-os2thr.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,193 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---             I N T E R F A C E S . O S 2 L I B . T H R E A D S            --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---          Copyright (C) 1993-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Interfaces.C;\n-\n-package Interfaces.OS2Lib.Threads is\n-   pragma Preelaborate;\n-\n-   package IC renames Interfaces.C;\n-\n-   type PID is new IC.unsigned_long;\n-   type PPID is access all PID;\n-   --  Process ID, and pointer to process ID\n-\n-   type TID is new IC.unsigned_long;\n-   type PTID is access all TID;\n-   --  Thread ID, and pointer to thread ID\n-\n-   -------------------------------------------------------------\n-   -- Thread Creation, Activation, Suspension And Termination --\n-   -------------------------------------------------------------\n-\n-   --  Note: <bsedos.h> defines the \"Informations\" and \"param\" parameter below\n-   --  as a ULONG, but everyone knows that in general an address will be passed\n-   --  to it. We declared it here with type PVOID (which it should have had)\n-   --  because Ada is a bit more sensitive to mixing integers and addresses.\n-\n-   type PFNTHREAD is access procedure (Informations : System.Address);\n-   --  TBSL should use PVOID instead of Address as per above node ???\n-\n-   function DosCreateThread\n-     (F_ptid  : PTID;\n-      pfn     : PFNTHREAD;\n-      param   : PVOID;\n-      flag    : ULONG;\n-      cbStack : ULONG) return APIRET;\n-   pragma Import (C, DosCreateThread, \"DosCreateThread\");\n-\n-   Block_Child     : constant := 1;\n-   No_Block_Child  : constant := 0;\n-   Commit_Stack    : constant := 2;\n-   No_Commit_Stack : constant := 0;\n-   --  Values for \"flag\" parameter in DosCreateThread call\n-\n-   procedure DosExit (Action : ULONG; Result : ULONG);\n-   pragma Import (C, DosExit, \"DosExit\");\n-\n-   EXIT_THREAD  : constant := 0;\n-   EXIT_PROCESS : constant := 1;\n-   --  Values for \"Action\" parameter in Dos_Exit call\n-\n-   function DosResumeThread (Id : TID) return APIRET;\n-   pragma Import (C, DosResumeThread, \"DosResumeThread\");\n-\n-   function DosSuspendThread (Id : TID) return APIRET;\n-   pragma Import (C, DosSuspendThread, \"DosSuspendThread\");\n-\n-   procedure DosWaitThread (Thread_Ptr : PTID; Option : ULONG);\n-   pragma Import (C, DosWaitThread, \"DosWaitThread\");\n-\n-   function DosKillThread (Id : TID) return APIRET;\n-   pragma Import (C, DosKillThread, \"DosKillThread\");\n-\n-   DCWW_WAIT   : constant := 0;\n-   DCWW_NOWAIT : constant := 1;\n-   --  Values for \"Option\" parameter in DosWaitThread call\n-\n-   ---------------------------------------------------\n-   -- Accessing properties of Threads and Processes --\n-   ---------------------------------------------------\n-\n-   --  Structures translated from BSETIB.H\n-\n-   --  Thread Information Block (TIB)\n-   --  Need documentation clarifying distinction between TIB, TIB2 ???\n-\n-   --  GB970409: Changed TIB2 structure, because the tib2_ulprio field\n-   --            is not the actual priority but contains two byte fields\n-   --            that hold the priority class and rank respectively.\n-   --            A proper Ada style record with explicit representation\n-   --            avoids this kind of errors.\n-\n-   type TIB2 is record\n-      Thread_ID           : TID;\n-      Prio_Rank           : UCHAR;\n-      Prio_Class          : UCHAR;\n-      Version             : ULONG;  -- Version number for this structure\n-      Must_Complete_Count : USHORT; -- Must Complete count\n-      Must_Complete_Force : USHORT; -- Must Complete force flag\n-   end record;\n-\n-   type PTIB2 is access all TIB2;\n-\n-   --  Thread Information Block (TIB)\n-\n-   type TIB is record\n-      tib_pexchain      : PVOID;  -- Head of exception handler chain\n-      tib_pstack        : PVOID;  -- Pointer to base of stack\n-      tib_pstacklimit   : PVOID;  -- Pointer to end of stack\n-      System            : PTIB2;  -- Pointer to system specific TIB\n-      tib_version       : ULONG;  -- Version number for this TIB structure\n-      tib_ordinal       : ULONG;  -- Thread ordinal number\n-   end record;\n-\n-   type PTIB is access all TIB;\n-\n-   --  Process Information Block (PIB)\n-\n-   type PIB is record\n-      pib_ulpid         : ULONG;   -- Process I.D.\n-      pib_ulppid        : ULONG;   -- Parent process I.D.\n-      pib_hmte          : ULONG;   -- Program (.EXE) module handle\n-      pib_pchcmd        : PCHAR;   -- Command line pointer\n-      pib_pchenv        : PCHAR;   -- Environment pointer\n-      pib_flstatus      : ULONG;   -- Process' status bits\n-      pib_ultype        : ULONG;   -- Process' type code\n-   end record;\n-\n-   type PPIB is access all PIB;\n-\n-   function DosGetInfoBlocks\n-     (Pptib : access PTIB;\n-      Pppib : access PPIB) return APIRET;\n-   pragma Import (C, DosGetInfoBlocks, \"DosGetInfoBlocks\");\n-\n-   --  Thread local memory\n-\n-   --  This function allocates a block of memory that is unique, or local, to\n-   --  a thread.\n-\n-   function DosAllocThreadLocalMemory\n-     (cb : ULONG;               -- Number of 4-byte DWORDs to allocate\n-      p  : access PVOID)        -- Address of the memory block\n-      return APIRET;                   -- Return Code (rc)\n-   pragma Import\n-     (Convention => C,\n-      Entity     => DosAllocThreadLocalMemory,\n-      Link_Name  => \"_DosAllocThreadLocalMemory\");\n-\n-   ----------------\n-   -- Priorities --\n-   ----------------\n-\n-   function DosSetPriority\n-     (Scope   : ULONG;\n-      Class   : ULONG;\n-      Delta_P : IC.long;\n-      PorTid  : TID) return APIRET;\n-   pragma Import (C, DosSetPriority, \"DosSetPriority\");\n-\n-   PRTYS_PROCESS     : constant := 0;\n-   PRTYS_PROCESSTREE : constant := 1;\n-   PRTYS_THREAD      : constant := 2;\n-   --  Values for \"Scope\" parameter in DosSetPriority call\n-\n-   PRTYC_NOCHANGE         : constant := 0;\n-   PRTYC_IDLETIME         : constant := 1;\n-   PRTYC_REGULAR          : constant := 2;\n-   PRTYC_TIMECRITICAL     : constant := 3;\n-   PRTYC_FOREGROUNDSERVER : constant := 4;\n-   --  Values for \"class\" parameter in DosSetPriority call\n-\n-end Interfaces.OS2Lib.Threads;"}, {"sha": "71b20fc6dbd57d931a27fc3790e46494abbc0782", "filename": "gcc/ada/s-intman-irix-athread.adb", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-intman-irix-athread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-intman-irix-athread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-irix-athread.adb?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,163 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n---                                                                          --\n---           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2005, AdaCore                     --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is an Irix (old pthread library) version of this package.\n-\n---  Make a careful study of all signals available under the OS,\n---  to see which need to be reserved, kept always unmasked,\n---  or kept always unmasked.\n-\n---  Be on the lookout for special signals that\n---  may be used by the thread library.\n-\n-with System.OS_Interface;\n---  used for various Constants, Signal and types\n-\n-with Interfaces.C;\n---  used for \"int\"\n-\n-package body System.Interrupt_Management is\n-\n-   use System.OS_Interface;\n-\n-   type Interrupt_List is array (Interrupt_ID range <>) of Interrupt_ID;\n-\n-   Exception_Interrupts : constant Interrupt_List :=\n-     (SIGILL,\n-      SIGABRT,\n-      SIGFPE,\n-      SIGSEGV,\n-      SIGBUS);\n-\n-   Reserved_Interrupts : constant Interrupt_List :=\n-     (0,\n-      SIGTRAP,\n-      SIGKILL,\n-      SIGSYS,\n-      SIGALRM,\n-      SIGSTOP,\n-      SIGPTINTR,\n-      SIGPTRESCHED);\n-\n-   Abort_Signal : constant := 48;\n-   --\n-   --  Serious MOJO:  The SGI pthreads library only supports the\n-   --                 unnamed signal number 48 for pthread_kill!\n-   --\n-\n-   Unreserve_All_Interrupts : Interfaces.C.int;\n-   pragma Import\n-     (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");\n-\n-   function State (Int : Interrupt_ID) return Character;\n-   pragma Import (C, State, \"__gnat_get_interrupt_state\");\n-   --  Get interrupt state.  Defined in a-init.c\n-   --  The input argument is the interrupt number,\n-   --  and the result is one of the following:\n-\n-   User    : constant Character := 'u';\n-   Runtime : constant Character := 'r';\n-   Default : constant Character := 's';\n-   --    'n'   this interrupt not set by any Interrupt_State pragma\n-   --    'u'   Interrupt_State pragma set state to User\n-   --    'r'   Interrupt_State pragma set state to Runtime\n-   --    's'   Interrupt_State pragma set state to System (use \"default\"\n-   --           system handler)\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize is\n-      use Interfaces.C;\n-   begin\n-      Abort_Task_Interrupt := Abort_Signal;\n-\n-      pragma Assert (Keep_Unmasked = (Interrupt_ID'Range => False));\n-      pragma Assert (Reserve = (Interrupt_ID'Range => False));\n-\n-      --  Process state of exception signals\n-\n-      for J in Exception_Interrupts'Range loop\n-         if State (Exception_Interrupts (J)) /= User then\n-            Keep_Unmasked (Exception_Interrupts (J)) := True;\n-            Reserve (Exception_Interrupts (J)) := True;\n-         end if;\n-      end loop;\n-\n-      if State (Abort_Task_Interrupt) /= User then\n-         Keep_Unmasked (Abort_Task_Interrupt) := True;\n-         Reserve (Abort_Task_Interrupt) := True;\n-      end if;\n-\n-      --  Set SIGINT to unmasked state as long as it's\n-      --  not in \"User\" state.  Check for Unreserve_All_Interrupts last\n-\n-      if State (SIGINT) /= User then\n-         Keep_Unmasked (SIGINT) := True;\n-      end if;\n-\n-      --  Check all signals for state that requires keeping them\n-      --  unmasked and reserved\n-\n-      for J in Interrupt_ID'Range loop\n-         if State (J) = Default or else State (J) = Runtime then\n-            Keep_Unmasked (J) := True;\n-            Reserve (J) := True;\n-         end if;\n-      end loop;\n-\n-      --  Add target-specific reserved signals\n-\n-      for J in Reserved_Interrupts'Range loop\n-         Reserve (Interrupt_ID (Reserved_Interrupts (J))) := True;\n-      end loop;\n-\n-      --  Process pragma Unreserve_All_Interrupts. This overrides any\n-      --  settings due to pragma Interrupt_State:\n-\n-      if Unreserve_All_Interrupts /= 0 then\n-         Keep_Unmasked (SIGINT) := False;\n-         Reserve (SIGINT) := False;\n-      end if;\n-\n-      --  We do not have Signal 0 in reality. We just use this value\n-      --  to identify not existing signals (see s-intnam.ads). Therefore,\n-      --  Signal 0 should not be used in all signal related operations hence\n-      --  mark it as reserved.\n-\n-      Reserve (0) := True;\n-   end Initialize;\n-\n-end System.Interrupt_Management;"}, {"sha": "72e251a56f55d0702b0c0b04182d8eb30e4a6a83", "filename": "gcc/ada/s-osinte-aix-fsu.ads", "status": "removed", "additions": 0, "deletions": 589, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-aix-fsu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-aix-fsu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-aix-fsu.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,589 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2005, Free Software Foundation, Inc.      --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a AIX (FSU THREADS) version of this package\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by children of System.\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Interfaces.C;\n-with Unchecked_Conversion;\n-\n-package System.OS_Interface is\n-   pragma Preelaborate;\n-   --  pragma Elaborate_Body;\n-\n-   pragma Linker_Options (\"-lgthreads\");\n-   pragma Linker_Options (\"-lmalloc\");\n-\n-   subtype int            is Interfaces.C.int;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EAGAIN    : constant := 11;\n-   EINTR     : constant := 4;\n-   EINVAL    : constant := 22;\n-   ENOMEM    : constant := 12;\n-   ETIMEDOUT : constant := 78;\n-\n-   -------------\n-   -- Signals --\n-   -------------\n-\n-   Max_Interrupt : constant := 63;\n-   type Signal is new int range 0 .. Max_Interrupt;\n-   for Signal'Size use int'Size;\n-\n-   SIGHUP      : constant := 1; --  hangup\n-   SIGINT      : constant := 2; --  interrupt (rubout)\n-   SIGQUIT     : constant := 3; --  quit (ASCD FS)\n-   SIGILL      : constant := 4; --  illegal instruction (not reset)\n-   SIGTRAP     : constant := 5; --  trace trap (not reset)\n-   SIGIOT      : constant := 6; --  IOT instruction\n-   SIGABRT     : constant := 6; --  used by abort, replace SIGIOT in the future\n-   SIGEMT      : constant := 7; --  EMT instruction\n-   SIGFPE      : constant := 8; --  floating point exception\n-   SIGKILL     : constant := 9; --  kill (cannot be caught or ignored)\n-   SIGBUS      : constant := 10; --  bus error\n-   SIGSEGV     : constant := 11; --  segmentation violation\n-   SIGSYS      : constant := 12; --  bad argument to system call\n-   SIGPIPE     : constant := 13; --  write on a pipe with no one to read it\n-   SIGALRM     : constant := 14; --  alarm clock\n-   SIGTERM     : constant := 15; --  software termination signal from kill\n-   SIGUSR1     : constant := 30; --  user defined signal 1\n-   SIGUSR2     : constant := 31; --  user defined signal 2\n-   SIGCLD      : constant := 20; --  alias for SIGCHLD\n-   SIGCHLD     : constant := 20; --  child status change\n-   SIGPWR      : constant := 29; --  power-fail restart\n-   SIGWINCH    : constant := 28; --  window size change\n-   SIGURG      : constant := 16; --  urgent condition on IO channel\n-   SIGPOLL     : constant := 23; --  pollable event occurred\n-   SIGIO       : constant := 23; --  I/O possible (Solaris SIGPOLL alias)\n-   SIGSTOP     : constant := 17; --  stop (cannot be caught or ignored)\n-   SIGTSTP     : constant := 18; --  user stop requested from tty\n-   SIGCONT     : constant := 19; --  stopped process has been continued\n-   SIGTTIN     : constant := 21; --  background tty read attempted\n-   SIGTTOU     : constant := 22; --  background tty write attempted\n-   SIGVTALRM   : constant := 34; --  virtual timer expired\n-   SIGPROF     : constant := 32; --  profiling timer expired\n-   SIGXCPU     : constant := 24; --  CPU time limit exceeded\n-   SIGXFSZ     : constant := 25; --  filesize limit exceeded\n-   SIGWAITING  : constant := 39; --  m:n scheduling\n-\n-   --  the following signals are AIX specific\n-   SIGMSG      : constant := 27; -- input data is in the ring buffer\n-   SIGDANGER   : constant := 33; -- system crash imminent\n-   SIGMIGRATE  : constant := 35; -- migrate process\n-   SIGPRE      : constant := 36; -- programming exception\n-   SIGVIRT     : constant := 37; -- AIX virtual time alarm\n-   SIGALRM1    : constant := 38; -- m:n condition variables\n-   SIGKAP      : constant := 60; -- keep alive poll from native keyboard\n-   SIGGRANT    : constant := SIGKAP; -- monitor mode granted\n-   SIGRETRACT  : constant := 61; -- monitor mode should be relinguished\n-   SIGSOUND    : constant := 62; -- sound control has completed\n-   SIGSAK      : constant := 63; -- secure attention key\n-\n-   SIGADAABORT : constant := SIGABRT;\n-\n-   type Signal_Set is array (Natural range <>) of Signal;\n-\n-   Unmasked    : constant Signal_Set :=\n-     (SIGTRAP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF);\n-   Reserved    : constant Signal_Set :=\n-     (SIGKILL, SIGSTOP, SIGALRM, SIGWAITING);\n-\n-   type sigset_t is private;\n-\n-   function sigaddset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigaddset, \"sigaddset\");\n-\n-   function sigdelset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigdelset, \"sigdelset\");\n-\n-   function sigfillset (set : access sigset_t) return int;\n-   pragma Import (C, sigfillset, \"sigfillset\");\n-\n-   function sigismember (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigismember, \"sigismember\");\n-\n-   function sigemptyset (set : access sigset_t) return int;\n-   pragma Import (C, sigemptyset, \"sigemptyset\");\n-\n-   type struct_sigaction is record\n-      sa_handler : System.Address;\n-      sa_mask    : sigset_t;\n-      sa_flags   : int;\n-   end record;\n-   pragma Convention (C, struct_sigaction);\n-   type struct_sigaction_ptr is access all struct_sigaction;\n-\n-   SA_SIGINFO  : constant := 16#0100#;\n-\n-   SIG_BLOCK   : constant := 0;\n-   SIG_UNBLOCK : constant := 1;\n-   SIG_SETMASK : constant := 2;\n-\n-   SIG_DFL : constant := 0;\n-   SIG_IGN : constant := 1;\n-\n-   function sigaction\n-     (sig  : Signal;\n-      act  : struct_sigaction_ptr;\n-      oact : struct_sigaction_ptr) return int;\n-   pragma Import (C, sigaction, \"_internal_sigaction\");\n-\n-   ----------\n-   -- Time --\n-   ----------\n-\n-   Time_Slice_Supported : constant Boolean := True;\n-   --  Indicates wether time slicing is supported (i.e FSU threads have been\n-   --  compiled with DEF_RR)\n-\n-   type timespec is private;\n-\n-   type clockid_t is private;\n-\n-   CLOCK_REALTIME : constant clockid_t;\n-\n-   function clock_gettime\n-     (clock_id : clockid_t;\n-      tp       : access timespec) return int;\n-   pragma Import (C, clock_gettime, \"clock_gettime\");\n-\n-   function To_Duration (TS : timespec) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timespec (D : Duration) return timespec;\n-   pragma Inline (To_Timespec);\n-\n-   type struct_timeval is private;\n-\n-   function To_Duration (TV : struct_timeval) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timeval (D : Duration) return struct_timeval;\n-   pragma Inline (To_Timeval);\n-\n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   SCHED_FIFO  : constant := 0;\n-   SCHED_RR    : constant := 1;\n-   SCHED_OTHER : constant := 2;\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   type pid_t is private;\n-\n-   function kill (pid : pid_t; sig : Signal) return int;\n-   pragma Import (C, kill, \"kill\");\n-\n-   function getpid return pid_t;\n-   pragma Import (C, getpid, \"getpid\");\n-\n-   ---------\n-   -- LWP --\n-   ---------\n-\n-   function lwp_self return System.Address;\n-   --  lwp_self does not exist on this thread library, revert to pthread_self\n-   --  which is the closest approximation (with getpid). This function is\n-   --  needed to share 7staprop.adb across POSIX-like targets.\n-   pragma Import (C, lwp_self, \"pthread_self\");\n-\n-   -------------\n-   -- Threads --\n-   -------------\n-\n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n-\n-   function Thread_Body_Access is new\n-     Unchecked_Conversion (System.Address, Thread_Body);\n-\n-   type pthread_t           is private;\n-   subtype Thread_Id        is pthread_t;\n-\n-   type pthread_mutex_t     is limited private;\n-   type pthread_cond_t      is limited private;\n-   type pthread_attr_t      is limited private;\n-   type pthread_mutexattr_t is limited private;\n-   type pthread_condattr_t  is limited private;\n-   type pthread_key_t       is private;\n-\n-   PTHREAD_CREATE_DETACHED : constant := 1;\n-\n-   -----------\n-   -- Stack --\n-   -----------\n-\n-   Stack_Base_Available : constant Boolean := True;\n-   --  Indicates wether the stack base is available on this target.\n-   --  This allows us to share s-osinte.adb between all the FSU run time.\n-   --  Note that this value can only be true if pthread_t has a complete\n-   --  definition that corresponds exactly to the C header files.\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address;\n-   pragma Inline (Get_Stack_Base);\n-   --  returns the stack base of the specified thread.\n-   --  Only call this function when Stack_Base_Available is True.\n-\n-   function Get_Page_Size return size_t;\n-   function Get_Page_Size return Address;\n-   pragma Import (C, Get_Page_Size, \"getpagesize\");\n-   --  returns the size of a page, or 0 if this is not relevant on this\n-   --  target\n-\n-   PROT_NONE  : constant := 0;\n-   PROT_READ  : constant := 1;\n-   PROT_WRITE : constant := 2;\n-   PROT_EXEC  : constant := 4;\n-   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n-\n-   PROT_ON    : constant := PROT_READ;\n-   PROT_OFF   : constant := PROT_ALL;\n-\n-   function mprotect (addr : Address; len : size_t; prot : int) return int;\n-   pragma Import (C, mprotect);\n-\n-   ---------------------------------------\n-   -- Nonstandard Thread Initialization --\n-   ---------------------------------------\n-\n-   procedure pthread_init;\n-   --  FSU_THREADS requires pthread_init, which is nonstandard\n-   --  and this should be invoked during the elaboration of s-taprop.adb\n-   pragma Import (C, pthread_init, \"pthread_init\");\n-\n-   -------------------------\n-   -- POSIX.1c  Section 3 --\n-   -------------------------\n-\n-   function sigwait\n-     (set : access sigset_t;\n-      sig : access Signal) return int;\n-   --  FSU_THREADS has a nonstandard sigwait\n-\n-   function pthread_kill\n-     (thread : pthread_t;\n-      sig    : Signal) return int;\n-   pragma Import (C, pthread_kill, \"pthread_kill\");\n-\n-   --  FSU threads does not have pthread_sigmask. Instead, it redefines\n-   --  sigprocmask and then uses a special syscall API to call the system\n-   --  version. Doing syscalls on AiX is very difficult, so we rename the\n-   --  pthread version instead.\n-\n-   type sigset_t_ptr is access all sigset_t;\n-\n-   function pthread_sigmask\n-     (how  : int;\n-      set  : sigset_t_ptr;\n-      oset : sigset_t_ptr) return int;\n-   pragma Import (C, pthread_sigmask, \"_internal_sigprocmask\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 11 --\n-   --------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n-\n-   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n-\n-   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n-   --  FSU_THREADS has nonstandard pthread_mutex_lock\n-\n-   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n-   --  FSU_THREADS has nonstandard pthread_mutex_lock\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   --  FSU_THREADS has a nonstandard pthread_cond_wait\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      abstime : access timespec) return int;\n-   --  FSU_THREADS has a nonstandard pthread_cond_timedwait\n-\n-   Relative_Timed_Wait : constant Boolean := False;\n-   --  pthread_cond_timedwait requires an absolute delay time\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   PTHREAD_PRIO_NONE    : constant := 0;\n-   PTHREAD_PRIO_PROTECT : constant := 2;\n-   PTHREAD_PRIO_INHERIT : constant := 1;\n-\n-   function pthread_mutexattr_setprotocol\n-     (attr     : access pthread_mutexattr_t;\n-      protocol : int) return int;\n-   pragma Import (C, pthread_mutexattr_setprotocol);\n-\n-   function pthread_mutexattr_setprioceiling\n-     (attr        : access pthread_mutexattr_t;\n-      prioceiling : int) return int;\n-   pragma Import\n-     (C, pthread_mutexattr_setprioceiling,\n-         \"pthread_mutexattr_setprio_ceiling\");\n-\n-   type struct_sched_param is record\n-      sched_priority : int;  --  scheduling priority\n-   end record;\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int;\n-   --  FSU_THREADS does not have pthread_setschedparam\n-\n-   function pthread_attr_setscope\n-     (attr            : access pthread_attr_t;\n-      contentionscope : int) return int;\n-   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n-\n-   function pthread_attr_setinheritsched\n-     (attr         : access pthread_attr_t;\n-      inheritsched : int) return int;\n-   pragma Import (C, pthread_attr_setinheritsched);\n-\n-   function pthread_attr_setschedpolicy\n-     (attr   : access pthread_attr_t;\n-      policy : int) return int;\n-   pragma Import (C, pthread_attr_setschedpolicy, \"pthread_attr_setsched\");\n-\n-   function sched_yield return int;\n-   --  FSU_THREADS does not have sched_yield;\n-\n-   ---------------------------\n-   -- P1003.1c - Section 16 --\n-   ---------------------------\n-\n-   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n-\n-   function pthread_attr_destroy\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int;\n-   --  FSU_THREADS has a nonstandard pthread_attr_setdetachstate\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize);\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attributes    : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int;\n-   pragma Import (C, pthread_create, \"pthread_create\");\n-\n-   procedure pthread_exit (status : System.Address);\n-   pragma Import (C, pthread_exit, \"pthread_exit\");\n-\n-   function pthread_self return pthread_t;\n-   pragma Import (C, pthread_self, \"pthread_self\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return int;\n-   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address;\n-   --  FSU_THREADS has a nonstandard pthread_getspecific\n-\n-   type destructor_pointer is access procedure (arg : System.Address);\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer) return int;\n-   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n-\n-private\n-\n-   type sigset_t is record\n-      losigs : unsigned_long;\n-      hisigs : unsigned_long;\n-   end record;\n-   pragma Convention (C_Pass_By_Copy, sigset_t);\n-\n-   type pid_t is new int;\n-\n-   type time_t is new long;\n-\n-   type timespec is record\n-      tv_sec  : time_t;\n-      tv_nsec : long;\n-   end record;\n-   pragma Convention (C, timespec);\n-\n-   type clockid_t is new int;\n-   CLOCK_REALTIME : constant clockid_t := 0;\n-\n-   type struct_timeval is record\n-      tv_sec  : long;\n-      tv_usec : long;\n-   end record;\n-   pragma Convention (C, struct_timeval);\n-\n-   type pthread_attr_t is record\n-      flags           : int;\n-      stacksize       : int;\n-      contentionscope : int;\n-      inheritsched    : int;\n-      detachstate     : int;\n-      sched           : int;\n-      prio            : int;\n-      starttime       : timespec;\n-      deadline        : timespec;\n-      period          : timespec;\n-   end record;\n-   pragma Convention (C_Pass_By_Copy, pthread_attr_t);\n-\n-   type pthread_condattr_t is record\n-      flags : int;\n-   end record;\n-   pragma Convention (C, pthread_condattr_t);\n-\n-   type pthread_mutexattr_t is record\n-      flags        : int;\n-      prio_ceiling : int;\n-      protocol     : int;\n-   end record;\n-   pragma Convention (C, pthread_mutexattr_t);\n-\n-   type sigjmp_buf is array (Integer range 0 .. 63) of int;\n-\n-   type pthread_t_struct is record\n-      context    : sigjmp_buf;\n-      pbody      : sigjmp_buf;\n-      errno      : int;\n-      ret        : int;\n-      stack_base : System.Address;\n-   end record;\n-   pragma Convention (C, pthread_t_struct);\n-\n-   type pthread_t is access all pthread_t_struct;\n-\n-   type queue_t is record\n-      head : System.Address;\n-      tail : System.Address;\n-   end record;\n-   pragma Convention (C, queue_t);\n-\n-   type pthread_mutex_t is record\n-      queue        : queue_t;\n-      lock         : plain_char;\n-      owner        : System.Address;\n-      flags        : int;\n-      prio_ceiling : int;\n-      protocol     : int;\n-      prev_max_ceiling_prio  : int;\n-   end record;\n-   pragma Convention (C, pthread_mutex_t);\n-\n-   type pthread_cond_t is record\n-      queue   : queue_t;\n-      flags   : int;\n-      waiters : int;\n-      mutex   : System.Address;\n-   end record;\n-   pragma Convention (C, pthread_cond_t);\n-\n-   type pthread_key_t is new int;\n-\n-end System.OS_Interface;"}, {"sha": "f5ebf934326e0398753a3bca6016f96d0adaade5", "filename": "gcc/ada/s-osinte-fsu.adb", "status": "removed", "additions": 0, "deletions": 366, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-fsu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-fsu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-fsu.adb?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,366 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2005, AdaCore                     --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a FSU Threads version of this package\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during\n---  tasking operations. It causes infinite loops and other problems.\n-\n-with Interfaces.C;\n-\n-package body System.OS_Interface is\n-\n-   use Interfaces.C;\n-\n-   -----------------\n-   -- To_Duration --\n-   -----------------\n-\n-   function To_Duration (TS : timespec) return Duration is\n-   begin\n-      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n-   end To_Duration;\n-\n-   function To_Duration (TV : struct_timeval) return Duration is\n-   begin\n-      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n-   end To_Duration;\n-\n-   -----------------\n-   -- To_Timespec --\n-   -----------------\n-\n-   function To_Timespec (D : Duration) return timespec is\n-      S : time_t;\n-      F : Duration;\n-\n-   begin\n-      S := time_t (Long_Long_Integer (D));\n-      F := D - Duration (S);\n-\n-      --  If F has negative value due to a round-up, adjust for positive F\n-      --  value.\n-\n-      if F < 0.0 then\n-         S := S - 1;\n-         F := F + 1.0;\n-      end if;\n-\n-      return timespec'(tv_sec  => S,\n-                       tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n-   end To_Timespec;\n-\n-   ----------------\n-   -- To_Timeval --\n-   ----------------\n-\n-   function To_Timeval (D : Duration) return struct_timeval is\n-      S : long;\n-      F : Duration;\n-\n-   begin\n-      S := long (Long_Long_Integer (D));\n-      F := D - Duration (S);\n-\n-      --  If F has negative value due to a round-up, adjust for positive F\n-      --  value.\n-\n-      if F < 0.0 then\n-         S := S - 1;\n-         F := F + 1.0;\n-      end if;\n-\n-      return\n-        struct_timeval'\n-          (tv_sec  => S,\n-           tv_usec => long (Long_Long_Integer (F * 10#1#E6)));\n-   end To_Timeval;\n-\n-   -------------\n-   -- sigwait --\n-   -------------\n-\n-   --  FSU_THREADS has a nonstandard sigwait\n-\n-   function sigwait\n-     (set  : access sigset_t;\n-      sig  : access Signal) return int\n-   is\n-      Result : int;\n-\n-      function sigwait_base (set : access sigset_t) return int;\n-      pragma Import (C, sigwait_base, \"sigwait\");\n-\n-   begin\n-      Result := sigwait_base (set);\n-\n-      if Result = -1 then\n-         sig.all := 0;\n-         return errno;\n-      end if;\n-\n-      sig.all := Signal (Result);\n-      return 0;\n-   end sigwait;\n-\n-   ------------------------\n-   -- pthread_mutex_lock --\n-   ------------------------\n-\n-   --  FSU_THREADS has nonstandard pthread_mutex_lock and unlock.\n-   --  It sets errno but the standard Posix requires it to be returned.\n-\n-   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int is\n-      function pthread_mutex_lock_base\n-        (mutex : access pthread_mutex_t) return int;\n-      pragma Import (C, pthread_mutex_lock_base, \"pthread_mutex_lock\");\n-\n-      Result : int;\n-\n-   begin\n-      Result := pthread_mutex_lock_base (mutex);\n-\n-      if Result /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_mutex_lock;\n-\n-   --------------------------\n-   -- pthread_mutex_unlock --\n-   --------------------------\n-\n-   function pthread_mutex_unlock\n-     (mutex : access pthread_mutex_t) return int\n-   is\n-      function pthread_mutex_unlock_base\n-        (mutex : access pthread_mutex_t) return int;\n-      pragma Import (C, pthread_mutex_unlock_base, \"pthread_mutex_unlock\");\n-\n-      Result : int;\n-\n-   begin\n-      Result := pthread_mutex_unlock_base (mutex);\n-\n-      if Result /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_mutex_unlock;\n-\n-   -----------------------\n-   -- pthread_cond_wait --\n-   -----------------------\n-\n-   --  FSU_THREADS has a nonstandard pthread_cond_wait.\n-   --  The FSU_THREADS version returns EINTR when interrupted.\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int\n-   is\n-      function pthread_cond_wait_base\n-        (cond  : access pthread_cond_t;\n-         mutex : access pthread_mutex_t) return int;\n-      pragma Import (C, pthread_cond_wait_base, \"pthread_cond_wait\");\n-\n-      Result : int;\n-\n-   begin\n-      Result := pthread_cond_wait_base (cond, mutex);\n-\n-      if Result = EINTR then\n-         return 0;\n-      else\n-         return Result;\n-      end if;\n-   end pthread_cond_wait;\n-\n-   ----------------------------\n-   -- pthread_cond_timedwait --\n-   ----------------------------\n-\n-   --  FSU_THREADS has a nonstandard pthread_cond_timedwait. The\n-   --  FSU_THREADS version returns -1 and set errno to EAGAIN for timeout.\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      abstime : access timespec) return int\n-   is\n-      function pthread_cond_timedwait_base\n-        (cond    : access pthread_cond_t;\n-         mutex   : access pthread_mutex_t;\n-         abstime : access timespec) return int;\n-      pragma Import (C, pthread_cond_timedwait_base, \"pthread_cond_timedwait\");\n-\n-      Result : int;\n-\n-   begin\n-      Result := pthread_cond_timedwait_base (cond, mutex, abstime);\n-\n-      if Result = -1 then\n-         if errno = EAGAIN then\n-            return ETIMEDOUT;\n-         else\n-            return EINVAL;\n-         end if;\n-      end if;\n-\n-      return 0;\n-   end pthread_cond_timedwait;\n-\n-   ---------------------------\n-   -- pthread_setschedparam --\n-   ---------------------------\n-\n-   --  FSU_THREADS does not have pthread_setschedparam\n-\n-   --  This routine returns a non-negative value upon failure but the error\n-   --  code cannot be set conforming the POSIX standard.\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int\n-   is\n-      function pthread_setschedattr\n-        (thread : pthread_t;\n-         attr   : pthread_attr_t) return int;\n-      pragma Import (C, pthread_setschedattr, \"pthread_setschedattr\");\n-\n-      attr   : aliased pthread_attr_t;\n-      Result : int;\n-\n-   begin\n-      Result := pthread_attr_init (attr'Access);\n-\n-      if Result /= 0 then\n-         return Result;\n-      end if;\n-\n-      attr.sched := policy;\n-\n-      --  Short-cut around pthread_attr_setprio\n-\n-      attr.prio := param.sched_priority;\n-\n-      Result := pthread_setschedattr (thread, attr);\n-\n-      if Result /= 0 then\n-         return Result;\n-      end if;\n-\n-      Result := pthread_attr_destroy (attr'Access);\n-\n-      if Result /= 0 then\n-         return Result;\n-      else\n-         return 0;\n-      end if;\n-   end pthread_setschedparam;\n-\n-   -------------------------\n-   -- pthread_getspecific --\n-   -------------------------\n-\n-   --  FSU_THREADS has a nonstandard pthread_getspecific\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address is\n-      function pthread_getspecific_base\n-        (key   : pthread_key_t;\n-         value : access System.Address) return int;\n-      pragma Import (C, pthread_getspecific_base, \"pthread_getspecific\");\n-\n-      Tmp    : aliased System.Address;\n-      Result : int;\n-\n-   begin\n-      Result := pthread_getspecific_base (key, Tmp'Access);\n-\n-      if Result /= 0 then\n-         return System.Null_Address;\n-      end if;\n-\n-      return Tmp;\n-   end pthread_getspecific;\n-\n-   ---------------------------------\n-   -- pthread_attr_setdetachstate --\n-   ---------------------------------\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int\n-   is\n-      function pthread_attr_setdetachstate_base\n-        (attr        : access pthread_attr_t;\n-         detachstate : access int) return int;\n-      pragma Import\n-        (C, pthread_attr_setdetachstate_base, \"pthread_attr_setdetachstate\");\n-\n-      Tmp : aliased int := detachstate;\n-\n-   begin\n-      return pthread_attr_setdetachstate_base (attr, Tmp'Access);\n-   end pthread_attr_setdetachstate;\n-\n-   -----------------\n-   -- sched_yield --\n-   -----------------\n-\n-   --  FSU_THREADS does not have sched_yield;\n-\n-   function sched_yield return int is\n-      procedure sched_yield_base (arg : System.Address);\n-      pragma Import (C, sched_yield_base, \"pthread_yield\");\n-\n-   begin\n-      sched_yield_base (System.Null_Address);\n-      return 0;\n-   end sched_yield;\n-\n-   ----------------\n-   -- Stack_Base --\n-   ----------------\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address is\n-   begin\n-      return thread.stack_base;\n-   end Get_Stack_Base;\n-\n-end System.OS_Interface;"}, {"sha": "b8d65a81f80e90a947fa08698c84bb80168bef17", "filename": "gcc/ada/s-osinte-irix-athread.ads", "status": "removed", "additions": 0, "deletions": 699, "changes": 699, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-irix-athread.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-irix-athread.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-irix-athread.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,699 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2005, Free Software Foundation, Inc.      --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is an Irix (old pthread library) version of this package\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by children of System.\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Interfaces;\n-with Interfaces.C;\n-with Interfaces.C.Strings;\n-with Unchecked_Conversion;\n-\n-package System.OS_Interface is\n-\n-   pragma Preelaborate;\n-\n-   pragma Linker_Options (\"-lathread\");\n-\n-   subtype int            is Interfaces.C.int;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-   subtype chars_ptr      is Interfaces.C.Strings.chars_ptr;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EINTR     : constant := 4;   --  interrupted system call\n-   EAGAIN    : constant := 11;  --  No more processes\n-   ENOMEM    : constant := 12;  --  Not enough core\n-   EINVAL    : constant := 22;  --  Invalid argument\n-   ETIMEDOUT : constant := 145; --  Connection timed out\n-\n-   -------------\n-   -- Signals --\n-   -------------\n-\n-   Max_Interrupt : constant := 64;\n-   type Signal is new int range 0 .. Max_Interrupt;\n-   for Signal'Size use int'Size;\n-\n-   SIGHUP     : constant := 1; --  hangup\n-   SIGINT     : constant := 2; --  interrupt (rubout)\n-   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n-   SIGILL     : constant := 4; --  illegal instruction (not reset)\n-   SIGTRAP    : constant := 5; --  trace trap (not reset)\n-   SIGIOT     : constant := 6; --  IOT instruction\n-   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the\n-   --                              future\n-   SIGEMT     : constant := 7; --  EMT instruction\n-   SIGFPE     : constant := 8; --  floating point exception\n-   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n-   SIGBUS     : constant := 10; --  bus error\n-   SIGSEGV    : constant := 11; --  segmentation violation\n-   SIGSYS     : constant := 12; --  bad argument to system call\n-   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n-   SIGALRM    : constant := 14; --  alarm clock\n-   SIGTERM    : constant := 15; --  software termination signal from kill\n-   SIGUSR1    : constant := 16; --  user defined signal 1\n-   SIGUSR2    : constant := 17; --  user defined signal 2\n-   SIGCLD     : constant := 18; --  alias for SIGCHLD\n-   SIGCHLD    : constant := 18; --  child status change\n-   SIGPWR     : constant := 19; --  power-fail restart\n-   SIGWINCH   : constant := 20; --  window size change\n-   SIGURG     : constant := 21; --  urgent condition on IO channel\n-   SIGPOLL    : constant := 22; --  pollable event occurred\n-   SIGIO      : constant := 22; --  I/O possible (Solaris SIGPOLL alias)\n-   SIGSTOP    : constant := 23; --  stop (cannot be caught or ignored)\n-   SIGTSTP    : constant := 24; --  user stop requested from tty\n-   SIGCONT    : constant := 25; --  stopped process has been continued\n-   SIGTTIN    : constant := 26; --  background tty read attempted\n-   SIGTTOU    : constant := 27; --  background tty write attempted\n-   SIGVTALRM  : constant := 28; --  virtual timer expired\n-   SIGPROF    : constant := 29; --  profiling timer expired\n-   SIGXCPU    : constant := 30; --  CPU time limit exceeded\n-   SIGXFSZ    : constant := 31; --  filesize limit exceeded\n-   SIGK32     : constant := 32; --  reserved for kernel (IRIX)\n-   SIGCKPT    : constant := 33; --  Checkpoint warning\n-   SIGRESTART : constant := 34; --  Restart warning\n-   SIGUME     : constant := 35; --  Uncorrectable memory error\n-   --  Signals defined for Posix 1003.1c.\n-   SIGPTINTR    : constant := 47;\n-   SIGPTRESCHED : constant := 48;\n-   --  Posix 1003.1b signals\n-   SIGRTMIN   : constant := 49; --  Posix 1003.1b signals\n-   SIGRTMAX   : constant := 64; --  Posix 1003.1b signals\n-\n-   type sigset_t is private;\n-   type sigset_t_ptr is access all sigset_t;\n-\n-   function sigaddset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigaddset, \"sigaddset\");\n-\n-   function sigdelset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigdelset, \"sigdelset\");\n-\n-   function sigfillset (set : access sigset_t) return int;\n-   pragma Import (C, sigfillset, \"sigfillset\");\n-\n-   function sigismember (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigismember, \"sigismember\");\n-\n-   function sigemptyset (set : access sigset_t) return int;\n-   pragma Import (C, sigemptyset, \"sigemptyset\");\n-\n-   type siginfo_t is record\n-      si_signo     : int;\n-      si_code      : int;\n-      si_errno     : int;\n-      bit_field_substitute_1 : String (1 .. 116);\n-   end record;\n-   pragma Convention (C, siginfo_t);\n-\n-   type array_type_2 is array (Integer range 0 .. 1) of int;\n-   type struct_sigaction is record\n-      sa_flags     : int;\n-      sa_handler   : System.Address;\n-      sa_mask      : sigset_t;\n-      sa_resv      : array_type_2;\n-   end record;\n-   pragma Convention (C, struct_sigaction);\n-   type struct_sigaction_ptr is access all struct_sigaction;\n-\n-   SIG_BLOCK   : constant := 1;\n-   SIG_UNBLOCK : constant := 2;\n-   SIG_SETMASK : constant := 3;\n-\n-   SIG_DFL : constant := 0;\n-   SIG_IGN : constant := 1;\n-\n-   function sigaction\n-     (sig  : Signal;\n-      act  : struct_sigaction_ptr;\n-      oact : struct_sigaction_ptr := null) return int;\n-   pragma Import (C, sigaction, \"sigaction\");\n-\n-   ----------\n-   -- Time --\n-   ----------\n-\n-   type time_t is new int;\n-\n-   type timespec is record\n-      tv_sec  : time_t;\n-      tv_nsec : long;\n-   end record;\n-   pragma Convention (C, timespec);\n-   type timespec_ptr is access all timespec;\n-\n-   function To_Duration (TS : timespec) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timespec (D : Duration) return timespec;\n-   pragma Inline (To_Timespec);\n-\n-   type timer_t is new Integer;\n-   type clockid_t is private;\n-\n-   CLOCK_REALTIME  : constant clockid_t;\n-   CLOCK_SGI_FAST  : constant clockid_t;\n-   CLOCK_SGI_CYCLE : constant clockid_t;\n-\n-   SGI_CYCLECNTR_SIZE : constant := 165;\n-   function syssgi (request : Interfaces.C.int) return Interfaces.C.ptrdiff_t;\n-\n-   pragma Import (C, syssgi, \"syssgi\");\n-\n-   function clock_gettime\n-     (clock_id : clockid_t;\n-      tp       : access timespec) return int;\n-   pragma Import (C, clock_gettime, \"clock_gettime\");\n-\n-   function clock_getres\n-     (clock_id : clockid_t; tp : access timespec) return int;\n-   pragma Import (C, clock_getres, \"clock_getres\");\n-\n-   type struct_timeval is record\n-      tv_sec  : time_t;\n-      tv_usec : time_t;\n-   end record;\n-   pragma Convention (C, struct_timeval);\n-\n-   function To_Duration (TV : struct_timeval) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timeval (D : Duration) return struct_timeval;\n-   pragma Inline (To_Timeval);\n-\n-   function gettimeofday\n-     (tv : access struct_timeval;\n-      tz : System.Address := System.Null_Address) return int;\n-   pragma Import (C, gettimeofday, \"gettimeofday\");\n-\n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   SCHED_FIFO  : constant := 0;\n-   SCHED_RR    : constant := 0;\n-   SCHED_OTHER : constant := 0;\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   type pid_t is private;\n-\n-   function kill (pid : pid_t; sig : Signal) return int;\n-   pragma Import (C, kill, \"kill\");\n-\n-   function getpid return pid_t;\n-   pragma Import (C, getpid, \"getpid\");\n-\n-   ---------------------------------------\n-   -- Nonstandard Thread Initialization --\n-   ---------------------------------------\n-\n-   procedure pthread_init;\n-   pragma Inline (pthread_init);\n-   --  This is a dummy procedure to share some GNULLI files\n-\n-   -------------\n-   -- Threads --\n-   -------------\n-\n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n-\n-   function Thread_Body_Access is new\n-     Unchecked_Conversion (System.Address, Thread_Body);\n-\n-   type pthread_t           is private; --   thread identifier\n-   subtype Thread_Id        is pthread_t;\n-\n-   type pthread_mutex_t     is private; --   mutex identifier\n-   type pthread_cond_t      is private; --   cond identifier\n-   type pthread_attr_t      is private; --   pthread attributes\n-   type pthread_mutexattr_t is private; --   mutex attributes\n-   type pthread_condattr_t  is private; --   mutex attributes\n-   type sem_t               is private; --   semaphore identifier\n-   type pthread_key_t       is private; --   per thread key\n-\n-   subtype pthread_once_t   is int;     --   dynamic package initialization\n-   subtype resource_t       is long;    --   sproc. resource info.\n-   type start_addr is access function (arg : Address) return Address;\n-   type sproc_start_addr is access function (arg : Address) return int;\n-   type callout_addr is\n-     access function (arg : Address; arg1 : Address) return Address;\n-\n-   --  SGI specific types\n-\n-   subtype sproc_t      is Address; --   sproc identifier\n-   subtype sproc_attr_t is Address; --   sproc attributes\n-\n-   subtype spcb_p is Address;\n-   subtype ptcb_p is Address;\n-\n-   --  Pthread Error Types\n-\n-   FUNC_OK  : constant := 0;\n-   FUNC_ERR : constant := -1;\n-\n-   --  pthread run-time initialization data structure\n-\n-   type pthread_init_struct is record\n-      conf_initsize       : int; --  shared area size\n-      max_sproc_count     : int; --  maximum number of sprocs\n-      sproc_stack_size    : size_t;  --  sproc stack size\n-      os_default_priority : int; --  default IRIX pri for main process\n-      os_sched_signal     : int; --  default OS scheduling signal\n-      guard_pages         : int; --  number of guard pages per stack\n-      init_sproc_count    : int; --  initial number of sprocs\n-   end record;\n-\n-   --\n-   --  Pthread Attribute Initialize / Destroy\n-   --\n-\n-   function pthread_attr_init (attr : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n-\n-   function pthread_attr_destroy (attr : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n-\n-   --\n-   --  Thread Attributes\n-   --\n-\n-   function pthread_attr_setstacksize\n-     (attr : access pthread_attr_t; stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n-\n-   function pthread_attr_setdetachstate\n-     (attr : access pthread_attr_t; detachstate : int) return int;\n-   pragma Import (C, pthread_attr_setdetachstate);\n-\n-   function pthread_attr_setname\n-     (attr : access pthread_attr_t; name : chars_ptr) return int;\n-   pragma Import (C, pthread_attr_setname, \"pthread_attr_setname\");\n-\n-   --\n-   --  Thread Scheduling Attributes\n-   --\n-\n-   function pthread_attr_setscope\n-     (attr : access pthread_attr_t; contentionscope : int) return int;\n-   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n-\n-   function pthread_attr_setinheritsched\n-     (attr : access pthread_attr_t; inherit : int) return int;\n-   pragma Import\n-     (C, pthread_attr_setinheritsched, \"pthread_attr_setinheritsched\");\n-\n-   function pthread_attr_setsched\n-     (attr : access pthread_attr_t; scheduler : int) return int;\n-   pragma Import (C, pthread_attr_setsched, \"pthread_attr_setsched\");\n-\n-   function  pthread_attr_setprio\n-     (attr : access pthread_attr_t; priority : int) return int;\n-   pragma Import (C, pthread_attr_setprio, \"pthread_attr_setprio\");\n-\n-   --\n-   --  SGI Extensions to Thread Attributes\n-   --\n-\n-   --  Bound to sproc attribute values\n-\n-   PTHREAD_BOUND     : constant := 1;\n-   PTHREAD_NOT_BOUND : constant := 0;\n-\n-   function pthread_attr_setresources\n-     (attr : access pthread_attr_t; resources : resource_t) return int;\n-   pragma Import (C, pthread_attr_setresources, \"pthread_attr_setresources\");\n-\n-   function pthread_attr_set_boundtosproc\n-     (attr : access pthread_attr_t; bound_to_sproc : int) return int;\n-   pragma Import\n-     (C, pthread_attr_set_boundtosproc, \"pthread_attr_set_boundtosproc\");\n-\n-   function pthread_attr_set_bsproc\n-     (attr : access pthread_attr_t; bsproc : spcb_p) return int;\n-   pragma Import (C, pthread_attr_set_bsproc, \"pthread_attr_set_bsproc\");\n-\n-   function pthread_attr_set_tslice\n-     (attr        : access pthread_attr_t;\n-      ts_interval : access struct_timeval) return int;\n-   pragma Import (C, pthread_attr_set_tslice, \"pthread_attr_set_tslice\");\n-\n-   --\n-   --  Thread Creation & Management\n-   --\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attr          : access pthread_attr_t;\n-      start_routine : start_addr;\n-      arg           : Address) return int;\n-   pragma Import (C, pthread_create, \"pthread_create\");\n-\n-   procedure pthread_exit (status : Address);\n-   pragma Import (C, pthread_exit, \"pthread_exit\");\n-\n-   procedure pthread_yield (arg : Address := System.Null_Address);\n-   pragma Import (C, pthread_yield, \"pthread_yield\");\n-\n-   function pthread_self return pthread_t;\n-   pragma Import (C, pthread_self, \"pthread_self\");\n-\n-   function pthread_kill (thread : pthread_t; sig : int) return int;\n-   pragma Import (C, pthread_kill, \"pthread_kill\");\n-\n-   --\n-   --  SGI Extensions to POSIX thread operations\n-   --\n-\n-   function pthread_setprio (thread : pthread_t; priority : int) return int;\n-   pragma Import (C, pthread_setprio, \"pthread_setprio\");\n-\n-   function pthread_suspend (thread : pthread_t) return int;\n-   pragma Import (C, pthread_suspend, \"pthread_suspend\");\n-\n-   function pthread_resume (thread : pthread_t) return int;\n-   pragma Import (C, pthread_resume, \"pthread_resume\");\n-\n-   function pthread_get_current_ada_tcb return Address;\n-   pragma Import (C, pthread_get_current_ada_tcb);\n-\n-   function pthread_set_ada_tcb\n-     (thread : pthread_t; data : Address) return int;\n-   pragma Import (C, pthread_set_ada_tcb, \"pthread_set_ada_tcb\");\n-\n-   --  Mutex Initialization / Destruction\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n-\n-   function pthread_mutexattr_setqueueorder\n-     (attr : access pthread_mutexattr_t; order : int) return int;\n-   pragma Import (C, pthread_mutexattr_setqueueorder);\n-\n-   function pthread_mutexattr_setceilingprio\n-     (attr : access pthread_mutexattr_t; priority : int) return int;\n-   pragma Import (C, pthread_mutexattr_setceilingprio);\n-\n-   --  Mutex Attributes\n-\n-   --  Threads queueing order\n-\n-   MUTEX_PRIORITY         : constant := 0; --   wait in priority order\n-   MUTEX_FIFO             : constant := 1; --   first-in-first-out\n-   MUTEX_PRIORITY_INHERIT : constant := 2; --   priority inhertance mutex\n-   MUTEX_PRIORITY_CEILING : constant := 3; --   priority ceiling mutex\n-\n-   --  Mutex debugging options\n-\n-   MUTEX_NO_DEBUG  : constant := 0; --   no debugging on mutex\n-   MUTEX_DEBUG     : constant := 1; --   debugging is on\n-\n-   --  Mutex spin on lock operations\n-\n-   MUTEX_NO_SPIN   : constant := 0;  --   no spin, try once only\n-   MUTEX_SPIN_ONLY : constant := -1; --   spin forever\n-   --  cnt > 0, limited spin\n-   --  Mutex sharing attributes\n-\n-   MUTEX_SHARED    : constant := 0; --   shared between processes\n-   MUTEX_NOTSHARED : constant := 1; --   not shared between processes\n-\n-   --  Mutex Operations\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n-\n-   function pthread_mutex_destroy\n-     (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n-\n-   function pthread_mutex_lock\n-     (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n-\n-   function pthread_mutex_unlock\n-     (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n-\n-   --  Condition Initialization / Destruction\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n-\n-   --  Condition Attributes\n-\n-   COND_PRIORITY  : constant := 0; --   wait in priority order\n-   COND_FIFO      : constant := 1; --   first-in-first-out\n-\n-   --  Condition debugging options\n-\n-   COND_NO_DEBUG  : constant := 0; --   no debugging on mutex\n-   COND_DEBUG     : constant := 1; --   debugging is on\n-\n-   --  Condition sharing attributes\n-\n-   COND_SHARED    : constant := 0; --   shared between processes\n-   COND_NOTSHARED : constant := 1; --   not shared between processes\n-\n-   --  Condition Operations\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n-\n-   function pthread_cond_destroy\n-     (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      abstime : access struct_timeval) return int;\n-   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n-\n-   --  Thread-Specific Data\n-\n-   type foo_h_proc_1 is access procedure (value : Address);\n-\n-   function pthread_key_create\n-     (key : access pthread_key_t; destructor : foo_h_proc_1) return int;\n-   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n-\n-   function pthread_setspecific\n-     (key : pthread_key_t; value : Address) return int;\n-   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n-\n-   function pthread_getspecific\n-     (key : pthread_key_t; value : access Address) return int;\n-   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n-\n-   type foo_h_proc_2 is access procedure;\n-\n-   function pthread_exec_begin (init : access pthread_init_struct) return int;\n-   pragma Import (C, pthread_exec_begin, \"pthread_exec_begin\");\n-\n-   function sproc_create\n-     (sproc_id      : access sproc_t;\n-      attr          : access sproc_attr_t;\n-      start_routine : sproc_start_addr;\n-      arg           : Address) return int;\n-   pragma Import (C, sproc_create, \"sproc_create\");\n-\n-   function sproc_self return sproc_t;\n-   pragma Import (C, sproc_self, \"sproc_self\");\n-\n-   --  if equal fast TRUE is returned - common case\n-   --  if not equal thread resource must NOT be null in order to compare bits\n-\n-   --\n-   --  Sproc attribute initialize / destroy\n-   --\n-\n-   function sproc_attr_init (attr : access sproc_attr_t) return int;\n-   pragma Import (C, sproc_attr_init, \"sproc_attr_init\");\n-\n-   function sproc_attr_destroy (attr : access sproc_attr_t) return int;\n-   pragma Import (C, sproc_attr_destroy, \"sproc_attr_destroy\");\n-\n-   function sproc_attr_setresources\n-     (attr : access sproc_attr_t; resources : resource_t) return int;\n-   pragma Import (C, sproc_attr_setresources, \"sproc_attr_setresources\");\n-\n-   function sproc_attr_getresources\n-     (attr      : access sproc_attr_t;\n-      resources : access resource_t) return int;\n-   pragma Import (C, sproc_attr_getresources, \"sproc_attr_getresources\");\n-\n-   function sproc_attr_setcpu\n-     (attr : access sproc_attr_t; cpu_num : int) return int;\n-   pragma Import (C, sproc_attr_setcpu, \"sproc_attr_setcpu\");\n-\n-   function sproc_attr_getcpu\n-     (attr : access sproc_attr_t; cpu_num : access int) return int;\n-   pragma Import (C, sproc_attr_getcpu, \"sproc_attr_getcpu\");\n-\n-   function sproc_attr_setresident\n-     (attr : access sproc_attr_t; resident : int) return int;\n-   pragma Import (C, sproc_attr_setresident, \"sproc_attr_setresident\");\n-\n-   function sproc_attr_getresident\n-     (attr : access sproc_attr_t; resident : access int) return int;\n-   pragma Import (C, sproc_attr_getresident, \"sproc_attr_getresident\");\n-\n-   function sproc_attr_setname\n-     (attr : access sproc_attr_t; name : chars_ptr) return int;\n-   pragma Import (C, sproc_attr_setname, \"sproc_attr_setname\");\n-\n-   function sproc_attr_getname\n-     (attr : access sproc_attr_t; name : chars_ptr) return int;\n-   pragma Import (C, sproc_attr_getname, \"sproc_attr_getname\");\n-\n-   function sproc_attr_setstacksize\n-     (attr : access sproc_attr_t; stacksize : size_t) return int;\n-   pragma Import (C, sproc_attr_setstacksize, \"sproc_attr_setstacksize\");\n-\n-   function sproc_attr_getstacksize\n-     (attr : access sproc_attr_t; stacksize : access size_t) return int;\n-   pragma Import (C, sproc_attr_getstacksize, \"sproc_attr_getstacksize\");\n-\n-   function sproc_attr_setprio\n-     (attr : access sproc_attr_t; priority : int) return int;\n-   pragma Import (C, sproc_attr_setprio, \"sproc_attr_setprio\");\n-\n-   function sproc_attr_getprio\n-     (attr : access sproc_attr_t; priority : access int) return int;\n-   pragma Import (C, sproc_attr_getprio, \"sproc_attr_getprio\");\n-\n-   function sproc_attr_setbthread\n-     (attr : access sproc_attr_t; bthread : ptcb_p) return int;\n-   pragma Import (C, sproc_attr_setbthread, \"sproc_attr_setbthread\");\n-\n-   function sproc_attr_getbthread\n-     (attr : access sproc_attr_t; bthread : access ptcb_p) return int;\n-   pragma Import (C, sproc_attr_getbthread, \"sproc_attr_getbthread\");\n-\n-   SPROC_NO_RESOURCES : constant := 0;\n-   SPROC_ANY_CPU      : constant := -1;\n-   SPROC_MY_PRIORITY  : constant := -1;\n-   SPROC_SWAPPED      : constant := 0;\n-   SPROC_RESIDENT     : constant := 1;\n-\n-   type isr_address is access procedure;\n-\n-   function intr_attach (sig : int; isr : isr_address) return int;\n-   pragma Import (C, intr_attach, \"intr_attach\");\n-\n-   Intr_Attach_Reset : constant Boolean := False;\n-   --  True if intr_attach is reset after an interrupt handler is called\n-\n-   function intr_exchange\n-     (sig  : int;\n-      isr  : isr_address;\n-      oisr : access isr_address) return int;\n-   pragma Import (C, intr_exchange, \"intr_exchange\");\n-\n-   function intr_current_isr\n-     (sig  : int;\n-      oisr : access isr_address)\n-     return int;\n-   pragma Import (C, intr_current_isr, \"intr_current_isr\");\n-\n-private\n-\n-   type clockid_t is new int;\n-\n-   CLOCK_REALTIME  : constant clockid_t := 1;\n-   CLOCK_SGI_CYCLE : constant clockid_t := 2;\n-   CLOCK_SGI_FAST  : constant clockid_t := 3;\n-\n-   type pthread_t           is new Address; --   thread identifier\n-   type pthread_mutex_t     is new Address; --   mutex identifier\n-   type pthread_cond_t      is new Address; --   cond identifier\n-   type pthread_attr_t      is new Address; --   pthread attributes\n-   type pthread_mutexattr_t is new Address; --   mutex attributes\n-   type pthread_condattr_t  is new Address; --   mutex attributes\n-   type sem_t               is new Address; --   semaphore identifier\n-   type pthread_key_t       is new Address; --   per thread key\n-\n-   type sigbits_t is array (Integer range 0 .. 3) of unsigned;\n-   type sigset_t is record\n-      sigbits : sigbits_t;\n-   end record;\n-   pragma Convention (C, sigset_t);\n-\n-   type pid_t is new long;\n-\n-end System.OS_Interface;"}, {"sha": "5d54315b280af0b3308b043d3e27536e00791824", "filename": "gcc/ada/s-osinte-linux-fsu.ads", "status": "removed", "additions": 0, "deletions": 599, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-linux-fsu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-linux-fsu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-linux-fsu.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,599 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2005, Free Software Foundation, Inc.      --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a GNU/Linux (FSU THREADS) version of this package.\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by children of System.\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Interfaces.C;\n-with Unchecked_Conversion;\n-\n-package System.OS_Interface is\n-   pragma Preelaborate;\n-\n-   pragma Linker_Options (\"-lgthreads\");\n-   pragma Linker_Options (\"-lmalloc\");\n-\n-   subtype int            is Interfaces.C.int;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EAGAIN    : constant := 11;\n-   EINTR     : constant := 4;\n-   EINVAL    : constant := 22;\n-   ENOMEM    : constant := 12;\n-   ETIMEDOUT : constant := 110;\n-\n-   -------------\n-   -- Signals --\n-   -------------\n-\n-   Max_Interrupt : constant := 31;\n-   type Signal is new int range 0 .. Max_Interrupt;\n-   for Signal'Size use int'Size;\n-\n-   SIGHUP     : constant := 1; --  hangup\n-   SIGINT     : constant := 2; --  interrupt (rubout)\n-   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n-   SIGILL     : constant := 4; --  illegal instruction (not reset)\n-   SIGTRAP    : constant := 5; --  trace trap (not reset)\n-   SIGIOT     : constant := 6; --  IOT instruction\n-   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n-   SIGFPE     : constant := 8; --  floating point exception\n-   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n-   SIGBUS     : constant := 7; --  bus error\n-   SIGSEGV    : constant := 11; --  segmentation violation\n-   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n-   SIGALRM    : constant := 14; --  alarm clock\n-   SIGTERM    : constant := 15; --  software termination signal from kill\n-   SIGUSR1    : constant := 10; --  user defined signal 1\n-   SIGUSR2    : constant := 12; --  user defined signal 2\n-   SIGCLD     : constant := 17; --  alias for SIGCHLD\n-   SIGCHLD    : constant := 17; --  child status change\n-   SIGPWR     : constant := 30; --  power-fail restart\n-   SIGWINCH   : constant := 28; --  window size change\n-   SIGURG     : constant := 23; --  urgent condition on IO channel\n-   SIGPOLL    : constant := 29; --  pollable event occurred\n-   SIGIO      : constant := 29; --  I/O now possible (4.2 BSD)\n-   SIGLOST    : constant := 29; --  File lock lost\n-   SIGSTOP    : constant := 19; --  stop (cannot be caught or ignored)\n-   SIGTSTP    : constant := 20; --  user stop requested from tty\n-   SIGCONT    : constant := 18; --  stopped process has been continued\n-   SIGTTIN    : constant := 21; --  background tty read attempted\n-   SIGTTOU    : constant := 22; --  background tty write attempted\n-   SIGVTALRM  : constant := 26; --  virtual timer expired\n-   SIGPROF    : constant := 27; --  profiling timer expired\n-   SIGXCPU    : constant := 24; --  CPU time limit exceeded\n-   SIGXFSZ    : constant := 25; --  filesize limit exceeded\n-   SIGUNUSED  : constant := 31; --  unused signal (GNU/Linux)\n-   SIGSTKFLT  : constant := 16; --  coprocessor stack fault (GNU/Linux)\n-\n-   SIGADAABORT : constant := SIGABRT;\n-   --  Change this if you want to use another signal for task abort.\n-   --  SIGTERM might be a good one.\n-\n-   type Signal_Set is array (Natural range <>) of Signal;\n-\n-   Unmasked    : constant Signal_Set :=\n-     (SIGTRAP, SIGBUS, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF);\n-\n-   Reserved    : constant Signal_Set :=\n-     (SIGKILL, SIGSTOP, SIGALRM, SIGVTALRM, SIGUNUSED);\n-\n-   type sigset_t is private;\n-\n-   function sigaddset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigaddset, \"sigaddset\");\n-\n-   function sigdelset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigdelset, \"sigdelset\");\n-\n-   function sigfillset (set : access sigset_t) return int;\n-   pragma Import (C, sigfillset, \"sigfillset\");\n-\n-   function sigismember (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigismember, \"sigismember\");\n-\n-   function sigemptyset (set : access sigset_t) return int;\n-   pragma Import (C, sigemptyset, \"sigemptyset\");\n-\n-   type struct_sigaction is record\n-      sa_handler  : System.Address;\n-      sa_mask     : sigset_t;\n-      sa_flags    : unsigned_long;\n-      sa_restorer : System.Address;\n-   end record;\n-   pragma Convention (C, struct_sigaction);\n-   type struct_sigaction_ptr is access all struct_sigaction;\n-\n-   type Machine_State is record\n-      eip : unsigned_long;\n-      ebx : unsigned_long;\n-      esp : unsigned_long;\n-      ebp : unsigned_long;\n-      esi : unsigned_long;\n-      edi : unsigned_long;\n-   end record;\n-   type Machine_State_Ptr is access all Machine_State;\n-\n-   SA_SIGINFO  : constant := 16#04#;\n-\n-   SIG_BLOCK   : constant := 0;\n-   SIG_UNBLOCK : constant := 1;\n-   SIG_SETMASK : constant := 2;\n-\n-   SIG_DFL : constant := 0;\n-   SIG_IGN : constant := 1;\n-\n-   function sigaction\n-     (sig  : Signal;\n-      act  : struct_sigaction_ptr;\n-      oact : struct_sigaction_ptr) return int;\n-   pragma Import (C, sigaction, \"sigaction\");\n-\n-   ----------\n-   -- Time --\n-   ----------\n-\n-   Time_Slice_Supported : constant Boolean := False;\n-   --  Indicates wether time slicing is supported (i.e FSU threads have been\n-   --  compiled with DEF_RR)\n-\n-   type timespec is private;\n-\n-   type clockid_t is private;\n-\n-   CLOCK_REALTIME : constant clockid_t;\n-\n-   function clock_gettime\n-     (clock_id : clockid_t;\n-      tp       : access timespec) return int;\n-   pragma Import (C, clock_gettime, \"clock_gettime\");\n-\n-   function To_Duration (TS : timespec) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timespec (D : Duration) return timespec;\n-   pragma Inline (To_Timespec);\n-\n-   type struct_timeval is private;\n-\n-   function To_Duration (TV : struct_timeval) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timeval (D : Duration) return struct_timeval;\n-   pragma Inline (To_Timeval);\n-\n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   SCHED_FIFO  : constant := 0;\n-   SCHED_RR    : constant := 1;\n-   SCHED_OTHER : constant := 2;\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   type pid_t is private;\n-\n-   function kill (pid : pid_t; sig : Signal) return int;\n-   pragma Import (C, kill, \"kill\");\n-\n-   function getpid return pid_t;\n-   pragma Import (C, getpid, \"getpid\");\n-\n-   ---------\n-   -- LWP --\n-   ---------\n-\n-   function lwp_self return System.Address;\n-   --  lwp_self does not exist on this thread library, revert to pthread_self\n-   --  which is the closest approximation (with getpid). This function is\n-   --  needed to share 7staprop.adb across POSIX-like targets.\n-   pragma Import (C, lwp_self, \"pthread_self\");\n-\n-   -------------\n-   -- Threads --\n-   -------------\n-\n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n-\n-   function Thread_Body_Access is new\n-     Unchecked_Conversion (System.Address, Thread_Body);\n-\n-   type pthread_t           is private;\n-   subtype Thread_Id        is pthread_t;\n-\n-   type pthread_mutex_t     is limited private;\n-   type pthread_cond_t      is limited private;\n-   type pthread_attr_t      is limited private;\n-   type pthread_mutexattr_t is limited private;\n-   type pthread_condattr_t  is limited private;\n-   type pthread_key_t       is private;\n-\n-   PTHREAD_CREATE_DETACHED : constant := 1;\n-\n-   -----------\n-   -- Stack --\n-   -----------\n-\n-   Stack_Base_Available : constant Boolean := False;\n-   --  Indicates wether the stack base is available on this target.\n-   --  This allows us to share s-osinte.adb between all the FSU run time.\n-   --  Note that this value can only be true if pthread_t has a complete\n-   --  definition that corresponds exactly to the C header files.\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address;\n-   pragma Inline (Get_Stack_Base);\n-   --  returns the stack base of the specified thread.\n-   --  Only call this function when Stack_Base_Available is True.\n-\n-   function Get_Page_Size return size_t;\n-   function Get_Page_Size return Address;\n-   pragma Import (C, Get_Page_Size, \"getpagesize\");\n-   --  returns the size of a page, or 0 if this is not relevant on this\n-   --  target\n-\n-   PROT_NONE  : constant := 0;\n-   PROT_READ  : constant := 1;\n-   PROT_WRITE : constant := 2;\n-   PROT_EXEC  : constant := 4;\n-   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n-\n-   PROT_ON    : constant := PROT_NONE;\n-   PROT_OFF   : constant := PROT_ALL;\n-\n-   function mprotect (addr : Address; len : size_t; prot : int) return int;\n-   pragma Import (C, mprotect);\n-\n-   ---------------------------------------\n-   -- Nonstandard Thread Initialization --\n-   ---------------------------------------\n-\n-   procedure pthread_init;\n-   --  FSU_THREADS requires pthread_init, which is nonstandard\n-   --  and this should be invoked during the elaboration of s-taprop.adb\n-   pragma Import (C, pthread_init, \"pthread_init\");\n-\n-   -------------------------\n-   -- POSIX.1c  Section 3 --\n-   -------------------------\n-\n-   function sigwait\n-     (set : access sigset_t;\n-      sig : access Signal) return int;\n-   pragma Inline (sigwait);\n-   --  FSU_THREADS has a nonstandard sigwait\n-\n-   function pthread_kill\n-     (thread : pthread_t;\n-      sig    : Signal) return int;\n-   pragma Import (C, pthread_kill, \"pthread_kill\");\n-\n-   --  FSU threads does not have pthread_sigmask. Instead, it uses\n-   --  sigprocmask to do the signal handling when the thread library is\n-   --  sucked in.\n-\n-   type sigset_t_ptr is access all sigset_t;\n-\n-   function pthread_sigmask\n-     (how  : int;\n-      set  : sigset_t_ptr;\n-      oset : sigset_t_ptr) return int;\n-   pragma Import (C, pthread_sigmask, \"sigprocmask\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 11 --\n-   --------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n-\n-   function pthread_mutex_destroy\n-     (mutex : access pthread_mutex_t) return  int;\n-   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n-\n-   function pthread_mutex_lock\n-     (mutex : access pthread_mutex_t) return int;\n-   pragma Inline (pthread_mutex_lock);\n-   --  FSU_THREADS has nonstandard pthread_mutex_lock\n-\n-   function pthread_mutex_unlock\n-     (mutex : access pthread_mutex_t) return int;\n-   pragma Inline (pthread_mutex_unlock);\n-   --  FSU_THREADS has nonstandard pthread_mutex_lock\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   pragma Inline (pthread_cond_wait);\n-   --  FSU_THREADS has a nonstandard pthread_cond_wait\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      abstime : access timespec) return int;\n-   pragma Inline (pthread_cond_timedwait);\n-   --  FSU_THREADS has a nonstandard pthread_cond_timedwait\n-\n-   Relative_Timed_Wait : constant Boolean := False;\n-   --  pthread_cond_timedwait requires an absolute delay time\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   PTHREAD_PRIO_NONE    : constant := 0;\n-   PTHREAD_PRIO_PROTECT : constant := 2;\n-   PTHREAD_PRIO_INHERIT : constant := 1;\n-\n-   function pthread_mutexattr_setprotocol\n-     (attr     : access pthread_mutexattr_t;\n-      protocol : int) return int;\n-   pragma Import (C, pthread_mutexattr_setprotocol);\n-\n-   function pthread_mutexattr_setprioceiling\n-     (attr        : access pthread_mutexattr_t;\n-      prioceiling : int) return int;\n-   pragma Import\n-     (C, pthread_mutexattr_setprioceiling,\n-      \"pthread_mutexattr_setprio_ceiling\");\n-\n-   type struct_sched_param is record\n-      sched_priority : int;  --  scheduling priority\n-   end record;\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int;\n-   pragma Inline (pthread_setschedparam);\n-   --  FSU_THREADS does not have pthread_setschedparam\n-\n-   function pthread_attr_setscope\n-     (attr            : access pthread_attr_t;\n-      contentionscope : int) return int;\n-   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n-\n-   function pthread_attr_setinheritsched\n-     (attr         : access pthread_attr_t;\n-      inheritsched : int) return int;\n-   pragma Import (C, pthread_attr_setinheritsched);\n-\n-   function pthread_attr_setschedpolicy\n-     (attr   : access pthread_attr_t;\n-      policy : int) return int;\n-   pragma Import (C, pthread_attr_setschedpolicy, \"pthread_attr_setsched\");\n-\n-   function sched_yield return int;\n-   pragma Inline (sched_yield);\n-   --  FSU_THREADS does not have sched_yield;\n-\n-   ---------------------------\n-   -- P1003.1c - Section 16 --\n-   ---------------------------\n-\n-   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n-\n-   function pthread_attr_destroy\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int;\n-   pragma Inline (pthread_attr_setdetachstate);\n-   --  FSU_THREADS has a nonstandard pthread_attr_setdetachstate\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attributes    : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int;\n-   pragma Import (C, pthread_create, \"pthread_create\");\n-\n-   procedure pthread_exit (status : System.Address);\n-   pragma Import (C, pthread_exit, \"pthread_exit\");\n-\n-   function pthread_self return pthread_t;\n-   pragma Import (C, pthread_self, \"pthread_self\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return int;\n-   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address;\n-   pragma Inline (pthread_getspecific);\n-   --  FSU_THREADS has a nonstandard pthread_getspecific\n-\n-   type destructor_pointer is access procedure (arg : System.Address);\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer) return int;\n-   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n-\n-private\n-\n-   type sigset_t is array (0 .. 31) of unsigned_long;\n-   pragma Convention (C, sigset_t);\n-   --  This is for GNU libc version 2 but should be backward compatible with\n-   --  other libc where sigset_t is smaller.\n-\n-   type pid_t is new int;\n-\n-   type time_t is new long;\n-\n-   type timespec is record\n-      tv_sec  : time_t;\n-      tv_nsec : long;\n-   end record;\n-   pragma Convention (C, timespec);\n-\n-   type clockid_t is new int;\n-   CLOCK_REALTIME : constant clockid_t := 0;\n-\n-   type struct_timeval is record\n-      tv_sec  : long;\n-      tv_usec : long;\n-   end record;\n-   pragma Convention (C, struct_timeval);\n-\n-   type pthread_attr_t is record\n-      flags           : int;\n-      stacksize       : int;\n-      contentionscope : int;\n-      inheritsched    : int;\n-      detachstate     : int;\n-      sched           : int;\n-      prio            : int;\n-      starttime       : timespec;\n-      deadline        : timespec;\n-      period          : timespec;\n-   end record;\n-   pragma Convention (C_Pass_By_Copy, pthread_attr_t);\n-\n-   type pthread_condattr_t is record\n-      flags : int;\n-   end record;\n-   pragma Convention (C, pthread_condattr_t);\n-\n-   type pthread_mutexattr_t is record\n-      flags        : int;\n-      prio_ceiling : int;\n-      protocol     : int;\n-   end record;\n-   pragma Convention (C, pthread_mutexattr_t);\n-\n-   type sigjmp_buf is array (Integer range 0 .. 38) of int;\n-\n-   type pthread_t_struct is record\n-      context    : sigjmp_buf;\n-      pbody      : sigjmp_buf;\n-      errno      : int;\n-      ret        : int;\n-      stack_base : System.Address;\n-   end record;\n-   pragma Convention (C, pthread_t_struct);\n-\n-   type pthread_t is access all pthread_t_struct;\n-\n-   type queue_t is record\n-      head : System.Address;\n-      tail : System.Address;\n-   end record;\n-   pragma Convention (C, queue_t);\n-\n-   type pthread_mutex_t is record\n-      queue                 : queue_t;\n-      lock                  : plain_char;\n-      owner                 : System.Address;\n-      flags                 : int;\n-      prio_ceiling          : int;\n-      protocol              : int;\n-      prev_max_ceiling_prio : int;\n-   end record;\n-   pragma Convention (C, pthread_mutex_t);\n-\n-   type pthread_cond_t is record\n-      queue        : queue_t;\n-      flags        : int;\n-      waiters      : int;\n-      mutex        : System.Address;\n-   end record;\n-   pragma Convention (C, pthread_cond_t);\n-\n-   type pthread_key_t is new int;\n-\n-end System.OS_Interface;"}, {"sha": "63c48dee38682b35efb1ca9d55e9b786a6b5485e", "filename": "gcc/ada/s-osinte-os2.adb", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-os2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-os2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-os2.adb?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,120 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2005, AdaCore                     --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OS/2 version of this package\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during\n---  tasking operations. It causes infinite loops and other problems.\n-\n-with Interfaces.OS2Lib.Errors;\n-with Interfaces.OS2Lib.Synchronization;\n-\n-package body System.OS_Interface is\n-\n-   use Interfaces;\n-   use Interfaces.OS2Lib;\n-   use Interfaces.OS2Lib.Synchronization;\n-   use Interfaces.OS2Lib.Errors;\n-\n-   -----------\n-   -- Yield --\n-   -----------\n-\n-   --  Give up the remainder of the time-slice and yield the processor\n-   --  to other threads of equal priority. Yield will return immediately\n-   --  without giving up the current time-slice when the only threads\n-   --  that are ready have a lower priority.\n-\n-   --  ???  Just giving up the current time-slice seems not to be enough\n-   --  to get the thread to the end of the ready queue if OS/2 does use\n-   --  a queue at all. As a partial work-around, we give up two time-slices.\n-\n-   --  This is the best we can do now, and at least is sufficient for passing\n-   --  the ACVC 2.0.1 Annex D tests.\n-\n-   procedure Yield is\n-   begin\n-      Delay_For (0);\n-      Delay_For (0);\n-   end Yield;\n-\n-   ---------------\n-   -- Delay_For --\n-   ---------------\n-\n-   procedure Delay_For (Period : in Duration_In_Millisec) is\n-      Result : APIRET;\n-\n-   begin\n-      pragma Assert (Period >= 0, \"GNULLI---Delay_For: negative argument\");\n-\n-      --  ??? DosSleep is not the appropriate function for a delay in real\n-      --  time. It only gives up some number of scheduled time-slices.\n-      --  Use a timer instead or block for some semaphore with a time-out.\n-      Result := DosSleep (ULONG (Period));\n-\n-      if Result = ERROR_TS_WAKEUP then\n-\n-         --  Do appropriate processing for interrupted sleep\n-         --  Can we raise an exception here?\n-\n-         null;\n-      end if;\n-\n-      pragma Assert (Result = NO_ERROR, \"GNULLI---Error in Delay_For\");\n-   end Delay_For;\n-\n-   -----------\n-   -- Clock --\n-   -----------\n-\n-   function Clock return Duration is\n-\n-      --  Implement conversion from tick count to Duration\n-      --  using fixed point arithmetic. The frequency of\n-      --  the Intel 8254 timer chip is 18.2 * 2**16 Hz.\n-\n-      Tick_Duration : constant := 1.0 / (18.2 * 2**16);\n-      Tick_Count    : aliased QWORD;\n-\n-   begin\n-      --  Read nr of clock ticks since boot time\n-\n-      Must_Not_Fail (DosTmrQueryTime (Tick_Count'Access));\n-\n-      return Tick_Count * Tick_Duration;\n-   end Clock;\n-\n-end System.OS_Interface;"}, {"sha": "6b32b5d610b08db90e7db71da49f10a36b8bafcb", "filename": "gcc/ada/s-osinte-os2.ads", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-os2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-os2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-os2.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,125 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2005, Free Software Foundation, Inc.      --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OS/2 version of this package\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by children of System.\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Interfaces.C;\n-\n-package System.OS_Interface is\n-   pragma Preelaborate;\n-\n-   package C renames Interfaces.C;\n-\n-   subtype int            is C.int;\n-   subtype unsigned_long  is C.unsigned_long;\n-\n-   type Duration_In_Millisec is new C.long;\n-   --  New type to prevent confusing time functions in this package\n-   --  with time functions returning seconds or other units.\n-\n-   type Thread_Id is new unsigned_long;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EAGAIN   : constant := 5;\n-   EINTR    : constant := 13;\n-   EINVAL   : constant := 14;\n-   ENOMEM   : constant := 25;\n-\n-   -------------\n-   -- Signals --\n-   -------------\n-\n-   Max_Interrupt : constant := 15;\n-   type Signal is new int range 0 .. Max_Interrupt;\n-\n-   --  Signals for OS/2, only SIGTERM used currently. The values are\n-   --  fake, since OS/2 uses 32 bit exception numbers that cannot be\n-   --  used to index arrays etc. The GNULLI maps these Unix-like signals\n-   --  to OS/2 exception numbers.\n-\n-   --  SIGTERM is used for the abort interrupt.\n-\n-   SIGHUP     : constant := 1;  --  hangup\n-   SIGINT     : constant := 2;  --  interrupt (rubout)\n-   SIGQUIT    : constant := 3;  --  quit (ASCD FS)\n-   SIGILL     : constant := 4;  --  illegal instruction (not reset)\n-   SIGTRAP    : constant := 5;  --  trace trap (not reset)\n-   SIGIOT     : constant := 6;  --  IOT instruction\n-   SIGEMT     : constant := 0;  --  EMT instruction\n-   SIGFPE     : constant := 8;  --  floating point exception\n-   SIGKILL    : constant := 9;  --  kill (cannot be caught or ignored)\n-   SIGBUS     : constant := 10; --  bus error\n-   SIGSEGV    : constant := 11; --  segmentation violation\n-   SIGSYS     : constant := 12; --  bad argument to system call\n-   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n-   SIGALRM    : constant := 14; --  alarm clock\n-   SIGTERM    : constant := 15; --  software termination signal from kill\n-\n-   subtype sigset_t is unsigned_long;\n-\n-   ----------\n-   -- Time --\n-   ----------\n-\n-   function Clock return Duration;\n-   pragma Inline (Clock);\n-   --  Clock measuring time since the epoch, which is the boot-time.\n-   --  The clock resolution is approximately 838 ns.\n-\n-   procedure Delay_For (Period : in Duration_In_Millisec);\n-   pragma Inline (Delay_For);\n-   --  Changed Sleep to Delay_For, for consistency with System.Time_Operations\n-\n-   ----------------\n-   -- Scheduling --\n-   ----------------\n-\n-   --  Put the calling task at the end of the ready queue for its priority\n-\n-   procedure Yield;\n-   pragma Inline (Yield);\n-\n-end System.OS_Interface;"}, {"sha": "86f3ac989cdd331cc3caa3e7e22570f0b96d4118", "filename": "gcc/ada/s-osinte-solaris-fsu.ads", "status": "removed", "additions": 0, "deletions": 667, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-solaris-fsu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-solaris-fsu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-solaris-fsu.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,667 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2005, Free Software Foundation, Inc.      --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a Solaris (FSU THREADS) version of this package\n-\n---  This package includes all direct interfaces to OS services\n---  that are needed by children of System.\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Interfaces.C;\n-with Unchecked_Conversion;\n-\n-package System.OS_Interface is\n-   pragma Preelaborate;\n-\n-   pragma Linker_Options (\"-lgthreads\");\n-   pragma Linker_Options (\"-lmalloc\");\n-\n-   subtype int            is Interfaces.C.int;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EAGAIN    : constant := 11;\n-   EINTR     : constant := 4;\n-   EINVAL    : constant := 22;\n-   ENOMEM    : constant := 12;\n-   ETIMEDOUT : constant := 145;\n-\n-   -------------\n-   -- Signals --\n-   -------------\n-\n-   Max_Interrupt : constant := 45;\n-   type Signal is new int range 0 .. Max_Interrupt;\n-   for Signal'Size use int'Size;\n-\n-   SIGHUP     : constant := 1; --  hangup\n-   SIGINT     : constant := 2; --  interrupt (rubout)\n-   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n-   SIGILL     : constant := 4; --  illegal instruction (not reset)\n-   SIGTRAP    : constant := 5; --  trace trap (not reset)\n-   SIGIOT     : constant := 6; --  IOT instruction\n-   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n-   SIGEMT     : constant := 7; --  EMT instruction\n-   SIGFPE     : constant := 8; --  floating point exception\n-   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n-   SIGBUS     : constant := 10; --  bus error\n-   SIGSEGV    : constant := 11; --  segmentation violation\n-   SIGSYS     : constant := 12; --  bad argument to system call\n-   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n-   SIGALRM    : constant := 14; --  alarm clock\n-   SIGTERM    : constant := 15; --  software termination signal from kill\n-   SIGUSR1    : constant := 16; --  user defined signal 1\n-   SIGUSR2    : constant := 17; --  user defined signal 2\n-   SIGCLD     : constant := 18; --  alias for SIGCHLD\n-   SIGCHLD    : constant := 18; --  child status change\n-   SIGPWR     : constant := 19; --  power-fail restart\n-   SIGWINCH   : constant := 20; --  window size change\n-   SIGURG     : constant := 21; --  urgent condition on IO channel\n-   SIGPOLL    : constant := 22; --  pollable event occurred\n-   SIGIO      : constant := 22; --  I/O possible (Solaris SIGPOLL alias)\n-   SIGSTOP    : constant := 23; --  stop (cannot be caught or ignored)\n-   SIGTSTP    : constant := 24; --  user stop requested from tty\n-   SIGCONT    : constant := 25; --  stopped process has been continued\n-   SIGTTIN    : constant := 26; --  background tty read attempted\n-   SIGTTOU    : constant := 27; --  background tty write attempted\n-   SIGVTALRM  : constant := 28; --  virtual timer expired\n-   SIGPROF    : constant := 29; --  profiling timer expired\n-   SIGXCPU    : constant := 30; --  CPU time limit exceeded\n-   SIGXFSZ    : constant := 31; --  filesize limit exceeded\n-   SIGWAITING : constant := 32; --  process's lwps blocked (Solaris)\n-   SIGLWP     : constant := 33; --  used by thread library (Solaris)\n-   SIGFREEZE  : constant := 34; --  used by CPR (Solaris)\n-   SIGTHAW    : constant := 35; --  used by CPR (Solaris)\n-   SIGCANCEL  : constant := 36; --  used for thread cancel (Solaris)\n-   SIGRTMIN   : constant := 38; --  first (highest-priority) realtime signal\n-   SIGRTMAX   : constant := 45; --  last (lowest-priority) realtime signal\n-\n-   type Signal_Set is array (Natural range <>) of Signal;\n-\n-   Unmasked    : constant Signal_Set :=\n-     (SIGTRAP, SIGLWP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF);\n-\n-   Reserved    : constant Signal_Set :=\n-     (SIGKILL, SIGSTOP, SIGALRM, SIGVTALRM, SIGWAITING, SIGRTMAX);\n-\n-   type sigset_t is private;\n-\n-   function sigaddset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigaddset, \"sigaddset\");\n-\n-   function sigdelset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigdelset, \"sigdelset\");\n-\n-   function sigfillset (set : access sigset_t) return int;\n-   pragma Import (C, sigfillset, \"sigfillset\");\n-\n-   function sigismember (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigismember, \"sigismember\");\n-\n-   function sigemptyset (set : access sigset_t) return int;\n-   pragma Import (C, sigemptyset, \"sigemptyset\");\n-\n-   type union_type_3 is new String (1 .. 116);\n-   type siginfo_t is record\n-      si_signo     : int;\n-      si_code      : int;\n-      si_errno     : int;\n-      X_data       : union_type_3;\n-   end record;\n-   pragma Convention (C, siginfo_t);\n-\n-   --  The types mcontext_t and gregset_t are part of the ucontext_t\n-   --  information, which is specific to Solaris2.4 for SPARC\n-   --  The ucontext_t info seems to be used by the handler\n-   --  for SIGSEGV to decide whether it is a Storage_Error (stack overflow) or\n-   --  a Constraint_Error (bad pointer).  The original code that did this\n-   --  is suspect, so it is not clear whether we really need this part of\n-   --  the signal context information, or perhaps something else.\n-   --  More analysis is needed, after which these declarations may need to\n-   --  be changed.\n-\n-   EMT_TAGOVF  : constant := 1; --  tag overflow\n-   FPE_INTDIV  : constant := 1; --  integer divide by zero\n-   FPE_INTOVF  : constant := 2; --  integer overflow\n-   FPE_FLTDIV  : constant := 3; --  floating point divide by zero\n-   FPE_FLTOVF  : constant := 4; --  floating point overflow\n-   FPE_FLTUND  : constant := 5; --  floating point underflow\n-   FPE_FLTRES  : constant := 6; --  floating point inexact result\n-   FPE_FLTINV  : constant := 7; --  invalid floating point operation\n-   FPE_FLTSUB  : constant := 8; --  subscript out of range\n-\n-   SEGV_MAPERR : constant := 1; --  address not mapped to object\n-   SEGV_ACCERR : constant := 2; --  invalid permissions\n-\n-   BUS_ADRALN  : constant := 1; --  invalid address alignment\n-   BUS_ADRERR  : constant := 2; --  non-existent physical address\n-   BUS_OBJERR  : constant := 3; --  object specific hardware error\n-\n-   ILL_ILLOPC  : constant := 1; --  illegal opcode\n-   ILL_ILLOPN  : constant := 2; --  illegal operand\n-   ILL_ILLADR  : constant := 3; --  illegal addressing mode\n-   ILL_ILLTRP  : constant := 4; --  illegal trap\n-   ILL_PRVOPC  : constant := 5; --  privileged opcode\n-   ILL_PRVREG  : constant := 6; --  privileged register\n-   ILL_COPROC  : constant := 7; --  co-processor\n-   ILL_BADSTK  : constant := 8; --  bad stack\n-\n-   type greg_t is new int;\n-\n-   type gregset_t is array (Integer range 0 .. 18) of greg_t;\n-\n-   REG_O0 : constant := 11;\n-   --  index of saved register O0 in ucontext.uc_mcontext.gregs array\n-\n-   type union_type_2 is new String (1 .. 128);\n-   type record_type_1 is record\n-      fpu_fr       : union_type_2;\n-      fpu_q        : System.Address;\n-      fpu_fsr      : unsigned;\n-      fpu_qcnt     : unsigned_char;\n-      fpu_q_entrysize  : unsigned_char;\n-      fpu_en       : unsigned_char;\n-   end record;\n-   pragma Convention (C, record_type_1);\n-   type array_type_7 is array (Integer range 0 .. 20) of long;\n-   type mcontext_t is record\n-      gregs        : gregset_t;\n-      gwins        : System.Address;\n-      fpregs       : record_type_1;\n-      filler       : array_type_7;\n-   end record;\n-   pragma Convention (C, mcontext_t);\n-\n-   type record_type_2 is record\n-      ss_sp        : System.Address;\n-      ss_size      : int;\n-      ss_flags     : int;\n-   end record;\n-   pragma Convention (C, record_type_2);\n-   type array_type_8 is array (Integer range 0 .. 22) of long;\n-   type ucontext_t is record\n-      uc_flags     : unsigned_long;\n-      uc_link      : System.Address;\n-      uc_sigmask   : sigset_t;\n-      uc_stack     : record_type_2;\n-      uc_mcontext  : mcontext_t;\n-      uc_filler    : array_type_8;\n-   end record;\n-   pragma Convention (C, ucontext_t);\n-\n-   type Signal_Handler is access procedure\n-      (signo   : Signal;\n-       info    : access siginfo_t;\n-       context : access ucontext_t);\n-\n-   type union_type_1 is new plain_char;\n-   type array_type_2 is array (Integer range 0 .. 1) of int;\n-   type struct_sigaction is record\n-      sa_flags     : int;\n-      sa_handler   : System.Address;\n-      sa_mask      : sigset_t;\n-      sa_resv      : array_type_2;\n-   end record;\n-   pragma Convention (C, struct_sigaction);\n-   type struct_sigaction_ptr is access all struct_sigaction;\n-\n-   SA_SIGINFO  : constant := 16#08#;\n-\n-   SIG_BLOCK   : constant := 1;\n-   SIG_UNBLOCK : constant := 2;\n-   SIG_SETMASK : constant := 3;\n-\n-   SIG_DFL : constant := 0;\n-   SIG_IGN : constant := 1;\n-\n-   function sigaction\n-     (sig  : Signal;\n-      act  : struct_sigaction_ptr;\n-      oact : struct_sigaction_ptr) return int;\n-   pragma Import (C, sigaction, \"sigaction\");\n-\n-   ----------\n-   -- Time --\n-   ----------\n-\n-   Time_Slice_Supported : constant Boolean := False;\n-   --  Indicates wether time slicing is supported (i.e FSU threads have been\n-   --  compiled with DEF_RR)\n-\n-   type timespec is private;\n-\n-   type clockid_t is private;\n-\n-   CLOCK_REALTIME : constant clockid_t;\n-\n-   function clock_gettime\n-     (clock_id : clockid_t;\n-      tp       : access timespec) return int;\n-   pragma Import (C, clock_gettime, \"clock_gettime\");\n-\n-   function To_Duration (TS : timespec) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timespec (D : Duration) return timespec;\n-   pragma Inline (To_Timespec);\n-\n-   type struct_timeval is private;\n-\n-   function To_Duration (TV : struct_timeval) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timeval (D : Duration) return struct_timeval;\n-   pragma Inline (To_Timeval);\n-\n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   SCHED_FIFO  : constant := 0;\n-   SCHED_RR    : constant := 1;\n-   SCHED_OTHER : constant := 2;\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   type pid_t is private;\n-\n-   function kill (pid : pid_t; sig : Signal) return int;\n-   pragma Import (C, kill, \"kill\");\n-\n-   function getpid return pid_t;\n-   pragma Import (C, getpid, \"getpid\");\n-\n-   ---------\n-   -- LWP --\n-   ---------\n-\n-   function lwp_self return System.Address;\n-   --  lwp_self does not exist on this thread library, revert to pthread_self\n-   --  which is the closest approximation (with getpid). This function is\n-   --  needed to share 7staprop.adb across POSIX-like targets.\n-   pragma Import (C, lwp_self, \"pthread_self\");\n-\n-   -------------\n-   -- Threads --\n-   -------------\n-\n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n-\n-   function Thread_Body_Access is new\n-     Unchecked_Conversion (System.Address, Thread_Body);\n-\n-   type pthread_t           is private;\n-   subtype Thread_Id        is pthread_t;\n-\n-   type pthread_mutex_t     is limited private;\n-   type pthread_cond_t      is limited private;\n-   type pthread_attr_t      is limited private;\n-   type pthread_mutexattr_t is limited private;\n-   type pthread_condattr_t  is limited private;\n-   type pthread_key_t       is private;\n-\n-   PTHREAD_CREATE_DETACHED : constant := 1;\n-\n-   -----------\n-   -- Stack --\n-   -----------\n-\n-   Stack_Base_Available : constant Boolean := False;\n-   --  Indicates wether the stack base is available on this target.\n-   --  This allows us to share s-osinte.adb between all the FSU run time.\n-   --  Note that this value can only be true if pthread_t has a complete\n-   --  definition that corresponds exactly to the C header files.\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address;\n-   pragma Inline (Get_Stack_Base);\n-   --  returns the stack base of the specified thread.\n-   --  Only call this function when Stack_Base_Available is True.\n-\n-   function Get_Page_Size return size_t;\n-   function Get_Page_Size return Address;\n-   pragma Import (C, Get_Page_Size, \"getpagesize\");\n-   --  returns the size of a page, or 0 if this is not relevant on this\n-   --  target\n-\n-   PROT_NONE  : constant := 0;\n-   PROT_READ  : constant := 1;\n-   PROT_WRITE : constant := 2;\n-   PROT_EXEC  : constant := 4;\n-   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n-\n-   PROT_ON    : constant := PROT_NONE;\n-   PROT_OFF   : constant := PROT_ALL;\n-\n-   function mprotect (addr : Address; len : size_t; prot : int) return int;\n-   pragma Import (C, mprotect);\n-\n-   ---------------------------------------\n-   -- Nonstandard Thread Initialization --\n-   ---------------------------------------\n-\n-   procedure pthread_init;\n-   --  FSU_THREADS requires pthread_init, which is nonstandard\n-   --  and this should be invoked during the elaboration of s-taprop.adb\n-   pragma Import (C, pthread_init, \"pthread_init\");\n-\n-   -------------------------\n-   -- POSIX.1c  Section 3 --\n-   -------------------------\n-\n-   function sigwait (set : access sigset_t; sig : access Signal) return int;\n-   --  FSU_THREADS has a nonstandard sigwait\n-\n-   function pthread_kill (thread : pthread_t; sig : Signal) return int;\n-   pragma Import (C, pthread_kill, \"pthread_kill\");\n-\n-   type sigset_t_ptr is access all sigset_t;\n-\n-   function pthread_sigmask\n-     (how  : int;\n-      set  : sigset_t_ptr;\n-      oset : sigset_t_ptr) return int;\n-   pragma Import (C, pthread_sigmask, \"sigprocmask\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 11 --\n-   --------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n-\n-   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n-\n-   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n-   --  FSU_THREADS has nonstandard pthread_mutex_lock\n-\n-   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n-   --  FSU_THREADS has nonstandard pthread_mutex_lock\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   --  FSU_THREADS has a nonstandard pthread_cond_wait\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      abstime : access timespec) return int;\n-   --  FSU_THREADS has a nonstandard pthread_cond_timedwait\n-\n-   Relative_Timed_Wait : constant Boolean := False;\n-   --  pthread_cond_timedwait requires an absolute delay time\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   PTHREAD_PRIO_NONE    : constant := 0;\n-   PTHREAD_PRIO_PROTECT : constant := 2;\n-   PTHREAD_PRIO_INHERIT : constant := 1;\n-\n-   function pthread_mutexattr_setprotocol\n-     (attr     : access pthread_mutexattr_t;\n-      protocol : int) return int;\n-   pragma Import (C, pthread_mutexattr_setprotocol);\n-\n-   function pthread_mutexattr_setprioceiling\n-     (attr     : access pthread_mutexattr_t;\n-      prioceiling : int) return int;\n-   pragma Import\n-     (C, pthread_mutexattr_setprioceiling,\n-      \"pthread_mutexattr_setprio_ceiling\");\n-\n-   type struct_sched_param is record\n-      sched_priority : int;  --  scheduling priority\n-   end record;\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int;\n-   --  FSU_THREADS does not have pthread_setschedparam\n-\n-   function pthread_attr_setscope\n-     (attr            : access pthread_attr_t;\n-      contentionscope : int) return int;\n-   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n-\n-   function pthread_attr_setinheritsched\n-     (attr            : access pthread_attr_t;\n-      inheritsched : int) return int;\n-   pragma Import (C, pthread_attr_setinheritsched);\n-\n-   function pthread_attr_setschedpolicy\n-     (attr   : access pthread_attr_t;\n-      policy : int) return int;\n-   pragma Import (C, pthread_attr_setschedpolicy, \"pthread_attr_setsched\");\n-\n-   function sched_yield return int;\n-   --  FSU_THREADS does not have sched_yield;\n-\n-   ---------------------------\n-   -- P1003.1c - Section 16 --\n-   ---------------------------\n-\n-   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n-\n-   function pthread_attr_destroy\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int;\n-   --  FSU_THREADS has a nonstandard pthread_attr_setdetachstate\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize);\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attributes    : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int;\n-   pragma Import (C, pthread_create, \"pthread_create\");\n-\n-   procedure pthread_exit (status : System.Address);\n-   pragma Import (C, pthread_exit, \"pthread_exit\");\n-\n-   function pthread_self return pthread_t;\n-   pragma Import (C, pthread_self, \"pthread_self\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return int;\n-   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address;\n-   --  FSU_THREADS has a nonstandard pthread_getspecific\n-\n-   type destructor_pointer is access procedure (arg : System.Address);\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer) return int;\n-   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n-\n-private\n-\n-   type array_type_1 is array (Integer range 0 .. 3) of unsigned_long;\n-   type sigset_t is record\n-      X_X_sigbits  : array_type_1;\n-   end record;\n-   pragma Convention (C, sigset_t);\n-\n-   type pid_t is new long;\n-\n-   type time_t is new long;\n-\n-   type timespec is record\n-      tv_sec  : time_t;\n-      tv_nsec : long;\n-   end record;\n-   pragma Convention (C, timespec);\n-\n-   type clockid_t is new int;\n-   CLOCK_REALTIME : constant clockid_t := 0;\n-\n-   type struct_timeval is record\n-      tv_sec  : long;\n-      tv_usec : long;\n-   end record;\n-   pragma Convention (C, struct_timeval);\n-\n-   type pthread_attr_t is record\n-      flags           : int;\n-      stacksize       : int;\n-      contentionscope : int;\n-      inheritsched    : int;\n-      detachstate     : int;\n-      sched           : int;\n-      prio            : int;\n-      starttime       : timespec;\n-      deadline        : timespec;\n-      period          : timespec;\n-   end record;\n-   pragma Convention (C, pthread_attr_t);\n-\n-   type pthread_condattr_t is record\n-      flags : int;\n-   end record;\n-   pragma Convention (C, pthread_condattr_t);\n-\n-   type pthread_mutexattr_t is record\n-      flags        : int;\n-      prio_ceiling : int;\n-      protocol     : int;\n-   end record;\n-   pragma Convention (C, pthread_mutexattr_t);\n-\n-   type sigjmp_buf is array (Integer range 0 .. 18) of int;\n-\n-   type pthread_t_struct is record\n-      context    : sigjmp_buf;\n-      pbody      : sigjmp_buf;\n-      errno      : int;\n-      ret        : int;\n-      stack_base : System.Address;\n-   end record;\n-   pragma Convention (C, pthread_t_struct);\n-\n-   type pthread_t is access all pthread_t_struct;\n-\n-   type queue_t is record\n-      head : System.Address;\n-      tail : System.Address;\n-   end record;\n-   pragma Convention (C, queue_t);\n-\n-   type pthread_mutex_t is record\n-      queue                 : queue_t;\n-      lock                  : plain_char;\n-      owner                 : System.Address;\n-      flags                 : int;\n-      prio_ceiling          : int;\n-      protocol              : int;\n-      prev_max_ceiling_prio : int;\n-   end record;\n-   pragma Convention (C, pthread_mutex_t);\n-\n-   type pthread_cond_t is record\n-      queue        : queue_t;\n-      flags        : int;\n-      waiters      : int;\n-      mutex        : System.Address;\n-   end record;\n-   pragma Convention (C, pthread_cond_t);\n-\n-   type pthread_key_t is new int;\n-\n-end System.OS_Interface;"}, {"sha": "d3f228efde61d19cfeae61993aff33550306a163", "filename": "gcc/ada/s-osinte-unixware.adb", "status": "removed", "additions": 0, "deletions": 182, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-unixware.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-unixware.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-unixware.adb?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,182 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---           Copyright (C) 1999-2005 Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a UnixWare (Native) version of this package\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during\n---  tasking operations. It causes infinite loops and other problems.\n-\n-with Interfaces.C;\n-\n-package body System.OS_Interface is\n-\n-   use Interfaces.C;\n-\n-   -----------------\n-   -- To_Duration --\n-   -----------------\n-\n-   function To_Duration (TS : timespec) return Duration is\n-   begin\n-      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n-   end To_Duration;\n-\n-   function To_Duration (TV : struct_timeval) return Duration is\n-   begin\n-      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n-   end To_Duration;\n-\n-   -----------------\n-   -- To_Timespec --\n-   -----------------\n-\n-   function To_Timespec (D : Duration) return timespec is\n-      S : time_t;\n-      F : Duration;\n-\n-   begin\n-      S := time_t (Long_Long_Integer (D));\n-      F := D - Duration (S);\n-\n-      --  If F has negative value due to a round-up, adjust for positive F\n-      --  value.\n-\n-      if F < 0.0 then\n-         S := S - 1;\n-         F := F + 1.0;\n-      end if;\n-\n-      return timespec'(tv_sec => S,\n-                       tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n-   end To_Timespec;\n-\n-   ----------------\n-   -- To_Timeval --\n-   ----------------\n-\n-   function To_Timeval (D : Duration) return struct_timeval is\n-      S : long;\n-      F : Duration;\n-\n-   begin\n-      S := long (Long_Long_Integer (D));\n-      F := D - Duration (S);\n-\n-      --  If F has negative value due to a round-up, adjust for positive F\n-      --  value.\n-\n-      if F < 0.0 then\n-         S := S - 1;\n-         F := F + 1.0;\n-      end if;\n-\n-      return\n-        struct_timeval'\n-          (tv_sec => S,\n-           tv_usec => long (Long_Long_Integer (F * 10#1#E6)));\n-   end To_Timeval;\n-\n-   -------------------\n-   -- clock_gettime --\n-   -------------------\n-\n-   function clock_gettime\n-     (clock_id : clockid_t;\n-      tp       : access timespec)\n-      return     int\n-   is\n-      pragma Warnings (Off, clock_id);\n-\n-      Result : int;\n-      tv     : aliased struct_timeval;\n-\n-      function gettimeofday\n-        (tv   : access struct_timeval;\n-         tz   : System.Address := System.Null_Address)\n-         return int;\n-      pragma Import (C, gettimeofday, \"gettimeofday\");\n-\n-   begin\n-      Result := gettimeofday (tv'Unchecked_Access);\n-      tp.all := To_Timespec (To_Duration (tv));\n-      return Result;\n-   end clock_gettime;\n-\n-   ---------------------------\n-   --  POSIX.1c  Section 3  --\n-   ---------------------------\n-\n-   function sigwait (set : access sigset_t; sig : access Signal) return int is\n-      Result : int;\n-\n-      function sigwait (set : access sigset_t) return int;\n-      pragma Import (C, sigwait, \"sigwait\");\n-\n-   begin\n-      Result := sigwait (set);\n-\n-      if Result < 0 then\n-         sig.all := 0;\n-         return errno;\n-      end if;\n-\n-      sig.all := Signal (Result);\n-      return 0;\n-   end sigwait;\n-\n-   function pthread_kill (thread : pthread_t; sig : Signal) return int is\n-      function pthread_kill_base\n-        (thread : access pthread_t; sig : access Signal) return int;\n-      pragma Import (C, pthread_kill_base, \"pthread_kill\");\n-\n-      thr   : aliased pthread_t := thread;\n-      signo : aliased Signal := sig;\n-\n-   begin\n-      return pthread_kill_base (thr'Unchecked_Access, signo'Unchecked_Access);\n-   end pthread_kill;\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address is\n-      pragma Warnings (Off, thread);\n-\n-   begin\n-      return Null_Address;\n-   end Get_Stack_Base;\n-\n-   procedure pthread_init is\n-   begin\n-      null;\n-   end pthread_init;\n-\n-end System.OS_Interface;"}, {"sha": "fda940f7dc4c4067bfba0c940c99dbad24915617", "filename": "gcc/ada/s-osinte-unixware.ads", "status": "removed", "additions": 0, "deletions": 600, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-unixware.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osinte-unixware.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-unixware.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,600 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2005, Free Software Foundation, Inc.      --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a UnixWare (Native THREADS) version of this package\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by children of System.\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Interfaces.C;\n-with Unchecked_Conversion;\n-\n-package System.OS_Interface is\n-   pragma Preelaborate;\n-\n-   pragma Linker_Options (\"-lthread\");\n-\n-   subtype int            is Interfaces.C.int;\n-   subtype char           is Interfaces.C.char;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EAGAIN    : constant := 11;\n-   EINTR     : constant := 4;\n-   EINVAL    : constant := 22;\n-   ENOMEM    : constant := 12;\n-   ETIMEDOUT : constant := 145;\n-\n-   -------------\n-   -- Signals --\n-   -------------\n-\n-   Max_Interrupt : constant := 34;\n-   type Signal is new int range 0 .. Max_Interrupt;\n-   for Signal'Size use int'Size;\n-\n-   SIGHUP      : constant := 1; --  hangup\n-   SIGINT      : constant := 2; --  interrupt (rubout)\n-   SIGQUIT     : constant := 3; --  quit (ASCD FS)\n-   SIGILL      : constant := 4; --  illegal instruction (not reset)\n-   SIGTRAP     : constant := 5; --  trace trap (not reset)\n-   SIGIOT      : constant := 6; --  IOT instruction\n-   SIGABRT     : constant := 6; --  used by abort, replace SIGIOT in the future\n-   SIGEMT      : constant := 7; --  EMT instruction\n-   SIGFPE      : constant := 8; --  floating point exception\n-   SIGKILL     : constant := 9; --  kill (cannot be caught or ignored)\n-   SIGBUS      : constant := 10; --  bus error\n-   SIGSEGV     : constant := 11; --  segmentation violation\n-   SIGSYS      : constant := 12; --  bad argument to system call\n-   SIGPIPE     : constant := 13; --  write on a pipe with no one to read it\n-   SIGALRM     : constant := 14; --  alarm clock\n-   SIGTERM     : constant := 15; --  software termination signal from kill\n-   SIGUSR1     : constant := 16; --  user defined signal 1\n-   SIGUSR2     : constant := 17; --  user defined signal 2\n-   SIGCLD      : constant := 18; --  alias for SIGCHLD\n-   SIGCHLD     : constant := 18; --  child status change\n-   SIGPWR      : constant := 19; --  power-fail restart\n-   SIGWINCH    : constant := 20; --  window size change\n-   SIGURG      : constant := 21; --  urgent condition on IO channel\n-   SIGPOLL     : constant := 22; --  pollable event occurred\n-   SIGIO       : constant := 22; --  I/O possible (Solaris SIGPOLL alias)\n-   SIGSTOP     : constant := 23; --  stop (cannot be caught or ignored)\n-   SIGTSTP     : constant := 24; --  user stop requested from tty\n-   SIGCONT     : constant := 25; --  stopped process has been continued\n-   SIGTTIN     : constant := 26; --  background tty read attempted\n-   SIGTTOU     : constant := 27; --  background tty write attempted\n-   SIGVTALRM   : constant := 28; --  virtual timer expired\n-   SIGPROF     : constant := 29; --  profiling timer expired\n-   SIGXCPU     : constant := 30; --  CPU time limit exceeded\n-   SIGXFSZ     : constant := 31; --  filesize limit exceeded\n-   SIGWAITING  : constant := 32; --  all LWPs blocked interruptibly notific.\n-   SIGLWP      : constant := 33; --  signal reserved for thread lib impl.\n-   SIGAIO      : constant := 34; --  Asynchronous I/O signal\n-\n-   SIGADAABORT : constant := SIGABRT;\n-   --  Change this if you want to use another signal for task abort.\n-   --  SIGTERM might be a good one.\n-\n-   type Signal_Set is array (Natural range <>) of Signal;\n-\n-   Unmasked    : constant Signal_Set :=\n-     (SIGTRAP, SIGLWP, SIGWAITING, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF);\n-   Reserved    : constant Signal_Set := (SIGABRT, SIGKILL, SIGSTOP);\n-\n-   type sigset_t is private;\n-\n-   function sigaddset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigaddset, \"sigaddset\");\n-\n-   function sigdelset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigdelset, \"sigdelset\");\n-\n-   function sigfillset (set : access sigset_t) return int;\n-   pragma Import (C, sigfillset, \"sigfillset\");\n-\n-   function sigismember (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigismember, \"sigismember\");\n-\n-   function sigemptyset (set : access sigset_t) return int;\n-   pragma Import (C, sigemptyset, \"sigemptyset\");\n-\n-   type struct_sigaction is record\n-      sa_flags   : int;\n-      sa_handler : System.Address;\n-      sa_mask    : sigset_t;\n-      sa_resv1   : int;\n-      sa_resv2   : int;\n-   end record;\n-   pragma Convention (C, struct_sigaction);\n-   type struct_sigaction_ptr is access all struct_sigaction;\n-\n-   SIG_BLOCK   : constant := 1;\n-   SIG_UNBLOCK : constant := 2;\n-   SIG_SETMASK : constant := 3;\n-\n-   SIG_DFL : constant := 0;\n-   SIG_IGN : constant := 1;\n-   --  SIG_ERR : constant := -1;\n-   --  not used\n-\n-   function sigaction\n-     (sig  : Signal;\n-      act  : struct_sigaction_ptr;\n-      oact : struct_sigaction_ptr) return int;\n-   pragma Import (C, sigaction, \"sigaction\");\n-\n-   ----------\n-   -- Time --\n-   ----------\n-\n-   Time_Slice_Supported : constant Boolean := False;\n-   --  Indicates wether time slicing is supported\n-\n-   type timespec is private;\n-\n-   type clockid_t is private;\n-\n-   CLOCK_REALTIME : constant clockid_t;\n-\n-   function clock_gettime\n-     (clock_id : clockid_t;\n-      tp       : access timespec) return int;\n-   --  UnixWare threads don't have clock_gettime\n-   --  We instead use gettimeofday()\n-\n-   function To_Duration (TS : timespec) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timespec (D : Duration) return timespec;\n-   pragma Inline (To_Timespec);\n-\n-   type struct_timezone is record\n-      tz_minuteswest : int;\n-      tz_dsttime     : int;\n-   end record;\n-   pragma Convention (C, struct_timezone);\n-   type struct_timezone_ptr is access all struct_timezone;\n-\n-   type struct_timeval is private;\n-   --  This is needed on systems that do not have clock_gettime()\n-   --  but do have gettimeofday().\n-\n-   function To_Duration (TV : struct_timeval) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timeval (D : Duration) return struct_timeval;\n-   pragma Inline (To_Timeval);\n-\n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   SCHED_FIFO  : constant := 2;\n-   SCHED_RR    : constant := 3;\n-   SCHED_OTHER : constant := 1;\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   type pid_t is private;\n-\n-   function kill (pid : pid_t; sig : Signal) return int;\n-   pragma Import (C, kill, \"kill\");\n-\n-   function getpid return pid_t;\n-   pragma Import (C, getpid, \"getpid\");\n-\n-   ---------\n-   -- LWP --\n-   ---------\n-\n-   function lwp_self return System.Address;\n-   pragma Import (C, lwp_self, \"_lwp_self\");\n-\n-   -------------\n-   -- Threads --\n-   -------------\n-\n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n-\n-   function Thread_Body_Access is new\n-     Unchecked_Conversion (System.Address, Thread_Body);\n-\n-   type pthread_t           is private;\n-   subtype Thread_Id        is pthread_t;\n-\n-   type pthread_mutex_t     is limited private;\n-   type pthread_cond_t      is limited private;\n-   type pthread_attr_t      is limited private;\n-   type pthread_mutexattr_t is limited private;\n-   type pthread_condattr_t  is limited private;\n-   type pthread_key_t       is private;\n-\n-   PTHREAD_CREATE_DETACHED : constant := 0;\n-\n-   -----------\n-   -- Stack --\n-   -----------\n-\n-   Stack_Base_Available : constant Boolean := False;\n-   --  Indicates wether the stack base is available on this target.\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address;\n-   pragma Inline (Get_Stack_Base);\n-   --  returns the stack base of the specified thread.\n-   --  Only call this function when Stack_Base_Available is True.\n-\n-   function Get_Page_Size return size_t;\n-   function Get_Page_Size return Address;\n-   pragma Import (C, Get_Page_Size, \"getpagesize\");\n-   --  returns the size of a page, or 0 if this is not relevant on this\n-   --  target\n-\n-   PROT_NONE  : constant := 0;\n-   PROT_READ  : constant := 1;\n-   PROT_WRITE : constant := 2;\n-   PROT_EXEC  : constant := 4;\n-   PROT_USER  : constant := 8;\n-   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC + PROT_USER;\n-\n-   PROT_ON    : constant := PROT_READ;\n-   PROT_OFF   : constant := PROT_ALL;\n-\n-   function mprotect (addr : Address; len : size_t; prot : int) return int;\n-   pragma Import (C, mprotect);\n-\n-   -------------------------\n-   -- POSIX.1c  Section 3 --\n-   -------------------------\n-\n-   function sigwait (set : access sigset_t; sig : access Signal) return int;\n-   pragma Inline (sigwait);\n-   --  UnixWare provides a non standard sigwait\n-\n-   function pthread_kill (thread : pthread_t; sig : Signal) return int;\n-   pragma Inline (pthread_kill);\n-   --  UnixWare provides a non standard pthread_kill\n-\n-   type sigset_t_ptr is access all sigset_t;\n-\n-   function pthread_sigmask\n-     (how  : int;\n-      set  : sigset_t_ptr;\n-      oset : sigset_t_ptr) return int;\n-   pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 11 --\n-   --------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n-\n-   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n-\n-   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n-\n-   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      abstime : access timespec) return int;\n-   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n-\n-   Relative_Timed_Wait : constant Boolean := False;\n-   --  pthread_cond_timedwait requires an absolute delay time\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   PTHREAD_PRIO_NONE    : constant := 1;\n-   PTHREAD_PRIO_INHERIT : constant := 2;\n-   PTHREAD_PRIO_PROTECT : constant := 3;\n-\n-   function pthread_mutexattr_setprotocol\n-     (attr     : access pthread_mutexattr_t;\n-      protocol : int) return int;\n-   pragma Import (C, pthread_mutexattr_setprotocol);\n-\n-   function pthread_mutexattr_setprioceiling\n-     (attr     : access pthread_mutexattr_t;\n-      prioceiling : int) return int;\n-   pragma Import (C, pthread_mutexattr_setprioceiling);\n-\n-   type sched_union is record\n-      sched_fifo    : int;\n-      sched_fcfs    : int;\n-      sched_other   : int;\n-      sched_ts      : int;\n-      policy_params : long;\n-   end record;\n-\n-   type struct_sched_param is record\n-      sched_priority    : int;\n-      sched_other_stuff : sched_union;\n-   end record;\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int;\n-   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n-\n-   function pthread_attr_setscope\n-     (attr            : access pthread_attr_t;\n-      contentionscope : int) return int;\n-   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n-\n-   function pthread_attr_setinheritsched\n-     (attr            : access pthread_attr_t;\n-      inheritsched : int) return int;\n-   pragma Import (C, pthread_attr_setinheritsched);\n-\n-   function pthread_attr_setschedpolicy\n-     (attr   : access pthread_attr_t;\n-      policy : int) return int;\n-   pragma Import (C, pthread_attr_setschedpolicy);\n-\n-   function sched_yield return int;\n-   pragma Import (C, sched_yield, \"sched_yield\");\n-\n-   ---------------------------\n-   -- P1003.1c - Section 16 --\n-   ---------------------------\n-\n-   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n-\n-   function pthread_attr_destroy\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int;\n-   pragma Import (C, pthread_attr_setdetachstate);\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize);\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attributes    : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int;\n-   pragma Import (C, pthread_create, \"pthread_create\");\n-\n-   procedure pthread_exit (status : System.Address);\n-   pragma Import (C, pthread_exit, \"pthread_exit\");\n-\n-   function pthread_self return pthread_t;\n-   pragma Import (C, pthread_self, \"pthread_self\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return int;\n-   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address;\n-   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n-\n-   type destructor_pointer is access procedure (arg : System.Address);\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer) return int;\n-   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n-\n-   procedure pthread_init;\n-   --  This is a dummy procedure to share some GNULLI files\n-\n-private\n-\n-   type sigbit_array is array (1 .. 4) of unsigned;\n-   type sigset_t is record\n-      sa_sigbits : sigbit_array;\n-   end record;\n-   pragma Convention (C_Pass_By_Copy, sigset_t);\n-\n-   type pid_t is new unsigned;\n-\n-   type time_t is new long;\n-\n-   type timespec is record\n-      tv_sec       : time_t;\n-      tv_nsec      : long;\n-   end record;\n-   pragma Convention (C, timespec);\n-\n-   type clockid_t is new int;\n-   CLOCK_REALTIME : constant clockid_t := 0;\n-\n-   type struct_timeval is record\n-      tv_sec       : long;\n-      tv_usec      : long;\n-   end record;\n-   pragma Convention (C, struct_timeval);\n-\n-   type pthread_attr_t is record\n-      pt_attr_status          : int;\n-      pt_attr_stacksize       : size_t;\n-      pt_attr_stackaddr       : System.Address;\n-      pt_attr_detachstate     : int;\n-      pt_attr_contentionscope : int;\n-      pt_attr_inheritsched    : int;\n-      pt_attr_schedpolicy     : int;\n-      pt_attr_sched_param     : struct_sched_param;\n-      pt_attr_tlflags         : int;\n-   end record;\n-   pragma Convention (C, pthread_attr_t);\n-\n-   type pthread_condattr_t is record\n-      pt_condattr_status  : int;\n-      pt_condattr_pshared : int;\n-   end record;\n-   pragma Convention (C, pthread_condattr_t);\n-\n-   type pthread_mutexattr_t is record\n-      pt_mutexattr_status  : int;\n-      pt_mutexattr_pshared : int;\n-      pt_mutexattr_type    : int;\n-   end record;\n-   pragma Convention (C, pthread_mutexattr_t);\n-\n-   type thread_t is new long;\n-   type pthread_t is new thread_t;\n-\n-   type thrq_elt_t;\n-   type thrq_elt_t_ptr is access all thrq_elt_t;\n-\n-   type thrq_elt_t is record\n-      thrq_next : thrq_elt_t_ptr;\n-      thrq_prev : thrq_elt_t_ptr;\n-   end record;\n-   pragma Convention (C, thrq_elt_t);\n-\n-   type lwp_mutex_t is record\n-      wanted : char;\n-      lock   : unsigned_char;\n-   end record;\n-   pragma Convention (C, lwp_mutex_t);\n-   pragma Volatile (lwp_mutex_t);\n-\n-   type mutex_t is record\n-      m_lmutex    : lwp_mutex_t;\n-      m_sync_lock : lwp_mutex_t;\n-      m_type      : int;\n-      m_sleepq    : thrq_elt_t;\n-      filler1     : int;\n-      filler2     : int;\n-   end record;\n-   pragma Convention (C, mutex_t);\n-   pragma Volatile (mutex_t);\n-\n-   type pthread_mutex_t is record\n-      pt_mutex_mutex : mutex_t;\n-      pt_mutex_pid   : pid_t;\n-      pt_mutex_owner : thread_t;\n-      pt_mutex_depth : int;\n-      pt_mutex_attr  : pthread_mutexattr_t;\n-   end record;\n-   pragma Convention (C, pthread_mutex_t);\n-\n-   type lwp_cond_t is record\n-      wanted : char;\n-   end record;\n-   pragma Convention (C, lwp_cond_t);\n-   pragma Volatile (lwp_cond_t);\n-\n-   type cond_t is record\n-      c_lcond     : lwp_cond_t;\n-      c_sync_lock : lwp_mutex_t;\n-      c_type      : int;\n-      c_syncq     : thrq_elt_t;\n-   end record;\n-   pragma Convention (C, cond_t);\n-   pragma Volatile (cond_t);\n-\n-   type pthread_cond_t is record\n-      pt_cond_cond : cond_t;\n-      pt_cond_attr : pthread_condattr_t;\n-   end record;\n-   pragma Convention (C, pthread_cond_t);\n-\n-   type pthread_key_t is new unsigned;\n-\n-end System.OS_Interface;"}, {"sha": "b8863f65dad211cecee00b634351fdda02beaaf3", "filename": "gcc/ada/s-osprim-os2.adb", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osprim-os2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-osprim-os2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-os2.adb?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,184 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                  S Y S T E M . O S _ P R I M I T I V E S                 --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---          Copyright (C) 1998-2005 Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OS/2 version of this package\n-\n-with Interfaces.C;                      use Interfaces.C;\n-with Interfaces.OS2Lib;                 use Interfaces.OS2Lib;\n-with Interfaces.OS2Lib.Synchronization; use Interfaces.OS2Lib.Synchronization;\n-\n-package body System.OS_Primitives is\n-\n-   ----------------\n-   -- Local Data --\n-   ----------------\n-\n-   Epoch_Offset    : Duration;       --  See Set_Epoch_Offset\n-   Max_Tick_Count  : QWORD := 0.0;\n-   --  This is needed to compensate for small glitches in the\n-   --  hardware clock or the way it is read by the OS\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Set_Epoch_Offset;\n-   --  Initializes the Epoch_1970_Offset to the offset of the System_Clock\n-   --  relative to the Unix epoch (Jan 1, 1970), such that\n-   --     Clock = System_Clock + Epoch_1970_Offset\n-\n-   function System_Clock return Duration;\n-   pragma Inline (System_Clock);\n-   --  Function returning value of system clock with system-dependent timebase.\n-   --  For OS/2 the system clock returns the elapsed time since system boot.\n-   --  The clock resolution is approximately 838 ns.\n-\n-   ------------------\n-   -- System_Clock --\n-   ------------------\n-\n-   function System_Clock return Duration is\n-\n-      --  Implement conversion from tick count to Duration\n-      --  using fixed point arithmetic. The frequency of\n-      --  the Intel 8254 timer chip is 18.2 * 2**16 Hz.\n-\n-      Tick_Duration : constant := 1.0 / (18.2 * 2**16);\n-      Tick_Count    : aliased QWORD;\n-\n-   begin\n-      Must_Not_Fail (DosTmrQueryTime (Tick_Count'Access));\n-      --  Read nr of clock ticks since boot time\n-\n-      Max_Tick_Count := QWORD'Max (Tick_Count, Max_Tick_Count);\n-\n-      return Max_Tick_Count * Tick_Duration;\n-   end System_Clock;\n-\n-   -----------\n-   -- Clock --\n-   -----------\n-\n-   function Clock return Duration is\n-   begin\n-      return System_Clock + Epoch_Offset;\n-   end Clock;\n-\n-   ---------------------\n-   -- Monotonic_Clock --\n-   ---------------------\n-\n-   function Monotonic_Clock return Duration renames Clock;\n-\n-   ----------------------\n-   -- Set_Epoch_Offset --\n-   ----------------------\n-\n-   procedure Set_Epoch_Offset is\n-\n-      --  Interface to Unix C style gettimeofday\n-\n-      type timeval is record\n-         tv_sec  : long;\n-         tv_usec : long;\n-      end record;\n-\n-      procedure gettimeofday\n-        (time : access timeval;\n-         zone : System.Address := System.Address'Null_Parameter);\n-      pragma Import (C, gettimeofday);\n-\n-      Time_Of_Day       : aliased timeval;\n-      Micro_To_Nano     : constant := 1.0E3;\n-      Sec_To_Nano       : constant := 1.0E9;\n-      Nanos_Since_Epoch : QWORD;\n-\n-   begin\n-      gettimeofday (Time_Of_Day'Access);\n-      Nanos_Since_Epoch := QWORD (Time_Of_Day.tv_sec) * Sec_To_Nano\n-        + QWORD (Time_Of_Day.tv_usec) * Micro_To_Nano;\n-\n-      Epoch_Offset :=\n-         Duration'(Nanos_Since_Epoch / Sec_To_Nano) - System_Clock;\n-\n-   end Set_Epoch_Offset;\n-\n-   -----------------\n-   -- Timed_Delay --\n-   -----------------\n-\n-   procedure Timed_Delay\n-     (Time : Duration;\n-      Mode : Integer)\n-   is\n-      Rel_Time   : Duration;\n-      Abs_Time   : Duration;\n-      Check_Time : Duration := Clock;\n-\n-   begin\n-      if Mode = Relative then\n-         Rel_Time := Time;\n-         Abs_Time := Time + Check_Time;\n-      else\n-         Rel_Time := Time - Check_Time;\n-         Abs_Time := Time;\n-      end if;\n-\n-      if Rel_Time > 0.0 then\n-         loop\n-            Must_Not_Fail (DosSleep (ULONG (Rel_Time * 1000.0)));\n-\n-            Check_Time := Clock;\n-\n-            exit when Abs_Time <= Check_Time;\n-\n-            Rel_Time := Abs_Time - Check_Time;\n-         end loop;\n-      end if;\n-   end Timed_Delay;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   Initialized : Boolean := False;\n-\n-   procedure Initialize is\n-   begin\n-      if not Initialized then\n-         Initialized := True;\n-         Set_Epoch_Offset;\n-      end if;\n-   end Initialize;\n-\n-end System.OS_Primitives;"}, {"sha": "8925897e4e5f0bdc49ab32bf2de1a01c745df2a7", "filename": "gcc/ada/s-parame-os2.adb", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-parame-os2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-parame-os2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-os2.adb?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,83 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    S Y S T E M . P A R A M E T E R S                     --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1997-2002 Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OS/2 specific version - default stacksizes need to be large\n-\n-package body System.Parameters is\n-\n-   ------------------------\n-   -- Default_Stack_Size --\n-   ------------------------\n-\n-   function Default_Stack_Size return Size_Type is\n-   begin\n-      --  The default stack size for extra tasks is based on the\n-      --  default stack size for the main task (8 MB) and for the heap\n-      --  (32 MB).\n-\n-      --  In OS/2 it doesn't hurt to define large stacks, unless\n-      --  the system is configured to commit all memory reservations.\n-      --  This is not a default configuration however.\n-\n-      return 1024 * 1024;\n-   end Default_Stack_Size;\n-\n-   ------------------------\n-   -- Minimum_Stack_Size --\n-   ------------------------\n-\n-   function Minimum_Stack_Size return Size_Type is\n-   begin\n-      --  System functions may need 8 kB of stack, so 12 kB seems a\n-      --  good minimum.\n-      return 12 * 1024;\n-   end Minimum_Stack_Size;\n-\n-   -------------------------\n-   -- Adjust_Storage_Size --\n-   -------------------------\n-\n-   function Adjust_Storage_Size (Size : Size_Type) return Size_Type is\n-   begin\n-      if Size = Unspecified_Size then\n-         return Default_Stack_Size;\n-\n-      elsif Size < Minimum_Stack_Size then\n-         return Minimum_Stack_Size;\n-\n-      else\n-         return Size;\n-      end if;\n-   end Adjust_Storage_Size;\n-\n-end System.Parameters;"}, {"sha": "43c0fa6380f0be6f8170550016c9066c87f8269f", "filename": "gcc/ada/s-taprop-irix-athread.adb", "status": "removed", "additions": 0, "deletions": 1110, "changes": 1110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-taprop-irix-athread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-taprop-irix-athread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix-athread.adb?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,1110 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n---                                                                          --\n---     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is an Irix (old athread library) version of this package\n-\n---  This package contains all the GNULL primitives that interface directly\n---  with the underlying OS.\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during\n---  tasking operations. It causes infinite loops and other problems.\n-\n-with Interfaces.C;\n---  used for int\n---           size_t\n-\n-with System.Tasking.Debug;\n---  used for Known_Tasks\n-\n-with System.Interrupt_Management;\n---  used for Keep_Unmasked\n---           Abort_Task_Interrupt\n---           Interrupt_ID\n-\n-with System.OS_Primitives;\n---  used for Delay_Modes\n-\n-with System.Task_Info;\n-\n-with System.Parameters;\n---  used for Size_Type\n-\n-with System.Program_Info;\n---  used for Default_Task_Stack\n---           Default_Time_Slice\n---           Stack_Guard_Pages\n---           Pthread_Sched_Signal\n---           Pthread_Arena_Size\n-\n-with System.Storage_Elements;\n---  used for To_Address\n-\n-with Unchecked_Conversion;\n-with Unchecked_Deallocation;\n-\n-package body System.Task_Primitives.Operations is\n-\n-   use System.Tasking.Debug;\n-   use System.Tasking;\n-   use Interfaces.C;\n-   use System.OS_Interface;\n-   use System.Parameters;\n-   use System.OS_Primitives;\n-\n-   -----------------\n-   -- Local Data  --\n-   -----------------\n-\n-   --  The followings are logically constants, but need to be initialized\n-   --  at run time.\n-\n-   Single_RTS_Lock : aliased RTS_Lock;\n-   --  This is a lock to allow only one thread of control in the RTS at\n-   --  a time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n-\n-   Environment_Task_Id : Task_Id;\n-   --  A variable to hold Task_Id for the environment task.\n-\n-   Locking_Policy : Character;\n-   pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n-\n-   Clock_Address : constant System.Address :=\n-     System.Storage_Elements.To_Address (16#200F90#);\n-\n-   RT_Clock_Id : clockid_t;\n-   for RT_Clock_Id'Address use Clock_Address;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Initialize_Athread_Library;\n-\n-   function To_Task_Id is new Unchecked_Conversion (System.Address, Task_Id);\n-   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n-\n-   -----------------\n-   -- Stack_Guard --\n-   -----------------\n-\n-   --  The underlying thread system sets a guard page at the\n-   --  bottom of a thread stack, so nothing is needed.\n-   --  ??? Check the comment above\n-\n-   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n-      pragma Unreferenced (T);\n-      pragma Unreferenced (On);\n-   begin\n-      null;\n-   end Stack_Guard;\n-\n-   --------------------\n-   -- Get_Thread_Id  --\n-   --------------------\n-\n-   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n-   begin\n-      return T.Common.LL.Thread;\n-   end Get_Thread_Id;\n-\n-   ----------\n-   -- Self --\n-   ----------\n-\n-   function Self return Task_Id is\n-   begin\n-      return To_Task_Id (pthread_get_current_ada_tcb);\n-   end Self;\n-\n-   ---------------------\n-   -- Initialize_Lock --\n-   ---------------------\n-\n-   --  Note: mutexes and cond_variables needed per-task basis are\n-   --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n-   --        used in RTS is initialized before any status change of RTS.\n-   --        Therefore rasing Storage_Error in the following routines\n-   --        should be able to be handled safely.\n-\n-   procedure Initialize_Lock\n-     (Prio : System.Any_Priority;\n-      L    : access Lock)\n-   is\n-      Attributes : aliased pthread_mutexattr_t;\n-      Result     : Interfaces.C.int;\n-\n-   begin\n-      Result := pthread_mutexattr_init (Attributes'Access);\n-\n-      if Result = FUNC_ERR then\n-         raise Storage_Error;\n-      end if;\n-\n-      if Locking_Policy = 'C' then\n-\n-         Result := pthread_mutexattr_setqueueorder\n-           (Attributes'Access, MUTEX_PRIORITY_CEILING);\n-\n-         pragma Assert (Result /= FUNC_ERR);\n-\n-         Result := pthread_mutexattr_setceilingprio\n-            (Attributes'Access, Interfaces.C.int (Prio));\n-\n-         pragma Assert (Result /= FUNC_ERR);\n-      end if;\n-\n-      Result := pthread_mutex_init (L, Attributes'Access);\n-\n-      if Result = FUNC_ERR then\n-         Result := pthread_mutexattr_destroy (Attributes'Access);\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Attributes'Access);\n-   end Initialize_Lock;\n-\n-   procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level) is\n-      pragma Unreferenced (Level);\n-\n-      Attributes : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      Result := pthread_mutexattr_init (Attributes'Access);\n-\n-      if Result = FUNC_ERR then\n-         raise Storage_Error;\n-      end if;\n-\n-      if Locking_Policy = 'C' then\n-         Result := pthread_mutexattr_setqueueorder\n-           (Attributes'Access, MUTEX_PRIORITY_CEILING);\n-         pragma Assert (Result /= FUNC_ERR);\n-\n-         Result := pthread_mutexattr_setceilingprio\n-            (Attributes'Access, Interfaces.C.int (System.Any_Priority'Last));\n-         pragma Assert (Result /= FUNC_ERR);\n-      end if;\n-\n-      Result := pthread_mutex_init (L, Attributes'Access);\n-\n-      if Result = FUNC_ERR then\n-         Result := pthread_mutexattr_destroy (Attributes'Access);\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Attributes'Access);\n-   end Initialize_Lock;\n-\n-   -------------------\n-   -- Finalize_Lock --\n-   -------------------\n-\n-   procedure Finalize_Lock (L : access Lock) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_destroy (L);\n-      pragma Assert (Result = 0);\n-   end Finalize_Lock;\n-\n-   procedure Finalize_Lock (L : access RTS_Lock) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_destroy (L);\n-      pragma Assert (Result = 0);\n-   end Finalize_Lock;\n-\n-   ----------------\n-   -- Write_Lock --\n-   ----------------\n-\n-   procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_lock (L);\n-      Ceiling_Violation := Result = FUNC_ERR and then errno = EINVAL;\n-      pragma Assert (Result /= FUNC_ERR);\n-   end Write_Lock;\n-\n-   procedure Write_Lock\n-     (L : access RTS_Lock; Global_Lock : Boolean := False)\n-   is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_lock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Write_Lock;\n-\n-   procedure Write_Lock (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Write_Lock;\n-\n-   ---------------\n-   -- Read_Lock --\n-   ---------------\n-\n-   procedure Read_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n-   begin\n-      Write_Lock (L, Ceiling_Violation);\n-   end Read_Lock;\n-\n-   ------------\n-   -- Unlock --\n-   ------------\n-\n-   procedure Unlock (L : access Lock) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_unlock (L);\n-      pragma Assert (Result = 0);\n-   end Unlock;\n-\n-   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_unlock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Unlock;\n-\n-   procedure Unlock (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Unlock;\n-\n-   -----------\n-   -- Sleep --\n-   -----------\n-\n-   procedure Sleep\n-     (Self_ID  : ST.Task_Id;\n-      Reason   : System.Tasking.Task_States)\n-   is\n-      pragma Unreferenced (Reason);\n-\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      if Single_Lock then\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n-      else\n-         Result := pthread_cond_wait\n-           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n-      end if;\n-\n-      --  EINTR is not considered a failure.\n-\n-      pragma Assert (Result = 0 or else Result = EINTR);\n-   end Sleep;\n-\n-   -----------------\n-   -- Timed_Sleep --\n-   -----------------\n-\n-   procedure Timed_Sleep\n-     (Self_ID  : Task_Id;\n-      Time     : Duration;\n-      Mode     : ST.Delay_Modes;\n-      Reason   : System.Tasking.Task_States;\n-      Timedout : out Boolean;\n-      Yielded  : out Boolean)\n-   is\n-      pragma Unreferenced (Reason);\n-\n-      Check_Time : constant Duration := Monotonic_Clock;\n-      Abs_Time   : Duration;\n-      Request    : aliased struct_timeval;\n-      Result     : Interfaces.C.int;\n-\n-   begin\n-      Timedout := True;\n-      Yielded := False;\n-\n-      if Mode = Relative then\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n-\n-      if Abs_Time > Check_Time then\n-         Request := To_Timeval (Abs_Time);\n-\n-         loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-              or else Self_ID.Pending_Priority_Change;\n-\n-            if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n-                  Request'Access);\n-\n-            else\n-               Result := pthread_cond_timedwait\n-                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n-                  Request'Access);\n-            end if;\n-\n-            exit when Abs_Time <= Monotonic_Clock;\n-\n-            if Result = 0 or Result = EINTR then\n-               --  somebody may have called Wakeup for us\n-               Timedout := False;\n-               exit;\n-            end if;\n-\n-            pragma Assert (Result = ETIMEDOUT\n-              or else (Result = -1 and then errno = EAGAIN));\n-         end loop;\n-      end if;\n-   end Timed_Sleep;\n-\n-   -----------------\n-   -- Timed_Delay --\n-   -----------------\n-\n-   procedure Timed_Delay\n-     (Self_ID  : Task_Id;\n-      Time     : Duration;\n-      Mode     : ST.Delay_Modes)\n-   is\n-      Check_Time : constant Duration := Monotonic_Clock;\n-      Abs_Time   : Duration;\n-      Request    : aliased struct_timeval;\n-      Result     : Interfaces.C.int;\n-\n-   begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n-      Write_Lock (Self_ID);\n-\n-      if Mode = Relative then\n-         Abs_Time := Time + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n-\n-      if Abs_Time > Check_Time then\n-         Request := To_Timeval (Abs_Time);\n-         Self_ID.Common.State := Delay_Sleep;\n-\n-         loop\n-            if Self_ID.Pending_Priority_Change then\n-               Self_ID.Pending_Priority_Change := False;\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-            end if;\n-\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n-\n-            if Single_Lock then\n-               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-                 Single_RTS_Lock'Access, Request'Access);\n-            else\n-               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-                 Self_ID.Common.LL.L'Access, Request'Access);\n-            end if;\n-\n-            exit when Abs_Time <= Monotonic_Clock;\n-\n-            pragma Assert (Result = 0 or else\n-              Result = ETIMEDOUT or else\n-              (Result = -1 and then errno = EAGAIN) or else\n-              Result = EINTR);\n-         end loop;\n-\n-         Self_ID.Common.State := Runnable;\n-      end if;\n-\n-      Unlock (Self_ID);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n-      pthread_yield;\n-   end Timed_Delay;\n-\n-   ---------------------\n-   -- Monotonic_Clock --\n-   ---------------------\n-\n-   function Monotonic_Clock return Duration is\n-      type timeval is record\n-         tv_sec  : Integer;\n-         tv_usec : Integer;\n-      end record;\n-      pragma Convention (C, timeval);\n-\n-      tv : aliased timeval;\n-\n-      procedure gettimeofday (tp : access timeval);\n-      pragma Import (C, gettimeofday, \"gettimeofday\", \"gettimeofday\");\n-\n-   begin\n-      gettimeofday (tv'Access);\n-      return Duration (tv.tv_sec) + Duration (tv.tv_usec) / 1_000_000.0;\n-   end Monotonic_Clock;\n-\n-   -------------------\n-   -- RT_Resolution --\n-   -------------------\n-\n-   function RT_Resolution return Duration is\n-   begin\n-      return 10#1.0#E-6;\n-   end RT_Resolution;\n-\n-   ------------\n-   -- Wakeup --\n-   ------------\n-\n-   procedure Wakeup\n-     (T : ST.Task_Id;\n-      Reason : System.Tasking.Task_States)\n-   is\n-      pragma Unreferenced (Reason);\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-   end Wakeup;\n-\n-   -----------\n-   -- Yield --\n-   -----------\n-\n-   procedure Yield (Do_Yield : Boolean := True) is\n-   begin\n-      if Do_Yield then\n-         pthread_yield;\n-      end if;\n-   end Yield;\n-\n-   ------------------\n-   -- Set_Priority --\n-   ------------------\n-\n-   procedure Set_Priority\n-     (T                   : Task_Id;\n-      Prio                : System.Any_Priority;\n-      Loss_Of_Inheritance : Boolean := False)\n-   is\n-      pragma Unreferenced (Loss_Of_Inheritance);\n-\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      T.Common.Current_Priority := Prio;\n-      Result := pthread_setprio (T.Common.LL.Thread, Interfaces.C.int (Prio));\n-      pragma Assert (Result /= FUNC_ERR);\n-   end Set_Priority;\n-\n-   ------------------\n-   -- Get_Priority --\n-   ------------------\n-\n-   function Get_Priority (T : Task_Id) return System.Any_Priority is\n-   begin\n-      return T.Common.Current_Priority;\n-   end Get_Priority;\n-\n-   ----------------\n-   -- Enter_Task --\n-   ----------------\n-\n-   procedure Enter_Task (Self_ID : Task_Id) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      Self_ID.Common.LL.Thread := pthread_self;\n-      Self_ID.Common.LL.LWP := sproc_self;\n-\n-      Result :=\n-        pthread_set_ada_tcb (Self_ID.Common.LL.Thread, To_Address (Self_ID));\n-\n-      pragma Assert (Result = 0);\n-\n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      Unlock_RTS;\n-   end Enter_Task;\n-\n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n-   -------------------\n-   -- Is_Valid_Task --\n-   -------------------\n-\n-   function Is_Valid_Task return Boolean is\n-   begin\n-      return False;\n-   end Is_Valid_Task;\n-\n-   -----------------------------\n-   -- Register_Foreign_Thread --\n-   -----------------------------\n-\n-   function Register_Foreign_Thread return Task_Id is\n-   begin\n-      return null;\n-   end Register_Foreign_Thread;\n-\n-   --------------------\n-   -- Initialize_TCB --\n-   --------------------\n-\n-   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n-      Result    : Interfaces.C.int;\n-      Cond_Attr : aliased pthread_condattr_t;\n-\n-   begin\n-      if not Single_Lock then\n-         Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n-      end if;\n-\n-      Result := pthread_condattr_init (Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = 0 then\n-         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-           Cond_Attr'Access);\n-         pragma Assert (Result = 0 or else Result = ENOMEM);\n-      end if;\n-\n-      if Result = 0 then\n-         Succeeded := True;\n-      else\n-         if not Single_Lock then\n-            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-            pragma Assert (Result = 0);\n-         end if;\n-\n-         Succeeded := False;\n-      end if;\n-\n-      Result := pthread_condattr_destroy (Cond_Attr'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize_TCB;\n-\n-   -----------------\n-   -- Create_Task --\n-   -----------------\n-\n-   procedure Create_Task\n-     (T          : Task_Id;\n-      Wrapper    : System.Address;\n-      Stack_Size : System.Parameters.Size_Type;\n-      Priority   : System.Any_Priority;\n-      Succeeded  : out Boolean)\n-   is\n-      Attributes          : aliased pthread_attr_t;\n-      Adjusted_Stack_Size : Interfaces.C.size_t;\n-      Result              : Interfaces.C.int;\n-\n-      function Thread_Body_Access is new\n-        Unchecked_Conversion (System.Address, start_addr);\n-\n-      function To_Resource_T is new Unchecked_Conversion\n-        (System.Task_Info.Resource_Vector_T, System.OS_Interface.resource_t);\n-\n-      use System.Task_Info;\n-\n-   begin\n-      if Stack_Size = Unspecified_Size then\n-         Adjusted_Stack_Size :=\n-           Interfaces.C.size_t (System.Program_Info.Default_Task_Stack);\n-\n-      elsif Stack_Size < Minimum_Stack_Size then\n-         Adjusted_Stack_Size := Interfaces.C.size_t (Minimum_Stack_Size);\n-\n-      else\n-         Adjusted_Stack_Size := Interfaces.C.size_t (Stack_Size);\n-      end if;\n-\n-      Result := pthread_attr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n-      end if;\n-\n-      Result := pthread_attr_setdetachstate (Attributes'Access, 1);\n-      pragma Assert (Result = 0);\n-\n-      Result := pthread_attr_setstacksize\n-        (Attributes'Access, Adjusted_Stack_Size);\n-      pragma Assert (Result = 0);\n-\n-      if T.Common.Task_Info /= null then\n-         Result := pthread_attr_setresources\n-           (Attributes'Access,\n-            To_Resource_T (T.Common.Task_Info.Thread_Resources));\n-         pragma Assert (Result /= FUNC_ERR);\n-\n-         if T.Common.Task_Info.Thread_Timeslice /= 0.0 then\n-            declare\n-               use System.OS_Interface;\n-\n-               Tv : aliased struct_timeval := To_Timeval\n-                 (T.Common.Task_Info.Thread_Timeslice);\n-            begin\n-               Result := pthread_attr_set_tslice\n-                 (Attributes'Access, Tv'Access);\n-            end;\n-         end if;\n-\n-         if T.Common.Task_Info.Bound_To_Sproc then\n-            Result := pthread_attr_set_boundtosproc\n-              (Attributes'Access, PTHREAD_BOUND);\n-            Result := pthread_attr_set_bsproc\n-              (Attributes'Access, T.Common.Task_Info.Sproc);\n-         end if;\n-\n-      end if;\n-\n-      --  Since the initial signal mask of a thread is inherited from the\n-      --  creator, and the Environment task has all its signals masked, we\n-      --  do not need to manipulate caller's signal mask at this point.\n-      --  All tasks in RTS will have All_Tasks_Mask initially.\n-\n-      Result := pthread_create\n-        (T.Common.LL.Thread'Access,\n-         Attributes'Access,\n-         Thread_Body_Access (Wrapper),\n-         To_Address (T));\n-      pragma Assert (Result = 0 or else Result = EAGAIN);\n-\n-      Succeeded := Result = 0;\n-\n-      Set_Priority (T, Priority);\n-\n-      Result := pthread_attr_destroy (Attributes'Access);\n-      pragma Assert (Result /= FUNC_ERR);\n-   end Create_Task;\n-\n-   ------------------\n-   -- Finalize_TCB --\n-   ------------------\n-\n-   procedure Finalize_TCB (T : Task_Id) is\n-      procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n-\n-      Result : Interfaces.C.int;\n-      Tmp    : Task_Id := T;\n-\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-\n-      if T.Known_Tasks_Index /= -1 then\n-         Known_Tasks (T.Known_Tasks_Index) := null;\n-      end if;\n-\n-      Free (Tmp);\n-   end Finalize_TCB;\n-\n-   ---------------\n-   -- Exit_Task --\n-   ---------------\n-\n-   procedure Exit_Task is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_set_ada_tcb (pthread_self, System.Null_Address);\n-      pragma Assert (Result = 0);\n-   end Exit_Task;\n-\n-   ----------------\n-   -- Abort_Task --\n-   ----------------\n-\n-   procedure Abort_Task (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result :=\n-        pthread_kill (T.Common.LL.Thread,\n-                      Interfaces.C.int\n-                        (System.Interrupt_Management.Abort_Task_Interrupt));\n-      pragma Assert (Result = 0);\n-   end Abort_Task;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (S : in out Suspension_Object) is\n-      Mutex_Attr : aliased pthread_mutexattr_t;\n-      Cond_Attr  : aliased pthread_condattr_t;\n-      Result     : Interfaces.C.int;\n-   begin\n-      --  Initialize internal state. It is always initialized to False (ARM\n-      --  D.10 par. 6).\n-\n-      S.State := False;\n-      S.Waiting := False;\n-\n-      --  Initialize internal mutex\n-\n-      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-         pragma Assert (Result = 0);\n-\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  Initialize internal condition variable\n-\n-      Result := pthread_condattr_init (Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         if Result = ENOMEM then\n-            raise Storage_Error;\n-         end if;\n-      end if;\n-\n-      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         if Result = ENOMEM then\n-            Result := pthread_condattr_destroy (Cond_Attr'Access);\n-            pragma Assert (Result = 0);\n-\n-            raise Storage_Error;\n-         end if;\n-      end if;\n-\n-      Result := pthread_condattr_destroy (Cond_Attr'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n-   begin\n-      --  Destroy internal mutex\n-\n-      Result := pthread_mutex_destroy (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  Destroy internal condition variable\n-\n-      Result := pthread_cond_destroy (S.CV'Access);\n-      pragma Assert (Result = 0);\n-   end Finalize;\n-\n-   -------------------\n-   -- Current_State --\n-   -------------------\n-\n-   function Current_State (S : Suspension_Object) return Boolean is\n-   begin\n-      --  We do not want to use lock on this read operation. State is marked\n-      --  as Atomic so that we ensure that the value retrieved is correct.\n-\n-      return S.State;\n-   end Current_State;\n-\n-   ---------------\n-   -- Set_False --\n-   ---------------\n-\n-   procedure Set_False (S : in out Suspension_Object) is\n-      Result  : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      S.State := False;\n-\n-      Result := pthread_mutex_unlock (S.L'Access);\n-      pragma Assert (Result = 0);\n-   end Set_False;\n-\n-   --------------\n-   -- Set_True --\n-   --------------\n-\n-   procedure Set_True (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  If there is already a task waiting on this suspension object then\n-      --  we resume it, leaving the state of the suspension object to False,\n-      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n-      --  the state to True.\n-\n-      if S.Waiting then\n-         S.Waiting := False;\n-         S.State := False;\n-\n-         Result := pthread_cond_signal (S.CV'Access);\n-         pragma Assert (Result = 0);\n-      else\n-         S.State := True;\n-      end if;\n-\n-      Result := pthread_mutex_unlock (S.L'Access);\n-      pragma Assert (Result = 0);\n-   end Set_True;\n-\n-   ------------------------\n-   -- Suspend_Until_True --\n-   ------------------------\n-\n-   procedure Suspend_Until_True (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      if S.Waiting then\n-         --  Program_Error must be raised upon calling Suspend_Until_True\n-         --  if another task is already waiting on that suspension object\n-         --  (ARM D.10 par. 10).\n-\n-         Result := pthread_mutex_unlock (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         raise Program_Error;\n-      else\n-         --  Suspend the task if the state is False. Otherwise, the task\n-         --  continues its execution, and the state of the suspension object\n-         --  is set to False (ARM D.10 par. 9).\n-\n-         if S.State then\n-            S.State := False;\n-         else\n-            S.Waiting := True;\n-            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n-         end if;\n-      end if;\n-\n-      Result := pthread_mutex_unlock (S.L'Access);\n-      pragma Assert (Result = 0);\n-   end Suspend_Until_True;\n-\n-   ----------------\n-   -- Check_Exit --\n-   ----------------\n-\n-   --  Dummy version\n-\n-   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (Self_ID);\n-   begin\n-      return True;\n-   end Check_Exit;\n-\n-   --------------------\n-   -- Check_No_Locks --\n-   --------------------\n-\n-   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (Self_ID);\n-   begin\n-      return True;\n-   end Check_No_Locks;\n-\n-   ----------------------\n-   -- Environment_Task --\n-   ----------------------\n-\n-   function Environment_Task return Task_Id is\n-   begin\n-      return Environment_Task_Id;\n-   end Environment_Task;\n-\n-   --------------\n-   -- Lock_RTS --\n-   --------------\n-\n-   procedure Lock_RTS is\n-   begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n-   end Lock_RTS;\n-\n-   ----------------\n-   -- Unlock_RTS --\n-   ----------------\n-\n-   procedure Unlock_RTS is\n-   begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n-   end Unlock_RTS;\n-\n-   ------------------\n-   -- Suspend_Task --\n-   ------------------\n-\n-   function Suspend_Task\n-     (T           : ST.Task_Id;\n-      Thread_Self : Thread_Id) return Boolean\n-   is\n-   begin\n-      if T.Common.LL.Thread /= Thread_Self then\n-         return pthread_suspend (T.Common.LL.Thread) = 0;\n-      else\n-         return True;\n-      end if;\n-   end Suspend_Task;\n-\n-   -----------------\n-   -- Resume_Task --\n-   -----------------\n-\n-   function Resume_Task\n-     (T           : ST.Task_Id;\n-      Thread_Self : Thread_Id) return Boolean\n-   is\n-   begin\n-      if T.Common.LL.Thread /= Thread_Self then\n-         return pthread_resume (T.Common.LL.Thread) = 0;\n-      else\n-         return True;\n-      end if;\n-   end Resume_Task;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (Environment_Task : Task_Id) is\n-   begin\n-      Initialize_Athread_Library;\n-      Environment_Task_Id := Environment_Task;\n-      Interrupt_Management.Initialize;\n-\n-      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n-      --  Initialize the lock used to synchronize chain of all ATCBs.\n-\n-      Enter_Task (Environment_Task);\n-\n-      Set_Priority (Environment_Task,\n-        Environment_Task.Common.Current_Priority);\n-   end Initialize;\n-\n-   --------------------------------\n-   -- Initialize_Athread_Library --\n-   --------------------------------\n-\n-   procedure Initialize_Athread_Library is\n-      Result : Interfaces.C.int;\n-      Init   : aliased pthread_init_struct;\n-\n-      package PINF renames System.Program_Info;\n-      package C    renames Interfaces.C;\n-\n-   begin\n-      Init.conf_initsize       := C.int (PINF.Pthread_Arena_Size);\n-      Init.max_sproc_count     := C.int (PINF.Max_Sproc_Count);\n-      Init.sproc_stack_size    := C.size_t (PINF.Sproc_Stack_Size);\n-      Init.os_default_priority := C.int (PINF.Os_Default_Priority);\n-      Init.os_sched_signal     := C.int (PINF.Pthread_Sched_Signal);\n-      Init.guard_pages         := C.int (PINF.Stack_Guard_Pages);\n-      Init.init_sproc_count    := C.int (PINF.Initial_Sproc_Count);\n-\n-      Result := pthread_exec_begin (Init'Access);\n-      pragma Assert (Result /= FUNC_ERR);\n-\n-      if Result = FUNC_ERR then\n-         raise Storage_Error;               --  Insufficient resources\n-      end if;\n-   end Initialize_Athread_Library;\n-\n-end System.Task_Primitives.Operations;"}, {"sha": "0455b404c86e67bbb9409d9d7dc51a6d9b7b1220", "filename": "gcc/ada/s-taprop-os2.adb", "status": "removed", "additions": 0, "deletions": 1274, "changes": 1274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-taprop-os2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-taprop-os2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-os2.adb?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,1274 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n---                                                                          --\n---    S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S     --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is an OS/2 version of this package\n-\n---  This package contains all the GNULL primitives that interface directly\n---  with the underlying OS.\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during\n---  tasking operations. It causes infinite loops and other problems.\n-\n-with System.Tasking.Debug;\n---  used for Known_Tasks\n-\n-with System.OS_Primitives;\n---  used for Delay_Modes\n---           Clock\n-\n-with Interfaces.OS2Lib.Errors;\n-with Interfaces.OS2Lib.Threads;\n-with Interfaces.OS2Lib.Synchronization;\n-\n-with Interfaces.C;\n---  used for size_t\n-\n-with Interfaces.C.Strings;\n---  used for Null_Ptr\n-\n-with System.Parameters;\n---  used for Size_Type\n-\n-with Unchecked_Conversion;\n-with Unchecked_Deallocation;\n-\n-package body System.Task_Primitives.Operations is\n-\n-   package IC  renames Interfaces.C;\n-   package ICS renames Interfaces.C.Strings;\n-   package OSP renames System.OS_Primitives;\n-\n-   use Interfaces.OS2Lib;\n-   use Interfaces.OS2Lib.Errors;\n-   use Interfaces.OS2Lib.Threads;\n-   use Interfaces.OS2Lib.Synchronization;\n-   use System.Parameters;\n-   use System.Tasking.Debug;\n-   use System.Tasking;\n-   use System.OS_Interface;\n-   use Interfaces.C;\n-   use System.OS_Primitives;\n-\n-   ---------------------\n-   -- Local Constants --\n-   ---------------------\n-\n-   Max_Locks_Per_Task   : constant := 100;\n-   Suppress_Owner_Check : constant Boolean := False;\n-\n-   -----------------\n-   -- Local Types --\n-   -----------------\n-\n-   subtype Lock_Range is Integer range 0 .. Max_Locks_Per_Task;\n-\n-   -----------------\n-   -- Local Data  --\n-   -----------------\n-\n-   --  The OS/2 DosAllocThreadLocalMemory API is used to allocate our TCB_Ptr\n-\n-   --  This API reserves a small range of virtual addresses that is backed\n-   --  by different physical memory for each running thread. In this case we\n-   --  create a pointer at a fixed address that points to the TCB_Ptr for the\n-   --  running thread. So all threads will be able to query and update their\n-   --  own TCB_Ptr without destroying the TCB_Ptr of other threads.\n-\n-   type Thread_Local_Data is record\n-      Self_ID           : Task_Id;    --  ID of the current thread\n-      Lock_Prio_Level   : Lock_Range; --  Nr of priority changes due to locks\n-\n-      --  ... room for expansion here, if we decide to make access to\n-      --  jump-buffer and exception stack more efficient in future\n-   end record;\n-\n-   type Access_Thread_Local_Data is access all Thread_Local_Data;\n-\n-   --  Pointer to Thread Local Data\n-   Thread_Local_Data_Ptr : aliased Access_Thread_Local_Data;\n-\n-   type PPTLD is access all Access_Thread_Local_Data;\n-\n-   Single_RTS_Lock : aliased RTS_Lock;\n-   --  This is a lock to allow only one thread of control in the RTS at\n-   --  a time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n-\n-   Environment_Task_Id : Task_Id;\n-   --  A variable to hold Task_Id for the environment task\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function To_PPVOID is new Unchecked_Conversion (PPTLD, PPVOID);\n-   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n-   function To_PFNTHREAD is\n-     new Unchecked_Conversion (System.Address, PFNTHREAD);\n-\n-   function To_MS (D : Duration) return ULONG;\n-\n-   procedure Set_Temporary_Priority\n-     (T            : in Task_Id;\n-      New_Priority : in System.Any_Priority);\n-\n-   -----------\n-   -- To_MS --\n-   -----------\n-\n-   function To_MS (D : Duration) return ULONG is\n-   begin\n-      return ULONG (D * 1_000);\n-   end To_MS;\n-\n-   -----------\n-   -- Clock --\n-   -----------\n-\n-   function Monotonic_Clock return Duration renames OSP.Monotonic_Clock;\n-\n-   -------------------\n-   -- RT_Resolution --\n-   -------------------\n-\n-   function RT_Resolution return Duration is\n-   begin\n-      return 10#1.0#E-6;\n-   end RT_Resolution;\n-\n-   -------------------\n-   -- Abort_Handler --\n-   -------------------\n-\n-   --  OS/2 only has limited support for asynchronous signals.\n-   --  It seems not to be possible to jump out of an exception\n-   --  handler or to change the execution context of the thread.\n-   --  So asynchonous transfer of control is not supported.\n-\n-   -----------------\n-   -- Stack_Guard --\n-   -----------------\n-\n-   --  The underlying thread system sets a guard page at the\n-   --  bottom of a thread stack, so nothing is needed.\n-   --  ??? Check the comment above\n-\n-   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n-      pragma Unreferenced (T);\n-      pragma Unreferenced (On);\n-   begin\n-      null;\n-   end Stack_Guard;\n-\n-   --------------------\n-   -- Get_Thread_Id  --\n-   --------------------\n-\n-   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n-   begin\n-      return OSI.Thread_Id (T.Common.LL.Thread);\n-   end Get_Thread_Id;\n-\n-   ----------\n-   -- Self --\n-   ----------\n-\n-   function Self return Task_Id is\n-      Self_ID : Task_Id renames Thread_Local_Data_Ptr.Self_ID;\n-\n-   begin\n-      --  Check that the thread local data has been initialized\n-\n-      pragma Assert\n-        ((Thread_Local_Data_Ptr /= null\n-          and then Thread_Local_Data_Ptr.Self_ID /= null));\n-\n-      return Self_ID;\n-   end Self;\n-\n-   ---------------------\n-   -- Initialize_Lock --\n-   ---------------------\n-\n-   procedure Initialize_Lock\n-     (Prio : System.Any_Priority;\n-      L    : access Lock)\n-   is\n-   begin\n-      if DosCreateMutexSem\n-        (ICS.Null_Ptr, L.Mutex'Unchecked_Access, 0, False32) /= NO_ERROR\n-      then\n-         raise Storage_Error;\n-      end if;\n-\n-      pragma Assert (L.Mutex /= 0, \"Error creating Mutex\");\n-      L.Priority := Prio;\n-      L.Owner_ID := Null_Address;\n-   end Initialize_Lock;\n-\n-   procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level) is\n-      pragma Unreferenced (Level);\n-\n-   begin\n-      if DosCreateMutexSem\n-        (ICS.Null_Ptr, L.Mutex'Unchecked_Access, 0, False32) /= NO_ERROR\n-      then\n-         raise Storage_Error;\n-      end if;\n-\n-      pragma Assert (L.Mutex /= 0, \"Error creating Mutex\");\n-\n-      L.Priority := System.Any_Priority'Last;\n-      L.Owner_ID := Null_Address;\n-   end Initialize_Lock;\n-\n-   -------------------\n-   -- Finalize_Lock --\n-   -------------------\n-\n-   procedure Finalize_Lock (L : access Lock) is\n-   begin\n-      Must_Not_Fail (DosCloseMutexSem (L.Mutex));\n-   end Finalize_Lock;\n-\n-   procedure Finalize_Lock (L : access RTS_Lock) is\n-   begin\n-      Must_Not_Fail (DosCloseMutexSem (L.Mutex));\n-   end Finalize_Lock;\n-\n-   ----------------\n-   -- Write_Lock --\n-   ----------------\n-\n-   procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n-      Self_ID      : constant Task_Id := Thread_Local_Data_Ptr.Self_ID;\n-      Old_Priority : constant Any_Priority :=\n-                       Self_ID.Common.LL.Current_Priority;\n-\n-   begin\n-      if L.Priority < Old_Priority then\n-         Ceiling_Violation := True;\n-         return;\n-      end if;\n-\n-      Ceiling_Violation := False;\n-\n-      --  Increase priority before getting the lock\n-      --  to prevent priority inversion\n-\n-      Thread_Local_Data_Ptr.Lock_Prio_Level :=\n-        Thread_Local_Data_Ptr.Lock_Prio_Level + 1;\n-      if L.Priority > Old_Priority then\n-         Set_Temporary_Priority (Self_ID, L.Priority);\n-      end if;\n-\n-      --  Request the lock and then update the lock owner data\n-\n-      Must_Not_Fail (DosRequestMutexSem (L.Mutex, SEM_INDEFINITE_WAIT));\n-      L.Owner_Priority := Old_Priority;\n-      L.Owner_ID := Self_ID.all'Address;\n-   end Write_Lock;\n-\n-   procedure Write_Lock\n-     (L           : access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n-      Self_ID      : Task_Id;\n-      Old_Priority : Any_Priority;\n-\n-   begin\n-      if not Single_Lock or else Global_Lock then\n-         Self_ID := Thread_Local_Data_Ptr.Self_ID;\n-         Old_Priority := Self_ID.Common.LL.Current_Priority;\n-\n-         --  Increase priority before getting the lock\n-         --  to prevent priority inversion\n-\n-         Thread_Local_Data_Ptr.Lock_Prio_Level :=\n-           Thread_Local_Data_Ptr.Lock_Prio_Level + 1;\n-\n-         if L.Priority > Old_Priority then\n-            Set_Temporary_Priority (Self_ID, L.Priority);\n-         end if;\n-\n-         --  Request the lock and then update the lock owner data\n-\n-         Must_Not_Fail (DosRequestMutexSem (L.Mutex, SEM_INDEFINITE_WAIT));\n-         L.Owner_Priority := Old_Priority;\n-         L.Owner_ID := Self_ID.all'Address;\n-      end if;\n-   end Write_Lock;\n-\n-   procedure Write_Lock (T : Task_Id) is\n-   begin\n-      if not Single_Lock then\n-\n-         --  Request the lock and then update the lock owner data\n-\n-         Must_Not_Fail\n-           (DosRequestMutexSem (T.Common.LL.L.Mutex, SEM_INDEFINITE_WAIT));\n-         T.Common.LL.L.Owner_ID := Null_Address;\n-      end if;\n-   end Write_Lock;\n-\n-   ---------------\n-   -- Read_Lock --\n-   ---------------\n-\n-   procedure Read_Lock\n-     (L : access Lock; Ceiling_Violation : out Boolean) renames Write_Lock;\n-\n-   ------------\n-   -- Unlock --\n-   ------------\n-\n-   procedure Unlock (L : access Lock) is\n-      Self_ID      : constant Task_Id := Thread_Local_Data_Ptr.Self_ID;\n-      Old_Priority : constant Any_Priority := L.Owner_Priority;\n-\n-   begin\n-      --  Check that this task holds the lock\n-\n-      pragma Assert (Suppress_Owner_Check\n-        or else L.Owner_ID = Self_ID.all'Address);\n-\n-      --  Upate the owner data\n-\n-      L.Owner_ID := Null_Address;\n-\n-      --  Do the actual unlocking. No more references\n-      --  to owner data of L after this point.\n-\n-      Must_Not_Fail (DosReleaseMutexSem (L.Mutex));\n-\n-      --  Reset priority after unlocking to avoid priority inversion\n-\n-      Thread_Local_Data_Ptr.Lock_Prio_Level :=\n-        Thread_Local_Data_Ptr.Lock_Prio_Level - 1;\n-      if L.Priority /= Old_Priority then\n-         Set_Temporary_Priority (Self_ID, Old_Priority);\n-      end if;\n-   end Unlock;\n-\n-   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n-      Self_ID      : Task_Id;\n-      Old_Priority : Any_Priority;\n-\n-   begin\n-      if not Single_Lock or else Global_Lock then\n-         Self_ID := Thread_Local_Data_Ptr.Self_ID;\n-         Old_Priority := L.Owner_Priority;\n-         --  Check that this task holds the lock\n-\n-         pragma Assert (Suppress_Owner_Check\n-           or else L.Owner_ID = Self_ID.all'Address);\n-\n-         --  Upate the owner data\n-\n-         L.Owner_ID := Null_Address;\n-\n-         --  Do the actual unlocking. No more references\n-         --  to owner data of L after this point.\n-\n-         Must_Not_Fail (DosReleaseMutexSem (L.Mutex));\n-\n-         --  Reset priority after unlocking to avoid priority inversion\n-\n-         Thread_Local_Data_Ptr.Lock_Prio_Level :=\n-           Thread_Local_Data_Ptr.Lock_Prio_Level - 1;\n-\n-         if L.Priority /= Old_Priority then\n-            Set_Temporary_Priority (Self_ID, Old_Priority);\n-         end if;\n-      end if;\n-   end Unlock;\n-\n-   procedure Unlock (T : Task_Id) is\n-   begin\n-      if not Single_Lock then\n-\n-         --  Check the owner data\n-\n-         pragma Assert (Suppress_Owner_Check\n-           or else T.Common.LL.L.Owner_ID = Null_Address);\n-\n-         --  Do the actual unlocking. No more references\n-         --  to owner data of T.Common.LL.L after this point.\n-\n-         Must_Not_Fail (DosReleaseMutexSem (T.Common.LL.L.Mutex));\n-      end if;\n-   end Unlock;\n-\n-   -----------\n-   -- Sleep --\n-   -----------\n-\n-   procedure Sleep\n-     (Self_ID : Task_Id;\n-      Reason  : System.Tasking.Task_States)\n-   is\n-      pragma Unreferenced (Reason);\n-\n-      Count : aliased ULONG; -- Used to store dummy result\n-\n-   begin\n-      --  Must reset Cond BEFORE L is unlocked\n-\n-      Sem_Must_Not_Fail\n-        (DosResetEventSem (Self_ID.Common.LL.CV, Count'Unchecked_Access));\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      else\n-         Unlock (Self_ID);\n-      end if;\n-\n-      --  No problem if we are interrupted here.\n-      --  If the condition is signaled, DosWaitEventSem will simply not block.\n-\n-      Sem_Must_Not_Fail\n-        (DosWaitEventSem (Self_ID.Common.LL.CV, SEM_INDEFINITE_WAIT));\n-\n-      --  Since L was previously accquired, lock operation should not fail\n-\n-      if Single_Lock then\n-         Lock_RTS;\n-      else\n-         Write_Lock (Self_ID);\n-      end if;\n-   end Sleep;\n-\n-   -----------------\n-   -- Timed_Sleep --\n-   -----------------\n-\n-   --  This is for use within the run-time system, so abort is\n-   --  assumed to be already deferred, and the caller should be\n-   --  holding its own ATCB lock.\n-\n-   --  Pre-assertion: Cond is posted\n-   --                 Self is locked.\n-\n-   --  Post-assertion: Cond is posted\n-   --                  Self is locked.\n-\n-   procedure Timed_Sleep\n-     (Self_ID  : Task_Id;\n-      Time     : Duration;\n-      Mode     : ST.Delay_Modes;\n-      Reason   : System.Tasking.Task_States;\n-      Timedout : out Boolean;\n-      Yielded  : out Boolean)\n-   is\n-      pragma Unreferenced (Reason);\n-\n-      Check_Time : constant Duration := OSP.Monotonic_Clock;\n-      Rel_Time   : Duration;\n-      Abs_Time   : Duration;\n-      Time_Out   : ULONG;\n-      Result    : APIRET;\n-      Count      : aliased ULONG;  --  Used to store dummy result\n-\n-   begin\n-      --  Must reset Cond BEFORE Self_ID is unlocked\n-\n-      Sem_Must_Not_Fail\n-        (DosResetEventSem (Self_ID.Common.LL.CV,\n-         Count'Unchecked_Access));\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      else\n-         Unlock (Self_ID);\n-      end if;\n-\n-      Timedout := True;\n-      Yielded := False;\n-\n-      if Mode = Relative then\n-         Rel_Time := Time;\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n-      else\n-         Rel_Time := Time - Check_Time;\n-         Abs_Time := Time;\n-      end if;\n-\n-      if Rel_Time > 0.0 then\n-         loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-              or else Self_ID.Pending_Priority_Change;\n-\n-            Time_Out := To_MS (Rel_Time);\n-            Result := DosWaitEventSem (Self_ID.Common.LL.CV, Time_Out);\n-            pragma Assert\n-             ((Result = NO_ERROR or Result = ERROR_TIMEOUT\n-                or Result = ERROR_INTERRUPT));\n-\n-            --  ???\n-            --  What to do with error condition ERROR_NOT_ENOUGH_MEMORY? Can\n-            --  we raise an exception here?  And what about ERROR_INTERRUPT?\n-            --  Should that be treated as a simple timeout?\n-            --  For now, consider only ERROR_TIMEOUT to be a timeout.\n-\n-            exit when Abs_Time <= OSP.Monotonic_Clock;\n-\n-            if Result /= ERROR_TIMEOUT then\n-               --  somebody may have called Wakeup for us\n-               Timedout := False;\n-               exit;\n-            end if;\n-\n-            Rel_Time := Abs_Time - OSP.Monotonic_Clock;\n-         end loop;\n-      end if;\n-\n-      --  Ensure post-condition\n-\n-      if Single_Lock then\n-         Lock_RTS;\n-      else\n-         Write_Lock (Self_ID);\n-      end if;\n-\n-      if Timedout then\n-         Sem_Must_Not_Fail (DosPostEventSem (Self_ID.Common.LL.CV));\n-      end if;\n-   end Timed_Sleep;\n-\n-   -----------------\n-   -- Timed_Delay --\n-   -----------------\n-\n-   procedure Timed_Delay\n-     (Self_ID  : Task_Id;\n-      Time     : Duration;\n-      Mode     : ST.Delay_Modes)\n-   is\n-      Check_Time : constant Duration := OSP.Monotonic_Clock;\n-      Rel_Time   : Duration;\n-      Abs_Time   : Duration;\n-      Timedout   : Boolean := True;\n-      Time_Out   : ULONG;\n-      Result     : APIRET;\n-      Count      : aliased ULONG;  --  Used to store dummy result\n-\n-   begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      else\n-         Write_Lock (Self_ID);\n-      end if;\n-\n-      --  Must reset Cond BEFORE Self_ID is unlocked\n-\n-      Sem_Must_Not_Fail\n-        (DosResetEventSem (Self_ID.Common.LL.CV,\n-         Count'Unchecked_Access));\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      else\n-         Unlock (Self_ID);\n-      end if;\n-\n-      if Mode = Relative then\n-         Rel_Time := Time;\n-         Abs_Time := Time + Check_Time;\n-      else\n-         Rel_Time := Time - Check_Time;\n-         Abs_Time := Time;\n-      end if;\n-\n-      if Rel_Time > 0.0 then\n-         Self_ID.Common.State := Delay_Sleep;\n-\n-         loop\n-            if Self_ID.Pending_Priority_Change then\n-               Self_ID.Pending_Priority_Change := False;\n-               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n-               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n-            end if;\n-\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n-\n-            Time_Out := To_MS (Rel_Time);\n-            Result := DosWaitEventSem (Self_ID.Common.LL.CV, Time_Out);\n-\n-            exit when Abs_Time <= OSP.Monotonic_Clock;\n-\n-            Rel_Time := Abs_Time - OSP.Monotonic_Clock;\n-         end loop;\n-\n-         Self_ID.Common.State := Runnable;\n-         Timedout := Result = ERROR_TIMEOUT;\n-      end if;\n-\n-      if Single_Lock then\n-         Lock_RTS;\n-      else\n-         Write_Lock (Self_ID);\n-      end if;\n-\n-      if Timedout then\n-         Sem_Must_Not_Fail (DosPostEventSem (Self_ID.Common.LL.CV));\n-      end if;\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      else\n-         Unlock (Self_ID);\n-      end if;\n-\n-      System.OS_Interface.Yield;\n-   end Timed_Delay;\n-\n-   ------------\n-   -- Wakeup --\n-   ------------\n-\n-   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n-      pragma Unreferenced (Reason);\n-   begin\n-      Sem_Must_Not_Fail (DosPostEventSem (T.Common.LL.CV));\n-   end Wakeup;\n-\n-   -----------\n-   -- Yield --\n-   -----------\n-\n-   procedure Yield (Do_Yield : Boolean := True) is\n-   begin\n-      if Do_Yield then\n-         System.OS_Interface.Yield;\n-      end if;\n-   end Yield;\n-\n-   ----------------------------\n-   -- Set_Temporary_Priority --\n-   ----------------------------\n-\n-   procedure Set_Temporary_Priority\n-     (T            : Task_Id;\n-      New_Priority : System.Any_Priority)\n-   is\n-      use Interfaces.C;\n-      Delta_Priority : Integer;\n-\n-   begin\n-      --  When Lock_Prio_Level = 0, we always need to set the\n-      --  Active_Priority. In this way we can make priority changes\n-      --  due to locking independent of those caused by calling\n-      --  Set_Priority.\n-\n-      if Thread_Local_Data_Ptr.Lock_Prio_Level = 0\n-        or else New_Priority < T.Common.Current_Priority\n-      then\n-         Delta_Priority := T.Common.Current_Priority -\n-           T.Common.LL.Current_Priority;\n-      else\n-         Delta_Priority := New_Priority - T.Common.LL.Current_Priority;\n-      end if;\n-\n-      if Delta_Priority /= 0 then\n-         --  ??? There is a race-condition here\n-         --  The TCB is updated before the system call to make\n-         --  pre-emption in the critical section less likely.\n-\n-         T.Common.LL.Current_Priority :=\n-           T.Common.LL.Current_Priority + Delta_Priority;\n-         Must_Not_Fail\n-           (DosSetPriority (Scope   => PRTYS_THREAD,\n-                            Class   => PRTYC_NOCHANGE,\n-                            Delta_P => IC.long (Delta_Priority),\n-                            PorTid  => T.Common.LL.Thread));\n-      end if;\n-   end Set_Temporary_Priority;\n-\n-   ------------------\n-   -- Set_Priority --\n-   ------------------\n-\n-   procedure Set_Priority\n-     (T                   : Task_Id;\n-      Prio                : System.Any_Priority;\n-      Loss_Of_Inheritance : Boolean := False)\n-   is\n-      pragma Unreferenced (Loss_Of_Inheritance);\n-   begin\n-      T.Common.Current_Priority := Prio;\n-      Set_Temporary_Priority (T, Prio);\n-   end Set_Priority;\n-\n-   ------------------\n-   -- Get_Priority --\n-   ------------------\n-\n-   function Get_Priority (T : Task_Id) return System.Any_Priority is\n-   begin\n-      return T.Common.Current_Priority;\n-   end Get_Priority;\n-\n-   ----------------\n-   -- Enter_Task --\n-   ----------------\n-\n-   procedure Enter_Task (Self_ID : Task_Id) is\n-   begin\n-      --  Initialize thread local data. Must be done first\n-\n-      Thread_Local_Data_Ptr.Self_ID := Self_ID;\n-      Thread_Local_Data_Ptr.Lock_Prio_Level := 0;\n-\n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      Unlock_RTS;\n-\n-      --  For OS/2, we can set Self_ID.Common.LL.Thread in\n-      --  Create_Task, since the thread is created suspended.\n-      --  That is, there is no danger of the thread racing ahead\n-      --  and trying to reference Self_ID.Common.LL.Thread before it\n-      --  has been initialized.\n-\n-      --  .... Do we need to do anything with signals for OS/2 ???\n-   end Enter_Task;\n-\n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n-   -------------------\n-   -- Is_Valid_Task --\n-   -------------------\n-\n-   function Is_Valid_Task return Boolean is\n-   begin\n-      return False;\n-   end Is_Valid_Task;\n-\n-   -----------------------------\n-   -- Register_Foreign_Thread --\n-   -----------------------------\n-\n-   function Register_Foreign_Thread return Task_Id is\n-   begin\n-      return null;\n-   end Register_Foreign_Thread;\n-\n-   --------------------\n-   -- Initialize_TCB --\n-   --------------------\n-\n-   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n-   begin\n-      if DosCreateEventSem (ICS.Null_Ptr,\n-        Self_ID.Common.LL.CV'Unchecked_Access, 0, True32) = NO_ERROR\n-      then\n-         if not Single_Lock\n-           and then DosCreateMutexSem\n-             (ICS.Null_Ptr,\n-              Self_ID.Common.LL.L.Mutex'Unchecked_Access,\n-              0,\n-              False32) /= NO_ERROR\n-         then\n-            Succeeded := False;\n-            Must_Not_Fail (DosCloseEventSem (Self_ID.Common.LL.CV));\n-         else\n-            Succeeded := True;\n-         end if;\n-\n-         --  We now want to do the equivalent of:\n-\n-         --  Initialize_Lock\n-         --    (Self_ID.Common.LL.L'Unchecked_Access, ATCB_Level);\n-\n-         --  But we avoid that because the Initialize_TCB routine has an\n-         --  exception handler, and it is too early for us to deal with\n-         --  installing handlers (see comment below), so we do our own\n-         --  Initialize_Lock operation manually.\n-\n-         Self_ID.Common.LL.L.Priority := System.Any_Priority'Last;\n-         Self_ID.Common.LL.L.Owner_ID := Null_Address;\n-\n-      else\n-         Succeeded := False;\n-      end if;\n-\n-      --  Note: at one time we had an exception handler here, whose code\n-      --  was as follows:\n-\n-      --  exception\n-\n-      --     Assumes any failure must be due to insufficient resources\n-\n-      --     when Storage_Error =>\n-      --        Must_Not_Fail (DosCloseEventSem (Self_ID.Common.LL.CV));\n-      --        Succeeded := False;\n-\n-      --  but that won't work with the old exception scheme, since it would\n-      --  result in messing with Jmpbuf values too early. If and when we get\n-      --  switched entirely to the new zero-cost exception scheme, we could\n-      --  put this handler back in!\n-   end Initialize_TCB;\n-\n-   -----------------\n-   -- Create_Task --\n-   -----------------\n-\n-   procedure Create_Task\n-     (T          : Task_Id;\n-      Wrapper    : System.Address;\n-      Stack_Size : System.Parameters.Size_Type;\n-      Priority   : System.Any_Priority;\n-      Succeeded  : out Boolean)\n-   is\n-      Result              : aliased APIRET;\n-      Adjusted_Stack_Size : System.Parameters.Size_Type;\n-      use System.Parameters;\n-\n-   begin\n-      --  In OS/2 the allocated stack size should be based on the\n-      --  amount of address space that should be reserved for the stack.\n-      --  Actual memory will only be used when the stack is touched anyway.\n-\n-      --  The new minimum size is 12 kB, although the EMX docs\n-      --  recommend a minimum size of 32 kB.  (The original was 4 kB)\n-      --  Systems that use many tasks (say > 30) and require much\n-      --  memory may run out of virtual address space, since OS/2\n-      --  has a per-proces limit of 512 MB, of which max. 300 MB is\n-      --  usable in practise.\n-\n-      if Stack_Size = Unspecified_Size then\n-         Adjusted_Stack_Size := Default_Stack_Size;\n-\n-      elsif Stack_Size < Minimum_Stack_Size then\n-         Adjusted_Stack_Size := Minimum_Stack_Size;\n-\n-      else\n-         Adjusted_Stack_Size := Stack_Size;\n-      end if;\n-\n-      --  GB970222:\n-      --    Because DosCreateThread is called directly here, the\n-      --    C RTL doesn't get initialized for the new thead. EMX by\n-      --    default uses per-thread local heaps in addition to the\n-      --    global heap. There might be other effects of by-passing the\n-      --    C library here.\n-\n-      --    When using _beginthread the newly created thread is not\n-      --    blocked initially. Does this matter or can I create the\n-      --    thread running anyway? The LL.Thread variable will be set\n-      --    anyway because the variable is passed by reference to OS/2.\n-\n-      T.Common.LL.Wrapper := To_PFNTHREAD (Wrapper);\n-\n-      --  The OS implicitly gives the new task the priority of this task\n-\n-      T.Common.LL.Current_Priority := Self.Common.LL.Current_Priority;\n-\n-      --  If task was locked before activator task was\n-      --  initialized, assume it has OS standard priority\n-\n-      if T.Common.LL.L.Owner_Priority not in Any_Priority'Range then\n-         T.Common.LL.L.Owner_Priority := 1;\n-      end if;\n-\n-      --  Create the thread, in blocked mode\n-\n-      Result := DosCreateThread\n-        (F_ptid   => T.Common.LL.Thread'Unchecked_Access,\n-         pfn      => T.Common.LL.Wrapper,\n-         param    => To_Address (T),\n-         flag     => Block_Child + Commit_Stack,\n-         cbStack  => ULONG (Adjusted_Stack_Size));\n-\n-      Succeeded := (Result = NO_ERROR);\n-\n-      if not Succeeded then\n-         return;\n-      end if;\n-\n-      --  Set the new thread's priority\n-      --  (child has inherited priority from parent)\n-\n-      Set_Priority (T, Priority);\n-\n-      --  Start the thread executing\n-\n-      Must_Not_Fail (DosResumeThread (T.Common.LL.Thread));\n-\n-   end Create_Task;\n-\n-   ------------------\n-   -- Finalize_TCB --\n-   ------------------\n-\n-   procedure Finalize_TCB (T : Task_Id) is\n-      Tmp    : Task_Id := T;\n-\n-      procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n-\n-   begin\n-      Must_Not_Fail (DosCloseEventSem (T.Common.LL.CV));\n-\n-      if not Single_Lock then\n-         Finalize_Lock (T.Common.LL.L'Unchecked_Access);\n-      end if;\n-\n-      if T.Known_Tasks_Index /= -1 then\n-         Known_Tasks (T.Known_Tasks_Index) := null;\n-      end if;\n-\n-      Free (Tmp);\n-   end Finalize_TCB;\n-\n-   ---------------\n-   -- Exit_Task --\n-   ---------------\n-\n-   procedure Exit_Task is\n-   begin\n-      Thread_Local_Data_Ptr := null;\n-   end Exit_Task;\n-\n-   ----------------\n-   -- Abort_Task --\n-   ----------------\n-\n-   procedure Abort_Task (T : Task_Id) is\n-      pragma Unreferenced (T);\n-\n-   begin\n-      null;\n-\n-      --  Task abort not implemented yet.\n-      --  Should perform other action ???\n-\n-   end Abort_Task;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-   begin\n-      --  Initialize internal state. It is always initialized to False (ARM\n-      --  D.10 par. 6).\n-\n-      S.State := False;\n-      S.Waiting := False;\n-\n-      --  Initialize internal mutex\n-      if DosCreateMutexSem\n-        (ICS.Null_Ptr, S.L'Unchecked_Access, 0, False32) /= NO_ERROR\n-      then\n-         raise Storage_Error;\n-      end if;\n-\n-      pragma Assert (S.L /= 0, \"Error creating Mutex\");\n-\n-      --  Initialize internal condition variable\n-\n-      if DosCreateEventSem\n-        (ICS.Null_Ptr, S.CV'Unchecked_Access, 0, True32) /= NO_ERROR\n-      then\n-         Must_Not_Fail (DosCloseMutexSem (S.L));\n-\n-         raise Storage_Error;\n-      end if;\n-\n-      pragma Assert (S.CV /= 0, \"Error creating Condition Variable\");\n-   end Initialize;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (S : in out Suspension_Object) is\n-   begin\n-      --  Destroy internal mutex\n-\n-      Must_Not_Fail (DosCloseMutexSem (S.L'Access));\n-\n-      --  Destroy internal condition variable\n-\n-      Must_Not_Fail (DosCloseEventSem (S.CV'Access));\n-   end Finalize;\n-\n-   -------------------\n-   -- Current_State --\n-   -------------------\n-\n-   function Current_State (S : Suspension_Object) return Boolean is\n-   begin\n-      --  We do not want to use lock on this read operation. State is marked\n-      --  as Atomic so that we ensure that the value retrieved is correct.\n-\n-      return S.State;\n-   end Current_State;\n-\n-   ---------------\n-   -- Set_False --\n-   ---------------\n-\n-   procedure Set_False (S : in out Suspension_Object) is\n-   begin\n-      Must_Not_Fail (DosRequestMutexSem (S.L, SEM_INDEFINITE_WAIT));\n-\n-      S.State := False;\n-\n-      Must_Not_Fail (DosReleaseMutexSem (S.L));\n-   end Set_False;\n-\n-   --------------\n-   -- Set_True --\n-   --------------\n-\n-   procedure Set_True (S : in out Suspension_Object) is\n-   begin\n-      Must_Not_Fail (DosRequestMutexSem (S.L, SEM_INDEFINITE_WAIT));\n-\n-      --  If there is already a task waiting on this suspension object then\n-      --  we resume it, leaving the state of the suspension object to False,\n-      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n-      --  the state to True.\n-\n-      if S.Waiting then\n-         S.Waiting := False;\n-         S.State := False;\n-\n-         Sem_Must_Not_Fail (DosPostEventSem (S.CV));\n-      else\n-         S.State := True;\n-      end if;\n-\n-      Must_Not_Fail (DosReleaseMutexSem (S.L));\n-   end Set_True;\n-\n-   ------------------------\n-   -- Suspend_Until_True --\n-   ------------------------\n-\n-   procedure Suspend_Until_True (S : in out Suspension_Object) is\n-      Count : aliased ULONG; -- Used to store dummy result\n-   begin\n-      Must_Not_Fail (DosRequestMutexSem (S.L, SEM_INDEFINITE_WAIT));\n-\n-      if S.Waiting then\n-         --  Program_Error must be raised upon calling Suspend_Until_True\n-         --  if another task is already waiting on that suspension object\n-         --  (ARM D.10 par. 10).\n-\n-         Must_Not_Fail (DosReleaseMutexSem (S.L));\n-\n-         raise Program_Error;\n-      else\n-         --  Suspend the task if the state is False. Otherwise, the task\n-         --  continues its execution, and the state of the suspension object\n-         --  is set to False (ARM D.10 par. 9).\n-\n-         if S.State then\n-            S.State := False;\n-\n-            Must_Not_Fail (DosReleaseMutexSem (S.L));\n-         else\n-            S.Waiting := True;\n-\n-            --  Must reset Cond BEFORE L is unlocked\n-\n-            Sem_Must_Not_Fail\n-              (DosResetEventSem (S.CV, Count'Unchecked_Access));\n-\n-            Must_Not_Fail (DosReleaseMutexSem (S.L));\n-\n-            Sem_Must_Not_Fail\n-              (DosWaitEventSem (S.CV, SEM_INDEFINITE_WAIT));\n-         end if;\n-      end if;\n-   end Suspend_Until_True;\n-\n-   ----------------\n-   -- Check_Exit --\n-   ----------------\n-\n-   --  Dummy version\n-\n-   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n-   begin\n-      return Check_No_Locks (Self_ID);\n-   end Check_Exit;\n-\n-   --------------------\n-   -- Check_No_Locks --\n-   --------------------\n-\n-   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n-      TLD : constant Access_Thread_Local_Data := Thread_Local_Data_Ptr;\n-   begin\n-      return Self_ID = TLD.Self_ID\n-        and then TLD.Lock_Prio_Level = 0;\n-   end Check_No_Locks;\n-\n-   ----------------------\n-   -- Environment_Task --\n-   ----------------------\n-\n-   function Environment_Task return Task_Id is\n-   begin\n-      return Environment_Task_Id;\n-   end Environment_Task;\n-\n-   --------------\n-   -- Lock_RTS --\n-   --------------\n-\n-   procedure Lock_RTS is\n-   begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n-   end Lock_RTS;\n-\n-   ----------------\n-   -- Unlock_RTS --\n-   ----------------\n-\n-   procedure Unlock_RTS is\n-   begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n-   end Unlock_RTS;\n-\n-   ------------------\n-   -- Suspend_Task --\n-   ------------------\n-\n-   function Suspend_Task\n-     (T           : ST.Task_Id;\n-      Thread_Self : Thread_Id) return Boolean\n-   is\n-   begin\n-      if Thread_Id (T.Common.LL.Thread) /= Thread_Self then\n-         return DosSuspendThread (T.Common.LL.Thread) = NO_ERROR;\n-      else\n-         return True;\n-      end if;\n-   end Suspend_Task;\n-\n-   -----------------\n-   -- Resume_Task --\n-   -----------------\n-\n-   function Resume_Task\n-     (T           : ST.Task_Id;\n-      Thread_Self : Thread_Id) return Boolean\n-   is\n-   begin\n-      if Thread_Id (T.Common.LL.Thread) /= Thread_Self then\n-         return DosResumeThread (T.Common.LL.Thread) = NO_ERROR;\n-      else\n-         return True;\n-      end if;\n-   end Resume_Task;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (Environment_Task : Task_Id) is\n-      Succeeded : Boolean;\n-   begin\n-      Environment_Task_Id := Environment_Task;\n-\n-      OS_Primitives.Initialize;\n-\n-      --  Initialize pointer to task local data.\n-      --  This is done once, for all tasks.\n-\n-      Must_Not_Fail (DosAllocThreadLocalMemory\n-         ((Thread_Local_Data'Size + 31) / 32,  --  nr of 32-bit words\n-          To_PPVOID (Thread_Local_Data_Ptr'Access)));\n-\n-      --  Initialize thread local data for main thread\n-\n-      Thread_Local_Data_Ptr.Self_ID := null;\n-      Thread_Local_Data_Ptr.Lock_Prio_Level := 0;\n-\n-      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n-      --  Initialize the lock used to synchronize chain of all ATCBs\n-\n-      --  Set ID of environment task\n-\n-      Thread_Local_Data_Ptr.Self_ID := Environment_Task;\n-      Environment_Task.Common.LL.Thread := 1; --  By definition\n-\n-      --  This priority is unknown in fact.\n-      --  If actual current priority is different,\n-      --  it will get synchronized later on anyway.\n-\n-      Environment_Task.Common.LL.Current_Priority :=\n-        Environment_Task.Common.Current_Priority;\n-\n-      --  Initialize TCB for this task.\n-      --  This includes all the normal task-external initialization.\n-      --  This is also done by Initialize_ATCB, why ???\n-\n-      Initialize_TCB (Environment_Task, Succeeded);\n-\n-      --  Consider raising Storage_Error,\n-      --  if propagation can be tolerated ???\n-\n-      pragma Assert (Succeeded);\n-\n-      --  Do normal task-internal initialization,\n-      --  which depends on an initialized TCB.\n-\n-      Enter_Task (Environment_Task);\n-\n-      --  Insert here any other special\n-      --  initialization needed for the environment task.\n-   end Initialize;\n-\n-end System.Task_Primitives.Operations;"}, {"sha": "8f4fbc8df8b223c5646fe9f78ca65d1d8cfa31f9", "filename": "gcc/ada/s-tasinf-irix-athread.adb", "status": "removed", "additions": 0, "deletions": 312, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-tasinf-irix-athread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-tasinf-irix-athread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasinf-irix-athread.adb?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,312 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                     S Y S T E M . T A S K _ I N F O                      --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package body contains the routines associated with the implementation\n---  of the Task_Info pragma.\n-\n---  This is the SGI specific version of this module.\n-\n-with Interfaces.C;\n-with System.OS_Interface;\n-with System;\n-with Unchecked_Conversion;\n-\n-package body System.Task_Info is\n-\n-   use System.OS_Interface;\n-   use type Interfaces.C.int;\n-\n-   function To_Resource_T is new\n-     Unchecked_Conversion (Resource_Vector_T, resource_t);\n-\n-   MP_NPROCS : constant := 1;\n-\n-   function Sysmp (Cmd : Integer) return Integer;\n-   pragma Import (C, Sysmp);\n-\n-   function Num_Processors (Cmd : Integer := MP_NPROCS) return Integer\n-     renames Sysmp;\n-\n-   function Geteuid return Integer;\n-   pragma Import (C, Geteuid);\n-\n-   Locking_Map : constant array (Page_Locking) of Interfaces.C.int :=\n-     (NOLOCK   => 0,\n-      PROCLOCK => 1,\n-      TXTLOCK  => 2,\n-      DATLOCK  => 4);\n-\n-   -------------------------------\n-   -- Resource_Vector_Functions --\n-   -------------------------------\n-\n-   package body Resource_Vector_Functions is\n-\n-      ---------\n-      -- \"+\" --\n-      ---------\n-\n-      function \"+\" (R : Resource_T) return Resource_Vector_T is\n-         Result : Resource_Vector_T  := NO_RESOURCES;\n-      begin\n-         Result (Resource_T'Pos (R)) := True;\n-         return Result;\n-      end \"+\";\n-\n-      function \"+\" (R1, R2 : Resource_T) return Resource_Vector_T is\n-         Result : Resource_Vector_T  := NO_RESOURCES;\n-      begin\n-         Result (Resource_T'Pos (R1)) := True;\n-         Result (Resource_T'Pos (R2)) := True;\n-         return Result;\n-      end \"+\";\n-\n-      function \"+\"\n-        (R : Resource_T;\n-         S : Resource_Vector_T) return Resource_Vector_T\n-      is\n-         Result : Resource_Vector_T := S;\n-      begin\n-         Result (Resource_T'Pos (R)) := True;\n-         return Result;\n-      end \"+\";\n-\n-      function \"+\"\n-        (S : Resource_Vector_T;\n-         R : Resource_T) return Resource_Vector_T\n-      is\n-         Result : Resource_Vector_T :=  S;\n-      begin\n-         Result (Resource_T'Pos (R)) := True;\n-         return Result;\n-      end \"+\";\n-\n-      function \"+\" (S1, S2 : Resource_Vector_T) return Resource_Vector_T is\n-         Result : Resource_Vector_T;\n-      begin\n-         Result :=  S1 or S2;\n-         return Result;\n-      end \"+\";\n-\n-      function \"-\"\n-        (S : Resource_Vector_T;\n-         R : Resource_T) return Resource_Vector_T\n-      is\n-         Result : Resource_Vector_T := S;\n-      begin\n-         Result (Resource_T'Pos (R)) := False;\n-         return Result;\n-      end \"-\";\n-\n-   end Resource_Vector_Functions;\n-\n-   ---------------\n-   -- New_Sproc --\n-   ---------------\n-\n-   function New_Sproc (Attr : Sproc_Attributes) return sproc_t is\n-      Sproc_Attr : aliased sproc_attr_t;\n-      Sproc      : aliased sproc_t;\n-      Status     : int;\n-\n-   begin\n-      Status := sproc_attr_init (Sproc_Attr'Unrestricted_Access);\n-\n-      if Status = 0 then\n-         Status := sproc_attr_setresources\n-           (Sproc_Attr'Unrestricted_Access,\n-            To_Resource_T (Attr.Sproc_Resources));\n-\n-         if Attr.CPU /= ANY_CPU then\n-            if Attr.CPU > Num_Processors then\n-               raise Invalid_CPU_Number;\n-            end if;\n-\n-            Status := sproc_attr_setcpu\n-              (Sproc_Attr'Unrestricted_Access,\n-               int (Attr.CPU));\n-         end if;\n-\n-         if Attr.Resident /= NOLOCK then\n-            if Geteuid /= 0 then\n-               raise Permission_Error;\n-            end if;\n-\n-            Status := sproc_attr_setresident\n-              (Sproc_Attr'Unrestricted_Access,\n-                Locking_Map (Attr.Resident));\n-         end if;\n-\n-         if Attr.NDPRI /= NDP_NONE then\n-\n---  ??? why is this commented out, should it be removed ?\n---          if Geteuid /= 0 then\n---             raise Permission_Error;\n---          end if;\n-\n-            Status :=\n-              sproc_attr_setprio\n-                (Sproc_Attr'Unrestricted_Access, int (Attr.NDPRI));\n-         end if;\n-\n-         Status :=\n-           sproc_create\n-             (Sproc'Unrestricted_Access,\n-              Sproc_Attr'Unrestricted_Access,\n-              null,\n-              System.Null_Address);\n-\n-         if Status /= 0 then\n-            Status := sproc_attr_destroy (Sproc_Attr'Unrestricted_Access);\n-            raise Sproc_Create_Error;\n-         end if;\n-\n-         Status := sproc_attr_destroy (Sproc_Attr'Unrestricted_Access);\n-      end if;\n-\n-      if Status /= 0 then\n-         raise Sproc_Create_Error;\n-      end if;\n-\n-      return Sproc;\n-   end New_Sproc;\n-\n-   ---------------\n-   -- New_Sproc --\n-   ---------------\n-\n-   function New_Sproc\n-     (Sproc_Resources : Resource_Vector_T      := NO_RESOURCES;\n-      CPU             : CPU_Number             := ANY_CPU;\n-      Resident        : Page_Locking           := NOLOCK;\n-      NDPRI           : Non_Degrading_Priority := NDP_NONE) return sproc_t\n-   is\n-      Attr : constant Sproc_Attributes :=\n-               (Sproc_Resources, CPU, Resident, NDPRI);\n-   begin\n-      return New_Sproc (Attr);\n-   end New_Sproc;\n-\n-   -------------------------------\n-   -- Unbound_Thread_Attributes --\n-   -------------------------------\n-\n-   function Unbound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n-      Thread_Timeslice : Duration          := 0.0) return Thread_Attributes\n-   is\n-   begin\n-      return (False, Thread_Resources, Thread_Timeslice);\n-   end Unbound_Thread_Attributes;\n-\n-   -----------------------------\n-   -- Bound_Thread_Attributes --\n-   -----------------------------\n-\n-   function Bound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n-      Thread_Timeslice : Duration          := 0.0;\n-      Sproc            : sproc_t)\n-      return             Thread_Attributes\n-   is\n-   begin\n-      return (True, Thread_Resources, Thread_Timeslice, Sproc);\n-   end Bound_Thread_Attributes;\n-\n-   -----------------------------\n-   -- Bound_Thread_Attributes --\n-   -----------------------------\n-\n-   function Bound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T      := NO_RESOURCES;\n-      Thread_Timeslice : Duration               := 0.0;\n-      Sproc_Resources  : Resource_Vector_T      := NO_RESOURCES;\n-      CPU              : CPU_Number             := ANY_CPU;\n-      Resident         : Page_Locking           := NOLOCK;\n-      NDPRI            : Non_Degrading_Priority := NDP_NONE)\n-      return Thread_Attributes\n-   is\n-      Sproc : constant sproc_t := New_Sproc\n-                (Sproc_Resources, CPU, Resident, NDPRI);\n-   begin\n-      return (True, Thread_Resources, Thread_Timeslice, Sproc);\n-   end Bound_Thread_Attributes;\n-\n-   -----------------------------------\n-   -- New_Unbound_Thread_Attributes --\n-   -----------------------------------\n-\n-   function New_Unbound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n-      Thread_Timeslice : Duration          := 0.0) return Task_Info_Type\n-   is\n-   begin\n-      return new Thread_Attributes'\n-        (False, Thread_Resources, Thread_Timeslice);\n-   end New_Unbound_Thread_Attributes;\n-\n-   ---------------------------------\n-   -- New_Bound_Thread_Attributes --\n-   ---------------------------------\n-\n-   function New_Bound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n-      Thread_Timeslice : Duration          := 0.0;\n-      Sproc            : sproc_t) return Task_Info_Type\n-   is\n-   begin\n-      return new Thread_Attributes'\n-        (True, Thread_Resources, Thread_Timeslice, Sproc);\n-   end  New_Bound_Thread_Attributes;\n-\n-   ---------------------------------\n-   -- New_Bound_Thread_Attributes --\n-   ---------------------------------\n-\n-   function New_Bound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T      := NO_RESOURCES;\n-      Thread_Timeslice : Duration               := 0.0;\n-      Sproc_Resources  : Resource_Vector_T      := NO_RESOURCES;\n-      CPU              : CPU_Number             := ANY_CPU;\n-      Resident         : Page_Locking           := NOLOCK;\n-      NDPRI            : Non_Degrading_Priority := NDP_NONE)\n-      return Task_Info_Type\n-   is\n-      Sproc : constant sproc_t := New_Sproc\n-                (Sproc_Resources, CPU, Resident, NDPRI);\n-   begin\n-      return new Thread_Attributes'\n-        (True, Thread_Resources, Thread_Timeslice, Sproc);\n-   end  New_Bound_Thread_Attributes;\n-\n-end System.Task_Info;"}, {"sha": "96a709d8190c11a0914918fa667d4a3fca6dc9df", "filename": "gcc/ada/s-tasinf-irix-athread.ads", "status": "removed", "additions": 0, "deletions": 274, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-tasinf-irix-athread.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-tasinf-irix-athread.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasinf-irix-athread.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,274 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                     S Y S T E M . T A S K _ I N F O                      --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains the definitions and routines associated with the\n---  implementation and use of the Task_Info pragma. It is specialized\n---  appropriately for targets that make use of this pragma.\n-\n---  Note: the compiler generates direct calls to this interface, via Rtsfind.\n---  Any changes to this interface may require corresponding compiler changes.\n-\n---  This unit may be used directly from an application program by providing\n---  an appropriate WITH, and the interface can be expected to remain stable.\n-\n---  This is the SGI (libathread) specific version of this module\n-\n-with System.OS_Interface;\n-\n-package System.Task_Info is\n-   pragma Preelaborate;\n-   pragma Elaborate_Body;\n-   --  To ensure that a body is allowed\n-\n-   ---------------------------------------------------------\n-   -- Binding of Tasks to sprocs and sprocs to processors --\n-   ---------------------------------------------------------\n-\n-   --  The SGI implementation of the GNU Low-Level Interface (GNULLI)\n-   --  implements each Ada task as a Posix thread (Pthread). The SGI\n-   --  Pthread library distributes threads across one or more processes\n-   --  that are members of a common share group. Irix distributes\n-   --  processes across the available CPUs on a given machine. The\n-   --  pragma Task_Info provides the mechanism to control the distribution\n-   --  of tasks to sprocs, and sprocs to processors.\n-\n-   --  Each thread has a number of attributes that dictate it's scheduling.\n-   --  These attributes are:\n-\n-   --      Bound_To_Sproc:  whether the thread is bound to a specific sproc\n-   --                       for its entire lifetime.\n-\n-   --      Timeslice:       Amount of time that a thread is allowed to execute\n-   --                       before the system yeilds control to another thread\n-   --                       of equal priority.\n-\n-   --      Resource_Vector: A bitmask used to control the binding of threads\n-   --                       to sprocs.\n-   --\n-\n-   --  Each share group process (sproc)\n-\n-   --  The Task_Info pragma:\n-\n-   --    pragma Task_Info (EXPRESSION);\n-\n-   --  allows the specification on a task by task basis of a value of type\n-   --  System.Task_Info.Task_Info_Type to be passed to a task when it is\n-   --  created. The specification of this type, and the effect on the task\n-   --  that is created is target dependent.\n-\n-   --  The Task_Info pragma appears within a task definition (compare the\n-   --  definition and implementation of pragma Priority). If no such pragma\n-   --  appears, then the value Task_Info_Unspecified is passed. If a pragma\n-   --  is present, then it supplies an alternative value. If the argument of\n-   --  the pragma is a discriminant reference, then the value can be set on\n-   --  a task by task basis by supplying the appropriate discriminant value.\n-\n-   --  Note that this means that the type used for Task_Info_Type must be\n-   --  suitable for use as a discriminant (i.e. a scalar or access type).\n-\n-   ----------------------\n-   -- Resource Vectors --\n-   ----------------------\n-\n-   --  <discussion>\n-\n-   type Resource_Vector_T is array (0 .. 31) of Boolean;\n-   pragma Pack (Resource_Vector_T);\n-\n-   NO_RESOURCES : constant Resource_Vector_T := (others => False);\n-\n-   generic\n-      type Resource_T is (<>);\n-      --  Discrete type up to 32 entries\n-\n-   package Resource_Vector_Functions is\n-      function \"+\"\n-        (R : Resource_T) return Resource_Vector_T;\n-\n-      function \"+\"\n-        (R1 : Resource_T;\n-         R2 : Resource_T) return Resource_Vector_T;\n-\n-      function \"+\"\n-        (R : Resource_T;\n-         S : Resource_Vector_T) return Resource_Vector_T;\n-\n-      function \"+\"\n-        (S : Resource_Vector_T;\n-         R : Resource_T) return Resource_Vector_T;\n-\n-      function \"+\"\n-        (S1 : Resource_Vector_T;\n-         S2 : Resource_Vector_T) return Resource_Vector_T;\n-\n-      function \"-\"\n-        (S : Resource_Vector_T;\n-         R : Resource_T) return Resource_Vector_T;\n-   end Resource_Vector_Functions;\n-\n-   ----------------------\n-   -- Sproc Attributes --\n-   ----------------------\n-\n-   subtype sproc_t is System.OS_Interface.sproc_t;\n-\n-   subtype CPU_Number is Integer range -1 .. Integer'Last;\n-\n-   ANY_CPU : constant CPU_Number := CPU_Number'First;\n-\n-   type Non_Degrading_Priority is range 0 .. 255;\n-   --  Specification of IRIX Non Degrading Priorities\n-   --\n-   --  WARNING: IRIX priorities have the reverse meaning of Ada priorities.\n-   --           The lower the priority value, the greater the greater the\n-   --           scheduling preference.\n-   --\n-   --  See the schedctl(2) man page for a complete discussion of non-degrading\n-   --  priorities.\n-\n-   NDPHIMAX : constant Non_Degrading_Priority := 30;\n-   NDPHIMIN : constant Non_Degrading_Priority := 39;\n-   --  These priorities are higher than ALL normal user process priorities\n-\n-   subtype NDP_High is Non_Degrading_Priority range NDPHIMAX .. NDPHIMIN;\n-\n-   NDPNORMMAX : constant Non_Degrading_Priority := 40;\n-   NDPNORMMIN : constant Non_Degrading_Priority := 127;\n-   --  These priorities overlap normal user process priorities\n-\n-   subtype NDP_Norm is Non_Degrading_Priority range NDPNORMMAX .. NDPNORMMIN;\n-\n-   NDPLOMAX : constant Non_Degrading_Priority := 128;\n-   NDPLOMIN : constant Non_Degrading_Priority := 254;\n-   --  These priorities are below ALL normal user process priorities\n-\n-   NDP_NONE   : constant Non_Degrading_Priority := 255;\n-\n-   subtype NDP_LOW is Non_Degrading_Priority range NDPLOMAX .. NDPLOMIN;\n-\n-   type Page_Locking is\n-      (NOLOCK,     --  Do not lock pages in memory\n-       PROCLOCK,   --  Lock text and data segments into memory (process lock)\n-       TXTLOCK,    --  Lock text segment into memory (text lock)\n-       DATLOCK     --  Lock data segment into memory (data lock)\n-      );\n-\n-   type Sproc_Attributes is record\n-      Sproc_Resources : Resource_Vector_T      := NO_RESOURCES;\n-      CPU             : CPU_Number             := ANY_CPU;\n-      Resident        : Page_Locking           := NOLOCK;\n-      NDPRI           : Non_Degrading_Priority := NDP_NONE;\n---  ??? why is that commented out, should it be removed ?\n---       Sproc_Slice     : Duration               := 0.0;\n---       Deadline_Period : Duration               := 0.0;\n---       Deadline_Alloc  : Duration               := 0.0;\n-   end record;\n-\n-   Default_Sproc_Attributes : constant Sproc_Attributes :=\n-      (NO_RESOURCES, ANY_CPU, NOLOCK, NDP_NONE);\n-\n-   function New_Sproc (Attr : Sproc_Attributes) return sproc_t;\n-   function New_Sproc\n-     (Sproc_Resources : Resource_Vector_T      := NO_RESOURCES;\n-      CPU             : CPU_Number             := ANY_CPU;\n-      Resident        : Page_Locking           := NOLOCK;\n-      NDPRI           : Non_Degrading_Priority := NDP_NONE) return sproc_t;\n-   --  Allocates a sproc_t control structure and creates corresponding sproc\n-\n-   Invalid_CPU_Number : exception;\n-   Permission_Error   : exception;\n-   Sproc_Create_Error : exception;\n-\n-   -----------------------\n-   -- Thread Attributes --\n-   -----------------------\n-\n-   type Thread_Attributes (Bound_To_Sproc : Boolean) is record\n-      Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n-\n-      Thread_Timeslice : Duration          := 0.0;\n-\n-      case Bound_To_Sproc is\n-         when False =>\n-            null;\n-         when True   =>\n-            Sproc : sproc_t;\n-      end case;\n-   end record;\n-\n-   Default_Thread_Attributes : constant Thread_Attributes :=\n-     (False, NO_RESOURCES, 0.0);\n-\n-   function Unbound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n-      Thread_Timeslice : Duration          := 0.0) return Thread_Attributes;\n-\n-   function Bound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n-      Thread_Timeslice : Duration          := 0.0;\n-      Sproc            : sproc_t) return Thread_Attributes;\n-\n-   function Bound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T      := NO_RESOURCES;\n-      Thread_Timeslice : Duration               := 0.0;\n-      Sproc_Resources  : Resource_Vector_T      := NO_RESOURCES;\n-      CPU              : CPU_Number             := ANY_CPU;\n-      Resident         : Page_Locking           := NOLOCK;\n-      NDPRI            : Non_Degrading_Priority := NDP_NONE)\n-      return Thread_Attributes;\n-\n-   type Task_Info_Type is access all Thread_Attributes;\n-\n-   function New_Unbound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n-      Thread_Timeslice : Duration          := 0.0)\n-      return Task_Info_Type;\n-\n-   function New_Bound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n-      Thread_Timeslice : Duration          := 0.0;\n-      Sproc            : sproc_t) return Task_Info_Type;\n-\n-   function New_Bound_Thread_Attributes\n-     (Thread_Resources : Resource_Vector_T      := NO_RESOURCES;\n-      Thread_Timeslice : Duration               := 0.0;\n-      Sproc_Resources  : Resource_Vector_T      := NO_RESOURCES;\n-      CPU              : CPU_Number             := ANY_CPU;\n-      Resident         : Page_Locking           := NOLOCK;\n-      NDPRI            : Non_Degrading_Priority := NDP_NONE)\n-      return Task_Info_Type;\n-\n-   Unspecified_Task_Info : constant Task_Info_Type := null;\n-\n-end System.Task_Info;"}, {"sha": "502260e96d2edaa2d7f8c2417b73a4497bbb5ab7", "filename": "gcc/ada/s-taspri-os2.ads", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-taspri-os2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fs-taspri-os2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-os2.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,122 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n---                                                                          --\n---                S Y S T E M . T A S K _ P R I M I T I V E S               --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2005, AdaCore                     --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is an OS/2 version of this package\n-\n---  This package provides low-level support for most tasking features\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during\n---  tasking operations. It causes infinite loops and other problems.\n-\n-with Interfaces.OS2Lib.Threads;\n-with Interfaces.OS2Lib.Synchronization;\n-\n-package System.Task_Primitives is\n-   pragma Preelaborate;\n-\n-   type Lock is limited private;\n-   --  Should be used for implementation of protected objects.\n-\n-   type RTS_Lock is limited private;\n-   --  Should be used inside the runtime system.\n-   --  The difference between Lock and the RTS_Lock is that the later\n-   --  one serves only as a semaphore so that do not check for\n-   --  ceiling violations.\n-\n-   type Task_Body_Access is access procedure;\n-   --  Pointer to the task body's entry point (or possibly a wrapper\n-   --  declared local to the GNARL).\n-\n-   type Private_Data is limited private;\n-   --  Any information that the GNULLI needs maintained on a per-task\n-   --  basis.  A component of this type is guaranteed to be included\n-   --  in the Ada_Task_Control_Block.\n-\n-private\n-\n-   type Lock is record\n-      Mutex          : aliased Interfaces.OS2Lib.Synchronization.HMTX;\n-      Priority       : Integer;\n-      Owner_Priority : Integer;\n-      Owner_ID       : Address;\n-   end record;\n-\n-   type RTS_Lock is new Lock;\n-\n-   type Suspension_Object is record\n-      State : Boolean;\n-      pragma Atomic (State);\n-      --  Boolean that indicates whether the object is open. This field is\n-      --  marked Atomic to ensure that we can read its value without locking\n-      --  the access to the Suspension_Object.\n-\n-      Waiting : Boolean;\n-      --  Flag showing if there is a task already suspended on this object\n-\n-      L : aliased Interfaces.OS2Lib.Synchronization.HMTX;\n-      --  Protection for ensuring mutual exclusion on the Suspension_Object\n-\n-      CV : aliased Interfaces.OS2Lib.Synchronization.HEV;\n-      --  Condition variable used to queue threads until condition is signaled\n-   end record;\n-\n-   type Private_Data is record\n-      Thread : aliased Interfaces.OS2Lib.Threads.TID;\n-      pragma Atomic (Thread);\n-      --  Thread field may be updated by two different threads of control.\n-      --  (See, Enter_Task and Create_Task in s-taprop.adb). They put the same\n-      --  value (thr_self value). We do not want to use lock on those\n-      --  operations and the only thing we have to make sure is that they are\n-      --  updated in atomic fashion.\n-\n-      CV : aliased Interfaces.OS2Lib.Synchronization.HEV;\n-\n-      L  : aliased RTS_Lock;\n-      --  Protection for all components is lock L\n-\n-      Current_Priority : Integer := -1;\n-      --  The Current_Priority is the actual priority of a thread. This field\n-      --  is needed because it is only possible to set delta priority in OS/2.\n-      --  The only places where this field should be set are Set_Priority,\n-      --  Create_Task and Initialize (Environment).\n-\n-      Wrapper : Interfaces.OS2Lib.Threads.PFNTHREAD;\n-      --  This is the original wrapper passed by Operations.Create_Task. When\n-      --  installing an exception handler in a thread, the thread starts\n-      --  executing the Exception_Wrapper which calls Wrapper when the handler\n-      --  has been installed. The handler is removed when wrapper returns.\n-   end record;\n-\n-end System.Task_Primitives;"}, {"sha": "65c9461c05014b2ab8ae0deb2186bfc6bf8a1a0d", "filename": "gcc/ada/system-os2.ads", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fsystem-os2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fsystem-os2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-os2.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,153 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAT RUN-TIME COMPONENTS                          --\n---                                                                          --\n---                               S Y S T E M                                --\n---                                                                          --\n---                                 S p e c                                  --\n---                             (OS/2 Version)                               --\n---                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-package System is\n-   pragma Pure;\n-   --  Note that we take advantage of the implementation permission to make\n-   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada\n-   --  2005, this is Pure in any case (AI-362).\n-\n-   type Name is (SYSTEM_NAME_GNAT);\n-   System_Name : constant Name := SYSTEM_NAME_GNAT;\n-\n-   --  System-Dependent Named Numbers\n-\n-   Min_Int               : constant := Long_Long_Integer'First;\n-   Max_Int               : constant := Long_Long_Integer'Last;\n-\n-   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n-   Max_Nonbinary_Modulus : constant := Integer'Last;\n-\n-   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n-   Max_Digits            : constant := Long_Long_Float'Digits;\n-\n-   Max_Mantissa          : constant := 63;\n-   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n-\n-   Tick                  : constant := 0.01;\n-\n-   --  Storage-related Declarations\n-\n-   type Address is private;\n-   Null_Address : constant Address;\n-\n-   Storage_Unit : constant := 8;\n-   Word_Size    : constant := 32;\n-   Memory_Size  : constant := 2 ** 32;\n-\n-   --  Address comparison\n-\n-   function \"<\"  (Left, Right : Address) return Boolean;\n-   function \"<=\" (Left, Right : Address) return Boolean;\n-   function \">\"  (Left, Right : Address) return Boolean;\n-   function \">=\" (Left, Right : Address) return Boolean;\n-   function \"=\"  (Left, Right : Address) return Boolean;\n-\n-   pragma Import (Intrinsic, \"<\");\n-   pragma Import (Intrinsic, \"<=\");\n-   pragma Import (Intrinsic, \">\");\n-   pragma Import (Intrinsic, \">=\");\n-   pragma Import (Intrinsic, \"=\");\n-\n-   --  Other System-Dependent Declarations\n-\n-   type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n-\n-   --  Priority-related Declarations (RM D.1)\n-\n-   Max_Priority           : constant Positive := 30;\n-   Max_Interrupt_Priority : constant Positive := 31;\n-\n-   subtype Any_Priority       is Integer      range  0 .. 31;\n-   subtype Priority           is Any_Priority range  0 .. 30;\n-   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n-\n-   Default_Priority : constant Priority := 15;\n-\n-private\n-\n-   type Address is mod Memory_Size;\n-   Null_Address : constant Address := 0;\n-\n-   --------------------------------------\n-   -- System Implementation Parameters --\n-   --------------------------------------\n-\n-   --  These parameters provide information about the target that is used\n-   --  by the compiler. They are in the private part of System, where they\n-   --  can be accessed using the special circuitry in the Targparm unit\n-   --  whose source should be consulted for more detailed descriptions\n-   --  of the individual switch values.\n-\n-   AAMP                      : constant Boolean := False;\n-   Backend_Divide_Checks     : constant Boolean := False;\n-   Backend_Overflow_Checks   : constant Boolean := False;\n-   Command_Line_Args         : constant Boolean := True;\n-   Compiler_System_Version   : constant Boolean := False;\n-   Configurable_Run_Time     : constant Boolean := False;\n-   Denorm                    : constant Boolean := True;\n-   Duration_32_Bits          : constant Boolean := False;\n-   Exit_Status_Supported     : constant Boolean := True;\n-   Fractional_Fixed_Ops      : constant Boolean := False;\n-   Frontend_Layout           : constant Boolean := False;\n-   Functions_Return_By_DSP   : constant Boolean := False;\n-   Machine_Overflows         : constant Boolean := False;\n-   Machine_Rounds            : constant Boolean := True;\n-   OpenVMS                   : constant Boolean := False;\n-   Preallocated_Stacks       : constant Boolean := False;\n-   Signed_Zeros              : constant Boolean := True;\n-   Stack_Check_Default       : constant Boolean := False;\n-   Stack_Check_Probes        : constant Boolean := False;\n-   Support_64_Bit_Divides    : constant Boolean := True;\n-   Support_Aggregates        : constant Boolean := True;\n-   Support_Composite_Assign  : constant Boolean := True;\n-   Support_Composite_Compare : constant Boolean := True;\n-   Support_Long_Shifts       : constant Boolean := True;\n-   Suppress_Standard_Library : constant Boolean := False;\n-   Use_Ada_Main_Program_Name : constant Boolean := False;\n-   ZCX_By_Default            : constant Boolean := False;\n-   GCC_ZCX_Support           : constant Boolean := False;\n-   Front_End_ZCX_Support     : constant Boolean := True;\n-\n-   --  Obsolete entries, to be removed eventually (bootstrap issues!)\n-\n-   High_Integrity_Mode       : constant Boolean := False;\n-   Long_Shifts_Inlined       : constant Boolean := True;\n-\n-end System;"}, {"sha": "801968d514181e7cd050b5e595c7a1d883ac3e81", "filename": "gcc/ada/system-unixware.ads", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fsystem-unixware.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17/gcc%2Fada%2Fsystem-unixware.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-unixware.ads?ref=5b4fdb2060e0d1820ebabfcf7ed7e350ee52ef17", "patch": "@@ -1,153 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAT RUN-TIME COMPONENTS                          --\n---                                                                          --\n---                               S Y S T E M                                --\n---                                                                          --\n---                                 S p e c                                  --\n---                         (SCO UnixWare Version)                           --\n---                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-package System is\n-   pragma Pure;\n-   --  Note that we take advantage of the implementation permission to make\n-   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada\n-   --  2005, this is Pure in any case (AI-362).\n-\n-   type Name is (SYSTEM_NAME_GNAT);\n-   System_Name : constant Name := SYSTEM_NAME_GNAT;\n-\n-   --  System-Dependent Named Numbers\n-\n-   Min_Int               : constant := Long_Long_Integer'First;\n-   Max_Int               : constant := Long_Long_Integer'Last;\n-\n-   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n-   Max_Nonbinary_Modulus : constant := Integer'Last;\n-\n-   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n-   Max_Digits            : constant := Long_Long_Float'Digits;\n-\n-   Max_Mantissa          : constant := 63;\n-   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n-\n-   Tick                  : constant := 0.01;\n-\n-   --  Storage-related Declarations\n-\n-   type Address is private;\n-   Null_Address : constant Address;\n-\n-   Storage_Unit : constant := 8;\n-   Word_Size    : constant := 32;\n-   Memory_Size  : constant := 2 ** 32;\n-\n-   --  Address comparison\n-\n-   function \"<\"  (Left, Right : Address) return Boolean;\n-   function \"<=\" (Left, Right : Address) return Boolean;\n-   function \">\"  (Left, Right : Address) return Boolean;\n-   function \">=\" (Left, Right : Address) return Boolean;\n-   function \"=\"  (Left, Right : Address) return Boolean;\n-\n-   pragma Import (Intrinsic, \"<\");\n-   pragma Import (Intrinsic, \"<=\");\n-   pragma Import (Intrinsic, \">\");\n-   pragma Import (Intrinsic, \">=\");\n-   pragma Import (Intrinsic, \"=\");\n-\n-   --  Other System-Dependent Declarations\n-\n-   type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n-\n-   --  Priority-related Declarations (RM D.1)\n-\n-   Max_Priority           : constant Positive := 30;\n-   Max_Interrupt_Priority : constant Positive := 31;\n-\n-   subtype Any_Priority       is Integer      range  0 .. 31;\n-   subtype Priority           is Any_Priority range  0 .. 30;\n-   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n-\n-   Default_Priority : constant Priority := 15;\n-\n-private\n-\n-   type Address is mod Memory_Size;\n-   Null_Address : constant Address := 0;\n-\n-   --------------------------------------\n-   -- System Implementation Parameters --\n-   --------------------------------------\n-\n-   --  These parameters provide information about the target that is used\n-   --  by the compiler. They are in the private part of System, where they\n-   --  can be accessed using the special circuitry in the Targparm unit\n-   --  whose source should be consulted for more detailed descriptions\n-   --  of the individual switch values.\n-\n-   AAMP                      : constant Boolean := False;\n-   Backend_Divide_Checks     : constant Boolean := False;\n-   Backend_Overflow_Checks   : constant Boolean := False;\n-   Command_Line_Args         : constant Boolean := True;\n-   Compiler_System_Version   : constant Boolean := False;\n-   Configurable_Run_Time     : constant Boolean := False;\n-   Denorm                    : constant Boolean := True;\n-   Duration_32_Bits          : constant Boolean := False;\n-   Exit_Status_Supported     : constant Boolean := True;\n-   Fractional_Fixed_Ops      : constant Boolean := False;\n-   Frontend_Layout           : constant Boolean := False;\n-   Functions_Return_By_DSP   : constant Boolean := False;\n-   Machine_Overflows         : constant Boolean := False;\n-   Machine_Rounds            : constant Boolean := True;\n-   OpenVMS                   : constant Boolean := False;\n-   Preallocated_Stacks       : constant Boolean := False;\n-   Signed_Zeros              : constant Boolean := True;\n-   Stack_Check_Default       : constant Boolean := False;\n-   Stack_Check_Probes        : constant Boolean := False;\n-   Support_64_Bit_Divides    : constant Boolean := True;\n-   Support_Aggregates        : constant Boolean := True;\n-   Support_Composite_Assign  : constant Boolean := True;\n-   Support_Composite_Compare : constant Boolean := True;\n-   Support_Long_Shifts       : constant Boolean := True;\n-   Suppress_Standard_Library : constant Boolean := False;\n-   Use_Ada_Main_Program_Name : constant Boolean := False;\n-   ZCX_By_Default            : constant Boolean := False;\n-   GCC_ZCX_Support           : constant Boolean := False;\n-   Front_End_ZCX_Support     : constant Boolean := False;\n-\n-   --  Obsolete entries, to be removed eventually (bootstrap issues!)\n-\n-   High_Integrity_Mode       : constant Boolean := False;\n-   Long_Shifts_Inlined       : constant Boolean := True;\n-\n-end System;"}]}