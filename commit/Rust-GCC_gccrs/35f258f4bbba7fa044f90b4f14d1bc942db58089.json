{"sha": "35f258f4bbba7fa044f90b4f14d1bc942db58089", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVmMjU4ZjRiYmJhN2ZhMDQ0ZjkwYjRmMTRkMWJjOTQyZGI1ODA4OQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-20T14:38:24Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-20T14:38:24Z"}, "message": "libgomp: Fix up bootstrap in libgomp/target.c due to false positive warning\n\n> On 10/20/20 2:11 PM, Tobias Burnus wrote:\n>\n> > Unfortunately, the committed patch\n> > (r11-4121-g1bfc07d150790fae93184a79a7cce897655cb37b)\n> > causes build errors.\n> >\n> > The error seems to be provoked by function cloning \u2013 as the code\n> > itself looks fine:\n> > ...\n> >  struct gomp_device_descr *devices_s\n> >     = malloc (num_devices * sizeof (struct gomp_device_descr));\n> > ...\n> >   for (i = 0; i < num_devices; i++)\n> >     if (!(devices[i].capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n> >       devices_s[num_devices_after_openmp++] = devices[i];\n>\n> gomp_target_init.part.0 ()\n> {\n> ...\n> <bb 2>\n>   devices_s_1 = malloc (0);\n> ...\n>   num_devices.16_67 = num_devices;\n> ...\n>   if (num_devices.16_67 > 0)\n>     goto <bb 3>; [89.00%]\n>   else\n>     goto <bb 18>; [11.00%]\n>\n> Which seems to have an ordering problem.\n\nThis patch fixes the warning that breaks the bootstrap.\n\n2020-10-20  Jakub Jelinek  <jakub@redhat.com>\n\n\t* target.c (gomp_target_init): Inside of the function, use automatic\n\tvariables corresponding to num_devices, num_devices_openmp and devices\n\tglobal variables and update the globals only at the end of the\n\tfunction.", "tree": {"sha": "a2902ab3016de36a8cef088607d373eb30f9bb1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2902ab3016de36a8cef088607d373eb30f9bb1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35f258f4bbba7fa044f90b4f14d1bc942db58089", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35f258f4bbba7fa044f90b4f14d1bc942db58089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35f258f4bbba7fa044f90b4f14d1bc942db58089", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35f258f4bbba7fa044f90b4f14d1bc942db58089/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "953277ba3fa39a9285cf89f59932b0169e7f6b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953277ba3fa39a9285cf89f59932b0169e7f6b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/953277ba3fa39a9285cf89f59932b0169e7f6b9d"}], "stats": {"total": 76, "additions": 39, "deletions": 37}, "files": [{"sha": "97f0cdd2a42b0ac80b78b6c1437b6847bf90099e", "filename": "libgomp/target.c", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35f258f4bbba7fa044f90b4f14d1bc942db58089/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35f258f4bbba7fa044f90b4f14d1bc942db58089/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=35f258f4bbba7fa044f90b4f14d1bc942db58089", "patch": "@@ -3279,10 +3279,9 @@ gomp_target_init (void)\n   const char *suffix = SONAME_SUFFIX (1);\n   const char *cur, *next;\n   char *plugin_name;\n-  int i, new_num_devices;\n-\n-  num_devices = 0;\n-  devices = NULL;\n+  int i, new_num_devs;\n+  int num_devs = 0, num_devs_openmp;\n+  struct gomp_device_descr *devs = NULL;\n \n   if (gomp_target_offload_var == GOMP_TARGET_OFFLOAD_DISABLED)\n     return;\n@@ -3303,7 +3302,7 @@ gomp_target_init (void)\n \tplugin_name = (char *) malloc (prefix_len + cur_len + suffix_len + 1);\n \tif (!plugin_name)\n \t  {\n-\t    num_devices = 0;\n+\t    num_devs = 0;\n \t    break;\n \t  }\n \n@@ -3313,16 +3312,16 @@ gomp_target_init (void)\n \n \tif (gomp_load_plugin_for_device (&current_device, plugin_name))\n \t  {\n-\t    new_num_devices = current_device.get_num_devices_func ();\n-\t    if (new_num_devices >= 1)\n+\t    new_num_devs = current_device.get_num_devices_func ();\n+\t    if (new_num_devs >= 1)\n \t      {\n \t\t/* Augment DEVICES and NUM_DEVICES.  */\n \n-\t\tdevices = realloc (devices, (num_devices + new_num_devices)\n-\t\t\t\t   * sizeof (struct gomp_device_descr));\n-\t\tif (!devices)\n+\t\tdevs = realloc (devs, (num_devs + new_num_devs)\n+\t\t\t\t      * sizeof (struct gomp_device_descr));\n+\t\tif (!devs)\n \t\t  {\n-\t\t    num_devices = 0;\n+\t\t    num_devs = 0;\n \t\t    free (plugin_name);\n \t\t    break;\n \t\t  }\n@@ -3332,12 +3331,12 @@ gomp_target_init (void)\n \t\tcurrent_device.type = current_device.get_type_func ();\n \t\tcurrent_device.mem_map.root = NULL;\n \t\tcurrent_device.state = GOMP_DEVICE_UNINITIALIZED;\n-\t\tfor (i = 0; i < new_num_devices; i++)\n+\t\tfor (i = 0; i < new_num_devs; i++)\n \t\t  {\n \t\t    current_device.target_id = i;\n-\t\t    devices[num_devices] = current_device;\n-\t\t    gomp_mutex_init (&devices[num_devices].lock);\n-\t\t    num_devices++;\n+\t\t    devs[num_devs] = current_device;\n+\t\t    gomp_mutex_init (&devs[num_devs].lock);\n+\t\t    num_devs++;\n \t\t  }\n \t      }\n \t  }\n@@ -3349,34 +3348,37 @@ gomp_target_init (void)\n \n   /* In DEVICES, sort the GOMP_OFFLOAD_CAP_OPENMP_400 ones first, and set\n      NUM_DEVICES_OPENMP.  */\n-  struct gomp_device_descr *devices_s\n-    = malloc (num_devices * sizeof (struct gomp_device_descr));\n-  if (!devices_s)\n-    {\n-      num_devices = 0;\n-      free (devices);\n-      devices = NULL;\n-    }\n-  num_devices_openmp = 0;\n-  for (i = 0; i < num_devices; i++)\n-    if (devices[i].capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n-      devices_s[num_devices_openmp++] = devices[i];\n-  int num_devices_after_openmp = num_devices_openmp;\n-  for (i = 0; i < num_devices; i++)\n-    if (!(devices[i].capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n-      devices_s[num_devices_after_openmp++] = devices[i];\n-  free (devices);\n-  devices = devices_s;\n-\n-  for (i = 0; i < num_devices; i++)\n+  struct gomp_device_descr *devs_s\n+    = malloc (num_devs * sizeof (struct gomp_device_descr));\n+  if (!devs_s)\n+    {\n+      num_devs = 0;\n+      free (devs);\n+      devs = NULL;\n+    }\n+  num_devs_openmp = 0;\n+  for (i = 0; i < num_devs; i++)\n+    if (devs[i].capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n+      devs_s[num_devs_openmp++] = devs[i];\n+  int num_devs_after_openmp = num_devs_openmp;\n+  for (i = 0; i < num_devs; i++)\n+    if (!(devs[i].capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n+      devs_s[num_devs_after_openmp++] = devs[i];\n+  free (devs);\n+  devs = devs_s;\n+\n+  for (i = 0; i < num_devs; i++)\n     {\n       /* The 'devices' array can be moved (by the realloc call) until we have\n \t found all the plugins, so registering with the OpenACC runtime (which\n \t takes a copy of the pointer argument) must be delayed until now.  */\n-      if (devices[i].capabilities & GOMP_OFFLOAD_CAP_OPENACC_200)\n-\tgoacc_register (&devices[i]);\n+      if (devs[i].capabilities & GOMP_OFFLOAD_CAP_OPENACC_200)\n+\tgoacc_register (&devs[i]);\n     }\n \n+  num_devices = num_devs;\n+  num_devices_openmp = num_devs_openmp;\n+  devices = devs;\n   if (atexit (gomp_target_fini) != 0)\n     gomp_fatal (\"atexit failed\");\n }"}]}