{"sha": "4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJjY2IzOWViYWVjYzNjOTFlYThhZWU1OGRjMGM3MWQ1YTdlM2I5NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-06-25T17:18:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-06-25T17:18:12Z"}, "message": "Makefile.in (TARGET_DEF): Add target-insns.def.\n\ngcc/\n\t* Makefile.in (TARGET_DEF): Add target-insns.def.\n\t(.PRECIOUS, simple_rtl_generated_h): Add insn-target-def.h.\n\t(build/gentarget-def.o): New rule.\n\t(genprogrtl): Add target-def.\n\t* target-insns.def, gentarget-def.c: New files.\n\t* target.def: Add targetm.have_* and targetm.gen_* hooks,\n\tbased on the contents of target-insns.def.\n\t* defaults.h (HAVE_simple_return, gen_simple_return): Delete.\n\t(HAVE_return, gen_return): Delete.\n\t* target-def.h: Include insn-target-def.h.\n\t* cfgrtl.c (force_nonfallthru_and_redirect): Use targetm interface\n\tinstead of direct calls.  Rely on them to do the appropriate assertions.\n\t* function.c (gen_return_pattern): Likewise.  Return an rtx_insn *.\n\t(convert_jumps_to_returns): Use targetm interface instead of\n\tdirect calls.\n\t(thread_prologue_and_epilogue_insns): Likewise.\n\t* reorg.c (find_end_label, dbr_schedule): Likewise.\n\t* shrink-wrap.h (SHRINK_WRAPPING_ENABLED): Likewise.\n\t* shrink-wrap.c (convert_to_simple_return): Likewise.\n\t(try_shrink_wrapping): Use SHRINK_WRAPPING_ENABLED.\n\nFrom-SVN: r224979", "tree": {"sha": "d4c2043c4d2fe1765f3dec6cc791fa7b0f3a1899", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4c2043c4d2fe1765f3dec6cc791fa7b0f3a1899"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d58627a0c75748b24e1c182d0c4cc1d5136cb42c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d58627a0c75748b24e1c182d0c4cc1d5136cb42c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d58627a0c75748b24e1c182d0c4cc1d5136cb42c"}], "stats": {"total": 428, "additions": 372, "deletions": 56}, "files": [{"sha": "ff6333cbae64d6955d6f6d2ab2a3e1471724ef32", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -1,3 +1,26 @@\n+2015-06-25  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* Makefile.in (TARGET_DEF): Add target-insns.def.\n+\t(.PRECIOUS, simple_rtl_generated_h): Add insn-target-def.h.\n+\t(build/gentarget-def.o): New rule.\n+\t(genprogrtl): Add target-def.\n+\t* target-insns.def, gentarget-def.c: New files.\n+\t* target.def: Add targetm.have_* and targetm.gen_* hooks,\n+\tbased on the contents of target-insns.def.\n+\t* defaults.h (HAVE_simple_return, gen_simple_return): Delete.\n+\t(HAVE_return, gen_return): Delete.\n+\t* target-def.h: Include insn-target-def.h.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect): Use targetm interface\n+\tinstead of direct calls.  Rely on them to do the appropriate assertions.\n+\t* function.c (gen_return_pattern): Likewise.  Return an rtx_insn *.\n+\t(convert_jumps_to_returns): Use targetm interface instead of\n+\tdirect calls.\n+\t(thread_prologue_and_epilogue_insns): Likewise.\n+\t* reorg.c (find_end_label, dbr_schedule): Likewise.\n+\t* shrink-wrap.h (SHRINK_WRAPPING_ENABLED): Likewise.\n+\t* shrink-wrap.c (convert_to_simple_return): Likewise.\n+\t(try_shrink_wrapping): Use SHRINK_WRAPPING_ENABLED.\n+\n 2015-06-25  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64.c, config/alpha/alpha.c, config/arm/arm.c,"}, {"sha": "89eda968d521e368216db6fd0945ec9a806fea43", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -866,7 +866,7 @@ DUMPFILE_H = $(srcdir)/../libcpp/include/line-map.h dumpfile.h\n VEC_H = vec.h statistics.h $(GGC_H)\n HASH_TABLE_H = $(HASHTAB_H) hash-table.h\n EXCEPT_H = except.h $(HASHTAB_H)\n-TARGET_DEF = target.def target-hooks-macros.h\n+TARGET_DEF = target.def target-hooks-macros.h target-insns.def\n C_TARGET_DEF = c-family/c-target.def target-hooks-macros.h\n COMMON_TARGET_DEF = common/common-target.def target-hooks-macros.h\n TARGET_H = $(TM_H) target.h $(TARGET_DEF) insn-modes.h insn-codes.h\n@@ -2078,7 +2078,8 @@ $(common_out_object_file): $(common_out_file)\n .PRECIOUS: insn-config.h insn-flags.h insn-codes.h insn-constants.h \\\n   insn-emit.c insn-recog.c insn-extract.c insn-output.c insn-peep.c \\\n   insn-attr.h insn-attr-common.h insn-attrtab.c insn-dfatab.c \\\n-  insn-latencytab.c insn-preds.c gimple-match.c generic-match.c\n+  insn-latencytab.c insn-preds.c gimple-match.c generic-match.c \\\n+  insn-target-def.h\n \n # Dependencies for the md file.  The first time through, we just assume\n # the md file itself and the generated dependency file (in order to get\n@@ -2099,7 +2100,7 @@ s-mddeps: $(md_file) $(MD_INCLUDES) build/genmddeps$(build_exeext)\n # the target file.\n \n simple_rtl_generated_h\t= insn-attr.h insn-attr-common.h insn-codes.h \\\n-\t\t\t  insn-config.h insn-flags.h\n+\t\t\t  insn-config.h insn-flags.h insn-target-def.h\n \n simple_rtl_generated_c\t= insn-automata.c insn-emit.c \\\n \t\t\t  insn-extract.c insn-output.c \\\n@@ -2498,6 +2499,9 @@ build/genextract.o : genextract.c $(RTL_BASE_H) $(BCONFIG_H)\t\t\\\n   $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n build/genflags.o : genflags.c $(RTL_BASE_H) $(OBSTACK_H) $(BCONFIG_H)\t\\\n   $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n+build/gentarget-def.o : gentarget-def.c $(BCONFIG_H) $(SYSTEM_H)\t\\\n+  coretypes.h $(GTM_H) $(RTL_BASE_H) errors.h $(READ_MD_H) gensupport.h\t\\\n+  $(HASH_TABLE_H) target-insns.def\n build/gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def\n \n # The gengtype generator program is special: Two versions are built.\n@@ -2562,7 +2566,7 @@ build/genmatch.o : genmatch.c $(BCONFIG_H) $(SYSTEM_H) \\\n \n # All these programs use the RTL reader ($(BUILD_RTL)).\n genprogrtl = attr attr-common attrtab automata codes conditions config emit \\\n-\t     extract flags opinit output peep preds recog mddump\n+\t     extract flags mddump opinit output peep preds recog target-def\n $(genprogrtl:%=build/gen%$(build_exeext)): $(BUILD_RTL)\n \n # All these programs use the MD reader ($(BUILD_MD))."}, {"sha": "2e33dda2f81581062ad411a7234e54e5e4110dfe", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -1695,19 +1695,12 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n   if (target == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       if (jump_label == ret_rtx)\n-\t{\n-\t  if (!HAVE_return)\n-\t    gcc_unreachable ();\n-\n-\t  emit_jump_insn_after_setloc (gen_return (), BB_END (jump_block), loc);\n-\t}\n+\temit_jump_insn_after_setloc (targetm.gen_return (),\n+\t\t\t\t     BB_END (jump_block), loc);\n       else\n \t{\n \t  gcc_assert (jump_label == simple_return_rtx);\n-\t  if (!HAVE_simple_return)\n-\t    gcc_unreachable ();\n-\n-\t  emit_jump_insn_after_setloc (gen_simple_return (),\n+\t  emit_jump_insn_after_setloc (targetm.gen_simple_return (),\n \t\t\t\t       BB_END (jump_block), loc);\n \t}\n       set_return_jump_label (BB_END (jump_block));"}, {"sha": "5534e42d8a0ba6fda73c5a063927c059b5984969", "filename": "gcc/defaults.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -1426,26 +1426,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_VTABLE_USES_DESCRIPTORS 0\n #endif\n \n-#ifndef HAVE_simple_return\n-#define HAVE_simple_return 0\n-static inline rtx\n-gen_simple_return ()\n-{\n-  gcc_unreachable ();\n-  return NULL;\n-}\n-#endif\n-\n-#ifndef HAVE_return\n-#define HAVE_return 0\n-static inline rtx\n-gen_return ()\n-{\n-  gcc_unreachable ();\n-  return NULL;\n-}\n-#endif\n-\n #ifndef HAVE_epilogue\n #define HAVE_epilogue 0\n static inline rtx"}, {"sha": "cffe32322d2f00e46576b6ae076f925bfd85d219", "filename": "gcc/function.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -5614,13 +5614,12 @@ emit_use_return_register_into_block (basic_block bb)\n /* Create a return pattern, either simple_return or return, depending on\n    simple_p.  */\n \n-static rtx\n+static rtx_insn *\n gen_return_pattern (bool simple_p)\n {\n-  if (!HAVE_simple_return)\n-    gcc_assert (!simple_p);\n-\n-  return simple_p ? gen_simple_return () : gen_return ();\n+  return (simple_p\n+\t  ? targetm.gen_simple_return ()\n+\t  : targetm.gen_return ());\n }\n \n /* Insert an appropriate return pattern at the end of block BB.  This\n@@ -5726,7 +5725,7 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n \t    dest = ret_rtx;\n \t  if (!redirect_jump (as_a <rtx_jump_insn *> (jump), dest, 0))\n \t    {\n-\t      if (HAVE_simple_return && simple_p)\n+\t      if (targetm.have_simple_return () && simple_p)\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n@@ -5747,7 +5746,7 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n \t}\n       else\n \t{\n-\t  if (HAVE_simple_return && simple_p)\n+\t  if (targetm.have_simple_return () && simple_p)\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file,\n@@ -5938,12 +5937,12 @@ thread_prologue_and_epilogue_insns (void)\n \n   exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n \n-  if (HAVE_simple_return && entry_edge != orig_entry_edge)\n+  if (targetm.have_simple_return () && entry_edge != orig_entry_edge)\n     exit_fallthru_edge\n \t= get_unconverted_simple_return (exit_fallthru_edge, bb_flags,\n \t\t\t\t\t &unconverted_simple_returns,\n \t\t\t\t\t &returnjump);\n-  if (HAVE_return)\n+  if (targetm.have_return ())\n     {\n       if (exit_fallthru_edge == NULL)\n \tgoto epilogue_done;\n@@ -5964,7 +5963,8 @@ thread_prologue_and_epilogue_insns (void)\n \n \t      /* Emitting the return may add a basic block.\n \t\t Fix bb_flags for the added block.  */\n-\t      if (HAVE_simple_return && last_bb != exit_fallthru_edge->src)\n+\t      if (targetm.have_simple_return ()\n+\t\t  && last_bb != exit_fallthru_edge->src)\n \t\tbitmap_set_bit (&bb_flags, last_bb->index);\n \n \t      goto epilogue_done;\n@@ -6080,7 +6080,7 @@ thread_prologue_and_epilogue_insns (void)\n \t}\n     }\n \n-  if (HAVE_simple_return)\n+  if (targetm.have_simple_return ())\n     convert_to_simple_return (entry_edge, orig_entry_edge, bb_flags,\n \t\t\t      returnjump, unconverted_simple_returns);\n \n@@ -6096,8 +6096,9 @@ thread_prologue_and_epilogue_insns (void)\n \n       if (!CALL_P (insn)\n \t  || ! SIBLING_CALL_P (insn)\n-\t  || (HAVE_simple_return && (entry_edge != orig_entry_edge\n-\t\t\t\t     && !bitmap_bit_p (&bb_flags, bb->index))))\n+\t  || (targetm.have_simple_return ()\n+\t      && entry_edge != orig_entry_edge\n+\t      && !bitmap_bit_p (&bb_flags, bb->index)))\n \t{\n \t  ei_next (&ei);\n \t  continue;"}, {"sha": "d4839e881d9c8ea156e739b6327eabe531e7806b", "filename": "gcc/gentarget-def.c", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Fgentarget-def.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Fgentarget-def.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgentarget-def.c?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -0,0 +1,265 @@\n+/* Generate insn-target-def.h, an automatically-generated part of targetm.\n+   Copyright (C) 1987-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"bconfig.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"errors.h\"\n+#include \"read-md.h\"\n+#include \"gensupport.h\"\n+#include \"hash-table.h\"\n+\n+/* This class hashes define_insns and define_expands by name.  */\n+struct insn_hasher : nofree_ptr_hash <rtx_def>\n+{\n+  typedef rtx value_type;\n+  typedef const char *compare_type;\n+\n+  static inline hashval_t hash (rtx);\n+  static inline bool equal (rtx, const char *);\n+};\n+\n+hashval_t\n+insn_hasher::hash (rtx x)\n+{\n+  return htab_hash_string (XSTR (x, 0));\n+}\n+\n+bool\n+insn_hasher::equal (rtx x, const char *y)\n+{\n+  return strcmp (XSTR (x, 0), y) == 0;\n+}\n+\n+/* All define_insns and define_expands, hashed by name.  */\n+static hash_table <insn_hasher> *insns;\n+\n+/* Records the prototype suffix X for each invalid_X stub that has been\n+   generated.  */\n+static hash_table <nofree_string_hash> *stubs;\n+\n+/* Records which C conditions have been wrapped in functions, as a mapping\n+   from the C condition to the function name.  */\n+static hash_map <nofree_string_hash, const char *> *have_funcs;\n+\n+/* Output hook definitions for pattern NAME, which has target-insns.def\n+   prototype PROTOTYPE.  */\n+\n+static void\n+def_target_insn (const char *name, const char *prototype)\n+{\n+  /* Get an upper-case form of NAME.  */\n+  unsigned int i;\n+  char *upper_name = XALLOCAVEC (char, strlen (name) + 1);\n+  for (i = 0; name[i]; ++i)\n+    upper_name[i] = TOUPPER (name[i]);\n+  upper_name[i] = 0;\n+\n+  /* Check that the prototype is valid and concatenate the types\n+     together to get a suffix.  */\n+  char *suffix = XALLOCAVEC (char, strlen (prototype) + 1);\n+  i = 0;\n+  unsigned int opno = 0;\n+  for (const char *p = prototype; *p; ++p)\n+    if (*p == 'x' && ISDIGIT (p[1]))\n+      {\n+\t/* This should be a parameter name of the form \"x<OPNO>\".\n+\t   That doesn't contribute to the suffix, so skip ahead and\n+\t   process the following character.  */\n+\tchar *endptr;\n+\tif (strtol (p + 1, &endptr, 10) != opno\n+\t    || (*endptr != ',' && *endptr != ')'))\n+\t  {\n+\t    error (\"invalid prototype for '%s'\", name);\n+\t    exit (FATAL_EXIT_CODE);\n+\t  }\n+\topno += 1;\n+\tp = endptr;\n+\tif (*p == ',')\n+\t  suffix[i++] = '_';\n+      }\n+    else if (*p == ')' || *p == ',')\n+      {\n+\t/* We found the end of a parameter without finding a\n+\t   parameter name.  */\n+\tif (strcmp (prototype, \"(void)\") != 0)\n+\t  {\n+\t    error (\"argument %d of '%s' did not have the expected name\",\n+\t\t   opno, name);\n+\t    exit (FATAL_EXIT_CODE);\n+\t  }\n+      }\n+    else if (*p != '(' && !ISSPACE (*p))\n+      suffix[i++] = *p;\n+  suffix[i] = 0;\n+\n+  /* See whether we have an implementation of this pattern.  */\n+  hashval_t hash = htab_hash_string (name);\n+  int truth = 0;\n+  const char *have_name = name;\n+  if (rtx insn = insns->find_with_hash (name, hash))\n+    {\n+      const char *test = XSTR (insn, 2);\n+      truth = maybe_eval_c_test (test);\n+      gcc_assert (truth != 0);\n+      if (truth < 0)\n+\t{\n+\t  /* Try to reuse an existing function that performs the same test.  */\n+\t  bool existed;\n+\t  const char *&entry = have_funcs->get_or_insert (test, &existed);\n+\t  if (!existed)\n+\t    {\n+\t      entry = name;\n+\t      printf (\"\\nstatic bool\\n\");\n+\t      printf (\"target_have_%s (void)\\n\", name);\n+\t      printf (\"{\\n\");\n+\t      printf (\"  return \");\n+\t      print_c_condition (test);\n+\t      printf (\";\\n\");\n+\t      printf (\"}\\n\");\n+\t    }\n+\t  have_name = entry;\n+\t}\n+      printf (\"\\nstatic rtx_insn *\\n\");\n+      printf (\"target_gen_%s %s\\n\", name, prototype);\n+      printf (\"{\\n\");\n+      if (truth < 0)\n+\tprintf (\"  gcc_checking_assert (targetm.have_%s ());\\n\", name);\n+      printf (\"  return insnify (gen_%s (\", name);\n+      for (i = 0; i < opno; ++i)\n+\tprintf (\"%sx%d\", i == 0 ? \"\" : \", \", i);\n+      printf (\"));\\n\");\n+      printf (\"}\\n\");\n+    }\n+  else\n+    {\n+      const char **slot = stubs->find_slot (suffix, INSERT);\n+      if (!*slot)\n+\t{\n+\t  *slot = xstrdup (suffix);\n+\t  printf (\"\\nstatic rtx_insn *\\n\");\n+\t  printf (\"invalid_%s \", suffix);\n+\t  const char *p = prototype;\n+\t  while (*p)\n+\t    {\n+\t      if (p[0] == 'x' && ISDIGIT (p[1]))\n+\t\t{\n+\t\t  char *endptr;\n+\t\t  strtol (p + 1, &endptr, 10);\n+\t\t  p = endptr;\n+\t\t}\n+\t      else\n+\t\tfputc (*p++, stdout);\n+\t    }\n+\t  printf (\"\\n{\\n\");\n+\t  printf (\"  gcc_unreachable ();\\n\");\n+\t  printf (\"}\\n\");\n+\t}\n+    }\n+  printf (\"\\n#undef TARGET_HAVE_%s\\n\", upper_name);\n+  printf (\"#define TARGET_HAVE_%s \", upper_name);\n+  if (truth == 0)\n+    printf (\"hook_bool_void_false\\n\");\n+  else if (truth == 1)\n+    printf (\"hook_bool_void_true\\n\");\n+  else\n+    printf (\"target_have_%s\\n\", have_name);\n+\n+  printf (\"#undef TARGET_GEN_%s\\n\", upper_name);\n+  printf (\"#define TARGET_GEN_%s \", upper_name);\n+  if (truth == 0)\n+    printf (\"invalid_%s\\n\", suffix);\n+  else\n+    printf (\"target_gen_%s\\n\", name);\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int insn_code_number = 0;\n+\n+  progname = \"gentarget-def\";\n+\n+  if (!init_rtx_reader_args (argc, argv))\n+    return (FATAL_EXIT_CODE);\n+\n+  insns = new hash_table <insn_hasher> (31);\n+  stubs = new hash_table <nofree_string_hash> (31);\n+  have_funcs = new hash_map <nofree_string_hash, const char *>;\n+\n+  while (1)\n+    {\n+      int line_no;\n+      rtx desc = read_md_rtx (&line_no, &insn_code_number);\n+      if (desc == NULL)\n+\tbreak;\n+      if (GET_CODE (desc) == DEFINE_INSN || GET_CODE (desc) == DEFINE_EXPAND)\n+\t{\n+\t  const char *name = XSTR (desc, 0);\n+\t  if (name[0] != 0 && name[0] != '*')\n+\t    {\n+\t      hashval_t hash = htab_hash_string (name);\n+\t      rtx *slot = insns->find_slot_with_hash (name, hash, INSERT);\n+\t      if (*slot)\n+\t\t{\n+\t\t  message_with_line (line_no, \"duplicate definition of '%s'\",\n+\t\t\t\t     name);\n+\t\t  have_error = 1;\n+\t\t}\n+\t      else\n+\t\t*slot = desc;\n+\t    }\n+\t}\n+    }\n+\n+  printf (\"/* Generated automatically by the program `gentarget-def'.  */\\n\");\n+  printf (\"#ifndef GCC_INSN_TARGET_DEF_H\\n\");\n+  printf (\"#define GCC_INSN_TARGET_DEF_H\\n\");\n+\n+  /* Output a routine to convert an rtx to an rtx_insn sequence.\n+     ??? At some point the gen_* functions themselves should return\n+\t rtx_insns.  */\n+  printf (\"\\nstatic inline rtx_insn *\\n\");\n+  printf (\"insnify (rtx x)\\n\");\n+  printf (\"{\\n\");\n+  printf (\"  if (!x)\\n\");\n+  printf (\"    return NULL;\\n\");\n+  printf (\"  if (rtx_insn *insn = dyn_cast <rtx_insn *> (x))\\n\");\n+  printf (\"    return insn;\\n\");\n+  printf (\"  start_sequence ();\\n\");\n+  printf (\"  emit (x);\\n\");\n+  printf (\"  rtx_insn *res = get_insns ();\\n\");\n+  printf (\"  end_sequence ();\\n\");\n+  printf (\"  return res;\\n\");\n+  printf (\"}\\n\");\n+\n+#define DEF_TARGET_INSN(INSN, ARGS) \\\n+  def_target_insn (#INSN, #ARGS);\n+#include \"target-insns.def\"\n+#undef DEF_TARGET_INSN\n+\n+  printf (\"\\n#endif /* GCC_INSN_TARGET_DEF_H */\\n\");\n+\n+  if (have_error || ferror (stdout) || fflush (stdout) || fclose (stdout))\n+    return FATAL_EXIT_CODE;\n+\n+  return SUCCESS_EXIT_CODE;\n+}"}, {"sha": "b24a3f04388398b7b8c15d6acb2df84114a53e8c", "filename": "gcc/reorg.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -473,7 +473,7 @@ find_end_label (rtx kind)\n \t}\n       else\n \t{\n-\t  if (HAVE_epilogue && ! HAVE_return)\n+\t  if (HAVE_epilogue && ! targetm.have_return ())\n \t    /* The RETURN insn has its delay slot filled so we cannot\n \t       emit the label just before it.  Since we already have\n \t       an epilogue and cannot emit a new RETURN, we cannot\n@@ -483,10 +483,10 @@ find_end_label (rtx kind)\n \t  /* Otherwise, make a new label and emit a RETURN and BARRIER,\n \t     if needed.  */\n \t  emit_label (label);\n-\t  if (HAVE_return)\n+\t  if (targetm.have_return ())\n \t    {\n \t      /* The return we make may have delay slots too.  */\n-\t      rtx pat = gen_return ();\n+\t      rtx_insn *pat = targetm.gen_return ();\n \t      rtx_insn *insn = emit_jump_insn (pat);\n \t      set_return_jump_label (insn);\n \t      emit_barrier ();\n@@ -3815,8 +3815,9 @@ dbr_schedule (rtx_insn *first)\n     delete_related_insns (function_simple_return_label);\n \n   need_return_insns = false;\n-  need_return_insns |= HAVE_return && function_return_label != 0;\n-  need_return_insns |= HAVE_simple_return && function_simple_return_label != 0;\n+  need_return_insns |= targetm.have_return () && function_return_label != 0;\n+  need_return_insns |= (targetm.have_simple_return ()\n+\t\t\t&& function_simple_return_label != 0);\n   if (need_return_insns)\n     make_return_insns (first);\n "}, {"sha": "51c0e7bfd71ca0efab1c580aa2635f5cf0a7e306", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -541,7 +541,7 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n \tbreak;\n       }\n \n-  if (flag_shrink_wrap && HAVE_simple_return\n+  if (SHRINK_WRAPPING_ENABLED\n       && (targetm.profile_before_prologue () || !crtl->profile)\n       && nonempty_prologue && !crtl->calls_eh_return)\n     {\n@@ -1004,8 +1004,8 @@ convert_to_simple_return (edge entry_edge, edge orig_entry_edge,\n \n \t      bb = create_basic_block (NULL, NULL, exit_pred);\n \t      BB_COPY_PARTITION (bb, e->src);\n-\t      rtx_jump_insn *start = emit_jump_insn_after (gen_simple_return (),\n-\t\t\t\t\t\t\t   BB_END (bb));\n+\t      rtx_insn *ret = targetm.gen_simple_return ();\n+\t      rtx_jump_insn *start = emit_jump_insn_after (ret, BB_END (bb));\n \t      JUMP_LABEL (start) = simple_return_rtx;\n \t      emit_barrier_after (start);\n "}, {"sha": "dda9b926f5ce9e08a3e04dfb4e5fc7fb4a4d2350", "filename": "gcc/shrink-wrap.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Fshrink-wrap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Fshrink-wrap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.h?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -36,7 +36,8 @@ extern void convert_to_simple_return (edge entry_edge, edge orig_entry_edge,\n \t\t\t\t      bitmap_head bb_flags,\n \t\t\t\t      rtx_insn *returnjump,\n \t\t\t\t      vec<edge> unconverted_simple_returns);\n-#define SHRINK_WRAPPING_ENABLED (flag_shrink_wrap && HAVE_simple_return)\n+#define SHRINK_WRAPPING_ENABLED \\\n+  (flag_shrink_wrap && targetm.have_simple_return ())\n \n #endif  /* GCC_SHRINK_WRAP_H  */\n "}, {"sha": "d24aad411527dea4ffb009d20d773b18a77f3e63", "filename": "gcc/target-def.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -107,3 +107,4 @@\n \n #include \"hooks.h\"\n #include \"targhooks.h\"\n+#include \"insn-target-def.h\""}, {"sha": "bf5b36742b52c59874cf76a06f93ddf36b20b940", "filename": "gcc/target-insns.def", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Ftarget-insns.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Ftarget-insns.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-insns.def?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -0,0 +1,34 @@\n+/* Target instruction definitions.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file has one entry for each public pattern name that the target\n+   can provide.  It is only used if no distinction between operand modes\n+   is necessary.  If separate patterns are needed for different modes\n+   (so as to distinguish addition of QImode values from addition of\n+   HImode values, for example) then an optab should be used instead.\n+\n+   Each entry has the form:\n+\n+     DEF_TARGET_INSN (name, prototype)\n+\n+   where NAME is the name of the pattern and PROTOTYPE is its C prototype.\n+   The prototype should use parameter names of the form \"x0\", \"x1\", etc.\n+   Patterns that take no operands should have a prototype \"(void)\".\n+\n+   Instructions should be documented in md.texi rather than here.  */\n+DEF_TARGET_INSN (return, (void))\n+DEF_TARGET_INSN (simple_return, (void))"}, {"sha": "dabb1f27018848d36e969b1970f0bd71cb0d91c1", "filename": "gcc/target.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=4bccb39ebaecc3c91ea8aee58dc0c71d5a7e3b95", "patch": "@@ -5864,6 +5864,19 @@ DEFHOOK\n \n HOOK_VECTOR_END (mode_switching)\n \n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_\"\n+\n+#define DEF_TARGET_INSN(NAME, PROTO) \\\n+  DEFHOOK_UNDOC (have_##NAME, \"\", bool, (void), false)\n+#include \"target-insns.def\"\n+#undef DEF_TARGET_INSN\n+\n+#define DEF_TARGET_INSN(NAME, PROTO) \\\n+  DEFHOOK_UNDOC (gen_##NAME, \"\", rtx_insn *, PROTO, NULL)\n+#include \"target-insns.def\"\n+#undef DEF_TARGET_INSN\n+\n /* Close the 'struct gcc_target' definition.  */\n HOOK_VECTOR_END (C90_EMPTY_HACK)\n "}]}