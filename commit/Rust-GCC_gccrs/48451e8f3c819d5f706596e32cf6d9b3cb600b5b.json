{"sha": "48451e8f3c819d5f706596e32cf6d9b3cb600b5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg0NTFlOGYzYzgxOWQ1ZjcwNjU5NmUzMmNmNmQ5YjNjYjYwMGI1Yg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-05-07T13:18:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-05-07T13:18:07Z"}, "message": "match.pd (bit_and (plus/minus (convert @0) (convert @1) mask): New simplifier to narrow arithmetic.\n\n\t* match.pd (bit_and (plus/minus (convert @0) (convert @1) mask): New\n\tsimplifier to narrow arithmetic.\n\t* generic-match-head.c: (types_match, single_use): New functions.\n\t* gimple-match-head.c: (types_match, single_use): New functions.\n\n\t* gcc.dg/tree-ssa/shorten-1.c: New test.\n\nFrom-SVN: r222877", "tree": {"sha": "5cc975e1ee19aa16d83a69b02b66bd72b50748e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cc975e1ee19aa16d83a69b02b66bd72b50748e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48451e8f3c819d5f706596e32cf6d9b3cb600b5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48451e8f3c819d5f706596e32cf6d9b3cb600b5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48451e8f3c819d5f706596e32cf6d9b3cb600b5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/comments", "author": null, "committer": null, "parents": [{"sha": "963ba1b266651a71ad1eee55607ea9ee34c1de7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/963ba1b266651a71ad1eee55607ea9ee34c1de7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/963ba1b266651a71ad1eee55607ea9ee34c1de7c"}], "stats": {"total": 178, "additions": 165, "deletions": 13}, "files": [{"sha": "78ba4b2eac3845dffa26d347e4d2eb2c5268cc71", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48451e8f3c819d5f706596e32cf6d9b3cb600b5b", "patch": "@@ -1,3 +1,10 @@\n+2015-05-07  Jeff Law  <law@redhat.com>\n+\n+\t* match.pd (bit_and (plus/minus (convert @0) (convert @1) mask): New\n+\tsimplifier to narrow arithmetic.\n+\t* generic-match-head.c: (types_match, single_use): New functions.\n+\t* gimple-match-head.c: (types_match, single_use): New functions.\n+\n 2015-05-07  Venkataramanan Kumar  <venkataramanan.kumar@amd.com>\n \n \t* combine.c (make_compound_operation): Remove checks for PLUS/MINUS"}, {"sha": "efaa2d8b7ce48608fdb941064d085c8e99142617", "filename": "gcc/generic-match-head.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2Fgeneric-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2Fgeneric-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match-head.c?ref=48451e8f3c819d5f706596e32cf6d9b3cb600b5b", "patch": "@@ -70,4 +70,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"generic-match.h\"\n \n+/* Routine to determine if the types T1 and T2 are effectively\n+   the same for GENERIC.  */\n \n+static inline bool\n+types_match (tree t1, tree t2)\n+{\n+  return TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2);\n+}\n+\n+/* Return if T has a single use.  For GENERIC, we assume this is\n+   always true.  */\n+\n+static inline bool\n+single_use (tree t ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}"}, {"sha": "7b9348b53ec014538ba457b89543c551059d962c", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=48451e8f3c819d5f706596e32cf6d9b3cb600b5b", "patch": "@@ -861,3 +861,21 @@ do_valueize (tree (*valueize)(tree), tree op)\n   return op;\n }\n \n+/* Routine to determine if the types T1 and T2 are effectively\n+   the same for GIMPLE.  */\n+\n+static inline bool\n+types_match (tree t1, tree t2)\n+{\n+  return types_compatible_p (t1, t2);\n+}\n+\n+/* Return if T has a single use.  For GIMPLE, we also allow any\n+   non-SSA_NAME (ie constants) and zero uses to cope with uses\n+   that aren't linked up yet.  */\n+\n+static inline bool\n+single_use (tree t)\n+{\n+  return TREE_CODE (t) != SSA_NAME || has_zero_uses (t) || has_single_use (t);\n+}"}, {"sha": "51a950acaa960c49afb17db612856ca61f6926eb", "filename": "gcc/match.pd", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=48451e8f3c819d5f706596e32cf6d9b3cb600b5b", "patch": "@@ -289,8 +289,7 @@ along with GCC; see the file COPYING3.  If not see\n   (if (((TREE_CODE (@1) == INTEGER_CST\n \t && INTEGRAL_TYPE_P (TREE_TYPE (@0))\n \t && int_fits_type_p (@1, TREE_TYPE (@0)))\n-\t|| (GIMPLE && types_compatible_p (TREE_TYPE (@0), TREE_TYPE (@1)))\n-\t|| (GENERIC && TREE_TYPE (@0) == TREE_TYPE (@1)))\n+\t|| types_match (TREE_TYPE (@0), TREE_TYPE (@1)))\n        /* ???  This transform conflicts with fold-const.c doing\n \t  Convert (T)(x & c) into (T)x & (T)c, if c is an integer\n \t  constants (if x has signed type, the sign bit cannot be set\n@@ -949,8 +948,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Unordered tests if either argument is a NaN.  */\n (simplify\n  (bit_ior (unordered @0 @0) (unordered @1 @1))\n- (if ((GIMPLE && types_compatible_p (TREE_TYPE (@0), TREE_TYPE (@1)))\n-      || (GENERIC && TREE_TYPE (@0) == TREE_TYPE (@1)))\n+ (if (types_match (TREE_TYPE (@0), TREE_TYPE (@1)))\n   (unordered @0 @1)))\n (simplify\n  (bit_ior:c (unordered @0 @0) (unordered:c@2 @0 @1))\n@@ -1054,7 +1052,7 @@ along with GCC; see the file COPYING3.  If not see\n    operation and convert the result to the desired type.  */\n (for op (plus minus)\n   (simplify\n-    (convert (op (convert@2 @0) (convert@3 @1)))\n+    (convert (op@4 (convert@2 @0) (convert@3 @1)))\n     (if (INTEGRAL_TYPE_P (type)\n \t /* We check for type compatibility between @0 and @1 below,\n \t    so there's no need to check that @1/@3 are integral types.  */\n@@ -1070,15 +1068,45 @@ along with GCC; see the file COPYING3.  If not see\n \t && TYPE_PRECISION (type) == GET_MODE_PRECISION (TYPE_MODE (type))\n \t /* The inner conversion must be a widening conversion.  */\n \t && TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (TREE_TYPE (@0))\n-\t && ((GENERIC \n-\t      && (TYPE_MAIN_VARIANT (TREE_TYPE (@0))\n-\t\t  == TYPE_MAIN_VARIANT (TREE_TYPE (@1)))\n-\t      && (TYPE_MAIN_VARIANT (TREE_TYPE (@0))\n-\t\t  == TYPE_MAIN_VARIANT (type)))\n-\t     || (GIMPLE\n-\t\t && types_compatible_p (TREE_TYPE (@0), TREE_TYPE (@1))\n-\t\t && types_compatible_p (TREE_TYPE (@0), type))))\n+\t && types_match (TREE_TYPE (@0), TREE_TYPE (@1))\n+\t && types_match (TREE_TYPE (@0), type)\n+\t && single_use (@4))\n       (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n \t(convert (op @0 @1)))\n       (with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n \t(convert (op (convert:utype @0) (convert:utype @1)))))))\n+\n+/* This is another case of narrowing, specifically when there's an outer\n+   BIT_AND_EXPR which masks off bits outside the type of the innermost\n+   operands.   Like the previous case we have to convert the operands\n+   to unsigned types to avoid introducing undefined behaviour for the\n+   arithmetic operation.  */\n+(for op (minus plus)\n+  (simplify\n+    (bit_and (op@5 (convert@2 @0) (convert@3 @1)) INTEGER_CST@4)\n+    (if (INTEGRAL_TYPE_P (type)\n+\t /* We check for type compatibility between @0 and @1 below,\n+\t    so there's no need to check that @1/@3 are integral types.  */\n+\t && INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+\t && INTEGRAL_TYPE_P (TREE_TYPE (@2))\n+\t /* The precision of the type of each operand must match the\n+\t    precision of the mode of each operand, similarly for the\n+\t    result.  */\n+\t && (TYPE_PRECISION (TREE_TYPE (@0))\n+\t     == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@0))))\n+\t && (TYPE_PRECISION (TREE_TYPE (@1))\n+\t     == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@1))))\n+\t && TYPE_PRECISION (type) == GET_MODE_PRECISION (TYPE_MODE (type))\n+\t /* The inner conversion must be a widening conversion.  */\n+\t && TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (TREE_TYPE (@0))\n+\t && types_match (TREE_TYPE (@0), TREE_TYPE (@1))\n+\t && (tree_int_cst_min_precision (@4, UNSIGNED)\n+\t     <= TYPE_PRECISION (TREE_TYPE (@0)))\n+\t && single_use (@5))\n+      (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n+\t(with { tree ntype = TREE_TYPE (@0); }\n+\t  (convert (bit_and (op @0 @1) (convert:ntype @4)))))\n+      (with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n+\t(convert (bit_and (op (convert:utype @0) (convert:utype @1))\n+\t\t\t  (convert:utype @4)))))))\n+"}, {"sha": "1bf57d1dca63fba153825debbb7b9aec7f6ad537", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=48451e8f3c819d5f706596e32cf6d9b3cb600b5b", "patch": "@@ -1,3 +1,7 @@\n+2015-05-07  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/shorten-1.c: New test.\n+\n 2015-05-07  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/66002"}, {"sha": "c9015c58aa6d49d2e75b570bee2c22f082da611d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/shorten-1.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fshorten-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48451e8f3c819d5f706596e32cf6d9b3cb600b5b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fshorten-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fshorten-1.c?ref=48451e8f3c819d5f706596e32cf6d9b3cb600b5b", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+extern const unsigned char mode_ibit[];\n+extern const unsigned char mode_fbit[];\n+extern const signed char smode_ibit[];\n+extern const signed char smode_fbit[];\n+\n+/* We use bit-and rather than modulo to ensure we're actually\n+   testing the desired match.pd pattern.  */\n+unsigned char\n+muufubar (int indx)\n+{\n+  int ret = (mode_fbit [indx] - mode_ibit [indx]) & 3;\n+  return ret;\n+}\n+\n+signed char\n+msufubar (int indx)\n+{\n+  int ret = (mode_fbit [indx] - mode_ibit [indx]) & 3;\n+  return ret;\n+}\n+\n+unsigned char\n+musfubar (int indx)\n+{\n+  int ret = (smode_fbit [indx] - smode_ibit [indx]) & 3;\n+  return ret;\n+}\n+\n+signed char\n+mssfubar (int indx)\n+{\n+  int ret = (smode_fbit [indx] - smode_ibit [indx]) & 3;\n+  return ret;\n+}\n+\n+\n+unsigned char\n+puufubar (int indx)\n+{\n+  int ret = (mode_fbit [indx] + mode_ibit [indx]) & 3;\n+  return ret;\n+}\n+\n+signed char\n+psufubar (int indx)\n+{\n+  int ret = (mode_fbit [indx] + mode_ibit [indx]) & 3;\n+  return ret;\n+}\n+\n+unsigned char\n+pusfubar (int indx)\n+{\n+  int ret = (smode_fbit [indx] + smode_ibit [indx]) & 3;\n+  return ret;\n+}\n+\n+signed char\n+pssfubar (int indx)\n+{\n+  int ret = (smode_fbit [indx] + smode_ibit [indx]) & 3;\n+  return ret;\n+}\n+\n+/* The shortening patterns in match.pd should arrange to do the\n+   arithmetic in char modes and thus any casts to ints should\n+   have been removed.  */\n+/* { dg-final {scan-tree-dump-not \"\\\\(int\\\\)\" \"optimized\"} } */\n+\n+/* We should have casted 4 operands from signed to unsigned char types.  */\n+/* { dg-final {scan-tree-dump-times \"\\\\(unsigned char\\\\)\" 8 \"optimized\" } } */\n+\n+/* And two return values should have been casted from unsigned char to\n+   a normal char.  */\n+/* { dg-final {scan-tree-dump-times \"\\\\(signed char\\\\)\" 4 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}