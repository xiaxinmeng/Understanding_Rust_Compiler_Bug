{"sha": "9d1a6119590ef828f9782a7083d03e535bc2f2cf", "node_id": "C_kwDOANBUbNoAKDlkMWE2MTE5NTkwZWY4MjhmOTc4MmE3MDgzZDAzZTUzNWJjMmYyY2Y", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-04-14T07:20:49Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-04-14T07:20:49Z"}, "message": "combine: Fix AND handling for WORD_REGISTER_OPERATIONS targets [PR109040]\n\nThe following testcase is miscompiled on riscv since the addition\nof *mvconst_internal define_insn_and_split.\nWe have:\n(insn 36 35 39 2 (set (mem/c:SI (plus:SI (reg/f:SI 65 frame)\n                (const_int -64 [0xffffffffffffffc0])) [2  S4 A128])\n        (reg:SI 166)) \"pr109040.c\":9:11 178 {*movsi_internal}\n     (expr_list:REG_DEAD (reg:SI 166)\n        (nil)))\n(insn 39 36 40 2 (set (reg:SI 171)\n        (zero_extend:SI (mem/c:HI (plus:SI (reg/f:SI 65 frame)\n                    (const_int -64 [0xffffffffffffffc0])) [0  S2 A128]))) \"pr109040.c\":9:11 111 {*zero_extendhisi2}\n     (nil))\nand RTL DSE's replace_read since r0-86337-g18b526e806ab6455 handles\neven different modes like in the above case, and so it optimizes it into:\n(insn 47 35 39 2 (set (reg:HI 175)\n        (subreg:HI (reg:SI 166) 0)) \"pr109040.c\":9:11 179 {*movhi_internal}\n     (expr_list:REG_DEAD (reg:SI 166)\n        (nil)))\n(insn 39 47 40 2 (set (reg:SI 171)\n        (zero_extend:SI (reg:HI 175))) \"pr109040.c\":9:11 111 {*zero_extendhisi2}\n     (expr_list:REG_DEAD (reg:HI 175)\n        (nil)))\nPseudo 166 is result of AND with 0x8084c constant (forced into a register).\nCombine attempts to combine the AND with the insn 47 above created by DSE,\nand turns it because of WORD_REGISTER_OPERATIONS and its assumption that all\nthe subword operations are actually done on word mode into:\n(set (subreg:SI (reg:HI 175) 0)\n    (and:SI (reg:SI 167 [ m ])\n        (reg:SI 168)))\nand later on the ZERO_EXTEND is thrown away.\n\nWe then see\n(and:SI (subreg:SI (reg:HI 175) 0) (const_int 0x84c))\nand optimize that into\n(subreg:SI (and:HI (reg:HI 175) (const_int 0x84c)) 0)\nwhich is still fine, in WORD_REGISTER_OPERATIONS the AND in HImode\nwill set all upper bits up to BITS_PER_WORD to zeros.\n\nBut later on simplify_binary_operation_1 or simplify_and_const_int_1\nsees that because nonzero_bits ((reg:HI 175), HImode) == 0x84c, we can\noptimize the AND into (reg:HI 175).  That isn't correct, because while\nthe low 16 bits of that REG are known to have all bits but 0x84c cleared,\nwe don't know that all the upper 16 bits are all clear as well.\nSo, for WORD_REGISTER_OPERATIONS for integral modes smaller than word mode,\nwe need to check all bits from word_mode in nonzero_bits for the optimizations.\n\n2023-04-14  Jeff Law  <jlaw@ventanamicro.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/108947\n\tPR target/109040\n\t* combine.cc (simplify_and_const_int_1): Compute nonzero_bits in\n\tword_mode rather than mode if WORD_REGISTER_OPERATIONS and mode is\n\tsmaller than word_mode.\n\t* simplify-rtx.cc (simplify_context::simplify_binary_operation_1)\n\t<case AND>: Likewise.\n\n\t* gcc.dg/pr108947.c: New test.\n\t* gcc.c-torture/execute/pr109040.c: New test.", "tree": {"sha": "8bb7585f319e13760d52a765a6aa01a8338bd509", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bb7585f319e13760d52a765a6aa01a8338bd509"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d1a6119590ef828f9782a7083d03e535bc2f2cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1a6119590ef828f9782a7083d03e535bc2f2cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d1a6119590ef828f9782a7083d03e535bc2f2cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1a6119590ef828f9782a7083d03e535bc2f2cf/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2134fcfee8b338a6f10273457145fc071dc8f092", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2134fcfee8b338a6f10273457145fc071dc8f092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2134fcfee8b338a6f10273457145fc071dc8f092"}], "stats": {"total": 61, "additions": 57, "deletions": 4}, "files": [{"sha": "0106092e456895925740396c05d1813061aaed82", "filename": "gcc/combine.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1a6119590ef828f9782a7083d03e535bc2f2cf/gcc%2Fcombine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1a6119590ef828f9782a7083d03e535bc2f2cf/gcc%2Fcombine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.cc?ref=9d1a6119590ef828f9782a7083d03e535bc2f2cf", "patch": "@@ -10055,9 +10055,12 @@ simplify_and_const_int_1 (scalar_int_mode mode, rtx varop,\n \n   /* See what bits may be nonzero in VAROP.  Unlike the general case of\n      a call to nonzero_bits, here we don't care about bits outside\n-     MODE.  */\n+     MODE unless WORD_REGISTER_OPERATIONS is true.  */\n \n-  nonzero = nonzero_bits (varop, mode) & GET_MODE_MASK (mode);\n+  scalar_int_mode tmode = mode;\n+  if (WORD_REGISTER_OPERATIONS && GET_MODE_BITSIZE (mode) < BITS_PER_WORD)\n+    tmode = word_mode;\n+  nonzero = nonzero_bits (varop, tmode) & GET_MODE_MASK (tmode);\n \n   /* Turn off all bits in the constant that are known to already be zero.\n      Thus, if the AND isn't needed at all, we will have CONSTOP == NONZERO_BITS\n@@ -10071,7 +10074,7 @@ simplify_and_const_int_1 (scalar_int_mode mode, rtx varop,\n \n   /* If VAROP is a NEG of something known to be zero or 1 and CONSTOP is\n      a power of two, we can replace this with an ASHIFT.  */\n-  if (GET_CODE (varop) == NEG && nonzero_bits (XEXP (varop, 0), mode) == 1\n+  if (GET_CODE (varop) == NEG && nonzero_bits (XEXP (varop, 0), tmode) == 1\n       && (i = exact_log2 (constop)) >= 0)\n     return simplify_shift_const (NULL_RTX, ASHIFT, mode, XEXP (varop, 0), i);\n "}, {"sha": "ee75079917f8359dbb8bfa378a8a634894105b30", "filename": "gcc/simplify-rtx.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1a6119590ef828f9782a7083d03e535bc2f2cf/gcc%2Fsimplify-rtx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1a6119590ef828f9782a7083d03e535bc2f2cf/gcc%2Fsimplify-rtx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.cc?ref=9d1a6119590ef828f9782a7083d03e535bc2f2cf", "patch": "@@ -3752,7 +3752,13 @@ simplify_context::simplify_binary_operation_1 (rtx_code code,\n \treturn op0;\n       if (HWI_COMPUTABLE_MODE_P (mode))\n \t{\n-\t  HOST_WIDE_INT nzop0 = nonzero_bits (trueop0, mode);\n+\t  /* When WORD_REGISTER_OPERATIONS is true, we need to know the\n+\t     nonzero bits in WORD_MODE rather than MODE.  */\n+\t  scalar_int_mode tmode = as_a <scalar_int_mode> (mode);\n+\t  if (WORD_REGISTER_OPERATIONS\n+\t      && GET_MODE_BITSIZE (tmode) < BITS_PER_WORD)\n+\t    tmode = word_mode;\n+\t  HOST_WIDE_INT nzop0 = nonzero_bits (trueop0, tmode);\n \t  HOST_WIDE_INT nzop1;\n \t  if (CONST_INT_P (trueop1))\n \t    {"}, {"sha": "b0dedd50e790dca0cb911210c45648451a9bd95c", "filename": "gcc/testsuite/gcc.c-torture/execute/pr109040.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1a6119590ef828f9782a7083d03e535bc2f2cf/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr109040.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1a6119590ef828f9782a7083d03e535bc2f2cf/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr109040.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr109040.c?ref=9d1a6119590ef828f9782a7083d03e535bc2f2cf", "patch": "@@ -0,0 +1,23 @@\n+/* PR target/109040 */\n+\n+typedef unsigned short __attribute__((__vector_size__ (32))) V;\n+\n+unsigned short a, b, c, d;\n+\n+void\n+foo (V m, unsigned short *ret)\n+{\n+  V v = 6 > ((V) { 2124, 8 } & m);\n+  unsigned short uc = v[0] + a + b + c + d;\n+  *ret = uc;\n+}\n+\n+int\n+main ()\n+{\n+  unsigned short x;\n+  foo ((V) { 0, 15 }, &x);\n+  if (x != (unsigned short) ~0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "2fe2f5c6e5762e8d26a497cee6c3148837223e40", "filename": "gcc/testsuite/gcc.dg/pr108947.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1a6119590ef828f9782a7083d03e535bc2f2cf/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108947.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1a6119590ef828f9782a7083d03e535bc2f2cf/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108947.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108947.c?ref=9d1a6119590ef828f9782a7083d03e535bc2f2cf", "patch": "@@ -0,0 +1,21 @@\n+/* PR target/108947 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-forward-propagate -Wno-psabi\" } */\n+\n+typedef unsigned short __attribute__((__vector_size__ (2 * sizeof (short)))) V;\n+\n+__attribute__((__noipa__)) V\n+foo (V v)\n+{\n+  V w = 3 > (v & 3992);\n+  return w;\n+}\n+\n+int\n+main ()\n+{\n+  V w = foo ((V) { 0, 9 });\n+  if (w[0] != 0xffff || w[1] != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}