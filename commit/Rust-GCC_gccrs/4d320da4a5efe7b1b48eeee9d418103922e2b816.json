{"sha": "4d320da4a5efe7b1b48eeee9d418103922e2b816", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQzMjBkYTRhNWVmZTdiMWI0OGVlZWU5ZDQxODEwMzkyMmUyYjgxNg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-08-04T14:14:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-04T14:14:32Z"}, "message": "tree-vrp.c (vrp_expr_computes_nonnegative): Remove.\n\n2011-08-04  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (vrp_expr_computes_nonnegative): Remove.\n\t(value_range_nonnegative_p): New function.\n\t(ssa_name_nonnegative_p): Use it.\n\t(value_range_constant_singleton): New function.\n\t(op_with_constant_singleton_value_range): Use it.\n\t(extract_range_from_binary_expr_1): New function, split out from ...\n\t(extract_range_from_binary_expr): ... this.  Remove fallback\n\tconstant folding done here.\n\nFrom-SVN: r177393", "tree": {"sha": "140b62ee3b3581ac705571f865a533574ee81b06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/140b62ee3b3581ac705571f865a533574ee81b06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d320da4a5efe7b1b48eeee9d418103922e2b816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d320da4a5efe7b1b48eeee9d418103922e2b816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d320da4a5efe7b1b48eeee9d418103922e2b816", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d320da4a5efe7b1b48eeee9d418103922e2b816/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e29ba60f137272db19c41c09cc04921027a56b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e29ba60f137272db19c41c09cc04921027a56b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e29ba60f137272db19c41c09cc04921027a56b8"}], "stats": {"total": 195, "additions": 100, "deletions": 95}, "files": [{"sha": "189b3b8afb833f235c0a768e3ddc5d06046e3640", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d320da4a5efe7b1b48eeee9d418103922e2b816/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d320da4a5efe7b1b48eeee9d418103922e2b816/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d320da4a5efe7b1b48eeee9d418103922e2b816", "patch": "@@ -1,3 +1,14 @@\n+2011-08-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (vrp_expr_computes_nonnegative): Remove.\n+\t(value_range_nonnegative_p): New function.\n+\t(ssa_name_nonnegative_p): Use it.\n+\t(value_range_constant_singleton): New function.\n+\t(op_with_constant_singleton_value_range): Use it.\n+\t(extract_range_from_binary_expr_1): New function, split out from ...\n+\t(extract_range_from_binary_expr): ... this.  Remove fallback\n+\tconstant folding done here.\n+\n 2011-08-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/49806"}, {"sha": "f73487bfc03c720519935283514882e45f3fca52", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 89, "deletions": 95, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d320da4a5efe7b1b48eeee9d418103922e2b816/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d320da4a5efe7b1b48eeee9d418103922e2b816/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=4d320da4a5efe7b1b48eeee9d418103922e2b816", "patch": "@@ -875,17 +875,6 @@ usable_range_p (value_range_t *vr, bool *strict_overflow_p)\n }\n \n \n-/* Like tree_expr_nonnegative_warnv_p, but this function uses value\n-   ranges obtained so far.  */\n-\n-static bool\n-vrp_expr_computes_nonnegative (tree expr, bool *strict_overflow_p)\n-{\n-  return (tree_expr_nonnegative_warnv_p (expr, strict_overflow_p)\n-\t  || (TREE_CODE (expr) == SSA_NAME\n-\t      && ssa_name_nonnegative_p (expr)));\n-}\n-\n /* Return true if the result of assignment STMT is know to be non-negative.\n    If the return value is based on the assumption that signed overflow is\n    undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n@@ -1404,6 +1393,25 @@ range_includes_zero_p (value_range_t *vr)\n   return (value_inside_range (zero, vr) == 1);\n }\n \n+/* Return true if *VR is know to only contain nonnegative values.  */\n+\n+static inline bool\n+value_range_nonnegative_p (value_range_t *vr)\n+{\n+  if (vr->type == VR_RANGE)\n+    {\n+      int result = compare_values (vr->min, integer_zero_node);\n+      return (result == 0 || result == 1);\n+    }\n+  else if (vr->type == VR_ANTI_RANGE)\n+    {\n+      int result = compare_values (vr->max, integer_zero_node);\n+      return result == -1;\n+    }\n+\n+  return false;\n+}\n+\n /* Return true if T, an SSA_NAME, is known to be nonnegative.  Return\n    false otherwise or if no value range information is available.  */\n \n@@ -1419,15 +1427,21 @@ ssa_name_nonnegative_p (const_tree t)\n   if (!vr)\n     return false;\n \n-  /* Testing for VR_ANTI_RANGE is not useful here as any anti-range\n-     which would return a useful value should be encoded as a VR_RANGE.  */\n-  if (vr->type == VR_RANGE)\n-    {\n-      int result = compare_values (vr->min, integer_zero_node);\n+  return value_range_nonnegative_p (vr);\n+}\n \n-      return (result == 0 || result == 1);\n-    }\n-  return false;\n+/* If *VR has a value rante that is a single constant value return that,\n+   otherwise return NULL_TREE.  */\n+\n+static tree\n+value_range_constant_singleton (value_range_t *vr)\n+{\n+  if (vr->type == VR_RANGE\n+      && operand_equal_p (vr->min, vr->max, 0)\n+      && is_gimple_min_invariant (vr->min))\n+    return vr->min;\n+\n+  return NULL_TREE;\n }\n \n /* If OP has a value range with a single constant value return that,\n@@ -1437,21 +1451,13 @@ ssa_name_nonnegative_p (const_tree t)\n static tree\n op_with_constant_singleton_value_range (tree op)\n {\n-  value_range_t *vr;\n-\n   if (is_gimple_min_invariant (op))\n     return op;\n \n   if (TREE_CODE (op) != SSA_NAME)\n     return NULL_TREE;\n \n-  vr = get_value_range (op);\n-  if (vr->type == VR_RANGE\n-      && operand_equal_p (vr->min, vr->max, 0)\n-      && is_gimple_min_invariant (vr->min))\n-    return vr->min;\n-\n-  return NULL_TREE;\n+  return value_range_constant_singleton (get_value_range (op));\n }\n \n /* Return true if op is in a boolean [0, 1] value-range.  */\n@@ -2179,19 +2185,19 @@ zero_nonzero_bits_from_vr (value_range_t *vr, double_int *may_be_nonzero,\n }\n \n \n-/* Extract range information from a binary expression EXPR based on\n-   the ranges of each of its operands and the expression code.  */\n+/* Extract range information from a binary operation CODE based on\n+   the ranges of each of its operands, *VR0 and *VR1 with resulting\n+   type EXPR_TYPE.  The resulting range is stored in *VR.  */\n \n static void\n-extract_range_from_binary_expr (value_range_t *vr,\n-\t\t\t\tenum tree_code code,\n-\t\t\t\ttree expr_type, tree op0, tree op1)\n+extract_range_from_binary_expr_1 (value_range_t *vr,\n+\t\t\t\t  enum tree_code code, tree expr_type,\n+\t\t\t\t  value_range_t *vr0_, value_range_t *vr1_)\n {\n+  value_range_t vr0 = *vr0_, vr1 = *vr1_;\n   enum value_range_type type;\n   tree min, max;\n   int cmp;\n-  value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n-  value_range_t vr1 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n \n   /* Not all binary expressions can be applied to ranges in a\n      meaningful way.  Handle only arithmetic operations.  */\n@@ -2211,42 +2217,10 @@ extract_range_from_binary_expr (value_range_t *vr,\n       && code != BIT_AND_EXPR\n       && code != BIT_IOR_EXPR)\n     {\n-      /* We can still do constant propagation here.  */\n-      tree const_op0 = op_with_constant_singleton_value_range (op0);\n-      tree const_op1 = op_with_constant_singleton_value_range (op1);\n-      if (const_op0 || const_op1)\n-\t{\n-\t  tree tem = fold_binary (code, expr_type,\n-\t\t\t\t  const_op0 ? const_op0 : op0,\n-\t\t\t\t  const_op1 ? const_op1 : op1);\n-\t  if (tem\n-\t      && is_gimple_min_invariant (tem)\n-\t      && !is_overflow_infinity (tem))\n-\t    {\n-\t      set_value_range (vr, VR_RANGE, tem, tem, NULL);\n-\t      return;\n-\t    }\n-\t}\n       set_value_range_to_varying (vr);\n       return;\n     }\n \n-  /* Get value ranges for each operand.  For constant operands, create\n-     a new value range with the operand to simplify processing.  */\n-  if (TREE_CODE (op0) == SSA_NAME)\n-    vr0 = *(get_value_range (op0));\n-  else if (is_gimple_min_invariant (op0))\n-    set_value_range_to_value (&vr0, op0, NULL);\n-  else\n-    set_value_range_to_varying (&vr0);\n-\n-  if (TREE_CODE (op1) == SSA_NAME)\n-    vr1 = *(get_value_range (op1));\n-  else if (is_gimple_min_invariant (op1))\n-    set_value_range_to_value (&vr1, op1, NULL);\n-  else\n-    set_value_range_to_varying (&vr1);\n-\n   /* If both ranges are UNDEFINED, so is the result.  */\n   if (vr0.type == VR_UNDEFINED && vr1.type == VR_UNDEFINED)\n     {\n@@ -2290,16 +2264,9 @@ extract_range_from_binary_expr (value_range_t *vr,\n     }\n \n   /* Now evaluate the expression to determine the new range.  */\n-  if (POINTER_TYPE_P (expr_type)\n-      || POINTER_TYPE_P (TREE_TYPE (op0))\n-      || POINTER_TYPE_P (TREE_TYPE (op1)))\n+  if (POINTER_TYPE_P (expr_type))\n     {\n-      if (code == BIT_IOR_EXPR)\n-        {\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-      else if (code == MIN_EXPR || code == MAX_EXPR)\n+      if (code == MIN_EXPR || code == MAX_EXPR)\n \t{\n \t  /* For MIN/MAX expressions with pointers, we only care about\n \t     nullness, if both are non null, then the result is nonnull.\n@@ -2311,10 +2278,8 @@ extract_range_from_binary_expr (value_range_t *vr,\n \t    set_value_range_to_null (vr, expr_type);\n \t  else\n \t    set_value_range_to_varying (vr);\n-\n-\t  return;\n \t}\n-      if (code == POINTER_PLUS_EXPR)\n+      else if (code == POINTER_PLUS_EXPR)\n \t{\n \t  /* For pointer types, we are really only interested in asserting\n \t     whether the expression evaluates to non-NULL.  */\n@@ -2337,7 +2302,7 @@ extract_range_from_binary_expr (value_range_t *vr,\n \t    set_value_range_to_varying (vr);\n \t}\n       else\n-\tgcc_unreachable ();\n+\tset_value_range_to_varying (vr);\n \n       return;\n     }\n@@ -2415,7 +2380,7 @@ extract_range_from_binary_expr (value_range_t *vr,\n \t point.  */\n       if (code == MULT_EXPR\n \t  && vr0.type == VR_ANTI_RANGE\n-\t  && !TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0)))\n+\t  && !TYPE_OVERFLOW_UNDEFINED (expr_type))\n \t{\n \t  set_value_range_to_varying (vr);\n \t  return;\n@@ -2428,12 +2393,11 @@ extract_range_from_binary_expr (value_range_t *vr,\n \t shifts, and the operation at the tree level may be widened.  */\n       if (code == RSHIFT_EXPR)\n \t{\n-\t  if (vr1.type == VR_ANTI_RANGE\n-\t      || !vrp_expr_computes_nonnegative (op1, &sop)\n-\t      || (operand_less_p\n-\t\t  (build_int_cst (TREE_TYPE (vr1.max),\n-\t\t\t\t  TYPE_PRECISION (expr_type) - 1),\n-\t\t   vr1.max) != 0))\n+\t  if (vr1.type != VR_RANGE\n+\t      || !value_range_nonnegative_p (&vr1)\n+\t      || TREE_CODE (vr1.max) != INTEGER_CST\n+\t      || compare_tree_int (vr1.max,\n+\t\t\t\t   TYPE_PRECISION (expr_type) - 1) == 1)\n \t    {\n \t      set_value_range_to_varying (vr);\n \t      return;\n@@ -2455,8 +2419,8 @@ extract_range_from_binary_expr (value_range_t *vr,\n \t      && !range_includes_zero_p (&vr1))\n \t    {\n \t      vr0.type = type = VR_RANGE;\n-\t      vr0.min = vrp_val_min (TREE_TYPE (op0));\n-\t      vr0.max = vrp_val_max (TREE_TYPE (op1));\n+\t      vr0.min = vrp_val_min (expr_type);\n+\t      vr0.max = vrp_val_max (expr_type);\n \t    }\n \t  else\n \t    {\n@@ -2500,7 +2464,8 @@ extract_range_from_binary_expr (value_range_t *vr,\n \t  sop = false;\n \t  min = NULL_TREE;\n \t  max = NULL_TREE;\n-\t  if (vrp_expr_computes_nonnegative (op1, &sop) && !sop)\n+\t  if (TYPE_UNSIGNED (expr_type)\n+\t      || value_range_nonnegative_p (&vr1))\n \t    {\n \t      /* For unsigned division or when divisor is known\n \t\t to be non-negative, the range has to cover\n@@ -2629,7 +2594,6 @@ extract_range_from_binary_expr (value_range_t *vr,\n     }\n   else if (code == TRUNC_MOD_EXPR)\n     {\n-      bool sop = false;\n       if (vr1.type != VR_RANGE\n \t  || symbolic_range_p (&vr1)\n \t  || range_includes_zero_p (&vr1)\n@@ -2640,17 +2604,17 @@ extract_range_from_binary_expr (value_range_t *vr,\n \t}\n       type = VR_RANGE;\n       /* Compute MAX <|vr1.min|, |vr1.max|> - 1.  */\n-      max = fold_unary_to_constant (ABS_EXPR, TREE_TYPE (vr1.min), vr1.min);\n+      max = fold_unary_to_constant (ABS_EXPR, expr_type, vr1.min);\n       if (tree_int_cst_lt (max, vr1.max))\n \tmax = vr1.max;\n       max = int_const_binop (MINUS_EXPR, max, integer_one_node);\n       /* If the dividend is non-negative the modulus will be\n \t non-negative as well.  */\n-      if (TYPE_UNSIGNED (TREE_TYPE (max))\n-\t  || (vrp_expr_computes_nonnegative (op0, &sop) && !sop))\n+      if (TYPE_UNSIGNED (expr_type)\n+\t  || value_range_nonnegative_p (&vr0))\n \tmin = build_int_cst (TREE_TYPE (max), 0);\n       else\n-\tmin = fold_unary_to_constant (NEGATE_EXPR, TREE_TYPE (max), max);\n+\tmin = fold_unary_to_constant (NEGATE_EXPR, expr_type, max);\n     }\n   else if (code == MINUS_EXPR)\n     {\n@@ -2822,6 +2786,36 @@ extract_range_from_binary_expr (value_range_t *vr,\n     set_value_range (vr, type, min, max, NULL);\n }\n \n+/* Extract range information from a binary expression OP0 CODE OP1 based on\n+   the ranges of each of its operands with resulting type EXPR_TYPE.\n+   The resulting range is stored in *VR.  */\n+\n+static void\n+extract_range_from_binary_expr (value_range_t *vr,\n+\t\t\t\tenum tree_code code,\n+\t\t\t\ttree expr_type, tree op0, tree op1)\n+{\n+  value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+  value_range_t vr1 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+\n+  /* Get value ranges for each operand.  For constant operands, create\n+     a new value range with the operand to simplify processing.  */\n+  if (TREE_CODE (op0) == SSA_NAME)\n+    vr0 = *(get_value_range (op0));\n+  else if (is_gimple_min_invariant (op0))\n+    set_value_range_to_value (&vr0, op0, NULL);\n+  else\n+    set_value_range_to_varying (&vr0);\n+\n+  if (TREE_CODE (op1) == SSA_NAME)\n+    vr1 = *(get_value_range (op1));\n+  else if (is_gimple_min_invariant (op1))\n+    set_value_range_to_value (&vr1, op1, NULL);\n+  else\n+    set_value_range_to_varying (&vr1);\n+\n+  extract_range_from_binary_expr_1 (vr, code, expr_type, &vr0, &vr1);\n+}\n \n /* Extract range information from a unary expression EXPR based on\n    the range of its operand and the expression code.  */"}]}