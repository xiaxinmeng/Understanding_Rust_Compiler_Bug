{"sha": "93c0e0bb1d729b142f698d42fb4a61ad23a52505", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNjMGUwYmIxZDcyOWIxNDJmNjk4ZDQyZmI0YTYxYWQyM2E1MjUwNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-09-27T20:05:34Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-09-27T20:05:34Z"}, "message": "Require lvalues as specified by the standard.\n\n\t* typeck.c (lvalue_or_else): Use real_lvalue_p.\n\t(cp_build_addr_expr_1): Split out of cp_build_unary_op.\n\t(cp_build_addr_expr, cp_build_addr_expr_strict): Interfaces.\n\t(decay_conversion, get_member_function_from_ptrfunc): Adjust.\n\t(build_x_unary_op, build_reinterpret_cast_1): Adjust.\n\t(build_const_cast_1): Adjust.\n\t* cp-tree.h: Declare new fns.\n\t* call.c (build_this, convert_like_real, build_over_call): Adjust.\n\t(initialize_reference): Adjust.\n\t* class.c (build_base_path, convert_to_base_statically): Adjust.\n\t(build_vfn_ref, resolve_address_of_overloaded_function): Adjust.\n\t* cvt.c (build_up_reference, convert_to_reference): Adjust.\n\t* decl.c (register_dtor_fn): Adjust.\n\t* decl2.c (build_offset_ref_call_from_tree): Adjust.\n\t* except.c (initialize_handler_parm): Adjust.\n\t* init.c (build_offset_ref, build_delete, build_vec_delete): Adjust.\n\t* rtti.c (build_dynamic_cast_1, tinfo_base_init): Adjust.\n\t* tree.c (stabilize_expr): Adjust.\n\nFrom-SVN: r164666", "tree": {"sha": "108a323659c8b36f70d1648d888403d8d41841bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/108a323659c8b36f70d1648d888403d8d41841bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93c0e0bb1d729b142f698d42fb4a61ad23a52505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c0e0bb1d729b142f698d42fb4a61ad23a52505", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93c0e0bb1d729b142f698d42fb4a61ad23a52505", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c0e0bb1d729b142f698d42fb4a61ad23a52505/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a77bfaebbf433f5559d936bc0ec7b32633f00865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a77bfaebbf433f5559d936bc0ec7b32633f00865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a77bfaebbf433f5559d936bc0ec7b32633f00865"}], "stats": {"total": 635, "additions": 355, "deletions": 280}, "files": [{"sha": "42d8b1729b02527763fec6b3dcd09bf755572241", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -1,3 +1,25 @@\n+2010-09-27  Jason Merrill  <jason@redhat.com>\n+\n+\tRequire lvalues as specified by the standard.\n+\t* typeck.c (lvalue_or_else): Use real_lvalue_p.\n+\t(cp_build_addr_expr_1): Split out of cp_build_unary_op.\n+\t(cp_build_addr_expr, cp_build_addr_expr_strict): Interfaces.\n+\t(decay_conversion, get_member_function_from_ptrfunc): Adjust.\n+\t(build_x_unary_op, build_reinterpret_cast_1): Adjust.\n+\t(build_const_cast_1): Adjust.\n+\t* cp-tree.h: Declare new fns.\n+\t* call.c (build_this, convert_like_real, build_over_call): Adjust.\n+\t(initialize_reference): Adjust.\n+\t* class.c (build_base_path, convert_to_base_statically): Adjust.\n+\t(build_vfn_ref, resolve_address_of_overloaded_function): Adjust.\n+\t* cvt.c (build_up_reference, convert_to_reference): Adjust.\n+\t* decl.c (register_dtor_fn): Adjust.\n+\t* decl2.c (build_offset_ref_call_from_tree): Adjust.\n+\t* except.c (initialize_handler_parm): Adjust.\n+\t* init.c (build_offset_ref, build_delete, build_vec_delete): Adjust.\n+\t* rtti.c (build_dynamic_cast_1, tinfo_base_init): Adjust.\n+\t* tree.c (stabilize_expr): Adjust.\n+\n 2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from apple/trunk branch on FSF servers:"}, {"sha": "2e7083d45fd03705b416281a547899eb431c677f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -2740,7 +2740,7 @@ build_this (tree obj)\n   if (processing_template_decl)\n     return build_address (obj);\n \n-  return cp_build_unary_op (ADDR_EXPR, obj, 0, tf_warning_or_error);\n+  return cp_build_addr_expr (obj, tf_warning_or_error);\n }\n \n /* Returns true iff functions are equivalent. Equivalent functions are\n@@ -5157,7 +5157,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  /* We are going to bind a reference directly to a base-class\n \t     subobject of EXPR.  */\n \t  /* Build an expression for `*((base*) &expr)'.  */\n-\t  expr = cp_build_unary_op (ADDR_EXPR, expr, 0, complain);\n+\t  expr = cp_build_addr_expr (expr, complain);\n \t  expr = convert_to_base (expr, build_pointer_type (totype),\n \t\t\t\t  !c_cast_p, /*nonnull=*/true, complain);\n \t  expr = cp_build_indirect_ref (expr, RO_IMPLICIT_CONVERSION, complain);\n@@ -5206,8 +5206,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n            VA_ARG_EXPR and CONSTRUCTOR expressions are special cases\n            that need temporaries, even when their types are reference\n            compatible with the type of reference being bound, so the\n-           upcoming call to cp_build_unary_op (ADDR_EXPR, expr, ...)\n-           doesn't fail.  */\n+           upcoming call to cp_build_addr_expr doesn't fail.  */\n \tif (convs->need_temporary_p\n \t    || TREE_CODE (expr) == CONSTRUCTOR\n \t    || TREE_CODE (expr) == VA_ARG_EXPR)\n@@ -5264,7 +5263,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \n \t/* Take the address of the thing to which we will bind the\n \t   reference.  */\n-\texpr = cp_build_unary_op (ADDR_EXPR, expr, 1, complain);\n+\texpr = cp_build_addr_expr (expr, complain);\n \tif (expr == error_mark_node)\n \t  return error_mark_node;\n \n@@ -6011,7 +6010,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \n \t  arg2 = TYPE_SIZE_UNIT (as_base);\n \t  arg1 = arg;\n-\t  arg0 = cp_build_unary_op (ADDR_EXPR, to, 0, complain);\n+\t  arg0 = cp_build_addr_expr (to, complain);\n \n \t  if (!can_trust_pointer_alignment ())\n \t    {\n@@ -7994,7 +7993,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup,\n \t    }\n \t  else\n \t    /* Take the address of EXPR.  */\n-\t    expr = cp_build_unary_op (ADDR_EXPR, expr, 0, tf_warning_or_error);\n+\t    expr = cp_build_addr_expr (expr, tf_warning_or_error);\n \t  /* If a BASE_CONV was required, perform it now.  */\n \t  if (base_conv_type)\n \t    expr = (perform_implicit_conversion"}, {"sha": "b093ce0fcc588ee2d87ee2469422b2b3fdb666be", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -282,7 +282,7 @@ build_base_path (enum tree_code code,\n \n   if (!want_pointer)\n     /* This must happen before the call to save_expr.  */\n-    expr = cp_build_unary_op (ADDR_EXPR, expr, 0, tf_warning_or_error);\n+    expr = cp_build_addr_expr (expr, tf_warning_or_error);\n   else\n     expr = mark_rvalue_use (expr);\n \n@@ -557,8 +557,7 @@ convert_to_base_statically (tree expr, tree base)\n \t when processing a template because they do not handle C++-specific\n \t trees.  */\n       gcc_assert (!processing_template_decl);\n-      expr = cp_build_unary_op (ADDR_EXPR, expr, /*noconvert=*/1, \n-                             tf_warning_or_error);\n+      expr = cp_build_addr_expr (expr, tf_warning_or_error);\n       if (!integer_zerop (BINFO_OFFSET (base)))\n         expr = fold_build2_loc (input_location,\n \t\t\t    POINTER_PLUS_EXPR, pointer_type, expr,\n@@ -661,8 +660,7 @@ build_vfn_ref (tree instance_ptr, tree idx)\n      vtable entry is treated as a function pointer.  */\n   if (TARGET_VTABLE_USES_DESCRIPTORS)\n     aref = build1 (NOP_EXPR, TREE_TYPE (aref),\n-\t\t   cp_build_unary_op (ADDR_EXPR, aref, /*noconvert=*/1,\n-                                   tf_warning_or_error));\n+\t\t   cp_build_addr_expr (aref, tf_warning_or_error));\n \n   /* Remember this as a method reference, for later devirtualization.  */\n   aref = build3 (OBJ_TYPE_REF, TREE_TYPE (aref), aref, instance_ptr, idx);\n@@ -6464,7 +6462,7 @@ resolve_address_of_overloaded_function (tree target_type,\n     }\n \n   if (TYPE_PTRFN_P (target_type) || TYPE_PTRMEMFUNC_P (target_type))\n-    return cp_build_unary_op (ADDR_EXPR, fn, 0, flags);\n+    return cp_build_addr_expr (fn, flags);\n   else\n     {\n       /* The target must be a REFERENCE_TYPE.  Above, cp_build_unary_op"}, {"sha": "2ff0973d691ff8e630ab0b0941b5f4bd738a8e80", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -5472,6 +5472,8 @@ extern tree build_x_binary_op\t\t\t(enum tree_code, tree,\n extern tree build_x_array_ref\t\t\t(tree, tree, tsubst_flags_t);\n extern tree build_x_unary_op\t\t\t(enum tree_code, tree,\n                                                  tsubst_flags_t);\n+extern tree cp_build_addr_expr\t\t\t(tree, tsubst_flags_t);\n+extern tree cp_build_addr_expr_strict\t\t(tree, tsubst_flags_t);\n extern tree cp_build_unary_op                   (enum tree_code, tree, int, \n                                                  tsubst_flags_t);\n extern tree unary_complex_lvalue\t\t(enum tree_code, tree);"}, {"sha": "00aa44aaa6082793a0fb37b1143bbc0b63ba3ad2", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -327,7 +327,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n   /* If we had a way to wrap this up, and say, if we ever needed its\n      address, transform all occurrences of the register, into a memory\n      reference we could win better.  */\n-  rval = cp_build_unary_op (ADDR_EXPR, arg, 1, tf_warning_or_error);\n+  rval = cp_build_addr_expr (arg, tf_warning_or_error);\n   if (rval == error_mark_node)\n     return error_mark_node;\n \n@@ -471,7 +471,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \twarning (0, \"casting %qT to %qT does not dereference pointer\",\n \t\t intype, reftype);\n \n-      rval = cp_build_unary_op (ADDR_EXPR, expr, 0, tf_warning_or_error);\n+      rval = cp_build_addr_expr (expr, tf_warning_or_error);\n       if (rval != error_mark_node)\n \trval = convert_force (build_pointer_type (TREE_TYPE (reftype)),\n \t\t\t      rval, 0);"}, {"sha": "18367b5e9db5e2805017a1ceb7726e7c00385ef0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -6354,8 +6354,8 @@ register_dtor_fn (tree decl)\n \t   in, and, in general, it's cheaper to pass NULL than any\n \t   other value.  */\n \taddr = null_pointer_node;\n-      arg2 = cp_build_unary_op (ADDR_EXPR, get_dso_handle_node (), 0,\n-                                tf_warning_or_error);\n+      arg2 = cp_build_addr_expr (get_dso_handle_node (),\n+\t\t\t\t tf_warning_or_error);\n       if (targetm.cxx.use_aeabi_atexit ())\n \t{\n \t  arg1 = cleanup;"}, {"sha": "fcc83fb66ba52b16acae6b2f4ef03b8bf86ce51f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -4009,7 +4009,7 @@ build_offset_ref_call_from_tree (tree fn, VEC(tree,gc) **args)\n       make_args_non_dependent (*args);\n       object = build_non_dependent_expr (object);\n       if (TREE_CODE (fn) == DOTSTAR_EXPR)\n-\tobject = cp_build_unary_op (ADDR_EXPR, object, 0, tf_warning_or_error);\n+\tobject = cp_build_addr_expr (object, tf_warning_or_error);\n       VEC_safe_insert (tree, gc, *args, 0, object);\n       /* Now that the arguments are done, transform FN.  */\n       fn = build_non_dependent_expr (fn);\n@@ -4023,8 +4023,7 @@ build_offset_ref_call_from_tree (tree fn, VEC(tree,gc) **args)\n \tvoid B::g() { (this->*p)(); }  */\n   if (TREE_CODE (fn) == OFFSET_REF)\n     {\n-      tree object_addr = cp_build_unary_op (ADDR_EXPR, object, 0,\n-                                         tf_warning_or_error);\n+      tree object_addr = cp_build_addr_expr (object, tf_warning_or_error);\n       fn = TREE_OPERAND (fn, 1);\n       fn = get_member_function_from_ptrfunc (&object_addr, fn);\n       VEC_safe_insert (tree, gc, *args, 0, object_addr);"}, {"sha": "9d19aa984fd9799062d01b8fef30c61b807ea96e", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -376,7 +376,7 @@ initialize_handler_parm (tree decl, tree exp)\n      pointer catch parm with the address of the temporary.  */\n   if (TREE_CODE (init_type) == REFERENCE_TYPE\n       && TYPE_PTR_P (TREE_TYPE (init_type)))\n-    exp = cp_build_unary_op (ADDR_EXPR, exp, 1, tf_warning_or_error);\n+    exp = cp_build_addr_expr (exp, tf_warning_or_error);\n \n   exp = ocp_convert (init_type, exp, CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n "}, {"sha": "5091d4e749eaba3806349ddc1a475e3e013c2d35", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -1649,8 +1649,7 @@ build_offset_ref (tree type, tree member, bool address_p)\n \t  if (flag_ms_extensions)\n \t    {\n \t      PTRMEM_OK_P (member) = 1;\n-\t      return cp_build_unary_op (ADDR_EXPR, member, 0, \n-                                        tf_warning_or_error);\n+\t      return cp_build_addr_expr (member, tf_warning_or_error);\n \t    }\n \t  error (\"invalid use of non-static member function %qD\",\n \t\t TREE_OPERAND (member, 1));\n@@ -3246,7 +3245,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n       /* Don't check PROTECT here; leave that decision to the\n \t destructor.  If the destructor is accessible, call it,\n \t else report error.  */\n-      addr = cp_build_unary_op (ADDR_EXPR, addr, 0, tf_warning_or_error);\n+      addr = cp_build_addr_expr (addr, tf_warning_or_error);\n       if (TREE_SIDE_EFFECTS (addr))\n \taddr = save_expr (addr);\n \n@@ -3486,7 +3485,7 @@ build_vec_delete (tree base, tree maxindex,\n \t bad name.  */\n       maxindex = array_type_nelts_total (type);\n       type = strip_array_types (type);\n-      base = cp_build_unary_op (ADDR_EXPR, base, 1, tf_warning_or_error);\n+      base = cp_build_addr_expr (base, tf_warning_or_error);\n       if (TREE_SIDE_EFFECTS (base))\n \t{\n \t  base_init = get_target_expr (base);"}, {"sha": "d7a151dec1faae27a7c028fd706e59f842e6e09d", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -693,10 +693,10 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \t  static_type = TYPE_MAIN_VARIANT (TREE_TYPE (exprtype));\n \t  td2 = get_tinfo_decl (target_type);\n \t  mark_used (td2);\n-\t  td2 = cp_build_unary_op (ADDR_EXPR, td2, 0, complain);\n+\t  td2 = cp_build_addr_expr (td2, complain);\n \t  td3 = get_tinfo_decl (static_type);\n \t  mark_used (td3);\n-\t  td3 = cp_build_unary_op (ADDR_EXPR, td3, 0, complain);\n+\t  td3 = cp_build_addr_expr (td3, complain);\n \n \t  /* Determine how T and V are related.  */\n \t  boff = dcast_base_hint (static_type, target_type);\n@@ -706,7 +706,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \n \t  expr1 = expr;\n \t  if (tc == REFERENCE_TYPE)\n-\t    expr1 = cp_build_unary_op (ADDR_EXPR, expr1, 0, complain);\n+\t    expr1 = cp_build_addr_expr (expr1, complain);\n \n \t  elems[0] = expr1;\n \t  elems[1] = td3;\n@@ -913,8 +913,7 @@ tinfo_base_init (tinfo_s *ti, tree target)\n \t}\n \n       vtable_ptr = get_vtable_decl (real_type, /*complete=*/1);\n-      vtable_ptr = cp_build_unary_op (ADDR_EXPR, vtable_ptr, 0, \n-                                   tf_warning_or_error);\n+      vtable_ptr = cp_build_addr_expr (vtable_ptr, tf_warning_or_error);\n \n       /* We need to point into the middle of the vtable.  */\n       vtable_ptr = build2"}, {"sha": "d52387b3b654ac7b584e870d9388514db7b3dfc3", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -3008,7 +3008,7 @@ stabilize_expr (tree exp, tree* initp)\n     }\n   else\n     {\n-      exp = cp_build_unary_op (ADDR_EXPR, exp, 1, tf_warning_or_error);\n+      exp = cp_build_addr_expr (exp, tf_warning_or_error);\n       init_expr = get_target_expr (exp);\n       exp = TARGET_EXPR_SLOT (init_expr);\n       exp = cp_build_indirect_ref (exp, RO_NULL, tf_warning_or_error);"}, {"sha": "c25a17708b42ac5875c4cd25f06f684a64b05585", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 280, "deletions": 243, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -1942,7 +1942,7 @@ decay_conversion (tree exp)\n   if (invalid_nonstatic_memfn_p (exp, tf_warning_or_error))\n     return error_mark_node;\n   if (code == FUNCTION_TYPE || is_overloaded_fn (exp))\n-    return cp_build_unary_op (ADDR_EXPR, exp, 0, tf_warning_or_error);\n+    return cp_build_addr_expr (exp, tf_warning_or_error);\n   if (code == ARRAY_TYPE)\n     {\n       tree adr;\n@@ -1977,7 +1977,7 @@ decay_conversion (tree exp)\n \t}\n       /* This way is better for a COMPONENT_REF since it can\n \t simplify the offset for a component.  */\n-      adr = cp_build_unary_op (ADDR_EXPR, exp, 1, tf_warning_or_error);\n+      adr = cp_build_addr_expr (exp, tf_warning_or_error);\n       return cp_convert (ptrtype, adr);\n     }\n \n@@ -3211,8 +3211,7 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n \t vtable entry is treated as a function pointer.  */\n       if (TARGET_VTABLE_USES_DESCRIPTORS)\n \te2 = build1 (NOP_EXPR, TREE_TYPE (e2),\n-\t\t     cp_build_unary_op (ADDR_EXPR, e2, /*noconvert=*/1,\n-                                     tf_warning_or_error));\n+\t\t     cp_build_addr_expr (e2, tf_warning_or_error));\n \n       e2 = fold_convert (TREE_TYPE (e3), e2);\n       e1 = build_conditional_expr (e1, e2, e3, tf_warning_or_error);\n@@ -4721,9 +4720,8 @@ build_x_unary_op (enum tree_code code, tree xarg, tsubst_flags_t complain)\n \t      PTRMEM_OK_P (xarg) = ptrmem;\n \t    }\n \t}\n-      else if (TREE_CODE (xarg) == TARGET_EXPR && (complain & tf_warning))\n-\twarning (0, \"taking address of temporary\");\n-      exp = cp_build_unary_op (ADDR_EXPR, xarg, 0, complain);\n+\n+      exp = cp_build_addr_expr_strict (xarg, complain);\n     }\n \n   if (processing_template_decl && exp != error_mark_node)\n@@ -4800,6 +4798,276 @@ build_nop (tree type, tree expr)\n   return build1 (NOP_EXPR, type, expr);\n }\n \n+/* Take the address of ARG, whatever that means under C++ semantics.\n+   If STRICT_LVALUE is true, require an lvalue; otherwise, allow xvalues\n+   and class rvalues as well.\n+\n+   Nothing should call this function directly; instead, callers should use\n+   cp_build_addr_expr or cp_build_addr_expr_strict.  */\n+\n+static tree\n+cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n+{\n+  tree argtype;\n+  tree val;\n+\n+  if (!arg || error_operand_p (arg))\n+    return error_mark_node;\n+\n+  arg = mark_lvalue_use (arg);\n+  argtype = lvalue_type (arg);\n+\n+  gcc_assert (TREE_CODE (arg) != IDENTIFIER_NODE\n+\t      || !IDENTIFIER_OPNAME_P (arg));\n+\n+  if (TREE_CODE (arg) == COMPONENT_REF && type_unknown_p (arg)\n+      && !really_overloaded_fn (TREE_OPERAND (arg, 1)))\n+    {\n+      /* They're trying to take the address of a unique non-static\n+\t member function.  This is ill-formed (except in MS-land),\n+\t but let's try to DTRT.\n+\t Note: We only handle unique functions here because we don't\n+\t want to complain if there's a static overload; non-unique\n+\t cases will be handled by instantiate_type.  But we need to\n+\t handle this case here to allow casts on the resulting PMF.\n+\t We could defer this in non-MS mode, but it's easier to give\n+\t a useful error here.  */\n+\n+      /* Inside constant member functions, the `this' pointer\n+\t contains an extra const qualifier.  TYPE_MAIN_VARIANT\n+\t is used here to remove this const from the diagnostics\n+\t and the created OFFSET_REF.  */\n+      tree base = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (arg, 0)));\n+      tree fn = get_first_fn (TREE_OPERAND (arg, 1));\n+      mark_used (fn);\n+\n+      if (! flag_ms_extensions)\n+\t{\n+\t  tree name = DECL_NAME (fn);\n+\t  if (!(complain & tf_error))\n+\t    return error_mark_node;\n+\t  else if (current_class_type\n+\t\t   && TREE_OPERAND (arg, 0) == current_class_ref)\n+\t    /* An expression like &memfn.  */\n+\t    permerror (input_location, \"ISO C++ forbids taking the address of an unqualified\"\n+\t\t       \" or parenthesized non-static member function to form\"\n+\t\t       \" a pointer to member function.  Say %<&%T::%D%>\",\n+\t\t       base, name);\n+\t  else\n+\t    permerror (input_location, \"ISO C++ forbids taking the address of a bound member\"\n+\t\t       \" function to form a pointer to member function.\"\n+\t\t       \"  Say %<&%T::%D%>\",\n+\t\t       base, name);\n+\t}\n+      arg = build_offset_ref (base, fn, /*address_p=*/true);\n+    }\n+\n+  /* Uninstantiated types are all functions.  Taking the\n+     address of a function is a no-op, so just return the\n+     argument.  */\n+  if (type_unknown_p (arg))\n+    return build1 (ADDR_EXPR, unknown_type_node, arg);\n+\n+  if (TREE_CODE (arg) == OFFSET_REF)\n+    /* We want a pointer to member; bypass all the code for actually taking\n+       the address of something.  */\n+    goto offset_ref;\n+\n+  /* Anything not already handled and not a true memory reference\n+     is an error.  */\n+  if (TREE_CODE (argtype) != FUNCTION_TYPE\n+      && TREE_CODE (argtype) != METHOD_TYPE)\n+    {\n+      bool win = strict_lvalue ? real_lvalue_p (arg) : lvalue_p (arg);\n+      if (!win)\n+\t{\n+\t  if (complain & tf_error)\n+\t    lvalue_error (lv_addressof);\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n+  if (TREE_CODE (argtype) == REFERENCE_TYPE)\n+    {\n+      tree type = build_pointer_type (TREE_TYPE (argtype));\n+      arg = build1 (CONVERT_EXPR, type, arg);\n+      return arg;\n+    }\n+  else if (pedantic && DECL_MAIN_P (arg))\n+    {\n+      /* ARM $3.4 */\n+      /* Apparently a lot of autoconf scripts for C++ packages do this,\n+\t so only complain if -pedantic.  */\n+      if (complain & (flag_pedantic_errors ? tf_error : tf_warning))\n+\tpedwarn (input_location, OPT_pedantic,\n+\t\t \"ISO C++ forbids taking address of function %<::main%>\");\n+      else if (flag_pedantic_errors)\n+\treturn error_mark_node;\n+    }\n+\n+  /* Let &* cancel out to simplify resulting code.  */\n+  if (TREE_CODE (arg) == INDIRECT_REF)\n+    {\n+      /* We don't need to have `current_class_ptr' wrapped in a\n+\t NON_LVALUE_EXPR node.  */\n+      if (arg == current_class_ref)\n+\treturn current_class_ptr;\n+\n+      arg = TREE_OPERAND (arg, 0);\n+      if (TREE_CODE (TREE_TYPE (arg)) == REFERENCE_TYPE)\n+\t{\n+\t  tree type = build_pointer_type (TREE_TYPE (TREE_TYPE (arg)));\n+\t  arg = build1 (CONVERT_EXPR, type, arg);\n+\t}\n+      else\n+\t/* Don't let this be an lvalue.  */\n+\targ = rvalue (arg);\n+      return arg;\n+    }\n+\n+  /* ??? Cope with user tricks that amount to offsetof.  */\n+  if (TREE_CODE (argtype) != FUNCTION_TYPE\n+      && TREE_CODE (argtype) != METHOD_TYPE\n+      && argtype != unknown_type_node\n+      && (val = get_base_address (arg))\n+      && TREE_CODE (val) == INDIRECT_REF\n+      && TREE_CONSTANT (TREE_OPERAND (val, 0)))\n+    {\n+      tree type = build_pointer_type (argtype);\n+      tree op0 = fold_convert (type, TREE_OPERAND (val, 0));\n+      tree op1 = fold_convert (sizetype, fold_offsetof (arg, val));\n+      return fold_build2 (POINTER_PLUS_EXPR, type, op0, op1);\n+    }\n+\n+  /* Handle complex lvalues (when permitted)\n+     by reduction to simpler cases.  */\n+  val = unary_complex_lvalue (ADDR_EXPR, arg);\n+  if (val != 0)\n+    return val;\n+\n+  switch (TREE_CODE (arg))\n+    {\n+    CASE_CONVERT:\n+    case FLOAT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+      /* Even if we're not being pedantic, we cannot allow this\n+\t extension when we're instantiating in a SFINAE\n+\t context.  */\n+      if (! lvalue_p (arg) && complain == tf_none)\n+\t{\n+\t  if (complain & tf_error)\n+\t    permerror (input_location, \"ISO C++ forbids taking the address of a cast to a non-lvalue expression\");\n+\t  else\n+\t    return error_mark_node;\n+\t}\n+      break;\n+\n+    case BASELINK:\n+      arg = BASELINK_FUNCTIONS (arg);\n+      /* Fall through.  */\n+\n+    case OVERLOAD:\n+      arg = OVL_CURRENT (arg);\n+      break;\n+\n+    case OFFSET_REF:\n+    offset_ref:\n+      /* Turn a reference to a non-static data member into a\n+\t pointer-to-member.  */\n+      {\n+\ttree type;\n+\ttree t;\n+\n+\tgcc_assert (PTRMEM_OK_P (arg));\n+\n+\tt = TREE_OPERAND (arg, 1);\n+\tif (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n+\t  {\n+\t    if (complain & tf_error)\n+\t      error (\"cannot create pointer to reference member %qD\", t);\n+\t    return error_mark_node;\n+\t  }\n+\n+\ttype = build_ptrmem_type (context_for_name_lookup (t),\n+\t\t\t\t  TREE_TYPE (t));\n+\tt = make_ptrmem_cst (type, TREE_OPERAND (arg, 1));\n+\treturn t;\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  if (argtype != error_mark_node)\n+    argtype = build_pointer_type (argtype);\n+\n+  /* In a template, we are processing a non-dependent expression\n+     so we can just form an ADDR_EXPR with the correct type.  */\n+  if (processing_template_decl || TREE_CODE (arg) != COMPONENT_REF)\n+    {\n+      val = build_address (arg);\n+      if (TREE_CODE (arg) == OFFSET_REF)\n+\tPTRMEM_OK_P (val) = PTRMEM_OK_P (arg);\n+    }\n+  else if (TREE_CODE (TREE_OPERAND (arg, 1)) == BASELINK)\n+    {\n+      tree fn = BASELINK_FUNCTIONS (TREE_OPERAND (arg, 1));\n+\n+      /* We can only get here with a single static member\n+\t function.  */\n+      gcc_assert (TREE_CODE (fn) == FUNCTION_DECL\n+\t\t  && DECL_STATIC_FUNCTION_P (fn));\n+      mark_used (fn);\n+      val = build_address (fn);\n+      if (TREE_SIDE_EFFECTS (TREE_OPERAND (arg, 0)))\n+\t/* Do not lose object's side effects.  */\n+\tval = build2 (COMPOUND_EXPR, TREE_TYPE (val),\n+\t\t      TREE_OPERAND (arg, 0), val);\n+    }\n+  else if (DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1)))\n+    {\n+      if (complain & tf_error)\n+\terror (\"attempt to take address of bit-field structure member %qD\",\n+\t       TREE_OPERAND (arg, 1));\n+      return error_mark_node;\n+    }\n+  else\n+    {\n+      tree object = TREE_OPERAND (arg, 0);\n+      tree field = TREE_OPERAND (arg, 1);\n+      gcc_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t  (TREE_TYPE (object), decl_type_context (field)));\n+      val = build_address (arg);\n+    }\n+\n+  if (TREE_CODE (argtype) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (argtype)) == METHOD_TYPE)\n+    {\n+      build_ptrmemfunc_type (argtype);\n+      val = build_ptrmemfunc (argtype, val, 0,\n+\t\t\t      /*c_cast_p=*/false,\n+\t\t\t      tf_warning_or_error);\n+    }\n+\n+  return val;\n+}\n+\n+/* Take the address of ARG if it has one, even if it's an rvalue.  */\n+\n+tree\n+cp_build_addr_expr (tree arg, tsubst_flags_t complain)\n+{\n+  return cp_build_addr_expr_1 (arg, 0, complain);\n+}\n+\n+/* Take the address of ARG, but only if it's an lvalue.  */\n+\n+tree\n+cp_build_addr_expr_strict (tree arg, tsubst_flags_t complain)\n+{\n+  return cp_build_addr_expr_1 (arg, 1, complain);\n+}\n+\n /* C++: Must handle pointers to members.\n \n    Perhaps type instantiation should be extended to handle conversion\n@@ -5066,238 +5334,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n     case ADDR_EXPR:\n       /* Note that this operation never does default_conversion\n \t regardless of NOCONVERT.  */\n-\n-      argtype = lvalue_type (arg);\n-\n-      arg = mark_lvalue_use (arg);\n-\n-      if (TREE_CODE (arg) == OFFSET_REF)\n-\tgoto offset_ref;\n-\n-      if (TREE_CODE (argtype) == REFERENCE_TYPE)\n-\t{\n-\t  tree type = build_pointer_type (TREE_TYPE (argtype));\n-\t  arg = build1 (CONVERT_EXPR, type, arg);\n-\t  return arg;\n-\t}\n-      else if (pedantic && DECL_MAIN_P (arg))\n-        {\n-          /* ARM $3.4 */\n-\t  /* Apparently a lot of autoconf scripts for C++ packages do this,\n-\t     so only complain if -pedantic.  */\n-          if (complain & (flag_pedantic_errors ? tf_error : tf_warning))\n-            pedwarn (input_location, OPT_pedantic,\n-\t\t     \"ISO C++ forbids taking address of function %<::main%>\");\n-          else if (flag_pedantic_errors)\n-            return error_mark_node;\n-        }\n-\n-      /* Let &* cancel out to simplify resulting code.  */\n-      if (TREE_CODE (arg) == INDIRECT_REF)\n-\t{\n-\t  /* We don't need to have `current_class_ptr' wrapped in a\n-\t     NON_LVALUE_EXPR node.  */\n-\t  if (arg == current_class_ref)\n-\t    return current_class_ptr;\n-\n-\t  arg = TREE_OPERAND (arg, 0);\n-\t  if (TREE_CODE (TREE_TYPE (arg)) == REFERENCE_TYPE)\n-\t    {\n-\t      tree type = build_pointer_type (TREE_TYPE (TREE_TYPE (arg)));\n-\t      arg = build1 (CONVERT_EXPR, type, arg);\n-\t    }\n-\t  else\n-\t    /* Don't let this be an lvalue.  */\n-\t    arg = rvalue (arg);\n-\t  return arg;\n-\t}\n-\n-      /* ??? Cope with user tricks that amount to offsetof.  */\n-      if (TREE_CODE (argtype) != FUNCTION_TYPE\n-\t  && TREE_CODE (argtype) != METHOD_TYPE\n-\t  && argtype != unknown_type_node\n-\t  && (val = get_base_address (arg))\n-\t  && TREE_CODE (val) == INDIRECT_REF\n-\t  && TREE_CONSTANT (TREE_OPERAND (val, 0)))\n-\t{\n-\t  tree type = build_pointer_type (argtype);\n-\t  tree op0 = fold_convert (type, TREE_OPERAND (val, 0));\n-\t  tree op1 = fold_convert (sizetype, fold_offsetof (arg, val));\n-\t  return fold_build2 (POINTER_PLUS_EXPR, type, op0, op1);\n-\t}\n-\n-      /* Uninstantiated types are all functions.  Taking the\n-\t address of a function is a no-op, so just return the\n-\t argument.  */\n-\n-      gcc_assert (TREE_CODE (arg) != IDENTIFIER_NODE\n-\t\t  || !IDENTIFIER_OPNAME_P (arg));\n-\n-      if (TREE_CODE (arg) == COMPONENT_REF && type_unknown_p (arg)\n-\t  && !really_overloaded_fn (TREE_OPERAND (arg, 1)))\n-\t{\n-\t  /* They're trying to take the address of a unique non-static\n-\t     member function.  This is ill-formed (except in MS-land),\n-\t     but let's try to DTRT.\n-\t     Note: We only handle unique functions here because we don't\n-\t     want to complain if there's a static overload; non-unique\n-\t     cases will be handled by instantiate_type.  But we need to\n-\t     handle this case here to allow casts on the resulting PMF.\n-\t     We could defer this in non-MS mode, but it's easier to give\n-\t     a useful error here.  */\n-\n-\t  /* Inside constant member functions, the `this' pointer\n-\t     contains an extra const qualifier.  TYPE_MAIN_VARIANT\n-\t     is used here to remove this const from the diagnostics\n-\t     and the created OFFSET_REF.  */\n-\t  tree base = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (arg, 0)));\n-\t  tree fn = get_first_fn (TREE_OPERAND (arg, 1));\n-\t  mark_used (fn);\n-\n-\t  if (! flag_ms_extensions)\n-\t    {\n-\t      tree name = DECL_NAME (fn);\n-              if (!(complain & tf_error))\n-                return error_mark_node;\n-\t      else if (current_class_type\n-                       && TREE_OPERAND (arg, 0) == current_class_ref)\n-                  /* An expression like &memfn.  */\n-                permerror (input_location, \"ISO C++ forbids taking the address of an unqualified\"\n-                           \" or parenthesized non-static member function to form\"\n-                           \" a pointer to member function.  Say %<&%T::%D%>\",\n-                           base, name);\n-\t      else\n-\t\tpermerror (input_location, \"ISO C++ forbids taking the address of a bound member\"\n-\t\t\t   \" function to form a pointer to member function.\"\n-\t\t\t   \"  Say %<&%T::%D%>\",\n-\t\t\t   base, name);\n-\t    }\n-\t  arg = build_offset_ref (base, fn, /*address_p=*/true);\n-\t}\n-\n-    offset_ref:\n-      if (type_unknown_p (arg))\n-\treturn build1 (ADDR_EXPR, unknown_type_node, arg);\n-\n-      /* Handle complex lvalues (when permitted)\n-\t by reduction to simpler cases.  */\n-      val = unary_complex_lvalue (code, arg);\n-      if (val != 0)\n-\treturn val;\n-\n-      switch (TREE_CODE (arg))\n-\t{\n-\tCASE_CONVERT:\n-\tcase FLOAT_EXPR:\n-\tcase FIX_TRUNC_EXPR:\n-          /* Even if we're not being pedantic, we cannot allow this\n-             extension when we're instantiating in a SFINAE\n-             context.  */\n-\t  if (! lvalue_p (arg) && complain == tf_none)\n-            {\n-              if (complain & tf_error)\n-                permerror (input_location, \"ISO C++ forbids taking the address of a cast to a non-lvalue expression\");\n-              else\n-                return error_mark_node;\n-            }\n-\t  break;\n-\n-\tcase BASELINK:\n-\t  arg = BASELINK_FUNCTIONS (arg);\n-\t  /* Fall through.  */\n-\n-\tcase OVERLOAD:\n-\t  arg = OVL_CURRENT (arg);\n-\t  break;\n-\n-\tcase OFFSET_REF:\n-\t  /* Turn a reference to a non-static data member into a\n-\t     pointer-to-member.  */\n-\t  {\n-\t    tree type;\n-\t    tree t;\n-\n-\t    if (!PTRMEM_OK_P (arg))\n-\t      return cp_build_unary_op (code, arg, 0, complain);\n-\n-\t    t = TREE_OPERAND (arg, 1);\n-\t    if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n-\t      {\n-                if (complain & tf_error)\n-                  error (\"cannot create pointer to reference member %qD\", t);\n-\t\treturn error_mark_node;\n-\t      }\n-\n-\t    type = build_ptrmem_type (context_for_name_lookup (t),\n-\t\t\t\t      TREE_TYPE (t));\n-\t    t = make_ptrmem_cst (type, TREE_OPERAND (arg, 1));\n-\t    return t;\n-\t  }\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      /* Anything not already handled and not a true memory reference\n-\t is an error.  */\n-      if (TREE_CODE (argtype) != FUNCTION_TYPE\n-\t  && TREE_CODE (argtype) != METHOD_TYPE\n-\t  && TREE_CODE (arg) != OFFSET_REF\n-\t  && !lvalue_or_else (arg, lv_addressof, complain))\n-\treturn error_mark_node;\n-\n-      if (argtype != error_mark_node)\n-\targtype = build_pointer_type (argtype);\n-\n-      /* In a template, we are processing a non-dependent expression\n-\t so we can just form an ADDR_EXPR with the correct type.  */\n-      if (processing_template_decl || TREE_CODE (arg) != COMPONENT_REF)\n-\t{\n-\t  val = build_address (arg);\n-\t  if (TREE_CODE (arg) == OFFSET_REF)\n-\t    PTRMEM_OK_P (val) = PTRMEM_OK_P (arg);\n-\t}\n-      else if (TREE_CODE (TREE_OPERAND (arg, 1)) == BASELINK)\n-\t{\n-\t  tree fn = BASELINK_FUNCTIONS (TREE_OPERAND (arg, 1));\n-\n-\t  /* We can only get here with a single static member\n-\t     function.  */\n-\t  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL\n-\t\t      && DECL_STATIC_FUNCTION_P (fn));\n-\t  mark_used (fn);\n-\t  val = build_address (fn);\n-\t  if (TREE_SIDE_EFFECTS (TREE_OPERAND (arg, 0)))\n-\t    /* Do not lose object's side effects.  */\n-\t    val = build2 (COMPOUND_EXPR, TREE_TYPE (val),\n-\t\t\t  TREE_OPERAND (arg, 0), val);\n-\t}\n-      else if (DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1)))\n-\t{\n-          if (complain & tf_error)\n-            error (\"attempt to take address of bit-field structure member %qD\",\n-                   TREE_OPERAND (arg, 1));\n-\t  return error_mark_node;\n-\t}\n-      else\n-\t{\n-\t  tree object = TREE_OPERAND (arg, 0);\n-\t  tree field = TREE_OPERAND (arg, 1);\n-\t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n-\t\t      (TREE_TYPE (object), decl_type_context (field)));\n-\t  val = build_address (arg);\n-\t}\n-\n-      if (TREE_CODE (argtype) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (argtype)) == METHOD_TYPE)\n-\t{\n-\t  build_ptrmemfunc_type (argtype);\n-\t  val = build_ptrmemfunc (argtype, val, 0,\n-\t\t\t\t  /*c_cast_p=*/false,\n-\t\t\t\t  tf_warning_or_error);\n-\t}\n-\n-      return val;\n+      return cp_build_addr_expr (arg, complain);\n \n     default:\n       break;\n@@ -6128,7 +6165,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n \twarning (0, \"casting %qT to %qT does not dereference pointer\",\n \t\t intype, type);\n \n-      expr = cp_build_unary_op (ADDR_EXPR, expr, 0, complain);\n+      expr = cp_build_addr_expr (expr, complain);\n \n       if (warn_strict_aliasing > 2)\n \tstrict_aliasing_warning (TREE_TYPE (expr), type, expr);\n@@ -6366,8 +6403,8 @@ build_const_cast_1 (tree dst_type, tree expr, bool complain,\n \t}\n       if (reference_type)\n \t{\n-\t  expr = cp_build_unary_op (ADDR_EXPR, expr, 0, \n-                                    complain? tf_warning_or_error : tf_none);\n+\t  expr = cp_build_addr_expr (expr,\n+\t\t\t\t     complain ? tf_warning_or_error : tf_none);\n \t  expr = build_nop (reference_type, expr);\n \t  return convert_from_reference (expr);\n \t}\n@@ -8324,7 +8361,7 @@ non_reference (tree t)\n int\n lvalue_or_else (tree ref, enum lvalue_use use, tsubst_flags_t complain)\n {\n-  int win = lvalue_p (ref);\n+  int win = real_lvalue_p (ref);\n \n   if (!win && (complain & tf_error))\n     lvalue_error (use);"}, {"sha": "f56e70965e287865d5ab12369087411340cc3aa9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -1,3 +1,11 @@\n+2010-09-27  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/rv-lvalue-req.C: New.\n+\t* g++.dg/ext/complit11.C: Adjust.\n+\t* g++.old-deja/g++.law/temps1.C: Adjust.\n+\t* g++.old-deja/g++.ns/koenig6.C: Adjust.\n+\t* g++.old-deja/g++.oliva/partord1.C: Adjust.\n+\n 2010-09-27  Ian Lance Taylor  <iant@google.com>\n \n \t* lib/target-supports.exp (check_effective_target_split_stack):"}, {"sha": "ba1c306d9dcd262a0364af93e08a385bb0889eaf", "filename": "gcc/testsuite/g++.dg/cpp0x/rv-lvalue-req.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv-lvalue-req.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv-lvalue-req.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv-lvalue-req.C?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options -std=c++0x }\n+\n+template <class T> T&& declval();\n+\n+int main()\n+{\n+  &declval<int>();\t\t        // { dg-error \"lvalue\" }\n+  declval<int>() = declval<int>();\t// { dg-error \"lvalue\" }\n+  declval<int>()++;\t\t\t// { dg-error \"lvalue\" }\n+  --declval<int>();\t\t\t// { dg-error \"lvalue\" }\n+  declval<int>() += 1;\t\t\t// { dg-error \"lvalue\" }\n+}"}, {"sha": "2cff6cd2eb485f749f0a10767c79324955e33e9e", "filename": "gcc/testsuite/g++.dg/ext/complit11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit11.C?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -6,7 +6,7 @@ struct A { int i; };\n template<int t>\n void foo()\n {\n-    ((struct A) { 0 }).i += 1;\n+    ((struct A) { 0 }).i += 1;\t// { dg-error \"lvalue required\" }\n }\n \n void g(void)"}, {"sha": "2e6a41951162d08699db4ce4bc54ef7a7a38c07e", "filename": "gcc/testsuite/g++.old-deja/g++.law/temps1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Ftemps1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Ftemps1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Ftemps1.C?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -16,4 +16,4 @@ struct cookie\n };\n \n cookie cat(&foo(\"apabepa\"));// { dg-warning \"deprecated conversion\" \"dep\" }\n-// { dg-warning \"taking address of temporary\" \"add\" { target *-*-* } 18 }\n+// { dg-error \"lvalue required\" \"lvalue\" { target *-*-* } 18 }"}, {"sha": "b5fa9c989963ba6adb3e3f90799354f7f4959815", "filename": "gcc/testsuite/g++.old-deja/g++.ns/koenig6.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fkoenig6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fkoenig6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fkoenig6.C?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -2,12 +2,12 @@\n namespace A{\n   struct X{};\n \n-  X foo(X a){return a;}\n+  X* foo(X a);\n   void bar(X*){}\n }\n \n int main()\n {\n   A::X x;\n-  bar(&foo(x));  // { dg-warning \"\" } address of temporary\n+  bar(foo(x));\n }"}, {"sha": "34fe92e64076fbeaf5f8412db440eceaf8f20446", "filename": "gcc/testsuite/g++.old-deja/g++.oliva/partord1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fpartord1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c0e0bb1d729b142f698d42fb4a61ad23a52505/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fpartord1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fpartord1.C?ref=93c0e0bb1d729b142f698d42fb4a61ad23a52505", "patch": "@@ -14,10 +14,10 @@ template <typename T> class bar {\n };\n \n template <typename T> void foo(T) {\n-  bar<T>().i = 0; // ok, I'm a friend\n+  bar<T>().i; // ok, I'm a friend\n }\n template <typename T> void foo(T*) {\n-  bar<T*>().i = 1; // { dg-error \"\" } not a friend\n+  bar<T*>().i; // { dg-error \"\" } not a friend\n }\n \n int main() {"}]}