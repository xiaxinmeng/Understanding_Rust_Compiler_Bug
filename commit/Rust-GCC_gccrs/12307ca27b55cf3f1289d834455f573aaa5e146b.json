{"sha": "12307ca27b55cf3f1289d834455f573aaa5e146b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIzMDdjYTI3YjU1Y2YzZjEyODlkODM0NDU1ZjU3M2FhYTVlMTQ2Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-27T20:27:39Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-27T20:27:39Z"}, "message": "Include regs.h.\n\n(initialize_for_inline): Pass additional args to gen_inline_header.\n(save_for_inline_copying): Make new regno_reg_rtx, regno_pointer_flag,\nand regno_pointer_align arrays.\n(expand_inline_function): Set alignment of reg for parm if passed by\nhidden pointer.\nSet regno_pointer_{flag,align} into remap table.\n(copy_rtx_and_substitute): Set alignment of pointers into stack frame.\nCopy pointer flag and alignment to regs that are copies of\npointer registers from the original regs.\n(output_inline_function): Don't call restore_reg_data.\nRestore reg_rtx_no, regno_{reg_rtx,pointer_flag,pointer_align}.\n\nFrom-SVN: r10877", "tree": {"sha": "b8e91fd072eecdcb5bbf97359d6c7df4a213dde6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8e91fd072eecdcb5bbf97359d6c7df4a213dde6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12307ca27b55cf3f1289d834455f573aaa5e146b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12307ca27b55cf3f1289d834455f573aaa5e146b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12307ca27b55cf3f1289d834455f573aaa5e146b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12307ca27b55cf3f1289d834455f573aaa5e146b/comments", "author": null, "committer": null, "parents": [{"sha": "3051365e5660fa68a8f0672f9422b7823b0c2ac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3051365e5660fa68a8f0672f9422b7823b0c2ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3051365e5660fa68a8f0672f9422b7823b0c2ac3"}], "stats": {"total": 112, "additions": 71, "deletions": 41}, "files": [{"sha": "77e4676a2c785837c650167de2e23adb45358141", "filename": "gcc/integrate.c", "status": "modified", "additions": 71, "deletions": 41, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12307ca27b55cf3f1289d834455f573aaa5e146b/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12307ca27b55cf3f1289d834455f573aaa5e146b/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=12307ca27b55cf3f1289d834455f573aaa5e146b", "patch": "@@ -25,6 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n+#include \"regs.h\"\n #include \"flags.h\"\n #include \"insn-config.h\"\n #include \"insn-flags.h\"\n@@ -106,14 +107,6 @@ function_cannot_inline_p (fndecl)\n   if (!DECL_INLINE (fndecl) && get_max_uid () > 3 * max_insns)\n     return \"function too large to be inline\";\n \n-#if 0\n-  /* Large stacks are OK now that inlined functions can share them.  */\n-  /* Don't inline functions with large stack usage,\n-     since they can make other recursive functions burn up stack.  */\n-  if (!DECL_INLINE (fndecl) && get_frame_size () > 100)\n-    return \"function stack frame for inlining\";\n-#endif\n-\n #if 0\n   /* Don't inline functions which do not specify a function prototype and\n      have BLKmode argument or take the address of a parameter.  */\n@@ -152,12 +145,11 @@ function_cannot_inline_p (fndecl)\n \n   if (!DECL_INLINE (fndecl) && get_max_uid () > max_insns)\n     {\n-      for (ninsns = 0, insn = get_first_nonparm_insn (); insn && ninsns < max_insns;\n+      for (ninsns = 0, insn = get_first_nonparm_insn ();\n+\t   insn && ninsns < max_insns;\n \t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t    ninsns++;\n-\t}\n+\tif (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t  ninsns++;\n \n       if (ninsns >= max_insns)\n \treturn \"function too large to be inline\";\n@@ -319,15 +311,18 @@ initialize_for_inline (fndecl, min_labelno, max_labelno, max_reg, copy)\n      some flags that are used to restore compiler globals,\n      the value of current_function_outgoing_args_size,\n      the original argument vector,\n-     and the original DECL_INITIAL.  */\n+     the original DECL_INITIAL,\n+     and pointers to the table of psuedo regs, pointer flags, and alignment. */\n \n   return gen_inline_header_rtx (NULL_RTX, NULL_RTX, min_labelno, max_labelno,\n \t\t\t\tmax_parm_reg, max_reg,\n \t\t\t\tcurrent_function_args_size,\n \t\t\t\tcurrent_function_pops_args,\n \t\t\t\tstack_slot_list, forced_labels, function_flags,\n \t\t\t\tcurrent_function_outgoing_args_size,\n-\t\t\t\targ_vector, (rtx) DECL_INITIAL (fndecl));\n+\t\t\t\targ_vector, (rtx) DECL_INITIAL (fndecl),\n+\t\t\t\t(rtvec) regno_reg_rtx, regno_pointer_flag,\n+\t\t\t\tregno_pointer_align);\n }\n \n /* Subroutine for `save_for_inline{copying,nocopy}'.  Finishes up the\n@@ -395,6 +390,8 @@ save_for_inline_copying (fndecl)\n   int max_reg;\n   int max_uid;\n   rtx first_nonparm_insn;\n+  char *new, *new1;\n+  rtx *new2;\n \n   /* Make and emit a return-label if we have not already done so. \n      Do this before recording the bounds on label numbers. */\n@@ -609,6 +606,19 @@ save_for_inline_copying (fndecl)\n \n   finish_inline (fndecl, head);\n \n+  /* Make new versions of the register tables.  */\n+  new = (char *) savealloc (regno_pointer_flag_length);\n+  bcopy (regno_pointer_flag, new, regno_pointer_flag_length);\n+  new1 = (char *) savealloc (regno_pointer_flag_length);\n+  bcopy (regno_pointer_align, new1, regno_pointer_flag_length);\n+  new2 = (rtx *) savealloc (regno_pointer_flag_length * sizeof (rtx));\n+  bcopy ((char *) regno_reg_rtx, (char *) new2,\n+\t regno_pointer_flag_length * sizeof (rtx));\n+\n+  regno_pointer_flag = new;\n+  regno_pointer_align = new1;\n+  regno_reg_rtx = new2;\n+\n   set_new_first_and_last_insn (first_insn, last_insn);\n }\n \n@@ -1151,7 +1161,8 @@ int global_const_equiv_map_size;\n    else an rtx for where the value is stored.  */\n \n rtx\n-expand_inline_function (fndecl, parms, target, ignore, type, structure_value_addr)\n+expand_inline_function (fndecl, parms, target, ignore, type,\n+\t\t\tstructure_value_addr)\n      tree fndecl, parms;\n      rtx target;\n      int ignore;\n@@ -1190,11 +1201,9 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n      passed.  Since the appropriate conversions or default promotions have\n      already been applied, the machine modes should match exactly.  */\n \n-  for (formal = DECL_ARGUMENTS (fndecl),\n-       actual = parms;\n+  for (formal = DECL_ARGUMENTS (fndecl), actual = parms;\n        formal;\n-       formal = TREE_CHAIN (formal),\n-       actual = TREE_CHAIN (actual))\n+       formal = TREE_CHAIN (formal), actual = TREE_CHAIN (actual))\n     {\n       tree arg;\n       enum machine_mode mode;\n@@ -1203,7 +1212,7 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \treturn (rtx) (HOST_WIDE_INT) -1;\n \n       arg = TREE_VALUE (actual);\n-      mode= TYPE_MODE (DECL_ARG_TYPE (formal));\n+      mode = TYPE_MODE (DECL_ARG_TYPE (formal));\n \n       if (mode != TYPE_MODE (TREE_TYPE (arg))\n \t  /* If they are block mode, the types should match exactly.\n@@ -1303,6 +1312,12 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \t\t handle SUBREGs in addresses.  */\n \t      || (GET_CODE (arg_vals[i]) == SUBREG)))\n \targ_vals[i] = copy_to_mode_reg (GET_MODE (loc), arg_vals[i]);\n+\n+      if (arg_vals[i] != 0 && GET_CODE (arg_vals[i]) == REG\n+\t  && TREE_CODE (TREE_TYPE (formal)) == POINTER_TYPE)\n+\tmark_reg_pointer (arg_vals[i],\n+\t\t\t  (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (formal)))\n+\t\t\t   / BITS_PER_UNIT));\n     }\n \t\n   /* Allocate the structures we use to remap things.  */\n@@ -1353,6 +1368,9 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n      and argument memory blocks.  */\n   map->insns_at_start = get_last_insn ();\n \n+  map->regno_pointer_flag = INLINE_REGNO_POINTER_FLAG (header);\n+  map->regno_pointer_align = INLINE_REGNO_POINTER_ALIGN (header);\n+\n   /* Update the outgoing argument size to allow for those in the inlined\n      function.  */\n   if (OUTGOING_ARGS_SIZE (header) > current_function_outgoing_args_size)\n@@ -2086,6 +2104,11 @@ copy_rtx_and_substitute (orig, map)\n \t      map->reg_map[regno] = temp\n \t\t= force_reg (Pmode, force_operand (loc, NULL_RTX));\n \n+#ifdef STACK_BOUNDARY\n+\t      mark_reg_pointer (map->reg_map[regno],\n+\t\t\t\tSTACK_BOUNDARY / BITS_PER_UNIT);\n+#endif\n+\n \t      if (REGNO (temp) < map->const_equiv_map_size)\n \t\t{\n \t\t  map->const_equiv_map[REGNO (temp)] = loc;\n@@ -2116,6 +2139,11 @@ copy_rtx_and_substitute (orig, map)\n \t      map->reg_map[regno] = temp\n \t\t= force_reg (Pmode, force_operand (loc, NULL_RTX));\n \n+#ifdef STACK_BOUNDARY\n+\t      mark_reg_pointer (map->reg_map[regno],\n+\t\t\t\tSTACK_BOUNDARY / BITS_PER_UNIT);\n+#endif\n+\n \t      if (REGNO (temp) < map->const_equiv_map_size)\n \t\t{\n \t\t  map->const_equiv_map[REGNO (temp)] = loc;\n@@ -2150,6 +2178,10 @@ copy_rtx_and_substitute (orig, map)\n \t  REG_LOOP_TEST_P (map->reg_map[regno]) = REG_LOOP_TEST_P (orig);\n \t  RTX_UNCHANGING_P (map->reg_map[regno]) = RTX_UNCHANGING_P (orig);\n \t  /* A reg with REG_FUNCTION_VALUE_P true will never reach here.  */\n+\n+\t  if (map->regno_pointer_flag[regno])\n+\t    mark_reg_pointer (map->reg_map[regno],\n+\t\t\t      map->regno_pointer_align[regno]);\n \t}\n       return map->reg_map[regno];\n \n@@ -2596,8 +2628,6 @@ subst_constants (loc, insn, map)\n \tsrc = SET_SRC (x);\n \n \twhile (GET_CODE (*dest_loc) == ZERO_EXTRACT\n-\t       /* By convention, we always use ZERO_EXTRACT in the dest.  */\n-/*\t       || GET_CODE (*dest_loc) == SIGN_EXTRACT */\n \t       || GET_CODE (*dest_loc) == SUBREG\n \t       || GET_CODE (*dest_loc) == STRICT_LOW_PART)\n \t  {\n@@ -2932,25 +2962,20 @@ set_block_abstract_flags (stmt, setting)\n      register tree stmt;\n      register int setting;\n {\n-  BLOCK_ABSTRACT (stmt) = setting;\n-\n-  {\n-    register tree local_decl;\n+  register tree local_decl;\n+  register tree subblock;\n \n-    for (local_decl = BLOCK_VARS (stmt);\n-\t local_decl != NULL_TREE;\n-\t local_decl = TREE_CHAIN (local_decl))\n-      set_decl_abstract_flags (local_decl, setting);\n-  }\n+  BLOCK_ABSTRACT (stmt) = setting;\n \n-  {\n-    register tree subblock;\n+  for (local_decl = BLOCK_VARS (stmt);\n+       local_decl != NULL_TREE;\n+       local_decl = TREE_CHAIN (local_decl))\n+    set_decl_abstract_flags (local_decl, setting);\n \n-    for (subblock = BLOCK_SUBBLOCKS (stmt);\n-\t subblock != NULL_TREE;\n-\t subblock = BLOCK_CHAIN (subblock))\n-      set_block_abstract_flags (subblock, setting);\n-  }\n+  for (subblock = BLOCK_SUBBLOCKS (stmt);\n+       subblock != NULL_TREE;\n+       subblock = BLOCK_CHAIN (subblock))\n+    set_block_abstract_flags (subblock, setting);\n }\n \n /* Given a pointer to some ..._DECL node, and a boolean value to set the\n@@ -3012,8 +3037,13 @@ output_inline_function (fndecl)\n   /* Set stack frame size.  */\n   assign_stack_local (BLKmode, DECL_FRAME_SIZE (fndecl), 0);\n \n-  restore_reg_data (FIRST_PARM_INSN (head));\n-\n+  /* The first is a bit of a lie (the array may be larger), but doesn't\n+     matter too much and it isn't worth saving the actual bound.  */\n+  reg_rtx_no = regno_pointer_flag_length = MAX_REGNUM (head);\n+  regno_reg_rtx = (rtx *) INLINE_REGNO_REG_RTX (head);\n+  regno_pointer_flag = INLINE_REGNO_POINTER_FLAG (head);\n+  regno_pointer_align = INLINE_REGNO_POINTER_ALIGN (head);\n+  \n   stack_slot_list = STACK_SLOT_LIST (head);\n   forced_labels = FORCED_LABELS (head);\n "}]}