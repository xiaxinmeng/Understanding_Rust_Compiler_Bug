{"sha": "ace0ae09332bbc6b95e084c2c2b17c466339ff76", "node_id": "C_kwDOANBUbNoAKGFjZTBhZTA5MzMyYmJjNmI5NWUwODRjMmMyYjE3YzQ2NjMzOWZmNzY", "commit": {"author": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2022-11-09T15:48:04Z"}, "committer": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2022-11-09T15:48:04Z"}, "message": "Change the name of array_at_struct_end_p to array_ref_flexible_size_p\n\nThe name of the utility routine \"array_at_struct_end_p\" is misleading\nand should be changed to a new name that more accurately reflects its\nreal meaning.\n\nThe routine \"array_at_struct_end_p\" is used to check whether an array\nreference is to an array whose actual size might be larger than its\nupper bound implies, which includes 3 different cases:\n\n   A. a ref to a flexible array member at the end of a structure;\n   B. a ref to an array with a different type against the original decl;\n   C. a ref to an array that was passed as a parameter;\n\nThe old name only reflects the above case A, therefore very confusing\nwhen reading the corresponding gcc source code.\n\nIn this patch, A new name \"array_ref_flexible_size_p\" is used to replace\nthe old name.\n\nAll the references to the routine \"array_at_struct_end_p\" was replaced\nwith this new name, and the corresponding comments were updated to make\nthem clean and consistent.\n\ngcc/ChangeLog:\n\n\t* gimple-array-bounds.cc (trailing_array): Replace\n\tarray_at_struct_end_p with new name and update comments.\n\t* gimple-fold.cc (get_range_strlen_tree): Likewise.\n\t* gimple-ssa-warn-restrict.cc (builtin_memref::builtin_memref):\n\tLikewise.\n\t* graphite-sese-to-poly.cc (bounds_are_valid): Likewise.\n\t* tree-if-conv.cc (idx_within_array_bound): Likewise.\n\t* tree-object-size.cc (addr_object_size): Likewise.\n\t* tree-ssa-alias.cc (component_ref_to_zero_sized_trailing_array_p):\n\tLikewise.\n\t(stmt_kills_ref_p): Likewise.\n\t* tree-ssa-loop-niter.cc (idx_infer_loop_bounds): Likewise.\n\t* tree-ssa-strlen.cc (maybe_set_strlen_range): Likewise.\n\t* tree.cc (array_at_struct_end_p): Rename to ...\n\t(array_ref_flexible_size_p): ... this.\n\t(component_ref_size): Replace array_at_struct_end_p with new name.\n\t* tree.h (array_at_struct_end_p): Rename to ...\n\t(array_ref_flexible_size_p): ... this.", "tree": {"sha": "54cd5d03b2e32bf70487ddea4dbdccbce7dc28c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54cd5d03b2e32bf70487ddea4dbdccbce7dc28c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ace0ae09332bbc6b95e084c2c2b17c466339ff76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ace0ae09332bbc6b95e084c2c2b17c466339ff76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ace0ae09332bbc6b95e084c2c2b17c466339ff76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ace0ae09332bbc6b95e084c2c2b17c466339ff76/comments", "author": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b3d926d796050468b8a844e5fb8c20bda741c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3d926d796050468b8a844e5fb8c20bda741c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b3d926d796050468b8a844e5fb8c20bda741c26"}], "stats": {"total": 72, "additions": 35, "deletions": 37}, "files": [{"sha": "fbf448e045df4c208b7e118f7e08242576a80184", "filename": "gcc/gimple-array-bounds.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Fgimple-array-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Fgimple-array-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.cc?ref=ace0ae09332bbc6b95e084c2c2b17c466339ff76", "patch": "@@ -129,7 +129,7 @@ get_ref_size (tree arg, tree *pref)\n }\n \n /* Return true if REF is (likely) an ARRAY_REF to a trailing array member\n-   of a struct.  It refines array_at_struct_end_p by detecting a pointer\n+   of a struct.  It refines array_ref_flexible_size_p by detecting a pointer\n    to an array and an array parameter declared using the [N] syntax (as\n    opposed to a pointer) and returning false.  Set *PREF to the decl or\n    expression REF refers to.  */\n@@ -167,7 +167,7 @@ trailing_array (tree arg, tree *pref)\n \treturn false;\n     }\n \n-  return array_at_struct_end_p (arg);\n+  return array_ref_flexible_size_p (arg);\n }\n \n /* Checks one ARRAY_REF in REF, located at LOCUS. Ignores flexible"}, {"sha": "8d4079870be53cce902e8368cf973ab87e775d11", "filename": "gcc/gimple-fold.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Fgimple-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Fgimple-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.cc?ref=ace0ae09332bbc6b95e084c2c2b17c466339ff76", "patch": "@@ -1690,13 +1690,11 @@ get_range_strlen_tree (tree arg, bitmap visited, strlen_range_kind rkind,\n \t  /* Handle a MEM_REF into a DECL accessing an array of integers,\n \t     being conservative about references to extern structures with\n \t     flexible array members that can be initialized to arbitrary\n-\t     numbers of elements as an extension (static structs are okay).\n-\t     FIXME: Make this less conservative -- see\n-\t     component_ref_size in tree.cc.  */\n+\t     numbers of elements as an extension (static structs are okay).  */\n \t  tree ref = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n \t  if ((TREE_CODE (ref) == PARM_DECL || VAR_P (ref))\n \t      && (decl_binds_to_current_def_p (ref)\n-\t\t  || !array_at_struct_end_p (arg)))\n+\t\t  || !array_ref_flexible_size_p (arg)))\n \t    {\n \t      /* Fail if the offset is out of bounds.  Such accesses\n \t\t should be diagnosed at some point.  */"}, {"sha": "832456ba6fce2f9e614e1bdf1c28612b6ddfe221", "filename": "gcc/gimple-ssa-warn-restrict.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Fgimple-ssa-warn-restrict.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Fgimple-ssa-warn-restrict.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.cc?ref=ace0ae09332bbc6b95e084c2c2b17c466339ff76", "patch": "@@ -296,8 +296,9 @@ builtin_memref::builtin_memref (pointer_query &ptrqry, gimple *stmt, tree expr,\n   tree basetype = TREE_TYPE (base);\n   if (TREE_CODE (basetype) == ARRAY_TYPE)\n     {\n-      if (ref && array_at_struct_end_p (ref))\n-\t;   /* Use the maximum possible offset for last member arrays.  */\n+      if (ref && array_ref_flexible_size_p (ref))\n+\t;   /* Use the maximum possible offset for an array that might\n+\t       have flexible size.  */\n       else if (tree basesize = TYPE_SIZE_UNIT (basetype))\n \tif (TREE_CODE (basesize) == INTEGER_CST)\n \t  /* Size could be non-constant for a variable-length type such"}, {"sha": "7eb24c1c991b5e153f66a58509b2a9ec13d972d2", "filename": "gcc/graphite-sese-to-poly.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Fgraphite-sese-to-poly.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Fgraphite-sese-to-poly.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.cc?ref=ace0ae09332bbc6b95e084c2c2b17c466339ff76", "patch": "@@ -536,9 +536,9 @@ bounds_are_valid (tree ref, tree low, tree high)\n       || !tree_fits_shwi_p (high))\n     return false;\n \n-  /* 1-element arrays at end of structures may extend over\n+  /* An array that has flexible size may extend over\n      their declared size.  */\n-  if (array_at_struct_end_p (ref)\n+  if (array_ref_flexible_size_p (ref)\n       && operand_equal_p (low, high, 0))\n     return false;\n "}, {"sha": "34bb507ff3ba6a1b97a465d5f1a11ca5b4f90658", "filename": "gcc/tree-if-conv.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree-if-conv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree-if-conv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.cc?ref=ace0ae09332bbc6b95e084c2c2b17c466339ff76", "patch": "@@ -763,10 +763,9 @@ idx_within_array_bound (tree ref, tree *idx, void *dta)\n   if (TREE_CODE (ref) != ARRAY_REF)\n     return false;\n \n-  /* For arrays at the end of the structure, we are not guaranteed that they\n-     do not really extend over their declared size.  However, for arrays of\n-     size greater than one, this is unlikely to be intended.  */\n-  if (array_at_struct_end_p (ref))\n+  /* For arrays that might have flexible sizes, it is not guaranteed that they\n+     do not extend over their declared size.  */\n+  if (array_ref_flexible_size_p (ref))\n     return false;\n \n   ev = analyze_scalar_evolution (loop, *idx);"}, {"sha": "2e5d267d8ce23a03dfab12feaaf86455da14fbc0", "filename": "gcc/tree-object-size.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree-object-size.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree-object-size.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.cc?ref=ace0ae09332bbc6b95e084c2c2b17c466339ff76", "patch": "@@ -633,7 +633,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t\t\tv = NULL_TREE;\n \t\t\tbreak;\n \t\t      }\n-\t\t    is_flexible_array_mem_ref = array_at_struct_end_p (v);\n+\t\t    is_flexible_array_mem_ref = array_ref_flexible_size_p (v);\n \t\t    while (v != pt_var && TREE_CODE (v) == COMPONENT_REF)\n \t\t      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (v, 0)))\n \t\t\t  != UNION_TYPE"}, {"sha": "d3a91b1f2385c9a7212df8e89cc0dc8200a3ebad", "filename": "gcc/tree-ssa-alias.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree-ssa-alias.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree-ssa-alias.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.cc?ref=ace0ae09332bbc6b95e084c2c2b17c466339ff76", "patch": "@@ -1073,7 +1073,7 @@ component_ref_to_zero_sized_trailing_array_p (tree ref)\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 1))) == ARRAY_TYPE\n \t  && (!TYPE_SIZE (TREE_TYPE (TREE_OPERAND (ref, 1)))\n \t      || integer_zerop (TYPE_SIZE (TREE_TYPE (TREE_OPERAND (ref, 1)))))\n-\t  && array_at_struct_end_p (ref));\n+\t  && array_ref_flexible_size_p (ref));\n }\n \n /* Worker for aliasing_component_refs_p. Most parameters match parameters of\n@@ -3433,10 +3433,10 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t    }\n \t  /* Finally check if the lhs has the same address and size as the\n \t     base candidate of the access.  Watch out if we have dropped\n-\t     an array-ref that was at struct end, this means ref->ref may\n-\t     be outside of the TYPE_SIZE of its base.  */\n+\t     an array-ref that might have flexible size, this means ref->ref\n+\t     may be outside of the TYPE_SIZE of its base.  */\n \t  if ((! innermost_dropped_array_ref\n-\t       || ! array_at_struct_end_p (innermost_dropped_array_ref))\n+\t       || ! array_ref_flexible_size_p (innermost_dropped_array_ref))\n \t      && (lhs == base\n \t\t  || (((TYPE_SIZE (TREE_TYPE (lhs))\n \t\t\t== TYPE_SIZE (TREE_TYPE (base)))"}, {"sha": "3fbbf4367ed1bda2bd38e0578c590cfdd2b9a351", "filename": "gcc/tree-ssa-loop-niter.cc", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree-ssa-loop-niter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree-ssa-loop-niter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.cc?ref=ace0ae09332bbc6b95e084c2c2b17c466339ff76", "patch": "@@ -3716,18 +3716,17 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n   struct ilb_data *data = (struct ilb_data *) dta;\n   tree ev, init, step;\n   tree low, high, type, next;\n-  bool sign, upper = true, at_end = false;\n+  bool sign, upper = true, has_flexible_size = false;\n   class loop *loop = data->loop;\n \n   if (TREE_CODE (base) != ARRAY_REF)\n     return true;\n \n-  /* For arrays at the end of the structure, we are not guaranteed that they\n-     do not really extend over their declared size.  However, for arrays of\n-     size greater than one, this is unlikely to be intended.  */\n-  if (array_at_struct_end_p (base))\n+  /* For arrays that might have flexible sizes, it is not guaranteed that they\n+     do not really extend over their declared size.  */ \n+  if (array_ref_flexible_size_p (base))\n     {\n-      at_end = true;\n+      has_flexible_size = true;\n       upper = false;\n     }\n \n@@ -3760,9 +3759,9 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n   sign = tree_int_cst_sign_bit (step);\n   type = TREE_TYPE (step);\n \n-  /* The array of length 1 at the end of a structure most likely extends\n+  /* The array that might have flexible size most likely extends\n      beyond its bounds.  */\n-  if (at_end\n+  if (has_flexible_size\n       && operand_equal_p (low, high, 0))\n     return true;\n "}, {"sha": "b87c7c7ce1f73ad84cb5b2bf9745eafbca81f60f", "filename": "gcc/tree-ssa-strlen.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree-ssa-strlen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree-ssa-strlen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.cc?ref=ace0ae09332bbc6b95e084c2c2b17c466339ff76", "patch": "@@ -1987,7 +1987,7 @@ maybe_set_strlen_range (tree lhs, tree src, tree bound)\n \t suggests if it's treated as a poor-man's flexible array member.  */\n       src = TREE_OPERAND (src, 0);\n       if (TREE_CODE (src) != MEM_REF\n-\t  && !array_at_struct_end_p (src))\n+\t  && !array_ref_flexible_size_p (src))\n \t{\n \t  tree type = TREE_TYPE (src);\n \t  tree size = TYPE_SIZE_UNIT (type);"}, {"sha": "574bd2e65d976d9654894fa936c1f62890f296b1", "filename": "gcc/tree.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=ace0ae09332bbc6b95e084c2c2b17c466339ff76", "patch": "@@ -12727,8 +12727,8 @@ array_ref_up_bound (tree exp)\n   return NULL_TREE;\n }\n \n-/* Returns true if REF is an array reference, component reference,\n-   or memory reference to an array whose actual size might be larger\n+/* Returns true if REF is an array reference, a component reference,\n+   or a memory reference to an array whose actual size might be larger\n    than its upper bound implies, there are multiple cases:\n    A. a ref to a flexible array member at the end of a structure;\n    B. a ref to an array with a different type against the original decl;\n@@ -12743,10 +12743,10 @@ array_ref_up_bound (tree exp)\n    int test (uint8_t *p, uint32_t t[1][1], int n) {\n    for (int i = 0; i < 4; i++, p++)\n      t[i][0] = ...;\n+*/\n \n-   FIXME, the name of this routine need to be changed to be more accurate.  */\n bool\n-array_at_struct_end_p (tree ref)\n+array_ref_flexible_size_p (tree ref)\n {\n   /* the TYPE for this array referece.  */\n   tree atype = NULL_TREE;\n@@ -12879,6 +12879,7 @@ array_at_struct_end_p (tree ref)\n   return afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n }\n \n+\n /* Return a tree representing the offset, in bytes, of the field referenced\n    by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n \n@@ -12974,7 +12975,7 @@ component_ref_size (tree ref, special_array_member *sam /* = NULL */)\n \treturn (tree_int_cst_equal (memsize, TYPE_SIZE_UNIT (memtype))\n \t\t? memsize : NULL_TREE);\n \n-      bool trailing = array_at_struct_end_p (ref);\n+      bool trailing = array_ref_flexible_size_p (ref);\n       bool zero_length = integer_zerop (memsize);\n       if (!trailing && !zero_length)\n \t/* MEMBER is either an interior array or is an array with"}, {"sha": "a863d2e50e5ecafa3f5da4dda98d9637261d07a9", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace0ae09332bbc6b95e084c2c2b17c466339ff76/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ace0ae09332bbc6b95e084c2c2b17c466339ff76", "patch": "@@ -5554,10 +5554,10 @@ extern tree array_ref_up_bound (tree);\n    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n extern tree array_ref_low_bound (tree);\n \n-/* Returns true if REF is an array reference or a component reference\n-   to an array at the end of a structure.  If this is the case, the array\n-   may be allocated larger than its upper bound implies.  */\n-extern bool array_at_struct_end_p (tree);\n+/* Returns true if REF is an array reference, a component reference,\n+   or a memory reference to an array whose actual size might be larger\n+   than its upper bound implies.  */\n+extern bool array_ref_flexible_size_p (tree);\n \n /* Return a tree representing the offset, in bytes, of the field referenced\n    by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */"}]}