{"sha": "df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY3YjBjYzRhYWUwNjIwZDgzMGI4ZTlmOGVkOGE1ODZlNjhmNDcwYg==", "commit": {"author": {"name": "Enkovich Ilya", "email": "ilya.enkovich@intel.com", "date": "2011-09-06T16:42:47Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2011-09-06T16:42:47Z"}, "message": "PR middle-end/44382: Tree reassociation improvement\n\ngcc/\n\n2011-09-06  Enkovich Ilya  <ilya.enkovich@intel.com>\n\n\tPR middle-end/44382\n\t* target.def (reassociation_width): New hook.\n\n\t* doc/tm.texi.in (reassociation_width): Likewise.\n\n\t* doc/tm.texi (reassociation_width): Likewise.\n\n\t* doc/invoke.texi (tree-reassoc-width): New param documented.\n\n\t* hooks.h (hook_int_uint_mode_1): New default hook.\n\n\t* hooks.c (hook_int_uint_mode_1): Likewise.\n\n\t* config/i386/i386.h (ix86_tune_indices): Add\n\tX86_TUNE_REASSOC_INT_TO_PARALLEL and\n\tX86_TUNE_REASSOC_FP_TO_PARALLEL.\n\n\t(TARGET_REASSOC_INT_TO_PARALLEL): New.\n\t(TARGET_REASSOC_FP_TO_PARALLEL): Likewise.\n\n\t* config/i386/i386.c (initial_ix86_tune_features): Add\n\tX86_TUNE_REASSOC_INT_TO_PARALLEL and\n\tX86_TUNE_REASSOC_FP_TO_PARALLEL.\n\n\t(ix86_reassociation_width) implementation of\n\tnew hook for i386 target.\n\n\t* params.def (PARAM_TREE_REASSOC_WIDTH): New param added.\n\n\t* tree-ssa-reassoc.c (get_required_cycles): New function.\n\t(get_reassociation_width): Likewise.\n\t(swap_ops_for_binary_stmt): Likewise.\n\t(rewrite_expr_tree_parallel): Likewise.\n\n\t(rewrite_expr_tree): Refactored. Part of code moved into\n\tswap_ops_for_binary_stmt.\n\n\t(reassociate_bb): Now checks reassociation width to be used\n\tand call rewrite_expr_tree_parallel instead of rewrite_expr_tree\n\tif needed.\n\ngcc/testsuite/\n\n2011-09-06  Enkovich Ilya  <ilya.enkovich@intel.com>\n\n\t* gcc.dg/tree-ssa/pr38533.c (dg-options): Added option\n\t--param tree-reassoc-width=1.\n\n\t* gcc.dg/tree-ssa/reassoc-24.c: New test.\n\t* gcc.dg/tree-ssa/reassoc-25.c: Likewise.\n\nFrom-SVN: r178602", "tree": {"sha": "1f9104f6409decb81158ba4c73d5eed24b186893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f9104f6409decb81158ba4c73d5eed24b186893"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/comments", "author": {"login": "ienkovich", "id": 18308708, "node_id": "MDQ6VXNlcjE4MzA4NzA4", "avatar_url": "https://avatars.githubusercontent.com/u/18308708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ienkovich", "html_url": "https://github.com/ienkovich", "followers_url": "https://api.github.com/users/ienkovich/followers", "following_url": "https://api.github.com/users/ienkovich/following{/other_user}", "gists_url": "https://api.github.com/users/ienkovich/gists{/gist_id}", "starred_url": "https://api.github.com/users/ienkovich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ienkovich/subscriptions", "organizations_url": "https://api.github.com/users/ienkovich/orgs", "repos_url": "https://api.github.com/users/ienkovich/repos", "events_url": "https://api.github.com/users/ienkovich/events{/privacy}", "received_events_url": "https://api.github.com/users/ienkovich/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df2f61000e93a5c300703c9f23af007c0621693f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df2f61000e93a5c300703c9f23af007c0621693f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df2f61000e93a5c300703c9f23af007c0621693f"}], "stats": {"total": 474, "additions": 425, "deletions": 49}, "files": [{"sha": "bf50b80f79bddfad1f87baf01154ba846e756904", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -1,3 +1,46 @@\n+2011-09-06  Enkovich Ilya  <ilya.enkovich@intel.com>\n+\n+\tPR middle-end/44382\n+\t* target.def (reassociation_width): New hook.\n+\n+\t* doc/tm.texi.in (reassociation_width): Likewise.\n+\n+\t* doc/tm.texi (reassociation_width): Likewise.\n+\n+\t* doc/invoke.texi (tree-reassoc-width): New param documented.\n+\n+\t* hooks.h (hook_int_uint_mode_1): New default hook.\n+\n+\t* hooks.c (hook_int_uint_mode_1): Likewise.\n+\n+\t* config/i386/i386.h (ix86_tune_indices): Add\n+\tX86_TUNE_REASSOC_INT_TO_PARALLEL and\n+\tX86_TUNE_REASSOC_FP_TO_PARALLEL.\n+\n+\t(TARGET_REASSOC_INT_TO_PARALLEL): New.\n+\t(TARGET_REASSOC_FP_TO_PARALLEL): Likewise.\n+\n+\t* config/i386/i386.c (initial_ix86_tune_features): Add\n+\tX86_TUNE_REASSOC_INT_TO_PARALLEL and\n+\tX86_TUNE_REASSOC_FP_TO_PARALLEL.\n+\n+\t(ix86_reassociation_width) implementation of\n+\tnew hook for i386 target.\n+\n+\t* params.def (PARAM_TREE_REASSOC_WIDTH): New param added.\n+\n+\t* tree-ssa-reassoc.c (get_required_cycles): New function.\n+\t(get_reassociation_width): Likewise.\n+\t(swap_ops_for_binary_stmt): Likewise.\n+\t(rewrite_expr_tree_parallel): Likewise.\n+\n+\t(rewrite_expr_tree): Refactored. Part of code moved into\n+\tswap_ops_for_binary_stmt.\n+\n+\t(reassociate_bb): Now checks reassociation width to be used\n+\tand call rewrite_expr_tree_parallel instead of rewrite_expr_tree\n+\tif needed.\n+\n 2011-09-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/47025"}, {"sha": "555db593cdb27d41e1fa67322da41a6471e3d117", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -2168,7 +2168,15 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n \n   /* X86_TUNE_AVX128_OPTIMAL: Enable 128-bit AVX instruction generation for\n      the auto-vectorizer.  */\n-  m_BDVER\n+  m_BDVER,\n+\n+  /* X86_TUNE_REASSOC_INT_TO_PARALLEL: Try to produce parallel computations\n+     during reassociation of integer computation.  */\n+  m_ATOM,\n+\n+  /* X86_TUNE_REASSOC_FP_TO_PARALLEL: Try to produce parallel computations\n+     during reassociation of fp computation.  */\n+  m_ATOM\n };\n \n /* Feature tests against the various architecture variations.  */\n@@ -34843,6 +34851,8 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #define TARGET_SCHED_DISPATCH has_dispatch\n #undef TARGET_SCHED_DISPATCH_DO\n #define TARGET_SCHED_DISPATCH_DO do_dispatch\n+#undef TARGET_SCHED_REASSOCIATION_WIDTH\n+#define TARGET_SCHED_REASSOCIATION_WIDTH ix86_reassociation_width\n \n /* The size of the dispatch window is the total number of bytes of\n    object code allowed in a window.  */\n@@ -35640,6 +35650,32 @@ has_dispatch (rtx insn, int action)\n   return false;\n }\n \n+/* Implementation of reassociation_width target hook used by\n+   reassoc phase to identify parallelism level in reassociated\n+   tree.  Statements tree_code is passed in OPC.  Arguments type\n+   is passed in MODE.\n+\n+   Currently parallel reassociation is enabled for Atom\n+   processors only and we set reassociation width to be 2\n+   because Atom may issue up to 2 instructions per cycle.\n+\n+   Return value should be fixed if parallel reassociation is\n+   enabled for other processors.  */\n+\n+static int\n+ix86_reassociation_width (unsigned int opc ATTRIBUTE_UNUSED,\n+\t\t\t  enum machine_mode mode)\n+{\n+  int res = 1;\n+\n+  if (INTEGRAL_MODE_P (mode) && TARGET_REASSOC_INT_TO_PARALLEL)\n+    res = 2;\n+  else if (FLOAT_MODE_P (mode) && TARGET_REASSOC_FP_TO_PARALLEL)\n+    res = 2;\n+\n+  return res;\n+}\n+\n /* ??? No autovectorization into MMX or 3DNOW until we can reliably\n    place emms and femms instructions.  */\n "}, {"sha": "21f507552118b1f275a39bb3bf2c385d14a878df", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -318,6 +318,8 @@ enum ix86_tune_indices {\n   X86_TUNE_VECTORIZE_DOUBLE,\n   X86_TUNE_SOFTWARE_PREFETCHING_BENEFICIAL,\n   X86_TUNE_AVX128_OPTIMAL,\n+  X86_TUNE_REASSOC_INT_TO_PARALLEL,\n+  X86_TUNE_REASSOC_FP_TO_PARALLEL,\n \n   X86_TUNE_LAST\n };\n@@ -416,6 +418,11 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n \tix86_tune_features[X86_TUNE_SOFTWARE_PREFETCHING_BENEFICIAL]\n #define TARGET_AVX128_OPTIMAL \\\n \tix86_tune_features[X86_TUNE_AVX128_OPTIMAL]\n+#define TARGET_REASSOC_INT_TO_PARALLEL \\\n+\tix86_tune_features[X86_TUNE_REASSOC_INT_TO_PARALLEL]\n+#define TARGET_REASSOC_FP_TO_PARALLEL \\\n+\tix86_tune_features[X86_TUNE_REASSOC_FP_TO_PARALLEL]\n+\n /* Feature tests against the various architecture variations.  */\n enum ix86_arch_indices {\n   X86_ARCH_CMOVE,\t\t/* || TARGET_SSE */"}, {"sha": "b1ff187ef482f0302a98276fc8f245ba9c74f6d0", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -9076,6 +9076,11 @@ The smallest number of different values for which it is best to use a\n jump-table instead of a tree of conditional branches.  If the value is\n 0, use the default for the machine.  The default is 0.\n \n+@item tree-reassoc-width\n+Set the maximum number of instructions executed in parallel in\n+reassociated tree. This parameter overrides target dependent\n+heuristics used by default if has non zero value.\n+\n @end table\n @end table\n "}, {"sha": "335c1d1f51d94dcad45481387d4c28dc89f9d87c", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -6840,6 +6840,11 @@ the order of instructions is important for correctness when scheduling, but\n also the latencies of operations.\n @end deftypevr\n \n+@deftypefn {Target Hook} int TARGET_SCHED_REASSOCIATION_WIDTH (unsigned int @var{opc}, enum machine_mode @var{mode})\n+This hook is called by tree reassociator to determine a level of\n+parallelism required in output calculations chain.\n+@end deftypefn\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "67838269dff82bd75e5930bbacbe89fea229fb7d", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -6774,6 +6774,8 @@ in its second parameter.\n \n @hook TARGET_SCHED_EXPOSED_PIPELINE\n \n+@hook TARGET_SCHED_REASSOCIATION_WIDTH\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "1ba44f9c7bb40eed86663485b4665dc30aa8bf43", "filename": "gcc/hooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -160,6 +160,13 @@ default_can_output_mi_thunk_no_vcall (const_tree a ATTRIBUTE_UNUSED,\n   return c == 0;\n }\n \n+int\n+hook_int_uint_mode_1 (unsigned int a ATTRIBUTE_UNUSED,\n+\t\t      enum machine_mode b ATTRIBUTE_UNUSED)\n+{\n+  return 1;\n+}\n+\n int\n hook_int_const_tree_0 (const_tree a ATTRIBUTE_UNUSED)\n {"}, {"sha": "54ace243f76a5923395df9a24ce9ecdaf1e094e6", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -68,6 +68,7 @@ extern void hook_void_tree_treeptr (tree, tree *);\n extern void hook_void_int_int (int, int);\n extern void hook_void_gcc_optionsp (struct gcc_options *);\n \n+extern int hook_int_uint_mode_1 (unsigned int, enum machine_mode);\n extern int hook_int_const_tree_0 (const_tree);\n extern int hook_int_const_tree_const_tree_1 (const_tree, const_tree);\n extern int hook_int_rtx_0 (rtx);"}, {"sha": "c376c80ebfbaa4e3dd6ab27365edd0854ea9a83d", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -914,6 +914,13 @@ DEFPARAM (PARAM_ALLOW_STORE_DATA_RACES,\n \t  \"Allow new data races on stores to be introduced\",\n \t  1, 0, 1)\n \n+/* Reassociation width to be used by tree reassoc optimization.  */\n+DEFPARAM (PARAM_TREE_REASSOC_WIDTH,\n+\t  \"tree-reassoc-width\",\n+\t  \"Set the maximum number of instructions executed in parallel in \"\n+\t  \"reassociated tree. If 0, use the target dependent heuristic.\",\n+\t  0, 0, 0)\n+\n \n /*\n Local variables:"}, {"sha": "1e09ba7bfade17070a267185a4443d6d06475f92", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -913,6 +913,16 @@ the order of instructions is important for correctness when scheduling, but\\n\\\n also the latencies of operations.\",\n bool, false)\n \n+/* The following member value is a function that returns number\n+   of operations reassociator should try to put in parallel for\n+   statements of the given type.  By default 1 is used.  */\n+DEFHOOK\n+(reassociation_width,\n+\"This hook is called by tree reassociator to determine a level of\\n\\\n+parallelism required in output calculations chain.\",\n+int, (unsigned int opc, enum machine_mode mode),\n+hook_int_uint_mode_1)\n+\n HOOK_VECTOR_END (sched)\n \n /* Functions relating to vectorization.  */"}, {"sha": "db1c7fda19e11cfdd799645e4a1256762547e772", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -1,3 +1,11 @@\n+2011-09-06  Enkovich Ilya  <ilya.enkovich@intel.com>\n+\n+\t* gcc.dg/tree-ssa/pr38533.c (dg-options): Added option\n+\t--param tree-reassoc-width=1.\n+\n+\t* gcc.dg/tree-ssa/reassoc-24.c: New test.\n+\t* gcc.dg/tree-ssa/reassoc-25.c: Likewise.\n+\n 2011-09-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/48149"}, {"sha": "a80a5a81390148e9c0673cdfa8da47101e5d4f2b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr38533.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr38533.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr38533.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr38533.c?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -1,6 +1,6 @@\n /* PR middle-end/38533 */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n+/* { dg-options \"-O2 --param tree-reassoc-width=1 -fdump-tree-reassoc1\" } */\n \n #define A asm volatile (\"\" : \"=r\" (f) : \"0\" (0)); e |= f;\n #define B A A A A A A A A A A A"}, {"sha": "c871628abc6f3cb5f319a2e48e9b125e301e3ad1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-24.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-24.c?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 --param tree-reassoc-width=2 -fdump-tree-reassoc1\" } */\n+\n+unsigned int\n+foo (void)\n+{\n+  unsigned int a = 0;\n+  unsigned int b;\n+\n+  asm volatile (\"\" : \"=r\" (b) : \"0\" (0));\n+  a += b;\n+  asm volatile (\"\" : \"=r\" (b) : \"0\" (0));\n+  a += b;\n+  asm volatile (\"\" : \"=r\" (b) : \"0\" (0));\n+  a += b;\n+  asm volatile (\"\" : \"=r\" (b) : \"0\" (0));\n+  a += b;\n+\n+  return a;\n+}\n+\n+/* Verify there are two pairs of __asm__ statements with no\n+   intervening stmts.  */\n+/* { dg-final { scan-tree-dump-times \"__asm__\\[^;\\n]*;\\n *__asm__\" 2 \"reassoc1\"} } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "4ff66ef8d05cdc5a014656189cf35b2baa2caa27", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-25.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-25.c?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 --param tree-reassoc-width=3 -fdump-tree-reassoc1-details\" } */\n+\n+unsigned int\n+foo (int a, int b, int c, int d)\n+{\n+  unsigned int s = 0;\n+\n+  s += a;\n+  s += b;\n+  s += c;\n+  s += d;\n+\n+  return s;\n+}\n+\n+/* Verify reassociation width was chosen to be 2.  */\n+/* { dg-final { scan-tree-dump-times \"Width = 2\" 1 \"reassoc1\"} } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "03e067242663bf67a07f5838e238bbf773e3049d", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 248, "deletions": 47, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7b0cc4aae0620d830b8e9f8ed8a586e68f470b/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=df7b0cc4aae0620d830b8e9f8ed8a586e68f470b", "patch": "@@ -40,6 +40,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pointer-set.h\"\n #include \"cfgloop.h\"\n #include \"flags.h\"\n+#include \"target.h\"\n+#include \"params.h\"\n \n /*  This is a simple global reassociation pass.  It is, in part, based\n     on the LLVM pass of the same name (They do some things more/less\n@@ -1617,6 +1619,62 @@ remove_visited_stmt_chain (tree var)\n     }\n }\n \n+/* This function checks three consequtive operands in\n+   passed operands vector OPS starting from OPINDEX and\n+   swaps two operands if it is profitable for binary operation\n+   consuming OPINDEX + 1 abnd OPINDEX + 2 operands.\n+\n+   We pair ops with the same rank if possible.\n+\n+   The alternative we try is to see if STMT is a destructive\n+   update style statement, which is like:\n+   b = phi (a, ...)\n+   a = c + b;\n+   In that case, we want to use the destructive update form to\n+   expose the possible vectorizer sum reduction opportunity.\n+   In that case, the third operand will be the phi node. This\n+   check is not performed if STMT is null.\n+\n+   We could, of course, try to be better as noted above, and do a\n+   lot of work to try to find these opportunities in >3 operand\n+   cases, but it is unlikely to be worth it.  */\n+\n+static void\n+swap_ops_for_binary_stmt (VEC(operand_entry_t, heap) * ops,\n+\t\t\t  unsigned int opindex, gimple stmt)\n+{\n+  operand_entry_t oe1, oe2, oe3;\n+\n+  oe1 = VEC_index (operand_entry_t, ops, opindex);\n+  oe2 = VEC_index (operand_entry_t, ops, opindex + 1);\n+  oe3 = VEC_index (operand_entry_t, ops, opindex + 2);\n+\n+  if ((oe1->rank == oe2->rank\n+       && oe2->rank != oe3->rank)\n+      || (stmt && is_phi_for_stmt (stmt, oe3->op)\n+\t  && !is_phi_for_stmt (stmt, oe1->op)\n+\t  && !is_phi_for_stmt (stmt, oe2->op)))\n+    {\n+      struct operand_entry temp = *oe3;\n+      oe3->op = oe1->op;\n+      oe3->rank = oe1->rank;\n+      oe1->op = temp.op;\n+      oe1->rank= temp.rank;\n+    }\n+  else if ((oe1->rank == oe3->rank\n+\t    && oe2->rank != oe3->rank)\n+\t   || (stmt && is_phi_for_stmt (stmt, oe2->op)\n+\t       && !is_phi_for_stmt (stmt, oe1->op)\n+\t       && !is_phi_for_stmt (stmt, oe3->op)))\n+    {\n+      struct operand_entry temp = *oe2;\n+      oe2->op = oe1->op;\n+      oe2->rank = oe1->rank;\n+      oe1->op = temp.op;\n+      oe1->rank= temp.rank;\n+    }\n+}\n+\n /* Recursively rewrite our linearized statements so that the operators\n    match those in OPS[OPINDEX], putting the computation in rank\n    order.  */\n@@ -1629,53 +1687,10 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n   tree rhs2 = gimple_assign_rhs2 (stmt);\n   operand_entry_t oe;\n \n-  /* If we have three operands left, then we want to make sure the one\n-     that gets the double binary op are the ones with the same rank.\n-\n-     The alternative we try is to see if this is a destructive\n-     update style statement, which is like:\n-     b = phi (a, ...)\n-     a = c + b;\n-     In that case, we want to use the destructive update form to\n-     expose the possible vectorizer sum reduction opportunity.\n-     In that case, the third operand will be the phi node.\n-\n-     We could, of course, try to be better as noted above, and do a\n-     lot of work to try to find these opportunities in >3 operand\n-     cases, but it is unlikely to be worth it.  */\n+  /* If we have three operands left, then we want to make sure the ones\n+     that get the double binary op are chosen wisely.  */\n   if (opindex + 3 == VEC_length (operand_entry_t, ops))\n-    {\n-      operand_entry_t oe1, oe2, oe3;\n-\n-      oe1 = VEC_index (operand_entry_t, ops, opindex);\n-      oe2 = VEC_index (operand_entry_t, ops, opindex + 1);\n-      oe3 = VEC_index (operand_entry_t, ops, opindex + 2);\n-\n-      if ((oe1->rank == oe2->rank\n-\t   && oe2->rank != oe3->rank)\n-\t  || (is_phi_for_stmt (stmt, oe3->op)\n-\t      && !is_phi_for_stmt (stmt, oe1->op)\n-\t      && !is_phi_for_stmt (stmt, oe2->op)))\n-\t{\n-\t  struct operand_entry temp = *oe3;\n-\t  oe3->op = oe1->op;\n-\t  oe3->rank = oe1->rank;\n-\t  oe1->op = temp.op;\n-\t  oe1->rank= temp.rank;\n-\t}\n-      else if ((oe1->rank == oe3->rank\n-\t\t&& oe2->rank != oe3->rank)\n-\t       || (is_phi_for_stmt (stmt, oe2->op)\n-\t\t   && !is_phi_for_stmt (stmt, oe1->op)\n-\t\t   && !is_phi_for_stmt (stmt, oe3->op)))\n-\t{\n-\t  struct operand_entry temp = *oe2;\n-\t  oe2->op = oe1->op;\n-\t  oe2->rank = oe1->rank;\n-\t  oe1->op = temp.op;\n-\t  oe1->rank= temp.rank;\n-\t}\n-    }\n+    swap_ops_for_binary_stmt (ops, opindex, stmt);\n \n   /* The final recursion case for this function is that you have\n      exactly two operations left.\n@@ -1760,6 +1775,178 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n   rewrite_expr_tree (SSA_NAME_DEF_STMT (rhs1), opindex + 1, ops, moved);\n }\n \n+/* Find out how many cycles we need to compute statements chain.\n+   OPS_NUM holds number os statements in a chain.  CPU_WIDTH is a\n+   maximum number of independent statements we may execute per cycle.  */\n+\n+static int\n+get_required_cycles (int ops_num, int cpu_width)\n+{\n+  int res;\n+  int elog;\n+  unsigned int rest;\n+\n+  /* While we have more than 2 * cpu_width operands\n+     we may reduce number of operands by cpu_width\n+     per cycle.  */\n+  res = ops_num / (2 * cpu_width);\n+\n+  /* Remained operands count may be reduced twice per cycle\n+     until we have only one operand.  */\n+  rest = (unsigned)(ops_num - res * cpu_width);\n+  elog = exact_log2 (rest);\n+  if (elog >= 0)\n+    res += elog;\n+  else\n+    res += floor_log2 (rest) + 1;\n+\n+  return res;\n+}\n+\n+/* Returns an optimal number of registers to use for computation of\n+   given statements.  */\n+\n+static int\n+get_reassociation_width (int ops_num, enum tree_code opc,\n+\t\t\t enum machine_mode mode)\n+{\n+  int param_width = PARAM_VALUE (PARAM_TREE_REASSOC_WIDTH);\n+  int width;\n+  int width_min;\n+  int cycles_best;\n+\n+  if (param_width > 0)\n+    width = param_width;\n+  else\n+    width = targetm.sched.reassociation_width (opc, mode);\n+\n+  if (width == 1)\n+    return width;\n+\n+  /* Get the minimal time required for sequence computation.  */\n+  cycles_best = get_required_cycles (ops_num, width);\n+\n+  /* Check if we may use less width and still compute sequence for\n+     the same time.  It will allow us to reduce registers usage.\n+     get_required_cycles is monotonically increasing with lower width\n+     so we can perform a binary search for the minimal width that still\n+     results in the optimal cycle count.  */\n+  width_min = 1;\n+  while (width > width_min)\n+    {\n+      int width_mid = (width + width_min) / 2;\n+\n+      if (get_required_cycles (ops_num, width_mid) == cycles_best)\n+\twidth = width_mid;\n+      else if (width_min < width_mid)\n+\twidth_min = width_mid;\n+      else\n+\tbreak;\n+    }\n+\n+  return width;\n+}\n+\n+/* Recursively rewrite our linearized statements so that the operators\n+   match those in OPS[OPINDEX], putting the computation in rank\n+   order and trying to allow operations to be executed in\n+   parallel.  */\n+\n+static void\n+rewrite_expr_tree_parallel (gimple stmt, int width,\n+\t\t\t    VEC(operand_entry_t, heap) * ops)\n+{\n+  enum tree_code opcode = gimple_assign_rhs_code (stmt);\n+  int op_num = VEC_length (operand_entry_t, ops);\n+  int stmt_num = op_num - 1;\n+  gimple *stmts = XALLOCAVEC (gimple, stmt_num);\n+  int op_index = op_num - 1;\n+  int stmt_index = 0;\n+  int ready_stmts_end = 0;\n+  int i = 0;\n+  tree last_rhs1 = gimple_assign_rhs1 (stmt);\n+  tree lhs_var;\n+\n+  /* We start expression rewriting from the top statements.\n+     So, in this loop we create a full list of statements\n+     we will work with.  */\n+  stmts[stmt_num - 1] = stmt;\n+  for (i = stmt_num - 2; i >= 0; i--)\n+    stmts[i] = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmts[i+1]));\n+\n+  lhs_var = create_tmp_reg (TREE_TYPE (last_rhs1), NULL);\n+  add_referenced_var (lhs_var);\n+\n+  for (i = 0; i < stmt_num; i++)\n+    {\n+      tree op1, op2;\n+\n+      /* Determine whether we should use results of\n+\t already handled statements or not.  */\n+      if (ready_stmts_end == 0\n+\t  && (i - stmt_index >= width || op_index < 1))\n+\tready_stmts_end = i;\n+\n+      /* Now we choose operands for the next statement.  Non zero\n+\t value in ready_stmts_end means here that we should use\n+\t the result of already generated statements as new operand.  */\n+      if (ready_stmts_end > 0)\n+\t{\n+\t  op1 = gimple_assign_lhs (stmts[stmt_index++]);\n+\t  if (ready_stmts_end > stmt_index)\n+\t    op2 = gimple_assign_lhs (stmts[stmt_index++]);\n+\t  else if (op_index >= 0)\n+\t    op2 = VEC_index (operand_entry_t, ops, op_index--)->op;\n+\t  else\n+\t    {\n+\t      gcc_assert (stmt_index < i);\n+\t      op2 = gimple_assign_lhs (stmts[stmt_index++]);\n+\t    }\n+\n+\t  if (stmt_index >= ready_stmts_end)\n+\t    ready_stmts_end = 0;\n+\t}\n+      else\n+\t{\n+\t  if (op_index > 1)\n+\t    swap_ops_for_binary_stmt (ops, op_index - 2, NULL);\n+\t  op2 = VEC_index (operand_entry_t, ops, op_index--)->op;\n+\t  op1 = VEC_index (operand_entry_t, ops, op_index--)->op;\n+\t}\n+\n+      /* If we emit the last statement then we should put\n+\t operands into the last statement.  It will also\n+\t break the loop.  */\n+      if (op_index < 0 && stmt_index == i)\n+\ti = stmt_num - 1;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Transforming \");\n+\t  print_gimple_stmt (dump_file, stmts[i], 0, 0);\n+\t}\n+\n+      /* We keep original statement only for the last one.  All\n+\t others are recreated.  */\n+      if (i == stmt_num - 1)\n+\t{\n+\t  gimple_assign_set_rhs1 (stmts[i], op1);\n+\t  gimple_assign_set_rhs2 (stmts[i], op2);\n+\t  update_stmt (stmts[i]);\n+\t}\n+      else\n+\tstmts[i] = build_and_add_sum (lhs_var, op1, op2, opcode);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \" into \");\n+\t  print_gimple_stmt (dump_file, stmts[i], 0, 0);\n+\t}\n+    }\n+\n+  remove_visited_stmt_chain (last_rhs1);\n+}\n+\n /* Transform STMT, which is really (A +B) + (C + D) into the left\n    linear form, ((A+B)+C)+D.\n    Recurse on D if necessary.  */\n@@ -2282,7 +2469,21 @@ reassociate_bb (basic_block bb)\n \t\t    }\n \t\t}\n \t      else\n-\t\trewrite_expr_tree (stmt, 0, ops, false);\n+\t\t{\n+\t\t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+\t\t  int ops_num = VEC_length (operand_entry_t, ops);\n+\t\t  int width = get_reassociation_width (ops_num, rhs_code, mode);\n+\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"Width = %d was chosen for reassociation\\n\", width);\n+\n+\t\t  if (width > 1\n+\t\t      && VEC_length (operand_entry_t, ops) > 3)\n+\t\t    rewrite_expr_tree_parallel (stmt, width, ops);\n+\t\t  else\n+\t\t    rewrite_expr_tree (stmt, 0, ops, false);\n+\t\t}\n \n \t      VEC_free (operand_entry_t, heap, ops);\n \t    }"}]}