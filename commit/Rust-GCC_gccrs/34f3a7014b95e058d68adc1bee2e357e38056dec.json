{"sha": "34f3a7014b95e058d68adc1bee2e357e38056dec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRmM2E3MDE0Yjk1ZTA1OGQ2OGFkYzFiZWUyZTM1N2UzODA1NmRlYw==", "commit": {"author": {"name": "Vincent Pucci", "email": "pucci@adacore.com", "date": "2012-06-14T10:43:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-06-14T10:43:53Z"}, "message": "einfo.adb einfo.ads (Get_Rep_Item): Removed.\n\n2012-06-14  Vincent Pucci  <pucci@adacore.com>\n\n\t* einfo.adb einfo.ads (Get_Rep_Item): Removed.\n\t(Get_Rep_Item_For_Entity): Removed.\n\t(Get_Rep_Pragma): Removed.\n\t(Get_Rep_Pragma_For_Entity): Removed.\n\t(Has_Rep_Item): Removed.\n\t(Has_Rep_Pragma): Removed.\n\t(Has_Rep_Pragma_For_Entity): Removed.\n\t* exp_ch9.adb (Expand_N_Task_Type_Declaration):\n\tHas_Rep_Pragma_For_Entity replaced by Has_Rep_Pragma\n\tand Get_Rep_Pragma_For_Entity replaced by Get_Rep_Pragma.\n\t(Make_Task_Create_Call): Has_Rep_Pragma_For_Entity replaced\n\tby Has_Rep_Pragma and Get_Rep_Pragma_For_Entity replaced by\n\tGet_Rep_Pragma.\n\t* exp_intr.adb: Dependency to Sem_Aux added for call to Get_Rep_Pragma.\n\t* sem_aux.adb (Get_Rep_Item): New routine.\n\t(Get_Rep_Pragma): New routine.\n\t(Has_Rep_Item): New routine.\n\t(Has_Rep_Pragma): New routine.\n\t(Nearest_Ancestor): Minor reformatting.\n\t* sem_aux.ads (Get_Rep_Item): New routine.\n\t(Get_Rep_Pragma): New routine.\n\t(Has_Rep_Item): New routine.\n\t(Has_Rep_Pragma): New routine.\n\t* sem_ch13.adb (Duplicate_Clause): Restore original error messages.\n\t* sem_eval.adb (Subtypes_Statically_Match): Get_Rep_Item_For_Entity\n\treplaced by Get_Rep_Item.\n\t* sem_prag.adb (Analyze_Pragma): Restore original error messages.\n\t(Check_Duplicate_Pragma): Restore original error messages.\n\nFrom-SVN: r188607", "tree": {"sha": "70d45c982e7dd024eb7d80959751e61224d87d28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70d45c982e7dd024eb7d80959751e61224d87d28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34f3a7014b95e058d68adc1bee2e357e38056dec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f3a7014b95e058d68adc1bee2e357e38056dec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34f3a7014b95e058d68adc1bee2e357e38056dec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f3a7014b95e058d68adc1bee2e357e38056dec/comments", "author": null, "committer": null, "parents": [{"sha": "3cebd1c0afe8c8b1e7120a0d2a5d0ed51a40cec9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cebd1c0afe8c8b1e7120a0d2a5d0ed51a40cec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cebd1c0afe8c8b1e7120a0d2a5d0ed51a40cec9"}], "stats": {"total": 543, "additions": 269, "deletions": 274}, "files": [{"sha": "4fa567771cbece9f59a0cd224ab114f7dbf285c3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=34f3a7014b95e058d68adc1bee2e357e38056dec", "patch": "@@ -1,3 +1,34 @@\n+2012-06-14  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* einfo.adb einfo.ads (Get_Rep_Item): Removed.\n+\t(Get_Rep_Item_For_Entity): Removed.\n+\t(Get_Rep_Pragma): Removed.\n+\t(Get_Rep_Pragma_For_Entity): Removed.\n+\t(Has_Rep_Item): Removed.\n+\t(Has_Rep_Pragma): Removed.\n+\t(Has_Rep_Pragma_For_Entity): Removed.\n+\t* exp_ch9.adb (Expand_N_Task_Type_Declaration):\n+\tHas_Rep_Pragma_For_Entity replaced by Has_Rep_Pragma\n+\tand Get_Rep_Pragma_For_Entity replaced by Get_Rep_Pragma.\n+\t(Make_Task_Create_Call): Has_Rep_Pragma_For_Entity replaced\n+\tby Has_Rep_Pragma and Get_Rep_Pragma_For_Entity replaced by\n+\tGet_Rep_Pragma.\n+\t* exp_intr.adb: Dependency to Sem_Aux added for call to Get_Rep_Pragma.\n+\t* sem_aux.adb (Get_Rep_Item): New routine.\n+\t(Get_Rep_Pragma): New routine.\n+\t(Has_Rep_Item): New routine.\n+\t(Has_Rep_Pragma): New routine.\n+\t(Nearest_Ancestor): Minor reformatting.\n+\t* sem_aux.ads (Get_Rep_Item): New routine.\n+\t(Get_Rep_Pragma): New routine.\n+\t(Has_Rep_Item): New routine.\n+\t(Has_Rep_Pragma): New routine.\n+\t* sem_ch13.adb (Duplicate_Clause): Restore original error messages.\n+\t* sem_eval.adb (Subtypes_Statically_Match): Get_Rep_Item_For_Entity\n+\treplaced by Get_Rep_Item.\n+\t* sem_prag.adb (Analyze_Pragma): Restore original error messages.\n+\t(Check_Duplicate_Pragma): Restore original error messages.\n+\n 2012-06-14  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_util.adb (Is_Object_Reference): in Ada 2012, qualified"}, {"sha": "d5fad3ecf548c4dd45dcf992f77231e63052484a", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 6, "deletions": 178, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=34f3a7014b95e058d68adc1bee2e357e38056dec", "patch": "@@ -32,12 +32,12 @@\n pragma Style_Checks (All_Checks);\n --  Turn off subprogram ordering, not used for this unit\n \n-with Atree;    use Atree;\n-with Nlists;   use Nlists;\n-with Output;   use Output;\n-with Sem_Aux;  use Sem_Aux;   -- wrong dependency ???\n-with Sinfo;    use Sinfo;\n-with Stand;    use Stand;\n+with Atree;  use Atree;\n+with Namet;  use Namet;\n+with Nlists; use Nlists;\n+with Output; use Output;\n+with Sinfo;  use Sinfo;\n+with Stand;  use Stand;\n \n package body Einfo is\n \n@@ -5979,41 +5979,6 @@ package body Einfo is\n       return Empty;\n    end Get_Attribute_Definition_Clause;\n \n-   ------------------\n-   -- Get_Rep_Item --\n-   ------------------\n-\n-   function Get_Rep_Item\n-     (E   : Entity_Id;\n-      Nam : Name_Id) return Node_Id\n-   is\n-      N     : Node_Id;\n-      N_Nam : Name_Id := No_Name;\n-\n-   begin\n-      N := First_Rep_Item (E);\n-      while Present (N) loop\n-         if Nkind (N) = N_Pragma then\n-            N_Nam := Pragma_Name (N);\n-         elsif Nkind (N) = N_Attribute_Definition_Clause then\n-            N_Nam := Chars (N);\n-         elsif Nkind (N) = N_Aspect_Specification then\n-            N_Nam := Chars (Identifier (N));\n-         end if;\n-\n-         if N_Nam = Nam\n-           or else (Nam = Name_Priority\n-                     and then N_Nam = Name_Interrupt_Priority)\n-         then\n-            return N;\n-         end if;\n-\n-         Next_Rep_Item (N);\n-      end loop;\n-\n-      return Empty;\n-   end Get_Rep_Item;\n-\n    -------------------\n    -- Get_Full_View --\n    -------------------\n@@ -6054,114 +6019,6 @@ package body Einfo is\n       return Empty;\n    end Get_Record_Representation_Clause;\n \n-   -----------------------------\n-   -- Get_Rep_Item_For_Entity --\n-   -----------------------------\n-\n-   function Get_Rep_Item_For_Entity\n-     (E   : Entity_Id;\n-      Nam : Name_Id) return Node_Id\n-   is\n-      Par : constant Entity_Id := Nearest_Ancestor (E);\n-      --  In case of a derived type or subtype, this node represents the parent\n-      --  type of type E.\n-\n-      N   : Node_Id;\n-\n-   begin\n-      N := First_Rep_Item (E);\n-      while Present (N) loop\n-         if Nkind (N) = N_Pragma\n-           and then\n-             (Pragma_Name (N) = Nam\n-               or else (Nam = Name_Priority\n-                         and then Pragma_Name (N) = Name_Interrupt_Priority))\n-         then\n-            --  Return N if the pragma doesn't appear in the Rep_Item chain of\n-            --  the parent.\n-\n-            if No (Par) then\n-               return N;\n-\n-            elsif not Present_In_Rep_Item (Par, N) then\n-               return N;\n-            end if;\n-\n-         elsif Nkind (N) = N_Attribute_Definition_Clause\n-           and then Entity (N) = E\n-           and then\n-             (Chars (N) = Nam\n-                or else (Nam = Name_Priority\n-                          and then Chars (N) = Name_Interrupt_Priority))\n-         then\n-            return N;\n-\n-         elsif Nkind (N) = N_Aspect_Specification\n-           and then Entity (N) = E\n-           and then\n-             (Chars (Identifier (N)) = Nam\n-                or else (Nam = Name_Priority\n-                          and then Chars (Identifier (N)) =\n-                                     Name_Interrupt_Priority))\n-         then\n-            return N;\n-         end if;\n-\n-         Next_Rep_Item (N);\n-      end loop;\n-\n-      return Empty;\n-   end Get_Rep_Item_For_Entity;\n-\n-   --------------------\n-   -- Get_Rep_Pragma --\n-   --------------------\n-\n-   function Get_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Node_Id is\n-      N : Node_Id;\n-\n-   begin\n-      N := First_Rep_Item (E);\n-      while Present (N) loop\n-         if Nkind (N) = N_Pragma\n-           and then\n-             (Pragma_Name (N) = Nam\n-               or else (Nam = Name_Interrupt_Priority\n-                         and then Pragma_Name (N) = Name_Priority))\n-         then\n-            return N;\n-         end if;\n-\n-         Next_Rep_Item (N);\n-      end loop;\n-\n-      return Empty;\n-   end Get_Rep_Pragma;\n-\n-   -------------------------------\n-   -- Get_Rep_Pragma_For_Entity --\n-   -------------------------------\n-\n-   function Get_Rep_Pragma_For_Entity\n-     (E : Entity_Id; Nam : Name_Id) return Node_Id\n-   is\n-      Par : constant Entity_Id := Nearest_Ancestor (E);\n-      --  In case of a derived type or subtype, this node represents the parent\n-      --  type of type E.\n-\n-      Prag : constant Node_Id := Get_Rep_Pragma (E, Nam);\n-\n-   begin\n-      if No (Par) then\n-         return Prag;\n-\n-      elsif not Present_In_Rep_Item (Par, Prag) then\n-         return Prag;\n-      end if;\n-\n-      return Empty;\n-   end Get_Rep_Pragma_For_Entity;\n-\n    ------------------------\n    -- Has_Attach_Handler --\n    ------------------------\n@@ -6247,35 +6104,6 @@ package body Einfo is\n       return False;\n    end Has_Interrupt_Handler;\n \n-   ------------------\n-   -- Has_Rep_Item --\n-   ------------------\n-\n-   function Has_Rep_Item (E : Entity_Id; Nam : Name_Id) return Boolean is\n-   begin\n-      return Present (Get_Rep_Item (E, Nam));\n-   end Has_Rep_Item;\n-\n-   --------------------\n-   -- Has_Rep_Pragma --\n-   --------------------\n-\n-   function Has_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Boolean is\n-   begin\n-      return Present (Get_Rep_Pragma (E, Nam));\n-   end Has_Rep_Pragma;\n-\n-   -------------------------------\n-   -- Has_Rep_Pragma_For_Entity --\n-   -------------------------------\n-\n-   function Has_Rep_Pragma_For_Entity\n-     (E : Entity_Id; Nam : Name_Id) return Boolean\n-   is\n-   begin\n-      return Present (Get_Rep_Pragma_For_Entity (E, Nam));\n-   end Has_Rep_Pragma_For_Entity;\n-\n    --------------------\n    -- Has_Unmodified --\n    --------------------"}, {"sha": "0f8250ac7ab5bb097d9e3c66cf8a95aab8f863b0", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=34f3a7014b95e058d68adc1bee2e357e38056dec", "patch": "@@ -29,7 +29,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Namet;  use Namet;\n with Snames; use Snames;\n with Types;  use Types;\n with Uintp;  use Uintp;\n@@ -7189,67 +7188,11 @@ package Einfo is\n    --  value returned is the N_Attribute_Definition_Clause node, otherwise\n    --  Empty is returned.\n \n-   --  What is difference between following two, and why are they named\n-   --  the way they are ???\n-\n-   function Get_Rep_Item\n-     (E   : Entity_Id;\n-      Nam : Name_Id) return Node_Id;\n-   --  Searches the Rep_Item chain for a given entity E, for the first\n-   --  occurrence of a rep item (pragma, attribute definition clause, or aspect\n-   --  specification) whose name matches the given name. If one is found, it is\n-   --  returned, otherwise Empty is returned. A special case is that when Nam\n-   --  is Name_Priority, the call will also find Interrupt_Priority.\n-\n-   function Get_Rep_Item_For_Entity\n-     (E   : Entity_Id;\n-      Nam : Name_Id) return Node_Id;\n-   --  Searches the Rep_Item chain for a given entity E, for an instance of a\n-   --  rep item (pragma, attribute definition clause, or aspect specification)\n-   --  whose name matches the given name. If one is found, it is returned,\n-   --  otherwise Empty is returned. This routine only returns items whose\n-   --  entity matches E (it does not return items from the parent chain). A\n-   --  special case is that when Nam is Name_Priority, the call will also find\n-   --  Interrupt_Priority.\n-\n    function Get_Record_Representation_Clause (E : Entity_Id) return Node_Id;\n    --  Searches the Rep_Item chain for a given entity E, for a record\n    --  representation clause, and if found, returns it. Returns Empty\n    --  if no such clause is found.\n \n-   --  I still don't get it, if the first one returns stuff from the parent\n-   --  it should say so, and it doesn't, and the names make no sense ???\n-\n-   function Get_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Node_Id;\n-   --  Searches the Rep_Item chain for the given entity E, for an instance\n-   --  a representation pragma with the given name Nam. If found then the\n-   --  value returned is the N_Pragma node, otherwise Empty is returned. A\n-   --  special case is that when Nam is Name_Priority, the call will also find\n-   --  Interrupt_Priority.\n-\n-   function Get_Rep_Pragma_For_Entity\n-     (E : Entity_Id; Nam : Name_Id) return Node_Id;\n-   --  Same as Get_Rep_Pragma except that this routine returns a pragma that\n-   --  doesn't appear in the Rep Item chain of the parent of E (if any).\n-\n-   function Has_Rep_Item (E : Entity_Id; Nam : Name_Id) return Boolean;\n-   --  Searches the Rep_Item chain for the given entity E, for an instance\n-   --  of rep item with the given name Nam. If found then True is returned,\n-   --  otherwise False indicates that no matching entry was found.\n-\n-   --  Again, the following two have bizarre names, and unclear specs ???\n-\n-   function Has_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Boolean;\n-   --  Searches the Rep_Item chain for the given entity E, for an instance\n-   --  of representation pragma with the given name Nam. If found then True\n-   --  is returned, otherwise False indicates that no matching entry was found.\n-\n-   function Has_Rep_Pragma_For_Entity\n-     (E : Entity_Id; Nam : Name_Id) return Boolean;\n-   --  Same as Has_Rep_Pragma except that this routine doesn't return True if\n-   --  the representation pragma is also present in the Rep Item chain of the\n-   --  parent of E (if any).\n-\n    function Present_In_Rep_Item (E : Entity_Id; N : Node_Id) return Boolean;\n    --  Return True if N is present in the Rep_Item chain for a given entity E\n "}, {"sha": "3f622beeac1400e5fd0220008c4deb92e8870082", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=34f3a7014b95e058d68adc1bee2e357e38056dec", "patch": "@@ -11604,7 +11604,7 @@ package body Exp_Ch9 is\n \n       --  Add the _Task_Info component if a Task_Info pragma is present\n \n-      if Has_Rep_Pragma_For_Entity (TaskId, Name_Task_Info) then\n+      if Has_Rep_Pragma (TaskId, Name_Task_Info, Check_Parents => False) then\n          Append_To (Cdecls,\n            Make_Component_Declaration (Loc,\n              Defining_Identifier =>\n@@ -11619,7 +11619,8 @@ package body Exp_Ch9 is\n              Expression => New_Copy (\n                Expression (First (\n                  Pragma_Argument_Associations (\n-                   Get_Rep_Pragma_For_Entity (TaskId, Name_Task_Info)))))));\n+                   Get_Rep_Pragma\n+                     (TaskId, Name_Task_Info, Check_Parents => False)))))));\n       end if;\n \n       --  Add the _CPU component with no expression\n@@ -13337,11 +13338,11 @@ package body Exp_Ch9 is\n              Attribute_Name => Name_Unchecked_Access));\n \n          --  Priority parameter. Set to Unspecified_Priority unless there is a\n-         --  priority clause, in which case we take the value from the\n-         --  pragma/attribute definition clause, or there is an interrupt\n-         --  clause and no priority clause, and we set the ceiling to\n-         --  Interrupt_Priority'Last, an implementation defined value,\n-         --  see D.3(10).\n+         --  Priority rep item, in which case we take the value from the pragma\n+         --  or attribute definition clause, or there is an Interrupt_Priority\n+         --  rep item and no Priority rep item, and we set the ceiling to\n+         --  Interrupt_Priority'Last, an implementation-defined value, see\n+         --  D.3(10).\n \n          if Has_Rep_Item (Ptyp, Name_Priority) then\n             declare\n@@ -13724,7 +13725,7 @@ package body Exp_Ch9 is\n       --  Task_Info parameter. Set to Unspecified_Task_Info unless there is a\n       --  Task_Info pragma, in which case we take the value from the pragma.\n \n-      if Has_Rep_Pragma_For_Entity (Ttyp, Name_Task_Info) then\n+      if Has_Rep_Pragma (Ttyp, Name_Task_Info, Check_Parents => False) then\n          Append_To (Args,\n            Make_Selected_Component (Loc,\n              Prefix        => Make_Identifier (Loc, Name_uInit),\n@@ -13907,7 +13908,7 @@ package body Exp_Ch9 is\n       --  init call unless there is a Task_Name pragma, in which case we take\n       --  the value from the pragma.\n \n-      if Has_Rep_Pragma_For_Entity (Ttyp, Name_Task_Name) then\n+      if Has_Rep_Pragma (Ttyp, Name_Task_Name, Check_Parents => False) then\n          --  Copy expression in full, because it may be dynamic and have\n          --  side effects.\n \n@@ -13916,7 +13917,8 @@ package body Exp_Ch9 is\n              (Expression\n                (First\n                  (Pragma_Argument_Associations\n-                   (Get_Rep_Pragma_For_Entity (Ttyp, Name_Task_Name))))));\n+                   (Get_Rep_Pragma\n+                     (Ttyp, Name_Task_Name, Check_Parents => False))))));\n \n       else\n          Append_To (Args, Make_Identifier (Loc, Name_uTask_Name));"}, {"sha": "dcf6b52650578fc87c7520e81e41e9f7486c47ad", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=34f3a7014b95e058d68adc1bee2e357e38056dec", "patch": "@@ -44,6 +44,7 @@ with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n+with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;"}, {"sha": "d08fa452d6452d4dd828b6d255b76c681f0532ee", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 150, "deletions": 2, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=34f3a7014b95e058d68adc1bee2e357e38056dec", "patch": "@@ -32,7 +32,6 @@\n \n with Atree;  use Atree;\n with Einfo;  use Einfo;\n-with Namet;  use Namet;\n with Sinfo;  use Sinfo;\n with Snames; use Snames;\n with Stand;  use Stand;\n@@ -418,6 +417,155 @@ package body Sem_Aux is\n       return Empty;\n    end First_Tag_Component;\n \n+   ------------------\n+   -- Get_Rep_Item --\n+   ------------------\n+\n+   function Get_Rep_Item\n+     (E             : Entity_Id;\n+      Nam           : Name_Id;\n+      Check_Parents : Boolean := True) return Node_Id\n+   is\n+      N : Node_Id;\n+\n+   begin\n+      N := First_Rep_Item (E);\n+      while Present (N) loop\n+         if Nkind (N) = N_Pragma\n+           and then\n+             (Pragma_Name (N) = Nam\n+               or else (Nam = Name_Priority\n+                         and then Pragma_Name (N) = Name_Interrupt_Priority))\n+         then\n+            if Check_Parents then\n+               return N;\n+\n+            --  If Check_Parents is False, return N if the pragma doesn't\n+            --  appear in the Rep_Item chain of the parent.\n+\n+            else\n+               declare\n+                  Par : constant Entity_Id := Nearest_Ancestor (E);\n+                  --  This node represents the parent type of type E (if any)\n+\n+               begin\n+                  if No (Par) then\n+                     return N;\n+\n+                  elsif not Present_In_Rep_Item (Par, N) then\n+                     return N;\n+                  end if;\n+               end;\n+            end if;\n+\n+         elsif Nkind (N) = N_Attribute_Definition_Clause\n+           and then\n+             (Chars (N) = Nam\n+                or else (Nam = Name_Priority\n+                          and then Chars (N) = Name_Interrupt_Priority))\n+         then\n+            if Check_Parents then\n+               return N;\n+\n+            elsif Entity (N) = E then\n+               return N;\n+            end if;\n+\n+         elsif Nkind (N) = N_Aspect_Specification\n+           and then\n+             (Chars (Identifier (N)) = Nam\n+                or else (Nam = Name_Priority\n+                          and then Chars (Identifier (N)) =\n+                                     Name_Interrupt_Priority))\n+         then\n+            if Check_Parents then\n+               return N;\n+\n+            elsif Entity (N) = E then\n+               return N;\n+            end if;\n+         end if;\n+\n+         Next_Rep_Item (N);\n+      end loop;\n+\n+      return Empty;\n+   end Get_Rep_Item;\n+\n+   --------------------\n+   -- Get_Rep_Pragma --\n+   --------------------\n+\n+   function Get_Rep_Pragma\n+     (E             : Entity_Id;\n+      Nam           : Name_Id;\n+      Check_Parents : Boolean := True) return Node_Id\n+   is\n+      N : Node_Id;\n+\n+   begin\n+      N := First_Rep_Item (E);\n+      while Present (N) loop\n+         if Nkind (N) = N_Pragma\n+           and then\n+             (Pragma_Name (N) = Nam\n+               or else (Nam = Name_Interrupt_Priority\n+                         and then Pragma_Name (N) = Name_Priority))\n+         then\n+            if Check_Parents then\n+               return N;\n+\n+            --  If Check_Parents is False, return N if the pragma doesn't\n+            --  appear in the Rep_Item chain of the parent.\n+\n+            else\n+               declare\n+                  Par : constant Entity_Id := Nearest_Ancestor (E);\n+                  --  This node represents the parent type of type E (if any)\n+\n+               begin\n+                  if No (Par) then\n+                     return N;\n+\n+                  elsif not Present_In_Rep_Item (Par, N) then\n+                     return N;\n+                  end if;\n+               end;\n+            end if;\n+         end if;\n+\n+         Next_Rep_Item (N);\n+      end loop;\n+\n+      return Empty;\n+   end Get_Rep_Pragma;\n+\n+   ------------------\n+   -- Has_Rep_Item --\n+   ------------------\n+\n+   function Has_Rep_Item\n+     (E             : Entity_Id;\n+      Nam           : Name_Id;\n+      Check_Parents : Boolean := True) return Boolean\n+   is\n+   begin\n+      return Present (Get_Rep_Item (E, Nam, Check_Parents));\n+   end Has_Rep_Item;\n+\n+   --------------------\n+   -- Has_Rep_Pragma --\n+   --------------------\n+\n+   function Has_Rep_Pragma\n+     (E             : Entity_Id;\n+      Nam           : Name_Id;\n+      Check_Parents : Boolean := True) return Boolean\n+   is\n+   begin\n+      return Present (Get_Rep_Pragma (E, Nam, Check_Parents));\n+   end Has_Rep_Pragma;\n+\n    -------------------------------\n    -- Initialization_Suppressed --\n    -------------------------------\n@@ -832,7 +980,7 @@ package body Sem_Aux is\n    ----------------------\n \n    function Nearest_Ancestor (Typ : Entity_Id) return Entity_Id is\n-      D : constant Node_Id := Original_Node (Declaration_Node (Typ));\n+      D : constant Node_Id := Declaration_Node (Typ);\n \n    begin\n       --  If we have a subtype declaration, get the ancestor subtype"}, {"sha": "85c70f9137443cea1d30eba7727a4aabc63b86b4", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=34f3a7014b95e058d68adc1bee2e357e38056dec", "patch": "@@ -39,6 +39,7 @@\n --  require more than minimal semantic knowledge.\n \n with Alloc; use Alloc;\n+with Namet; use Namet;\n with Table;\n with Types; use Types;\n \n@@ -155,6 +156,52 @@ package Sem_Aux is\n    --  Typ must be a tagged record type. This function returns the Entity for\n    --  the first _Tag field in the record type.\n \n+   function Get_Rep_Item\n+     (E             : Entity_Id;\n+      Nam           : Name_Id;\n+      Check_Parents : Boolean := True) return Node_Id;\n+   --  Searches the Rep_Item chain for a given entity E, for an instance of a\n+   --  rep item (pragma, attribute definition clause, or aspect specification)\n+   --  whose name matches the given name Nam. If Check_Parents is False then it\n+   --  only returns rep item that has been directly specified to E (and not\n+   --  inherited from its parents, if any). If one is found, it is returned,\n+   --  otherwise Empty is returned. A special case is that when Nam is\n+   --  Name_Priority, the call will also find Interrupt_Priority.\n+\n+   function Get_Rep_Pragma\n+     (E             : Entity_Id;\n+      Nam           : Name_Id;\n+      Check_Parents : Boolean := True) return Node_Id;\n+   --  Searches the Rep_Item chain for a given entity E, for an instance of a\n+   --  representation pragma whose name matches the given name Nam. If\n+   --  Check_Parents is False then it only returns representation pragma that\n+   --  has been directly specified to E (and not inherited from its parents, if\n+   --  any). If one is found, it is returned, otherwise Empty is returned. A\n+   --  special case is that when Nam is Name_Priority, the call will also find\n+   --  Interrupt_Priority.\n+\n+   function Has_Rep_Item\n+     (E             : Entity_Id;\n+      Nam           : Name_Id;\n+      Check_Parents : Boolean := True) return Boolean;\n+   --  Searches the Rep_Item chain for the given entity E, for an instance of a\n+   --  rep item (pragma, attribute definition clause, or aspect specification)\n+   --  with the given name Nam. If Check_Parents is False then it only returns\n+   --  rep item that has been directly specified to E (and not inherited from\n+   --  its parents, if any). If found then True is returned, otherwise False\n+   --  indicates that no matching entry was found.\n+\n+   function Has_Rep_Pragma\n+     (E             : Entity_Id;\n+      Nam           : Name_Id;\n+      Check_Parents : Boolean := True) return Boolean;\n+   --  Searches the Rep_Item chain for the given entity E, for an instance of a\n+   --  representation pragma with the given name Nam. If Check_Parents is False\n+   --  then it only returns representation pragma that has been directly\n+   --  specified to E (and not inherited from its parents, if any). If found\n+   --  then True is returned, otherwise False indicates that no matching entry\n+   --  was found.\n+\n    function In_Generic_Body (Id : Entity_Id) return Boolean;\n    --  Determine whether entity Id appears inside a generic body\n "}, {"sha": "63b29c10c7dc08d9b98183fd9e4ed2a6431b85d6", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=34f3a7014b95e058d68adc1bee2e357e38056dec", "patch": "@@ -2058,24 +2058,13 @@ package body Sem_Ch13 is\n          --  previously given pragma or aspect specification for the same\n          --  aspect.\n \n-         A := Get_Rep_Item_For_Entity (U_Ent, Chars (N));\n+         A := Get_Rep_Item (U_Ent, Chars (N), Check_Parents => False);\n \n          if Present (A) then\n             Error_Msg_Name_1 := Chars (N);\n             Error_Msg_Sloc := Sloc (A);\n \n-            if Nkind (A) = N_Aspect_Specification\n-              or else From_Aspect_Specification (A)\n-            then\n-               Error_Msg_NE (\"aspect% for & previously given#\", N, U_Ent);\n-\n-            elsif Nkind (A) = N_Pragma then\n-               Error_Msg_NE (\"clause% for & duplicates pragma#\", N, U_Ent);\n-\n-            else\n-               Error_Msg_NE (\"clause% for & duplicates clause#\", N, U_Ent);\n-            end if;\n-\n+            Error_Msg_NE (\"aspect% for & previously given#\", N, U_Ent);\n             return True;\n          end if;\n "}, {"sha": "cecdbef46ab78e623ff4d78417a77be5027787cb", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=34f3a7014b95e058d68adc1bee2e357e38056dec", "patch": "@@ -4685,8 +4685,12 @@ package body Sem_Eval is\n             return False;\n \n          else\n-            Pred1 := Get_Rep_Item_For_Entity (T1, Name_Static_Predicate);\n-            Pred2 := Get_Rep_Item_For_Entity (T2, Name_Static_Predicate);\n+            Pred1 :=\n+              Get_Rep_Item\n+                (T1, Name_Static_Predicate, Check_Parents => False);\n+            Pred2 :=\n+              Get_Rep_Item\n+                (T2, Name_Static_Predicate, Check_Parents => False);\n \n             --  Subtypes statically match if the predicate comes from the\n             --  same declaration, which can only happen if one is a subtype"}, {"sha": "35e1f6404eed851f6a23cc2c8da4d2239f894bc3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f3a7014b95e058d68adc1bee2e357e38056dec/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=34f3a7014b95e058d68adc1bee2e357e38056dec", "patch": "@@ -1613,7 +1613,7 @@ package body Sem_Prag is\n          --  previously given aspect specification or attribute definition\n          --  clause for the same pragma.\n \n-         P := Get_Rep_Item_For_Entity (E, Pragma_Name (N));\n+         P := Get_Rep_Item (E, Pragma_Name (N), Check_Parents => False);\n \n          if Present (P) then\n             Error_Msg_Name_1 := Pragma_Name (N);\n@@ -1630,12 +1630,8 @@ package body Sem_Prag is\n               or else From_Aspect_Specification (P)\n             then\n                Error_Msg_NE (\"aspect% for & previously given#\", N, Id);\n-\n-            elsif Nkind (P) = N_Pragma then\n-               Error_Msg_NE (\"pragma% for & duplicates pragma#\", N, Id);\n-\n             else\n-               Error_Msg_NE (\"pragma% for & duplicates clause#\", N, Id);\n+               Error_Msg_NE (\"pragma% for & duplicates pragma#\", N, Id);\n             end if;\n \n             raise Pragma_Exit;\n@@ -8024,7 +8020,6 @@ package body Sem_Prag is\n             --  Item chain of Ent.\n \n             Check_Duplicate_Pragma (Ent);\n-\n             Record_Rep_Item (Ent, N);\n          end CPU;\n \n@@ -8317,7 +8312,6 @@ package body Sem_Prag is\n                --  Item chain of Ent.\n \n                Check_Duplicate_Pragma (Ent);\n-\n                Record_Rep_Item (Ent, N);\n \n             --  Anything else is incorrect\n@@ -10284,7 +10278,6 @@ package body Sem_Prag is\n                --  Item chain of Ent.\n \n                Check_Duplicate_Pragma (Ent);\n-\n                Record_Rep_Item (Ent, N);\n             end if;\n          end Interrupt_Priority;\n@@ -12410,7 +12403,6 @@ package body Sem_Prag is\n             --  Item chain of Ent.\n \n             Check_Duplicate_Pragma (Ent);\n-\n             Record_Rep_Item (Ent, N);\n          end Priority;\n \n@@ -13928,7 +13920,12 @@ package body Sem_Prag is\n             --  Check duplicate pragma before we chain the pragma in the Rep\n             --  Item chain of Ent.\n \n-            Check_Duplicate_Pragma (Ent);\n+            if Has_Rep_Pragma\n+                 (Ent, Name_Task_Info, Check_Parents => False)\n+            then\n+               Error_Pragma (\"duplicate pragma% not allowed\");\n+            end if;\n+\n             Record_Rep_Item (Ent, N);\n          end Task_Info;\n \n@@ -13965,7 +13962,12 @@ package body Sem_Prag is\n             --  Check duplicate pragma before we chain the pragma in the Rep\n             --  Item chain of Ent.\n \n-            Check_Duplicate_Pragma (Ent);\n+            if Has_Rep_Pragma\n+                 (Ent, Name_Task_Name, Check_Parents => False)\n+            then\n+               Error_Pragma (\"duplicate pragma% not allowed\");\n+            end if;\n+\n             Record_Rep_Item (Ent, N);\n          end Task_Name;\n "}]}