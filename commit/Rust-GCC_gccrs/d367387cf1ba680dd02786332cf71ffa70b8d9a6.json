{"sha": "d367387cf1ba680dd02786332cf71ffa70b8d9a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM2NzM4N2NmMWJhNjgwZGQwMjc4NjMzMmNmNzFmZmE3MGI4ZDlhNg==", "commit": {"author": {"name": "Cong Hou", "email": "congh@google.com", "date": "2014-04-18T19:46:49Z"}, "committer": {"name": "Cong Hou", "email": "congh@gcc.gnu.org", "date": "2014-04-18T19:46:49Z"}, "message": "tree-vect-patterns.c (vect_recog_widen_mult_pattern): Enhance the widen-mult pattern by handling two operands with different sizes.\n\n2014-04-18  Cong Hou  <congh@google.com>\n\n        * tree-vect-patterns.c (vect_recog_widen_mult_pattern): Enhance\n        the widen-mult pattern by handling two operands with different\n        sizes.\n        * tree-vect-stmts.c (vectorizable_conversion): Allow multi-steps\n        conversions after widening mult operation.\n        (supportable_widening_operation): Likewise.\n\n2014-04-18  Cong Hou  <congh@google.com>\n\n        * gcc.dg/vect/vect-widen-mult-u8-s16-s32.c: New test.\n        * gcc.dg/vect/vect-widen-mult-u8-u32.c: New test.\n\nFrom-SVN: r209524", "tree": {"sha": "d6b44f1fff5d77a1173c2fe5c6d70ea9f750fd46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6b44f1fff5d77a1173c2fe5c6d70ea9f750fd46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d367387cf1ba680dd02786332cf71ffa70b8d9a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d367387cf1ba680dd02786332cf71ffa70b8d9a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d367387cf1ba680dd02786332cf71ffa70b8d9a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d367387cf1ba680dd02786332cf71ffa70b8d9a6/comments", "author": null, "committer": null, "parents": [{"sha": "b6d627e4724edc68777c8b2f5e11aad99a1dd2e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3"}], "stats": {"total": 203, "additions": 193, "deletions": 10}, "files": [{"sha": "bbf468aec6b1607817547500e2c29a1f36b0ac68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d367387cf1ba680dd02786332cf71ffa70b8d9a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d367387cf1ba680dd02786332cf71ffa70b8d9a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d367387cf1ba680dd02786332cf71ffa70b8d9a6", "patch": "@@ -1,3 +1,12 @@\n+2014-04-18  Cong Hou  <congh@google.com>\n+\n+\t* tree-vect-patterns.c (vect_recog_widen_mult_pattern): Enhance\n+\tthe widen-mult pattern by handling two operands with different\n+\tsizes.\n+\t* tree-vect-stmts.c (vectorizable_conversion): Allow multi-steps\n+\tconversions after widening mult operation.\n+\t(supportable_widening_operation): Likewise.\n+\n 2014-04-18  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-inline.h (INLINE_HINT_known_hot): New hint."}, {"sha": "a1071cd55d98bc166509bcce8a4ab1eeb46ba415", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d367387cf1ba680dd02786332cf71ffa70b8d9a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d367387cf1ba680dd02786332cf71ffa70b8d9a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d367387cf1ba680dd02786332cf71ffa70b8d9a6", "patch": "@@ -1,3 +1,8 @@\n+2014-04-18  Cong Hou  <congh@google.com>\n+\n+\t* gcc.dg/vect/vect-widen-mult-u8-s16-s32.c: New test.\n+\t* gcc.dg/vect/vect-widen-mult-u8-u32.c: New test.\n+\n 2014-04-18  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* gcc.dg/vmx/merge-vsx.c: Add V4SI and V4SF tests."}, {"sha": "ae485499971221757a14140f4345452546c783b4", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8-s16-s32.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d367387cf1ba680dd02786332cf71ffa70b8d9a6/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8-s16-s32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d367387cf1ba680dd02786332cf71ffa70b8d9a6/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8-s16-s32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8-s16-s32.c?ref=d367387cf1ba680dd02786332cf71ffa70b8d9a6", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned char X[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+short Y[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int result[N];\n+\n+/* unsigned char * short -> int widening-mult.  */\n+__attribute__ ((noinline)) int\n+foo (int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    result[i] = X[i] * Y[i];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+    __asm__ volatile (\"\");\n+  }\n+\n+  foo (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (result[i] != X[i] * Y[i])\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_mult_hi_to_si || vect_unpack } } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times \"pattern recognized\" 1 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "adc578ad5033ba66b8a4ea324b6f42f0ff35c2f3", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8-u32.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d367387cf1ba680dd02786332cf71ffa70b8d9a6/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8-u32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d367387cf1ba680dd02786332cf71ffa70b8d9a6/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8-u32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8-u32.c?ref=d367387cf1ba680dd02786332cf71ffa70b8d9a6", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned char X[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+unsigned char Y[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+unsigned int result[N];\n+\n+/* unsigned char-> unsigned int widening-mult.  */\n+__attribute__ ((noinline)) int\n+foo (int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    result[i] = X[i] * Y[i];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+    __asm__ volatile (\"\");\n+  }\n+\n+  foo (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (result[i] != X[i] * Y[i])\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" { target vect_widen_mult_qi_to_hi_pattern } } } */\n+/* { dg-final { scan-tree-dump-times \"pattern recognized\" 1 \"vect\" { target vect_widen_mult_qi_to_hi_pattern } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "5daaf2459c4097e1b79eeb6895cdba93b5a3c916", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 83, "deletions": 10, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d367387cf1ba680dd02786332cf71ffa70b8d9a6/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d367387cf1ba680dd02786332cf71ffa70b8d9a6/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=d367387cf1ba680dd02786332cf71ffa70b8d9a6", "patch": "@@ -529,7 +529,8 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n \n    Try to find the following pattern:\n \n-     type a_t, b_t;\n+     type1 a_t;\n+     type2 b_t;\n      TYPE a_T, b_T, prod_T;\n \n      S1  a_t = ;\n@@ -538,11 +539,12 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n      S4  b_T = (TYPE) b_t;\n      S5  prod_T = a_T * b_T;\n \n-   where type 'TYPE' is at least double the size of type 'type'.\n+   where type 'TYPE' is at least double the size of type 'type1' and 'type2'.\n \n    Also detect unsigned cases:\n \n-     unsigned type a_t, b_t;\n+     unsigned type1 a_t;\n+     unsigned type2 b_t;\n      unsigned TYPE u_prod_T;\n      TYPE a_T, b_T, prod_T;\n \n@@ -596,6 +598,8 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n    * Return value: A new stmt that will be used to replace the sequence of\n    stmts that constitute the pattern.  In this case it will be:\n         WIDEN_MULT <a_t, b_t>\n+   If the result of WIDEN_MULT needs to be converted to a larger type, the\n+   returned stmt will be this type conversion stmt.\n */\n \n static gimple\n@@ -606,8 +610,8 @@ vect_recog_widen_mult_pattern (vec<gimple> *stmts,\n   gimple def_stmt0, def_stmt1;\n   tree oprnd0, oprnd1;\n   tree type, half_type0, half_type1;\n-  gimple pattern_stmt;\n-  tree vectype, vectype_out = NULL_TREE;\n+  gimple new_stmt = NULL, pattern_stmt = NULL;\n+  tree vectype, vecitype;\n   tree var;\n   enum tree_code dummy_code;\n   int dummy_int;\n@@ -661,6 +665,33 @@ vect_recog_widen_mult_pattern (vec<gimple> *stmts,\n         return NULL;\n     }\n \n+  /* If the two arguments have different sizes, convert the one with\n+     the smaller type into the larger type.  */\n+  if (TYPE_PRECISION (half_type0) != TYPE_PRECISION (half_type1))\n+    {\n+      tree* oprnd = NULL;\n+      gimple def_stmt = NULL;\n+\n+      if (TYPE_PRECISION (half_type0) < TYPE_PRECISION (half_type1))\n+\t{\n+\t  def_stmt = def_stmt0;\n+\t  half_type0 = half_type1;\n+\t  oprnd = &oprnd0;\n+\t}\n+      else\n+\t{\n+\t  def_stmt = def_stmt1;\n+\t  half_type1 = half_type0;\n+\t  oprnd = &oprnd1;\n+\t}\n+\n+        tree old_oprnd = gimple_assign_rhs1 (def_stmt);\n+        tree new_oprnd = make_ssa_name (half_type0, NULL);\n+        new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n+                                                 old_oprnd, NULL_TREE);\n+        *oprnd = new_oprnd;\n+    }\n+\n   /* Handle unsigned case.  Look for\n      S6  u_prod_T = (unsigned TYPE) prod_T;\n      Use unsigned TYPE as the type for WIDEN_MULT_EXPR.  */\n@@ -692,30 +723,72 @@ vect_recog_widen_mult_pattern (vec<gimple> *stmts,\n   if (!types_compatible_p (half_type0, half_type1))\n     return NULL;\n \n+  /* If TYPE is more than twice larger than HALF_TYPE, we use WIDEN_MULT\n+     to get an intermediate result of type ITYPE.  In this case we need\n+     to build a statement to convert this intermediate result to type TYPE.  */\n+  tree itype = type;\n+  if (TYPE_PRECISION (type) > TYPE_PRECISION (half_type0) * 2)\n+    itype = build_nonstandard_integer_type\n+              (GET_MODE_BITSIZE (TYPE_MODE (half_type0)) * 2,\n+               TYPE_UNSIGNED (type));\n+\n   /* Pattern detected.  */\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_recog_widen_mult_pattern: detected:\\n\");\n \n   /* Check target support  */\n   vectype = get_vectype_for_scalar_type (half_type0);\n-  vectype_out = get_vectype_for_scalar_type (type);\n+  vecitype = get_vectype_for_scalar_type (itype);\n   if (!vectype\n-      || !vectype_out\n+      || !vecitype\n       || !supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt,\n-\t\t\t\t\t  vectype_out, vectype,\n+\t\t\t\t\t  vecitype, vectype,\n \t\t\t\t\t  &dummy_code, &dummy_code,\n \t\t\t\t\t  &dummy_int, &dummy_vec))\n     return NULL;\n \n   *type_in = vectype;\n-  *type_out = vectype_out;\n+  *type_out = get_vectype_for_scalar_type (type);\n \n   /* Pattern supported. Create a stmt to be used to replace the pattern: */\n-  var = vect_recog_temp_ssa_var (type, NULL);\n+  var = vect_recog_temp_ssa_var (itype, NULL);\n   pattern_stmt = gimple_build_assign_with_ops (WIDEN_MULT_EXPR, var, oprnd0,\n \t\t\t\t\t       oprnd1);\n \n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n+\n+  /* If the original two operands have different sizes, we may need to convert\n+     the smaller one into the larget type.  If this is the case, at this point\n+     the new stmt is already built.  */\n+  if (new_stmt)\n+    {\n+      append_pattern_def_seq (stmt_vinfo, new_stmt);\n+      stmt_vec_info new_stmt_info\n+        = new_stmt_vec_info (new_stmt, loop_vinfo, bb_vinfo);\n+      set_vinfo_for_stmt (new_stmt, new_stmt_info);\n+      STMT_VINFO_VECTYPE (new_stmt_info) = vectype;\n+    }\n+\n+  /* If ITYPE is not TYPE, we need to build a type convertion stmt to convert\n+     the result of the widen-mult operation into type TYPE.  */\n+  if (itype != type)\n+    {\n+      append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n+      stmt_vec_info pattern_stmt_info\n+        = new_stmt_vec_info (pattern_stmt, loop_vinfo, bb_vinfo);\n+      set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n+      STMT_VINFO_VECTYPE (pattern_stmt_info) = vecitype;\n+      pattern_stmt\n+        = gimple_build_assign_with_ops (NOP_EXPR,\n+                                        vect_recog_temp_ssa_var (type, NULL),\n+                                        gimple_assign_lhs (pattern_stmt),\n+                                        NULL_TREE);\n+    }\n+\n   if (dump_enabled_p ())\n     dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n "}]}