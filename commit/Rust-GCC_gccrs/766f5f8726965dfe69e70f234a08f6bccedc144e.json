{"sha": "766f5f8726965dfe69e70f234a08f6bccedc144e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY2ZjVmODcyNjk2NWRmZTY5ZTcwZjIzNGEwOGY2YmNjZWRjMTQ0ZQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-08-28T22:50:38Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-08-29T15:19:03Z"}, "message": "d: Call the assertp and boundsp variants for assert and array contract failures.\n\ngcc/d/ChangeLog:\n\n\t* d-codegen.cc: Include dmd/module.h.\n\t(build_filename_from_loc): New function.\n\t(d_assert_call): Rename to...\n\t(build_assert_call): ...this.\n\t(build_array_bounds_call): Call arrayboundsp variant of the array\n\tbounds failure callback.\n\t(build_bounds_condition): Rename to...\n\t(build_bounds_index_condition): ...this.  Update signature.\n\t(build_bounds_slice_condition): New function.\n\t(checkaction_trap_p): New function.\n\t(d_assert_call): Call assertp variant of assert failure callback.\n\t* d-tree.h (class IndexExp): Declare.\n\t(class SliceExp): Declare.\n\t(build_bounds_condition): Remove.\n\t(build_assert_call): Declare.\n\t(build_bounds_index_condition): Declare.\n\t(build_bounds_slice_condition): Declare.\n\t(checkaction_trap_p): Declare.\n\t(d_assert_call): Remove.\n\t* expr.cc (ExprVisitor::visit(IndexExp *)): Call\n\tbuild_bounds_index_condition.\n\t(ExprVisitor::visit(SliceExp *)): Call build_bounds_slice_condition.\n\t(ExprVisitor::visit(AssertExp *)): Update setting of libcall.\n\t* runtime.cc (enum d_libcall_type): Add LCT_IMMUTABLE_CHARPTR.\n\t(get_libcall_type): Handle LCT_IMMUTABLE_CHARPTR.\n\t* runtime.def (ASSERT): Rename to...\n\t(ASSERTP): ...this.  Update signature.\n\t(UNITTEST): Rename to...\n\t(UNITTESTP): ...this.  Update signature.\n\t(ARRAY_BOUNDS): Rename to...\n\t(ARRAYBOUNDSP): ...this.  Updates signature.\n\t* toir.cc (IRVisitor::visit(SwitchErrorStatement *)): Update call.", "tree": {"sha": "3faf414ef540d78219b3e3832a658dc31a7e0e53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3faf414ef540d78219b3e3832a658dc31a7e0e53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/766f5f8726965dfe69e70f234a08f6bccedc144e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/766f5f8726965dfe69e70f234a08f6bccedc144e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/766f5f8726965dfe69e70f234a08f6bccedc144e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/766f5f8726965dfe69e70f234a08f6bccedc144e/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "118a559df998051430c2068cfa4e03479c0c85da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118a559df998051430c2068cfa4e03479c0c85da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/118a559df998051430c2068cfa4e03479c0c85da"}], "stats": {"total": 282, "additions": 173, "deletions": 109}, "files": [{"sha": "e63365055d37b2c4dd3afc5b64d2cf2d79e357d0", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 139, "deletions": 46, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=766f5f8726965dfe69e70f234a08f6bccedc144e", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dmd/ctfe.h\"\n #include \"dmd/declaration.h\"\n #include \"dmd/identifier.h\"\n+#include \"dmd/module.h\"\n #include \"dmd/target.h\"\n #include \"dmd/template.h\"\n \n@@ -1831,50 +1832,149 @@ void_okay_p (tree t)\n   return t;\n }\n \n-/* Builds a CALL_EXPR at location LOC in the source file to execute when an\n-   array bounds check fails.  */\n+/* Builds a STRING_CST representing the filename of location LOC.  When the\n+   location is not valid, the name of the source module is used instead.  */\n+\n+static tree\n+build_filename_from_loc (const Loc &loc)\n+{\n+  const char *filename = loc.filename\n+    ? loc.filename : d_function_chain->module->srcfile->toChars ();\n+\n+  unsigned length = strlen (filename);\n+  tree str = build_string (length, filename);\n+  TREE_TYPE (str) = make_array_type (Type::tchar, length + 1);\n+\n+  return build_address (str);\n+}\n+\n+/* Builds a CALL_EXPR at location LOC in the source file to call LIBCALL when\n+   an assert check fails.  When calling the msg variant functions, MSG is the\n+   error message supplied by the user.  */\n \n tree\n-build_array_bounds_call (const Loc &loc)\n+build_assert_call (const Loc &loc, libcall_fn libcall, tree msg)\n {\n-  switch (global.params.checkAction)\n+  tree file;\n+  tree line = size_int (loc.linnum);\n+\n+  switch (libcall)\n     {\n-    case CHECKACTION_D:\n-      return d_assert_call (loc, LIBCALL_ARRAY_BOUNDS);\n+    case LIBCALL_ASSERT_MSG:\n+    case LIBCALL_UNITTEST_MSG:\n+    case LIBCALL_SWITCH_ERROR:\n+      /* File location is passed as a D string.  */\n+      if (loc.filename)\n+\t{\n+\t  unsigned len = strlen (loc.filename);\n+\t  tree str = build_string (len, loc.filename);\n+\t  TREE_TYPE (str) = make_array_type (Type::tchar, len);\n \n-    case CHECKACTION_C:\n-    case CHECKACTION_halt:\n-      return build_call_expr (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+\t  file = d_array_value (build_ctype (Type::tchar->arrayOf ()),\n+\t\t\t\tsize_int (len), build_address (str));\n+\t}\n+      else\n+\tfile = null_array_node;\n+      break;\n+\n+    case LIBCALL_ASSERTP:\n+    case LIBCALL_UNITTESTP:\n+      file = build_filename_from_loc (loc);\n+      break;\n \n     default:\n       gcc_unreachable ();\n     }\n+\n+\n+  if (msg != NULL_TREE)\n+    return build_libcall (libcall, Type::tvoid, 3, msg, file, line);\n+  else\n+    return build_libcall (libcall, Type::tvoid, 2, file, line);\n }\n \n-/* Builds a bounds condition checking that INDEX is between 0 and LEN.\n-   The condition returns the INDEX if true, or throws a RangeError.\n-   If INCLUSIVE, we allow INDEX == LEN to return true also.  */\n+/* Builds a CALL_EXPR at location LOC in the source file to execute when an\n+   array bounds check fails.  */\n \n tree\n-build_bounds_condition (const Loc &loc, tree index, tree len, bool inclusive)\n+build_array_bounds_call (const Loc &loc)\n {\n-  if (!array_bounds_check ())\n+  /* Terminate the program with a trap if no D runtime present.  */\n+  if (checkaction_trap_p ())\n+    return build_call_expr (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+  else\n+    {\n+      return build_libcall (LIBCALL_ARRAYBOUNDSP, Type::tvoid, 2,\n+\t\t\t    build_filename_from_loc (loc),\n+\t\t\t    size_int (loc.linnum));\n+    }\n+}\n+\n+/* Builds a bounds condition checking that INDEX is between 0 and LENGTH\n+   in the index expression IE.  The condition returns the INDEX if true, or\n+   throws a `RangeError`.  */\n+\n+tree\n+build_bounds_index_condition (IndexExp *ie, tree index, tree length)\n+{\n+  if (ie->indexIsInBounds || !array_bounds_check ())\n     return index;\n \n   /* Prevent multiple evaluations of the index.  */\n   index = d_save_expr (index);\n \n-  /* Generate INDEX >= LEN && throw RangeError.\n+  /* Generate INDEX >= LENGTH && throw RangeError.\n      No need to check whether INDEX >= 0 as the front-end should\n      have already taken care of implicit casts to unsigned.  */\n-  tree condition = fold_build2 (inclusive ? GT_EXPR : GE_EXPR,\n-\t\t\t\td_bool_type, index, len);\n-  /* Terminate the program with a trap if no D runtime present.  */\n-  tree boundserr = build_array_bounds_call (loc);\n+  tree condition = fold_build2 (GE_EXPR, d_bool_type, index, length);\n+  tree boundserr = build_array_bounds_call (ie->e2->loc);\n \n   return build_condition (TREE_TYPE (index), condition, boundserr, index);\n }\n \n+/* Builds a bounds condition checking that the range LOWER..UPPER do not overlap\n+   the slice expression SE of the source array length LENGTH.  The condition\n+   returns the new array length if true, or throws an `ArraySliceError`.  */\n+\n+tree\n+build_bounds_slice_condition (SliceExp *se, tree lower, tree upper, tree length)\n+{\n+  if (array_bounds_check ())\n+    {\n+      tree condition = NULL_TREE;\n+\n+      /* Enforces that `upper <= length`.  */\n+      if (!se->upperIsInBounds && length != NULL_TREE)\n+\tcondition = fold_build2 (GT_EXPR, d_bool_type, upper, length);\n+      else\n+\tlength = integer_zero_node;\n+\n+      /* Enforces that `lower <= upper`.  No need to check `lower <= length` as\n+\t we've already ensured that `upper <= length`.  */\n+      if (!se->lowerIsLessThanUpper)\n+\t{\n+\t  tree lwr_cond = fold_build2 (GT_EXPR, d_bool_type, lower, upper);\n+\n+\t  if (condition != NULL_TREE)\n+\t    condition = build_boolop (TRUTH_ORIF_EXPR, condition, lwr_cond);\n+\t  else\n+\t    condition = lwr_cond;\n+\t}\n+\n+      if (condition != NULL_TREE)\n+\t{\n+\t  tree boundserr = build_array_bounds_call (se->loc);\n+\t  upper = build_condition (TREE_TYPE (upper), condition,\n+\t\t\t\t   boundserr, upper);\n+\t}\n+    }\n+\n+  /* Need to ensure lower always gets evaluated first, as it may be a function\n+     call.  Generates (lower, upper) - lower.  */\n+  return fold_build2 (MINUS_EXPR, TREE_TYPE (upper),\n+\t\t      compound_expr (lower, upper), lower);\n+}\n+\n /* Returns TRUE if array bounds checking code generation is turned on.  */\n \n bool\n@@ -1905,6 +2005,26 @@ array_bounds_check (void)\n     }\n }\n \n+/* Returns TRUE if we terminate the program with a trap if an array bounds or\n+   contract check fails.  */\n+\n+bool\n+checkaction_trap_p (void)\n+{\n+  switch (global.params.checkAction)\n+    {\n+    case CHECKACTION_D:\n+      return false;\n+\n+    case CHECKACTION_C:\n+    case CHECKACTION_halt:\n+      return true;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Returns the TypeFunction class for Type T.\n    Assumes T is already ->toBasetype().  */\n \n@@ -2093,33 +2213,6 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n   return compound_expr (saved_args, result);\n }\n \n-/* Builds a call to AssertError or AssertErrorMsg.  */\n-\n-tree\n-d_assert_call (const Loc &loc, libcall_fn libcall, tree msg)\n-{\n-  tree file;\n-  tree line = size_int (loc.linnum);\n-\n-  /* File location is passed as a D string.  */\n-  if (loc.filename)\n-    {\n-      unsigned len = strlen (loc.filename);\n-      tree str = build_string (len, loc.filename);\n-      TREE_TYPE (str) = make_array_type (Type::tchar, len);\n-\n-      file = d_array_value (build_ctype (Type::tchar->arrayOf ()),\n-\t\t\t    size_int (len), build_address (str));\n-    }\n-  else\n-    file = null_array_node;\n-\n-  if (msg != NULL)\n-    return build_libcall (libcall, Type::tvoid, 3, msg, file, line);\n-  else\n-    return build_libcall (libcall, Type::tvoid, 2, file, line);\n-}\n-\n /* Build and return the correct call to fmod depending on TYPE.\n    ARG0 and ARG1 are the arguments pass to the function.  */\n "}, {"sha": "9b90ca530e60b8503ac51b970c4508b2c9c723d0", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=766f5f8726965dfe69e70f234a08f6bccedc144e", "patch": "@@ -31,6 +31,8 @@ class TypeInfoDeclaration;\n class VarDeclaration;\n class Expression;\n class ClassReferenceExp;\n+class IndexExp;\n+class SliceExp;\n class Module;\n class Statement;\n class Type;\n@@ -575,15 +577,17 @@ extern tree build_array_set (tree, tree, tree);\n extern tree build_array_from_val (Type *, tree);\n extern tree build_array_from_exprs (Type *, Expressions *, bool);\n extern tree void_okay_p (tree);\n+extern tree build_assert_call (const Loc &, libcall_fn, tree = NULL_TREE);\n extern tree build_array_bounds_call (const Loc &);\n-extern tree build_bounds_condition (const Loc &, tree, tree, bool);\n+extern tree build_bounds_index_condition (IndexExp *, tree, tree);\n+extern tree build_bounds_slice_condition (SliceExp *, tree, tree, tree);\n extern bool array_bounds_check (void);\n+extern bool checkaction_trap_p (void);\n extern tree bind_expr (tree, tree);\n extern TypeFunction *get_function_type (Type *);\n extern bool call_by_alias_p (FuncDeclaration *, FuncDeclaration *);\n extern tree d_build_call_expr (FuncDeclaration *, tree, Expressions *);\n extern tree d_build_call (TypeFunction *, tree, tree, Expressions *);\n-extern tree d_assert_call (const Loc &, libcall_fn, tree = NULL_TREE);\n extern tree build_float_modulus (tree, tree, tree);\n extern tree build_vthis_function (tree, tree);\n extern tree error_no_frame_access (Dsymbol *);"}, {"sha": "ea21bd5a8a15d171af5a2828459853a613789e23", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 8, "deletions": 50, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=766f5f8726965dfe69e70f234a08f6bccedc144e", "patch": "@@ -1304,8 +1304,8 @@ class ExprVisitor : public Visitor\n \n \t/* If it's a static array and the index is constant, the front end has\n \t   already checked the bounds.  */\n-\tif (tb1->ty != Tpointer && !e->indexIsInBounds)\n-\t  index = build_bounds_condition (e->e2->loc, index, length, false);\n+\tif (tb1->ty != Tpointer)\n+\t  index = build_bounds_index_condition (e, index, length);\n \n \t/* Index the .ptr.  */\n \tptr = void_okay_p (ptr);\n@@ -1412,8 +1412,6 @@ class ExprVisitor : public Visitor\n \tptr = build_array_index (void_okay_p (ptr), lwr_tree);\n \tptr = build_nop (ptrtype, ptr);\n       }\n-    else\n-      lwr_tree = NULL_TREE;\n \n     /* Nothing more to do for static arrays, their bounds checking has been\n        done at compile-time.  */\n@@ -1426,46 +1424,8 @@ class ExprVisitor : public Visitor\n       gcc_assert (tb->ty == Tarray);\n \n     /* Generate bounds checking code.  */\n-    tree newlength;\n-\n-    if (!e->upperIsInBounds)\n-      {\n-\tif (length)\n-\t  {\n-\t    newlength = build_bounds_condition (e->upr->loc, upr_tree,\n-\t\t\t\t\t\tlength, true);\n-\t  }\n-\telse\n-\t  {\n-\t    /* Still need to check bounds lwr <= upr for pointers.  */\n-\t    gcc_assert (tb1->ty == Tpointer);\n-\t    newlength = upr_tree;\n-\t  }\n-      }\n-    else\n-      newlength = upr_tree;\n-\n-    if (lwr_tree)\n-      {\n-\t/* Enforces lwr <= upr.  No need to check lwr <= length as\n-\t   we've already ensured that upr <= length.  */\n-\tif (!e->lowerIsLessThanUpper)\n-\t  {\n-\t    tree cond = build_bounds_condition (e->lwr->loc, lwr_tree,\n-\t\t\t\t\t\tupr_tree, true);\n-\n-\t    /* When bounds checking is off, the index value is\n-\t       returned directly.  */\n-\t    if (cond != lwr_tree)\n-\t      newlength = compound_expr (cond, newlength);\n-\t  }\n-\n-\t/* Need to ensure lwr always gets evaluated first, as it may be a\n-\t   function call.  Generates (lwr, upr) - lwr.  */\n-\tnewlength = fold_build2 (MINUS_EXPR, TREE_TYPE (newlength),\n-\t\t\t\t compound_expr (lwr_tree, newlength), lwr_tree);\n-      }\n-\n+    tree newlength = build_bounds_slice_condition (e, lwr_tree, upr_tree,\n+\t\t\t\t\t\t   length);\n     tree result = d_array_value (build_ctype (e->type), newlength, ptr);\n     this->result_ = compound_expr (array, result);\n   }\n@@ -2023,8 +1983,7 @@ class ExprVisitor : public Visitor\n     tree assert_pass = void_node;\n     tree assert_fail;\n \n-    if (global.params.useAssert == CHECKENABLEon\n-\t&& global.params.checkAction == CHECKACTION_D)\n+    if (global.params.useAssert == CHECKENABLEon && !checkaction_trap_p ())\n       {\n \t/* Generate: ((bool) e1  ? (void)0 : _d_assert (...))\n \t\t or: (e1 != null ? e1._invariant() : _d_assert (...))  */\n@@ -2037,10 +1996,10 @@ class ExprVisitor : public Visitor\n \t    libcall = unittest_p ? LIBCALL_UNITTEST_MSG : LIBCALL_ASSERT_MSG;\n \t  }\n \telse\n-\t  libcall = unittest_p ? LIBCALL_UNITTEST : LIBCALL_ASSERT;\n+\t  libcall = unittest_p ? LIBCALL_UNITTESTP : LIBCALL_ASSERTP;\n \n \t/* Build a call to _d_assert().  */\n-\tassert_fail = d_assert_call (e->loc, libcall, tmsg);\n+\tassert_fail = build_assert_call (e->loc, libcall, tmsg);\n \n \tif (global.params.useInvariants == CHECKENABLEon)\n \t  {\n@@ -2068,8 +2027,7 @@ class ExprVisitor : public Visitor\n \t      }\n \t  }\n       }\n-    else if (global.params.useAssert == CHECKENABLEon\n-\t     && global.params.checkAction == CHECKACTION_C)\n+    else if (global.params.useAssert == CHECKENABLEon && checkaction_trap_p ())\n       {\n \t/* Generate: __builtin_trap()  */\n \ttree fn = builtin_decl_explicit (BUILT_IN_TRAP);"}, {"sha": "5206b53b86567bfcdc7a5fdefb287ea84dd5d455", "filename": "gcc/d/runtime.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.cc?ref=766f5f8726965dfe69e70f234a08f6bccedc144e", "patch": "@@ -51,6 +51,7 @@ enum d_libcall_type\n   LCT_ARRAY_VOID,\t    /* void[]\t\t    */\n   LCT_ARRAY_SIZE_T,\t    /* size_t[]\t\t    */\n   LCT_ARRAY_BYTE,\t    /* byte[]\t\t    */\n+  LCT_IMMUTABLE_CHARPTR,    /* immutable(char*)\t    */\n   LCT_ARRAY_STRING,\t    /* string[]\t\t    */\n   LCT_ARRAY_WSTRING,\t    /* wstring[]\t    */\n   LCT_ARRAY_DSTRING,\t    /* dstring[]\t    */\n@@ -200,6 +201,10 @@ get_libcall_type (d_libcall_type type)\n       libcall_types[type] = Type::tint8->arrayOf ()->pointerTo ();\n       break;\n \n+    case LCT_IMMUTABLE_CHARPTR:\n+      libcall_types[type] = Type::tchar->pointerTo ()->immutableOf ();\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "0296233f4e29073726a78c5ec15f1b94cd3411d1", "filename": "gcc/d/runtime.def", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.def?ref=766f5f8726965dfe69e70f234a08f6bccedc144e", "patch": "@@ -26,27 +26,31 @@ along with GCC; see the file COPYING3.  If not see\n    extern(C) - for those that are not, ensure to use correct mangling.  */\n \n /* Helper macros for parameter building.  */\n-#define P0()\t\t    0\n-#define P1(T1)\t\t    1, LCT_ ## T1\n-#define P2(T1, T2)\t    2, LCT_ ## T1, LCT_ ## T2\n-#define P3(T1, T2, T3)\t    3, LCT_ ## T1, LCT_ ## T2, LCT_ ## T3\n-#define P4(T1, T2, T3, T4)  4, LCT_ ## T1, LCT_ ## T2, LCT_ ## T3, LCT_ ## T4\n-#define RT(T1)\t\t    LCT_ ## T1\n+#define P0()\t0\n+#define P1(T1)\t1, LCT_ ## T1\n+#define P2(T1, T2) \\\n+\t\t2, LCT_ ## T1, LCT_ ## T2\n+#define P3(T1, T2, T3) \\\n+\t\t3, LCT_ ## T1, LCT_ ## T2, LCT_ ## T3\n+#define P4(T1, T2, T3, T4) \\\n+\t\t4, LCT_ ## T1, LCT_ ## T2, LCT_ ## T3, LCT_ ## T4\n+#define RT(T1)\tLCT_ ## T1\n \n /* Used when an assert() contract fails.  */\n-DEF_D_RUNTIME (ASSERT, \"_d_assert\", RT(VOID), P2(STRING, UINT), ECF_NORETURN)\n+DEF_D_RUNTIME (ASSERTP, \"_d_assertp\", RT(VOID), P2(IMMUTABLE_CHARPTR, UINT),\n+\t       ECF_NORETURN)\n DEF_D_RUNTIME (ASSERT_MSG, \"_d_assert_msg\", RT(VOID), P3(STRING, STRING, UINT),\n \t       ECF_NORETURN)\n \n /* Used when an assert() contract fails in a unittest function.  */\n-DEF_D_RUNTIME (UNITTEST, \"_d_unittest\", RT(VOID), P2(STRING, UINT),\n+DEF_D_RUNTIME (UNITTESTP, \"_d_unittestp\", RT(VOID), P2(IMMUTABLE_CHARPTR, UINT),\n \t       ECF_NORETURN)\n DEF_D_RUNTIME (UNITTEST_MSG, \"_d_unittest_msg\", RT(VOID),\n \t       P3(STRING, STRING, UINT), ECF_NORETURN)\n \n /* Used when an array index outside the bounds of its range.  */\n-DEF_D_RUNTIME (ARRAY_BOUNDS, \"_d_arraybounds\", RT(VOID), P2(STRING, UINT),\n-\t       ECF_NORETURN)\n+DEF_D_RUNTIME (ARRAYBOUNDSP, \"_d_arrayboundsp\", RT(VOID),\n+\t       P2(IMMUTABLE_CHARPTR, UINT), ECF_NORETURN)\n \n /* Used when calling new on a class.  */\n DEF_D_RUNTIME (NEWCLASS, \"_d_newclass\", RT(OBJECT), P1(CONST_CLASSINFO), 0)"}, {"sha": "1c9da101f3995a76da8aaf0df7d285ccff739fb8", "filename": "gcc/d/toir.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Ftoir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766f5f8726965dfe69e70f234a08f6bccedc144e/gcc%2Fd%2Ftoir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftoir.cc?ref=766f5f8726965dfe69e70f234a08f6bccedc144e", "patch": "@@ -992,7 +992,7 @@ class IRVisitor : public Visitor\n \n   void visit (SwitchErrorStatement *s)\n   {\n-    add_stmt (d_assert_call (s->loc, LIBCALL_SWITCH_ERROR));\n+    add_stmt (build_assert_call (s->loc, LIBCALL_SWITCH_ERROR));\n   }\n \n   /* A return statement exits the current function and supplies its return"}]}