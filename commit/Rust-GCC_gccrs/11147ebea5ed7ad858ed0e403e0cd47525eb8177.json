{"sha": "11147ebea5ed7ad858ed0e403e0cd47525eb8177", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTExNDdlYmVhNWVkN2FkODU4ZWQwZTQwM2UwY2Q0NzUyNWViODE3Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-20T11:50:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-20T11:50:18Z"}, "message": "(try_split): Rename third parameter as LAST.\n\n(try_split): Rename third parameter as LAST.  Recursively call\ntry_split for each new insn created.\n\nFrom-SVN: r6832", "tree": {"sha": "f9eb63eb1a68355b330b56647ffd88b098e61920", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9eb63eb1a68355b330b56647ffd88b098e61920"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11147ebea5ed7ad858ed0e403e0cd47525eb8177", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11147ebea5ed7ad858ed0e403e0cd47525eb8177", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11147ebea5ed7ad858ed0e403e0cd47525eb8177", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11147ebea5ed7ad858ed0e403e0cd47525eb8177/comments", "author": null, "committer": null, "parents": [{"sha": "e048778fca6e205cf73e02a3a4d2d8df0f54a614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e048778fca6e205cf73e02a3a4d2d8df0f54a614", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e048778fca6e205cf73e02a3a4d2d8df0f54a614"}], "stats": {"total": 23, "additions": 16, "deletions": 7}, "files": [{"sha": "91d57148fdaec3b99f5034244a024f2bc940343a", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11147ebea5ed7ad858ed0e403e0cd47525eb8177/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11147ebea5ed7ad858ed0e403e0cd47525eb8177/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=11147ebea5ed7ad858ed0e403e0cd47525eb8177", "patch": "@@ -1965,16 +1965,16 @@ prev_cc0_setter (insn)\n /* Try splitting insns that can be split for better scheduling.\n    PAT is the pattern which might split.\n    TRIAL is the insn providing PAT.\n-   BACKWARDS is non-zero if we are scanning insns from last to first.\n+   LAST is non-zero if we should return the last insn of the sequence produced.\n \n    If this routine succeeds in splitting, it returns the first or last\n-   replacement insn depending on the value of BACKWARDS.  Otherwise, it\n+   replacement insn depending on the value of LAST.  Otherwise, it\n    returns TRIAL.  If the insn to be returned can be split, it will be.  */\n \n rtx\n-try_split (pat, trial, backwards)\n+try_split (pat, trial, last)\n      rtx pat, trial;\n-     int backwards;\n+     int last;\n {\n   rtx before = PREV_INSN (trial);\n   rtx after = NEXT_INSN (trial);\n@@ -2017,6 +2017,14 @@ try_split (pat, trial, backwards)\n \t  delete_insn (trial);\n \t  if (has_barrier)\n \t    emit_barrier_after (tem);\n+\n+\t  /* Recursively call try_split for each new insn created; by the\n+\t     time control returns here that insn will be fully split, so\n+\t     set LAST and continue from the insn after the one returned.\n+\t     We can't use next_active_insn here since AFTER may be a note. */\n+\t  for (tem = NEXT_INSN (before); tem != after;\n+\t       tem = NEXT_INSN (tem))\n+\t    tem = try_split (PATTERN (tem), tem, 1);\n \t}\n       /* Avoid infinite loop if the result matches the original pattern.  */\n       else if (rtx_equal_p (seq, pat))\n@@ -2025,11 +2033,12 @@ try_split (pat, trial, backwards)\n \t{\n \t  PATTERN (trial) = seq;\n \t  INSN_CODE (trial) = -1;\n+\t  try_split (seq, trial, last);\n \t}\n \n-      /* Set TEM to the insn we should return.  */\n-      tem = backwards ? prev_active_insn (after) : next_active_insn (before);\n-      return try_split (PATTERN (tem), tem, backwards);\n+      /* Return either the first or the last insn, depending on which was\n+\t requested.  */\n+      return last ? prev_active_insn (after) : next_active_insn (before);\n     }\n \n   return trial;"}]}