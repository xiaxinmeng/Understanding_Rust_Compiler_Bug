{"sha": "ad9eef11dfc362261d3de4231eab7eac352d7f9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ5ZWVmMTFkZmMzNjIyNjFkM2RlNDIzMWVhYjdlYWMzNTJkN2Y5Zg==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-12T22:00:01Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-12T22:00:01Z"}, "message": "Makefile.in (C_SOURCE_FILES): Added methods.c.\n\n2010-10-12  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * Makefile.in (C_SOURCE_FILES): Added methods.c.\n        * encoding.c (method_getNumberOfArguments): New.\n        (method_get_number_of_arguments): Call\n        method_getNumberOfArguments.\n        * ivars.c (ivar_getName): Check for NULL variable argument.\n        (ivar_getOffset): Check for NULL variable argument.\n        (ivar_getTypeEncoding): Check for NULL variable argument.\n        (class_copyIvarList): New.\n        * methods.c: New.\n        * protocols.c (class_copyProtocolList): Check for Nil class_\n        argument.\n        * sendmsg.c: Use 'struct objc_method *' instead of Method_t, and\n        'struct objc_method_list *' instead of MethodList_t.\n        (class_getMethodImplementation): New.\n        (class_respondsToSelector): New.\n        (class_getInstanceMethod): New.\n        (class_getClassMethod): New.\n        * objc/runtime.h: Updated comments.\n        (class_copyIvarList): New.\n        (class_getInstanceMethod): New.\n        (class_getClassMethod): New.\n        (class_getMethodImplementation): New.\n        (class_respondsToSelector): New.\n        (method_getName): New.\n        (method_getImplementation): New.\n        (method_getTypeEncoding): New.\n        (class_copyMethodList): New.\n        (method_getNumberOfArguments): New.\n\nFrom-SVN: r165400", "tree": {"sha": "c1e1a95aab3eeed0bec8d3d90946e13dff607e7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1e1a95aab3eeed0bec8d3d90946e13dff607e7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad9eef11dfc362261d3de4231eab7eac352d7f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad9eef11dfc362261d3de4231eab7eac352d7f9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad9eef11dfc362261d3de4231eab7eac352d7f9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad9eef11dfc362261d3de4231eab7eac352d7f9f/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d761137fee594ee61ab14d121bdac9e051d67b07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d761137fee594ee61ab14d121bdac9e051d67b07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d761137fee594ee61ab14d121bdac9e051d67b07"}], "stats": {"total": 444, "additions": 407, "deletions": 37}, "files": [{"sha": "300bb3e7e20ab80712035a47a6c155fe406e2691", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=ad9eef11dfc362261d3de4231eab7eac352d7f9f", "patch": "@@ -1,3 +1,34 @@\n+2010-10-12  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* Makefile.in (C_SOURCE_FILES): Added methods.c.\n+\t* encoding.c (method_getNumberOfArguments): New.\n+\t(method_get_number_of_arguments): Call\n+\tmethod_getNumberOfArguments.\n+\t* ivars.c (ivar_getName): Check for NULL variable argument.\n+\t(ivar_getOffset): Check for NULL variable argument.\n+\t(ivar_getTypeEncoding): Check for NULL variable argument.\n+\t(class_copyIvarList): New.\n+\t* methods.c: New.\n+\t* protocols.c (class_copyProtocolList): Check for Nil class_\n+\targument.\n+\t* sendmsg.c: Use 'struct objc_method *' instead of Method_t, and\n+\t'struct objc_method_list *' instead of MethodList_t.\n+\t(class_getMethodImplementation): New.\n+\t(class_respondsToSelector): New.\n+\t(class_getInstanceMethod): New.\n+\t(class_getClassMethod): New.\n+\t* objc/runtime.h: Updated comments.\n+\t(class_copyIvarList): New.\n+\t(class_getInstanceMethod): New.\n+\t(class_getClassMethod): New.\n+\t(class_getMethodImplementation): New.\n+\t(class_respondsToSelector): New.\n+\t(method_getName): New.\n+\t(method_getImplementation): New.\n+\t(method_getTypeEncoding): New.\n+\t(class_copyMethodList): New.\n+\t(method_getNumberOfArguments): New.\n+\t\n 2010-10-12  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* class.c: Include objc/runtime.h and objc-private/module-abi-8.h"}, {"sha": "b644b3f48321100ed53e7dfa0b5afc5811d9f427", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=ad9eef11dfc362261d3de4231eab7eac352d7f9f", "patch": "@@ -173,6 +173,7 @@ C_SOURCE_FILES = \\\n    init.c \\\n    ivars.c \\\n    memory.c \\\n+   methods.c \\\n    nil_method.c \\\n    objc-foreach.c \\\n    objc-sync.c \\"}, {"sha": "b30389ee0e495c3977e236846b3cd0fe072f2a3b", "filename": "libobjc/encoding.c", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fencoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fencoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fencoding.c?ref=ad9eef11dfc362261d3de4231eab7eac352d7f9f", "patch": "@@ -797,22 +797,39 @@ objc_skip_argspec (const char *type)\n   return type;\n }\n \n-/*\n-  Return the number of arguments that the method MTH expects.\n-  Note that all methods need two implicit arguments `self' and\n-  `_cmd'.\n-*/\n-int\n-method_get_number_of_arguments (struct objc_method *mth)\n+unsigned int\n+method_getNumberOfArguments (struct objc_method *method)\n {\n-  int i = 0;\n-  const char *type = mth->method_types;\n-  while (*type)\n+  if (method == NULL)\n+    return 0;\n+  else\n     {\n-      type = objc_skip_argspec (type);\n-      i += 1;\n+      unsigned int i = 0;\n+      const char *type = method->method_types;\n+      while (*type)\n+\t{\n+\t  type = objc_skip_argspec (type);\n+\t  i += 1;\n+\t}\n+\n+      if (i == 0)\n+\t{\n+\t  /* This could only happen if method_types is invalid; in\n+\t     that case, return 0.  */\n+\t  return 0;\n+\t}\n+      else\n+\t{\n+\t  /* Remove the return type.  */\n+\t  return (i - 1);\n+\t}\n     }\n-  return i - 1;\n+}\n+\n+int\n+method_get_number_of_arguments (struct objc_method *mth)\n+{\n+  return method_getNumberOfArguments (mth);\n }\n \n /*"}, {"sha": "0dbb45b676af0bafab5949b7cd57ea744d3a8d17", "filename": "libobjc/ivars.c", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fivars.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fivars.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fivars.c?ref=ad9eef11dfc362261d3de4231eab7eac352d7f9f", "patch": "@@ -26,8 +26,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"objc/runtime.h\"\n #include \"objc-private/module-abi-8.h\" /* For runtime structures  */\n #include \"objc/thr.h\"\n-#include \"objc-private/runtime.h\"\t\t/* the kitchen sink */\n-#include <string.h> /* For strcmp */\n+#include \"objc-private/runtime.h\"      /* the kitchen sink */\n+#include <string.h>                    /* For strcmp */\n \n struct objc_ivar *\n class_getInstanceVariable (Class class_, const char *name)\n@@ -157,15 +157,74 @@ void object_setIvar (id object, struct objc_ivar * variable, id value)\n \n const char * ivar_getName (struct objc_ivar * variable)\n {\n+  if (variable == NULL)\n+    return NULL;\n+\n   return variable->ivar_name;\n }\n \n ptrdiff_t ivar_getOffset (struct objc_ivar * variable)\n {\n+  if (variable == NULL)\n+    return 0;\n+\n   return (ptrdiff_t)(variable->ivar_offset);\n }\n \n const char * ivar_getTypeEncoding (struct objc_ivar * variable)\n {\n+  if (variable == NULL)\n+    return NULL;\n+\n   return variable->ivar_type;\n }\n+\n+struct objc_ivar ** class_copyIvarList (Class class_, unsigned int *numberOfReturnedIvars)\n+{\n+  unsigned int count = 0;\n+  struct objc_ivar **returnValue = NULL;\n+  struct objc_ivar_list* ivar_list;\n+\n+  if (class_ == Nil)\n+    {\n+      if (numberOfReturnedIvars)\n+\t*numberOfReturnedIvars = 0;\n+      return NULL;\n+    }\n+\n+  /* TODO: We do not need to lock the runtime mutex if the class has\n+     been registered with the runtime, since the instance variable\n+     list can not change after the class is registered.  The only case\n+     where the lock may be useful if the class is still being created\n+     using objc_allocateClassPair(), but has not been registered using\n+     objc_registerClassPair() yet.  I'm not even sure that is\n+     allowed.  */\n+  objc_mutex_lock (__objc_runtime_mutex);\n+\n+  /* Count how many ivars we have.  */\n+  ivar_list = class_->ivars;\n+  count = ivar_list->ivar_count;\n+\n+  if (count != 0)\n+    {\n+      unsigned int i = 0;\n+      \n+      /* Allocate enough memory to hold them.  */\n+      returnValue = (struct objc_ivar **)(malloc (sizeof (struct objc_ivar *) * (count + 1)));\n+      \n+      /* Copy the ivars.  */\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  returnValue[i] = &(ivar_list->ivar_list[i]);\n+\t}\n+      \n+      returnValue[i] = NULL;\n+    }\n+  \n+  objc_mutex_unlock (__objc_runtime_mutex);\n+\n+  if (numberOfReturnedIvars)\n+    *numberOfReturnedIvars = count;\n+\n+  return returnValue;\n+}"}, {"sha": "c6236a100e7e1509440ad1c5410a19639a078f83", "filename": "libobjc/methods.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fmethods.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fmethods.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fmethods.c?ref=ad9eef11dfc362261d3de4231eab7eac352d7f9f", "patch": "@@ -0,0 +1,114 @@\n+/* GNU Objective C Runtime method related functions.\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Nicola Pero\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 3, or (at your option) any later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"objc-private/common.h\"\n+#include \"objc/runtime.h\"\n+#include \"objc-private/module-abi-8.h\" /* For runtime structures.   */\n+#include \"objc/thr.h\"\n+#include \"objc-private/runtime.h\"      /* For __objc_runtime_mutex.  */\n+#include <stdlib.h>                    /* For malloc.  */\n+\n+SEL method_getName (struct objc_method * method)\n+{\n+  if (method == NULL)\n+    return NULL;\n+\n+  return method->method_name;\n+}\n+\n+const char * method_getTypeEncoding (struct objc_method * method)\n+{\n+  if (method == NULL)\n+    return NULL;\n+\n+  return method->method_types;\n+}\n+\n+IMP method_getImplementation (struct objc_method * method)\n+{\n+  if (method == NULL)\n+    return NULL;\n+\n+  return method->method_imp;\n+}\n+\n+struct objc_method ** class_copyMethodList (Class class_, unsigned int *numberOfReturnedMethods)\n+{\n+  unsigned int count = 0;\n+  struct objc_method **returnValue = NULL;\n+  struct objc_method_list* method_list;\n+\n+  if (class_ == Nil)\n+    {\n+      if (numberOfReturnedMethods)\n+\t*numberOfReturnedMethods = 0;\n+      return NULL;\n+    }\n+\n+  /* Lock the runtime mutex because the class methods may be\n+     concurrently modified.  */\n+  objc_mutex_lock (__objc_runtime_mutex);\n+\n+  /* Count how many methods we have.  */\n+  method_list = class_->methods;\n+\n+  while (method_list)\n+    {\n+      count = count + method_list->method_count;\n+      method_list = method_list->method_next;\n+    }\n+\n+  if (count != 0)\n+    {\n+      unsigned int i = 0;\n+      \n+      /* Allocate enough memory to hold them.  */\n+      returnValue \n+\t= (struct objc_method **)(malloc (sizeof (struct objc_method *) \n+\t\t\t\t\t  * (count + 1)));\n+      \n+      /* Copy the methods.  */\n+      method_list = class_->methods;\n+      \n+      while (method_list)\n+\t{\n+\t  int j;\n+\t  for (j = 0; j < method_list->method_count; j++)\n+\t    {\n+\t      returnValue[i] = &(method_list->method_list[j]);\n+\t      i++;\n+\t    }\n+\t  method_list = method_list->method_next;\n+\t}\n+      \n+      returnValue[i] = NULL;\n+    }\n+\n+  objc_mutex_unlock (__objc_runtime_mutex);\n+\n+  if (numberOfReturnedMethods)\n+    *numberOfReturnedMethods = count;\n+\n+  return returnValue;\n+}"}, {"sha": "a11d283586f7e14df1a2179176c57af6818f1aa0", "filename": "libobjc/objc/runtime.h", "status": "modified", "additions": 92, "deletions": 3, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fruntime.h?ref=ad9eef11dfc362261d3de4231eab7eac352d7f9f", "patch": "@@ -284,16 +284,27 @@ objc_EXPORT id object_getIvar (id object, Ivar variable);\n    object_setInstanceVariable.  */\n objc_EXPORT void object_setIvar (id object, Ivar variable, id value);\n \n-/* Return the name of the instance variable.  */\n+/* Return the name of the instance variable.  Return NULL if\n+   'variable' is NULL.  */\n objc_EXPORT const char * ivar_getName (Ivar variable);\n \n /* Return the offset of the instance variable from the start of the\n-   object data.  */\n+   object data.  Return 0 if 'variable' is NULL.  */\n objc_EXPORT ptrdiff_t ivar_getOffset (Ivar variable);\n \n-/* Return the type encoding of the variable.  */\n+/* Return the type encoding of the variable.  Return NULL if\n+   'variable' is NULL.  */\n objc_EXPORT const char * ivar_getTypeEncoding (Ivar variable);\n \n+/* Return all the instance variables of the class.  The return value\n+   of the function is a pointer to an area, allocated with malloc(),\n+   that contains all the instance variables of the class.  It does not\n+   include instance variables of superclasses.  The list is terminated\n+   by NULL.  Optionally, if you pass a non-NULL\n+   'numberOfReturnedIvars' pointer, the unsigned int that it points to\n+   will be filled with the number of instance variables returned.  */\n+objc_EXPORT Ivar * class_copyIvarList (Class class_, unsigned int *numberOfReturnedIvars);\n+\n \n /** Implementation: the following functions are in class.c.  */\n \n@@ -412,6 +423,84 @@ objc_EXPORT void class_setVersion (Class class_, int version);\n objc_EXPORT size_t class_getInstanceSize (Class class_);\n \n \n+/** Implementation: the following functions are in sendmsg.c.  */\n+\n+/* Return the instance method with selector 'selector' of class\n+   'class_', or NULL if the class (or one of its superclasses) does\n+   not implement the method.  Return NULL if class_ is Nil or selector\n+   is NULL.  */\n+objc_EXPORT Method class_getInstanceMethod (Class class_, SEL selector);\n+\n+/* Return the class method with selector 'selector' of class 'class_',\n+   or NULL if the class (or one of its superclasses) does not\n+   implement the method.  Return NULL if class_ is Nil or selector is\n+   NULL.  */\n+objc_EXPORT Method class_getClassMethod (Class class_, SEL selector);\n+\n+/* Return the IMP (pointer to the function implementing a method) for\n+   the instance method with selector 'selector' in class 'class_'.\n+   This is the same routine that is used while messaging, and should\n+   be very fast.  Note that you most likely would need to cast the\n+   return function pointer to a function pointer with the appropriate\n+   arguments and return type before calling it.  To get a class\n+   method, you can pass the meta-class as the class_ argument (ie, use\n+   class_getMethodImplementation (object_getClass (class_),\n+   selector)).  Return NULL if class_ is Nil or selector is NULL.  */\n+objc_EXPORT IMP class_getMethodImplementation (Class class_, SEL selector);\n+\n+/* Compatibility Note: the Apple/NeXT runtime has the function\n+   class_getMethodImplementation_stret () which currently does not\n+   exist on the GNU runtime because the messaging implementation is\n+   different.  */\n+\n+/* Return YES if class 'class_' has an instance method implementing\n+   selector 'selector', and NO if not.  Return NO if class_ is Nil or\n+   selector is NULL.  If you need to check a class method, use the\n+   meta-class as the class_ argument (ie, use class_respondsToSelector\n+   (object_getClass (class_), selector)).  */\n+objc_EXPORT BOOL class_respondsToSelector (Class class_, SEL selector);\n+\n+\n+/** Implementation: the following functions are in methods.c.  */\n+\n+/* Return the selector for method 'method'.  Return NULL if 'method'\n+   is NULL.\n+\n+   This function is misnamed; it should be called\n+   'method_getSelector'.  To get the actual name, get the selector,\n+   then the name from the selector (ie, use sel_getName\n+   (method_getName (method))).  */\n+objc_EXPORT SEL method_getName (Method method);\n+\n+/* Return the IMP of the method.  Return NULL if 'method' is NULL.  */\n+objc_EXPORT IMP method_getImplementation (Method method);\n+\n+/* Return the type encoding of the method.  Return NULL if 'method' is\n+   NULL.  */\n+objc_EXPORT const char * method_getTypeEncoding (Method method);\n+\n+/* Return all the instance methods of the class.  The return value of\n+   the function is a pointer to an area, allocated with malloc(), that\n+   contains all the instance methods of the class.  It does not\n+   include instance methods of superclasses.  The list is terminated\n+   by NULL.  Optionally, if you pass a non-NULL\n+   'numberOfReturnedMethods' pointer, the unsigned int that it points\n+   to will be filled with the number of instance methods returned.  To\n+   get the list of class methods, pass the meta-class in the 'class_'\n+   argument, (ie, use class_copyMethodList (object_getClass (class_),\n+   &numberOfReturnedMethods)).  */\n+objc_EXPORT Method * class_copyMethodList (Class class_, unsigned int *numberOfReturnedMethods);\n+\n+\n+/** Implementation: the following functions are in encoding.c.  */\n+\n+/* Return the number of arguments that the method 'method' expects.\n+   Note that all methods need two implicit arguments ('self' for the\n+   receiver, and '_cmd' for the selector).  Return 0 if 'method' is\n+   NULL.  */\n+objc_EXPORT unsigned int method_getNumberOfArguments (Method method);\n+\n+\n /** Implementation: the following functions are in protocols.c.  */\n \n /* Return the protocol with name 'name', or nil if it the protocol is"}, {"sha": "bc714ae63ae0bbecd4bdfdec483721a2936d403d", "filename": "libobjc/protocols.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fprotocols.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fprotocols.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fprotocols.c?ref=ad9eef11dfc362261d3de4231eab7eac352d7f9f", "patch": "@@ -211,6 +211,13 @@ class_copyProtocolList (Class class_, unsigned int *numberOfReturnedProtocols)\n   Protocol **returnValue = NULL;\n   struct objc_protocol_list* proto_list;\n \n+  if (class_ == Nil)\n+    {\n+      if (numberOfReturnedProtocols)\n+\t*numberOfReturnedProtocols = 0;\n+      return NULL;\n+    }\n+\n   /* Lock the runtime mutex because the class protocols may be\n      concurrently modified.  */\n   objc_mutex_lock (__objc_runtime_mutex);"}, {"sha": "d68e3040f4f33edbda11facfe51a7293b54c1cd8", "filename": "libobjc/sendmsg.c", "status": "modified", "additions": 71, "deletions": 19, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9eef11dfc362261d3de4231eab7eac352d7f9f/libobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsendmsg.c?ref=ad9eef11dfc362261d3de4231eab7eac352d7f9f", "patch": "@@ -1,6 +1,6 @@\n /* GNU Objective C Runtime message lookup \n    Copyright (C) 1993, 1995, 1996, 1997, 1998,\n-   2001, 2002, 2004, 2009 Free Software Foundation, Inc.\n+   2001, 2002, 2004, 2009, 2010 Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup\n \n This file is part of GCC.\n@@ -91,8 +91,8 @@ static __big\n static id\n #endif\n __objc_block_forward (id, SEL, ...);\n-static Method_t search_for_method_in_hierarchy (Class class, SEL sel);\n-Method_t search_for_method_in_list (MethodList_t list, SEL op);\n+static struct objc_method * search_for_method_in_hierarchy (Class class, SEL sel);\n+struct objc_method * search_for_method_in_list (struct objc_method_list * list, SEL op);\n id nil_method (id, SEL);\n \n /* Given a selector, return the proper forwarding implementation. */\n@@ -193,11 +193,22 @@ get_imp (Class class, SEL sel)\n   return res;\n }\n \n+/* The new name of get_imp().  */\n+IMP\n+class_getMethodImplementation (Class class_, SEL selector)\n+{\n+  if (class_ == Nil  ||  selector == NULL)\n+    return NULL;\n+\n+  /* get_imp is inlined, so we're good.  */\n+  return get_imp (class_, selector);\n+}\n+\n /* Given a method, return its implementation.  */\n IMP\n-method_get_imp (Method_t method)\n+method_get_imp (struct objc_method * method)\n {\n-  return (method != (Method_t)0) ? method->method_imp : (IMP)0;\n+  return (method != (struct objc_method *)0) ? method->method_imp : (IMP)0;\n }\n \n /* Query if an object can respond to a selector, returns YES if the\n@@ -225,6 +236,30 @@ __objc_responds_to (id object, SEL sel)\n   return (res != 0);\n }\n \n+BOOL\n+class_respondsToSelector (Class class_, SEL selector)\n+{\n+  void *res;\n+\n+  if (class_ == Nil  ||  selector == NULL)\n+    return NO;\n+\n+  /* Install dispatch table if need be */\n+  if (class_->dtable == __objc_uninstalled_dtable)\n+    {\n+      objc_mutex_lock (__objc_runtime_mutex);\n+      if (class_->dtable == __objc_uninstalled_dtable)\n+\t{\n+\t  __objc_install_dispatch_table_for_class (class_);\n+\t}\n+      objc_mutex_unlock (__objc_runtime_mutex);\n+    }\n+\n+  /* Get the method from the dispatch table */\n+  res = sarray_get_safe (class_->dtable, (size_t) selector->sel_id);\n+  return (res != 0);\n+}\n+\n /* This is the lookup function.  All entries in the table are either a \n    valid method *or* zero.  If zero then either the dispatch table\n    needs to be installed or it doesn't exist and forwarding is attempted. */\n@@ -374,11 +409,11 @@ __objc_send_initialize (Class class)\n       {\n \tSEL \t     op = sel_register_name (\"initialize\");\n \tIMP\t     imp = 0;\n-        MethodList_t method_list = class->class_pointer->methods;\n+        struct objc_method_list * method_list = class->class_pointer->methods;\n \n         while (method_list) {\n \t  int i;\n-          Method_t method;\n+          struct objc_method * method;\n \n           for (i = 0; i < method_list->method_count; i++) {\n \t    method = &(method_list->method_list[i]);\n@@ -409,7 +444,7 @@ __objc_send_initialize (Class class)\n    method nothing is guaranteed about what method will be used.\n    Assumes that __objc_runtime_mutex is locked down. */\n static void\n-__objc_install_methods_in_dtable (Class class, MethodList_t method_list)\n+__objc_install_methods_in_dtable (Class class, struct objc_method_list * method_list)\n {\n   int i;\n \n@@ -421,7 +456,7 @@ __objc_install_methods_in_dtable (Class class, MethodList_t method_list)\n \n   for (i = 0; i < method_list->method_count; i++)\n     {\n-      Method_t method = &(method_list->method_list[i]);\n+      struct objc_method * method = &(method_list->method_list[i]);\n       sarray_at_put_safe (class->dtable,\n \t\t\t  (sidx) method->method_name->sel_id,\n \t\t\t  method->method_imp);\n@@ -492,7 +527,7 @@ __objc_update_dispatch_table_for_class (Class class)\n    methods installed right away, and their selectors are made into\n    SEL's by the function __objc_register_selectors_from_class. */\n void\n-class_add_method_list (Class class, MethodList_t list)\n+class_add_method_list (Class class, struct objc_method_list * list)\n {\n   /* Passing of a linked list is not allowed.  Do multiple calls.  */\n   assert (! list->method_next);\n@@ -507,27 +542,44 @@ class_add_method_list (Class class, MethodList_t list)\n   __objc_update_dispatch_table_for_class (class);\n }\n \n-Method_t\n+struct objc_method *\n class_get_instance_method (Class class, SEL op)\n {\n   return search_for_method_in_hierarchy (class, op);\n }\n \n-Method_t\n+struct objc_method *\n class_get_class_method (MetaClass class, SEL op)\n {\n   return search_for_method_in_hierarchy (class, op);\n }\n \n+struct objc_method *\n+class_getInstanceMethod (Class class_, SEL selector)\n+{\n+  if (class_ == Nil  ||  selector == NULL)\n+    return NULL;\n+\n+  return search_for_method_in_hierarchy (class_, selector);\n+}\n+\n+struct objc_method *\n+class_getClassMethod (Class class_, SEL selector)\n+{\n+  if (class_ == Nil  ||  selector == NULL)\n+    return NULL;\n+  \n+  return search_for_method_in_hierarchy (class_->class_pointer, \n+\t\t\t\t\t selector);\n+}\n \n /* Search for a method starting from the current class up its hierarchy.\n    Return a pointer to the method's method structure if found.  NULL\n    otherwise. */   \n-\n-static Method_t\n+static struct objc_method *\n search_for_method_in_hierarchy (Class cls, SEL sel)\n {\n-  Method_t method = NULL;\n+  struct objc_method * method = NULL;\n   Class class;\n \n   if (! sel_is_mapped (sel))\n@@ -546,10 +598,10 @@ search_for_method_in_hierarchy (Class cls, SEL sel)\n /* Given a linked list of method and a method's name.  Search for the named\n    method's method structure.  Return a pointer to the method's method\n    structure if found.  NULL otherwise. */  \n-Method_t\n-search_for_method_in_list (MethodList_t list, SEL op)\n+struct objc_method *\n+search_for_method_in_list (struct objc_method_list * list, SEL op)\n {\n-  MethodList_t method_list = list;\n+  struct objc_method_list * method_list = list;\n \n   if (! sel_is_mapped (op))\n     return NULL;\n@@ -562,7 +614,7 @@ search_for_method_in_list (MethodList_t list, SEL op)\n       /* Search the method list.  */\n       for (i = 0; i < method_list->method_count; ++i)\n         {\n-          Method_t method = &method_list->method_list[i];\n+          struct objc_method * method = &method_list->method_list[i];\n \n           if (method->method_name)\n             if (method->method_name->sel_id == op->sel_id)"}]}