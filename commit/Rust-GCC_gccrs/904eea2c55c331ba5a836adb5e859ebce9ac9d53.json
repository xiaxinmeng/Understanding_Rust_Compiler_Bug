{"sha": "904eea2c55c331ba5a836adb5e859ebce9ac9d53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA0ZWVhMmM1NWMzMzFiYTVhODM2YWRiNWU4NTllYmNlOWFjOWQ1Mw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2012-03-04T18:54:26Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-03-04T18:54:26Z"}, "message": "constraints.md (Ya): New internal constraint.\n\n\t* config/i386/constraints.md (Ya): New internal constraint.\n\t* config/i386/i386.md (zero_extendsidi2): Remove expansion.\n\t(*zero_extendsidi2_rex64): Add x,x alternative.\n\t(*zero_extendsidi2): Ditto.  Add o,0 alternative.\n\tRemove flags reg clobber.  Adjust corresponding splits.\n\t(zero_extend<mode>si2): Macroize expander from zero_extendhisi2 and\n\tzero_extendqisi2 expanders using SWI12 mode iterator.\n\t(zero_extend<mode>si2_and): Macroize insn from\n\tzero_extendhisi2_and and zero_extendqisi2_and.  Merge corresponding\n\tsplitters.\n\t(*zero_extend<mode>si2):  Macroize insn from\n\t*zero_extendhisi2_movzbl and *zero_extendqisi2_movzbl.\n\t(*zero_extend*2_movzbl_and): Remove insn patterns.\n\t(zero_extendqihi2_and): Merge corresponding splitter.\n\t(*zero_extendqihi2): Rename from *zero_extendqihi2_movzbl.\n\t(*zero_extend*2_movzbl_and): Remove insn patterns.\n\t(*anddi_1): Split TYPE_IMOVX instructions.\n\t(*andsi_1): Use Ya for alternative 2.  Split TYPE_IMOVX instructions.\n\t(*andhi_1): Ditto.\n\t(and->zext splitter): Add splitter pattern.\n\t(zero extend with andsi3 splitter): Adjust zero_extend pattern.\n\nFrom-SVN: r184891", "tree": {"sha": "a9b085983c2d89253ef49e8584d287926a4f06a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9b085983c2d89253ef49e8584d287926a4f06a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/904eea2c55c331ba5a836adb5e859ebce9ac9d53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/904eea2c55c331ba5a836adb5e859ebce9ac9d53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/904eea2c55c331ba5a836adb5e859ebce9ac9d53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/904eea2c55c331ba5a836adb5e859ebce9ac9d53/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d4ce3635686859cf75cee8ece6151b7dc4910028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4ce3635686859cf75cee8ece6151b7dc4910028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4ce3635686859cf75cee8ece6151b7dc4910028"}], "stats": {"total": 320, "additions": 164, "deletions": 156}, "files": [{"sha": "c34b1c0079573c0b1dc14487b1b325f1f14c0878", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904eea2c55c331ba5a836adb5e859ebce9ac9d53/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904eea2c55c331ba5a836adb5e859ebce9ac9d53/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=904eea2c55c331ba5a836adb5e859ebce9ac9d53", "patch": "@@ -1,3 +1,27 @@\n+2012-03-04  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/constraints.md (Ya): New internal constraint.\n+\t* config/i386/i386.md (zero_extendsidi2): Remove expansion.\n+\t(*zero_extendsidi2_rex64): Add x,x alternative.\n+\t(*zero_extendsidi2): Ditto.  Add o,0 alternative.\n+\tRemove flags reg clobber.  Adjust corresponding splits.\n+\t(zero_extend<mode>si2): Macroize expander from zero_extendhisi2 and\n+\tzero_extendqisi2 expanders using SWI12 mode iterator.\n+\t(zero_extend<mode>si2_and): Macroize insn from\n+\tzero_extendhisi2_and and zero_extendqisi2_and.  Merge corresponding\n+\tsplitters.\n+\t(*zero_extend<mode>si2):  Macroize insn from\n+\t*zero_extendhisi2_movzbl and *zero_extendqisi2_movzbl.\n+\t(*zero_extend*2_movzbl_and): Remove insn patterns.\n+\t(zero_extendqihi2_and): Merge corresponding splitter.\n+\t(*zero_extendqihi2): Rename from *zero_extendqihi2_movzbl.\n+\t(*zero_extend*2_movzbl_and): Remove insn patterns.\n+\t(*anddi_1): Split TYPE_IMOVX instructions.\n+\t(*andsi_1): Use Ya for alternative 2.  Split TYPE_IMOVX instructions.\n+\t(*andhi_1): Ditto.\n+\t(and->zext splitter): Add splitter pattern.\n+\t(zero extend with andsi3 splitter): Adjust zero_extend pattern.\n+\n 2012-03-04  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/invoke.texi (C++ Dialect Options): Minor copy-edits to\n@@ -58,13 +82,13 @@\n \t(atomic_compare_and_swap<mode>_soft): Likewise.\n \n 2012-03-02  Oleg Endo  <olegendo@gcc.gnu.org>\n- \n+\n \tPR target/31640\n \t* config/sh/sh.h (LOOP_ALIGN): Move logic to sh_loop_align.\n \t* config/sh/sh.c: Update copyright notice dates.\n \t(sh_loop_align): Add logic from LOOP_ALIGN.  Don't disable loop\n \talignment for TARGET_HARD_SH4.\n-\t(sh_option_override): Reduce default function alignment.  Set \n+\t(sh_option_override): Reduce default function alignment.  Set\n \tloop alignment to 4 bytes when not optimizing for size.\n \n 2012-03-02  Maxim Kuvyrkov  <maxim@codesourcery.com>"}, {"sha": "9537d934ade2c741875530a7f66be0ff538e0d85", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904eea2c55c331ba5a836adb5e859ebce9ac9d53/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904eea2c55c331ba5a836adb5e859ebce9ac9d53/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=904eea2c55c331ba5a836adb5e859ebce9ac9d53", "patch": "@@ -89,6 +89,7 @@\n ;;  z\tFirst SSE register.\n ;;  i\tSSE2 inter-unit moves enabled\n ;;  m\tMMX inter-unit moves enabled\n+;;  a\tInteger register when zero extensions with AND are disabled\n ;;  p\tInteger register when TARGET_PARTIAL_REG_STALL is disabled\n ;;  d\tInteger register when integer DFmode moves are enabled\n ;;  x\tInteger register when integer XFmode moves are enabled\n@@ -108,6 +109,11 @@\n  \"TARGET_PARTIAL_REG_STALL ? NO_REGS : GENERAL_REGS\"\n  \"@internal Any integer register when TARGET_PARTIAL_REG_STALL is disabled.\")\n \n+(define_register_constraint \"Ya\"\n+ \"TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun)\n+  ? NO_REGS : GENERAL_REGS\"\n+ \"@internal Any integer register when zero extensions with AND are disabled.\")\n+\n (define_register_constraint \"Yd\"\n  \"(TARGET_64BIT\n    || (TARGET_INTEGER_DFMODE_MOVES && optimize_function_for_speed_p (cfun)))"}, {"sha": "bfbf5bf14bcd4a8240eebc487fd8991103cd1886", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 132, "deletions": 154, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904eea2c55c331ba5a836adb5e859ebce9ac9d53/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904eea2c55c331ba5a836adb5e859ebce9ac9d53/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=904eea2c55c331ba5a836adb5e859ebce9ac9d53", "patch": "@@ -3371,20 +3371,14 @@\n \n (define_expand \"zero_extendsidi2\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-{\n-  if (!TARGET_64BIT)\n-    {\n-      emit_insn (gen_zero_extendsidi2_1 (operands[0], operands[1]));\n-      DONE;\n-    }\n-})\n+\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))])\n \n (define_insn \"*zero_extendsidi2_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\"  \"=r,o,?*Ym,?*y,?*Yi,*x\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\"\n+\t\t\t\"=r,o,?*Ym,?*y,?*Yi,!*x\")\n \t(zero_extend:DI\n-\t (match_operand:SI 1 \"nonimmediate_operand\" \"rm,0,r   ,m  ,r   ,m\")))]\n+\t (match_operand:SI 1 \"nonimmediate_operand\"\n+\t        \t\"rm,0,r   ,m  ,r   ,m*x\")))]\n   \"TARGET_64BIT\"\n   \"@\n    mov{l}\\t{%1, %k0|%k0, %1}\n@@ -3393,24 +3387,17 @@\n    movd\\t{%1, %0|%0, %1}\n    %vmovd\\t{%1, %0|%0, %1}\n    %vmovd\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"imovx,imov,mmxmov,mmxmov,ssemov,ssemov\")\n+  [(set_attr \"isa\" \"*,*,*,*,*,sse2\")\n+   (set_attr \"type\" \"imovx,multi,mmxmov,mmxmov,ssemov,ssemov\")\n    (set_attr \"prefix\" \"orig,*,orig,orig,maybe_vex,maybe_vex\")\n    (set_attr \"prefix_0f\" \"0,*,*,*,*,*\")\n-   (set_attr \"mode\" \"SI,DI,DI,DI,TI,TI\")])\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"memory_operand\" \"\")\n-     \t(zero_extend:DI (match_dup 0)))]\n-  \"TARGET_64BIT\"\n-  [(set (match_dup 4) (const_int 0))]\n-  \"split_double_mode (DImode, &operands[0], 1, &operands[3], &operands[4]);\")\n+   (set_attr \"mode\" \"SI,SI,DI,DI,TI,TI\")])\n \n-;; %%% Kill me once multi-word ops are sane.\n-(define_insn \"zero_extendsidi2_1\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,?r,?o,?*Ym,?*y,?*Yi,*x\")\n-\t(zero_extend:DI\n-\t (match_operand:SI 1 \"nonimmediate_operand\" \"0,rm,r ,r   ,m  ,r   ,m\")))\n-   (clobber (reg:CC FLAGS_REG))]\n+(define_insn \"*zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\"\n+\t\t\t\"=ro,?r,?o,?*Ym,?*y,?*Yi,!*x\")\n+\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\"\n+\t\t\t\"0  ,rm,r ,r   ,m  ,r   ,m*x\")))]\n   \"!TARGET_64BIT\"\n   \"@\n    #\n@@ -3425,20 +3412,27 @@\n    (set_attr \"prefix\" \"*,*,*,orig,orig,maybe_vex,maybe_vex\")\n    (set_attr \"mode\" \"SI,SI,SI,DI,DI,TI,TI\")])\n \n+(define_split\n+  [(set (match_operand:DI 0 \"memory_operand\" \"\")\n+     \t(zero_extend:DI (match_operand:SI 1 \"memory_operand\" \"\")))]\n+  \"reload_completed\"\n+  [(set (match_dup 4) (const_int 0))]\n+  \"split_double_mode (DImode, &operands[0], 1, &operands[3], &operands[4]);\")\n+\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n+\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))]\n   \"!TARGET_64BIT && reload_completed\n+   && !(MMX_REG_P (operands[0]) || SSE_REG_P (operands[0]))\n    && true_regnum (operands[0]) == true_regnum (operands[1])\"\n   [(set (match_dup 4) (const_int 0))]\n   \"split_double_mode (DImode, &operands[0], 1, &operands[3], &operands[4]);\")\n \n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(zero_extend:DI (match_operand:SI 1 \"general_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n+\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n   \"!TARGET_64BIT && reload_completed\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && !(MMX_REG_P (operands[0]) || SSE_REG_P (operands[0]))\"\n   [(set (match_dup 3) (match_dup 1))\n    (set (match_dup 4) (const_int 0))]\n@@ -3453,112 +3447,100 @@\n   [(set_attr \"type\" \"imovx\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_expand \"zero_extendhisi2\"\n+(define_expand \"zero_extend<mode>si2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n+\t(zero_extend:SI (match_operand:SWI12 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n {\n   if (TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun))\n     {\n-      operands[1] = force_reg (HImode, operands[1]);\n-      emit_insn (gen_zero_extendhisi2_and (operands[0], operands[1]));\n+      operands[1] = force_reg (<MODE>mode, operands[1]);\n+      emit_insn (gen_zero_extend<mode>si2_and (operands[0], operands[1]));\n       DONE;\n     }\n })\n \n-(define_insn_and_split \"zero_extendhisi2_and\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))\n+(define_insn_and_split \"zero_extend<mode>si2_and\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,?&<r>\")\n+\t(zero_extend:SI\n+\t  (match_operand:SWI12 1 \"nonimmediate_operand\" \"0,<r>m\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun)\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (const_int 65535)))\n+  [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (match_dup 2)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n+{\n+  if (true_regnum (operands[0]) != true_regnum (operands[1]))\n+    {\n+      ix86_expand_clear (operands[0]);\n+\n+      gcc_assert (!TARGET_PARTIAL_REG_STALL);\n+      emit_insn (gen_movstrict<mode>\n+\t\t  (gen_lowpart (<MODE>mode, operands[0]), operands[1]));\n+      DONE;\n+    }\n+\n+  operands[2] = GEN_INT (GET_MODE_MASK (<MODE>mode));\n+}\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*zero_extendhisi2_movzwl\"\n+(define_insn \"*zero_extend<mode>si2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"!TARGET_ZERO_EXTEND_WITH_AND\n-   || optimize_function_for_size_p (cfun)\"\n-  \"movz{wl|x}\\t{%1, %0|%0, %1}\"\n+\t(zero_extend:SI\n+\t  (match_operand:SWI12 1 \"nonimmediate_operand\" \"<r>m\")))]\n+  \"!(TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun))\"\n+  \"movz{<imodesuffix>l|x}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"imovx\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_expand \"zero_extendqi<mode>2\"\n-  [(parallel\n-    [(set (match_operand:SWI24 0 \"register_operand\" \"\")\n-\t  (zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n-     (clobber (reg:CC FLAGS_REG))])])\n+(define_expand \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+{\n+  if (TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun))\n+    {\n+      operands[1] = force_reg (QImode, operands[1]);\n+      emit_insn (gen_zero_extendqihi2_and (operands[0], operands[1]));\n+      DONE;\n+    }\n+})\n \n-(define_insn \"*zero_extendqi<mode>2_and\"\n-  [(set (match_operand:SWI24 0 \"register_operand\" \"=r,?&q\")\n-\t(zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"0,qm\")))\n+(define_insn_and_split \"zero_extendqihi2_and\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,?&q\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"0,qm\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun)\"\n   \"#\"\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-;; When source and destination does not overlap, clear destination\n-;; first and then do the movb\n-(define_split\n-  [(set (match_operand:SWI24 0 \"register_operand\" \"\")\n-\t(zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && (TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun))\n-   && ANY_QI_REG_P (operands[0])\n-   && (ANY_QI_REG_P (operands[1]) || MEM_P (operands[1]))\n-   && !reg_overlap_mentioned_p (operands[0], operands[1])\"\n-  [(set (strict_low_part (match_dup 2)) (match_dup 1))]\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (const_int 255)))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n {\n-  operands[2] = gen_lowpart (QImode, operands[0]);\n-  ix86_expand_clear (operands[0]);\n-})\n+  if (true_regnum (operands[0]) != true_regnum (operands[1]))\n+    {\n+      ix86_expand_clear (operands[0]);\n \n-(define_insn \"*zero_extendqi<mode>2_movzbl_and\"\n-  [(set (match_operand:SWI24 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"qm,0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_ZERO_EXTEND_WITH_AND || optimize_function_for_size_p (cfun)\"\n-  \"#\"\n-  [(set_attr \"type\" \"imovx,alu1\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+      gcc_assert (!TARGET_PARTIAL_REG_STALL);\n+      emit_insn (gen_movstrictqi\n+\t\t  (gen_lowpart (QImode, operands[0]), operands[1]));\n+      DONE;\n+    }\n \n-;; For the movzbl case strip only the clobber\n-(define_split\n-  [(set (match_operand:SWI24 0 \"register_operand\" \"\")\n-\t(zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && (!TARGET_ZERO_EXTEND_WITH_AND || optimize_function_for_size_p (cfun))\n-   && (!REG_P (operands[1]) || ANY_QI_REG_P (operands[1]))\"\n-  [(set (match_dup 0)\n-\t(zero_extend:SWI24 (match_dup 1)))])\n+  operands[0] = gen_lowpart (SImode, operands[0]);\n+}\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"SI\")])\n \n ; zero extend to SImode to avoid partial register stalls\n-(define_insn \"*zero_extendqi<mode>2_movzbl\"\n-  [(set (match_operand:SWI24 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))]\n-  \"reload_completed\n-   && (!TARGET_ZERO_EXTEND_WITH_AND || optimize_function_for_size_p (cfun))\"\n+(define_insn \"*zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))]\n+  \"!(TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun))\"\n   \"movz{bl|x}\\t{%1, %k0|%k0, %1}\"\n   [(set_attr \"type\" \"imovx\")\n    (set_attr \"mode\" \"SI\")])\n-\n-;; Rest is handled by single and.\n-(define_split\n-  [(set (match_operand:SWI24 0 \"register_operand\" \"\")\n-\t(zero_extend:SWI24 (match_operand:QI 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && true_regnum (operands[0]) == true_regnum (operands[1])\"\n-  [(parallel [(set (match_dup 0) (and:SWI24 (match_dup 0) (const_int 255)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n \f\n ;; Sign extension instructions\n \n@@ -7674,28 +7656,7 @@\n   switch (get_attr_type (insn))\n     {\n     case TYPE_IMOVX:\n-      {\n-\tenum machine_mode mode;\n-\n-\tgcc_assert (CONST_INT_P (operands[2]));\n-\tif (INTVAL (operands[2]) == (HOST_WIDE_INT) 0xffffffff)\n-\t  mode = SImode;\n-\telse if (INTVAL (operands[2]) == 0xffff)\n-\t  mode = HImode;\n-\telse\n-\t  {\n-\t    gcc_assert (INTVAL (operands[2]) == 0xff);\n-\t    mode = QImode;\n-\t  }\n-\n-\toperands[1] = gen_lowpart (mode, operands[1]);\n-\tif (mode == SImode)\n-\t  return \"mov{l}\\t{%1, %k0|%k0, %1}\";\n-\telse if (mode == HImode)\n-\t  return \"movz{wl|x}\\t{%1, %k0|%k0, %1}\";\n-\telse\n-\t  return \"movz{bl|x}\\t{%1, %k0|%k0, %1}\";\n-      }\n+      return \"#\";\n \n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n@@ -7717,7 +7678,7 @@\n    (set_attr \"mode\" \"SI,DI,DI,SI\")])\n \n (define_insn \"*andsi_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r,r\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r,Ya\")\n \t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,qm\")\n \t\t(match_operand:SI 2 \"x86_64_general_operand\" \"re,rm,L\")))\n    (clobber (reg:CC FLAGS_REG))]\n@@ -7726,24 +7687,7 @@\n   switch (get_attr_type (insn))\n     {\n     case TYPE_IMOVX:\n-      {\n-\tenum machine_mode mode;\n-\n-\tgcc_assert (CONST_INT_P (operands[2]));\n-        if (INTVAL (operands[2]) == 0xffff)\n-\t  mode = HImode;\n-\telse\n-\t  {\n-\t    gcc_assert (INTVAL (operands[2]) == 0xff);\n-\t    mode = QImode;\n-\t  }\n-\n-\toperands[1] = gen_lowpart (mode, operands[1]);\n-\tif (mode == HImode)\n-\t  return \"movz{wl|x}\\t{%1, %0|%0, %1}\";\n-\telse\n-\t  return \"movz{bl|x}\\t{%1, %0|%0, %1}\";\n-      }\n+      return \"#\";\n \n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n@@ -7774,7 +7718,7 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*andhi_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r,r\")\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r,Ya\")\n \t(and:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,qm\")\n \t\t(match_operand:HI 2 \"general_operand\" \"rn,rm,L\")))\n    (clobber (reg:CC FLAGS_REG))]\n@@ -7783,13 +7727,10 @@\n   switch (get_attr_type (insn))\n     {\n     case TYPE_IMOVX:\n-      gcc_assert (CONST_INT_P (operands[2]));\n-      gcc_assert (INTVAL (operands[2]) == 0xff);\n-      return \"movz{bl|x}\\t{%b1, %k0|%k0, %b1}\";\n+      return \"#\";\n \n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n-\n       return \"and{w}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -7828,6 +7769,44 @@\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"QI\")])\n \n+(define_split\n+  [(set (match_operand:SWI248 0 \"register_operand\" \"\")\n+\t(and:SWI248 (match_operand:SWI248 1 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:SWI248 2 \"const_int_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"reload_completed\n+   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n+  [(const_int 0)]\n+{\n+  enum machine_mode mode;\n+\n+  if (INTVAL (operands[2]) == (HOST_WIDE_INT) 0xffffffff)\n+    mode = SImode;\n+  else if (INTVAL (operands[2]) == 0xffff)\n+    mode = HImode;\n+  else\n+    {\n+      gcc_assert (INTVAL (operands[2]) == 0xff);\n+      mode = QImode;\n+    }\n+\n+  operands[1] = gen_lowpart (mode, operands[1]);\n+\n+  if (mode == SImode)\n+    emit_insn (gen_zero_extendsidi2 (operands[0], operands[1]));\n+  else\n+    {\n+      rtx (*insn) (rtx, rtx);\n+\n+      /* Zero extend to SImode to avoid partial register stalls.  */\n+      operands[0] = gen_lowpart (SImode, operands[0]);\n+\n+      insn = (mode == HImode) ? gen_zero_extendhisi2 : gen_zero_extendqisi2;\n+      emit_insn (insn (operands[0], operands[1]));\n+    }\n+  DONE;\n+})\n+\n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(and (match_dup 0)\n@@ -11175,18 +11154,17 @@\n   ix86_expand_clear (operands[3]);\n })\n \n-;; Similar, but match zero_extendhisi2_and, which adds a clobber.\n+;; Similar, but match zero extend with andsi3.\n \n (define_peephole2\n   [(set (reg FLAGS_REG) (match_operand 0 \"\" \"\"))\n    (set (match_operand:QI 1 \"register_operand\" \"\")\n \t(match_operator:QI 2 \"ix86_comparison_operator\"\n \t  [(reg FLAGS_REG) (const_int 0)]))\n-   (parallel [(set (match_operand 3 \"q_regs_operand\" \"\")\n-\t\t   (zero_extend (match_dup 1)))\n+   (parallel [(set (match_operand:SI 3 \"q_regs_operand\" \"\")\n+\t\t   (and:SI (match_dup 3) (const_int 255)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"(peep2_reg_dead_p (3, operands[1])\n-    || operands_match_p (operands[1], operands[3]))\n+  \"REGNO (operands[1]) == REGNO (operands[3])\n    && ! reg_overlap_mentioned_p (operands[3], operands[0])\"\n   [(set (match_dup 4) (match_dup 0))\n    (set (strict_low_part (match_dup 5))"}]}