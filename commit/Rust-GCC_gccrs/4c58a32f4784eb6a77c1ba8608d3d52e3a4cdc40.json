{"sha": "4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM1OGEzMmY0Nzg0ZWI2YTc3YzFiYTg2MDhkM2Q1MmUzYTRjZGM0MA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-08-14T13:04:51Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-08-14T14:44:46Z"}, "message": "c++: More simplification of name_lookup api\n\nContinuing fixing name lookup's API we have two parameters saying what\nwe'd like to find 'prefer_type', which is a tri-valued boolan with\nmeaning 'don't care', 'type or namespace', 'type or death'.  And we\nhave a second parameter 'namespaces_only', which means 'namespace or\ndeath'.  There are only 4 states, because the latter one has priority.\nFirstly 'prefer_type' isn't really the right name -- it's not a preference,\nit's a requirement.  Name lookup maps those two parameters into 2 LOOKUP_\nbits.  We can simply have callers express that desire directly.\n\nSo this adds another enum class, LOOK_want, which expresses all\nthose options in 2 bits.  Most of this patch is then the expected fallout\nfrom such a change.  The parser was mapping its internal state into\na prefer_type value, which was then mapped into the LOOKUP_ bits. So this\nsaves a conversion there.  Also the parser's conversion routine had an\n'is_template' flag, which was only ever true in one place, where the parser\nalso had to deal with other nuances of the flags to pass.  So just drop\nthat parm and deal with it at the call site too.\n\nI've left LOOKUP_HIDDEN alone for the moment.  That'll be next.\n\n\tgcc/cp/\n\t* cp-tree.h (LOOKUP_PREFER_TYPES, LOOKUP_PREFER_NAMESPACES)\n\t(LOOKUP_NAMESPACES_ONLY, LOOKUP_TYPES_ONLY)\n\t(LOOKUP_QUALIFIERS_ONL): Delete.\n\t(LOOKUP_HIDDEN): Adjust.\n\t* name-lookup.h (enum class LOOK_want): New.\n\t(operator|, operator&): Overloads for it.\n\t(lookup_name_real): Replace prefer_type & namespaces_only with\n\tLOOK_want parm.\n\t(lookup_qualified_name): Replace prefer_type with LOOK_want.\n\t(lookup_name_prefer_type): Replace with ...\n\t(lookup_name): ... this.  New overload with LOOK_want parm.\n\t* name-lookup.c (struct name_lookup): Replace flags with want and\n\thidden fields.  Adjust constructors.\n\t(name_lookyp::add_overload): Correct hidden stripping test.  Update\n\tfor new LOOK_want type.\n\t(name_lookup::process_binding): Likewise.\n\t(name_lookup::search_unqualified): Use hidden flag.\n\t(identifier_type_value_1): Adjust lookup_name_real call.\n\t(set_decl_namespace): Adjust name_lookup ctor.\n\t(lookup_flags): Delete.\n\t(qualify_lookup): Add LOOK_want parm, adjust.\n\t(lookup_qualified_name): Replace prefer_type parm with LOOK_want.\n\t(lookup_name_real_1): Replace prefer_type and namespaces_only with\n\tLOOK_want parm.\n\t(lookup_name_real): Likewise.\n\t(lookup_name_nonclass, lookup_name): Adjust lookup_name_real call.\n\t(lookup_name_prefer_type): Rename to ...\n\t(lookup_name): ... here.  New overload with LOOK_want parm.\n\t(lookup_type_scope_1): Adjust qualify_lookup calls.\n\t* call.c (build_operator_new_call)\n\t(add_operator_candidates): Adjust lookup_name_real calls.\n\t* coroutines.cc (find_coro_traits_template_decl)\n\t(find_coro_handle_template_decl, morph_fn_to_coro): Adjust\n\tlookup_qualified_name calls.\n\t* cp-objcp-common.c (identifier_global_tag): Likewise.\n\t* decl.c (get_tuple_size, get_tuple_decomp_init): Likewise.\n\t(lookup_and_check_tag): Use lookup_name overload.\n\t* parser.c (cp_parser_userdef_numeric_literal): Adjust\n\tlookup_qualified_name call.\n\t(prefer_arg_type): Drop template_mem_access parm, return LOOK_want\n\tvalue.\n\t(cp_parser_lookup_name): Adjust lookup_member, lookup_name_real\n\tcalls.\n\t* pt.c (check_explicit_specialization): Adjust lookup_qualified_name\n\tcall.\n\t(tsubst_copy_and_build, tsubst_qualified_name): Likewise\n\t(deduction_guides_for): Likewise.\n\t(tsubst_friend_class): Adjust lookup_name_real call.\n\t(lookup_init_capture, tsubst_expr): Likewise.\n\t* rtti.c (emit_support_tinfos): Adjust lookup_qualified_name call.\n\t* semantics.c (omp_reduction_lookup): Likewise.\n\t(capture_decltype): Adjust lookup_name_real call.\n\tlibcc1/\n\t* libcp1plugin.cc (plugin_build_dependent_expr): Adjust\n\tlookup_name_real & lookup_qualified_name calls.", "tree": {"sha": "ae5777c3d8fbb1051cc2033c6d8991df4be8a62f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae5777c3d8fbb1051cc2033c6d8991df4be8a62f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2398c206101f6da09f87e8afaf3ff422236db61d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2398c206101f6da09f87e8afaf3ff422236db61d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2398c206101f6da09f87e8afaf3ff422236db61d"}], "stats": {"total": 287, "additions": 142, "deletions": 145}, "files": [{"sha": "d4935bd0ce13578eb3edd970fda60a0c395a3040", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -4704,7 +4704,7 @@ build_operator_new_call (tree fnname, vec<tree, va_gc> **args,\n        up in the global scope.\n \n      we disregard block-scope declarations of \"operator new\".  */\n-  fns = lookup_name_real (fnname, LOOK_where::NAMESPACE, 0, 0, 0);\n+  fns = lookup_name_real (fnname, LOOK_where::NAMESPACE, LOOK_want::NORMAL, 0);\n   fns = lookup_arg_dependent (fnname, fns, *args);\n \n   if (align_arg)\n@@ -5983,7 +5983,7 @@ add_operator_candidates (z_candidate **candidates,\n   if (!memonly)\n     {\n       tree fns = lookup_name_real (fnname, LOOK_where::BLOCK_NAMESPACE,\n-\t\t\t\t   0, 0, 0);\n+\t\t\t\t   LOOK_want::NORMAL, 0);\n       fns = lookup_arg_dependent (fnname, fns, arglist);\n       add_candidates (fns, NULL_TREE, arglist, NULL_TREE,\n \t\t      NULL_TREE, false, NULL_TREE, NULL_TREE,"}, {"sha": "22ba81c802524ae956975b63270126cc8c8a833a", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -267,7 +267,7 @@ find_coro_traits_template_decl (location_t kw)\n   static bool traits_error_emitted = false;\n \n   tree traits_decl = lookup_qualified_name (std_node, coro_traits_identifier,\n-\t\t\t\t\t    0,\n+\t\t\t\t\t    LOOK_want::NORMAL,\n \t\t\t\t\t    /*complain=*/!traits_error_emitted);\n   if (traits_decl == error_mark_node\n       || !DECL_TYPE_TEMPLATE_P (traits_decl))\n@@ -348,7 +348,8 @@ find_coro_handle_template_decl (location_t kw)\n     it once.  */\n   static bool coro_handle_error_emitted = false;\n   tree handle_decl = lookup_qualified_name (std_node, coro_handle_identifier,\n-\t\t\t\t\t    0, !coro_handle_error_emitted);\n+\t\t\t\t\t    LOOK_want::NORMAL,\n+\t\t\t\t\t    !coro_handle_error_emitted);\n   if (handle_decl == error_mark_node\n       || !DECL_CLASS_TEMPLATE_P (handle_decl))\n     {\n@@ -4309,7 +4310,8 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t   non-throwing noexcept-specification.  So we need std::nothrow.  */\n \t  tree std_nt = lookup_qualified_name (std_node,\n \t\t\t\t\t       get_identifier (\"nothrow\"),\n-\t\t\t\t\t       0, /*complain=*/true, false);\n+\t\t\t\t\t       LOOK_want::NORMAL,\n+\t\t\t\t\t       /*complain=*/true, false);\n \t  if (!std_nt || std_nt == error_mark_node)\n \t    error_at (fn_start, \"%qE is provided by %qT but %<std::nothrow%> \"\n \t\t      \"cannot be found\", grooaf, promise_type);"}, {"sha": "852a34dbc5f2cacfec84c3cc551b02a7b59a00de", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -355,7 +355,7 @@ identifier_global_value (tree name)\n tree\n identifier_global_tag (tree name)\n {\n-  tree ret = lookup_qualified_name (global_namespace, name, /*prefer_type*/2,\n+  tree ret = lookup_qualified_name (global_namespace, name, LOOK_want::TYPE,\n \t\t\t\t    /*complain*/false);\n   if (ret == error_mark_node)\n     return NULL_TREE;"}, {"sha": "82834e65a53fab654cb1166b71bb8daccd41140e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -5567,16 +5567,10 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n #define LOOKUP_DESTRUCTOR (1 << 5)\n /* Do not permit references to bind to temporaries.  */\n #define LOOKUP_NO_TEMP_BIND (1 << 6)\n-/* Do not accept objects, and possibly namespaces.  */\n-#define LOOKUP_PREFER_TYPES (1 << 7)\n-/* Do not accept objects, and possibly types.   */\n-#define LOOKUP_PREFER_NAMESPACES (1 << 8)\n-/* Accept types or namespaces.  */\n-#define LOOKUP_PREFER_BOTH (LOOKUP_PREFER_TYPES | LOOKUP_PREFER_NAMESPACES)\n /* Return friend declarations and un-declared builtin functions.\n    (Normally, these entities are registered in the symbol table, but\n    not found by lookup.)  */\n-#define LOOKUP_HIDDEN (LOOKUP_PREFER_NAMESPACES << 1)\n+#define LOOKUP_HIDDEN (1 << 7)\n /* We're trying to treat an lvalue as an rvalue.  */\n /* FIXME remove when we extend the P1825 semantics to all standard modes, the\n    C++20 approach uses IMPLICIT_RVALUE_P instead.  */\n@@ -5626,13 +5620,6 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n /* We're initializing an aggregate from a parenthesized list of values.  */\n #define LOOKUP_AGGREGATE_PAREN_INIT (LOOKUP_REVERSED << 1)\n \n-#define LOOKUP_NAMESPACES_ONLY(F)  \\\n-  (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))\n-#define LOOKUP_TYPES_ONLY(F)  \\\n-  (!((F) & LOOKUP_PREFER_NAMESPACES) && ((F) & LOOKUP_PREFER_TYPES))\n-#define LOOKUP_QUALIFIERS_ONLY(F)     ((F) & LOOKUP_PREFER_BOTH)\n-\n-\n /* These flags are used by the conversion code.\n    CONV_IMPLICIT   :  Perform implicit conversions (standard and user-defined).\n    CONV_STATIC     :  Perform the explicit conversions for static_cast."}, {"sha": "d1af63e730091c422a91b7b5946ef80c403e559b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -8100,7 +8100,7 @@ get_tuple_size (tree type)\n   if (inst == error_mark_node || !COMPLETE_TYPE_P (inst))\n     return NULL_TREE;\n   tree val = lookup_qualified_name (inst, value_identifier,\n-\t\t\t\t    /*type*/false, /*complain*/false);\n+\t\t\t\t    LOOK_want::NORMAL, /*complain*/false);\n   if (TREE_CODE (val) == VAR_DECL || TREE_CODE (val) == CONST_DECL)\n     val = maybe_constant_value (val);\n   if (TREE_CODE (val) == INTEGER_CST)\n@@ -8144,7 +8144,7 @@ get_tuple_decomp_init (tree decl, unsigned i)\n     e = move (e);\n \n   tree fns = lookup_qualified_name (TREE_TYPE (e), get__identifier,\n-\t\t\t\t    /*type*/false, /*complain*/false);\n+\t\t\t\t    LOOK_want::NORMAL, /*complain*/false);\n   bool use_member_get = false;\n \n   /* To use a member get, member lookup must find at least one\n@@ -14834,7 +14834,7 @@ lookup_and_check_tag (enum tag_types tag_code, tree name,\n     {\n       /* First try ordinary name lookup, ignoring hidden class name\n \t injected via friend declaration.  */\n-      decl = lookup_name_prefer_type (name, 2);\n+      decl = lookup_name (name, LOOK_want::TYPE);\n       decl = strip_using_decl (decl);\n       /* If that fails, the name will be placed in the smallest\n \t non-class, non-function-prototype scope according to 3.3.1/5."}, {"sha": "51de6fb4c36e4ff4a29897187b6df799d81ba2c2", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 69, "deletions": 83, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -164,7 +164,9 @@ class name_lookup\n   tree name;\t/* The identifier being looked for.  */\n   tree value;\t/* A (possibly ambiguous) set of things found.  */\n   tree type;\t/* A type that has been found.  */\n-  int flags;\t/* Lookup flags.  */\n+  LOOK_want want;  /* What kind of entity we want.  */\n+  bool hidden;\t/* Allow hidden  */\n+\n   bool deduping; /* Full deduping is needed because using declarations\n \t\t    are in play.  */\n   vec<tree, va_heap, vl_embed> *scopes;\n@@ -177,8 +179,9 @@ class name_lookup\n   static name_lookup *active;\n \n public:\n-  name_lookup (tree n, int f = 0)\n-  : name (n), value (NULL_TREE), type (NULL_TREE), flags (f),\n+  name_lookup (tree n, LOOK_want w = LOOK_want::NORMAL, bool h = false)\n+  : name (n), value (NULL_TREE), type (NULL_TREE),\n+    want (w), hidden (h),\n     deduping (false), scopes (NULL), previous (NULL)\n   {\n     preserve_state ();\n@@ -417,7 +420,7 @@ name_lookup::add_overload (tree fns)\n   if (!deduping && TREE_CODE (fns) == OVERLOAD)\n     {\n       tree probe = fns;\n-      if (flags & LOOKUP_HIDDEN)\n+      if (!hidden)\n \tprobe = ovl_skip_hidden (probe);\n       if (probe && TREE_CODE (probe) == OVERLOAD\n \t  && OVL_DEDUP_P (probe))\n@@ -485,13 +488,13 @@ name_lookup::process_binding (tree new_val, tree new_type)\n {\n   /* Did we really see a type? */\n   if (new_type\n-      && (LOOKUP_NAMESPACES_ONLY (flags)\n-\t  || (!(flags & LOOKUP_HIDDEN)\n+      && ((want & LOOK_want::TYPE_NAMESPACE) == LOOK_want::NAMESPACE\n+\t  || (!hidden\n \t      && DECL_LANG_SPECIFIC (new_type)\n \t      && DECL_ANTICIPATED (new_type))))\n     new_type = NULL_TREE;\n \n-  if (new_val && !(flags & LOOKUP_HIDDEN))\n+  if (new_val && !hidden)\n     new_val = ovl_skip_hidden (new_val);\n \n   /* Do we really see a value? */\n@@ -501,21 +504,21 @@ name_lookup::process_binding (tree new_val, tree new_type)\n       case TEMPLATE_DECL:\n \t/* If we expect types or namespaces, and not templates,\n \t   or this is not a template class.  */\n-\tif ((LOOKUP_QUALIFIERS_ONLY (flags)\n-\t     && !DECL_TYPE_TEMPLATE_P (new_val)))\n+\tif (bool (want & LOOK_want::TYPE_NAMESPACE)\n+\t    && !DECL_TYPE_TEMPLATE_P (new_val))\n \t  new_val = NULL_TREE;\n \tbreak;\n       case TYPE_DECL:\n-\tif (LOOKUP_NAMESPACES_ONLY (flags)\n-\t    || (new_type && (flags & LOOKUP_PREFER_TYPES)))\n+\tif ((want & LOOK_want::TYPE_NAMESPACE) == LOOK_want::NAMESPACE\n+\t    || (new_type && bool (want & LOOK_want::TYPE)))\n \t  new_val = NULL_TREE;\n \tbreak;\n       case NAMESPACE_DECL:\n-\tif (LOOKUP_TYPES_ONLY (flags))\n+\tif ((want & LOOK_want::TYPE_NAMESPACE) == LOOK_want::TYPE)\n \t  new_val = NULL_TREE;\n \tbreak;\n       default:\n-\tif (LOOKUP_QUALIFIERS_ONLY (flags))\n+\tif (bool (want & LOOK_want::TYPE_NAMESPACE))\n \t  new_val = NULL_TREE;\n       }\n \n@@ -721,7 +724,7 @@ name_lookup::search_unqualified (tree scope, cp_binding_level *level)\n \t function, class template or function template the friend is a\n \t member of the innermost enclosing namespace.  See also\n \t [basic.lookup.unqual]/7 */\n-      if (flags & LOOKUP_HIDDEN)\n+      if (hidden)\n \tbreak;\n     }\n \n@@ -3741,7 +3744,7 @@ identifier_type_value_1 (tree id)\n     return REAL_IDENTIFIER_TYPE_VALUE (id);\n   /* Have to search for it. It must be on the global level, now.\n      Ask lookup_name not to return non-types.  */\n-  id = lookup_name_real (id, LOOK_where::BLOCK_NAMESPACE, 2, 0, 0);\n+  id = lookup_name_real (id, LOOK_where::BLOCK_NAMESPACE, LOOK_want::TYPE, 0);\n   if (id)\n     return TREE_TYPE (id);\n   return NULL_TREE;\n@@ -4742,7 +4745,7 @@ do_class_using_decl (tree scope, tree name)\n       || scope == error_mark_node)\n     return NULL_TREE;\n \n-  name_lookup lookup (name, 0);\n+  name_lookup lookup (name);\n   if (!lookup_using_decl (scope, lookup))\n     return NULL_TREE;\n \n@@ -4815,7 +4818,7 @@ set_decl_namespace (tree decl, tree scope, bool friendp)\n      children.  */\n   tree old = NULL_TREE;\n   {\n-    name_lookup lookup (DECL_NAME (decl), LOOKUP_HIDDEN);\n+    name_lookup lookup (DECL_NAME (decl), LOOK_want::NORMAL, true);\n     if (!lookup.search_qualified (scope, /*usings=*/false))\n       /* No old declaration at all.  */\n       goto not_found;\n@@ -5127,7 +5130,7 @@ finish_nonmember_using_decl (tree scope, tree name)\n   if (scope == error_mark_node || name == error_mark_node)\n     return;\n \n-  name_lookup lookup (name, 0);\n+  name_lookup lookup (name);\n \n   if (!lookup_using_decl (scope, lookup))\n     return;\n@@ -5209,43 +5212,35 @@ cp_namespace_decls (tree ns)\n   return NAMESPACE_LEVEL (ns)->names;\n }\n \n-/* Combine prefer_type and namespaces_only into flags.  */\n-\n-static int\n-lookup_flags (int prefer_type, int namespaces_only)\n-{\n-  if (namespaces_only)\n-    return LOOKUP_PREFER_NAMESPACES;\n-  if (prefer_type > 1)\n-    return LOOKUP_PREFER_TYPES;\n-  if (prefer_type > 0)\n-    return LOOKUP_PREFER_BOTH;\n-  return 0;\n-}\n-\n /* Given a lookup that returned VAL, use FLAGS to decide if we want to\n    ignore it or not.  Subroutine of lookup_name_real and\n    lookup_type_scope.  */\n \n static bool\n-qualify_lookup (tree val, int flags)\n+qualify_lookup (tree val, LOOK_want want, int flags)\n {\n   if (val == NULL_TREE)\n     return false;\n-  if ((flags & LOOKUP_PREFER_NAMESPACES) && TREE_CODE (val) == NAMESPACE_DECL)\n+\n+  if (bool (want & LOOK_want::NAMESPACE) && TREE_CODE (val) == NAMESPACE_DECL)\n     return true;\n-  if (flags & LOOKUP_PREFER_TYPES)\n+\n+  if (bool (want & LOOK_want::TYPE))\n     {\n       tree target_val = strip_using_decl (val);\n+\n       if (TREE_CODE (target_val) == TYPE_DECL\n \t  || TREE_CODE (target_val) == TEMPLATE_DECL)\n \treturn true;\n     }\n-  if (flags & (LOOKUP_PREFER_NAMESPACES | LOOKUP_PREFER_TYPES))\n+\n+  if (bool (want & LOOK_want::TYPE_NAMESPACE))\n     return false;\n+\n   /* Look through lambda things that we shouldn't be able to see.  */\n   if (!(flags & LOOKUP_HIDDEN) && is_lambda_ignored_entity (val))\n     return false;\n+\n   return true;\n }\n \n@@ -5992,34 +5987,31 @@ suggest_alternative_in_scoped_enum (tree name, tree scoped_enum)\n /* Look up NAME (an IDENTIFIER_NODE) in SCOPE (either a NAMESPACE_DECL\n    or a class TYPE).\n \n-   If PREFER_TYPE is > 0, we only return TYPE_DECLs or namespaces.\n-   If PREFER_TYPE is > 1, we only return TYPE_DECLs.\n+   WANT as for lookup_name_real_1.\n \n    Returns a DECL (or OVERLOAD, or BASELINK) representing the\n    declaration found.  If no suitable declaration can be found,\n    ERROR_MARK_NODE is returned.  If COMPLAIN is true and SCOPE is\n    neither a class-type nor a namespace a diagnostic is issued.  */\n \n tree\n-lookup_qualified_name (tree scope, tree name, int prefer_type, bool complain,\n+lookup_qualified_name (tree scope, tree name, LOOK_want want, bool complain,\n \t\t       bool find_hidden /*=false*/)\n {\n   tree t = NULL_TREE;\n \n   if (TREE_CODE (scope) == NAMESPACE_DECL)\n     {\n-      int flags = lookup_flags (prefer_type, /*namespaces_only*/false);\n-      if (find_hidden)\n-\tflags |= LOOKUP_HIDDEN;\n-      name_lookup lookup (name, flags);\n+      name_lookup lookup (name, want, find_hidden);\n \n       if (qualified_namespace_lookup (scope, &lookup))\n \tt = lookup.value;\n     }\n   else if (cxx_dialect != cxx98 && TREE_CODE (scope) == ENUMERAL_TYPE)\n     t = lookup_enumerator (scope, name);\n   else if (is_class_type (scope, complain))\n-    t = lookup_member (scope, name, 2, prefer_type, tf_warning_or_error);\n+    t = lookup_member (scope, name, 2, bool (want & LOOK_want::TYPE),\n+\t\t       tf_warning_or_error);\n \n   if (!t)\n     return error_mark_node;\n@@ -6029,8 +6021,10 @@ lookup_qualified_name (tree scope, tree name, int prefer_type, bool complain,\n /* Wrapper for the above that takes a string argument.  The function name is\n    not at the beginning of the line to keep this wrapper out of etags.  */\n \n-tree lookup_qualified_name (tree t, const char *p, int wt, bool c, bool fh)\n-{ return lookup_qualified_name (t, get_identifier (p), wt, c, fh); }\n+tree lookup_qualified_name (tree t, const char *p, LOOK_want w, bool c, bool fh)\n+{\n+  return lookup_qualified_name (t, get_identifier (p), w, c, fh);\n+}\n \n /* [namespace.qual]\n    Accepts the NAME to lookup and its qualifying SCOPE.\n@@ -6418,23 +6412,20 @@ innermost_non_namespace_value (tree name)\n    not ignored.\n \n    WHERE controls which scopes are considered.  It is a bit mask of\n-   LOOKUP_where::BLOCK (look in block scope), LOOKUP_where::CLASS\n-   (look in class scopes) & LOOKUP_where::NAMESPACE (look in namespace\n+   LOOK_where::BLOCK (look in block scope), LOOK_where::CLASS\n+   (look in class scopes) & LOOK_where::NAMESPACE (look in namespace\n    scopes).  It is an error for no bits to be set.  These scopes are\n    searched from innermost to outermost.\n \n-   If PREFER_TYPE is > 0, we prefer TYPE_DECLs or namespaces.\n-   If PREFER_TYPE is > 1, we reject non-type decls (e.g. namespaces).\n-   Otherwise we prefer non-TYPE_DECLs.\n-\n-   If NONCLASS is nonzero, bindings in class scopes are ignored.  If\n-   BLOCK_P is false, bindings in block scopes are ignored.  */\n+   WANT controls what kind of entity we'd happy with.\n+   LOOK_want::NORMAL for normal lookup (implicit typedefs can be\n+   hidden).  LOOK_want::TYPE for only TYPE_DECLS, LOOK_want::NAMESPACE\n+   for only NAMESPACE_DECLS.  These two can be bit-ored to find\n+   namespace or type.  */\n \n static tree\n-lookup_name_real_1 (tree name, LOOK_where where, int prefer_type,\n-\t\t    int namespaces_only, int flags)\n+lookup_name_real_1 (tree name, LOOK_where where, LOOK_want want, int flags)\n {\n-  cxx_binding *iter;\n   tree val = NULL_TREE;\n \n   gcc_checking_assert (unsigned (where) != 0);\n@@ -6471,31 +6462,28 @@ lookup_name_real_1 (tree name, LOOK_where where, int prefer_type,\n       return NULL_TREE;\n     }\n \n-  flags |= lookup_flags (prefer_type, namespaces_only);\n-\n   /* First, look in non-namespace scopes.  */\n \n   if (current_class_type == NULL_TREE)\n     /* Maybe avoid searching the binding stack at all.  */\n     where = LOOK_where (unsigned (where) & ~unsigned (LOOK_where::CLASS));\n \n-  if (where & (LOOK_where::BLOCK | LOOK_where::CLASS))\n-    for (iter = outer_binding (name, NULL, where & LOOK_where::CLASS);\n-\t iter;\n-\t iter = outer_binding (name, iter, where & LOOK_where::CLASS))\n+  if (bool (where & (LOOK_where::BLOCK | LOOK_where::CLASS)))\n+    for (cxx_binding *iter = nullptr;\n+\t (iter = outer_binding (name, iter, bool (where & LOOK_where::CLASS)));)\n       {\n \ttree binding;\n \n \t/* Skip entities we don't want.  */\n-\tif (!(where & (LOCAL_BINDING_P (iter)\n-\t\t       ? LOOK_where::BLOCK : LOOK_where::CLASS)))\n+\tif (!bool (where & (LOCAL_BINDING_P (iter)\n+\t\t\t    ? LOOK_where::BLOCK : LOOK_where::CLASS)))\n \t  continue;\n \n \t/* If this is the kind of thing we're looking for, we're done.  */\n-\tif (qualify_lookup (iter->value, flags))\n+\tif (qualify_lookup (iter->value, want, flags))\n \t  binding = iter->value;\n-\telse if ((flags & LOOKUP_PREFER_TYPES)\n-\t\t && qualify_lookup (iter->type, flags))\n+\telse if (bool (want & LOOK_want::TYPE)\n+\t\t && qualify_lookup (iter->type, want, flags))\n \t  binding = iter->type;\n \telse\n \t  binding = NULL_TREE;\n@@ -6558,9 +6546,9 @@ lookup_name_real_1 (tree name, LOOK_where where, int prefer_type,\n       }\n \n   /* Now lookup in namespace scopes.  */\n-  if (!val && (where & LOOK_where::NAMESPACE))\n+  if (!val && bool (where & LOOK_where::NAMESPACE))\n     {\n-      name_lookup lookup (name, flags);\n+      name_lookup lookup (name, want, flags & LOOKUP_HIDDEN);\n       if (lookup.search_unqualified\n \t  (current_decl_namespace (), current_binding_level))\n \tval = lookup.value;\n@@ -6576,13 +6564,11 @@ lookup_name_real_1 (tree name, LOOK_where where, int prefer_type,\n /* Wrapper for lookup_name_real_1.  */\n \n tree\n-lookup_name_real (tree name, LOOK_where where, int prefer_type,\n-\t\t  int namespaces_only, int flags)\n+lookup_name_real (tree name, LOOK_where where, LOOK_want want, int flags)\n {\n   tree ret;\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = lookup_name_real_1 (name, where, prefer_type,\n-\t\t\t    namespaces_only, flags);\n+  ret = lookup_name_real_1 (name, where, want, flags);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n@@ -6591,19 +6577,19 @@ tree\n lookup_name_nonclass (tree name)\n {\n   return lookup_name_real (name, LOOK_where::BLOCK_NAMESPACE,\n-\t\t\t   0, 0, 0);\n+\t\t\t   LOOK_want::NORMAL, 0);\n }\n \n tree\n lookup_name (tree name)\n {\n-  return lookup_name_real (name, LOOK_where::ALL, 0, 0, 0);\n+  return lookup_name_real (name, LOOK_where::ALL, LOOK_want::NORMAL, 0);\n }\n \n tree\n-lookup_name_prefer_type (tree name, int prefer_type)\n+lookup_name (tree name, LOOK_want want)\n {\n-  return lookup_name_real (name, LOOK_where::ALL, prefer_type, 0, 0);\n+  return lookup_name_real (name, LOOK_where::ALL, want, 0);\n }\n \n /* Look up NAME for type used in elaborated name specifier in\n@@ -6651,13 +6637,13 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n \t     typedef struct C {} C;\n \t   correctly.  */\n \tif (tree type = iter->type)\n-\t  if (qualify_lookup (type, LOOKUP_PREFER_TYPES)\n+\t  if (qualify_lookup (type, LOOK_want::TYPE, false)\n \t      && (scope != ts_current\n \t\t  || LOCAL_BINDING_P (iter)\n \t\t  || DECL_CONTEXT (type) == iter->scope->this_entity))\n \t    return type;\n \n-\tif (qualify_lookup (iter->value, LOOKUP_PREFER_TYPES)\n+\tif (qualify_lookup (iter->value, LOOK_want::TYPE, false)\n \t    && (scope != ts_current\n \t\t|| !INHERITED_VALUE_BINDING_P (iter)))\n \t  return iter->value;\n@@ -6678,11 +6664,11 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n     {\n       /* If this is the kind of thing we're looking for, we're done.  */\n       if (tree type = MAYBE_STAT_TYPE (*slot))\n-\tif (qualify_lookup (type, LOOKUP_PREFER_TYPES))\n+\tif (qualify_lookup (type, LOOK_want::TYPE, false))\n \t  return type;\n \n       if (tree decl = MAYBE_STAT_DECL (*slot))\n-\tif (qualify_lookup (decl, LOOKUP_PREFER_TYPES))\n+\tif (qualify_lookup (decl, LOOK_want::TYPE, false))\n \t  return decl;\n     }\n \n@@ -7384,7 +7370,7 @@ push_namespace (tree name, bool make_inline)\n \n   tree ns = NULL_TREE;\n   {\n-    name_lookup lookup (name, 0);\n+    name_lookup lookup (name);\n     if (!lookup.search_qualified (current_namespace, /*usings=*/false))\n       ;\n     else if (TREE_CODE (lookup.value) == TREE_LIST)"}, {"sha": "79b7a590915f2fd496bf4a884dcb29483a64076c", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -295,25 +295,45 @@ constexpr LOOK_where operator| (LOOK_where a, LOOK_where b)\n {\n   return LOOK_where (unsigned (a) | unsigned (b));\n }\n-constexpr bool operator& (LOOK_where a, LOOK_where b)\n+constexpr LOOK_where operator& (LOOK_where a, LOOK_where b)\n {\n-  return 0 != (unsigned (a) & unsigned (b));\n+  return LOOK_where (unsigned (a) & unsigned (b));\n }\n \n-extern tree lookup_name_prefer_type (tree, int);\n+enum class LOOK_want\n+{\n+  NORMAL = 0,  /* Normal lookup -- non-types can hide implicit types.  */\n+  TYPE = 1 << 1,  /* We only want TYPE_DECLS.  */\n+  NAMESPACE = 1 << 2,  /* We only want NAMESPACE_DECLS.  */\n \n+  TYPE_NAMESPACE = TYPE | NAMESPACE,  /* Either NAMESPACE or TYPE.  */\n+};\n+constexpr LOOK_want operator| (LOOK_want a, LOOK_want b)\n+{\n+  return LOOK_want (unsigned (a) | unsigned (b));\n+}\n+constexpr LOOK_want operator& (LOOK_want a, LOOK_want b)\n+{\n+  return LOOK_want (unsigned (a) & unsigned (b));\n+}\n \n-extern tree lookup_name_real (tree, LOOK_where, int prefer_type,\n-\t\t\t      int namespaces_only, int flags);\n+extern tree lookup_name_real (tree, LOOK_where, LOOK_want, int flags);\n extern tree lookup_type_scope (tree, tag_scope);\n extern tree get_namespace_binding (tree ns, tree id);\n extern void set_global_binding (tree decl);\n inline tree get_global_binding (tree id)\n {\n   return get_namespace_binding (NULL_TREE, id);\n }\n-extern tree lookup_qualified_name (tree, tree, int = 0, bool = true, /*hidden*/bool = false);\n-extern tree lookup_qualified_name (tree t, const char *p, int = 0, bool = true, bool = false);\n+/* Also declared in c-family/c-common.h.  */\n+extern tree lookup_name (tree name);\n+extern tree lookup_name (tree name, LOOK_want);\n+extern tree lookup_qualified_name (tree scope, tree name,\n+\t\t\t\t   LOOK_want = LOOK_want::NORMAL,\n+\t\t\t\t   bool = true, /*hidden*/bool = false);\n+extern tree lookup_qualified_name (tree scope, const char *name,\n+\t\t\t\t   LOOK_want = LOOK_want::NORMAL,\n+\t\t\t\t   bool = true, bool = false);\n extern tree lookup_name_nonclass (tree);\n extern bool is_local_extern (tree);\n extern bool pushdecl_class_level (tree);"}, {"sha": "2e12a5997278d8df6a3cbacea1c3862213fcae6e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -4617,7 +4617,7 @@ cp_parser_userdef_numeric_literal (cp_parser *parser)\n   if (i14 && ext)\n     {\n       tree cxlit = lookup_qualified_name (std_node, \"complex_literals\",\n-\t\t\t\t\t  0, false);\n+\t\t\t\t\t  LOOK_want::NORMAL, false);\n       if (cxlit == error_mark_node)\n \t{\n \t  /* No <complex>, so pedwarn and use GNU semantics.  */\n@@ -28214,20 +28214,16 @@ cp_parser_nested_requirement (cp_parser *parser)\n /* Support Functions */\n \n /* Return the appropriate prefer_type argument for lookup_name_real based on\n-   tag_type and template_mem_access.  */\n+   tag_type.  */\n \n-static inline int\n-prefer_type_arg (tag_types tag_type, bool template_mem_access = false)\n+static inline LOOK_want\n+prefer_type_arg (tag_types tag_type)\n {\n-  /* DR 141: When looking in the current enclosing context for a template-name\n-     after -> or ., only consider class templates.  */\n-  if (template_mem_access)\n-    return 2;\n   switch (tag_type)\n     {\n-    case none_type:  return 0;\t// No preference.\n-    case scope_type: return 1;\t// Type or namespace.\n-    default:         return 2;\t// Type only.\n+    case none_type:  return LOOK_want::NORMAL;\t// No preference.\n+    case scope_type: return LOOK_want::TYPE_NAMESPACE;\t// Type or namespace.\n+    default:         return LOOK_want::TYPE;\t// Type only.\n     }\n }\n \n@@ -28451,7 +28447,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \tdecl = lookup_member (object_type,\n \t\t\t      name,\n \t\t\t      /*protect=*/0,\n-\t\t\t      prefer_type_arg (tag_type),\n+\t\t\t      /*prefer_type=*/tag_type != none_type,\n \t\t\t      tf_warning_or_error);\n       else\n \tdecl = NULL_TREE;\n@@ -28460,16 +28456,22 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t/* Look it up in the enclosing context.  DR 141: When looking for a\n \t   template-name after -> or ., only consider class templates.  */\n \tdecl = lookup_name_real (name, LOOK_where::ALL,\n-\t\t\t\t prefer_type_arg (tag_type, is_template),\n-\t\t\t\t is_namespace, 0);\n+\t\t\t\t is_namespace ? LOOK_want::NAMESPACE\n+\t\t\t\t /* DR 141: When looking in the\n+\t\t\t\t    current enclosing context for a\n+\t\t\t\t    template-name after -> or ., only\n+\t\t\t\t    consider class templates.  */\n+\t\t\t\t : is_template ? LOOK_want::TYPE\n+\t\t\t\t : prefer_type_arg (tag_type), 0);\n       parser->object_scope = object_type;\n       parser->qualifying_scope = NULL_TREE;\n     }\n   else\n     {\n       decl = lookup_name_real (name, LOOK_where::ALL,\n-\t\t\t       prefer_type_arg (tag_type),\n-\t\t\t       is_namespace, 0);\n+\t\t\t       is_namespace ? LOOK_want::NAMESPACE\n+\t\t\t       : prefer_type_arg (tag_type),\n+\t\t\t       0);\n       parser->qualifying_scope = NULL_TREE;\n       parser->object_scope = NULL_TREE;\n     }"}, {"sha": "fe7f71dc05b717e7ab94ce4582056a8ada46b313", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -2995,12 +2995,12 @@ check_explicit_specialization (tree declarator,\n \t      /* Find the namespace binding, using the declaration\n \t\t context.  */\n \t      fns = lookup_qualified_name (CP_DECL_CONTEXT (decl), dname,\n-\t\t\t\t\t   false, true);\n+\t\t\t\t\t   LOOK_want::NORMAL, true);\n \t      if (fns == error_mark_node)\n \t\t/* If lookup fails, look for a friend declaration so we can\n \t\t   give a better diagnostic.  */\n \t\tfns = lookup_qualified_name (CP_DECL_CONTEXT (decl), dname,\n-\t\t\t\t\t     /*type*/false, /*complain*/true,\n+\t\t\t\t\t     LOOK_want::NORMAL, /*complain*/true,\n \t\t\t\t\t     /*hidden*/true);\n \n \t      if (fns == error_mark_node || !is_overloaded_fn (fns))\n@@ -11184,8 +11184,7 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n     }\n \n   tmpl = lookup_name_real (DECL_NAME (friend_tmpl), LOOK_where::CLASS_NAMESPACE,\n-\t\t\t   /*prefer_type=*/0, /*namespaces_only=*/false,\n-\t\t\t   LOOKUP_HIDDEN);\n+\t\t\t   LOOK_want::NORMAL, LOOKUP_HIDDEN);\n \n   if (tmpl && DECL_CLASS_TEMPLATE_P (tmpl))\n     {\n@@ -16186,10 +16185,10 @@ tsubst_qualified_id (tree qualified_id, tree args,\n \t    }\n \t  else\n \t    expr = lookup_qualified_name (scope, complete_dtor_identifier,\n-\t\t\t\t\t  /*is_type_p=*/0, false);\n+\t\t\t\t\t  LOOK_want::NORMAL, false);\n \t}\n       else\n-\texpr = lookup_qualified_name (scope, expr, /*is_type_p=*/0, false);\n+\texpr = lookup_qualified_name (scope, expr, LOOK_want::NORMAL, false);\n       if (TREE_CODE (TREE_CODE (expr) == TEMPLATE_DECL\n \t\t     ? DECL_TEMPLATE_RESULT (expr) : expr) == TYPE_DECL)\n \t{\n@@ -17835,7 +17834,8 @@ lookup_init_capture_pack (tree decl)\n   for (int i = 0; i < len; ++i)\n     {\n       tree ename = vec ? make_ith_pack_parameter_name (cname, i) : cname;\n-      tree elt = lookup_name_real (ename, LOOK_where::ALL, 0, 0, LOOKUP_NORMAL);\n+      tree elt = lookup_name_real (ename, LOOK_where::ALL, LOOK_want::NORMAL,\n+\t\t\t\t   LOOKUP_NORMAL);\n       if (vec)\n \tTREE_VEC_ELT (vec, i) = elt;\n       else\n@@ -17942,7 +17942,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t      {\n \t\tinst = lookup_name_real (DECL_NAME (decl),\n \t\t\t\t\t LOOK_where::BLOCK_NAMESPACE,\n-\t\t\t\t\t /*prefer_type*/0, /*ns_only*/0,\n+\t\t\t\t\t LOOK_want::NORMAL,\n \t\t\t\t\t LOOKUP_HIDDEN);\n \t\tgcc_assert (inst != decl && is_capture_proxy (inst));\n \t      }\n@@ -20223,8 +20223,7 @@ tsubst_copy_and_build (tree t,\n \t    tree scope = TREE_OPERAND (member, 0);\n \t    tree tmpl = TREE_OPERAND (TREE_OPERAND (member, 1), 0);\n \t    tree args = TREE_OPERAND (TREE_OPERAND (member, 1), 1);\n-\t    member = lookup_qualified_name (scope, tmpl,\n-\t\t\t\t\t    /*is_type_p=*/false,\n+\t    member = lookup_qualified_name (scope, tmpl, LOOK_want::NORMAL,\n \t\t\t\t\t    /*complain=*/false);\n \t    if (BASELINK_P (member))\n \t      {\n@@ -28727,7 +28726,7 @@ deduction_guides_for (tree tmpl, tsubst_flags_t complain)\n     {\n       guides = lookup_qualified_name (CP_DECL_CONTEXT (tmpl),\n \t\t\t\t      dguide_name (tmpl),\n-\t\t\t\t      /*type*/false, /*complain*/false,\n+\t\t\t\t      LOOK_want::NORMAL, /*complain*/false,\n \t\t\t\t      /*hidden*/false);\n       if (guides == error_mark_node)\n \tguides = NULL_TREE;"}, {"sha": "432ebab2639339a8c1ce2bde741a4f445f7f568e", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -1564,7 +1564,7 @@ emit_support_tinfos (void)\n \n   /* Look for a defined class.  */\n   tree bltn_type = lookup_qualified_name\n-    (abi_node, \"__fundamental_type_info\", true, false);\n+    (abi_node, \"__fundamental_type_info\", LOOK_want::TYPE, false);\n   if (TREE_CODE (bltn_type) != TYPE_DECL)\n     return;\n "}, {"sha": "a7b8eb84b7e23fde31abadea25433f7a5aee6cc9", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -5522,7 +5522,7 @@ omp_reduction_lookup (location_t loc, tree id, tree type, tree *baselinkp,\n \t\t\t\tomp_reduction_id (ERROR_MARK,\n \t\t\t\t\t\t  TREE_OPERAND (id, 1),\n \t\t\t\t\t\t  type),\n-\t\t\t\tfalse, false);\n+\t\t\t\tLOOK_want::NORMAL, false);\n   tree fns = id;\n   id = NULL_TREE;\n   if (fns && is_overloaded_fn (fns))\n@@ -10323,7 +10323,7 @@ capture_decltype (tree decl)\n {\n   tree lam = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (current_function_decl));\n   tree cap = lookup_name_real (DECL_NAME (decl), LOOK_where::BLOCK_NAMESPACE,\n-\t\t\t       /*type*/0, /*ns*/false, LOOKUP_HIDDEN);\n+\t\t\t       LOOK_want::NORMAL, LOOKUP_HIDDEN);\n   tree type;\n \n   if (cap && is_capture_proxy (cap))"}, {"sha": "ddff74522263a5abe6cd3374e8e77c4bf7d6a8c4", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=4c58a32f4784eb6a77c1ba8608d3d52e3a4cdc40", "patch": "@@ -2652,10 +2652,11 @@ plugin_build_dependent_expr (cc1_plugin::connection *self,\n     }\n   tree res = identifier;\n   if (!scope)\n-    res = lookup_name_real (res, LOOK_where::BLOCK_NAMESPACE, 0, 0, 0);\n+    res = lookup_name_real (res, LOOK_where::BLOCK_NAMESPACE,\n+\t\t\t    LOOK_want::NORMAL, 0);\n   else if (!TYPE_P (scope) || !dependent_scope_p (scope))\n     {\n-      res = lookup_qualified_name (scope, res, false, true);\n+      res = lookup_qualified_name (scope, res, LOOK_want::NORMAL, true);\n       /* We've already resolved the name in the scope, so skip the\n \t build_qualified_name call below.  */\n       scope = NULL;"}]}