{"sha": "7c355bca10d745fdac57df6a07e1c92fbe3ed8af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MzNTViY2ExMGQ3NDVmZGFjNTdkZjZhMDdlMWM5MmZiZTNlZDhhZg==", "commit": {"author": {"name": "Martin v. L\u00f6wis", "email": "loewis@informatik.hu-berlin.de", "date": "1999-11-05T23:11:58Z"}, "committer": {"name": "Martin v. L\u00f6wis", "email": "loewis@gcc.gnu.org", "date": "1999-11-05T23:11:58Z"}, "message": "cp-tree.h (VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK): New macro.\n\n\t* cp-tree.h (VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK): New macro.\n\t(DECL_TEMPLATE_INFO): Use it.\n\t* decl.c (warn_extern_redeclared_static): Do nothing for\n\tTEMPLATE_DECLs.\n\t* decl2.c (mark_used): Explicitly check for function or variable.\n\t* semantics.c (finish_unary_op_expr): Check whether result is also\n\tan INTEGER_CST.\n\nFrom-SVN: r30426", "tree": {"sha": "3a2d5b2d2ea6a81be81deb66093129b9d26e96db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a2d5b2d2ea6a81be81deb66093129b9d26e96db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c355bca10d745fdac57df6a07e1c92fbe3ed8af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c355bca10d745fdac57df6a07e1c92fbe3ed8af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c355bca10d745fdac57df6a07e1c92fbe3ed8af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c355bca10d745fdac57df6a07e1c92fbe3ed8af/comments", "author": null, "committer": null, "parents": [{"sha": "32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5"}], "stats": {"total": 45, "additions": 36, "deletions": 9}, "files": [{"sha": "0cc115e643671297f69c17d7a8fa2a11a40a005b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c355bca10d745fdac57df6a07e1c92fbe3ed8af/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c355bca10d745fdac57df6a07e1c92fbe3ed8af/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7c355bca10d745fdac57df6a07e1c92fbe3ed8af", "patch": "@@ -1,3 +1,13 @@\n+1999-11-05  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n+\n+\t* cp-tree.h (VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK): New macro.\n+\t(DECL_TEMPLATE_INFO): Use it.\n+\t* decl.c (warn_extern_redeclared_static): Do nothing for\n+\tTEMPLATE_DECLs.\n+\t* decl2.c (mark_used): Explicitly check for function or variable.\n+\t* semantics.c (finish_unary_op_expr): Check whether result is also\n+\tan INTEGER_CST.\n+\n 1999-11-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in (typeck2.o): Depend on output.h."}, {"sha": "47bb32bbc6b60886ae0a6e224e1e7839bcf75f09", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c355bca10d745fdac57df6a07e1c92fbe3ed8af/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c355bca10d745fdac57df6a07e1c92fbe3ed8af/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7c355bca10d745fdac57df6a07e1c92fbe3ed8af", "patch": "@@ -134,6 +134,17 @@ Boston, MA 02111-1307, USA.  */\n \t\t\t __LINE__, __PRETTY_FUNCTION__);\t\\\n     __t; })\n \n+#define VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK(NODE)\t\t\\\n+({  const tree __t = NODE;\t\t\t\t\t\\\n+    enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n+    if (__c != VAR_DECL \t\t\t\t\t\\\n+\t&& __c != FUNCTION_DECL\t\t\t\t\t\\\n+\t&& __c != TYPE_DECL\t\t\t\t\t\\\n+\t&& __c != TEMPLATE_DECL)\t\t\t\t\\\n+      tree_check_failed (__t, VAR_DECL, __FILE__,\t\t\\\n+\t\t\t __LINE__, __PRETTY_FUNCTION__);\t\\\n+    __t; })\n+\n #define RECORD_OR_UNION_TYPE_CHECK(NODE)\t\t\t\\\n ({  const tree __t = NODE;\t\t\t\t\t\\\n     enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n@@ -145,6 +156,7 @@ Boston, MA 02111-1307, USA.  */\n #else /* not ENABLE_CHECKING, or not gcc */\n \n #define VAR_OR_FUNCTION_DECL_CHECK(NODE)\tNODE\n+#define VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK(NODE)\tNODE\n #define RECORD_OR_UNION_TYPE_CHECK(NODE)\tNODE\n \n #endif\n@@ -1601,7 +1613,8 @@ struct lang_decl_flags\n   tree context;\n \n   union {\n-    /* In a FUNCTION_DECL or a VAR_DECL, this is DECL_TEMPLATE_INFO.  */\n+    /* In a FUNCTION_DECL, VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this\n+       is DECL_TEMPLATE_INFO.  */\n     tree template_info;\n \n     /* In a NAMESPACE_DECL, this is NAMESPACE_LEVEL.  */\n@@ -1838,9 +1851,10 @@ struct lang_decl\n #define DECL_SAVED_INLINE(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->decl_flags.saved_inline)\n \n-/* For a VAR_DECL or FUNCTION_DECL: template-specific information.  */\n+/* For a VAR_DECL, FUNCTION_DECL, TYPE_DECL or TEMPLATE_DECL:\n+   template-specific information.  */\n #define DECL_TEMPLATE_INFO(NODE) \\\n-  (DECL_LANG_SPECIFIC(VAR_OR_FUNCTION_DECL_CHECK (NODE))->decl_flags.u.template_info)\n+  (DECL_LANG_SPECIFIC(VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK (NODE))->decl_flags.u.template_info)\n \n /* Template information for a RECORD_TYPE or UNION_TYPE.  */\n #define CLASSTYPE_TEMPLATE_INFO(NODE) \\"}, {"sha": "226f6ae2deb11ed88d988e01b07553de38f9c90b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c355bca10d745fdac57df6a07e1c92fbe3ed8af/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c355bca10d745fdac57df6a07e1c92fbe3ed8af/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7c355bca10d745fdac57df6a07e1c92fbe3ed8af", "patch": "@@ -2900,7 +2900,8 @@ warn_extern_redeclared_static (newdecl, olddecl)\n \n   tree name;\n \n-  if (TREE_CODE (newdecl) == TYPE_DECL)\n+  if (TREE_CODE (newdecl) == TYPE_DECL \n+      || TREE_CODE (newdecl) == TEMPLATE_DECL)\n     return;\n   \n   /* Don't get confused by static member functions; that's a different"}, {"sha": "5624767b51dcc9661078673c7a25031e133739b9", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c355bca10d745fdac57df6a07e1c92fbe3ed8af/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c355bca10d745fdac57df6a07e1c92fbe3ed8af/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=7c355bca10d745fdac57df6a07e1c92fbe3ed8af", "patch": "@@ -5152,11 +5152,9 @@ mark_used (decl)\n \n   /* If this is a function or variable that is an instance of some\n      template, we now know that we will need to actually do the\n-     instantiation.  A TEMPLATE_DECL may also have DECL_TEMPLATE_INFO,\n-     if it's a partial instantiation, but there's no need to\n-     instantiate such a thing.  We check that DECL is not an explicit\n+     instantiation. We check that DECL is not an explicit\n      instantiation because that is not checked in instantiate_decl.  */\n-  if (TREE_CODE (decl) != TEMPLATE_DECL\n+  if ((TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)\n       && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)\n       && !DECL_EXPLICIT_INSTANTIATION (decl))\n     instantiate_decl (decl);"}, {"sha": "3eb955e9a3a900404a34b4347193c341ad9f7032", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c355bca10d745fdac57df6a07e1c92fbe3ed8af/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c355bca10d745fdac57df6a07e1c92fbe3ed8af/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=7c355bca10d745fdac57df6a07e1c92fbe3ed8af", "patch": "@@ -1597,7 +1597,11 @@ finish_unary_op_expr (code, expr)\n      tree expr;\n {\n   tree result = build_x_unary_op (code, expr);\n-  if (code == NEGATE_EXPR && TREE_CODE (expr) == INTEGER_CST)\n+  /* Inside a template, build_x_unary_op does not fold the\n+     expression. So check whether the result is folded before\n+     setting TREE_NEGATED_INT.  */\n+  if (code == NEGATE_EXPR && TREE_CODE (expr) == INTEGER_CST\n+      && TREE_CODE (result) == INTEGER_CST)\n     TREE_NEGATED_INT (result) = 1;\n   overflow_warning (result);\n   return result;"}]}