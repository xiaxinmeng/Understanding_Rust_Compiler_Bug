{"sha": "aa683f5c03673210edc89d1057868f59583570ea", "node_id": "C_kwDOANBUbNoAKGFhNjgzZjVjMDM2NzMyMTBlZGM4OWQxMDU3ODY4ZjU5NTgzNTcwZWE", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-05-31T11:20:46Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-04T07:45:59Z"}, "message": "[Ada] Small housekeeping work in Expand_N_Object_Declaration\n\nThe local function Rewrite_As_Renaming can be called twice in certain\ncircumstances, which is both not quite safe and unnecessary, so this\nreplaces it with a local variable whose value is computed only once.\n\nNo functional changes.\n\ngcc/ada/\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration) <OK_To_Rename_Ref>: New\n\tlocal function.\n\t<Rewrite_As_Renaming>: Change to a local variable whose value is\n\tcomputed once and generate a call to Finalize after this is done.\n\tSimplify the code creating the renaming at the end.", "tree": {"sha": "49c7e4ff1ce0e549b9e3896c37e25d4ef3c36c42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49c7e4ff1ce0e549b9e3896c37e25d4ef3c36c42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa683f5c03673210edc89d1057868f59583570ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa683f5c03673210edc89d1057868f59583570ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa683f5c03673210edc89d1057868f59583570ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa683f5c03673210edc89d1057868f59583570ea/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f94aea27c0bbc2f174176bff9fece9626a5ee0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f94aea27c0bbc2f174176bff9fece9626a5ee0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f94aea27c0bbc2f174176bff9fece9626a5ee0a"}], "stats": {"total": 256, "additions": 119, "deletions": 137}, "files": [{"sha": "143e330018ef28d6b7becc53ff919f8bf06d1bc7", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 119, "deletions": 137, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa683f5c03673210edc89d1057868f59583570ea/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa683f5c03673210edc89d1057868f59583570ea/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=aa683f5c03673210edc89d1057868f59583570ea", "patch": "@@ -6173,7 +6173,7 @@ package body Exp_Ch3 is\n       Obj_Def  : constant Node_Id    := Object_Definition (N);\n       Typ      : constant Entity_Id  := Etype (Def_Id);\n       Base_Typ : constant Entity_Id  := Base_Type (Typ);\n-      Expr_Q   : Node_Id;\n+      Next_N   : constant Node_Id    := Next (N);\n \n       function Build_Equivalent_Aggregate return Boolean;\n       --  If the object has a constrained discriminated type and no initial\n@@ -6193,9 +6193,8 @@ package body Exp_Ch3 is\n       --  Generate all default initialization actions for object Def_Id. Any\n       --  new code is inserted after node After.\n \n-      function Rewrite_As_Renaming return Boolean;\n-      --  Indicate whether to rewrite a declaration with initialization into an\n-      --  object renaming declaration (see below).\n+      function OK_To_Rename_Ref (N : Node_Id) return Boolean;\n+      --  Return True if N denotes an entity with OK_To_Rename set\n \n       --------------------------------\n       -- Build_Equivalent_Aggregate --\n@@ -6801,91 +6800,21 @@ package body Exp_Ch3 is\n          end if;\n       end Default_Initialize_Object;\n \n-      -------------------------\n-      -- Rewrite_As_Renaming --\n-      -------------------------\n-\n-      function Rewrite_As_Renaming return Boolean is\n-\n-         function OK_To_Rename_Entity_Name (N : Node_Id) return Boolean;\n-         --  Return True if N denotes an entity with OK_To_Rename set\n-\n-         ------------------------------\n-         -- OK_To_Rename_Entity_Name --\n-         ------------------------------\n-\n-         function OK_To_Rename_Entity_Name (N : Node_Id) return Boolean is\n-         begin\n-            return Is_Entity_Name (N)\n-              and then Ekind (Entity (N)) = E_Variable\n-              and then OK_To_Rename (Entity (N));\n-         end OK_To_Rename_Entity_Name;\n-\n-         Result : constant Boolean :=\n-\n-         --  If the object declaration appears in the form\n-\n-         --    Obj : Typ := Func (...);\n-\n-         --  where Typ both needs finalization and is returned on the secondary\n-         --  stack, the object declaration can be rewritten into a dereference\n-         --  of the reference to the result built on the secondary stack (see\n-         --  Expand_Ctrl_Function_Call for this expansion of the call):\n-\n-         --    type Axx is access all Typ;\n-         --    Rxx : constant Axx := Func (...)'reference;\n-         --    Obj : Typ renames Rxx.all;\n-\n-         --  This avoids an extra copy and the pair of Adjust/Finalize calls.\n-\n-         (not Is_Library_Level_Entity (Def_Id)\n-            and then Nkind (Expr_Q) = N_Explicit_Dereference\n-            and then not Comes_From_Source (Expr_Q)\n-            and then Nkind (Original_Node (Expr_Q)) = N_Function_Call\n-            and then Needs_Finalization (Typ)\n-            and then not Is_Class_Wide_Type (Typ))\n-\n-           --  If the initializing expression is for a variable with attribute\n-           --  OK_To_Rename set, then transform:\n-\n-           --     Obj : Typ := Expr;\n-\n-           --  into\n-\n-           --     Obj : Typ renames Expr;\n-\n-           --  provided that Obj is not aliased. The aliased case has to be\n-           --  excluded in general because Expr will not be aliased in general.\n+      ----------------------\n+      -- OK_To_Rename_Ref --\n+      ----------------------\n \n-           or else\n-             (not Aliased_Present (N)\n-               and then (OK_To_Rename_Entity_Name (Expr_Q)\n-                          or else\n-                         (Nkind (Expr_Q) = N_Slice\n-                           and then\n-                          OK_To_Rename_Entity_Name (Prefix (Expr_Q)))));\n+      function OK_To_Rename_Ref (N : Node_Id) return Boolean is\n       begin\n-         return Result\n-\n-           --  The declaration cannot be rewritten if it has got constraints,\n-           --  in other words the nominal subtype must be unconstrained.\n-\n-           and then Is_Entity_Name (Original_Node (Obj_Def))\n-\n-           --  ??? Return False if there are any aspect specifications, because\n-           --  otherwise we duplicate that corresponding implicit attribute\n-           --  definition, and call Insert_Action, which has no place to insert\n-           --  the attribute definition. The attribute definition is stored in\n-           --  Aspect_Rep_Item, which is not a list.\n-\n-           and then No (Aspect_Specifications (N));\n-      end Rewrite_As_Renaming;\n+         return Is_Entity_Name (N)\n+           and then Ekind (Entity (N)) = E_Variable\n+           and then OK_To_Rename (Entity (N));\n+      end OK_To_Rename_Ref;\n \n       --  Local variables\n \n-      Next_N : constant Node_Id := Next (N);\n-\n       Adj_Call   : Node_Id;\n+      Expr_Q     : Node_Id;\n       Id_Ref     : Node_Id;\n       Tag_Assign : Node_Id;\n \n@@ -6895,6 +6824,9 @@ package body Exp_Ch3 is\n       --  which case the init proc call must be inserted only after the bodies\n       --  of the shared variable procedures have been seen.\n \n+      Rewrite_As_Renaming : Boolean := False;\n+      --  Whether to turn the declaration into a renaming at the end\n+\n    --  Start of processing for Expand_N_Object_Declaration\n \n    begin\n@@ -7442,33 +7374,6 @@ package body Exp_Ch3 is\n                end if;\n             end if;\n \n-            --  If the type needs finalization and is not inherently limited,\n-            --  then the target is adjusted after the copy and attached to the\n-            --  finalization list. However, no adjustment is needed in the case\n-            --  where the object has been initialized by a call to a function\n-            --  returning on the primary stack (see Expand_Ctrl_Function_Call)\n-            --  since no copy occurred, given that the type is by-reference.\n-            --  Similarly, no adjustment is needed if we are going to rewrite\n-            --  the object declaration into a renaming declaration.\n-\n-            if Needs_Finalization (Typ)\n-              and then not Is_Limited_View (Typ)\n-              and then Nkind (Expr_Q) /= N_Function_Call\n-              and then not Rewrite_As_Renaming\n-            then\n-               Adj_Call :=\n-                 Make_Adjust_Call (\n-                   Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n-                   Typ     => Base_Typ);\n-\n-               --  Guard against a missing [Deep_]Adjust when the base type\n-               --  was not properly frozen.\n-\n-               if Present (Adj_Call) then\n-                  Insert_Action_After (Init_After, Adj_Call);\n-               end if;\n-            end if;\n-\n             --  For tagged types, when an init value is given, the tag has to\n             --  be re-initialized separately in order to avoid the propagation\n             --  of a wrong tag coming from a view conversion unless the type\n@@ -7587,6 +7492,91 @@ package body Exp_Ch3 is\n                   Set_Is_Known_Valid (Def_Id);\n                end if;\n             end if;\n+\n+            --  Now determine whether we will use a renaming\n+\n+            Rewrite_As_Renaming :=\n+\n+              --  If the object declaration appears in the form\n+\n+              --    Obj : Typ := Func (...);\n+\n+              --  where Typ needs finalization and is returned on the secondary\n+              --  stack, the declaration can be rewritten into a dereference of\n+              --  the reference to the result built on the secondary stack (see\n+              --  Expand_Ctrl_Function_Call for this expansion of the call):\n+\n+              --    type Axx is access all Typ;\n+              --    Rxx : constant Axx := Func (...)'reference;\n+              --    Obj : Typ renames Rxx.all;\n+\n+              --  This avoids an extra copy and a pair of Adjust/Finalize calls\n+\n+              ((not Is_Library_Level_Entity (Def_Id)\n+                 and then Nkind (Expr_Q) = N_Explicit_Dereference\n+                 and then not Comes_From_Source (Expr_Q)\n+                 and then Nkind (Original_Node (Expr_Q)) = N_Function_Call\n+                 and then Needs_Finalization (Typ)\n+                 and then not Is_Class_Wide_Type (Typ))\n+\n+                --  If the initializing expression is for a variable with flag\n+                --  OK_To_Rename set, then transform:\n+\n+                --     Obj : Typ := Expr;\n+\n+                --  into\n+\n+                --     Obj : Typ renames Expr;\n+\n+                --  provided that Obj is not aliased. The aliased case has to\n+                --  be excluded because Expr will not be aliased in general.\n+\n+               or else (not Aliased_Present (N)\n+                         and then (OK_To_Rename_Ref (Expr_Q)\n+                                    or else\n+                                   (Nkind (Expr_Q) = N_Slice\n+                                     and then\n+                                    OK_To_Rename_Ref (Prefix (Expr_Q))))))\n+\n+              --  The declaration cannot be rewritten if it has got constraints\n+              --  in other words the nominal subtype must be unconstrained.\n+\n+              and then Is_Entity_Name (Original_Node (Obj_Def))\n+\n+              --  ??? Likewise if there are any aspect specifications, because\n+              --  otherwise we duplicate that corresponding implicit attribute\n+              --  definition and call Insert_Action, which has no place for the\n+              --  attribute definition. The attribute definition is stored in\n+              --  Aspect_Rep_Item, which is not a list.\n+\n+              and then No (Aspect_Specifications (N));\n+\n+            --  If the type needs finalization and is not inherently limited,\n+            --  then the target is adjusted after the copy and attached to the\n+            --  finalization list. However, no adjustment is needed in the case\n+            --  where the object has been initialized by a call to a function\n+            --  returning on the primary stack (see Expand_Ctrl_Function_Call)\n+            --  since no copy occurred, given that the type is by-reference.\n+            --  Similarly, no adjustment is needed if we are going to rewrite\n+            --  the object declaration into a renaming declaration.\n+\n+            if Needs_Finalization (Typ)\n+              and then not Is_Limited_View (Typ)\n+              and then Nkind (Expr_Q) /= N_Function_Call\n+              and then not Rewrite_As_Renaming\n+            then\n+               Adj_Call :=\n+                 Make_Adjust_Call (\n+                   Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n+                   Typ     => Base_Typ);\n+\n+               --  Guard against a missing [Deep_]Adjust when the base type\n+               --  was not properly frozen.\n+\n+               if Present (Adj_Call) then\n+                  Insert_Action_After (Init_After, Adj_Call);\n+               end if;\n+            end if;\n          end if;\n \n          --  Cases where the back end cannot handle the initialization\n@@ -7714,40 +7704,32 @@ package body Exp_Ch3 is\n       --  declaration, then this transformation generates what would be\n       --  illegal code if written by hand, but that's OK.\n \n-      if Present (Expr) then\n-         if Rewrite_As_Renaming then\n-            Rewrite (N,\n-              Make_Object_Renaming_Declaration (Loc,\n-                Defining_Identifier => Defining_Identifier (N),\n-                Subtype_Mark        => Obj_Def,\n-                Name                => Expr_Q));\n+      if Rewrite_As_Renaming then\n+         Rewrite (N,\n+           Make_Object_Renaming_Declaration (Loc,\n+             Defining_Identifier => Defining_Identifier (N),\n+             Subtype_Mark        => Obj_Def,\n+             Name                => Expr_Q));\n \n-            --  We do not analyze this renaming declaration, because all its\n-            --  components have already been analyzed, and if we were to go\n-            --  ahead and analyze it, we would in effect be trying to generate\n-            --  another declaration of X, which won't do.\n+         --  We do not analyze this renaming declaration, because all its\n+         --  components have already been analyzed, and if we were to go\n+         --  ahead and analyze it, we would in effect be trying to generate\n+         --  another declaration of X, which won't do.\n \n-            Set_Renamed_Object (Defining_Identifier (N), Expr_Q);\n-            Set_Analyzed (N);\n+         Set_Renamed_Object (Defining_Identifier (N), Expr_Q);\n+         Set_Analyzed (N);\n \n-            --  We do need to deal with debug issues for this renaming\n+         --  We do need to deal with debug issues for this renaming\n \n-            --  First, if entity comes from source, then mark it as needing\n-            --  debug information, even though it is defined by a generated\n-            --  renaming that does not come from source.\n+         --  First, if entity comes from source, then mark it as needing\n+         --  debug information, even though it is defined by a generated\n+         --  renaming that does not come from source.\n \n-            Set_Debug_Info_Defining_Id (N);\n+         Set_Debug_Info_Defining_Id (N);\n \n-            --  Now call the routine to generate debug info for the renaming\n+         --  Now call the routine to generate debug info for the renaming\n \n-            declare\n-               Decl : constant Node_Id := Debug_Renaming_Declaration (N);\n-            begin\n-               if Present (Decl) then\n-                  Insert_Action (N, Decl);\n-               end if;\n-            end;\n-         end if;\n+         Insert_Action (N, Debug_Renaming_Declaration (N));\n       end if;\n \n    --  Exception on library entity not available"}]}