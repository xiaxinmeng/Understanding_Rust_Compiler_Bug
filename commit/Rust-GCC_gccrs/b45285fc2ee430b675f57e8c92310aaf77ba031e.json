{"sha": "b45285fc2ee430b675f57e8c92310aaf77ba031e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ1Mjg1ZmMyZWU0MzBiNjc1ZjU3ZThjOTIzMTBhYWY3N2JhMDMxZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-01-27T18:51:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-01-27T18:51:58Z"}, "message": "compiler: Accept map composite literals with omitted key types.\n\n    compiler: Copy key_path_ when copying a Composite_literal_expression.\n    \n    Fixes golang/go#10263.\n    \n    Reviewed-on: https://go-review.googlesource.com/14299\n    Reviewed-on: https://go-review.googlesource.com/18988\n\nFrom-SVN: r232892", "tree": {"sha": "668ea53d0e4fe91b41cc2d1c49cd4d7983cee20b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/668ea53d0e4fe91b41cc2d1c49cd4d7983cee20b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b45285fc2ee430b675f57e8c92310aaf77ba031e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b45285fc2ee430b675f57e8c92310aaf77ba031e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b45285fc2ee430b675f57e8c92310aaf77ba031e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b45285fc2ee430b675f57e8c92310aaf77ba031e/comments", "author": null, "committer": null, "parents": [{"sha": "8f91e6e0eff1494cfefb2129876847aab5748538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f91e6e0eff1494cfefb2129876847aab5748538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f91e6e0eff1494cfefb2129876847aab5748538"}], "stats": {"total": 190, "additions": 116, "deletions": 74}, "files": [{"sha": "755dee5aab1995ebd912291f0657946599d0bd3f", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45285fc2ee430b675f57e8c92310aaf77ba031e/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45285fc2ee430b675f57e8c92310aaf77ba031e/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=b45285fc2ee430b675f57e8c92310aaf77ba031e", "patch": "@@ -1,4 +1,4 @@\n-9e68d67d65fd72b9b4f163f2f26e15cd0d3e2cd2\n+8dce33f24dd3a34e3574c1d2604428586b63c1aa\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "09ab5bf8f7e19fc9625de2992f9b4252cc09a8a4", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 15, "deletions": 67, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45285fc2ee430b675f57e8c92310aaf77ba031e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45285fc2ee430b675f57e8c92310aaf77ba031e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=b45285fc2ee430b675f57e8c92310aaf77ba031e", "patch": "@@ -12583,69 +12583,7 @@ Map_construction_expression::do_dump_expression(\n   ast_dump_context->ostream() << \"}\";\n }\n \n-// A general composite literal.  This is lowered to a type specific\n-// version.\n-\n-class Composite_literal_expression : public Parser_expression\n-{\n- public:\n-  Composite_literal_expression(Type* type, int depth, bool has_keys,\n-\t\t\t       Expression_list* vals, bool all_are_names,\n-\t\t\t       Location location)\n-    : Parser_expression(EXPRESSION_COMPOSITE_LITERAL, location),\n-      type_(type), depth_(depth), vals_(vals), has_keys_(has_keys),\n-      all_are_names_(all_are_names)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse);\n-\n-  Expression*\n-  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return new Composite_literal_expression(this->type_, this->depth_,\n-\t\t\t\t\t    this->has_keys_,\n-\t\t\t\t\t    (this->vals_ == NULL\n-\t\t\t\t\t     ? NULL\n-\t\t\t\t\t     : this->vals_->copy()),\n-\t\t\t\t\t    this->all_are_names_,\n-\t\t\t\t\t    this->location());\n-  }\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-  \n- private:\n-  Expression*\n-  lower_struct(Gogo*, Type*);\n-\n-  Expression*\n-  lower_array(Type*);\n-\n-  Expression*\n-  make_array(Type*, const std::vector<unsigned long>*, Expression_list*);\n-\n-  Expression*\n-  lower_map(Gogo*, Named_object*, Statement_inserter*, Type*);\n-\n-  // The type of the composite literal.\n-  Type* type_;\n-  // The depth within a list of composite literals within a composite\n-  // literal, when the type is omitted.\n-  int depth_;\n-  // The values to put in the composite literal.\n-  Expression_list* vals_;\n-  // If this is true, then VALS_ is a list of pairs: a key and a\n-  // value.  In an array initializer, a missing key will be NULL.\n-  bool has_keys_;\n-  // If this is true, then HAS_KEYS_ is true, and every key is a\n-  // simple identifier.\n-  bool all_are_names_;\n-};\n+// Class Composite_literal_expression.\n \n // Traversal.\n \n@@ -12664,12 +12602,17 @@ Composite_literal_expression::do_traverse(Traverse* traverse)\n       // The type may not be resolvable at this point.\n       Type* type = this->type_;\n \n-      for (int depth = this->depth_; depth > 0; --depth)\n+      for (int depth = 0; depth < this->depth_; ++depth)\n         {\n           if (type->array_type() != NULL)\n             type = type->array_type()->element_type();\n           else if (type->map_type() != NULL)\n-            type = type->map_type()->val_type();\n+            {\n+              if (this->key_path_[depth])\n+                type = type->map_type()->key_type();\n+              else\n+                type = type->map_type()->val_type();\n+            }\n           else\n             {\n               // This error will be reported during lowering.\n@@ -12723,12 +12666,17 @@ Composite_literal_expression::do_lower(Gogo* gogo, Named_object* function,\n {\n   Type* type = this->type_;\n \n-  for (int depth = this->depth_; depth > 0; --depth)\n+  for (int depth = 0; depth < this->depth_; ++depth)\n     {\n       if (type->array_type() != NULL)\n \ttype = type->array_type()->element_type();\n       else if (type->map_type() != NULL)\n-\ttype = type->map_type()->val_type();\n+        {\n+          if (this->key_path_[depth])\n+            type = type->map_type()->key_type();\n+          else\n+            type = type->map_type()->val_type();\n+        }\n       else\n \t{\n \t  if (!type->is_error())"}, {"sha": "c33e63653e62072ae564a02db0a25257b6124fbb", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45285fc2ee430b675f57e8c92310aaf77ba031e/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45285fc2ee430b675f57e8c92310aaf77ba031e/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=b45285fc2ee430b675f57e8c92310aaf77ba031e", "patch": "@@ -47,6 +47,7 @@ class Bound_method_expression;\n class Field_reference_expression;\n class Interface_field_reference_expression;\n class Allocation_expression;\n+class Composite_literal_expression;\n class Struct_construction_expression;\n class Array_construction_expression;\n class Fixed_array_construction_expression;\n@@ -691,6 +692,15 @@ class Expression\n   allocation_expression()\n   { return this->convert<Allocation_expression, EXPRESSION_ALLOCATION>(); }\n \n+  // If this is a general composite literal, return the\n+  // Composite_literal_expression structure.  Otherwise, return NULL.\n+  Composite_literal_expression*\n+  complit()\n+  {\n+    return this->convert<Composite_literal_expression,\n+\t\t\t EXPRESSION_COMPOSITE_LITERAL>();\n+  }\n+\n   // If this is a struct composite literal, return the\n   // Struct_construction_expression structure.  Otherwise, return NULL.\n   Struct_construction_expression*\n@@ -2890,6 +2900,87 @@ class Allocation_expression : public Expression\n   bool allocate_on_stack_;\n };\n \n+// A general composite literal.  This is lowered to a type specific\n+// version.\n+\n+class Composite_literal_expression : public Parser_expression\n+{\n+ public:\n+  Composite_literal_expression(Type* type, int depth, bool has_keys,\n+\t\t\t       Expression_list* vals, bool all_are_names,\n+\t\t\t       Location location)\n+    : Parser_expression(EXPRESSION_COMPOSITE_LITERAL, location),\n+      type_(type), depth_(depth), vals_(vals), has_keys_(has_keys),\n+      all_are_names_(all_are_names), key_path_(std::vector<bool>(depth))\n+  {}\n+\n+\n+  // Mark the DEPTH entry of KEY_PATH as containing a key.\n+  void\n+  update_key_path(size_t depth)\n+  {\n+    go_assert(depth < this->key_path_.size());\n+    this->key_path_[depth] = true;\n+  }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  Expression*\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    Composite_literal_expression *ret =\n+      new Composite_literal_expression(this->type_, this->depth_,\n+\t\t\t\t       this->has_keys_,\n+\t\t\t\t       (this->vals_ == NULL\n+\t\t\t\t\t? NULL\n+\t\t\t\t\t: this->vals_->copy()),\n+\t\t\t\t       this->all_are_names_,\n+\t\t\t\t       this->location());\n+    ret->key_path_ = this->key_path_;\n+    return ret;\n+  }\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  Expression*\n+  lower_struct(Gogo*, Type*);\n+\n+  Expression*\n+  lower_array(Type*);\n+\n+  Expression*\n+  make_array(Type*, const std::vector<unsigned long>*, Expression_list*);\n+\n+  Expression*\n+  lower_map(Gogo*, Named_object*, Statement_inserter*, Type*);\n+\n+  // The type of the composite literal.\n+  Type* type_;\n+  // The depth within a list of composite literals within a composite\n+  // literal, when the type is omitted.\n+  int depth_;\n+  // The values to put in the composite literal.\n+  Expression_list* vals_;\n+  // If this is true, then VALS_ is a list of pairs: a key and a\n+  // value.  In an array initializer, a missing key will be NULL.\n+  bool has_keys_;\n+  // If this is true, then HAS_KEYS_ is true, and every key is a\n+  // simple identifier.\n+  bool all_are_names_;\n+  // A complement to DEPTH that indicates for each level starting from 0 to\n+  // DEPTH-1 whether or not this composite literal is nested inside of key or\n+  // a value.  This is used to decide which type to use when given a map literal\n+  // with omitted key types.\n+  std::vector<bool> key_path_;\n+};\n+\n // Construct a struct.\n \n class Struct_construction_expression : public Expression"}, {"sha": "827eb0a120aad310d553577a7332e08d6bbff2bd", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45285fc2ee430b675f57e8c92310aaf77ba031e/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45285fc2ee430b675f57e8c92310aaf77ba031e/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=b45285fc2ee430b675f57e8c92310aaf77ba031e", "patch": "@@ -2739,7 +2739,7 @@ Parse::composite_lit(Type* type, int depth, Location location)\n \t  // This must be a composite literal inside another composite\n \t  // literal, with the type omitted for the inner one.\n \t  val = this->composite_lit(type, depth + 1, token->location());\n-\t  is_type_omitted = true;\n+          is_type_omitted = true;\n \t}\n \n       token = this->peek_token();\n@@ -2751,11 +2751,14 @@ Parse::composite_lit(Type* type, int depth, Location location)\n \t}\n       else\n \t{\n-\t  if (is_type_omitted && !val->is_error_expression())\n-\t    {\n-\t      error_at(this->location(), \"unexpected %<:%>\");\n-\t      val = Expression::make_error(this->location());\n-\t    }\n+          if (is_type_omitted)\n+            {\n+              // VAL is a nested composite literal with an omitted type being\n+              // used a key.  Record this information in VAL so that the correct\n+              // type is associated with the literal value if VAL is a\n+              // map literal.\n+              val->complit()->update_key_path(depth);\n+            }\n \n \t  this->advance_token();\n "}]}