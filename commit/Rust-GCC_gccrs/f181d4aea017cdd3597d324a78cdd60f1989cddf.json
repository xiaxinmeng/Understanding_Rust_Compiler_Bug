{"sha": "f181d4aea017cdd3597d324a78cdd60f1989cddf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE4MWQ0YWVhMDE3Y2RkMzU5N2QzMjRhNzhjZGQ2MGYxOTg5Y2RkZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-12-13T14:46:07Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-12-13T14:46:07Z"}, "message": "cp-tree.def (CPLUS_BINDING): Update documentation.\n\n\t* cp-tree.def (CPLUS_BINDING): Update documentation.\n\t* cp-tree.h (LOCAL_BINDING_P): New macro.\n\t(lang_identifier): Rename local_value to bindings.\n\t(tree_binding): Make `scope' of type `void*', not `tree'.\n\t(BINDING_SCOPE): Update documentation.\n\t(IDENTIFIER_LOCAL_VALUE): Remove.\n\t(IDENTIFIER_CLASS_VALUE): Document.\n\t(IDENTIFIER_BINDING): New macro.\n\t(IDENTIFIER_VALUE): Likewise.\n\t(TIME_IDENTIFIER_TIME): Likewise.\n\t(TIME_IDENTIFIER_FILEINFO): Likewise.\n\t(IMPLICIT_TYPENAME_P): Likewise.\n\t(set_identifier_local_value): Remove.\n\t(push_local_binding): New function.\n\t(push_class_binding): Likewise.\n\t* class.c (pushclass): Update comments; use push_class_binding.\n\t* decl.c (set_identifier_local_value_with_scope): Remove.\n\t(set_identifier_local_value): Likewise.\n\t(push_binding): New function.\n\t(pop_binding): Likewise.\n\t(binding_level): Update documentation.  Remove shadowed.\n\t(BINDING_LEVEL): New macro.\n\t(free_binding_nodes): New variable.\n\t(poplevel): Adjust for new name-lookup scheme.  Don't mess up\n\tBLOCK_VARs when doing for-scope extension.  Remove effectively\n\tdead code.\n\t(pushlevel_class): Tweak formatting.\n\t(poplevel_class): Adjust for new name-lookup scheme.\n\t(print_binding_level): Likewise.\n\t(store_bindings): Likewise.\n\t(pushdecl): Likewise.\n\t(pushdecl_class_level): Likewise.\n\t(push_class_level_binding): Likewise.\n\t(push_overloaded_decl): Update comments.  Adjust for new\n\tname-lookup scheme.\n\t(lookup_name_real): Likewise.\n\t(lookup_name_current_level): Likewise.\n\t(cp_finish_decl): Likewise.\n\t(require_complete_types_for_parms): Likewise.  Remove misleading\n\t#if 0'd code.\n\t(grok_parms): Likewise.  Don't call\n\trequire_complete_types_for_parms here.\n\t(grok_ctor_properties): Don't treat templates as copy\n\tconstructors.\n\t(grop_op_properties): Or as assignment operators.\n\t(start_function): Document.  Adjust for new name-lookup scheme.\n\t(finish_function): Likewise.\n\t* decl2.c (do_local_using_decl): Use push_local_binding.\n\t* lex.c (begin_definition_of_inclass_inline): New function, split\n\tout from ...\n\t(do_pending_inlines): Here, and ...\n\t(process_next_inline): Here.\n\t(get_time_identifier): Use TIME_IDENTIFIER_* macros.\n\t(init_filename_times): Likewise.\n\t(extract_interface_info): Likewise.\n\t(ste_typedecl_interface_info): Likewise.\n\t(check_newline): Likewise.\n\t(dump_time_statistics): Likewise.\n\t(handle_cp_pragma): Likewise.\n\t(do_identifier): Adjust for new name-lookup scheme.\n\t* parse.y (function_try_block): Return ctor_initializer_opt value.\n\t(fndef): Use it.\n\t(fn.defpen): Pass appropriate values to start_function.\n\t(pending_inline): Use functor_try_block value, and pass\n\tappropriate values to finish_function.\n\t* pt.c (is_member_template): Update documentation; remove handling\n\tof FUNCTION_DECLs.  As per name, this function should deal only in\n\tTEMPLATE_DECLs.\n\t(decl_template_parm_p): Change name of olddecl parameter to decl.\n\t(check_template_shadow): Adjust for new name-lookup scheme.\n\t(lookup_template_class): Likewise.\n\t(tsubst_decl): Tweak so as not to confuse member templates with\n\tcopy constructors and assignment operators.\n\t(unify): Handle UNION_TYPEs.\n\t* ptree.c (print_lang_identifier): Adjust for new name-lookup scheme.\n\t(lang_print_xnode): Adjust for new name-lookup scheme.\n\t* typeck.c (mark_addressable): Likewise.\n\t(c_expand_return): Likewise.\n\nFrom-SVN: r24296", "tree": {"sha": "807c2e0544168b2313fcea1dce6434567e6f8339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/807c2e0544168b2313fcea1dce6434567e6f8339"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f181d4aea017cdd3597d324a78cdd60f1989cddf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f181d4aea017cdd3597d324a78cdd60f1989cddf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f181d4aea017cdd3597d324a78cdd60f1989cddf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f181d4aea017cdd3597d324a78cdd60f1989cddf/comments", "author": null, "committer": null, "parents": [{"sha": "92c068d1dc9b2bf77a9154e9cbaac97687ae9818", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92c068d1dc9b2bf77a9154e9cbaac97687ae9818", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92c068d1dc9b2bf77a9154e9cbaac97687ae9818"}], "stats": {"total": 1604, "additions": 988, "deletions": 616}, "files": [{"sha": "84cc28fa1b7d0ddb21b22fc1db13ddf8700d048f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -1,3 +1,84 @@\n+1998-12-13  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.def (CPLUS_BINDING): Update documentation.\n+\t* cp-tree.h (LOCAL_BINDING_P): New macro.\n+\t(lang_identifier): Rename local_value to bindings.\n+\t(tree_binding): Make `scope' of type `void*', not `tree'.\n+\t(BINDING_SCOPE): Update documentation.\n+\t(IDENTIFIER_LOCAL_VALUE): Remove.\n+\t(IDENTIFIER_CLASS_VALUE): Document.\n+\t(IDENTIFIER_BINDING): New macro.\n+\t(IDENTIFIER_VALUE): Likewise.\n+\t(TIME_IDENTIFIER_TIME): Likewise.\n+\t(TIME_IDENTIFIER_FILEINFO): Likewise.\n+\t(IMPLICIT_TYPENAME_P): Likewise.\n+\t(set_identifier_local_value): Remove.\n+\t(push_local_binding): New function.\n+\t(push_class_binding): Likewise.\n+\t* class.c (pushclass): Update comments; use push_class_binding.\n+\t* decl.c (set_identifier_local_value_with_scope): Remove.\n+\t(set_identifier_local_value): Likewise.\n+\t(push_binding): New function.\n+\t(pop_binding): Likewise.\n+\t(binding_level): Update documentation.  Remove shadowed.\n+\t(BINDING_LEVEL): New macro.\n+\t(free_binding_nodes): New variable.\n+\t(poplevel): Adjust for new name-lookup scheme.  Don't mess up\n+\tBLOCK_VARs when doing for-scope extension.  Remove effectively\n+\tdead code.\n+\t(pushlevel_class): Tweak formatting.\n+\t(poplevel_class): Adjust for new name-lookup scheme.\n+\t(print_binding_level): Likewise.\n+\t(store_bindings): Likewise.\n+\t(pushdecl): Likewise.\n+\t(pushdecl_class_level): Likewise.\n+\t(push_class_level_binding): Likewise.\n+\t(push_overloaded_decl): Update comments.  Adjust for new\n+\tname-lookup scheme.\n+\t(lookup_name_real): Likewise.\n+\t(lookup_name_current_level): Likewise.\n+\t(cp_finish_decl): Likewise.\n+\t(require_complete_types_for_parms): Likewise.  Remove misleading\n+\t#if 0'd code. \n+\t(grok_parms): Likewise.  Don't call\n+\trequire_complete_types_for_parms here.\n+\t(grok_ctor_properties): Don't treat templates as copy\n+\tconstructors. \n+\t(grop_op_properties): Or as assignment operators.\n+\t(start_function): Document.  Adjust for new name-lookup scheme.\n+\t(finish_function): Likewise.\n+\t* decl2.c (do_local_using_decl): Use push_local_binding.\n+\t* lex.c (begin_definition_of_inclass_inline): New function, split\n+\tout from ...\n+\t(do_pending_inlines): Here, and ...\n+\t(process_next_inline): Here.\n+\t(get_time_identifier): Use TIME_IDENTIFIER_* macros.\n+\t(init_filename_times): Likewise.\n+\t(extract_interface_info): Likewise.\n+\t(ste_typedecl_interface_info): Likewise.\n+\t(check_newline): Likewise.\n+\t(dump_time_statistics): Likewise.\n+\t(handle_cp_pragma): Likewise.\n+\t(do_identifier): Adjust for new name-lookup scheme.\n+\t* parse.y (function_try_block): Return ctor_initializer_opt value.\n+\t(fndef): Use it.\n+\t(fn.defpen): Pass appropriate values to start_function.\n+\t(pending_inline): Use functor_try_block value, and pass\n+\tappropriate values to finish_function.\n+\t* pt.c (is_member_template): Update documentation; remove handling\n+\tof FUNCTION_DECLs.  As per name, this function should deal only in\n+\tTEMPLATE_DECLs. \n+\t(decl_template_parm_p): Change name of olddecl parameter to decl.\n+\t(check_template_shadow): Adjust for new name-lookup scheme.\n+\t(lookup_template_class): Likewise.\n+\t(tsubst_decl): Tweak so as not to confuse member templates with\n+\tcopy constructors and assignment operators.\n+\t(unify): Handle UNION_TYPEs.\n+\t* ptree.c (print_lang_identifier): Adjust for new name-lookup scheme.\n+\t(lang_print_xnode): Adjust for new name-lookup scheme.\n+\t* typeck.c (mark_addressable): Likewise.\n+\t(c_expand_return): Likewise.\n+\t\n 1998-12-08  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (grokdeclarator): Allow field with same name as class"}, {"sha": "5031b55691758579ef6f341b69c6ded098f14286", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -4780,15 +4780,18 @@ pushclass (type, modify)\n \t{\n \t  tree item;\n \n-\t  /* Hooray, we successfully cached; let's just install the\n-\t     cached class_shadowed list, and walk through it to get the\n-\t     IDENTIFIER_TYPE_VALUEs correct.  */\n+\t  /* We are re-entering the same class we just left, so we\n+\t     don't have to search the whole inheritance matrix to find\n+\t     all the decls to bind again.  Instead, we install the\n+\t     cached class_shadowed list, and walk through it binding\n+\t     names and setting up IDENTIFIER_TYPE_VALUEs.  */\n \t  set_class_shadows (previous_class_values);\n \t  for (item = previous_class_values; item; item = TREE_CHAIN (item))\n \t    {\n \t      tree id = TREE_PURPOSE (item);\n \t      tree decl = IDENTIFIER_CLASS_VALUE (id);\n \n+\t      push_class_binding (id, decl);\n \t      if (TREE_CODE (decl) == TYPE_DECL)\n \t\tset_identifier_type_value (id, TREE_TYPE (decl));\n \t    }"}, {"sha": "37c444687fa1b39a2b848625b77e4fc40034e502", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -178,9 +178,9 @@ DEFTREECODE (DEFAULT_ARG, \"default_arg\", 'c', 2)\n    the template may be an IDENTIFIER_NODE.  */\n DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n \n-/* An association between namespace and entity. Parameters are the\n-   scope and the (non-type) value.\n-   TREE_TYPE indicates the type bound to the name. */\n+/* An association between name and entity. Parameters are the scope\n+   and the (non-type) value.  TREE_TYPE indicates the type bound to\n+   the name. */\n DEFTREECODE (CPLUS_BINDING, \"binding\", 'x', 2)\n \n /* A list-like node for chaining overloading candidates. TREE_TYPE is "}, {"sha": "395b24a2b40b1aa0b0277119f52957619eb5ef60", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n       LOOKUP_EXPR_GLOBAL (in LOOKUP_EXPR).\n       TREE_NEGATED_INT (in INTEGER_CST).\n       IDENTIFIER_MARKED (used by search routines).\n+      LOCAL_BINDING_P (in CPLUS_BINDING)\n    1:  IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -92,7 +93,8 @@ Boston, MA 02111-1307, USA.  */\n struct lang_identifier\n {\n   struct tree_identifier ignore;\n-  tree namespace_bindings, local_value;\n+  tree namespace_bindings;\n+  tree bindings;\n   tree class_value;\n   tree class_template_info;\n   struct lang_id2 *x;\n@@ -127,15 +129,24 @@ typedef struct ptrmem_cst\n   tree member;\n }* ptrmem_cst_t;\n \n-/* For a binding between a name and an entity, defines the scope\n-   where the binding is declared. Currently always points to a\n-   namespace declaration.  */\n-#define BINDING_SCOPE(NODE)    (((struct tree_binding*)NODE)->scope)\n+/* Nonzero if this binding is for a local scope, as opposed to a class\n+   or namespace scope.  */\n+#define LOCAL_BINDING_P(NODE) TREE_LANG_FLAG_0(NODE)\n+\n+/* For a binding between a name and an entity at a non-local scope,\n+   defines the scope where the binding is declared.  (Either a class\n+   _TYPE node, or a NAMESPACE_DECL.)  This macro should be used only\n+   for namespace-level bindings; on the IDENTIFIER_BINDING list\n+   BINDING_LEVEL is used instead.  */\n+#define BINDING_SCOPE(NODE) ((tree) ((struct tree_binding*)NODE)->scope)\n+\n /* This is the declaration bound to the name. Possible values:\n    variable, overloaded function, namespace, template, enumerator.  */\n #define BINDING_VALUE(NODE)    (((struct tree_binding*)NODE)->value)\n+\n /* If name is bound to a type, this is the type (struct, union, enum).  */\n #define BINDING_TYPE(NODE)     TREE_TYPE(NODE)\n+\n #define IDENTIFIER_GLOBAL_VALUE(NODE) \\\n   namespace_binding (NODE, global_namespace)\n #define SET_IDENTIFIER_GLOBAL_VALUE(NODE, VAL) \\\n@@ -148,7 +159,7 @@ typedef struct ptrmem_cst\n struct tree_binding\n {\n   char common[sizeof (struct tree_common)];\n-  tree scope;\n+  void* scope;\n   tree value;\n };\n \n@@ -200,13 +211,43 @@ struct tree_srcloc\n \n #define IDENTIFIER_NAMESPACE_BINDINGS(NODE)\t\\\n   (((struct lang_identifier *)(NODE))->namespace_bindings)\n-#define IDENTIFIER_CLASS_VALUE(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->class_value)\n-#define IDENTIFIER_LOCAL_VALUE(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->local_value)\n #define IDENTIFIER_TEMPLATE(NODE)\t\\\n   (((struct lang_identifier *)(NODE))->class_template_info)\n \n+/* The IDENTIFIER_BINDING is the innermost CPLUS_BINDING for the\n+    identifier.  It's TREE_CHAIN is the next outermost binding.  Each\n+    BINDING_VALUE is a DECL for the associated declaration.  Thus,\n+    name lookup consists simply of pulling off the node at the front\n+    of the list (modulo oddities for looking up the names of types,\n+    and such.)  You can use BINDING_SCOPE or BINDING_LEVEL to\n+    determine the scope that bound the name.  */\n+#define IDENTIFIER_BINDING(NODE) \\\n+  (((struct lang_identifier*) (NODE))->bindings)\n+\n+/* The IDENTIFIER_VALUE is the value of the IDENTIFIER_BINDING, or\n+   NULL_TREE if there is no binding.  */\n+#define IDENTIFIER_VALUE(NODE)\t\t\t\\\n+  (IDENTIFIER_BINDING (NODE) \t\t\t\\\n+   ? BINDING_VALUE (IDENTIFIER_BINDING (NODE))\t\\\n+   : NULL_TREE)\n+\n+/* If we are currently in class scope, then IDENTIFIER_CLASS_VALUE\n+   indicates the class-scoped binding of NODE.  This is just a pointer\n+   to the BINDING_VALUE of one of the bindings in the\n+   IDENTIFIER_BINDINGs list, so any time that this is set so is\n+   IDENTIFIER_BINDING.  */\n+#define IDENTIFIER_CLASS_VALUE(NODE) \\\n+  (((struct lang_identifier *) (NODE))->class_value)\n+\n+/* The amount of time used by the file whose special \"time identifier\"\n+   is NODE, represented as an INTEGER_CST.  See get_time_identifier.  */\n+#define TIME_IDENTIFIER_TIME(NODE) IDENTIFIER_BINDING(NODE)\n+\n+/* For a \"time identifier\" this is a INTEGER_CST.  The\n+   TREE_INT_CST_LOW is 1 if the corresponding file is \"interface only\".\n+   The TRE_INT_CST_HIGH is 1 if it is \"interface unknown\".  */\n+#define TIME_IDENTIFIER_FILEINFO(NODE) IDENTIFIER_CLASS_VALUE (NODE)\n+\n /* TREE_TYPE only indicates on local and class scope the current\n    type. For namespace scope, the presence of a type in any namespace\n    is indicated with global_type_node, and the real type behind must\n@@ -1444,6 +1485,10 @@ struct lang_decl\n    TEMPLATE_ID_EXPR if we had something like `typename X::Y<T>'.  */\n #define TYPENAME_TYPE_FULLNAME(NODE) TYPE_BINFO (NODE)\n \n+/* Nonzero if NODE is an implicit typename.  */\n+#define IMPLICIT_TYPENAME_P(NODE) \\\n+  (TREE_CODE (NODE) == TYPENAME_TYPE && TREE_TYPE (NODE))\n+\n /* Nonzero in INTEGER_CST means that this int is negative by dint of\n    using a twos-complement negated operand.  */\n #define TREE_NEGATED_INT(NODE) (TREE_LANG_FLAG_0 (NODE))\n@@ -2665,7 +2710,6 @@ extern void push_to_top_level\t\t\tPROTO((void));\n extern void pop_from_top_level\t\t\tPROTO((void));\n extern tree identifier_type_value\t\tPROTO((tree));\n extern void set_identifier_type_value\t\tPROTO((tree, tree));\n-extern void set_identifier_local_value\t\tPROTO((tree, tree));\n extern void pop_everything\t\t\tPROTO((void));\n extern void pushtag\t\t\t\tPROTO((tree, tree, int));\n extern tree make_anon_name\t\t\tPROTO((void));\n@@ -2761,6 +2805,8 @@ extern void revert_static_member_fn             PROTO((tree*, tree*, tree*));\n extern void cat_namespace_levels                PROTO((void));\n extern void fixup_anonymous_union               PROTO((tree));\n extern int check_static_variable_definition     PROTO((tree, tree));\n+extern void push_local_binding                  PROTO((tree, tree));\n+extern void push_class_binding                  PROTO((tree, tree));\n \n /* in decl2.c */\n extern int check_java_method\t\t\tPROTO((tree));"}, {"sha": "7c9a518e1617eb5fd04236fb865fbfcad1e510dd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 555, "deletions": 440, "changes": 995, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -169,8 +169,6 @@ static tree lookup_tag PROTO((enum tree_code, tree,\n \t\t\t      struct binding_level *, int));\n static void set_identifier_type_value_with_scope\n \tPROTO((tree, tree, struct binding_level *));\n-static void set_identifier_local_value_with_scope\n-\tPROTO((tree, tree, struct binding_level *));\n static void record_builtin_type PROTO((enum rid, char *, tree));\n static void record_unknown_type PROTO((tree, char *));\n static int member_function_or_else PROTO((tree, tree, char *));\n@@ -181,6 +179,8 @@ static tree maybe_process_template_type_declaration PROTO((tree, int, struct bin\n static void check_for_uninitialized_const_var PROTO((tree));\n static unsigned long typename_hash PROTO((hash_table_key));\n static boolean typename_compare PROTO((hash_table_key, hash_table_key));\n+static void push_binding PROTO((tree, tree, struct binding_level*));\n+static void pop_binding PROTO((tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -611,7 +611,8 @@ struct binding_level\n   {\n     /* A chain of _DECL nodes for all variables, constants, functions,\n        and typedef types.  These are in the reverse of the order\n-       supplied.  */\n+       supplied.  There may be OVERLOADs on this list, too, but they\n+       are wrapped in TREE_LISTs; the TREE_VALUE is the OVERLOAD.  */\n     tree names;\n \n     /* A list of structure, union and enum definitions, for looking up\n@@ -631,16 +632,16 @@ struct binding_level\n        VALUE the common ancestor with this binding_level's namespace. */\n     tree using_directives;\n \n-    /* For each level, a list of shadowed outer-level local definitions\n-       to be restored when this level is popped.\n-       Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n-       whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */\n-    tree shadowed;\n-\n-    /* Same, for IDENTIFIER_CLASS_VALUE.  */\n+    /* If this binding level is the binding level for a class, then\n+       class_shadowed is a TREE_LIST.  The TREE_PURPOSE of each node\n+       is the name of an entity bound in the class; the TREE_VALUE is\n+       the IDENTIFIER_CLASS_VALUE before we entered the class.  Thus,\n+       when leaving class scope, we can restore the\n+       IDENTIFIER_CLASS_VALUE by walking this list.  */\n     tree class_shadowed;\n \n-    /* Same, for IDENTIFIER_TYPE_VALUE.  */\n+    /* Similar to class_shadowed, but for IDENTIFIER_TYPE_VALUE, and\n+       is used for all binding levels.  */\n     tree type_shadowed;\n \n     /* For each level (except not the global one),\n@@ -661,7 +662,8 @@ struct binding_level\n \n     /* List of VAR_DECLS saved from a previous for statement.\n        These would be dead in ANSI-conforming code, but might\n-       be referenced in ARM-era code.  */\n+       be referenced in ARM-era code.  These are stored in a\n+       TREE_LIST; the TREE_VALUE is the actual declaration.  */\n     tree dead_vars_from_for;\n \n     /* 1 for the level that holds the parameters of a function.\n@@ -1030,6 +1032,112 @@ pushlevel_temporary (tag_transparent)\n   expand_start_bindings (0);\n }\n \n+/* For a binding between a name and an entity at a block scope,\n+   this is the `struct binding_level' for the block.  */\n+#define BINDING_LEVEL(NODE) \\\n+   ((struct binding_level*) ((struct tree_binding*)NODE)->scope)\n+\n+/* These are currently unused, but permanent, CPLUS_BINDING nodes.\n+   They are kept here because they are allocated from the permanent\n+   obstack and cannot be easily freed.  */\n+static tree free_binding_nodes;\n+\n+/* Make DECL the innermost binding for ID.  The LEVEL is the binding\n+   level at which this declaration is being bound.  */\n+\n+static void\n+push_binding (id, decl, level)\n+     tree id;\n+     tree decl;\n+     struct binding_level* level;\n+{\n+  tree binding;\n+\n+  if (!free_binding_nodes)\n+    {\n+      /* There are no free nodes, so we must build one here.  */\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      binding = make_node (CPLUS_BINDING);\n+      pop_obstacks ();\n+    }\n+  else\n+    {\n+      /* There are nodes on the free list.  Grab the first one.  */\n+      binding = free_binding_nodes;\n+      \n+      /* And update the free list.  */\n+      free_binding_nodes = TREE_CHAIN (free_binding_nodes);\n+    }\n+\n+  /* Now, fill in the binding information.  */\n+  BINDING_VALUE (binding) = decl;\n+  BINDING_LEVEL (binding) = level;\n+  LOCAL_BINDING_P (binding) = (level != class_binding_level);\n+\n+  /* And put it on the front of the ilst of bindings for ID.  */\n+  TREE_CHAIN (binding) = IDENTIFIER_BINDING (id);\n+  IDENTIFIER_BINDING (id) = binding;\n+}\n+\n+/* Bind DECL to ID in the current_binding_level.  */\n+\n+void\n+push_local_binding (id, decl)\n+     tree id;\n+     tree decl;\n+{\n+  tree d = decl;;\n+\n+  if (TREE_CODE (decl) == OVERLOAD)\n+    /* We must put the OVERLOAD into a TREE_LIST since the\n+       TREE_CHAIN of an OVERLOAD is already used.  */\n+    decl = build_tree_list (NULL_TREE, decl);\n+\n+  /* Create a binding, hanging off of ID.  */\n+  push_binding (id, d, current_binding_level);\n+\n+  /* And put DECL on the list of things declared by the current\n+     binding level.  */\n+  TREE_CHAIN (decl) = current_binding_level->names;\n+  current_binding_level->names = decl;\n+}\n+\n+/* Bind DECL to ID in the class_binding_level.  */\n+\n+void\n+push_class_binding (id, decl)\n+     tree id;\n+     tree decl;\n+{\n+  push_binding (id, decl, class_binding_level);\n+}\n+\n+/* Remove the innermost binding for ID; it has gone out of scope.  */\n+\n+static void \n+pop_binding (id) \n+     tree id;\n+{\n+  tree binding;\n+\n+  if (id == NULL_TREE)\n+    /* It's easiest to write the loops that call this function without\n+       checking whether or not the entities involved have names.  We\n+       get here for such an entity.  */\n+    return;\n+\n+  my_friendly_assert (IDENTIFIER_BINDING (id) != NULL_TREE, 0);\n+\n+  /* Unhook the innermost binding from the list of bindings.  */\n+  binding = IDENTIFIER_BINDING (id);\n+  IDENTIFIER_BINDING (id) = TREE_CHAIN (binding);\n+\n+  /* And place this list node on the free list.  */\n+  TREE_CHAIN (binding) = free_binding_nodes;\n+  free_binding_nodes = binding;\n+}\n+\n /* Exit a binding level.\n    Pop the level off, and restore the state of the identifier-decl mappings\n    that were in effect when this level was entered.\n@@ -1063,6 +1171,13 @@ poplevel (keep, reverse, functionbody)\n   tree block = NULL_TREE;\n   tree decl;\n   int block_previously_created;\n+  int leaving_for_scope;\n+\n+  if (current_binding_level->parm_flag == 2\n+      || current_binding_level->class_shadowed)\n+    /* We should not be using poplevel to pop a class binding level.\n+       Use poplevel_class instead.  */\n+    my_friendly_abort (0);\n \n   /* We used to use KEEP == 2 to indicate that the new block should go\n      at the beginning of the list of blocks at this binding level,\n@@ -1127,9 +1242,8 @@ poplevel (keep, reverse, functionbody)\n \t  if (decls || tags || subblocks)\n \t    {\n \t      if (BLOCK_VARS (block) || BLOCK_TYPE_TAGS (block))\n-\t\t{\n-\t\t  warning (\"internal compiler error: debugging info corrupted\");\n-\t\t}\n+\t\twarning (\"internal compiler error: debugging info corrupted\");\n+\n \t      BLOCK_VARS (block) = decls;\n \t      BLOCK_TYPE_TAGS (block) = tags;\n \n@@ -1148,7 +1262,8 @@ poplevel (keep, reverse, functionbody)\n \t  BLOCK_VARS (block) = decls;\n \t  BLOCK_TYPE_TAGS (block) = tags;\n \t  BLOCK_SUBBLOCKS (block) = subblocks;\n-\t  /* Otherwise, for a new block, install a new BLOCK_END_NOTE value.  */\n+\t  /* Otherwise, for a new block, install a new BLOCK_END_NOTE\n+\t     value.  */ \n \t  remember_end_note (block);\n \t}\n     }\n@@ -1159,92 +1274,116 @@ poplevel (keep, reverse, functionbody)\n     for (link = subblocks; link; link = TREE_CHAIN (link))\n       BLOCK_SUPERCONTEXT (link) = block;\n \n-  /* Clear out the meanings of the local variables of this level.  */\n-\n-  if (current_binding_level->is_for_scope && flag_new_for_scope == 1)\n-    {\n-      struct binding_level *outer = current_binding_level->level_chain;\n-      for (link = decls; link; link = TREE_CHAIN (link))\n-\t{\n-\t  if (TREE_CODE (link) == VAR_DECL)\n-\t    DECL_DEAD_FOR_LOCAL (link) = 1;\n+  /* We still support the old for-scope rules, whereby the variables\n+     in a for-init statement were in scope after the for-statement\n+     ended.  We only use the new rules in flag_new_for_scope is\n+     nonzero.  */\n+  leaving_for_scope \n+    = current_binding_level->is_for_scope && flag_new_for_scope == 1;\n+\n+  /* Remove declarations for all the DECLs in this level.  */\n+  for (link = decls; link; link = TREE_CHAIN (link))\n+    {\n+      if (leaving_for_scope && TREE_CODE (link) == VAR_DECL)\n+\t{\n+\t  tree outer_binding \n+\t    = TREE_CHAIN (IDENTIFIER_BINDING (DECL_NAME (link)));\n+\t  tree ns_binding;\n+\n+\t  if (!outer_binding)\n+\t    ns_binding = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (link));\n+\t\t\t\t\t\t   \n+\t  if (outer_binding \n+\t      && (BINDING_LEVEL (outer_binding) \n+\t\t  == current_binding_level->level_chain))\n+\t    /* We have something like:\n+\t       \n+\t         int i;\n+\t         for (int i; ;);\n+\t\t \n+\t       and we are leaving the `for' scope.  There's no reason to\n+\t       keep the binding of the inner `i' in this case.  */\n+\t    pop_binding (DECL_NAME (link));\n+\t  else if ((outer_binding \n+\t\t    && (TREE_CODE (BINDING_VALUE (outer_binding)) \n+\t\t\t== TYPE_DECL))\n+\t\t   || (ns_binding \n+\t\t       && TREE_CODE (ns_binding) == TYPE_DECL))\n+\t    /* Here, we have something like:\n+\n+\t\t typedef int I;\n+\n+\t\t void f () {\n+\t\t   for (int I; ;);\n+\t\t }\n+\n+\t       We must pop the for-scope binding so we know what's a\n+\t       type and what isn't.  */\n+\t    pop_binding (DECL_NAME (link));\n \t  else\n-\t    IDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = NULL_TREE;\n-\t}\n-\n-      /* Save declarations made in a 'for' statement so we can support pre-ANSI\n-\t 'for' scoping semantics.  */\n-\n-      for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n-\t{\n-\t  tree id = TREE_PURPOSE (link);\n-\t  tree decl = IDENTIFIER_LOCAL_VALUE (id);\n-\n-\t  if (decl && DECL_DEAD_FOR_LOCAL (decl))\n \t    {\n-\t      /* In this case keep the dead for-decl visible,\n-\t\t but remember what (if anything) it shadowed.  */\n-\t      DECL_SHADOWED_FOR_VAR (decl) = TREE_VALUE (link);\n-\t      TREE_CHAIN (decl) = outer->dead_vars_from_for;\n-\t      outer->dead_vars_from_for = decl;\n+\t      /* Mark this VAR_DECL as dead so that we can tell we left it\n+\t\t there only for backward compatibility.  */\n+\t      DECL_DEAD_FOR_LOCAL (link) = 1;\n+\t      \n+\t      /* Keep track of what should of have happenned when we\n+\t\t popped the binding.  */\n+\t      if (outer_binding && BINDING_VALUE (outer_binding))\n+\t\tDECL_SHADOWED_FOR_VAR (link) \n+\t\t  = BINDING_VALUE (outer_binding);\n+\n+\t      /* Add it to the list of dead variables in the next\n+\t\t outermost binding to that we can remove these when we\n+\t\t leave that binding.  */\n+\t      current_binding_level->level_chain->dead_vars_from_for\n+\t\t= tree_cons (NULL_TREE, link,\n+\t\t\t     current_binding_level->level_chain->\n+\t\t\t     dead_vars_from_for);\n+\n+\t      /* Although we don't pop the CPLUS_BINDING, we do clear\n+\t\t its BINDING_LEVEL since the level is going away now.  */\n+\t      BINDING_LEVEL (IDENTIFIER_BINDING (DECL_NAME (link)))\n+\t\t= 0;\n \t    }\n-\t  else\n-\t    IDENTIFIER_LOCAL_VALUE (id) = TREE_VALUE (link);\n \t}\n-    }\n-  else /* Not special for scope.  */\n-    {\n-      for (link = decls; link; link = TREE_CHAIN (link))\n+      else \n \t{\n-\t  if (DECL_NAME (link) != NULL_TREE)\n-\t    {\n-\t      /* If the ident. was used or addressed via a local extern decl,\n-\t\t don't forget that fact.  */\n-\t      if (DECL_EXTERNAL (link))\n-\t\t{\n-\t\t  if (TREE_USED (link))\n-\t\t    TREE_USED (DECL_ASSEMBLER_NAME (link)) = 1;\n-\t\t  if (TREE_ADDRESSABLE (link))\n-\t\t    TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (link)) = 1;\n-\t\t}\n-\t      IDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = NULL_TREE;\n-\t    }\n+\t  /* Remove the binding.  */\n+\t  if (TREE_CODE_CLASS (TREE_CODE (link)) == 'd')\n+\t    pop_binding (DECL_NAME (link));\n+\t  else if (TREE_CODE (link) == TREE_LIST)\n+\t    pop_binding (DECL_NAME (OVL_FUNCTION (TREE_VALUE (link))));\n+\t  else\n+\t    my_friendly_abort (0);\n \t}\n+    }\n \n-      /* Restore all name-meanings of the outer levels\n-\t that were shadowed by this level.  */\n-\n-      for (link = current_binding_level->shadowed;\n-\t   link; link = TREE_CHAIN (link))\n-\tIDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-\n-      /* We first restore the regular decls and *then* the dead_vars_from_for\n-\t to handle this case:\n-\n-\t int i; // i#1\n-\t {\n-\t   for (int i; ; ) { ...} // i#2\n-           int i; // i#3\n-\t } // we are here\n-\n-\t In this case, we want remove the binding for i#3, restoring\n-\t that of i#2.  Then we want to remove the binding for i#2,\n-\t and restore that of i#1.  */\n+  /* Remove declarations for any `for' variables from inner scopes\n+     that we kept around.  */\n+  for (link = current_binding_level->dead_vars_from_for;\n+       link; link = TREE_CHAIN (link))\n+    pop_binding (DECL_NAME (TREE_VALUE (link)));\n \n-      link = current_binding_level->dead_vars_from_for;\n-      for (; link != NULL_TREE; link = TREE_CHAIN (link))\n-\t{\n-\t  tree id = DECL_NAME (link);\n-\t  if (IDENTIFIER_LOCAL_VALUE (id) == link)\n-\t    IDENTIFIER_LOCAL_VALUE (id) = DECL_SHADOWED_FOR_VAR (link);\n-\t}\n+  /* Restore the IDENTIFIER_TYPE_VALUEs.  */\n+  for (link = current_binding_level->type_shadowed;\n+       link; link = TREE_CHAIN (link))\n+    SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link), TREE_VALUE (link));\n+  \n+  /* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs\n+     list if a `using' declaration put them there.  The debugging\n+     back-ends won't understand OVERLOAD, so we remove them here.\n+     Because the BLOCK_VARS are (temporarily) shared with\n+     CURRENT_BINDING_LEVEL->NAMES we must do this fixup after we have\n+     popped all the bindings.  */\n+  if (block)\n+    {\n+      tree* d;\n \n-      for (link = current_binding_level->class_shadowed;\n-\t   link; link = TREE_CHAIN (link))\n-\tIDENTIFIER_CLASS_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-      for (link = current_binding_level->type_shadowed;\n-\t   link; link = TREE_CHAIN (link))\n-\tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link), TREE_VALUE (link));\n+      for (d = &BLOCK_VARS (block); \n+\t   *d; \n+\t   d = *d ? &TREE_CHAIN (*d) : d)\n+\tif (TREE_CODE (*d) == TREE_LIST)\n+\t  *d = TREE_CHAIN (*d);\n     }\n \n   /* If the level being exited is the top level of a function,\n@@ -1407,9 +1546,7 @@ pushlevel_class ()\n       free_binding_level = free_binding_level->level_chain;\n     }\n   else\n-    {\n-      newlevel = make_binding_level ();\n-    }\n+    newlevel = make_binding_level ();\n \n #if defined(DEBUG_CP_BINDING_LEVELS)\n   is_class_level = 1;\n@@ -1444,8 +1581,6 @@ poplevel_class (force)\n   my_friendly_assert (level != 0, 354);\n   \n   decl_stack = pop_stack_level (decl_stack);\n-  for (shadowed = level->shadowed; shadowed; shadowed = TREE_CHAIN (shadowed))\n-    IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (shadowed)) = TREE_VALUE (shadowed);\n   /* If we're leaving a toplevel class, don't bother to do the setting\n      of IDENTIFIER_CLASS_VALUE to NULL_TREE, since first of all this slot\n      shouldn't even be used when current_class_type isn't set, and second,\n@@ -1468,6 +1603,12 @@ poplevel_class (force)\n        shadowed = TREE_CHAIN (shadowed))\n     SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (shadowed), TREE_VALUE (shadowed));\n \n+  /* Remove the bindings for all of the class-level declarations.  */\n+  for (shadowed = level->class_shadowed; \n+       shadowed; \n+       shadowed = TREE_CHAIN (shadowed))\n+    pop_binding (TREE_PURPOSE (shadowed));\n+\n   GNU_xref_end_scope ((HOST_WIDE_INT) class_binding_level,\n \t\t      (HOST_WIDE_INT) class_binding_level->level_chain,\n \t\t      class_binding_level->parm_flag,\n@@ -1574,15 +1715,6 @@ print_binding_level (lvl)\n       if (i)\n \tfprintf (stderr, \"\\n\");\n     }\n-  if (lvl->shadowed)\n-    {\n-      fprintf (stderr, \" shadowed:\");\n-      for (t = lvl->shadowed; t; t = TREE_CHAIN (t))\n-\t{\n-\t  fprintf (stderr, \" %s \", IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n-\t}\n-      fprintf (stderr, \"\\n\");\n-    }\n   if (lvl->class_shadowed)\n     {\n       fprintf (stderr, \" class-shadowed:\");\n@@ -1932,9 +2064,11 @@ store_bindings (names, old_bindings)\n       else\n \tid = DECL_NAME (t);\n \n-      if (!id\n-\t  || (!IDENTIFIER_LOCAL_VALUE (id)\n-\t      && !IDENTIFIER_CLASS_VALUE (id)))\n+      if (!id \n+\t  /* Note that we may have an IDENTIFIER_CLASS_VALUE even when\n+\t     we have no IDENTIFIER_BINDING if we have left the class\n+\t     scope, but cached the class-level declarations.  */\n+\t  || !(IDENTIFIER_BINDING (id) || IDENTIFIER_CLASS_VALUE (id)))\n \tcontinue;\n \n       for (t1 = old_bindings; t1; t1 = TREE_CHAIN (t1))\n@@ -1954,9 +2088,9 @@ store_bindings (names, old_bindings)\n \t  my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 135);\n \t  TREE_VEC_ELT (binding, 0) = id;\n \t  TREE_VEC_ELT (binding, 1) = REAL_IDENTIFIER_TYPE_VALUE (id);\n-\t  TREE_VEC_ELT (binding, 2) = IDENTIFIER_LOCAL_VALUE (id);\n+\t  TREE_VEC_ELT (binding, 2) = IDENTIFIER_BINDING (id);\n \t  TREE_VEC_ELT (binding, 3) = IDENTIFIER_CLASS_VALUE (id);\n-\t  IDENTIFIER_LOCAL_VALUE (id) = NULL_TREE;\n+\t  IDENTIFIER_BINDING (id) = NULL_TREE;\n \t  IDENTIFIER_CLASS_VALUE (id) = NULL_TREE;\n \t}\n       TREE_CHAIN (binding) = old_bindings;\n@@ -2085,7 +2219,7 @@ pop_from_top_level ()\n       if (id)\n \t{\n \t  SET_IDENTIFIER_TYPE_VALUE (id, TREE_VEC_ELT (t, 1));\n-\t  IDENTIFIER_LOCAL_VALUE (id) = TREE_VEC_ELT (t, 2);\n+\t  IDENTIFIER_BINDING (id) = TREE_VEC_ELT (t, 2);\n \t  IDENTIFIER_CLASS_VALUE (id) = TREE_VEC_ELT (t, 3);\n \t}\n       t = TREE_CHAIN (t);\n@@ -2169,26 +2303,6 @@ set_identifier_type_value (id, type)\n   set_identifier_type_value_with_scope (id, type, inner_binding_level);\n }\n \n-static void\n-set_identifier_local_value_with_scope (id, val, b)\n-     tree id, val;\n-     struct binding_level *b;\n-{\n-  tree oldlocal;\n-  my_friendly_assert (! b->namespace_p, 980716);\n-\n-  oldlocal = IDENTIFIER_LOCAL_VALUE (id);\n-  b->shadowed = tree_cons (id, oldlocal, b->shadowed);\n-  IDENTIFIER_LOCAL_VALUE (id) = val;\n-}\n-\n-void\n-set_identifier_local_value (id, val)\n-     tree id, val;\n-{\n-  set_identifier_local_value_with_scope (id, val, current_binding_level);\n-}\n-\n /* Return the type associated with id. */\n \n tree\n@@ -3322,14 +3436,14 @@ pushdecl (x)\n {\n   register tree t;\n   register tree name = DECL_ASSEMBLER_NAME (x);\n-  register struct binding_level *b = current_binding_level;\n+  int need_new_binding = 1;\n \n   if (current_function_decl && x != current_function_decl\n       /* A local declaration for a function doesn't constitute nesting.  */\n       && (TREE_CODE (x) != FUNCTION_DECL || DECL_INITIAL (x))\n       /* Don't change DECL_CONTEXT of virtual methods.  */\n       && (TREE_CODE (x) != FUNCTION_DECL || !DECL_VIRTUAL_P (x))\n-      && ! DECL_CONTEXT (x))\n+      && !DECL_CONTEXT (x))\n     DECL_CONTEXT (x) = current_function_decl;\n   if (!DECL_CONTEXT (x))\n     DECL_CONTEXT (x) = FROB_CONTEXT (current_namespace);\n@@ -3459,6 +3573,11 @@ pushdecl (x)\n \t  t = push_overloaded_decl (x, 1);\n \t  if (t != x || DECL_LANGUAGE (x) == lang_c)\n \t    return t;\n+\t  if (!namespace_bindings_p ())\n+\t    /* We do not need to create a binding for this name;\n+\t       push_overloaded_decl will have already done so if\n+\t       necessary.  */\n+\t    need_new_binding = 0;\n \t}\n       else if (DECL_FUNCTION_TEMPLATE_P (x) && DECL_NAMESPACE_SCOPE_P (x))\n \treturn push_overloaded_decl (x, 0);\n@@ -3495,7 +3614,15 @@ pushdecl (x)\n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)\n \t      && TYPE_IDENTIFIER (type))\n-            set_identifier_type_value_with_scope (DECL_NAME (x), type, b);\n+            set_identifier_type_value_with_scope (DECL_NAME (x), type, \n+\t\t\t\t\t\t  current_binding_level);\n+\n+\t  if (TREE_CODE (x) == TYPE_DECL\n+\t      && DECL_ARTIFICIAL (x)\n+\t      && t != NULL_TREE)\n+\t    /* We don't want an artificial TYPE_DECL is we already\n+\t       have another DECL with the same name.  */\n+\t    need_new_binding = 0;\n \t}\n \n       /* Multiple external decls of the same identifier ought to match.\n@@ -3536,11 +3663,7 @@ pushdecl (x)\n \t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && TREE_PUBLIC (x))\n \t    TREE_PUBLIC (name) = 1;\n \n-\t  /* Don't install an artificial TYPE_DECL if we already have\n-\t     another _DECL with that name.  */\n-\t  if (TREE_CODE (x) != TYPE_DECL\n-\t      || t == NULL_TREE\n-\t      || ! DECL_ARTIFICIAL (x))\n+\t  if (need_new_binding)\n \t    {\n \t      if (TREE_CODE (x) == FUNCTION_DECL)\n \t\tmy_friendly_assert \n@@ -3575,25 +3698,29 @@ pushdecl (x)\n       else\n \t{\n \t  /* Here to install a non-global value.  */\n-\t  tree oldlocal = IDENTIFIER_LOCAL_VALUE (name);\n+\t  tree oldlocal = IDENTIFIER_VALUE (name);\n \t  tree oldglobal = IDENTIFIER_NAMESPACE_VALUE (name);\n \n-\t  /* Don't install an artificial TYPE_DECL if we already have\n-\t     another _DECL with that name.  */\n-\t  if (TREE_CODE (x) != TYPE_DECL\n-\t      || t == NULL_TREE\n-\t      || ! DECL_ARTIFICIAL (x))\n-\t    set_identifier_local_value_with_scope (name, x, b);\n+\t  if (need_new_binding)\n+\t    {\n+\t      push_local_binding (name, x);\n+\t      /* Because push_local_binding will hook X on to the\n+\t\t current_binding_level's name list, we don't want to\n+\t\t do that again below.  */\n+\t      need_new_binding = 0;\n+\t    }\n \n \t  /* If this is a TYPE_DECL, push it into the type value slot.  */\n \t  if (TREE_CODE (x) == TYPE_DECL)\n-\t    set_identifier_type_value_with_scope (name, TREE_TYPE (x), b);\n+\t    set_identifier_type_value_with_scope (name, TREE_TYPE (x), \n+\t\t\t\t\t\t  current_binding_level);\n \n \t  /* Clear out any TYPE_DECL shadowed by a namespace so that\n \t     we won't think this is a type.  The C struct hack doesn't\n \t     go through namespaces.  */\n \t  if (TREE_CODE (x) == NAMESPACE_DECL)\n-\t    set_identifier_type_value_with_scope (name, NULL_TREE, b);\n+\t    set_identifier_type_value_with_scope (name, NULL_TREE, \n+\t\t\t\t\t\t  current_binding_level);\n \n \t  /* If this is an extern function declaration, see if we\n \t     have a global definition or declaration for the function.  */\n@@ -3619,9 +3746,7 @@ pushdecl (x)\n \t      && oldglobal == NULL_TREE\n \t      && DECL_EXTERNAL (x)\n \t      && TREE_PUBLIC (x))\n-\t    {\n-\t      TREE_PUBLIC (name) = 1;\n-\t    }\n+\t    TREE_PUBLIC (name) = 1;\n \n \t  if (DECL_FROM_INLINE (x))\n \t    /* Inline decls shadow nothing.  */;\n@@ -3642,7 +3767,8 @@ pushdecl (x)\n \t      if (b->parm_flag == 1)\n \t\tcp_error (\"declaration of `%#D' shadows a parameter\", name);\n \t    }\n-\t  else if (warn_shadow && oldlocal != NULL_TREE && b->is_for_scope\n+\t  else if (warn_shadow && oldlocal != NULL_TREE\n+\t\t   && current_binding_level->is_for_scope\n \t\t   && !DECL_DEAD_FOR_LOCAL (oldlocal))\n \t    {\n \t      warning (\"variable `%s' shadows local\",\n@@ -3686,15 +3812,20 @@ pushdecl (x)\n \t      /* RTTI TD entries are created while defining the type_info.  */\n \t      || (TYPE_LANG_SPECIFIC (TREE_TYPE (x))\n \t\t  && TYPE_BEING_DEFINED (TREE_TYPE (x)))))\n-\tb->incomplete = tree_cons (NULL_TREE, x, b->incomplete);\n+\tcurrent_binding_level->incomplete \n+\t  = tree_cons (NULL_TREE, x, current_binding_level->incomplete);\n     }\n \n-  /* Put decls on list in reverse order.\n-     We will reverse them later if necessary.  */\n-  TREE_CHAIN (x) = b->names;\n-  b->names = x;\n-  if (! (b != global_binding_level || TREE_PERMANENT (x)))\n-    my_friendly_abort (124);\n+  if (need_new_binding)\n+    {\n+      /* Put decls on list in reverse order.\n+\t We will reverse them later if necessary.  */\n+      TREE_CHAIN (x) = current_binding_level->names;\n+      current_binding_level->names = x;\n+      if (! (current_binding_level != global_binding_level \n+\t     || TREE_PERMANENT (x)))\n+\tmy_friendly_abort (124);\n+    }\n \n   return x;\n }\n@@ -3828,9 +3959,7 @@ pushdecl_class_level (x)\n \n       push_class_level_binding (name, x);\n       if (TREE_CODE (x) == TYPE_DECL)\n-\t{\n-\t  set_identifier_type_value (name, TREE_TYPE (x));\n-\t}\n+\tset_identifier_type_value (name, TREE_TYPE (x));\n     }\n }\n \n@@ -3874,12 +4003,20 @@ push_class_level_binding (name, x)\n       && purpose_member (name, class_binding_level->class_shadowed))\n     return;\n \n+  /* If this declaration shadows a declaration from an enclosing\n+     class, then we will need to restore IDENTIFIER_CLASS_VALUE when\n+     we leave this class.  Record the shadowed declaration here.  */\n   maybe_push_cache_obstack ();\n   class_binding_level->class_shadowed\n       = tree_cons (name, IDENTIFIER_CLASS_VALUE (name),\n \t\t   class_binding_level->class_shadowed);\n   pop_obstacks ();\n+\n+  /* Put the binding on the stack of bindings for the identifier, and\n+     update IDENTIFIER_CLASS_VALUE.  */\n+  push_class_binding (name, x);\n   IDENTIFIER_CLASS_VALUE (name) = x;\n+\n   obstack_ptr_grow (&decl_obstack, x);\n }\n \n@@ -3934,11 +4071,11 @@ push_using_directive (used)\n   return ud;\n }\n \n-/* DECL is a FUNCTION_DECL which may have other definitions already in\n-   place.  We get around this by making the value of the identifier point\n-   to a list of all the things that want to be referenced by that name.  It\n-   is then up to the users of that name to decide what to do with that\n-   list.\n+/* DECL is a FUNCTION_DECL for a non-member function, which may have\n+   other definitions already in place.  We get around this by making\n+   the value of the identifier point to a list of all the things that\n+   want to be referenced by that name.  It is then up to the users of\n+   that name to decide what to do with that list.\n \n    DECL may also be a TEMPLATE_DECL, with a FUNCTION_DECL in its DECL_RESULT\n    slot.  It is dealt with the same way.\n@@ -3952,13 +4089,14 @@ push_overloaded_decl (decl, forgettable)\n      tree decl;\n      int forgettable;\n {\n-  tree orig_name = DECL_NAME (decl);\n+  tree name = DECL_NAME (decl);\n   tree old;\n+  tree new_binding;\n   int doing_global = (namespace_bindings_p () || ! forgettable);\n \n   if (doing_global)\n     {\n-      old = namespace_binding (orig_name, DECL_CONTEXT (decl));\n+      old = namespace_binding (name, DECL_CONTEXT (decl));\n       if (old && TREE_CODE (old) == FUNCTION_DECL\n \t  && DECL_ARTIFICIAL (old)\n \t  && (DECL_BUILT_IN (old) || DECL_BUILT_IN_NONANSI (old)))\n@@ -3969,16 +4107,7 @@ push_overloaded_decl (decl, forgettable)\n \t}\n     }\n   else\n-    {\n-      old = IDENTIFIER_LOCAL_VALUE (orig_name);\n-\n-      if (! purpose_member (orig_name, current_binding_level->shadowed))\n-\t{\n-\t  current_binding_level->shadowed\n-\t    = tree_cons (orig_name, old, current_binding_level->shadowed);\n-\t  old = NULL_TREE;\n-\t}\n-    }\n+    old = lookup_name_current_level (name);\n \n   if (old)\n     {\n@@ -4011,17 +4140,44 @@ push_overloaded_decl (decl, forgettable)\n   if (old || TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n       if (old && TREE_CODE (old) != OVERLOAD)\n-\told = ovl_cons (old, NULL_TREE);\n-      old = ovl_cons (decl, old);\n+\tnew_binding = ovl_cons (decl, ovl_cons (old, NULL_TREE));\n+      else\n+\tnew_binding = ovl_cons (decl, old);\n     }\n   else\n-    /* orig_name is not ambiguous.  */\n-    old = decl;\n+    /* NAME is not ambiguous.  */\n+    new_binding = decl;\n \n   if (doing_global)\n-    set_namespace_binding (orig_name, current_namespace, old);\n+    set_namespace_binding (name, current_namespace, new_binding);\n   else\n-    IDENTIFIER_LOCAL_VALUE (orig_name) = old;\n+    {\n+      /* We only create an OVERLOAD if there was a previous binding at\n+\t this level.  In that case, we need to remove the old binding\n+\t and replace it with the new binding.  We must also run\n+\t through the NAMES on the current binding level to update the\n+\t chain.  */\n+      if (TREE_CODE (new_binding) == OVERLOAD)\n+\t{\n+\t  tree *d;\n+\t  \n+\t  for (d = &BINDING_LEVEL (IDENTIFIER_BINDING (name))->names;\n+\t       *d;\n+\t       d = &TREE_CHAIN (*d))\n+\t    if (*d == old\n+\t\t|| (TREE_CODE (*d) == TREE_LIST\n+\t\t    && TREE_VALUE (*d) == old))\n+\t      {\n+\t\t*d = TREE_CHAIN (*d);\n+\t\tbreak;\n+\t      }\n+\n+\t  pop_binding (name);\n+\t}\n+\n+      /* Install the new binding.  */\n+      push_local_binding (name, new_binding);\n+    }\n \n   return decl;\n }\n@@ -5073,7 +5229,6 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n   register tree val;\n   int yylex = 0;\n   tree from_obj = NULL_TREE;\n-  tree locval, classval;\n   int flags;\n \n   /* Hack: copy flag set by parser, if set. */\n@@ -5166,140 +5321,86 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n   else\n     flags = lookup_flags (prefer_type, namespaces_only);\n \n-  locval = classval = NULL_TREE;\n-\n-  if (! namespace_bindings_p () && IDENTIFIER_LOCAL_VALUE (name))\n-    {\n-      locval = qualify_lookup (IDENTIFIER_LOCAL_VALUE (name), flags);\n+  /* First, look in a non-global scope, carefully avoiding any\n+     class-scope bindings if required.  */\n+  val = IDENTIFIER_BINDING (name); \n+  while (val && nonclass && !LOCAL_BINDING_P (val))\n+    val = TREE_CHAIN (val);\n \n-      /* Kludge kludge kludge */\n-      if (locval == NULL_TREE && prefer_type)\n-\t{\n-\t  locval = REAL_IDENTIFIER_TYPE_VALUE (name);\n-\t  if (locval && locval != global_type_node\n-\t      && TYPE_NAME (locval)\n-\t      && DECL_FUNCTION_SCOPE_P (TYPE_NAME (locval)))\n-\t    locval = TYPE_NAME (locval);\n-\t  else\n-\t    locval = NULL_TREE;\n-\t}\n-    }\n-\n-  /* In C++ class fields are between local and global scope,\n-     just before the global scope.  */\n-  if (current_class_type && ! nonclass)\n-    {\n-      classval = IDENTIFIER_CLASS_VALUE (name);\n-      if (classval == NULL_TREE && TYPE_BEING_DEFINED (current_class_type))\n-\t/* Try to find values from base classes if we are presently\n-\t   defining a type.  We are primarily interested in\n-\t   TYPE_DECLs or constants.  */\n-\tclassval = lookup_field (current_class_type, name, 0, prefer_type);\n-\n-      /* Add implicit 'typename' to types from template bases.  lookup_field\n-         will do this for us.  If classval is actually from an enclosing\n-         scope, lookup_nested_field will get it for us.  */\n-      else if (processing_template_decl\n-\t       && classval && TREE_CODE (classval) == TYPE_DECL\n-\t       && ! currently_open_class (DECL_CONTEXT (classval))\n-\t       && uses_template_parms (current_class_type))\n-\tclassval = lookup_field (current_class_type, name, 0, 1);\n-\n-      /* yylex() calls this with -2, since we should never start digging for\n-\t the nested name at the point where we haven't even, for example,\n-\t created the COMPONENT_REF or anything like that.  */\n-      if (classval == NULL_TREE)\n-\tclassval = lookup_nested_field (name, ! yylex);\n-\n-      classval = qualify_lookup (classval, flags);\n+  /* Get the DECL actually bound.  */\n+  if (val)\n+    val = BINDING_VALUE (val);\n+\n+  /* If VAL is a type from a dependent base, we're not really supposed\n+     to be able to see it; the fact that we can is the \"implicit\n+     typename\" extension.  We call lookup_field here to turn VAL into\n+     a TYPE_DECL for a TYPENAME_TYPE.  */\n+  if (processing_template_decl && val\n+      && val == IDENTIFIER_CLASS_VALUE (name)\n+      && TREE_CODE (val) == TYPE_DECL\n+      && !currently_open_class (DECL_CONTEXT (val))\n+      && uses_template_parms (current_class_type))\n+    val = lookup_field (current_class_type, name, 0, 1);\n+\n+  /* Make sure that this binding is the sort of thing we're looking\n+     for.  */\n+  val = qualify_lookup (val, flags);\n+\n+  /* We don't put names from baseclasses onto the IDENTIFIER_BINDING\n+     list when we're defining a type.  It would probably be simpler to\n+     do this, but we don't.  So, we must lookup names from base\n+     classes explicitly.  */\n+  if (!val && !nonclass \n+      && current_class_type && TYPE_BEING_DEFINED (current_class_type))\n+    {\n+      val = qualify_lookup (lookup_field (current_class_type, name, 0, 0),\n+\t\t\t    flags);\n+      if (!val)\n+\tval = qualify_lookup (lookup_nested_field (name, !yylex),\n+\t\t\t      flags);\n     }\n-\n-  if (locval && classval)\n+  \n+  /* If we found a type from a dependent base class (using the\n+     implicit typename extension), turn it into the TYPE_DECL for a\n+     TYPENAME_TYPE here.  */\n+  if (val && TREE_CODE (val) == TYPE_DECL\n+      && IMPLICIT_TYPENAME_P (TREE_TYPE (val)))\n     {\n-      /* We have both a local binding and a class-level binding.  This\n-\t can happen in two ways:\n+      tree global_val;\n \n-\t   o We are in a member function of a class.\n-           o We are in a local class within a function.\n+      /* Any other name takes precedence over an implicit typename.  Warn the\n+\t user about this potentially confusing lookup.  */\n+      global_val = unqualified_namespace_lookup (name, flags);\n \n-\t We need to determine which one of these situations is\n-\t occuring, and give the innermost binding.  One tricky bit is\n-\t that with member templates we can be in the first case\n-\t without CURRENT_FUNCTION_DECL being set.  Consider\n-\t  \n-\t   struct A { template <class A> void f(A); };\n-\n-\t Here, when we look at the `A' in the parameter declaration\n-\t for `f' we have a local binding (the template parameter) and\n-\t a class-level binding (the TYPE_DECL for the class).\n-\t Fortunately, if LOCVAL is a template parameter it is safe to\n-\t take it; nothing within the scope of the template parameter\n-\t is allowed to have the same name.  */\n-\n-      if (decl_template_parm_p (locval))\n-\tval = locval;\n-      else if (current_scope () == current_function_decl\n-\t  && ! hack_decl_function_context (current_function_decl))\n-\t/* Not in a nested function.  */\n-\tval = locval;\n-      else\n-\t{\n-\t  /* This is incredibly horrible.  The whole concept of\n-\t     IDENTIFIER_LOCAL_VALUE / IDENTIFIER_CLASS_VALUE /\n-\t     IDENTIFIER_GLOBAL_VALUE needs to be scrapped for local\n-\t     classes.  */\n-\t  tree lctx = hack_decl_function_context (locval);\n-\t  tree cctx = hack_decl_function_context (classval);\n-\n-\t  if (lctx == current_scope ())\n-\t    val = locval;\n-\t  else if (lctx == cctx)\n-\t    val = classval;\n-\t  else\n-\t    /* I don't know which is right; let's just guess for now.  */\n-\t    val = locval;\n-\t}\n-    }\n-  else if (locval)\n-    val = locval;\n-  else if (classval)\n-    val = classval;\n-  else\n-    val = unqualified_namespace_lookup (name, flags);\n-\n-  /* Any other name takes precedence over an implicit typename.  Warn the\n-     user about this potentially confusing lookup.  */\n-  if (classval && TREE_CODE (val) == TYPE_DECL\n-      && TREE_CODE (TREE_TYPE (val)) == TYPENAME_TYPE\n-      && TREE_TYPE (TREE_TYPE (val)))\n-    {\n-      if (locval == NULL_TREE)\n-\tlocval = unqualified_namespace_lookup (name, flags);\n-\n-      if (locval && val != locval)\n+      if (global_val)\n \t{\n \t  tree subtype;\n \n-\t  val = locval;\n-\n \t  /* Only warn when not lexing; we don't want to warn if they\n \t     use this name as a declarator.  */\n-\t  subtype = TREE_TYPE (TREE_TYPE (classval));\n+\t  subtype = TREE_TYPE (TREE_TYPE (val));\n \t  if (! yylex\n-\t      && ! (TREE_CODE (locval) == TEMPLATE_DECL\n+\t      && ! (TREE_CODE (global_val) == TEMPLATE_DECL\n \t\t    && CLASSTYPE_TEMPLATE_INFO (subtype)\n-\t\t    && CLASSTYPE_TI_TEMPLATE (subtype) == locval)\n-\t      && ! (TREE_CODE (locval) == TYPE_DECL\n-\t\t    && same_type_p (TREE_TYPE (locval), subtype)))\n+\t\t    && CLASSTYPE_TI_TEMPLATE (subtype) == global_val)\n+\t      && ! (TREE_CODE (global_val) == TYPE_DECL\n+\t\t    && same_type_p (TREE_TYPE (global_val), subtype)))\n \t    {\n-\t      cp_warning (\"lookup of `%D' finds `%#D'\", name, locval);\n+\t      cp_warning (\"lookup of `%D' finds `%#D'\", name, global_val);\n \t      cp_warning (\"  instead of `%D' from dependent base class\",\n-\t\t\t  classval);\n+\t\t\t  val);\n \t      cp_warning (\"  (use `typename %T::%D' if that's what you meant)\",\n \t\t\t  constructor_name (current_class_type), name);\n \t    }\n+\n+\t  /* Use the global value instead of the implicit typename.  */\n+\t  val = global_val;\n \t}\n     }\n+  else if (!val)\n+    /* No local, or class-scoped binding.  Look for a namespace-scope\n+       declaration.  */\n+    val = unqualified_namespace_lookup (name, flags);\n \n  done:\n   if (val)\n@@ -5381,13 +5482,16 @@ lookup_name_current_level (name)\n       if (t != NULL_TREE && TREE_CODE (t) == TREE_LIST)\n \tt = TREE_VALUE (t);\n     }\n-  else if (IDENTIFIER_LOCAL_VALUE (name) != NULL_TREE)\n+  else if (IDENTIFIER_BINDING (name) \n+\t   && LOCAL_BINDING_P (IDENTIFIER_BINDING (name)))\n     {\n       struct binding_level *b = current_binding_level;\n+\n       while (1)\n \t{\n-\t  if (purpose_member (name, b->shadowed))\n-\t    return IDENTIFIER_LOCAL_VALUE (name);\n+\t  if (BINDING_LEVEL (IDENTIFIER_BINDING (name)) == b)\n+\t    return IDENTIFIER_VALUE (name);\n+\t  \n \t  if (b->keep == 2)\n \t    b = b->level_chain;\n \t  else\n@@ -7681,7 +7785,8 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \n \t  if (current_binding_level->is_for_scope)\n \t    {\n-\t      struct binding_level *outer = current_binding_level->level_chain;\n+\t      struct binding_level *outer \n+\t\t= current_binding_level->level_chain;\n \n \t      /* Check to see if the same name is already bound at\n \t\t the outer level, either because it was directly declared,\n@@ -7693,36 +7798,20 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t Otherwise, we need to preserve the temp slot for decl\n \t\t to last into the outer binding level.  */\n \n-\t      int handling_dead_for_vars = 0;\n-\t      tree link = outer->names;\n-\t      for (; ; link = TREE_CHAIN (link))\n+\t      tree outer_binding \n+\t\t= TREE_CHAIN (IDENTIFIER_BINDING (DECL_NAME (decl)));\n+\t      \n+\t      if (outer_binding && BINDING_LEVEL (outer_binding) == outer\n+\t\t  && (TREE_CODE (BINDING_VALUE (outer_binding)) \n+\t\t      == VAR_DECL)\n+\t\t  && DECL_DEAD_FOR_LOCAL (BINDING_VALUE (outer_binding)))\n \t\t{\n-\t\t  if (link == NULL && handling_dead_for_vars == 0)\n-\t\t    {\n-\t\t      link = outer->dead_vars_from_for;\n-\t\t      handling_dead_for_vars = 1;\n-\t\t    }\n-\t\t  if (link == NULL)\n-\t\t    {\n-\t\t      if (DECL_IN_MEMORY_P (decl))\n-\t\t\tpreserve_temp_slots (DECL_RTL (decl));\n-\t\t      break;\n-\t\t    }\n-\t\t  if (DECL_NAME (link) == DECL_NAME (decl))\n-\t\t    {\n-\t\t      if (handling_dead_for_vars)\n-\t\t\t{\n-\t\t\t  tree shadowing\n-\t\t\t    = purpose_member (DECL_NAME (decl),\n-\t\t\t\t\t      current_binding_level->shadowed);\n-\t\t\t  if (shadowing && TREE_VALUE (shadowing) == link)\n-\t\t\t    TREE_VALUE (shadowing)\n-\t\t\t      = DECL_SHADOWED_FOR_VAR (link);\n-\t\t\t}\n-\t\t      current_binding_level->is_for_scope = 0;\n-\t\t      break;\n-\t\t    }\n+\t\t  BINDING_VALUE (outer_binding)\n+\t\t    = DECL_SHADOWED_FOR_VAR (BINDING_VALUE (outer_binding));\n+\t\t  current_binding_level->is_for_scope = 0;\n \t\t}\n+\t      else if (DECL_IN_MEMORY_P (decl))\n+\t\tpreserve_temp_slots (DECL_RTL (decl));\n \t    }\n \n \t  expand_start_target_temps ();\n@@ -11032,18 +11121,14 @@ parmlist_is_exprlist (exprs)\n   return 1;\n }\n \n-/* Subroutine of `grokparms'.  In a fcn definition, arg types must\n-   be complete.\n-\n-   C++: also subroutine of `start_function'.  */\n+/* Subroutine of start_function.  Ensure that each of the parameter\n+   types (as listed in PARMS) is complete, as is required for a\n+   function definition.  */\n \n static void\n require_complete_types_for_parms (parms)\n      tree parms;\n {\n-  if (processing_template_decl)\n-    return;\n-\n   while (parms)\n     {\n       tree type = TREE_TYPE (parms);\n@@ -11058,31 +11143,7 @@ require_complete_types_for_parms (parms)\n \t}\n       else\n \tlayout_decl (parms, 0);\n-#if 0\n-      /* If the arg types are incomplete in a declaration,\n-\t they must include undefined tags.\n-\t These tags can never be defined in the scope of the declaration,\n-\t so the types can never be completed,\n-\t and no call can be compiled successfully.  */\n-      /* This is not the right behavior for C++, but not having\n-\t it is also probably wrong.  */\n-      else\n-\t{\n-\t  /* Now warn if is a pointer to an incomplete type.  */\n-\t  while (TREE_CODE (type) == POINTER_TYPE\n-\t\t || TREE_CODE (type) == REFERENCE_TYPE)\n-\t    type = TREE_TYPE (type);\n-\t  type = TYPE_MAIN_VARIANT (type);\n-\t  if (TYPE_SIZE (type) == NULL_TREE)\n-\t    {\n-\t      if (DECL_NAME (parm) != NULL_TREE)\n-\t\twarning (\"parameter `%s' points to incomplete type\",\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parm)));\n-\t      else\n-\t\twarning (\"parameter points to incomplete type\");\n-\t    }\n-\t}\n-#endif\n+\n       parms = TREE_CHAIN (parms);\n     }\n }\n@@ -11276,16 +11337,20 @@ grokparms (first_parm, funcdef_flag)\n \t\t      /* Unparsed default arg from in-class decl.  */\n \t\t      else if (TREE_CODE (init) == DEFAULT_ARG)\n \t\t\t;\n-\t\t      else if (TREE_CODE (init) == VAR_DECL\n-\t\t\t       || TREE_CODE (init) == PARM_DECL)\n+\t\t      else if (TREE_CODE (init) == PARM_DECL\n+\t\t\t       || TREE_CODE (init) == VAR_DECL)\n \t\t\t{\n-\t\t\t  if (IDENTIFIER_LOCAL_VALUE (DECL_NAME (init)))\n+\t\t\t  if (TREE_CODE (init) == VAR_DECL\n+\t\t\t      && (IDENTIFIER_VALUE (DECL_NAME (init))\n+\t\t\t\t  == init)\n+\t\t\t      && LOCAL_BINDING_P\n+\t\t\t      (IDENTIFIER_BINDING (DECL_NAME\n+\t\t\t\t\t\t   (init))))\n \t\t\t    {\n-\t\t\t      /* ``Local variables may not be used in default\n-\t\t\t\t argument expressions.'' dpANSI C++ 8.2.6 */\n-\t\t\t      /* If extern int i; within a function is not\n-\t\t\t\t considered a local variable, then this code is\n-\t\t\t\t wrong.  */\n+\t\t\t      /* ``Local variables may not be used in\n+\t\t\t\t default argument expressions.''\n+\t\t\t\t dpANSI C++ 8.2.6 */\n+\n \t\t\t      cp_error (\"local variable `%D' may not be used as a default argument\", init);\n \t\t\t      any_error = 1;\n \t\t\t    }\n@@ -11349,10 +11414,6 @@ grokparms (first_parm, funcdef_flag)\n \n   last_function_parms = decls;\n \n-  /* In a fcn definition, arg types must be complete.  */\n-  if (funcdef_flag > 0)\n-    require_complete_types_for_parms (last_function_parms);\n-\n   return result;\n }\n \n@@ -11417,20 +11478,45 @@ grok_ctor_properties (ctype, decl)\n       parmtype = TREE_VALUE (parmtypes);\n     }\n \n+  /* [class.copy]\n+\n+     A non-template constructor for class X is a copy constructor if\n+     its first parameter is of type X&, const X&, volatile X& or const\n+     volatile X&, and either there are no other parameters or else all\n+     other parameters have default arguments.  */\n   if (TREE_CODE (parmtype) == REFERENCE_TYPE\n       && TYPE_MAIN_VARIANT (TREE_TYPE (parmtype)) == ctype\n       && (TREE_CHAIN (parmtypes) == NULL_TREE\n \t  || TREE_CHAIN (parmtypes) == void_list_node\n-\t  || TREE_PURPOSE (TREE_CHAIN (parmtypes))))\n+\t  || TREE_PURPOSE (TREE_CHAIN (parmtypes)))\n+      && !(DECL_TEMPLATE_INSTANTIATION (decl)\n+\t   && is_member_template (DECL_TI_TEMPLATE (decl))))\n     {\n       TYPE_HAS_INIT_REF (ctype) = 1;\n       if (CP_TYPE_CONST_P (TREE_TYPE (parmtype)))\n \tTYPE_HAS_CONST_INIT_REF (ctype) = 1;\n     }\n+  /* [class.copy]\n+\n+     A declaration of a constructor for a class X is ill-formed if its\n+     first parameter is of type (optionally cv-qualified) X and either\n+     there are no other parameters or else all other parameters have\n+     default arguments.  \n+\n+     We *don't* complain about member template instantiations that\n+     have this form, though; they can occur as we try to decide what\n+     constructor to use during overload resolution.  Since overload\n+     resolution will never prefer such a constructor to the\n+     non-template copy constructor (which is either explicitly or\n+     implicitly defined), there's no need to worry about their\n+     existence.  Theoretically, they should never even be\n+     instantiated, but that's hard to forestall.  */\n   else if (TYPE_MAIN_VARIANT (parmtype) == ctype\n \t   && (TREE_CHAIN (parmtypes) == NULL_TREE\n \t       || TREE_CHAIN (parmtypes) == void_list_node\n-\t       || TREE_PURPOSE (TREE_CHAIN (parmtypes))))\n+\t       || TREE_PURPOSE (TREE_CHAIN (parmtypes)))\n+\t   && !(DECL_TEMPLATE_INSTANTIATION (decl)\n+\t\t&& is_member_template (DECL_TI_TEMPLATE (decl))))\n     {\n       cp_error (\"invalid constructor; you probably meant `%T (const %T&)'\",\n \t\tctype, ctype);\n@@ -11486,7 +11572,15 @@ grok_op_properties (decl, virtualp, friendp)\n \n   if (! friendp)\n     {\n-      if (name == ansi_opname[(int) MODIFY_EXPR])\n+      /* [class.copy]\n+\n+\t A user-declared copy assignment operator X::operator= is a\n+\t non-static non-template member function of class X with\n+\t exactly one parameter of type X, X&, const X&, volatile X& or\n+\t const volatile X&.  */\n+      if (name == ansi_opname[(int) MODIFY_EXPR]\n+\t  && !(DECL_TEMPLATE_INSTANTIATION (decl)\n+\t       && is_member_template (DECL_TI_TEMPLATE (decl))))\n \tTYPE_HAS_ASSIGNMENT (current_class_type) = 1;\n       else if (name == ansi_opname[(int) CALL_EXPR])\n \tTYPE_OVERLOADS_CALL_EXPR (current_class_type) = 1;\n@@ -12477,6 +12571,15 @@ static int function_depth;\n    they describe the function's name and the type it returns,\n    but twisted together in a fashion that parallels the syntax of C.\n \n+   If PRE_PARSED_P is non-zero then DECLARATOR is really the DECL for\n+   the function we are about to process; DECLSPECS are ignored.  For\n+   example, we set PRE_PARSED_P when processing the definition of\n+   inline function that was defined in-class; the definition is\n+   actually processed when the class is complete.  In this case,\n+   PRE_PARSED_P is 2.  We also set PRE_PARSED_P when instanting the\n+   body of a template function, and when constructing thunk functions\n+   and such; in these cases PRE_PARSED_P is 1.\n+   \n    This function creates a binding context for the function body\n    as well as setting up the FUNCTION_DECL in current_function_decl.\n \n@@ -12577,17 +12680,6 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t    doing_friend = 1;\n \t}\n \n-      /* In a fcn definition, arg types must be complete.  */\n-      require_complete_types_for_parms (DECL_ARGUMENTS (decl1));\n-\n-      /* In case some arg types were completed since the declaration was\n-         parsed, fix up the decls.  */\n-      {\n-\ttree t = DECL_ARGUMENTS (decl1);\n-\tfor (; t; t = TREE_CHAIN (t))\n-\t  layout_decl (t, 0);\n-      }\n-\n       last_function_parms = DECL_ARGUMENTS (decl1);\n       last_function_parm_tags = NULL_TREE;\n     }\n@@ -12636,16 +12728,37 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n       && IDENTIFIER_IMPLICIT_DECL (DECL_NAME (decl1)) != NULL_TREE)\n     cp_warning_at (\"`%D' implicitly declared before its definition\", IDENTIFIER_IMPLICIT_DECL (DECL_NAME (decl1)));\n \n+  announce_function (decl1);\n+\n+  /* Set up current_class_type, and enter the scope of the class, if\n+     appropriate.  */\n+  if (ctype)\n+    push_nested_class (ctype, 1);\n+  else if (DECL_STATIC_FUNCTION_P (decl1))\n+    push_nested_class (DECL_CONTEXT (decl1), 2);\n+\n+  /* Now that we have entered the scope of the class, we must restore\n+     the bindings for any template parameters surrounding DECL1, if it\n+     is an inline member template.  (Order is important; consider the\n+     case where a template parameter has the same name as a field of\n+     the class.)  It is not until after this point that\n+     PROCESSING_TEMPLATE_DECL is guaranteed to be set up correctly.  */\n+  if (pre_parsed_p == 2)\n+    maybe_begin_member_template_processing (decl1);\n+\n+  /* We are now in the scope of the function being defined.  */\n   current_function_decl = decl1;\n+\n   /* Save the parm names or decls from this function's declarator\n      where store_parm_decls will find them.  */\n   current_function_parms = last_function_parms;\n   current_function_parm_tags = last_function_parm_tags;\n \n-  announce_function (decl1);\n-\n   if (! processing_template_decl)\n     {\n+      /* In a fcn definition, arg types must be complete.  */\n+      require_complete_types_for_parms (DECL_ARGUMENTS (decl1));\n+\n       if (TYPE_SIZE (complete_type (TREE_TYPE (fntype))) == NULL_TREE)\n \t{\n \t  cp_error (\"return-type `%#T' is an incomplete type\",\n@@ -12695,13 +12808,6 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n      (This does not mean `static' in the C sense!)  */\n   TREE_STATIC (decl1) = 1;\n \n-  /* Set up current_class_type, and enter the scope of the class, if\n-     appropriate.  */\n-  if (ctype)\n-    push_nested_class (ctype, 1);\n-  else if (DECL_STATIC_FUNCTION_P (decl1))\n-    push_nested_class (DECL_CONTEXT (decl1), 2);\n-\n   /* We must call push_template_decl after current_class_type is set\n      up.  (If we are processing inline definitions after exiting a\n      class scope, current_class_type will be NULL_TREE until set above\n@@ -12937,9 +13043,6 @@ store_parm_decls ()\n   /* Initialize RTL machinery.  */\n   init_function_start (fndecl, input_filename, lineno);\n \n-  /* Declare __FUNCTION__ and __PRETTY_FUNCTION__ for this function.  */\n-  declare_function_name ();\n-\n   /* Create a binding level for the parms.  */\n   expand_start_bindings (0);\n \n@@ -13025,6 +13128,9 @@ store_parm_decls ()\n \n   storedecls (chainon (nonparms, DECL_ARGUMENTS (fndecl)));\n \n+  /* Declare __FUNCTION__ and __PRETTY_FUNCTION__ for this function.  */\n+  declare_function_name ();\n+\n   /* Initialize the RTL code for the function.  */\n   DECL_SAVED_INSNS (fndecl) = NULL_RTX;\n   if (! processing_template_decl)\n@@ -13135,18 +13241,23 @@ store_return_init (return_id, init)\n    This is called after parsing the body of the function definition.\n    LINENO is the current line number.\n \n-   C++: CALL_POPLEVEL is non-zero if an extra call to poplevel\n-   (and expand_end_bindings) must be made to take care of the binding\n-   contour for the base initializers.  This is only relevant for\n-   constructors.\n+   FLAGS is a bitwise or of the following values: \n+     1 - CALL_POPLEVEL \n+       An extra call to poplevel (and expand_end_bindings) must be\n+       made to take care of the binding contour for the base\n+       initializers.  This is only relevant for constructors.\n+     2 - INCLASS_INLINE\n+       We just finished processing the body of an in-class inline\n+       function definition.  (This processing will have taken place\n+       after the class definition is complete.)\n \n    NESTED is nonzero if we were in the middle of compiling another function\n    when we started on this one.  */\n \n void\n-finish_function (lineno, call_poplevel, nested)\n+finish_function (lineno, flags, nested)\n      int lineno;\n-     int call_poplevel;\n+     int flags;\n      int nested;\n {\n   register tree fndecl = current_function_decl;\n@@ -13155,6 +13266,9 @@ finish_function (lineno, call_poplevel, nested)\n   /* Label to use if this function is supposed to return a value.  */\n   tree no_return_label = NULL_TREE;\n   tree decls = NULL_TREE;\n+  int call_poplevel = (flags & 1) != 0;\n+  int inclass_inline = (flags & 2) != 0;\n+  int in_template;\n \n   /* When we get some parse errors, we can end up without a\n      current_function_decl, so cope.  */\n@@ -13560,6 +13674,27 @@ finish_function (lineno, call_poplevel, nested)\n       /* Generate rtl for function exit.  */\n       expand_function_end (input_filename, lineno, 1);\n     }\n+  \n+  /* Must mark the RESULT_DECL as being in this function.  */\n+  DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n+\n+  /* Set the BLOCK_SUPERCONTEXT of the outermost function scope to point\n+     to the FUNCTION_DECL node itself.  */\n+  BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n+\n+  /* If we're processing a template, squirrel away the definition\n+     until we do an instantiation.  */\n+  if (processing_template_decl)\n+    {\n+      --minimal_parse_mode;\n+      DECL_SAVED_TREE (fndecl) = TREE_CHAIN (DECL_SAVED_TREE (fndecl));\n+      /* We have to save this value here in case\n+\t maybe_end_member_template_processing decides to pop all the\n+\t template parameters.  */\n+      in_template = 1;\n+    }\n+  else\n+    in_template = 0;\n \n   /* This must come after expand_function_end because cleanups might\n      have declarations (from inline functions) that need to go into\n@@ -13568,6 +13703,13 @@ finish_function (lineno, call_poplevel, nested)\n     my_friendly_abort (122);\n   poplevel (1, 0, 1);\n \n+  /* If this is a in-class inline definition, we may have to pop the\n+     bindings for the template parameters that we added in\n+     maybe_begin_member_template_processing when start_function was\n+     called.  */\n+  if (inclass_inline)\n+    maybe_end_member_template_processing ();\n+\n   /* Reset scope for C++: if we were in the scope of a class,\n      then when we finish this function, we are not longer so.\n      This cannot be done until we know for sure that no more\n@@ -13579,14 +13721,7 @@ finish_function (lineno, call_poplevel, nested)\n       pop_nested_class (1);\n     }\n \n-  /* Must mark the RESULT_DECL as being in this function.  */\n-  DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n-\n-  /* Set the BLOCK_SUPERCONTEXT of the outermost function scope to point\n-     to the FUNCTION_DECL node itself.  */\n-  BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n-\n-  if (! processing_template_decl)\n+  if (!in_template)\n     {\n       int saved_flag_keep_inline_functions =\n \tflag_keep_inline_functions;\n@@ -13670,12 +13805,6 @@ finish_function (lineno, call_poplevel, nested)\n   /* Free all the tree nodes making up this function.  */\n   /* Switch back to allocating nodes permanently\n      until we start another function.  */\n-  if (processing_template_decl)\n-    {\n-      --minimal_parse_mode;\n-      DECL_SAVED_TREE (fndecl) = TREE_CHAIN (DECL_SAVED_TREE (fndecl));\n-    }\n-\n   if (! nested)\n     permanent_allocation (1);\n \n@@ -13710,8 +13839,6 @@ finish_function (lineno, call_poplevel, nested)\n }\n \f\n /* Create the FUNCTION_DECL for a function definition.\n-   LINE1 is the line number that the definition absolutely begins on.\n-   LINE2 is the line number that the name of the function appears on.\n    DECLSPECS and DECLARATOR are the parts of the declaration;\n    they describe the return type and the name of the function,\n    but twisted together in a fashion that parallels the syntax of C.\n@@ -13849,23 +13976,11 @@ finish_method (decl)\n   for (link = current_binding_level->names; link; link = TREE_CHAIN (link))\n     {\n       if (DECL_NAME (link) != NULL_TREE)\n-\tIDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = 0;\n+\tpop_binding (DECL_NAME (link));\n       my_friendly_assert (TREE_CODE (link) != FUNCTION_DECL, 163);\n       DECL_CONTEXT (link) = NULL_TREE;\n     }\n \n-  /* Restore all name-meanings of the outer levels\n-     that were shadowed by this level.  */\n-\n-  for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n-      IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-  for (link = current_binding_level->class_shadowed;\n-       link; link = TREE_CHAIN (link))\n-    IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-  for (link = current_binding_level->type_shadowed;\n-       link; link = TREE_CHAIN (link))\n-    SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link), TREE_VALUE (link));\n-\n   GNU_xref_end_scope ((HOST_WIDE_INT) current_binding_level,\n \t\t      (HOST_WIDE_INT) current_binding_level->level_chain,\n \t\t      current_binding_level->parm_flag,"}, {"sha": "630e262183f058cb55b65a24e51761bfadfff787", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -4829,7 +4829,7 @@ do_local_using_decl (decl)\n   do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n \n   if (newval)\n-    set_identifier_local_value (name, newval);\n+    push_local_binding (name, newval);\n   if (newtype)\n     set_identifier_type_value (name, newtype);\n }"}, {"sha": "e6dd29fe31a3d27bf5e5bce7b0fdcdff2b1ab2e7", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 67, "deletions": 72, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -84,6 +84,7 @@ static int reduce_cmp PROTO((int *, int *));\n static int token_cmp PROTO((int *, int *));\n #endif\n #endif\n+static void begin_definition_of_inclass_inline PROTO((struct pending_inline*));\n \n /* Given a file name X, return the nondirectory portion.\n    Keep in mind that X can be computed more than once.  */\n@@ -322,12 +323,13 @@ get_time_identifier (name)\n   bcopy (name, buf+5, len);\n   buf[len+5] = '\\0';\n   time_identifier = get_identifier (buf);\n-  if (IDENTIFIER_LOCAL_VALUE (time_identifier) == NULL_TREE)\n+  if (TIME_IDENTIFIER_TIME (time_identifier) == NULL_TREE)\n     {\n       push_obstacks_nochange ();\n       end_temporary_allocation ();\n-      IDENTIFIER_LOCAL_VALUE (time_identifier) = build_int_2 (0, 0);\n-      IDENTIFIER_CLASS_VALUE (time_identifier) = build_int_2 (0, 1);\n+      TIME_IDENTIFIER_TIME (time_identifier) = build_int_2 (0, 0);\n+      TIME_IDENTIFIER_FILEINFO (time_identifier) \n+\t= build_int_2 (0, 1);\n       SET_IDENTIFIER_GLOBAL_VALUE (time_identifier, filename_times);\n       filename_times = time_identifier;\n       pop_obstacks ();\n@@ -435,7 +437,8 @@ init_filename_times ()\n     {\n       header_time = 0;\n       body_time = my_get_run_time ();\n-      TREE_INT_CST_LOW (IDENTIFIER_LOCAL_VALUE (this_filename_time)) = body_time;\n+      TREE_INT_CST_LOW (TIME_IDENTIFIER_TIME (this_filename_time)) \n+\t= body_time;\n     }\n }\n \n@@ -1145,7 +1148,7 @@ extract_interface_info ()\n     }\n   if (!fileinfo)\n     fileinfo = get_time_identifier (input_filename);\n-  fileinfo = IDENTIFIER_CLASS_VALUE (fileinfo);\n+  fileinfo = TIME_IDENTIFIER_FILEINFO (fileinfo);\n   interface_only = TREE_INT_CST_LOW (fileinfo);\n   interface_unknown = TREE_INT_CST_HIGH (fileinfo);\n }\n@@ -1196,7 +1199,7 @@ set_typedecl_interface_info (prev, vars)\n      tree prev ATTRIBUTE_UNUSED, vars;\n {\n   tree id = get_time_identifier (DECL_SOURCE_FILE (vars));\n-  tree fileinfo = IDENTIFIER_CLASS_VALUE (id);\n+  tree fileinfo = TIME_IDENTIFIER_FILEINFO (id);\n   tree type = TREE_TYPE (vars);\n \n   CLASSTYPE_INTERFACE_ONLY (type) = TREE_INT_CST_LOW (fileinfo)\n@@ -1222,6 +1225,37 @@ set_vardecl_interface_info (prev, vars)\n   return 0;\n }\n \f\n+/* Set up the state required to correctly handle the definition of the\n+   inline function whose preparsed state has been saved in PI.  */\n+\n+static void\n+begin_definition_of_inclass_inline (pi)\n+     struct pending_inline* pi;\n+{\n+  tree context;\n+\n+  if (!pi->fndecl)\n+    return;\n+\n+  /* If this is an inline function in a local class, we must make sure\n+     that we save all pertinent information about the function\n+     surrounding the local class.  */\n+  context = hack_decl_function_context (pi->fndecl);\n+  if (context)\n+    push_cp_function_context (context);\n+\n+  feed_input (pi->buf, pi->len);\n+  lineno = pi->lineno;\n+  input_filename = pi->filename;\n+  yychar = PRE_PARSED_FUNCTION_DECL;\n+  yylval.ttype = build_tree_list ((tree) pi, pi->fndecl);\n+  /* Pass back a handle to the rest of the inline functions, so that they\n+     can be processed later.  */\n+  DECL_PENDING_INLINE_INFO (pi->fndecl) = 0;\n+  interface_unknown = pi->interface == 1;\n+  interface_only  = pi->interface == 0;\n+}\n+\n /* Called from the top level: if there are any pending inlines to\n    do, set up to process them now.  This function sets up the first function\n    to be parsed; after it has been, the rule for fndef in parse.y will\n@@ -1231,7 +1265,6 @@ void\n do_pending_inlines ()\n {\n   struct pending_inline *t;\n-  tree context;\n \n   /* Oops, we're still dealing with the last batch.  */\n   if (yychar == PRE_PARSED_FUNCTION_DECL)\n@@ -1258,32 +1291,7 @@ do_pending_inlines ()\n     return;\n \t    \n   /* Now start processing the first inline function.  */\n-  context = hack_decl_function_context (t->fndecl);\n-  if (context)\n-    push_cp_function_context (context);\n-  maybe_begin_member_template_processing (t->fndecl);\n-  if (t->len > 0)\n-    {\n-      feed_input (t->buf, t->len);\n-      lineno = t->lineno;\n-#if 0\n-      if (input_filename != t->filename)\n-\t{\n-\t  input_filename = t->filename;\n-\t  /* Get interface/implementation back in sync.  */\n-\t  extract_interface_info ();\n-\t}\n-#else\n-      input_filename = t->filename;\n-      interface_unknown = t->interface == 1;\n-      interface_only = t->interface == 0;\n-#endif\n-      yychar = PRE_PARSED_FUNCTION_DECL;\n-    }\n-  /* Pass back a handle on the rest of the inline functions, so that they\n-     can be processed later.  */\n-  yylval.ttype = build_tree_list ((tree) t, t->fndecl);\n-  DECL_PENDING_INLINE_INFO (t->fndecl) = 0;\n+  begin_definition_of_inclass_inline (t);\n }\n \n static int nextchar = -1;\n@@ -1299,7 +1307,6 @@ process_next_inline (t)\n   tree context;\n   struct pending_inline *i = (struct pending_inline *) TREE_PURPOSE (t);\n   context = hack_decl_function_context (i->fndecl);  \n-  maybe_end_member_template_processing ();\n   if (context)\n     pop_cp_function_context (context);\n   i = i->next;\n@@ -1317,24 +1324,8 @@ process_next_inline (t)\n     }\n   yychar = YYEMPTY;\n   end_input ();\n-  if (i && i->fndecl != NULL_TREE)\n-    {\n-      context = hack_decl_function_context (i->fndecl);\n-      if (context)\n-\tpush_cp_function_context (context);\n-      maybe_begin_member_template_processing (i->fndecl);\n-      feed_input (i->buf, i->len);\n-      lineno = i->lineno;\n-      input_filename = i->filename;\n-      yychar = PRE_PARSED_FUNCTION_DECL;\n-      yylval.ttype = build_tree_list ((tree) i, i->fndecl);\n-      DECL_PENDING_INLINE_INFO (i->fndecl) = 0;\n-    }\n   if (i)\n-    {\n-      interface_unknown = i->interface == 1;\n-      interface_only = i->interface == 0;\n-    }\n+    begin_definition_of_inclass_inline (i);\n   else\n     extract_interface_info ();\n }\n@@ -2507,7 +2498,7 @@ check_newline ()\n \t  int this_time = my_get_run_time ();\n \t  tree time_identifier = get_time_identifier (TREE_STRING_POINTER (yylval.ttype));\n \t  header_time += this_time - body_time;\n-\t  TREE_INT_CST_LOW (IDENTIFIER_LOCAL_VALUE (this_filename_time))\n+\t  TREE_INT_CST_LOW (TIME_IDENTIFIER_TIME (this_filename_time))\n \t    += this_time - body_time;\n \t  this_filename_time = time_identifier;\n \t  body_time = this_time;\n@@ -2943,11 +2934,9 @@ do_identifier (token, parsing, args)\n   /* Do Koenig lookup if appropriate (inside templates we build lookup\n      expressions instead).  */\n   if (args && !current_template_parms && (!id || is_global (id)))\n-    {\n-      /* If we have arguments and we only found global names,\n-         do Koenig lookup. */\n-      id = lookup_arg_dependent (token, id, args);\n-    }\n+    /* If we have arguments and we only found global names, do Koenig\n+         lookup. */\n+    id = lookup_arg_dependent (token, id, args);\n \n   /* Remember that this name has been used in the class definition, as per\n      [class.scope0] */\n@@ -3183,16 +3172,20 @@ identifier_typedecl_value (node)\n   type = IDENTIFIER_TYPE_VALUE (node);\n   if (type == NULL_TREE)\n     return NULL_TREE;\n-#define do(X) \\\n-  { \\\n-    t = (X); \\\n-    if (t && TREE_CODE (t) == TYPE_DECL && TREE_TYPE (t) == type) \\\n-      return t; \\\n-  }\n-  do (IDENTIFIER_LOCAL_VALUE (node));\n-  do (IDENTIFIER_CLASS_VALUE (node));\n-  do (IDENTIFIER_NAMESPACE_VALUE (node));\n-#undef do\n+\n+  if (IDENTIFIER_BINDING (node))\n+    {\n+      t = IDENTIFIER_VALUE (node);\n+      if (t && TREE_CODE (t) == TYPE_DECL && TREE_TYPE (t) == type)\n+\treturn t;\n+    }\n+  if (IDENTIFIER_NAMESPACE_VALUE (node))\n+    {\n+      t = IDENTIFIER_NAMESPACE_VALUE (node);\n+      if (t && TREE_CODE (t) == TYPE_DECL && TREE_TYPE (t) == type)\n+\treturn t;\n+    }\n+\n   /* Will this one ever happen?  */\n   if (TYPE_MAIN_DECL (type))\n     return TYPE_MAIN_DECL (type);\n@@ -4737,7 +4730,7 @@ dump_time_statistics ()\n {\n   register tree prev = 0, decl, next;\n   int this_time = my_get_run_time ();\n-  TREE_INT_CST_LOW (IDENTIFIER_LOCAL_VALUE (this_filename_time))\n+  TREE_INT_CST_LOW (TIME_IDENTIFIER_TIME (this_filename_time))\n     += this_time - body_time;\n \n   fprintf (stderr, \"\\n******\\n\");\n@@ -4756,7 +4749,7 @@ dump_time_statistics ()\n \n   for (decl = prev; decl; decl = IDENTIFIER_GLOBAL_VALUE (decl))\n     print_time (IDENTIFIER_POINTER (decl),\n-\t\tTREE_INT_CST_LOW (IDENTIFIER_LOCAL_VALUE (decl)));\n+\t\tTREE_INT_CST_LOW (TIME_IDENTIFIER_TIME (decl)));\n }\n \n void\n@@ -4847,7 +4840,8 @@ handle_cp_pragma (pname)\n     }\n   else if (! strcmp (pname, \"interface\"))\n     {\n-      tree fileinfo = IDENTIFIER_CLASS_VALUE (get_time_identifier (input_filename));\n+      tree fileinfo \n+\t= TIME_IDENTIFIER_FILEINFO (get_time_identifier (input_filename));\n       char *main_filename = input_filename;\n \n       main_filename = file_name_nondirectory (main_filename);\n@@ -4882,7 +4876,7 @@ handle_cp_pragma (pname)\n #ifdef AUTO_IMPLEMENT\n \t  filename = file_name_nondirectory (main_input_filename);\n \t  fi = get_time_identifier (filename);\n-\t  fi = IDENTIFIER_CLASS_VALUE (fi);\n+\t  fi = TIME_IDENTIFIER_FILEINFO (fi);\n \t  TREE_INT_CST_LOW (fi) = 0;\n \t  TREE_INT_CST_HIGH (fi) = 1;\n \t  /* Get default.  */\n@@ -4902,7 +4896,8 @@ handle_cp_pragma (pname)\n     }\n   else if (! strcmp (pname, \"implementation\"))\n     {\n-      tree fileinfo = IDENTIFIER_CLASS_VALUE (get_time_identifier (input_filename));\n+      tree fileinfo \n+\t= TIME_IDENTIFIER_FILEINFO (get_time_identifier (input_filename));\n       char *main_filename = main_input_filename ? main_input_filename : input_filename;\n \n       main_filename = file_name_nondirectory (main_filename);"}, {"sha": "4d4827c95e0959b82cf99e764a8c6ff4229b146b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -236,7 +236,7 @@ empty_parms ()\n %token <ttype> PRE_PARSED_CLASS_DECL DEFARG DEFARG_MARKER\n %type <ttype> component_constructor_declarator\n %type <ttype> fn.def2 return_id fn.defpen constructor_declarator\n-%type <itype> ctor_initializer_opt\n+%type <itype> ctor_initializer_opt function_try_block\n %type <ttype> named_class_head named_class_head_sans_basetype\n %type <ttype> named_complex_class_head_sans_basetype\n %type <ttype> unnamed_class_head\n@@ -639,7 +639,11 @@ fndef:\n \t  fn.def1 maybe_return_init ctor_initializer_opt compstmt_or_error\n \t\t{ finish_function (lineno, (int)$3, 0); }\n \t| fn.def1 maybe_return_init function_try_block\n-\t\t{ }\n+\t\t{ \n+\t\t  int nested = (hack_decl_function_context\n+\t\t\t\t(current_function_decl) != NULL_TREE);\n+\t\t  finish_function (lineno, (int)$3, nested); \n+\t\t}\n \t| fn.def1 maybe_return_init error\n \t\t{ }\n \t;\n@@ -2037,19 +2041,24 @@ initlist:\n fn.defpen:\n \tPRE_PARSED_FUNCTION_DECL\n \t\t{ start_function (NULL_TREE, TREE_VALUE ($1),\n-\t\t\t\t  NULL_TREE, 1);\n+\t\t\t\t  NULL_TREE, 2);\n \t\t  reinit_parse_for_function (); }\n \n pending_inline:\n \t  fn.defpen maybe_return_init ctor_initializer_opt compstmt_or_error\n \t\t{\n \t\t  int nested = (hack_decl_function_context\n \t\t\t\t(current_function_decl) != NULL_TREE);\n-\t\t  finish_function (lineno, (int)$3, nested);\n+\t\t  finish_function (lineno, (int)$3 | 2, nested);\n \t\t  process_next_inline ($1);\n \t\t}\n \t| fn.defpen maybe_return_init function_try_block\n-\t\t{ process_next_inline ($1); }\n+\t\t{ \n+\t\t  int nested = (hack_decl_function_context\n+\t\t\t\t(current_function_decl) != NULL_TREE);\n+\t\t  finish_function (lineno, (int)$3 | 2, nested); \n+                  process_next_inline ($1);\n+\t\t}\n \t| fn.defpen maybe_return_init error\n \t\t{ process_next_inline ($1); }\n \t;\n@@ -3339,10 +3348,8 @@ function_try_block:\n                 }\n \t  handler_seq\n \t\t{\n-\t\t  int nested = (hack_decl_function_context\n-\t\t\t\t(current_function_decl) != NULL_TREE);\n \t\t  expand_end_all_catch ();\n-\t\t  finish_function (lineno, (int)$3, nested);\n+\t\t  $$ = $3;\n \t\t}\n \t;\n "}, {"sha": "bdf85dd760f174447793eb2c66630ace2a1412c3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 41, "deletions": 62, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -426,14 +426,14 @@ maybe_end_member_template_processing ()\n      template <class T> class C { template <class U> void f(U); }\n \n    then neither C<int>::f<char> nor C<T>::f<double> is considered\n-   to be a member template.  */\n+   to be a member template.  But, `template <class U> void\n+   C<int>::f(U)' is considered a member template.  */\n \n int\n is_member_template (t)\n      tree t;\n {\n-  if (TREE_CODE (t) != FUNCTION_DECL\n-      && !DECL_FUNCTION_TEMPLATE_P (t))\n+  if (!DECL_FUNCTION_TEMPLATE_P (t))\n     /* Anything that isn't a function or a template function is\n        certainly not a member template.  */\n     return 0;\n@@ -442,31 +442,12 @@ is_member_template (t)\n   if (hack_decl_function_context (t))\n     return 0;\n \n-  if ((DECL_FUNCTION_MEMBER_P (t) \n-       && !DECL_TEMPLATE_SPECIALIZATION (t))\n-      || (TREE_CODE (t) == TEMPLATE_DECL \n-\t  && DECL_FUNCTION_MEMBER_P (DECL_TEMPLATE_RESULT (t))))\n-    {\n-      tree tmpl;\n-\n-      if (DECL_FUNCTION_TEMPLATE_P (t))\n-\ttmpl = t;\n-      else if (DECL_TEMPLATE_INFO (t) \n-\t       && DECL_FUNCTION_TEMPLATE_P (DECL_TI_TEMPLATE (t)))\n-\ttmpl = DECL_TI_TEMPLATE (t);\n-      else\n-\ttmpl = NULL_TREE;\n-\n-      if (tmpl\n+  return (DECL_FUNCTION_MEMBER_P (DECL_TEMPLATE_RESULT (t))\n \t  /* If there are more levels of template parameters than\n \t     there are template classes surrounding the declaration,\n \t     then we have a member template.  */\n-\t  && (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl)) > \n-\t      template_class_depth (DECL_CLASS_CONTEXT (t))))\n-\treturn 1;\n-    }\n-\n-  return 0;\n+\t  && (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (t)) > \n+\t      template_class_depth (DECL_CLASS_CONTEXT (t))));\n }\n \n #if 0 /* UNUSED */\n@@ -1487,28 +1468,27 @@ int comp_template_parms (parms1, parms2)\n }\n \n \n-/* Returns 1 iff old_id is a template parameter. OLD_DECL is the decl\n-   from IDENTIFIER_LOCAL_VALUE (new identifier). */\n+/* Returns 1 iff DECL is a template parameter.  */\n \n-int decl_template_parm_p (old_decl)\n-     tree old_decl;\n+int decl_template_parm_p (decl)\n+     tree decl;\n {\n   /* For template template parms. */\n-  if (TREE_CODE (old_decl) == TEMPLATE_DECL\n-      && TREE_TYPE (old_decl)\n-      && TREE_CODE (TREE_TYPE (old_decl)) == TEMPLATE_TEMPLATE_PARM)\n+  if (TREE_CODE (decl) == TEMPLATE_DECL\n+      && TREE_TYPE (decl)\n+      && TREE_CODE (TREE_TYPE (decl)) == TEMPLATE_TEMPLATE_PARM)\n     return 1;\n \n   /* For template type parms. */\n-  if (TREE_CODE (old_decl) == TYPE_DECL\n-      && TREE_TYPE (old_decl)\n-      && TREE_CODE (TREE_TYPE (old_decl)) == TEMPLATE_TYPE_PARM)\n+  if (TREE_CODE (decl) == TYPE_DECL\n+      && TREE_TYPE (decl)\n+      && TREE_CODE (TREE_TYPE (decl)) == TEMPLATE_TYPE_PARM)\n     return 1;\n \n   /* For template non-type parms. */\n-  if (TREE_CODE (old_decl) == CONST_DECL\n-      && DECL_INITIAL (old_decl) \n-      && TREE_CODE (DECL_INITIAL (old_decl)) == TEMPLATE_PARM_INDEX)\n+  if (TREE_CODE (decl) == CONST_DECL\n+      && DECL_INITIAL (decl) \n+      && TREE_CODE (DECL_INITIAL (decl)) == TEMPLATE_PARM_INDEX)\n     return 1;\n \n   return 0;\n@@ -1523,11 +1503,10 @@ void\n check_template_shadow (decl)\n      tree decl;\n {\n-  if (current_template_parms \n-      && IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)))\n-    {\n-      tree olddecl = IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl));\n+  tree olddecl = IDENTIFIER_VALUE (DECL_NAME (decl));\n \n+  if (current_template_parms && olddecl)\n+    {\n       /* We check for decl != olddecl to avoid bogus errors for using a\n \t name inside a class.  We check TPFI to avoid duplicate errors for\n \t inline member templates.  */\n@@ -3423,9 +3402,9 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \n   if (TREE_CODE (d1) == IDENTIFIER_NODE)\n     {\n-      if (IDENTIFIER_LOCAL_VALUE (d1) \n-\t  && DECL_TEMPLATE_TEMPLATE_PARM_P (IDENTIFIER_LOCAL_VALUE (d1)))\n-\ttemplate = IDENTIFIER_LOCAL_VALUE (d1);\n+      if (IDENTIFIER_VALUE (d1) \n+\t  && DECL_TEMPLATE_TEMPLATE_PARM_P (IDENTIFIER_VALUE (d1)))\n+\ttemplate = IDENTIFIER_VALUE (d1);\n       else\n \t{\n \t  if (context)\n@@ -3468,9 +3447,10 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n     my_friendly_abort (272);\n \n   /* With something like `template <class T> class X class X { ... };'\n-     we could end up with D1 having nothing but an IDENTIFIER_LOCAL_VALUE.\n-     We don't want to do that, but we have to deal with the situation, so\n-     let's give them some syntax errors to chew on instead of a crash.  */\n+     we could end up with D1 having nothing but an IDENTIFIER_VALUE.\n+     We don't want to do that, but we have to deal with the situation,\n+     so let's give them some syntax errors to chew on instead of a\n+     crash.  */\n   if (! template)\n     {\n       cp_error (\"`%T' is not a template\", d1);\n@@ -5434,11 +5414,9 @@ tsubst_decl (t, args, type, in_decl)\n \tif (member && !strncmp (OPERATOR_TYPENAME_FORMAT,\n \t\t\t\tIDENTIFIER_POINTER (DECL_NAME (r)),\n \t\t\t\tsizeof (OPERATOR_TYPENAME_FORMAT) - 1))\n-\t  {\n-\t    /* Type-conversion operator.  Reconstruct the name, in\n-\t       case it's the name of one of the template's parameters.  */\n-\t    DECL_NAME (r) = build_typename_overload (TREE_TYPE (type));\n-\t  }\n+\t  /* Type-conversion operator.  Reconstruct the name, in\n+\t     case it's the name of one of the template's parameters.  */\n+\t  DECL_NAME (r) = build_typename_overload (TREE_TYPE (type));\n \n \tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args, t);\n \tDECL_MAIN_VARIANT (r) = r;\n@@ -5453,14 +5431,6 @@ tsubst_decl (t, args, type, in_decl)\n \tDECL_PENDING_INLINE_INFO (r) = 0;\n \tTREE_USED (r) = 0;\n \n-\tif (DECL_CONSTRUCTOR_P (r))\n-\t  {\n-\t    maybe_retrofit_in_chrg (r);\n-\t    grok_ctor_properties (ctx, r);\n-\t  }\n-\tif (IDENTIFIER_OPNAME_P (DECL_NAME (r)))\n-\t  grok_op_properties (r, DECL_VIRTUAL_P (r), DECL_FRIEND_P (r));\n-\n \t/* Set up the DECL_TEMPLATE_INFO for R and compute its mangled\n \t   name.  There's no need to do this in the special friend\n \t   case mentioned above where GEN_TMPL is NULL.  */\n@@ -5507,6 +5477,14 @@ tsubst_decl (t, args, type, in_decl)\n \t\t    == NULL_TREE))\n \t      SET_IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (r), r);\n \t  }\n+\n+\tif (DECL_CONSTRUCTOR_P (r))\n+\t  {\n+\t    maybe_retrofit_in_chrg (r);\n+\t    grok_ctor_properties (ctx, r);\n+\t  }\n+\tif (IDENTIFIER_OPNAME_P (DECL_NAME (r)))\n+\t  grok_op_properties (r, DECL_VIRTUAL_P (r), DECL_FRIEND_P (r));\n       }\n       break;\n \n@@ -7688,11 +7666,12 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n       }\n \n     case RECORD_TYPE:\n+    case UNION_TYPE:\n       if (TYPE_PTRMEMFUNC_FLAG (parm))\n \treturn unify (tparms, targs, TYPE_PTRMEMFUNC_FN_TYPE (parm),\n \t\t      arg, strict, explicit_mask);\n \n-      if (TREE_CODE (arg) != RECORD_TYPE)\n+      if (TREE_CODE (arg) != TREE_CODE (parm))\n \treturn 1;\n   \n       if (CLASSTYPE_TEMPLATE_INFO (parm) && uses_template_parms (parm))"}, {"sha": "4fb0413b9c0efa829ef9cab57e9897ee94a602f4", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -152,7 +152,7 @@ print_lang_identifier (file, node, indent)\n {\n   print_node (file, \"bindings\", IDENTIFIER_NAMESPACE_BINDINGS (node), indent + 4);\n   print_node (file, \"class\", IDENTIFIER_CLASS_VALUE (node), indent + 4);\n-  print_node (file, \"local\", IDENTIFIER_LOCAL_VALUE (node), indent + 4);\n+  print_node (file, \"local bindings\", IDENTIFIER_BINDING (node), indent + 4);\n   print_node (file, \"label\", IDENTIFIER_LABEL_VALUE (node), indent + 4);\n   print_node (file, \"template\", IDENTIFIER_TEMPLATE (node), indent + 4);\n   print_node (file, \"implicit\", IDENTIFIER_IMPLICIT_DECL (node), indent + 4);\n@@ -168,7 +168,8 @@ lang_print_xnode (file, node, indent)\n   switch (TREE_CODE (node))\n     {\n     case CPLUS_BINDING:\n-      print_node (file, \"scope\", BINDING_SCOPE (node), indent+4);\n+      fprintf (file, \" scope \");\n+      fprintf (file, HOST_PTR_PRINTF, BINDING_SCOPE (node));\n       print_node (file, \"value\", BINDING_VALUE (node), indent+4);\n       print_node (file, \"chain\", TREE_CHAIN (node), indent+4);\n       break;"}, {"sha": "fddc9998070d34341276570b60c0359a12dbfde0", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -4849,7 +4849,8 @@ mark_addressable (exp)\n \n \t    TREE_ASM_WRITTEN (x) = 0;\n \t    DECL_RTL (x) = 0;\n-\t    rest_of_decl_compilation (x, 0, IDENTIFIER_LOCAL_VALUE (x) == 0,\n+\t    rest_of_decl_compilation (x, 0, \n+\t\t\t\t      !DECL_FUNCTION_SCOPE_P (x),\n \t\t\t\t      0);\n \t    TREE_ADDRESSABLE (x) = 1;\n \n@@ -7235,9 +7236,9 @@ c_expand_return (retval)\n \t      if (TEMP_NAME_P (DECL_NAME (whats_returned)))\n \t\twarning (\"reference to non-lvalue returned\");\n \t      else if (TREE_CODE (TREE_TYPE (whats_returned)) != REFERENCE_TYPE\n-\t\t       && ! TREE_STATIC (whats_returned)\n-\t\t       && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned))\n-\t\t       && !TREE_PUBLIC (whats_returned))\n+\t\t       && DECL_FUNCTION_SCOPE_P (whats_returned)\n+\t\t       && !(TREE_STATIC (whats_returned)\n+\t\t\t    || TREE_PUBLIC (whats_returned)))\n \t\tcp_warning_at (\"reference to local variable `%D' returned\", whats_returned);\n \t    }\n \t}\n@@ -7247,9 +7248,9 @@ c_expand_return (retval)\n \n \t  if (TREE_CODE (whats_returned) == VAR_DECL\n \t      && DECL_NAME (whats_returned)\n-\t      && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned))\n-\t      && !TREE_STATIC (whats_returned)\n-\t      && !TREE_PUBLIC (whats_returned))\n+\t      && DECL_FUNCTION_SCOPE_P (whats_returned)\n+\t      && !(TREE_STATIC (whats_returned)\n+\t\t   || TREE_PUBLIC (whats_returned)))\n \t    cp_warning_at (\"address of local variable `%D' returned\", whats_returned);\n \t}\n     }"}, {"sha": "dcd35681bde59014f3d5d036f243aa495ef96a4d", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900511_02.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900511_02.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900511_02.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900511_02.C?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -8,11 +8,11 @@\n \n // cfront 2.0 passes this test.\n \n-enum enum0 { enum0_value_0 };\t// ERROR - \n+enum enum0 { enum0_value_0 };\n \n struct struct0 {\n-  int enum0;\t\t\t// ERROR - \n-  void member_function (enum0 e);\n+  int enum0;\t\t\t\n+  void member_function (enum0 e); // ERROR - \n };\n \n void class0::member_function (enum0 e) {\t// ERROR - "}, {"sha": "d3cf47c575e714825527d35f987e4c5451b5d85b", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900511_03.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900511_03.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900511_03.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900511_03.C?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -6,11 +6,11 @@\n \n // keywords: typedef names, shadowing, scope, formal parameter list\n \n-class class0;\t\t\t\t// ERROR - \n+class class0;\n \n struct struct1 {\n-  int class0;\t\t\t// ERROR - \n-  void member_function (class0 *);\n+  int class0;\t\t\t\n+  void member_function (class0 *); // ERROR - \n };\n \n void class1::member_function (class0 *p) {\t// ERROR - "}, {"sha": "31cd741a366878800af45862b17765f16d29bfae", "filename": "gcc/testsuite/g++.old-deja/g++.other/for1.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffor1.C?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -0,0 +1,41 @@\n+// Build don't link:\n+\n+int i;\n+int j;\n+\n+struct S {\n+  int operator()(int)\n+    {\n+      i = 1;\n+    }\n+\n+  typedef int I;\n+\n+  void f() {\n+    for (S I; false; )\n+      ;\n+    int k = I(3);\n+  }\n+};\n+\n+typedef int J;\n+\n+struct T {\n+  int operator()(int)\n+    {\n+      j = 1;\n+    }\n+\n+  void f() {\n+    for (T J; false; )\n+      ;\n+    int k = J(3);\n+  }\n+};\n+\n+int main()\n+{\n+  S s;\n+  s.f();\n+  return 2 * i + j;\n+}"}, {"sha": "08f5ac521ed56a745eacf9fdae3e7dd9ab6c9997", "filename": "gcc/testsuite/g++.old-deja/g++.other/lookup6.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup6.C?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -0,0 +1,25 @@\n+int f(int i)\n+{\n+  struct C {\n+    int i;\n+    C () : i(1) {}\n+    int f() {    \n+      struct D {\n+        int i;\n+\tD () : i(2) {}\n+        int g() { return i; }\n+      } d;\n+\n+      return d.g();\n+    }\n+  } c;\n+\n+  return c.f();\n+}\n+\n+\n+int main()\n+{\n+  if (f(0) != 2)\n+    return 1;\n+}"}, {"sha": "521f4bd4d06a91e608de4728ddc444f480689de2", "filename": "gcc/testsuite/g++.old-deja/g++.other/overload9.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload9.C?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -0,0 +1,31 @@\n+struct T { ~T() {}; };\n+\n+int g ()\n+{\n+ foo:\n+  T t;\n+  int f(int);\n+ bar:\n+  T t2;\n+  int f(double);\n+  return f(3);\n+}\n+\n+\n+int f(int)\n+{\n+  return 0;\n+}\n+\n+\n+int f(double)\n+{\n+  return 1;\n+}\n+\n+\n+int main()\n+{\n+  return g();\n+}\n+"}, {"sha": "7981530f697ea1789518ccede3e6d5a7987f4a14", "filename": "gcc/testsuite/g++.old-deja/g++.pt/copy1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcopy1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcopy1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcopy1.C?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -0,0 +1,29 @@\n+int i = 0;\n+\n+template <class T>\n+class F \n+{\n+public:\n+  F() {}\n+  \n+  template <class T2> F(F<T2>) \n+    {\n+      i = 1;\n+    }      \n+};\n+\n+\n+F<int>\n+foo()\n+{\n+  F<int> f1;\n+  F<int> f2(f1);\n+  return f1;\n+}\n+\n+int\n+main()\n+{\n+  return i;\n+}\n+"}, {"sha": "56eb80a5056da2a29a947e3d840f3bcc458d8138", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend34.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend34.C?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -1,5 +1,5 @@\n // Build don't link:\n-// excess errors test - XFAIL *-*-*\n+// excess errors test \n \n // This testcase won't fail if class ::foo is forward-declared in the\n // global namespace, nor if class bar is not a template class."}, {"sha": "a1da446e570718b200213adac8a1c630ef5474ce", "filename": "gcc/testsuite/g++.old-deja/g++.pt/union1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funion1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f181d4aea017cdd3597d324a78cdd60f1989cddf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funion1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funion1.C?ref=f181d4aea017cdd3597d324a78cdd60f1989cddf", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+\n+union Un {int i;};\n+\n+template<class T1, class T2> struct St1 {};\n+template<class T> struct St1<Un,T> {};\n+\n+template<class T> struct St2 {};\n+template<> struct St2<Un> {};\n+\n+template<class T1, class T2> struct St3 {};\n+template<> struct St3<Un,int> {};\n+\n+void f() {\n+  St1<int,int> s1;\n+  St2<int>     s2;\n+  St3<int,int> s3;\n+}"}]}