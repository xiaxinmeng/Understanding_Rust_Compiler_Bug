{"sha": "72a35f9354f285d7ab6211c6c1b71056969f90c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJhMzVmOTM1NGYyODVkN2FiNjIxMWM2YzFiNzEwNTY5NjlmOTBjNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-08-05T15:47:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-08-05T15:47:31Z"}, "message": "gensupport.c (sequence_num): Replace with...\n\ngcc/\n\t* gensupport.c (sequence_num): Replace with...\n\t(insn_sequence_num, split_sequence_num, peephole2_sequence_num):\n\t...these new variables.\n\t(init_rtx_reader_args_cb): Update accordingly.\n\t(get_num_code_insns): Likewise.\n\t(read_md_rtx): Rework to use a while loop and get_c_test.\n\tUse the new counters.  Remove redundant DEFINE_SUBST case.\n\t* genoutput.c (gen_split): Delete.\n\t(main): Don't call it.\n\nFrom-SVN: r226635", "tree": {"sha": "4433412ddc23100f25b093ce4c253045e93e103b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4433412ddc23100f25b093ce4c253045e93e103b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72a35f9354f285d7ab6211c6c1b71056969f90c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a35f9354f285d7ab6211c6c1b71056969f90c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72a35f9354f285d7ab6211c6c1b71056969f90c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a35f9354f285d7ab6211c6c1b71056969f90c7/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d1427a17a7d98f096ee0b199ef8caf993c8f2e0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1427a17a7d98f096ee0b199ef8caf993c8f2e0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1427a17a7d98f096ee0b199ef8caf993c8f2e0e"}], "stats": {"total": 169, "additions": 78, "deletions": 91}, "files": [{"sha": "38c3fdc8947e05f70d2362bd9334c010576e43c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a35f9354f285d7ab6211c6c1b71056969f90c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a35f9354f285d7ab6211c6c1b71056969f90c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72a35f9354f285d7ab6211c6c1b71056969f90c7", "patch": "@@ -1,3 +1,15 @@\n+2015-08-05  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gensupport.c (sequence_num): Replace with...\n+\t(insn_sequence_num, split_sequence_num, peephole2_sequence_num):\n+\t...these new variables.\n+\t(init_rtx_reader_args_cb): Update accordingly.\n+\t(get_num_code_insns): Likewise.\n+\t(read_md_rtx): Rework to use a while loop and get_c_test.\n+\tUse the new counters.  Remove redundant DEFINE_SUBST case.\n+\t* genoutput.c (gen_split): Delete.\n+\t(main): Don't call it.\n+\n 2015-08-05  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gensupport.h (get_c_test): Declare."}, {"sha": "ed9540ded4c777dd32cbd45493e594101017e4ff", "filename": "gcc/genoutput.c", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a35f9354f285d7ab6211c6c1b71056969f90c7/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a35f9354f285d7ab6211c6c1b71056969f90c7/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=72a35f9354f285d7ab6211c6c1b71056969f90c7", "patch": "@@ -973,46 +973,6 @@ gen_expand (md_rtx_info *info)\n   place_operands (d);\n }\n \f\n-/* Process a define_split just read.  Assign its code number,\n-   only for reasons of consistency and to simplify genrecog.  */\n-\n-static void\n-gen_split (md_rtx_info *info)\n-{\n-  struct pattern_stats stats;\n-  data *d = new data;\n-  int i;\n-\n-  d->code_number = info->index;\n-  d->loc = info->loc;\n-  d->name = 0;\n-\n-  /* Build up the list in the same order as the insns are seen\n-     in the machine description.  */\n-  d->next = 0;\n-  *idata_end = d;\n-  idata_end = &d->next;\n-\n-  memset (d->operand, 0, sizeof (d->operand));\n-\n-  /* Get the number of operands by scanning all the patterns of the\n-     split patterns.  But ignore all the rest of the information thus\n-     obtained.  */\n-  rtx split = info->def;\n-  for (i = 0; i < XVECLEN (split, 0); i++)\n-    scan_operands (d, XVECEXP (split, 0, i), 0, 0);\n-\n-  get_pattern_stats (&stats, XVEC (split, 0));\n-  d->n_generator_args = 0;\n-  d->n_operands = stats.num_insn_operands;\n-  d->n_dups = 0;\n-  d->n_alternatives = 0;\n-  d->template_code = 0;\n-  d->output_format = INSN_OUTPUT_FORMAT_NONE;\n-\n-  place_operands (d);\n-}\n-\n static void\n init_insn_for_nothing (void)\n {\n@@ -1055,11 +1015,6 @@ main (int argc, char **argv)\n \tgen_expand (&info);\n \tbreak;\n \n-      case DEFINE_SPLIT:\n-      case DEFINE_PEEPHOLE2:\n-\tgen_split (&info);\n-\tbreak;\n-\n       case DEFINE_CONSTRAINT:\n       case DEFINE_REGISTER_CONSTRAINT:\n       case DEFINE_ADDRESS_CONSTRAINT:"}, {"sha": "9e00f13a2f9f0dcf9ad004fa97a7d6f7e8b1fc80", "filename": "gcc/gensupport.c", "status": "modified", "additions": 66, "deletions": 46, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a35f9354f285d7ab6211c6c1b71056969f90c7/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a35f9354f285d7ab6211c6c1b71056969f90c7/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=72a35f9354f285d7ab6211c6c1b71056969f90c7", "patch": "@@ -43,11 +43,14 @@ int insn_elision = 1;\n static struct obstack obstack;\n struct obstack *rtl_obstack = &obstack;\n \n-/* Counter for patterns that generate code: define_insn, define_expand,\n-   define_split, define_peephole, and define_peephole2.  See read_md_rtx().\n-   Any define_insn_and_splits are already in separate queues so that the\n-   insn and the splitter get a unique number also.  */\n-static int sequence_num;\n+/* Counter for named patterns and INSN_CODEs.  */\n+static int insn_sequence_num;\n+\n+/* Counter for define_splits.  */\n+static int split_sequence_num;\n+\n+/* Counter for define_peephole2s.  */\n+static int peephole2_sequence_num;\n \n static int predicable_default;\n static const char *predicable_true;\n@@ -2504,7 +2507,11 @@ init_rtx_reader_args_cb (int argc, char **argv,\n   obstack_init (rtl_obstack);\n \n   /* Start at 1, to make 0 available for CODE_FOR_nothing.  */\n-  sequence_num = 1;\n+  insn_sequence_num = 1;\n+\n+  /* These sequences are not used as indices, so can start at 1 also.  */\n+  split_sequence_num = 1;\n+  peephole2_sequence_num = 1;\n \n   read_md_files (argc, argv, parse_opt, rtx_handle_directive);\n \n@@ -2539,66 +2546,79 @@ init_rtx_reader_args (int argc, char **argv)\n bool\n read_md_rtx (md_rtx_info *info)\n {\n-  struct queue_elem **queue, *elem;\n-  rtx desc;\n-\n- discard:\n-\n-  /* Read all patterns from a given queue before moving on to the next.  */\n-  if (define_attr_queue != NULL)\n-    queue = &define_attr_queue;\n-  else if (define_pred_queue != NULL)\n-    queue = &define_pred_queue;\n-  else if (define_insn_queue != NULL)\n-    queue = &define_insn_queue;\n-  else if (other_queue != NULL)\n-    queue = &other_queue;\n-  else\n-    return false;\n-\n-  elem = *queue;\n-  *queue = elem->next;\n-  info->def = elem->data;\n-  info->loc = elem->loc;\n-  info->index = sequence_num;\n-\n-  free (elem);\n+  int truth, *counter;\n+  rtx def;\n \n   /* Discard insn patterns which we know can never match (because\n      their C test is provably always false).  If insn_elision is\n      false, our caller needs to see all the patterns.  Note that the\n      elided patterns are never counted by the sequence numbering; it\n      is the caller's responsibility, when insn_elision is false, not\n      to use elided pattern numbers for anything.  */\n-  desc = info->def;\n-  switch (GET_CODE (desc))\n+  do\n+    {\n+      struct queue_elem **queue, *elem;\n+\n+      /* Read all patterns from a given queue before moving on to the next.  */\n+      if (define_attr_queue != NULL)\n+\tqueue = &define_attr_queue;\n+      else if (define_pred_queue != NULL)\n+\tqueue = &define_pred_queue;\n+      else if (define_insn_queue != NULL)\n+\tqueue = &define_insn_queue;\n+      else if (other_queue != NULL)\n+\tqueue = &other_queue;\n+      else\n+\treturn false;\n+\n+      elem = *queue;\n+      *queue = elem->next;\n+      def = elem->data;\n+      info->def = def;\n+      info->loc = elem->loc;\n+      free (elem);\n+\n+      truth = maybe_eval_c_test (get_c_test (def));\n+    }\n+  while (truth == 0 && insn_elision);\n+\n+  /* Perform code-specific processing and pick the appropriate sequence\n+     number counter.  */\n+  switch (GET_CODE (def))\n     {\n     case DEFINE_INSN:\n     case DEFINE_EXPAND:\n-    case DEFINE_SUBST:\n-      if (maybe_eval_c_test (XSTR (desc, 2)) != 0)\n-\tsequence_num++;\n-      else if (insn_elision)\n-\tgoto discard;\n-\n-      /* info->index is used here so the name table will match caller's\n+      /* insn_sequence_num is used here so the name table will match caller's\n \t idea of insn numbering, whether or not elision is active.  */\n-      record_insn_name (info->index, XSTR (desc, 0));\n+      record_insn_name (insn_sequence_num, XSTR (def, 0));\n+\n+      /* Fall through.  */\n+    case DEFINE_PEEPHOLE:\n+      counter = &insn_sequence_num;\n       break;\n \n     case DEFINE_SPLIT:\n-    case DEFINE_PEEPHOLE:\n+      counter = &split_sequence_num;\n+      break;\n+\n     case DEFINE_PEEPHOLE2:\n-      if (maybe_eval_c_test (XSTR (desc, 1)) != 0)\n-\tsequence_num++;\n-      else if (insn_elision)\n-\tgoto discard;\n+      counter = &peephole2_sequence_num;\n       break;\n \n     default:\n+      counter = NULL;\n       break;\n     }\n \n+  if (counter)\n+    {\n+      info->index = *counter;\n+      if (truth != 0)\n+\t*counter += 1;\n+    }\n+  else\n+    info->index = -1;\n+\n   return true;\n }\n \n@@ -2607,7 +2627,7 @@ read_md_rtx (md_rtx_info *info)\n unsigned int\n get_num_insn_codes ()\n {\n-  return sequence_num;\n+  return insn_sequence_num;\n }\n \n /* Return the C test that says whether definition rtx DEF can be used,"}]}