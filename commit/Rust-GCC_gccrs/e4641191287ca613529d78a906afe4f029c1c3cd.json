{"sha": "e4641191287ca613529d78a906afe4f029c1c3cd", "node_id": "C_kwDOANBUbNoAKGU0NjQxMTkxMjg3Y2E2MTM1MjlkNzhhOTA2YWZlNGYwMjljMWMzY2Q", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-11-13T12:26:16Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-11-16T19:42:35Z"}, "message": "PCH: Make the save and restore diagnostics more robust.\n\nWhen saving, if we cannot obtain a suitable memory segment there\nis no point in continuing, so exit with an error.\n\nWhen reading in the PCH, we have a situation that the read-in\ndata will replace the line tables used by the diagnostics output.\nHowever, the state of the read-oin line tables is indeterminate\nat some points where diagnostics might be needed.\n\nTo make this more robust, we save the existing line tables at\nthe start and, once we have read in the pointer to the new one,\nput that to one side and restore the original table.  This\navoids compiler hangs if the read or memory acquisition code\nissues an assert, fatal_error, segv etc.\n\nOnce the read is complete, we swap in the new line table that\ncame from the PCH.\n\nIf the read-in PCH is corrupted then we still have a broken\ncompilation w.r.t any future diagnostics - but there is little\nthat can be done about that without more careful validation of\nthe file.\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\ngcc/ChangeLog:\n\n\t* ggc-common.c (gt_pch_save): If we cannot find a suitable\n\tmemory segment for save, then error-out, do not try to\n\tcontinue.\n\t(gt_pch_restore): Save the existing line table, and when\n\tthe replacement is being read, use that when constructing\n\tdiagnostics.", "tree": {"sha": "36b948e20a0b63f8c27845aa38866e73534dd0ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36b948e20a0b63f8c27845aa38866e73534dd0ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4641191287ca613529d78a906afe4f029c1c3cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4641191287ca613529d78a906afe4f029c1c3cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4641191287ca613529d78a906afe4f029c1c3cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4641191287ca613529d78a906afe4f029c1c3cd/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cdf7db9a39d18bd536d816a5751d4d3cf23808b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cdf7db9a39d18bd536d816a5751d4d3cf23808b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cdf7db9a39d18bd536d816a5751d4d3cf23808b"}], "stats": {"total": 39, "additions": 37, "deletions": 2}, "files": [{"sha": "b6abed1d9a2ba46cd36ef71ef5a12ef8d7a29d08", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4641191287ca613529d78a906afe4f029c1c3cd/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4641191287ca613529d78a906afe4f029c1c3cd/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=e4641191287ca613529d78a906afe4f029c1c3cd", "patch": "@@ -440,6 +440,10 @@ gt_pch_save (FILE *f)\n      (The extra work goes in HOST_HOOKS_GT_PCH_GET_ADDRESS and\n      HOST_HOOKS_GT_PCH_USE_ADDRESS.)  */\n   mmi.preferred_base = host_hooks.gt_pch_get_address (mmi.size, fileno (f));\n+  /* If the host cannot supply any suitable address for this, we are stuck.  */\n+  if (mmi.preferred_base == NULL)\n+    fatal_error (input_location,\n+\t\t \"cannot write PCH file: required memory segment unavailable\");\n \n   ggc_pch_this_base (state.d, mmi.preferred_base);\n \n@@ -589,6 +593,13 @@ gt_pch_restore (FILE *f)\n   struct mmap_info mmi;\n   int result;\n \n+  /* We are about to reload the line maps along with the rest of the PCH\n+     data, which means that the (loaded) ones cannot be guaranteed to be\n+     in any valid state for reporting diagnostics that happen during the\n+     load.  Save the current table (and use it during the loading process\n+     below).  */\n+  class line_maps *save_line_table = line_table;\n+\n   /* Delete any deletable objects.  This makes ggc_pch_read much\n      faster, as it can be sure that no GCable objects remain other\n      than the ones just read in.  */\n@@ -603,20 +614,40 @@ gt_pch_restore (FILE *f)\n \tfatal_error (input_location, \"cannot read PCH file: %m\");\n \n   /* Read in all the global pointers, in 6 easy loops.  */\n+  bool error_reading_pointers = false;\n   for (rt = gt_ggc_rtab; *rt; rt++)\n     for (rti = *rt; rti->base != NULL; rti++)\n       for (i = 0; i < rti->nelt; i++)\n \tif (fread ((char *)rti->base + rti->stride * i,\n \t\t   sizeof (void *), 1, f) != 1)\n-\t  fatal_error (input_location, \"cannot read PCH file: %m\");\n+\t  error_reading_pointers = true;\n+\n+  /* Stash the newly read-in line table pointer - it does not point to\n+     anything meaningful yet, so swap the old one back in.  */\n+  class line_maps *new_line_table = line_table;\n+  line_table = save_line_table;\n+  if (error_reading_pointers)\n+    fatal_error (input_location, \"cannot read PCH file: %m\");\n \n   if (fread (&mmi, sizeof (mmi), 1, f) != 1)\n     fatal_error (input_location, \"cannot read PCH file: %m\");\n \n   result = host_hooks.gt_pch_use_address (mmi.preferred_base, mmi.size,\n \t\t\t\t\t  fileno (f), mmi.offset);\n+\n+  /* We could not mmap or otherwise allocate the required memory at the\n+     address needed.  */\n   if (result < 0)\n-    fatal_error (input_location, \"had to relocate PCH\");\n+    {\n+      sorry_at (input_location, \"PCH relocation is not yet supported\");\n+      /* There is no point in continuing from here, we will only end up\n+\t with a crashed (most likely hanging) compiler.  */\n+      exit (-1);\n+    }\n+\n+  /* (0) We allocated memory, but did not mmap the file, so we need to read\n+     the data in manually.  (>0) Otherwise the mmap succeed for the address\n+     we wanted.  */\n   if (result == 0)\n     {\n       if (fseek (f, mmi.offset, SEEK_SET) != 0\n@@ -629,6 +660,10 @@ gt_pch_restore (FILE *f)\n   ggc_pch_read (f, mmi.preferred_base);\n \n   gt_pch_restore_stringpool ();\n+\n+  /* Barring corruption of the PCH file, the restored line table should be\n+     complete and usable.  */\n+  line_table = new_line_table;\n }\n \n /* Default version of HOST_HOOKS_GT_PCH_GET_ADDRESS when mmap is not present."}]}