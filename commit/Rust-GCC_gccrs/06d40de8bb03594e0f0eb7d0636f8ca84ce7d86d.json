{"sha": "06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZkNDBkZThiYjAzNTk0ZTBmMGViN2QwNjM2ZjhjYTg0Y2U3ZDg2ZA==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2007-01-02T14:23:26Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-01-02T14:23:26Z"}, "message": "c-common.c (c_common_nodes_and_builtins): Since variants of void_type_node get built before it is given a name...\n\n2007-01-02  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* c-common.c(c_common_nodes_and_builtins): Since variants of\n\tvoid_type_node get built before it is given a name, we need to\n\tgive those variants the name, too. \n\t(complete_array_type): We need to work with the canonical main\n\ttype of the array, from which we will build the qualified version.\n\t* params.def (PARAM_VERIFY_CANONICAL_TYPES): New.\n\t* print-tree.c (print_node): Display canonical type information\n\tfor each type.\n\t* stor-layout.c (layout_type): When we don't know the\n\talignment of a type for which we're building an array, we end up\n\tguessing wrong, so make the type require structural equality.\n\t* tree.c (make_node_stat): When we build a new type, it is its\n\town canonical type.\n\t(build_type_attribute_qual_variant): When building an attribute\n\tvariant, its canonical type is the non-attribute variant. However,\n\tif the attributes are target-dependent and they differ, we need to\n\tuse structural equality checks for this type.\n\t(build_qualified_type): A qualified type is not equivalent to its\n\tunqualified variant; set the canonical type appropriately.\n\t(build_distinct_type_copy): When building a distinct type from\n\tanother type, the new type is its own canonical type.\n\t(build_variant_type_copy): When building a new type variant, we\n\tassume that it is equivalent to the original type.\n\t(build_pointer_type_for_mode): When building a pointer type, also\n\tbuild a canonical type pointer.\n\t(build_reference_type_for_mode): When building a reference type,\n\talso build a canonical type reference.\n\t(build_index_type): When we can't hash an index type (e.g.,\n\tbecause its maximum value is negative), the index type requires\n\tstructural equality tests.\n\t(build_array_type): Build the canonical form of an array type.\n\t(build_function_type): Function types require structural equality,\n\tbecause they contain default arguments, attributes, etc. \n\t(build_method_type_directly): Ditto for method types.\n\t(build_offset_type): Build the canonical offset type.\n\t(build_complex_type): Build the canonical vector type.\n\t(make_vector_type): Build the canonical vector type.\n\t* tree.h (TYPE_CANONICAL): New.\n\t(TYPE_STRUCTURAL_EQUALITY_P): New.\n\t(SET_TYPE_STRUCTURAL_EQUALITY): New.\n\t(struct tree_type): Added \"canonical\" field.\n\t* params.h (VERIFY_CANONICAL_TYPES): New.\n\t* doc/c-tree.texi (TYPE_CANONICAL): Document.\n\t(TYPE_STRUCTURAL_EQUALITY_P): Document.\n\t(SET_TYPE_STRUCTURAL_EQUALITY): Document.\n\t* doc/invoke.texi (verify-canonical-types): Document --param\n\tparameter for verifying canonical types.\n\t\n2007-01-02  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* typeck.c (structural_comptypes): Renamed from \"comptypes\".\n\t(comptypes): Use canonical type information to perform fast type\n\tcomparison. When VERIFY_CANONICAL_TYPES, verify that the\n\tcanonical type comparison returns the same results as we would see\n\tfrom the current, structural check. Support COMPARE_STRUCTURAL\n\twhen we need structural checks.\n\t* decl.c (typename_compare): Fix comment.\n\t(build_typename_type): TYPENAME_TYPE nodes require structural\n\tequality checks, because they resolve different based on the\n\tcurrent class type.\n\t(make_unbound_class_template): UNBOUND_CLASS_TEMPLATE nodes\n\trequire structural equality checks (for now).\n\t(build_ptrmemfunc_type): Build the canonical pointer to member\n\tfunction type.\n\t(compute_array_index_type): Whenever we build a new index type\n\tto represent the size of an array in a template, we need to mark\n\tthis index type as requiring structural equality. This goes for\n\tarrays with value-dependent sizes with the current ABI, or all\n\tarrays with ABI-1.\n\t* tree.c (cplus_array_hash): New.\n\t(struct cplus_array_info): New.\n\t(cplus_array_compare): New.\n\t(cplus_array_htab): New.\n\t(build_cplus_array_type_1): Use a hash table to cache the array\n\ttypes we build. Build the canonical array type for each array\n\ttype.\n\t(cp_build_qualified_type_real): When building a cv-qualified array\n\ttype, use the hash table of array types and build canonical array\n\ttypes as necessary.\n\t(bind_template_template_parm): BOUND_TEMPLATE_TEMPLATE_PARM nodes\n\tuse structural equality (for now).\n\t* cp-tree.h (COMPARE_STRUCTURAL): New.\n\t* pt.c (canonical_template_parms): New.\n\t(canonical_type_parameter): New.\n\t(process_template_parm): Find the canonical type parameter.\n\t(lookup_template_class): When we have named the primary template\n\ttype, set the canonical type for our template class to the primary\n\ttemplate type. If any of the template arguments need structural\n\tequality checks, the template class needs structural equality\n\tchecks.\n\t(tsubst): When reducing the level of a template template\n\tparameter, we require structural equality tests for the resulting\n\tparameter because its template parameters have not had their types\n\tcanonicalized. When reducing a template type parameter, find the\n\tcanonical reduced type parameter.\n\t(any_template_arguments_need_structural_equality_p): New.\n\n2007-01-02  Douglas Gregor  <doug.gregor@gmail.com>\n\t\n\t* objc-act.c (objc_build_volatilized_type): Keep track of\n\tcanonical types.\n\t(objc_get_protocol_qualified_type): Ditto.\n\nFrom-SVN: r120341", "tree": {"sha": "c7764f44cdfd0ac83984115b7e6b9f215d169dc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7764f44cdfd0ac83984115b7e6b9f215d169dc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eca0d5e8cef314a820425453b74f7bc4bb26100a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca0d5e8cef314a820425453b74f7bc4bb26100a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eca0d5e8cef314a820425453b74f7bc4bb26100a"}], "stats": {"total": 724, "additions": 701, "deletions": 23}, "files": [{"sha": "2e3e2abd9a6826f9a3c545fb4c92d0793eaa29a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -1,3 +1,53 @@\n+2007-01-02  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\t* c-common.c(c_common_nodes_and_builtins): Since variants of\n+\tvoid_type_node get built before it is given a name, we need to\n+\tgive those variants the name, too. \n+\t(complete_array_type): We need to work with the canonical main\n+\ttype of the array, from which we will build the qualified version.\n+\t* params.def (PARAM_VERIFY_CANONICAL_TYPES): New.\n+\t* print-tree.c (print_node): Display canonical type information\n+\tfor each type.\n+\t* stor-layout.c (layout_type): When we don't know the\n+\talignment of a type for which we're building an array, we end up\n+\tguessing wrong, so make the type require structural equality.\n+\t* tree.c (make_node_stat): When we build a new type, it is its\n+\town canonical type.\n+\t(build_type_attribute_qual_variant): When building an attribute\n+\tvariant, its canonical type is the non-attribute variant. However,\n+\tif the attributes are target-dependent and they differ, we need to\n+\tuse structural equality checks for this type.\n+\t(build_qualified_type): A qualified type is not equivalent to its\n+\tunqualified variant; set the canonical type appropriately.\n+\t(build_distinct_type_copy): When building a distinct type from\n+\tanother type, the new type is its own canonical type.\n+\t(build_variant_type_copy): When building a new type variant, we\n+\tassume that it is equivalent to the original type.\n+\t(build_pointer_type_for_mode): When building a pointer type, also\n+\tbuild a canonical type pointer.\n+\t(build_reference_type_for_mode): When building a reference type,\n+\talso build a canonical type reference.\n+\t(build_index_type): When we can't hash an index type (e.g.,\n+\tbecause its maximum value is negative), the index type requires\n+\tstructural equality tests.\n+\t(build_array_type): Build the canonical form of an array type.\n+\t(build_function_type): Function types require structural equality,\n+\tbecause they contain default arguments, attributes, etc. \n+\t(build_method_type_directly): Ditto for method types.\n+\t(build_offset_type): Build the canonical offset type.\n+\t(build_complex_type): Build the canonical vector type.\n+\t(make_vector_type): Build the canonical vector type.\n+\t* tree.h (TYPE_CANONICAL): New.\n+\t(TYPE_STRUCTURAL_EQUALITY_P): New.\n+\t(SET_TYPE_STRUCTURAL_EQUALITY): New.\n+\t(struct tree_type): Added \"canonical\" field.\n+\t* params.h (VERIFY_CANONICAL_TYPES): New.\n+\t* doc/c-tree.texi (TYPE_CANONICAL): Document.\n+\t(TYPE_STRUCTURAL_EQUALITY_P): Document.\n+\t(SET_TYPE_STRUCTURAL_EQUALITY): Document.\n+\t* doc/invoke.texi (verify-canonical-types): Document --param\n+\tparameter for verifying canonical types.\n+\n 2007-01-02  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config.gcc (powerpc-*-eabispe*, powerpc-*-eabisimaltivec*,"}, {"sha": "0658141dadc0f098c5cb6537d9d207efe7c10a6e", "filename": "gcc/c-common.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -3458,6 +3458,16 @@ c_common_nodes_and_builtins (void)\n \n   record_builtin_type (RID_VOID, NULL, void_type_node);\n \n+  /* Set the TYPE_NAME for any variants that were built before\n+     record_builtin_type gave names to the built-in types. */\n+  {\n+    tree void_name = TYPE_NAME (void_type_node);\n+    TYPE_NAME (void_type_node) = NULL_TREE;\n+    TYPE_NAME (build_qualified_type (void_type_node, TYPE_QUAL_CONST))\n+      = void_name;\n+    TYPE_NAME (void_type_node) = void_name;\n+  }\n+\n   /* This node must not be shared.  */\n   void_zero_node = make_node (INTEGER_CST);\n   TREE_TYPE (void_zero_node) = void_type_node;\n@@ -6294,6 +6304,7 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n {\n   tree maxindex, type, main_type, elt, unqual_elt;\n   int failure = 0, quals;\n+  hashval_t hashcode = 0;\n \n   maxindex = size_zero_node;\n   if (initial_value)\n@@ -6370,6 +6381,12 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n   TYPE_DOMAIN (main_type) = build_index_type (maxindex);\n   layout_type (main_type);\n \n+  /* Make sure we have the canonical MAIN_TYPE. */\n+  hashcode = iterative_hash_object (TYPE_HASH (unqual_elt), hashcode);\n+  hashcode = iterative_hash_object (TYPE_HASH (TYPE_DOMAIN (main_type)), \n+\t\t\t\t    hashcode);\n+  main_type = type_hash_canon (hashcode, main_type);\n+\n   if (quals == 0)\n     type = main_type;\n   else"}, {"sha": "dc291d054a175f9e7b836d08d87e2c9bede58d5b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -1,3 +1,52 @@\n+2007-01-02  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\t* typeck.c (structural_comptypes): Renamed from \"comptypes\".\n+\t(comptypes): Use canonical type information to perform fast type\n+\tcomparison. When VERIFY_CANONICAL_TYPES, verify that the\n+\tcanonical type comparison returns the same results as we would see\n+\tfrom the current, structural check. Support COMPARE_STRUCTURAL\n+\twhen we need structural checks.\n+\t* decl.c (typename_compare): Fix comment.\n+\t(build_typename_type): TYPENAME_TYPE nodes require structural\n+\tequality checks, because they resolve different based on the\n+\tcurrent class type.\n+\t(make_unbound_class_template): UNBOUND_CLASS_TEMPLATE nodes\n+\trequire structural equality checks (for now).\n+\t(build_ptrmemfunc_type): Build the canonical pointer to member\n+\tfunction type.\n+\t(compute_array_index_type): Whenever we build a new index type\n+\tto represent the size of an array in a template, we need to mark\n+\tthis index type as requiring structural equality. This goes for\n+\tarrays with value-dependent sizes with the current ABI, or all\n+\tarrays with ABI-1.\n+\t* tree.c (cplus_array_hash): New.\n+\t(struct cplus_array_info): New.\n+\t(cplus_array_compare): New.\n+\t(cplus_array_htab): New.\n+\t(build_cplus_array_type_1): Use a hash table to cache the array\n+\ttypes we build. Build the canonical array type for each array\n+\ttype.\n+\t(cp_build_qualified_type_real): When building a cv-qualified array\n+\ttype, use the hash table of array types and build canonical array\n+\ttypes as necessary.\n+\t(bind_template_template_parm): BOUND_TEMPLATE_TEMPLATE_PARM nodes\n+\tuse structural equality (for now).\n+\t* cp-tree.h (COMPARE_STRUCTURAL): New.\n+\t* pt.c (canonical_template_parms): New.\n+\t(canonical_type_parameter): New.\n+\t(process_template_parm): Find the canonical type parameter.\n+\t(lookup_template_class): When we have named the primary template\n+\ttype, set the canonical type for our template class to the primary\n+\ttemplate type. If any of the template arguments need structural\n+\tequality checks, the template class needs structural equality\n+\tchecks.\n+\t(tsubst): When reducing the level of a template template\n+\tparameter, we require structural equality tests for the resulting\n+\tparameter because its template parameters have not had their types\n+\tcanonicalized. When reducing a template type parameter, find the\n+\tcanonical reduced type parameter.\n+\t(any_template_arguments_need_structural_equality_p): New.\n+\n 2006-12-31  Simon Martin  <simartin@users.sourceforge.net>\n \n \tPR c++/29731"}, {"sha": "1ec96655ab5c14937214c0b5904ed0234cb96fe9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -3508,6 +3508,10 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define COMPARE_REDECLARATION 4 /* The comparison is being done when\n \t\t\t\t   another declaration of an existing\n \t\t\t\t   entity is seen.  */\n+#define COMPARE_STRUCTURAL    8 /* The comparison is intended to be\n+\t\t\t\t   structural. The actual comparison\n+\t\t\t\t   will be identical to\n+\t\t\t\t   COMPARE_STRICT.  */\n \n /* Used with push_overloaded_decl.  */\n #define PUSH_GLOBAL\t     0  /* Push the DECL into namespace scope,"}, {"sha": "1ed8afc7708ac7ac25c17aac49665d28d0c6283f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -2695,7 +2695,8 @@ typedef struct typename_info {\n   bool class_p;\n } typename_info;\n \n-/* Compare two TYPENAME_TYPEs.  K1 and K2 are really of type `tree'.  */\n+/* Compare two TYPENAME_TYPEs.  K1 is really of type `tree', K2 is\n+   really of type `typename_info*'  */\n \n static int\n typename_compare (const void * k1, const void * k2)\n@@ -2766,6 +2767,11 @@ build_typename_type (tree context, tree name, tree fullname,\n \n       /* Store it in the hash table.  */\n       *e = t;\n+\n+      /* TYPENAME_TYPEs must always be compared structurally, because\n+\t they may or may not resolve down to another type depending on\n+\t the currently open classes. */\n+      SET_TYPE_STRUCTURAL_EQUALITY (t);\n     }\n \n   return t;\n@@ -2937,6 +2943,7 @@ make_unbound_class_template (tree context, tree name, tree parm_list,\n   t = make_aggr_type (UNBOUND_CLASS_TEMPLATE);\n   TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n   TREE_TYPE (t) = NULL_TREE;\n+  SET_TYPE_STRUCTURAL_EQUALITY (t);\n \n   /* Build the corresponding TEMPLATE_DECL.  */\n   d = build_decl (TEMPLATE_DECL, name, t);\n@@ -6461,6 +6468,11 @@ build_ptrmemfunc_type (tree type)\n      later.  */\n   TYPE_SET_PTRMEMFUNC_TYPE (type, t);\n \n+  if (TYPE_STRUCTURAL_EQUALITY_P (type))\n+    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+  else if (TYPE_CANONICAL (type) != type)\n+    TYPE_CANONICAL (t) = build_ptrmemfunc_type (TYPE_CANONICAL (type));\n+\n   return t;\n }\n \n@@ -6535,6 +6547,7 @@ compute_array_index_type (tree name, tree size)\n {\n   tree type;\n   tree itype;\n+  tree abi_1_itype = NULL_TREE;\n \n   if (error_operand_p (size))\n     return error_mark_node;\n@@ -6551,14 +6564,26 @@ compute_array_index_type (tree name, tree size)\n       type = TREE_TYPE (size);\n     }\n \n-  if (abi_version_at_least (2)\n-      /* We should only handle value dependent expressions specially.  */\n-      ? value_dependent_expression_p (size)\n-      /* But for abi-1, we handled all instances in templates. This\n-\t effects the manglings produced.  */\n-      : processing_template_decl)\n-    return build_index_type (build_min (MINUS_EXPR, sizetype,\n-\t\t\t\t\tsize, integer_one_node));\n+  if (value_dependent_expression_p (size))\n+    {\n+      /* We cannot do any checking for a value-dependent SIZE. Just\n+\t build the index type and mark that it requires structural\n+\t equality checks.  */\n+      itype = build_index_type (build_min (MINUS_EXPR, sizetype,\n+\t\t\t\t\t   size, integer_one_node));\n+      SET_TYPE_STRUCTURAL_EQUALITY (itype);\n+      return itype;\n+    }\n+  \n+  if (!abi_version_at_least (2) && processing_template_decl)\n+    /* For abi-1, we handled all instances in templates the same way,\n+       even when they were non-dependent. This effects the manglings\n+       produced.  So, we do the normal checking for non-dependent\n+       sizes, but at the end we'll return the same type that abi-1\n+       would have, but with TYPE_CANONICAL set to the \"right\"\n+       value that the current ABI would provide. */\n+    abi_1_itype = build_index_type (build_min (MINUS_EXPR, sizetype,\n+\t\t\t\t\t       size, integer_one_node));\n \n   /* The size might be the result of a cast.  */\n   STRIP_TYPE_NOPS (size);\n@@ -6649,7 +6674,14 @@ compute_array_index_type (tree name, tree size)\n     }\n \n   /* Create and return the appropriate index type.  */\n-  return build_index_type (itype);\n+  if (abi_1_itype)\n+    {\n+      tree t = build_index_type (itype);\n+      TYPE_CANONICAL (abi_1_itype) = TYPE_CANONICAL (t);\n+      return abi_1_itype;\n+    }\n+  else\n+    return build_index_type (itype);\n }\n \n /* Returns the scope (if any) in which the entity declared by"}, {"sha": "1e90751287c89e8f99e451d21d1506a6ae994ba2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -80,6 +80,12 @@ static tree cur_stmt_expr;\n    local variables.  */\n static htab_t local_specializations;\n \n+/* Contains canonical template parameter types. The vector is index by\n+   the TEMPLATE_TYPE_IDX of the template parameter. Each element is a\n+   TREE_LIST, whose TREE_VALUEs contain the canonical template\n+   parameters of various types and levels.  */\n+static GTY(()) VEC(tree,gc) *canonical_template_parms;\n+\n #define UNIFY_ALLOW_NONE 0\n #define UNIFY_ALLOW_MORE_CV_QUAL 1\n #define UNIFY_ALLOW_LESS_CV_QUAL 2\n@@ -157,6 +163,7 @@ static tree copy_default_args_to_explicit_spec_1 (tree, tree);\n static void copy_default_args_to_explicit_spec (tree);\n static int invalid_nontype_parm_type_p (tree, tsubst_flags_t);\n static int eq_local_specializations (const void *, const void *);\n+static bool any_template_arguments_need_structural_equality_p (tree);\n static bool dependent_type_p_r (tree);\n static tree tsubst (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_expr\t(tree, tree, tsubst_flags_t, tree, bool);\n@@ -2335,6 +2342,35 @@ build_template_parm_index (int index,\n   return t;\n }\n \n+/* Find the canonical type parameter for the given template type\n+   parmaeter. Returns the canonical type parameter, which may be TYPE\n+   if no such parameter existed. */\n+static tree\n+canonical_type_parameter (tree type)\n+{\n+  tree list;\n+  int idx = TEMPLATE_TYPE_IDX (type);\n+  if (!canonical_template_parms)\n+    canonical_template_parms = VEC_alloc (tree, gc, idx+1);\n+\n+  while (VEC_length (tree, canonical_template_parms) <= (unsigned)idx)\n+    VEC_safe_push (tree, gc, canonical_template_parms, NULL_TREE);\n+\n+  list = VEC_index (tree, canonical_template_parms, idx);\n+  while (list && !comptypes (type, TREE_VALUE (list), COMPARE_STRUCTURAL))\n+    list = TREE_CHAIN (list);\n+\n+  if (list)\n+    return TREE_VALUE (list);\n+  else\n+    {\n+      VEC_replace(tree, canonical_template_parms, idx,\n+\t\t  tree_cons (NULL_TREE, type, \n+\t\t\t     VEC_index (tree, canonical_template_parms, idx)));\n+      return type;\n+    }\n+}\n+\n /* Return a TEMPLATE_PARM_INDEX, similar to INDEX, but whose\n    TEMPLATE_PARM_LEVEL has been decreased by LEVELS.  If such a\n    TEMPLATE_PARM_INDEX already exists, it is returned; otherwise, a\n@@ -2473,6 +2509,7 @@ process_template_parm (tree list, tree parm, bool is_non_type)\n \t= build_template_parm_index (idx, processing_template_decl,\n \t\t\t\t     processing_template_decl,\n \t\t\t\t     decl, TREE_TYPE (parm));\n+      TYPE_CANONICAL (t) = canonical_type_parameter (t);\n     }\n   DECL_ARTIFICIAL (decl) = 1;\n   SET_DECL_TEMPLATE_PARM_P (decl);\n@@ -4807,6 +4844,17 @@ lookup_template_class (tree d1,\n \t  /* A local class.  Make sure the decl gets registered properly.  */\n \t  if (context == current_function_decl)\n \t    pushtag (DECL_NAME (template), t, /*tag_scope=*/ts_current);\n+\n+\t  if (comp_template_args (CLASSTYPE_TI_ARGS (template_type), arglist))\n+\t    /* This instantiation is another name for the primary\n+\t       template type. Set the TYPE_CANONICAL field\n+\t       appropriately. */\n+\t    TYPE_CANONICAL (t) = template_type;\n+\t  else if (any_template_arguments_need_structural_equality_p (arglist))\n+\t    /* Some of the template arguments require structural\n+\t       equality testing, so this template class requires\n+\t       structural equality testing. */\n+\t    SET_TYPE_STRUCTURAL_EQUALITY (t);\n \t}\n \n       /* If we called start_enum or pushtag above, this information\n@@ -7473,6 +7521,18 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\tTYPE_POINTER_TO (r) = NULL_TREE;\n \t\tTYPE_REFERENCE_TO (r) = NULL_TREE;\n \n+\t\tif (TREE_CODE (r) == TEMPLATE_TEMPLATE_PARM)\n+\t\t  /* We have reduced the level of the template\n+\t\t     template parameter, but not the levels of its\n+\t\t     template parameters, so canonical_type_parameter\n+\t\t     will not be able to find the canonical template\n+\t\t     template parameter for this level. Thus, we\n+\t\t     require structural equality checking to compare\n+\t\t     TEMPLATE_TEMPLATE_PARMs. */\n+\t\t  SET_TYPE_STRUCTURAL_EQUALITY (r);\n+\t\telse\n+\t\t  TYPE_CANONICAL (r) = canonical_type_parameter (r);\n+\n \t\tif (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t\t  {\n \t\t    tree argvec = tsubst (TYPE_TI_ARGS (t), args,\n@@ -13167,6 +13227,40 @@ dependent_template_arg_p (tree arg)\n \t    || value_dependent_expression_p (arg));\n }\n \n+/* Returns true if ARGS (a collection of template arguments) contains\n+   any types that require structural equality testing.  */\n+\n+bool\n+any_template_arguments_need_structural_equality_p (tree args)\n+{\n+  int i;\n+  int j;\n+\n+  if (!args)\n+    return false;\n+  if (args == error_mark_node)\n+    return true;\n+\n+  for (i = 0; i < TMPL_ARGS_DEPTH (args); ++i)\n+    {\n+      tree level = TMPL_ARGS_LEVEL (args, i + 1);\n+      for (j = 0; j < TREE_VEC_LENGTH (level); ++j)\n+\t{\n+\t  tree arg = TREE_VEC_ELT (level, j);\n+\t  if (TREE_CODE (arg) == TEMPLATE_DECL\n+\t      || TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+\t    continue;\n+\t  else if (TYPE_P (arg) && TYPE_STRUCTURAL_EQUALITY_P (arg))\n+\t    return true;\n+\t  else if (!TYPE_P (arg) && TREE_TYPE (arg)\n+\t\t   && TYPE_STRUCTURAL_EQUALITY_P (TREE_TYPE (arg)))\n+\t    return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* Returns true if ARGS (a collection of template arguments) contains\n    any dependent arguments.  */\n "}, {"sha": "ae3dc4c27867ca7c0201c225037038415c4a082b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 134, "deletions": 3, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -407,6 +407,49 @@ rvalue (tree expr)\n }\n \n \f\n+/* Hash an ARRAY_TYPE.  K is really of type `tree'.  */\n+\n+static hashval_t\n+cplus_array_hash (const void* k)\n+{\n+  hashval_t hash;\n+  tree t = (tree) k;\n+\n+  hash = (htab_hash_pointer (TREE_TYPE (t))\n+\t  ^ htab_hash_pointer (TYPE_DOMAIN (t)));\n+\n+  return hash;\n+}\n+\n+typedef struct cplus_array_info {\n+  tree type;\n+  tree domain;\n+} cplus_array_info;\n+\n+/* Compare two ARRAY_TYPEs.  K1 is really of type `tree', K2 is really\n+   of type `cplus_array_info*'. */\n+\n+static int\n+cplus_array_compare (const void * k1, const void * k2)\n+{\n+  tree t1 = (tree) k1;\n+  const cplus_array_info *t2 = (const cplus_array_info*) k2;\n+\n+  if (!comptypes (TREE_TYPE (t1), t2->type, COMPARE_STRUCTURAL))\n+    return 0;\n+\n+  if (!TYPE_DOMAIN (t1))\n+    return !t2->domain;\n+\n+  if (!t2->domain)\n+    return 0;\n+\n+  return comptypes (TYPE_DOMAIN (t1), t2->domain, COMPARE_STRUCTURAL);\n+}\n+\n+static GTY ((param_is (union tree_node))) htab_t cplus_array_htab;\n+\n+\n static tree\n build_cplus_array_type_1 (tree elt_type, tree index_type)\n {\n@@ -419,9 +462,47 @@ build_cplus_array_type_1 (tree elt_type, tree index_type)\n       || (index_type\n \t  && value_dependent_expression_p (TYPE_MAX_VALUE (index_type))))\n     {\n-      t = make_node (ARRAY_TYPE);\n-      TREE_TYPE (t) = elt_type;\n-      TYPE_DOMAIN (t) = index_type;\n+      void **e;\n+      cplus_array_info cai;\n+      hashval_t hash;\n+      \n+      if (cplus_array_htab == NULL)\n+\tcplus_array_htab = htab_create_ggc (61, &cplus_array_hash,\n+\t\t\t\t\t    &cplus_array_compare, NULL);\n+      \n+      hash = (htab_hash_pointer (elt_type)\n+\t      ^ htab_hash_pointer (index_type));\n+      cai.type = elt_type;\n+      cai.domain = index_type;\n+\n+      e = htab_find_slot_with_hash (cplus_array_htab, &cai, hash, INSERT); \n+      if (*e)\n+\t/* We have found the type: we're done. */\n+\treturn (tree) *e;\n+      else\n+\t{\n+\t  /* Build a new array type. */\n+\t  t = make_node (ARRAY_TYPE);\n+\t  TREE_TYPE (t) = elt_type;\n+\t  TYPE_DOMAIN (t) = index_type;\n+\n+\t  /* Complete building the array type. */\n+\t  if (TYPE_STRUCTURAL_EQUALITY_P (elt_type)\n+\t      || (index_type && TYPE_STRUCTURAL_EQUALITY_P (index_type)))\n+\t    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+\t  else if (TYPE_CANONICAL (elt_type) != elt_type\n+\t\t   || (index_type \n+\t\t       && TYPE_CANONICAL (index_type) != index_type))\n+\t    TYPE_CANONICAL (t) \n+\t      = TYPE_CANONICAL \n+\t          (build_cplus_array_type_1 (TYPE_CANONICAL (elt_type),\n+\t\t\t\t\t     index_type? \n+\t\t\t\t\t       TYPE_CANONICAL (index_type)\n+\t\t\t\t\t       : index_type));\n+\n+\t  /* Store it in the hash table. */\n+\t  *e = t;\n+\t}\n     }\n   else\n     t = build_array_type (elt_type, index_type);\n@@ -508,10 +589,59 @@ cp_build_qualified_type_real (tree type,\n \n       if (!t)\n \t{\n+\t  tree domain = TYPE_DOMAIN (type);\n+\n \t  /* Make a new array type, just like the old one, but with the\n \t     appropriately qualified element type.  */\n \t  t = build_variant_type_copy (type);\n \t  TREE_TYPE (t) = element_type;\n+\n+\t  /* This is a new type. */\n+\t  TYPE_CANONICAL (t) = t;\n+\n+\t  if (dependent_type_p (element_type)\n+\t      || (domain\n+\t\t  && value_dependent_expression_p (TYPE_MAX_VALUE (domain))))\n+\t    {\n+\t      /* The new dependent array type we just created might be\n+\t\t equivalent to an existing dependent array type, so we\n+\t\t need to keep track of this new array type with a\n+\t\t lookup into CPLUS_ARRAY_HTAB. Note that we cannot\n+\t\t directly call build_cplus_array_type (that would\n+\t\t recurse) or build_cplus_array_type_1 (that would lose\n+\t\t attributes). */\n+\t      void **e;\n+\t      cplus_array_info cai;\n+\t      hashval_t hash;\n+\n+\t      if (cplus_array_htab == NULL)\n+\t\tcplus_array_htab = htab_create_ggc (61, &cplus_array_hash,\n+\t\t\t\t\t\t    &cplus_array_compare, \n+\t\t\t\t\t\t    NULL);\n+\t  \n+\t      hash = (htab_hash_pointer (element_type)\n+\t\t      ^ htab_hash_pointer (domain));\n+\t      cai.type = element_type;\n+\t      cai.domain = domain;\n+\t  \n+\t      e = htab_find_slot_with_hash (cplus_array_htab, &cai, hash, \n+\t\t\t\t\t    INSERT); \n+\t      if (! *e)\n+\t\t/* Save this new type. */\n+\t\t*e = t;\n+\t    }\n+\n+\t  if (TYPE_STRUCTURAL_EQUALITY_P (TREE_TYPE (t))\n+\t\t   || (TYPE_DOMAIN (t)\n+\t\t       && TYPE_STRUCTURAL_EQUALITY_P (TYPE_DOMAIN (t))))\n+\t    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+\t  else\n+\t    TYPE_CANONICAL (t) \n+\t      = TYPE_CANONICAL \n+\t          (build_array_type (TYPE_CANONICAL (TREE_TYPE (t)),\n+\t\t\t\t     TYPE_DOMAIN (t)? \n+\t\t\t\t       TYPE_CANONICAL (TYPE_DOMAIN(t))\n+\t\t\t\t       : TYPE_DOMAIN (t)));\n \t}\n \n       /* Even if we already had this variant, we update\n@@ -1003,6 +1133,7 @@ bind_template_template_parm (tree t, tree newargs)\n   TYPE_NAME (t2) = decl;\n   TYPE_STUB_DECL (t2) = decl;\n   TYPE_SIZE (t2) = 0;\n+  SET_TYPE_STRUCTURAL_EQUALITY (t2);\n \n   return t2;\n }"}, {"sha": "7e8b785b3eb7b3d903bb107a8256d9115ea1a6c0", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -43,6 +43,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"target.h\"\n #include \"convert.h\"\n #include \"c-common.h\"\n+#include \"params.h\"\n \n static tree pfn_from_ptrmemfunc (tree);\n static tree convert_for_assignment (tree, tree, const char *, tree, int);\n@@ -927,11 +928,10 @@ comp_array_types (tree t1, tree t2, bool allow_redeclaration)\n   return true;\n }\n \n-/* Return true if T1 and T2 are related as allowed by STRICT.  STRICT\n-   is a bitwise-or of the COMPARE_* flags.  */\n+/* Subroutine in comptypes.  */\n \n-bool\n-comptypes (tree t1, tree t2, int strict)\n+static bool\n+structural_comptypes (tree t1, tree t2, int strict)\n {\n   if (t1 == t2)\n     return true;\n@@ -1090,6 +1090,65 @@ comptypes (tree t1, tree t2, int strict)\n   return targetm.comp_type_attributes (t1, t2);\n }\n \n+/* Return true if T1 and T2 are related as allowed by STRICT.  STRICT\n+   is a bitwise-or of the COMPARE_* flags.  */\n+\n+bool\n+comptypes (tree t1, tree t2, int strict)\n+{\n+  if (strict == COMPARE_STRICT)\n+    {\n+      bool result;\n+\n+      if (t1 == t2)\n+\treturn true;\n+\n+      if (t1 == error_mark_node || t2 == error_mark_node)\n+\treturn false;\n+\n+      if (TYPE_STRUCTURAL_EQUALITY_P (t1) || TYPE_STRUCTURAL_EQUALITY_P (t2))\n+\t/* At least one of the types requires structural equality, so\n+\t   perform a deep check. */\n+\treturn structural_comptypes (t1, t2, strict);\n+\n+      if (VERIFY_CANONICAL_TYPES)\n+\t{\n+\t  result = structural_comptypes (t1, t2, strict);\n+\n+\t  if (result && TYPE_CANONICAL (t1) != TYPE_CANONICAL (t2))\n+\t    {\n+\t      /* The two types are structurally equivalent, but their\n+\t\t canonical types were different. This is a failure of the\n+\t\t canonical type propagation code.*/\n+\t      warning(0,\n+\t\t      \"canonical types differ for identical types %T and %T\", \n+\t\t      t1, t2);\n+\t      debug_tree (t1);\n+\t      debug_tree (t2);\n+\t    }\n+\t  else if (!result && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n+\t    {\n+\t      /* Two types are structurally different, but the canonical\n+\t\t types are the same. This means we were over-eager in\n+\t\t assigning canonical types. */\n+\t      warning (0, \n+\t\t       \"same canonical type node for different types %T and %T\",\n+\t\t       t1, t2);\n+\t      debug_tree (t1);\n+\t      debug_tree (t2);\n+\t    }\n+\t  \n+\t  return result;\n+\t}\n+      else\n+\treturn TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n+    }\n+  else if (strict == COMPARE_STRUCTURAL)\n+    return structural_comptypes (t1, t2, COMPARE_STRICT);\n+  else\n+    return structural_comptypes (t1, t2, strict);\n+}\n+\n /* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */\n \n bool"}, {"sha": "aa7b7e79b8dcd4683af8e57451f834c38d2e416f", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -305,6 +305,9 @@ The elements are indexed from zero.\n @findex TYPENAME_TYPE_FULLNAME\n @findex TYPE_FIELDS\n @findex TYPE_PTROBV_P\n+@findex TYPE_CANONICAL\n+@findex TYPE_STRUCTURAL_EQUALITY_P\n+@findex SET_TYPE_STRUCTURAL_EQUALITY\n \n All types have corresponding tree nodes.  However, you should not assume\n that there is exactly one tree node corresponding to each type.  There\n@@ -406,6 +409,52 @@ does not hold for the generic pointer to object type @code{void *}.  You\n may use @code{TYPE_PTROBV_P} to test for a pointer to object type as\n well as @code{void *}.\n \n+@item TYPE_CANONICAL\n+This macro returns the ``canonical'' type for the given type\n+node. Canonical types are used to improve performance in the C++ and\n+Objective-C++ front ends by allowing efficient comparison between two\n+type nodes in @code{same_type_p}: if the @code{TYPE_CANONICAL} values\n+of the types are equal, the types are equivalent; otherwise, the types\n+are not equivalent. The notion of equivalence for canonical types is\n+the same as the notion of type equivalence in the language itself. For\n+instance,\n+\n+When @code{TYPE_CANONICAL} is @code{NULL_TREE}, there is no canonical\n+type for the given type node. In this case, comparison between this\n+type and any other type requires the compiler to perform a deep,\n+``structural'' comparison to see if the two type nodes have the same\n+form and properties.\n+\n+The canonical type for a node is always the most fundamental type in\n+the equivalence class of types. For instance, @code{int} is its own\n+canonical type. A typedef @code{I} of @code{int} will have @code{int}\n+as its canonical type. Similarly, @code{I*}@ and a typedef @code{IP}@\n+(defined to @code{I*}) will has @code{int*} as their canonical\n+type. When building a new type node, be sure to set\n+@code{TYPE_CANONICAL} to the appropriate canonical type. If the new\n+type is a compound type (built from other types), and any of those\n+other types require structural equality, use\n+@code{SET_TYPE_STRUCTURAL_EQUALITY} to ensure that the new type also\n+requires structural equality. Finally, if for some reason you cannot\n+guarantee that @code{TYPE_CANONICAL} will point to the canonical type,\n+use @code{SET_TYPE_STRUCTURAL_EQUALITY} to make sure that the new\n+type--and any type constructed based on it--requires structural\n+equality. If you suspect that the canonical type system is\n+miscomparing types, pass @code{--param verify-canonical-types=1} to\n+the compiler or configure with @code{--enable-checking} to force the\n+compiler to verify its canonical-type comparisons against the\n+structural comparisons; the compiler will then print any warnings if\n+the canonical types miscompare.\n+\n+@item TYPE_STRUCTURAL_EQUALITY_P\n+This predicate holds when the node requires structural equality\n+checks, e.g., when @code{TYPE_CANONICAL} is @code{NULL_TREE}.\n+\n+@item SET_TYPE_STRUCTURAL_EQUALITY\n+This macro states that the type node it is given requires structural\n+equality checks, e.g., it sets @code{TYPE_CANONICAL} to\n+@code{NULL_TREE}.\n+\n @item same_type_p\n This predicate takes two types as input, and holds if they are the same\n type.  For example, if one type is a @code{typedef} for the other, or"}, {"sha": "ff463c781ff52e38e139de2210d43644d63537cc", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -6383,6 +6383,13 @@ The size of cache line in L1 cache, in bytes.\n @item l1-cache-size\n The number of cache lines in L1 cache.\n \n+@item verify-canonical-types\n+Whether the compiler should verify the ``canonical'' types used for\n+type equality comparisons within the C++ and Objective-C++ front\n+ends. Set to 1 (the default when GCC is configured with\n+--enable-checking) to enable verification, 0 to disable verification\n+(the default when GCC is configured with --disable-checking).\n+\n @end table\n @end table\n "}, {"sha": "0759c8db9e0f9f78289f6dbb7a1091bdc05ca81c", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -1,3 +1,9 @@\n+2007-01-02  Douglas Gregor  <doug.gregor@gmail.com>\n+\t\n+\t* objc-act.c (objc_build_volatilized_type): Keep track of\n+\tcanonical types.\n+\t(objc_get_protocol_qualified_type): Ditto.\n+\t\n 2006-11-02  Andreas Tobler  <a.tobler@schweiz.org>\n \n \t* objc-act.c (objc_finish_file): Remove ifdef clause for OBJCPLUS and"}, {"sha": "bd79796df7e3620b6a79cc58247c271cd886a0dd", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -908,6 +908,14 @@ objc_build_volatilized_type (tree type)\n   t = build_variant_type_copy (type);\n   TYPE_VOLATILE (t) = 1;\n \n+  /* Set up the canonical type information. */\n+  if (TYPE_STRUCTURAL_EQUALITY_P (type))\n+    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+  else if (TYPE_CANONICAL (type) != type)\n+    TYPE_CANONICAL (t) = objc_build_volatilized_type (TYPE_CANONICAL (type));\n+  else\n+    TYPE_CANONICAL (t) = t;\n+\n   return t;\n }\n \n@@ -1370,7 +1378,13 @@ objc_get_protocol_qualified_type (tree interface, tree protocols)\n \t to the pointee.  */\n       if (is_ptr)\n \t{\n-\t  TREE_TYPE (type) = build_variant_type_copy (TREE_TYPE (type));\n+\t  tree orig_pointee_type = TREE_TYPE (type);\n+\t  TREE_TYPE (type) = build_variant_type_copy (orig_pointee_type);\n+\n+\t  /* Set up the canonical type information. */\n+\t  TYPE_CANONICAL (type) \n+\t    = TYPE_CANONICAL (TYPE_POINTER_TO (orig_pointee_type));\n+\n \t  TYPE_POINTER_TO (TREE_TYPE (type)) = type;\n \t  type = TREE_TYPE (type);\n \t}"}, {"sha": "41a4e417ccf90e22994227d466264b1cd0a2962d", "filename": "gcc/params.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -626,6 +626,19 @@ DEFPARAM (PARAM_L1_CACHE_LINE_SIZE,\n \t  \"The size of L1 cache line\",\n \t  32, 0, 0)\n \n+#ifdef ENABLE_CHECKING\n+# define GCC_CANONICAL_TYPES_DEFAULT 1\n+#else\n+# define GCC_CANONICAL_TYPES_DEFAULT 0\n+#endif\n+\n+/* Whether we should verify that the canonical types in the system are\n+   consistent with the \"structural\" typing. */\n+\n+DEFPARAM (PARAM_VERIFY_CANONICAL_TYPES,\n+\t  \"verify-canonical-types\",\n+\t  \"Whether to verify canonical types\",\n+\t  GCC_CANONICAL_TYPES_DEFAULT, 0, 1)\n /*\n Local variables:\n mode:c"}, {"sha": "79a656c31e9956911529d53367841ebb0a475b05", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -164,4 +164,6 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_L1_CACHE_SIZE)\n #define L1_CACHE_LINE_SIZE \\\n   PARAM_VALUE (PARAM_L1_CACHE_LINE_SIZE)\n+#define VERIFY_CANONICAL_TYPES \\\n+  PARAM_VALUE (PARAM_VERIFY_CANONICAL_TYPES)\n #endif /* ! GCC_PARAMS_H */"}, {"sha": "a73247d2de14d731c0031a9adb6ad7c2a350b525", "filename": "gcc/print-tree.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -604,6 +604,11 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t       TYPE_ALIGN (node), TYPE_SYMTAB_ADDRESS (node),\n \t       TYPE_ALIAS_SET (node));\n \n+      if (TYPE_STRUCTURAL_EQUALITY_P (node))\n+\tfprintf (file, \" structural equality\");\n+      else\n+\tdump_addr (file, \" canonical type \", TYPE_CANONICAL (node));\n+      \n       print_node (file, \"attributes\", TYPE_ATTRIBUTES (node), indent + 4);\n \n       if (INTEGRAL_TYPE_P (node) || TREE_CODE (node) == REAL_TYPE)"}, {"sha": "61879a060a31ff8bb6d98cdcf5f85c4e499b0122", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -1782,6 +1782,11 @@ layout_type (tree type)\n #else\n \tTYPE_ALIGN (type) = MAX (TYPE_ALIGN (element), BITS_PER_UNIT);\n #endif\n+\tif (!TYPE_SIZE (element))\n+\t  /* We don't know the size of the underlying element type, so\n+\t     our alignment calculations will be wrong, forcing us to\n+\t     fall back on structural equality. */\n+\t  SET_TYPE_STRUCTURAL_EQUALITY (type);\n \tTYPE_USER_ALIGN (type) = TYPE_USER_ALIGN (element);\n \tTYPE_MODE (type) = BLKmode;\n \tif (TYPE_SIZE (type) != 0"}, {"sha": "5abd6f345f3ca28c85545dfb91352866797090ad", "filename": "gcc/tree.c", "status": "modified", "additions": 124, "deletions": 5, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -605,6 +605,7 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n       TYPE_ALIGN (t) = BITS_PER_UNIT;\n       TYPE_USER_ALIGN (t) = 0;\n       TYPE_MAIN_VARIANT (t) = t;\n+      TYPE_CANONICAL (t) = t;\n \n       /* Default to no attributes for type, but let target change that.  */\n       TYPE_ATTRIBUTES (t) = NULL_TREE;\n@@ -3620,6 +3621,12 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)\n       TYPE_REFERENCE_TO (ntype) = 0;\n       TYPE_ATTRIBUTES (ntype) = attribute;\n \n+      if (TYPE_STRUCTURAL_EQUALITY_P (ttype))\n+\tSET_TYPE_STRUCTURAL_EQUALITY (ntype);\n+      else\n+\tTYPE_CANONICAL (ntype)\n+\t  = build_qualified_type (TYPE_CANONICAL (ttype), quals);\n+\n       /* Create a new main variant of TYPE.  */\n       TYPE_MAIN_VARIANT (ntype) = ntype;\n       TYPE_NEXT_VARIANT (ntype) = 0;\n@@ -3657,6 +3664,13 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)\n \t}\n \n       ntype = type_hash_canon (hashcode, ntype);\n+\n+      /* If the target-dependent attributes make NTYPE different from\n+\t its canonical type, we will need to use structural equality\n+\t checks for this qualified type. */\n+      if (!targetm.comp_type_attributes (ntype, ttype))\n+\tSET_TYPE_STRUCTURAL_EQUALITY (ntype);\n+\n       ttype = build_qualified_type (ntype, quals);\n     }\n \n@@ -4104,13 +4118,28 @@ build_qualified_type (tree type, int type_quals)\n     {\n       t = build_variant_type_copy (type);\n       set_type_quals (t, type_quals);\n+\n+      if (TYPE_STRUCTURAL_EQUALITY_P (type))\n+\t/* Propagate structural equality. */\n+\tSET_TYPE_STRUCTURAL_EQUALITY (t);\n+      else if (TYPE_CANONICAL (type) != type)\n+\t/* Build the underlying canonical type, since it is different\n+\t   from TYPE. */\n+\tTYPE_CANONICAL (t) = build_qualified_type (TYPE_CANONICAL (type),\n+\t\t\t\t\t\t   type_quals);\n+      else\n+\t/* T is its own canonical type. */\n+\tTYPE_CANONICAL (t) = t;\n+      \n     }\n \n   return t;\n }\n \n /* Create a new distinct copy of TYPE.  The new type is made its own\n-   MAIN_VARIANT.  */\n+   MAIN_VARIANT. If TYPE requires structural equality checks, the\n+   resulting type requires structural equality checks; otherwise, its\n+   TYPE_CANONICAL points to itself. */\n \n tree\n build_distinct_type_copy (tree type)\n@@ -4120,22 +4149,36 @@ build_distinct_type_copy (tree type)\n   TYPE_POINTER_TO (t) = 0;\n   TYPE_REFERENCE_TO (t) = 0;\n \n+  /* Set the canonical type either to a new equivalence class, or\n+     propagate the need for structural equality checks. */\n+  if (TYPE_STRUCTURAL_EQUALITY_P (type))\n+    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+  else\n+    TYPE_CANONICAL (t) = t;\n+\n   /* Make it its own variant.  */\n   TYPE_MAIN_VARIANT (t) = t;\n   TYPE_NEXT_VARIANT (t) = 0;\n   \n   return t;\n }\n \n-/* Create a new variant of TYPE, equivalent but distinct.\n-   This is so the caller can modify it.  */\n+/* Create a new variant of TYPE, equivalent but distinct.  This is so\n+   the caller can modify it. TYPE_CANONICAL for the return type will\n+   be equivalent to TYPE_CANONICAL of TYPE, indicating that the types\n+   are considered equal by the language itself (or that both types\n+   require structural equality checks). */\n \n tree\n build_variant_type_copy (tree type)\n {\n   tree t, m = TYPE_MAIN_VARIANT (type);\n \n   t = build_distinct_type_copy (type);\n+\n+  /* Since we're building a variant, assume that it is a non-semantic\n+     variant. This also propagates TYPE_STRUCTURAL_EQUALITY_P. */\n+  TYPE_CANONICAL (t) = TYPE_CANONICAL (type);\n   \n   /* Add the new type to the chain of variants of TYPE.  */\n   TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (m);\n@@ -5237,6 +5280,13 @@ build_pointer_type_for_mode (tree to_type, enum machine_mode mode,\n   TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (to_type);\n   TYPE_POINTER_TO (to_type) = t;\n \n+  if (TYPE_STRUCTURAL_EQUALITY_P (to_type))\n+    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+  else if (TYPE_CANONICAL (to_type) != to_type)\n+    TYPE_CANONICAL (t)\n+      = build_pointer_type_for_mode (TYPE_CANONICAL (to_type),\n+\t\t\t\t     mode, can_alias_all);\n+\n   /* Lay out the type.  This function has many callers that are concerned\n      with expression-construction, and this simplifies them all.  */\n   layout_type (t);\n@@ -5286,6 +5336,13 @@ build_reference_type_for_mode (tree to_type, enum machine_mode mode,\n   TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (to_type);\n   TYPE_REFERENCE_TO (to_type) = t;\n \n+  if (TYPE_STRUCTURAL_EQUALITY_P (to_type))\n+    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+  else if (TYPE_CANONICAL (to_type) != to_type)\n+    TYPE_CANONICAL (t) \n+      = build_reference_type_for_mode (TYPE_CANONICAL (to_type),\n+\t\t\t\t       mode, can_alias_all);\n+\n   layout_type (t);\n \n   return t;\n@@ -5352,7 +5409,12 @@ build_index_type (tree maxval)\n   if (host_integerp (maxval, 1))\n     return type_hash_canon (tree_low_cst (maxval, 1), itype);\n   else\n-    return itype;\n+    {\n+      /* Since we cannot hash this type, we need to compare it using\n+\t structural equality checks. */\n+      SET_TYPE_STRUCTURAL_EQUALITY (itype);\n+      return itype;\n+    }\n }\n \n /* Builds a signed or unsigned integer type of precision PRECISION.\n@@ -5444,6 +5506,16 @@ build_array_type (tree elt_type, tree index_type)\n       t = type_hash_canon (hashcode, t);\n       if (save == t)\n \tlayout_type (t);\n+\n+      if (TYPE_CANONICAL (t) == t)\n+\t{\n+\t  if (TYPE_STRUCTURAL_EQUALITY_P (elt_type))\n+\t    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+\t  else if (TYPE_CANONICAL (elt_type) != elt_type)\n+\t    TYPE_CANONICAL (t) \n+\t      = build_array_type (TYPE_CANONICAL (elt_type), index_type);\n+\t}\n+\n       return t;\n     }\n \n@@ -5453,6 +5525,19 @@ build_array_type (tree elt_type, tree index_type)\n \n   if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n+\n+  if (TYPE_CANONICAL (t) == t)\n+    {\n+      if (TYPE_STRUCTURAL_EQUALITY_P (elt_type)\n+\t  || TYPE_STRUCTURAL_EQUALITY_P (index_type))\n+\tSET_TYPE_STRUCTURAL_EQUALITY (t);\n+      else if (TYPE_CANONICAL (elt_type) != elt_type\n+\t       || TYPE_CANONICAL (index_type) != index_type)\n+\tTYPE_CANONICAL (t) \n+\t  = build_array_type (TYPE_CANONICAL (elt_type),\n+\t\t\t      TYPE_CANONICAL (index_type));\n+    }\n+\n   return t;\n }\n \n@@ -5494,6 +5579,9 @@ build_function_type (tree value_type, tree arg_types)\n   TREE_TYPE (t) = value_type;\n   TYPE_ARG_TYPES (t) = arg_types;\n \n+  /* We don't have canonicalization of function types, yet. */\n+  SET_TYPE_STRUCTURAL_EQUALITY (t);\n+\n   /* If we already have such a type, use the old one.  */\n   hashcode = iterative_hash_object (TYPE_HASH (value_type), hashcode);\n   hashcode = type_hash_list (arg_types, hashcode);\n@@ -5561,6 +5649,9 @@ build_method_type_directly (tree basetype,\n   argtypes = tree_cons (NULL_TREE, ptype, argtypes);\n   TYPE_ARG_TYPES (t) = argtypes;\n \n+  /* We don't have canonicalization of method types yet. */\n+  SET_TYPE_STRUCTURAL_EQUALITY (t);\n+\n   /* If we already have such a type, use the old one.  */\n   hashcode = iterative_hash_object (TYPE_HASH (basetype), hashcode);\n   hashcode = iterative_hash_object (TYPE_HASH (rettype), hashcode);\n@@ -5612,6 +5703,18 @@ build_offset_type (tree basetype, tree type)\n   if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n \n+  if (TYPE_CANONICAL (t) == t)\n+    {\n+      if (TYPE_STRUCTURAL_EQUALITY_P (basetype)\n+\t  || TYPE_STRUCTURAL_EQUALITY_P (type))\n+\tSET_TYPE_STRUCTURAL_EQUALITY (t);\n+      else if (TYPE_CANONICAL (basetype) != basetype\n+\t       || TYPE_CANONICAL (type) != type)\n+\tTYPE_CANONICAL (t) \n+\t  = build_offset_type (TYPE_CANONICAL (basetype), \n+\t\t\t       TYPE_CANONICAL (type));\n+    }\n+\n   return t;\n }\n \n@@ -5635,6 +5738,15 @@ build_complex_type (tree component_type)\n   if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n \n+  if (TYPE_CANONICAL (t) == t)\n+    {\n+      if (TYPE_STRUCTURAL_EQUALITY_P (component_type))\n+\tSET_TYPE_STRUCTURAL_EQUALITY (t);\n+      else if (TYPE_CANONICAL (component_type) != component_type)\n+\tTYPE_CANONICAL (t) \n+\t  = build_complex_type (TYPE_CANONICAL (component_type));\n+    }\n+\n   /* If we are writing Dwarf2 output we need to create a name,\n      since complex is a fundamental type.  */\n   if ((write_symbols == DWARF2_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)\n@@ -6653,6 +6765,13 @@ make_vector_type (tree innertype, int nunits, enum machine_mode mode)\n   TYPE_READONLY (t) = TYPE_READONLY (innertype);\n   TYPE_VOLATILE (t) = TYPE_VOLATILE (innertype);\n \n+  if (TYPE_STRUCTURAL_EQUALITY_P (innertype))\n+    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+  else if (TYPE_CANONICAL (innertype) != innertype\n+\t   || mode != VOIDmode)\n+    TYPE_CANONICAL (t) \n+      = make_vector_type (TYPE_CANONICAL (innertype), nunits, VOIDmode);\n+\n   layout_type (t);\n \n   {\n@@ -6866,7 +6985,7 @@ build_common_tree_nodes_2 (int short_double)\n        declare the type to be __builtin_va_list.  */\n     if (TREE_CODE (t) != RECORD_TYPE)\n       t = build_variant_type_copy (t);\n-\n+    \n     va_list_type_node = t;\n   }\n }"}, {"sha": "3a226287107967d07f5206894019d77e3e8f701f", "filename": "gcc/tree.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=06d40de8bb03594e0f0eb7d0636f8ca84ce7d86d", "patch": "@@ -2005,6 +2005,27 @@ struct tree_block GTY(())\n #define TYPE_NEXT_VARIANT(NODE) (TYPE_CHECK (NODE)->type.next_variant)\n #define TYPE_MAIN_VARIANT(NODE) (TYPE_CHECK (NODE)->type.main_variant)\n #define TYPE_CONTEXT(NODE) (TYPE_CHECK (NODE)->type.context)\n+\n+/* The \"canonical\" type for this type node, which can be used to\n+   compare the type for equality with another type. If two types are\n+   equal (based on the semantics of the language), then they will have\n+   equivalent TYPE_CANONICAL entries. \n+\n+   As a special case, if TYPE_CANONICAL is NULL_TREE, then it cannot\n+   be used for comparison against other types. Instead, the type is\n+   said to require structural equality checks, described in\n+   TYPE_STRUCTURAL_EQUALITY_P. */\n+#define TYPE_CANONICAL(NODE) (TYPE_CHECK (NODE)->type.canonical)\n+/* Indicates that the type node requires structural equality\n+   checks. The compiler will need to look at the composition of the\n+   type to determine whether it is equal to another type, rather than\n+   just comparing canonical type pointers. For instance, we would need\n+   to look at the return and parameter types of a FUNCTION_TYPE\n+   node. */\n+#define TYPE_STRUCTURAL_EQUALITY_P(NODE) (TYPE_CANONICAL (NODE) == NULL_TREE)\n+/* Sets the TYPE_CANONICAL field to NULL_TREE, indicating that the\n+   type node requires structural equality. */\n+#define SET_TYPE_STRUCTURAL_EQUALITY(NODE) (TYPE_CANONICAL (NODE) = NULL_TREE)\n #define TYPE_LANG_SPECIFIC(NODE) (TYPE_CHECK (NODE)->type.lang_specific)\n \n /* For a VECTOR_TYPE node, this describes a different type which is emitted\n@@ -2205,6 +2226,7 @@ struct tree_type GTY(())\n   tree main_variant;\n   tree binfo;\n   tree context;\n+  tree canonical;\n   HOST_WIDE_INT alias_set;\n   /* Points to a structure whose details depend on the language in use.  */\n   struct lang_type *lang_specific;"}]}