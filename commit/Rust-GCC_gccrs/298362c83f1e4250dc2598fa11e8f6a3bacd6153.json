{"sha": "298362c83f1e4250dc2598fa11e8f6a3bacd6153", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk4MzYyYzgzZjFlNDI1MGRjMjU5OGZhMTFlOGY2YTNiYWNkNjE1Mw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2011-02-08T09:55:07Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2011-02-08T09:55:07Z"}, "message": "mn10300.opt (mliw): New command line option.\n\n\t* config/mn10300/mn10300.opt (mliw): New command line option.\n\t* config/mn10300/mn10300.md (UNSPEC_LIW): New unspec.\n\t(liw_bundling): New automaton.\n\t(liw): New attribute.\n\t(liw_op): New attribute.\n\t(liw_op1, liw_op2, liw_both, liw_either): New reservations.\n\t(movsi_internal): Add LIW attributes.\n\t(andsi3): Likewise.\n\t(iorsi3): Likewise.\n\t(xorsi3): Likewise.\n\t(addsi3): Separate register and immediate alternatives.\n\tAdd LIW attributes.\n\t(subsi3): Likewise.\n\t(cmpsi): Likewise.\n\t(aslsi3): Likewise.\n\t(lshrsi3): Likewise.\n\t(ashrsi3): Likewise.\n\t(liw): New pattern.\n\t* config/mn10300/mn10300.c (liw_op_names): New\n\t(mn10300_print_operand): Handle 'W' operand descriptor.\n\t(extract_bundle): New function.\n\t(check_liw_constraints): New function.\n\t(liw_candidate): New function.\n\t(mn10300_bundle_liw): New function.\n\t(mn10300_reorg): New function.\n\t(TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(TARGET_DEFAULT_TARGET_FLAGS): Add MASK_ALLOW_LIW.\n\t* config/mn10300/mn10300.h (TARGET_CPU_CPP_BUILTINS): Define\n\t__LIW__ or __NO_LIW__.\n\t* doc/invoke.texi: Describe the -mliw command line option.\n\nFrom-SVN: r169916", "tree": {"sha": "1c0fb74b651b2e76acaebbf1cdc8a355f3ea96c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c0fb74b651b2e76acaebbf1cdc8a355f3ea96c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/298362c83f1e4250dc2598fa11e8f6a3bacd6153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298362c83f1e4250dc2598fa11e8f6a3bacd6153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/298362c83f1e4250dc2598fa11e8f6a3bacd6153", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298362c83f1e4250dc2598fa11e8f6a3bacd6153/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30c4a23d026c9f3fb6d2f688b294d41c07ecbc51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c4a23d026c9f3fb6d2f688b294d41c07ecbc51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30c4a23d026c9f3fb6d2f688b294d41c07ecbc51"}], "stats": {"total": 937, "additions": 648, "deletions": 289}, "files": [{"sha": "3fd6d0225bd55591fe7cbb91ab92d70b72e9cda2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=298362c83f1e4250dc2598fa11e8f6a3bacd6153", "patch": "@@ -1,3 +1,36 @@\n+2011-02-08  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/mn10300/mn10300.opt (mliw): New command line option.\n+\t* config/mn10300/mn10300.md (UNSPEC_LIW): New unspec.\n+\t(liw_bundling): New automaton.\n+\t(liw): New attribute.\n+\t(liw_op): New attribute.\n+\t(liw_op1, liw_op2, liw_both, liw_either): New reservations.\n+\t(movsi_internal): Add LIW attributes.\n+\t(andsi3): Likewise.\n+\t(iorsi3): Likewise.\n+\t(xorsi3): Likewise.\n+\t(addsi3): Separate register and immediate alternatives.\n+\tAdd LIW attributes.\n+\t(subsi3): Likewise.\n+\t(cmpsi): Likewise.\n+\t(aslsi3): Likewise.\n+\t(lshrsi3): Likewise.\n+\t(ashrsi3): Likewise.\n+\t(liw): New pattern.\n+\t* config/mn10300/mn10300.c (liw_op_names): New\n+\t(mn10300_print_operand): Handle 'W' operand descriptor.\n+\t(extract_bundle): New function.\n+\t(check_liw_constraints): New function.\n+\t(liw_candidate): New function.\n+\t(mn10300_bundle_liw): New function.\n+\t(mn10300_reorg): New function.\n+\t(TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(TARGET_DEFAULT_TARGET_FLAGS): Add MASK_ALLOW_LIW.\n+\t* config/mn10300/mn10300.h (TARGET_CPU_CPP_BUILTINS): Define\n+\t__LIW__ or __NO_LIW__.\n+\t* doc/invoke.texi: Describe the -mliw command line option.\n+\n 2011-02-07  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* config.gcc (hppa[12]*-*-hpux11*): Don't set extra_parts."}, {"sha": "5ff8852c5f7314fdd002823855802fddf0394b75", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 447, "deletions": 258, "changes": 705, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=298362c83f1e4250dc2598fa11e8f6a3bacd6153", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for Matsushita MN10300 series\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n    This file is part of GCC.\n@@ -165,6 +165,16 @@ mn10300_file_start (void)\n     fprintf (asm_out_file, \"\\t.am33\\n\");\n }\n \f\n+/* Note: This list must match the liw_op attribute in mn10300.md.  */\n+\n+static const char *liw_op_names[] =\n+{\n+  \"add\", \"cmp\", \"sub\", \"mov\",\n+  \"and\", \"or\", \"xor\",\n+  \"asr\", \"lsr\", \"asl\",\n+  \"none\", \"max\"\n+};\n+\n /* Print operand X using operand code CODE to assembly language output file\n    FILE.  */\n \n@@ -173,309 +183,319 @@ mn10300_print_operand (FILE *file, rtx x, int code)\n {\n   switch (code)\n     {\n-      case 'b':\n-      case 'B':\n-\t{\n-\t  enum rtx_code cmp = GET_CODE (x);\n-\t  enum machine_mode mode = GET_MODE (XEXP (x, 0));\n-\t  const char *str;\n-\t  int have_flags;\n-\n-\t  if (code == 'B')\n-\t    cmp = reverse_condition (cmp);\n-\t  have_flags = cc_flags_for_mode (mode);\n-\n-\t  switch (cmp)\n-\t    {\n-\t    case NE:\n-\t      str = \"ne\";\n-\t      break;\n-\t    case EQ:\n-\t      str = \"eq\";\n-\t      break;\n-\t    case GE:\n-\t      /* bge is smaller than bnc.  */\n-\t      str = (have_flags & CC_FLAG_V ? \"ge\" : \"nc\");\n-\t      break;\n-\t    case LT:\n-\t      str = (have_flags & CC_FLAG_V ? \"lt\" : \"ns\");\n-\t      break;\n-\t    case GT:\n-\t      str = \"gt\";\n-\t      break;\n-\t    case LE:\n-\t      str = \"le\";\n-\t      break;\n-\t    case GEU:\n-\t      str = \"cc\";\n-\t      break;\n-\t    case GTU:\n-\t      str = \"hi\";\n-\t      break;\n-\t    case LEU:\n-\t      str = \"ls\";\n-\t      break;\n-\t    case LTU:\n-\t      str = \"cs\";\n-\t      break;\n-\t    case ORDERED:\n-\t      str = \"lge\";\n-\t      break;\n-\t    case UNORDERED:\n-\t      str = \"uo\";\n-\t      break;\n-\t    case LTGT:\n-\t      str = \"lg\";\n-\t      break;\n-\t    case UNEQ:\n-\t      str = \"ue\";\n-\t      break;\n-\t    case UNGE:\n-\t      str = \"uge\";\n-\t      break;\n-\t    case UNGT:\n-\t      str = \"ug\";\n-\t      break;\n-\t    case UNLE:\n-\t      str = \"ule\";\n-\t      break;\n-\t    case UNLT:\n-\t      str = \"ul\";\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n+    case 'W':\n+      {\n+\tunsigned int liw_op = UINTVAL (x);\n \n-\t  gcc_checking_assert ((cc_flags_for_code (cmp) & ~have_flags) == 0);\n-\t  fputs (str, file);\n-\t}\n+\tgcc_assert (TARGET_ALLOW_LIW);\n+\tgcc_assert (liw_op < LIW_OP_MAX);\n+\tfputs (liw_op_names[liw_op], file);\n \tbreak;\n+      }\n \n-      case 'C':\n-\t/* This is used for the operand to a call instruction;\n-\t   if it's a REG, enclose it in parens, else output\n-\t   the operand normally.  */\n-\tif (REG_P (x))\n-\t  {\n-\t    fputc ('(', file);\n-\t    mn10300_print_operand (file, x, 0);\n-\t    fputc (')', file);\n-\t  }\n-\telse\n-\t  mn10300_print_operand (file, x, 0);\n-\tbreak;\n+    case 'b':\n+    case 'B':\n+      {\n+\tenum rtx_code cmp = GET_CODE (x);\n+\tenum machine_mode mode = GET_MODE (XEXP (x, 0));\n+\tconst char *str;\n+\tint have_flags;\n+\n+\tif (code == 'B')\n+\t  cmp = reverse_condition (cmp);\n+\thave_flags = cc_flags_for_mode (mode);\n \n-      case 'D':\n-\tswitch (GET_CODE (x))\n+\tswitch (cmp)\n \t  {\n-\t  case MEM:\n-\t    fputc ('(', file);\n-\t    output_address (XEXP (x, 0));\n-\t    fputc (')', file);\n+\t  case NE:\n+\t    str = \"ne\";\n \t    break;\n-\n-\t  case REG:\n-\t    fprintf (file, \"fd%d\", REGNO (x) - 18);\n+\t  case EQ:\n+\t    str = \"eq\";\n+\t    break;\n+\t  case GE:\n+\t    /* bge is smaller than bnc.  */\n+\t    str = (have_flags & CC_FLAG_V ? \"ge\" : \"nc\");\n+\t    break;\n+\t  case LT:\n+\t    str = (have_flags & CC_FLAG_V ? \"lt\" : \"ns\");\n+\t    break;\n+\t  case GT:\n+\t    str = \"gt\";\n+\t    break;\n+\t  case LE:\n+\t    str = \"le\";\n+\t    break;\n+\t  case GEU:\n+\t    str = \"cc\";\n+\t    break;\n+\t  case GTU:\n+\t    str = \"hi\";\n+\t    break;\n+\t  case LEU:\n+\t    str = \"ls\";\n+\t    break;\n+\t  case LTU:\n+\t    str = \"cs\";\n+\t    break;\n+\t  case ORDERED:\n+\t    str = \"lge\";\n+\t    break;\n+\t  case UNORDERED:\n+\t    str = \"uo\";\n+\t    break;\n+\t  case LTGT:\n+\t    str = \"lg\";\n+\t    break;\n+\t  case UNEQ:\n+\t    str = \"ue\";\n+\t    break;\n+\t  case UNGE:\n+\t    str = \"uge\";\n+\t    break;\n+\t  case UNGT:\n+\t    str = \"ug\";\n+\t    break;\n+\t  case UNLE:\n+\t    str = \"ule\";\n+\t    break;\n+\t  case UNLT:\n+\t    str = \"ul\";\n \t    break;\n-\n \t  default:\n \t    gcc_unreachable ();\n \t  }\n-\tbreak;\n+\n+\tgcc_checking_assert ((cc_flags_for_code (cmp) & ~have_flags) == 0);\n+\tfputs (str, file);\n+      }\n+      break;\n+\n+    case 'C':\n+      /* This is used for the operand to a call instruction;\n+\t if it's a REG, enclose it in parens, else output\n+\t the operand normally.  */\n+      if (REG_P (x))\n+\t{\n+\t  fputc ('(', file);\n+\t  mn10300_print_operand (file, x, 0);\n+\t  fputc (')', file);\n+\t}\n+      else\n+\tmn10300_print_operand (file, x, 0);\n+      break;\n+\n+    case 'D':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase MEM:\n+\t  fputc ('(', file);\n+\t  output_address (XEXP (x, 0));\n+\t  fputc (')', file);\n+\t  break;\n+\n+\tcase REG:\n+\t  fprintf (file, \"fd%d\", REGNO (x) - 18);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n \n       /* These are the least significant word in a 64bit value.  */\n-      case 'L':\n-\tswitch (GET_CODE (x))\n-\t  {\n-\t  case MEM:\n-\t    fputc ('(', file);\n-\t    output_address (XEXP (x, 0));\n-\t    fputc (')', file);\n-\t    break;\n+    case 'L':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase MEM:\n+\t  fputc ('(', file);\n+\t  output_address (XEXP (x, 0));\n+\t  fputc (')', file);\n+\t  break;\n \n-\t  case REG:\n-\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n-\t    break;\n+\tcase REG:\n+\t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t  break;\n \n-\t  case SUBREG:\n-\t    fprintf (file, \"%s\", reg_names[subreg_regno (x)]);\n-\t    break;\n+\tcase SUBREG:\n+\t  fprintf (file, \"%s\", reg_names[subreg_regno (x)]);\n+\t  break;\n \n-\t  case CONST_DOUBLE:\n-\t      {\n-\t\tlong val[2];\n-\t\tREAL_VALUE_TYPE rv;\n+\tcase CONST_DOUBLE:\n+\t  {\n+\t    long val[2];\n+\t    REAL_VALUE_TYPE rv;\n \n-\t\tswitch (GET_MODE (x))\n-\t\t  {\n-\t\t    case DFmode:\n-\t\t      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n-\t\t      REAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n-\t\t      fprintf (file, \"0x%lx\", val[0]);\n-\t\t      break;;\n-\t\t    case SFmode:\n-\t\t      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n-\t\t      REAL_VALUE_TO_TARGET_SINGLE (rv, val[0]);\n-\t\t      fprintf (file, \"0x%lx\", val[0]);\n-\t\t      break;;\n-\t\t    case VOIDmode:\n-\t\t    case DImode:\n-\t\t      mn10300_print_operand_address (file,\n-\t\t\t\t\t\t     GEN_INT (CONST_DOUBLE_LOW (x)));\n-\t\t      break;\n-\t\t    default:\n-\t\t      break;\n-\t\t  }\n+\t    switch (GET_MODE (x))\n+\t      {\n+\t      case DFmode:\n+\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t\tREAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n+\t\tfprintf (file, \"0x%lx\", val[0]);\n+\t\tbreak;;\n+\t      case SFmode:\n+\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t\tREAL_VALUE_TO_TARGET_SINGLE (rv, val[0]);\n+\t\tfprintf (file, \"0x%lx\", val[0]);\n+\t\tbreak;;\n+\t      case VOIDmode:\n+\t      case DImode:\n+\t\tmn10300_print_operand_address (file,\n+\t\t\t\t\t       GEN_INT (CONST_DOUBLE_LOW (x)));\n+\t\tbreak;\n+\t      default:\n \t\tbreak;\n \t      }\n+\t    break;\n+\t  }\n \n-\t  case CONST_INT:\n-\t    {\n-\t      rtx low, high;\n-\t      split_double (x, &low, &high);\n-\t      fprintf (file, \"%ld\", (long)INTVAL (low));\n-\t      break;\n+\tcase CONST_INT:\n+\t  {\n+\t    rtx low, high;\n+\t    split_double (x, &low, &high);\n+\t    fprintf (file, \"%ld\", (long)INTVAL (low));\n+\t    break;\n \t    }\n \n-\t  default:\n-\t    gcc_unreachable ();\n-\t  }\n-\tbreak;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n \n       /* Similarly, but for the most significant word.  */\n-      case 'H':\n-\tswitch (GET_CODE (x))\n-\t  {\n-\t  case MEM:\n-\t    fputc ('(', file);\n-\t    x = adjust_address (x, SImode, 4);\n-\t    output_address (XEXP (x, 0));\n-\t    fputc (')', file);\n-\t    break;\n+    case 'H':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase MEM:\n+\t  fputc ('(', file);\n+\t  x = adjust_address (x, SImode, 4);\n+\t  output_address (XEXP (x, 0));\n+\t  fputc (')', file);\n+\t  break;\n \n-\t  case REG:\n-\t    fprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n-\t    break;\n+\tcase REG:\n+\t  fprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n+\t  break;\n \n-\t  case SUBREG:\n-\t    fprintf (file, \"%s\", reg_names[subreg_regno (x) + 1]);\n-\t    break;\n+\tcase SUBREG:\n+\t  fprintf (file, \"%s\", reg_names[subreg_regno (x) + 1]);\n+\t  break;\n \n-\t  case CONST_DOUBLE:\n-\t      {\n-\t\tlong val[2];\n-\t\tREAL_VALUE_TYPE rv;\n+\tcase CONST_DOUBLE:\n+\t  {\n+\t    long val[2];\n+\t    REAL_VALUE_TYPE rv;\n \n-\t\tswitch (GET_MODE (x))\n-\t\t  {\n-\t\t    case DFmode:\n-\t\t      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n-\t\t      REAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n-\t\t      fprintf (file, \"0x%lx\", val[1]);\n-\t\t      break;;\n-\t\t    case SFmode:\n-\t\t      gcc_unreachable ();\n-\t\t    case VOIDmode:\n-\t\t    case DImode:\n-\t\t      mn10300_print_operand_address (file,\n-\t\t\t\t\t\t     GEN_INT (CONST_DOUBLE_HIGH (x)));\n-\t\t      break;\n-\t\t    default:\n-\t\t      break;\n-\t\t  }\n+\t    switch (GET_MODE (x))\n+\t      {\n+\t      case DFmode:\n+\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t\tREAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n+\t\tfprintf (file, \"0x%lx\", val[1]);\n+\t\tbreak;;\n+\t      case SFmode:\n+\t\tgcc_unreachable ();\n+\t      case VOIDmode:\n+\t      case DImode:\n+\t\tmn10300_print_operand_address (file,\n+\t\t\t\t\t       GEN_INT (CONST_DOUBLE_HIGH (x)));\n+\t\tbreak;\n+\t      default:\n \t\tbreak;\n \t      }\n+\t    break;\n+\t  }\n \n-\t  case CONST_INT:\n-\t    {\n-\t      rtx low, high;\n-\t      split_double (x, &low, &high);\n-\t      fprintf (file, \"%ld\", (long)INTVAL (high));\n-\t      break;\n-\t    }\n-\n-\t  default:\n-\t    gcc_unreachable ();\n+\tcase CONST_INT:\n+\t  {\n+\t    rtx low, high;\n+\t    split_double (x, &low, &high);\n+\t    fprintf (file, \"%ld\", (long)INTVAL (high));\n+\t    break;\n \t  }\n-\tbreak;\n \n-      case 'A':\n-\tfputc ('(', file);\n-\tif (REG_P (XEXP (x, 0)))\n-\t  output_address (gen_rtx_PLUS (SImode, XEXP (x, 0), const0_rtx));\n-\telse\n-\t  output_address (XEXP (x, 0));\n-\tfputc (')', file);\n-\tbreak;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n \n-      case 'N':\n-\tgcc_assert (INTVAL (x) >= -128 && INTVAL (x) <= 255);\n-\tfprintf (file, \"%d\", (int)((~INTVAL (x)) & 0xff));\n-\tbreak;\n+    case 'A':\n+      fputc ('(', file);\n+      if (REG_P (XEXP (x, 0)))\n+\toutput_address (gen_rtx_PLUS (SImode, XEXP (x, 0), const0_rtx));\n+      else\n+\toutput_address (XEXP (x, 0));\n+      fputc (')', file);\n+      break;\n \n-      case 'U':\n-\tgcc_assert (INTVAL (x) >= -128 && INTVAL (x) <= 255);\n-\tfprintf (file, \"%d\", (int)(INTVAL (x) & 0xff));\n-\tbreak;\n+    case 'N':\n+      gcc_assert (INTVAL (x) >= -128 && INTVAL (x) <= 255);\n+      fprintf (file, \"%d\", (int)((~INTVAL (x)) & 0xff));\n+      break;\n+\n+    case 'U':\n+      gcc_assert (INTVAL (x) >= -128 && INTVAL (x) <= 255);\n+      fprintf (file, \"%d\", (int)(INTVAL (x) & 0xff));\n+      break;\n \n       /* For shift counts.  The hardware ignores the upper bits of\n \t any immediate, but the assembler will flag an out of range\n \t shift count as an error.  So we mask off the high bits\n \t of the immediate here.  */\n-      case 'S':\n-\tif (CONST_INT_P (x))\n-\t  {\n-\t    fprintf (file, \"%d\", (int)(INTVAL (x) & 0x1f));\n-\t    break;\n-\t  }\n-\t/* FALL THROUGH */\n+    case 'S':\n+      if (CONST_INT_P (x))\n+\t{\n+\t  fprintf (file, \"%d\", (int)(INTVAL (x) & 0x1f));\n+\t  break;\n+\t}\n+      /* FALL THROUGH */\n \n-      default:\n-\tswitch (GET_CODE (x))\n-\t  {\n-\t  case MEM:\n-\t    fputc ('(', file);\n-\t    output_address (XEXP (x, 0));\n-\t    fputc (')', file);\n-\t    break;\n+    default:\n+      switch (GET_CODE (x))\n+\t{\n+\tcase MEM:\n+\t  fputc ('(', file);\n+\t  output_address (XEXP (x, 0));\n+\t  fputc (')', file);\n+\t  break;\n \n-\t  case PLUS:\n-\t    output_address (x);\n-\t    break;\n+\tcase PLUS:\n+\t  output_address (x);\n+\t  break;\n \n-\t  case REG:\n-\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n-\t    break;\n+\tcase REG:\n+\t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t  break;\n \n-\t  case SUBREG:\n-\t    fprintf (file, \"%s\", reg_names[subreg_regno (x)]);\n-\t    break;\n+\tcase SUBREG:\n+\t  fprintf (file, \"%s\", reg_names[subreg_regno (x)]);\n+\t  break;\n \n \t  /* This will only be single precision....  */\n-\t  case CONST_DOUBLE:\n-\t    {\n-\t      unsigned long val;\n-\t      REAL_VALUE_TYPE rv;\n-\n-\t      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n-\t      REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n-\t      fprintf (file, \"0x%lx\", val);\n-\t      break;\n-\t    }\n+\tcase CONST_DOUBLE:\n+\t  {\n+\t    unsigned long val;\n+\t    REAL_VALUE_TYPE rv;\n \n-\t  case CONST_INT:\n-\t  case SYMBOL_REF:\n-\t  case CONST:\n-\t  case LABEL_REF:\n-\t  case CODE_LABEL:\n-\t  case UNSPEC:\n-\t    mn10300_print_operand_address (file, x);\n+\t    REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t    REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n+\t    fprintf (file, \"0x%lx\", val);\n \t    break;\n-\t  default:\n-\t    gcc_unreachable ();\n \t  }\n-\tbreak;\n-   }\n+\n+\tcase CONST_INT:\n+\tcase SYMBOL_REF:\n+\tcase CONST:\n+\tcase LABEL_REF:\n+\tcase CODE_LABEL:\n+\tcase UNSPEC:\n+\t  mn10300_print_operand_address (file, x);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+    }\n }\n \n /* Output assembly language output for the address ADDR to FILE.  */\n@@ -1694,7 +1714,7 @@ mn10300_output_add (rtx operands[3], bool need_flags)\n   dest_class = REGNO_REG_CLASS (dest_regnum);\n   src1_class = REGNO_REG_CLASS (src1_regnum);\n \n-  if (GET_CODE (src2) == CONST_INT)\n+  if (CONST_INT_P (src2))\n     {\n       gcc_assert (dest_regnum == src1_regnum);\n \n@@ -2925,8 +2945,177 @@ mn10300_split_and_operand_count (rtx op)\n     }\n }\n \f\n+/* Extract operands and (if requested) the LIW op type from the insn.\n+   Returns false if the insn can't be bundled.  */\n+\n+static bool\n+extract_bundle (rtx insn, rtx * ops, enum attr_liw_op * plop)\n+{\n+  enum attr_liw_op lop;\n+  rtx p, s;\n+\n+  p = single_set (insn);\n+  s = SET_SRC (p);\n+  lop = get_attr_liw_op (insn);\n+  if (plop != NULL)\n+    * plop = lop;\n+\n+  switch (lop)\n+    {\n+    case LIW_OP_MOV:\n+      ops[0] = SET_DEST (p);\n+      ops[1] = SET_SRC (p);\n+      break;\n+    case LIW_OP_CMP:\n+      ops[0] = XEXP (SET_SRC (p), 0);\n+      ops[1] = XEXP (SET_SRC (p), 1);\n+      break;\n+    case LIW_OP_NONE:\n+      return false;\n+    default:\n+      ops[0] = SET_DEST (p);\n+      ops[1] = XEXP (SET_SRC (p), 1);\n+      break;\n+    }\n+\n+  return REG_P (ops[0]) && REG_P (ops[1]);\n+}\n+\n+/* Look for conflicts in the operands used in\n+   the potential bundling of the two insns.  */\n+\n+static bool\n+check_liw_constraints (rtx ops[4],\n+\t\t       enum attr_liw_op op1,\n+\t\t       enum attr_liw_op op2,\n+\t\t       bool swapped)\n+{\n+  /* Look for the two destination registers being the same.  This is OK if\n+     the first op is a comparison op, since it will compare the value prior\n+     to the completion of the second op.  */\n+  if (REGNO (ops[0]) == REGNO (ops[2])\n+      && ( (! swapped && op1 != LIW_OP_CMP)\n+\t  || (swapped && op2 != LIW_OP_CMP)))\n+    return false;\n+\n+  /* Look for the source of the second op being the destination of the first op.\n+     Nomrally this will prevent the bundling since GCC has generated sequential\n+     operations and the LIW opcodes are executed in parallel.  But if the first\n+     opcode is a MOV, we can copy its source to the second ops source.  */\n+  if (swapped)\n+    return REGNO (ops[1]) != REGNO (ops[2]);\n+\n+  if (REGNO (ops[3]) == REGNO (ops[0]))\n+    {\n+      if (op1 == LIW_OP_MOV)\n+\t{\n+\t  ops[3] = ops[1];\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Decide if the given insn is a candidate for LIW bundling.  For now we just\n+   check that the insn has an LIW attribute.  Later on we check operand\n+   constraints and such.  */\n+\n+static bool\n+liw_candidate (rtx insn)\n+{\n+  return insn != NULL_RTX\n+    && single_set (insn) != NULL_RTX\n+    && get_attr_liw (insn) != LIW_BOTH;\n+}\n+\n+/* Combine pairs of insns into LIW bundles.  */\n+\n+static void\n+mn10300_bundle_liw (void)\n+{\n+  rtx r;\n+\n+  for (r = get_insns (); r != NULL_RTX; r = next_nonnote_nondebug_insn (r))\n+    {\n+      rtx insn1, insn2, ops[4];\n+      enum attr_liw liw1, liw2;\n+      enum attr_liw_op op1, op2;\n+      bool swapped = false;\n+\n+      insn1 = r;\n+      if (! liw_candidate (insn1))\n+\tcontinue;\n+\n+      insn2 = next_nonnote_nondebug_insn (insn1);\n+      if (! liw_candidate (insn2))\n+\tcontinue;\n+\n+      liw1 = get_attr_liw (insn1);\n+      if (liw1 == LIW_BOTH)\n+\tcontinue;\n+      liw2 = get_attr_liw (insn2);\n+      if (liw2 == LIW_BOTH)\n+\tcontinue;\n+      if (liw2 == liw1 && liw1 != LIW_EITHER)\n+\tcontinue;\n+\n+      /* The scheduler always groups the insns correctly, but not\n+\t always in sequence.  So, we can do a naive check and expect\n+\t it to work.  */\n+      if (liw1 == LIW_OP2 || liw2 == LIW_OP1)\n+\t{\n+\t  rtx r;\n+\t  enum attr_liw lt;\n+\n+\t  r = insn1;\n+\t  insn1 = insn2;\n+\t  insn2 = r;\n+\t  lt = liw1;\n+\t  liw1 = liw2;\n+\t  liw2 = lt;\n+\t  swapped = true;\n+\t}\n+\n+      if (! extract_bundle (insn1, ops, & op1))\n+\tcontinue;\n+      if (! extract_bundle (insn2, ops + 2, & op2))\n+\tcontinue;\n+      if (! check_liw_constraints (ops, op1, op2, swapped))\n+\tcontinue;\n+\n+      delete_insn (insn2);\n+\n+      if (op1 == LIW_OP_CMP)\n+\tinsn2 = gen_cmp_liw (ops[2], ops[3], ops[0], ops[1], GEN_INT (op2));\n+      else if (op2 == LIW_OP_CMP)\n+\tinsn2 = gen_liw_cmp (ops[0], ops[1], ops[2], ops[3], GEN_INT (op1));\n+      else\n+\tinsn2 = gen_liw (ops[0], ops[2], ops[1], ops[3],\n+\t\t\t GEN_INT (op1), GEN_INT (op2));\n+\n+      insn2 = emit_insn_after (insn2, insn1);\n+      delete_insn (insn1);\n+      r = insn2;\n+    }\n+}\n+\n+static void\n+mn10300_reorg (void)\n+{\n+  if (TARGET_AM33)\n+    {\n+      if (TARGET_ALLOW_LIW)\n+\tmn10300_bundle_liw ();\n+    }\n+}\n+\f\n /* Initialize the GCC target structure.  */\n \n+#undef  TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG mn10300_reorg\n+\n #undef  TARGET_EXCEPT_UNWIND_INFO\n #define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info\n \n@@ -2954,7 +3143,7 @@ mn10300_split_and_operand_count (rtx op)\n #define TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA mn10300_asm_output_addr_const_extra\n \n #undef  TARGET_DEFAULT_TARGET_FLAGS\n-#define TARGET_DEFAULT_TARGET_FLAGS MASK_MULT_BUG | MASK_PTR_A0D0\n+#define TARGET_DEFAULT_TARGET_FLAGS MASK_MULT_BUG | MASK_PTR_A0D0 | MASK_ALLOW_LIW\n #undef  TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION mn10300_handle_option\n #undef  TARGET_OPTION_OVERRIDE"}, {"sha": "2e97ca4ff4c426942db2e1b5dcdebb763cf1369d", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=298362c83f1e4250dc2598fa11e8f6a3bacd6153", "patch": "@@ -50,6 +50,10 @@\n         }\t\t\t\t\t\\\n       else if (TARGET_AM33)\t\t\t\\\n         builtin_define (\"__AM33__=1\");\t\t\\\n+\t\t\t\t\t\t\\\n+      builtin_define (TARGET_ALLOW_LIW ?\t\\\n+\t\t      \"__LIW__\" : \"__NO_LIW__\");\\\n+\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n "}, {"sha": "e8d2ae1194dc829821558e53e436f3b14074536d", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 145, "deletions": 29, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=298362c83f1e4250dc2598fa11e8f6a3bacd6153", "patch": "@@ -1,6 +1,6 @@\n ;; GCC machine description for Matsushita MN10300\n ;; Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-;; 2005, 2006, 2007, 2008, 2009, 2010\n+;; 2005, 2006, 2007, 2008, 2009, 2010, 2011\n ;; Free Software Foundation, Inc.\n ;; Contributed by Jeff Law (law@cygnus.com).\n \n@@ -39,6 +39,9 @@\n \n   (UNSPEC_EXT\t\t6)\n   (UNSPEC_BSCH\t\t7)\n+\n+  ;; This is used to encode LIW patterns.\n+  (UNSPEC_LIW\t\t8)\n ])\n \n (include \"predicates.md\")\n@@ -74,6 +77,43 @@\n \n (define_mode_iterator INT [QI HI SI])\n \n+\f\n+;; Bundling of smaller insns into a long instruction word (LIW)\n+(define_automaton \"liw_bundling\")\n+(automata_option \"ndfa\")\n+\n+(define_cpu_unit \"liw_op1_u,liw_op2_u\" \"liw_bundling\")\n+\n+(define_attr \"liw\" \"op1,op2,both,either\"\n+  (const_string \"both\"))\n+;; Note: this list must match the one defined for liw_op_names[].\n+(define_attr \"liw_op\" \"add,cmp,sub,mov,and,or,xor,asr,lsr,asl,none,max\"\n+  (const_string \"none\"))\n+\n+(define_insn_reservation \"liw_op1\" 1\n+  (and (ior (eq_attr \"cpu\" \"am33\")\n+            (eq_attr \"cpu\" \"am33_2\")\n+\t    (eq_attr \"cpu\" \"am34\"))\n+       (eq_attr \"liw\" \"op1\"))\n+  \"liw_op1_u\");\n+(define_insn_reservation \"liw_op2\" 1\n+  (and (ior (eq_attr \"cpu\" \"am33\")\n+            (eq_attr \"cpu\" \"am33_2\")\n+\t    (eq_attr \"cpu\" \"am34\"))\n+       (eq_attr \"liw\" \"op2\"))\n+  \"liw_op2_u\");\n+(define_insn_reservation \"liw_both\" 1\n+  (and (ior (eq_attr \"cpu\" \"am33\")\n+            (eq_attr \"cpu\" \"am33_2\")\n+\t    (eq_attr \"cpu\" \"am34\"))\n+       (eq_attr \"liw\" \"both\"))\n+  \"liw_op1_u + liw_op2_u\");\n+(define_insn_reservation \"liw_either\" 1\n+  (and (ior (eq_attr \"cpu\" \"am33\")\n+            (eq_attr \"cpu\" \"am33_2\")\n+\t    (eq_attr \"cpu\" \"am34\"))\n+       (eq_attr \"liw\" \"either\"))\n+  \"liw_op1_u | liw_op2_u\");\n \f\n ;; ----------------------------------------------------------------------\n ;; Pipeline description.\n@@ -417,6 +457,8 @@\n     }\n }\n   [(set_attr \"isa\" \"*,*,*,*,*,*,*,am33,*,*\")\n+   (set_attr \"liw\" \"*,*,either,*,*,*,*,*,*,*\")\n+   (set_attr \"liw_op\" \"mov\")\n    (set_attr_alternative \"timings\"\n \t [(const_int 11)\n \t  (const_int 22)\n@@ -521,13 +563,15 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"addsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\"  \"=r,!*y,!r\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"%0,  0, r\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ri,  i, r\")))\n+  [(set (match_operand:SI          0 \"register_operand\"  \"=r,r,!*y,!r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,  0, r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\"  \"r,i,  i, r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   { return mn10300_output_add (operands, false); }\n-  [(set_attr \"timings\" \"11,11,22\")]\n+  [(set_attr \"timings\" \"11,11,11,22\")\n+   (set_attr \"liw\" \"either,*,*,*\")\n+   (set_attr \"liw_op\" \"add\")]\n )\n \n ;; Note that ADD IMM,SP does not set the flags, so omit that here.\n@@ -714,22 +758,25 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"subsi3\"\n-  [(set (match_operand:SI           0 \"register_operand\"  \"=r,r\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\"  \" 0,r\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"ri,r\")))\n+  [(set (match_operand:SI           0 \"register_operand\"  \"=r,r,r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\"   \"0,0,r\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\"  \"r,i,r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"@\n+   sub %2,%0\n    sub %2,%0\n    sub %2,%1,%0\"\n-  [(set_attr \"isa\" \"*,am33\")\n-   (set_attr \"timings\" \"11,22\")]\n+  [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"liw\" \"either,*,*\")\n+   (set_attr \"liw_op\" \"sub\")\n+   (set_attr \"timings\" \"11,11,22\")]\n )\n \n (define_insn \"*subsi3_flags\"\n-  [(set (match_operand:SI           0 \"register_operand\"  \"=r,r\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\"  \" 0,r\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"ri,r\")))\n+  [(set (match_operand:SI           0 \"register_operand\"  \"=r, r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\"   \"0, r\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\"  \"ri,r\")))\n    (set (reg CC_REG)\n    \t(compare (minus:SI (match_dup 1) (match_dup 2))\n \t\t (const_int 0)))]\n@@ -1125,6 +1172,8 @@\n    and %2,%0\n    and %2,%1,%0\"\n   [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"liw\" \"*,op1,*\")\n+   (set_attr \"liw_op\" \"and\")\n    (set_attr \"timings\" \"22,11,11\")]\n )\n \n@@ -1210,6 +1259,8 @@\n    or %2,%0\n    or %2,%1,%0\"\n   [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"liw\" \"*,op1,*\")\n+   (set_attr \"liw_op\" \"or\")\n    (set_attr \"timings\" \"22,11,11\")]\n )\n \n@@ -1244,6 +1295,8 @@\n    xor %2,%0\n    xor %2,%1,%0\"\n   [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"liw\" \"*,op1,*\")\n+   (set_attr \"liw_op\" \"xor\")\n    (set_attr \"timings\" \"22,11,11\")]\n )\n \n@@ -1321,8 +1374,8 @@\n \n (define_insn \"*cmpsi\"\n   [(set (reg CC_REG)\n-\t(compare (match_operand:SI 0 \"register_operand\"  \"r\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"ri\")))]\n+\t(compare (match_operand:SI 0 \"register_operand\"  \"r,r\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"r,i\")))]\n   \"reload_completed\"\n {\n   /* The operands of CMP must be distinct registers.  In the case where\n@@ -1336,7 +1389,10 @@\n     return \"cmp %1,%0\";\n }\n   [(set_attr_alternative \"timings\"\n-     [(if_then_else (eq_attr \"cpu\" \"am34\") (const_int 11) (const_int 22))])]\n+     [(if_then_else (eq_attr \"cpu\" \"am34\") (const_int 11) (const_int 22))\n+      (if_then_else (eq_attr \"cpu\" \"am34\") (const_int 11) (const_int 22))])\n+   (set_attr \"liw\" \"either,*\")\n+   (set_attr \"liw_op\" \"cmp\")]\n )\n \n (define_insn \"*integer_conditional_branch\"\n@@ -1676,10 +1732,10 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"ashlsi3\"\n-  [(set (match_operand:SI  0 \"register_operand\"  \"=r,D,d,d, D,r\")\n+  [(set (match_operand:SI  0 \"register_operand\"   \"=r,D,d,d,D,D,r\")\n \t(ashift:SI\n-\t  (match_operand:SI 1 \"register_operand\"  \" 0,0,0,0, 0,r\")\n-\t  (match_operand:QI 2 \"nonmemory_operand\" \" J,K,M,L,Di,r\")))\n+\t  (match_operand:SI 1 \"register_operand\"  \" 0,0,0,0,0,0,r\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \" J,K,M,L,D,i,r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"@\n@@ -1688,35 +1744,44 @@\n    asl2 %0\\;add %0,%0\n    asl2 %0\\;asl2 %0\n    asl %S2,%0\n+   asl %S2,%0\n    asl %2,%1,%0\"\n-  [(set_attr \"isa\" \"*,*,*,*,*,am33\")\n-   (set_attr \"timings\" \"11,11,22,22,11,11\")]\n+  [(set_attr \"isa\" \"*,*,*,*,*,*,am33\")\n+   (set_attr \"liw\" \"*,*,*,*,op2,*,*\")\n+   (set_attr \"liw_op\" \"asl\")\n+   (set_attr \"timings\" \"11,11,22,22,11,11,11\")]\n )\n \n (define_insn \"lshrsi3\"\n-  [(set (match_operand:SI  0 \"register_operand\"  \"=D,r\")\n+  [(set (match_operand:SI  0 \"register_operand\"  \"=D,D,r\")\n \t(lshiftrt:SI\n-\t  (match_operand:SI 1 \"register_operand\"  \" 0,r\")\n-\t  (match_operand:QI 2 \"nonmemory_operand\" \"Di,r\")))\n+\t  (match_operand:SI 1 \"register_operand\"  \"0,0,r\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"D,i,r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"@\n+   lsr %S2,%0\n    lsr %S2,%0\n    lsr %2,%1,%0\"\n-  [(set_attr \"isa\" \"*,am33\")]\n+  [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"liw\" \"op2,*,*\")\n+   (set_attr \"liw_op\" \"lsr\")]\n )\n \n (define_insn \"ashrsi3\"\n-  [(set (match_operand:SI  0 \"register_operand\"  \"=D,r\")\n+  [(set (match_operand:SI  0 \"register_operand\"  \"=D,D,r\")\n \t(ashiftrt:SI\n-\t  (match_operand:SI 1 \"register_operand\"  \" 0,r\")\n-\t  (match_operand:QI 2 \"nonmemory_operand\" \"Di,r\")))\n+\t  (match_operand:SI 1 \"register_operand\"  \"0,0,r\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"D,i,r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"@\n+   asr %S2,%0\n    asr %S2,%0\n    asr %2,%1,%0\"\n-  [(set_attr \"isa\" \"*,am33\")]\n+  [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"liw\" \"op2,*,*\")\n+   (set_attr \"liw_op\" \"asr\")]\n )\n \n ;; ----------------------------------------------------------------------\n@@ -2029,3 +2094,54 @@\n }\n   [(set_attr \"timings\" \"66\")]\n )\n+\n+;; The mode on operand 3 has been deliberately omitted because it\n+;; can be either SI (for arithmetic operations) or QI (for shifts).\n+(define_insn \"liw\"\n+  [(set (match_operand:SI             0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_dup 0)\n+                    (match_operand:SI 2 \"register_operand\" \"r\")\n+                    (match_operand:SI 4 \"const_int_operand\" \"\")]\n+                   UNSPEC_LIW))\n+   (set (match_operand:SI             1 \"register_operand\" \"=r\")\n+        (unspec:SI [(match_dup 1)\n+                    (match_operand    3 \"register_operand\" \"r\")\n+                    (match_operand:SI 5 \"const_int_operand\" \"\")]\n+                   UNSPEC_LIW))]\n+  \"TARGET_ALLOW_LIW\"\n+  \"%W4_%W5 %2, %0, %3, %1\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 13) (const_int 12)))]\n+)\n+\n+;; The mode on operand 1 has been deliberately omitted because it\n+;; can be either SI (for arithmetic operations) or QI (for shifts).\n+(define_insn \"cmp_liw\"\n+  [(set (reg:CC CC_REG)\n+\t(compare:CC (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t    (match_operand:SI 3 \"register_operand\" \"r\")))\n+   (set (match_operand:SI             0 \"register_operand\" \"=r\")\n+        (unspec:SI [(match_dup 0)\n+                    (match_operand    1 \"register_operand\" \"r\")\n+                    (match_operand:SI 4 \"const_int_operand\" \"\")]\n+                   UNSPEC_LIW))]\n+  \"TARGET_ALLOW_LIW\"\n+  \"cmp_%W4 %2, %3, %0, %1\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 13) (const_int 12)))]\n+)\n+\n+(define_insn \"liw_cmp\"\n+  [(set (match_operand:SI             0 \"register_operand\" \"=r\")\n+        (unspec:SI [(match_dup 0)\n+                    (match_operand:SI 1 \"register_operand\" \"r\")\n+                    (match_operand:SI 4 \"const_int_operand\" \"\")]\n+                   UNSPEC_LIW))\n+   (set (reg:CC CC_REG)\n+\t(compare:CC (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t    (match_operand:SI 3 \"register_operand\" \"r\")))]\n+  \"TARGET_ALLOW_LIW\"\n+  \"%W4_cmp %0, %1, %2, %3\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 13) (const_int 12)))]\n+)"}, {"sha": "427510304b2f340cecd16050a4f25a3949ed53a8", "filename": "gcc/config/mn10300/mn10300.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2Fconfig%2Fmn10300%2Fmn10300.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2Fconfig%2Fmn10300%2Fmn10300.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.opt?ref=298362c83f1e4250dc2598fa11e8f6a3bacd6153", "patch": "@@ -1,6 +1,6 @@\n ; Options for the Matsushita MN10300 port of the compiler.\n \n-; Copyright (C) 2005, 2007, 2010 Free Software Foundation, Inc.\n+; Copyright (C) 2005, 2007, 2010, 2011 Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n ;\n@@ -46,3 +46,7 @@ Enable linker relaxations\n mreturn-pointer-on-d0\n Target Report Mask(PTR_A0D0)\n Return pointers in both a0 and d0\n+\n+mliw\n+Target Report Mask(ALLOW_LIW)\n+Allow gcc to generate LIW instructions"}, {"sha": "a916e4ea141afc6e48f3d2573e23420b4dc5719c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298362c83f1e4250dc2598fa11e8f6a3bacd6153/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=298362c83f1e4250dc2598fa11e8f6a3bacd6153", "patch": "@@ -739,7 +739,7 @@ Objective-C and Objective-C++ Dialects}.\n -mno-am33 -mam33 -mam33-2 -mam34 @gol\n -mtune=@var{cpu-type} @gol\n -mreturn-pointer-on-d0 @gol\n--mno-crt0  -mrelax}\n+-mno-crt0  -mrelax -mliw}\n \n @emph{PDP-11 Options}\n @gccoptlist{-mfpu  -msoft-float  -mac0  -mno-ac0  -m40  -m45  -m10 @gol\n@@ -15035,6 +15035,19 @@ to shorten branches, calls and absolute memory addresses.  This option only\n has an effect when used on the command line for the final link step.\n \n This option makes symbolic debugging impossible.\n+\n+@item -mliw\n+@opindex mliw\n+Allow the compiler to generate @emph{Long Instruction Word}\n+instructions if the target is the @samp{AM33} or later.  This is the\n+default.  This option defines the preprocessor macro @samp{__LIW__}.\n+\n+@item -mnoliw\n+@opindex mnoliw\n+Do not allow the compiler to generate @emph{Long Instruction Word}\n+instructions.  This option defines the preprocessor macro\n+@samp{__NO_LIW__}.\n+\n @end table\n \n @node PDP-11 Options"}]}