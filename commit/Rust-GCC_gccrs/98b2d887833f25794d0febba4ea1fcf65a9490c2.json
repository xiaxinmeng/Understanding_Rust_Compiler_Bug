{"sha": "98b2d887833f25794d0febba4ea1fcf65a9490c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThiMmQ4ODc4MzNmMjU3OTRkMGZlYmJhNGVhMWZjZjY1YTk0OTBjMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-09T20:22:15Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-09T20:22:15Z"}, "message": "pa.md (dbra pattern): Use output_dbra.\n\n        * pa.md (dbra pattern): Use output_dbra.\n        (dbra pattern #2): New pattern.  Also use output_dbra.\n        (movb, inverted movb): New patterns.\n\nFrom-SVN: r4887", "tree": {"sha": "229b0ae128af8a9b16108590bb83441e46b8259a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/229b0ae128af8a9b16108590bb83441e46b8259a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98b2d887833f25794d0febba4ea1fcf65a9490c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98b2d887833f25794d0febba4ea1fcf65a9490c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98b2d887833f25794d0febba4ea1fcf65a9490c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98b2d887833f25794d0febba4ea1fcf65a9490c2/comments", "author": null, "committer": null, "parents": [{"sha": "6bd5174eb2f1c6786ee2a6be2fb1e185d1b43623", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd5174eb2f1c6786ee2a6be2fb1e185d1b43623", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bd5174eb2f1c6786ee2a6be2fb1e185d1b43623"}], "stats": {"total": 213, "additions": 147, "deletions": 66}, "files": [{"sha": "ce223165c577f9a44c5a8c0937d847c9f6efe69c", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 147, "deletions": 66, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b2d887833f25794d0febba4ea1fcf65a9490c2/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b2d887833f25794d0febba4ea1fcf65a9490c2/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=98b2d887833f25794d0febba4ea1fcf65a9490c2", "patch": "@@ -2898,7 +2898,6 @@\n   return \\\"depi %3,%2+%1-1,%1,%0\\\";\n }\")\n \n-;; The dbra pattern from hell.  \n ;; This insn is used for some loop tests, typically loops reversed when\n ;; strength reduction is used.  It is actually created when the instruction\n ;; combination phase combines the special loop test.  Since this insn\n@@ -2918,72 +2917,63 @@\n \t(plus:SI (match_dup 0) (match_dup 1)))\n    (clobber (match_scratch:SI 4 \"=X,r,r\"))]\n   \"\"\n-\"*\n-{\n+\"* output_dbra (operands, insn, which_alternative); \"\n+;; Do not expect to understand this the first time through.  \n+[(set_attr \"type\" \"cbranch,multi,multi\")\n+ (set (attr \"length\")\n+      (if_then_else (eq_attr \"alternative\" \"0\")\n+;; Loop counter in register case\n+;; Short branch has length of 1\n+;; Long branch has length of 2\n+\t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t\t      (const_int 2047))\n+           (const_int 1)\n+\t   (const_int 2))\n \n-  if (which_alternative == 0)\n-    {\n-      int nullify = INSN_ANNULLED_BRANCH_P (insn);\n-      int length = get_attr_length (insn);\n-\n-      /* If this is a long branch with its delay slot unfilled, set `nullify'\n-\t as it can nullify the delay slot and save a nop.  */\n-      if (length == 2 && dbr_sequence_length () == 0)\n-\tnullify = 1;\n-\n-      /* If this is a short forward conditional branch which did not get\n-\t its delay slot filled, the delay slot can still be nullified.  */\n-      if (! nullify && length == 1 && dbr_sequence_length () == 0)\n-\tnullify = forward_branch_p (insn);\n-\n-      /* Handle short versions first.  */\n-      if (length == 1 && nullify)\n-\treturn \\\"addib,%C2,n %1,%0,%3\\\";\n-      else if (length == 1 && ! nullify)\n-\treturn \\\"addib,%C2 %1,%0,%3\\\";\n-      else if (length == 2)\n-\t{\n-\t  /* Handle weird backwards branch with a fulled delay slot \n-\t     which is nullified.  */\n-\t  if (dbr_sequence_length () != 0\n-\t      && ! forward_branch_p (insn)\n-\t      && nullify)\n-\t    return \\\"addib,%N2,n %1,%0,.+12\\;bl %3,0\\\";\n-\t  \n-\t  /* Handle normal cases.  */  \n-\t  if (nullify)\n-\t    return \\\"addi,%N2 %1,%0,%0\\;bl,n %3,0\\\";\n-\t  else\n-\t    return \\\"addi,%N2 %1,%0,%0\\;bl %3,0\\\";\n-\t}\n-      else\n-\tabort();\n-    }\n-  /* Deal with gross reload from FP register case.  */\n-  else if (which_alternative == 1)\n-    {\n-      /* Move loop counter from FP register to MEM then into a GR,\n-\t increment the GR, store the GR into MEM, and finally reload\n-\t the FP register from MEM from within the branch's delay slot.  */ \n-      output_asm_insn (\\\"fstws %0,-16(0,%%r30)\\;ldw -16(0,%%r30),%4\\\",operands);\n-      output_asm_insn (\\\"ldo %1(%4),%4\\;stw %4,-16(0,%%r30)\\\", operands);\n-      if (get_attr_length (insn) == 6)\n-\treturn \\\"comb,%S2 0,%4,%3\\;fldws -16(0,%%r30),%0\\\";\n-      else\n-\treturn \\\"comclr,%B2 0,%4,0\\;bl %3,0\\;fldws -16(0,%%r30),%0\\\";\n-    }\n-  /* Deal with gross reload from memory case.  */\n-  else\n-    {\n-      /* Reload loop counter from memory, the store back to memory\n-\t happens in the branch's delay slot.   */\n-      output_asm_insn (\\\"ldw %0,%4\\\", operands);\n-      if (get_attr_length (insn) == 3)\n-\treturn \\\"addib,%C2 %1,%4,%3;stw %4,%0\\\";\n-      else\n-\treturn \\\"addi,%N2 %1,%4,%0\\;bl %3,0\\;stw %4,%0\\\";\n-    }\n-}\"\n+;; Loop counter in FP reg case.\n+;; Extra goo to deal with additional reload insns.\n+\t(if_then_else (eq_attr \"alternative\" \"1\")\n+\t  (if_then_else (lt (match_dup 3) (pc))\n+\t    (if_then_else \n+\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 6))))\n+\t\t  (const_int 2047))\n+\t      (const_int 6)\n+\t      (const_int 7))\n+\t    (if_then_else \n+\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t\t  (const_int 2047))\n+\t      (const_int 6)\n+\t      (const_int 7)))\n+;; Loop counter in memory case.\n+;; Extra goo to deal with additional reload insns.\n+\t(if_then_else (lt (match_dup 3) (pc))\n+\t  (if_then_else \n+\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 3))))\n+\t\t(const_int 2047))\n+\t    (const_int 3)\n+\t    (const_int 4))\n+\t  (if_then_else \n+\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t\t(const_int 2047))\n+\t    (const_int 3)\n+\t    (const_int 4))))))])\n+\n+;; Simply another variant of the dbra pattern.  More restrictive \n+;; in testing the comparison operator as it must worry about overflow\n+;; problems.\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 2 \"eq_neq_comparison_operator\"\n+\t   [(match_operand:SI 0 \"register_operand\" \"+!r,!*fx,!*m\")\n+\t    (match_operand:SI 5 \"const_int_operand\" \"\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0) (match_operand:SI 1 \"int5_operand\" \"L,L,L\")))\n+   (clobber (match_scratch:SI 4 \"=X,r,r\"))]\n+  \"INTVAL (operands[5]) == - INTVAL (operands[1])\"\n+\"* return output_dbra (operands, insn, which_alternative);\"\n ;; Do not expect to understand this the first time through.  \n [(set_attr \"type\" \"cbranch,multi,multi\")\n  (set (attr \"length\")\n@@ -3024,6 +3014,97 @@\n \t    (const_int 3)\n \t    (const_int 4))))))])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 2 \"movb_comparison_operator\"\n+\t   [(match_operand:SI 1 \"register_operand\" \"r,r,r\") (const_int 0)])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=!r,!*fx,!*m\")\n+\t(match_dup 1))]\n+  \"\"\n+\"* return output_movb (operands, insn, which_alternative, 0); \"\n+;; Do not expect to understand this the first time through.  \n+[(set_attr \"type\" \"cbranch,multi,multi\")\n+ (set (attr \"length\")\n+      (if_then_else (eq_attr \"alternative\" \"0\")\n+;; Loop counter in register case\n+;; Short branch has length of 1\n+;; Long branch has length of 2\n+\t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t\t      (const_int 2047))\n+           (const_int 1)\n+\t   (const_int 2))\n+\n+;; Loop counter in FP reg case.\n+;; Extra goo to deal with additional reload insns.\n+\t(if_then_else (eq_attr \"alternative\" \"1\")\n+\t  (if_then_else (lt (match_dup 3) (pc))\n+\t    (if_then_else \n+\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 3))))\n+\t\t  (const_int 2047))\n+\t      (const_int 3)\n+\t      (const_int 4))\n+\t    (if_then_else \n+\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t\t  (const_int 2047))\n+\t      (const_int 3)\n+\t      (const_int 4)))\n+;; Loop counter in memory case.\n+;; Extra goo to deal with additional reload insns.\n+\t(if_then_else \n+\t  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t      (const_int 2047))\n+\t  (const_int 2)\n+\t  (const_int 3)))))])\n+\n+;; Handle negated branch.\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 2 \"movb_comparison_operator\"\n+\t   [(match_operand:SI 1 \"register_operand\" \"r,r,r\") (const_int 0)])\n+\t  (pc)\n+\t  (label_ref (match_operand 3 \"\" \"\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=!r,!*fx,!*m\")\n+\t(match_dup 1))]\n+  \"\"\n+\"* return output_movb (operands, insn, which_alternative, 1); \"\n+;; Do not expect to understand this the first time through.  \n+[(set_attr \"type\" \"cbranch,multi,multi\")\n+ (set (attr \"length\")\n+      (if_then_else (eq_attr \"alternative\" \"0\")\n+;; Loop counter in register case\n+;; Short branch has length of 1\n+;; Long branch has length of 2\n+\t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t\t      (const_int 2047))\n+           (const_int 1)\n+\t   (const_int 2))\n+\n+;; Loop counter in FP reg case.\n+;; Extra goo to deal with additional reload insns.\n+\t(if_then_else (eq_attr \"alternative\" \"1\")\n+\t  (if_then_else (lt (match_dup 3) (pc))\n+\t    (if_then_else \n+\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 3))))\n+\t\t  (const_int 2047))\n+\t      (const_int 3)\n+\t      (const_int 4))\n+\t    (if_then_else \n+\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t\t  (const_int 2047))\n+\t      (const_int 3)\n+\t      (const_int 4)))\n+;; Loop counter in memory case.\n+;; Extra goo to deal with additional reload insns.\n+\t(if_then_else \n+\t  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t      (const_int 2047))\n+\t  (const_int 2)\n+\t  (const_int 3)))))])\n+\n ;; The next four peepholes take advantage of the new 5 operand \n ;; fmpy{add,sub} instructions available on 1.1 CPUS.  Basically\n ;; fmpyadd performs a multiply and add/sub of independent operands"}]}