{"sha": "cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FkZGRmZGRhMmM0YTE2ZTdmZGQ1ZjBkOGQwMmI0NjVjYWFkMmFkNQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2013-03-25T15:40:26Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-03-25T15:40:26Z"}, "message": "re PR fortran/38536 (ICE with C_LOC in resolve.c due to not properly going through expr->ref)\n\n2013-03-25  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/38536\n        PR fortran/38813\n        PR fortran/38894\n        PR fortran/39288\n        PR fortran/40963\n        PR fortran/45824\n        PR fortran/47023\n        PR fortran/47034\n        PR fortran/49023\n        PR fortran/50269\n        PR fortran/50612\n        PR fortran/52426\n        PR fortran/54263\n        PR fortran/55343\n        PR fortran/55444\n        PR fortran/55574\n        PR fortran/56079\n        PR fortran/56378\n        * check.c (gfc_var_strlen): Properly handle 0-sized string.\n        (gfc_check_c_sizeof): Use is_c_interoperable, add checks.\n        (is_c_interoperable, gfc_check_c_associated, gfc_check_c_f_pointer,\n        gfc_check_c_f_procpointer, gfc_check_c_funloc, gfc_check_c_loc): New\n        functions.\n        * expr.c (check_inquiry): Add c_sizeof, compiler_version and\n        compiler_options.\n        (gfc_check_pointer_assign): Refine function result check.\n        gfortran.h (gfc_isym_id): Add GFC_ISYM_C_ASSOCIATED,\n        GFC_ISYM_C_F_POINTER, GFC_ISYM_C_F_PROCPOINTER, GFC_ISYM_C_FUNLOC,\n        GFC_ISYM_C_LOC.\n        (iso_fortran_env_symbol, iso_c_binding_symbol): Handle\n        NAMED_SUBROUTINE.\n        (generate_isocbinding_symbol): Update prototype.\n        (get_iso_c_sym): Remove.\n        (gfc_isym_id_by_intmod, gfc_isym_id_by_intmod_sym): New prototypes.\n        * intrinsic.c (gfc_intrinsic_subroutine_by_id): New function.\n        (gfc_intrinsic_sub_interface): Use it.\n        (add_functions, add_subroutines): Add missing C-binding intrinsics.\n        (gfc_intrinsic_func_interface): Add special case for c_loc.\n        gfc_isym_id_by_intmod, gfc_isym_id_by_intmod_sym): New functions.\n        (gfc_intrinsic_func_interface, gfc_intrinsic_sub_interface): Use them.\n        * intrinsic.h (gfc_check_c_associated, gfc_check_c_f_pointer,\n        gfc_check_c_f_procpointer, gfc_check_c_funloc, gfc_check_c_loc,\n        gfc_resolve_c_loc, gfc_resolve_c_funloc): New prototypes.\n        * iresolve.c (gfc_resolve_c_loc, gfc_resolve_c_funloc): New\n        functions.\n        * iso-c-binding.def: Split PROCEDURE into NAMED_SUBROUTINE and\n        NAMED_FUNCTION.\n        * iso-fortran-env.def: Add NAMED_SUBROUTINE for completeness.\n        * module.c (create_intrinsic_function): Support subroutines and\n        derived-type results.\n        (use_iso_fortran_env_module): Update calls.\n        (import_iso_c_binding_module): Ditto; update calls to\n        generate_isocbinding_symbol.\n        * resolve.c (find_arglists): Skip for intrinsic symbols.\n        (gfc_resolve_intrinsic): Find intrinsic subs via id.\n        (is_scalar_expr_ptr, gfc_iso_c_func_interface,\n        set_name_and_label, gfc_iso_c_sub_interface): Remove.\n        (resolve_function, resolve_specific_s0): Remove calls to those.\n        (resolve_structure_cons): Fix handling.\n        * symbol.c (gen_special_c_interop_ptr): Update c_ptr/c_funptr\n        generation.\n        (gen_cptr_param, gen_fptr_param, gen_shape_param,\n        build_formal_args, get_iso_c_sym): Remove.\n        (std_for_isocbinding_symbol): Handle NAMED_SUBROUTINE.\n        (generate_isocbinding_symbol): Support hidden symbols and\n        using c_ptr/c_funptr symtrees for nullptr defs.\n        * target-memory.c (gfc_target_encode_expr): Fix handling\n        of c_ptr/c_funptr.\n        * trans-expr.c (conv_isocbinding_procedure): Remove.\n        (gfc_conv_procedure_call): Remove call to it.\n        (gfc_trans_subcomponent_assign, gfc_conv_expr): Update handling\n        of c_ptr/c_funptr.\n        * trans-intrinsic.c (conv_isocbinding_function,\n        conv_isocbinding_subroutine): New.\n        (gfc_conv_intrinsic_function, gfc_conv_intrinsic_subroutine):\n        Call them.\n        * trans-io.c (transfer_expr): Fix handling of c_ptr/c_funptr.\n        * trans-types.c (gfc_typenode_for_spec,\n        gfc_get_derived_type): Ditto.\n        (gfc_init_c_interop_kinds): Handle NAMED_SUBROUTINE.\n\n2013-03-25  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/38536\n        PR fortran/38813\n        PR fortran/38894\n        PR fortran/39288\n        PR fortran/40963\n        PR fortran/45824\n        PR fortran/47023\n        PR fortran/47034\n        PR fortran/49023\n        PR fortran/50269\n        PR fortran/50612\n        PR fortran/52426\n        PR fortran/54263\n        PR fortran/55343\n        PR fortran/55444\n        PR fortran/55574\n        PR fortran/56079\n        PR fortran/56378\n        * gfortran.dg/c_assoc_2.f03: Update dg-error wording.\n        * gfortran.dg/c_f_pointer_shape_test.f90: Ditto.\n        * gfortran.dg/c_f_pointer_shape_tests_3.f03: Ditto.\n        * gfortran.dg/c_f_pointer_tests_5.f90: Ditto.\n        * gfortran.dg/c_funloc_tests_2.f03: Ditto.\n        * gfortran.dg/c_funloc_tests_5.f03: Ditto.\n        * gfortran.dg/c_funloc_tests_6.f90: Ditto.\n        * gfortran.dg/c_loc_tests_10.f03: Add -std=f2008.\n        * gfortran.dg/c_loc_tests_11.f03: Ditto, update dg-error.\n        * gfortran.dg/c_loc_tests_16.f90: Ditto.\n        * gfortran.dg/c_loc_tests_4.f03: Ditto.\n        * gfortran.dg/c_loc_tests_15.f90: Update dg-error wording.\n        * gfortran.dg/c_loc_tests_3.f03: Valid since F2003 TC5.\n        * gfortran.dg/c_loc_tests_8.f03: Ditto.\n        * gfortran.dg/c_ptr_tests_14.f90: Update scan-tree-dump-times.\n        * gfortran.dg/c_ptr_tests_15.f90: Ditto.\n        * gfortran.dg/c_sizeof_1.f90: Fix invalid code.\n        * gfortran.dg/iso_c_binding_init_expr.f03: Update dg-error wording.\n        * gfortran.dg/pr32601_1.f03: Ditto.\n        * gfortran.dg/storage_size_2.f08: Remove dg-error.\n        * gfortran.dg/blockdata_7.f90: New.\n        * gfortran.dg/c_assoc_4.f90: New.\n        * gfortran.dg/c_f_pointer_tests_6.f90: New.\n        * gfortran.dg/c_f_pointer_tests_7.f90: New.\n        * gfortran.dg/c_funloc_tests_8.f90: New.\n        * gfortran.dg/c_loc_test_17.f90: New.\n        * gfortran.dg/c_loc_test_18.f90: New.\n        * gfortran.dg/c_loc_test_19.f90: New.\n        * gfortran.dg/c_loc_test_20.f90: New.\n        * gfortran.dg/c_sizeof_5.f90: New.\n        * gfortran.dg/iso_c_binding_rename_3.f90: New.\n        * gfortran.dg/transfer_resolve_2.f90: New.\n        * gfortran.dg/transfer_resolve_3.f90: New.\n        * gfortran.dg/transfer_resolve_4.f90: New.\n        * gfortran.dg/pr32601.f03: Update dg-error.\n        * gfortran.dg/c_ptr_tests_13.f03: Update dg-error.\n        * gfortran.dg/c_ptr_tests_9.f03: Fix test case.\n\nFrom-SVN: r197053", "tree": {"sha": "8a59184d212dad5695956782c588f54b5ed68b53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a59184d212dad5695956782c588f54b5ed68b53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a5a4c20a5c922f2faa66b9326b336b5d7eb5065e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5a4c20a5c922f2faa66b9326b336b5d7eb5065e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5a4c20a5c922f2faa66b9326b336b5d7eb5065e"}], "stats": {"total": 3146, "additions": 1629, "deletions": 1517}, "files": [{"sha": "a14423cc94c6ca110fa2a3d1d30fcd3a8352722b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -1,3 +1,86 @@\n+2013-03-25  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/38536\n+\tPR fortran/38813\n+\tPR fortran/38894\n+\tPR fortran/39288\n+\tPR fortran/40963\n+\tPR fortran/45824\n+\tPR fortran/47023\n+\tPR fortran/47034\n+\tPR fortran/49023\n+\tPR fortran/50269\n+\tPR fortran/50612\n+\tPR fortran/52426\n+\tPR fortran/54263\n+\tPR fortran/55343\n+\tPR fortran/55444\n+\tPR fortran/55574\n+\tPR fortran/56079\n+\tPR fortran/56378\n+\t* check.c (gfc_var_strlen): Properly handle 0-sized string.\n+\t(gfc_check_c_sizeof): Use is_c_interoperable, add checks.\n+\t(is_c_interoperable, gfc_check_c_associated, gfc_check_c_f_pointer,\n+\tgfc_check_c_f_procpointer, gfc_check_c_funloc, gfc_check_c_loc): New\n+\tfunctions.\n+\t* expr.c (check_inquiry): Add c_sizeof, compiler_version and\n+\tcompiler_options.\n+\t(gfc_check_pointer_assign): Refine function result check.\n+\tgfortran.h (gfc_isym_id): Add GFC_ISYM_C_ASSOCIATED,\n+\tGFC_ISYM_C_F_POINTER, GFC_ISYM_C_F_PROCPOINTER, GFC_ISYM_C_FUNLOC,\n+\tGFC_ISYM_C_LOC.\n+\t(iso_fortran_env_symbol, iso_c_binding_symbol): Handle\n+\tNAMED_SUBROUTINE.\n+\t(generate_isocbinding_symbol): Update prototype.\n+\t(get_iso_c_sym): Remove.\n+\t(gfc_isym_id_by_intmod, gfc_isym_id_by_intmod_sym): New prototypes.\n+\t* intrinsic.c (gfc_intrinsic_subroutine_by_id): New function.\n+\t(gfc_intrinsic_sub_interface): Use it.\n+\t(add_functions, add_subroutines): Add missing C-binding intrinsics.\n+\t(gfc_intrinsic_func_interface): Add special case for c_loc.\n+\tgfc_isym_id_by_intmod, gfc_isym_id_by_intmod_sym): New functions.\n+\t(gfc_intrinsic_func_interface, gfc_intrinsic_sub_interface): Use them.\n+\t* intrinsic.h (gfc_check_c_associated, gfc_check_c_f_pointer,\n+\tgfc_check_c_f_procpointer, gfc_check_c_funloc, gfc_check_c_loc,\n+\tgfc_resolve_c_loc, gfc_resolve_c_funloc): New prototypes.\n+\t* iresolve.c (gfc_resolve_c_loc, gfc_resolve_c_funloc): New\n+\tfunctions.\n+\t* iso-c-binding.def: Split PROCEDURE into NAMED_SUBROUTINE and\n+\tNAMED_FUNCTION.\n+\t* iso-fortran-env.def: Add NAMED_SUBROUTINE for completeness.\n+\t* module.c (create_intrinsic_function): Support subroutines and\n+\tderived-type results.\n+\t(use_iso_fortran_env_module): Update calls.\n+\t(import_iso_c_binding_module): Ditto; update calls to\n+\tgenerate_isocbinding_symbol.\n+\t* resolve.c (find_arglists): Skip for intrinsic symbols.\n+\t(gfc_resolve_intrinsic): Find intrinsic subs via id.\n+\t(is_scalar_expr_ptr, gfc_iso_c_func_interface,\n+\tset_name_and_label, gfc_iso_c_sub_interface): Remove.\n+\t(resolve_function, resolve_specific_s0): Remove calls to those.\n+\t(resolve_structure_cons): Fix handling.\n+\t* symbol.c (gen_special_c_interop_ptr): Update c_ptr/c_funptr\n+\tgeneration.\n+\t(gen_cptr_param, gen_fptr_param, gen_shape_param,\n+\tbuild_formal_args, get_iso_c_sym): Remove.\n+\t(std_for_isocbinding_symbol): Handle NAMED_SUBROUTINE.\n+\t(generate_isocbinding_symbol): Support hidden symbols and\n+\tusing c_ptr/c_funptr symtrees for nullptr defs.\n+\t* target-memory.c (gfc_target_encode_expr): Fix handling\n+\tof c_ptr/c_funptr.\n+\t* trans-expr.c (conv_isocbinding_procedure): Remove.\n+\t(gfc_conv_procedure_call): Remove call to it.\n+\t(gfc_trans_subcomponent_assign, gfc_conv_expr): Update handling\n+\tof c_ptr/c_funptr.\n+\t* trans-intrinsic.c (conv_isocbinding_function,\n+\tconv_isocbinding_subroutine): New.\n+\t(gfc_conv_intrinsic_function, gfc_conv_intrinsic_subroutine):\n+\tCall them.\n+\t* trans-io.c (transfer_expr): Fix handling of c_ptr/c_funptr.\n+\t* trans-types.c (gfc_typenode_for_spec,\n+\tgfc_get_derived_type): Ditto.\n+\t(gfc_init_c_interop_kinds): Handle NAMED_SUBROUTINE.\n+\n 2013-03-18  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.h (gfc_option_t): Remove flag_whole_file."}, {"sha": "0460bf2341d331ed978f9321b288ab8db2239732", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 390, "deletions": 7, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -693,14 +693,19 @@ gfc_var_strlen (const gfc_expr *a)\n     {\n       long start_a, end_a;\n \n-      if (ra->u.ss.start->expr_type == EXPR_CONSTANT\n+      if (!ra->u.ss.end)\n+\treturn -1;\n+\n+      if ((!ra->u.ss.start || ra->u.ss.start->expr_type == EXPR_CONSTANT)\n \t  && ra->u.ss.end->expr_type == EXPR_CONSTANT)\n \t{\n-\t  start_a = mpz_get_si (ra->u.ss.start->value.integer);\n+\t  start_a = ra->u.ss.start ? mpz_get_si (ra->u.ss.start->value.integer)\n+\t\t\t\t   : 1;\n \t  end_a = mpz_get_si (ra->u.ss.end->value.integer);\n-\t  return end_a - start_a + 1;\n+\t  return (end_a < start_a) ? 0 : end_a - start_a + 1;\n \t}\n-      else if (gfc_dep_compare_expr (ra->u.ss.start, ra->u.ss.end) == 0)\n+      else if (ra->u.ss.start\n+\t       && gfc_dep_compare_expr (ra->u.ss.start, ra->u.ss.end) == 0)\n \treturn 1;\n       else\n \treturn -1;\n@@ -3621,17 +3626,395 @@ gfc_check_sizeof (gfc_expr *arg)\n }\n \n \n+/* Check whether an expression is interoperable.  When returning false,\n+   msg is set to a string telling why the expression is not interoperable,\n+   otherwise, it is set to NULL.  The msg string can be used in diagnostics.\n+   If all_len_okay is true, all length-type parameters (for character) are\n+   allowed.  Required for C_LOC (cf. Fortran 2003corr5 or Fortran 2008).  */\n+\n+static bool\n+is_c_interoperable (gfc_expr *expr, const char **msg, bool all_len_okay)\n+{\n+  *msg = NULL;\n+\n+  if (expr->ts.type == BT_CLASS)\n+    {\n+      *msg = \"Expression is polymorphic\";\n+      return false;\n+    }\n+\n+  if (expr->ts.type == BT_DERIVED && !expr->ts.u.derived->attr.is_bind_c\n+      && !expr->ts.u.derived->ts.is_iso_c)\n+    {\n+      *msg = \"Expression is a noninteroperable derived type\";\n+      return false;\n+    }\n+\n+  if (expr->ts.type == BT_PROCEDURE)\n+    {\n+      *msg = \"Procedure unexpected as argument\";\n+      return false;\n+    }\n+\n+  if (gfc_notification_std (GFC_STD_GNU) && expr->ts.type == BT_LOGICAL)\n+    {\n+      int i;\n+      for (i = 0; gfc_logical_kinds[i].kind; i++)\n+        if (gfc_logical_kinds[i].kind == expr->ts.kind)\n+          return true;\n+      *msg = \"Extension to use a non-C_Bool-kind LOGICAL\";\n+      return false;\n+    }\n+\n+  if (gfc_notification_std (GFC_STD_GNU) && expr->ts.type == BT_CHARACTER\n+      && expr->ts.kind != 1)\n+    {\n+      *msg = \"Extension to use a non-C_CHAR-kind CHARACTER\";\n+      return false;\n+    }\n+\n+  if (expr->ts.type == BT_CHARACTER) {\n+    if (expr->ts.deferred)\n+      {\n+\t/* TS 29113 allows deferred-length strings as dummy arguments,\n+\t   but it is not an interoperable type. */\n+\t*msg = \"Expression shall not be a deferred-length string\";\n+\treturn false;\n+      }\n+\n+    if (expr->ts.u.cl && expr->ts.u.cl->length\n+\t&& gfc_simplify_expr (expr, 0) == FAILURE)\n+      gfc_internal_error (\"is_c_interoperable(): gfc_simplify_expr failed\");\n+\n+    if (!all_len_okay && expr->ts.u.cl\n+\t&& (!expr->ts.u.cl->length\n+\t    || expr->ts.u.cl->length->expr_type != EXPR_CONSTANT\n+\t    || mpz_cmp_si (expr->ts.u.cl->length->value.integer, 1) != 0))\n+      {\n+\t*msg = \"Type shall have a character length of 1\";\n+\treturn false;\n+      }\n+    }\n+\n+  /* Note: The following checks are about interoperatable variables, Fortran\n+     15.3.5/15.3.6.  In intrinsics like C_LOC or in procedure interface, more\n+     is allowed, e.g. assumed-shape arrays with TS 29113.  */\n+\n+  if (gfc_is_coarray (expr))\n+    {\n+      *msg = \"Coarrays are not interoperable\";\n+      return false;\n+    }\n+\n+  if (expr->rank > 0 && expr->expr_type != EXPR_ARRAY)\n+    {\n+      gfc_array_ref *ar = gfc_find_array_ref (expr);\n+      if (ar->type != AR_FULL)\n+\t{\n+\t  *msg = \"Only whole-arrays are interoperable\";\n+\t  return false;\n+\t}\n+      if (ar->as->type != AS_EXPLICIT && ar->as->type != AS_ASSUMED_SIZE)\n+\t{\n+\t  *msg = \"Only explicit-size and assumed-size arrays are interoperable\";\n+\t  return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+\n gfc_try\n gfc_check_c_sizeof (gfc_expr *arg)\n {\n-  if (gfc_verify_c_interop (&arg->ts) != SUCCESS)\n+  const char *msg;\n+\n+  if (is_c_interoperable (arg, &msg, false) != SUCCESS)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be an \"\n-\t\t \"interoperable data entity\",\n+\t\t \"interoperable data entity: %s\",\n \t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n-\t\t &arg->where);\n+\t\t &arg->where, msg);\n+      return FAILURE;\n+    }\n+\n+  if (arg->rank && arg->expr_type == EXPR_VARIABLE\n+      && arg->symtree->n.sym->as != NULL\n+      && arg->symtree->n.sym->as->type == AS_ASSUMED_SIZE && arg->ref\n+      && arg->ref->type == REF_ARRAY && arg->ref->u.ar.type == AR_FULL)\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be an \"\n+\t\t \"assumed-size array\", gfc_current_intrinsic_arg[0]->name,\n+\t\t gfc_current_intrinsic, &arg->where);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n+gfc_try\n+gfc_check_c_associated (gfc_expr *c_ptr_1, gfc_expr *c_ptr_2)\n+{\n+  if (c_ptr_1->ts.type != BT_DERIVED\n+      || c_ptr_1->ts.u.derived->from_intmod != INTMOD_ISO_C_BINDING\n+      || (c_ptr_1->ts.u.derived->intmod_sym_id != ISOCBINDING_PTR\n+\t  && c_ptr_1->ts.u.derived->intmod_sym_id != ISOCBINDING_FUNPTR))\n+    {\n+      gfc_error (\"Argument C_PTR_1 at %L to C_ASSOCIATED shall have the \"\n+\t\t \"type TYPE(C_PTR) or TYPE(C_FUNPTR)\", &c_ptr_1->where);\n+      return FAILURE;\n+    }\n+\n+  if (scalar_check (c_ptr_1, 0) == FAILURE)\n+    return FAILURE;\n+\n+  if (c_ptr_2\n+      && (c_ptr_2->ts.type != BT_DERIVED\n+\t  || c_ptr_2->ts.u.derived->from_intmod != INTMOD_ISO_C_BINDING\n+\t  || (c_ptr_1->ts.u.derived->intmod_sym_id\n+\t      != c_ptr_2->ts.u.derived->intmod_sym_id)))\n+    {\n+      gfc_error (\"Argument C_PTR_2 at %L to C_ASSOCIATED shall have the \"\n+\t\t \"same type as C_PTR_1: %s instead of %s\", &c_ptr_1->where,\n+\t\t gfc_typename (&c_ptr_1->ts),\n+\t\t gfc_typename (&c_ptr_2->ts));\n+      return FAILURE;\n+    }\n+\n+  if (c_ptr_2 && scalar_check (c_ptr_2, 1) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n+gfc_try\n+gfc_check_c_f_pointer (gfc_expr *cptr, gfc_expr *fptr, gfc_expr *shape)\n+{\n+  symbol_attribute attr;\n+  const char *msg;\n+\n+  if (cptr->ts.type != BT_DERIVED\n+      || cptr->ts.u.derived->from_intmod != INTMOD_ISO_C_BINDING\n+      || cptr->ts.u.derived->intmod_sym_id != ISOCBINDING_PTR)\n+    {\n+      gfc_error (\"Argument CPTR at %L to C_F_POINTER shall have the \"\n+\t\t \"type TYPE(C_PTR)\", &cptr->where);\n+      return FAILURE;\n+    }\n+\n+  if (scalar_check (cptr, 0) == FAILURE)\n+    return FAILURE;\n+\n+  attr = gfc_expr_attr (fptr);\n+\n+  if (!attr.pointer)\n+    {\n+      gfc_error (\"Argument FPTR at %L to C_F_POINTER must be a pointer\",\n+\t\t &fptr->where);\n+      return FAILURE;\n+    }\n+\n+  if (fptr->ts.type == BT_CLASS)\n+    {\n+      gfc_error (\"FPTR argument at %L to C_F_POINTER shall not be polymorphic\",\n+\t\t &fptr->where);\n+      return FAILURE;\n+    }\n+\n+  if (gfc_is_coindexed (fptr))\n+    {\n+      gfc_error (\"Argument FPTR at %L to C_F_POINTER shall not be \"\n+\t\t \"coindexed\", &fptr->where);\n+      return FAILURE;\n+    }\n+\n+  if (fptr->rank == 0 && shape)\n+    {\n+      gfc_error (\"Unexpected SHAPE argument at %L to C_F_POINTER with scalar \"\n+\t\t \"FPTR\", &fptr->where);\n+      return FAILURE;\n+    }\n+  else if (fptr->rank && !shape)\n+    {\n+      gfc_error (\"Expected SHAPE argument to C_F_POINTER with array \"\n+\t\t \"FPTR at %L\", &fptr->where);\n+      return FAILURE;\n+    }\n+\n+  if (shape && rank_check (shape, 2, 1) == FAILURE)\n+    return FAILURE;\n+\n+  if (shape && type_check (shape, 2, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (shape)\n+    {\n+      mpz_t size;\n+\n+      if (gfc_array_size (shape, &size) == SUCCESS\n+\t  && mpz_cmp_ui (size, fptr->rank) != 0)\n+\t{\n+\t  mpz_clear (size);\n+\t  gfc_error (\"SHAPE argument at %L to C_F_POINTER must have the same \"\n+\t\t     \"size as the RANK of FPTR\", &shape->where);\n+\t  return FAILURE;\n+\t}\n+      mpz_clear (size);\n+    }\n+\n+  if (fptr->ts.type == BT_CLASS)\n+    {\n+      gfc_error (\"Polymorphic FPTR at %L to C_F_POINTER\", &fptr->where);\n+      return FAILURE;\n+    }\n+\n+  if (!is_c_interoperable (fptr, &msg, false) && fptr->rank)\n+    return gfc_notify_std (GFC_STD_F2008_TS, \"Noninteroperable array FPTR \"\n+\t\t\t   \"at %L to C_F_POINTER: %s\", &fptr->where, msg);\n+\n+  return SUCCESS;\n+}\n+\n+\n+gfc_try\n+gfc_check_c_f_procpointer (gfc_expr *cptr, gfc_expr *fptr)\n+{\n+  symbol_attribute attr;\n+\n+  if (cptr->ts.type != BT_DERIVED\n+      || cptr->ts.u.derived->from_intmod != INTMOD_ISO_C_BINDING\n+      || cptr->ts.u.derived->intmod_sym_id != ISOCBINDING_FUNPTR)\n+    {\n+      gfc_error (\"Argument CPTR at %L to C_F_PROCPOINTER shall have the \"\n+\t\t \"type TYPE(C_FUNPTR)\", &cptr->where);\n+      return FAILURE;\n+    }\n+\n+  if (scalar_check (cptr, 0) == FAILURE)\n+    return FAILURE;\n+\n+  attr = gfc_expr_attr (fptr);\n+\n+  if (!attr.proc_pointer)\n+    {\n+      gfc_error (\"Argument FPTR at %L to C_F_PROCPOINTER shall be a procedure \"\n+\t\t \"pointer\", &fptr->where);\n+      return FAILURE;\n+    }\n+\n+  if (gfc_is_coindexed (fptr))\n+    {\n+      gfc_error (\"Argument FPTR at %L to C_F_PROCPOINTER shall not be \"\n+\t\t \"coindexed\", &fptr->where);\n+      return FAILURE;\n+    }\n+\n+  if (!attr.is_bind_c)\n+    return gfc_notify_std (GFC_STD_F2008_TS, \"Noninteroperable procedure \"\n+\t\t\t   \"pointer at %L to C_F_PROCPOINTER\", &fptr->where);\n+\n+  return SUCCESS;\n+}\n+\n+\n+gfc_try\n+gfc_check_c_funloc (gfc_expr *x)\n+{\n+  symbol_attribute attr;\n+\n+  if (gfc_is_coindexed (x))\n+    {\n+      gfc_error (\"Argument X at %L to C_FUNLOC shall not be \"\n+\t\t \"coindexed\", &x->where);\n       return FAILURE;\n     }\n+\n+  attr = gfc_expr_attr (x);\n+\n+  if (attr.function && !attr.proc_pointer && x->expr_type == EXPR_VARIABLE\n+      && x->symtree->n.sym == x->symtree->n.sym->result)\n+    {\n+      gfc_namespace *ns = gfc_current_ns;\n+\n+      for (ns = gfc_current_ns; ns; ns = ns->parent)\n+\tif (x->symtree->n.sym == ns->proc_name)\n+\t  {\n+\t    gfc_error (\"Function result '%s' at %L is invalid as X argument \"\n+\t\t       \"to C_FUNLOC\", x->symtree->n.sym->name, &x->where);\n+\t    return FAILURE;\n+\t  }\n+    }\n+\n+  if (attr.flavor != FL_PROCEDURE)\n+    {\n+      gfc_error (\"Argument X at %L to C_FUNLOC shall be a procedure \"\n+\t\t \"or a procedure pointer\", &x->where);\n+      return FAILURE;\n+    }\n+\n+  if (!attr.is_bind_c)\n+    return gfc_notify_std (GFC_STD_F2008_TS, \"Noninteroperable procedure \"\n+\t\t\t   \"at %L to C_FUNLOC\", &x->where);\n+  return SUCCESS;\n+}\n+\n+\n+gfc_try\n+gfc_check_c_loc (gfc_expr *x)\n+{\n+  symbol_attribute attr;\n+  const char *msg;\n+\n+  if (gfc_is_coindexed (x))\n+    {\n+      gfc_error (\"Argument X at %L to C_LOC shall not be coindexed\", &x->where);\n+      return FAILURE;\n+    }\n+\n+  if (x->ts.type == BT_CLASS)\n+    {\n+      gfc_error (\"X argument at %L to C_LOC shall not be polymorphic\",\n+\t\t &x->where);\n+      return FAILURE;\n+    }\n+\n+  attr = gfc_expr_attr (x);\n+\n+  if (!attr.pointer\n+      && (x->expr_type != EXPR_VARIABLE || !attr.target\n+\t  || attr.flavor == FL_PARAMETER))\n+    {\n+      gfc_error (\"Argument X at %L to C_LOC shall have either \"\n+\t\t \"the POINTER or the TARGET attribute\", &x->where);\n+      return FAILURE;\n+    }\n+\n+  if (x->ts.type == BT_CHARACTER\n+      && gfc_var_strlen (x) == 0)\n+    {\n+      gfc_error (\"Argument X at %L to C_LOC shall be not be a zero-sized \"\n+\t\t \"string\", &x->where);\n+      return FAILURE;\n+    }\n+\n+  if (!is_c_interoperable (x, &msg, true))\n+    {\n+      if (x->ts.type == BT_CLASS)\n+\t{\n+\t  gfc_error (\"Argument at %L to C_LOC shall not be polymorphic\",\n+\t\t     &x->where);\n+\t  return FAILURE;\n+\t}\n+     \n+      if (x->rank\n+\t  && gfc_notify_std (GFC_STD_F2008_TS, \"Noninteroperable array at %L as\"\n+\t\t\t \" argument to C_LOC: %s\", &x->where, msg) == FAILURE)\n+\t  return FAILURE;\n+    }\n+\n   return SUCCESS;\n }\n "}, {"sha": "8deb4ebf05d757a1c6756bb38e256c908c0f6372", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -2256,7 +2256,7 @@ check_inquiry (gfc_expr *e, int not_restricted)\n     \"new_line\", NULL\n   };\n \n-  int i;\n+  int i = 0;\n   gfc_actual_arglist *ap;\n \n   if (!e->value.function.isym\n@@ -2267,17 +2267,31 @@ check_inquiry (gfc_expr *e, int not_restricted)\n   if (e->symtree == NULL)\n     return MATCH_NO;\n \n-  name = e->symtree->n.sym->name;\n+  if (e->symtree->n.sym->from_intmod)\n+    {\n+      if (e->symtree->n.sym->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t  && e->symtree->n.sym->intmod_sym_id != ISOFORTRAN_COMPILER_OPTIONS\n+\t  && e->symtree->n.sym->intmod_sym_id != ISOFORTRAN_COMPILER_VERSION)\n+\treturn MATCH_NO;\n+\n+      if (e->symtree->n.sym->from_intmod == INTMOD_ISO_C_BINDING\n+\t  && e->symtree->n.sym->intmod_sym_id != ISOCBINDING_C_SIZEOF)\n+\treturn MATCH_NO;\n+    }\n+  else\n+    {\n+      name = e->symtree->n.sym->name;\n \n-  functions = (gfc_option.warn_std & GFC_STD_F2003)\n+      functions = (gfc_option.warn_std & GFC_STD_F2003)\n \t\t? inquiry_func_f2003 : inquiry_func_f95;\n \n-  for (i = 0; functions[i]; i++)\n-    if (strcmp (functions[i], name) == 0)\n-      break;\n+      for (i = 0; functions[i]; i++)\n+\tif (strcmp (functions[i], name) == 0)\n+\t  break;\n \n-  if (functions[i] == NULL)\n-    return MATCH_ERROR;\n+\tif (functions[i] == NULL)\n+\t  return MATCH_ERROR;\n+    }\n \n   /* At this point we have an inquiry function with a variable argument.  The\n      type of the variable might be undefined, but we need it now, because the\n@@ -3429,13 +3443,18 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t      attr = gfc_expr_attr (rvalue);\n \t    }\n \t  /* Check for result of embracing function.  */\n-\t  if (sym == gfc_current_ns->proc_name\n-\t      && sym->attr.function && sym->result == sym)\n+\t  if (sym->attr.function && sym->result == sym)\n \t    {\n-\t      gfc_error (\"Function result '%s' is invalid as proc-target \"\n-\t\t\t \"in procedure pointer assignment at %L\",\n-\t\t\t sym->name, &rvalue->where);\n-\t      return FAILURE;\n+\t      gfc_namespace *ns;\n+\n+\t      for (ns = gfc_current_ns; ns; ns = ns->parent)\n+\t\tif (sym == ns->proc_name)\n+\t\t  {\n+\t\t    gfc_error (\"Function result '%s' is invalid as proc-target \"\n+\t\t\t       \"in procedure pointer assignment at %L\",\n+\t\t\t       sym->name, &rvalue->where);\n+\t\t    return FAILURE;\n+\t\t  }\n \t    }\n \t}\n       if (attr.abstract)"}, {"sha": "f28a99a78bf78b61c957458a33f45bd105bcc3ba", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -343,6 +343,11 @@ enum gfc_isym_id\n   GFC_ISYM_CPU_TIME,\n   GFC_ISYM_CSHIFT,\n   GFC_ISYM_CTIME,\n+  GFC_ISYM_C_ASSOCIATED,\n+  GFC_ISYM_C_F_POINTER,\n+  GFC_ISYM_C_F_PROCPOINTER,\n+  GFC_ISYM_C_FUNLOC,\n+  GFC_ISYM_C_LOC,\n   GFC_ISYM_C_SIZEOF,\n   GFC_ISYM_DATE_AND_TIME,\n   GFC_ISYM_DBLE,\n@@ -610,6 +615,7 @@ gfc_reverse;\n #define NAMED_INTCST(a,b,c,d) a,\n #define NAMED_KINDARRAY(a,b,c,d) a,\n #define NAMED_FUNCTION(a,b,c,d) a,\n+#define NAMED_SUBROUTINE(a,b,c,d) a,\n #define NAMED_DERIVED_TYPE(a,b,c,d) a,\n typedef enum\n {\n@@ -621,6 +627,7 @@ iso_fortran_env_symbol;\n #undef NAMED_INTCST\n #undef NAMED_KINDARRAY\n #undef NAMED_FUNCTION\n+#undef NAMED_SUBROUTINE\n #undef NAMED_DERIVED_TYPE\n \n #define NAMED_INTCST(a,b,c,d) a,\n@@ -630,8 +637,8 @@ iso_fortran_env_symbol;\n #define NAMED_CHARKNDCST(a,b,c) a,\n #define NAMED_CHARCST(a,b,c) a,\n #define DERIVED_TYPE(a,b,c) a,\n-#define PROCEDURE(a,b) a,\n #define NAMED_FUNCTION(a,b,c,d) a,\n+#define NAMED_SUBROUTINE(a,b,c,d) a,\n typedef enum\n {\n   ISOCBINDING_INVALID = -1,\n@@ -647,8 +654,8 @@ iso_c_binding_symbol;\n #undef NAMED_CHARKNDCST\n #undef NAMED_CHARCST\n #undef DERIVED_TYPE\n-#undef PROCEDURE\n #undef NAMED_FUNCTION\n+#undef NAMED_SUBROUTINE\n \n typedef enum\n {\n@@ -2635,8 +2642,8 @@ gfc_try gfc_verify_c_interop_param (gfc_symbol *);\n gfc_try verify_bind_c_sym (gfc_symbol *, gfc_typespec *, int, gfc_common_head *);\n gfc_try verify_bind_c_derived_type (gfc_symbol *);\n gfc_try verify_com_block_vars_c_interop (gfc_common_head *);\n-void generate_isocbinding_symbol (const char *, iso_c_binding_symbol, const char *);\n-gfc_symbol *get_iso_c_sym (gfc_symbol *, char *, const char *, int);\n+gfc_symtree *generate_isocbinding_symbol (const char *, iso_c_binding_symbol,\n+\t\t\t\t\t  const char *, gfc_symtree *, bool);\n int gfc_get_sym_tree (const char *, gfc_namespace *, gfc_symtree **, bool);\n int gfc_get_ha_symbol (const char *, gfc_symbol **);\n int gfc_get_ha_sym_tree (const char *, gfc_symtree **);\n@@ -2707,6 +2714,10 @@ int gfc_intrinsic_actual_ok (const char *, const bool);\n gfc_intrinsic_sym *gfc_find_function (const char *);\n gfc_intrinsic_sym *gfc_find_subroutine (const char *);\n gfc_intrinsic_sym *gfc_intrinsic_function_by_id (gfc_isym_id);\n+gfc_intrinsic_sym *gfc_intrinsic_subroutine_by_id (gfc_isym_id);\n+gfc_isym_id gfc_isym_id_by_intmod (intmod_id, int);\n+gfc_isym_id gfc_isym_id_by_intmod_sym (gfc_symbol *);\n+\n \n match gfc_intrinsic_func_interface (gfc_expr *, int);\n match gfc_intrinsic_sub_interface (gfc_code *, int);"}, {"sha": "358c33e02b7acf79e4c0831454b085bd9423d944", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 100, "deletions": 7, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -810,6 +810,57 @@ find_sym (gfc_intrinsic_sym *start, int n, const char *name)\n }\n \n \n+gfc_isym_id\n+gfc_isym_id_by_intmod (intmod_id from_intmod, int intmod_sym_id)\n+{\n+  if (from_intmod == INTMOD_ISO_C_BINDING)\n+    return (gfc_isym_id) c_interop_kinds_table[intmod_sym_id].value;\n+  else if (from_intmod == INTMOD_ISO_FORTRAN_ENV)\n+    switch (intmod_sym_id)\n+      {\n+#define NAMED_SUBROUTINE(a,b,c,d) \\\n+      case a: \\\n+\treturn (gfc_isym_id) c;\n+#define NAMED_FUNCTION(a,b,c,d) \\\n+      case a: \\\n+\treturn (gfc_isym_id) c;\n+#include \"iso-fortran-env.def\"\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  else\n+    {\n+      gcc_unreachable ();\n+    }\n+  return (gfc_isym_id) 0;\n+}\n+\n+\n+gfc_isym_id\n+gfc_isym_id_by_intmod_sym (gfc_symbol *sym)\n+{\n+  return gfc_isym_id_by_intmod (sym->from_intmod, sym->intmod_sym_id);\n+}\n+\n+\n+gfc_intrinsic_sym *\n+gfc_intrinsic_subroutine_by_id (gfc_isym_id id)\n+{\n+  gfc_intrinsic_sym *start = subroutines;\n+  int n = nsub;\n+\n+  while (true)\n+    {\n+      gcc_assert (n > 0);\n+      if (id == start->id)\n+\treturn start;\n+\n+      start++;\n+      n--;\n+    }\n+}\n+\n+\n gfc_intrinsic_sym *\n gfc_intrinsic_function_by_id (gfc_isym_id id)\n {\n@@ -2652,9 +2703,28 @@ add_functions (void)\n \n   make_generic (\"sizeof\", GFC_ISYM_SIZEOF, GFC_STD_GNU);\n \n-  /* C_SIZEOF is part of ISO_C_BINDING.  */\n+  /* The following functions are part of ISO_C_BINDING.  */\n+  add_sym_2 (\"c_associated\", GFC_ISYM_C_ASSOCIATED, CLASS_INQUIRY, ACTUAL_NO,\n+\t     BT_LOGICAL, dl, GFC_STD_F2003, gfc_check_c_associated, NULL, NULL,\n+\t     \"C_PTR_1\", BT_VOID, 0, REQUIRED,\n+\t     \"C_PTR_2\", BT_VOID, 0, OPTIONAL);\n+  make_from_module();\n+\n+  add_sym_1 (\"c_loc\", GFC_ISYM_C_LOC, CLASS_INQUIRY, ACTUAL_NO,\n+\t     BT_VOID, 0, GFC_STD_F2003,\n+\t     gfc_check_c_loc, NULL, gfc_resolve_c_loc,\n+\t     x, BT_UNKNOWN, 0, REQUIRED);\n+  make_from_module();\n+\n+  add_sym_1 (\"c_funloc\", GFC_ISYM_C_FUNLOC, CLASS_INQUIRY, ACTUAL_NO,\n+\t     BT_VOID, 0, GFC_STD_F2003,\n+\t     gfc_check_c_funloc, NULL, gfc_resolve_c_funloc,\n+\t     x, BT_UNKNOWN, 0, REQUIRED);\n+  make_from_module();\n+\n   add_sym_1 (\"c_sizeof\", GFC_ISYM_C_SIZEOF, CLASS_INQUIRY, ACTUAL_NO,\n-\t     BT_INTEGER, ii, GFC_STD_F2008, gfc_check_c_sizeof, NULL, NULL,\n+\t     BT_INTEGER, gfc_index_integer_kind, GFC_STD_F2008,\n+\t     gfc_check_c_sizeof, NULL, NULL,\n \t     x, BT_UNKNOWN, 0, REQUIRED);\n   make_from_module();\n \n@@ -3056,6 +3126,22 @@ add_subroutines (void)\n \t      pt, BT_INTEGER, di, OPTIONAL, INTENT_IN,\n \t      gt, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n \n+  /* The following subroutines are part of ISO_C_BINDING.  */\n+\n+  add_sym_3s (\"c_f_pointer\", GFC_ISYM_C_F_POINTER, CLASS_IMPURE, BT_UNKNOWN, 0,\n+\t      GFC_STD_F2003, gfc_check_c_f_pointer, NULL, NULL,\n+\t      \"cptr\", BT_VOID, 0, REQUIRED, INTENT_IN,\n+\t      \"fptr\", BT_UNKNOWN, 0, REQUIRED, INTENT_OUT,\n+\t      \"shape\", BT_INTEGER, di, OPTIONAL, INTENT_IN);\n+  make_from_module();\n+\n+  add_sym_2s (\"c_f_procpointer\", GFC_ISYM_C_F_PROCPOINTER, CLASS_IMPURE,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2003, gfc_check_c_f_procpointer,\n+\t      NULL, NULL,\n+\t      \"cptr\", BT_VOID, 0, REQUIRED, INTENT_IN,\n+\t      \"fptr\", BT_UNKNOWN, 0, REQUIRED, INTENT_OUT);\n+  make_from_module();\n+\n   /* More G77 compatibility garbage.  */\n   add_sym_3s (\"alarm\", GFC_ISYM_ALARM, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      gfc_check_alarm_sub, NULL, gfc_resolve_alarm_sub,\n@@ -4078,8 +4164,8 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n \n   if (expr->symtree->n.sym->intmod_sym_id)\n     {\n-      int id = expr->symtree->n.sym->intmod_sym_id;\n-      isym = specific = gfc_intrinsic_function_by_id ((gfc_isym_id) id);\n+      gfc_isym_id id = gfc_isym_id_by_intmod_sym (expr->symtree->n.sym);\n+      isym = specific = gfc_intrinsic_function_by_id (id);\n     }\n   else\n     isym = specific = gfc_find_function (name);\n@@ -4105,12 +4191,12 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n \n   gfc_current_intrinsic_where = &expr->where;\n \n-  /* Bypass the generic list for min and max.  */\n+  /* Bypass the generic list for min, max and ISO_C_Binding's c_loc.  */\n   if (isym->check.f1m == gfc_check_min_max)\n     {\n       init_arglist (isym);\n \n-      if (gfc_check_min_max (expr->value.function.actual) == SUCCESS)\n+      if (isym->check.f1m (expr->value.function.actual) == SUCCESS)\n \tgoto got_specific;\n \n       if (!error_flag)\n@@ -4192,7 +4278,14 @@ gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n \n   name = c->symtree->n.sym->name;\n \n-  isym = gfc_find_subroutine (name);\n+  if (c->symtree->n.sym->intmod_sym_id)\n+    {\n+      gfc_isym_id id;\n+      id = gfc_isym_id_by_intmod_sym (c->symtree->n.sym);\n+      isym = gfc_intrinsic_subroutine_by_id (id);\n+    }\n+  else\n+    isym = gfc_find_subroutine (name);\n   if (isym == NULL)\n     return MATCH_NO;\n "}, {"sha": "0f9b50c8d1dc463f3cab32ab026e6f6dbdf3a4e1", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -143,6 +143,11 @@ gfc_try gfc_check_size (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_sign (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_signal (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_sizeof (gfc_expr *);\n+gfc_try gfc_check_c_associated (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_c_f_pointer (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_c_f_procpointer (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_c_funloc (gfc_expr *);\n+gfc_try gfc_check_c_loc (gfc_expr *);\n gfc_try gfc_check_c_sizeof (gfc_expr *);\n gfc_try gfc_check_sngl (gfc_expr *);\n gfc_try gfc_check_spread (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -421,6 +426,8 @@ void gfc_resolve_atomic_ref (gfc_code *);\n void gfc_resolve_besn (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_bessel_n2 (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *a);\n void gfc_resolve_btest (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_c_loc (gfc_expr *, gfc_expr *);\n+void gfc_resolve_c_funloc (gfc_expr *, gfc_expr *);\n void gfc_resolve_ceiling (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_char (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_chdir (gfc_expr *, gfc_expr *);"}, {"sha": "2b92b7c2bc66d7e856c966482af64987ee11d103", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -500,6 +500,20 @@ gfc_resolve_btest (gfc_expr *f, gfc_expr *i, gfc_expr *pos)\n }\n \n \n+void\n+gfc_resolve_c_loc (gfc_expr *f, gfc_expr *x ATTRIBUTE_UNUSED)\n+{\n+  f->ts = f->value.function.isym->ts;\n+}\n+\n+\n+void\n+gfc_resolve_c_funloc (gfc_expr *f, gfc_expr *x ATTRIBUTE_UNUSED)\n+{\n+  f->ts = f->value.function.isym->ts;\n+}\n+\n+\n void\n gfc_resolve_ceiling (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {"}, {"sha": "c36a4786083165b005b5e1d1dfd1658ebd1a3f8b", "filename": "gcc/fortran/iso-c-binding.def", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fiso-c-binding.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fiso-c-binding.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-c-binding.def?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -43,6 +43,10 @@ along with GCC; see the file COPYING3.  If not see\n # define NAMED_FUNCTION(a,b,c,d)\n #endif\n \n+#ifndef NAMED_SUBROUTINE\n+# define NAMED_SUBROUTINE(a,b,c,d)\n+#endif\n+\n /* The arguments to NAMED_*CST are:\n      -- an internal name\n      -- the symbol name in the module, as seen by Fortran code\n@@ -165,32 +169,32 @@ DERIVED_TYPE (ISOCBINDING_FUNPTR, \"c_funptr\", \\\n DERIVED_TYPE (ISOCBINDING_NULL_FUNPTR, \"c_null_funptr\", \\\n               get_int_kind_from_node (ptr_type_node))\n \n-  \n-#ifndef PROCEDURE\n-# define PROCEDURE(a,b) \n-#endif\n-\n-PROCEDURE (ISOCBINDING_F_POINTER, \"c_f_pointer\")\n-PROCEDURE (ISOCBINDING_ASSOCIATED, \"c_associated\")\n-PROCEDURE (ISOCBINDING_LOC, \"c_loc\")\n-PROCEDURE (ISOCBINDING_FUNLOC, \"c_funloc\")\n-PROCEDURE (ISOCBINDING_F_PROCPOINTER, \"c_f_procpointer\")\n-\n-/* The arguments to NAMED_FUNCTIONS are:\n+/* The arguments to NAMED_FUNCTIONS and NAMED_SUBROUTINES are:\n      -- the ISYM\n      -- the symbol name in the module, as seen by Fortran code\n      -- the Fortran standard  */\n \n+NAMED_SUBROUTINE (ISOCBINDING_F_POINTER, \"c_f_pointer\",\n+                  GFC_ISYM_C_F_POINTER, GFC_STD_F2003)\n+NAMED_SUBROUTINE (ISOCBINDING_F_PROCPOINTER, \"c_f_procpointer\",\n+                  GFC_ISYM_C_F_PROCPOINTER, GFC_STD_F2003)\n+\n+NAMED_FUNCTION (ISOCBINDING_ASSOCIATED, \"c_associated\",\n+\t\tGFC_ISYM_C_ASSOCIATED, GFC_STD_F2003)\n+NAMED_FUNCTION (ISOCBINDING_FUNLOC, \"c_funloc\",\n+                GFC_ISYM_C_FUNLOC, GFC_STD_F2003)\n+NAMED_FUNCTION (ISOCBINDING_LOC, \"c_loc\",\n+                GFC_ISYM_C_LOC, GFC_STD_F2003)\n+\n NAMED_FUNCTION (ISOCBINDING_C_SIZEOF, \"c_sizeof\", \\\n                 GFC_ISYM_C_SIZEOF, GFC_STD_F2008)\n \n-\n #undef NAMED_INTCST\n #undef NAMED_REALCST\n #undef NAMED_CMPXCST\n #undef NAMED_LOGCST\n #undef NAMED_CHARCST\n #undef NAMED_CHARKNDCST\n #undef DERIVED_TYPE\n-#undef PROCEDURE\n #undef NAMED_FUNCTION\n+#undef NAMED_SUBROUTINE"}, {"sha": "13ddaa31603737549d94ec0e2684203ad382336b", "filename": "gcc/fortran/iso-fortran-env.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fiso-fortran-env.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fiso-fortran-env.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-fortran-env.def?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -27,6 +27,10 @@ along with GCC; see the file COPYING3.  If not see\n # define NAMED_KINDARRAY(a,b,c,d)\n #endif\n \n+#ifndef NAMED_SUBROUTINE\n+# define NAMED_SUBROUTINE(a,b,c,d)\n+#endif\n+\n #ifndef NAMED_FUNCTION\n # define NAMED_FUNCTION(a,b,c,d)\n #endif\n@@ -120,4 +124,5 @@ NAMED_DERIVED_TYPE (ISOFORTRAN_LOCK_TYPE, \"lock_type\", \\\n #undef NAMED_INTCST\n #undef NAMED_KINDARRAY\n #undef NAMED_FUNCTION\n+#undef NAMED_SUBROUTINE\n #undef NAMED_DERIVED_TYPE"}, {"sha": "ee09291ec7622f98af3a5c723eb477f7a0747ffa", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 154, "deletions": 52, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -5570,8 +5570,9 @@ gfc_dump_module (const char *name, int dump_flag)\n \n \n static void\n-create_intrinsic_function (const char *name, gfc_isym_id id,\n-\t\t\t   const char *modname, intmod_id module)\n+create_intrinsic_function (const char *name, int id,\n+\t\t\t   const char *modname, intmod_id module,\n+\t\t\t   bool subroutine, gfc_symbol *result_type)\n {\n   gfc_intrinsic_sym *isym;\n   gfc_symtree *tmp_symtree;\n@@ -5588,7 +5589,30 @@ create_intrinsic_function (const char *name, gfc_isym_id id,\n   gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n   sym = tmp_symtree->n.sym;\n \n-  isym = gfc_intrinsic_function_by_id (id);\n+  if (subroutine)\n+    {\n+      gfc_isym_id isym_id = gfc_isym_id_by_intmod (module, id);\n+      isym = gfc_intrinsic_subroutine_by_id (isym_id);\n+      sym->attr.subroutine = 1;\n+    }\n+  else\n+    {\n+      gfc_isym_id isym_id = gfc_isym_id_by_intmod (module, id);\n+      isym = gfc_intrinsic_function_by_id (isym_id);\n+\n+      sym->attr.function = 1;\n+      if (result_type)\n+\t{\n+\t  sym->ts.type = BT_DERIVED;\n+\t  sym->ts.u.derived = result_type;\n+\t  sym->ts.is_c_interop = 1;\n+\t  isym->ts.f90_type = BT_VOID;\n+\t  isym->ts.type = BT_DERIVED;\n+\t  isym->ts.f90_type = BT_VOID;\n+\t  isym->ts.u.derived = result_type;\n+\t  isym->ts.is_c_interop = 1;\n+\t}\n+    }\n   gcc_assert (isym);\n \n   sym->attr.flavor = FL_PROCEDURE;\n@@ -5609,11 +5633,13 @@ create_intrinsic_function (const char *name, gfc_isym_id id,\n static void\n import_iso_c_binding_module (void)\n {\n-  gfc_symbol *mod_sym = NULL;\n-  gfc_symtree *mod_symtree = NULL;\n+  gfc_symbol *mod_sym = NULL, *return_type;\n+  gfc_symtree *mod_symtree = NULL, *tmp_symtree;\n+  gfc_symtree *c_ptr = NULL, *c_funptr = NULL;\n   const char *iso_c_module_name = \"__iso_c_binding\";\n   gfc_use_rename *u;\n   int i;\n+  bool want_c_ptr = false, want_c_funptr = false;\n \n   /* Look only in the current namespace.  */\n   mod_symtree = gfc_find_symtree (gfc_current_ns->sym_root, iso_c_module_name);\n@@ -5636,6 +5662,57 @@ import_iso_c_binding_module (void)\n       mod_sym->from_intmod = INTMOD_ISO_C_BINDING;\n     }\n \n+  /* Check whether C_PTR or C_FUNPTR are in the include list, if so, load it;\n+     check also whether C_NULL_(FUN)PTR or C_(FUN)LOC are requested, which\n+     need C_(FUN)PTR.  */\n+  for (u = gfc_rename_list; u; u = u->next)\n+    {\n+      if (strcmp (c_interop_kinds_table[ISOCBINDING_NULL_PTR].name,\n+\t\t  u->use_name) == 0)\n+        want_c_ptr = true;\n+      else if (strcmp (c_interop_kinds_table[ISOCBINDING_LOC].name,\n+\t\t       u->use_name) == 0)\n+        want_c_ptr = true;\n+      else if (strcmp (c_interop_kinds_table[ISOCBINDING_NULL_FUNPTR].name,\n+\t\t       u->use_name) == 0)\n+        want_c_funptr = true;\n+      else if (strcmp (c_interop_kinds_table[ISOCBINDING_FUNLOC].name,\n+\t\t       u->use_name) == 0)\n+        want_c_funptr = true;\n+      else if (strcmp (c_interop_kinds_table[ISOCBINDING_PTR].name,\n+                       u->use_name) == 0)\n+\t{\n+\t  c_ptr = generate_isocbinding_symbol (iso_c_module_name,\n+                                               (iso_c_binding_symbol)\n+\t\t\t\t\t\t\tISOCBINDING_PTR,\n+                                               u->local_name[0] ? u->local_name\n+                                                                : u->use_name,\n+                                               NULL, false);\n+\t}\n+      else if (strcmp (c_interop_kinds_table[ISOCBINDING_FUNPTR].name,\n+                       u->use_name) == 0)\n+\t{\n+\t  c_funptr\n+\t     = generate_isocbinding_symbol (iso_c_module_name,\n+\t\t\t\t\t    (iso_c_binding_symbol)\n+\t\t\t\t\t\t\tISOCBINDING_FUNPTR,\n+\t\t\t\t\t     u->local_name[0] ? u->local_name\n+\t\t\t\t\t\t\t      : u->use_name,\n+\t\t\t\t\t     NULL, false);\n+\t}\n+    }\n+\n+  if ((want_c_ptr || !only_flag) && !c_ptr)\n+    c_ptr = generate_isocbinding_symbol (iso_c_module_name,\n+\t\t\t\t\t (iso_c_binding_symbol)\n+\t\t\t\t\t\t\tISOCBINDING_PTR,\n+\t\t\t\t\t NULL, NULL, only_flag);\n+  if ((want_c_funptr || !only_flag) && !c_funptr)\n+    c_funptr = generate_isocbinding_symbol (iso_c_module_name,\n+\t\t\t\t\t    (iso_c_binding_symbol)\n+\t\t\t\t\t\t\tISOCBINDING_FUNPTR,\n+\t\t\t\t\t    NULL, NULL, only_flag);\n+\n   /* Generate the symbols for the named constants representing\n      the kinds for intrinsic data types.  */\n   for (i = 0; i < ISOCBINDING_NUMBER; i++)\n@@ -5656,29 +5733,27 @@ import_iso_c_binding_module (void)\n \t\t  not_in_std = (gfc_option.allow_std & d) == 0; \\\n \t\t  name = b; \\\n \t\t  break;\n-#include \"iso-c-binding.def\"\n-#undef NAMED_FUNCTION\n+#define NAMED_SUBROUTINE(a,b,c,d) \\\n+\t        case a: \\\n+\t\t  not_in_std = (gfc_option.allow_std & d) == 0; \\\n+\t\t  name = b; \\\n+\t\t  break;\n #define NAMED_INTCST(a,b,c,d) \\\n \t        case a: \\\n \t\t  not_in_std = (gfc_option.allow_std & d) == 0; \\\n \t\t  name = b; \\\n \t\t  break;\n-#include \"iso-c-binding.def\"\n-#undef NAMED_INTCST\n #define NAMED_REALCST(a,b,c,d) \\\n \t        case a: \\\n \t\t  not_in_std = (gfc_option.allow_std & d) == 0; \\\n \t\t  name = b; \\\n \t\t  break;\n-#include \"iso-c-binding.def\"\n-#undef NAMED_REALCST\n #define NAMED_CMPXCST(a,b,c,d) \\\n \t        case a: \\\n \t\t  not_in_std = (gfc_option.allow_std & d) == 0; \\\n \t\t  name = b; \\\n \t\t  break;\n #include \"iso-c-binding.def\"\n-#undef NAMED_CMPXCST\n \t\tdefault:\n \t\t  not_in_std = false;\n \t\t  name = \"\";\n@@ -5694,21 +5769,44 @@ import_iso_c_binding_module (void)\n \t    switch (i)\n \t      {\n #define NAMED_FUNCTION(a,b,c,d) \\\n+\t        case a: \\\n+\t\t  if (a == ISOCBINDING_LOC) \\\n+\t\t    return_type = c_ptr->n.sym; \\\n+\t\t  else if (a == ISOCBINDING_FUNLOC) \\\n+\t\t    return_type = c_funptr->n.sym; \\\n+\t\t  else \\\n+\t\t    return_type = NULL; \\\n+\t\t  create_intrinsic_function (u->local_name[0] \\\n+\t\t\t\t\t     ? u->local_name : u->use_name, \\\n+\t\t\t\t\t     a, iso_c_module_name, \\\n+\t\t\t\t\t     INTMOD_ISO_C_BINDING, false, \\\n+\t\t\t\t\t     return_type); \\\n+\t\t  break;\n+#define NAMED_SUBROUTINE(a,b,c,d) \\\n \t        case a: \\\n \t\t  create_intrinsic_function (u->local_name[0] ? u->local_name \\\n \t\t\t\t\t\t\t      : u->use_name, \\\n-\t\t\t\t\t     (gfc_isym_id) c, \\\n-                                             iso_c_module_name, \\\n-                                             INTMOD_ISO_C_BINDING); \\\n+                                             a, iso_c_module_name, \\\n+                                             INTMOD_ISO_C_BINDING, true, NULL); \\\n \t\t  break;\n #include \"iso-c-binding.def\"\n-#undef NAMED_FUNCTION\n \n+\t\tcase ISOCBINDING_PTR:\n+\t\tcase ISOCBINDING_FUNPTR:\n+\t\t  /* Already handled above.  */\n+\t\t  break;\n \t\tdefault:\n+\t\t  if (i == ISOCBINDING_NULL_PTR)\n+\t\t    tmp_symtree = c_ptr;\n+\t\t  else if (i == ISOCBINDING_NULL_FUNPTR)\n+\t\t    tmp_symtree = c_funptr;\n+\t\t  else\n+\t\t    tmp_symtree = NULL;\n \t\t  generate_isocbinding_symbol (iso_c_module_name,\n \t\t\t\t\t       (iso_c_binding_symbol) i,\n-\t\t\t\t\t       u->local_name[0] ? u->local_name\n-\t\t\t\t\t\t\t\t: u->use_name);\n+\t\t\t\t\t       u->local_name[0]\n+\t\t\t\t\t       ? u->local_name : u->use_name,\n+\t\t\t\t\t       tmp_symtree, false);\n \t      }\n \t  }\n \n@@ -5722,30 +5820,27 @@ import_iso_c_binding_module (void)\n \t\tif ((gfc_option.allow_std & d) == 0) \\\n \t\t  continue; \\\n \t\tbreak;\n-#include \"iso-c-binding.def\"\n-#undef NAMED_FUNCTION\n-\n+#define NAMED_SUBROUTINE(a,b,c,d) \\\n+\t      case a: \\\n+\t\tif ((gfc_option.allow_std & d) == 0) \\\n+\t\t  continue; \\\n+\t\tbreak;\n #define NAMED_INTCST(a,b,c,d) \\\n \t      case a: \\\n \t\tif ((gfc_option.allow_std & d) == 0) \\\n \t\t  continue; \\\n \t\tbreak;\n-#include \"iso-c-binding.def\"\n-#undef NAMED_INTCST\n #define NAMED_REALCST(a,b,c,d) \\\n \t      case a: \\\n \t\tif ((gfc_option.allow_std & d) == 0) \\\n \t\t  continue; \\\n \t\tbreak;\n-#include \"iso-c-binding.def\"\n-#undef NAMED_REALCST\n #define NAMED_CMPXCST(a,b,c,d) \\\n \t      case a: \\\n \t\tif ((gfc_option.allow_std & d) == 0) \\\n \t\t  continue; \\\n \t\tbreak;\n #include \"iso-c-binding.def\"\n-#undef NAMED_CMPXCST\n \t      default:\n \t\t; /* Not GFC_STD_* versioned. */\n \t    }\n@@ -5754,16 +5849,37 @@ import_iso_c_binding_module (void)\n \t    {\n #define NAMED_FUNCTION(a,b,c,d) \\\n \t      case a: \\\n-\t\tcreate_intrinsic_function (b, (gfc_isym_id) c, \\\n-\t\t\t\t\t   iso_c_module_name, \\\n-\t\t\t\t\t   INTMOD_ISO_C_BINDING); \\\n+\t\tif (a == ISOCBINDING_LOC) \\\n+\t\t  return_type = c_ptr->n.sym; \\\n+\t\telse if (a == ISOCBINDING_FUNLOC) \\\n+\t\t  return_type = c_funptr->n.sym; \\\n+\t\telse \\\n+\t\t  return_type = NULL; \\\n+\t\tcreate_intrinsic_function (b, a, iso_c_module_name, \\\n+\t\t\t\t\t   INTMOD_ISO_C_BINDING, false, \\\n+\t\t\t\t\t   return_type); \\\n+\t\tbreak;\n+#define NAMED_SUBROUTINE(a,b,c,d) \\\n+\t      case a: \\\n+\t\tcreate_intrinsic_function (b, a, iso_c_module_name, \\\n+\t\t\t\t\t   INTMOD_ISO_C_BINDING, true, NULL); \\\n \t\t  break;\n #include \"iso-c-binding.def\"\n-#undef NAMED_FUNCTION\n \n+\t      case ISOCBINDING_PTR:\n+\t      case ISOCBINDING_FUNPTR:\n+\t\t/* Already handled above.  */\n+\t\tbreak;\n \t      default:\n+\t\tif (i == ISOCBINDING_NULL_PTR)\n+\t\t  tmp_symtree = c_ptr;\n+\t\telse if (i == ISOCBINDING_NULL_FUNPTR)\n+\t\t  tmp_symtree = c_funptr;\n+\t\telse\n+\t\t  tmp_symtree = NULL;\n \t\tgenerate_isocbinding_symbol (iso_c_module_name,\n-\t\t\t\t\t     (iso_c_binding_symbol) i, NULL);\n+\t\t\t\t\t     (iso_c_binding_symbol) i, NULL,\n+\t\t\t\t\t     tmp_symtree, false);\n \t    }\n \t}\n    }\n@@ -5917,23 +6033,16 @@ use_iso_fortran_env_module (void)\n \n   intmod_sym symbol[] = {\n #define NAMED_INTCST(a,b,c,d) { a, b, 0, d },\n-#include \"iso-fortran-env.def\"\n-#undef NAMED_INTCST\n #define NAMED_KINDARRAY(a,b,c,d) { a, b, 0, d },\n-#include \"iso-fortran-env.def\"\n-#undef NAMED_KINDARRAY\n #define NAMED_DERIVED_TYPE(a,b,c,d) { a, b, 0, d },\n-#include \"iso-fortran-env.def\"\n-#undef NAMED_DERIVED_TYPE\n #define NAMED_FUNCTION(a,b,c,d) { a, b, c, d },\n+#define NAMED_SUBROUTINE(a,b,c,d) { a, b, c, d },\n #include \"iso-fortran-env.def\"\n-#undef NAMED_FUNCTION\n     { ISOFORTRANENV_INVALID, NULL, -1234, 0 } };\n \n   i = 0;\n #define NAMED_INTCST(a,b,c,d) symbol[i++].value = c;\n #include \"iso-fortran-env.def\"\n-#undef NAMED_INTCST\n \n   /* Generate the symbol for the module itself.  */\n   mod_symtree = gfc_find_symtree (gfc_current_ns->sym_root, mod);\n@@ -5985,7 +6094,6 @@ use_iso_fortran_env_module (void)\n #define NAMED_INTCST(a,b,c,d) \\\n \t\tcase a:\n #include \"iso-fortran-env.def\"\n-#undef NAMED_INTCST\n \t\t  create_int_parameter (u->local_name[0] ? u->local_name\n \t\t\t\t\t\t\t : u->use_name,\n \t\t\t\t\tsymbol[i].value, mod,\n@@ -6008,7 +6116,6 @@ use_iso_fortran_env_module (void)\n \t\t\t\t\t      symbol[i].id); \\\n \t\t  break;\n #include \"iso-fortran-env.def\"\n-#undef NAMED_KINDARRAY\n \n #define NAMED_DERIVED_TYPE(a,b,TYPE,STD) \\\n \t\tcase a:\n@@ -6018,16 +6125,15 @@ use_iso_fortran_env_module (void)\n \t\t\t\t       mod, INTMOD_ISO_FORTRAN_ENV,\n \t\t\t\t       symbol[i].id);\n \t\t  break;\n-#undef NAMED_DERIVED_TYPE\n \n #define NAMED_FUNCTION(a,b,c,d) \\\n \t\tcase a:\n #include \"iso-fortran-env.def\"\n-#undef NAMED_FUNCTION\n \t\t  create_intrinsic_function (u->local_name[0] ? u->local_name\n \t\t\t\t\t\t\t      : u->use_name,\n-\t\t\t\t\t     (gfc_isym_id) symbol[i].value, mod,\n-\t\t\t\t\t     INTMOD_ISO_FORTRAN_ENV);\n+\t\t\t\t\t     symbol[i].id, mod,\n+\t\t\t\t\t     INTMOD_ISO_FORTRAN_ENV, false,\n+\t\t\t\t\t     NULL);\n \t\t  break;\n \n \t\tdefault:\n@@ -6054,7 +6160,6 @@ use_iso_fortran_env_module (void)\n #define NAMED_INTCST(a,b,c,d) \\\n \t    case a:\n #include \"iso-fortran-env.def\"\n-#undef NAMED_INTCST\n \t      create_int_parameter (symbol[i].name, symbol[i].value, mod,\n \t\t\t\t    INTMOD_ISO_FORTRAN_ENV, symbol[i].id);\n \t      break;\n@@ -6071,23 +6176,20 @@ use_iso_fortran_env_module (void)\n                                         INTMOD_ISO_FORTRAN_ENV, symbol[i].id);\\\n             break;\n #include \"iso-fortran-env.def\"\n-#undef NAMED_KINDARRAY\n \n #define NAMED_DERIVED_TYPE(a,b,TYPE,STD) \\\n \t  case a:\n #include \"iso-fortran-env.def\"\n \t    create_derived_type (symbol[i].name, mod, INTMOD_ISO_FORTRAN_ENV,\n \t\t\t\t symbol[i].id);\n \t    break;\n-#undef NAMED_DERIVED_TYPE\n \n #define NAMED_FUNCTION(a,b,c,d) \\\n \t\tcase a:\n #include \"iso-fortran-env.def\"\n-#undef NAMED_FUNCTION\n-\t\t  create_intrinsic_function (symbol[i].name,\n-\t\t\t\t\t     (gfc_isym_id) symbol[i].value, mod,\n-\t\t\t\t\t     INTMOD_ISO_FORTRAN_ENV);\n+\t\t  create_intrinsic_function (symbol[i].name, symbol[i].id, mod,\n+\t\t\t\t\t     INTMOD_ISO_FORTRAN_ENV, false,\n+\t\t\t\t\t     NULL);\n \t\t  break;\n \n \t  default:"}, {"sha": "835b57f4996ccfe4d72139a35f38d3b7dab3b1f2", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 25, "deletions": 587, "changes": 612, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -520,7 +520,7 @@ static void\n find_arglists (gfc_symbol *sym)\n {\n   if (sym->attr.if_source == IFSRC_UNKNOWN || sym->ns != gfc_current_ns\n-      || sym->attr.flavor == FL_DERIVED)\n+      || sym->attr.flavor == FL_DERIVED || sym->attr.intrinsic)\n     return;\n \n   resolve_formal_arglist (sym);\n@@ -1038,23 +1038,6 @@ resolve_structure_cons (gfc_expr *expr, int init)\n \n   cons = gfc_constructor_first (expr->value.constructor);\n \n-  /* See if the user is trying to invoke a structure constructor for one of\n-     the iso_c_binding derived types.  */\n-  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived\n-      && expr->ts.u.derived->ts.is_iso_c && cons\n-      && (cons->expr == NULL || cons->expr->expr_type != EXPR_NULL))\n-    {\n-      gfc_error (\"Components of structure constructor '%s' at %L are PRIVATE\",\n-\t\t expr->ts.u.derived->name, &(expr->where));\n-      return FAILURE;\n-    }\n-\n-  /* Return if structure constructor is c_null_(fun)prt.  */\n-  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived\n-      && expr->ts.u.derived->ts.is_iso_c && cons\n-      && cons->expr && cons->expr->expr_type == EXPR_NULL)\n-    return SUCCESS;\n-\n   /* A constructor may have references if it is the result of substituting a\n      parameter variable.  In this case we just pull out the component we\n      want.  */\n@@ -1180,7 +1163,7 @@ resolve_structure_cons (gfc_expr *expr, int init)\n \n       if (cons->expr->expr_type == EXPR_NULL\n \t  && !(comp->attr.pointer || comp->attr.allocatable\n-\t       || comp->attr.proc_pointer\n+\t       || comp->attr.proc_pointer || comp->ts.f90_type == BT_VOID\n \t       || (comp->ts.type == BT_CLASS\n \t\t   && (CLASS_DATA (comp)->attr.class_pointer\n \t\t       || CLASS_DATA (comp)->attr.allocatable))))\n@@ -1562,12 +1545,20 @@ gfc_resolve_intrinsic (gfc_symbol *sym, locus *loc)\n      gfc_find_subroutine directly to check whether it is a function or\n      subroutine.  */\n \n-  if (sym->intmod_sym_id)\n-    isym = gfc_intrinsic_function_by_id ((gfc_isym_id) sym->intmod_sym_id);\n+  if (sym->intmod_sym_id && sym->attr.subroutine)\n+    {\n+      gfc_isym_id id = gfc_isym_id_by_intmod_sym (sym);\n+      isym = gfc_intrinsic_subroutine_by_id (id);\n+    }\n+  else if (sym->intmod_sym_id)\n+    {\n+      gfc_isym_id id = gfc_isym_id_by_intmod_sym (sym);\n+      isym = gfc_intrinsic_function_by_id (id);\n+    }\n   else if (!sym->attr.subroutine)\n     isym = gfc_find_function (sym->name);\n \n-  if (isym)\n+  if (isym && !sym->attr.subroutine)\n     {\n       if (sym->ts.type != BT_UNKNOWN && gfc_option.warn_surprising\n \t  && !sym->attr.implicit_type)\n@@ -1580,7 +1571,7 @@ gfc_resolve_intrinsic (gfc_symbol *sym, locus *loc)\n \n       sym->ts = isym->ts;\n     }\n-  else if ((isym = gfc_find_subroutine (sym->name)))\n+  else if (isym || (isym = gfc_find_subroutine (sym->name)))\n     {\n       if (sym->ts.type != BT_UNKNOWN && !sym->attr.implicit_type)\n \t{\n@@ -2719,366 +2710,6 @@ pure_stmt_function (gfc_expr *e, gfc_symbol *sym)\n }\n \n \n-static gfc_try\n-is_scalar_expr_ptr (gfc_expr *expr)\n-{\n-  gfc_try retval = SUCCESS;\n-  gfc_ref *ref;\n-  int start;\n-  int end;\n-\n-  /* See if we have a gfc_ref, which means we have a substring, array\n-     reference, or a component.  */\n-  if (expr->ref != NULL)\n-    {\n-      ref = expr->ref;\n-      while (ref->next != NULL)\n-        ref = ref->next;\n-\n-      switch (ref->type)\n-        {\n-        case REF_SUBSTRING:\n-          if (ref->u.ss.start == NULL || ref->u.ss.end == NULL\n-\t      || gfc_dep_compare_expr (ref->u.ss.start, ref->u.ss.end) != 0)\n-\t    retval = FAILURE;\n-          break;\n-\n-        case REF_ARRAY:\n-          if (ref->u.ar.type == AR_ELEMENT)\n-            retval = SUCCESS;\n-          else if (ref->u.ar.type == AR_FULL)\n-            {\n-              /* The user can give a full array if the array is of size 1.  */\n-              if (ref->u.ar.as != NULL\n-                  && ref->u.ar.as->rank == 1\n-                  && ref->u.ar.as->type == AS_EXPLICIT\n-                  && ref->u.ar.as->lower[0] != NULL\n-                  && ref->u.ar.as->lower[0]->expr_type == EXPR_CONSTANT\n-                  && ref->u.ar.as->upper[0] != NULL\n-                  && ref->u.ar.as->upper[0]->expr_type == EXPR_CONSTANT)\n-                {\n-\t\t  /* If we have a character string, we need to check if\n-\t\t     its length is one.\t */\n-\t\t  if (expr->ts.type == BT_CHARACTER)\n-\t\t    {\n-\t\t      if (expr->ts.u.cl == NULL\n-\t\t\t  || expr->ts.u.cl->length == NULL\n-\t\t\t  || mpz_cmp_si (expr->ts.u.cl->length->value.integer, 1)\n-\t\t\t  != 0)\n-                        retval = FAILURE;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* We have constant lower and upper bounds.  If the\n-\t\t\t difference between is 1, it can be considered a\n-\t\t\t scalar.\n-\t\t\t FIXME: Use gfc_dep_compare_expr instead.  */\n-\t\t      start = (int) mpz_get_si\n-\t\t\t\t(ref->u.ar.as->lower[0]->value.integer);\n-\t\t      end = (int) mpz_get_si\n-\t\t\t\t(ref->u.ar.as->upper[0]->value.integer);\n-\t\t      if (end - start + 1 != 1)\n-\t\t\tretval = FAILURE;\n-\t\t   }\n-                }\n-              else\n-                retval = FAILURE;\n-            }\n-          else\n-            retval = FAILURE;\n-          break;\n-        default:\n-          retval = SUCCESS;\n-          break;\n-        }\n-    }\n-  else if (expr->ts.type == BT_CHARACTER && expr->rank == 0)\n-    {\n-      /* Character string.  Make sure it's of length 1.  */\n-      if (expr->ts.u.cl == NULL\n-          || expr->ts.u.cl->length == NULL\n-          || mpz_cmp_si (expr->ts.u.cl->length->value.integer, 1) != 0)\n-        retval = FAILURE;\n-    }\n-  else if (expr->rank != 0)\n-    retval = FAILURE;\n-\n-  return retval;\n-}\n-\n-\n-/* Match one of the iso_c_binding functions (c_associated or c_loc)\n-   and, in the case of c_associated, set the binding label based on\n-   the arguments.  */\n-\n-static gfc_try\n-gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n-                          gfc_symbol **new_sym)\n-{\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\n-  int optional_arg = 0;\n-  gfc_try retval = SUCCESS;\n-  gfc_symbol *args_sym;\n-  gfc_typespec *arg_ts;\n-  symbol_attribute arg_attr;\n-\n-  if (args->expr->expr_type == EXPR_CONSTANT\n-      || args->expr->expr_type == EXPR_OP\n-      || args->expr->expr_type == EXPR_NULL)\n-    {\n-      gfc_error (\"Argument to '%s' at %L is not a variable\",\n-\t\t sym->name, &(args->expr->where));\n-      return FAILURE;\n-    }\n-\n-  args_sym = args->expr->symtree->n.sym;\n-\n-  /* The typespec for the actual arg should be that stored in the expr\n-     and not necessarily that of the expr symbol (args_sym), because\n-     the actual expression could be a part-ref of the expr symbol.  */\n-  arg_ts = &(args->expr->ts);\n-  arg_attr = gfc_expr_attr (args->expr);\n-\n-  if (sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n-    {\n-      /* If the user gave two args then they are providing something for\n-\t the optional arg (the second cptr).  Therefore, set the name and\n-\t binding label to the c_associated for two cptrs.  Otherwise,\n-\t set c_associated to expect one cptr.  */\n-      if (args->next)\n-\t{\n-\t  /* two args.  */\n-\t  sprintf (name, \"%s_2\", sym->name);\n-\t  optional_arg = 1;\n-\t}\n-      else\n-\t{\n-\t  /* one arg.  */\n-\t  sprintf (name, \"%s_1\", sym->name);\n-\t  optional_arg = 0;\n-\t}\n-\n-      /* Get a new symbol for the version of c_associated that\n-\t will get called.  */\n-      *new_sym = get_iso_c_sym (sym, name, NULL, optional_arg);\n-    }\n-  else if (sym->intmod_sym_id == ISOCBINDING_LOC\n-\t   || sym->intmod_sym_id == ISOCBINDING_FUNLOC)\n-    {\n-      sprintf (name, \"%s\", sym->name);\n-\n-      /* Error check the call.  */\n-      if (args->next != NULL)\n-        {\n-          gfc_error_now (\"More actual than formal arguments in '%s' \"\n-                         \"call at %L\", name, &(args->expr->where));\n-          retval = FAILURE;\n-        }\n-      else if (sym->intmod_sym_id == ISOCBINDING_LOC)\n-        {\n-\t  gfc_ref *ref;\n-\t  bool seen_section;\n-\n-          /* Make sure we have either the target or pointer attribute.  */\n-\t  if (!arg_attr.target && !arg_attr.pointer)\n-            {\n-              gfc_error_now (\"Parameter '%s' to '%s' at %L must be either \"\n-                             \"a TARGET or an associated pointer\",\n-                             args_sym->name,\n-                             sym->name, &(args->expr->where));\n-              retval = FAILURE;\n-            }\n-\n-\t  if (gfc_is_coindexed (args->expr))\n-\t    {\n-\t      gfc_error_now (\"Coindexed argument not permitted\"\n-\t\t\t     \" in '%s' call at %L\", name,\n-\t\t\t     &(args->expr->where));\n-\t      retval = FAILURE;\n-\t    }\n-\n-\t  /* Follow references to make sure there are no array\n-\t     sections.  */\n-\t  seen_section = false;\n-\n-\t  for (ref=args->expr->ref; ref; ref = ref->next)\n-\t    {\n-\t      if (ref->type == REF_ARRAY)\n-\t\t{\n-\t\t  if (ref->u.ar.type == AR_SECTION)\n-\t\t    seen_section = true;\n-\n-\t\t  if (ref->u.ar.type != AR_ELEMENT)\n-\t\t    {\n-\t\t      gfc_ref *r;\n-\t\t      for (r = ref->next; r; r=r->next)\n-\t\t\tif (r->type == REF_COMPONENT)\n-\t\t\t  {\n-\t\t\t    gfc_error_now (\"Array section not permitted\"\n-\t\t\t\t\t   \" in '%s' call at %L\", name,\n-\t\t\t\t\t   &(args->expr->where));\n-\t\t\t    retval = FAILURE;\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  if (seen_section && retval == SUCCESS)\n-\t    gfc_warning (\"Array section in '%s' call at %L\", name,\n-\t\t\t &(args->expr->where));\n-\n-          /* See if we have interoperable type and type param.  */\n-          if (gfc_verify_c_interop (arg_ts) == SUCCESS\n-              || gfc_check_any_c_kind (arg_ts) == SUCCESS)\n-            {\n-              if (args_sym->attr.target == 1)\n-                {\n-                  /* Case 1a, section 15.1.2.5, J3/04-007: variable that\n-                     has the target attribute and is interoperable.  */\n-                  /* Case 1b, section 15.1.2.5, J3/04-007: allocated\n-                     allocatable variable that has the TARGET attribute and\n-                     is not an array of zero size.  */\n-                  if (args_sym->attr.allocatable == 1)\n-                    {\n-                      if (args_sym->attr.dimension != 0\n-                          && (args_sym->as && args_sym->as->rank == 0))\n-                        {\n-                          gfc_error_now (\"Allocatable variable '%s' used as a \"\n-                                         \"parameter to '%s' at %L must not be \"\n-                                         \"an array of zero size\",\n-                                         args_sym->name, sym->name,\n-                                         &(args->expr->where));\n-                          retval = FAILURE;\n-                        }\n-                    }\n-                  else\n-\t\t    {\n-\t\t      /* A non-allocatable target variable with C\n-\t\t\t interoperable type and type parameters must be\n-\t\t\t interoperable.\t */\n-\t\t      if (args_sym && args_sym->attr.dimension)\n-\t\t\t{\n-\t\t\t  if (args_sym->as->type == AS_ASSUMED_SHAPE)\n-\t\t\t    {\n-\t\t\t      gfc_error (\"Assumed-shape array '%s' at %L \"\n-\t\t\t\t\t \"cannot be an argument to the \"\n-\t\t\t\t\t \"procedure '%s' because \"\n-\t\t\t\t\t \"it is not C interoperable\",\n-\t\t\t\t\t args_sym->name,\n-\t\t\t\t\t &(args->expr->where), sym->name);\n-\t\t\t      retval = FAILURE;\n-\t\t\t    }\n-\t\t\t  else if (args_sym->as->type == AS_DEFERRED)\n-\t\t\t    {\n-\t\t\t      gfc_error (\"Deferred-shape array '%s' at %L \"\n-\t\t\t\t\t \"cannot be an argument to the \"\n-\t\t\t\t\t \"procedure '%s' because \"\n-\t\t\t\t\t \"it is not C interoperable\",\n-\t\t\t\t\t args_sym->name,\n-\t\t\t\t\t &(args->expr->where), sym->name);\n-\t\t\t      retval = FAILURE;\n-\t\t\t    }\n-\t\t\t}\n-\n-                      /* Make sure it's not a character string.  Arrays of\n-                         any type should be ok if the variable is of a C\n-                         interoperable type.  */\n-\t\t      if (arg_ts->type == BT_CHARACTER)\n-\t\t\tif (arg_ts->u.cl != NULL\n-\t\t\t    && (arg_ts->u.cl->length == NULL\n-\t\t\t\t|| arg_ts->u.cl->length->expr_type\n-\t\t\t\t   != EXPR_CONSTANT\n-\t\t\t\t|| mpz_cmp_si\n-\t\t\t\t    (arg_ts->u.cl->length->value.integer, 1)\n-\t\t\t\t   != 0)\n-\t\t\t    && is_scalar_expr_ptr (args->expr) != SUCCESS)\n-\t\t\t  {\n-\t\t\t    gfc_error_now (\"CHARACTER argument '%s' to '%s' \"\n-\t\t\t\t\t   \"at %L must have a length of 1\",\n-\t\t\t\t\t   args_sym->name, sym->name,\n-\t\t\t\t\t   &(args->expr->where));\n-\t\t\t    retval = FAILURE;\n-\t\t\t  }\n-                    }\n-                }\n-              else if (arg_attr.pointer\n-\t\t       && is_scalar_expr_ptr (args->expr) != SUCCESS)\n-                {\n-                  /* Case 1c, section 15.1.2.5, J3/04-007: an associated\n-                     scalar pointer.  */\n-                  gfc_error_now (\"Argument '%s' to '%s' at %L must be an \"\n-                                 \"associated scalar POINTER\", args_sym->name,\n-                                 sym->name, &(args->expr->where));\n-                  retval = FAILURE;\n-                }\n-            }\n-          else\n-            {\n-              /* The parameter is not required to be C interoperable.  If it\n-                 is not C interoperable, it must be a nonpolymorphic scalar\n-                 with no length type parameters.  It still must have either\n-                 the pointer or target attribute, and it can be\n-                 allocatable (but must be allocated when c_loc is called).  */\n-              if (args->expr->rank != 0\n-                  && is_scalar_expr_ptr (args->expr) != SUCCESS)\n-                {\n-                  gfc_error_now (\"Parameter '%s' to '%s' at %L must be a \"\n-                                 \"scalar\", args_sym->name, sym->name,\n-                                 &(args->expr->where));\n-                  retval = FAILURE;\n-                }\n-              else if (arg_ts->type == BT_CHARACTER\n-                       && is_scalar_expr_ptr (args->expr) != SUCCESS)\n-                {\n-                  gfc_error_now (\"CHARACTER argument '%s' to '%s' at \"\n-                                 \"%L must have a length of 1\",\n-                                 args_sym->name, sym->name,\n-                                 &(args->expr->where));\n-                  retval = FAILURE;\n-                }\n-\t      else if (arg_ts->type == BT_CLASS)\n-\t\t{\n-\t\t  gfc_error_now (\"Parameter '%s' to '%s' at %L must not be \"\n-\t\t\t\t \"polymorphic\", args_sym->name, sym->name,\n-\t\t\t\t &(args->expr->where));\n-\t\t  retval = FAILURE;\n-\t\t}\n-            }\n-        }\n-      else if (sym->intmod_sym_id == ISOCBINDING_FUNLOC)\n-        {\n-          if (args_sym->attr.flavor != FL_PROCEDURE)\n-            {\n-              /* TODO: Update this error message to allow for procedure\n-                 pointers once they are implemented.  */\n-              gfc_error_now (\"Argument '%s' to '%s' at %L must be a \"\n-                             \"procedure\",\n-                             args_sym->name, sym->name,\n-                             &(args->expr->where));\n-              retval = FAILURE;\n-            }\n-\t  else if (args_sym->attr.is_bind_c != 1\n-\t\t   && gfc_notify_std (GFC_STD_F2008_TS, \"Noninteroperable \"\n-\t\t\t\t      \"argument '%s' to '%s' at %L\",\n-\t\t\t\t      args_sym->name, sym->name,\n-\t\t\t\t      &(args->expr->where)) == FAILURE)\n-\t    retval = FAILURE;\n-        }\n-\n-      /* for c_loc/c_funloc, the new symbol is the same as the old one */\n-      *new_sym = sym;\n-    }\n-  else\n-    {\n-      gfc_internal_error (\"gfc_iso_c_func_interface(): Unhandled \"\n-\t\t\t  \"iso_c_binding function: '%s'!\\n\", sym->name);\n-    }\n-\n-  return retval;\n-}\n-\n-\n /* Resolve a function call, which means resolving the arguments, then figuring\n    out which entity the name refers to.  */\n \n@@ -3141,19 +2772,6 @@ resolve_function (gfc_expr *expr)\n \n   inquiry_argument = false;\n \n-  /* Need to setup the call to the correct c_associated, depending on\n-     the number of cptrs to user gives to compare.  */\n-  if (sym && sym->attr.is_iso_c == 1)\n-    {\n-      if (gfc_iso_c_func_interface (sym, expr->value.function.actual, &sym)\n-          == FAILURE)\n-        return FAILURE;\n-\n-      /* Get the symtree for the new symbol (resolved func).\n-         the old one will be freed later, when it's no longer used.  */\n-      gfc_find_sym_tree (sym->name, sym->ns, 1, &(expr->symtree));\n-    }\n-\n   /* Resume assumed_size checking.  */\n   need_full_assumed_size--;\n \n@@ -3236,6 +2854,7 @@ resolve_function (gfc_expr *expr)\n \t   && GENERIC_ID != GFC_ISYM_LBOUND\n \t   && GENERIC_ID != GFC_ISYM_LEN\n \t   && GENERIC_ID != GFC_ISYM_LOC\n+\t   && GENERIC_ID != GFC_ISYM_C_LOC\n \t   && GENERIC_ID != GFC_ISYM_PRESENT)\n     {\n       /* Array intrinsics must also have the last upper bound of an\n@@ -3438,203 +3057,13 @@ resolve_generic_s (gfc_code *c)\n }\n \n \n-/* Set the name and binding label of the subroutine symbol in the call\n-   expression represented by 'c' to include the type and kind of the\n-   second parameter.  This function is for resolving the appropriate\n-   version of c_f_pointer() and c_f_procpointer().  For example, a\n-   call to c_f_pointer() for a default integer pointer could have a\n-   name of c_f_pointer_i4.  If no second arg exists, which is an error\n-   for these two functions, it defaults to the generic symbol's name\n-   and binding label.  */\n-\n-static void\n-set_name_and_label (gfc_code *c, gfc_symbol *sym,\n-                    char *name, const char **binding_label)\n-{\n-  gfc_expr *arg = NULL;\n-  char type;\n-  int kind;\n-\n-  /* The second arg of c_f_pointer and c_f_procpointer determines\n-     the type and kind for the procedure name.  */\n-  arg = c->ext.actual->next->expr;\n-\n-  if (arg != NULL)\n-    {\n-      /* Set up the name to have the given symbol's name,\n-         plus the type and kind.  */\n-      /* a derived type is marked with the type letter 'u' */\n-      if (arg->ts.type == BT_DERIVED)\n-        {\n-          type = 'd';\n-          kind = 0; /* set the kind as 0 for now */\n-        }\n-      else\n-        {\n-          type = gfc_type_letter (arg->ts.type);\n-          kind = arg->ts.kind;\n-        }\n-\n-      if (arg->ts.type == BT_CHARACTER)\n-\t/* Kind info for character strings not needed.\t*/\n-\tkind = 0;\n-\n-      sprintf (name, \"%s_%c%d\", sym->name, type, kind);\n-      /* Set up the binding label as the given symbol's label plus\n-         the type and kind.  */\n-      *binding_label = gfc_get_string (\"%s_%c%d\", sym->binding_label, type,\n-\t\t\t\t       kind);\n-    }\n-  else\n-    {\n-      /* If the second arg is missing, set the name and label as\n-         was, cause it should at least be found, and the missing\n-         arg error will be caught by compare_parameters().  */\n-      sprintf (name, \"%s\", sym->name);\n-      *binding_label = sym->binding_label;\n-    }\n-\n-  return;\n-}\n-\n-\n-/* Resolve a generic version of the iso_c_binding procedure given\n-   (sym) to the specific one based on the type and kind of the\n-   argument(s).  Currently, this function resolves c_f_pointer() and\n-   c_f_procpointer based on the type and kind of the second argument\n-   (FPTR).  Other iso_c_binding procedures aren't specially handled.\n-   Upon successfully exiting, c->resolved_sym will hold the resolved\n-   symbol.  Returns MATCH_ERROR if an error occurred; MATCH_YES\n-   otherwise.  */\n-\n-match\n-gfc_iso_c_sub_interface (gfc_code *c, gfc_symbol *sym)\n-{\n-  gfc_symbol *new_sym;\n-  /* this is fine, since we know the names won't use the max */\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\n-  const char* binding_label;\n-  /* default to success; will override if find error */\n-  match m = MATCH_YES;\n-\n-  /* Make sure the actual arguments are in the necessary order (based on the\n-     formal args) before resolving.  */\n-  if (gfc_procedure_use (sym, &c->ext.actual, &(c->loc)) == FAILURE)\n-    {\n-      c->resolved_sym = sym;\n-      return MATCH_ERROR;\n-    }\n-\n-  if ((sym->intmod_sym_id == ISOCBINDING_F_POINTER) ||\n-      (sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER))\n-    {\n-      set_name_and_label (c, sym, name, &binding_label);\n-\n-      if (sym->intmod_sym_id == ISOCBINDING_F_POINTER)\n-\t{\n-\t  if (c->ext.actual != NULL && c->ext.actual->next != NULL)\n-\t    {\n-\t      gfc_actual_arglist *arg1 = c->ext.actual;\n-\t      gfc_actual_arglist *arg2 = c->ext.actual->next;\n-\t      gfc_actual_arglist *arg3 = c->ext.actual->next->next;\n-\n-\t      /* Check first argument (CPTR).  */\n-\t      if (arg1->expr->ts.type != BT_DERIVED\n-\t\t  || arg1->expr->ts.u.derived->intmod_sym_id != ISOCBINDING_PTR)\n-\t\t{\n-\t\t  gfc_error (\"Argument CPTR to C_F_POINTER at %L shall have \"\n-\t\t\t     \"the type C_PTR\", &arg1->expr->where);\n-\t\t  m = MATCH_ERROR;\n-\t\t}\n-\n-\t      /* Check second argument (FPTR).  */\n-\t      if (arg2->expr->ts.type == BT_CLASS)\n-\t\t{\n-\t\t  gfc_error (\"Argument FPTR to C_F_POINTER at %L must not be \"\n-\t\t\t     \"polymorphic\", &arg2->expr->where);\n-\t\t  m = MATCH_ERROR;\n-\t\t}\n-\n-\t      /* Make sure we got a third arg (SHAPE) if the second arg has\n-\t\t non-zero rank. We must also check that the type and rank are\n-\t\t correct since we short-circuit this check in\n-\t\t gfc_procedure_use() (called above to sort actual args).  */\n-\t      if (arg2->expr->rank != 0)\n-\t\t{\n-\t\t  if (arg3 == NULL || arg3->expr == NULL)\n-\t\t    {\n-\t\t      m = MATCH_ERROR;\n-\t\t      gfc_error (\"Missing SHAPE argument for call to %s at %L\",\n-\t\t\t\t sym->name, &c->loc);\n-\t\t    }\n-\t\t  else if (arg3->expr->ts.type != BT_INTEGER\n-\t\t\t   || arg3->expr->rank != 1)\n-\t\t    {\n-\t\t      m = MATCH_ERROR;\n-\t\t      gfc_error (\"SHAPE argument for call to %s at %L must be \"\n-\t\t\t\t \"a rank 1 INTEGER array\", sym->name, &c->loc);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-      else /* ISOCBINDING_F_PROCPOINTER.  */\n-\t{\n-\t  if (c->ext.actual\n-\t      && (c->ext.actual->expr->ts.type != BT_DERIVED\n-\t\t  || c->ext.actual->expr->ts.u.derived->intmod_sym_id\n-\t\t     != ISOCBINDING_FUNPTR))\n-\t    {\n-\t      gfc_error (\"Argument at %L to C_F_FUNPOINTER shall have the type \"\n-\t                 \"C_FUNPTR\", &c->ext.actual->expr->where);\n-              m = MATCH_ERROR;\n-\t    }\n-\t  if (c->ext.actual && c->ext.actual->next\n-\t      && !gfc_expr_attr (c->ext.actual->next->expr).is_bind_c\n-\t      && gfc_notify_std (GFC_STD_F2008_TS, \"Noninteroperable \"\n-\t\t\t\t \"procedure-pointer at %L to C_F_FUNPOINTER\",\n-\t\t\t\t &c->ext.actual->next->expr->where)\n-\t\t   == FAILURE)\n-\t    m = MATCH_ERROR;\n-\t}\n-\n-      if (m != MATCH_ERROR)\n-\t{\n-\t  /* the 1 means to add the optional arg to formal list */\n-\t  new_sym = get_iso_c_sym (sym, name, binding_label, 1);\n-\n-\t  /* for error reporting, say it's declared where the original was */\n-\t  new_sym->declared_at = sym->declared_at;\n-\t}\n-    }\n-  else\n-    {\n-      /* no differences for c_loc or c_funloc */\n-      new_sym = sym;\n-    }\n-\n-  /* set the resolved symbol */\n-  if (m != MATCH_ERROR)\n-    c->resolved_sym = new_sym;\n-  else\n-    c->resolved_sym = sym;\n-\n-  return m;\n-}\n-\n-\n /* Resolve a subroutine call known to be specific.  */\n \n static match\n resolve_specific_s0 (gfc_code *c, gfc_symbol *sym)\n {\n   match m;\n \n-  if(sym->attr.is_iso_c)\n-    {\n-      m = gfc_iso_c_sub_interface (c,sym);\n-      return m;\n-    }\n-\n   if (sym->attr.external || sym->attr.if_source == IFSRC_IFBODY)\n     {\n       if (sym->attr.dummy)\n@@ -8767,7 +8196,16 @@ resolve_transfer (gfc_code *code)\n \t  return;\n \t}\n \n-      if (derived_inaccessible (ts->u.derived))\n+      /* C_PTR and C_FUNPTR have private components which means they can not\n+         be printed.  However, if -std=gnu and not -pedantic, allow\n+         the component to be printed to help debugging.  */\n+      if (ts->u.derived->ts.f90_type == BT_VOID)\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_GNU, \"Data transfer element at %L cannot \"\n+\t\t\t      \"have PRIVATE components\", &code->loc) == FAILURE)\n+\t    return;\n+\t}\n+      else if (derived_inaccessible (ts->u.derived))\n \t{\n \t  gfc_error (\"Data transfer element at %L cannot have \"\n \t\t     \"PRIVATE components\",&code->loc);"}, {"sha": "ec64231da8fdc51a3428cdf15e0855ee150e36dd", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 97, "deletions": 524, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -3939,75 +3939,32 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n /* Generate symbols for the named constants c_null_ptr and c_null_funptr.  */\n \n static gfc_try\n-gen_special_c_interop_ptr (int ptr_id, const char *ptr_name,\n-                           const char *module_name)\n+gen_special_c_interop_ptr (gfc_symbol *tmp_sym, gfc_symtree *dt_symtree)\n {\n-  gfc_symtree *tmp_symtree;\n-  gfc_symbol *tmp_sym;\n   gfc_constructor *c;\n \n-  tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root, ptr_name);\n-\t \n-  if (tmp_symtree != NULL)\n-    tmp_sym = tmp_symtree->n.sym;\n-  else\n-    {\n-      tmp_sym = NULL;\n-      gfc_internal_error (\"gen_special_c_interop_ptr(): Unable to \"\n-                          \"create symbol for %s\", ptr_name);\n-    }\n+  gcc_assert (tmp_sym && dt_symtree && dt_symtree->n.sym);\n+  dt_symtree->n.sym->attr.referenced = 1;\n \n-  tmp_sym->ts.is_c_interop = 1;\n   tmp_sym->attr.is_c_interop = 1;\n+  tmp_sym->attr.is_bind_c = 1;\n+  tmp_sym->ts.is_c_interop = 1;\n   tmp_sym->ts.is_iso_c = 1;\n   tmp_sym->ts.type = BT_DERIVED;\n+  tmp_sym->ts.f90_type = BT_VOID;\n   tmp_sym->attr.flavor = FL_PARAMETER;\n-\n-  /* The c_ptr and c_funptr derived types will provide the\n-     definition for c_null_ptr and c_null_funptr, respectively.  */\n-  if (ptr_id == ISOCBINDING_NULL_PTR)\n-    tmp_sym->ts.u.derived = get_iso_c_binding_dt (ISOCBINDING_PTR);\n-  else\n-    tmp_sym->ts.u.derived = get_iso_c_binding_dt (ISOCBINDING_FUNPTR);\n-  if (tmp_sym->ts.u.derived == NULL)\n-    {\n-      /* This can occur if the user forgot to declare c_ptr or\n-         c_funptr and they're trying to use one of the procedures\n-         that has arg(s) of the missing type.  In this case, a\n-         regular version of the thing should have been put in the\n-         current ns.  */\n-\n-      generate_isocbinding_symbol (module_name, ptr_id == ISOCBINDING_NULL_PTR \n-                                   ? ISOCBINDING_PTR : ISOCBINDING_FUNPTR,\n-                                   (const char *) (ptr_id == ISOCBINDING_NULL_PTR \n-\t\t\t\t   ? \"c_ptr\"\n-\t\t\t\t   : \"c_funptr\"));\n-      tmp_sym->ts.u.derived =\n-\tget_iso_c_binding_dt (ptr_id == ISOCBINDING_NULL_PTR\n-\t\t\t      ? ISOCBINDING_PTR : ISOCBINDING_FUNPTR);\n-    }\n-\n-  /* Module name is some mangled version of iso_c_binding.  */\n-  tmp_sym->module = gfc_get_string (module_name);\n-  \n-  /* Say it's from the iso_c_binding module.  */\n-  tmp_sym->attr.is_iso_c = 1;\n-  \n-  tmp_sym->attr.use_assoc = 1;\n-  tmp_sym->attr.is_bind_c = 1;\n-  /* Since we never generate a call to this symbol, don't set the\n-     binding_label.  */\n+  tmp_sym->ts.u.derived = dt_symtree->n.sym;\n   \n   /* Set the c_address field of c_null_ptr and c_null_funptr to\n      the value of NULL.\t */\n   tmp_sym->value = gfc_get_expr ();\n   tmp_sym->value->expr_type = EXPR_STRUCTURE;\n   tmp_sym->value->ts.type = BT_DERIVED;\n+  tmp_sym->value->ts.f90_type = BT_VOID;\n   tmp_sym->value->ts.u.derived = tmp_sym->ts.u.derived;\n   gfc_constructor_append_expr (&tmp_sym->value->value.constructor, NULL, NULL);\n   c = gfc_constructor_first (tmp_sym->value->value.constructor);\n-  c->expr = gfc_get_expr ();\n-  c->expr->expr_type = EXPR_NULL;\n+  c->expr = gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n   c->expr->ts.is_iso_c = 1;\n \n   return SUCCESS;\n@@ -4040,200 +3997,6 @@ add_formal_arg (gfc_formal_arglist **head,\n }\n \n \n-/* Generates a symbol representing the CPTR argument to an\n-   iso_c_binding procedure.  Also, create a gfc_formal_arglist for the\n-   CPTR and add it to the provided argument list.  */\n-\n-static void\n-gen_cptr_param (gfc_formal_arglist **head,\n-                gfc_formal_arglist **tail,\n-                const char *module_name,\n-                gfc_namespace *ns, const char *c_ptr_name,\n-                int iso_c_sym_id)\n-{\n-  gfc_symbol *param_sym = NULL;\n-  gfc_symbol *c_ptr_sym = NULL;\n-  gfc_symtree *param_symtree = NULL;\n-  gfc_formal_arglist *formal_arg = NULL;\n-  const char *c_ptr_in;\n-  const char *c_ptr_type = NULL;\n-\n-  if (iso_c_sym_id == ISOCBINDING_F_PROCPOINTER)\n-    c_ptr_type = \"c_funptr\";\n-  else\n-    c_ptr_type = \"c_ptr\";\n-\n-  if(c_ptr_name == NULL)\n-    c_ptr_in = \"gfc_cptr__\";\n-  else\n-    c_ptr_in = c_ptr_name;\n-  gfc_get_sym_tree (c_ptr_in, ns, &param_symtree, false);\n-  if (param_symtree != NULL)\n-    param_sym = param_symtree->n.sym;\n-  else\n-    gfc_internal_error (\"gen_cptr_param(): Unable to \"\n-\t\t\t\"create symbol for %s\", c_ptr_in);\n-\n-  /* Set up the appropriate fields for the new c_ptr param sym.  */\n-  param_sym->refs++;\n-  param_sym->attr.flavor = FL_DERIVED;\n-  param_sym->ts.type = BT_DERIVED;\n-  param_sym->attr.intent = INTENT_IN;\n-  param_sym->attr.dummy = 1;\n-\n-  /* This will pass the ptr to the iso_c routines as a (void *).  */\n-  param_sym->attr.value = 1;\n-  param_sym->attr.use_assoc = 1;\n-\n-  /* Get the symbol for c_ptr or c_funptr, no matter what it's name is \n-     (user renamed).  */\n-  if (iso_c_sym_id == ISOCBINDING_F_PROCPOINTER)\n-    c_ptr_sym = get_iso_c_binding_dt (ISOCBINDING_FUNPTR);\n-  else\n-    c_ptr_sym = get_iso_c_binding_dt (ISOCBINDING_PTR);\n-  if (c_ptr_sym == NULL)\n-    {\n-      /* This can happen if the user did not define c_ptr but they are\n-         trying to use one of the iso_c_binding functions that need it.  */\n-      if (iso_c_sym_id == ISOCBINDING_F_PROCPOINTER)\n-\tgenerate_isocbinding_symbol (module_name, ISOCBINDING_FUNPTR,\n-\t\t\t\t     (const char *)c_ptr_type);\n-      else\n-\tgenerate_isocbinding_symbol (module_name, ISOCBINDING_PTR,\n-\t\t\t\t     (const char *)c_ptr_type);\n-\n-      gfc_get_ha_symbol (c_ptr_type, &(c_ptr_sym));\n-    }\n-\n-  param_sym->ts.u.derived = c_ptr_sym;\n-  param_sym->module = gfc_get_string (module_name);\n-\n-  /* Make new formal arg.  */\n-  formal_arg = gfc_get_formal_arglist ();\n-  /* Add arg to list of formal args (the CPTR arg).  */\n-  add_formal_arg (head, tail, formal_arg, param_sym);\n-\n-  /* Validate changes.  */\n-  gfc_commit_symbol (param_sym);\n-}\n-\n-\n-/* Generates a symbol representing the FPTR argument to an\n-   iso_c_binding procedure.  Also, create a gfc_formal_arglist for the\n-   FPTR and add it to the provided argument list.  */\n-\n-static void\n-gen_fptr_param (gfc_formal_arglist **head,\n-                gfc_formal_arglist **tail,\n-                const char *module_name,\n-                gfc_namespace *ns, const char *f_ptr_name, int proc)\n-{\n-  gfc_symbol *param_sym = NULL;\n-  gfc_symtree *param_symtree = NULL;\n-  gfc_formal_arglist *formal_arg = NULL;\n-  const char *f_ptr_out = \"gfc_fptr__\";\n-\n-  if (f_ptr_name != NULL)\n-    f_ptr_out = f_ptr_name;\n-\n-  gfc_get_sym_tree (f_ptr_out, ns, &param_symtree, false);\n-  if (param_symtree != NULL)\n-    param_sym = param_symtree->n.sym;\n-  else\n-    gfc_internal_error (\"generateFPtrParam(): Unable to \"\n-\t\t\t\"create symbol for %s\", f_ptr_out);\n-\n-  /* Set up the necessary fields for the fptr output param sym.  */\n-  param_sym->refs++;\n-  if (proc)\n-    param_sym->attr.proc_pointer = 1;\n-  else\n-    param_sym->attr.pointer = 1;\n-  param_sym->attr.dummy = 1;\n-  param_sym->attr.use_assoc = 1;\n-\n-  /* ISO C Binding type to allow any pointer type as actual param.  */\n-  param_sym->ts.type = BT_VOID;\n-  param_sym->module = gfc_get_string (module_name);\n-   \n-  /* Make the arg.  */\n-  formal_arg = gfc_get_formal_arglist ();\n-  /* Add arg to list of formal args.  */\n-  add_formal_arg (head, tail, formal_arg, param_sym);\n-\n-  /* Validate changes.  */\n-  gfc_commit_symbol (param_sym);\n-}\n-\n-\n-/* Generates a symbol representing the optional SHAPE argument for the\n-   iso_c_binding c_f_pointer() procedure.  Also, create a\n-   gfc_formal_arglist for the SHAPE and add it to the provided\n-   argument list.  */\n-\n-static void\n-gen_shape_param (gfc_formal_arglist **head,\n-                 gfc_formal_arglist **tail,\n-                 const char *module_name,\n-                 gfc_namespace *ns, const char *shape_param_name)\n-{\n-  gfc_symbol *param_sym = NULL;\n-  gfc_symtree *param_symtree = NULL;\n-  gfc_formal_arglist *formal_arg = NULL;\n-  const char *shape_param = \"gfc_shape_array__\";\n-\n-  if (shape_param_name != NULL)\n-    shape_param = shape_param_name;\n-\n-  gfc_get_sym_tree (shape_param, ns, &param_symtree, false);\n-  if (param_symtree != NULL)\n-    param_sym = param_symtree->n.sym;\n-  else\n-    gfc_internal_error (\"generateShapeParam(): Unable to \"\n-\t\t\t\"create symbol for %s\", shape_param);\n-   \n-  /* Set up the necessary fields for the shape input param sym.  */\n-  param_sym->refs++;\n-  param_sym->attr.dummy = 1;\n-  param_sym->attr.use_assoc = 1;\n-\n-  /* Integer array, rank 1, describing the shape of the object.  Make it's\n-     type BT_VOID initially so we can accept any type/kind combination of\n-     integer.  During gfc_iso_c_sub_interface (resolve.c), we'll make it\n-     of BT_INTEGER type.  */\n-  param_sym->ts.type = BT_VOID;\n-\n-  /* Initialize the kind to default integer.  However, it will be overridden\n-     during resolution to match the kind of the SHAPE parameter given as\n-     the actual argument (to allow for any valid integer kind).  */\n-  param_sym->ts.kind = gfc_default_integer_kind;\n-  param_sym->as = gfc_get_array_spec ();\n-\n-  param_sym->as->rank = 1;\n-  param_sym->as->lower[0] = gfc_get_int_expr (gfc_default_integer_kind,\n-\t\t\t\t\t      NULL, 1);\n-\n-  /* The extent is unknown until we get it.  The length give us\n-     the rank the incoming pointer.  */\n-  param_sym->as->type = AS_ASSUMED_SHAPE;\n-\n-  /* The arg is also optional; it is required iff the second arg\n-     (fptr) is to an array, otherwise, it's ignored.  */\n-  param_sym->attr.optional = 1;\n-  param_sym->attr.intent = INTENT_IN;\n-  param_sym->attr.dimension = 1;\n-  param_sym->module = gfc_get_string (module_name);\n-   \n-  /* Make the arg.  */\n-  formal_arg = gfc_get_formal_arglist ();\n-  /* Add arg to list of formal args.  */\n-  add_formal_arg (head, tail, formal_arg, param_sym);\n-\n-  /* Validate changes.  */\n-  gfc_commit_symbol (param_sym);\n-}\n-\n-\n /* Add a procedure interface to the given symbol (i.e., store a\n    reference to the list of formal arguments).  */\n \n@@ -4314,74 +4077,6 @@ gfc_copy_formal_args_intr (gfc_symbol *dest, gfc_intrinsic_sym *src)\n }\n \n \n-/* Builds the parameter list for the iso_c_binding procedure\n-   c_f_pointer or c_f_procpointer.  The old_sym typically refers to a\n-   generic version of either the c_f_pointer or c_f_procpointer\n-   functions.  The new_proc_sym represents a \"resolved\" version of the\n-   symbol.  The functions are resolved to match the types of their\n-   parameters; for example, c_f_pointer(cptr, fptr) would resolve to\n-   something similar to c_f_pointer_i4 if the type of data object fptr\n-   pointed to was a default integer.  The actual name of the resolved\n-   procedure symbol is further mangled with the module name, etc., but\n-   the idea holds true.  */\n-\n-static void\n-build_formal_args (gfc_symbol *new_proc_sym,\n-                   gfc_symbol *old_sym, int add_optional_arg)\n-{\n-  gfc_formal_arglist *head = NULL, *tail = NULL;\n-  gfc_namespace *parent_ns = NULL;\n-\n-  parent_ns = gfc_current_ns;\n-  /* Create a new namespace, which will be the formal ns (namespace\n-     of the formal args).  */\n-  gfc_current_ns = gfc_get_namespace(parent_ns, 0);\n-  gfc_current_ns->proc_name = new_proc_sym;\n-\n-  /* Generate the params.  */\n-  if (old_sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER)\n-    {\n-      gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n-\t\t      gfc_current_ns, \"cptr\", old_sym->intmod_sym_id);\n-      gen_fptr_param (&head, &tail, (const char *) new_proc_sym->module,\n-\t\t      gfc_current_ns, \"fptr\", 1);\n-    }\n-  else if (old_sym->intmod_sym_id == ISOCBINDING_F_POINTER)\n-    {\n-      gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n-\t\t      gfc_current_ns, \"cptr\", old_sym->intmod_sym_id);\n-      gen_fptr_param (&head, &tail, (const char *) new_proc_sym->module,\n-\t\t      gfc_current_ns, \"fptr\", 0);\n-      /* If we're dealing with c_f_pointer, it has an optional third arg.  */\n-      gen_shape_param (&head, &tail,(const char *) new_proc_sym->module,\n-\t\t       gfc_current_ns, \"shape\");\n-\n-    }\n-  else if (old_sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n-    {\n-      /* c_associated has one required arg and one optional; both\n-\t are c_ptrs.  */\n-      gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n-\t\t      gfc_current_ns, \"c_ptr_1\", ISOCBINDING_ASSOCIATED);\n-      if (add_optional_arg)\n-\t{\n-\t  gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n-\t\t\t  gfc_current_ns, \"c_ptr_2\", ISOCBINDING_ASSOCIATED);\n-\t  /* The last param is optional so mark it as such.  */\n-\t  tail->sym->attr.optional = 1;\n-\t}\n-    }\n-\n-  /* Add the interface (store formal args to new_proc_sym).  */\n-  add_proc_interface (new_proc_sym, IFSRC_DECL, head);\n-\n-  /* Set up the formal_ns pointer to the one created for the\n-     new procedure so it'll get cleaned up during gfc_free_symbol().  */\n-  new_proc_sym->formal_ns = gfc_current_ns;\n-\n-  gfc_current_ns = parent_ns;\n-}\n-\n static int\n std_for_isocbinding_symbol (int id)\n {\n@@ -4396,8 +4091,12 @@ std_for_isocbinding_symbol (int id)\n #define NAMED_FUNCTION(a,b,c,d) \\\n       case a:\\\n         return d;\n+#define NAMED_SUBROUTINE(a,b,c,d) \\\n+      case a:\\\n+        return d;\n #include \"iso-c-binding.def\"\n #undef NAMED_FUNCTION\n+#undef NAMED_SUBROUTINE\n \n        default:\n          return GFC_STD_F2003;\n@@ -4412,23 +4111,29 @@ std_for_isocbinding_symbol (int id)\n    reported.  If the user does not give an 'only' clause, all\n    iso_c_binding symbols are generated.  If a list of specific kinds\n    is given, it must have a NULL in the first empty spot to mark the\n-   end of the list.  */\n+   end of the list. For C_null_(fun)ptr, dt_symtree has to be set and\n+   point to the symtree for c_(fun)ptr.  */\n \n-\n-void\n+gfc_symtree *\n generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n-\t\t\t     const char *local_name)\n+\t\t\t     const char *local_name, gfc_symtree *dt_symtree,\n+\t\t\t     bool hidden)\n {\n-  const char *const name = (local_name && local_name[0]) ? local_name\n-\t\t\t\t\t     : c_interop_kinds_table[s].name;\n-  gfc_symtree *tmp_symtree = NULL;\n+  const char *const name = (local_name && local_name[0])\n+\t\t\t   ? local_name : c_interop_kinds_table[s].name;\n+  gfc_symtree *tmp_symtree;\n   gfc_symbol *tmp_sym = NULL;\n   int index;\n \n   if (gfc_notification_std (std_for_isocbinding_symbol (s)) == ERROR)\n-    return;\n+    return NULL;\n \n   tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root, name);\n+  if (hidden\n+      && (!tmp_symtree || !tmp_symtree->n.sym\n+\t  || tmp_symtree->n.sym->from_intmod != INTMOD_ISO_C_BINDING\n+\t  || tmp_symtree->n.sym->intmod_sym_id != s))\n+    tmp_symtree = NULL;\n \n   /* Already exists in this scope so don't re-add it. */\n   if (tmp_symtree != NULL && (tmp_sym = tmp_symtree->n.sym) != NULL\n@@ -4446,21 +4151,40 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n   \t  gfc_derived_types = dt_list;\n         }\n \n-      return;\n+      return tmp_symtree;\n     }\n \n   /* Create the sym tree in the current ns.  */\n-  gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n-  if (tmp_symtree)\n-    tmp_sym = tmp_symtree->n.sym;\n+  if (hidden)\n+    {\n+      tmp_symtree = gfc_get_unique_symtree (gfc_current_ns);\n+      tmp_sym = gfc_new_symbol (name, gfc_current_ns);\n+\n+      /* Add to the list of tentative symbols.  */\n+      latest_undo_chgset->syms.safe_push (tmp_sym);\n+      tmp_sym->old_symbol = NULL;\n+      tmp_sym->mark = 1;\n+      tmp_sym->gfc_new = 1;\n+\n+      tmp_symtree->n.sym = tmp_sym;\n+      tmp_sym->refs++;\n+    }\n   else\n-    gfc_internal_error (\"generate_isocbinding_symbol(): Unable to \"\n-\t\t\t\"create symbol\");\n+    {\n+      gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n+      gcc_assert (tmp_symtree);\n+      tmp_sym = tmp_symtree->n.sym;\n+    }\n \n   /* Say what module this symbol belongs to.  */\n   tmp_sym->module = gfc_get_string (mod_name);\n   tmp_sym->from_intmod = INTMOD_ISO_C_BINDING;\n   tmp_sym->intmod_sym_id = s;\n+  tmp_sym->attr.is_iso_c = 1;\n+  tmp_sym->attr.use_assoc = 1;\n+\n+  gcc_assert (dt_symtree == NULL || s == ISOCBINDING_NULL_FUNPTR\n+\t      || s == ISOCBINDING_NULL_PTR);\n \n   switch (s)\n     {\n@@ -4490,11 +4214,6 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \t/* Tell what f90 type this c interop kind is valid.  */\n \ttmp_sym->ts.f90_type = c_interop_kinds_table[s].f90_type;\n \n-\t/* Say it's from the iso_c_binding module.  */\n-\ttmp_sym->attr.is_iso_c = 1;\n-\n-\t/* Make it use associated.  */\n-\ttmp_sym->attr.use_assoc = 1;\n \tbreak;\n \n \n@@ -4531,70 +4250,69 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \t/* Tell what f90 type this c interop kind is valid.  */\n \ttmp_sym->ts.f90_type = BT_CHARACTER;\n \n-\t/* Say it's from the iso_c_binding module.  */\n-\ttmp_sym->attr.is_iso_c = 1;\n-\n-\t/* Make it use associated.  */\n-\ttmp_sym->attr.use_assoc = 1;\n \tbreak;\n \n       case ISOCBINDING_PTR:\n       case ISOCBINDING_FUNPTR:\n \t{\n-\t  gfc_interface *intr, *head;\n \t  gfc_symbol *dt_sym;\n-\t  const char *hidden_name;\n \t  gfc_dt_list **dt_list_ptr = NULL;\n \t  gfc_component *tmp_comp = NULL;\n-\t  char comp_name[(GFC_MAX_SYMBOL_LEN * 2) + 1];\n-\n-\t  hidden_name = gfc_get_string (\"%c%s\",\n-\t\t\t    (char) TOUPPER ((unsigned char) tmp_sym->name[0]),\n-                            &tmp_sym->name[1]);\n \n \t  /* Generate real derived type.  */\n-\t  tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root,\n-\t\t\t\t\t  hidden_name);\n-\n-\t  if (tmp_symtree != NULL)\n-\t    gcc_unreachable ();\n-\t  gfc_get_sym_tree (hidden_name, gfc_current_ns, &tmp_symtree, false);\n-\t  if (tmp_symtree)\n-\t    dt_sym = tmp_symtree->n.sym;\n+\t  if (hidden)\n+\t    dt_sym = tmp_sym;\n \t  else\n-\t    gcc_unreachable ();\n-\n-\t  /* Generate an artificial generic function.  */\n-\t  dt_sym->name = gfc_get_string (tmp_sym->name);\n-\t  head = tmp_sym->generic;\n-\t  intr = gfc_get_interface ();\n-\t  intr->sym = dt_sym;\n-\t  intr->where = gfc_current_locus;\n-\t  intr->next = head;\n-\t  tmp_sym->generic = intr;\n-\n-\t  if (!tmp_sym->attr.generic\n-\t      && gfc_add_generic (&tmp_sym->attr, tmp_sym->name, NULL)\n-\t\t == FAILURE)\n-\t    return;\n-\n-\t  if (!tmp_sym->attr.function\n-\t      && gfc_add_function (&tmp_sym->attr, tmp_sym->name, NULL)\n-\t\t == FAILURE)\n-\t    return;\n+\t    {\n+\t      const char *hidden_name;\n+\t      gfc_interface *intr, *head;\n+\n+\t      hidden_name = gfc_get_string (\"%c%s\",\n+\t\t\t\t\t    (char) TOUPPER ((unsigned char)\n+\t\t\t\t\t\t\t      tmp_sym->name[0]),\n+\t\t\t\t\t    &tmp_sym->name[1]);\n+\t      tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root,\n+\t\t\t\t\t      hidden_name);\n+\t      gcc_assert (tmp_symtree == NULL);\n+\t      gfc_get_sym_tree (hidden_name, gfc_current_ns, &tmp_symtree, false);\n+\t      dt_sym = tmp_symtree->n.sym;\n+\t      dt_sym->name = gfc_get_string (s == ISOCBINDING_PTR\n+\t\t\t\t\t    ? \"c_ptr\" : \"c_funptr\");\n+\n+\t      /* Generate an artificial generic function.  */\n+\t      head = tmp_sym->generic;\n+\t      intr = gfc_get_interface ();\n+\t      intr->sym = dt_sym;\n+\t      intr->where = gfc_current_locus;\n+\t      intr->next = head;\n+\t      tmp_sym->generic = intr;\n+\n+\t      if (!tmp_sym->attr.generic\n+\t\t  && gfc_add_generic (&tmp_sym->attr, tmp_sym->name, NULL)\n+\t\t     == FAILURE)\n+\t\treturn NULL;\n+\n+\t      if (!tmp_sym->attr.function\n+\t\t  && gfc_add_function (&tmp_sym->attr, tmp_sym->name, NULL)\n+\t\t     == FAILURE)\n+\t\treturn NULL;\n+\t    }\n \n \t  /* Say what module this symbol belongs to.  */\n \t  dt_sym->module = gfc_get_string (mod_name);\n \t  dt_sym->from_intmod = INTMOD_ISO_C_BINDING;\n \t  dt_sym->intmod_sym_id = s;\n+          dt_sym->attr.use_assoc = 1;\n \n \t  /* Initialize an integer constant expression node.  */\n \t  dt_sym->attr.flavor = FL_DERIVED;\n \t  dt_sym->ts.is_c_interop = 1;\n \t  dt_sym->attr.is_c_interop = 1;\n-\t  dt_sym->attr.is_iso_c = 1;\n+\t  dt_sym->attr.private_comp = 1;\n+\t  dt_sym->component_access = ACCESS_PRIVATE;\n \t  dt_sym->ts.is_iso_c = 1;\n \t  dt_sym->ts.type = BT_DERIVED;\n+\t  dt_sym->ts.f90_type = BT_VOID;\n \n \t  /* A derived type must have the bind attribute to be\n \t     interoperable (J3/04-007, Section 15.2.3), even though\n@@ -4617,15 +4335,9 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \t  (*dt_list_ptr)->derived = dt_sym;\n \t  (*dt_list_ptr)->next = NULL;\n \n-\t  /* Set up the component of the derived type, which will be\n-\t     an integer with kind equal to c_ptr_size.  Mangle the name of\n-\t     the field for the c_address to prevent the curious user from\n-\t     trying to access it from Fortran.  */\n-\t  sprintf (comp_name, \"__%s_%s\", dt_sym->name, \"c_address\");\n-\t  gfc_add_component (dt_sym, comp_name, &tmp_comp);\n+\t  gfc_add_component (dt_sym, \"c_address\", &tmp_comp);\n \t  if (tmp_comp == NULL)\n-          gfc_internal_error (\"generate_isocbinding_symbol(): Unable to \"\n-\t\t\t      \"create component for c_address\");\n+\t    gcc_unreachable ();\n \n \t  tmp_comp->ts.type = BT_INTEGER;\n \n@@ -4635,163 +4347,24 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \t  /* The kinds for c_ptr and c_funptr are the same.  */\n \t  index = get_c_kind (\"c_ptr\", c_interop_kinds_table);\n \t  tmp_comp->ts.kind = c_interop_kinds_table[index].value;\n-\n-\t  tmp_comp->attr.pointer = 0;\n-\t  tmp_comp->attr.dimension = 0;\n+\t  tmp_comp->attr.access = ACCESS_PRIVATE;\n \n \t  /* Mark the component as C interoperable.  */\n \t  tmp_comp->ts.is_c_interop = 1;\n-\n-\t  /* Make it use associated (iso_c_binding module).  */\n-\t  dt_sym->attr.use_assoc = 1;\n \t}\n \n \tbreak;\n \n       case ISOCBINDING_NULL_PTR:\n       case ISOCBINDING_NULL_FUNPTR:\n-        gen_special_c_interop_ptr (s, name, mod_name);\n+        gen_special_c_interop_ptr (tmp_sym, dt_symtree);\n         break;\n \n-      case ISOCBINDING_F_POINTER:\n-      case ISOCBINDING_ASSOCIATED:\n-      case ISOCBINDING_LOC:\n-      case ISOCBINDING_FUNLOC:\n-      case ISOCBINDING_F_PROCPOINTER:\n-\n-\ttmp_sym->attr.proc = PROC_MODULE;\n-\n-        /* Use the procedure's name as it is in the iso_c_binding module for\n-           setting the binding label in case the user renamed the symbol.  */\n-\ttmp_sym->binding_label = \n-\t  gfc_get_string (\"%s_%s\", mod_name, \n-\t\t\t  c_interop_kinds_table[s].name);\n-\ttmp_sym->attr.is_iso_c = 1;\n-\tif (s == ISOCBINDING_F_POINTER || s == ISOCBINDING_F_PROCPOINTER)\n-\t  tmp_sym->attr.subroutine = 1;\n-\telse\n-\t  {\n-            /* TODO!  This needs to be finished more for the expr of the\n-               function or something!\n-               This may not need to be here, because trying to do c_loc\n-               as an external.  */\n-\t    if (s == ISOCBINDING_ASSOCIATED)\n-\t      {\n-\t\ttmp_sym->attr.function = 1;\n-\t\ttmp_sym->ts.type = BT_LOGICAL;\n-\t\ttmp_sym->ts.kind = gfc_default_logical_kind;\n-\t\ttmp_sym->result = tmp_sym;\n-\t      }\n-\t    else\n-\t      {\n-               /* Here, we're taking the simple approach.  We're defining\n-                  c_loc as an external identifier so the compiler will put\n-                  what we expect on the stack for the address we want the\n-                  C address of.  */\n-\t\ttmp_sym->ts.type = BT_DERIVED;\n-                if (s == ISOCBINDING_LOC)\n-                  tmp_sym->ts.u.derived =\n-                    get_iso_c_binding_dt (ISOCBINDING_PTR);\n-                else\n-                  tmp_sym->ts.u.derived =\n-                    get_iso_c_binding_dt (ISOCBINDING_FUNPTR);\n-\n-\t\tif (tmp_sym->ts.u.derived == NULL)\n-\t\t  {\n-                    /* Create the necessary derived type so we can continue\n-                       processing the file.  */\n-\t\t    generate_isocbinding_symbol\n-\t\t      (mod_name, s == ISOCBINDING_FUNLOC\n-\t\t\t\t? ISOCBINDING_FUNPTR : ISOCBINDING_PTR,\n-\t\t      (const char *)(s == ISOCBINDING_FUNLOC\n-\t\t\t\t? \"c_funptr\" : \"c_ptr\"));\n-                    tmp_sym->ts.u.derived =\n-\t\t    get_iso_c_binding_dt (s == ISOCBINDING_FUNLOC\n-\t\t\t\t\t    ? ISOCBINDING_FUNPTR\n-\t\t\t\t\t    : ISOCBINDING_PTR);\n-\t\t  }\n-\n-\t\t/* The function result is itself (no result clause).  */\n-\t\ttmp_sym->result = tmp_sym;\n-\t\ttmp_sym->attr.external = 1;\n-\t\ttmp_sym->attr.use_assoc = 0;\n-\t\ttmp_sym->attr.pure = 1;\n-\t\ttmp_sym->attr.if_source = IFSRC_UNKNOWN;\n-\t\ttmp_sym->attr.proc = PROC_UNKNOWN;\n-\t      }\n-\t  }\n-\n-\ttmp_sym->attr.flavor = FL_PROCEDURE;\n-\ttmp_sym->attr.contained = 0;\n-\t\n-       /* Try using this builder routine, with the new and old symbols\n-          both being the generic iso_c proc sym being created.  This\n-          will create the formal args (and the new namespace for them).\n-          Don't build an arg list for c_loc because we're going to treat\n-          c_loc as an external procedure.  */\n-\tif (s != ISOCBINDING_LOC && s != ISOCBINDING_FUNLOC)\n-          /* The 1 says to add any optional args, if applicable.  */\n-\t  build_formal_args (tmp_sym, tmp_sym, 1);\n-\n-        /* Set this after setting up the symbol, to prevent error messages.  */\n-\ttmp_sym->attr.use_assoc = 1;\n-\n-        /* This symbol will not be referenced directly.  It will be\n-           resolved to the implementation for the given f90 kind.  */\n-\ttmp_sym->attr.referenced = 0;\n-\n-\tbreak;\n-\n       default:\n \tgcc_unreachable ();\n     }\n   gfc_commit_symbol (tmp_sym);\n-}\n-\n-\n-/* Creates a new symbol based off of an old iso_c symbol, with a new\n-   binding label.  This function can be used to create a new,\n-   resolved, version of a procedure symbol for c_f_pointer or\n-   c_f_procpointer that is based on the generic symbols.  A new\n-   parameter list is created for the new symbol using\n-   build_formal_args().  The add_optional_flag specifies whether the\n-   to add the optional SHAPE argument.  The new symbol is\n-   returned.  */\n-\n-gfc_symbol *\n-get_iso_c_sym (gfc_symbol *old_sym, char *new_name,\n-               const char *new_binding_label, int add_optional_arg)\n-{\n-  gfc_symtree *new_symtree = NULL;\n-\n-  /* See if we have a symbol by that name already available, looking\n-     through any parent namespaces.  */\n-  gfc_find_sym_tree (new_name, gfc_current_ns, 1, &new_symtree);\n-  if (new_symtree != NULL)\n-    /* Return the existing symbol.  */\n-    return new_symtree->n.sym;\n-\n-  /* Create the symtree/symbol, with attempted host association.  */\n-  gfc_get_ha_sym_tree (new_name, &new_symtree);\n-  if (new_symtree == NULL)\n-    gfc_internal_error (\"get_iso_c_sym(): Unable to create \"\n-\t\t\t\"symtree for '%s'\", new_name);\n-\n-  /* Now fill in the fields of the resolved symbol with the old sym.  */\n-  new_symtree->n.sym->binding_label = new_binding_label;\n-  new_symtree->n.sym->attr = old_sym->attr;\n-  new_symtree->n.sym->ts = old_sym->ts;\n-  new_symtree->n.sym->module = gfc_get_string (old_sym->module);\n-  new_symtree->n.sym->from_intmod = old_sym->from_intmod;\n-  new_symtree->n.sym->intmod_sym_id = old_sym->intmod_sym_id;\n-  if (old_sym->attr.function)\n-    new_symtree->n.sym->result = new_symtree->n.sym;\n-  /* Build the formal arg list.  */\n-  build_formal_args (new_symtree->n.sym, old_sym, add_optional_arg);\n-\n-  gfc_commit_symbol (new_symtree->n.sym);\n-\n-  return new_symtree->n.sym;\n+  return tmp_symtree;\n }\n \n "}, {"sha": "7633516664ab18ae5c8ac9796e3ffe068ffb83de", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -316,6 +316,17 @@ gfc_target_encode_expr (gfc_expr *source, unsigned char *buffer,\n \t}\n \n     case BT_DERIVED:\n+      if (source->ts.u.derived->ts.f90_type == BT_VOID)\n+\t{\n+\t  gfc_constructor *c;\n+\t  gcc_assert (source->expr_type == EXPR_STRUCTURE);\n+\t  c = gfc_constructor_first (source->value.constructor);\n+\t  gcc_assert (c->expr->expr_type == EXPR_CONSTANT\n+\t\t      && c->expr->ts.type == BT_INTEGER);\n+\t  return encode_integer (gfc_index_integer_kind, c->expr->value.integer,\n+\t\t\t\t buffer, buffer_size);\n+\t}\n+\n       return encode_derived (source, buffer, buffer_size);\n     default:\n       gfc_internal_error (\"Invalid expression in gfc_target_encode_expr.\");"}, {"sha": "06afc4f63e03ab52283386aa51cb41bafb4405d9", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 5, "deletions": 233, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -3695,229 +3695,6 @@ conv_arglist_function (gfc_se *se, gfc_expr *expr, const char *name)\n }\n \n \n-/* The following routine generates code for the intrinsic\n-   procedures from the ISO_C_BINDING module:\n-    * C_LOC           (function)\n-    * C_FUNLOC        (function)\n-    * C_F_POINTER     (subroutine)\n-    * C_F_PROCPOINTER (subroutine)\n-    * C_ASSOCIATED    (function)\n-   One exception which is not handled here is C_F_POINTER with non-scalar\n-   arguments. Returns 1 if the call was replaced by inline code (else: 0).  */\n-\n-static int\n-conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n-\t\t\t    gfc_actual_arglist * arg)\n-{\n-  gfc_symbol *fsym;\n-\n-  if (sym->intmod_sym_id == ISOCBINDING_LOC)\n-    {\n-      if (arg->expr->rank == 0)\n-\tgfc_conv_expr_reference (se, arg->expr);\n-      else\n-\t{\n-\t  int f;\n-\t  /* This is really the actual arg because no formal arglist is\n-\t     created for C_LOC.\t */\n-\t  fsym = arg->expr->symtree->n.sym;\n-\n-\t  /* We should want it to do g77 calling convention.  */\n-\t  f = (fsym != NULL)\n-\t    && !(fsym->attr.pointer || fsym->attr.allocatable)\n-\t    && fsym->as->type != AS_ASSUMED_SHAPE;\n-\t  f = f || !sym->attr.always_explicit;\n-\n-\t  gfc_conv_array_parameter (se, arg->expr, f, NULL, NULL, NULL);\n-\t}\n-\n-      /* TODO -- the following two lines shouldn't be necessary, but if\n-\t they're removed, a bug is exposed later in the code path.\n-\t This workaround was thus introduced, but will have to be\n-\t removed; please see PR 35150 for details about the issue.  */\n-      se->expr = convert (pvoid_type_node, se->expr);\n-      se->expr = gfc_evaluate_now (se->expr, &se->pre);\n-\n-      return 1;\n-    }\n-  else if (sym->intmod_sym_id == ISOCBINDING_FUNLOC)\n-    {\n-      arg->expr->ts.type = sym->ts.u.derived->ts.type;\n-      arg->expr->ts.f90_type = sym->ts.u.derived->ts.f90_type;\n-      arg->expr->ts.kind = sym->ts.u.derived->ts.kind;\n-      gfc_conv_expr_reference (se, arg->expr);\n-\n-      return 1;\n-    }\n-  else if (sym->intmod_sym_id == ISOCBINDING_F_POINTER\n-\t   || sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER)\n-    {\n-      /* Convert c_f_pointer and c_f_procpointer.  */\n-      gfc_se cptrse;\n-      gfc_se fptrse;\n-      gfc_se shapese;\n-      gfc_ss *shape_ss;\n-      tree desc, dim, tmp, stride, offset;\n-      stmtblock_t body, block;\n-      gfc_loopinfo loop;\n-\n-      gfc_init_se (&cptrse, NULL);\n-      gfc_conv_expr (&cptrse, arg->expr);\n-      gfc_add_block_to_block (&se->pre, &cptrse.pre);\n-      gfc_add_block_to_block (&se->post, &cptrse.post);\n-\n-      gfc_init_se (&fptrse, NULL);\n-      if (arg->next->expr->rank == 0)\n-\t{\n-\t  if (sym->intmod_sym_id == ISOCBINDING_F_POINTER\n-\t      || gfc_is_proc_ptr_comp (arg->next->expr))\n-\t    fptrse.want_pointer = 1;\n-\n-\t  gfc_conv_expr (&fptrse, arg->next->expr);\n-\t  gfc_add_block_to_block (&se->pre, &fptrse.pre);\n-\t  gfc_add_block_to_block (&se->post, &fptrse.post);\n-\t  if (arg->next->expr->symtree->n.sym->attr.proc_pointer\n-\t      && arg->next->expr->symtree->n.sym->attr.dummy)\n-\t    fptrse.expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t       fptrse.expr);\n-     \t  se->expr = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t      TREE_TYPE (fptrse.expr),\n-\t\t\t\t      fptrse.expr,\n-\t\t\t\t      fold_convert (TREE_TYPE (fptrse.expr),\n-\t\t\t\t\t\t    cptrse.expr));\n-\t  return 1;\n-\t}\n-\n-      gfc_start_block (&block);\n-\n-      /* Get the descriptor of the Fortran pointer.  */\n-      fptrse.descriptor_only = 1;\n-      gfc_conv_expr_descriptor (&fptrse, arg->next->expr);\n-      gfc_add_block_to_block (&block, &fptrse.pre);\n-      desc = fptrse.expr;\n-\n-      /* Set data value, dtype, and offset.  */\n-      tmp = GFC_TYPE_ARRAY_DATAPTR_TYPE (TREE_TYPE (desc));\n-      gfc_conv_descriptor_data_set (&block, desc,\n-\t\t\t\t    fold_convert (tmp, cptrse.expr));\n-      gfc_add_modify (&block, gfc_conv_descriptor_dtype (desc),\n-\t\t      gfc_get_dtype (TREE_TYPE (desc)));\n-\n-      /* Start scalarization of the bounds, using the shape argument.  */\n-\n-      shape_ss = gfc_walk_expr (arg->next->next->expr);\n-      gcc_assert (shape_ss != gfc_ss_terminator);\n-      gfc_init_se (&shapese, NULL);\n-\n-      gfc_init_loopinfo (&loop);\n-      gfc_add_ss_to_loop (&loop, shape_ss);\n-      gfc_conv_ss_startstride (&loop);\n-      gfc_conv_loop_setup (&loop, &arg->next->expr->where);\n-      gfc_mark_ss_chain_used (shape_ss, 1);\n-\n-      gfc_copy_loopinfo_to_se (&shapese, &loop);\n-      shapese.ss = shape_ss;\n-\n-      stride = gfc_create_var (gfc_array_index_type, \"stride\");\n-      offset = gfc_create_var (gfc_array_index_type, \"offset\");\n-      gfc_add_modify (&block, stride, gfc_index_one_node);\n-      gfc_add_modify (&block, offset, gfc_index_zero_node);\n-\n-      /* Loop body.  */\n-      gfc_start_scalarized_body (&loop, &body);\n-\n-      dim = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     loop.loopvar[0], loop.from[0]);\n-\n-      /* Set bounds and stride. */\n-      gfc_conv_descriptor_lbound_set (&body, desc, dim, gfc_index_one_node);\n-      gfc_conv_descriptor_stride_set (&body, desc, dim, stride);\n-\n-      gfc_conv_expr (&shapese, arg->next->next->expr);\n-      gfc_add_block_to_block (&body, &shapese.pre);\n-      gfc_conv_descriptor_ubound_set (&body, desc, dim, shapese.expr);\n-      gfc_add_block_to_block (&body, &shapese.post);\n-\n-      /* Calculate offset. */\n-      gfc_add_modify (&body, offset,\n-\t\t      fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t       gfc_array_index_type, offset, stride));\n-      /* Update stride.  */\n-      gfc_add_modify (&body, stride,\n-\t\t      fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t       gfc_array_index_type, stride,\n-\t\t\t\t       fold_convert (gfc_array_index_type,\n-\t\t\t\t\t\t     shapese.expr)));\n-      /* Finish scalarization loop.  */\n-      gfc_trans_scalarizing_loops (&loop, &body);\n-      gfc_add_block_to_block (&block, &loop.pre);\n-      gfc_add_block_to_block (&block, &loop.post);\n-      gfc_add_block_to_block (&block, &fptrse.post);\n-      gfc_cleanup_loop (&loop);\n-\n-      gfc_add_modify (&block, offset,\n-\t\t      fold_build1_loc (input_location, NEGATE_EXPR,\n-\t\t\t\t       gfc_array_index_type, offset));\n-      gfc_conv_descriptor_offset_set (&block, desc, offset);\n-\n-      se->expr = gfc_finish_block (&block);\n-      return 1;\n-    }\n-  else if (sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n-    {\n-      gfc_se arg1se;\n-      gfc_se arg2se;\n-\n-      /* Build the addr_expr for the first argument.  The argument is\n-\t already an *address* so we don't need to set want_pointer in\n-\t the gfc_se.  */\n-      gfc_init_se (&arg1se, NULL);\n-      gfc_conv_expr (&arg1se, arg->expr);\n-      gfc_add_block_to_block (&se->pre, &arg1se.pre);\n-      gfc_add_block_to_block (&se->post, &arg1se.post);\n-\n-      /* See if we were given two arguments.  */\n-      if (arg->next == NULL)\n-\t/* Only given one arg so generate a null and do a\n-\t   not-equal comparison against the first arg.  */\n-\tse->expr = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n-\t\t\t\t    arg1se.expr,\n-\t\t\t\t    fold_convert (TREE_TYPE (arg1se.expr),\n-\t\t\t\t\t\t  null_pointer_node));\n-      else\n-\t{\n-\t  tree eq_expr;\n-\t  tree not_null_expr;\n-\n-\t  /* Given two arguments so build the arg2se from second arg.  */\n-\t  gfc_init_se (&arg2se, NULL);\n-\t  gfc_conv_expr (&arg2se, arg->next->expr);\n-\t  gfc_add_block_to_block (&se->pre, &arg2se.pre);\n-\t  gfc_add_block_to_block (&se->post, &arg2se.post);\n-\n-\t  /* Generate test to compare that the two args are equal.  */\n-\t  eq_expr = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n-\t\t\t\t     arg1se.expr, arg2se.expr);\n-\t  /* Generate test to ensure that the first arg is not null.  */\n-\t  not_null_expr = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t   boolean_type_node,\n-\t\t\t\t\t   arg1se.expr, null_pointer_node);\n-\n-\t  /* Finally, the generated test must check that both arg1 is not\n-\t     NULL and that it is equal to the second arg.  */\n-\t  se->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t      boolean_type_node,\n-\t\t\t\t      not_null_expr, eq_expr);\n-\t}\n-\n-      return 1;\n-    }\n-\n-  /* Nothing was done.  */\n-  return 0;\n-}\n-\n-\n /* Generate code for a procedure call.  Note can return se->post != NULL.\n    If se->direct_byref is set then se->expr contains the return parameter.\n    Return nonzero, if the call has alternate specifiers.\n@@ -3964,10 +3741,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   len = NULL_TREE;\n   gfc_clear_ts (&ts);\n \n-  if (sym->from_intmod == INTMOD_ISO_C_BINDING\n-      && conv_isocbinding_procedure (se, sym, args))\n-    return 0;\n-\n   comp = gfc_get_proc_ptr_comp (expr);\n \n   if (se->ss != NULL)\n@@ -6013,7 +5786,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n     }\n-  else if (expr->ts.type == BT_DERIVED)\n+  else if (expr->ts.type == BT_DERIVED && expr->ts.f90_type != BT_VOID)\n     {\n       if (expr->expr_type != EXPR_STRUCTURE)\n \t{\n@@ -6224,8 +5997,7 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n      null_pointer_node.  C_PTR and C_FUNPTR are converted to match the\n      typespec for the C_PTR and C_FUNPTR symbols, which has already been\n      updated to be an integer with a kind equal to the size of a (void *).  */\n-  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived\n-      && expr->ts.u.derived->attr.is_iso_c)\n+  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->ts.f90_type == BT_VOID)\n     {\n       if (expr->expr_type == EXPR_VARIABLE\n \t  && (expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_PTR\n@@ -6240,9 +6012,9 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n         {\n           /* Update the type/kind of the expression to be what the new\n              type/kind are for the updated symbols of C_PTR/C_FUNPTR.  */\n-          expr->ts.type = expr->ts.u.derived->ts.type;\n-          expr->ts.f90_type = expr->ts.u.derived->ts.f90_type;\n-          expr->ts.kind = expr->ts.u.derived->ts.kind;\n+          expr->ts.type = BT_INTEGER;\n+          expr->ts.f90_type = BT_VOID;\n+          expr->ts.kind = gfc_index_integer_kind;\n         }\n     }\n "}, {"sha": "9b2cc19509e9f6b07635b99d7332bbc67f0c48e7", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -6301,6 +6301,208 @@ gfc_conv_intrinsic_loc (gfc_se * se, gfc_expr * expr)\n   se->expr = temp_var;\n }\n \n+\n+/* The following routine generates code for the intrinsic\n+   functions from the ISO_C_BINDING module:\n+    * C_LOC\n+    * C_FUNLOC\n+    * C_ASSOCIATED  */\n+\n+static void\n+conv_isocbinding_function (gfc_se *se, gfc_expr *expr)\n+{\n+  gfc_actual_arglist *arg = expr->value.function.actual;\n+\n+  if (expr->value.function.isym->id == GFC_ISYM_C_LOC)\n+    {\n+      if (arg->expr->rank == 0)\n+\tgfc_conv_expr_reference (se, arg->expr);\n+      else\n+\tgfc_conv_array_parameter (se, arg->expr, true, NULL, NULL, NULL);\n+\n+      /* TODO -- the following two lines shouldn't be necessary, but if\n+\t they're removed, a bug is exposed later in the code path.\n+\t This workaround was thus introduced, but will have to be\n+\t removed; please see PR 35150 for details about the issue.  */\n+      se->expr = convert (pvoid_type_node, se->expr);\n+      se->expr = gfc_evaluate_now (se->expr, &se->pre);\n+    }\n+  else if (expr->value.function.isym->id == GFC_ISYM_C_FUNLOC)\n+    gfc_conv_expr_reference (se, arg->expr);\n+  else if (expr->value.function.isym->id == GFC_ISYM_C_ASSOCIATED)\n+    {\n+      gfc_se arg1se;\n+      gfc_se arg2se;\n+\n+      /* Build the addr_expr for the first argument.  The argument is\n+\t already an *address* so we don't need to set want_pointer in\n+\t the gfc_se.  */\n+      gfc_init_se (&arg1se, NULL);\n+      gfc_conv_expr (&arg1se, arg->expr);\n+      gfc_add_block_to_block (&se->pre, &arg1se.pre);\n+      gfc_add_block_to_block (&se->post, &arg1se.post);\n+\n+      /* See if we were given two arguments.  */\n+      if (arg->next->expr == NULL)\n+\t/* Only given one arg so generate a null and do a\n+\t   not-equal comparison against the first arg.  */\n+\tse->expr = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t    arg1se.expr,\n+\t\t\t\t    fold_convert (TREE_TYPE (arg1se.expr),\n+\t\t\t\t\t\t  null_pointer_node));\n+      else\n+\t{\n+\t  tree eq_expr;\n+\t  tree not_null_expr;\n+\n+\t  /* Given two arguments so build the arg2se from second arg.  */\n+\t  gfc_init_se (&arg2se, NULL);\n+\t  gfc_conv_expr (&arg2se, arg->next->expr);\n+\t  gfc_add_block_to_block (&se->pre, &arg2se.pre);\n+\t  gfc_add_block_to_block (&se->post, &arg2se.post);\n+\n+\t  /* Generate test to compare that the two args are equal.  */\n+\t  eq_expr = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t     arg1se.expr, arg2se.expr);\n+\t  /* Generate test to ensure that the first arg is not null.  */\n+\t  not_null_expr = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t   arg1se.expr, null_pointer_node);\n+\n+\t  /* Finally, the generated test must check that both arg1 is not\n+\t     NULL and that it is equal to the second arg.  */\n+\t  se->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t      boolean_type_node,\n+\t\t\t\t      not_null_expr, eq_expr);\n+\t}\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+\n+/* The following routine generates code for the intrinsic\n+   subroutines from the ISO_C_BINDING module:\n+    * C_F_POINTER\n+    * C_F_PROCPOINTER.  */\n+\n+static tree\n+conv_isocbinding_subroutine (gfc_code *code)\n+{\n+  gfc_se se;\n+  gfc_se cptrse;\n+  gfc_se fptrse;\n+  gfc_se shapese;\n+  gfc_ss *shape_ss;\n+  tree desc, dim, tmp, stride, offset;\n+  stmtblock_t body, block;\n+  gfc_loopinfo loop;\n+  gfc_actual_arglist *arg = code->ext.actual;\n+\n+  gfc_init_se (&se, NULL);\n+  gfc_init_se (&cptrse, NULL);\n+  gfc_conv_expr (&cptrse, arg->expr);\n+  gfc_add_block_to_block (&se.pre, &cptrse.pre);\n+  gfc_add_block_to_block (&se.post, &cptrse.post);\n+\n+  gfc_init_se (&fptrse, NULL);\n+  if (arg->next->expr->rank == 0)\n+    {\n+      fptrse.want_pointer = 1;\n+      gfc_conv_expr (&fptrse, arg->next->expr);\n+      gfc_add_block_to_block (&se.pre, &fptrse.pre);\n+      gfc_add_block_to_block (&se.post, &fptrse.post);\n+      if (arg->next->expr->symtree->n.sym->attr.proc_pointer\n+\t  && arg->next->expr->symtree->n.sym->attr.dummy)\n+\tfptrse.expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t       fptrse.expr);\n+      se.expr = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t TREE_TYPE (fptrse.expr),\n+\t\t\t\t fptrse.expr,\n+\t\t\t\t fold_convert (TREE_TYPE (fptrse.expr),\n+\t\t\t\t\t       cptrse.expr));\n+      gfc_add_expr_to_block (&se.pre, se.expr);\n+      gfc_add_block_to_block (&se.pre, &se.post);\n+      return gfc_finish_block (&se.pre);\n+    }\n+\n+  gfc_start_block (&block);\n+\n+  /* Get the descriptor of the Fortran pointer.  */\n+  fptrse.descriptor_only = 1;\n+  gfc_conv_expr_descriptor (&fptrse, arg->next->expr);\n+  gfc_add_block_to_block (&block, &fptrse.pre);\n+  desc = fptrse.expr;\n+\n+  /* Set data value, dtype, and offset.  */\n+  tmp = GFC_TYPE_ARRAY_DATAPTR_TYPE (TREE_TYPE (desc));\n+  gfc_conv_descriptor_data_set (&block, desc, fold_convert (tmp, cptrse.expr));\n+  gfc_add_modify (&block, gfc_conv_descriptor_dtype (desc),\n+\t\t  gfc_get_dtype (TREE_TYPE (desc)));\n+\n+  /* Start scalarization of the bounds, using the shape argument.  */\n+\n+  shape_ss = gfc_walk_expr (arg->next->next->expr);\n+  gcc_assert (shape_ss != gfc_ss_terminator);\n+  gfc_init_se (&shapese, NULL);\n+\n+  gfc_init_loopinfo (&loop);\n+  gfc_add_ss_to_loop (&loop, shape_ss);\n+  gfc_conv_ss_startstride (&loop);\n+  gfc_conv_loop_setup (&loop, &arg->next->expr->where);\n+  gfc_mark_ss_chain_used (shape_ss, 1);\n+\n+  gfc_copy_loopinfo_to_se (&shapese, &loop);\n+  shapese.ss = shape_ss;\n+\n+  stride = gfc_create_var (gfc_array_index_type, \"stride\");\n+  offset = gfc_create_var (gfc_array_index_type, \"offset\");\n+  gfc_add_modify (&block, stride, gfc_index_one_node);\n+  gfc_add_modify (&block, offset, gfc_index_zero_node);\n+\n+  /* Loop body.  */\n+  gfc_start_scalarized_body (&loop, &body);\n+\n+  dim = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     loop.loopvar[0], loop.from[0]);\n+\n+  /* Set bounds and stride. */\n+  gfc_conv_descriptor_lbound_set (&body, desc, dim, gfc_index_one_node);\n+  gfc_conv_descriptor_stride_set (&body, desc, dim, stride);\n+\n+  gfc_conv_expr (&shapese, arg->next->next->expr);\n+  gfc_add_block_to_block (&body, &shapese.pre);\n+  gfc_conv_descriptor_ubound_set (&body, desc, dim, shapese.expr);\n+  gfc_add_block_to_block (&body, &shapese.post);\n+\n+  /* Calculate offset. */\n+  gfc_add_modify (&body, offset,\n+\t\t  fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t   gfc_array_index_type, offset, stride));\n+  /* Update stride.  */\n+  gfc_add_modify (&body, stride,\n+\t\t  fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t   gfc_array_index_type, stride,\n+\t\t\t\t   fold_convert (gfc_array_index_type,\n+\t\t\t\t\t\t shapese.expr)));\n+  /* Finish scalarization loop.  */\n+  gfc_trans_scalarizing_loops (&loop, &body);\n+  gfc_add_block_to_block (&block, &loop.pre);\n+  gfc_add_block_to_block (&block, &loop.post);\n+  gfc_add_block_to_block (&block, &fptrse.post);\n+  gfc_cleanup_loop (&loop);\n+\n+  gfc_add_modify (&block, offset,\n+\t\t  fold_build1_loc (input_location, NEGATE_EXPR,\n+\t\t\t\t   gfc_array_index_type, offset));\n+  gfc_conv_descriptor_offset_set (&block, desc, offset);\n+\n+  gfc_add_expr_to_block (&se.pre, gfc_finish_block (&block));\n+  gfc_add_block_to_block (&se.pre, &se.post);\n+  return gfc_finish_block (&se.pre);\n+}\n+\n+\n /* Generate code for an intrinsic function.  Some map directly to library\n    calls, others get special handling.  In some cases the name of the function\n    used depends on the type specifiers.  */\n@@ -6476,6 +6678,12 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_bitcomp (se, expr, LT_EXPR);\n       break;\n \n+    case GFC_ISYM_C_ASSOCIATED:\n+    case GFC_ISYM_C_FUNLOC:\n+    case GFC_ISYM_C_LOC:\n+      conv_isocbinding_function (se, expr);\n+      break;\n+\n     case GFC_ISYM_ACHAR:\n     case GFC_ISYM_CHAR:\n       gfc_conv_intrinsic_char (se, expr);\n@@ -7585,6 +7793,12 @@ gfc_conv_intrinsic_subroutine (gfc_code *code)\n       res = conv_intrinsic_atomic_ref (code);\n       break;\n \n+    case GFC_ISYM_C_F_POINTER:\n+    case GFC_ISYM_C_F_PROCPOINTER:\n+      res = conv_isocbinding_subroutine (code);\n+      break;\n+\n+\n     default:\n       res = NULL_TREE;\n       break;"}, {"sha": "d60d15faf284535487850a71b936c17a7b6755c6", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -2026,20 +2026,8 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n       && ts->u.derived != NULL\n       && (ts->is_iso_c == 1 || ts->u.derived->ts.is_iso_c == 1))\n     {\n-      /* C_PTR and C_FUNPTR have private components which means they can not\n-         be printed.  However, if -std=gnu and not -pedantic, allow\n-         the component to be printed to help debugging.  */\n-      if (gfc_notification_std (GFC_STD_GNU) != SILENT)\n-\t{\n-\t  gfc_error_now (\"Derived type '%s' at %L has PRIVATE components\",\n-\t\t\t ts->u.derived->name, code != NULL ? &(code->loc) : \n-\t\t\t &gfc_current_locus);\n-\t  return;\n-\t}\n-\n-      ts->type = ts->u.derived->ts.type;\n-      ts->kind = ts->u.derived->ts.kind;\n-      ts->f90_type = ts->u.derived->ts.f90_type;\n+      ts->type = BT_INTEGER;\n+      ts->kind = gfc_index_integer_kind;\n     }\n   \n   kind = ts->kind;"}, {"sha": "4f4c05840bcd7bb60b0ecf86b124d69563109a7d", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -338,12 +338,11 @@ gfc_init_c_interop_kinds (void)\n   strncpy (c_interop_kinds_table[a].name, b, strlen(b) + 1); \\\n   c_interop_kinds_table[a].f90_type = BT_DERIVED; \\\n   c_interop_kinds_table[a].value = c;\n-#define PROCEDURE(a,b) \\\n+#define NAMED_FUNCTION(a,b,c,d) \\\n   strncpy (c_interop_kinds_table[a].name, b, strlen(b) + 1); \\\n   c_interop_kinds_table[a].f90_type = BT_PROCEDURE; \\\n-  c_interop_kinds_table[a].value = 0;\n-#include \"iso-c-binding.def\"\n-#define NAMED_FUNCTION(a,b,c,d) \\\n+  c_interop_kinds_table[a].value = c;\n+#define NAMED_SUBROUTINE(a,b,c,d) \\\n   strncpy (c_interop_kinds_table[a].name, b, strlen(b) + 1); \\\n   c_interop_kinds_table[a].f90_type = BT_PROCEDURE; \\\n   c_interop_kinds_table[a].value = c;\n@@ -1111,11 +1110,11 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n          type and kind to fit a (void *) and the basetype returned was a\n          ptr_type_node.  We need to pass up this new information to the\n          symbol that was declared of type C_PTR or C_FUNPTR.  */\n-      if (spec->u.derived->attr.is_iso_c)\n+      if (spec->u.derived->ts.f90_type == BT_VOID)\n         {\n-          spec->type = spec->u.derived->ts.type;\n-          spec->kind = spec->u.derived->ts.kind;\n-          spec->f90_type = spec->u.derived->ts.f90_type;\n+          spec->type = BT_INTEGER;\n+          spec->kind = gfc_index_integer_kind;\n+          spec->f90_type = BT_VOID;\n         }\n       break;\n     case BT_VOID:\n@@ -2349,7 +2348,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n     derived = gfc_find_dt_in_generic (derived);\n \n   /* See if it's one of the iso_c_binding derived types.  */\n-  if (derived->attr.is_iso_c == 1)\n+  if (derived->attr.is_iso_c == 1 || derived->ts.f90_type == BT_VOID)\n     {\n       if (derived->backend_decl)\n \treturn derived->backend_decl;"}, {"sha": "7fef6065e97f40b62447505c31622df221ac2914", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -1,3 +1,61 @@\n+2013-03-25  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/38536\n+\tPR fortran/38813\n+\tPR fortran/38894\n+\tPR fortran/39288\n+\tPR fortran/40963\n+\tPR fortran/45824\n+\tPR fortran/47023\n+\tPR fortran/47034\n+\tPR fortran/49023\n+\tPR fortran/50269\n+\tPR fortran/50612\n+\tPR fortran/52426\n+\tPR fortran/54263\n+\tPR fortran/55343\n+\tPR fortran/55444\n+\tPR fortran/55574\n+\tPR fortran/56079\n+\tPR fortran/56378\n+\t* gfortran.dg/c_assoc_2.f03: Update dg-error wording.\n+\t* gfortran.dg/c_f_pointer_shape_test.f90: Ditto.\n+\t* gfortran.dg/c_f_pointer_shape_tests_3.f03: Ditto.\n+\t* gfortran.dg/c_f_pointer_tests_5.f90: Ditto.\n+\t* gfortran.dg/c_funloc_tests_2.f03: Ditto.\n+\t* gfortran.dg/c_funloc_tests_5.f03: Ditto.\n+\t* gfortran.dg/c_funloc_tests_6.f90: Ditto.\n+\t* gfortran.dg/c_loc_tests_10.f03: Add -std=f2008.\n+\t* gfortran.dg/c_loc_tests_11.f03: Ditto, update dg-error.\n+\t* gfortran.dg/c_loc_tests_16.f90: Ditto.\n+\t* gfortran.dg/c_loc_tests_4.f03: Ditto.\n+\t* gfortran.dg/c_loc_tests_15.f90: Update dg-error wording.\n+\t* gfortran.dg/c_loc_tests_3.f03: Valid since F2003 TC5.\n+\t* gfortran.dg/c_loc_tests_8.f03: Ditto.\n+\t* gfortran.dg/c_ptr_tests_14.f90: Update scan-tree-dump-times.\n+\t* gfortran.dg/c_ptr_tests_15.f90: Ditto.\n+\t* gfortran.dg/c_sizeof_1.f90: Fix invalid code.\n+\t* gfortran.dg/iso_c_binding_init_expr.f03: Update dg-error wording.\n+\t* gfortran.dg/pr32601_1.f03: Ditto.\n+\t* gfortran.dg/storage_size_2.f08: Remove dg-error.\n+\t* gfortran.dg/blockdata_7.f90: New.\n+\t* gfortran.dg/c_assoc_4.f90: New.\n+\t* gfortran.dg/c_f_pointer_tests_6.f90: New.\n+\t* gfortran.dg/c_f_pointer_tests_7.f90: New.\n+\t* gfortran.dg/c_funloc_tests_8.f90: New.\n+\t* gfortran.dg/c_loc_test_17.f90: New.\n+\t* gfortran.dg/c_loc_test_18.f90: New.\n+\t* gfortran.dg/c_loc_test_19.f90: New.\n+\t* gfortran.dg/c_loc_test_20.f90: New.\n+\t* gfortran.dg/c_sizeof_5.f90: New.\n+\t* gfortran.dg/iso_c_binding_rename_3.f90: New.\n+\t* gfortran.dg/transfer_resolve_2.f90: New.\n+\t* gfortran.dg/transfer_resolve_3.f90: New.\n+\t* gfortran.dg/transfer_resolve_4.f90: New.\n+\t* gfortran.dg/pr32601.f03: Update dg-error.\n+\t* gfortran.dg/c_ptr_tests_13.f03: Update dg-error.\n+\t* gfortran.dg/c_ptr_tests_9.f03: Fix test case.\n+\n 2013-03-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/arm/vseleqdf.c: New test."}, {"sha": "b7de9642cd5f00d8b8f747dde3b94bb3b185f7c3", "filename": "gcc/testsuite/gfortran.dg/blockdata_7.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fblockdata_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fblockdata_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblockdata_7.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+!\n+! PR fortran/55444\n+!\n+! Contributed by Henrik Holst\n+!\n+      BLOCKDATA\n+!       USE ISO_C_BINDING, ONLY: C_INT, C_FLOAT ! WORKS\n+        USE :: ISO_C_BINDING  ! FAILS\n+        INTEGER(C_INT) X\n+        REAL(C_FLOAT) Y\n+        COMMON /FOO/ X,Y\n+        BIND(C,NAME='fortranStuff') /FOO/\n+        DATA X /1/\n+        DATA Y /2.0/\n+      END BLOCKDATA"}, {"sha": "275e88eadc38d7d3e19b6fac5686c0e775d8c74f", "filename": "gcc/testsuite/gfortran.dg/c_assoc_2.f03", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_2.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -16,19 +16,19 @@ subroutine sub0(my_c_ptr) bind(c)\n        call abort()\n     end if\n \n-    if(.not. c_associated(my_c_ptr, my_c_ptr, my_c_ptr)) then ! { dg-error \"More actual than formal arguments\" }\n+    if(.not. c_associated(my_c_ptr, my_c_ptr, my_c_ptr)) then ! { dg-error \"Too many arguments in call\" }\n        call abort()\n     end if\n \n-    if(.not. c_associated()) then ! { dg-error \"Missing argument\" }\n+    if(.not. c_associated()) then ! { dg-error \"Missing actual argument 'C_PTR_1' in call to 'c_associated'\" }\n        call abort()\n-    end if ! { dg-error \"Expecting END SUBROUTINE\" }\n+    end if\n \n     if(.not. c_associated(my_c_ptr_2)) then\n        call abort()\n     end if\n \n-    if(.not. c_associated(my_integer)) then ! { dg-error \"Type mismatch\" }\n+    if(.not. c_associated(my_integer)) then ! { dg-error \"shall have the type TYPE.C_PTR. or TYPE.C_FUNPTR.\" }\n        call abort()\n     end if\n   end subroutine sub0"}, {"sha": "5421a363f10aad5328cd858909d831572949aa8c", "filename": "gcc/testsuite/gfortran.dg/c_assoc_4.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_4.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+!\n+! PR fortran/49023\n+!\n+PROGRAM test\n+\n+  USE, INTRINSIC :: iso_c_binding\n+  IMPLICIT NONE\n+\n+  TYPE (C_PTR) :: x, y\n+\n+  PRINT *, C_ASSOCIATED([x,y])  ! { dg-error \"'C_PTR_1' argument of 'c_associated' intrinsic at .1. must be a scalar\" }\n+\n+END PROGRAM test"}, {"sha": "9b130ad6e5994d4482868cb4266ea9ba8dfe3bf9", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_shape_test.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_test.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_test.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_test.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -13,7 +13,7 @@ subroutine test_0(myAssumedArray, cPtr)\n     type(c_ptr), value :: cPtr\n     \n     myArrayPtr => myArray\n-    call c_f_pointer(cPtr, myArrayPtr) ! { dg-error \"Missing SHAPE argument\" }\n+    call c_f_pointer(cPtr, myArrayPtr) ! { dg-error \"Expected SHAPE argument to C_F_POINTER with array FPTR\" }\n   end subroutine test_0\n end module c_f_pointer_shape_test\n "}, {"sha": "632e4579ce83ea3aac556e3d7ed42e92ba1e14f5", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_shape_tests_3.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_3.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -8,7 +8,7 @@ subroutine sub0(my_c_array) bind(c)\n     type(c_ptr), value :: my_c_array\n     integer(c_int), dimension(:), pointer :: my_array_ptr\n     \n-    call c_f_pointer(my_c_array, my_array_ptr, (/ 10.0 /)) ! { dg-error \"must be a rank 1 INTEGER array\" }\n+    call c_f_pointer(my_c_array, my_array_ptr, (/ 10.0 /)) ! { dg-error \"must be INTEGER\" }\n   end subroutine sub0\n \n   subroutine sub1(my_c_array) bind(c)\n@@ -17,6 +17,6 @@ subroutine sub1(my_c_array) bind(c)\n     integer(c_int), dimension(1,1) :: shape\n \n     shape(1,1) = 10\n-    call c_f_pointer(my_c_array, my_array_ptr, shape) ! { dg-error \"must be a rank 1 INTEGER array\" }\n+    call c_f_pointer(my_c_array, my_array_ptr, shape) ! { dg-error \"must be of rank 1\" }\n   end subroutine sub1\n end module c_f_pointer_shape_tests_3"}, {"sha": "5194e40b1ea1cad849505cafe57036afc761efc6", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_tests_5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_5.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -9,5 +9,5 @@\n end type\n type(c_ptr) :: cSelf\n class(nc), pointer :: self\n-call c_f_pointer(cSelf, self)  ! { dg-error \"must not be polymorphic\" }\n+call c_f_pointer(cSelf, self)  ! { dg-error \"shall not be polymorphic\" }\n end"}, {"sha": "6dc439770d4c22600bf6e3ed7015d5be8a5be88a", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_tests_6.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_6.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do compile }\n+!\n+! PR fortran/38894\n+!\n+!\n+\n+subroutine test2\n+use iso_c_binding\n+type(c_funptr) :: fun\n+type(c_ptr) :: fptr\n+procedure(), pointer :: bar\n+integer, pointer :: bari\n+call c_f_procpointer(fptr,bar) ! { dg-error \"Argument CPTR at .1. to C_F_PROCPOINTER shall have the type TYPE.C_FUNPTR.\" }\n+call c_f_pointer(fun,bari) ! { dg-error \"Argument CPTR at .1. to C_F_POINTER shall have the type TYPE.C_PTR.\" }\n+fun = fptr ! { dg-error \"Can't convert TYPE.c_ptr. to TYPE.c_funptr.\" }\n+end\n+\n+subroutine test()\n+use iso_c_binding, c_ptr2 => c_ptr\n+type(c_ptr2) :: fun\n+procedure(), pointer :: bar\n+integer, pointer :: foo\n+call c_f_procpointer(fun,bar) ! { dg-error \"Argument CPTR at .1. to C_F_PROCPOINTER shall have the type TYPE.C_FUNPTR.\" }\n+call c_f_pointer(fun,foo)  ! OK\n+end\n+\n+module rename\n+  use, intrinsic :: iso_c_binding, only: my_c_ptr_0 => c_ptr\n+end module rename\n+\n+program p\n+  use, intrinsic :: iso_c_binding, my_c_ptr => c_ptr\n+  type(my_c_ptr) :: my_ptr\n+  print *,c_associated(my_ptr)\n+contains\n+  subroutine sub()\n+    use rename   ! (***)\n+    type(my_c_ptr_0) :: my_ptr2\n+    type(c_funptr) :: myfun\n+    print *,c_associated(my_ptr,my_ptr2)\n+    print *,c_associated(my_ptr,myfun) ! { dg-error \"Argument C_PTR_2 at .1. to C_ASSOCIATED shall have the same type as C_PTR_1: TYPE.c_ptr. instead of TYPE.c_funptr.\" }\n+  end subroutine\n+end"}, {"sha": "8cabd18d1389f20e762d14aa3d2a509096dc3a81", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_tests_7.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_7.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+!\n+! PR fortran/54263\n+!\n+use iso_c_binding\n+type(c_ptr) :: cp\n+integer, pointer :: p\n+call c_f_pointer (cp, p, shape=[2]) ! { dg-error \"Unexpected SHAPE argument at .1. to C_F_POINTER with scalar FPTR\" }\n+end"}, {"sha": "4db7bcc5fc746aeb1c82d7c7f6dab8f84268c66c", "filename": "gcc/testsuite/gfortran.dg/c_funloc_tests_2.f03", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_2.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -8,9 +8,9 @@ recursive subroutine sub0() bind(c)\n     type(c_funptr) :: my_c_funptr\n     integer :: my_local_variable\n     \n-    my_c_funptr = c_funloc() ! { dg-error \"Missing argument\" }\n+    my_c_funptr = c_funloc() ! { dg-error \"Missing actual argument 'x' in call to 'c_funloc'\" }\n     my_c_funptr = c_funloc(sub0)\n-    my_c_funptr = c_funloc(sub0, sub0) ! { dg-error \"More actual than formal\" }\n-    my_c_funptr = c_funloc(my_local_variable) ! { dg-error \"must be a procedure\" }\n+    my_c_funptr = c_funloc(sub0, sub0) ! { dg-error \"Too many arguments in call to 'c_funloc'\" }\n+    my_c_funptr = c_funloc(my_local_variable) ! { dg-error \"Argument X at .1. to C_FUNLOC shall be a procedure or a procedure pointer\" }\n   end subroutine sub0\n end module c_funloc_tests_2"}, {"sha": "ae321a998dcd21ca8743e4a8e72f6fcbc35fb3bc", "filename": "gcc/testsuite/gfortran.dg/c_funloc_tests_5.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_5.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -8,9 +8,9 @@ module c_funloc_tests_5\n   subroutine sub0() bind(c)\n     type(c_funptr) :: my_c_funptr\n \n-    my_c_funptr = c_funloc(sub1) ! { dg-error \"TS 29113: Noninteroperable argument\" }\n+    my_c_funptr = c_funloc(sub1) ! { dg-error \"TS 29113: Noninteroperable procedure at .1. to C_FUNLOC\" }\n \n-    my_c_funptr = c_funloc(func0) ! { dg-error \"TS 29113: Noninteroperable argument\" }\n+    my_c_funptr = c_funloc(func0) ! { dg-error \"TS 29113: Noninteroperable procedure at .1. to C_FUNLOC\" }\n   end subroutine sub0\n \n   subroutine sub1() "}, {"sha": "1a7f0362d16c17cb4ffc96e62df588bd52d4af07", "filename": "gcc/testsuite/gfortran.dg/c_funloc_tests_6.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_6.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -23,9 +23,9 @@ end subroutine sub\n cp = c_funloc (sub) ! { dg-error \"Can't convert TYPE.c_funptr. to TYPE.c_ptr.\" })\n cfp = c_loc (int)   ! { dg-error \"Can't convert TYPE.c_ptr. to TYPE.c_funptr.\" }\n \n-call c_f_pointer (cfp, int)     ! { dg-error \"Argument CPTR to C_F_POINTER at .1. shall have the type C_PTR\" }\n-call c_f_procpointer (cp, fsub) ! { dg-error \"Argument at .1. to C_F_FUNPOINTER shall have the type C_FUNPTR\" }\n+call c_f_pointer (cfp, int)     ! { dg-error \"Argument CPTR at .1. to C_F_POINTER shall have the type TYPE.C_PTR.\" }\n+call c_f_procpointer (cp, fsub) ! { dg-error \"Argument CPTR at .1. to C_F_PROCPOINTER shall have the type TYPE.C_FUNPTR.\" }\n \n-cfp = c_funloc (noCsub) ! { dg-error \"TS 29113: Noninteroperable argument 'nocsub' to 'c_funloc'\" }\n-call c_f_procpointer (cfp, fint) ! { dg-error \"TS 29113: Noninteroperable procedure-pointer at .1. to C_F_FUNPOINTER\" }\n+cfp = c_funloc (noCsub) ! { dg-error \"TS 29113: Noninteroperable procedure at .1. to C_FUNLOC\" }\n+call c_f_procpointer (cfp, fint) ! { dg-error \"TS 29113: Noninteroperable procedure pointer at .1. to C_F_PROCPOINTER\" }\n end"}, {"sha": "1650a79e1057187b8ead278a6bf9e8624393d19d", "filename": "gcc/testsuite/gfortran.dg/c_funloc_tests_8.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_8.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do compile }\n+!\n+! PR fortran/50612\n+! PR fortran/47023\n+!\n+subroutine test\n+  use iso_c_binding\n+  implicit none\n+  external foo\n+  procedure(), pointer :: pp\n+  print *, c_sizeof(pp) ! { dg-error \"Procedure unexpected as argument\" }\n+  print *, c_sizeof(foo) ! { dg-error \"Procedure unexpected as argument\" }\n+  print *, c_sizeof(bar) ! { dg-error \"Procedure unexpected as argument\" }\n+contains\n+  subroutine bar()\n+  end subroutine bar\n+end\n+\n+integer function foo2()\n+  procedure(), pointer :: ptr\n+  ptr => foo2 ! { dg-error \"Function result 'foo2' is invalid as proc-target in procedure pointer assignment\" }\n+  foo2 = 7\n+  block\n+    ptr => foo2 ! { dg-error \"Function result 'foo2' is invalid as proc-target in procedure pointer assignment\" }\n+  end block\n+contains\n+  subroutine foo()\n+    ptr => foo2 ! { dg-error \"Function result 'foo2' is invalid as proc-target in procedure pointer assignment\" }\n+  end subroutine foo\n+end function foo2\n+\n+module m2\n+contains\n+integer function foo(i, fptr) bind(C)\n+  use iso_c_binding\n+  implicit none\n+  integer :: i\n+  type(c_funptr) :: fptr\n+  fptr = c_funloc(foo) ! { dg-error \"Function result 'foo' at .1. is invalid as X argument to C_FUNLOC\" }\n+  block\n+    fptr = c_funloc(foo) ! { dg-error \"Function result 'foo' at .1. is invalid as X argument to C_FUNLOC\" }\n+  end block\n+  foo = 42*i\n+contains\n+  subroutine bar()\n+    fptr = c_funloc(foo) ! { dg-error \"Function result 'foo' at .1. is invalid as X argument to C_FUNLOC\" }\n+  end subroutine bar\n+end function foo\n+end module m2"}, {"sha": "4c2a7d657ee1b8bc05ad01897041a5379542de3e", "filename": "gcc/testsuite/gfortran.dg/c_loc_test_17.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_17.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+! { dg-options \"\" }\n+!\n+! PR fortran/56378\n+! PR fortran/52426\n+!\n+! Contributed by David Sagan & Joost VandeVondele\n+!\n+\n+module t\n+ use, intrinsic :: iso_c_binding\n+ interface fvec2vec\n+   module procedure int_fvec2vec\n+ end interface\n+contains\n+ function int_fvec2vec (f_vec, n) result (c_vec)\n+ integer f_vec(:)\n+ integer(c_int), target :: c_vec(n)\n+ end function int_fvec2vec\n+ subroutine lat_to_c (Fp, C) bind(c)\n+ integer, allocatable :: ic(:)\n+ call lat_to_c2 (c_loc(fvec2vec(ic, n1_ic))) ! { dg-error \"Argument X at .1. to C_LOC shall have either the POINTER or the TARGET attribute\" }\n+ end subroutine lat_to_c\n+end module\n+\n+use iso_c_binding\n+print *, c_loc([1]) ! { dg-error \"Argument X at .1. to C_LOC shall have either the POINTER or the TARGET attribute\" }\n+end"}, {"sha": "b8542002f59deeeb117646940e2fd002293207ce", "filename": "gcc/testsuite/gfortran.dg/c_loc_test_18.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_18.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+!\n+! PR fortran/39288\n+!\n+! From IR F03/0129, cf.\n+! Fortran 2003, Technical Corrigendum 5\n+!\n+! Was invalid before.\n+\n+  SUBROUTINE S(A,I,K)\n+    USE ISO_C_BINDING\n+    CHARACTER(*),TARGET :: A\n+    CHARACTER(:),ALLOCATABLE,TARGET :: B\n+    TYPE(C_PTR) P1,P2,P3,P4,P5\n+    P1 = C_LOC(A(1:1))    ! *1\n+    P2 = C_LOC(A(I:I))    ! *2\n+    P3 = C_LOC(A(1:))     ! *3\n+    P4 = C_LOC(A(I:K))    ! *4\n+    ALLOCATE(CHARACTER(1)::B)\n+    P5 = C_LOC(B)         ! *5\n+  END SUBROUTINE"}, {"sha": "a667eaf52de4817c2ae42421d49ea2e1feb0ae36", "filename": "gcc/testsuite/gfortran.dg/c_loc_test_19.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_19.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_19.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_19.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+!\n+! PR fortran/50269\n+!\n+Program gf\n+   Use iso_c_binding\n+   Real( c_double ), Dimension( 1:10 ), Target :: a\n+   Call test( a )\n+Contains\n+   Subroutine test( aa )\n+     Real( c_double ), Dimension( : ), Target :: aa\n+     Type( c_ptr ), Pointer :: b\n+     b = c_loc( aa( 1 ) )  ! was rejected before.\n+     b = c_loc( aa ) ! { dg-error \"TS 29113: Noninteroperable array at .1. as argument to C_LOC: Only explicit-size and assumed-size arrays are interoperable\" }\n+   End Subroutine test\n+End Program gf"}, {"sha": "4ff0ca1bac0fa33d68105beeda90a0f820234970", "filename": "gcc/testsuite/gfortran.dg/c_loc_test_20.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_20.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_20.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_20.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+!\n+! PR fortran/38829\n+! PR fortran/40963\n+! PR fortran/38813\n+!\n+!\n+program testcloc\n+    use, intrinsic :: iso_c_binding\n+    implicit none\n+\n+    type obj\n+        real :: array(10,10)\n+        real, allocatable :: array2(:,:)\n+    end type\n+\n+    type(obj), target :: obj1\n+    type(c_ptr) :: cptr\n+    integer :: i\n+    real, pointer :: array(:)\n+\n+    allocate (obj1%array2(10,10))\n+    obj1%array  = reshape ([(i, i=1,100)], shape (obj1%array))\n+    obj1%array2 = reshape ([(i, i=1,100)], shape (obj1%array))\n+\n+    cptr = c_loc (obj1%array)\n+    call c_f_pointer (cptr, array, shape=[100])\n+    if (any (array /= [(i, i=1,100)])) call abort ()\n+\n+    cptr = c_loc (obj1%array2)\n+    call c_f_pointer (cptr, array, shape=[100])\n+    if (any (array /= [(i, i=1,100)])) call abort ()\n+end program testcloc\n+"}, {"sha": "21cbe0be7ec0ba4d12913fe7c7a094137862c800", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_10.f03", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_10.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_10.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_10.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -1,8 +1,9 @@\n ! { dg-do compile }\n+! { dg-options \"-std=f2008\" }\n subroutine aaa(in)\n   use iso_c_binding\n   implicit none\n   integer(KIND=C_int), DIMENSION(:), TARGET  :: in\n   type(c_ptr) :: cptr\n-  cptr = c_loc(in) ! { dg-error \"not C interoperable\" }\n+  cptr = c_loc(in) ! { dg-error \"TS 29113: Noninteroperable array at .1. as argument to C_LOC\" }\n end subroutine aaa"}, {"sha": "b8e6d849e67a6a3994d90c08db76e96206f64c0c", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_11.f03", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_11.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_11.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_11.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -1,4 +1,6 @@\n ! { dg-do compile }\n+! { dg-options \"-std=f2008\" }\n+!\n ! Test argument checking for C_LOC with subcomponent parameters.\n module c_vhandle_mod\n   use iso_c_binding\n@@ -29,19 +31,19 @@ type(c_ptr) function get_double_vector_address(handle)\n     integer(c_int), intent(in) :: handle\n     \n     if (.true.) then   ! The ultimate component is an allocatable target \n-      get_double_vector_address = c_loc(dbv_pool(handle)%v)\n+      get_double_vector_address = c_loc(dbv_pool(handle)%v)  ! { dg-error \"TS 29113: Noninteroperable array at .1. as argument to C_LOC: Only explicit-size and assumed-size arrays are interoperable\" }\n     else\n-      get_double_vector_address = c_loc(vv)\n+      get_double_vector_address = c_loc(vv)  ! { dg-error \"TS 29113: Noninteroperable array at .1. as argument to C_LOC: Only explicit-size and assumed-size arrays are interoperable\" }\n     endif\n     \n   end function get_double_vector_address\n \n \n   type(c_ptr) function get_foo_address(handle)\n     integer(c_int), intent(in) :: handle    \n-    get_foo_address = c_loc(foo_pool(handle)%v)    \n+    get_foo_address = c_loc(foo_pool(handle)%v)\n \n-    get_foo_address = c_loc(foo_pool2(handle)%v) ! { dg-error \"must be a scalar\" } \n+    get_foo_address = c_loc(foo_pool2(handle)%v) ! { dg-error \"TS 29113: Noninteroperable array at .1. as argument to C_LOC: Expression is a noninteroperable derived type\" }\n   end function get_foo_address\n \n     "}, {"sha": "c8d5868705051643654faa0dd63f1ef7180903bf", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_15.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_15.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -11,6 +11,6 @@\n \n   type(c_ptr) :: tt_cptr\n   class(t), pointer :: tt_fptr\n-  if (associated(tt_fptr)) tt_cptr = c_loc(tt_fptr)  ! { dg-error \"must not be polymorphic\" }\n+  if (associated(tt_fptr)) tt_cptr = c_loc(tt_fptr)  ! { dg-error \"shall not be polymorphic\" }\n \n end"}, {"sha": "2c074e874f0dec473f232accbfc61831109363c2", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_16.f90", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_16.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-fcoarray=single\" }\n+! { dg-options \"-fcoarray=single -std=f2008\" }\n ! PR 38536 - array sections as arguments to c_loc are illegal.\n   use iso_c_binding\n   type, bind(c) :: t1\n@@ -18,8 +18,8 @@\n   integer(c_int), target :: x[*]\n   type(C_PTR) :: p\n \n-  p = c_loc(tt%t%i(1))  ! { dg-error \"Array section not permitted\" }\n-  p = c_loc(n(1:2))  ! { dg-warning \"Array section\" }\n-  p = c_loc(ttt%t(5,1:2)%i(1)) ! { dg-error \"Array section not permitted\" }\n-  p = c_loc(x[1]) ! { dg-error \"Coindexed argument not permitted\" }\n+  p = c_loc(tt%t%i(1))\n+  p = c_loc(n(1:2))  ! { dg-error \"TS 29113: Noninteroperable array at .1. as argument to C_LOC: Only whole-arrays are interoperable\" }\n+  p = c_loc(ttt%t(5,1:2)%i(1)) ! { dg-error \"TS 29113: Noninteroperable array at .1. as argument to C_LOC: Only whole-arrays are interoperable\" }\n+  p = c_loc(x[1]) ! { dg-error \"shall not be coindexed\" }\n   end"}, {"sha": "5e4eb8affabdc3f02e699a858c227a752708c69d", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_17.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_17.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+!\n+! PR fortran/55574\n+! The following code used to be accepted because C_LOC pulls in C_PTR\n+! implicitly.\n+!\n+! Contributed by Valery Weber <valeryweber@hotmail.com>\n+!\n+program aaaa\n+  use iso_c_binding, only : c_loc\n+  integer, target :: i\n+  type(C_PTR) :: f_ptr ! { dg-error \"being used before it is defined\" }\n+  f_ptr=c_loc(i)  ! { dg-error \"Can't convert\" }\n+end program aaaa"}, {"sha": "0cd56a684647efaebd2bded11baada833f45b594", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_3.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_3.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -3,6 +3,6 @@\n implicit none\n character(kind=c_char,len=256),target :: arg\n type(c_ptr),pointer :: c\n-c = c_loc(arg) ! { dg-error \"must have a length of 1\" }\n+c = c_loc(arg) ! OK since Fortran 2003, Tech Corrigenda 5; IR F03/0129\n \n end"}, {"sha": "1f28d3e0c0e64e8fa0170c8c78ee93c754c24edb", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_4.f03", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_4.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -1,4 +1,6 @@\n ! { dg-do compile }\n+! { dg-options \"-std=f2008\" }\n+!\n module c_loc_tests_4\n   use, intrinsic :: iso_c_binding\n   implicit none\n@@ -10,6 +12,6 @@ subroutine sub0() bind(c)\n     type(c_ptr) :: my_c_ptr\n \n     my_array_ptr => my_array\n-    my_c_ptr = c_loc(my_array_ptr) ! { dg-error \"must be an associated scalar POINTER\" }\n+    my_c_ptr = c_loc(my_array_ptr) ! { dg-error \"Noninteroperable array at .1. as argument to C_LOC: Only explicit-size and assumed-size arrays are interoperable\" }\n   end subroutine sub0\n end module c_loc_tests_4"}, {"sha": "4a4e73ee7ceddf344c74b6035a1892f69b7d1320", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_8.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_8.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -7,7 +7,7 @@ module x\n SUBROUTINE glutInit_f03()\n   TYPE(C_PTR), DIMENSION(1), TARGET :: argv=C_NULL_PTR\n   character(kind=c_char, len=5), target :: string=\"hello\"\n-  argv(1)=C_LOC(string) ! { dg-error \"must have a length of 1\" }\n+  argv(1)=C_LOC(string) ! OK since Fortran 2003, Tech Corrigenda 5; IR F03/0129\n END SUBROUTINE\n end module x\n "}, {"sha": "020b057fe251b6e50cba33ddb17c04fd658e1fa0", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_13.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_13.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_13.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_13.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -10,6 +10,6 @@ program main\n    integer(C_INTPTR_T) p\n    type(C_PTR) cptr\n    p = 0\n-   cptr = C_PTR(p+1) ! { dg-error \"Components of structure constructor\" }\n-   cptr = C_PTR(1) ! { dg-error \"Components of structure constructor\" } \n+   cptr = C_PTR(p+1) ! { dg-error \"is a PRIVATE component of 'c_ptr'\" }\n+   cptr = C_PTR(1) ! { dg-error \"is a PRIVATE component of 'c_ptr'\" }\n end program main"}, {"sha": "2bf4262898b5a37e6124801421459ea0306884c2", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_14.f90", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_14.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -39,8 +39,10 @@ program test\n   if(c_associated(file%gsl_func)) call abort()\n end program test\n \n-! { dg-final { scan-tree-dump-times \"gsl_file = 0B\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"gsl_func = 0B\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"c_funptr.\\[0-9\\]+ = 0B;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"fgsl_file.\\[0-9\\]+.gsl_func = c_funptr.\\[0-9\\]+;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"c_ptr.\\[0-9\\]+ = 0B;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"fgsl_file.\\[0-9\\]+.gsl_file = c_ptr.\\[0-9\\]+;\" 1 \"original\" } }\n \n ! { dg-final { scan-tree-dump-times \"NIptr = 0B\"    0 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"NIfunptr = 0B\" 0 \"original\" } }"}, {"sha": "dec2e8e4ad9257784f66017b1b2bffd309de25fd", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_15.f90", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_15.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -41,8 +41,10 @@ program test\n   if(c_associated(file%gsl_func)) call abort()\n end program test\n \n-! { dg-final { scan-tree-dump-times \"gsl_file = 0B\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"gsl_func = 0B\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"c_funptr.\\[0-9\\]+ = 0B;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"fgsl_file.\\[0-9\\]+.gsl_func = c_funptr.\\[0-9\\]+;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"c_ptr.\\[0-9\\]+ = 0B;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"fgsl_file.\\[0-9\\]+.gsl_file = c_ptr.\\[0-9\\]+;\" 1 \"original\" } }\n \n ! { dg-final { scan-tree-dump-times \"NIptr = 0B\"    0 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"NIfunptr = 0B\" 0 \"original\" } }"}, {"sha": "5a32553b8c59611f9ab71fef044f918e2efaa88f", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_9.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_9.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -16,9 +16,9 @@ subroutine sub0() bind(c)\n     type(myF90Derived), pointer :: my_f90_type_ptr\n \n     my_f90_type%my_c_ptr = c_null_ptr\n-    print *, 'my_f90_type is: ', my_f90_type\n+    print *, 'my_f90_type is: ', my_f90_type%my_c_ptr\n     my_f90_type_ptr => my_f90_type\n-    print *, 'my_f90_type_ptr is: ', my_f90_type_ptr\n+    print *, 'my_f90_type_ptr is: ', my_f90_type_ptr%my_c_ptr\n   end subroutine sub0\n end module c_ptr_tests_9\n "}, {"sha": "4a8385b8d8fd5a7035192c9ecdb50ced7ac969e0", "filename": "gcc/testsuite/gfortran.dg/c_sizeof_1.f90", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_sizeof_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_sizeof_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_sizeof_1.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -4,7 +4,8 @@\n use iso_c_binding, only: c_int, c_char, c_ptr, c_intptr_t, c_null_ptr, c_sizeof\n \n integer(kind=c_int) :: i, j(10)\n-character(kind=c_char,len=4),parameter :: str(1) = \"abcd\"\n+character(kind=c_char,len=4),parameter :: str(1 ) = \"abcd\"\n+character(kind=c_char,len=1),parameter :: str2(4) = [\"a\",\"b\",\"c\",\"d\"]\n type(c_ptr) :: cptr\n integer(c_intptr_t) :: iptr\n \n@@ -15,13 +16,13 @@\n i = c_sizeof(j)\n if (i /= 40) call abort()\n \n-i = c_sizeof(str)\n+i = c_sizeof(str2)\n if (i /= 4) call abort()\n \n-i = c_sizeof(str(1))\n-if (i /= 4) call abort()\n+i = c_sizeof(str2(1))\n+if (i /= 1) call abort()\n \n-i = c_sizeof(str(1)(1:3))\n+i = c_sizeof(str2(1:3))\n if (i /= 3) call abort()\n \n write(*,*) c_sizeof(cptr), c_sizeof(iptr), c_sizeof(C_NULL_PTR)"}, {"sha": "127a24ab6a4ffd6ba5535ddfaac80b73dff08430", "filename": "gcc/testsuite/gfortran.dg/c_sizeof_5.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_sizeof_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_sizeof_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_sizeof_5.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+! { dg-options \"-fcray-pointer\" }\n+!\n+use iso_c_binding\n+real target(10)\n+real pointee(10)\n+pointer (ipt, pointee)\n+integer(c_intptr_t) :: int_cptr\n+real :: x\n+if (c_sizeof(ipt) /= c_sizeof(int_cptr)) call abort()\n+if (c_sizeof(pointee) /= c_sizeof(x)*10) call abort()\n+end"}, {"sha": "45eaa5c2443df8f9c4e68576a413b4db73cc57b0", "filename": "gcc/testsuite/gfortran.dg/iso_c_binding_init_expr.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_init_expr.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_init_expr.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_init_expr.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -5,7 +5,7 @@\n implicit none\n integer, target :: a\n type t\n-  type(c_ptr) :: ptr = c_loc(a)    ! { dg-error \"must be an intrinsic function\" }\n+  type(c_ptr) :: ptr = c_loc(a)    ! { dg-error \"Intrinsic function 'c_loc' at .1. is not permitted in an initialization expression\" }\n end type t\n-type(c_ptr) :: ptr2 = c_loc(a)     ! { dg-error \"must be an intrinsic function\" }\n+type(c_ptr) :: ptr2 = c_loc(a)     ! { dg-error \"Intrinsic function 'c_loc' at .1. is not permitted in an initialization expression\" }\n end"}, {"sha": "bbe17cb89645f7be86e2e120ee1ac85b8376c00d", "filename": "gcc/testsuite/gfortran.dg/iso_c_binding_rename_3.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_3.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+!\n+! PR fortran/55343\n+!\n+! Contributed by Janus Weil\n+!\n+module my_mod\n+  implicit none\n+  type int_type\n+    integer :: i\n+  end type int_type\n+end module my_mod\n+program main\n+  use iso_c_binding, only: C_void_ptr=>C_ptr, C_string_ptr=>C_ptr\n+  use my_mod, only: i1_type=>int_type, i2_type=>int_type\n+  implicit none\n+  type(C_string_ptr) :: p_string\n+  type(C_void_ptr) :: p_void\n+  type (i1_type) :: i1\n+  type (i2_type) :: i2\n+  p_void = p_string\n+  i1 = i2\n+end program main"}, {"sha": "a4048cc321c06c020ebc953fc52f009a8bcaeafd", "filename": "gcc/testsuite/gfortran.dg/pr32601.f03", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32601.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32601.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32601.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -19,9 +19,9 @@ end module pr32601\n t = c_null_ptr\n \n ! Next two lines should be errors if -pedantic or -std=f2003\n-print *, c_null_ptr, t  ! { dg-error \"has PRIVATE components\" }\n-print *, t ! { dg-error \"has PRIVATE components\" }\n+print *, c_null_ptr, t  ! { dg-error \"cannot have PRIVATE components\" }\n+print *, t ! { dg-error \"cannot have PRIVATE components\" }\n \n-print *, c_loc(get_ptr()) ! { dg-error \"has PRIVATE components\" }\n+print *, c_loc(get_ptr()) ! { dg-error \"cannot have PRIVATE components\" }\n \n end"}, {"sha": "a297e1728ec1a3658f231161f810e14eb1ec95c7", "filename": "gcc/testsuite/gfortran.dg/pr32601_1.f03", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32601_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32601_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32601_1.f03?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -1,10 +1,12 @@\n ! { dg-do compile }\n+! { dg-options \"\" }\n+!\n ! PR fortran/32601\n use, intrinsic :: iso_c_binding, only: c_loc, c_ptr\n implicit none\n \n ! This was causing an ICE, but is an error because the argument to C_LOC \n ! needs to be a variable.\n-print *, c_loc(4) ! { dg-error \"not a variable\" }\n+print *, c_loc(4) ! { dg-error \"shall have either the POINTER or the TARGET attribute\" }\n \n end"}, {"sha": "ba8bd229cd840c6256325e6c91a281934ac7e9ee", "filename": "gcc/testsuite/gfortran.dg/storage_size_2.f08", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fstorage_size_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Fstorage_size_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstorage_size_2.f08?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -14,10 +14,10 @@\n integer(c_int) :: i2\n type(t) :: x\n \n-print *,c_sizeof(i1)                ! { dg-error \"must be an interoperable data entity\" }\n+print *,c_sizeof(i1)\n print *,c_sizeof(i2)\n print *,c_sizeof(x)\n-print *, c_sizeof(ran())            ! { dg-error \"must be an interoperable data entity\" }\n+print *, c_sizeof(ran())\n \n print *,storage_size(1.0,4)\n print *,storage_size(1.0,3.2)       ! { dg-error \"must be INTEGER\" }"}, {"sha": "b6c5ddd347f62bdd2016fb370d70db7795dba72c", "filename": "gcc/testsuite/gfortran.dg/transfer_resolve_2.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_resolve_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_resolve_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_resolve_2.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+!\n+! PR fortran/56079\n+!\n+! Contributed by  Thomas Koenig\n+!\n+program gar_nichts\n+   use ISO_C_BINDING\n+   use ISO_C_BINDING, only: C_PTR\n+   use ISO_C_BINDING, only: abc => C_PTR\n+   use ISO_C_BINDING, only: xyz => C_PTR\n+   type(xyz) nada\n+   nada = transfer(C_NULL_PTR,nada)\n+end program gar_nichts"}, {"sha": "f3a58e27beeab0224138ea0282cbba96caf7cea4", "filename": "gcc/testsuite/gfortran.dg/transfer_resolve_3.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_resolve_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_resolve_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_resolve_3.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/56079\n+!\n+use iso_c_binding\n+implicit none\n+type t\n+  type(c_ptr) :: ptr = c_null_ptr\n+end type t\n+\n+type(t), parameter :: para = t()\n+integer(c_intptr_t) :: intg\n+intg = transfer (para, intg)\n+intg = transfer (para%ptr, intg)\n+end\n+\n+! { dg-final { scan-tree-dump-times \"intg = 0;\" 2 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+"}, {"sha": "2dad63c7587631dea8a65f7ca0cf6bad6cd510d2", "filename": "gcc/testsuite/gfortran.dg/transfer_resolve_4.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_resolve_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_resolve_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_resolve_4.f90?ref=cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+!\n+! PR fortran/47034\n+!\n+! Contributed by James Van Buskirk\n+!\n+subroutine james\n+   use iso_c_binding\n+   type(C_PTR), parameter :: p1 = &\n+   transfer(32512_C_INTPTR_T,C_NULL_PTR)\n+   integer(C_INTPTR_T), parameter :: n1 = transfer(p1,0_C_INTPTR_T)\n+end"}]}