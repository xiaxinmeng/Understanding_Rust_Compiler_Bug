{"sha": "1c8e4e2e5556facd565d1e61bb0433b37ff86243", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM4ZTRlMmU1NTU2ZmFjZDU2NWQxZTYxYmIwNDMzYjM3ZmY4NjI0Mw==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2007-06-06T10:45:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:45:42Z"}, "message": "socket.c (__gnat_close_signalling_fd): New function.\n\n2007-04-20  Thomas Quinot  <quinot@adacore.com>\n\n\t* socket.c (__gnat_close_signalling_fd): New function.\n\t(__gnat_safe_gethostbyaddr, __gnat_safe_gethostbyname,\n\t__gnat_safe_getservbyname, __gnat_safe_getservbyport):\n\tNew supporting functions for task safe Netdb operations.\n\nFrom-SVN: r125456", "tree": {"sha": "e3c3ee5bef03f85020876cbab98bf3883bb5fbba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3c3ee5bef03f85020876cbab98bf3883bb5fbba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c8e4e2e5556facd565d1e61bb0433b37ff86243", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c8e4e2e5556facd565d1e61bb0433b37ff86243", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c8e4e2e5556facd565d1e61bb0433b37ff86243", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c8e4e2e5556facd565d1e61bb0433b37ff86243/comments", "author": null, "committer": null, "parents": [{"sha": "2e6039943389e265c08f390ff07f39790409c022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e6039943389e265c08f390ff07f39790409c022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e6039943389e265c08f390ff07f39790409c022"}], "stats": {"total": 166, "additions": 160, "deletions": 6}, "files": [{"sha": "cae30e6619c97e6974b53ef07cc20e4c6b48d71f", "filename": "gcc/ada/socket.c", "status": "modified", "additions": 160, "deletions": 6, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8e4e2e5556facd565d1e61bb0433b37ff86243/gcc%2Fada%2Fsocket.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8e4e2e5556facd565d1e61bb0433b37ff86243/gcc%2Fada%2Fsocket.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsocket.c?ref=1c8e4e2e5556facd565d1e61bb0433b37ff86243", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 2003-2006, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 2003-2007, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -52,6 +52,7 @@ extern void __gnat_disable_all_sigpipes (void);\n extern int  __gnat_create_signalling_fds (int *fds);\n extern int  __gnat_read_signalling_fd (int rsig);\n extern int  __gnat_write_signalling_fd (int wsig);\n+extern void  __gnat_close_signalling_fd (int sig);\n extern void __gnat_free_socket_set (fd_set *);\n extern void __gnat_last_socket_in_set (fd_set *, int *);\n extern void __gnat_get_socket_from_set (fd_set *, int *, int *);\n@@ -115,6 +116,150 @@ __gnat_write_signalling_fd (int wsig) {\n   char c = 0;\n   return write (wsig, &c, 1);\n }\n+\f\n+/*\n+ * Close one end of a pair of signalling fds\n+ */\n+void\n+__gnat_close_signalling_fd (int sig) {\n+  (void) close (sig);\n+}\n+#endif\n+\f\n+/*\n+ * GetXXXbyYYY wrappers\n+ * These functions are used by the default implementation of g-socthi,\n+ * and also by the Windows version.\n+ *\n+ * They can be used for any platform that either provides an intrinsically\n+ * task safe implementation of getXXXbyYYY, or a reentrant variant\n+ * getXXXbyYYY_r. Otherwise, a task safe wrapper, including proper mutual\n+ * exclusion if appropriate, must be implemented in the target specific\n+ * version of g-socthi.\n+ */\n+\n+#ifdef HAVE_THREAD_SAFE_GETxxxBYyyy\n+int\n+__gnat_safe_gethostbyname (const char *name,\n+  struct hostent *ret, char *buf, size_t buflen,\n+  int *h_errnop)\n+{\n+  struct hostent *rh;\n+  rh = gethostbyname (name);\n+  if (rh == NULL) {\n+    *h_errnop = h_errno;\n+    return -1;\n+  }\n+  *ret = *rh;\n+  *h_errnop = 0;\n+  return 0;\n+}\n+\n+int\n+__gnat_safe_gethostbyaddr (const char *addr, int len, int type,\n+  struct hostent *ret, char *buf, size_t buflen,\n+  int *h_errnop)\n+{\n+  struct hostent *rh;\n+  rh = gethostbyaddr (addr, len, type);\n+  if (rh == NULL) {\n+    *h_errnop = h_errno;\n+    return -1;\n+  }\n+  *ret = *rh;\n+  *h_errnop = 0;\n+  return 0;\n+}\n+\n+int\n+__gnat_safe_getservbyname (const char *name, const char *proto,\n+  struct servent *ret, char *buf, size_t buflen)\n+{\n+  struct servent *rh;\n+  rh = getservbyname (name, proto);\n+  if (rh == NULL)\n+    return -1;\n+  *ret = *rh;\n+  return 0;\n+}\n+\n+int\n+__gnat_safe_getservbyport (int port, const char *proto,\n+  struct servent *ret, char *buf, size_t buflen)\n+{\n+  struct servent *rh;\n+  rh = getservbyport (port, proto);\n+  if (rh == NULL)\n+    return -1;\n+  *ret = *rh;\n+  return 0;\n+}\n+#elif HAVE_GETxxxBYyyy_R\n+int\n+__gnat_safe_gethostbyname (const char *name,\n+  struct hostent *ret, char *buf, size_t buflen,\n+  int *h_errnop)\n+{\n+  struct hostent *rh;\n+  int ri;\n+\n+#ifdef __linux__\n+  (void) gethostbyname_r (name, ret, buf, buflen, &rh, h_errnop);\n+#else\n+  rh = gethostbyname_r (name, ret, buf, buflen, h_errnop);\n+#endif\n+  ri = (rh == NULL) ? -1 : 0;\n+  return ri;\n+}\n+\n+int\n+__gnat_safe_gethostbyaddr (const char *addr, int len, int type,\n+  struct hostent *ret, char *buf, size_t buflen,\n+  int *h_errnop)\n+{\n+  struct hostent *rh;\n+  int ri;\n+\n+#ifdef __linux__\n+  (void) gethostbyaddr_r (addr, len, type, ret, buf, buflen, &rh, h_errnop);\n+#else\n+  rh = gethostbyaddr_r (addr, len, type, ret, buf, buflen, h_errnop);\n+#endif\n+  ri = (rh == NULL) ? -1 : 0;\n+  return ri;\n+}\n+\n+int\n+__gnat_safe_getservbyname (const char *name, const char *proto,\n+  struct servent *ret, char *buf, size_t buflen)\n+{\n+  struct servent *rh;\n+  int ri;\n+\n+#ifdef __linux__\n+  (void) getservbyname_r (name, proto, ret, buf, buflen, &rh);\n+#else\n+  rh = getservbyname_r (name, proto, ret, buf, buflen);\n+#endif\n+  ri = (rh == NULL) ? -1 : 0;\n+  return ri;\n+}\n+\n+int\n+__gnat_safe_getservbyport (int port, const char *proto,\n+  struct servent *ret, char *buf, size_t buflen)\n+{\n+  struct servent *rh;\n+  int ri;\n+\n+#ifdef __linux__\n+  (void) getservbyport_r (port, proto, ret, buf, buflen, &rh);\n+#else\n+  rh = getservbyport_r (port, proto, ret, buf, buflen);\n+#endif\n+  ri = (rh == NULL) ? -1 : 0;\n+  return ri;\n+}\n #endif\n \f\n /* Free socket set. */\n@@ -241,15 +386,24 @@ __gnat_get_h_errno (void) {\n     default:\n       return -1;\n   }\n-#elif defined(VMS)\n-  return errno;\n-#elif defined(__rtems__)\n+\n+#elif defined (VMS)\n+  /* h_errno is defined as follows in OpenVMS' version of <netdb.h>.\n+   * However this header file is not available when building the GNAT\n+   * runtime library using GCC, so we are hardcoding the definition\n+   * directly. Note that the returned address is thread-specific.\n+   */\n+  extern int *decc$h_errno_get_addr ();\n+  return *decc$h_errno_get_addr ();\n+\n+#elif defined (__rtems__)\n   /* At this stage in the tool build, no networking .h files are available.\n-     Newlib does not provide networking .h files and RTEMS is not built yet.\n-     So we need to explicitly extern h_errno to access it.\n+   * Newlib does not provide networking .h files and RTEMS is not built yet.\n+   * So we need to explicitly extern h_errno to access it.\n    */\n   extern int h_errno;\n   return h_errno;\n+\n #else\n   return h_errno;\n #endif"}]}