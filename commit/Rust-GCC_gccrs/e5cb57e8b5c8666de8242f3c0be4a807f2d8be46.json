{"sha": "e5cb57e8b5c8666de8242f3c0be4a807f2d8be46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVjYjU3ZThiNWM4NjY2ZGU4MjQyZjNjMGJlNGE4MDdmMmQ4YmU0Ng==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-05-03T17:15:40Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-05-03T17:15:40Z"}, "message": "(asm_output_function_prefix, function_prologue): Setup\n\nFrom-SVN: r11915", "tree": {"sha": "b9e2d53ca5dd0576b6a014d75556e331bae05567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9e2d53ca5dd0576b6a014d75556e331bae05567"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5cb57e8b5c8666de8242f3c0be4a807f2d8be46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5cb57e8b5c8666de8242f3c0be4a807f2d8be46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5cb57e8b5c8666de8242f3c0be4a807f2d8be46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5cb57e8b5c8666de8242f3c0be4a807f2d8be46/comments", "author": null, "committer": null, "parents": [{"sha": "809c8c30be2829c4a7d60ec52c34274804a80aad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809c8c30be2829c4a7d60ec52c34274804a80aad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/809c8c30be2829c4a7d60ec52c34274804a80aad"}], "stats": {"total": 103, "additions": 94, "deletions": 9}, "files": [{"sha": "9d5c7f371bbe419348f28f1dc69b4a6810379db9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 94, "deletions": 9, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cb57e8b5c8666de8242f3c0be4a807f2d8be46/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cb57e8b5c8666de8242f3c0be4a807f2d8be46/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e5cb57e8b5c8666de8242f3c0be4a807f2d8be46", "patch": "@@ -72,14 +72,14 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   40\t\t\t\t\t/* cost of a divide/mod */\n };\n \n-struct processor_costs pentium_cost = {\t/* 486 specific costs */\n+struct processor_costs pentium_cost = {\n   1,\t\t\t\t\t/* cost of an add instruction */\n   1,\t\t\t\t\t/* cost of a lea instruction */\n   3,\t\t\t\t\t/* variable shift costs */\n-  2,\t\t\t\t\t/* constant shift costs */\n+  1,\t\t\t\t\t/* constant shift costs */\n   12,\t\t\t\t\t/* cost of starting a multiply */\n   1,\t\t\t\t\t/* cost of multiply per each bit set */\n-  40\t\t\t\t\t/* cost of a divide/mod */\n+  25\t\t\t\t\t/* cost of a divide/mod */\n };\n \n struct processor_costs *ix86_cost = &pentium_cost;\n@@ -1674,6 +1674,31 @@ ix86_unary_operator_ok (code, mode, operands)\n }\n \n \f\n+\n+static rtx pic_label_rtx;\n+\n+/* This function generates code for -fpic that loads %ebx with\n+   with the return address of the caller and then returns.  */\n+void\n+asm_output_function_prefix (file, name)\n+    FILE * file;\n+    char * name;\n+{\n+  rtx xops[2];\n+  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n+\t\t\t\t  || current_function_uses_const_pool);\n+  xops[0] = pic_offset_table_rtx;\n+  xops[1] = stack_pointer_rtx;\n+\n+  if (pic_reg_used && TARGET_DEEP_BRANCH_PREDICTION)\n+    {\n+      pic_label_rtx = (rtx) gen_label_rtx ();\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (pic_label_rtx));\n+      output_asm_insn (\"movl (%1),%0\", xops);\n+      output_asm_insn (\"ret\", xops);\n+    }\n+}\n+\n /* This function generates the assembly code for function entry.\n    FILE is an stdio stream to output the code to.\n    SIZE is an int: how many units of temporary storage to allocate. */\n@@ -1719,16 +1744,23 @@ function_prologue (file, size)\n \toutput_asm_insn (\"push%L0 %0\", xops);\n       }\n \n-  if (pic_reg_used)\n+  if (pic_reg_used && TARGET_PENTIUMPRO)\n     {\n       xops[0] = pic_offset_table_rtx;\n-      xops[1] = (rtx) gen_label_rtx ();\n+      xops[1] = pic_label_rtx;\n \n       output_asm_insn (AS1 (call,%P1), xops);\n-      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (xops[1]));\n-      output_asm_insn (AS1 (pop%L0,%0), xops);\n-      output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_+[.-%P1],%0\", xops);\n+      output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_,%0\", xops);\n     }\n+  else {\n+    xops[0] = pic_offset_table_rtx;\n+    xops[1] = (rtx) gen_label_rtx ();\n+ \n+    output_asm_insn (AS1 (call,%P1), xops);\n+    ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (xops[1]));\n+    output_asm_insn (AS1 (pop%L0,%0), xops);\n+    output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_+[.-%P1],%0\", xops);\n+  } \n }\n \n /* Return 1 if it is appropriate to emit `ret' instructions in the\n@@ -2526,9 +2558,53 @@ output_pic_addr_const (file, x, code)\n     }\n }\n \f\n+\n+/* Append the correct conditional move suffix which corresponds to CODE */\n+\n+static void\n+put_condition_code (code, file)\n+    enum rtx_code code;\n+    FILE * file;\n+{\n+  switch (code)\n+    {\n+      case NE: \n+\t  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n+\t    fputs (\"b\", file);\n+\t  else\n+\t    fputs (\"ne\", file);\n+\t  return;\n+      case EQ: \n+\t  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n+\t    fputs (\"ae\", file);\n+\t  else\n+\t    fputs (\"e\", file);\n+\t  return;\n+      case GE: \n+\t  fputs (\"ge\", file); return;\n+      case GT: \n+\t  fputs (\"g\", file); return;\n+      case LE: \n+\t  fputs (\"le\", file); return;\n+      case LT: \n+\t  fputs (\"l\", file); return;\n+      case GEU: \n+\t  fputs (\"ae\", file); return;\n+      case GTU: \n+\t  fputs (\"a\", file); return;\n+      case LEU: \n+\t  fputs (\"be\", file); return;\n+      case LTU: \n+\t  fputs (\"b\", file); return;\n+      default: output_operand_lossage (\"Invalid %%C operand\");\n+    }\n+}\n+\n /* Meaning of CODE:\n    f -- float insn (print a CONST_DOUBLE as a float rather than in hex).\n    D,L,W,B,Q,S -- print the opcode suffix for specified size of operand.\n+   C -- print opcode suffix for set/cmov insn.\n+   N -- like C, but print reversed condition\n    R -- print the prefix for register names.\n    z -- print the opcode suffix for the size of the current operand.\n    * -- print a star (in certain assembler syntax)\n@@ -2651,6 +2727,15 @@ print_operand (file, x, code)\n \t    }\n \t  abort ();\n \n+      /* This is used by the conditional move instructions.  */\n+    case 'C':\n+\tput_condition_code (GET_CODE (x), file);\n+\treturn;\n+      /* like above but reverse condition */\n+    case 'N':\n+\tput_condition_code (reverse_condition (GET_CODE (x)), file);\n+\treturn;\n+\n \tdefault:\n \t  {\n \t    char str[50];\n@@ -4396,7 +4481,7 @@ output_strlen_unroll (operands)\n \n   if (QI_REG_P (xops[1]))\n     {\n-\t/* on i586 it is faster to compare the hi- and lo- part */\n+ \t/* on i586 it is faster to compare the hi- and lo- part */\n \t/* as a kind of lookahead.  If xoring both is zero, then one */\n \t/* of both *could* be zero, otherwith none of both is zero */\n \t/* this saves one instruction, on i486 this is slower */"}]}