{"sha": "b0e878721209b1b2a6f6596a9334178884167f2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBlODc4NzIxMjA5YjFiMmE2ZjY1OTZhOTMzNDE3ODg4NDE2N2YyZQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-06-10T19:48:55Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-06-10T19:48:55Z"}, "message": "protoize.c: Include gansidecl.h.\n\n\t* protoize.c: Include gansidecl.h.\n\t(my_execvp): Delete.\n\t(choose_temp_base,pexecute,pwait): Declare.\n\t(PEXECUTE_{FIRST,LAST,SEARCH}): Define.\n\t(execvp): Delete decl.\n\t(usage): Fix typo.\n\t(gen_aux_info_file): Rewrite to use pexecute/pwait.\n\nFrom-SVN: r12267", "tree": {"sha": "78d7965651cbc1ce793423bde2171e8b70ce1baf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78d7965651cbc1ce793423bde2171e8b70ce1baf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0e878721209b1b2a6f6596a9334178884167f2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e878721209b1b2a6f6596a9334178884167f2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0e878721209b1b2a6f6596a9334178884167f2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e878721209b1b2a6f6596a9334178884167f2e/comments", "author": null, "committer": null, "parents": [{"sha": "b46de15ede48804ec0dce7b15bb60160c859bb51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46de15ede48804ec0dce7b15bb60160c859bb51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b46de15ede48804ec0dce7b15bb60160c859bb51"}], "stats": {"total": 119, "additions": 49, "deletions": 70}, "files": [{"sha": "d313398eb9ea07b9810de8da73aeb4fc924b9aa4", "filename": "gcc/protoize.c", "status": "modified", "additions": 49, "deletions": 70, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e878721209b1b2a6f6596a9334178884167f2e/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e878721209b1b2a6f6596a9334178884167f2e/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=b0e878721209b1b2a6f6596a9334178884167f2e", "patch": "@@ -1,5 +1,5 @@\n /* Protoize program - Original version by Ron Guilmette (rfg@segfault.us.com).\n-   Copyright (C) 1989, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 92-95, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -74,6 +74,8 @@ Boston, MA 02111-1307, USA.  */\n #endif\n #include <setjmp.h>\n \n+#include \"gansidecl.h\"\n+\n /* Include getopt.h for the sake of getopt_long.\n    We don't need the declaration of getopt, and it could conflict\n    with something from a system header file, so effectively nullify that.  */\n@@ -107,14 +109,23 @@ extern char *version_string;\n \n #define my_access(file,flag)\taccess((char *)file, flag)\n #define my_stat(file,pkt)\tstat((char *)file, pkt)\n-#define my_execvp(prog,argv)\texecvp((char *)prog, (char **)argv)\n #define my_link(file1, file2)\tlink((char *)file1, (char *)file2)\n #define my_unlink(file)\t\tunlink((char *)file)\n #define my_open(file, mode, flag)\topen((char *)file, mode, flag)\n #define my_chmod(file, mode)\tchmod((char *)file, mode)\n \n extern char *getpwd ();\n \n+extern char *choose_temp_base PROTO ((void));\n+\n+extern int pexecute PROTO ((const char *, char * const *, const char *,\n+\t\t\t    const char *, char **, char **, int));\n+extern int pwait PROTO ((int, int *, int));\n+/* Flag arguments to pexecute.  */\n+#define PEXECUTE_FIRST  1\n+#define PEXECUTE_LAST   2\n+#define PEXECUTE_SEARCH 4\n+\n /* Aliases for pointers to void.\n    These were made to facilitate compilation with old brain-dead DEC C\n    compilers which didn't properly grok `void*' types.  */\n@@ -192,7 +203,6 @@ extern int fputc ();\n extern int link ();\n extern int unlink ();\n extern int access ();\n-extern int execvp ();\n \n #if 0 /* size_t from sys/types.h may fail to match GCC.\n \t If so, we would get a warning from this.  */\n@@ -867,7 +877,7 @@ usage ()\n   fprintf (stderr, \"%s: usage '%s [ -VqfnkN ] [ -i <istring> ] [ filename ... ]'\\n\",\n \t   pname, pname);\n #else /* !defined (UNPROTOIZE) */\n-  fprintf (stderr, \"%s: usage '%s [ -VqfnkNlgC ] [ -B <diname> ] [ filename ... ]'\\n\",\n+  fprintf (stderr, \"%s: usage '%s [ -VqfnkNlgC ] [ -B <dirname> ] [ filename ... ]'\\n\",\n \t   pname, pname);\n #endif /* !defined (UNPROTOIZE) */\n   exit (1);\n@@ -2085,14 +2095,14 @@ munge_compile_params (params_list)\n }\n \n /* Do a recompilation for the express purpose of generating a new aux_info\n-   file to go with a specific base source file.  */\n+   file to go with a specific base source file.\n+\n+   The result is a boolean indicating success.  */\n \n static int\n gen_aux_info_file (base_filename)\n      const char *base_filename;\n {\n-  int child_pid;\n-\n   if (!input_file_name_index)\n     munge_compile_params (\"\");\n \n@@ -2109,79 +2119,48 @@ gen_aux_info_file (base_filename)\n     fprintf (stderr, \"%s: compiling `%s'\\n\",\n \t     pname, compile_params[input_file_name_index]);\n \n-  if (child_pid = fork ())\n-    {\n-      if (child_pid == -1)\n-        {\n-          fprintf (stderr, \"%s: could not fork process: %s\\n\",\n-\t\t   pname, my_strerror(errno));\n-          return 0;\n-        }\n+  {\n+    char *errmsg_fmt, *errmsg_arg;\n+    int wait_status, pid;\n+    char *temp_base = choose_temp_base ();\n \n-#if 0\n-      /* Print out the command line that the other process is now executing.  */\n-\n-      if (!quiet_flag)\n-        {\n-          const char **arg;\n-  \n-          fputs (\"\\t\", stderr);\n-          for (arg = compile_params; *arg; arg++)\n-            {\n-              fputs (*arg, stderr);\n-              fputc (' ', stderr);\n-            }\n-          fputc ('\\n', stderr);\n-          fflush (stderr);\n-        }\n-#endif /* 0 */\n+    pid = pexecute (compile_params[0], (char * const *) compile_params,\n+\t\t    pname, temp_base, &errmsg_fmt, &errmsg_arg,\n+\t\t    PEXECUTE_FIRST | PEXECUTE_LAST | PEXECUTE_SEARCH);\n \n+    if (pid == -1)\n       {\n-        int wait_status;\n+\tint errno_val = errno;\n+\tfprintf (stderr, \"%s: \", pname);\n+\tfprintf (stderr, errmsg_fmt, errmsg_arg);\n+\tfprintf (stderr, \": %s\\n\", my_strerror (errno_val));\n+\treturn 0;\n+      }\n \n-        if (wait (&wait_status) == -1)\n-          {\n-            fprintf (stderr, \"%s: wait failed: %s\\n\",\n-\t\t     pname, my_strerror(errno));\n-            return 0;\n-          }\n-\tif (WIFSIGNALED (wait_status))\n-\t  {\n-\t    fprintf (stderr, \"%s: subprocess got fatal signal %d\",\n-\t\t     pname, WTERMSIG (wait_status));\n-\t    return 0;\n-\t  }\n-\tif (WIFEXITED (wait_status) && WEXITSTATUS (wait_status) != 0)\n+    pid = pwait (pid, &wait_status, 0);\n+    if (pid == -1)\n+      {\n+\tfprintf (stderr, \"%s: wait: %s\\n\", pname, my_strerror (errno));\n+\treturn 0;\n+      }\n+    if (WIFSIGNALED (wait_status))\n+      {\n+\tfprintf (stderr, \"%s: subprocess got fatal signal %d\\n\",\n+\t\t pname, WTERMSIG (wait_status));\n+\treturn 0;\n+      }\n+    if (WIFEXITED (wait_status))\n+      {\n+\tif (WEXITSTATUS (wait_status) != 0)\n \t  {\n \t    fprintf (stderr, \"%s: %s exited with status %d\\n\",\n-\t\t     pname, base_filename, WEXITSTATUS (wait_status));\n+\t\t     pname, compile_params[0], WEXITSTATUS (wait_status));\n \t    return 0;\n \t  }\n \treturn 1;\n       }\n-    }\n-  else\n-    {\n-      if (my_execvp (compile_params[0], (char *const *) compile_params))\n-        {\n-\t  int e = errno, f = fileno (stderr);\n-\t  write (f, pname, strlen (pname));\n-\t  write (f, \": \", 2);\n-\t  write (f, compile_params[0], strlen (compile_params[0]));\n-\t  write (f, \": \", 2);\n-#ifdef HAVE_STRERROR\n-\t  {\n-\t    char *p = strerror(e);\n-\t    write (f, p, strlen (p));\n-\t  }\n-#else\n-\t  write (f, sys_errlist[e], strlen (sys_errlist[e]));\n-#endif\n-\t  write (f, \"\\n\", 1);\n-          _exit (1);\n-        }\n-      return 1;\t\t/* Never executed.  */\n-    }\n+    abort ();\n+  }\n }\n \f\n /* Read in all of the information contained in a single aux_info file."}]}