{"sha": "6d8b12448d9bbe96517f2145a93f4589e947edb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ4YjEyNDQ4ZDliYmU5NjUxN2YyMTQ1YTkzZjQ1ODllOTQ3ZWRiNQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-12-10T01:18:30Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-12-10T01:18:30Z"}, "message": "resolve.cc (_Jv_PrepareClass): Verify method here...\n\n\t* resolve.cc (_Jv_PrepareClass): Verify method here...\n\t* defineclass.cc (handleMethodsEnd): ... not here.\n\t* verify.cc (_Jv_BytecodeVerifier::initialize_stack): New method.\n\t(_Jv_BytecodeVerifier::verify_instructions_0) [op_return]: Ensure\n\tthere are no uninitialized objects.\n\t(_Jv_BytecodeVerifier::state::this_type): New field.\n\t(_Jv_BytecodeVerifier::state::state): Initialize this_type.\n\t(_Jv_BytecodeVerifier::state::copy): Copy this_type.\n\t(_Jv_BytecodeVerifier::state::merge): Merge this_type.\n\t(_Jv_BytecodeVerifier::state::check_no_uninitialized_objects):\n\tHandle this_type.\n\t(_Jv_BytecodeVerifier::state::check_this_initialized): New\n\tmethod.\n\t(_Jv_BytecodeVerifier::state::set_initialized): Handle this_type.\n\t(_Jv_BytecodeVerifier::state::set_this_type): New method.\n\t(_Jv_BytecodeVerifier::verify_instructions_0) [op_putfield]: Allow\n\tassignment to fields of `this' before another initializer is run.\n\nFrom-SVN: r47826", "tree": {"sha": "45cc1d1d0e9f8a64a919f48430d377afbd8b126c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45cc1d1d0e9f8a64a919f48430d377afbd8b126c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d8b12448d9bbe96517f2145a93f4589e947edb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8b12448d9bbe96517f2145a93f4589e947edb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d8b12448d9bbe96517f2145a93f4589e947edb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8b12448d9bbe96517f2145a93f4589e947edb5/comments", "author": null, "committer": null, "parents": [{"sha": "ec10f7c7036edcb58649048bef39ade57fc12594", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec10f7c7036edcb58649048bef39ade57fc12594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec10f7c7036edcb58649048bef39ade57fc12594"}], "stats": {"total": 144, "additions": 105, "deletions": 39}, "files": [{"sha": "c9d99f5d0ee2557f2cd711b443bff18eb65b73e6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8b12448d9bbe96517f2145a93f4589e947edb5/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8b12448d9bbe96517f2145a93f4589e947edb5/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6d8b12448d9bbe96517f2145a93f4589e947edb5", "patch": "@@ -1,5 +1,23 @@\n 2001-12-09  Tom Tromey  <tromey@redhat.com>\n \n+\t* resolve.cc (_Jv_PrepareClass): Verify method here...\n+\t* defineclass.cc (handleMethodsEnd): ... not here.\n+\t* verify.cc (_Jv_BytecodeVerifier::initialize_stack): New method.\n+\t(_Jv_BytecodeVerifier::verify_instructions_0) [op_return]: Ensure\n+\tthere are no uninitialized objects.\n+\t(_Jv_BytecodeVerifier::state::this_type): New field.\n+\t(_Jv_BytecodeVerifier::state::state): Initialize this_type.\n+\t(_Jv_BytecodeVerifier::state::copy): Copy this_type.\n+\t(_Jv_BytecodeVerifier::state::merge): Merge this_type.\n+\t(_Jv_BytecodeVerifier::state::check_no_uninitialized_objects):\n+\tHandle this_type.\n+\t(_Jv_BytecodeVerifier::state::check_this_initialized): New\n+\tmethod.\n+\t(_Jv_BytecodeVerifier::state::set_initialized): Handle this_type.\n+\t(_Jv_BytecodeVerifier::state::set_this_type): New method.\n+\t(_Jv_BytecodeVerifier::verify_instructions_0) [op_putfield]: Allow\n+\tassignment to fields of `this' before another initializer is run.\n+\n \t* Makefile.in: Rebuilt.\n \t* Makefile.am (gnu/gcj/runtime/VMClassLoader.h): Use `::java'.\n "}, {"sha": "df2da0968e7d18102ec8addc356221284f0d8266", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8b12448d9bbe96517f2145a93f4589e947edb5/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8b12448d9bbe96517f2145a93f4589e947edb5/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=6d8b12448d9bbe96517f2145a93f4589e947edb5", "patch": "@@ -940,7 +940,7 @@ _Jv_ClassReader::handleClassBegin\n       pool_data[super_class].clazz = the_super;\n       pool_tags[super_class] = JV_CONSTANT_ResolvedClass;\n     }\n-\t    \n+\n   // now we've come past the circularity problem, we can \n   // now say that we're loading...\n \n@@ -1315,15 +1315,6 @@ void _Jv_ClassReader::handleMethodsEnd ()\n \t{\n \t  if (def->interpreted_methods[i] == 0)\n \t    throw_class_format_error (\"method with no code\");\n-\n-\t  if (verify)\n-\t    {\n-\t      _Jv_InterpMethod *m;\n-\t      m = (reinterpret_cast<_Jv_InterpMethod *>\n-\t\t   (def->interpreted_methods[i]));\n-\t      // FIXME: enable once verifier is more fully tested.\n-\t      // _Jv_VerifyMethod (m);\n-\t    }\n \t}\n     }\n }"}, {"sha": "ba397c9b11901d6154c02f13a121e553604a06d4", "filename": "libjava/resolve.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8b12448d9bbe96517f2145a93f4589e947edb5/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8b12448d9bbe96517f2145a93f4589e947edb5/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=6d8b12448d9bbe96517f2145a93f4589e947edb5", "patch": "@@ -578,7 +578,7 @@ _Jv_PrepareClass(jclass klass)\n \n   // set the instance size for the class\n   clz->size_in_bytes = instance_size;\n-    \n+\n   // allocate static memory\n   if (static_size != 0)\n     {\n@@ -628,6 +628,8 @@ _Jv_PrepareClass(jclass klass)\n       else if (imeth != 0)\t\t// it could be abstract\n \t{\n \t  _Jv_InterpMethod *im = reinterpret_cast<_Jv_InterpMethod *> (imeth);\n+\t  // FIXME: enable once verifier is more fully tested.\n+\t  // _Jv_VerifyMethod (im);\n \t  clz->methods[i].ncode = im->ncode ();\n \t}\n     }"}, {"sha": "8627de571c3869af0de14b7e8d86c41d408d76cf", "filename": "libjava/verify.cc", "status": "modified", "additions": 83, "deletions": 28, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8b12448d9bbe96517f2145a93f4589e947edb5/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8b12448d9bbe96517f2145a93f4589e947edb5/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=6d8b12448d9bbe96517f2145a93f4589e947edb5", "patch": "@@ -764,6 +764,13 @@ class _Jv_BytecodeVerifier\n     // This is used to keep a linked list of all the states which\n     // require re-verification.  We use the PC to keep track.\n     int next;\n+    // We keep track of the type of `this' specially.  This is used to\n+    // ensure that an instance initializer invokes another initializer\n+    // on `this' before returning.  We must keep track of this\n+    // specially because otherwise we might be confused by code which\n+    // assigns to locals[0] (overwriting `this') and then returns\n+    // without really initializing.\n+    type this_type;\n \n     // INVALID marks a state which is not on the linked list of states\n     // requiring reverification.\n@@ -772,13 +779,15 @@ class _Jv_BytecodeVerifier\n     static const int NO_NEXT = -2;\n \n     state ()\n+      : this_type ()\n     {\n       stack = NULL;\n       locals = NULL;\n       local_changed = NULL;\n     }\n \n     state (int max_stack, int max_locals)\n+      : this_type ()\n     {\n       stacktop = 0;\n       stackdepth = 0;\n@@ -855,6 +864,7 @@ class _Jv_BytecodeVerifier\n \t    locals[i] = copy->locals[i];\n \t  local_changed[i] = copy->local_changed[i];\n \t}\n+      this_type = copy->this_type;\n       // Don't modify `next'.\n     }\n \n@@ -870,14 +880,19 @@ class _Jv_BytecodeVerifier\n       // FIXME: subroutine handling?\n     }\n \n-    // Merge STATE into this state.  Destructively modifies this state.\n-    // Returns true if the new state was in fact changed.  Will throw an\n-    // exception if the states are not mergeable.\n+    // Merge STATE_OLD into this state.  Destructively modifies this\n+    // state.  Returns true if the new state was in fact changed.\n+    // Will throw an exception if the states are not mergeable.\n     bool merge (state *state_old, bool ret_semantics,\n \t\tint max_locals)\n     {\n       bool changed = false;\n \n+      // Special handling for `this'.  If one or the other is\n+      // uninitialized, then the merge is uninitialized.\n+      if (this_type.isinitialized ())\n+\tthis_type = state_old->this_type;\n+\n       // Merge subroutine states.  *THIS and *STATE_OLD must be in the\n       // same subroutine.  Also, recursive subroutine calls must be\n       // avoided.\n@@ -940,6 +955,21 @@ class _Jv_BytecodeVerifier\n       for (int i = 0; i < max_locals; ++i)\n \tif (locals[i].isreference () && ! locals[i].isinitialized ())\n \t  verify_fail (\"uninitialized object in local variable\");\n+\n+      check_this_initialized ();\n+    }\n+\n+    // Ensure that `this' has been initialized.\n+    void check_this_initialized ()\n+    {\n+      if (this_type.isreference () && ! this_type.isinitialized ())\n+\tverify_fail (\"`this' is uninitialized\");\n+    }\n+\n+    // Set type of `this'.\n+    void set_this_type (const type &k)\n+    {\n+      this_type = k;\n     }\n \n     // Note that a local variable was modified.\n@@ -957,6 +987,7 @@ class _Jv_BytecodeVerifier\n \tstack[i].set_initialized (pc);\n       for (int i = 0; i < max_locals; ++i)\n \tlocals[i].set_initialized (pc);\n+      this_type.set_initialized (pc);\n     }\n \n     // Return true if this state is the unmerged result of a `ret'.\n@@ -1870,6 +1901,42 @@ class _Jv_BytecodeVerifier\n       verify_fail (\"incompatible return type\", start_PC);\n   }\n \n+  // Initialize the stack for the new method.  Returns true if this\n+  // method is an instance initializer.\n+  bool initialize_stack ()\n+  {\n+    int var = 0;\n+    bool is_init = false;\n+\n+    using namespace java::lang::reflect;\n+    if (! Modifier::isStatic (current_method->self->accflags))\n+      {\n+\ttype kurr (current_class);\n+\tif (_Jv_equalUtf8Consts (current_method->self->name, gcj::init_name))\n+\t  {\n+\t    kurr.set_uninitialized (type::SELF);\n+\t    is_init = true;\n+\t  }\n+\tset_variable (0, kurr);\n+\tcurrent_state->set_this_type (kurr);\n+\t++var;\n+      }\n+\n+    // We have to handle wide arguments specially here.\n+    int arg_count = _Jv_count_arguments (current_method->self->signature);\n+    type arg_types[arg_count];\n+    compute_argument_types (current_method->self->signature, arg_types);\n+    for (int i = 0; i < arg_count; ++i)\n+      {\n+\tset_variable (var, arg_types[i]);\n+\t++var;\n+\tif (arg_types[i].iswide ())\n+\t  ++var;\n+      }\n+\n+    return is_init;\n+  }\n+\n   void verify_instructions_0 ()\n   {\n     current_state = new state (current_method->max_stack,\n@@ -1878,31 +1945,8 @@ class _Jv_BytecodeVerifier\n     PC = 0;\n     start_PC = 0;\n \n-    {\n-      int var = 0;\n-\n-      using namespace java::lang::reflect;\n-      if (! Modifier::isStatic (current_method->self->accflags))\n-\t{\n-\t  type kurr (current_class);\n-\t  if (_Jv_equalUtf8Consts (current_method->self->name, gcj::init_name))\n-\t    kurr.set_uninitialized (type::SELF);\n-\t  set_variable (0, kurr);\n-\t  ++var;\n-\t}\n-\n-      // We have to handle wide arguments specially here.\n-      int arg_count = _Jv_count_arguments (current_method->self->signature);\n-      type arg_types[arg_count];\n-      compute_argument_types (current_method->self->signature, arg_types);\n-      for (int i = 0; i < arg_count; ++i)\n-\t{\n-\t  set_variable (var, arg_types[i]);\n-\t  ++var;\n-\t  if (arg_types[i].iswide ())\n-\t    ++var;\n-\t}\n-    }\n+    // True if we are verifying an instance initializer.\n+    bool this_is_init = initialize_stack ();\n \n     states = (state **) _Jv_Malloc (sizeof (state *)\n \t\t\t\t    * current_method->code_length);\n@@ -2561,6 +2605,10 @@ class _Jv_BytecodeVerifier\n \t    invalidate_pc ();\n \t    break;\n \t  case op_return:\n+\t    // We only need to check this when the return type is\n+\t    // void, because all instance initializers return void.\n+\t    if (this_is_init)\n+\t      current_state->check_this_initialized ();\n \t    check_return_type (void_type);\n \t    invalidate_pc ();\n \t    break;\n@@ -2583,6 +2631,13 @@ class _Jv_BytecodeVerifier\n \t      type klass;\n \t      type field = check_field_constant (get_ushort (), &klass);\n \t      pop_type (field);\n+\n+\t      // We have an obscure special case here: we can use\n+\t      // `putfield' on a field declared in this class, even if\n+\t      // `this' has not yet been initialized.\n+\t      if (! current_state->this_type.isinitialized ()\n+\t\t  && current_state->this_type.pc == type::SELF)\n+\t\tklass.set_uninitialized (type::SELF);\n \t      pop_type (klass);\n \t    }\n \t    break;"}]}