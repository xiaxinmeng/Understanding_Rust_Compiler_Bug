{"sha": "ad73b558320545ee96736ae3f3373c48d3622504", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ3M2I1NTgzMjA1NDVlZTk2NzM2YWUzZjMzNzNjNDhkMzYyMjUwNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-28T06:22:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-28T06:22:23Z"}, "message": "flow.c (tidy_fallthru_edges): Don't combine complex edges.\n\n        * flow.c (tidy_fallthru_edges): Don't combine complex edges.\n        (calculate_global_regs_live): Kill call-clobbered registers\n        across exception edges.\n        * reg-stack.c (convert_regs_1): Kill the entire target stack\n        across non-call exception edges.\n\nFrom-SVN: r40909", "tree": {"sha": "6a3f4acb3012550610fc130ba3daec51f92064a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a3f4acb3012550610fc130ba3daec51f92064a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad73b558320545ee96736ae3f3373c48d3622504", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad73b558320545ee96736ae3f3373c48d3622504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad73b558320545ee96736ae3f3373c48d3622504", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad73b558320545ee96736ae3f3373c48d3622504/comments", "author": null, "committer": null, "parents": [{"sha": "461fc4de6a0434d7fc8c3ef53b25a4e51db69829", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/461fc4de6a0434d7fc8c3ef53b25a4e51db69829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/461fc4de6a0434d7fc8c3ef53b25a4e51db69829"}], "stats": {"total": 44, "additions": 37, "deletions": 7}, "files": [{"sha": "de13830884d9d16b77b0c1e44ceeeff382ff275e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad73b558320545ee96736ae3f3373c48d3622504/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad73b558320545ee96736ae3f3373c48d3622504/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad73b558320545ee96736ae3f3373c48d3622504", "patch": "@@ -28,6 +28,12 @@\n \t* final.c: Don't check it.\n \t* except.c: Provide stub definition.\n \n+\t* flow.c (tidy_fallthru_edges): Don't combine complex edges.\n+\t(calculate_global_regs_live): Kill call-clobbered registers\n+\tacross exception edges.\n+\t* reg-stack.c (convert_regs_1): Kill the entire target stack\n+\tacross non-call exception edges.\n+\n 2001-03-27  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* configure.in: Don't check for bcopy."}, {"sha": "e8bf0400262a88448324a17cf2bd8654864de6cb", "filename": "gcc/flow.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad73b558320545ee96736ae3f3373c48d3622504/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad73b558320545ee96736ae3f3373c48d3622504/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ad73b558320545ee96736ae3f3373c48d3622504", "patch": "@@ -2995,6 +2995,7 @@ tidy_fallthru_edges ()\n \t merge the flags for the duplicate edges.  So we do not want to\n \t check that the edge is not a FALLTHRU edge.  */\n       if ((s = b->succ) != NULL\n+\t  && ! (s->flags & EDGE_COMPLEX)\n \t  && s->succ_next == NULL\n \t  && s->dest == c\n \t  /* If the jump insn has side effects, we can't tidy the edge.  */\n@@ -3542,13 +3543,19 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n      int flags;\n {\n   basic_block *queue, *qhead, *qtail, *qend;\n-  regset tmp, new_live_at_end;\n-  regset_head tmp_head;\n+  regset tmp, new_live_at_end, call_used;\n+  regset_head tmp_head, call_used_head;\n   regset_head new_live_at_end_head;\n   int i;\n \n   tmp = INITIALIZE_REG_SET (tmp_head);\n   new_live_at_end = INITIALIZE_REG_SET (new_live_at_end_head);\n+  call_used = INITIALIZE_REG_SET (call_used_head);\n+\n+  /* Inconveniently, this is only redily available in hard reg set form.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    if (call_used_regs[i])\n+      SET_REGNO_REG_SET (call_used, i);\n \n   /* Create a worklist.  Allocate an extra slot for ENTRY_BLOCK, and one\n      because the `head == tail' style test for an empty queue doesn't\n@@ -3602,7 +3609,18 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  basic_block sb = e->dest;\n-\t  IOR_REG_SET (new_live_at_end, sb->global_live_at_start);\n+\n+\t  /* Call-clobbered registers die across exception and call edges.  */\n+\t  /* ??? Abnormal call edges ignored for the moment, as this gets\n+\t     confused by sibling call edges, which crashes reg-stack.  */\n+\t  if (e->flags & EDGE_EH)\n+\t    {\n+\t      bitmap_operation (tmp, sb->global_live_at_start,\n+\t\t\t\tcall_used, BITMAP_AND_COMPL);\n+\t      IOR_REG_SET (new_live_at_end, tmp);\n+\t    }\n+\t  else\n+\t    IOR_REG_SET (new_live_at_end, sb->global_live_at_start);\n \t}\n \n       /* The all-important stack pointer must always be live.  */\n@@ -3750,6 +3768,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \n   FREE_REG_SET (tmp);\n   FREE_REG_SET (new_live_at_end);\n+  FREE_REG_SET (call_used);\n \n   if (blocks_out)\n     {"}, {"sha": "54c3f086a48236a3447cb9104dc3c7516c8a878c", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad73b558320545ee96736ae3f3373c48d3622504/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad73b558320545ee96736ae3f3373c48d3622504/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=ad73b558320545ee96736ae3f3373c48d3622504", "patch": "@@ -2553,10 +2553,15 @@ convert_regs_1 (file, block)\n \t    }\n \t}\n \n-      /* Care for EH edges specially.  The normal return path may return\n-\t a value in st(0), but the EH path will not, and there's no need\n-\t to add popping code to the edge.  */\n-      if (e->flags & (EDGE_EH | EDGE_ABNORMAL_CALL))\n+      /* Care for non-call EH edges specially.  The normal return path have\n+\t values in registers.  These will be popped en masse by the unwind\n+\t library.  */\n+      if ((e->flags & (EDGE_EH | EDGE_ABNORMAL_CALL)) == EDGE_EH)\n+\ttarget_stack->top = -1;\n+\n+      /* Other calls may appear to have values live in st(0), but the\n+\t abnormal return path will not have actually loaded the values.  */\n+      else if (e->flags & EDGE_ABNORMAL_CALL)\n \t{\n \t  /* Assert that the lifetimes are as we expect -- one value\n \t     live at st(0) on the end of the source block, and no"}]}