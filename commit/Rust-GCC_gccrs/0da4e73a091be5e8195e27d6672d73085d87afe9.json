{"sha": "0da4e73a091be5e8195e27d6672d73085d87afe9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRhNGU3M2EwOTFiZTVlODE5NWUyN2Q2NjcyZDczMDg1ZDg3YWZlOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-05-19T09:49:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-19T09:49:55Z"}, "message": "re PR target/21390 (alphaev68-dec-osf5.1b long double optimization bug with gcc-4.0.0)\n\n        PR target/21390\n        * config/alpha/alpha.c (alpha_emit_conditional_branch): Move\n        TFmode code swapping ...\n        (alpha_emit_xfloating_compare): ... here.\n        (alpha_emit_setcc): Update to match.\n        (alpha_lookup_xfloating_lib_func): Assert TARGET_HAS_XFLOATING_LIBS.\n\nFrom-SVN: r99972", "tree": {"sha": "063a77ef427dec46a449285bdd24fd9fceb6e5b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/063a77ef427dec46a449285bdd24fd9fceb6e5b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0da4e73a091be5e8195e27d6672d73085d87afe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da4e73a091be5e8195e27d6672d73085d87afe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0da4e73a091be5e8195e27d6672d73085d87afe9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da4e73a091be5e8195e27d6672d73085d87afe9/comments", "author": null, "committer": null, "parents": [{"sha": "9a7e4ed66ad1bf4ad75fab99bab3eeaaca071d39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a7e4ed66ad1bf4ad75fab99bab3eeaaca071d39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a7e4ed66ad1bf4ad75fab99bab3eeaaca071d39"}], "stats": {"total": 107, "additions": 51, "deletions": 56}, "files": [{"sha": "4dd3f15cef102e4d76d00e062555032cd9561113", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da4e73a091be5e8195e27d6672d73085d87afe9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da4e73a091be5e8195e27d6672d73085d87afe9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0da4e73a091be5e8195e27d6672d73085d87afe9", "patch": "@@ -1,3 +1,12 @@\n+2005-05-19  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/21390\n+\t* config/alpha/alpha.c (alpha_emit_conditional_branch): Move \n+\tTFmode code swapping ...\n+\t(alpha_emit_xfloating_compare): ... here.\n+\t(alpha_emit_setcc): Update to match.\n+\t(alpha_lookup_xfloating_lib_func): Assert TARGET_HAS_XFLOATING_LIBS.\n+\n 2005-05-19  Richard Henderson  <rth@redhat.com>\n \n \tPR target/21657"}, {"sha": "66f9f48ea9464b83e7794453c7e02c5bdaeeefde", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 42, "deletions": 56, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da4e73a091be5e8195e27d6672d73085d87afe9/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da4e73a091be5e8195e27d6672d73085d87afe9/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=0da4e73a091be5e8195e27d6672d73085d87afe9", "patch": "@@ -211,7 +211,7 @@ static struct alpha_rtx_cost_data const alpha_rtx_cost_size =\n \n /* Declarations of static functions.  */\n static struct machine_function *alpha_init_machine_status (void);\n-static rtx alpha_emit_xfloating_compare (enum rtx_code, rtx, rtx);\n+static rtx alpha_emit_xfloating_compare (enum rtx_code *, rtx, rtx);\n \n #if TARGET_ABI_OPEN_VMS\n static void alpha_write_linkage (FILE *, const char *, tree);\n@@ -2501,35 +2501,7 @@ alpha_emit_conditional_branch (enum rtx_code code)\n \n   if (alpha_compare.fp_p && GET_MODE (op0) == TFmode)\n     {\n-      gcc_assert (TARGET_HAS_XFLOATING_LIBS);\n-\n-      /* X_floating library comparison functions return\n-\t   -1  unordered\n-\t    0  false\n-\t    1  true\n-\t Convert the compare against the raw return value.  */\n-\n-      switch (code)\n-\t{\n-\tcase UNORDERED:\n-\t  cmp_code = EQ;\n-\t  code = LT;\n-\t  break;\n-\tcase ORDERED:\n-\t  cmp_code = EQ;\n-\t  code = GE;\n-\t  break;\n-\tcase NE:\n-\t  cmp_code = NE;\n-\t  code = NE;\n-\t  break;\n-\tdefault:\n-\t  cmp_code = code;\n-\t  code = GT;\n-\t  break;\n-\t}\n-\n-      op0 = alpha_emit_xfloating_compare (cmp_code, op0, op1);\n+      op0 = alpha_emit_xfloating_compare (&code, op0, op1);\n       op1 = const0_rtx;\n       alpha_compare.fp_p = 0;\n     }\n@@ -2665,29 +2637,9 @@ alpha_emit_setcc (enum rtx_code code)\n \n   if (fp_p && GET_MODE (op0) == TFmode)\n     {\n-      gcc_assert (TARGET_HAS_XFLOATING_LIBS);\n-\n-      /* X_floating library comparison functions return\n-\t   -1  unordered\n-\t    0  false\n-\t    1  true\n-\t Convert the compare against the raw return value.  */\n-\n-      if (code == UNORDERED || code == ORDERED)\n-\tcmp_code = EQ;\n-      else\n-\tcmp_code = code;\n-\n-      op0 = alpha_emit_xfloating_compare (cmp_code, op0, op1);\n+      op0 = alpha_emit_xfloating_compare (&code, op0, op1);\n       op1 = const0_rtx;\n       fp_p = 0;\n-\n-      if (code == UNORDERED)\n-\tcode = LT;\n-      else if (code == ORDERED)\n-\tcode = GE;\n-      else\n-        code = GT;\n     }\n \n   if (fp_p && !TARGET_FIX)\n@@ -3025,6 +2977,8 @@ alpha_lookup_xfloating_lib_func (enum rtx_code code)\n   long n = ARRAY_SIZE (xfloating_ops);\n   long i;\n \n+  gcc_assert (TARGET_HAS_XFLOATING_LIBS);\n+\n   /* How irritating.  Nothing to key off for the main table.  */\n   if (TARGET_FLOAT_VAX && (code == FLOAT_EXTEND || code == FLOAT_TRUNCATE))\n     {\n@@ -3185,12 +3139,44 @@ alpha_emit_xfloating_arith (enum rtx_code code, rtx operands[])\n /* Emit an X_floating library function call for a comparison.  */\n \n static rtx\n-alpha_emit_xfloating_compare (enum rtx_code code, rtx op0, rtx op1)\n+alpha_emit_xfloating_compare (enum rtx_code *pcode, rtx op0, rtx op1)\n {\n-  rtx func;\n-  rtx out, operands[2];\n+  enum rtx_code cmp_code, res_code;\n+  rtx func, out, operands[2];\n \n-  func = alpha_lookup_xfloating_lib_func (code);\n+  /* X_floating library comparison functions return\n+\t   -1  unordered\n+\t    0  false\n+\t    1  true\n+     Convert the compare against the raw return value.  */\n+\n+  cmp_code = *pcode;\n+  switch (cmp_code)\n+    {\n+    case UNORDERED:\n+      cmp_code = EQ;\n+      res_code = LT;\n+      break;\n+    case ORDERED:\n+      cmp_code = EQ;\n+      res_code = GE;\n+      break;\n+    case NE:\n+      res_code = NE;\n+      break;\n+    case EQ:\n+    case LT:\n+    case GT:\n+    case LE:\n+    case GE:\n+      res_code = GT;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  *pcode = res_code;\n+\n+  func = alpha_lookup_xfloating_lib_func (cmp_code);\n \n   operands[0] = op0;\n   operands[1] = op1;\n@@ -3199,7 +3185,7 @@ alpha_emit_xfloating_compare (enum rtx_code code, rtx op0, rtx op1)\n   /* ??? Strange mode for equiv because what's actually returned\n      is -1,0,1, not a proper boolean value.  */\n   alpha_emit_xfloating_libcall (func, out, operands, 2,\n-\t\t\t\tgen_rtx_fmt_ee (code, CCmode, op0, op1));\n+\t\t\t\tgen_rtx_fmt_ee (cmp_code, CCmode, op0, op1));\n \n   return out;\n }"}]}