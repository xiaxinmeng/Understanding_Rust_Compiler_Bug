{"sha": "885c9b5d3a53c531fca622b4a3b0ef03df92daed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg1YzliNWQzYTUzYzUzMWZjYTYyMmI0YTNiMGVmMDNkZjkyZGFlZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-11-16T22:13:52Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-11-16T22:13:52Z"}, "message": "re PR rtl-optimization/46315 (-O2 -fno-strict-overflow causes wrong code generation)\n\n\tPR rtl-optimization/46315\n\t* rtl.h (remove_reg_equal_equiv_notes_for_regno): Declare.\n\t* rtlanal.c (remove_reg_equal_equiv_notes_for_regno): New function\n\textracted from...\n\t* dce.c (delete_corresponding_reg_eq_notes): ...here.  Rename into...\n\t(remove_reg_equal_equiv_notes_for_defs): ...this.\n\t(delete_unmarked_insns): Adjust to above renaming.\n\t* ifcvt.c (dead_or_predicable): Remove REG_EQUAL and REG_EQUIV notes\n\treferring to registers set in the insns being moved, if any.\n\n\t* df-core.c (df_ref_dump): New function extracted from...\n\t(df_refs_chain_dump): ...here.  Call it.\n\t(df_regs_chain_dump): Likewise.\n\t* df-problems.c (df_chain_dump): Print 'e' for uses in notes.\n\t* df-scan.c (df_scan_start_dump): Likewise.  Fix long line.\n\nFrom-SVN: r166827", "tree": {"sha": "d3ce62c6785fad984002bec2dbfc693e299f8950", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3ce62c6785fad984002bec2dbfc693e299f8950"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/885c9b5d3a53c531fca622b4a3b0ef03df92daed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/885c9b5d3a53c531fca622b4a3b0ef03df92daed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/885c9b5d3a53c531fca622b4a3b0ef03df92daed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/885c9b5d3a53c531fca622b4a3b0ef03df92daed/comments", "author": null, "committer": null, "parents": [{"sha": "2b12962772d3b0e85d860609f32bfb28515d5ba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b12962772d3b0e85d860609f32bfb28515d5ba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b12962772d3b0e85d860609f32bfb28515d5ba9"}], "stats": {"total": 214, "additions": 155, "deletions": 59}, "files": [{"sha": "4e4f64a68d69e6fb4fdc684f8eee67b71f733635", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=885c9b5d3a53c531fca622b4a3b0ef03df92daed", "patch": "@@ -1,3 +1,21 @@\n+2010-11-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/46315\n+\t* rtl.h (remove_reg_equal_equiv_notes_for_regno): Declare.\n+\t* rtlanal.c (remove_reg_equal_equiv_notes_for_regno): New function\n+\textracted from...\n+\t* dce.c (delete_corresponding_reg_eq_notes): ...here.  Rename into...\n+\t(remove_reg_equal_equiv_notes_for_defs): ...this.\n+\t(delete_unmarked_insns): Adjust to above renaming.\n+\t* ifcvt.c (dead_or_predicable): Remove REG_EQUAL and REG_EQUIV notes\n+\treferring to registers set in the insns being moved, if any.\n+\n+\t* df-core.c (df_ref_dump): New function extracted from...\n+\t(df_refs_chain_dump): ...here.  Call it.\n+\t(df_regs_chain_dump): Likewise.\n+\t* df-problems.c (df_chain_dump): Print 'e' for uses in notes.\n+\t* df-scan.c (df_scan_start_dump): Likewise.  Fix long line.\n+\n 2010-11-16  Andreas Schwab  <schwab@linux-m68k.org>\n \n \tPR rtl-optimization/46395"}, {"sha": "a7697f51e06c20e54b41ea0300b278e11abb3e90", "filename": "gcc/dce.c", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=885c9b5d3a53c531fca622b4a3b0ef03df92daed", "patch": "@@ -466,36 +466,16 @@ find_call_stack_args (rtx call_insn, bool do_mark, bool fast,\n }\n \n \n-/* Delete all REG_EQUAL notes of the registers INSN writes, to prevent\n-   bad dangling REG_EQUAL notes. */\n+/* Remove all REG_EQUAL and REG_EQUIV notes referring to the registers INSN\n+   writes to.  */\n \n static void\n-delete_corresponding_reg_eq_notes (rtx insn)\n+remove_reg_equal_equiv_notes_for_defs (rtx insn)\n {\n   df_ref *def_rec;\n+\n   for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-    {\n-      df_ref def = *def_rec;\n-      unsigned int regno = DF_REF_REGNO (def);\n-      /* This loop is a little tricky.  We cannot just go down the\n-\t chain because it is being modified by the actions in the\n-\t loop.  So we just get the head.  We plan to drain the list\n-\t anyway.  */\n-      while (DF_REG_EQ_USE_CHAIN (regno))\n-\t{\n-\t  df_ref eq_use = DF_REG_EQ_USE_CHAIN (regno);\n-\t  rtx noted_insn = DF_REF_INSN (eq_use);\n-\t  rtx note = find_reg_note (noted_insn, REG_EQUAL, NULL_RTX);\n-\t  if (!note)\n-\t    note = find_reg_note (noted_insn, REG_EQUIV, NULL_RTX);\n-\n-\t  /* This assert is generally triggered when someone deletes a\n-\t     REG_EQUAL or REG_EQUIV note by hacking the list manually\n-\t     rather than calling remove_note.  */\n-\t  gcc_assert (note);\n-\t  remove_note (noted_insn, note);\n-\t}\n-    }\n+    remove_reg_equal_equiv_notes_for_regno (DF_REF_REGNO (*def_rec));\n }\n \n \n@@ -544,9 +524,9 @@ delete_unmarked_insns (void)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"DCE: Deleting insn %d\\n\", INSN_UID (insn));\n \n-\t  /* Before we delete the insn we have to delete REG_EQUAL notes\n+\t  /* Before we delete the insn we have to remove the REG_EQUAL notes\n \t     for the destination regs in order to avoid dangling notes.  */\n-\t  delete_corresponding_reg_eq_notes (insn);\n+\t  remove_reg_equal_equiv_notes_for_defs (insn);\n \n \t  /* If a pure or const call is deleted, this may make the cfg\n \t     have unreachable blocks.  We rememeber this and call"}, {"sha": "dacefc71aaf88e83bbff8c9b402f03814dea38d1", "filename": "gcc/df-core.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=885c9b5d3a53c531fca622b4a3b0ef03df92daed", "patch": "@@ -2051,17 +2051,25 @@ df_dump_bottom (basic_block bb, FILE *file)\n }\n \n \n+static void\n+df_ref_dump (df_ref ref, FILE *file)\n+{\n+  fprintf (file, \"%c%d(%d)\",\n+\t   DF_REF_REG_DEF_P (ref)\n+\t   ? 'd'\n+\t   : (DF_REF_FLAGS (ref) & DF_REF_IN_NOTE) ? 'e' : 'u',\n+\t   DF_REF_ID (ref),\n+\t   DF_REF_REGNO (ref));\n+}\n+\n void\n df_refs_chain_dump (df_ref *ref_rec, bool follow_chain, FILE *file)\n {\n   fprintf (file, \"{ \");\n   while (*ref_rec)\n     {\n       df_ref ref = *ref_rec;\n-      fprintf (file, \"%c%d(%d)\",\n-\t       DF_REF_REG_DEF_P (ref) ? 'd' : (DF_REF_FLAGS (ref) & DF_REF_IN_NOTE) ? 'e' : 'u',\n-\t       DF_REF_ID (ref),\n-\t       DF_REF_REGNO (ref));\n+      df_ref_dump (ref, file);\n       if (follow_chain)\n \tdf_chain_dump (DF_REF_CHAIN (ref), file);\n       ref_rec++;\n@@ -2078,10 +2086,7 @@ df_regs_chain_dump (df_ref ref,  FILE *file)\n   fprintf (file, \"{ \");\n   while (ref)\n     {\n-      fprintf (file, \"%c%d(%d) \",\n-\t       DF_REF_REG_DEF_P (ref) ? 'd' : 'u',\n-\t       DF_REF_ID (ref),\n-\t       DF_REF_REGNO (ref));\n+      df_ref_dump (ref, file);\n       ref = DF_REF_NEXT_REG (ref);\n     }\n   fprintf (file, \"}\");"}, {"sha": "559af9184627d8c0a670b1ab507225bd0b20b999", "filename": "gcc/df-problems.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=885c9b5d3a53c531fca622b4a3b0ef03df92daed", "patch": "@@ -109,10 +109,13 @@ df_chain_dump (struct df_link *link, FILE *file)\n   for (; link; link = link->next)\n     {\n       fprintf (file, \"%c%d(bb %d insn %d) \",\n-\t       DF_REF_REG_DEF_P (link->ref) ? 'd' : 'u',\n+\t       DF_REF_REG_DEF_P (link->ref)\n+\t       ? 'd'\n+\t       : (DF_REF_FLAGS (link->ref) & DF_REF_IN_NOTE) ? 'e' : 'u',\n \t       DF_REF_ID (link->ref),\n \t       DF_REF_BBNO (link->ref),\n-\t       DF_REF_IS_ARTIFICIAL (link->ref) ? -1 : DF_REF_INSN_UID (link->ref));\n+\t       DF_REF_IS_ARTIFICIAL (link->ref)\n+\t       ? -1 : DF_REF_INSN_UID (link->ref));\n     }\n   fprintf (file, \"}\");\n }"}, {"sha": "5cda89730d31776d444be08afe7547ce118065f8", "filename": "gcc/df-scan.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=885c9b5d3a53c531fca622b4a3b0ef03df92daed", "patch": "@@ -445,7 +445,7 @@ df_scan_start_dump (FILE *file ATTRIBUTE_UNUSED)\n \t  }\n \tif (DF_REG_EQ_USE_COUNT (i))\n \t  {\n-\t    fprintf (file, \"%s%dd\", sep, DF_REG_EQ_USE_COUNT (i));\n+\t    fprintf (file, \"%s%de\", sep, DF_REG_EQ_USE_COUNT (i));\n \t    ecount += DF_REG_EQ_USE_COUNT (i);\n \t  }\n \tfprintf (file, \"} \");\n@@ -461,8 +461,10 @@ df_scan_start_dump (FILE *file ATTRIBUTE_UNUSED)\n \t    icount++;\n \t}\n \n-  fprintf (file, \"\\n;;    total ref usage %d{%dd,%du,%de} in %d{%d regular + %d call} insns.\\n\",\n-\t   dcount + ucount + ecount, dcount, ucount, ecount, icount + ccount, icount, ccount);\n+  fprintf (file, \"\\n;;    total ref usage %d{%dd,%du,%de}\"\n+\t\t \" in %d{%d regular + %d call} insns.\\n\",\n+\t\t dcount + ucount + ecount, dcount, ucount, ecount,\n+\t\t icount + ccount, icount, ccount);\n }\n \n /* Dump the bb_info for a given basic block. */"}, {"sha": "c91bbbfef295ac1a1392165c82251d38a7f457c3", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=885c9b5d3a53c531fca622b4a3b0ef03df92daed", "patch": "@@ -3998,6 +3998,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t\t    basic_block other_bb, basic_block new_dest, int reversep)\n {\n   rtx head, end, jump, earliest = NULL_RTX, old_dest, new_label = NULL_RTX;\n+  bitmap merge_set = NULL, merge_set_noclobber = NULL;\n   /* Number of pending changes.  */\n   int n_validated_changes = 0;\n \n@@ -4086,6 +4087,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       earliest = jump;\n     }\n #endif\n+\n   /* Try the NCE path if the CE path did not result in any changes.  */\n   if (n_validated_changes == 0)\n     {\n@@ -4094,9 +4096,8 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t that any registers modified are dead at the branch site.  */\n \n       rtx insn, cond, prev;\n-      bitmap merge_set, merge_set_noclobber, test_live, test_set;\n-      unsigned i, fail = 0;\n-      bitmap_iterator bi;\n+      bitmap test_live, test_set;\n+      bool intersect = false;\n \n       /* Check for no calls or trapping operations.  */\n       for (insn = head; ; insn = NEXT_INSN (insn))\n@@ -4138,12 +4139,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \n       merge_set = BITMAP_ALLOC (&reg_obstack);\n       merge_set_noclobber = BITMAP_ALLOC (&reg_obstack);\n-      test_live = BITMAP_ALLOC (&reg_obstack);\n-      test_set = BITMAP_ALLOC (&reg_obstack);\n \n-      /* ??? bb->local_set is only valid during calculate_global_regs_live,\n-\t so we must recompute usage for MERGE_BB.  Not so bad, I suppose,\n-         since we've already asserted that MERGE_BB is small.  */\n       /* If we allocated new pseudos (e.g. in the conditional move\n \t expander called from noce_emit_cmove), we must resize the\n \t array first.  */\n@@ -4164,17 +4160,22 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       if (! reload_completed\n \t  && targetm.small_register_classes_for_mode_p (VOIDmode))\n \t{\n+\t  unsigned i;\n+\t  bitmap_iterator bi;\n+\n           EXECUTE_IF_SET_IN_BITMAP (merge_set_noclobber, 0, i, bi)\n \t    {\n \t      if (i < FIRST_PSEUDO_REGISTER\n \t\t  && ! fixed_regs[i]\n \t\t  && ! global_regs[i])\n-\t\tfail = 1;\n+\t\tgoto fail;\n \t    }\n \t}\n \n       /* For TEST, we're interested in a range of insns, not a whole block.\n \t Moreover, we're interested in the insns live from OTHER_BB.  */\n+      test_live = BITMAP_ALLOC (&reg_obstack);\n+      test_set = BITMAP_ALLOC (&reg_obstack);\n \n       /* The loop below takes the set of live registers\n          after JUMP, and calculates the live set before EARLIEST. */\n@@ -4195,23 +4196,21 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       /* We can perform the transformation if\n \t   MERGE_SET_NOCLOBBER & TEST_SET\n \t and\n-\t   MERGE_SET & TEST_LIVE)\n+\t   MERGE_SET & TEST_LIVE\n \t and\n \t   TEST_SET & DF_LIVE_IN (merge_bb)\n \t are empty.  */\n \n-      if (bitmap_intersect_p (test_set, merge_set_noclobber)\n-\t  || bitmap_intersect_p (test_live, merge_set)\n+      if (bitmap_intersect_p (merge_set_noclobber, test_set)\n+\t  || bitmap_intersect_p (merge_set, test_live)\n \t  || bitmap_intersect_p (test_set, df_get_live_in (merge_bb)))\n-\tfail = 1;\n+\tintersect = true;\n \n-      BITMAP_FREE (merge_set_noclobber);\n-      BITMAP_FREE (merge_set);\n       BITMAP_FREE (test_live);\n       BITMAP_FREE (test_set);\n \n-      if (fail)\n-\treturn FALSE;\n+      if (intersect)\n+\tgoto fail;\n     }\n \n  no_body:\n@@ -4261,8 +4260,8 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       if (end == BB_END (merge_bb))\n \tBB_END (merge_bb) = PREV_INSN (head);\n \n-      /* PR 21767: When moving insns above a conditional branch, REG_EQUAL\n-\t notes might become invalid.  */\n+      /* PR 21767: when moving insns above a conditional branch, the REG_EQUAL\n+\t notes being moved might become invalid.  */\n       insn = head;\n       do\n \t{\n@@ -4279,6 +4278,20 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t    remove_note (insn, note);\n \t} while (insn != end && (insn = NEXT_INSN (insn)));\n \n+      /* PR46315: when moving insns above a conditional branch, the REG_EQUAL\n+\t notes referring to the registers being set might become invalid.  */\n+      if (merge_set)\n+\t{\n+\t  unsigned i;\n+\t  bitmap_iterator bi;\n+\n+\t  EXECUTE_IF_SET_IN_BITMAP (merge_set_noclobber, 0, i, bi)\n+\t    remove_reg_equal_equiv_notes_for_regno (i);\n+\n+\t  BITMAP_FREE (merge_set);\n+\t  BITMAP_FREE (merge_set_noclobber);\n+\t}\n+\n       reorder_insns (head, end, PREV_INSN (earliest));\n     }\n \n@@ -4295,6 +4308,12 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \n  cancel:\n   cancel_changes (0);\n+ fail:\n+  if (merge_set)\n+    {\n+      BITMAP_FREE (merge_set);\n+      BITMAP_FREE (merge_set_noclobber);\n+    }\n   return FALSE;\n }\n \f"}, {"sha": "745d6f437ec51472c653ef294b37a42355e403f5", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=885c9b5d3a53c531fca622b4a3b0ef03df92daed", "patch": "@@ -1892,6 +1892,7 @@ extern rtx alloc_reg_note (enum reg_note, rtx, rtx);\n extern void add_reg_note (rtx, enum reg_note, rtx);\n extern void remove_note (rtx, const_rtx);\n extern void remove_reg_equal_equiv_notes (rtx);\n+extern void remove_reg_equal_equiv_notes_for_regno (unsigned int);\n extern int side_effects_p (const_rtx);\n extern int volatile_refs_p (const_rtx);\n extern int volatile_insn_p (const_rtx);"}, {"sha": "eb4d3ab9ad30dabcae39636963a6a117a1b2dd39", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=885c9b5d3a53c531fca622b4a3b0ef03df92daed", "patch": "@@ -1941,6 +1941,33 @@ remove_reg_equal_equiv_notes (rtx insn)\n     }\n }\n \n+/* Remove all REG_EQUAL and REG_EQUIV notes referring to REGNO.  */\n+\n+void\n+remove_reg_equal_equiv_notes_for_regno (unsigned int regno)\n+{\n+  df_ref eq_use;\n+\n+  if (!df)\n+    return;\n+\n+  /* This loop is a little tricky.  We cannot just go down the chain because\n+     it is being modified by some actions in the loop.  So we just iterate\n+     over the head.  We plan to drain the list anyway.  */\n+  while ((eq_use = DF_REG_EQ_USE_CHAIN (regno)) != NULL)\n+    {\n+      rtx insn = DF_REF_INSN (eq_use);\n+      rtx note = find_reg_equal_equiv_note (insn);\n+\n+      /* This assert is generally triggered when someone deletes a REG_EQUAL\n+\t or REG_EQUIV note by hacking the list manually rather than calling\n+\t remove_note.  */\n+      gcc_assert (note);\n+\n+      remove_note (insn, note);\n+    }\n+}\n+\n /* Search LISTP (an EXPR_LIST) for an entry whose first operand is NODE and\n    return 1 if it is found.  A simple equality test is used to determine if\n    NODE matches.  */"}, {"sha": "afb99ff8f853f9cec0ec736e6179b5277512daf9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=885c9b5d3a53c531fca622b4a3b0ef03df92daed", "patch": "@@ -1,3 +1,7 @@\n+2010-11-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/rx/pack.c: New test.\n+\n 2010-11-16  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \t    Tobias Burnus  <burnus@net-b.de>\n "}, {"sha": "2349284e2e9cf3ddfbf05f3c0490236a2b5299fb", "filename": "gcc/testsuite/gcc.dg/pr46315.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46315.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885c9b5d3a53c531fca622b4a3b0ef03df92daed/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46315.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46315.c?ref=885c9b5d3a53c531fca622b4a3b0ef03df92daed", "patch": "@@ -0,0 +1,37 @@\n+/* PR rtl-optimization/46315 */\n+/* Reported by Magnus Granberg <zorry@gentoo.org> */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-strict-overflow\" } */\n+\n+extern void abort (void);\n+\n+static char const *\n+parse_ranged (char const *s, int digits)\n+{\n+  int n = 0;\n+  char const *lim = s + digits;\n+  while (s < lim)\n+    {\n+      unsigned d = *s++ - '0';\n+      if (9 < d)\n+        return 0;\n+      n = 10 * n + d;\n+    }\n+  return s && 0 <= n && n <= 59 ? s : 0;\n+}\n+\n+int main(void)\n+{\n+  const char *s = \"10092240\";\n+\n+  s = parse_ranged (s, 2);\n+  s = parse_ranged (s, 2);\n+  s = parse_ranged (s, 2);\n+  s = parse_ranged (s, 2);\n+\n+  if (!s || *s != '\\0')\n+    abort();\n+\n+  return 0;\n+}"}]}