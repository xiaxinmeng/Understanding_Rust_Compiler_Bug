{"sha": "c64959bdf1388d332159cb5d40afddc30d8c61d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY0OTU5YmRmMTM4OGQzMzIxNTljYjVkNDBhZmRkYzMwZDhjNjFkMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-10-12T21:25:10Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-10-12T21:25:10Z"}, "message": "Fix spacing issue.\n\nFrom-SVN: r253696", "tree": {"sha": "94e83b60b12f89338d9dde60dc1cdf6f53f5c6c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94e83b60b12f89338d9dde60dc1cdf6f53f5c6c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c64959bdf1388d332159cb5d40afddc30d8c61d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c64959bdf1388d332159cb5d40afddc30d8c61d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c64959bdf1388d332159cb5d40afddc30d8c61d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c64959bdf1388d332159cb5d40afddc30d8c61d2/comments", "author": null, "committer": null, "parents": [{"sha": "912a7ec3b1f424ee8c6dce7965bd2f98df174dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/912a7ec3b1f424ee8c6dce7965bd2f98df174dea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/912a7ec3b1f424ee8c6dce7965bd2f98df174dea"}], "stats": {"total": 308, "additions": 156, "deletions": 152}, "files": [{"sha": "20fb303d03a574e80efa104c0363139eb0ef2014", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c64959bdf1388d332159cb5d40afddc30d8c61d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c64959bdf1388d332159cb5d40afddc30d8c61d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c64959bdf1388d332159cb5d40afddc30d8c61d2", "patch": "@@ -1,3 +1,7 @@\n+2017-10-12  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/amo.h: Fix spacing issue.\n+\n 2017-10-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/82498"}, {"sha": "d83e035da0593db47a82d187a0aff0cdea7d65a0", "filename": "gcc/config/rs6000/amo.h", "status": "modified", "additions": 152, "deletions": 152, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c64959bdf1388d332159cb5d40afddc30d8c61d2/gcc%2Fconfig%2Frs6000%2Famo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c64959bdf1388d332159cb5d40afddc30d8c61d2/gcc%2Fconfig%2Frs6000%2Famo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Famo.h?ref=c64959bdf1388d332159cb5d40afddc30d8c61d2", "patch": "@@ -1,152 +1,152 @@\n- /* Power ISA 3.0 atomic memory operation include file.\n-    Copyright (C) 2017 Free Software Foundation, Inc.\n-    Contributed by Michael Meissner <meissner@linux.vnet.ibm.com>.\n-\n-    This file is part of GCC.\n-\n-    GCC is free software; you can redistribute it and/or modify it\n-    under the terms of the GNU General Public License as published\n-    by the Free Software Foundation; either version 3, or (at your\n-    option) any later version.\n-\n-    GCC is distributed in the hope that it will be useful, but WITHOUT\n-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-    License for more details.\n-\n-    Under Section 7 of GPL version 3, you are granted additional\n-    permissions described in the GCC Runtime Library Exception, version\n-    3.1, as published by the Free Software Foundation.\n-\n-    You should have received a copy of the GNU General Public License and\n-    a copy of the GCC Runtime Library Exception along with this program;\n-    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-    <http://www.gnu.org/licenses/>.  */\n-\n- #ifndef _AMO_H\n- #define _AMO_H\n-\n- #if !defined(_ARCH_PWR9) || !defined(_ARCH_PPC64)\n- #error \"The atomic memory operations require Power 64-bit ISA 3.0\"\n-\n- #else\n- #include <stdint.h>\n-\n- /* Enumeration of the LWAT/LDAT sub-opcodes.  */\n- enum _AMO_LD {\n-   _AMO_LD_ADD\t\t= 0x00,\t\t/* Fetch and Add.  */\n-   _AMO_LD_XOR\t\t= 0x01,\t\t/* Fetch and Xor.  */\n-   _AMO_LD_IOR\t\t= 0x02,\t\t/* Fetch and Ior.  */\n-   _AMO_LD_AND\t\t= 0x03,\t\t/* Fetch and And.  */\n-   _AMO_LD_UMAX\t\t= 0x04,\t\t/* Fetch and Unsigned Maximum.  */\n-   _AMO_LD_SMAX\t\t= 0x05,\t\t/* Fetch and Signed Maximum.  */\n-   _AMO_LD_UMIN\t\t= 0x06,\t\t/* Fetch and Unsigned Minimum.  */\n-   _AMO_LD_SMIN\t\t= 0x07,\t\t/* Fetch and Signed Minimum.  */\n-   _AMO_LD_SWAP\t\t= 0x08,\t\t/* Swap.  */\n-   _AMO_LD_CS_NE\t\t= 0x10,\t\t/* Compare and Swap Not Equal.  */\n-   _AMO_LD_INC_BOUNDED\t= 0x18,\t\t/* Fetch and Increment Bounded.  */\n-   _AMO_LD_INC_EQUAL\t= 0x19,\t\t/* Fetch and Increment Equal.  */\n-   _AMO_LD_DEC_BOUNDED\t= 0x1A\t\t/* Fetch and Decrement Bounded.  */\n- };\n-\n- /* Implementation of the simple LWAT/LDAT operations that take one register and\n-    modify one word or double-word of memory and return the value that was\n-    previously in the memory location.\n-\n-    The LWAT/LDAT opcode requires the address to be a single register, and that\n-    points to a suitably aligned memory location.  Asm volatile is used to\n-    prevent the optimizer from moving the operation.  */\n-\n- #define _AMO_LD_SIMPLE(NAME, TYPE, OPCODE, FC)\t\t\t\t\\\n- static __inline__ TYPE\t\t\t\t\t\t\t\\\n- NAME (TYPE *_PTR, TYPE _VALUE)\t\t\t\t\t\t\\\n- {\t\t\t\t\t\t\t\t\t\\\n-   unsigned __int128 _TMP;\t\t\t\t\t\t\\\n-   TYPE _RET;\t\t\t\t\t\t\t\t\\\n-   __asm__ volatile (\"mr %L1,%3\\n\"\t\t\t\t\t\\\n- \t\t    \"\\t\" OPCODE \" %1,%P0,%4\\n\"\t\t\t\t\\\n- \t\t    \"\\tmr %2,%1\\n\"\t\t\t\t\t\\\n- \t\t    : \"+Q\" (_PTR[0]), \"=&r\" (_TMP), \"=r\" (_RET)\t\t\\\n- \t\t    : \"r\" (_VALUE), \"n\" (FC));\t\t\t\t\\\n-   return _RET;\t\t\t\t\t\t\t\t\\\n- }\n-\n- _AMO_LD_SIMPLE (amo_lwat_add,   uint32_t, \"lwat\", _AMO_LD_ADD)\n- _AMO_LD_SIMPLE (amo_lwat_xor,   uint32_t, \"lwat\", _AMO_LD_XOR)\n- _AMO_LD_SIMPLE (amo_lwat_ior,   uint32_t, \"lwat\", _AMO_LD_IOR)\n- _AMO_LD_SIMPLE (amo_lwat_and,   uint32_t, \"lwat\", _AMO_LD_AND)\n- _AMO_LD_SIMPLE (amo_lwat_umax,  uint32_t, \"lwat\", _AMO_LD_UMAX)\n- _AMO_LD_SIMPLE (amo_lwat_umin,  uint32_t, \"lwat\", _AMO_LD_UMIN)\n- _AMO_LD_SIMPLE (amo_lwat_swap,  uint32_t, \"lwat\", _AMO_LD_SWAP)\n-\n- _AMO_LD_SIMPLE (amo_lwat_sadd,  int32_t,  \"lwat\", _AMO_LD_ADD)\n- _AMO_LD_SIMPLE (amo_lwat_smax,  int32_t,  \"lwat\", _AMO_LD_SMAX)\n- _AMO_LD_SIMPLE (amo_lwat_smin,  int32_t,  \"lwat\", _AMO_LD_SMIN)\n- _AMO_LD_SIMPLE (amo_lwat_sswap, int32_t,  \"lwat\", _AMO_LD_SWAP)\n-\n- _AMO_LD_SIMPLE (amo_ldat_add,   uint64_t, \"ldat\", _AMO_LD_ADD)\n- _AMO_LD_SIMPLE (amo_ldat_xor,   uint64_t, \"ldat\", _AMO_LD_XOR)\n- _AMO_LD_SIMPLE (amo_ldat_ior,   uint64_t, \"ldat\", _AMO_LD_IOR)\n- _AMO_LD_SIMPLE (amo_ldat_and,   uint64_t, \"ldat\", _AMO_LD_AND)\n- _AMO_LD_SIMPLE (amo_ldat_umax,  uint64_t, \"ldat\", _AMO_LD_UMAX)\n- _AMO_LD_SIMPLE (amo_ldat_umin,  uint64_t, \"ldat\", _AMO_LD_UMIN)\n- _AMO_LD_SIMPLE (amo_ldat_swap,  uint64_t, \"ldat\", _AMO_LD_SWAP)\n-\n- _AMO_LD_SIMPLE (amo_ldat_sadd,  int64_t,  \"ldat\", _AMO_LD_ADD)\n- _AMO_LD_SIMPLE (amo_ldat_smax,  int64_t,  \"ldat\", _AMO_LD_SMAX)\n- _AMO_LD_SIMPLE (amo_ldat_smin,  int64_t,  \"ldat\", _AMO_LD_SMIN)\n- _AMO_LD_SIMPLE (amo_ldat_sswap, int64_t,  \"ldat\", _AMO_LD_SWAP)\n-\n- /* Enumeration of the STWAT/STDAT sub-opcodes.  */\n- enum _AMO_ST {\n-   _AMO_ST_ADD\t\t= 0x00,\t\t/* Store Add.  */\n-   _AMO_ST_XOR\t\t= 0x01,\t\t/* Store Xor.  */\n-   _AMO_ST_IOR\t\t= 0x02,\t\t/* Store Ior.  */\n-   _AMO_ST_AND\t\t= 0x03,\t\t/* Store And.  */\n-   _AMO_ST_UMAX\t\t= 0x04,\t\t/* Store Unsigned Maximum.  */\n-   _AMO_ST_SMAX\t\t= 0x05,\t\t/* Store Signed Maximum.  */\n-   _AMO_ST_UMIN\t\t= 0x06,\t\t/* Store Unsigned Minimum.  */\n-   _AMO_ST_SMIN\t\t= 0x07,\t\t/* Store Signed Minimum.  */\n-   _AMO_ST_TWIN\t\t= 0x18\t\t/* Store Twin.  */\n- };\n-\n- /* Implementation of the simple STWAT/STDAT operations that take one register\n-    and modify one word or double-word of memory.  No value is returned.\n-\n-    The STWAT/STDAT opcode requires the address to be a single register, and\n-    that points to a suitably aligned memory location.  Asm volatile is used to\n-    prevent the optimizer from moving the operation.  */\n-\n- #define _AMO_ST_SIMPLE(NAME, TYPE, OPCODE, FC)\t\t\t\t\\\n- static __inline__ void\t\t\t\t\t\t\t\\\n- NAME (TYPE *_PTR, TYPE _VALUE)\t\t\t\t\t\t\\\n- {\t\t\t\t\t\t\t\t\t\\\n-   __asm__ volatile (OPCODE \" %1,%P0,%2\"\t\t\t\t\t\\\n- \t\t    : \"+Q\" (_PTR[0])\t\t\t\t\t\\\n- \t\t    : \"r\" (_VALUE), \"n\" (FC));\t\t\t\t\\\n-   return;\t\t\t\t\t\t\t\t\\\n- }\n-\n- _AMO_ST_SIMPLE (amo_stwat_add,  uint32_t, \"stwat\", _AMO_ST_ADD)\n- _AMO_ST_SIMPLE (amo_stwat_xor,  uint32_t, \"stwat\", _AMO_ST_XOR)\n- _AMO_ST_SIMPLE (amo_stwat_ior,  uint32_t, \"stwat\", _AMO_ST_IOR)\n- _AMO_ST_SIMPLE (amo_stwat_and,  uint32_t, \"stwat\", _AMO_ST_AND)\n- _AMO_ST_SIMPLE (amo_stwat_umax, uint32_t, \"stwat\", _AMO_ST_UMAX)\n- _AMO_ST_SIMPLE (amo_stwat_umin, uint32_t, \"stwat\", _AMO_ST_UMIN)\n-\n- _AMO_ST_SIMPLE (amo_stwat_sadd, int32_t,  \"stwat\", _AMO_ST_ADD)\n- _AMO_ST_SIMPLE (amo_stwat_smax, int32_t,  \"stwat\", _AMO_ST_SMAX)\n- _AMO_ST_SIMPLE (amo_stwat_smin, int32_t,  \"stwat\", _AMO_ST_SMIN)\n-\n- _AMO_ST_SIMPLE (amo_stdat_add,  uint64_t, \"stdat\", _AMO_ST_ADD)\n- _AMO_ST_SIMPLE (amo_stdat_xor,  uint64_t, \"stdat\", _AMO_ST_XOR)\n- _AMO_ST_SIMPLE (amo_stdat_ior,  uint64_t, \"stdat\", _AMO_ST_IOR)\n- _AMO_ST_SIMPLE (amo_stdat_and,  uint64_t, \"stdat\", _AMO_ST_AND)\n- _AMO_ST_SIMPLE (amo_stdat_umax, uint64_t, \"stdat\", _AMO_ST_UMAX)\n- _AMO_ST_SIMPLE (amo_stdat_umin, uint64_t, \"stdat\", _AMO_ST_UMIN)\n-\n- _AMO_ST_SIMPLE (amo_stdat_sadd, int64_t,  \"stdat\", _AMO_ST_ADD)\n- _AMO_ST_SIMPLE (amo_stdat_smax, int64_t,  \"stdat\", _AMO_ST_SMAX)\n- _AMO_ST_SIMPLE (amo_stdat_smin, int64_t,  \"stdat\", _AMO_ST_SMIN)\n- #endif\t/* _ARCH_PWR9 && _ARCH_PPC64.  */\n- #endif\t/* _POWERPC_AMO_H.  */\n+/* Power ISA 3.0 atomic memory operation include file.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Michael Meissner <meissner@linux.vnet.ibm.com>.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _AMO_H\n+#define _AMO_H\n+\n+#if !defined(_ARCH_PWR9) || !defined(_ARCH_PPC64)\n+#error \"The atomic memory operations require Power 64-bit ISA 3.0\"\n+\n+#else\n+#include <stdint.h>\n+\n+/* Enumeration of the LWAT/LDAT sub-opcodes.  */\n+enum _AMO_LD {\n+  _AMO_LD_ADD\t\t= 0x00,\t\t/* Fetch and Add.  */\n+  _AMO_LD_XOR\t\t= 0x01,\t\t/* Fetch and Xor.  */\n+  _AMO_LD_IOR\t\t= 0x02,\t\t/* Fetch and Ior.  */\n+  _AMO_LD_AND\t\t= 0x03,\t\t/* Fetch and And.  */\n+  _AMO_LD_UMAX\t\t= 0x04,\t\t/* Fetch and Unsigned Maximum.  */\n+  _AMO_LD_SMAX\t\t= 0x05,\t\t/* Fetch and Signed Maximum.  */\n+  _AMO_LD_UMIN\t\t= 0x06,\t\t/* Fetch and Unsigned Minimum.  */\n+  _AMO_LD_SMIN\t\t= 0x07,\t\t/* Fetch and Signed Minimum.  */\n+  _AMO_LD_SWAP\t\t= 0x08,\t\t/* Swap.  */\n+  _AMO_LD_CS_NE\t\t= 0x10,\t\t/* Compare and Swap Not Equal.  */\n+  _AMO_LD_INC_BOUNDED\t= 0x18,\t\t/* Fetch and Increment Bounded.  */\n+  _AMO_LD_INC_EQUAL\t= 0x19,\t\t/* Fetch and Increment Equal.  */\n+  _AMO_LD_DEC_BOUNDED\t= 0x1A\t\t/* Fetch and Decrement Bounded.  */\n+};\n+\n+/* Implementation of the simple LWAT/LDAT operations that take one register and\n+   modify one word or double-word of memory and return the value that was\n+   previously in the memory location.\n+\n+   The LWAT/LDAT opcode requires the address to be a single register, and that\n+   points to a suitably aligned memory location.  Asm volatile is used to\n+   prevent the optimizer from moving the operation.  */\n+\n+#define _AMO_LD_SIMPLE(NAME, TYPE, OPCODE, FC)\t\t\t\t\\\n+static __inline__ TYPE\t\t\t\t\t\t\t\\\n+NAME (TYPE *_PTR, TYPE _VALUE)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  unsigned __int128 _TMP;\t\t\t\t\t\t\\\n+  TYPE _RET;\t\t\t\t\t\t\t\t\\\n+  __asm__ volatile (\"mr %L1,%3\\n\"\t\t\t\t\t\\\n+\t\t    \"\\t\" OPCODE \" %1,%P0,%4\\n\"\t\t\t\t\\\n+\t\t    \"\\tmr %2,%1\\n\"\t\t\t\t\t\\\n+\t\t    : \"+Q\" (_PTR[0]), \"=&r\" (_TMP), \"=r\" (_RET)\t\t\\\n+\t\t    : \"r\" (_VALUE), \"n\" (FC));\t\t\t\t\\\n+  return _RET;\t\t\t\t\t\t\t\t\\\n+}\n+\n+_AMO_LD_SIMPLE (amo_lwat_add,   uint32_t, \"lwat\", _AMO_LD_ADD)\n+_AMO_LD_SIMPLE (amo_lwat_xor,   uint32_t, \"lwat\", _AMO_LD_XOR)\n+_AMO_LD_SIMPLE (amo_lwat_ior,   uint32_t, \"lwat\", _AMO_LD_IOR)\n+_AMO_LD_SIMPLE (amo_lwat_and,   uint32_t, \"lwat\", _AMO_LD_AND)\n+_AMO_LD_SIMPLE (amo_lwat_umax,  uint32_t, \"lwat\", _AMO_LD_UMAX)\n+_AMO_LD_SIMPLE (amo_lwat_umin,  uint32_t, \"lwat\", _AMO_LD_UMIN)\n+_AMO_LD_SIMPLE (amo_lwat_swap,  uint32_t, \"lwat\", _AMO_LD_SWAP)\n+\n+_AMO_LD_SIMPLE (amo_lwat_sadd,  int32_t,  \"lwat\", _AMO_LD_ADD)\n+_AMO_LD_SIMPLE (amo_lwat_smax,  int32_t,  \"lwat\", _AMO_LD_SMAX)\n+_AMO_LD_SIMPLE (amo_lwat_smin,  int32_t,  \"lwat\", _AMO_LD_SMIN)\n+_AMO_LD_SIMPLE (amo_lwat_sswap, int32_t,  \"lwat\", _AMO_LD_SWAP)\n+\n+_AMO_LD_SIMPLE (amo_ldat_add,   uint64_t, \"ldat\", _AMO_LD_ADD)\n+_AMO_LD_SIMPLE (amo_ldat_xor,   uint64_t, \"ldat\", _AMO_LD_XOR)\n+_AMO_LD_SIMPLE (amo_ldat_ior,   uint64_t, \"ldat\", _AMO_LD_IOR)\n+_AMO_LD_SIMPLE (amo_ldat_and,   uint64_t, \"ldat\", _AMO_LD_AND)\n+_AMO_LD_SIMPLE (amo_ldat_umax,  uint64_t, \"ldat\", _AMO_LD_UMAX)\n+_AMO_LD_SIMPLE (amo_ldat_umin,  uint64_t, \"ldat\", _AMO_LD_UMIN)\n+_AMO_LD_SIMPLE (amo_ldat_swap,  uint64_t, \"ldat\", _AMO_LD_SWAP)\n+\n+_AMO_LD_SIMPLE (amo_ldat_sadd,  int64_t,  \"ldat\", _AMO_LD_ADD)\n+_AMO_LD_SIMPLE (amo_ldat_smax,  int64_t,  \"ldat\", _AMO_LD_SMAX)\n+_AMO_LD_SIMPLE (amo_ldat_smin,  int64_t,  \"ldat\", _AMO_LD_SMIN)\n+_AMO_LD_SIMPLE (amo_ldat_sswap, int64_t,  \"ldat\", _AMO_LD_SWAP)\n+\n+/* Enumeration of the STWAT/STDAT sub-opcodes.  */\n+enum _AMO_ST {\n+  _AMO_ST_ADD\t\t= 0x00,\t\t/* Store Add.  */\n+  _AMO_ST_XOR\t\t= 0x01,\t\t/* Store Xor.  */\n+  _AMO_ST_IOR\t\t= 0x02,\t\t/* Store Ior.  */\n+  _AMO_ST_AND\t\t= 0x03,\t\t/* Store And.  */\n+  _AMO_ST_UMAX\t\t= 0x04,\t\t/* Store Unsigned Maximum.  */\n+  _AMO_ST_SMAX\t\t= 0x05,\t\t/* Store Signed Maximum.  */\n+  _AMO_ST_UMIN\t\t= 0x06,\t\t/* Store Unsigned Minimum.  */\n+  _AMO_ST_SMIN\t\t= 0x07,\t\t/* Store Signed Minimum.  */\n+  _AMO_ST_TWIN\t\t= 0x18\t\t/* Store Twin.  */\n+};\n+\n+/* Implementation of the simple STWAT/STDAT operations that take one register\n+   and modify one word or double-word of memory.  No value is returned.\n+\n+   The STWAT/STDAT opcode requires the address to be a single register, and\n+   that points to a suitably aligned memory location.  Asm volatile is used to\n+   prevent the optimizer from moving the operation.  */\n+\n+#define _AMO_ST_SIMPLE(NAME, TYPE, OPCODE, FC)\t\t\t\t\\\n+static __inline__ void\t\t\t\t\t\t\t\\\n+NAME (TYPE *_PTR, TYPE _VALUE)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  __asm__ volatile (OPCODE \" %1,%P0,%2\"\t\t\t\t\t\\\n+\t\t    : \"+Q\" (_PTR[0])\t\t\t\t\t\\\n+\t\t    : \"r\" (_VALUE), \"n\" (FC));\t\t\t\t\\\n+  return;\t\t\t\t\t\t\t\t\\\n+}\n+\n+_AMO_ST_SIMPLE (amo_stwat_add,  uint32_t, \"stwat\", _AMO_ST_ADD)\n+_AMO_ST_SIMPLE (amo_stwat_xor,  uint32_t, \"stwat\", _AMO_ST_XOR)\n+_AMO_ST_SIMPLE (amo_stwat_ior,  uint32_t, \"stwat\", _AMO_ST_IOR)\n+_AMO_ST_SIMPLE (amo_stwat_and,  uint32_t, \"stwat\", _AMO_ST_AND)\n+_AMO_ST_SIMPLE (amo_stwat_umax, uint32_t, \"stwat\", _AMO_ST_UMAX)\n+_AMO_ST_SIMPLE (amo_stwat_umin, uint32_t, \"stwat\", _AMO_ST_UMIN)\n+\n+_AMO_ST_SIMPLE (amo_stwat_sadd, int32_t,  \"stwat\", _AMO_ST_ADD)\n+_AMO_ST_SIMPLE (amo_stwat_smax, int32_t,  \"stwat\", _AMO_ST_SMAX)\n+_AMO_ST_SIMPLE (amo_stwat_smin, int32_t,  \"stwat\", _AMO_ST_SMIN)\n+\n+_AMO_ST_SIMPLE (amo_stdat_add,  uint64_t, \"stdat\", _AMO_ST_ADD)\n+_AMO_ST_SIMPLE (amo_stdat_xor,  uint64_t, \"stdat\", _AMO_ST_XOR)\n+_AMO_ST_SIMPLE (amo_stdat_ior,  uint64_t, \"stdat\", _AMO_ST_IOR)\n+_AMO_ST_SIMPLE (amo_stdat_and,  uint64_t, \"stdat\", _AMO_ST_AND)\n+_AMO_ST_SIMPLE (amo_stdat_umax, uint64_t, \"stdat\", _AMO_ST_UMAX)\n+_AMO_ST_SIMPLE (amo_stdat_umin, uint64_t, \"stdat\", _AMO_ST_UMIN)\n+\n+_AMO_ST_SIMPLE (amo_stdat_sadd, int64_t,  \"stdat\", _AMO_ST_ADD)\n+_AMO_ST_SIMPLE (amo_stdat_smax, int64_t,  \"stdat\", _AMO_ST_SMAX)\n+_AMO_ST_SIMPLE (amo_stdat_smin, int64_t,  \"stdat\", _AMO_ST_SMIN)\n+#endif\t/* _ARCH_PWR9 && _ARCH_PPC64.  */\n+#endif\t/* _POWERPC_AMO_H.  */"}]}