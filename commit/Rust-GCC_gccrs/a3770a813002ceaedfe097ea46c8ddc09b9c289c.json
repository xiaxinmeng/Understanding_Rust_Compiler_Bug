{"sha": "a3770a813002ceaedfe097ea46c8ddc09b9c289c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM3NzBhODEzMDAyY2VhZWRmZTA5N2VhNDZjOGRkYzA5YjljMjg5Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-05T16:08:20Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-05T16:08:20Z"}, "message": "Makefile.in (ggc-simple.o): Depend on varray.h.\n\n\t* Makefile.in (ggc-simple.o): Depend on varray.h.\n\t(rtl.o): Depend on ggc.h.\n\t(genattrtab.o): Depend on ggc.h.\n\t(print-tree.o): Likewise.\n\t(fold-const.o): Likewise.\n\t* emit-rtl.c (sequence_element_free_list): Remove, and all references.\n\t(make_insn_raw): Don't cache insns when GC'ing.\n\t(emit_insn_before): Likewise.\n\t(emit_insn_after): Likewise.\n\t(emit_insn): Likewise.\n\t(start_sequence): Use xmalloc to allocate the sequence_stack.\n\t(end_sequence): Add free to free it.\n\t(gen_sequence): Don't cache insns when GC'ing.\n\t(clear_emit_caches): Don't use sequence_element_free_list.\n\t(init_emit): Use xcalloc, not xmalloc+bzero.\n\t* fold-const.c (size_int_wide): Kill the cache, when GC'ing.\n\t* function.c (pop_function_context_from): Use free to free the\n\tfixup_var_refs_queue.\n\t(put_reg_into_stack): Allocate it with xmalloc.\n\t* genattrtab.c: Include ggc.h.\n\t(operate_exp): Don't use obstack_free when GC'ing.\n\t(simplify_cond): Likewise.\n\t(simplify_text_exp): Likewise.\n\t(optimize_attrs): Likewise.\n\t* gengentrtl.c (gendef): Use ggc_alloc_rtx to allocate RTL, when\n\tGC'ing.\n\t(gencode): Generate a #include for ggc.h.\n\t* ggc-callbacks.c (ggc_p): Define it to zero.\n\t* ggc-none.c (ggc_p): Likewise.\n\t* ggc-simple.c: Include varray.h.\n\t(ggc_mark_tree_varray): New function.\n\t(ggc_add_tree_varray_root): Likewise.\n\t(ggc_mark_tree_varray_ptr): Likewise.\n\t* ggc.h (ggc_p): Declare.\n\t(varray_head_tag): Likewise.\n\t(ggc_add_tree_varray_root): Declare.\n\t* print-tree.c (print_node): Don't check for TREE_PERMANENT\n\tinconsistencies when GC'ing.\n\t* rtl.c: Include ggc.h.\n\t(rtvec_alloc): Use ggc_alloc_rtvec when GC'ing.\n\t(rtx_alloc): Use ggc_alloc_rtx when GC'ing.\n\t(rtx_free): Don't call obstack_free when GC'ing.\n\t* toplev.c (rest_of_compilation): Call ggc_collect after every\n\tpass, if GC'ing.\n\t* tree.c (push_obstacks): Do nothing, if GC'ing.\n\t(pop_obstacks_nochange): Likewise.\n\t(pop_obstacks): Likewise.\n\t(make_node): Use ggc_alloc_tree when GC'ing.\n\t(copy_node): Likewise.\n\t(get_identifier): Use ggc_alloc_string when GC'ing.\n\t(build_string): Likewise.\n\t(make_tree_vec): Use ggc_alloc_tree when GC'ing.\n\t(tree_cons): Likewise.\n\t(build1): Likewise.\n\t(type_hash_canon): Don't call obstack_free when GC'ing.\n\nCo-Authored-By: Bernd Schmidt <bernds@cygnus.co.uk>\nCo-Authored-By: Mark Mitchell <mark@codesourcery.com>\n\nFrom-SVN: r29125", "tree": {"sha": "53f583f3f8569b93ca268331c1f771e401b63045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53f583f3f8569b93ca268331c1f771e401b63045"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3770a813002ceaedfe097ea46c8ddc09b9c289c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3770a813002ceaedfe097ea46c8ddc09b9c289c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3770a813002ceaedfe097ea46c8ddc09b9c289c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3770a813002ceaedfe097ea46c8ddc09b9c289c/comments", "author": null, "committer": null, "parents": [{"sha": "616aeddaa175d5e70417df682d41ce8370bdeab2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/616aeddaa175d5e70417df682d41ce8370bdeab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/616aeddaa175d5e70417df682d41ce8370bdeab2"}], "stats": {"total": 515, "additions": 373, "deletions": 142}, "files": [{"sha": "6954e886c731fde6a4d7990b0f0577e315515854", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -1,3 +1,63 @@\n+Sun Sep  5 00:35:17 1999  Richard Henderson  <rth@cygnus.com>\n+\t                  Bernd Schmidt <bernds@cygnus.co.uk>\n+\t                  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Makefile.in (ggc-simple.o): Depend on varray.h.\n+\t(rtl.o): Depend on ggc.h.\n+\t(genattrtab.o): Depend on ggc.h.\n+\t(print-tree.o): Likewise.\n+\t(fold-const.o): Likewise.\n+\t* emit-rtl.c (sequence_element_free_list): Remove, and all references.\n+\t(make_insn_raw): Don't cache insns when GC'ing.\n+\t(emit_insn_before): Likewise.\n+\t(emit_insn_after): Likewise.\n+\t(emit_insn): Likewise.\n+\t(start_sequence): Use xmalloc to allocate the sequence_stack.\n+\t(end_sequence): Add free to free it.\n+\t(gen_sequence): Don't cache insns when GC'ing.\n+\t(clear_emit_caches): Don't use sequence_element_free_list.\n+\t(init_emit): Use xcalloc, not xmalloc+bzero.\n+\t* fold-const.c (size_int_wide): Kill the cache, when GC'ing.\n+\t* function.c (pop_function_context_from): Use free to free the\n+\tfixup_var_refs_queue.\n+\t(put_reg_into_stack): Allocate it with xmalloc.\n+\t* genattrtab.c: Include ggc.h.\n+\t(operate_exp): Don't use obstack_free when GC'ing.\n+\t(simplify_cond): Likewise.\n+\t(simplify_text_exp): Likewise.\n+\t(optimize_attrs): Likewise.\n+\t* gengentrtl.c (gendef): Use ggc_alloc_rtx to allocate RTL, when\n+\tGC'ing.\n+\t(gencode): Generate a #include for ggc.h.\n+\t* ggc-callbacks.c (ggc_p): Define it to zero.\n+\t* ggc-none.c (ggc_p): Likewise.\n+\t* ggc-simple.c: Include varray.h.\n+\t(ggc_mark_tree_varray): New function.\n+\t(ggc_add_tree_varray_root): Likewise.\n+\t(ggc_mark_tree_varray_ptr): Likewise.\n+\t* ggc.h (ggc_p): Declare.\n+\t(varray_head_tag): Likewise.\n+\t(ggc_add_tree_varray_root): Declare.\n+\t* print-tree.c (print_node): Don't check for TREE_PERMANENT\n+\tinconsistencies when GC'ing.\n+\t* rtl.c: Include ggc.h.\n+\t(rtvec_alloc): Use ggc_alloc_rtvec when GC'ing.\n+\t(rtx_alloc): Use ggc_alloc_rtx when GC'ing.\n+\t(rtx_free): Don't call obstack_free when GC'ing.\n+\t* toplev.c (rest_of_compilation): Call ggc_collect after every\n+\tpass, if GC'ing.\n+\t* tree.c (push_obstacks): Do nothing, if GC'ing.\n+\t(pop_obstacks_nochange): Likewise.\n+\t(pop_obstacks): Likewise.\n+\t(make_node): Use ggc_alloc_tree when GC'ing.\n+\t(copy_node): Likewise.\n+\t(get_identifier): Use ggc_alloc_string when GC'ing.\n+\t(build_string): Likewise.\n+\t(make_tree_vec): Use ggc_alloc_tree when GC'ing.\n+\t(tree_cons): Likewise.\n+\t(build1): Likewise.\n+\t(type_hash_canon): Don't call obstack_free when GC'ing.\n+\t\n Sat Sep  4 21:52:32 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* haifa-sched.c (schedule_block): Use next_nonnote_insn instead"}, {"sha": "d60242e8a9ae1c28cfa2d6cab8a0e6f31d43fc13", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -1432,7 +1432,8 @@ dumpvers: dumpvers.c\n \n version.o: version.c\n \n-ggc-simple.o: ggc-simple.c $(CONFIG_H) $(RTL_BASE_H) $(TREE_H) flags.h ggc.h\n+ggc-simple.o: ggc-simple.c $(CONFIG_H) $(RTL_BASE_H) $(TREE_H) flags.h \\\n+\tggc.h varray.h\n \n ggc-none.o: ggc-none.c $(CONFIG_H) $(RTL_BASE_H) ggc.h\n \n@@ -1452,11 +1453,11 @@ convert.o: convert.c $(CONFIG_H) $(TREE_H) flags.h convert.h toplev.h\n \n tree.o : tree.c $(CONFIG_H) system.h $(TREE_H) flags.h function.h toplev.h \\\n    ggc.h\n-print-tree.o : print-tree.c $(CONFIG_H) system.h $(TREE_H)\n+print-tree.o : print-tree.c $(CONFIG_H) system.h $(TREE_H) ggc.h\n stor-layout.o : stor-layout.c $(CONFIG_H) system.h $(TREE_H) flags.h \\\n    function.h $(EXPR_H) $(RTL_H) toplev.h ggc.h\n fold-const.o : fold-const.c $(CONFIG_H) system.h $(TREE_H) flags.h toplev.h \\\n-   $(RTL_H)\n+   $(RTL_H) ggc.h\n toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) function.h \\\n    flags.h input.h insn-attr.h xcoffout.h defaults.h output.h \\\n    insn-codes.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h dwarfout.h \\\n@@ -1466,7 +1467,7 @@ toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) function.h \\\n \t  -DTARGET_NAME=\\\"$(target_alias)\\\" \\\n \t  -c `echo $(srcdir)/toplev.c | sed 's,^\\./,,'`\n \n-rtl.o : rtl.c $(CONFIG_H) system.h $(RTL_H) bitmap.h\n+rtl.o : rtl.c $(CONFIG_H) system.h $(RTL_H) bitmap.h ggc.h\n \n print-rtl.o : print-rtl.c $(CONFIG_H) system.h $(RTL_H) bitmap.h basic-block.h\n rtlanal.o : rtlanal.c $(CONFIG_H) system.h $(RTL_H)\n@@ -1845,7 +1846,7 @@ genattrtab : genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_RTLANA\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n \t genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_RTLANAL) $(HOST_LIBS)\n \n-genattrtab.o : genattrtab.c $(RTL_H)  $(build_xm_file) system.h insn-config.h errors.h\n+genattrtab.o : genattrtab.c $(RTL_H)  $(build_xm_file) system.h insn-config.h errors.h ggc.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genattrtab.c\n \n genoutput : genoutput.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)"}, {"sha": "a87c5198ca0c71694ef58f26d12e744ffb87c282", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -158,21 +158,18 @@ struct rtx_def const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n /* start_sequence and gen_sequence can make a lot of rtx expressions which are\n    shortly thrown away.  We use two mechanisms to prevent this waste:\n \n-   First, we keep a list of the expressions used to represent the sequence\n-   stack in sequence_element_free_list.\n-\n-   Second, for sizes up to 5 elements, we keep a SEQUENCE and its associated\n-   rtvec for use by gen_sequence.  One entry for each size is sufficient\n-   because most cases are calls to gen_sequence followed by immediately\n-   emitting the SEQUENCE.  Reuse is safe since emitting a sequence is\n-   destructive on the insn in it anyway and hence can't be redone.\n+   For sizes up to 5 elements, we keep a SEQUENCE and its associated\n+   rtvec for use by gen_sequence.  One entry for each size is\n+   sufficient because most cases are calls to gen_sequence followed by\n+   immediately emitting the SEQUENCE.  Reuse is safe since emitting a\n+   sequence is destructive on the insn in it anyway and hence can't be\n+   redone.\n \n    We do not bother to save this cached data over nested function calls.\n    Instead, we just reinitialize them.  */\n \n #define SEQUENCE_RESULT_SIZE 5\n \n-static struct sequence_stack *sequence_element_free_list;\n static rtx sequence_result[SEQUENCE_RESULT_SIZE];\n \n /* During RTL generation, we also keep a list of free INSN rtl codes.  */\n@@ -2256,7 +2253,7 @@ make_insn_raw (pattern)\n   register rtx insn;\n \n   /* If in RTL generation phase, see if FREE_INSN can be used.  */\n-  if (free_insn != 0 && rtx_equal_function_value_matters)\n+  if (!ggc_p && free_insn != 0 && rtx_equal_function_value_matters)\n     {\n       insn = free_insn;\n       free_insn = NEXT_INSN (free_insn);\n@@ -2600,7 +2597,7 @@ emit_insn_before (pattern, before)\n \t  insn = XVECEXP (pattern, 0, i);\n \t  add_insn_before (insn, before);\n \t}\n-      if (XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n+      if (!ggc_p && XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n \tsequence_result[XVECLEN (pattern, 0)] = pattern;\n     }\n   else\n@@ -2720,7 +2717,7 @@ emit_insn_after (pattern, after)\n \t  add_insn_after (insn, after);\n \t  after = insn;\n \t}\n-      if (XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n+      if (!ggc_p && XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n \tsequence_result[XVECLEN (pattern, 0)] = pattern;\n     }\n   else\n@@ -2868,7 +2865,7 @@ emit_insn (pattern)\n \t  insn = XVECEXP (pattern, 0, i);\n \t  add_insn (insn);\n \t}\n-      if (XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n+      if (!ggc_p && XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n \tsequence_result[XVECLEN (pattern, 0)] = pattern;\n     }\n   else\n@@ -3188,14 +3185,7 @@ start_sequence ()\n {\n   struct sequence_stack *tem;\n \n-  if (sequence_element_free_list)\n-    {\n-      /* Reuse a previously-saved struct sequence_stack.  */\n-      tem = sequence_element_free_list;\n-      sequence_element_free_list = tem->next;\n-    }\n-  else\n-    tem = (struct sequence_stack *) permalloc (sizeof (struct sequence_stack));\n+  tem = (struct sequence_stack *) xmalloc (sizeof (struct sequence_stack));\n \n   tem->next = seq_stack;\n   tem->first = first_insn;\n@@ -3298,8 +3288,7 @@ end_sequence ()\n   seq_rtl_expr = tem->sequence_rtl_expr;\n   seq_stack = tem->next;\n \n-  tem->next = sequence_element_free_list;\n-  sequence_element_free_list = tem;\n+  free (tem);\n }\n \n /* Return 1 if currently emitting into a sequence.  */\n@@ -3340,14 +3329,18 @@ gen_sequence ()\n \t  || (GET_CODE (first_insn) == CALL_INSN\n \t      && CALL_INSN_FUNCTION_USAGE (first_insn) == NULL_RTX)))\n     {\n-      NEXT_INSN (first_insn) = free_insn;\n-      free_insn = first_insn;\n+      if (!ggc_p)\n+\t{\n+\t  NEXT_INSN (first_insn) = free_insn;\n+\t  free_insn = first_insn;\n+\t}\n       return PATTERN (first_insn);\n     }\n \n   /* Put them in a vector.  See if we already have a SEQUENCE of the\n      appropriate length around.  */\n-  if (len < SEQUENCE_RESULT_SIZE && (result = sequence_result[len]) != 0)\n+  if (!ggc_p && len < SEQUENCE_RESULT_SIZE \n+      && (result = sequence_result[len]) != 0)\n     sequence_result[len] = 0;\n   else\n     {\n@@ -3385,7 +3378,6 @@ clear_emit_caches ()\n   int i;\n \n   /* Clear the start_sequence/gen_sequence cache.  */\n-  sequence_element_free_list = 0;\n   for (i = 0; i < SEQUENCE_RESULT_SIZE; i++)\n     sequence_result[i] = 0;\n   free_insn = 0;\n@@ -3418,17 +3410,15 @@ init_emit ()\n   f->emit->regno_pointer_flag_length = LAST_VIRTUAL_REGISTER + 101;\n \n   f->emit->regno_pointer_flag \n-    = (char *) xmalloc (f->emit->regno_pointer_flag_length);\n-  bzero (f->emit->regno_pointer_flag, f->emit->regno_pointer_flag_length);\n+    = (char *) xcalloc (f->emit->regno_pointer_flag_length, sizeof (char));\n \n   f->emit->regno_pointer_align\n-    = (char *) xmalloc (f->emit->regno_pointer_flag_length);\n-  bzero (f->emit->regno_pointer_align, f->emit->regno_pointer_flag_length);\n+    = (char *) xcalloc (f->emit->regno_pointer_flag_length,\n+\t\t\tsizeof (char));\n \n   regno_reg_rtx \n-    = (rtx *) xmalloc (f->emit->regno_pointer_flag_length * sizeof (rtx));\n-  bzero ((char *) regno_reg_rtx,\n-\t f->emit->regno_pointer_flag_length * sizeof (rtx));\n+    = (rtx *) xcalloc (f->emit->regno_pointer_flag_length * sizeof (rtx),\n+\t\t       sizeof (rtx));\n \n   /* Put copies of all the virtual register rtx into regno_reg_rtx.  */\n   init_virtual_regs (f->emit);"}, {"sha": "f7dc9cb53e83e82e2949ced5638747383519e0ed", "filename": "gcc/fold-const.c", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -49,6 +49,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"toplev.h\"\n+#include \"ggc.h\"\n \n static void encode\t\tPROTO((HOST_WIDE_INT *,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT));\n@@ -1692,29 +1693,32 @@ size_int_wide (number, high, bit_p)\n      unsigned HOST_WIDE_INT number, high;\n      int bit_p;\n {\n-  register tree t;\n-  /* Type-size nodes already made for small sizes.  */\n-  static tree size_table[2*HOST_BITS_PER_WIDE_INT + 1][2];\n-\n-  if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && ! high\n-      && size_table[number][bit_p] != 0)\n-    return size_table[number][bit_p];\n-  if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && ! high)\n-    {\n-      push_obstacks_nochange ();\n-      /* Make this a permanent node.  */\n-      end_temporary_allocation ();\n-      t = build_int_2 (number, 0);\n-      TREE_TYPE (t) = bit_p ? bitsizetype : sizetype;\n-      size_table[number][bit_p] = t;\n-      pop_obstacks ();\n-    }\n-  else\n+  tree t;\n+  \n+  if (!ggc_p)\n     {\n-      t = build_int_2 (number, high);\n-      TREE_TYPE (t) = bit_p ? bitsizetype : sizetype;\n-      TREE_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (t) = force_fit_type (t, 0);\n+      /* Type-size nodes already made for small sizes.  */\n+      static tree size_table[2*HOST_BITS_PER_WIDE_INT + 1][2];\n+\n+      if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && ! high\n+\t  && size_table[number][bit_p] != 0)\n+\treturn size_table[number][bit_p];\n+      if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && ! high)\n+\t{\n+\t  push_obstacks_nochange ();\n+\t  /* Make this a permanent node.  */\n+\t  end_temporary_allocation ();\n+\t  t = build_int_2 (number, 0);\n+\t  TREE_TYPE (t) = bit_p ? bitsizetype : sizetype;\n+\t  size_table[number][bit_p] = t;\n+\t  pop_obstacks ();\n+\t  return t;\n+\t}\n     }\n+\n+  t = build_int_2 (number, high);\n+  TREE_TYPE (t) = bit_p ? bitsizetype : sizetype;\n+  TREE_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (t) = force_fit_type (t, 0);\n   return t;\n }\n "}, {"sha": "960b660eca9cbcf62c3868f80999b80b2a09375a", "filename": "gcc/function.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -350,6 +350,7 @@ pop_function_context_from (context)\n {\n   struct function *p = outer_function_chain;\n   struct var_refs_queue *queue;\n+  struct var_refs_queue *next;\n \n   current_function = p;\n   outer_function_chain = p->next;\n@@ -367,9 +368,14 @@ pop_function_context_from (context)\n \n   /* Finish doing put_var_into_stack for any of our variables\n      which became addressable during the nested function.  */\n-  for (queue = p->fixup_var_refs_queue; queue; queue = queue->next)\n-    fixup_var_refs (queue->modified, queue->promoted_mode,\n-\t\t    queue->unsignedp, 0);\n+  for (queue = p->fixup_var_refs_queue; queue; queue = next)\n+    {\n+      next = queue->next;\n+      fixup_var_refs (queue->modified, queue->promoted_mode,\n+\t\t      queue->unsignedp, 0);\n+      free (queue);\n+    }\n+  p->fixup_var_refs_queue = 0;\n \n   /* Reset variables that have known state during rtx generation.  */\n   rtx_equal_function_value_matters = 1;\n@@ -1337,20 +1343,13 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n     {\n       struct var_refs_queue *temp;\n \n-      /* Variable is inherited; fix it up when we get back to its function.  */\n-      push_obstacks (function->function_obstack,\n-\t\t     function->function_maybepermanent_obstack);\n-\n-      /* See comment in restore_tree_status in tree.c for why this needs to be\n-\t on saveable obstack.  */\n       temp\n-\t= (struct var_refs_queue *) savealloc (sizeof (struct var_refs_queue));\n+\t= (struct var_refs_queue *) xmalloc (sizeof (struct var_refs_queue));\n       temp->modified = reg;\n       temp->promoted_mode = promoted_mode;\n       temp->unsignedp = TREE_UNSIGNED (type);\n       temp->next = function->fixup_var_refs_queue;\n       function->fixup_var_refs_queue = temp;\n-      pop_obstacks ();\n     }\n   else if (used_p)\n     /* Variable is local; fix it up now.  */"}, {"sha": "254f78c2459821cbd29f3ca57f15a97bad09e81a", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -99,6 +99,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"insn-config.h\"\t/* For REGISTER_CONSTRAINTS */\n+#include \"ggc.h\"\n \n #ifdef HAVE_SYS_RESOURCE_H\n # include <sys/resource.h>\n@@ -1726,15 +1727,17 @@ operate_exp (op, left, right)\n \t     give the same value), optimize it away.  */\n \t  if (allsame)\n \t    {\n-\t      obstack_free (rtl_obstack, newexp);\n+\t      if (!ggc_p)\n+\t\tobstack_free (rtl_obstack, newexp);\n \t      return operate_exp (op, left, XEXP (right, 1));\n \t    }\n \n \t  /* If the result is the same as the RIGHT operand,\n \t     just use that.  */\n \t  if (rtx_equal_p (newexp, right))\n \t    {\n-\t      obstack_free (rtl_obstack, newexp);\n+\t      if (!ggc_p)\n+\t\tobstack_free (rtl_obstack, newexp);\n \t      return right;\n \t    }\n \n@@ -1783,15 +1786,17 @@ operate_exp (op, left, right)\n \t optimize it away.  */\n       if (allsame)\n \t{\n-\t  obstack_free (rtl_obstack, newexp);\n+\t  if (!ggc_p)\n+\t    obstack_free (rtl_obstack, newexp);\n \t  return operate_exp (op, XEXP (left, 1), right);\n \t}\n \n       /* If the result is the same as the LEFT operand,\n \t just use that.  */\n       if (rtx_equal_p (newexp, left))\n \t{\n-\t  obstack_free (rtl_obstack, newexp);\n+\t  if (!ggc_p)\n+\t    obstack_free (rtl_obstack, newexp);\n \t  return left;\n \t}\n \n@@ -2609,14 +2614,16 @@ simplify_cond (exp, insn_code, insn_index)\n \n   if (len == 0)\n     {\n-      obstack_free (rtl_obstack, first_spacer);\n+      if (!ggc_p)\n+\tobstack_free (rtl_obstack, first_spacer);\n       if (GET_CODE (defval) == COND)\n \treturn simplify_cond (defval, insn_code, insn_index);\n       return defval;\n     }\n   else if (allsame)\n     {\n-      obstack_free (rtl_obstack, first_spacer);\n+      if (!ggc_p)\n+\tobstack_free (rtl_obstack, first_spacer);\n       return exp;\n     }\n   else\n@@ -3146,14 +3153,16 @@ simplify_test_exp (exp, insn_code, insn_index)\n       SIMPLIFY_ALTERNATIVE (left);\n       if (left == false_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n+\t  if (!ggc_p)\n+\t    obstack_free (rtl_obstack, spacer);\n \t  return false_rtx;\n \t}\n       right = SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n       SIMPLIFY_ALTERNATIVE (right);\n       if (left == false_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n+\t  if (!ggc_p)\n+\t    obstack_free (rtl_obstack, spacer);\n \t  return false_rtx;\n \t}\n \n@@ -3185,7 +3194,8 @@ simplify_test_exp (exp, insn_code, insn_index)\n \n       if (left == false_rtx || right == false_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n+\t  if (!ggc_p)\n+\t    obstack_free (rtl_obstack, spacer);\n \t  return false_rtx;\n \t}\n       else if (left == true_rtx)\n@@ -3244,14 +3254,16 @@ simplify_test_exp (exp, insn_code, insn_index)\n       SIMPLIFY_ALTERNATIVE (left);\n       if (left == true_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n+\t  if (!ggc_p)\n+\t    obstack_free (rtl_obstack, spacer);\n \t  return true_rtx;\n \t}\n       right = SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n       SIMPLIFY_ALTERNATIVE (right);\n       if (right == true_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n+\t  if (!ggc_p)\n+\t    obstack_free (rtl_obstack, spacer);\n \t  return true_rtx;\n \t}\n \n@@ -3261,7 +3273,8 @@ simplify_test_exp (exp, insn_code, insn_index)\n \n       if (right == true_rtx || left == true_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n+\t  if (!ggc_p)\n+\t    obstack_free (rtl_obstack, spacer);\n \t  return true_rtx;\n \t}\n       else if (left == false_rtx)\n@@ -3348,12 +3361,14 @@ simplify_test_exp (exp, insn_code, insn_index)\n \n       if (left == false_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n+\t  if (!ggc_p)\n+\t    obstack_free (rtl_obstack, spacer);\n \t  return true_rtx;\n \t}\n       else if (left == true_rtx)\n \t{\n-\t  obstack_free (rtl_obstack, spacer);\n+\t  if (!ggc_p)\n+\t    obstack_free (rtl_obstack, spacer);\n \t  return false_rtx;\n \t}\n \n@@ -3515,7 +3530,8 @@ optimize_attrs ()\n \t\t  insert_insn_ent (av, ie);\n \t\t  something_changed = 1;\n \t\t}\n-\t      obstack_free (temp_obstack, spacer);\n+\t      if (!ggc_p)\n+\t\tobstack_free (temp_obstack, spacer);\n \t    }\n \t}\n     }"}, {"sha": "797c3de47cafd241999dc61078bf407e1c14a738", "filename": "gcc/ggc-callbacks.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fggc-callbacks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fggc-callbacks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-callbacks.c?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -24,6 +24,8 @@\n #include \"tree.h\"\n #include \"ggc.h\"\n \n+int ggc_p = 0;\n+\n void \n lang_mark_tree (t)\n      union tree_node *t ATTRIBUTE_UNUSED;"}, {"sha": "0953059a41cb697e18ebf73fc8d047a76716ec3b", "filename": "gcc/ggc-none.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -31,6 +31,9 @@\n #include \"rtl.h\"\n #include \"ggc.h\"\n \n+/* For now, keep using the old obstack scheme in the gen* programs.  */\n+int ggc_p = 0;\n+\n rtx\n ggc_alloc_rtx (nslots)\n      int nslots;"}, {"sha": "0e7b53fc18570c32c15530c8d778697958f1395f", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -24,6 +24,7 @@\n #include \"tree.h\"\n #include \"ggc.h\"\n #include \"flags.h\"\n+#include \"varray.h\"\n \n /* Debugging flags.  */\n #undef GGC_DUMP\n@@ -96,6 +97,7 @@ static void ggc_free_rtx PROTO ((struct ggc_rtx *r));\n static void ggc_free_tree PROTO ((struct ggc_tree *t));\n static void ggc_mark_rtx_ptr PROTO ((void *elt));\n static void ggc_mark_tree_ptr PROTO ((void *elt));\n+static void ggc_mark_tree_varray_ptr PROTO ((void *elt));\n \n /* These allocators are dreadfully simple, with no caching whatsoever so\n    that Purify-like tools that do allocation versioning can catch errors.\n@@ -472,6 +474,18 @@ ggc_mark_tree (t)\n     }\n }\n \n+/* Mark all the elements of the varray V, which contains trees.  */\n+\n+void\n+ggc_mark_tree_varray (v)\n+     varray_type v;\n+{\n+  int i;\n+\n+  for (i = v->num_elements - 1; i >= 0; --i) \n+    ggc_mark_tree (VARRAY_TREE (v, i));\n+}\n+\n void\n ggc_mark_string (s)\n      char *s;\n@@ -645,6 +659,17 @@ ggc_add_tree_root (base, nelt)\n   ggc_add_root (base, nelt, sizeof(tree), ggc_mark_tree_ptr);\n }\n \n+/* Add vV (a varray full of trees) to the list of GC roots.  */\n+\n+void\n+ggc_add_tree_varray_root (base, nelt)\n+     varray_type *base;\n+     int nelt;\n+{\n+  ggc_add_root (base, nelt, sizeof (varray_type), \n+\t\tggc_mark_tree_varray_ptr);\n+}\n+\n void\n ggc_del_root (base)\n      void *base;\n@@ -681,6 +706,16 @@ ggc_mark_tree_ptr (elt)\n   ggc_mark_tree (*(tree *)elt);\n }\n \n+/* Type-correct function to pass to ggc_add_root.  It just forwards\n+   ELT (which is really a varray_type *) to ggc_mark_tree_varray.  */\n+\n+static void\n+ggc_mark_tree_varray_ptr (elt)\n+     void *elt;\n+{\n+  ggc_mark_tree_varray (*(varray_type *)elt);\n+}\n+\n #ifdef GGC_DUMP\n /* Don't enable this unless you want a really really lot of data.  */\n static void __attribute__((constructor))"}, {"sha": "557ee064d791c7f1804107857860c5a8d4f20b71", "filename": "gcc/ggc.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -23,6 +23,10 @@\n /* Symbols are marked with `ggc' for `gcc gc' so as not to interfere with\n    an external gc library that might be linked in.  */\n \n+/* Language-specific code defines this variable to be either one (if\n+   it wants garbage collection), or zero (if it does not).  */\n+extern int ggc_p;\n+\n /* These structures are defined in various headers throughout the\n    compiler.  However, rather than force everyone who includes this\n    header to include all the headers in which they are declared, we\n@@ -32,6 +36,7 @@ struct eh_status;\n struct emit_status;\n struct stmt_status;\n struct varasm_status;\n+struct varray_head_tag;\n \n /* Startup */\n \n@@ -54,6 +59,7 @@ void ggc_add_root PROTO ((void *base, int nelt, int size,\n \t\t\t   void (*)(void *)));\n void ggc_add_rtx_root PROTO ((struct rtx_def **, int nelt));\n void ggc_add_tree_root PROTO ((union tree_node **, int nelt));\n+void ggc_add_tree_varray_root PROTO ((struct varray_head_tag **, int nelt));\n void ggc_del_root PROTO ((void *base));\n \n /* Mark nodes from the gc_add_root callback.  */"}, {"sha": "81219e77de33a62309ef6fa31685708304645e12", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -22,6 +22,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n+#include \"ggc.h\"\n \n void print_node ();\n void indent_to ();\n@@ -274,7 +275,7 @@ print_node (file, prefix, node, indent)\n     }\n \n   /* If a permanent object is in the wrong obstack, or the reverse, warn.  */\n-  if (object_permanent_p (node) != TREE_PERMANENT (node))\n+  if (!ggc_p && object_permanent_p (node) != TREE_PERMANENT (node))\n     {\n       if (TREE_PERMANENT (node))\n \tfputs (\" !!permanent object in non-permanent obstack!!\", file);"}, {"sha": "db28096ac65b7e087c45ade47a8c576f8dd35c24", "filename": "gcc/rtl.c", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -24,7 +24,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"real.h\"\n #include \"bitmap.h\"\n-\n+#include \"ggc.h\"\n #include \"obstack.h\"\n #define\tobstack_chunk_alloc\txmalloc\n #define\tobstack_chunk_free\tfree\n@@ -244,18 +244,23 @@ rtvec_alloc (n)\n      int n;\n {\n   rtvec rt;\n-  int i;\n-\n-  rt = (rtvec) obstack_alloc (rtl_obstack,\n-\t\t\t      sizeof (struct rtvec_def)\n-\t\t\t      + (( n - 1) * sizeof (rtx)));\n+ \n+  if (ggc_p)\n+    rt = ggc_alloc_rtvec (n);\n+  else\n+    {\n+      int i;\n \n-  /* clear out the vector */\n-  PUT_NUM_ELEM (rt, n);\n+      rt = (rtvec) obstack_alloc (rtl_obstack,\n+\t\t\t\t  sizeof (struct rtvec_def)\n+\t\t\t\t  + (( n - 1) * sizeof (rtx)));\n \n-  for (i = 0; i < n; i++)\n-    rt->elem[i] = 0;\n+      /* clear out the vector */\n+      for (i = 0; i < n; i++)\n+\trt->elem[i] = 0;\n+    }\n \n+  PUT_NUM_ELEM (rt, n);\n   return rt;\n }\n \n@@ -267,34 +272,40 @@ rtx_alloc (code)\n   RTX_CODE code;\n {\n   rtx rt;\n-  register struct obstack *ob = rtl_obstack;\n-  register int nelts = GET_RTX_LENGTH (code);\n-  register int length = sizeof (struct rtx_def)\n-    + (nelts - 1) * sizeof (rtunion);\n-\n-  /* This function is called more than any other in GCC,\n-     so we manipulate the obstack directly.\n \n-     Even though rtx objects are word aligned, we may be sharing an obstack\n-     with tree nodes, which may have to be double-word aligned.  So align\n-     our length to the alignment mask in the obstack.  */\n-\n-  length = (length + ob->alignment_mask) & ~ ob->alignment_mask;\n-\n-  if (ob->chunk_limit - ob->next_free < length)\n-    _obstack_newchunk (ob, length);\n-  rt = (rtx)ob->object_base;\n-  ob->next_free += length;\n-  ob->object_base = ob->next_free;\n-\n-  /* We want to clear everything up to the FLD array.  Normally, this is\n-     one int, but we don't want to assume that and it isn't very portable\n-     anyway; this is.  */\n-\n-  memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));\n+  if (ggc_p)\n+    rt = ggc_alloc_rtx (GET_RTX_LENGTH (code));\n+  else\n+    {\n+      register struct obstack *ob = rtl_obstack;\n+      register int nelts = GET_RTX_LENGTH (code);\n+      register int length = sizeof (struct rtx_def)\n+\t+ (nelts - 1) * sizeof (rtunion);\n+\n+      /* This function is called more than any other in GCC, so we\n+\t manipulate the obstack directly.\n+       \n+\t Even though rtx objects are word aligned, we may be sharing\n+\t an obstack with tree nodes, which may have to be double-word\n+\t aligned.  So align our length to the alignment mask in the\n+\t obstack.  */\n+\n+      length = (length + ob->alignment_mask) & ~ ob->alignment_mask;\n+\n+      if (ob->chunk_limit - ob->next_free < length)\n+\t_obstack_newchunk (ob, length);\n+      rt = (rtx)ob->object_base;\n+      ob->next_free += length;\n+      ob->object_base = ob->next_free;\n+\n+      /* We want to clear everything up to the FLD array.  Normally,\n+\t this is one int, but we don't want to assume that and it\n+\t isn't very portable anyway; this is.  */\n+\n+      memset (rt, 0, sizeof (struct rtx_def) - sizeof (rtunion));\n+    }\n \n   PUT_CODE (rt, code);\n-\n   return rt;\n }\n \n@@ -304,7 +315,8 @@ void\n rtx_free (x)\n      rtx x;\n {\n-  obstack_free (rtl_obstack, x);\n+  if (!ggc_p)\n+    obstack_free (rtl_obstack, x);\n }\n \f\n /* Create a new copy of an rtx."}, {"sha": "ca95121e62de311eff3ed6fe100c55837dff86a0", "filename": "gcc/toplev.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -3801,6 +3801,9 @@ rest_of_compilation (decl)\n   if (jump_opt_dump)\n     dump_rtl (\".jump\", decl, print_rtl, insns);\n \n+  if (ggc_p)\n+    ggc_collect ();\n+\n   /* Perform common subexpression elimination.\n      Nonzero value from `cse_main' means that jumps were simplified\n      and some code may now be unreachable, so do\n@@ -3846,6 +3849,9 @@ rest_of_compilation (decl)\n \tprint_rtl_graph_with_bb (dump_base_name, \".addressof\", insns);\n     }\n \n+  if (ggc_p)\n+    ggc_collect ();\n+\n   /* Perform global cse.  */\n \n   if (optimize > 0 && flag_gcse)\n@@ -3870,6 +3876,9 @@ rest_of_compilation (decl)\n \t  if (graph_dump_format != no_graph)\n \t    print_rtl_graph_with_bb (dump_base_name, \".gcse\", insns);\n \t}\n+\n+      if (ggc_p)\n+\tggc_collect ();\n     }\n   /* Move constant computations out of loops.  */\n \n@@ -3909,6 +3918,9 @@ rest_of_compilation (decl)\n \t  if (graph_dump_format != no_graph)\n \t    print_rtl_graph_with_bb (dump_base_name, \".loop\", insns);\n \t}\n+\n+      if (ggc_p)\n+\tggc_collect ();\n     }\n \n   if (optimize > 0)\n@@ -3953,6 +3965,9 @@ rest_of_compilation (decl)\n \t  if (graph_dump_format != no_graph)\n \t    print_rtl_graph_with_bb (dump_base_name, \".cse2\", insns);\n \t}\n+\n+      if (ggc_p)\n+\tggc_collect ();\n     }\n \n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n@@ -3972,6 +3987,9 @@ rest_of_compilation (decl)\n \t  if (graph_dump_format != no_graph)\n \t    print_rtl_graph_with_bb (dump_base_name, \".bp\", insns);\n \t}\n+\n+      if (ggc_p)\n+\tggc_collect ();\n     }\n \n   /* We are no longer anticipating cse in this function, at least.  */\n@@ -4030,6 +4048,9 @@ rest_of_compilation (decl)\n \tprint_rtl_graph_with_bb (dump_base_name, \".flow\", insns);\n     }\n \n+  if (ggc_p)\n+    ggc_collect ();\n+\n   /* The first life analysis pass has finished.  From now on we can not\n      generate any new pseudos.  */\n   no_new_pseudos = 1;\n@@ -4048,6 +4069,9 @@ rest_of_compilation (decl)\n \t  if (graph_dump_format != no_graph)\n \t    print_rtl_graph_with_bb (dump_base_name, \".combine\", insns);\n \t}\n+\n+      if (ggc_p)\n+\tggc_collect ();\n     }\n \n   /* Register allocation pre-pass, to reduce number of moves\n@@ -4066,6 +4090,9 @@ rest_of_compilation (decl)\n \t  if (graph_dump_format != no_graph)\n \t    print_rtl_graph_with_bb (dump_base_name, \".regmove\", insns);\n \t}\n+\n+      if (ggc_p)\n+\tggc_collect ();\n     }\n \n   /* Print function header into sched dump now\n@@ -4089,6 +4116,9 @@ rest_of_compilation (decl)\n \t  if (graph_dump_format != no_graph)\n \t    print_rtl_graph_with_bb (dump_base_name, \".sched\", insns);\n \t}\n+\n+      if (ggc_p)\n+\tggc_collect ();\n     }\n \n   /* Determine if the current function is a leaf before running reload\n@@ -4126,6 +4156,9 @@ rest_of_compilation (decl)\n \tprint_rtl_graph_with_bb (dump_base_name, \".lreg\", insns);\n     }\n \n+  if (ggc_p)\n+    ggc_collect ();\n+\n   if (global_reg_dump)\n     open_dump_file (\".greg\", decl_printable_name (decl, 2));\n \n@@ -4145,6 +4178,9 @@ rest_of_compilation (decl)\n   if (failure)\n     goto exit_rest_of_compilation;\n \n+  if (ggc_p)\n+    ggc_collect ();\n+\n   /* Do a very simple CSE pass over just the hard registers.  */\n   if (optimize > 0)\n     reload_cse_regs (insns);\n@@ -4203,6 +4239,9 @@ rest_of_compilation (decl)\n \t   find_basic_blocks (insns, max_reg_num (), rtl_dump_file, 1);\n \t   life_analysis (insns, max_reg_num (), rtl_dump_file, 1);\n \t });\n+\n+      if (ggc_p)\n+\tggc_collect ();\n     }\n \n   flow2_completed = 1;\n@@ -4256,6 +4295,9 @@ rest_of_compilation (decl)\n \t  if (graph_dump_format != no_graph)\n \t    print_rtl_graph_with_bb (dump_base_name, \".sched2\", insns);\n \t}\n+\n+      if (ggc_p)\n+\tggc_collect ();\n     }\n \n #ifdef LEAF_REGISTERS\n@@ -4297,6 +4339,9 @@ rest_of_compilation (decl)\n        if (graph_dump_format != no_graph)\n \t print_rtl_graph_with_bb (dump_base_name, \".mach\", insns);\n      }\n+\n+   if (ggc_p)\n+     ggc_collect ();\n #endif\n \n   /* If a scheduling pass for delayed branches is to be done,\n@@ -4317,6 +4362,9 @@ rest_of_compilation (decl)\n \t    print_rtl_graph_with_bb (dump_base_name, \".dbr\", insns);\n \t}\n     }\n+\n+   if (ggc_p)\n+     ggc_collect ();\n #endif\n \n   /* Shorten branches.  */\n@@ -4337,6 +4385,9 @@ rest_of_compilation (decl)\n       if (graph_dump_format != no_graph)\n \tprint_rtl_graph_with_bb (dump_base_name, \".stack\", insns);\n     }\n+\n+   if (ggc_p)\n+     ggc_collect ();\n #endif\n \n   /* Now turn the rtl into assembler code.  */\n@@ -4373,6 +4424,9 @@ rest_of_compilation (decl)\n \t     regset_release_memory ();\n \t   });\n \n+   if (ggc_p)\n+     ggc_collect ();\n+\n   /* Write DBX symbols if requested */\n \n   /* Note that for those inline functions where we don't initially\n@@ -4458,6 +4512,10 @@ rest_of_compilation (decl)\n   if (! DECL_DEFER_OUTPUT (decl))\n     free_after_compilation (current_function);\n \n+  current_function = 0;\n+\n+  ggc_collect ();\n+\n   /* The parsing time is all the time spent in yyparse\n      *except* what is spent in this function.  */\n "}, {"sha": "03fc790d2b41c60b206b01865b68e83f154ce2be", "filename": "gcc/tree.c", "status": "modified", "additions": 63, "deletions": 19, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3770a813002ceaedfe097ea46c8ddc09b9c289c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a3770a813002ceaedfe097ea46c8ddc09b9c289c", "patch": "@@ -474,8 +474,12 @@ void\n push_obstacks (current, saveable)\n      struct obstack *current, *saveable;\n {\n-  struct obstack_stack *p\n-    = (struct obstack_stack *) obstack_alloc (&obstack_stack_obstack,\n+  struct obstack_stack *p;\n+\n+  if (ggc_p)\n+    return;\n+\n+  p = (struct obstack_stack *) obstack_alloc (&obstack_stack_obstack,\n \t\t\t\t\t      (sizeof (struct obstack_stack)));\n \n   p->current = current_obstack;\n@@ -495,8 +499,12 @@ push_obstacks (current, saveable)\n void\n push_obstacks_nochange ()\n {\n-  struct obstack_stack *p\n-    = (struct obstack_stack *) obstack_alloc (&obstack_stack_obstack,\n+  struct obstack_stack *p;\n+  \n+  if (ggc_p)\n+    return;\n+\n+  p = (struct obstack_stack *) obstack_alloc (&obstack_stack_obstack,\n \t\t\t\t\t      (sizeof (struct obstack_stack)));\n \n   p->current = current_obstack;\n@@ -512,7 +520,12 @@ push_obstacks_nochange ()\n void\n pop_obstacks ()\n {\n-  struct obstack_stack *p = obstack_stack;\n+  struct obstack_stack *p;\n+\n+  if (ggc_p)\n+    return;\n+\n+  p = obstack_stack;\n   obstack_stack = p->next;\n \n   current_obstack = p->current;\n@@ -1005,8 +1018,13 @@ make_node (code)\n       abort ();\n     }\n \n-  t = (tree) obstack_alloc (obstack, length);\n-  bzero ((PTR) t, length);\n+  if (ggc_p)\n+    t = ggc_alloc_tree (length);\n+  else\n+    {\n+      t = (tree) obstack_alloc (obstack, length);\n+      bzero ((PTR) t, length);\n+    }\n \n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int)kind]++;\n@@ -1119,8 +1137,13 @@ copy_node (node)\n \tlength += (TREE_VEC_LENGTH (node) - 1) * sizeof (char *);\n     }\n \n-  t = (tree) obstack_alloc (current_obstack, length);\n-  memcpy (t, node, length);\n+  if (ggc_p)\n+    t = ggc_alloc_tree (length);\n+  else\n+    {\n+      t = (tree) obstack_alloc (current_obstack, length);\n+      memcpy (t, node, length);\n+    }\n \n   /* EXPR_WITH_FILE_LOCATION must keep filename info stored in TREE_CHAIN */\n   if (TREE_CODE (node) != EXPR_WITH_FILE_LOCATION)\n@@ -1230,7 +1253,10 @@ get_identifier (text)\n   id_string_size += len;\n #endif\n \n-  IDENTIFIER_POINTER (idp) = obstack_copy0 (&permanent_obstack, text, len);\n+  if (ggc_p)\n+    IDENTIFIER_POINTER (idp) = ggc_alloc_string (text, len);\n+  else\n+    IDENTIFIER_POINTER (idp) = obstack_copy0 (&permanent_obstack, text, len);\n \n   TREE_CHAIN (idp) = hash_table[hi];\n   hash_table[hi] = idp;\n@@ -1469,7 +1495,10 @@ build_string (len, str)\n \n   register tree s = make_node (STRING_CST);\n   TREE_STRING_LENGTH (s) = len;\n-  TREE_STRING_POINTER (s) = obstack_copy0 (saveable_obstack, str, len);\n+  if (ggc_p)\n+    TREE_STRING_POINTER (s) = ggc_alloc_string (str, len);\n+  else\n+    TREE_STRING_POINTER (s) = obstack_copy0 (saveable_obstack, str, len);\n   return s;\n }\n \n@@ -1509,8 +1538,13 @@ make_tree_vec (len)\n   tree_node_sizes[(int)vec_kind] += length;\n #endif\n \n-  t = (tree) obstack_alloc (obstack, length);\n-  bzero ((PTR) t, length);\n+  if (ggc_p)\n+    t = ggc_alloc_tree (length);\n+  else\n+    {\n+      t = (tree) obstack_alloc (obstack, length);\n+      bzero ((PTR) t, length);\n+    }\n \n   TREE_SET_CODE (t, TREE_VEC);\n   TREE_VEC_LENGTH (t) = len;\n@@ -2011,15 +2045,21 @@ tree_cons (purpose, value, chain)\n #if 0\n   register tree node = make_node (TREE_LIST);\n #else\n-  register int i;\n-  register tree node = (tree) obstack_alloc (current_obstack, sizeof (struct tree_list));\n+  register tree node;\n+\n+  if (ggc_p)\n+    node = ggc_alloc_tree (sizeof (struct tree_list));\n+  else\n+    {\n+      node = (tree) obstack_alloc (current_obstack, sizeof (struct tree_list));\n+      bzero (node, sizeof (struct tree_common));\n+    }\n+\n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int)x_kind]++;\n   tree_node_sizes[(int)x_kind] += sizeof (struct tree_list);\n #endif\n \n-  for (i = (sizeof (struct tree_common) / sizeof (int)) - 1; i >= 0; i--)\n-    ((int *) node)[i] = 0;\n \n   TREE_SET_CODE (node, TREE_LIST);\n   if (current_obstack == &permanent_obstack)\n@@ -3028,7 +3068,10 @@ build1 (code, type, node)\n \n   length = sizeof (struct tree_exp);\n \n-  t = (tree) obstack_alloc (obstack, length);\n+  if (ggc_p)\n+    t = ggc_alloc_tree (length);\n+  else\n+    t = (tree) obstack_alloc (obstack, length);\n   bzero ((PTR) t, length);\n \n #ifdef GATHER_STATISTICS\n@@ -3706,7 +3749,8 @@ type_hash_canon (hashcode, type)\n   t1 = type_hash_lookup (hashcode, type);\n   if (t1 != 0)\n     {\n-      obstack_free (TYPE_OBSTACK (type), type);\n+      if (!ggc_p)\n+\tobstack_free (TYPE_OBSTACK (type), type);\n #ifdef GATHER_STATISTICS\n       tree_node_counts[(int)t_kind]--;\n       tree_node_sizes[(int)t_kind] -= sizeof (struct tree_type);"}]}