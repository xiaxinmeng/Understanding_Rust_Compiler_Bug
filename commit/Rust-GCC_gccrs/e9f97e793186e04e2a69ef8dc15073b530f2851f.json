{"sha": "e9f97e793186e04e2a69ef8dc15073b530f2851f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlmOTdlNzkzMTg2ZTA0ZTJhNjllZjhkYzE1MDczYjUzMGYyODUxZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T09:56:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T09:56:56Z"}, "message": "[multiple changes]\n\n2015-10-20  Bob Duff  <duff@adacore.com>\n\n\t* a-coinve.ads, a-coinve.adb: Do the same efficiency\n\timprovements that were already done in the definite case\n\t(Ada.Containers.Vectors, i.e. a-convec). This includes the\n\tability to suppress checks, the fast path for Append, inlining\n\tas appropriate, and special-casing of \"for ... of\" loops. Reuse\n\tthe tampering machinery that is now in Ada.Containers. Simplify\n\tmany operations.\n\t* a-convec.ads, a-convec.adb: Change the code to be more similar\n\tto a-coinve.\n\t* a-finali.ads, a-finali.adb: Expose the \"null\"-ness of the\n\toperations. This may enable optimizations in the future, and\n\tseems cleaner anyway.\n\n2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Is_Operational_Item): Attributes related to\n\tAda 2012 iterators are operational items, and can be specified\n\ton partial views.\n\nFrom-SVN: r229033", "tree": {"sha": "4bf01e9fce36ef4cf64ed5b7df7bb399ce1e7b01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bf01e9fce36ef4cf64ed5b7df7bb399ce1e7b01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9f97e793186e04e2a69ef8dc15073b530f2851f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9f97e793186e04e2a69ef8dc15073b530f2851f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9f97e793186e04e2a69ef8dc15073b530f2851f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9f97e793186e04e2a69ef8dc15073b530f2851f/comments", "author": null, "committer": null, "parents": [{"sha": "0489576ce8062475a2a90b3aae869166d9005460", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0489576ce8062475a2a90b3aae869166d9005460", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0489576ce8062475a2a90b3aae869166d9005460"}], "stats": {"total": 1836, "additions": 598, "deletions": 1238}, "files": [{"sha": "81f651231102ed88754fbc9397b683537662e489", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e9f97e793186e04e2a69ef8dc15073b530f2851f", "patch": "@@ -1,3 +1,24 @@\n+2015-10-20  Bob Duff  <duff@adacore.com>\n+\n+\t* a-coinve.ads, a-coinve.adb: Do the same efficiency\n+\timprovements that were already done in the definite case\n+\t(Ada.Containers.Vectors, i.e. a-convec). This includes the\n+\tability to suppress checks, the fast path for Append, inlining\n+\tas appropriate, and special-casing of \"for ... of\" loops. Reuse\n+\tthe tampering machinery that is now in Ada.Containers. Simplify\n+\tmany operations.\n+\t* a-convec.ads, a-convec.adb: Change the code to be more similar\n+\tto a-coinve.\n+\t* a-finali.ads, a-finali.adb: Expose the \"null\"-ness of the\n+\toperations. This may enable optimizations in the future, and\n+\tseems cleaner anyway.\n+\n+2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Is_Operational_Item): Attributes related to\n+\tAda 2012 iterators are operational items, and can be specified\n+\ton partial views.\n+\n 2015-10-20  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Check_Usage): Update the calls to Usage_Error."}, {"sha": "5cc61b467a970d91c07c78b58fe2c1ab26d8b6ef", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 504, "deletions": 1146, "changes": 1650, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=e9f97e793186e04e2a69ef8dc15073b530f2851f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,525 +36,98 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers\n+\n    procedure Free is\n      new Ada.Unchecked_Deallocation (Elements_Type, Elements_Access);\n \n    procedure Free is\n      new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n \n+   procedure Append_Slow_Path\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type);\n+   --  This is the slow path for Append. This is split out to minimize the size\n+   --  of Append, because we have Inline (Append).\n+\n    ---------\n    -- \"&\" --\n    ---------\n \n-   function \"&\" (Left, Right : Vector) return Vector is\n-      LN   : constant Count_Type := Length (Left);\n-      RN   : constant Count_Type := Length (Right);\n-      N    : Count_Type'Base;  -- length of result\n-      J    : Count_Type'Base;  -- for computing intermediate values\n-      Last : Index_Type'Base;  -- Last index of result\n+   --  We decide that the capacity of the result of \"&\" is the minimum needed\n+   --  -- the sum of the lengths of the vector parameters. We could decide to\n+   --  make it larger, but we have no basis for knowing how much larger, so we\n+   --  just allocate the minimum amount of storage.\n \n+   function \"&\" (Left, Right : Vector) return Vector is\n    begin\n-      --  We decide that the capacity of the result is the sum of the lengths\n-      --  of the vector parameters. We could decide to make it larger, but we\n-      --  have no basis for knowing how much larger, so we just allocate the\n-      --  minimum amount of storage.\n-\n-      --  Here we handle the easy cases first, when one of the vector\n-      --  parameters is empty. (We say \"easy\" because there's nothing to\n-      --  compute, that can potentially overflow.)\n-\n-      if LN = 0 then\n-         if RN = 0 then\n-            return Empty_Vector;\n-         end if;\n-\n-         declare\n-            RE : Elements_Array renames\n-                   Right.Elements.EA (Index_Type'First .. Right.Last);\n-\n-            Elements : Elements_Access := new Elements_Type (Right.Last);\n-\n-         begin\n-            --  Elements of an indefinite vector are allocated, so we cannot\n-            --  use simple slice assignment to give a value to our result.\n-            --  Hence we must walk the array of the Right vector, and copy\n-            --  each source element individually.\n-\n-            for I in Elements.EA'Range loop\n-               begin\n-                  if RE (I) /= null then\n-                     Elements.EA (I) := new Element_Type'(RE (I).all);\n-                  end if;\n-\n-               exception\n-                  when others =>\n-                     for J in Index_Type'First .. I - 1 loop\n-                        Free (Elements.EA (J));\n-                     end loop;\n-\n-                     Free (Elements);\n-                     raise;\n-               end;\n-            end loop;\n-\n-            return (Controlled with Elements, Right.Last, 0, 0);\n-         end;\n-      end if;\n-\n-      if RN = 0 then\n-         declare\n-            LE : Elements_Array renames\n-                   Left.Elements.EA (Index_Type'First .. Left.Last);\n-\n-            Elements : Elements_Access := new Elements_Type (Left.Last);\n-\n-         begin\n-            --  Elements of an indefinite vector are allocated, so we cannot\n-            --  use simple slice assignment to give a value to our result.\n-            --  Hence we must walk the array of the Left vector, and copy\n-            --  each source element individually.\n-\n-            for I in Elements.EA'Range loop\n-               begin\n-                  if LE (I) /= null then\n-                     Elements.EA (I) := new Element_Type'(LE (I).all);\n-                  end if;\n-\n-               exception\n-                  when others =>\n-                     for J in Index_Type'First .. I - 1 loop\n-                        Free (Elements.EA (J));\n-                     end loop;\n-\n-                     Free (Elements);\n-                     raise;\n-               end;\n-            end loop;\n-\n-            return (Controlled with Elements, Left.Last, 0, 0);\n-         end;\n-      end if;\n-\n-      --  Neither of the vector parameters is empty, so we must compute the\n-      --  length of the result vector and its last index. (This is the harder\n-      --  case, because our computations must avoid overflow.)\n-\n-      --  There are two constraints we need to satisfy. The first constraint is\n-      --  that a container cannot have more than Count_Type'Last elements, so\n-      --  we must check the sum of the combined lengths. Note that we cannot\n-      --  simply add the lengths, because of the possibility of overflow.\n-\n-      if LN > Count_Type'Last - RN then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      --  It is now safe compute the length of the new vector.\n-\n-      N := LN + RN;\n-\n-      --  The second constraint is that the new Last index value cannot\n-      --  exceed Index_Type'Last. We use the wider of Index_Type'Base and\n-      --  Count_Type'Base as the type for intermediate values.\n-\n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n-\n-         --  We perform a two-part test. First we determine whether the\n-         --  computed Last value lies in the base range of the type, and then\n-         --  determine whether it lies in the range of the index (sub)type.\n-\n-         --  Last must satisfy this relation:\n-         --    First + Length - 1 <= Last\n-         --  We regroup terms:\n-         --    First - 1 <= Last - Length\n-         --  Which can rewrite as:\n-         --    No_Index <= Last - Length\n-\n-         if Index_Type'Base'Last - Index_Type'Base (N) < No_Index then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         --  We now know that the computed value of Last is within the base\n-         --  range of the type, so it is safe to compute its value:\n-\n-         Last := No_Index + Index_Type'Base (N);\n-\n-         --  Finally we test whether the value is within the range of the\n-         --  generic actual index subtype:\n-\n-         if Last > Index_Type'Last then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-      elsif Index_Type'First <= 0 then\n-\n-         --  Here we can compute Last directly, in the normal way. We know that\n-         --  No_Index is less than 0, so there is no danger of overflow when\n-         --  adding the (positive) value of length.\n-\n-         J := Count_Type'Base (No_Index) + N;  -- Last\n-\n-         if J > Count_Type'Base (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         --  We know that the computed value (having type Count_Type) of Last\n-         --  is within the range of the generic actual index subtype, so it is\n-         --  safe to convert to Index_Type:\n-\n-         Last := Index_Type'Base (J);\n-\n-      else\n-         --  Here Index_Type'First (and Index_Type'Last) is positive, so we\n-         --  must test the length indirectly (by working backwards from the\n-         --  largest possible value of Last), in order to prevent overflow.\n-\n-         J := Count_Type'Base (Index_Type'Last) - N;  -- No_Index\n-\n-         if J < Count_Type'Base (No_Index) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         --  We have determined that the result length would not create a Last\n-         --  index value outside of the range of Index_Type, so we can now\n-         --  safely compute its value.\n-\n-         Last := Index_Type'Base (Count_Type'Base (No_Index) + N);\n-      end if;\n-\n-      declare\n-         LE : Elements_Array renames\n-                Left.Elements.EA (Index_Type'First .. Left.Last);\n-         RE : Elements_Array renames\n-                Right.Elements.EA (Index_Type'First .. Right.Last);\n-\n-         Elements : Elements_Access := new Elements_Type (Last);\n-\n-         I : Index_Type'Base := No_Index;\n-\n-      begin\n-         --  Elements of an indefinite vector are allocated, so we cannot use\n-         --  simple slice assignment to give a value to our result. Hence we\n-         --  must walk the array of each vector parameter, and copy each source\n-         --  element individually.\n-\n-         for LI in LE'Range loop\n-            I := I + 1;\n-\n-            begin\n-               if LE (LI) /= null then\n-                  Elements.EA (I) := new Element_Type'(LE (LI).all);\n-               end if;\n-\n-            exception\n-               when others =>\n-                  for J in Index_Type'First .. I - 1 loop\n-                     Free (Elements.EA (J));\n-                  end loop;\n-\n-                  Free (Elements);\n-                  raise;\n-            end;\n-         end loop;\n-\n-         for RI in RE'Range loop\n-            I := I + 1;\n-\n-            begin\n-               if RE (RI) /= null then\n-                  Elements.EA (I) := new Element_Type'(RE (RI).all);\n-               end if;\n-\n-            exception\n-               when others =>\n-                  for J in Index_Type'First .. I - 1 loop\n-                     Free (Elements.EA (J));\n-                  end loop;\n-\n-                  Free (Elements);\n-                  raise;\n-            end;\n-         end loop;\n-\n-         return (Controlled with Elements, Last, 0, 0);\n-      end;\n+      return Result : Vector do\n+         Reserve_Capacity (Result, Length (Left) + Length (Right));\n+         Append (Result, Left);\n+         Append (Result, Right);\n+      end return;\n    end \"&\";\n \n-   function \"&\" (Left : Vector; Right : Element_Type) return Vector is\n+   function \"&\" (Left  : Vector; Right : Element_Type) return Vector is\n    begin\n-      --  We decide that the capacity of the result is the sum of the lengths\n-      --  of the parameters. We could decide to make it larger, but we have no\n-      --  basis for knowing how much larger, so we just allocate the minimum\n-      --  amount of storage.\n-\n-      --  Here we handle the easy case first, when the vector parameter (Left)\n-      --  is empty.\n-\n-      if Left.Is_Empty then\n-         declare\n-            Elements : Elements_Access := new Elements_Type (Index_Type'First);\n-\n-         begin\n-            begin\n-               Elements.EA (Index_Type'First) := new Element_Type'(Right);\n-            exception\n-               when others =>\n-                  Free (Elements);\n-                  raise;\n-            end;\n-\n-            return (Controlled with Elements, Index_Type'First, 0, 0);\n-         end;\n-      end if;\n-\n-      --  The vector parameter is not empty, so we must compute the length of\n-      --  the result vector and its last index, but in such a way that overflow\n-      --  is avoided. We must satisfy two constraints: the new length cannot\n-      --  exceed Count_Type'Last, and the new Last index cannot exceed\n-      --  Index_Type'Last.\n-\n-      if Left.Length = Count_Type'Last then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      if Left.Last >= Index_Type'Last then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      declare\n-         Last : constant Index_Type := Left.Last + 1;\n-\n-         LE : Elements_Array renames\n-                 Left.Elements.EA (Index_Type'First .. Left.Last);\n-\n-         Elements : Elements_Access := new Elements_Type (Last);\n-\n-      begin\n-         for I in LE'Range loop\n-            begin\n-               if LE (I) /= null then\n-                  Elements.EA (I) := new Element_Type'(LE (I).all);\n-               end if;\n-\n-            exception\n-               when others =>\n-                  for J in Index_Type'First .. I - 1 loop\n-                     Free (Elements.EA (J));\n-                  end loop;\n-\n-                  Free (Elements);\n-                  raise;\n-            end;\n-         end loop;\n-\n-         begin\n-            Elements.EA (Last) := new Element_Type'(Right);\n-\n-         exception\n-            when others =>\n-               for J in Index_Type'First .. Last - 1 loop\n-                  Free (Elements.EA (J));\n-               end loop;\n-\n-               Free (Elements);\n-               raise;\n-         end;\n-\n-         return (Controlled with Elements, Last, 0, 0);\n-      end;\n+      return Result : Vector do\n+         Reserve_Capacity (Result, Length (Left) + 1);\n+         Append (Result, Left);\n+         Append (Result, Right);\n+      end return;\n    end \"&\";\n \n-   function \"&\" (Left : Element_Type; Right : Vector) return Vector is\n+   function \"&\" (Left  : Element_Type; Right : Vector) return Vector is\n    begin\n-      --  We decide that the capacity of the result is the sum of the lengths\n-      --  of the parameters. We could decide to make it larger, but we have no\n-      --  basis for knowing how much larger, so we just allocate the minimum\n-      --  amount of storage.\n-\n-      --  Here we handle the easy case first, when the vector parameter (Right)\n-      --  is empty.\n-\n-      if Right.Is_Empty then\n-         declare\n-            Elements : Elements_Access := new Elements_Type (Index_Type'First);\n-\n-         begin\n-            begin\n-               Elements.EA (Index_Type'First) := new Element_Type'(Left);\n-            exception\n-               when others =>\n-                  Free (Elements);\n-                  raise;\n-            end;\n-\n-            return (Controlled with Elements, Index_Type'First, 0, 0);\n-         end;\n-      end if;\n-\n-      --  The vector parameter is not empty, so we must compute the length of\n-      --  the result vector and its last index, but in such a way that overflow\n-      --  is avoided. We must satisfy two constraints: the new length cannot\n-      --  exceed Count_Type'Last, and the new Last index cannot exceed\n-      --  Index_Type'Last.\n-\n-      if Right.Length = Count_Type'Last then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      if Right.Last >= Index_Type'Last then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      declare\n-         Last : constant Index_Type := Right.Last + 1;\n-\n-         RE : Elements_Array renames\n-                Right.Elements.EA (Index_Type'First .. Right.Last);\n-\n-         Elements : Elements_Access := new Elements_Type (Last);\n-\n-         I : Index_Type'Base := Index_Type'First;\n-\n-      begin\n-         begin\n-            Elements.EA (I) := new Element_Type'(Left);\n-         exception\n-            when others =>\n-               Free (Elements);\n-               raise;\n-         end;\n-\n-         for RI in RE'Range loop\n-            I := I + 1;\n-\n-            begin\n-               if RE (RI) /= null then\n-                  Elements.EA (I) := new Element_Type'(RE (RI).all);\n-               end if;\n-\n-            exception\n-               when others =>\n-                  for J in Index_Type'First .. I - 1 loop\n-                     Free (Elements.EA (J));\n-                  end loop;\n-\n-                  Free (Elements);\n-                  raise;\n-            end;\n-         end loop;\n-\n-         return (Controlled with Elements, Last, 0, 0);\n-      end;\n+      return Result : Vector do\n+         Reserve_Capacity (Result, 1 + Length (Right));\n+         Append (Result, Left);\n+         Append (Result, Right);\n+      end return;\n    end \"&\";\n \n    function \"&\" (Left, Right : Element_Type) return Vector is\n    begin\n-      --  We decide that the capacity of the result is the sum of the lengths\n-      --  of the parameters. We could decide to make it larger, but we have no\n-      --  basis for knowing how much larger, so we just allocate the minimum\n-      --  amount of storage.\n-\n-      --  We must compute the length of the result vector and its last index,\n-      --  but in such a way that overflow is avoided. We must satisfy two\n-      --  constraints: the new length cannot exceed Count_Type'Last (here, we\n-      --  know that that condition is satisfied), and the new Last index cannot\n-      --  exceed Index_Type'Last.\n-\n-      if Index_Type'First >= Index_Type'Last then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      declare\n-         Last     : constant Index_Type := Index_Type'First + 1;\n-         Elements : Elements_Access := new Elements_Type (Last);\n-\n-      begin\n-         begin\n-            Elements.EA (Index_Type'First) := new Element_Type'(Left);\n-         exception\n-            when others =>\n-               Free (Elements);\n-               raise;\n-         end;\n-\n-         begin\n-            Elements.EA (Last) := new Element_Type'(Right);\n-         exception\n-            when others =>\n-               Free (Elements.EA (Index_Type'First));\n-               Free (Elements);\n-               raise;\n-         end;\n-\n-         return (Controlled with Elements, Last, 0, 0);\n-      end;\n+      return Result : Vector do\n+         Reserve_Capacity (Result, 1 + 1);\n+         Append (Result, Left);\n+         Append (Result, Right);\n+      end return;\n    end \"&\";\n \n    ---------\n    -- \"=\" --\n    ---------\n \n    overriding function \"=\" (Left, Right : Vector) return Boolean is\n-      BL : Natural renames Left'Unrestricted_Access.Busy;\n-      LL : Natural renames Left'Unrestricted_Access.Lock;\n-\n-      BR : Natural renames Right'Unrestricted_Access.Busy;\n-      LR : Natural renames Right'Unrestricted_Access.Lock;\n-\n-      Result : Boolean;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n+      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       if Left.Last /= Right.Last then\n          return False;\n       end if;\n \n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      BL := BL + 1;\n-      LL := LL + 1;\n-\n-      BR := BR + 1;\n-      LR := LR + 1;\n-\n-      Result := True;\n-      for J in Index_Type'First .. Left.Last loop\n+      for J in Index_Type range Index_Type'First .. Left.Last loop\n          if Left.Elements.EA (J) = null then\n             if Right.Elements.EA (J) /= null then\n-               Result := False;\n-               exit;\n+               return False;\n             end if;\n \n          elsif Right.Elements.EA (J) = null then\n-            Result := False;\n-            exit;\n+            return False;\n \n          elsif Left.Elements.EA (J).all /= Right.Elements.EA (J).all then\n-            Result := False;\n-            exit;\n+            return False;\n          end if;\n       end loop;\n \n-      BL := BL - 1;\n-      LL := LL - 1;\n-\n-      BR := BR - 1;\n-      LR := LR - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         BL := BL - 1;\n-         LL := LL - 1;\n-\n-         BR := BR - 1;\n-         LR := LR - 1;\n-\n-         raise;\n+      return True;\n    end \"=\";\n \n    ------------\n@@ -576,8 +149,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       begin\n          Container.Elements := null;\n          Container.Last := No_Index;\n-         Container.Busy := 0;\n-         Container.Lock := 0;\n+         Zero_Counts (Container.TC);\n \n          Container.Elements := new Elements_Type (L);\n \n@@ -591,20 +163,6 @@ package body Ada.Containers.Indefinite_Vectors is\n       end;\n    end Adjust;\n \n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Vector renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Append --\n    ------------\n@@ -613,7 +171,7 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Is_Empty (New_Item) then\n          return;\n-      elsif Container.Last = Index_Type'Last then\n+      elsif Checks and then Container.Last = Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n       else\n          Insert (Container, Container.Last + 1, New_Item);\n@@ -625,15 +183,57 @@ package body Ada.Containers.Indefinite_Vectors is\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n    is\n+   begin\n+      --  In the general case, we pass the buck to Insert, but for efficiency,\n+      --  we check for the usual case where Count = 1 and the vector has enough\n+      --  room for at least one more element.\n+\n+      if Count = 1\n+        and then Container.Elements /= null\n+        and then Container.Last /= Container.Elements.Last\n+      then\n+         TC_Check (Container.TC);\n+\n+         --  Increment Container.Last after assigning the New_Item, so we\n+         --  leave the Container unmodified in case Finalize/Adjust raises\n+         --  an exception.\n+\n+         declare\n+            New_Last : constant Index_Type := Container.Last + 1;\n+\n+            --  The element allocator may need an accessibility check in the\n+            --  case actual type is class-wide or has access discriminants\n+            --  (see RM 4.8(10.1) and AI12-0035).\n+\n+            pragma Unsuppress (Accessibility_Check);\n+         begin\n+            Container.Elements.EA (New_Last) := new Element_Type'(New_Item);\n+            Container.Last := New_Last;\n+         end;\n+\n+      else\n+         Append_Slow_Path (Container, New_Item, Count);\n+      end if;\n+   end Append;\n+\n+   ----------------------\n+   -- Append_Slow_Path --\n+   ----------------------\n+\n+   procedure Append_Slow_Path\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   is\n    begin\n       if Count = 0 then\n          return;\n-      elsif Container.Last = Index_Type'Last then\n+      elsif Checks and then Container.Last = Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n       else\n          Insert (Container, Container.Last + 1, New_Item, Count);\n       end if;\n-   end Append;\n+   end Append_Slow_Path;\n \n    ------------\n    -- Assign --\n@@ -668,21 +268,17 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    procedure Clear (Container : in out Vector) is\n    begin\n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n+      TC_Check (Container.TC);\n \n-      else\n-         while Container.Last >= Index_Type'First loop\n-            declare\n-               X : Element_Access := Container.Elements.EA (Container.Last);\n-            begin\n-               Container.Elements.EA (Container.Last) := null;\n-               Container.Last := Container.Last - 1;\n-               Free (X);\n-            end;\n-         end loop;\n-      end if;\n+      while Container.Last >= Index_Type'First loop\n+         declare\n+            X : Element_Access := Container.Elements.EA (Container.Last);\n+         begin\n+            Container.Elements.EA (Container.Last) := null;\n+            Container.Last := Container.Last - 1;\n+            Free (X);\n+         end;\n+      end loop;\n    end Clear;\n \n    ------------------------\n@@ -693,72 +289,70 @@ package body Ada.Containers.Indefinite_Vectors is\n      (Container : aliased Vector;\n       Position  : Cursor) return Constant_Reference_Type\n    is\n-      E : Element_Access;\n-\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor denotes wrong container\";\n-      end if;\n-\n-      if Position.Index > Position.Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n-      end if;\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n \n-      E := Container.Elements.EA (Position.Index);\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n+         end if;\n \n-      if E = null then\n-         raise Constraint_Error with \"element at Position is empty\";\n+         if Position.Index > Position.Container.Last then\n+            raise Constraint_Error with \"Position cursor is out of range\";\n+         end if;\n       end if;\n \n-      declare\n-         C : Vector renames Container'Unrestricted_Access.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-      begin\n+      if T_Check then\n+         declare\n+            TC : constant Tamper_Counts_Access :=\n+              Container.TC'Unrestricted_Access;\n+         begin\n+            --  The following will raise Constraint_Error if Element is null\n+\n+            return R : constant Constant_Reference_Type :=\n+              (Element => Container.Elements.EA (Position.Index),\n+               Control => (Controlled with TC))\n+            do\n+               Lock (TC.all);\n+            end return;\n+         end;\n+      else\n          return R : constant Constant_Reference_Type :=\n-           (Element => E.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n-         do\n-            B := B + 1;\n-            L := L + 1;\n-         end return;\n-      end;\n+           (Element => Container.Elements.EA (Position.Index),\n+            Control => (Controlled with null));\n+      end if;\n    end Constant_Reference;\n \n    function Constant_Reference\n      (Container : aliased Vector;\n       Index     : Index_Type) return Constant_Reference_Type\n    is\n-      E : Element_Access;\n-\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      E := Container.Elements.EA (Index);\n-\n-      if E = null then\n-         raise Constraint_Error with \"element at Index is empty\";\n-      end if;\n-\n-      declare\n-         C : Vector renames Container'Unrestricted_Access.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-      begin\n+      if T_Check then\n+         declare\n+            TC : constant Tamper_Counts_Access :=\n+              Container.TC'Unrestricted_Access;\n+         begin\n+            --  The following will raise Constraint_Error if Element is null\n+\n+            return R : constant Constant_Reference_Type :=\n+              (Element => Container.Elements.EA (Index),\n+               Control => (Controlled with TC))\n+            do\n+               Lock (TC.all);\n+            end return;\n+         end;\n+      else\n          return R : constant Constant_Reference_Type :=\n-           (Element => E.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n-         do\n-            B := B + 1;\n-            L := L + 1;\n-         end return;\n-      end;\n+           (Element => Container.Elements.EA (Index),\n+            Control => (Controlled with null));\n+      end if;\n    end Constant_Reference;\n \n    --------------\n@@ -790,9 +384,9 @@ package body Ada.Containers.Indefinite_Vectors is\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n \n-      else\n-         raise Capacity_Error\n-           with \"Requested capacity is less than Source length\";\n+      elsif Checks then\n+         raise Capacity_Error with\n+           \"Requested capacity is less than Source length\";\n       end if;\n \n       return Target : Vector do\n@@ -833,7 +427,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  in the base range that immediately precede and immediately follow the\n       --  values in the Index_Type.)\n \n-      if Index < Index_Type'First then\n+      if Checks and then Index < Index_Type'First then\n          raise Constraint_Error with \"Index is out of range (too small)\";\n       end if;\n \n@@ -845,7 +439,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  algorithm, so that case is treated as a proper error.)\n \n       if Index > Old_Last then\n-         if Index > Old_Last + 1 then\n+         if Checks and then Index > Old_Last + 1 then\n             raise Constraint_Error with \"Index is out of range (too large)\";\n          else\n             return;\n@@ -874,10 +468,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  the count on exit. Delete checks the count to determine whether it is\n       --  being called while the associated callback procedure is executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  We first calculate what's available for deletion starting at\n       --  Index. Here and elsewhere we use the wider of Index_Type'Base and\n@@ -886,7 +477,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then\n          Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;\n-\n       else\n          Count2 := Count_Type'Base (Old_Last - Index + 1);\n       end if;\n@@ -938,7 +528,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  index value New_Last is the last index value of their new home, and\n       --  index value J is the first index of their old home.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          New_Last := Old_Last - Index_Type'Base (Count);\n          J := Index + Index_Type'Base (Count);\n       else\n@@ -988,22 +578,21 @@ package body Ada.Containers.Indefinite_Vectors is\n       Position  : in out Cursor;\n       Count     : Count_Type := 1)\n    is\n-      pragma Warnings (Off, Position);\n-\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-\n-      elsif Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor denotes wrong container\";\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n \n-      elsif Position.Index > Container.Last then\n-         raise Program_Error with \"Position index is out of range\";\n+         elsif Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n \n-      else\n-         Delete (Container, Position.Index, Count);\n-         Position := No_Element;\n+         elsif Position.Index > Container.Last then\n+            raise Program_Error with \"Position index is out of range\";\n+         end if;\n       end if;\n+\n+      Delete (Container, Position.Index, Count);\n+      Position := No_Element;\n    end Delete;\n \n    ------------------\n@@ -1062,10 +651,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  it is being called while the associated callback procedure is\n       --  executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  Elements in an indefinite vector are allocated, so we must iterate\n       --  over the loop and deallocate elements one-at-a-time. We work from\n@@ -1108,14 +694,14 @@ package body Ada.Containers.Indefinite_Vectors is\n       Index     : Index_Type) return Element_Type\n    is\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n       declare\n          EA : constant Element_Access := Container.Elements.EA (Index);\n       begin\n-         if EA = null then\n+         if Checks and then EA = null then\n             raise Constraint_Error with \"element is empty\";\n          else\n             return EA.all;\n@@ -1125,19 +711,21 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n \n-      if Position.Index > Position.Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n+         if Position.Index > Position.Container.Last then\n+            raise Constraint_Error with \"Position cursor is out of range\";\n+         end if;\n       end if;\n \n       declare\n          EA : constant Element_Access :=\n                 Position.Container.Elements.EA (Position.Index);\n       begin\n-         if EA = null then\n+         if Checks and then EA = null then\n             raise Constraint_Error with \"element is empty\";\n          else\n             return EA.all;\n@@ -1162,25 +750,9 @@ package body Ada.Containers.Indefinite_Vectors is\n    end Finalize;\n \n    procedure Finalize (Object : in out Iterator) is\n-      B : Natural renames Object.Container.Busy;\n-   begin\n-      B := B - 1;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n+      pragma Assert (T_Check); -- not called if check suppressed\n    begin\n-      if Control.Container /= null then\n-         declare\n-            C : Vector renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n-      end if;\n+      Unbusy (Object.Container.TC);\n    end Finalize;\n \n    ----------\n@@ -1193,7 +765,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       Position  : Cursor := No_Element) return Cursor\n    is\n    begin\n-      if Position.Container /= null then\n+      if Checks and then Position.Container /= null then\n          if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error with \"Position cursor denotes wrong container\";\n          end if;\n@@ -1207,39 +779,15 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Index_Type'Base;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Result := No_Index;\n          for J in Position.Index .. Container.Last loop\n-            if Container.Elements.EA (J) /= null\n-              and then Container.Elements.EA (J).all = Item\n-            then\n-               Result := J;\n-               exit;\n+            if Container.Elements.EA (J).all = Item then\n+               return Cursor'(Container'Unrestricted_Access, J);\n             end if;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = No_Index then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-            raise;\n+         return No_Element;\n       end;\n    end Find;\n \n@@ -1252,39 +800,18 @@ package body Ada.Containers.Indefinite_Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index\n    is\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-      L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-      Result : Index_Type'Base;\n-\n-   begin\n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n-      B := B + 1;\n-      L := L + 1;\n-\n-      Result := No_Index;\n+      Lock : With_Lock (Container.TC'Unrestricted_Access);\n+   begin\n       for Indx in Index .. Container.Last loop\n-         if Container.Elements.EA (Indx) /= null\n-           and then Container.Elements.EA (Indx).all = Item\n-         then\n-            Result := Indx;\n-            exit;\n+         if Container.Elements.EA (Indx).all = Item then\n+            return Indx;\n          end if;\n       end loop;\n \n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-\n-         raise;\n+      return No_Index;\n    end Find_Index;\n \n    -----------\n@@ -1329,15 +856,15 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    function First_Element (Container : Vector) return Element_Type is\n    begin\n-      if Container.Last = No_Index then\n+      if Checks and then Container.Last = No_Index then\n          raise Constraint_Error with \"Container is empty\";\n       end if;\n \n       declare\n          EA : constant Element_Access :=\n                 Container.Elements.EA (Index_Type'First);\n       begin\n-         if EA = null then\n+         if Checks and then EA = null then\n             raise Constraint_Error with \"first element is empty\";\n          else\n             return EA.all;\n@@ -1397,36 +924,16 @@ package body Ada.Containers.Indefinite_Vectors is\n          --  element tampering by a generic actual subprogram.\n \n          declare\n+            Lock : With_Lock (Container.TC'Unrestricted_Access);\n             E : Elements_Array renames Container.Elements.EA;\n-\n-            B : Natural renames Container'Unrestricted_Access.Busy;\n-            L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-            Result : Boolean;\n-\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            Result := True;\n-            for I in Index_Type'First .. Container.Last - 1 loop\n-               if Is_Less (E (I + 1), E (I)) then\n-                  Result := False;\n-                  exit;\n+            for J in Index_Type'First .. Container.Last - 1 loop\n+               if Is_Less (E (J + 1), E (J)) then\n+                  return False;\n                end if;\n             end loop;\n \n-            B := B - 1;\n-            L := L - 1;\n-\n-            return Result;\n-\n-         exception\n-            when others =>\n-               B := B - 1;\n-               L := L - 1;\n-\n-               raise;\n+            return True;\n          end;\n       end Is_Sorted;\n \n@@ -1450,7 +957,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             return;\n          end if;\n \n-         if Target'Address = Source'Address then\n+         if Checks and then Target'Address = Source'Address then\n             raise Program_Error with\n               \"Target and Source denote same non-empty container\";\n          end if;\n@@ -1460,10 +967,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             return;\n          end if;\n \n-         if Source.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (vector is busy)\";\n-         end if;\n+         TC_Check (Source.TC);\n \n          I := Target.Last;  -- original value (before Set_Length)\n          Target.Set_Length (Length (Target) + Length (Source));\n@@ -1475,19 +979,9 @@ package body Ada.Containers.Indefinite_Vectors is\n             TA : Elements_Array renames Target.Elements.EA;\n             SA : Elements_Array renames Source.Elements.EA;\n \n-            TB : Natural renames Target.Busy;\n-            TL : Natural renames Target.Lock;\n-\n-            SB : Natural renames Source.Busy;\n-            SL : Natural renames Source.Lock;\n-\n+            Lock_Target : With_Lock (Target.TC'Unchecked_Access);\n+            Lock_Source : With_Lock (Source.TC'Unchecked_Access);\n          begin\n-            TB := TB + 1;\n-            TL := TL + 1;\n-\n-            SB := SB + 1;\n-            SL := SL + 1;\n-\n             J := Target.Last;  -- new value (after Set_Length)\n             while Source.Last >= Index_Type'First loop\n                pragma Assert\n@@ -1531,22 +1025,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n                J := J - 1;\n             end loop;\n-\n-            TB := TB - 1;\n-            TL := TL - 1;\n-\n-            SB := SB - 1;\n-            SL := SL - 1;\n-\n-         exception\n-            when others =>\n-               TB := TB - 1;\n-               TL := TL - 1;\n-\n-               SB := SB - 1;\n-               SL := SL - 1;\n-\n-               raise;\n          end;\n       end Merge;\n \n@@ -1579,38 +1057,30 @@ package body Ada.Containers.Indefinite_Vectors is\n          --  an artifact of our array-based implementation. Logically Sort\n          --  requires a check for cursor tampering.\n \n-         if Container.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (vector is busy)\";\n-         end if;\n+         TC_Check (Container.TC);\n \n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n+            Lock : With_Lock (Container.TC'Unchecked_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n             Sort (Container.Elements.EA (Index_Type'First .. Container.Last));\n-\n-            B := B - 1;\n-            L := L - 1;\n-\n-         exception\n-            when others =>\n-               B := B - 1;\n-               L := L - 1;\n-\n-               raise;\n          end;\n       end Sort;\n \n    end Generic_Sorting;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Container.Elements.EA (Position.Index);\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1648,33 +1118,33 @@ package body Ada.Containers.Indefinite_Vectors is\n       Dst          : Elements_Access;  -- new, expanded internal array\n \n    begin\n-      --  As a precondition on the generic actual Index_Type, the base type\n-      --  must include Index_Type'Pred (Index_Type'First); this is the value\n-      --  that Container.Last assumes when the vector is empty. However, we do\n-      --  not allow that as the value for Index when specifying where the new\n-      --  items should be inserted, so we must manually check. (That the user\n-      --  is allowed to specify the value at all here is a consequence of the\n-      --  declaration of the Extended_Index subtype, which includes the values\n-      --  in the base range that immediately precede and immediately follow the\n-      --  values in the Index_Type.)\n+      if Checks then\n+         --  As a precondition on the generic actual Index_Type, the base type\n+         --  must include Index_Type'Pred (Index_Type'First); this is the value\n+         --  that Container.Last assumes when the vector is empty. However, we\n+         --  do not allow that as the value for Index when specifying where the\n+         --  new items should be inserted, so we must manually check. (That the\n+         --  user is allowed to specify the value at all here is a consequence\n+         --  of the declaration of the Extended_Index subtype, which includes\n+         --  the values in the base range that immediately precede and\n+         --  immediately follow the values in the Index_Type.)\n \n-      if Before < Index_Type'First then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too small)\";\n-      end if;\n+         if Before < Index_Type'First then\n+            raise Constraint_Error with\n+              \"Before index is out of range (too small)\";\n+         end if;\n \n-      --  We do allow a value greater than Container.Last to be specified as\n-      --  the Index, but only if it's immediately greater. This allows for the\n-      --  case of appending items to the back end of the vector. (It is assumed\n-      --  that specifying an index value greater than Last + 1 indicates some\n-      --  deeper flaw in the caller's algorithm, so that case is treated as a\n-      --  proper error.)\n-\n-      if Before > Container.Last\n-        and then Before > Container.Last + 1\n-      then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too large)\";\n+         --  We do allow a value greater than Container.Last to be specified as\n+         --  the Index, but only if it's immediately greater. This allows for\n+         --  the case of appending items to the back end of the vector. (It is\n+         --  assumed that specifying an index value greater than Last + 1\n+         --  indicates some deeper flaw in the caller's algorithm, so that case\n+         --  is treated as a proper error.)\n+\n+         if Before > Container.Last + 1 then\n+            raise Constraint_Error with\n+              \"Before index is out of range (too large)\";\n+         end if;\n       end if;\n \n       --  We treat inserting 0 items into the container as a no-op, even when\n@@ -1687,10 +1157,10 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  There are two constraints we need to satisfy. The first constraint is\n       --  that a container cannot have more than Count_Type'Last elements, so\n       --  we must check the sum of the current length and the insertion count.\n-      --  Note that we cannot simply add these values, because of the\n-      --  possibility of overflow.\n+      --  Note: we cannot simply add these values, because of the possibility\n+      --  of overflow.\n \n-      if Old_Length > Count_Type'Last - Count then\n+      if Checks and then Old_Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n@@ -1705,7 +1175,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  compare the new length to the maximum length. If the new length is\n       --  acceptable, then we compute the new last index from that.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n \n          --  We have to handle the case when there might be more values in the\n          --  range of Index_Type than in the range of Count_Type.\n@@ -1740,9 +1210,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            if Index_Type'Last - No_Index >=\n-                 Count_Type'Pos (Count_Type'Last)\n-            then\n+            if Index_Type'Last - No_Index >= Count_Type_Last then\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -1799,15 +1267,15 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  an internal array with a last index value greater than\n       --  Index_Type'Last, with no way to index those elements).\n \n-      if New_Length > Max_Length then\n+      if Checks and then New_Length > Max_Length then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n       --  New_Last is the last index value of the items in the container after\n       --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to\n       --  compute its value from the New_Length.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          New_Last := No_Index + Index_Type'Base (New_Length);\n       else\n          New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n@@ -1863,10 +1331,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  exit. Insert checks the count to determine whether it is being called\n       --  while the associated callback procedure is executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       if New_Length <= Container.Elements.EA'Length then\n \n@@ -1916,7 +1381,7 @@ package body Ada.Containers.Indefinite_Vectors is\n                --  new home. We use the wider of Index_Type'Base and\n                --  Count_Type'Base as the type for intermediate index values.\n \n-               if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+               if Index_Type'Base'Last >= Count_Type_Last then\n                   Index := Before + Index_Type'Base (Count);\n                else\n                   Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n@@ -2002,7 +1467,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  We have computed the length of the new internal array (and this is\n       --  what \"vector capacity\" means), so use that to compute its last index.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          Dst_Last := No_Index + Index_Type'Base (New_Capacity);\n       else\n          Dst_Last :=\n@@ -2069,7 +1534,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  The new items are being inserted before some existing elements,\n             --  so we must slide the existing elements up to their new home.\n \n-            if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+            if Index_Type'Base'Last >= Count_Type_Last then\n                Index := Before + Index_Type'Base (Count);\n             else\n                Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n@@ -2219,7 +1684,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  after copying the first slice of the source, and determining that\n       --  this second slice of the source is empty.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          J := Before + Index_Type'Base (N);\n       else\n          J := Index_Type'Base (Count_Type'Base (Before) + N);\n@@ -2242,7 +1707,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          --  destination that receives this slice of the source. (For the\n          --  reasons given above, this slice is guaranteed to be non-empty.)\n \n-         if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         if Index_Type'Base'Last >= Count_Type_Last then\n             Dst_Index := J - Index_Type'Base (Src'Length);\n          else\n             Dst_Index := Index_Type'Base (Count_Type'Base (J) - Src'Length);\n@@ -2266,7 +1731,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -2277,7 +1742,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Before.Container = null or else Before.Index > Container.Last then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -2300,9 +1765,8 @@ package body Ada.Containers.Indefinite_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n-        and then Before.Container /=\n-                   Vector_Access'(Container'Unrestricted_Access)\n+      if Checks and then Before.Container /= null\n+        and then Before.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n@@ -2318,7 +1782,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Before.Container = null or else Before.Index > Container.Last then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -2331,7 +1795,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       Insert (Container, Index, New_Item);\n \n-      Position := Cursor'(Container'Unrestricted_Access, Index);\n+      Position := (Container'Unrestricted_Access, Index);\n    end Insert;\n \n    procedure Insert\n@@ -2343,7 +1807,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -2354,7 +1818,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Before.Container = null or else Before.Index > Container.Last then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -2378,16 +1842,14 @@ package body Ada.Containers.Indefinite_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n \n       if Count = 0 then\n-         if Before.Container = null\n-           or else Before.Index > Container.Last\n-         then\n+         if Before.Container = null or else Before.Index > Container.Last then\n             Position := No_Element;\n          else\n             Position := (Container'Unrestricted_Access, Before.Index);\n@@ -2397,7 +1859,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Before.Container = null or else Before.Index > Container.Last then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -2436,31 +1898,33 @@ package body Ada.Containers.Indefinite_Vectors is\n       Dst          : Elements_Access;  -- new, expanded internal array\n \n    begin\n-      --  As a precondition on the generic actual Index_Type, the base type\n-      --  must include Index_Type'Pred (Index_Type'First); this is the value\n-      --  that Container.Last assumes when the vector is empty. However, we do\n-      --  not allow that as the value for Index when specifying where the new\n-      --  items should be inserted, so we must manually check. (That the user\n-      --  is allowed to specify the value at all here is a consequence of the\n-      --  declaration of the Extended_Index subtype, which includes the values\n-      --  in the base range that immediately precede and immediately follow the\n-      --  values in the Index_Type.)\n+      if Checks then\n+         --  As a precondition on the generic actual Index_Type, the base type\n+         --  must include Index_Type'Pred (Index_Type'First); this is the value\n+         --  that Container.Last assumes when the vector is empty. However, we\n+         --  do not allow that as the value for Index when specifying where the\n+         --  new items should be inserted, so we must manually check. (That the\n+         --  user is allowed to specify the value at all here is a consequence\n+         --  of the declaration of the Extended_Index subtype, which includes\n+         --  the values in the base range that immediately precede and\n+         --  immediately follow the values in the Index_Type.)\n \n-      if Before < Index_Type'First then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too small)\";\n-      end if;\n+         if Before < Index_Type'First then\n+            raise Constraint_Error with\n+              \"Before index is out of range (too small)\";\n+         end if;\n \n-      --  We do allow a value greater than Container.Last to be specified as\n-      --  the Index, but only if it's immediately greater. This allows for the\n-      --  case of appending items to the back end of the vector. (It is assumed\n-      --  that specifying an index value greater than Last + 1 indicates some\n-      --  deeper flaw in the caller's algorithm, so that case is treated as a\n-      --  proper error.)\n-\n-      if Before > Container.Last and then Before > Container.Last + 1 then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too large)\";\n+         --  We do allow a value greater than Container.Last to be specified as\n+         --  the Index, but only if it's immediately greater. This allows for\n+         --  the case of appending items to the back end of the vector. (It is\n+         --  assumed that specifying an index value greater than Last + 1\n+         --  indicates some deeper flaw in the caller's algorithm, so that case\n+         --  is treated as a proper error.)\n+\n+         if Before > Container.Last + 1 then\n+            raise Constraint_Error with\n+              \"Before index is out of range (too large)\";\n+         end if;\n       end if;\n \n       --  We treat inserting 0 items into the container as a no-op, even when\n@@ -2472,11 +1936,11 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       --  There are two constraints we need to satisfy. The first constraint is\n       --  that a container cannot have more than Count_Type'Last elements, so\n-      --  we must check the sum of the current length and the insertion\n-      --  count. Note that we cannot simply add these values, because of the\n-      --  possibility of overflow.\n+      --  we must check the sum of the current length and the insertion count.\n+      --  Note: we cannot simply add these values, because of the possibility\n+      --  of overflow.\n \n-      if Old_Length > Count_Type'Last - Count then\n+      if Checks and then Old_Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n@@ -2491,7 +1955,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  compare the new length to the maximum length. If the new length is\n       --  acceptable, then we compute the new last index from that.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          --  We have to handle the case when there might be more values in the\n          --  range of Index_Type than in the range of Count_Type.\n \n@@ -2525,9 +1989,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            if Index_Type'Last - No_Index >=\n-                 Count_Type'Pos (Count_Type'Last)\n-            then\n+            if Index_Type'Last - No_Index >= Count_Type_Last then\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -2584,15 +2046,15 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  an internal array with a last index value greater than\n       --  Index_Type'Last, with no way to index those elements).\n \n-      if New_Length > Max_Length then\n+      if Checks and then New_Length > Max_Length then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n       --  New_Last is the last index value of the items in the container after\n       --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to\n       --  compute its value from the New_Length.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          New_Last := No_Index + Index_Type'Base (New_Length);\n       else\n          New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n@@ -2624,10 +2086,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  Insert checks the count to determine whether it is being called while\n       --  the associated callback procedure is executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       if New_Length <= Container.Elements.EA'Length then\n \n@@ -2646,7 +2105,7 @@ package body Ada.Containers.Indefinite_Vectors is\n                --  their new home. We use the wider of Index_Type'Base and\n                --  Count_Type'Base as the type for intermediate index values.\n \n-               if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+               if Index_Type'Base'Last >= Count_Type_Last then\n                   Index := Before + Index_Type'Base (Count);\n                else\n                   Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n@@ -2692,7 +2151,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  We have computed the length of the new internal array (and this is\n       --  what \"vector capacity\" means), so use that to compute its last index.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          Dst_Last := No_Index + Index_Type'Base (New_Capacity);\n       else\n          Dst_Last :=\n@@ -2722,7 +2181,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  The new items are being inserted before some existing elements,\n             --  so we must slide the existing elements up to their new home.\n \n-            if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+            if Index_Type'Base'Last >= Count_Type_Last then\n                Index := Before + Index_Type'Base (Count);\n             else\n                Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n@@ -2750,7 +2209,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -2766,10 +2225,8 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n-      if Before.Container = null\n-        or else Before.Index > Container.Last\n-      then\n-         if Container.Last = Index_Type'Last then\n+      if Before.Container = null or else Before.Index > Container.Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -2782,7 +2239,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       Insert_Space (Container, Index, Count);\n \n-      Position := Cursor'(Container'Unrestricted_Access, Index);\n+      Position := (Container'Unrestricted_Access, Index);\n    end Insert_Space;\n \n    --------------\n@@ -2802,30 +2259,18 @@ package body Ada.Containers.Indefinite_Vectors is\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-\n-      begin\n-         for Indx in Index_Type'First .. Container.Last loop\n-            Process (Cursor'(Container'Unrestricted_Access, Indx));\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      for Indx in Index_Type'First .. Container.Last loop\n+         Process (Cursor'(Container'Unrestricted_Access, Indx));\n+      end loop;\n    end Iterate;\n \n-   function Iterate (Container : Vector)\n+   function Iterate\n+     (Container : Vector)\n       return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       V : constant Vector_Access := Container'Unrestricted_Access;\n-      B : Natural renames V.Busy;\n-\n    begin\n       --  The value of its Index component influences the behavior of the First\n       --  and Last selector functions of the iterator object. When the Index\n@@ -2842,7 +2287,7 @@ package body Ada.Containers.Indefinite_Vectors is\n            Container => V,\n            Index     => No_Index)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -2852,8 +2297,6 @@ package body Ada.Containers.Indefinite_Vectors is\n       return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       V : constant Vector_Access := Container'Unrestricted_Access;\n-      B : Natural renames V.Busy;\n-\n    begin\n       --  It was formerly the case that when Start = No_Element, the partial\n       --  iterator was defined to behave the same as for a complete iterator,\n@@ -2866,19 +2309,21 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  however, that it is not possible to use a partial iterator to specify\n       --  an empty sequence of items.\n \n-      if Start.Container = null then\n-         raise Constraint_Error with\n-           \"Start position for iterator equals No_Element\";\n-      end if;\n+      if Checks then\n+         if Start.Container = null then\n+            raise Constraint_Error with\n+              \"Start position for iterator equals No_Element\";\n+         end if;\n \n-      if Start.Container /= V then\n-         raise Program_Error with\n-           \"Start cursor of Iterate designates wrong vector\";\n-      end if;\n+         if Start.Container /= V then\n+            raise Program_Error with\n+              \"Start cursor of Iterate designates wrong vector\";\n+         end if;\n \n-      if Start.Index > V.Last then\n-         raise Constraint_Error with\n-           \"Start position for iterator equals No_Element\";\n+         if Start.Index > V.Last then\n+            raise Constraint_Error with\n+              \"Start position for iterator equals No_Element\";\n+         end if;\n       end if;\n \n       --  The value of its Index component influences the behavior of the First\n@@ -2895,7 +2340,7 @@ package body Ada.Containers.Indefinite_Vectors is\n            Container => V,\n            Index     => Start.Index)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -2934,21 +2379,21 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n    end Last;\n \n-   -----------------\n+   ------------------\n    -- Last_Element --\n    ------------------\n \n    function Last_Element (Container : Vector) return Element_Type is\n    begin\n-      if Container.Last = No_Index then\n+      if Checks and then Container.Last = No_Index then\n          raise Constraint_Error with \"Container is empty\";\n       end if;\n \n       declare\n          EA : constant Element_Access :=\n                 Container.Elements.EA (Container.Last);\n       begin\n-         if EA = null then\n+         if Checks and then EA = null then\n             raise Constraint_Error with \"last element is empty\";\n          else\n             return EA.all;\n@@ -3012,10 +2457,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (Source is busy)\";\n-      end if;\n+      TC_Check (Source.TC);\n \n       Clear (Target);  --  Checks busy-bit\n \n@@ -3049,7 +2491,7 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      elsif Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong vector\";\n       else\n@@ -3090,17 +2532,6 @@ package body Ada.Containers.Indefinite_Vectors is\n    -- Previous --\n    --------------\n \n-   procedure Previous (Position : in out Cursor) is\n-   begin\n-      if Position.Container = null then\n-         return;\n-      elsif Position.Index > Index_Type'First then\n-         Position.Index := Position.Index - 1;\n-      else\n-         Position := No_Element;\n-      end if;\n-   end Previous;\n-\n    function Previous (Position : Cursor) return Cursor is\n    begin\n       if Position.Container = null then\n@@ -3116,14 +2547,39 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      elsif Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong vector\";\n       else\n          return Previous (Position);\n       end if;\n    end Previous;\n \n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+      if Position.Container = null then\n+         return;\n+      elsif Position.Index > Index_Type'First then\n+         Position.Index := Position.Index - 1;\n+      else\n+         Position := No_Element;\n+      end if;\n+   end Previous;\n+\n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Vector'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access := Container.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -3133,41 +2589,27 @@ package body Ada.Containers.Indefinite_Vectors is\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : Element_Type))\n    is\n+      Lock : With_Lock (Container.TC'Unrestricted_Access);\n       V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Busy;\n-      L : Natural renames V.Lock;\n \n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      if V.Elements.EA (Index) = null then\n+      if Checks and then V.Elements.EA (Index) = null then\n          raise Constraint_Error with \"element is null\";\n       end if;\n \n-      B := B + 1;\n-      L := L + 1;\n-\n-      begin\n-         Process (V.Elements.EA (Index).all);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      L := L - 1;\n-      B := B - 1;\n+      Process (V.Elements.EA (Index).all);\n    end Query_Element;\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       else\n          Query_Element (Position.Container.all, Position.Index, Process);\n@@ -3241,72 +2683,70 @@ package body Ada.Containers.Indefinite_Vectors is\n      (Container : aliased in out Vector;\n       Position  : Cursor) return Reference_Type\n    is\n-      E : Element_Access;\n-\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor denotes wrong container\";\n-      end if;\n-\n-      if Position.Index > Position.Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n-      end if;\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n \n-      E := Container.Elements.EA (Position.Index);\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n+         end if;\n \n-      if E = null then\n-         raise Constraint_Error with \"element at Position is empty\";\n+         if Position.Index > Position.Container.Last then\n+            raise Constraint_Error with \"Position cursor is out of range\";\n+         end if;\n       end if;\n \n-      declare\n-         C : Vector renames Container'Unrestricted_Access.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-      begin\n+      if T_Check then\n+         declare\n+            TC : constant Tamper_Counts_Access :=\n+              Container.TC'Unrestricted_Access;\n+         begin\n+            --  The following will raise Constraint_Error if Element is null\n+\n+            return R : constant Reference_Type :=\n+              (Element => Container.Elements.EA (Position.Index),\n+               Control => (Controlled with TC))\n+            do\n+               Lock (TC.all);\n+            end return;\n+         end;\n+      else\n          return R : constant Reference_Type :=\n-           (Element => E.all'Access,\n-            Control => (Controlled with Position.Container))\n-         do\n-            B := B + 1;\n-            L := L + 1;\n-         end return;\n-      end;\n+           (Element => Container.Elements.EA (Position.Index),\n+            Control => (Controlled with null));\n+      end if;\n    end Reference;\n \n    function Reference\n      (Container : aliased in out Vector;\n       Index     : Index_Type) return Reference_Type\n    is\n-      E : Element_Access;\n-\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      E := Container.Elements.EA (Index);\n-\n-      if E = null then\n-         raise Constraint_Error with \"element at Index is empty\";\n-      end if;\n-\n-      declare\n-         C : Vector renames Container'Unrestricted_Access.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-      begin\n+      if T_Check then\n+         declare\n+            TC : constant Tamper_Counts_Access :=\n+              Container.TC'Unrestricted_Access;\n+         begin\n+            --  The following will raise Constraint_Error if Element is null\n+\n+            return R : constant Reference_Type :=\n+              (Element => Container.Elements.EA (Index),\n+               Control => (Controlled with TC))\n+            do\n+               Lock (TC.all);\n+            end return;\n+         end;\n+      else\n          return R : constant Reference_Type :=\n-           (Element => E.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n-         do\n-            B := B + 1;\n-            L := L + 1;\n-         end return;\n-      end;\n+           (Element => Container.Elements.EA (Index),\n+            Control => (Controlled with null));\n+      end if;\n    end Reference;\n \n    ---------------------\n@@ -3319,14 +2759,11 @@ package body Ada.Containers.Indefinite_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       declare\n          X : Element_Access := Container.Elements.EA (Index);\n@@ -3349,22 +2786,21 @@ package body Ada.Containers.Indefinite_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor denotes wrong container\";\n-      end if;\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n+         end if;\n \n-      if Position.Index > Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n+         if Position.Index > Container.Last then\n+            raise Constraint_Error with \"Position cursor is out of range\";\n+         end if;\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       declare\n          X : Element_Access := Container.Elements.EA (Position.Index);\n@@ -3442,10 +2878,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  so this is the best we can do with respect to minimizing\n             --  storage).\n \n-            if Container.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with cursors (vector is busy)\";\n-            end if;\n+            TC_Check (Container.TC);\n \n             declare\n                subtype Array_Index_Subtype is Index_Type'Base range\n@@ -3485,7 +2918,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  the Last index value of the new internal array, in a way that avoids\n       --  any possibility of overflow.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n \n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n@@ -3498,7 +2931,9 @@ package body Ada.Containers.Indefinite_Vectors is\n          --  Which can rewrite as:\n          --    No_Index <= Last - Length\n \n-         if Index_Type'Base'Last - Index_Type'Base (Capacity) < No_Index then\n+         if Checks and then\n+           Index_Type'Base'Last - Index_Type'Base (Capacity) < No_Index\n+         then\n             raise Constraint_Error with \"Capacity is out of range\";\n          end if;\n \n@@ -3510,7 +2945,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          --  Finally we test whether the value is within the range of the\n          --  generic actual index subtype:\n \n-         if Last > Index_Type'Last then\n+         if Checks and then Last > Index_Type'Last then\n             raise Constraint_Error with \"Capacity is out of range\";\n          end if;\n \n@@ -3522,7 +2957,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          Index := Count_Type'Base (No_Index) + Capacity;  -- Last\n \n-         if Index > Count_Type'Base (Index_Type'Last) then\n+         if Checks and then Index > Count_Type'Base (Index_Type'Last) then\n             raise Constraint_Error with \"Capacity is out of range\";\n          end if;\n \n@@ -3539,7 +2974,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          Index := Count_Type'Base (Index_Type'Last) - Capacity;  -- No_Index\n \n-         if Index < Count_Type'Base (No_Index) then\n+         if Checks and then Index < Count_Type'Base (No_Index) then\n             raise Constraint_Error with \"Capacity is out of range\";\n          end if;\n \n@@ -3578,10 +3013,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  internal array having a length that exactly matches the number\n             --  of items in the container.\n \n-            if Container.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with cursors (vector is busy)\";\n-            end if;\n+            TC_Check (Container.TC);\n \n             declare\n                subtype Array_Index_Subtype is Index_Type'Base range\n@@ -3634,10 +3066,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  number of active elements in the container.) We must check whether\n       --  the container is busy before doing anything else.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  We now allocate a new internal array, having a length different from\n       --  its current value.\n@@ -3689,10 +3118,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  implementation. Logically Reverse_Elements requires a check for\n       --  cursor tampering.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       declare\n          I : Index_Type;\n@@ -3729,55 +3155,32 @@ package body Ada.Containers.Indefinite_Vectors is\n       Last : Index_Type'Base;\n \n    begin\n-      if Position.Container /= null\n+      if Checks and then Position.Container /= null\n         and then Position.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n-      if Position.Container = null or else Position.Index > Container.Last then\n-         Last := Container.Last;\n-      else\n-         Last := Position.Index;\n-      end if;\n+      Last :=\n+        (if Position.Container = null or else Position.Index > Container.Last\n+         then Container.Last\n+         else Position.Index);\n \n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Index_Type'Base;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Result := No_Index;\n          for Indx in reverse Index_Type'First .. Last loop\n             if Container.Elements.EA (Indx) /= null\n               and then Container.Elements.EA (Indx).all = Item\n             then\n-               Result := Indx;\n-               exit;\n+               return Cursor'(Container'Unrestricted_Access, Indx);\n             end if;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = No_Index then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-            raise;\n+         return No_Element;\n       end;\n    end Reverse_Find;\n \n@@ -3790,41 +3193,24 @@ package body Ada.Containers.Indefinite_Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index\n    is\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-      L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-      Last : constant Index_Type'Base :=\n-        (if Index > Container.Last then Container.Last else Index);\n-\n-      Result : Index_Type'Base;\n-\n-   begin\n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n-      B := B + 1;\n-      L := L + 1;\n+      Lock : With_Lock (Container.TC'Unrestricted_Access);\n+\n+      Last : constant Index_Type'Base :=\n+        Index_Type'Min (Container.Last, Index);\n \n-      Result := No_Index;\n+   begin\n       for Indx in reverse Index_Type'First .. Last loop\n          if Container.Elements.EA (Indx) /= null\n            and then Container.Elements.EA (Indx).all = Item\n          then\n-            Result := Indx;\n-            exit;\n+            return Indx;\n          end if;\n       end loop;\n \n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-         raise;\n+      return No_Index;\n    end Reverse_Find_Index;\n \n    ---------------------\n@@ -3835,33 +3221,18 @@ package body Ada.Containers.Indefinite_Vectors is\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Busy;\n-\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-\n-      begin\n-         for Indx in reverse Index_Type'First .. Container.Last loop\n-            Process (Cursor'(Container'Unrestricted_Access, Indx));\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      for Indx in reverse Index_Type'First .. Container.Last loop\n+         Process (Cursor'(Container'Unrestricted_Access, Indx));\n+      end loop;\n    end Reverse_Iterate;\n \n    ----------------\n    -- Set_Length --\n    ----------------\n \n-   procedure Set_Length\n-     (Container : in out Vector;\n-      Length    : Count_Type)\n-   is\n+   procedure Set_Length (Container : in out Vector; Length : Count_Type) is\n       Count : constant Count_Type'Base := Container.Length - Length;\n \n    begin\n@@ -3875,7 +3246,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Count >= 0 then\n          Container.Delete_Last (Count);\n \n-      elsif Container.Last >= Index_Type'Last then\n+      elsif Checks and then Container.Last >= Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n \n       else\n@@ -3887,27 +3258,23 @@ package body Ada.Containers.Indefinite_Vectors is\n    -- Swap --\n    ----------\n \n-   procedure Swap\n-     (Container : in out Vector;\n-      I, J      : Index_Type)\n-   is\n+   procedure Swap (Container : in out Vector; I, J : Index_Type) is\n    begin\n-      if I > Container.Last then\n-         raise Constraint_Error with \"I index is out of range\";\n-      end if;\n+      if Checks then\n+         if I > Container.Last then\n+            raise Constraint_Error with \"I index is out of range\";\n+         end if;\n \n-      if J > Container.Last then\n-         raise Constraint_Error with \"J index is out of range\";\n+         if J > Container.Last then\n+            raise Constraint_Error with \"J index is out of range\";\n+         end if;\n       end if;\n \n       if I = J then\n          return;\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       declare\n          EI : Element_Access renames Container.Elements.EA (I);\n@@ -3926,20 +3293,22 @@ package body Ada.Containers.Indefinite_Vectors is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Container = null then\n-         raise Constraint_Error with \"I cursor has no element\";\n-      end if;\n+      if Checks then\n+         if I.Container = null then\n+            raise Constraint_Error with \"I cursor has no element\";\n+         end if;\n \n-      if J.Container = null then\n-         raise Constraint_Error with \"J cursor has no element\";\n-      end if;\n+         if J.Container = null then\n+            raise Constraint_Error with \"J cursor has no element\";\n+         end if;\n \n-      if I.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"I cursor denotes wrong container\";\n-      end if;\n+         if I.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"I cursor denotes wrong container\";\n+         end if;\n \n-      if J.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"J cursor denotes wrong container\";\n+         if J.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"J cursor denotes wrong container\";\n+         end if;\n       end if;\n \n       Swap (Container, I.Index, J.Index);\n@@ -3997,7 +3366,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  index).  We must therefore check whether the specified Length would\n       --  create a Last index value greater than Index_Type'Last.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n \n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n@@ -4010,7 +3379,9 @@ package body Ada.Containers.Indefinite_Vectors is\n          --  Which can rewrite as:\n          --    No_Index <= Last - Length\n \n-         if Index_Type'Base'Last - Index_Type'Base (Length) < No_Index then\n+         if Checks and then\n+           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index\n+         then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -4022,7 +3393,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          --  Finally we test whether the value is within the range of the\n          --  generic actual index subtype:\n \n-         if Last > Index_Type'Last then\n+         if Checks and then Last > Index_Type'Last then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -4034,7 +3405,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          Index := Count_Type'Base (No_Index) + Length;  -- Last\n \n-         if Index > Count_Type'Base (Index_Type'Last) then\n+         if Checks and then Index > Count_Type'Base (Index_Type'Last) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -4051,7 +3422,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index\n \n-         if Index < Count_Type'Base (No_Index) then\n+         if Checks and then Index < Count_Type'Base (No_Index) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -4064,7 +3435,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       Elements := new Elements_Type (Last);\n \n-      return Vector'(Controlled with Elements, Last, 0, 0);\n+      return Vector'(Controlled with Elements, Last, TC => <>);\n    end To_Vector;\n \n    function To_Vector\n@@ -4087,7 +3458,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  index). We must therefore check whether the specified Length would\n       --  create a Last index value greater than Index_Type'Last.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n \n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n@@ -4100,7 +3471,9 @@ package body Ada.Containers.Indefinite_Vectors is\n          --  Which can rewrite as:\n          --    No_Index <= Last - Length\n \n-         if Index_Type'Base'Last - Index_Type'Base (Length) < No_Index then\n+         if Checks and then\n+           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index\n+         then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -4112,7 +3485,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          --  Finally we test whether the value is within the range of the\n          --  generic actual index subtype:\n \n-         if Last > Index_Type'Last then\n+         if Checks and then Last > Index_Type'Last then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -4124,7 +3497,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          Index := Count_Type'Base (No_Index) + Length;  -- Last\n \n-         if Index > Count_Type'Base (Index_Type'Last) then\n+         if Checks and then Index > Count_Type'Base (Index_Type'Last) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -4141,7 +3514,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index\n \n-         if Index < Count_Type'Base (No_Index) then\n+         if Checks and then Index < Count_Type'Base (No_Index) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -4191,7 +3564,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             raise;\n       end;\n \n-      return (Controlled with Elements, Last, 0, 0);\n+      return (Controlled with Elements, Last, TC => <>);\n    end To_Vector;\n \n    --------------------\n@@ -4203,32 +3576,17 @@ package body Ada.Containers.Indefinite_Vectors is\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n-      B : Natural renames Container.Busy;\n-      L : Natural renames Container.Lock;\n-\n+      Lock : With_Lock (Container.TC'Unchecked_Access);\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      if Container.Elements.EA (Index) = null then\n+      if Checks and then Container.Elements.EA (Index) = null then\n          raise Constraint_Error with \"element is null\";\n       end if;\n \n-      B := B + 1;\n-      L := L + 1;\n-\n-      begin\n-         Process (Container.Elements.EA (Index).all);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      L := L - 1;\n-      B := B - 1;\n+      Process (Container.Elements.EA (Index).all);\n    end Update_Element;\n \n    procedure Update_Element\n@@ -4237,15 +3595,15 @@ package body Ada.Containers.Indefinite_Vectors is\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-\n-      elsif Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor denotes wrong container\";\n-\n-      else\n-         Update_Element (Container, Position.Index, Process);\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         elsif Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n+         end if;\n       end if;\n+\n+      Update_Element (Container, Position.Index, Process);\n    end Update_Element;\n \n    -----------"}, {"sha": "978b49a455ae9755f4abf107ba0015ddc08de7a7", "filename": "gcc/ada/a-coinve.ads", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-coinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-coinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.ads?ref=e9f97e793186e04e2a69ef8dc15073b530f2851f", "patch": "@@ -343,6 +343,7 @@ package Ada.Containers.Indefinite_Vectors is\n \n private\n \n+   pragma Inline (Append);\n    pragma Inline (First_Index);\n    pragma Inline (Last_Index);\n    pragma Inline (Element);\n@@ -351,35 +352,37 @@ private\n    pragma Inline (Query_Element);\n    pragma Inline (Update_Element);\n    pragma Inline (Replace_Element);\n+   pragma Inline (Is_Empty);\n    pragma Inline (Contains);\n    pragma Inline (Next);\n    pragma Inline (Previous);\n \n+   package Implementation is new Generic_Implementation;\n+   use Implementation;\n+\n    type Element_Access is access Element_Type;\n \n    type Elements_Array is array (Index_Type range <>) of Element_Access;\n    function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n-   type Elements_Type (Last : Index_Type) is limited record\n+   type Elements_Type (Last : Extended_Index) is limited record\n       EA : Elements_Array (Index_Type'First .. Last);\n    end record;\n \n-   type Elements_Access is access Elements_Type;\n+   type Elements_Access is access all Elements_Type;\n+\n+   use Finalization;\n+   use Streams;\n \n-   type Vector is new Ada.Finalization.Controlled with record\n-      Elements : Elements_Access;\n+   type Vector is new Controlled with record\n+      Elements : Elements_Access := null;\n       Last     : Extended_Index := No_Index;\n-      Busy     : Natural := 0;\n-      Lock     : Natural := 0;\n+      TC       : aliased Tamper_Counts;\n    end record;\n \n    overriding procedure Adjust (Container : in out Vector);\n-\n    overriding procedure Finalize (Container : in out Vector);\n \n-   use Ada.Finalization;\n-   use Ada.Streams;\n-\n    procedure Write\n      (Stream    : not null access Root_Stream_Type'Class;\n       Container : Vector);\n@@ -412,16 +415,8 @@ private\n \n    for Cursor'Write use Write;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : Vector_Access;\n-      end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -467,16 +462,33 @@ private\n \n    for Reference_Type'Read use Read;\n \n-   Empty_Vector : constant Vector := (Controlled with null, No_Index, 0, 0);\n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Exp_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Vector'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n \n    No_Element : constant Cursor := Cursor'(null, Index_Type'First);\n \n+   Empty_Vector : constant Vector := (Controlled with others => <>);\n+\n    type Iterator is new Limited_Controlled and\n      Vector_Iterator_Interfaces.Reversible_Iterator with\n    record\n       Container : Vector_Access;\n       Index     : Index_Type'Base;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "404d1f59598ccc8f4418d33db369ee07eb1377af", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=e9f97e793186e04e2a69ef8dc15073b530f2851f", "patch": "@@ -450,9 +450,9 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      --  There are some elements aren't being deleted (the requested count was\n-      --  less than the available count), so we must slide them down to\n-      --  Index. We first calculate the index values of the respective array\n+      --  There are some elements that aren't being deleted (the requested\n+      --  count was less than the available count), so we must slide them down\n+      --  to Index. We first calculate the index values of the respective array\n       --  slices, using the wider of Index_Type'Base and Count_Type'Base as the\n       --  type for intermediate calculations. For the elements that slide down,\n       --  index value New_Last is the last index value of their new home, and\n@@ -583,9 +583,9 @@ package body Ada.Containers.Vectors is\n    begin\n       if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n-      else\n-         return Container.Elements.EA (Index);\n       end if;\n+\n+      return Container.Elements.EA (Index);\n    end Element;\n \n    function Element (Position : Cursor) return Element_Type is\n@@ -692,9 +692,9 @@ package body Ada.Containers.Vectors is\n    begin\n       if Is_Empty (Container) then\n          return No_Element;\n-      else\n-         return (Container'Unrestricted_Access, Index_Type'First);\n       end if;\n+\n+      return (Container'Unrestricted_Access, Index_Type'First);\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n@@ -1030,7 +1030,6 @@ package body Ada.Containers.Vectors is\n             --  handled above).\n \n             if Index_Type'Last - No_Index >= Count_Type_Last then\n-\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -1655,7 +1654,6 @@ package body Ada.Containers.Vectors is\n       --  acceptable, then we compute the new last index from that.\n \n       if Index_Type'Base'Last >= Count_Type_Last then\n-\n          --  We have to handle the case when there might be more values in the\n          --  range of Index_Type than in the range of Count_Type.\n \n@@ -1690,7 +1688,6 @@ package body Ada.Containers.Vectors is\n             --  handled above).\n \n             if Index_Type'Last - No_Index >= Count_Type_Last then\n-\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -1965,7 +1962,7 @@ package body Ada.Containers.Vectors is\n          Index := Before.Index;\n       end if;\n \n-      Insert_Space (Container, Index, Count => Count);\n+      Insert_Space (Container, Index, Count);\n \n       Position := (Container'Unrestricted_Access, Index);\n    end Insert_Space;\n@@ -2022,7 +2019,7 @@ package body Ada.Containers.Vectors is\n    function Iterate\n      (Container : Vector;\n       Start     : Cursor)\n-      return Vector_Iterator_Interfaces.Reversible_Iterator'class\n+      return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       V : constant Vector_Access := Container'Unrestricted_Access;\n    begin\n@@ -2911,6 +2908,7 @@ package body Ada.Containers.Vectors is\n    ---------------------\n    -- Reverse_Iterate --\n    ---------------------\n+\n    procedure Reverse_Iterate\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor))\n@@ -3119,7 +3117,7 @@ package body Ada.Containers.Vectors is\n \n       Elements := new Elements_Type (Last);\n \n-      return Vector'(Controlled with Elements, Last, others => <>);\n+      return Vector'(Controlled with Elements, Last, TC => <>);\n    end To_Vector;\n \n    function To_Vector\n@@ -3211,7 +3209,7 @@ package body Ada.Containers.Vectors is\n \n       Elements := new Elements_Type'(Last, EA => (others => New_Item));\n \n-      return Vector'(Controlled with Elements, Last, others => <>);\n+      return (Controlled with Elements, Last, TC => <>);\n    end To_Vector;\n \n    --------------------"}, {"sha": "f19af2e0311f7f7899d6eb5faf7a5fb26be25e6c", "filename": "gcc/ada/a-convec.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=e9f97e793186e04e2a69ef8dc15073b530f2851f", "patch": "@@ -487,7 +487,7 @@ private\n      (Position : Cursor) return not null Element_Access;\n    --  Returns a pointer to the element designated by Position.\n \n-   No_Element   : constant Cursor := Cursor'(null, Index_Type'First);\n+   No_Element : constant Cursor := Cursor'(null, Index_Type'First);\n \n    Empty_Vector : constant Vector := (Controlled with others => <>);\n "}, {"sha": "3d6e45bcf6d465de391f115d29834b07885b3b5f", "filename": "gcc/ada/a-finali.adb", "status": "modified", "additions": 5, "deletions": 45, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-finali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-finali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-finali.adb?ref=e9f97e793186e04e2a69ef8dc15073b530f2851f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,48 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body Ada.Finalization is\n+--  This package does not require a body. We provide a dummy file containing a\n+--  No_Body pragma so that previous versions of the body (which did exist) will\n+--  not interfere.\n \n-   ------------\n-   -- Adjust --\n-   ------------\n-\n-   procedure Adjust (Object : in out Controlled) is\n-      pragma Warnings (Off, Object);\n-   begin\n-      null;\n-   end Adjust;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (Object : in out Controlled) is\n-      pragma Warnings (Off, Object);\n-   begin\n-      null;\n-   end Finalize;\n-\n-   procedure Finalize (Object : in out Limited_Controlled) is\n-      pragma Warnings (Off, Object);\n-   begin\n-      null;\n-   end Finalize;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (Object : in out Controlled) is\n-      pragma Warnings (Off, Object);\n-   begin\n-      null;\n-   end Initialize;\n-\n-   procedure Initialize (Object : in out Limited_Controlled) is\n-      pragma Warnings (Off, Object);\n-   begin\n-      null;\n-   end Initialize;\n-\n-end Ada.Finalization;\n+pragma No_Body;"}, {"sha": "a1f420efc91b508a87414d1c6ad01ab3b8a0ae40", "filename": "gcc/ada/a-finali.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-finali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fa-finali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-finali.ads?ref=e9f97e793186e04e2a69ef8dc15073b530f2851f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -43,15 +43,15 @@ package Ada.Finalization is\n    type Controlled is abstract tagged private;\n    pragma Preelaborable_Initialization (Controlled);\n \n-   procedure Initialize (Object : in out Controlled);\n-   procedure Adjust     (Object : in out Controlled);\n-   procedure Finalize   (Object : in out Controlled);\n+   procedure Initialize (Object : in out Controlled) is null;\n+   procedure Adjust     (Object : in out Controlled) is null;\n+   procedure Finalize   (Object : in out Controlled) is null;\n \n    type Limited_Controlled is abstract tagged limited private;\n    pragma Preelaborable_Initialization (Limited_Controlled);\n \n-   procedure Initialize (Object : in out Limited_Controlled);\n-   procedure Finalize   (Object : in out Limited_Controlled);\n+   procedure Initialize (Object : in out Limited_Controlled) is null;\n+   procedure Finalize   (Object : in out Limited_Controlled) is null;\n \n private\n    package SFR renames System.Finalization_Root;"}, {"sha": "7ef0c10aae6b69e2915f09c5512f3b22ff1a679d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9f97e793186e04e2a69ef8dc15073b530f2851f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e9f97e793186e04e2a69ef8dc15073b530f2851f", "patch": "@@ -2036,8 +2036,8 @@ package body Sem_Ch13 is\n                      Analyze_And_Resolve (Expr, Standard_Integer);\n \n                      --  Interrupt_Priority aspect not allowed for main\n-                     --  subprograms. ARM D.1 does not forbid this explicitly,\n-                     --  but ARM J.15.11 (6/3) does not permit pragma\n+                     --  subprograms. RM D.1 does not forbid this explicitly,\n+                     --  but RM J.15.11(6/3) does not permit pragma\n                      --  Interrupt_Priority for subprograms.\n \n                      if A_Id = Aspect_Interrupt_Priority then\n@@ -2060,7 +2060,7 @@ package body Sem_Ch13 is\n                                       (Specification (N)))\n                        or else not Is_Compilation_Unit (Defining_Entity (N))\n                      then\n-                        --  See ARM D.1 (14/3) and D.16 (12/3)\n+                        --  See RM D.1(14/3) and D.16(12/3)\n \n                         Error_Msg_N\n                           (\"aspect applied to subprogram other than the \"\n@@ -11419,9 +11419,20 @@ package body Sem_Ch13 is\n          declare\n             Id : constant Attribute_Id := Get_Attribute_Id (Chars (N));\n          begin\n-            return    Id = Attribute_Input\n+\n+            --  List of operational items is given in RM 13.1(8.mm/1).\n+            --  It is clearly incomplete, as it does not include iterator\n+            --  aspects, among others.\n+\n+            return    Id = Attribute_Constant_Indexing\n+              or else Id = Attribute_Default_Iterator\n+              or else Id = Attribute_Implicit_Dereference\n+              or else Id = Attribute_Input\n+              or else Id = Attribute_Iterator_Element\n+              or else Id = Attribute_Iterable\n               or else Id = Attribute_Output\n               or else Id = Attribute_Read\n+              or else Id = Attribute_Variable_Indexing\n               or else Id = Attribute_Write\n               or else Id = Attribute_External_Tag;\n          end;"}]}