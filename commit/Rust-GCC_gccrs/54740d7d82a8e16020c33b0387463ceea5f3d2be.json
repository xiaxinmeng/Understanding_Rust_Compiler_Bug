{"sha": "54740d7d82a8e16020c33b0387463ceea5f3d2be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ3NDBkN2Q4MmE4ZTE2MDIwYzMzYjAzODc0NjNjZWVhNWYzZDJiZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-19T12:04:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-19T12:04:13Z"}, "message": "[multiple changes]\n\n2017-01-19  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_aggr.adb (Pass_Aggregate_To_Back_End): Renamed as\n\tBuild_Back_End_Aggregate.\n\t(Generate_Aggregate_For_Derived_Type): Code cleanup.\n\t(Prepend_Stored_Values): Code cleanup.\n\n2017-01-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): Check for an\n\tincomplete return type after attempting to freeze it, so that\n\tother freeze actiona are generated in the proper order.\n\n2017-01-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Aggregate): If the type is a string\n\ttype, ie. a type whose component is a character type, and the\n\taggregate is positional, do not convert into a string literal\n\tif the index type is not an integer type, because the original\n\ttype may be required in an enclosing operation.\n\n2017-01-19  Bob Duff  <duff@adacore.com>\n\n\t* binde.adb, debug.adb: Enable new elaboration order algorithm\n\tby default. -dp switch reverts to the old algorithm.\n\n2017-01-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch3.adb Add with and use clauses for Exp_Ch7.\n\t(Analyze_Declarations): Create the DIC and Invariant\n\tprocedure bodies s after all freezing has taken place.\n\t(Build_Assertion_Bodies): New routine.\n\t* sem_ch7.adb Remove the with and use clauses for Exp_Ch7\n\tand Exp_Util.\n\t(Analyze_Package_Specification): Remove the\n\tgeneration of the DIC and Invariant procedure bodies. This is\n\tnow done by Analyze_Declarations.\n\t* sem_disp.adb (Check_Dispatching_Operation): DIC and Invariant\n\tprocedures are never treated as primitives.\n\n2017-01-19  Yannick Moy  <moy@adacore.com>\n\n\t* frontend.adb: Analyze inlined bodies and check elaboration\n\trules in GNATprove mode too.\n\t* sem_elab.adb (Delay_Element): Add Boolean component to save\n\tindication that call is in SPARK code.\t(Check_Elab_Calls):\n\tCheck elaboration rules in GNATprove mode, and correctly set\n\tthe current value of SPARK_Mode.\n\t* lib-xref-spark_specific.adb\n\t(Add_SPARK_Xrefs): Simplify iteration over dereferences.\n\n2017-01-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenate): Do no enable overflow\n\tchecks on the expression for the high bound of concatenation\n\twhen checks are disabled, to suppress warnings about potential\n\tconstraint errors in restricted runtimes.\n\nFrom-SVN: r244626", "tree": {"sha": "c57a88b8dbf25eac04f0d76890f3955e7a51ac6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c57a88b8dbf25eac04f0d76890f3955e7a51ac6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54740d7d82a8e16020c33b0387463ceea5f3d2be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54740d7d82a8e16020c33b0387463ceea5f3d2be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54740d7d82a8e16020c33b0387463ceea5f3d2be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54740d7d82a8e16020c33b0387463ceea5f3d2be/comments", "author": null, "committer": null, "parents": [{"sha": "138fc6f10fc6b0b66123a75dfe88b1641cba5e9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/138fc6f10fc6b0b66123a75dfe88b1641cba5e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/138fc6f10fc6b0b66123a75dfe88b1641cba5e9d"}], "stats": {"total": 806, "additions": 486, "deletions": 320}, "files": [{"sha": "375f02bf02bc10cc7492e438ae7899d72bce3f37", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -1,3 +1,61 @@\n+2017-01-19  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_aggr.adb (Pass_Aggregate_To_Back_End): Renamed as\n+\tBuild_Back_End_Aggregate.\n+\t(Generate_Aggregate_For_Derived_Type): Code cleanup.\n+\t(Prepend_Stored_Values): Code cleanup.\n+\n+2017-01-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): Check for an\n+\tincomplete return type after attempting to freeze it, so that\n+\tother freeze actiona are generated in the proper order.\n+\n+2017-01-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Aggregate): If the type is a string\n+\ttype, ie. a type whose component is a character type, and the\n+\taggregate is positional, do not convert into a string literal\n+\tif the index type is not an integer type, because the original\n+\ttype may be required in an enclosing operation.\n+\n+2017-01-19  Bob Duff  <duff@adacore.com>\n+\n+\t* binde.adb, debug.adb: Enable new elaboration order algorithm\n+\tby default. -dp switch reverts to the old algorithm.\n+\n+2017-01-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch3.adb Add with and use clauses for Exp_Ch7.\n+\t(Analyze_Declarations): Create the DIC and Invariant\n+\tprocedure bodies s after all freezing has taken place.\n+\t(Build_Assertion_Bodies): New routine.\n+\t* sem_ch7.adb Remove the with and use clauses for Exp_Ch7\n+\tand Exp_Util.\n+\t(Analyze_Package_Specification): Remove the\n+\tgeneration of the DIC and Invariant procedure bodies. This is\n+\tnow done by Analyze_Declarations.\n+\t* sem_disp.adb (Check_Dispatching_Operation): DIC and Invariant\n+\tprocedures are never treated as primitives.\n+\n+2017-01-19  Yannick Moy  <moy@adacore.com>\n+\n+\t* frontend.adb: Analyze inlined bodies and check elaboration\n+\trules in GNATprove mode too.\n+\t* sem_elab.adb (Delay_Element): Add Boolean component to save\n+\tindication that call is in SPARK code.\t(Check_Elab_Calls):\n+\tCheck elaboration rules in GNATprove mode, and correctly set\n+\tthe current value of SPARK_Mode.\n+\t* lib-xref-spark_specific.adb\n+\t(Add_SPARK_Xrefs): Simplify iteration over dereferences.\n+\n+2017-01-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Concatenate): Do no enable overflow\n+\tchecks on the expression for the high bound of concatenation\n+\twhen checks are disabled, to suppress warnings about potential\n+\tconstraint errors in restricted runtimes.\n+\n 2017-01-19  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch3.adb (Expand_Freeze_Enumeration_Type): Mark the"}, {"sha": "2becc1b43b1d4a456f527738885355bfcb3805d5", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -37,8 +37,7 @@ with System.OS_Lib;\n \n package body Binde is\n \n-   --  We now have Elab_New, a new elaboration-order algorithm. It has the\n-   --  property that ???\n+   --  We now have Elab_New, a new elaboration-order algorithm.\n    --\n    --  However, any change to elaboration order can break some programs.\n    --  Therefore, we are keeping the old algorithm in place, to be selected\n@@ -289,7 +288,12 @@ package body Binde is\n \n    function Debug_Flag_Older return Boolean;\n    function Debug_Flag_Old return Boolean;\n-   --  True if debug flags select the old or older algorithms\n+   --  True if debug flags select the old or older algorithms. Pretty much any\n+   --  change to elaboration order can break some programs. For example,\n+   --  programs can depend on elaboration order even without failing\n+   --  access-before-elaboration checks. A trivial example is a program that\n+   --  prints text during elaboration. Therefore, we have flags to revert to\n+   --  the old(er) algorithms.\n \n    procedure Validate (Order : Unit_Id_Array; Doing_New : Boolean);\n    --  Assert that certain properties are true\n@@ -1134,10 +1138,7 @@ package body Binde is\n \n    function Debug_Flag_Old return Boolean is\n    begin\n-      --  For now, Debug_Flag_P means \"use the new algorithm\". Once it is\n-      --  stable, we intend to remove the \"not\" below.\n-\n-      return not Debug_Flag_P;\n+      return Debug_Flag_P;\n    end Debug_Flag_Old;\n \n    ----------------------"}, {"sha": "70dfdc8b910fb721f9c2cd7e79143e095268bf8e", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -182,7 +182,7 @@ package body Debug is\n    --  dm\n    --  dn  List details of manipulation of Num_Pred values\n    --  do  Use older preference for elaboration order\n-   --  dp  Use new preference for elaboration order\n+   --  dp  Use old preference for elaboration order\n    --  dq\n    --  dr\n    --  ds\n@@ -813,16 +813,15 @@ package body Debug is\n    --      prefer specs with no bodies to specs with bodies, and between two\n    --      specs with bodies, prefers the one whose body is closer to being\n    --      able to be elaborated. This is a clear improvement, but we provide\n-   --      this debug flag in case of regressions.\n+   --      this debug flag in case of regressions. Note: -do is even older than\n+   --      -dp.\n \n-   --  dp  Use new elaboration order preference. The new preference rules\n+   --  dp  Use old elaboration order preference. The new preference rules\n    --      elaborate all units within a strongly connected component together,\n    --      with no other units in between. In particular, if a spec/body pair\n    --      can be elaborated together, it will be. In the new order, the binder\n    --      behaves as if every pragma Elaborate_All that would be legal is\n-   --      present, even if it does not appear in the source code. NOTE: We\n-   --      intend to reverse the sense of this switch at some point, so the new\n-   --      preference is the default.\n+   --      present, even if it does not appear in the source code.\n \n    --  du  List unit name and file name for each unit as it is read in\n "}, {"sha": "9da35ddb9c2e6a418e2c72cccce3d27f28928793", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 229, "deletions": 218, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -6507,6 +6507,9 @@ package body Exp_Aggr is\n       --  and the aggregate can be constructed statically and handled by\n       --  the back-end.\n \n+      procedure Build_Back_End_Aggregate;\n+      --  Build a proper aggregate to be handled by the back-end\n+\n       function Compile_Time_Known_Composite_Value (N : Node_Id) return Boolean;\n       --  Returns true if N is an expression of composite type which can be\n       --  fully evaluated at compile time without raising constraint error.\n@@ -6545,192 +6548,15 @@ package body Exp_Aggr is\n       --  because it will not be set when type and its parent are in the\n       --  same scope, and the parent component needs expansion.\n \n-      procedure Pass_Aggregate_To_Back_End;\n-      --  Build a proper aggregate to be handled by the back-end\n-\n       function Top_Level_Aggregate (N : Node_Id) return Node_Id;\n       --  For nested aggregates return the ultimate enclosing aggregate; for\n       --  non-nested aggregates return N.\n \n-      ----------------------------------------\n-      -- Compile_Time_Known_Composite_Value --\n-      ----------------------------------------\n-\n-      function Compile_Time_Known_Composite_Value\n-        (N : Node_Id) return Boolean\n-      is\n-      begin\n-         --  If we have an entity name, then see if it is the name of a\n-         --  constant and if so, test the corresponding constant value.\n-\n-         if Is_Entity_Name (N) then\n-            declare\n-               E : constant Entity_Id := Entity (N);\n-               V : Node_Id;\n-            begin\n-               if Ekind (E) /= E_Constant then\n-                  return False;\n-               else\n-                  V := Constant_Value (E);\n-                  return Present (V)\n-                    and then Compile_Time_Known_Composite_Value (V);\n-               end if;\n-            end;\n-\n-         --  We have a value, see if it is compile time known\n-\n-         else\n-            if Nkind (N) = N_Aggregate then\n-               return Compile_Time_Known_Aggregate (N);\n-            end if;\n-\n-            --  All other types of values are not known at compile time\n-\n-            return False;\n-         end if;\n-\n-      end Compile_Time_Known_Composite_Value;\n+      ------------------------------\n+      -- Build_Back_End_Aggregate --\n+      ------------------------------\n \n-      ----------------------------------\n-      -- Component_Not_OK_For_Backend --\n-      ----------------------------------\n-\n-      function Component_Not_OK_For_Backend return Boolean is\n-         C      : Node_Id;\n-         Expr_Q : Node_Id;\n-\n-      begin\n-         if No (Comps) then\n-            return False;\n-         end if;\n-\n-         C := First (Comps);\n-         while Present (C) loop\n-\n-            --  If the component has box initialization, expansion is needed\n-            --  and component is not ready for backend.\n-\n-            if Box_Present (C) then\n-               return True;\n-            end if;\n-\n-            if Nkind (Expression (C)) = N_Qualified_Expression then\n-               Expr_Q := Expression (Expression (C));\n-            else\n-               Expr_Q := Expression (C);\n-            end if;\n-\n-            --  Return true if the aggregate has any associations for tagged\n-            --  components that may require tag adjustment.\n-\n-            --  These are cases where the source expression may have a tag that\n-            --  could differ from the component tag (e.g., can occur for type\n-            --  conversions and formal parameters). (Tag adjustment not needed\n-            --  if Tagged_Type_Expansion because object tags are implicit in\n-            --  the machine.)\n-\n-            if Is_Tagged_Type (Etype (Expr_Q))\n-              and then (Nkind (Expr_Q) = N_Type_Conversion\n-                         or else (Is_Entity_Name (Expr_Q)\n-                                    and then\n-                                      Ekind (Entity (Expr_Q)) in Formal_Kind))\n-              and then Tagged_Type_Expansion\n-            then\n-               Static_Components := False;\n-               return True;\n-\n-            elsif Is_Delayed_Aggregate (Expr_Q) then\n-               Static_Components := False;\n-               return True;\n-\n-            elsif Possible_Bit_Aligned_Component (Expr_Q) then\n-               Static_Components := False;\n-               return True;\n-\n-            elsif Modify_Tree_For_C\n-              and then Nkind (C) = N_Component_Association\n-              and then Has_Per_Object_Constraint (Choices (C))\n-            then\n-               Static_Components := False;\n-               return True;\n-\n-            elsif Modify_Tree_For_C\n-              and then Nkind (Expr_Q) = N_Identifier\n-              and then Is_Array_Type (Etype (Expr_Q))\n-            then\n-               Static_Components := False;\n-               return True;\n-            end if;\n-\n-            if Is_Elementary_Type (Etype (Expr_Q)) then\n-               if not Compile_Time_Known_Value (Expr_Q) then\n-                  Static_Components := False;\n-               end if;\n-\n-            elsif not Compile_Time_Known_Composite_Value (Expr_Q) then\n-               Static_Components := False;\n-\n-               if Is_Private_Type (Etype (Expr_Q))\n-                 and then Has_Discriminants (Etype (Expr_Q))\n-               then\n-                  return True;\n-               end if;\n-            end if;\n-\n-            Next (C);\n-         end loop;\n-\n-         return False;\n-      end Component_Not_OK_For_Backend;\n-\n-      -------------------------------\n-      -- Has_Per_Object_Constraint --\n-      -------------------------------\n-\n-      function Has_Per_Object_Constraint (L : List_Id) return Boolean is\n-         N : Node_Id := First (L);\n-      begin\n-         while Present (N) loop\n-            if Is_Entity_Name (N)\n-              and then Present (Entity (N))\n-              and then Has_Per_Object_Constraint (Entity (N))\n-            then\n-               return True;\n-            end if;\n-\n-            Next (N);\n-         end loop;\n-\n-         return False;\n-      end Has_Per_Object_Constraint;\n-\n-      -----------------------------------\n-      --  Has_Visible_Private_Ancestor --\n-      -----------------------------------\n-\n-      function Has_Visible_Private_Ancestor (Id : E) return Boolean is\n-         R  : constant Entity_Id := Root_Type (Id);\n-         T1 : Entity_Id := Id;\n-\n-      begin\n-         loop\n-            if Is_Private_Type (T1) then\n-               return True;\n-\n-            elsif T1 = R then\n-               return False;\n-\n-            else\n-               T1 := Etype (T1);\n-            end if;\n-         end loop;\n-      end Has_Visible_Private_Ancestor;\n-\n-      --------------------------------\n-      -- Pass_Aggregate_To_Back_End --\n-      --------------------------------\n-\n-      procedure Pass_Aggregate_To_Back_End is\n+      procedure Build_Back_End_Aggregate is\n          Comp      : Entity_Id;\n          New_Comp  : Node_Id;\n          Tag_Value : Node_Id;\n@@ -6761,13 +6587,6 @@ package body Exp_Aggr is\n             --  describe the type and its components.\n \n             Generate_Aggregate_For_Derived_Type : declare\n-               Constraints  : constant List_Id := New_List;\n-               First_Comp   : Node_Id;\n-               Discriminant : Entity_Id;\n-               Decl         : Node_Id;\n-               Num_Disc     : Nat := 0;\n-               Num_Gird     : Nat := 0;\n-\n                procedure Prepend_Stored_Values (T : Entity_Id);\n                --  Scan the list of stored discriminants of the type, and add\n                --  their values to the aggregate being built.\n@@ -6777,17 +6596,20 @@ package body Exp_Aggr is\n                ---------------------------\n \n                procedure Prepend_Stored_Values (T : Entity_Id) is\n+                  Discr      : Entity_Id;\n+                  First_Comp : Node_Id := Empty;\n+\n                begin\n-                  Discriminant := First_Stored_Discriminant (T);\n-                  while Present (Discriminant) loop\n+                  Discr := First_Stored_Discriminant (T);\n+                  while Present (Discr) loop\n                      New_Comp :=\n                        Make_Component_Association (Loc,\n                          Choices    => New_List (\n-                           New_Occurrence_Of (Discriminant, Loc)),\n+                           New_Occurrence_Of (Discr, Loc)),\n                          Expression =>\n                            New_Copy_Tree\n                              (Get_Discriminant_Value\n-                                (Discriminant,\n+                                (Discr,\n                                  Typ,\n                                  Discriminant_Constraint (Typ))));\n \n@@ -6798,26 +6620,41 @@ package body Exp_Aggr is\n                      end if;\n \n                      First_Comp := New_Comp;\n-                     Next_Stored_Discriminant (Discriminant);\n+                     Next_Stored_Discriminant (Discr);\n                   end loop;\n                end Prepend_Stored_Values;\n \n+               --  Local variables\n+\n+               Constraints : constant List_Id := New_List;\n+\n+               Discr    : Entity_Id;\n+               Decl     : Node_Id;\n+               Num_Disc : Nat := 0;\n+               Num_Gird : Nat := 0;\n+\n             --  Start of processing for Generate_Aggregate_For_Derived_Type\n \n             begin\n                --  Remove the associations for the discriminant of derived type\n \n-               First_Comp := First (Component_Associations (N));\n-               while Present (First_Comp) loop\n-                  Comp := First_Comp;\n-                  Next (First_Comp);\n+               declare\n+                  First_Comp : Node_Id;\n \n-                  if Ekind (Entity (First (Choices (Comp)))) = E_Discriminant\n-                  then\n-                     Remove (Comp);\n-                     Num_Disc := Num_Disc + 1;\n-                  end if;\n-               end loop;\n+               begin\n+                  First_Comp := First (Component_Associations (N));\n+                  while Present (First_Comp) loop\n+                     Comp := First_Comp;\n+                     Next (First_Comp);\n+\n+                     if Ekind (Entity (First (Choices (Comp)))) =\n+                          E_Discriminant\n+                     then\n+                        Remove (Comp);\n+                        Num_Disc := Num_Disc + 1;\n+                     end if;\n+                  end loop;\n+               end;\n \n                --  Insert stored discriminant associations in the correct\n                --  order. If there are more stored discriminants than new\n@@ -6828,12 +6665,10 @@ package body Exp_Aggr is\n                --  components. Otherwise there is one-one correspondence\n                --  between the constraints and the stored discriminants.\n \n-               First_Comp := Empty;\n-\n-               Discriminant := First_Stored_Discriminant (Base_Type (Typ));\n-               while Present (Discriminant) loop\n+               Discr := First_Stored_Discriminant (Base_Type (Typ));\n+               while Present (Discr) loop\n                   Num_Gird := Num_Gird + 1;\n-                  Next_Stored_Discriminant (Discriminant);\n+                  Next_Stored_Discriminant (Discr);\n                end loop;\n \n                --  Case of more stored discriminants than new discriminants\n@@ -6844,17 +6679,17 @@ package body Exp_Aggr is\n                   --  proper implementation type for the aggregate, and convert\n                   --  it to the intended target type.\n \n-                  Discriminant := First_Stored_Discriminant (Base_Type (Typ));\n-                  while Present (Discriminant) loop\n+                  Discr := First_Stored_Discriminant (Base_Type (Typ));\n+                  while Present (Discr) loop\n                      New_Comp :=\n                        New_Copy_Tree\n                          (Get_Discriminant_Value\n-                            (Discriminant,\n+                            (Discr,\n                              Typ,\n                              Discriminant_Constraint (Typ)));\n \n                      Append (New_Comp, Constraints);\n-                     Next_Stored_Discriminant (Discriminant);\n+                     Next_Stored_Discriminant (Discr);\n                   end loop;\n \n                   Decl :=\n@@ -6920,8 +6755,8 @@ package body Exp_Aggr is\n \n                      Append_To (Comps,\n                        Make_Component_Association (Loc,\n-                         Choices    =>\n-                           New_List (New_Occurrence_Of (Comp, Loc)),\n+                         Choices    => New_List (\n+                           New_Occurrence_Of (Comp, Loc)),\n                          Expression => New_Comp));\n \n                      Analyze_And_Resolve (New_Comp, Etype (Comp));\n@@ -6937,8 +6772,10 @@ package body Exp_Aggr is\n \n             if Present (Orig_Tag) then\n                Tag_Value := Orig_Tag;\n+\n             elsif not Tagged_Type_Expansion then\n                Tag_Value := Empty;\n+\n             else\n                Tag_Value :=\n                  New_Occurrence_Of\n@@ -6959,7 +6796,7 @@ package body Exp_Aggr is\n                   --  Remove the inherited component association from the\n                   --  aggregate and store them in the parent aggregate\n \n-                  First_Comp := First (Component_Associations (N));\n+                  First_Comp   := First (Component_Associations (N));\n                   Parent_Comps := New_List;\n                   while Present (First_Comp)\n                     and then\n@@ -7028,7 +6865,181 @@ package body Exp_Aggr is\n                end;\n             end if;\n          end if;\n-      end Pass_Aggregate_To_Back_End;\n+      end Build_Back_End_Aggregate;\n+\n+      ----------------------------------------\n+      -- Compile_Time_Known_Composite_Value --\n+      ----------------------------------------\n+\n+      function Compile_Time_Known_Composite_Value\n+        (N : Node_Id) return Boolean\n+      is\n+      begin\n+         --  If we have an entity name, then see if it is the name of a\n+         --  constant and if so, test the corresponding constant value.\n+\n+         if Is_Entity_Name (N) then\n+            declare\n+               E : constant Entity_Id := Entity (N);\n+               V : Node_Id;\n+            begin\n+               if Ekind (E) /= E_Constant then\n+                  return False;\n+               else\n+                  V := Constant_Value (E);\n+                  return Present (V)\n+                    and then Compile_Time_Known_Composite_Value (V);\n+               end if;\n+            end;\n+\n+         --  We have a value, see if it is compile time known\n+\n+         else\n+            if Nkind (N) = N_Aggregate then\n+               return Compile_Time_Known_Aggregate (N);\n+            end if;\n+\n+            --  All other types of values are not known at compile time\n+\n+            return False;\n+         end if;\n+\n+      end Compile_Time_Known_Composite_Value;\n+\n+      ----------------------------------\n+      -- Component_Not_OK_For_Backend --\n+      ----------------------------------\n+\n+      function Component_Not_OK_For_Backend return Boolean is\n+         C      : Node_Id;\n+         Expr_Q : Node_Id;\n+\n+      begin\n+         if No (Comps) then\n+            return False;\n+         end if;\n+\n+         C := First (Comps);\n+         while Present (C) loop\n+\n+            --  If the component has box initialization, expansion is needed\n+            --  and component is not ready for backend.\n+\n+            if Box_Present (C) then\n+               return True;\n+            end if;\n+\n+            if Nkind (Expression (C)) = N_Qualified_Expression then\n+               Expr_Q := Expression (Expression (C));\n+            else\n+               Expr_Q := Expression (C);\n+            end if;\n+\n+            --  Return true if the aggregate has any associations for tagged\n+            --  components that may require tag adjustment.\n+\n+            --  These are cases where the source expression may have a tag that\n+            --  could differ from the component tag (e.g., can occur for type\n+            --  conversions and formal parameters). (Tag adjustment not needed\n+            --  if Tagged_Type_Expansion because object tags are implicit in\n+            --  the machine.)\n+\n+            if Is_Tagged_Type (Etype (Expr_Q))\n+              and then (Nkind (Expr_Q) = N_Type_Conversion\n+                         or else (Is_Entity_Name (Expr_Q)\n+                                    and then\n+                                      Ekind (Entity (Expr_Q)) in Formal_Kind))\n+              and then Tagged_Type_Expansion\n+            then\n+               Static_Components := False;\n+               return True;\n+\n+            elsif Is_Delayed_Aggregate (Expr_Q) then\n+               Static_Components := False;\n+               return True;\n+\n+            elsif Possible_Bit_Aligned_Component (Expr_Q) then\n+               Static_Components := False;\n+               return True;\n+\n+            elsif Modify_Tree_For_C\n+              and then Nkind (C) = N_Component_Association\n+              and then Has_Per_Object_Constraint (Choices (C))\n+            then\n+               Static_Components := False;\n+               return True;\n+\n+            elsif Modify_Tree_For_C\n+              and then Nkind (Expr_Q) = N_Identifier\n+              and then Is_Array_Type (Etype (Expr_Q))\n+            then\n+               Static_Components := False;\n+               return True;\n+            end if;\n+\n+            if Is_Elementary_Type (Etype (Expr_Q)) then\n+               if not Compile_Time_Known_Value (Expr_Q) then\n+                  Static_Components := False;\n+               end if;\n+\n+            elsif not Compile_Time_Known_Composite_Value (Expr_Q) then\n+               Static_Components := False;\n+\n+               if Is_Private_Type (Etype (Expr_Q))\n+                 and then Has_Discriminants (Etype (Expr_Q))\n+               then\n+                  return True;\n+               end if;\n+            end if;\n+\n+            Next (C);\n+         end loop;\n+\n+         return False;\n+      end Component_Not_OK_For_Backend;\n+\n+      -------------------------------\n+      -- Has_Per_Object_Constraint --\n+      -------------------------------\n+\n+      function Has_Per_Object_Constraint (L : List_Id) return Boolean is\n+         N : Node_Id := First (L);\n+      begin\n+         while Present (N) loop\n+            if Is_Entity_Name (N)\n+              and then Present (Entity (N))\n+              and then Has_Per_Object_Constraint (Entity (N))\n+            then\n+               return True;\n+            end if;\n+\n+            Next (N);\n+         end loop;\n+\n+         return False;\n+      end Has_Per_Object_Constraint;\n+\n+      -----------------------------------\n+      --  Has_Visible_Private_Ancestor --\n+      -----------------------------------\n+\n+      function Has_Visible_Private_Ancestor (Id : E) return Boolean is\n+         R  : constant Entity_Id := Root_Type (Id);\n+         T1 : Entity_Id := Id;\n+\n+      begin\n+         loop\n+            if Is_Private_Type (T1) then\n+               return True;\n+\n+            elsif T1 = R then\n+               return False;\n+\n+            else\n+               T1 := Etype (T1);\n+            end if;\n+         end loop;\n+      end Has_Visible_Private_Ancestor;\n \n       -------------------------\n       -- Top_Level_Aggregate --\n@@ -7101,7 +7112,7 @@ package body Exp_Aggr is\n          --  the back-end\n \n          else\n-            Pass_Aggregate_To_Back_End;\n+            Build_Back_End_Aggregate;\n          end if;\n \n       --  Gigi doesn't properly handle temporaries of variable size so we\n@@ -7178,7 +7189,7 @@ package body Exp_Aggr is\n       --  In all other cases, build a proper aggregate to be handled by gigi\n \n       else\n-         Pass_Aggregate_To_Back_End;\n+         Build_Back_End_Aggregate;\n       end if;\n    end Expand_Record_Aggregate;\n "}, {"sha": "385456764e07ed0568c333dfaac43cd4c452d8d6", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -3286,9 +3286,12 @@ package body Exp_Ch4 is\n       --  very weird cases, so in the general case we need an overflow check on\n       --  the high bound. We can avoid this for the common case of string types\n       --  and other types whose index is Positive, since we chose a wider range\n-      --  for the arithmetic type.\n+      --  for the arithmetic type. If checks are suppressed we do not set the\n+      --  flag, and possibly superfluous warnings will be omitted.\n \n-      if Istyp /= Standard_Positive then\n+      if Istyp /= Standard_Positive\n+        and then not Overflow_Checks_Suppressed (Istyp)\n+      then\n          Activate_Overflow_Check (High_Bound);\n       end if;\n "}, {"sha": "dd79db5cb79a8d9c03fa29ef1fda656e199045b4", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -420,7 +420,10 @@ begin\n             Instantiate_Bodies;\n          end if;\n \n-         if Operating_Mode = Generate_Code then\n+         --  Analyze inlined bodies and check elaboration rules in GNATprove\n+         --  mode as well as during compilation.\n+\n+         if Operating_Mode = Generate_Code or else GNATprove_Mode then\n             if Inline_Processing_Required then\n                Analyze_Inlined_Bodies;\n             end if;"}, {"sha": "14948d505791efa387a2e83da2d8c000e083a9b0", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -701,10 +701,13 @@ package body SPARK_Specific is\n          end;\n       end loop;\n \n-      for Index in Drefs.First .. Drefs.Last loop\n-         Xrefs.Append (Drefs.Table (Index));\n-         Nrefs := Nrefs + 1;\n-      end loop;\n+      declare\n+         Drefs_Table : Drefs.Table_Type\n+           renames Drefs.Table (Drefs.First .. Drefs.Last);\n+      begin\n+         Xrefs.Append_All (Xrefs.Table_Type (Drefs_Table));\n+         Nrefs := Nrefs + Drefs_Table'Length;\n+      end;\n \n       --  Capture the definition Sloc values. As in the case of normal cross\n       --  references, we have to wait until now to get the correct value."}, {"sha": "10ea8a52b67a841f76d1571303ef90b04453c224", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -986,13 +986,16 @@ package body Sem_Aggr is\n \n       elsif Is_Array_Type (Typ) then\n \n-         --  First a special test, for the case of a positional aggregate\n-         --  of characters which can be replaced by a string literal.\n+         --  First a special test, for the case of a positional aggregate of\n+         --  characters which can be replaced by a string literal.\n \n-         --  Do not perform this transformation if this was a string literal to\n-         --  start with, whose components needed constraint checks, or if the\n-         --  component type is non-static, because it will require those checks\n-         --  and be transformed back into an aggregate.\n+         --  Do not perform this transformation if this was a string literal\n+         --  to start with, whose components needed constraint checks, or if\n+         --  the component type is non-static, because it will require those\n+         --  checks and be transformed back into an aggregate. If the index\n+         --  type is not Integer the aggregate may represent a user-defined\n+         --  string type but the context might need the original type so we\n+         --  do not perform the transformation at this point.\n \n          if Number_Dimensions (Typ) = 1\n            and then Is_Standard_Character_Type (Component_Type (Typ))\n@@ -1002,6 +1005,8 @@ package body Sem_Aggr is\n            and then not Is_Bit_Packed_Array (Typ)\n            and then Nkind (Original_Node (Parent (N))) /= N_String_Literal\n            and then Is_OK_Static_Subtype (Component_Type (Typ))\n+           and then Base_Type (Etype (First_Index (Typ))) =\n+                      Base_Type (Standard_Integer)\n          then\n             declare\n                Expr : Node_Id;"}, {"sha": "dbbb25e7f0d0739b775fe34c04ee79053e214cc8", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 103, "deletions": 1, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -33,6 +33,7 @@ with Einfo;     use Einfo;\n with Errout;    use Errout;\n with Eval_Fat;  use Eval_Fat;\n with Exp_Ch3;   use Exp_Ch3;\n+with Exp_Ch7;   use Exp_Ch7;\n with Exp_Ch9;   use Exp_Ch9;\n with Exp_Disp;  use Exp_Disp;\n with Exp_Dist;  use Exp_Dist;\n@@ -2153,6 +2154,17 @@ package body Sem_Ch3 is\n       --  (They have the sloc of the label as found in the source, and that\n       --  is ahead of the current declarative part).\n \n+      procedure Build_Assertion_Bodies (Decls : List_Id; Context : Node_Id);\n+      --  Create the subprogram bodies which verify the run-time semantics of\n+      --  the pragmas listed below for each elibigle type found in declarative\n+      --  list Decls. The pragmas are:\n+      --\n+      --    Default_Initial_Condition\n+      --    Invariant\n+      --    Type_Invariant\n+      --\n+      --  Context denotes the owner of the declarative list.\n+\n       procedure Check_Entry_Contracts;\n       --  Perform a pre-analysis of the pre- and postconditions of an entry\n       --  declaration. This must be done before full resolution and creation\n@@ -2195,6 +2207,85 @@ package body Sem_Ch3 is\n          end loop;\n       end Adjust_Decl;\n \n+      ----------------------------\n+      -- Build_Assertion_Bodies --\n+      ----------------------------\n+\n+      procedure Build_Assertion_Bodies (Decls : List_Id; Context : Node_Id) is\n+         procedure Build_Assertion_Bodies_For_Type (Typ : Entity_Id);\n+         --  Create the subprogram bodies which verify the run-time semantics\n+         --  of the pragmas listed below for type Typ. The pragmas are:\n+         --\n+         --    Default_Initial_Condition\n+         --    Invariant\n+         --    Type_Invariant\n+\n+         -------------------------------------\n+         -- Build_Assertion_Bodies_For_Type --\n+         -------------------------------------\n+\n+         procedure Build_Assertion_Bodies_For_Type (Typ : Entity_Id) is\n+         begin\n+            --  Preanalyze and resolve the Default_Initial_Condition assertion\n+            --  expression at the end of the declarations to catch any errors.\n+\n+            if Has_DIC (Typ) then\n+               Build_DIC_Procedure_Body (Typ);\n+            end if;\n+\n+            if Nkind (Context) = N_Package_Specification then\n+\n+               --  Preanalyze and resolve the invariants of a private type\n+               --  at the end of the visible declarations to catch potential\n+               --  errors. Inherited class-wide invariants are not included\n+               --  because they have already been resolved.\n+\n+               if Decls = Visible_Declarations (Context)\n+                 and then Ekind_In (Typ, E_Limited_Private_Type,\n+                                         E_Private_Type,\n+                                         E_Record_Type_With_Private)\n+                 and then Has_Own_Invariants (Typ)\n+               then\n+                  Build_Invariant_Procedure_Body\n+                    (Typ               => Typ,\n+                     Partial_Invariant => True);\n+\n+               --  Preanalyze and resolve the invariants of a private type's\n+               --  full view at the end of the private declarations to catch\n+               --  potential errors.\n+\n+               elsif Decls = Private_Declarations (Context)\n+                 and then not Is_Private_Type (Typ)\n+                 and then Has_Private_Declaration (Typ)\n+                 and then Has_Invariants (Typ)\n+               then\n+                  Build_Invariant_Procedure_Body (Typ);\n+               end if;\n+            end if;\n+         end Build_Assertion_Bodies_For_Type;\n+\n+         --  Local variables\n+\n+         Decl    : Node_Id;\n+         Decl_Id : Entity_Id;\n+\n+      --  Start of processing for Build_Assertion_Bodies\n+\n+      begin\n+         Decl := First (Decls);\n+         while Present (Decl) loop\n+            if Is_Declaration (Decl) then\n+               Decl_Id := Defining_Entity (Decl);\n+\n+               if Is_Type (Decl_Id) then\n+                  Build_Assertion_Bodies_For_Type (Decl_Id);\n+               end if;\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+      end Build_Assertion_Bodies;\n+\n       ---------------------------\n       -- Check_Entry_Contracts --\n       ---------------------------\n@@ -2581,11 +2672,13 @@ package body Sem_Ch3 is\n          Decl := Next_Decl;\n       end loop;\n \n-      --  Analyze the contracts of packages and their bodies\n+      --  Post-freezing actions\n \n       if Present (L) then\n          Context := Parent (L);\n \n+         --  Analyze the contracts of packages and their bodies\n+\n          if Nkind (Context) = N_Package_Specification then\n \n             --  When a package has private declarations, its contract must be\n@@ -2643,6 +2736,15 @@ package body Sem_Ch3 is\n          --  protected, subprogram, or task body (SPARK RM 7.2.2(3)).\n \n          Check_State_Refinements (Context);\n+\n+         --  Create the subprogram bodies which verify the run-time semantics\n+         --  of pragmas Default_Initial_Condition and [Type_]Invariant for all\n+         --  types within the current declarative list. This ensures that all\n+         --  assertion expressions are preanalyzed and resolved at the end of\n+         --  the declarative part. Note that the resolution happens even when\n+         --  freezing does not take place.\n+\n+         Build_Assertion_Bodies (L, Context);\n       end if;\n    end Analyze_Declarations;\n "}, {"sha": "12486f252d3c903c1b1603f817b01bd3bfb230de", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -369,31 +369,29 @@ package body Sem_Ch6 is\n          Set_Is_Inlined (Prev);\n          Ret_Type := Etype (Prev);\n \n-         --  An expression function that is a completion freezes the\n-         --  expression. This means freezing the return type, and if it is an\n-         --  access type, freezing its designated type as well.\n+         --  An expression function which acts as a completion freezes the\n+         --  expression. This means freezing the return type, and if it is\n+         --  an access type, freezing its designated type as well.\n \n          --  Note that we cannot defer this freezing to the analysis of the\n          --  expression itself, because a freeze node might appear in a nested\n          --  scope, leading to an elaboration order issue in gigi.\n \n-         --  An entity can only be frozen if it has a completion, so we must\n-         --  check this explicitly. If it is declared elsewhere it will have\n-         --  been frozen already, so only types declared in currently opened\n-         --  scopes need to be tested.\n+         Freeze_Before (N, Ret_Type);\n \n-         if Ekind (Ret_Type) = E_Private_Type\n-           and then In_Open_Scopes (Scope (Ret_Type))\n+         --  An entity can only be frozen if it is complete, so if the type\n+         --  is still unfrozen it must still be incomplete in some way, e.g.\n+         --  a privte type without a full view, or a type derived from such\n+         --  in an enclosing scope. Except in a generic context, such an\n+         --  incomplete type is an error.\n+\n+         if not Is_Frozen (Ret_Type)\n            and then not Is_Generic_Type (Ret_Type)\n-           and then not Is_Frozen (Ret_Type)\n-           and then No (Full_View (Ret_Type))\n+           and then not Inside_A_Generic\n          then\n             Error_Msg_NE\n               (\"premature use of private type&\",\n                Result_Definition (Specification (N)), Ret_Type);\n-\n-         else\n-            Freeze_Before (N, Ret_Type);\n          end if;\n \n          if Is_Access_Type (Etype (Prev)) then"}, {"sha": "95774e278e43ef37b54944679c0b70595e97cd82", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -35,11 +35,9 @@ with Debug;     use Debug;\n with Einfo;     use Einfo;\n with Elists;    use Elists;\n with Errout;    use Errout;\n-with Exp_Ch7;   use Exp_Ch7;\n with Exp_Disp;  use Exp_Disp;\n with Exp_Dist;  use Exp_Dist;\n with Exp_Dbug;  use Exp_Dbug;\n-with Exp_Util;  use Exp_Util;\n with Freeze;    use Freeze;\n with Ghost;     use Ghost;\n with Lib;       use Lib;\n@@ -1432,30 +1430,6 @@ package body Sem_Ch7 is\n             Error_Msg_N (\"no declaration in visible part for incomplete}\", E);\n          end if;\n \n-         if Is_Type (E) then\n-\n-            --  Preanalyze and resolve the Default_Initial_Condition assertion\n-            --  expression at the end of the visible declarations to catch any\n-            --  errors.\n-\n-            if Has_DIC (E) then\n-               Build_DIC_Procedure_Body (E);\n-            end if;\n-\n-            --  Preanalyze and resolve the invariants of a private type at the\n-            --  end of the visible declarations to catch potential errors. Note\n-            --  that inherited class-wide invariants are not considered because\n-            --  they have already been resolved.\n-\n-            if Ekind_In (E, E_Limited_Private_Type,\n-                            E_Private_Type,\n-                            E_Record_Type_With_Private)\n-              and then Has_Own_Invariants (E)\n-            then\n-               Build_Invariant_Procedure_Body (E, Partial_Invariant => True);\n-            end if;\n-         end if;\n-\n          Next_Entity (E);\n       end loop;\n \n@@ -1635,30 +1609,6 @@ package body Sem_Ch7 is\n               (\"full view of & does not have preelaborable initialization\", E);\n          end if;\n \n-         if Is_Type (E) and then Serious_Errors_Detected > 0 then\n-\n-            --  Preanalyze and resolve the Default_Initial_Condition assertion\n-            --  expression at the end of the private declarations when freezing\n-            --  did not take place due to errors or because the context is a\n-            --  generic unit.\n-\n-            if Has_DIC (E) then\n-               Build_DIC_Procedure_Body (E);\n-            end if;\n-\n-            --  Preanalyze and resolve the invariants of a private type's full\n-            --  view at the end of the private declarations in case freezing\n-            --  did not take place either due to errors or because the context\n-            --  is a generic unit.\n-\n-            if not Is_Private_Type (E)\n-              and then Has_Private_Declaration (E)\n-              and then Has_Invariants (E)\n-            then\n-               Build_Invariant_Procedure_Body (E);\n-            end if;\n-         end if;\n-\n          Next_Entity (E);\n       end loop;\n "}, {"sha": "ef1a20b151ae8dd19fd7050bf7d0bb881b1b95dd", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -932,13 +932,29 @@ package body Sem_Disp is\n    ---------------------------------\n \n    procedure Check_Dispatching_Operation (Subp, Old_Subp : Entity_Id) is\n-      Tagged_Type            : Entity_Id;\n-      Has_Dispatching_Parent : Boolean   := False;\n       Body_Is_Last_Primitive : Boolean   := False;\n+      Has_Dispatching_Parent : Boolean   := False;\n       Ovr_Subp               : Entity_Id := Empty;\n+      Tagged_Type            : Entity_Id;\n \n    begin\n-      if not Ekind_In (Subp, E_Procedure, E_Function) then\n+      if not Ekind_In (Subp, E_Function, E_Procedure) then\n+         return;\n+\n+      --  The Default_Initial_Condition procedure is not a primitive subprogram\n+      --  even if it relates to a tagged type. This routine is not meant to be\n+      --  inherited or overridden.\n+\n+      elsif Is_DIC_Procedure (Subp) then\n+         return;\n+\n+      --  The \"partial\" and \"full\" type invariant procedures are not primitive\n+      --  subprograms even if they relate to a tagged type. These routines are\n+      --  not meant to be inherited or overridden.\n+\n+      elsif Is_Invariant_Procedure (Subp)\n+        or else Is_Partial_Invariant_Procedure (Subp)\n+      then\n          return;\n       end if;\n "}, {"sha": "89b21a0ef6a1528f90505d05d079a2966abfa90c", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54740d7d82a8e16020c33b0387463ceea5f3d2be/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=54740d7d82a8e16020c33b0387463ceea5f3d2be", "patch": "@@ -112,6 +112,9 @@ package body Sem_Elab is\n       --  The current scope of the call. This is restored when we complete the\n       --  delayed call, so that we do this in the right scope.\n \n+      From_SPARK_Code : Boolean;\n+      --  Save indication of whether this call is under SPARK_Mode => On\n+\n       From_Elab_Code : Boolean;\n       --  Save indication of whether this call is from elaboration code\n \n@@ -1941,13 +1944,17 @@ package body Sem_Elab is\n    ----------------------\n \n    procedure Check_Elab_Calls is\n+      Save_SPARK_Mode : SPARK_Mode_Type;\n+\n    begin\n-      --  If expansion is disabled, do not generate any checks. Also skip\n+      --  If expansion is disabled, do not generate any checks, unless we\n+      --  are in GNATprove mode, so that errors are issued in GNATprove for\n+      --  violations of static elaboration rules in SPARK code. Also skip\n       --  checks if any subunits are missing because in either case we lack the\n       --  full information that we need, and no object file will be created in\n       --  any case.\n \n-      if not Expander_Active\n+      if (not Expander_Active and not GNATprove_Mode)\n         or else Is_Generic_Unit (Cunit_Entity (Main_Unit))\n         or else Subunits_Missing\n       then\n@@ -1964,12 +1971,21 @@ package body Sem_Elab is\n             Push_Scope (Delay_Check.Table (J).Curscop);\n             From_Elab_Code := Delay_Check.Table (J).From_Elab_Code;\n \n+            --  Set appropriate value of SPARK_Mode\n+\n+            Save_SPARK_Mode := SPARK_Mode;\n+\n+            if Delay_Check.Table (J).From_SPARK_Code then\n+               SPARK_Mode := On;\n+            end if;\n+\n             Check_Internal_Call_Continue (\n               N           => Delay_Check.Table (J).N,\n               E           => Delay_Check.Table (J).E,\n               Outer_Scope => Delay_Check.Table (J).Outer_Scope,\n               Orig_Ent    => Delay_Check.Table (J).Orig_Ent);\n \n+            SPARK_Mode := Save_SPARK_Mode;\n             Pop_Scope;\n          end loop;\n \n@@ -2223,12 +2239,13 @@ package body Sem_Elab is\n \n       if Delaying_Elab_Checks then\n          Delay_Check.Append (\n-           (N              => N,\n-            E              => E,\n-            Orig_Ent       => Orig_Ent,\n-            Curscop        => Current_Scope,\n-            Outer_Scope    => Outer_Scope,\n-            From_Elab_Code => From_Elab_Code));\n+           (N               => N,\n+            E               => E,\n+            Orig_Ent        => Orig_Ent,\n+            Curscop         => Current_Scope,\n+            Outer_Scope     => Outer_Scope,\n+            From_Elab_Code  => From_Elab_Code,\n+            From_SPARK_Code => SPARK_Mode = On));\n          return;\n \n       --  Otherwise, call phase 2 continuation right now"}]}