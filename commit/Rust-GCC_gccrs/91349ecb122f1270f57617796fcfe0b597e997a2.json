{"sha": "91349ecb122f1270f57617796fcfe0b597e997a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEzNDllY2IxMjJmMTI3MGY1NzYxNzc5NmZjZmUwYjU5N2U5OTdhMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-03T00:15:16Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-03T00:15:16Z"}, "message": "Rewrite conversion of named types to backend representation.\n\nFrom-SVN: r170627", "tree": {"sha": "678d2222967b4569da0137e478d14dd2f4606c72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/678d2222967b4569da0137e478d14dd2f4606c72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91349ecb122f1270f57617796fcfe0b597e997a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91349ecb122f1270f57617796fcfe0b597e997a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91349ecb122f1270f57617796fcfe0b597e997a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91349ecb122f1270f57617796fcfe0b597e997a2/comments", "author": null, "committer": null, "parents": [{"sha": "f63f8a3c1938e9bd7cec23c37754ee6caacbd477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f63f8a3c1938e9bd7cec23c37754ee6caacbd477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f63f8a3c1938e9bd7cec23c37754ee6caacbd477"}], "stats": {"total": 887, "additions": 576, "deletions": 311}, "files": [{"sha": "ee486ffb27a79d5b3107e7a1785b05ad25774330", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=91349ecb122f1270f57617796fcfe0b597e997a2", "patch": "@@ -7013,6 +7013,8 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n \treturn false;\n       if (arg_type->is_abstract())\n \treturn false;\n+      if (arg_type->named_type() != NULL)\n+\targ_type->named_type()->convert(this->gogo_);\n       tree arg_type_tree = arg_type->get_tree(this->gogo_);\n       if (arg_type_tree == error_mark_node)\n \treturn false;\n@@ -7057,6 +7059,8 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n       Type* st = struct_expr->type();\n       if (st->struct_type() == NULL)\n \treturn false;\n+      if (st->named_type() != NULL)\n+\tst->named_type()->convert(this->gogo_);\n       tree struct_tree = st->get_tree(this->gogo_);\n       gcc_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n       tree field = TYPE_FIELDS(struct_tree);\n@@ -8793,10 +8797,21 @@ Call_expression::do_get_tree(Translate_context* context)\n       return error_mark_node;\n     }\n \n-  // This is to support builtin math functions when using 80387 math.\n   tree fndecl = fn;\n   if (TREE_CODE(fndecl) == ADDR_EXPR)\n     fndecl = TREE_OPERAND(fndecl, 0);\n+\n+  // Add a type cast in case the type of the function is a recursive\n+  // type which refers to itself.\n+  if (!DECL_P(fndecl) || !DECL_IS_BUILTIN(fndecl))\n+    {\n+      tree fnt = fntype->get_tree(gogo);\n+      if (fnt == error_mark_node)\n+\treturn error_mark_node;\n+      fn = fold_convert_loc(location, fnt, fn);\n+    }\n+\n+  // This is to support builtin math functions when using 80387 math.\n   tree excess_type = NULL_TREE;\n   if (DECL_P(fndecl)\n       && DECL_IS_BUILTIN(fndecl)\n@@ -8842,7 +8857,7 @@ Call_expression::do_get_tree(Translate_context* context)\n   // to the correct type.\n   if (TREE_TYPE(ret) == ptr_type_node)\n     {\n-      tree t = this->type()->get_tree(gogo);\n+      tree t = this->type()->base()->get_tree(gogo);\n       ret = fold_convert_loc(location, t, ret);\n     }\n "}, {"sha": "7b1fd7eccbb4b8d7c1e279497b6e048e5fcd9810", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=91349ecb122f1270f57617796fcfe0b597e997a2", "patch": "@@ -118,9 +118,6 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n   // Export global identifiers as appropriate.\n   ::gogo->do_exports();\n \n-  // Build required interface method tables.\n-  ::gogo->build_interface_method_tables();\n-\n   // Turn short-cut operators (&&, ||) into explicit if statements.\n   ::gogo->remove_shortcuts();\n "}, {"sha": "722a23a52d70dc8637d609364bbce2142eda9e2f", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=91349ecb122f1270f57617796fcfe0b597e997a2", "patch": "@@ -640,6 +640,9 @@ sort_var_inits(Var_inits* var_inits)\n void\n Gogo::write_globals()\n {\n+  this->convert_named_types();\n+  this->build_interface_method_tables();\n+\n   Bindings* bindings = this->current_bindings();\n   size_t count = bindings->size_definitions();\n "}, {"sha": "bb2fcab8230a18858641351929912ee4faecc38f", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 79, "deletions": 6, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=91349ecb122f1270f57617796fcfe0b597e997a2", "patch": "@@ -34,7 +34,8 @@ Gogo::Gogo(int int_type_size, int pointer_size)\n     imported_init_fns_(),\n     unique_prefix_(),\n     unique_prefix_specified_(false),\n-    interface_types_()\n+    interface_types_(),\n+    named_types_are_converted_(false)\n {\n   const source_location loc = BUILTINS_LOCATION;\n \n@@ -1119,11 +1120,6 @@ class Verify_types : public Traverse\n int\n Verify_types::type(Type* t)\n {\n-  // Don't verify types defined in other packages.\n-  Named_type* nt = t->named_type();\n-  if (nt != NULL && nt->named_object()->package() != NULL)\n-    return TRAVERSE_SKIP_COMPONENTS;\n-\n   if (!t->verify())\n     return TRAVERSE_SKIP_COMPONENTS;\n   return TRAVERSE_CONTINUE;\n@@ -2520,6 +2516,83 @@ Gogo::do_exports()\n \t\t     this->package_->bindings());\n }\n \n+// Find the blocks in order to convert named types defined in blocks.\n+\n+class Convert_named_types : public Traverse\n+{\n+ public:\n+  Convert_named_types(Gogo* gogo)\n+    : Traverse(traverse_blocks),\n+      gogo_(gogo)\n+  { }\n+\n+ protected:\n+  int\n+  block(Block* block);\n+\n+ private:\n+  Gogo* gogo_;\n+};\n+\n+int\n+Convert_named_types::block(Block* block)\n+{\n+  this->gogo_->convert_named_types_in_bindings(block->bindings());\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Convert all named types to the backend representation.  Since named\n+// types can refer to other types, this needs to be done in the right\n+// sequence, which is handled by Named_type::convert.  Here we arrange\n+// to call that for each named type.\n+\n+void\n+Gogo::convert_named_types()\n+{\n+  this->convert_named_types_in_bindings(this->globals_);\n+  for (Packages::iterator p = this->packages_.begin();\n+       p != this->packages_.end();\n+       ++p)\n+    {\n+      Package* package = p->second;\n+      this->convert_named_types_in_bindings(package->bindings());\n+    }\n+\n+  Convert_named_types cnt(this);\n+  this->traverse(&cnt);\n+\n+  // Make all the builtin named types used for type descriptors, and\n+  // then convert them.  They will only be written out if they are\n+  // needed.\n+  Type::make_type_descriptor_type();\n+  Type::make_type_descriptor_ptr_type();\n+  Function_type::make_function_type_descriptor_type();\n+  Pointer_type::make_pointer_type_descriptor_type();\n+  Struct_type::make_struct_type_descriptor_type();\n+  Array_type::make_array_type_descriptor_type();\n+  Array_type::make_slice_type_descriptor_type();\n+  Map_type::make_map_type_descriptor_type();\n+  Channel_type::make_chan_type_descriptor_type();\n+  Interface_type::make_interface_type_descriptor_type();\n+  Type::convert_builtin_named_types(this);\n+\n+  this->named_types_are_converted_ = true;\n+}\n+\n+// Convert all names types in a set of bindings.\n+\n+void\n+Gogo::convert_named_types_in_bindings(Bindings* bindings)\n+{\n+  for (Bindings::const_definitions_iterator p = bindings->begin_definitions();\n+       p != bindings->end_definitions();\n+       ++p)\n+    {\n+      if ((*p)->is_type())\n+\t(*p)->type_value()->convert(this);\n+    }\n+}\n+\n // Class Function.\n \n Function::Function(Function_type* type, Function* enclosing, Block* block,"}, {"sha": "8db802ea53e34881dc8ba645423f9dd5450bd052", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=91349ecb122f1270f57617796fcfe0b597e997a2", "patch": "@@ -405,6 +405,20 @@ class Gogo\n   void\n   simplify_thunk_statements();\n \n+  // Convert named types to the backend representation.\n+  void\n+  convert_named_types();\n+\n+  // Convert named types in a list of bindings.\n+  void\n+  convert_named_types_in_bindings(Bindings*);\n+\n+  // True if named types have been converted to the backend\n+  // representation.\n+  bool\n+  named_types_are_converted() const\n+  { return this->named_types_are_converted_; }\n+\n   // Write out the global values.\n   void\n   write_globals();\n@@ -661,6 +675,8 @@ class Gogo\n   bool unique_prefix_specified_;\n   // A list of interface types defined while parsing.\n   std::vector<Interface_type*> interface_types_;\n+  // Whether named types have been converted.\n+  bool named_types_are_converted_;\n };\n \n // A block of statements."}, {"sha": "368ecae127a084c8457bcae6a5433a76f306e2f8", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 380, "deletions": 252, "changes": 632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=91349ecb122f1270f57617796fcfe0b597e997a2", "patch": "@@ -835,8 +835,9 @@ Type::get_tree(Gogo* gogo)\n     Type::type_trees.insert(val);\n   if (!ins.second && ins.first->second != NULL_TREE)\n     {\n-      this->tree_ = ins.first->second;\n-      return this->tree_;\n+      if (gogo != NULL && gogo->named_types_are_converted())\n+\tthis->tree_ = ins.first->second;\n+      return ins.first->second;\n     }\n \n   tree t = this->get_tree_without_hash(gogo);\n@@ -850,6 +851,8 @@ Type::get_tree(Gogo* gogo)\n       // which in turns uses an identical unnamed type.  Use the tree\n       // we created earlier and ignore the one we just built.\n       t = ins.first->second;\n+      if (gogo == NULL || !gogo->named_types_are_converted())\n+\treturn t;\n       this->tree_ = t;\n     }\n \n@@ -874,6 +877,9 @@ Type::get_tree_without_hash(Gogo* gogo)\n       if (t == ptr_type_node && this->forward_declaration_type() != NULL)\n \treturn t;\n \n+      if (gogo == NULL || !gogo->named_types_are_converted())\n+\treturn t;\n+\n       this->tree_ = t;\n       go_preserve_from_gc(t);\n     }\n@@ -961,14 +967,36 @@ Type::make_builtin_struct_type(int nfields, ...)\n   return Type::make_struct_type(sfl, bloc);\n }\n \n+// A list of builtin named types.\n+\n+std::vector<Named_type*> Type::named_builtin_types;\n+\n // Make a builtin named type.\n \n Named_type*\n Type::make_builtin_named_type(const char* name, Type* type)\n {\n   source_location bloc = BUILTINS_LOCATION;\n   Named_object* no = Named_object::make_type(name, NULL, type, bloc);\n-  return no->type_value();\n+  Named_type* ret = no->type_value();\n+  Type::named_builtin_types.push_back(ret);\n+  return ret;\n+}\n+\n+// Convert the named builtin types.\n+\n+void\n+Type::convert_builtin_named_types(Gogo* gogo)\n+{\n+  for (std::vector<Named_type*>::const_iterator p =\n+\t Type::named_builtin_types.begin();\n+       p != Type::named_builtin_types.end();\n+       ++p)\n+    {\n+      bool r = (*p)->verify();\n+      gcc_assert(r);\n+      (*p)->convert(gogo);\n+    }\n }\n \n // Return the type of a type descriptor.  We should really tie this to\n@@ -3309,20 +3337,10 @@ Call_multiple_result_type::do_get_tree(Gogo* gogo)\n   gcc_assert(fntype != NULL);\n   const Typed_identifier_list* results = fntype->results();\n   gcc_assert(results != NULL && results->size() > 1);\n-\n-  Struct_field_list* sfl = new Struct_field_list;\n-  for (Typed_identifier_list::const_iterator p = results->begin();\n-       p != results->end();\n-       ++p)\n-    {\n-      const std::string name = ((p->name().empty()\n-\t\t\t\t || p->name() == Import::import_marker)\n-\t\t\t\t? \"UNNAMED\"\n-\t\t\t\t: p->name());\n-      sfl->push_back(Struct_field(Typed_identifier(name, p->type(),\n-\t\t\t\t\t\t   this->call_->location())));\n-    }\n-  return Type::make_struct_type(sfl, this->call_->location())->get_tree(gogo);\n+  tree fntype_tree = fntype->get_tree(gogo);\n+  if (fntype_tree == error_mark_node)\n+    return error_mark_node;\n+  return TREE_TYPE(fntype_tree);\n }\n \n // Make a call result type.\n@@ -3782,28 +3800,17 @@ Struct_type::fill_in_tree(Gogo* gogo, tree type)\n {\n   tree field_trees = NULL_TREE;\n   tree* pp = &field_trees;\n-  bool has_pointer = false;\n   for (Struct_field_list::const_iterator p = this->fields_->begin();\n        p != this->fields_->end();\n        ++p)\n     {\n       std::string name = Gogo::unpack_hidden_name(p->field_name());\n       tree name_tree = get_identifier_with_length(name.data(), name.length());\n \n-      // Don't follow pointers yet, so that we don't get confused by a\n-      // pointer to an array of this struct type.\n-      tree field_type_tree;\n-      if (p->type()->points_to() != NULL || p->type()->function_type() != NULL)\n-\t{\n-\t  field_type_tree = ptr_type_node;\n-\t  has_pointer = true;\n-\t}\n-      else\n-\t{\n-\t  field_type_tree = p->type()->get_tree(gogo);\n-\t  if (field_type_tree == error_mark_node)\n-\t    return error_mark_node;\n-\t}\n+      tree field_type_tree = p->type()->get_tree(gogo);\n+      if (field_type_tree == error_mark_node)\n+\treturn error_mark_node;\n+      gcc_assert(TYPE_SIZE(field_type_tree) != NULL_TREE);\n \n       tree field = build_decl(p->location(), FIELD_DECL, name_tree,\n \t\t\t      field_type_tree);\n@@ -3816,35 +3823,9 @@ Struct_type::fill_in_tree(Gogo* gogo, tree type)\n \n   layout_type(type);\n \n-  if (has_pointer)\n-    {\n-      tree field = field_trees;\n-      for (Struct_field_list::const_iterator p = this->fields_->begin();\n-\t   p != this->fields_->end();\n-\t   ++p, field = DECL_CHAIN(field))\n-\t{\n-\t  if (p->type()->points_to() != NULL\n-\t      || p->type()->function_type() != NULL)\n-\t    TREE_TYPE(field) = p->type()->get_tree(gogo);\n-\t}\n-    }\n-\n   return type;\n }\n \n-// Make sure that all structs which must be converted to the backend\n-// representation before this one are in fact converted.\n-\n-void\n-Struct_type::convert_prerequisites(Gogo* gogo)\n-{\n-  for (std::vector<Named_type*>::const_iterator p\n-\t = this->prerequisites_.begin();\n-       p != this->prerequisites_.end();\n-       ++p)\n-    (*p)->get_tree(gogo);\n-}\n-\n // Initialize struct fields.\n \n tree\n@@ -4487,6 +4468,8 @@ Array_type::fill_in_array_tree(Gogo* gogo, tree array_type)\n       || length_tree == error_mark_node)\n     return error_mark_node;\n \n+  gcc_assert(TYPE_SIZE(element_type_tree) != NULL_TREE);\n+\n   length_tree = fold_convert(sizetype, length_tree);\n \n   // build_index_type takes the maximum index, which is one less than\n@@ -6074,70 +6057,86 @@ tree\n Interface_type::do_get_tree(Gogo* gogo)\n {\n   if (this->methods_ == NULL)\n+    return Interface_type::empty_type_tree(gogo);\n+  else\n     {\n-      // At the tree level, use the same type for all empty\n-      // interfaces.  This lets us assign them to each other directly\n-      // without triggering GIMPLE type errors.\n-      tree dtype = Type::make_type_descriptor_type()->get_tree(gogo);\n-      dtype = build_pointer_type(build_qualified_type(dtype, TYPE_QUAL_CONST));\n-      static tree empty_interface;\n-      return Gogo::builtin_struct(&empty_interface, \"__go_empty_interface\",\n-\t\t\t\t  NULL_TREE, 2,\n-\t\t\t\t  \"__type_descriptor\",\n-\t\t\t\t  dtype,\n-\t\t\t\t  \"__object\",\n-\t\t\t\t  ptr_type_node);\n+      tree t = Interface_type::non_empty_type_tree(this->location_);\n+      return this->fill_in_tree(gogo, t);\n     }\n-\n-  return this->fill_in_tree(gogo, make_node(RECORD_TYPE));\n }\n \n-// Fill in the tree for an interface type.  This is used for named\n-// interface types.\n+// Return a singleton struct for an empty interface type.  We use the\n+// same type for all empty interfaces.  This lets us assign them to\n+// each other directly without triggering GIMPLE type errors.\n \n tree\n-Interface_type::fill_in_tree(Gogo* gogo, tree type)\n+Interface_type::empty_type_tree(Gogo* gogo)\n {\n-  gcc_assert(this->methods_ != NULL);\n+  static tree empty_interface;\n+  if (empty_interface != NULL_TREE)\n+    return empty_interface;\n+\n+  tree dtype = Type::make_type_descriptor_type()->get_tree(gogo);\n+  dtype = build_pointer_type(build_qualified_type(dtype, TYPE_QUAL_CONST));\n+  return Gogo::builtin_struct(&empty_interface, \"__go_empty_interface\",\n+\t\t\t      NULL_TREE, 2,\n+\t\t\t      \"__type_descriptor\",\n+\t\t\t      dtype,\n+\t\t\t      \"__object\",\n+\t\t\t      ptr_type_node);\n+}\n \n-  // Because the methods may refer to the interface type itself, we\n-  // need to build the interface type first, and then update the\n-  // method pointer later.\n+// Return a new struct for a non-empty interface type.  The correct\n+// values are filled in by fill_in_tree.\n+\n+tree\n+Interface_type::non_empty_type_tree(source_location location)\n+{\n+  tree ret = make_node(RECORD_TYPE);\n \n   tree field_trees = NULL_TREE;\n   tree* pp = &field_trees;\n \n   tree name_tree = get_identifier(\"__methods\");\n-  tree methods_field = build_decl(this->location_, FIELD_DECL, name_tree,\n-\t\t\t\t  ptr_type_node);\n-  DECL_CONTEXT(methods_field) = type;\n-  *pp = methods_field;\n-  pp = &DECL_CHAIN(methods_field);\n+  tree field = build_decl(location, FIELD_DECL, name_tree, ptr_type_node);\n+  DECL_CONTEXT(field) = ret;\n+  *pp = field;\n+  pp = &DECL_CHAIN(field);\n \n   name_tree = get_identifier(\"__object\");\n-  tree field = build_decl(this->location_, FIELD_DECL, name_tree,\n-\t\t\t  ptr_type_node);\n-  DECL_CONTEXT(field) = type;\n+  field = build_decl(location, FIELD_DECL, name_tree, ptr_type_node);\n+  DECL_CONTEXT(field) = ret;\n   *pp = field;\n \n-  TYPE_FIELDS(type) = field_trees;\n+  TYPE_FIELDS(ret) = field_trees;\n \n-  layout_type(type);\n+  layout_type(ret);\n+\n+  return ret;\n+}\n+\n+// Fill in the tree for an interface type.  This is used for named\n+// interface types.\n+\n+tree\n+Interface_type::fill_in_tree(Gogo* gogo, tree type)\n+{\n+  gcc_assert(this->methods_ != NULL);\n \n   // Build the type of the table of methods.\n \n   tree method_table = make_node(RECORD_TYPE);\n \n   // The first field is a pointer to the type descriptor.\n-  name_tree = get_identifier(\"__type_descriptor\");\n+  tree name_tree = get_identifier(\"__type_descriptor\");\n   tree dtype = Type::make_type_descriptor_type()->get_tree(gogo);\n   dtype = build_pointer_type(build_qualified_type(dtype, TYPE_QUAL_CONST));\n-  field = build_decl(this->location_, FIELD_DECL, name_tree, dtype);\n+  tree field = build_decl(this->location_, FIELD_DECL, name_tree, dtype);\n   DECL_CONTEXT(field) = method_table;\n   TYPE_FIELDS(method_table) = field;\n \n   std::string last_name = \"\";\n-  pp = &DECL_CHAIN(field);\n+  tree* pp = &DECL_CHAIN(field);\n   for (Typed_identifier_list::const_iterator p = this->methods_->begin();\n        p != this->methods_->end();\n        ++p)\n@@ -6159,7 +6158,10 @@ Interface_type::fill_in_tree(Gogo* gogo, tree type)\n \n   // Update the type of the __methods field from a generic pointer to\n   // a pointer to the method table.\n-  TREE_TYPE(methods_field) = build_pointer_type(method_table);\n+  field = TYPE_FIELDS(type);\n+  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__methods\") == 0);\n+\n+  TREE_TYPE(field) = build_pointer_type(method_table);\n \n   return type;\n }\n@@ -6876,7 +6878,7 @@ Named_type::named_type_has_hidden_fields(std::string* reason) const\n class Find_type_use : public Traverse\n {\n  public:\n-  Find_type_use(Type* find_type)\n+  Find_type_use(Named_type* find_type)\n     : Traverse(traverse_types),\n       find_type_(find_type), found_(false)\n   { }\n@@ -6892,7 +6894,7 @@ class Find_type_use : public Traverse\n \n  private:\n   // The type we are looking for.\n-  Type* find_type_;\n+  Named_type* find_type_;\n   // Whether we found the type.\n   bool found_;\n };\n@@ -6902,11 +6904,12 @@ class Find_type_use : public Traverse\n int\n Find_type_use::type(Type* type)\n {\n-  if (this->find_type_ == type)\n+  if (type->named_type() != NULL && this->find_type_ == type->named_type())\n     {\n       this->found_ = true;\n       return TRAVERSE_EXIT;\n     }\n+\n   // It's OK if we see a reference to the type in any type which is\n   // essentially a pointer: a pointer, a slice, a function, a map, or\n   // a channel.\n@@ -6940,6 +6943,42 @@ Find_type_use::type(Type* type)\n       return TRAVERSE_SKIP_COMPONENTS;\n     }\n \n+  // Otherwise, FIND_TYPE_ depends on TYPE, in the sense that we need\n+  // to convert TYPE to the backend representation before we convert\n+  // FIND_TYPE_.\n+  if (type->named_type() != NULL)\n+    {\n+      switch (type->base()->classification())\n+\t{\n+\tcase Type::TYPE_ERROR:\n+\tcase Type::TYPE_BOOLEAN:\n+\tcase Type::TYPE_INTEGER:\n+\tcase Type::TYPE_FLOAT:\n+\tcase Type::TYPE_COMPLEX:\n+\tcase Type::TYPE_STRING:\n+\tcase Type::TYPE_NIL:\n+\t  break;\n+\n+\tcase Type::TYPE_ARRAY:\n+\tcase Type::TYPE_STRUCT:\n+\t  this->find_type_->add_dependency(type->named_type());\n+\t  break;\n+\n+\tcase Type::TYPE_VOID:\n+\tcase Type::TYPE_SINK:\n+\tcase Type::TYPE_FUNCTION:\n+\tcase Type::TYPE_POINTER:\n+\tcase Type::TYPE_CALL_MULTIPLE_RESULT:\n+\tcase Type::TYPE_MAP:\n+\tcase Type::TYPE_CHANNEL:\n+\tcase Type::TYPE_INTERFACE:\n+\tcase Type::TYPE_NAMED:\n+\tcase Type::TYPE_FORWARD:\n+\tdefault:\n+\t  gcc_unreachable();\n+\t}\n+    }\n+\n   return TRAVERSE_CONTINUE;\n }\n \n@@ -6995,36 +7034,6 @@ Named_type::do_verify()\n \treturn false;\n     }\n \n-  // If this is a struct, then if any of the fields of the struct\n-  // themselves have struct type, or array of struct type, then this\n-  // struct must be converted to the backend representation before the\n-  // field's type is converted.  That may seem backward, but it works\n-  // because if the field's type refers to this one, e.g., via a\n-  // pointer, then the conversion process will pick up the half-built\n-  // struct and do the right thing.\n-  if (this->struct_type() != NULL)\n-    {\n-      const Struct_field_list* fields = this->struct_type()->fields();\n-      for (Struct_field_list::const_iterator p = fields->begin();\n-\t   p != fields->end();\n-\t   ++p)\n-\t{\n-\t  Struct_type* st = p->type()->struct_type();\n-\t  if (st != NULL)\n-\t    st->add_prerequisite(this);\n-\t  else\n-\t    {\n-\t      Array_type* at = p->type()->array_type();\n-\t      if (at != NULL && !at->is_open_array_type())\n-\t\t{\n-\t\t  st = at->element_type()->struct_type();\n-\t\t  if (st != NULL)\n-\t\t    st->add_prerequisite(this);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n   return true;\n }\n \n@@ -7074,21 +7083,109 @@ Named_type::do_hash_for_method(Gogo* gogo) const\n   return ret;\n }\n \n-// Get a tree for a named type.\n+// Convert a named type to the backend representation.  In order to\n+// get dependencies right, we fill in a dummy structure for this type,\n+// then convert all the dependencies, then complete this type.  When\n+// this function is complete, the size of the type is known.\n \n-tree\n-Named_type::do_get_tree(Gogo* gogo)\n+void\n+Named_type::convert(Gogo* gogo)\n+{\n+  if (this->is_error_ || this->is_converted_)\n+    return;\n+\n+  this->create_placeholder(gogo);\n+\n+  // Convert all the dependencies.  If they refer indirectly back to\n+  // this type, they will pick up the intermediate tree we just\n+  // created.\n+  for (std::vector<Named_type*>::const_iterator p = this->dependencies_.begin();\n+       p != this->dependencies_.end();\n+       ++p)\n+    (*p)->convert(gogo);\n+\n+  // Complete this type.\n+  tree t = this->named_tree_;\n+  Type* base = this->type_->base();\n+  switch (base->classification())\n+    {\n+    case TYPE_VOID:\n+    case TYPE_BOOLEAN:\n+    case TYPE_INTEGER:\n+    case TYPE_FLOAT:\n+    case TYPE_COMPLEX:\n+    case TYPE_STRING:\n+    case TYPE_NIL:\n+      break;\n+\n+    case TYPE_MAP:\n+    case TYPE_CHANNEL:\n+      break;\n+\n+    case TYPE_FUNCTION:\n+    case TYPE_POINTER:\n+      // The size of these types is already correct.\n+      break;\n+\n+    case TYPE_STRUCT:\n+      t = base->struct_type()->fill_in_tree(gogo, t);\n+      break;\n+\n+    case TYPE_ARRAY:\n+      if (!base->is_open_array_type())\n+\tt = base->array_type()->fill_in_array_tree(gogo, t);\n+      break;\n+\n+    case TYPE_INTERFACE:\n+      if (!base->interface_type()->is_empty())\n+\tt = base->interface_type()->fill_in_tree(gogo, t);\n+      break;\n+\n+    case TYPE_ERROR:\n+      return;\n+\n+    default:\n+    case TYPE_SINK:\n+    case TYPE_CALL_MULTIPLE_RESULT:\n+    case TYPE_NAMED:\n+    case TYPE_FORWARD:\n+      gcc_unreachable();\n+    }\n+\n+  this->named_tree_ = t;\n+\n+  if (t == error_mark_node)\n+    this->is_error_ = true;\n+  else\n+    gcc_assert(TYPE_SIZE(t) != NULL_TREE);\n+\n+  this->is_converted_ = true;\n+}\n+\n+// Create the placeholder for a named type.  This is the first step in\n+// converting to the backend representation.\n+\n+void\n+Named_type::create_placeholder(Gogo* gogo)\n {\n   if (this->is_error_)\n-    return error_mark_node;\n+    this->named_tree_ = error_mark_node;\n \n-  // Go permits types to refer to themselves in various ways.  Break\n-  // the recursion here.\n+  if (this->named_tree_ != NULL_TREE)\n+    return;\n+\n+  // Create the structure for this type.  Note that because we call\n+  // base() here, we don't attempt to represent a named type defined\n+  // as another named type.  Instead both named types will point to\n+  // different base representations.\n+  Type* base = this->type_->base();\n   tree t;\n-  switch (this->type_->forwarded()->classification())\n+  switch (base->classification())\n     {\n     case TYPE_ERROR:\n-      return error_mark_node;\n+      this->is_error_ = true;\n+      this->named_tree_ = error_mark_node;\n+      return;\n \n     case TYPE_VOID:\n     case TYPE_BOOLEAN:\n@@ -7097,163 +7194,194 @@ Named_type::do_get_tree(Gogo* gogo)\n     case TYPE_COMPLEX:\n     case TYPE_STRING:\n     case TYPE_NIL:\n-      // These types can not refer to themselves.\n-    case TYPE_MAP:\n-    case TYPE_CHANNEL:\n-      // All maps and channels have the same type in GENERIC.\n-      t = Type::get_named_type_tree(gogo, this->type_);\n+      // These are simple basic types, we can just create them\n+      // directly.\n+      t = Type::get_named_type_tree(gogo, base);\n       if (t == error_mark_node)\n-\treturn error_mark_node;\n-      // Build a copy to set TYPE_NAME.\n+\t{\n+\t  this->is_error_ = true;\n+\t  this->named_tree_ = error_mark_node;\n+\t  return;\n+\t}\n       t = build_variant_type_copy(t);\n       break;\n \n-    case TYPE_FUNCTION:\n-      // GENERIC can't handle a pointer to a function type whose\n-      // return type is a pointer to the function type itself.  It\n-      // goes into an infinite loop when walking the types.\n-      if (this->seen_ > 0)\n+    case TYPE_MAP:\n+    case TYPE_CHANNEL:\n+      // All maps and channels have the same type in GENERIC.\n+      t = Type::get_named_type_tree(gogo, base);\n+      if (t == error_mark_node)\n \t{\n-\t  Function_type* fntype = this->type_->function_type();\n-\t  if (fntype->results() != NULL\n-\t      && fntype->results()->size() == 1\n-\t      && fntype->results()->front().type()->forwarded() == this)\n-\t    return ptr_type_node;\n-\n-\t  // We can legitimately see ourselves here twice when a named\n-\t  // type is defined using a struct which refers to the named\n-\t  // type.  If we see ourselves too often we are in a loop.\n-\t  if (this->seen_ > 3)\n-\t    return ptr_type_node;\n+\t  this->is_error_ = true;\n+\t  this->named_tree_ = error_mark_node;\n+\t  return;\n \t}\n-      ++this->seen_;\n-      t = Type::get_named_type_tree(gogo, this->type_);\n-      --this->seen_;\n-      if (t == error_mark_node)\n-\treturn error_mark_node;\n       t = build_variant_type_copy(t);\n       break;\n \n+    case TYPE_FUNCTION:\n     case TYPE_POINTER:\n-      // Don't recur infinitely if a pointer type refers to itself.\n-      // Ideally we would build a circular data structure here, but\n-      // GENERIC can't handle them.\n-      if (this->seen_ > 0)\n-\t{\n-\t  if (this->type_->points_to()->forwarded() == this)\n-\t    return ptr_type_node;\n-\n-\t  if (this->seen_ > 3)\n-\t    return ptr_type_node;\n-\t}\n-      ++this->seen_;\n-      t = Type::get_named_type_tree(gogo, this->type_);\n-      --this->seen_;\n-      if (t == error_mark_node)\n-\treturn error_mark_node;\n-      t = build_variant_type_copy(t);\n+      t = build_variant_type_copy(ptr_type_node);\n       break;\n \n     case TYPE_STRUCT:\n-      // If there are structs which must be converted first, do them.\n-      if (this->seen_ == 0)\n-\t{\n-\t  ++this->seen_;\n-\t  this->type_->struct_type()->convert_prerequisites(gogo);\n-\t  --this->seen_;\n-\t}\n-\n-      if (this->named_tree_ != NULL_TREE)\n-\treturn this->named_tree_;\n-\n       t = make_node(RECORD_TYPE);\n-      this->named_tree_ = t;\n-      t = this->type_->struct_type()->fill_in_tree(gogo, t);\n-      if (t == error_mark_node)\n-\t{\n-\t  this->named_tree_ = error_mark_node;\n-\t  return error_mark_node;\n-\t}\n       break;\n \n     case TYPE_ARRAY:\n-      if (this->named_tree_ != NULL_TREE)\n-\treturn this->named_tree_;\n-      if (!this->is_open_array_type())\n-\t{\n-\t  t = make_node(ARRAY_TYPE);\n-\t  this->named_tree_ = t;\n-\t  t = this->type_->array_type()->fill_in_array_tree(gogo, t);\n-\t}\n+      if (base->is_open_array_type())\n+\tt = gogo->slice_type_tree(void_type_node);\n       else\n-\t{\n-\t  t = gogo->slice_type_tree(void_type_node);\n-\t  this->named_tree_ = t;\n-\t  t = this->type_->array_type()->fill_in_slice_tree(gogo, t);\n-\t}\n-      if (t == error_mark_node)\n-\treturn error_mark_node;\n-      t = build_variant_type_copy(t);\n+\tt = make_node(ARRAY_TYPE);\n       break;\n \n     case TYPE_INTERFACE:\n-      if (this->type_->interface_type()->is_empty())\n+      if (base->interface_type()->is_empty())\n \t{\n-\t  t = Type::get_named_type_tree(gogo, this->type_);\n-\t  if (t == error_mark_node)\n-\t    return error_mark_node;\n+\t  t = Interface_type::empty_type_tree(gogo);\n \t  t = build_variant_type_copy(t);\n \t}\n       else\n \t{\n-\t  if (this->named_tree_ != NULL_TREE)\n-\t    return this->named_tree_;\n-\t  t = make_node(RECORD_TYPE);\n-\t  this->named_tree_ = t;\n-\t  t = this->type_->interface_type()->fill_in_tree(gogo, t);\n-\t  if (t == error_mark_node)\n-\t    {\n-\t      this->named_tree_ = error_mark_node;\n-\t      return error_mark_node;\n-\t    }\n+\t  source_location loc = base->interface_type()->location();\n+\t  t = Interface_type::non_empty_type_tree(loc);\n \t}\n       break;\n \n-    case TYPE_NAMED:\n-      {\n-\t// When a named type T1 is defined as another named type T2,\n-\t// the definition must simply be \"type T1 T2\".  If the\n-\t// definition of T2 may refer to T1, then we must simply\n-\t// return the type for T2 here.  It's not precisely correct,\n-\t// but it's as close as we can get with GENERIC.\n-\t++this->seen_;\n-\tt = Type::get_named_type_tree(gogo, this->type_);\n-\t--this->seen_;\n-\tif (this->seen_ > 0)\n-\t  return t;\n-\tif (t == error_mark_node)\n-\t  return error_mark_node;\n-\tt = build_variant_type_copy(t);\n-      }\n-      break;\n-\n-    case TYPE_FORWARD:\n-      // An undefined forwarding type.  Make sure the error is\n-      // emitted.\n-      this->type_->forward_declaration_type()->real_type();\n-      return error_mark_node;\n-\n     default:\n     case TYPE_SINK:\n     case TYPE_CALL_MULTIPLE_RESULT:\n+    case TYPE_NAMED:\n+    case TYPE_FORWARD:\n       gcc_unreachable();\n     }\n \n+  // Create the named type.\n+\n   tree id = this->named_object_->get_id(gogo);\n   tree decl = build_decl(this->location_, TYPE_DECL, id, t);\n   TYPE_NAME(t) = decl;\n \n-  return t;\n+  this->named_tree_ = t;\n+}\n+\n+// Get a tree for a named type.\n+\n+tree\n+Named_type::do_get_tree(Gogo* gogo)\n+{\n+  if (this->is_error_)\n+    return error_mark_node;\n+\n+  tree t = this->named_tree_;\n+\n+  // FIXME: GOGO can be NULL when called from go_type_for_size, which\n+  // is only used for basic types.\n+  if (gogo == NULL || !gogo->named_types_are_converted())\n+    {\n+      // We have not completed converting named types.  NAMED_TREE_ is\n+      // a placeholder and we shouldn't do anything further.\n+      if (t != NULL_TREE)\n+\treturn t;\n+\n+      // We don't build dependencies for types whose sizes do not\n+      // change or are not relevant, so we may see them here while\n+      // converting types.\n+      this->create_placeholder(gogo);\n+      t = this->named_tree_;\n+      gcc_assert(t != NULL_TREE);\n+      return t;\n+    }\n+\n+  // We are not converting types.  This should only be called if the\n+  // type has already been converted.\n+  gcc_assert(this->is_converted_);\n+  gcc_assert(t != NULL_TREE && TYPE_SIZE(t) != NULL_TREE);\n+\n+  // Complete the tree.\n+  Type* base = this->type_->base();\n+  tree t1;\n+  switch (base->classification())\n+    {\n+    case TYPE_ERROR:\n+      return error_mark_node;\n+\n+    case TYPE_VOID:\n+    case TYPE_BOOLEAN:\n+    case TYPE_INTEGER:\n+    case TYPE_FLOAT:\n+    case TYPE_COMPLEX:\n+    case TYPE_STRING:\n+    case TYPE_NIL:\n+    case TYPE_MAP:\n+    case TYPE_CHANNEL:\n+    case TYPE_STRUCT:\n+    case TYPE_INTERFACE:\n+      return t;\n+\n+    case TYPE_FUNCTION:\n+      // Don't build a circular data structure.  GENERIC can't handle\n+      // it.\n+      if (this->seen_ > 0)\n+\t{\n+\t  this->is_circular_ = true;\n+\t  return ptr_type_node;\n+\t}\n+      ++this->seen_;\n+      t1 = Type::get_named_type_tree(gogo, base);\n+      --this->seen_;\n+      if (t1 == error_mark_node)\n+\treturn error_mark_node;\n+      if (this->is_circular_)\n+\tt1 = ptr_type_node;\n+      gcc_assert(t != NULL_TREE && TREE_CODE(t) == POINTER_TYPE);\n+      gcc_assert(TREE_CODE(t1) == POINTER_TYPE);\n+      TREE_TYPE(t) = TREE_TYPE(t1);\n+      return t;\n+\n+    case TYPE_POINTER:\n+      // Don't build a circular data structure. GENERIC can't handle\n+      // it.\n+      if (this->seen_ > 0)\n+\t{\n+\t  this->is_circular_ = true;\n+\t  return ptr_type_node;\n+\t}\n+      ++this->seen_;\n+      t1 = Type::get_named_type_tree(gogo, base);\n+      --this->seen_;\n+      if (t1 == error_mark_node)\n+\treturn error_mark_node;\n+      if (this->is_circular_)\n+\tt1 = ptr_type_node;\n+      gcc_assert(t != NULL_TREE && TREE_CODE(t) == POINTER_TYPE);\n+      gcc_assert(TREE_CODE(t1) == POINTER_TYPE);\n+      TREE_TYPE(t) = TREE_TYPE(t1);\n+      return t;\n+\n+    case TYPE_ARRAY:\n+      if (base->is_open_array_type())\n+\t{\n+\t  if (this->seen_ > 0)\n+\t    return t;\n+\t  else\n+\t    {\n+\t      ++this->seen_;\n+\t      t = base->array_type()->fill_in_slice_tree(gogo, t);\n+\t      --this->seen_;\n+\t    }\n+\t}\n+      return t;\n+\n+    default:\n+    case TYPE_SINK:\n+    case TYPE_CALL_MULTIPLE_RESULT:\n+    case TYPE_NAMED:\n+    case TYPE_FORWARD:\n+      gcc_unreachable();\n+    }\n+\n+  gcc_unreachable();\n }\n \n // Build a type descriptor for a named type."}, {"sha": "8e91dfcab072edf11caedbf3aff1a330a7c2d484", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 81, "deletions": 48, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91349ecb122f1270f57617796fcfe0b597e997a2/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=91349ecb122f1270f57617796fcfe0b597e997a2", "patch": "@@ -799,6 +799,10 @@ class Type\n   check_make_expression(Expression_list* args, source_location location)\n   { return this->do_check_make_expression(args, location); }\n \n+  // Convert the builtin named types.\n+  static void\n+  convert_builtin_named_types(Gogo*);\n+\n   // Return a tree representing this type.\n   tree\n   get_tree(Gogo*);\n@@ -1082,6 +1086,9 @@ class Type\n \n   static Type_trees type_trees;\n \n+  // A list of builtin named types.\n+  static std::vector<Named_type*> named_builtin_types;\n+\n   // The type classification.\n   Type_classification classification_;\n   // The tree representation of the type, once it has been determined.\n@@ -1605,6 +1612,9 @@ class Function_type : public Type\n   Function_type*\n   copy_with_receiver(Type*) const;\n \n+  static Type*\n+  make_function_type_descriptor_type();\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -1636,9 +1646,6 @@ class Function_type : public Type\n   do_export(Export*) const;\n \n  private:\n-  static Type*\n-  make_function_type_descriptor_type();\n-\n   Expression*\n   type_descriptor_params(Type*, const Typed_identifier*,\n \t\t\t const Typed_identifier_list*);\n@@ -1680,6 +1687,9 @@ class Pointer_type : public Type\n   static Pointer_type*\n   do_import(Import*);\n \n+  static Type*\n+  make_pointer_type_descriptor_type();\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -1710,9 +1720,6 @@ class Pointer_type : public Type\n   do_export(Export*) const;\n \n  private:\n-  static Type*\n-  make_pointer_type_descriptor_type();\n-\n   // The type to which this type points.\n   Type* to_type_;\n };\n@@ -1841,8 +1848,7 @@ class Struct_type : public Type\n  public:\n   Struct_type(Struct_field_list* fields, source_location location)\n     : Type(TYPE_STRUCT),\n-      fields_(fields), location_(location), all_methods_(NULL),\n-      prerequisites_()\n+      fields_(fields), location_(location), all_methods_(NULL)\n   { }\n \n   // Return the field NAME.  This only looks at local fields, not at\n@@ -1937,16 +1943,8 @@ class Struct_type : public Type\n   tree\n   fill_in_tree(Gogo*, tree);\n \n-  // Note that a struct must be converted to the backend\n-  // representation before we convert this struct.\n-  void\n-  add_prerequisite(Named_type* nt)\n-  { this->prerequisites_.push_back(nt); }\n-\n-  // If there are any structs which must be converted to the backend\n-  // representation before this one, convert them.\n-  void\n-  convert_prerequisites(Gogo*);\n+  static Type*\n+  make_struct_type_descriptor_type();\n \n  protected:\n   int\n@@ -1992,25 +1990,12 @@ class Struct_type : public Type\n \t\t\tsource_location, Saw_named_type*,\n \t\t\tunsigned int* depth) const;\n \n-  static Type*\n-  make_struct_type_descriptor_type();\n-\n   // The fields of the struct.\n   Struct_field_list* fields_;\n   // The place where the struct was declared.\n   source_location location_;\n   // If this struct is unnamed, a list of methods.\n   Methods* all_methods_;\n-  // A list of structs which must be converted to the backend\n-  // representation before this struct can be converted.  This is for\n-  // cases like\n-  //   type S1 { p *S2 }\n-  //   type S2 { s S1 }\n-  // where we must start converting S2 before we start converting S1.\n-  // That is because we can fully convert S1 before S2 is complete,\n-  // but we can not fully convert S2 before S1 is complete.  If we\n-  // start converting S1 first, we won't be able to convert S2.\n-  std::vector<Named_type*> prerequisites_;\n };\n \n // The type of an array.\n@@ -2066,6 +2051,12 @@ class Array_type : public Type\n   tree\n   fill_in_slice_tree(Gogo*, tree);\n \n+  static Type*\n+  make_array_type_descriptor_type();\n+\n+  static Type*\n+  make_slice_type_descriptor_type();\n+\n  protected:\n   int\n   do_traverse(Traverse* traverse);\n@@ -2114,12 +2105,6 @@ class Array_type : public Type\n   tree\n   get_length_tree(Gogo*);\n \n-  Type*\n-  make_array_type_descriptor_type();\n-\n-  Type*\n-  make_slice_type_descriptor_type();\n-\n   Expression*\n   array_type_descriptor(Gogo*, Named_type*);\n \n@@ -2162,6 +2147,9 @@ class Map_type : public Type\n   static Map_type*\n   do_import(Import*);\n \n+  static Type*\n+  make_map_type_descriptor_type();\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -2202,9 +2190,6 @@ class Map_type : public Type\n   do_export(Export*) const;\n \n  private:\n-  static Type*\n-  make_map_type_descriptor_type();\n-\n   // The key type.\n   Type* key_type_;\n   // The value type.\n@@ -2248,6 +2233,9 @@ class Channel_type : public Type\n   static Channel_type*\n   do_import(Import*);\n \n+  static Type*\n+  make_chan_type_descriptor_type();\n+\n  protected:\n   int\n   do_traverse(Traverse* traverse)\n@@ -2286,9 +2274,6 @@ class Channel_type : public Type\n   do_export(Export*) const;\n \n  private:\n-  static Type*\n-  make_chan_type_descriptor_type();\n-\n   // Whether this channel can send data.\n   bool may_send_;\n   // Whether this channel can receive data.\n@@ -2308,6 +2293,11 @@ class Interface_type : public Type\n       methods_(methods), location_(location)\n   { gcc_assert(methods == NULL || !methods->empty()); }\n \n+  // The location where the interface type was defined.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n   // Return whether this is an empty interface.\n   bool\n   is_empty() const\n@@ -2361,10 +2351,21 @@ class Interface_type : public Type\n   static Interface_type*\n   do_import(Import*);\n \n+  // Make a struct for an empty interface type.\n+  static tree\n+  empty_type_tree(Gogo*);\n+\n+  // Make a struct for non-empty interface type.\n+  static tree\n+  non_empty_type_tree(source_location);\n+\n   // Fill in the fields for a named interface type.\n   tree\n   fill_in_tree(Gogo*, tree);\n \n+  static Type*\n+  make_interface_type_descriptor_type();\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -2395,9 +2396,6 @@ class Interface_type : public Type\n   do_export(Export*) const;\n \n  private:\n-  static Type*\n-  make_interface_type_descriptor_type();\n-\n   // The list of methods associated with the interface.  This will be\n   // NULL for the empty interface.\n   Typed_identifier_list* methods_;\n@@ -2419,8 +2417,9 @@ class Named_type : public Type\n       named_object_(named_object), in_function_(NULL), type_(type),\n       local_methods_(NULL), all_methods_(NULL),\n       interface_method_tables_(NULL), pointer_interface_method_tables_(NULL),\n-      location_(location), named_tree_(NULL), is_visible_(true),\n-      is_error_(false), seen_(0)\n+      location_(location), named_tree_(NULL), dependencies_(),\n+      is_visible_(true), is_error_(false), is_converted_(false),\n+      is_circular_(false), seen_(0)\n   { }\n \n   // Return the associated Named_object.  This holds the actual name.\n@@ -2493,6 +2492,12 @@ class Named_type : public Type\n   is_builtin() const\n   { return this->location_ == BUILTINS_LOCATION; }\n \n+  // Whether this is a circular type: a pointer or function type that\n+  // refers to itself, which is not possible in C.\n+  bool\n+  is_circular() const\n+  { return this->is_circular_; }\n+\n   // Return the base type for this type.\n   Type*\n   named_base();\n@@ -2567,6 +2572,12 @@ class Named_type : public Type\n   bool\n   named_type_has_hidden_fields(std::string* reason) const;\n \n+  // Note that a type must be converted to the backend representation\n+  // before we convert this type.\n+  void\n+  add_dependency(Named_type* nt)\n+  { this->dependencies_.push_back(nt); }\n+\n   // Export the type.\n   void\n   export_named_type(Export*, const std::string& name) const;\n@@ -2575,6 +2586,10 @@ class Named_type : public Type\n   static void\n   import_named_type(Import*, Named_type**);\n \n+  // Initial conversion to backend representation.\n+  void\n+  convert(Gogo*);\n+\n  protected:\n   int\n   do_traverse(Traverse* traverse)\n@@ -2618,6 +2633,10 @@ class Named_type : public Type\n   do_export(Export*) const;\n \n  private:\n+  // Create the placeholder during conversion.\n+  void\n+  create_placeholder(Gogo*);\n+\n   // A mapping from interfaces to the associated interface method\n   // tables for this type.  This maps to a decl.\n   typedef Unordered_map_hash(const Interface_type*, tree, Type_hash_identical,\n@@ -2647,13 +2666,27 @@ class Named_type : public Type\n   // The tree for this type while converting to GENERIC.  This is used\n   // to avoid endless recursion when a named type refers to itself.\n   tree named_tree_;\n+  // A list of types which must be converted to the backend\n+  // representation before this type can be converted.  This is for\n+  // cases like\n+  //   type S1 { p *S2 }\n+  //   type S2 { s S1 }\n+  // where we can't convert S2 to the backend representation unless we\n+  // have converted S1.\n+  std::vector<Named_type*> dependencies_;\n   // Whether this type is visible.  This is false if this type was\n   // created because it was referenced by an imported object, but the\n   // type itself was not exported.  This will always be true for types\n   // created in the current package.\n   bool is_visible_;\n   // Whether this type is erroneous.\n   bool is_error_;\n+  // Whether this type has been converted to the backend\n+  // representation.\n+  bool is_converted_;\n+  // Whether this is a pointer or function type which refers to the\n+  // type itself.\n+  bool is_circular_;\n   // In a recursive operation such as has_hidden_fields, this flag is\n   // used to prevent infinite recursion when a type refers to itself.\n   // This is mutable because it is always reset to false when the"}]}