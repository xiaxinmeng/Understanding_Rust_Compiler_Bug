{"sha": "bb12a72a480421a89e860414cf69065fd4607443", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIxMmE3MmE0ODA0MjFhODllODYwNDE0Y2Y2OTA2NWZkNDYwNzQ0Mw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@davemloft.net", "date": "2011-10-24T03:51:47Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2011-10-24T03:51:47Z"}, "message": "Add support for sparc VIS3 fp<-->int moves.\n\n\t* config/sparc/sparc.h (SECONDARY_MEMORY_NEEDED): We can move\n\tbetween float and non-float regs when VIS3.\n\t* config/sparc/sparc.c (eligible_for_restore_insn): We can't\n\tuse a restore when the source is a float register.\n\t(sparc_split_regreg_legitimate): When VIS3 allow moves between\n\tfloat and integer regs.\n\t(sparc_register_move_cost): Adjust to account for VIS3 moves.\n\t(sparc_preferred_reload_class): On 32-bit with VIS3 when moving an\n\tinteger reg to a class containing EXTRA_FP_REGS, constrain to\n\tFP_REGS.\n\t(sparc_secondary_reload): On 32-bit with VIS3 when moving between\n\tfloat and integer regs we sometimes need a FP_REGS class\n\tintermediate move to satisfy the reload.  When this happens\n\tspecify an extra cost of 2.\n\t(*movsi_insn): Rename to have \"_novis3\" suffix and add !VIS3\n\tguard.\n\t(*movdi_insn_sp32_v9): Likewise.\n\t(*movdi_insn_sp64): Likewise.\n\t(*movsf_insn): Likewise.\n\t(*movdf_insn_sp32_v9): Likewise.\n\t(*movdf_insn_sp64): Likewise.\n\t(*zero_extendsidi2_insn_sp64): Likewise.\n\t(*sign_extendsidi2_insn): Likewise.\n\t(*movsi_insn_vis3): New insn.\n\t(*movdi_insn_sp32_v9_vis3): New insn.\n\t(*movdi_insn_sp64_vis3): New insn.\n\t(*movsf_insn_vis3): New insn.\n\t(*movdf_insn_sp32_v9_vis3): New insn.\n\t(*movdf_insn_sp64_vis3): New insn.\n\t(*zero_extendsidi2_insn_sp64_vis3): New insn.\n\t(*sign_extendsidi2_insn_vis3): New insn.\n\t(TFmode reg/reg split): Make sure both REG operands are float.\n\t(*mov<VM32:mode>_insn): Add \"_novis3\" suffix and !VIS3 guard. Remove\n\teasy constant to integer reg alternatives.\n\t(*mov<VM64:mode>_insn_sp64): Likewise.\n\t(*mov<VM64:mode>_insn_sp32_novis3): Likewise.\n\t(*mov<VM32:mode>_insn_vis3): New insn.\n\t(*mov<VM64:mode>_insn_sp64_vis3): New insn.\n\t(*mov<VM64:mode>_insn_sp32_vis3): New insn.\n\t(VM64 reg<-->reg split): New spliiter for 32-bit.\n\nFrom-SVN: r180360", "tree": {"sha": "5bd9c991eaa0a8e9b848234a50274bca511fcf1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bd9c991eaa0a8e9b848234a50274bca511fcf1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb12a72a480421a89e860414cf69065fd4607443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb12a72a480421a89e860414cf69065fd4607443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb12a72a480421a89e860414cf69065fd4607443", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb12a72a480421a89e860414cf69065fd4607443/comments", "author": {"login": "davem330", "id": 1053866, "node_id": "MDQ6VXNlcjEwNTM4NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1053866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davem330", "html_url": "https://github.com/davem330", "followers_url": "https://api.github.com/users/davem330/followers", "following_url": "https://api.github.com/users/davem330/following{/other_user}", "gists_url": "https://api.github.com/users/davem330/gists{/gist_id}", "starred_url": "https://api.github.com/users/davem330/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davem330/subscriptions", "organizations_url": "https://api.github.com/users/davem330/orgs", "repos_url": "https://api.github.com/users/davem330/repos", "events_url": "https://api.github.com/users/davem330/events{/privacy}", "received_events_url": "https://api.github.com/users/davem330/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1"}], "stats": {"total": 510, "additions": 469, "deletions": 41}, "files": [{"sha": "18424021f505927b1c7d94e754e413debf4931c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb12a72a480421a89e860414cf69065fd4607443/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb12a72a480421a89e860414cf69065fd4607443/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb12a72a480421a89e860414cf69065fd4607443", "patch": "@@ -1,5 +1,46 @@\n 2011-10-23  David S. Miller  <davem@davemloft.net>\n \n+\t* config/sparc/sparc.h (SECONDARY_MEMORY_NEEDED): We can move\n+\tbetween float and non-float regs when VIS3.\n+\t* config/sparc/sparc.c (eligible_for_restore_insn): We can't\n+\tuse a restore when the source is a float register.\n+\t(sparc_split_regreg_legitimate): When VIS3 allow moves between\n+\tfloat and integer regs.\n+\t(sparc_register_move_cost): Adjust to account for VIS3 moves.\n+\t(sparc_preferred_reload_class): On 32-bit with VIS3 when moving an\n+\tinteger reg to a class containing EXTRA_FP_REGS, constrain to\n+\tFP_REGS.\n+\t(sparc_secondary_reload): On 32-bit with VIS3 when moving between\n+\tfloat and integer regs we sometimes need a FP_REGS class\n+\tintermediate move to satisfy the reload.  When this happens\n+\tspecify an extra cost of 2.\n+\t(*movsi_insn): Rename to have \"_novis3\" suffix and add !VIS3\n+\tguard.\n+\t(*movdi_insn_sp32_v9): Likewise.\n+\t(*movdi_insn_sp64): Likewise.\n+\t(*movsf_insn): Likewise.\n+\t(*movdf_insn_sp32_v9): Likewise.\n+\t(*movdf_insn_sp64): Likewise.\n+\t(*zero_extendsidi2_insn_sp64): Likewise.\n+\t(*sign_extendsidi2_insn): Likewise.\n+\t(*movsi_insn_vis3): New insn.\n+\t(*movdi_insn_sp32_v9_vis3): New insn.\n+\t(*movdi_insn_sp64_vis3): New insn.\n+\t(*movsf_insn_vis3): New insn.\n+\t(*movdf_insn_sp32_v9_vis3): New insn.\n+\t(*movdf_insn_sp64_vis3): New insn.\n+\t(*zero_extendsidi2_insn_sp64_vis3): New insn.\n+\t(*sign_extendsidi2_insn_vis3): New insn.\n+\t(TFmode reg/reg split): Make sure both REG operands are float.\n+\t(*mov<VM32:mode>_insn): Add \"_novis3\" suffix and !VIS3 guard. Remove\n+\teasy constant to integer reg alternatives.\n+\t(*mov<VM64:mode>_insn_sp64): Likewise.\n+\t(*mov<VM64:mode>_insn_sp32_novis3): Likewise.\n+\t(*mov<VM32:mode>_insn_vis3): New insn.\n+\t(*mov<VM64:mode>_insn_sp64_vis3): New insn.\n+\t(*mov<VM64:mode>_insn_sp32_vis3): New insn.\n+\t(VM64 reg<-->reg split): New spliiter for 32-bit.\n+\n \t* config/sparc/sparc.c (sparc_split_regreg_legitimate): New\n \tfunction.\n \t* config/sparc/sparc-protos.h (sparc_split_regreg_legitimate):"}, {"sha": "79bb82164cccba30ab316bb8bc68861755545398", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 79, "deletions": 6, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb12a72a480421a89e860414cf69065fd4607443/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb12a72a480421a89e860414cf69065fd4607443/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bb12a72a480421a89e860414cf69065fd4607443", "patch": "@@ -2996,10 +2996,23 @@ eligible_for_restore_insn (rtx trial, bool return_p)\n {\n   rtx pat = PATTERN (trial);\n   rtx src = SET_SRC (pat);\n+  bool src_is_freg = false;\n+  rtx src_reg;\n+\n+  /* Since we now can do moves between float and integer registers when\n+     VIS3 is enabled, we have to catch this case.  We can allow such\n+     moves when doing a 'return' however.  */\n+  src_reg = src;\n+  if (GET_CODE (src_reg) == SUBREG)\n+    src_reg = SUBREG_REG (src_reg);\n+  if (GET_CODE (src_reg) == REG\n+      && SPARC_FP_REG_P (REGNO (src_reg)))\n+    src_is_freg = true;\n \n   /* The 'restore src,%g0,dest' pattern for word mode and below.  */\n   if (GET_MODE_CLASS (GET_MODE (src)) != MODE_FLOAT\n-      && arith_operand (src, GET_MODE (src)))\n+      && arith_operand (src, GET_MODE (src))\n+      && ! src_is_freg)\n     {\n       if (TARGET_ARCH64)\n         return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (DImode);\n@@ -3009,7 +3022,8 @@ eligible_for_restore_insn (rtx trial, bool return_p)\n \n   /* The 'restore src,%g0,dest' pattern for double-word mode.  */\n   else if (GET_MODE_CLASS (GET_MODE (src)) != MODE_FLOAT\n-\t   && arith_double_operand (src, GET_MODE (src)))\n+\t   && arith_double_operand (src, GET_MODE (src))\n+\t   && ! src_is_freg)\n     return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (DImode);\n \n   /* The 'restore src,%g0,dest' pattern for float if no FPU.  */\n@@ -7784,6 +7798,13 @@ sparc_split_regreg_legitimate (rtx reg1, rtx reg2)\n   if (SPARC_INT_REG_P (regno1) && SPARC_INT_REG_P (regno2))\n     return 1;\n \n+  if (TARGET_VIS3)\n+    {\n+      if ((SPARC_INT_REG_P (regno1) && SPARC_FP_REG_P (regno2))\n+\t  || (SPARC_FP_REG_P (regno1) && SPARC_INT_REG_P (regno2)))\n+\treturn 1;\n+    }\n+\n   return 0;\n }\n \n@@ -10302,10 +10323,28 @@ static int\n sparc_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  reg_class_t from, reg_class_t to)\n {\n-  if ((FP_REG_CLASS_P (from) && general_or_i64_p (to))\n-      || (general_or_i64_p (from) && FP_REG_CLASS_P (to))\n-      || from == FPCC_REGS\n-      || to == FPCC_REGS)  \n+  bool need_memory = false;\n+\n+  if (from == FPCC_REGS || to == FPCC_REGS)\n+    need_memory = true;\n+  else if ((FP_REG_CLASS_P (from) && general_or_i64_p (to))\n+\t   || (general_or_i64_p (from) && FP_REG_CLASS_P (to)))\n+    {\n+      if (TARGET_VIS3)\n+\t{\n+\t  int size = GET_MODE_SIZE (mode);\n+\t  if (size == 8 || size == 4)\n+\t    {\n+\t      if (! TARGET_ARCH32 || size == 4)\n+\t\treturn 4;\n+\t      else\n+\t\treturn 6;\n+\t    }\n+\t}\n+      need_memory = true;\n+    }\n+\n+  if (need_memory)\n     {\n       if (sparc_cpu == PROCESSOR_ULTRASPARC\n \t  || sparc_cpu == PROCESSOR_ULTRASPARC3\n@@ -11163,6 +11202,18 @@ sparc_preferred_reload_class (rtx x, reg_class_t rclass)\n \t}\n     }\n \n+  if (TARGET_VIS3\n+      && ! TARGET_ARCH64\n+      && (rclass == EXTRA_FP_REGS\n+\t  || rclass == GENERAL_OR_EXTRA_FP_REGS))\n+    {\n+      int regno = true_regnum (x);\n+\n+      if (SPARC_INT_REG_P (regno))\n+\treturn (rclass == EXTRA_FP_REGS\n+\t\t? FP_REGS : GENERAL_OR_FP_REGS);\n+    }\n+\n   return rclass;\n }\n \n@@ -11275,6 +11326,9 @@ sparc_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n {\n   enum reg_class rclass = (enum reg_class) rclass_i;\n \n+  sri->icode = CODE_FOR_nothing;\n+  sri->extra_cost = 0;\n+\n   /* We need a temporary when loading/storing a HImode/QImode value\n      between memory and the FPU registers.  This can happen when combine puts\n      a paradoxical subreg in a float/fix conversion insn.  */\n@@ -11307,6 +11361,25 @@ sparc_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n       return NO_REGS;\n     }\n \n+  if (TARGET_VIS3 && TARGET_ARCH32)\n+    {\n+      int regno = true_regnum (x);\n+\n+      /* When using VIS3 fp<-->int register moves, on 32-bit we have\n+\t to move 8-byte values in 4-byte pieces.  This only works via\n+\t FP_REGS, and not via EXTRA_FP_REGS.  Therefore if we try to\n+\t move between EXTRA_FP_REGS and GENERAL_REGS, we will need\n+\t an FP_REGS intermediate move.  */\n+      if ((rclass == EXTRA_FP_REGS && SPARC_INT_REG_P (regno))\n+\t  || ((general_or_i64_p (rclass)\n+\t       || rclass == GENERAL_OR_FP_REGS)\n+\t      && SPARC_FP_REG_P (regno)))\n+\t{\n+\t  sri->extra_cost = 2;\n+\t  return FP_REGS;\n+\t}\n+    }\n+\n   return NO_REGS;\n }\n "}, {"sha": "aed18fcb16daec70237b6eaa13d051ab2bba7593", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb12a72a480421a89e860414cf69065fd4607443/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb12a72a480421a89e860414cf69065fd4607443/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=bb12a72a480421a89e860414cf69065fd4607443", "patch": "@@ -1040,10 +1040,13 @@ extern char leaf_reg_remap[];\n #define SPARC_SETHI32_P(X) \\\n   (SPARC_SETHI_P ((unsigned HOST_WIDE_INT) (X) & GET_MODE_MASK (SImode)))\n \n-/* On SPARC it is not possible to directly move data between\n-   GENERAL_REGS and FP_REGS.  */\n+/* On SPARC when not VIS3 it is not possible to directly move data\n+   between GENERAL_REGS and FP_REGS.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n-  (FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2))\n+  ((FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2)) \\\n+   && (! TARGET_VIS3 \\\n+       || GET_MODE_SIZE (MODE) > 8 \\\n+       || GET_MODE_SIZE (MODE) < 4))\n \n /* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on v9\n    because the movsi and movsf patterns don't handle r/f moves."}, {"sha": "0f716d6ee7ca47bcef87039895207cc00284fb2d", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 343, "deletions": 32, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb12a72a480421a89e860414cf69065fd4607443/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb12a72a480421a89e860414cf69065fd4607443/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=bb12a72a480421a89e860414cf69065fd4607443", "patch": "@@ -1312,11 +1312,12 @@\n     DONE;\n })\n \n-(define_insn \"*movsi_insn\"\n+(define_insn \"*movsi_insn_novis3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,m,!f,!f,!m,d,d\")\n \t(match_operand:SI 1 \"input_operand\"   \"rI,K,m,rJ,f,m,f,J,P\"))]\n-  \"(register_operand (operands[0], SImode)\n-    || register_or_zero_or_all_ones_operand (operands[1], SImode))\"\n+  \"(! TARGET_VIS3\n+    && (register_operand (operands[0], SImode)\n+        || register_or_zero_or_all_ones_operand (operands[1], SImode)))\"\n   \"@\n    mov\\t%1, %0\n    sethi\\t%%hi(%a1), %0\n@@ -1329,6 +1330,26 @@\n    fones\\t%0\"\n   [(set_attr \"type\" \"*,*,load,store,fpmove,fpload,fpstore,fga,fga\")])\n \n+(define_insn \"*movsi_insn_vis3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r, m, r,*f,*f,*f, m,d,d\")\n+\t(match_operand:SI 1 \"input_operand\"        \"rI,K,m,rJ,*f, r, f, m,*f,J,P\"))]\n+  \"(TARGET_VIS3\n+    && (register_operand (operands[0], SImode)\n+        || register_or_zero_or_all_ones_operand (operands[1], SImode)))\"\n+  \"@\n+   mov\\t%1, %0\n+   sethi\\t%%hi(%a1), %0\n+   ld\\t%1, %0\n+   st\\t%r1, %0\n+   movstouw\\t%1, %0\n+   movwtos\\t%1, %0\n+   fmovs\\t%1, %0\n+   ld\\t%1, %0\n+   st\\t%1, %0\n+   fzeros\\t%0\n+   fones\\t%0\"\n+  [(set_attr \"type\" \"*,*,load,store,*,*,fpmove,fpload,fpstore,fga,fga\")])\n+\n (define_insn \"*movsi_lo_sum\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -1486,13 +1507,14 @@\n   [(set_attr \"type\" \"store,store,load,*,*,*,*,fpstore,fpload,*,*,*\")\n    (set_attr \"length\" \"2,*,*,2,2,2,2,*,*,2,2,2\")])\n \n-(define_insn \"*movdi_insn_sp32_v9\"\n+(define_insn \"*movdi_insn_sp32_v9_novis3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n \t\t\t\t\t\"=T,o,T,U,o,r,r,r,?T,?f,?f,?o,?e,?e,?W,b,b\")\n         (match_operand:DI 1 \"input_operand\"\n \t\t\t\t\t\" J,J,U,T,r,o,i,r, f, T, o, f, e, W, e,J,P\"))]\n   \"! TARGET_ARCH64\n    && TARGET_V9\n+   && ! TARGET_VIS3\n    && (register_operand (operands[0], DImode)\n        || register_or_zero_operand (operands[1], DImode))\"\n   \"@\n@@ -1517,10 +1539,45 @@\n    (set_attr \"length\" \"*,2,*,*,2,2,2,2,*,*,2,2,*,*,*,*,*\")\n    (set_attr \"fptype\" \"*,*,*,*,*,*,*,*,*,*,*,*,double,*,*,double,double\")])\n \n-(define_insn \"*movdi_insn_sp64\"\n+(define_insn \"*movdi_insn_sp32_v9_vis3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\"\n+\t\t\t\t\t\"=T,o,T,U,o,r,r,r,?T,?*f,?*f,?o,?*e,  r,?*f,?*e,?W,b,b\")\n+        (match_operand:DI 1 \"input_operand\"\n+\t\t\t\t\t\" J,J,U,T,r,o,i,r,*f,  T,  o,*f, *e,?*f,  r,  W,*e,J,P\"))]\n+  \"! TARGET_ARCH64\n+   && TARGET_V9\n+   && TARGET_VIS3\n+   && (register_operand (operands[0], DImode)\n+       || register_or_zero_operand (operands[1], DImode))\"\n+  \"@\n+   stx\\t%%g0, %0\n+   #\n+   std\\t%1, %0\n+   ldd\\t%1, %0\n+   #\n+   #\n+   #\n+   #\n+   std\\t%1, %0\n+   ldd\\t%1, %0\n+   #\n+   #\n+   fmovd\\t%1, %0\n+   #\n+   #\n+   ldd\\t%1, %0\n+   std\\t%1, %0\n+   fzero\\t%0\n+   fone\\t%0\"\n+  [(set_attr \"type\" \"store,store,store,load,*,*,*,*,fpstore,fpload,*,*,*,*,fpmove,fpload,fpstore,fga,fga\")\n+   (set_attr \"length\" \"*,2,*,*,2,2,2,2,*,*,2,2,*,2,2,*,*,*,*\")\n+   (set_attr \"fptype\" \"*,*,*,*,*,*,*,*,*,*,*,*,double,*,*,*,*,double,double\")])\n+\n+(define_insn \"*movdi_insn_sp64_novis3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,m,?e,?e,?W,b,b\")\n         (match_operand:DI 1 \"input_operand\"   \"rI,N,m,rJ,e,W,e,J,P\"))]\n   \"TARGET_ARCH64\n+   && ! TARGET_VIS3\n    && (register_operand (operands[0], DImode)\n        || register_or_zero_or_all_ones_operand (operands[1], DImode))\"\n   \"@\n@@ -1536,6 +1593,28 @@\n   [(set_attr \"type\" \"*,*,load,store,fpmove,fpload,fpstore,fga,fga\")\n    (set_attr \"fptype\" \"*,*,*,*,double,*,*,double,double\")])\n \n+(define_insn \"*movdi_insn_sp64_vis3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r, m, r,*e,?*e,?*e,?W,b,b\")\n+        (match_operand:DI 1 \"input_operand\"        \"rI,N,m,rJ,*e, r, *e,  W,*e,J,P\"))]\n+  \"TARGET_ARCH64\n+   && TARGET_VIS3\n+   && (register_operand (operands[0], DImode)\n+       || register_or_zero_or_all_ones_operand (operands[1], DImode))\"\n+  \"@\n+   mov\\t%1, %0\n+   sethi\\t%%hi(%a1), %0\n+   ldx\\t%1, %0\n+   stx\\t%r1, %0\n+   movdtox\\t%1, %0\n+   movxtod\\t%1, %0\n+   fmovd\\t%1, %0\n+   ldd\\t%1, %0\n+   std\\t%1, %0\n+   fzero\\t%0\n+   fone\\t%0\"\n+  [(set_attr \"type\" \"*,*,load,store,*,*,fpmove,fpload,fpstore,fga,fga\")\n+   (set_attr \"fptype\" \"*,*,*,*,*,*,double,*,*,double,double\")])\n+\n (define_expand \"movdi_pic_label_ref\"\n   [(set (match_dup 3) (high:DI\n      (unspec:DI [(match_operand:DI 1 \"label_ref_operand\" \"\")\n@@ -1933,10 +2012,11 @@\n     DONE;\n })\n \n-(define_insn \"*movsf_insn\"\n+(define_insn \"*movsf_insn_novis3\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=d, d,f,  *r,*r,*r,f,*r,m,   m\")\n \t(match_operand:SF 1 \"input_operand\"        \"GY,ZC,f,*rRY, Q, S,m, m,f,*rGY\"))]\n   \"TARGET_FPU\n+   && ! TARGET_VIS3\n    && (register_operand (operands[0], SFmode)\n        || register_or_zero_or_all_ones_operand (operands[1], SFmode))\"\n {\n@@ -1979,6 +2059,57 @@\n }\n   [(set_attr \"type\" \"fga,fga,fpmove,*,*,*,fpload,load,fpstore,store\")])\n \n+(define_insn \"*movsf_insn_vis3\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=d, d,f,  *r,*r,*r,*r, f, f,*r, m,   m\")\n+\t(match_operand:SF 1 \"input_operand\"        \"GY,ZC,f,*rRY, Q, S, f,*r, m, m, f,*rGY\"))]\n+  \"TARGET_FPU\n+   && TARGET_VIS3\n+   && (register_operand (operands[0], SFmode)\n+       || register_or_zero_or_all_ones_operand (operands[1], SFmode))\"\n+{\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE\n+      && (which_alternative == 3\n+          || which_alternative == 4\n+          || which_alternative == 5))\n+    {\n+      REAL_VALUE_TYPE r;\n+      long i;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+      REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+      operands[1] = GEN_INT (i);\n+    }\n+\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"fzeros\\t%0\";\n+    case 1:\n+      return \"fones\\t%0\";\n+    case 2:\n+      return \"fmovs\\t%1, %0\";\n+    case 3:\n+      return \"mov\\t%1, %0\";\n+    case 4:\n+      return \"sethi\\t%%hi(%a1), %0\";\n+    case 5:\n+      return \"#\";\n+    case 6:\n+      return \"movstouw\\t%1, %0\";\n+    case 7:\n+      return \"movwtos\\t%1, %0\";\n+    case 8:\n+    case 9:\n+      return \"ld\\t%1, %0\";\n+    case 10:\n+    case 11:\n+      return \"st\\t%r1, %0\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"fga,fga,fpmove,*,*,*,*,*,fpload,load,fpstore,store\")])\n+\n ;; Exactly the same as above, except that all `f' cases are deleted.\n ;; This is necessary to prevent reload from ever trying to use a `f' reg\n ;; when -mno-fpu.\n@@ -2107,11 +2238,12 @@\n    (set_attr \"length\" \"*,*,2,2,2\")])\n \n ;; We have available v9 double floats but not 64-bit integer registers.\n-(define_insn \"*movdf_insn_sp32_v9\"\n+(define_insn \"*movdf_insn_sp32_v9_novis3\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=b, b,e,  e, T,W,U,T,  f,     *r,    o\")\n         (match_operand:DF 1 \"input_operand\"        \"GY,ZC,e,W#F,GY,e,T,U,o#F,*roGYDF,*rGYf\"))]\n   \"TARGET_FPU\n    && TARGET_V9\n+   && ! TARGET_VIS3\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n        || register_or_zero_or_all_ones_operand (operands[1], DFmode))\"\n@@ -2131,6 +2263,33 @@\n    (set_attr \"length\" \"*,*,*,*,*,*,*,*,2,2,2\")\n    (set_attr \"fptype\" \"double,double,double,*,*,*,*,*,*,*,*\")])\n \n+(define_insn \"*movdf_insn_sp32_v9_vis3\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=b, b,e,*r, f,  e, T,W,U,T,  f,     *r,    o\")\n+        (match_operand:DF 1 \"input_operand\"        \"GY,ZC,e, f,*r,W#F,GY,e,T,U,o#F,*roGYDF,*rGYf\"))]\n+  \"TARGET_FPU\n+   && TARGET_V9\n+   && TARGET_VIS3\n+   && ! TARGET_ARCH64\n+   && (register_operand (operands[0], DFmode)\n+       || register_or_zero_or_all_ones_operand (operands[1], DFmode))\"\n+  \"@\n+  fzero\\t%0\n+  fone\\t%0\n+  fmovd\\t%1, %0\n+  #\n+  #\n+  ldd\\t%1, %0\n+  stx\\t%r1, %0\n+  std\\t%1, %0\n+  ldd\\t%1, %0\n+  std\\t%1, %0\n+  #\n+  #\n+  #\"\n+  [(set_attr \"type\" \"fga,fga,fpmove,*,*,load,store,store,load,store,*,*,*\")\n+   (set_attr \"length\" \"*,*,*,2,2,*,*,*,*,*,2,2,2\")\n+   (set_attr \"fptype\" \"double,double,double,*,*,*,*,*,*,*,*,*,*\")])\n+\n (define_insn \"*movdf_insn_sp32_v9_no_fpu\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=U,T,T,r,o\")\n \t(match_operand:DF 1 \"input_operand\"    \"T,U,G,ro,rG\"))]\n@@ -2149,10 +2308,11 @@\n    (set_attr \"length\" \"*,*,*,2,2\")])\n \n ;; We have available both v9 double floats and 64-bit integer registers.\n-(define_insn \"*movdf_insn_sp64\"\n+(define_insn \"*movdf_insn_sp64_novis3\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=b, b,e,  e,W,  *r,*r,   m,*r\")\n         (match_operand:DF 1 \"input_operand\"        \"GY,ZC,e,W#F,e,*rGY, m,*rGY,DF\"))]\n   \"TARGET_FPU\n+   && ! TARGET_VIS3\n    && TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n        || register_or_zero_or_all_ones_operand (operands[1], DFmode))\"\n@@ -2170,6 +2330,30 @@\n    (set_attr \"length\" \"*,*,*,*,*,*,*,*,2\")\n    (set_attr \"fptype\" \"double,double,double,*,*,*,*,*,*\")])\n \n+(define_insn \"*movdf_insn_sp64_vis3\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=b, b,e,*r, e,  e,W,  *r,*r,   m,*r\")\n+        (match_operand:DF 1 \"input_operand\"        \"GY,ZC,e, e,*r,W#F,e,*rGY, m,*rGY,DF\"))]\n+  \"TARGET_FPU\n+   && TARGET_ARCH64\n+   && TARGET_VIS3\n+   && (register_operand (operands[0], DFmode)\n+       || register_or_zero_or_all_ones_operand (operands[1], DFmode))\"\n+  \"@\n+  fzero\\t%0\n+  fone\\t%0\n+  fmovd\\t%1, %0\n+  movdtox\\t%1, %0\n+  movxtod\\t%1, %0\n+  ldd\\t%1, %0\n+  std\\t%1, %0\n+  mov\\t%r1, %0\n+  ldx\\t%1, %0\n+  stx\\t%r1, %0\n+  #\"\n+  [(set_attr \"type\" \"fga,fga,fpmove,*,*,load,store,*,load,store,*\")\n+   (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,2\")\n+   (set_attr \"fptype\" \"double,double,double,double,double,*,*,*,*,*,*\")])\n+\n (define_insn \"*movdf_insn_sp64_no_fpu\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m\")\n         (match_operand:DF 1 \"input_operand\"    \"r,m,rG\"))]\n@@ -2444,7 +2628,8 @@\n    && (! TARGET_ARCH64\n        || (TARGET_FPU\n            && ! TARGET_HARD_QUAD)\n-       || ! fp_register_operand (operands[0], TFmode))\"\n+       || (! fp_register_operand (operands[0], TFmode)\n+           && ! fp_register_operand (operands[1], TFmode)))\"\n   [(clobber (const_int 0))]\n {\n   rtx set_dest = operands[0];\n@@ -2944,15 +3129,29 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*zero_extendsidi2_insn_sp64\"\n+(define_insn \"*zero_extendsidi2_insn_sp64_novis3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:DI (match_operand:SI 1 \"input_operand\" \"r,m\")))]\n-  \"TARGET_ARCH64 && GET_CODE (operands[1]) != CONST_INT\"\n+  \"TARGET_ARCH64\n+   && ! TARGET_VIS3\n+   && GET_CODE (operands[1]) != CONST_INT\"\n   \"@\n    srl\\t%1, 0, %0\n    lduw\\t%1, %0\"\n   [(set_attr \"type\" \"shift,load\")])\n \n+(define_insn \"*zero_extendsidi2_insn_sp64_vis3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:DI (match_operand:SI 1 \"input_operand\" \"r,m,*f\")))]\n+  \"TARGET_ARCH64\n+   && TARGET_VIS3\n+   && GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   srl\\t%1, 0, %0\n+   lduw\\t%1, %0\n+   movstouw\\t%1, %0\"\n+  [(set_attr \"type\" \"shift,load,*\")])\n+\n (define_insn_and_split \"*zero_extendsidi2_insn_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\")))]\n@@ -3276,16 +3475,27 @@\n   \"TARGET_ARCH64\"\n   \"\")\n \n-(define_insn \"*sign_extendsidi2_insn\"\n+(define_insn \"*sign_extendsidi2_insn_novis3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(sign_extend:DI (match_operand:SI 1 \"input_operand\" \"r,m\")))]\n-  \"TARGET_ARCH64\"\n+  \"TARGET_ARCH64 && ! TARGET_VIS3\"\n   \"@\n   sra\\t%1, 0, %0\n   ldsw\\t%1, %0\"\n   [(set_attr \"type\" \"shift,sload\")\n    (set_attr \"us3load_type\" \"*,3cycle\")])\n \n+(define_insn \"*sign_extendsidi2_insn_vis3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n+\t(sign_extend:DI (match_operand:SI 1 \"input_operand\" \"r,m,*f\")))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\"\n+  \"@\n+  sra\\t%1, 0, %0\n+  ldsw\\t%1, %0\n+  movstosw\\t%1, %0\"\n+  [(set_attr \"type\" \"shift,sload,*\")\n+   (set_attr \"us3load_type\" \"*,3cycle,*\")])\n+\n \n ;; Special pattern for optimizing bit-field compares.  This is needed\n ;; because combine uses this as a canonical form.\n@@ -7769,10 +7979,11 @@\n     DONE;\n })\n \n-(define_insn \"*mov<VM32:mode>_insn\"\n-  [(set (match_operand:VM32 0 \"nonimmediate_operand\" \"=f, f,f,f,m, m,r,m, r, r\")\n-\t(match_operand:VM32 1 \"input_operand\"        \"GY,ZC,f,m,f,GY,m,r,GY,ZC\"))]\n+(define_insn \"*mov<VM32:mode>_insn_novis3\"\n+  [(set (match_operand:VM32 0 \"nonimmediate_operand\" \"=f, f,f,f,m, m,r,m,*r\")\n+\t(match_operand:VM32 1 \"input_operand\"        \"GY,ZC,f,m,f,GY,m,r,*r\"))]\n   \"TARGET_VIS\n+   && ! TARGET_VIS3\n    && (register_operand (operands[0], <VM32:MODE>mode)\n        || register_or_zero_or_all_ones_operand (operands[1], <VM32:MODE>mode))\"\n   \"@\n@@ -7784,14 +7995,35 @@\n   st\\t%r1, %0\n   ld\\t%1, %0\n   st\\t%1, %0\n-  mov\\t0, %0\n-  mov\\t-1, %0\"\n-  [(set_attr \"type\" \"fga,fga,fga,fpload,fpstore,store,load,store,*,*\")])\n+  mov\\t%1, %0\"\n+  [(set_attr \"type\" \"fga,fga,fga,fpload,fpstore,store,load,store,*\")])\n \n-(define_insn \"*mov<VM64:mode>_insn_sp64\"\n-  [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e, e,e,e,m, m,r,m, r, r\")\n-\t(match_operand:VM64 1 \"input_operand\"        \"GY,ZC,e,m,e,GY,m,r,GY,ZC\"))]\n+(define_insn \"*mov<VM32:mode>_insn_vis3\"\n+  [(set (match_operand:VM32 0 \"nonimmediate_operand\" \"=f, f,f,f,m, m,*r, m,*r,*r, f\")\n+\t(match_operand:VM32 1 \"input_operand\"        \"GY,ZC,f,m,f,GY, m,*r,*r, f,*r\"))]\n   \"TARGET_VIS\n+   && TARGET_VIS3\n+   && (register_operand (operands[0], <VM32:MODE>mode)\n+       || register_or_zero_or_all_ones_operand (operands[1], <VM32:MODE>mode))\"\n+  \"@\n+  fzeros\\t%0\n+  fones\\t%0\n+  fsrc1s\\t%1, %0\n+  ld\\t%1, %0\n+  st\\t%1, %0\n+  st\\t%r1, %0\n+  ld\\t%1, %0\n+  st\\t%1, %0\n+  mov\\t%1, %0\n+  movstouw\\t%1, %0\n+  movwtos\\t%1, %0\"\n+  [(set_attr \"type\" \"fga,fga,fga,fpload,fpstore,store,load,store,*,*,*\")])\n+\n+(define_insn \"*mov<VM64:mode>_insn_sp64_novis3\"\n+  [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e, e,e,e,m, m,r,m,*r\")\n+\t(match_operand:VM64 1 \"input_operand\"        \"GY,ZC,e,m,e,GY,m,r,*r\"))]\n+  \"TARGET_VIS\n+   && ! TARGET_VIS3\n    && TARGET_ARCH64\n    && (register_operand (operands[0], <VM64:MODE>mode)\n        || register_or_zero_or_all_ones_operand (operands[1], <VM64:MODE>mode))\"\n@@ -7804,14 +8036,36 @@\n   stx\\t%r1, %0\n   ldx\\t%1, %0\n   stx\\t%1, %0\n-  mov\\t0, %0\n-  mov\\t-1, %0\"\n-  [(set_attr \"type\" \"fga,fga,fga,fpload,fpstore,store,load,store,*,*\")])\n+  mov\\t%1, %0\"\n+  [(set_attr \"type\" \"fga,fga,fga,fpload,fpstore,store,load,store,*\")])\n \n-(define_insn \"*mov<VM64:mode>_insn_sp32\"\n-  [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e, e,e,e,m, m,U,T,o, r, r\")\n-\t(match_operand:VM64 1 \"input_operand\"        \"GY,ZC,e,m,e,GY,T,U,r,GY,ZC\"))]\n+(define_insn \"*mov<VM64:mode>_insn_sp64_vis3\"\n+  [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e, e,e,e,m, m,*r, m,*r, f,*r\")\n+\t(match_operand:VM64 1 \"input_operand\"        \"GY,ZC,e,m,e,GY, m,*r, f,*r,*r\"))]\n   \"TARGET_VIS\n+   && TARGET_VIS3\n+   && TARGET_ARCH64\n+   && (register_operand (operands[0], <VM64:MODE>mode)\n+       || register_or_zero_or_all_ones_operand (operands[1], <VM64:MODE>mode))\"\n+  \"@\n+  fzero\\t%0\n+  fone\\t%0\n+  fsrc1\\t%1, %0\n+  ldd\\t%1, %0\n+  std\\t%1, %0\n+  stx\\t%r1, %0\n+  ldx\\t%1, %0\n+  stx\\t%1, %0\n+  movdtox\\t%1, %0\n+  movxtod\\t%1, %0\n+  mov\\t%1, %0\"\n+  [(set_attr \"type\" \"fga,fga,fga,fpload,fpstore,store,load,store,*,*,*\")])\n+\n+(define_insn \"*mov<VM64:mode>_insn_sp32_novis3\"\n+  [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e, e,e,e,m, m,U,T,o,*r\")\n+\t(match_operand:VM64 1 \"input_operand\"        \"GY,ZC,e,m,e,GY,T,U,r,*r\"))]\n+  \"TARGET_VIS\n+   && ! TARGET_VIS3\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], <VM64:MODE>mode)\n        || register_or_zero_or_all_ones_operand (operands[1], <VM64:MODE>mode))\"\n@@ -7825,10 +8079,33 @@\n   ldd\\t%1, %0\n   std\\t%1, %0\n   #\n-  mov 0, %L0; mov 0, %H0\n-  mov -1, %L0; mov -1, %H0\"\n-  [(set_attr \"type\" \"fga,fga,fga,fpload,fpstore,store,load,store,*,*,*\")\n-   (set_attr \"length\" \"*,*,*,*,*,*,*,*,2,2,2\")])\n+  #\"\n+  [(set_attr \"type\" \"fga,fga,fga,fpload,fpstore,store,load,store,*,*\")\n+   (set_attr \"length\" \"*,*,*,*,*,*,*,*,2,2\")])\n+\n+(define_insn \"*mov<VM64:mode>_insn_sp32_vis3\"\n+  [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e, e,e,*r, f,e,m, m,U,T, o,*r\")\n+\t(match_operand:VM64 1 \"input_operand\"        \"GY,ZC,e, f,*r,m,e,GY,T,U,*r,*r\"))]\n+  \"TARGET_VIS\n+   && TARGET_VIS3\n+   && ! TARGET_ARCH64\n+   && (register_operand (operands[0], <VM64:MODE>mode)\n+       || register_or_zero_or_all_ones_operand (operands[1], <VM64:MODE>mode))\"\n+  \"@\n+  fzero\\t%0\n+  fone\\t%0\n+  fsrc1\\t%1, %0\n+  #\n+  #\n+  ldd\\t%1, %0\n+  std\\t%1, %0\n+  stx\\t%r1, %0\n+  ldd\\t%1, %0\n+  std\\t%1, %0\n+  #\n+  #\"\n+  [(set_attr \"type\" \"fga,fga,fga,*,*,fpload,fpstore,store,load,store,*,*\")\n+   (set_attr \"length\" \"*,*,*,2,2,*,*,*,*,*,2,2\")])\n \n (define_split\n   [(set (match_operand:VM64 0 \"memory_operand\" \"\")\n@@ -7851,6 +8128,40 @@\n   DONE;\n })\n \n+(define_split\n+  [(set (match_operand:VM64 0 \"register_operand\" \"\")\n+        (match_operand:VM64 1 \"register_operand\" \"\"))]\n+  \"reload_completed\n+   && TARGET_VIS\n+   && ! TARGET_ARCH64\n+   && sparc_split_regreg_legitimate (operands[0], operands[1])\"\n+  [(clobber (const_int 0))]\n+{\n+  rtx set_dest = operands[0];\n+  rtx set_src = operands[1];\n+  rtx dest1, dest2;\n+  rtx src1, src2;\n+\n+  dest1 = gen_highpart (SImode, set_dest);\n+  dest2 = gen_lowpart (SImode, set_dest);\n+  src1 = gen_highpart (SImode, set_src);\n+  src2 = gen_lowpart (SImode, set_src);\n+\n+  /* Now emit using the real source and destination we found, swapping\n+     the order if we detect overlap.  */\n+  if (reg_overlap_mentioned_p (dest1, src2))\n+    {\n+      emit_insn (gen_movsi (dest2, src2));\n+      emit_insn (gen_movsi (dest1, src1));\n+    }\n+  else\n+    {\n+      emit_insn (gen_movsi (dest1, src1));\n+      emit_insn (gen_movsi (dest2, src2));\n+    }\n+  DONE;\n+})\n+\n (define_expand \"vec_init<mode>\"\n   [(match_operand:VMALL 0 \"register_operand\" \"\")\n    (match_operand:VMALL 1 \"\" \"\")]"}]}