{"sha": "62828c0078f54356ccc4d81136bd2ef6c68e9b7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI4MjhjMDA3OGY1NDM1NmNjYzRkODExMzZiZDJlZjZjNjhlOWI3Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-07T23:33:47Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-07T23:33:47Z"}, "message": "flow.c (loop_depth): Remove.\n\n\t* flow.c (loop_depth): Remove.\n\t(reg_next_use, cc0_live, mem_set_list): Replace with ...\n\t(struct propagate_block_info): New.\n\t(life_analysis): Don't allocate reg_next_use.\n\t(propagate_block_delete_insn): Break out of propagate_block.\n\tUse flow_delete_insn to unlink rather than use NOTE_INSN_DELETED.\n\t(propagate_block_delete_libcall): Likewise.\n\t(propagate_block): Create a propagate_block_info struct to pass\n\tto subroutines.  Allocate one not two temporary regsets.  Don't\n\tclobber memory for const calls.  Look for clobbers in\n\tCALL_INSN_FUNCTION_USAGE.\n\t(mark_set_regs): Recognize COND_EXEC.\n\t(mark_set_reg): Break out of mark_set_1.\n\t(mark_used_reg): Break out of mark_used_regs.\n\t(mark_used_regs): Recognize COND_EXEC.\n\t(insn_dead_p): Use propagate_block_info struct.\n\t(libcall_dead_p, invalidate_mems_from_autoinc): Likewise.\n\t(find_auto_inc, try_pre_increment_1): Likewise.\n\t(print_rtl_with_bb): Dump regs live at end too.\n\t(count_reg_sets_1): Pass in loop_depth.\n\t(count_reg_sets, count_reg_references): Likewise.\n\t(recompute_reg_usage): Provide it.\n\nFrom-SVN: r33012", "tree": {"sha": "6f5803593cbd6ead55d5dee13f78940d641c0d19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f5803593cbd6ead55d5dee13f78940d641c0d19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62828c0078f54356ccc4d81136bd2ef6c68e9b7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62828c0078f54356ccc4d81136bd2ef6c68e9b7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62828c0078f54356ccc4d81136bd2ef6c68e9b7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62828c0078f54356ccc4d81136bd2ef6c68e9b7b/comments", "author": null, "committer": null, "parents": [{"sha": "4f0207119fb3bf380997ea865fecf19d4398d688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0207119fb3bf380997ea865fecf19d4398d688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f0207119fb3bf380997ea865fecf19d4398d688"}], "stats": {"total": 1135, "additions": 618, "deletions": 517}, "files": [{"sha": "f99fa3c398efc18e3b3bfd7258fe64b84f9a6e1e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62828c0078f54356ccc4d81136bd2ef6c68e9b7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62828c0078f54356ccc4d81136bd2ef6c68e9b7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62828c0078f54356ccc4d81136bd2ef6c68e9b7b", "patch": "@@ -1,3 +1,28 @@\n+2000-04-07  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (loop_depth): Remove.\n+\t(reg_next_use, cc0_live, mem_set_list): Replace with ...\n+\t(struct propagate_block_info): New.\n+\t(life_analysis): Don't allocate reg_next_use.\n+\t(propagate_block_delete_insn): Break out of propagate_block.\n+\tUse flow_delete_insn to unlink rather than use NOTE_INSN_DELETED.\n+\t(propagate_block_delete_libcall): Likewise.\n+\t(propagate_block): Create a propagate_block_info struct to pass\n+\tto subroutines.  Allocate one not two temporary regsets.  Don't\n+\tclobber memory for const calls.  Look for clobbers in\n+\tCALL_INSN_FUNCTION_USAGE.\n+\t(mark_set_regs): Recognize COND_EXEC.\n+\t(mark_set_reg): Break out of mark_set_1.\n+\t(mark_used_reg): Break out of mark_used_regs.\n+\t(mark_used_regs): Recognize COND_EXEC.\n+\t(insn_dead_p): Use propagate_block_info struct.\n+\t(libcall_dead_p, invalidate_mems_from_autoinc): Likewise.\n+\t(find_auto_inc, try_pre_increment_1): Likewise.\n+\t(print_rtl_with_bb): Dump regs live at end too.\n+\t(count_reg_sets_1): Pass in loop_depth.\n+\t(count_reg_sets, count_reg_references): Likewise.\n+\t(recompute_reg_usage): Provide it.\n+\n 2000-04-07  Richard Henderson  <rth@cygnus.com>\n \n \t* Makefile.in (conflict.o): Depend on $(RTL_H) and $(BASIC_BLOCK_H)"}, {"sha": "ea386232ea7bea821b3b63981722c4570cb76c66", "filename": "gcc/flow.c", "status": "modified", "additions": 593, "deletions": 517, "changes": 1110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62828c0078f54356ccc4d81136bd2ef6c68e9b7b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62828c0078f54356ccc4d81136bd2ef6c68e9b7b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=62828c0078f54356ccc4d81136bd2ef6c68e9b7b", "patch": "@@ -225,12 +225,6 @@ varray_type reg_n_info;\n \n unsigned int reg_n_max;\n \n-/* Element N is the next insn that uses (hard or pseudo) register number N\n-   within the current basic block; or zero, if there is no such insn.\n-   This is valid only during the final backward scan in propagate_block.  */\n-\n-static rtx *reg_next_use;\n-\n /* Size of a regset for the current function,\n    in (1) bytes and (2) elements.  */\n \n@@ -248,20 +242,6 @@ regset regs_live_at_setjmp;\n    are another pair, etc.  */\n rtx regs_may_share;\n \n-/* Depth within loops of basic block being scanned for lifetime analysis,\n-   plus one.  This is the weight attached to references to registers.  */\n-\n-static int loop_depth;\n-\n-/* During propagate_block, this is non-zero if the value of CC0 is live.  */\n-\n-static int cc0_live;\n-\n-/* During propagate_block, this contains a list of all the MEMs we are\n-   tracking for dead store elimination.  */\n-\n-static rtx mem_set_list;\n-\n /* Set of registers that may be eliminable.  These are handled specially\n    in updating regs_ever_live.  */\n \n@@ -277,6 +257,35 @@ varray_type basic_block_for_insn;\n \n static rtx label_value_list;\n \n+/* For use in communicating between propagate_block and its subroutines.\n+   Holds all information needed to compute life and def-use information.  */\n+\n+struct propagate_block_info\n+{\n+  /* The basic block we're considering.  */\n+  basic_block bb;\n+\n+  /* Bit N is set if register N is conditionally or unconditionally live.  */\n+  regset reg_live;\n+\n+  /* Element N is the next insn that uses (hard or pseudo) register N\n+     within the current basic block; or zero, if there is no such insn.  */\n+  rtx *reg_next_use;\n+\n+  /* Contains a list of all the MEMs we are tracking for dead store\n+     elimination.  */\n+  rtx mem_set_list;\n+\n+  /* If non-null, record the set of registers set in the basic block.  */\n+  regset local_set;\n+\n+  /* Non-zero if the value of CC0 is live.  */\n+  int cc0_live;\n+\n+  /* Flags controling the set of information propagate_block collects.  */\n+  int flags;\n+};\n+\n /* Forward declarations */\n static int count_basic_blocks\t\tPARAMS ((rtx));\n static rtx find_basic_blocks_1\t\tPARAMS ((rtx));\n@@ -317,28 +326,41 @@ static void mark_reg\t\t\tPARAMS ((rtx, void *));\n static void mark_regs_live_at_end\tPARAMS ((regset));\n static int set_phi_alternative_reg      PARAMS ((rtx, int, int, void *));\n static void calculate_global_regs_live\tPARAMS ((sbitmap, sbitmap, int));\n+static void propagate_block_delete_insn PARAMS ((basic_block, rtx));\n+static rtx propagate_block_delete_libcall PARAMS ((basic_block, rtx, rtx));\n static void propagate_block\t\tPARAMS ((basic_block, regset,\n \t\t\t\t\t\t regset, int));\n-static int insn_dead_p\t\t\tPARAMS ((rtx, regset, int, rtx));\n-static int libcall_dead_p\t\tPARAMS ((rtx, regset, rtx, rtx));\n-static void mark_set_regs\t\tPARAMS ((regset, regset, rtx,\n-\t\t\t\t\t\t rtx, regset, int));\n-static void mark_set_1\t\t\tPARAMS ((regset, regset, rtx,\n-\t\t\t\t\t\t rtx, regset, int));\n+static int insn_dead_p\t\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t rtx, int, rtx));\n+static int libcall_dead_p\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t rtx, rtx, rtx));\n+static void mark_set_regs\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t regset, rtx, rtx));\n+static void mark_set_1\t\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t regset, rtx, rtx, rtx));\n+static int mark_set_reg\t\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t regset, rtx, rtx,\n+\t\t\t\t\t\t int *, int *));\n #ifdef AUTO_INC_DEC\n-static void find_auto_inc\t\tPARAMS ((regset, rtx, rtx));\n-static int try_pre_increment_1\t\tPARAMS ((rtx));\n+static void find_auto_inc\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t rtx, rtx));\n+static int try_pre_increment_1\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t rtx));\n static int try_pre_increment\t\tPARAMS ((rtx, rtx, HOST_WIDE_INT));\n #endif\n-static void mark_used_regs\t\tPARAMS ((regset, regset, rtx, int, rtx));\n+static void mark_used_reg\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t regset, rtx, rtx, rtx));\n+static void mark_used_regs\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t regset, rtx, rtx, rtx));\n void dump_flow_info\t\t\tPARAMS ((FILE *));\n void debug_flow_info\t\t\tPARAMS ((void));\n static void dump_edge_info\t\tPARAMS ((FILE *, edge, int));\n \n-static void count_reg_sets_1\t\tPARAMS ((rtx));\n-static void count_reg_sets\t\tPARAMS ((rtx));\n-static void count_reg_references\tPARAMS ((rtx));\n-static void invalidate_mems_from_autoinc PARAMS ((rtx));\n+static void count_reg_sets_1\t\tPARAMS ((rtx, int));\n+static void count_reg_sets\t\tPARAMS ((rtx, int));\n+static void count_reg_references\tPARAMS ((rtx, int));\n+static void invalidate_mems_from_autoinc PARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t  rtx));\n static void remove_fake_successors\tPARAMS ((basic_block));\n static void flow_nodes_print\tPARAMS ((const char *, const sbitmap, FILE *));\n static void flow_exits_print PARAMS ((const char *, const edge *, int, FILE *));\n@@ -2558,7 +2580,6 @@ life_analysis (f, nregs, file, remove_dead_code)\n      data from lifetime analysis.  */\n   allocate_reg_life_data ();\n   allocate_bb_life_data ();\n-  reg_next_use = (rtx *) xcalloc (nregs, sizeof (rtx));\n   all_blocks = sbitmap_alloc (n_basic_blocks);\n   sbitmap_ones (all_blocks);\n \n@@ -2575,8 +2596,6 @@ life_analysis (f, nregs, file, remove_dead_code)\n \n   /* Clean up.  */\n   sbitmap_free (all_blocks);\n-  free (reg_next_use);\n-  reg_next_use = NULL;\n   end_alias_analysis ();\n \n   if (file)\n@@ -2675,9 +2694,8 @@ verify_local_live_at_start (new_live_at_start, bb)\n \n    BLOCK_FOR_INSN is assumed to be correct.\n \n-   PROP_FLAGS should not contain PROP_LOG_LINKS unless the caller sets\n-   up reg_next_use.  Including PROP_REG_INFO does not properly refresh\n-   regs_ever_live unless the caller resets it to zero.  */\n+   Including PROP_REG_INFO does not properly refresh regs_ever_live\n+   unless the caller resets it to zero.  */\n \n void\n update_life_info (blocks, extent, prop_flags)\n@@ -3217,57 +3235,108 @@ allocate_reg_life_data ()\n     }\n }\n \n-/* Compute the registers live at the beginning of a basic block\n-   from those live at the end.\n+/* Delete dead instructions for propagate_block.  */\n+\n+static void\n+propagate_block_delete_insn (bb, insn)\n+     basic_block bb;\n+     rtx insn;\n+{\n+  rtx inote = find_reg_note (insn, REG_LABEL, NULL_RTX);\n \n-   When called, OLD contains those live at the end.\n-   On return, it contains those live at the beginning.\n-   FIRST and LAST are the first and last insns of the basic block.\n+  /* If the insn referred to a label, and that label was attached to\n+     an ADDR_VEC, it's safe to delete the ADDR_VEC.  In fact, it's\n+     pretty much mandatory to delete it, because the ADDR_VEC may be\n+     referencing labels that no longer exist.  */\n \n-   FINAL is nonzero if we are doing the final pass which is not\n-   for computing the life info (since that has already been done)\n-   but for acting on it.  On this pass, we delete dead stores,\n-   set up the logical links and dead-variables lists of instructions,\n-   and merge instructions for autoincrement and autodecrement addresses.\n+  if (inote)\n+    {\n+      rtx label = XEXP (inote, 0);\n+      rtx next;\n \n-   SIGNIFICANT is nonzero only the first time for each basic block.\n-   If it is nonzero, it points to a regset in which we store\n-   a 1 for each register that is set within the block.\n+      if (LABEL_NUSES (label) == 1\n+\t  && (next = next_nonnote_insn (label)) != NULL\n+\t  && GET_CODE (next) == JUMP_INSN\n+\t  && (GET_CODE (PATTERN (next)) == ADDR_VEC\n+\t      || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n+\t{\n+\t  rtx pat = PATTERN (next);\n+\t  int diff_vec_p = GET_CODE (pat) == ADDR_DIFF_VEC;\n+\t  int len = XVECLEN (pat, diff_vec_p);\n+\t  int i;\n \n-   BNUM is the number of the basic block.  */\n+\t  for (i = 0; i < len; i++)\n+\t    LABEL_NUSES (XEXP (XVECEXP (pat, diff_vec_p, i), 0))--;\n \n-static void\n-propagate_block (bb, old, significant, flags)\n+\t  flow_delete_insn (next);\n+\t}\n+    }\n+\n+  if (bb->end == insn)\n+    bb->end = PREV_INSN (insn);\n+  flow_delete_insn (insn);\n+}\n+\n+/* Delete dead libcalls for propagate_block.  Return the insn\n+   before the libcall.  */\n+\n+static rtx\n+propagate_block_delete_libcall (bb, insn, note)\n      basic_block bb;\n-     regset old;\n-     regset significant;\n-     int flags;\n+     rtx insn, note;\n {\n-  register rtx insn;\n-  rtx prev;\n-  regset live;\n-  regset_head live_head;\n-  regset dead;\n-  regset_head dead_head;\n+  rtx first = XEXP (note, 0);\n+  rtx before = PREV_INSN (first);\n \n-  /* Find the loop depth for this block.  Ignore loop level changes in the\n-     middle of the basic block -- for register allocation purposes, the \n-     important uses will be in the blocks wholely contained within the loop\n-     not in the loop pre-header or post-trailer.  */\n-  loop_depth = bb->loop_depth;\n+  if (insn == bb->end)\n+    bb->end = before;\n+  \n+  flow_delete_insn_chain (first, insn);\n+  return before;\n+}\n+\n+/* Compute the registers live at the beginning of a basic block BB from\n+   those live at the end.\n \n-  dead = INITIALIZE_REG_SET (live_head);\n-  live = INITIALIZE_REG_SET (dead_head);\n+   When called, REG_LIVE contains those live at the end.  On return, it\n+   contains those live at the beginning.\n \n-  cc0_live = 0;\n+   LOCAL_SET, if non-null, will be set with all registers killed by \n+   this basic block.  */\n+\n+static void\n+propagate_block (bb, live, local_set, flags)\n+     basic_block bb;\n+     regset live;\n+     regset local_set;\n+     int flags;\n+{\n+  struct propagate_block_info pbi;\n+  rtx insn, prev;\n+  regset_head tmp_head;\n+  regset tmp;\n+  \n+  pbi.bb = bb;\n+  pbi.reg_live = live;\n+  pbi.mem_set_list = NULL_RTX;\n+  pbi.local_set = local_set;\n+  pbi.cc0_live = 0;\n+  pbi.flags = flags;\n+\n+  if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n+    pbi.reg_next_use = (rtx *) xcalloc (max_reg_num (), sizeof (rtx));\n+  else\n+    pbi.reg_next_use = NULL;\n+\n+  tmp = INITIALIZE_REG_SET (tmp_head);\n \n   if (flags & PROP_REG_INFO)\n     {\n       register int i;\n \n       /* Process the regs live at the end of the block.\n \t Mark them as not local to any one basic block. */\n-      EXECUTE_IF_SET_IN_REG_SET (old, 0, i,\n+      EXECUTE_IF_SET_IN_REG_SET (live, 0, i,\n \t\t\t\t {\n \t\t\t\t   REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL;\n \t\t\t\t });\n@@ -3286,7 +3355,7 @@ propagate_block (bb, old, significant, flags)\n \n \t  if ((flags & PROP_REG_INFO)\n \t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n-\t    IOR_REG_SET (regs_live_at_setjmp, old);\n+\t    IOR_REG_SET (regs_live_at_setjmp, pbi.reg_live);\n \t}\n \n       /* Update the life-status of regs for this insn.\n@@ -3305,10 +3374,10 @@ propagate_block (bb, old, significant, flags)\n \n \t  if (flags & PROP_SCAN_DEAD_CODE)\n \t    {\n-\t      insn_is_dead = insn_dead_p (PATTERN (insn), old, 0,\n+\t      insn_is_dead = insn_dead_p (&pbi, PATTERN (insn), 0,\n \t\t\t\t\t  REG_NOTES (insn));\n \t      libcall_is_dead = (insn_is_dead && note != 0\n-\t                         && libcall_dead_p (PATTERN (insn), old,\n+\t                         && libcall_dead_p (&pbi, PATTERN (insn),\n \t\t\t\t\t\t    note, insn));\n \t    }\n \n@@ -3331,84 +3400,25 @@ propagate_block (bb, old, significant, flags)\n \t    }\n \n \t  /* If an instruction consists of just dead store(s) on final pass,\n-\t     \"delete\" it by turning it into a NOTE of type NOTE_INSN_DELETED.\n-\t     We could really delete it with delete_insn, but that\n-\t     can cause trouble for first or last insn in a basic block.  */\n+\t     delete it.  */\n \t  if ((flags & PROP_KILL_DEAD_CODE) && insn_is_dead)\n \t    {\n-\t      rtx inote;\n-\t      /* If the insn referred to a label, note that the label is\n-\t\t now less used.  */\n-\t      for (inote = REG_NOTES (insn); inote; inote = XEXP (inote, 1))\n+\t      if (libcall_is_dead)\n \t\t{\n-\t\t  if (REG_NOTE_KIND (inote) == REG_LABEL)\n-\t\t    {\n-\t\t      rtx label = XEXP (inote, 0);\n-\t\t      rtx next;\n-\t\t      LABEL_NUSES (label)--;\n-\n-\t\t      /* If this label was attached to an ADDR_VEC, it's\n-\t\t\t safe to delete the ADDR_VEC.  In fact, it's pretty\n-\t\t\t much mandatory to delete it, because the ADDR_VEC may\n-\t\t\t be referencing labels that no longer exist.  */\n-\t\t      if (LABEL_NUSES (label) == 0\n-\t\t\t  && (next = next_nonnote_insn (label)) != NULL\n-\t\t\t  && GET_CODE (next) == JUMP_INSN\n-\t\t\t  && (GET_CODE (PATTERN (next)) == ADDR_VEC\n-\t\t\t      || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n-\t\t\t{\n-\t\t\t  rtx pat = PATTERN (next);\n-\t\t\t  int diff_vec_p = GET_CODE (pat) == ADDR_DIFF_VEC;\n-\t\t\t  int len = XVECLEN (pat, diff_vec_p);\n-\t\t\t  int i;\n-\t\t\t  for (i = 0; i < len; i++)\n-\t\t\t    LABEL_NUSES (XEXP (XVECEXP (pat, diff_vec_p, i), 0))--;\n-\t\t\t  PUT_CODE (next, NOTE);\n-\t\t\t  NOTE_LINE_NUMBER (next) = NOTE_INSN_DELETED;\n-\t\t\t  NOTE_SOURCE_FILE (next) = 0;\n-\n-\t\t\t  if ((next = next_nonnote_insn (label)) != NULL\n-\t\t\t      && GET_CODE (next) == BARRIER)\n-\t\t\t    {\n-\t\t\t      PUT_CODE (next, NOTE);\n-\t\t\t      NOTE_LINE_NUMBER (next) = NOTE_INSN_DELETED;\n-\t\t\t      NOTE_SOURCE_FILE (next) = 0;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n+\t\t  prev = propagate_block_delete_libcall (bb, insn, note);\n+\t\t  insn = NEXT_INSN (prev);\n \t\t}\n-\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n+\t      else\n+\t\tpropagate_block_delete_insn (bb, insn);\n \n \t      /* CC0 is now known to be dead.  Either this insn used it,\n \t\t in which case it doesn't anymore, or clobbered it,\n \t\t so the next insn can't use it.  */\n-\t      cc0_live = 0;\n+\t      pbi.cc0_live = 0;\n \n-\t      /* If this insn is copying the return value from a library call,\n-\t\t delete the entire library call.  */\n-\t      if (libcall_is_dead)\n-\t\t{\n-\t\t  rtx first = XEXP (note, 0);\n-\t\t  rtx p = insn;\n-\t\t  while (INSN_DELETED_P (first))\n-\t\t    first = NEXT_INSN (first);\n-\t\t  while (p != first)\n-\t\t    {\n-\t\t      p = PREV_INSN (p);\n-\t\t      PUT_CODE (p, NOTE);\n-\t\t      NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;\n-\t\t      NOTE_SOURCE_FILE (p) = 0;\n-\t\t    }\n-\t\t}\n \t      goto flushed;\n \t    }\n \n-\t  CLEAR_REG_SET (dead);\n-\t  CLEAR_REG_SET (live);\n-\n \t  /* See if this is an increment or decrement that can be\n \t     merged into a following memory address.  */\n #ifdef AUTO_INC_DEC\n@@ -3428,20 +3438,22 @@ propagate_block (bb, old, significant, flags)\n \t\t   If one is found, change the memory ref to a PRE_INC\n \t\t   or PRE_DEC, cancel this insn, and return 1.\n \t\t   Return 0 if nothing has been done.  */\n-\t\t&& try_pre_increment_1 (insn))\n+\t\t&& try_pre_increment_1 (&pbi, insn))\n \t      goto flushed;\n \t  }\n #endif /* AUTO_INC_DEC */\n \n+\t  CLEAR_REG_SET (tmp);\n+\n \t  /* If this is not the final pass, and this insn is copying the\n \t     value of a library call and it's dead, don't scan the\n \t     insns that perform the library call, so that the call's\n \t     arguments are not marked live.  */\n \t  if (libcall_is_dead)\n \t    {\n-\t      /* Mark the dest reg as `significant'.  */\n-\t      mark_set_regs (old, dead, PATTERN (insn), NULL_RTX,\n-\t\t\t     significant, flags);\n+\t      /* Record the death of the dest reg.  */\n+\t      mark_set_regs (&pbi, tmp, PATTERN (insn), insn);\n+\t      AND_COMPL_REG_SET (pbi.reg_live, tmp);\n \n \t      insn = XEXP (note, 0);\n \t      prev = PREV_INSN (insn);\n@@ -3464,95 +3476,121 @@ propagate_block (bb, old, significant, flags)\n \n \t      if (GET_CODE (insn) == CALL_INSN\n \t\t  && (flags & PROP_REG_INFO))\n-\t\tEXECUTE_IF_SET_IN_REG_SET (old, 0, i,\n-\t\t\t\t\t   {\n-\t\t\t\t\t     REG_N_CALLS_CROSSED (i)++;\n-\t\t\t\t\t   });\n+\t\tEXECUTE_IF_SET_IN_REG_SET (pbi.reg_live, 0, i,\n+\t\t\t\t\t   { REG_N_CALLS_CROSSED (i)++; });\n+\n+\t      /* Record sets.  Do this even for dead instructions,\n+\t\t since they would have killed the values if they hadn't\n+\t\t been deleted.  */\n+\t      mark_set_regs (&pbi, tmp, PATTERN (insn), insn);\n+\n+\t      /* Each call clobbers all call-clobbered regs that are not\n+\t\t global or fixed.  Note that the function-value reg is a\n+\t\t call-clobbered reg, and mark_set_regs has already had\n+\t\t a chance to handle it.  */\n+\t      if (GET_CODE (insn) == CALL_INSN)\n+\t\t{\n+\t\t  register int i;\n+\t\t  rtx cond;\n+\n+\t\t  cond = NULL_RTX;\n+\t\t  if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n+\t\t    cond = COND_EXEC_TEST (PATTERN (insn));\n+\n+\t\t  /* Non-constant calls clobber memory.  */\n+\t\t  if (! CONST_CALL_P (insn))\n+\t\t    free_EXPR_LIST_list (&pbi.mem_set_list);\n+\n+\t\t  /* There may be extra registers to be clobbered.  */\n+\t          for (note = CALL_INSN_FUNCTION_USAGE (insn);\n+\t\t       note;\n+\t\t       note = XEXP (note, 1))\n+\t\t    if (GET_CODE (XEXP (note, 0)) == CLOBBER)\n+\t\t      mark_set_1 (&pbi, tmp, XEXP (XEXP (note, 0), 0),\n+\t\t\t\t  cond, insn);\n \n-\t      /* LIVE gets the regs used in INSN;\n-\t\t DEAD gets those set by it.  Dead insns don't make anything\n-\t\t live.  */\n+\t\t  /* Calls change all call-used and global registers.  */\n+\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\t    if (call_used_regs[i] && ! global_regs[i]\n+\t\t\t&& ! fixed_regs[i])\n+\t\t      {\n+\t\t\tint dummy;\n+\t\t        mark_set_reg (&pbi, tmp,\n+\t\t\t\t      gen_rtx_REG (reg_raw_mode[i], i),\n+\t\t\t\t      cond, &dummy, &dummy);\n+\t\t      }\n+\t\t}\n \n-\t      mark_set_regs (old, dead, PATTERN (insn),\n-\t\t\t     insn, significant, flags);\n+\t      /* Update live for the registers killed.  */\n+\t      AND_COMPL_REG_SET (pbi.reg_live, tmp);\n+\t      CLEAR_REG_SET (tmp);\n \n \t      /* If an insn doesn't use CC0, it becomes dead since we \n \t\t assume that every insn clobbers it.  So show it dead here;\n \t\t mark_used_regs will set it live if it is referenced.  */\n-\t      cc0_live = 0;\n+\t      pbi.cc0_live = 0;\n \n+\t      /* Record uses.  */\n \t      if (! insn_is_dead)\n-\t\tmark_used_regs (old, live, PATTERN (insn), flags, insn);\n+\t\tmark_used_regs (&pbi, tmp, PATTERN (insn), NULL_RTX, insn);\n \n-\t      /* Sometimes we may have inserted something before INSN (such as\n-\t\t a move) when we make an auto-inc.  So ensure we will scan\n-\t\t those insns.  */\n+\t      /* Sometimes we may have inserted something before INSN\n+\t\t (such as a move) when we make an auto-inc.  So ensure\n+\t\t we will scan those insns.  */\n #ifdef AUTO_INC_DEC\n \t      prev = PREV_INSN (insn);\n #endif\n \n \t      if (! insn_is_dead && GET_CODE (insn) == CALL_INSN)\n \t\t{\n \t\t  register int i;\n+\t\t  rtx note, cond;\n \n-\t\t  rtx note;\n+\t\t  cond = NULL_RTX;\n+\t\t  if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n+\t\t    cond = COND_EXEC_TEST (PATTERN (insn));\n \n \t          for (note = CALL_INSN_FUNCTION_USAGE (insn);\n \t\t       note;\n \t\t       note = XEXP (note, 1))\n \t\t    if (GET_CODE (XEXP (note, 0)) == USE)\n-\t\t      mark_used_regs (old, live, XEXP (XEXP (note, 0), 0),\n-\t\t\t\t      flags, insn);\n-\n-\t\t  /* Each call clobbers all call-clobbered regs that are not\n-\t\t     global or fixed.  Note that the function-value reg is a\n-\t\t     call-clobbered reg, and mark_set_regs has already had\n-\t\t     a chance to handle it.  */\n-\n-\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t    if (call_used_regs[i] && ! global_regs[i]\n-\t\t\t&& ! fixed_regs[i])\n-\t\t      {\n-\t\t        SET_REGNO_REG_SET (dead, i);\n-\t\t\tif (significant)\n-\t\t          SET_REGNO_REG_SET (significant, i);\n-\t\t      }\n+\t\t      mark_used_regs (&pbi, tmp, XEXP (XEXP (note, 0), 0),\n+\t\t\t\t      cond, insn);\n \n \t\t  /* The stack ptr is used (honorarily) by a CALL insn.  */\n-\t\t  SET_REGNO_REG_SET (live, STACK_POINTER_REGNUM);\n+\t\t  SET_REGNO_REG_SET (tmp, STACK_POINTER_REGNUM);\n \n \t\t  /* Calls may also reference any of the global registers,\n \t\t     so they are made live.  */\n \t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\t    if (global_regs[i])\n-\t\t      mark_used_regs (old, live,\n-\t\t\t\t      gen_rtx_REG (reg_raw_mode[i], i),\n-\t\t\t\t      flags, insn);\n-\n-\t\t  /* Calls also clobber memory.  */\n-\t\t  free_EXPR_LIST_list (&mem_set_list);\n+\t\t      mark_used_reg (&pbi, tmp,\n+\t\t\t\t     gen_rtx_REG (reg_raw_mode[i], i),\n+\t\t\t\t     cond, insn);\n \t\t}\n \n-\t      /* Update OLD for the registers used or set.  */\n-\t      AND_COMPL_REG_SET (old, dead);\n-\t      IOR_REG_SET (old, live);\n-\n+\t      /* Update live for the registers used.  */\n+\t      IOR_REG_SET (pbi.reg_live, tmp);\n \t    }\n \n \t  /* On final pass, update counts of how many insns in which\n \t     each reg is live.  */\n \t  if (flags & PROP_REG_INFO)\n-\t    EXECUTE_IF_SET_IN_REG_SET (old, 0, i, { REG_LIVE_LENGTH (i)++; });\n+\t    EXECUTE_IF_SET_IN_REG_SET (pbi.reg_live, 0, i,\n+\t\t\t\t       { REG_LIVE_LENGTH (i)++; });\n \t}\n     flushed:\n       if (insn == bb->head)\n \tbreak;\n     }\n \n-  FREE_REG_SET (dead);\n-  FREE_REG_SET (live);\n-  free_EXPR_LIST_list (&mem_set_list);\n+  FREE_REG_SET (tmp);\n+  free_EXPR_LIST_list (&pbi.mem_set_list);\n+\n+  if (pbi.reg_next_use)\n+    free (pbi.reg_next_use);\n }\n+\n \f\n /* Return 1 if X (the body of an insn, or part of it) is just dead stores\n    (SET expressions whose destinations are registers dead after the insn).\n@@ -3564,9 +3602,9 @@ propagate_block (bb, old, significant, flags)\n    pertaining to the insn.  */\n \n static int\n-insn_dead_p (x, needed, call_ok, notes)\n+insn_dead_p (pbi, x, call_ok, notes)\n+     struct propagate_block_info *pbi;\n      rtx x;\n-     regset needed;\n      int call_ok;\n      rtx notes ATTRIBUTE_UNUSED;\n {\n@@ -3585,7 +3623,7 @@ insn_dead_p (x, needed, call_ok, notes)\n \n \t      /* Don't delete insns to set global regs.  */\n \t      if ((regno < FIRST_PSEUDO_REGISTER && global_regs[regno])\n-\t\t  || REGNO_REG_SET_P (needed, regno))\n+\t\t  || REGNO_REG_SET_P (pbi->reg_live, regno))\n \t\treturn 0;\n \t    }\n \t}\n@@ -3601,7 +3639,7 @@ insn_dead_p (x, needed, call_ok, notes)\n \n #ifdef HAVE_cc0\n       if (GET_CODE (r) == CC0)\n-\treturn ! cc0_live;\n+\treturn ! pbi->cc0_live;\n #endif\n       \n       /* A SET that is a subroutine call cannot be dead.  */\n@@ -3626,7 +3664,7 @@ insn_dead_p (x, needed, call_ok, notes)\n \t     and see if one is an identical match to this memory location.\n \t     If so, this memory write is dead (remember, we're walking\n \t     backwards from the end of the block to the start.  */\n-\t  temp = mem_set_list;\n+\t  temp = pbi->mem_set_list;\n \t  while (temp)\n \t    {\n \t      if (rtx_equal_p (XEXP (temp, 0), r))\n@@ -3646,7 +3684,7 @@ insn_dead_p (x, needed, call_ok, notes)\n \t      int regno = REGNO (r);\n \n \t      /* Obvious.  */\n-\t      if (REGNO_REG_SET_P (needed, regno))\n+\t      if (REGNO_REG_SET_P (pbi->reg_live, regno))\n \t\treturn 0;\n \n \t      /* If this is a hard register, verify that subsequent\n@@ -3656,7 +3694,7 @@ insn_dead_p (x, needed, call_ok, notes)\n \t\t  int n = HARD_REGNO_NREGS (regno, GET_MODE (r));\n \n \t\t  while (--n > 0)\n-\t\t    if (REGNO_REG_SET_P (needed, regno+n))\n+\t\t    if (REGNO_REG_SET_P (pbi->reg_live, regno+n))\n \t\t      return 0;\n \t\t}\n \n@@ -3703,7 +3741,7 @@ insn_dead_p (x, needed, call_ok, notes)\n       for (i--; i >= 0; i--)\n \tif (GET_CODE (XVECEXP (x, 0, i)) != CLOBBER\n \t    && GET_CODE (XVECEXP (x, 0, i)) != USE\n-\t    && ! insn_dead_p (XVECEXP (x, 0, i), needed, call_ok, NULL_RTX))\n+\t    && ! insn_dead_p (pbi, XVECEXP (x, 0, i), call_ok, NULL_RTX))\n \t  return 0;\n \n       return 1;\n@@ -3713,7 +3751,7 @@ insn_dead_p (x, needed, call_ok, notes)\n      is not necessarily true for hard registers.  */\n   else if (code == CLOBBER && GET_CODE (XEXP (x, 0)) == REG\n \t   && REGNO (XEXP (x, 0)) >= FIRST_PSEUDO_REGISTER\n-\t   && ! REGNO_REG_SET_P (needed, REGNO (XEXP (x, 0))))\n+\t   && ! REGNO_REG_SET_P (pbi->reg_live, REGNO (XEXP (x, 0))))\n     return 1;\n \n   /* We do not check other CLOBBER or USE here.  An insn consisting of just\n@@ -3736,9 +3774,9 @@ insn_dead_p (x, needed, call_ok, notes)\n    NOTE is the REG_RETVAL note of the insn.  INSN is the insn itself.  */\n \n static int\n-libcall_dead_p (x, needed, note, insn)\n+libcall_dead_p (pbi, x, note, insn)\n+     struct propagate_block_info *pbi;\n      rtx x;\n-     regset needed;\n      rtx note;\n      rtx insn;\n {\n@@ -3781,7 +3819,7 @@ libcall_dead_p (x, needed, note, insn)\n \t      call_pat = XVECEXP (call_pat, 0, i);\n \t    }\n \n-\t  return insn_dead_p (call_pat, needed, 1, REG_NOTES (call));\n+\t  return insn_dead_p (pbi, call_pat, 1, REG_NOTES (call));\n \t}\n     }\n   return 1;\n@@ -3826,15 +3864,16 @@ regno_clobbered_at_setjmp (regno)\n    Find any entries on the mem_set_list that need to be invalidated due\n    to an address change.  */\n static void\n-invalidate_mems_from_autoinc (insn)\n+invalidate_mems_from_autoinc (pbi, insn)\n+     struct propagate_block_info *pbi;\n      rtx insn;\n {\n   rtx note = REG_NOTES (insn);\n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n     {\n       if (REG_NOTE_KIND (note) == REG_INC)\n         {\n-          rtx temp = mem_set_list;\n+          rtx temp = pbi->mem_set_list;\n           rtx prev = NULL_RTX;\n \t  rtx next;\n \n@@ -3847,7 +3886,7 @@ invalidate_mems_from_autoinc (insn)\n \t          if (prev)\n \t            XEXP (prev, 1) = next;\n \t          else\n-\t            mem_set_list = next;\n+\t            pbi->mem_set_list = next;\n \t\t  free_EXPR_LIST_node (temp);\n \t        }\n \t      else\n@@ -3866,44 +3905,71 @@ invalidate_mems_from_autoinc (insn)\n    FLAGS is the set of operations to perform.  */\n \n static void\n-mark_set_regs (needed, dead, x, insn, significant, flags)\n-     regset needed;\n-     regset dead;\n-     rtx x;\n-     rtx insn;\n-     regset significant;\n-     int flags;\n+mark_set_regs (pbi, new_dead, x, insn)\n+     struct propagate_block_info *pbi;\n+     regset new_dead;\n+     rtx x, insn;\n {\n-  register RTX_CODE code = GET_CODE (x);\n+  rtx cond = NULL_RTX;\n \n-  if (code == SET || code == CLOBBER)\n-    mark_set_1 (needed, dead, x, insn, significant, flags);\n-  else if (code == PARALLEL)\n+ retry:\n+  switch (GET_CODE (x))\n     {\n-      register int i;\n-      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\t{\n-\t  code = GET_CODE (XVECEXP (x, 0, i));\n-\t  if (code == SET || code == CLOBBER)\n-\t    mark_set_1 (needed, dead, XVECEXP (x, 0, i), insn,\n-\t\t\tsignificant, flags);\n-\t}\n+    case SET:\n+    case CLOBBER:\n+      mark_set_1 (pbi, new_dead, SET_DEST (x), cond, insn);\n+      return;\n+\n+    case COND_EXEC:\n+      cond = COND_EXEC_TEST (x);\n+      x = COND_EXEC_CODE (x);\n+      goto retry;\n+\n+    case PARALLEL:\n+      {\n+\tregister int i;\n+\tfor (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\t  {\n+\t    rtx sub = XVECEXP (x, 0, i);\n+\t    switch (GET_CODE (sub))\n+\t      {\n+\t      case COND_EXEC:\n+\t\tif (cond != NULL_RTX)\n+\t\t  abort ();\n+\n+\t\tcond = COND_EXEC_TEST (sub);\n+\t\tsub = COND_EXEC_CODE (sub);\n+\t\tif (GET_CODE (sub) != SET && GET_CODE (sub) != CLOBBER)\n+\t\t  break;\n+\t\t/* FALLTHRU */\n+\n+\t      case SET:\n+\t      case CLOBBER:\n+\t\tmark_set_1 (pbi, new_dead, SET_DEST (sub), cond, insn);\n+\t\tbreak;\n+\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tbreak;\n+      }\n+\n+    default:\n+      break;\n     }\n }\n \n /* Process a single SET rtx, X.  */\n \n static void\n-mark_set_1 (needed, dead, x, insn, significant, flags)\n-     regset needed;\n-     regset dead;\n-     rtx x;\n-     rtx insn;\n-     regset significant;\n-     int flags;\n+mark_set_1 (pbi, new_dead, reg, cond, insn)\n+     struct propagate_block_info *pbi;\n+     regset new_dead;\n+     rtx reg, cond, insn;\n {\n   register int regno = -1;\n-  register rtx reg = SET_DEST (x);\n+  int flags = pbi->flags;\n \n   /* Some targets place small structures in registers for\n      return values of functions.  We have to detect this\n@@ -3914,8 +3980,7 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n       register int i;\n \n       for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\tmark_set_1 (needed, dead, XVECEXP (reg, 0, i), insn,\n-\t\t    significant, flags);\n+\tmark_set_1 (pbi, new_dead, XVECEXP (reg, 0, i), cond, insn);\n       return;\n     }\n \n@@ -3940,10 +4005,9 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n      If this set is a REG, then it kills any MEMs which use the reg.  */\n   if (flags & PROP_SCAN_DEAD_CODE)\n     {\n-      if (GET_CODE (reg) == MEM\n-\t  || GET_CODE (reg) == REG)\n+      if (GET_CODE (reg) == MEM || GET_CODE (reg) == REG)\n \t{\n-\t  rtx temp = mem_set_list;\n+\t  rtx temp = pbi->mem_set_list;\n \t  rtx prev = NULL_RTX;\n \t  rtx next;\n \n@@ -3959,7 +4023,7 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n \t\t  if (prev)\n \t\t    XEXP (prev, 1) = next;\n \t\t  else\n-\t\t    mem_set_list = next;\n+\t\t    pbi->mem_set_list = next;\n \t\t  free_EXPR_LIST_node (temp);\n \t\t}\n \t      else\n@@ -3972,7 +4036,7 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n \t address modes.  Then we may need to kill some entries on the\n \t memory set list.  */\n       if (insn && GET_CODE (reg) == MEM)\n-\tinvalidate_mems_from_autoinc (insn);\n+\tinvalidate_mems_from_autoinc (pbi, insn);\n \n       if (GET_CODE (reg) == MEM && ! side_effects_p (reg)\n \t  /* We do not know the size of a BLKmode store, so we do not track\n@@ -3982,7 +4046,7 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n \t     everything that invalidates it.  To be safe, don't eliminate any\n \t     stores though SP; none of them should be redundant anyway.  */\n \t  && ! reg_mentioned_p (stack_pointer_rtx, reg))\n-\tmem_set_list = alloc_EXPR_LIST (0, reg, mem_set_list);\n+\tpbi->mem_set_list = alloc_EXPR_LIST (0, reg, pbi->mem_set_list);\n     }\n \n   if (GET_CODE (reg) == REG\n@@ -3996,54 +4060,25 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n       && ! (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n #endif\n-      && ! (regno < FIRST_PSEUDO_REGISTER && global_regs[regno]))\n-      /* && regno != STACK_POINTER_REGNUM) -- let's try without this.  */\n+      )\n     {\n-      int some_needed = REGNO_REG_SET_P (needed, regno);\n-      int some_not_needed = ! some_needed;\n-\n-      /* Mark it as a significant register for this basic block.  */\n-      if (significant)\n-\tSET_REGNO_REG_SET (significant, regno);\n-\n-      /* Mark it as dead before this insn.  */\n-      SET_REGNO_REG_SET (dead, regno);\n-\n-      /* A hard reg in a wide mode may really be multiple registers.\n-\t If so, mark all of them just like the first.  */\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  int n;\n+      int some_was_live, some_was_dead;\n \n-\t  /* Nothing below is needed for the stack pointer; get out asap.\n-\t     Eg, log links aren't needed, since combine won't use them.  */\n-\t  if (regno == STACK_POINTER_REGNUM)\n-\t    return;\n-\n-\t  n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\t  while (--n > 0)\n-\t    {\n-\t      int regno_n = regno + n;\n-\t      int needed_regno = REGNO_REG_SET_P (needed, regno_n);\n-\t      if (significant)\n-\t\tSET_REGNO_REG_SET (significant, regno_n);\n-\n-\t      SET_REGNO_REG_SET (dead, regno_n);\n-\t      some_needed |= needed_regno;\n-\t      some_not_needed |= ! needed_regno;\n-\t    }\n-\t}\n+      /* Perform the pbi datastructure update.  */\n+      if (! mark_set_reg (pbi, new_dead, reg, cond,\n+\t\t\t  &some_was_live, &some_was_dead))\n+\treturn;\n \n       /* Additional data to record if this is the final pass.  */\n       if (flags & (PROP_LOG_LINKS | PROP_REG_INFO\n \t\t   | PROP_DEATH_NOTES | PROP_AUTOINC))\n \t{\n \t  register rtx y;\n-\t  register int blocknum = BLOCK_NUM (insn);\n+\t  register int blocknum = pbi->bb->index;\n \n \t  y = NULL_RTX;\n \t  if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n-\t    y = reg_next_use[regno];\n+\t    y = pbi->reg_next_use[regno];\n \n \t  /* If this is a hard reg, record this function uses the reg.  */\n \n@@ -4057,7 +4092,7 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n \t\t  {\n \t\t    /* The next use is no longer \"next\", since a store\n \t\t       intervenes.  */\n-\t\t    reg_next_use[i] = 0;\n+\t\t    pbi->reg_next_use[i] = 0;\n \t\t  }\n \n \t      if (flags & PROP_REG_INFO)\n@@ -4072,7 +4107,7 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n \t      /* The next use is no longer \"next\", since a store\n \t\t intervenes.  */\n \t      if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n-\t        reg_next_use[regno] = 0;\n+\t        pbi->reg_next_use[regno] = 0;\n \n \t      /* Keep track of which basic blocks each reg appears in.  */\n \n@@ -4086,7 +4121,7 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n \t          /* Count (weighted) references, stores, etc.  This counts a\n \t\t     register twice if it is modified, but that is correct.  */\n \t          REG_N_SETS (regno)++;\n-\t          REG_N_REFS (regno) += loop_depth + 1;\n+\t          REG_N_REFS (regno) += pbi->bb->loop_depth + 1;\n \t\t  \n \t          /* The insns where a reg is live are normally counted\n \t\t     elsewhere, but we want the count to include the insn\n@@ -4096,7 +4131,7 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n \t\t}\n \t    }\n \n-\t  if (! some_not_needed)\n+\t  if (! some_was_dead)\n \t    {\n \t      if (flags & PROP_LOG_LINKS)\n \t\t{\n@@ -4115,7 +4150,7 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n \t\t    LOG_LINKS (y) = alloc_INSN_LIST (insn, LOG_LINKS (y));\n \t\t}\n \t    }\n-\t  else if (! some_needed)\n+\t  else if (! some_was_live)\n \t    {\n \t      if (flags & PROP_REG_INFO)\n \t\tREG_N_DEATHS (REGNO (reg))++;\n@@ -4145,7 +4180,7 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n \n \t\t  for (i = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1;\n \t\t       i >= 0; i--)\n-\t\t    if (!REGNO_REG_SET_P (needed, regno + i))\n+\t\t    if (! REGNO_REG_SET_P (pbi->reg_live, regno + i))\n \t\t      REG_NOTES (insn)\n \t\t\t= (alloc_EXPR_LIST\n \t\t\t   (REG_UNUSED,\n@@ -4158,7 +4193,7 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n   else if (GET_CODE (reg) == REG)\n     {\n       if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n-\treg_next_use[regno] = 0;\n+\tpbi->reg_next_use[regno] = 0;\n     }\n \n   /* If this is the last pass and this is a SCRATCH, show it will be dying\n@@ -4170,15 +4205,73 @@ mark_set_1 (needed, dead, x, insn, significant, flags)\n \t  = alloc_EXPR_LIST (REG_UNUSED, reg, REG_NOTES (insn));\n     }\n }\n+\n+/* Update data structures for a (possibly conditional) store into REG.\n+   Return true if REG is now unconditionally dead.  */\n+\n+static int\n+mark_set_reg (pbi, new_dead, reg, cond, p_some_was_live, p_some_was_dead)\n+     struct propagate_block_info *pbi;\n+     regset new_dead;\n+     rtx reg;\n+     rtx cond ATTRIBUTE_UNUSED;\n+     int *p_some_was_live, *p_some_was_dead;\n+{\n+  int regno = REGNO (reg);\n+  int some_was_live = REGNO_REG_SET_P (pbi->reg_live, regno);\n+  int some_was_dead = ! some_was_live;\n+\n+  /* Mark it as a significant register for this basic block.  */\n+  if (pbi->local_set)\n+    SET_REGNO_REG_SET (pbi->local_set, regno);\n+\n+  /* A hard reg in a wide mode may really be multiple registers.\n+     If so, mark all of them just like the first.  */\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      int n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      while (--n > 0)\n+\t{\n+\t  int regno_n = regno + n;\n+\t  int needed_regno = REGNO_REG_SET_P (pbi->reg_live, regno_n);\n+\t  if (pbi->local_set)\n+\t    SET_REGNO_REG_SET (pbi->local_set, regno_n);\n+\n+\t  some_was_live |= needed_regno;\n+\t  some_was_dead |= ! needed_regno;\n+\t}\n+    }\n+\n+  *p_some_was_live = some_was_live;\n+  *p_some_was_dead = some_was_dead;\n+\n+  /* The stack pointer is never dead.  Well, not strictly true, but it's\n+     very difficult to tell from here.  Hopefully combine_stack_adjustments\n+     will fix up the most egregious errors.  */\n+  if (regno == STACK_POINTER_REGNUM)\n+    return 0;\n+\n+  /* Mark it as dead before this insn.  */\n+  SET_REGNO_REG_SET (new_dead, regno);\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      int n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      while (--n > 0)\n+\tSET_REGNO_REG_SET (new_dead, regno + n);\n+    }\n+\n+  /* Unconditionally dead.  */\n+  return 1;\n+}\n \f\n #ifdef AUTO_INC_DEC\n \n /* X is a MEM found in INSN.  See if we can convert it into an auto-increment\n    reference.  */\n \n static void\n-find_auto_inc (needed, x, insn)\n-     regset needed;\n+find_auto_inc (pbi, x, insn)\n+     struct propagate_block_info *pbi;\n      rtx x;\n      rtx insn;\n {\n@@ -4201,7 +4294,7 @@ find_auto_inc (needed, x, insn)\n       int regno = REGNO (addr);\n \n       /* Is the next use an increment that might make auto-increment? */\n-      if ((incr = reg_next_use[regno]) != 0\n+      if ((incr = pbi->reg_next_use[regno]) != 0\n \t  && (set = single_set (incr)) != 0\n \t  && GET_CODE (set) == SET\n \t  && BLOCK_NUM (incr) == BLOCK_NUM (insn)\n@@ -4290,18 +4383,18 @@ find_auto_inc (needed, x, insn)\n \t      if (GET_CODE (PREV_INSN (insn)) == INSN\n \t\t  && GET_CODE (PATTERN (PREV_INSN (insn))) == SET\n \t\t  && SET_SRC (PATTERN (PREV_INSN (insn))) == addr)\n-\t\treg_next_use[regno] = PREV_INSN (insn);\n+\t\tpbi->reg_next_use[regno] = PREV_INSN (insn);\n \t      else\n-\t\treg_next_use[regno] = 0;\n+\t\tpbi->reg_next_use[regno] = 0;\n \n \t      addr = q;\n \t      regno = REGNO (q);\n \n-\t      /* REGNO is now used in INCR which is below INSN, but\n-\t\t it previously wasn't live here.  If we don't mark\n-\t\t it as needed, we'll put a REG_DEAD note for it\n-\t\t on this insn, which is incorrect.  */\n-\t      SET_REGNO_REG_SET (needed, regno);\n+\t      /* REGNO is now used in INCR which is below INSN, but it\n+\t\t previously wasn't live here.  If we don't mark it as\n+\t\t live, we'll put a REG_DEAD note for it on this insn,\n+\t\t which is incorrect.  */\n+\t      SET_REGNO_REG_SET (pbi->reg_live, regno);\n \n \t      /* If there are any calls between INSN and INCR, show\n \t\t that REGNO now crosses them.  */\n@@ -4339,7 +4432,7 @@ find_auto_inc (needed, x, insn)\n \t      /* Count an extra reference to the reg.  When a reg is\n \t\t incremented, spilling it is worse, so we want to make\n \t\t that less likely.  */\n-\t      REG_N_REFS (regno) += loop_depth + 1;\n+\t      REG_N_REFS (regno) += pbi->bb->loop_depth + 1;\n \n \t      /* Count the increment as a setting of the register,\n \t\t even though it isn't a SET in rtl.  */\n@@ -4350,26 +4443,143 @@ find_auto_inc (needed, x, insn)\n }\n #endif /* AUTO_INC_DEC */\n \f\n-/* Scan expression X and store a 1-bit in LIVE for each reg it uses.\n-   This is done assuming the registers needed from X\n-   are those that have 1-bits in NEEDED.\n+static void\n+mark_used_reg (pbi, new_live, reg, cond, insn)\n+     struct propagate_block_info *pbi;\n+     regset new_live;\n+     rtx reg;\n+     rtx cond ATTRIBUTE_UNUSED;\n+     rtx insn;\n+{\n+  int regno = REGNO (reg);\n+  int some_was_live = REGNO_REG_SET_P (pbi->reg_live, regno);\n+  int some_was_dead = ! some_was_live;\n+\n+  SET_REGNO_REG_SET (new_live, regno);\n+\n+  /* A hard reg in a wide mode may really be multiple registers.\n+     If so, mark all of them just like the first.  */\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      int n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      while (--n > 0)\n+\t{\n+\t  int regno_n = regno + n;\n+\t  int needed_regno = REGNO_REG_SET_P (pbi->reg_live, regno_n);\n+\n+\t  SET_REGNO_REG_SET (new_live, regno_n);\n+\t  some_was_live |= needed_regno;\n+\t  some_was_dead |= ! needed_regno;\n+\t}\n+    }\n+\n+  if (pbi->flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n+    {\n+      /* Record where each reg is used, so when the reg is set we know\n+\t the next insn that uses it.  */\n+      pbi->reg_next_use[regno] = insn;\n+    }\n+\n+  if (pbi->flags & PROP_REG_INFO)\n+    {\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  /* If this is a register we are going to try to eliminate,\n+\t     don't mark it live here.  If we are successful in\n+\t     eliminating it, it need not be live unless it is used for\n+\t     pseudos, in which case it will have been set live when it\n+\t     was allocated to the pseudos.  If the register will not\n+\t     be eliminated, reload will set it live at that point.\n+\n+\t     Otherwise, record that this function uses this register.  */\n+\n+\t  if (! TEST_HARD_REG_BIT (elim_reg_set, regno))\n+\t    {\n+\t      int n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\t      if (n == 0)\n+\t\tn = 1;\n+\t      do\n+\t\tregs_ever_live[regno + --n] = 1;\n+\t      while (n > 0);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Keep track of which basic block each reg appears in.  */\n+\n+\t  register int blocknum = pbi->bb->index;\n+\t  if (REG_BASIC_BLOCK (regno) == REG_BLOCK_UNKNOWN)\n+\t    REG_BASIC_BLOCK (regno) = blocknum;\n+\t  else if (REG_BASIC_BLOCK (regno) != blocknum)\n+\t    REG_BASIC_BLOCK (regno) = REG_BLOCK_GLOBAL;\n+\n+\t  /* Count (weighted) number of uses of each reg.  */\n+\t  REG_N_REFS (regno) += pbi->bb->loop_depth + 1;\n+\t}\n+    }\n+\n+  /* Record and count the insns in which a reg dies.  If it is used in\n+     this insn and was dead below the insn then it dies in this insn.\n+     If it was set in this insn, we do not make a REG_DEAD note;\n+     likewise if we already made such a note.  */\n+\n+  if ((pbi->flags & PROP_DEATH_NOTES)\n+      && some_was_dead\n+      && ! dead_or_set_p (insn, reg))\n+    {\n+      int n;\n+\n+      /* Check for the case where the register dying partially\n+\t overlaps the register set by this insn.  */\n+      if (regno < FIRST_PSEUDO_REGISTER\n+\t  && HARD_REGNO_NREGS (regno, GET_MODE (reg)) > 1)\n+\t{\n+\t  n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\t  while (--n >= 0)\n+\t    some_was_live |= dead_or_set_regno_p (insn, regno + n);\n+\t}\n+\n+      /* If none of the words in X is needed, make a REG_DEAD note.\n+\t Otherwise, we must make partial REG_DEAD notes.  */\n+      if (! some_was_live)\n+\t{\n+\t  REG_NOTES (insn)\n+\t    = alloc_EXPR_LIST (REG_DEAD, reg, REG_NOTES (insn));\n+\t  REG_N_DEATHS (regno)++;\n+\t}\n+      else\n+\t{\n+\t  /* Don't make a REG_DEAD note for a part of a register\n+\t     that is set in the insn.  */\n+\n+\t  n = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1;\n+\t  for (; n >= regno; n--)\n+\t    if (!REGNO_REG_SET_P (pbi->reg_live, n)\n+\t\t&& ! dead_or_set_regno_p (insn, n))\n+\t      REG_NOTES (insn)\n+\t\t= alloc_EXPR_LIST (REG_DEAD,\n+\t\t\t\t   gen_rtx_REG (reg_raw_mode[n], n),\n+\t\t\t\t   REG_NOTES (insn));\n+\t}\n+    }\n+}\n \n-   FLAGS is the set of enabled operations.\n+/* Scan expression X and store a 1-bit in NEW_LIVE for each reg it uses.\n+   This is done assuming the registers needed from X are those that\n+   have 1-bits in PBI->REG_LIVE.\n \n-   INSN is the containing instruction.  If INSN is dead, this function is not\n-   called.  */\n+   INSN is the containing instruction.  If INSN is dead, this function\n+   is not called.  */\n \n static void\n-mark_used_regs (needed, live, x, flags, insn)\n-     regset needed;\n-     regset live;\n-     rtx x;\n-     int flags;\n-     rtx insn;\n+mark_used_regs (pbi, new_live, x, cond, insn)\n+     struct propagate_block_info *pbi;\n+     regset new_live;\n+     rtx x, cond, insn;\n {\n   register RTX_CODE code;\n   register int regno;\n-  int i;\n+  int flags = pbi->flags;\n \n  retry:\n   code = GET_CODE (x);\n@@ -4387,15 +4597,15 @@ mark_used_regs (needed, live, x, flags, insn)\n \n #ifdef HAVE_cc0\n     case CC0:\n-      cc0_live = 1;\n+      pbi->cc0_live = 1;\n       return;\n #endif\n \n     case CLOBBER:\n       /* If we are clobbering a MEM, mark any registers inside the address\n \t as being used.  */\n       if (GET_CODE (XEXP (x, 0)) == MEM)\n-\tmark_used_regs (needed, live, XEXP (XEXP (x, 0), 0), flags, insn);\n+\tmark_used_regs (pbi, new_live, XEXP (XEXP (x, 0), 0), cond, insn);\n       return;\n \n     case MEM:\n@@ -4410,7 +4620,7 @@ mark_used_regs (needed, live, x, flags, insn)\n \t    ; /* needn't clear the memory set list */\n           else\n \t    {\n-\t      rtx temp = mem_set_list;\n+\t      rtx temp = pbi->mem_set_list;\n \t      rtx prev = NULL_RTX;\n \t      rtx next;\n \n@@ -4423,7 +4633,7 @@ mark_used_regs (needed, live, x, flags, insn)\n \t\t      if (prev)\n \t\t\tXEXP (prev, 1) = next;\n \t\t      else\n-\t\t\tmem_set_list = next;\n+\t\t\tpbi->mem_set_list = next;\n \t\t      free_EXPR_LIST_node (temp);\n \t\t    }\n \t\t  else\n@@ -4436,12 +4646,12 @@ mark_used_regs (needed, live, x, flags, insn)\n \t     address modes.  Then we may need to kill some entries on the\n \t     memory set list.  */\n \t  if (insn)\n-\t    invalidate_mems_from_autoinc (insn);\n+\t    invalidate_mems_from_autoinc (pbi, insn);\n \t}\n \n #ifdef AUTO_INC_DEC\n       if (flags & PROP_AUTOINC)\n-        find_auto_inc (needed, x, insn);\n+        find_auto_inc (pbi, x, insn);\n #endif\n       break;\n \n@@ -4454,170 +4664,13 @@ mark_used_regs (needed, live, x, flags, insn)\n \n       /* While we're here, optimize this case.  */\n       x = SUBREG_REG (x);\n-\n-      /* In case the SUBREG is not of a register, don't optimize */\n       if (GET_CODE (x) != REG)\n-\t{\n-\t  mark_used_regs (needed, live, x, flags, insn);\n-\t  return;\n-\t}\n-\n-      /* ... fall through ...  */\n+\tgoto retry;\n+      /* FALLTHRU */\n \n     case REG:\n-      /* See a register other than being set\n-\t => mark it as needed.  */\n-\n-      regno = REGNO (x);\n-      {\n-\tint some_needed = REGNO_REG_SET_P (needed, regno);\n-\tint some_not_needed = ! some_needed;\n-\n-\tSET_REGNO_REG_SET (live, regno);\n-\n-\t/* A hard reg in a wide mode may really be multiple registers.\n-\t   If so, mark all of them just like the first.  */\n-\tif (regno < FIRST_PSEUDO_REGISTER)\n-\t  {\n-\t    int n;\n-\n-\t    /* For stack ptr or fixed arg pointer,\n-\t       nothing below can be necessary, so waste no more time.  */\n-\t    if (regno == STACK_POINTER_REGNUM\n-#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-\t\t|| (regno == HARD_FRAME_POINTER_REGNUM\n-\t\t    && (! reload_completed || frame_pointer_needed))\n-#endif\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t\t|| (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n-#endif\n-\t\t|| (regno == FRAME_POINTER_REGNUM\n-\t\t    && (! reload_completed || frame_pointer_needed)))\n-\t      {\n-\t\t/* If this is a register we are going to try to eliminate,\n-\t\t   don't mark it live here.  If we are successful in\n-\t\t   eliminating it, it need not be live unless it is used for\n-\t\t   pseudos, in which case it will have been set live when\n-\t\t   it was allocated to the pseudos.  If the register will not\n-\t\t   be eliminated, reload will set it live at that point.  */\n-\n-\t\tif ((flags & PROP_REG_INFO)\n-\t\t    && ! TEST_HARD_REG_BIT (elim_reg_set, regno))\n-\t\t  regs_ever_live[regno] = 1;\n-\t\treturn;\n-\t      }\n-\t    /* No death notes for global register variables;\n-\t       their values are live after this function exits.  */\n-\t    if (global_regs[regno])\n-\t      {\n-\t\tif (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n-\t\t  reg_next_use[regno] = insn;\n-\t\treturn;\n-\t      }\n-\n-\t    n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n-\t    while (--n > 0)\n-\t      {\n-\t\tint regno_n = regno + n;\n-\t\tint needed_regno = REGNO_REG_SET_P (needed, regno_n);\n-\n-\t\tSET_REGNO_REG_SET (live, regno_n);\n-\t\tsome_needed |= needed_regno;\n-\t\tsome_not_needed |= ! needed_regno;\n-\t      }\n-\t  }\n-\n-\tif (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n-\t  {\n-\t    /* Record where each reg is used, so when the reg\n-\t       is set we know the next insn that uses it.  */\n-\n-\t    reg_next_use[regno] = insn;\n-\t  }\n-\tif (flags & PROP_REG_INFO)\n-\t  {\n-\t    if (regno < FIRST_PSEUDO_REGISTER)\n-\t      {\n-\t\t/* If a hard reg is being used,\n-\t\t   record that this function does use it.  */\n-\n-\t\ti = HARD_REGNO_NREGS (regno, GET_MODE (x));\n-\t\tif (i == 0)\n-\t\t  i = 1;\n-\t\tdo\n-\t\t  regs_ever_live[regno + --i] = 1;\n-\t\twhile (i > 0);\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Keep track of which basic block each reg appears in.  */\n-\n-\t\tregister int blocknum = BLOCK_NUM (insn);\n-\n-\t\tif (REG_BASIC_BLOCK (regno) == REG_BLOCK_UNKNOWN)\n-\t\t  REG_BASIC_BLOCK (regno) = blocknum;\n-\t\telse if (REG_BASIC_BLOCK (regno) != blocknum)\n-\t\t  REG_BASIC_BLOCK (regno) = REG_BLOCK_GLOBAL;\n-\n-\t\t/* Count (weighted) number of uses of each reg.  */\n-\n-\t\tREG_N_REFS (regno) += loop_depth + 1;\n-\t      }\n-\t  }\n-\n-\t/* Record and count the insns in which a reg dies.\n-\t   If it is used in this insn and was dead below the insn\n-\t   then it dies in this insn.  If it was set in this insn,\n-\t   we do not make a REG_DEAD note; likewise if we already\n-\t   made such a note.  */\n-\n-\tif (flags & PROP_DEATH_NOTES)\n-\t  {\n-\t    if (some_not_needed\n-\t\t&& ! dead_or_set_p (insn, x)\n-#if 0\n-\t\t&& (regno >= FIRST_PSEUDO_REGISTER || ! fixed_regs[regno])\n-#endif\n-\t\t)\n-\t      {\n-\t\t/* Check for the case where the register dying partially\n-\t\t   overlaps the register set by this insn.  */\n-\t\tif (regno < FIRST_PSEUDO_REGISTER\n-\t\t    && HARD_REGNO_NREGS (regno, GET_MODE (x)) > 1)\n-\t\t  {\n-\t\t    int n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n-\t\t    while (--n >= 0)\n-\t\t      some_needed |= dead_or_set_regno_p (insn, regno + n);\n-\t\t  }\n-\n-\t\t/* If none of the words in X is needed, make a REG_DEAD\n-\t\t   note.  Otherwise, we must make partial REG_DEAD notes.  */\n-\t\tif (! some_needed)\n-\t\t  {\n-\t\t    REG_NOTES (insn)\n-\t\t      = alloc_EXPR_LIST (REG_DEAD, x, REG_NOTES (insn));\n-\t\t    REG_N_DEATHS (regno)++;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    int i;\n-\n-\t\t    /* Don't make a REG_DEAD note for a part of a register\n-\t\t       that is set in the insn.  */\n-\n-\t\t    for (i = HARD_REGNO_NREGS (regno, GET_MODE (x)) - 1;\n-\t\t\t i >= 0; i--)\n-\t\t      if (!REGNO_REG_SET_P (needed, regno + i)\n-\t\t\t  && ! dead_or_set_regno_p (insn, regno + i))\n-\t\t\tREG_NOTES (insn)\n-\t\t\t  = (alloc_EXPR_LIST\n-\t\t\t     (REG_DEAD, gen_rtx_REG (reg_raw_mode[regno + i],\n-\t\t\t\t\t\t     regno + i),\n-\t\t\t      REG_NOTES (insn)));\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n+      /* See a register other than being set => mark it as needed.  */\n+      mark_used_reg (pbi, new_live, x, cond, insn);\n       return;\n \n     case SET:\n@@ -4631,10 +4684,10 @@ mark_used_regs (needed, live, x, flags, insn)\n \t  {\n #ifdef AUTO_INC_DEC\n \t    if (flags & PROP_AUTOINC)\n-\t      find_auto_inc (needed, testreg, insn);\n+\t      find_auto_inc (pbi, testreg, insn);\n #endif\n-\t    mark_used_regs (needed, live, XEXP (testreg, 0), flags, insn);\n-\t    mark_used_regs (needed, live, SET_SRC (x), flags, insn);\n+\t    mark_used_regs (pbi, new_live, XEXP (testreg, 0), cond, insn);\n+\t    mark_used_regs (pbi, new_live, SET_SRC (x), cond, insn);\n \t    return;\n \t  }\n \t    \n@@ -4669,14 +4722,15 @@ mark_used_regs (needed, live, x, flags, insn)\n \t    testreg = XEXP (testreg, 0);\n \t  }\n \n-\t/* If this is a store into a register,\n-\t   recursively scan the value being stored.  */\n+\t/* If this is a store into a register, recursively scan the\n+\t   value being stored.  */\n \n \tif ((GET_CODE (testreg) == PARALLEL\n \t     && GET_MODE (testreg) == BLKmode)\n \t    || (GET_CODE (testreg) == REG\n-\t\t&& (regno = REGNO (testreg), ! (regno == FRAME_POINTER_REGNUM\n-\t\t\t\t\t\t&& (! reload_completed || frame_pointer_needed)))\n+\t\t&& (regno = REGNO (testreg),\n+\t\t    ! (regno == FRAME_POINTER_REGNUM\n+\t\t       && (! reload_completed || frame_pointer_needed)))\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n \t\t&& ! (regno == HARD_FRAME_POINTER_REGNUM\n \t\t      && (! reload_completed || frame_pointer_needed))\n@@ -4688,9 +4742,9 @@ mark_used_regs (needed, live, x, flags, insn)\n \t  /* We used to exclude global_regs here, but that seems wrong.\n \t     Storing in them is like storing in mem.  */\n \t  {\n-\t    mark_used_regs (needed, live, SET_SRC (x), flags, insn);\n+\t    mark_used_regs (pbi, new_live, SET_SRC (x), cond, insn);\n \t    if (mark_dest)\n-\t      mark_used_regs (needed, live, SET_DEST (x), flags, insn);\n+\t      mark_used_regs (pbi, new_live, SET_DEST (x), cond, insn);\n \t    return;\n \t  }\n       }\n@@ -4716,7 +4770,7 @@ mark_used_regs (needed, live, x, flags, insn)\n \t   So for now, just clear the memory set list and mark any regs\n \t   we can find in ASM_OPERANDS as used.  */\n \tif (code != ASM_OPERANDS || MEM_VOLATILE_P (x))\n-\t  free_EXPR_LIST_list (&mem_set_list);\n+\t  free_EXPR_LIST_list (&pbi->mem_set_list);\n \n         /* For all ASM_OPERANDS, we must traverse the vector of input operands.\n \t   We can not just fall through here since then we would be confused\n@@ -4727,12 +4781,22 @@ mark_used_regs (needed, live, x, flags, insn)\n \t    int j;\n \n \t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n-\t      mark_used_regs (needed, live, ASM_OPERANDS_INPUT (x, j),\n-\t\t\t      flags, insn);\n+\t      mark_used_regs (pbi, new_live, ASM_OPERANDS_INPUT (x, j),\n+\t\t\t      cond, insn);\n \t  }\n \tbreak;\n       }\n \n+    case COND_EXEC:\n+      if (cond != NULL_RTX)\n+\tabort ();\n+\n+      mark_used_regs (pbi, new_live, COND_EXEC_TEST (x), NULL_RTX, insn);\n+\n+      cond = COND_EXEC_TEST (x);\n+      x = COND_EXEC_CODE (x);\n+      goto retry;\n+\n     case PHI:\n       /* We _do_not_ want to scan operands of phi nodes.  Operands of\n \t a phi function are evaluated only when control reaches this\n@@ -4761,13 +4825,13 @@ mark_used_regs (needed, live, x, flags, insn)\n \t\tx = XEXP (x, 0);\n \t\tgoto retry;\n \t      }\n-\t    mark_used_regs (needed, live, XEXP (x, i), flags, insn);\n+\t    mark_used_regs (pbi, new_live, XEXP (x, i), cond, insn);\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n \t    register int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      mark_used_regs (needed, live, XVECEXP (x, i, j), flags, insn);\n+\t      mark_used_regs (pbi, new_live, XVECEXP (x, i, j), cond, insn);\n \t  }\n       }\n   }\n@@ -4776,7 +4840,8 @@ mark_used_regs (needed, live, x, flags, insn)\n #ifdef AUTO_INC_DEC\n \n static int\n-try_pre_increment_1 (insn)\n+try_pre_increment_1 (pbi, insn)\n+     struct propagate_block_info *pbi;\n      rtx insn;\n {\n   /* Find the next use of this reg.  If in same basic block,\n@@ -4785,7 +4850,7 @@ try_pre_increment_1 (insn)\n   HOST_WIDE_INT amount = ((GET_CODE (SET_SRC (x)) == PLUS ? 1 : -1)\n \t\t* INTVAL (XEXP (SET_SRC (x), 1)));\n   int regno = REGNO (SET_DEST (x));\n-  rtx y = reg_next_use[regno];\n+  rtx y = pbi->reg_next_use[regno];\n   if (y != 0\n       && BLOCK_NUM (y) == BLOCK_NUM (insn)\n       /* Don't do this if the reg dies, or gets set in y; a standard addressing\n@@ -4805,7 +4870,7 @@ try_pre_increment_1 (insn)\n \t less likely.  */\n       if (regno >= FIRST_PSEUDO_REGISTER)\n \t{\n-\t  REG_N_REFS (regno) += loop_depth + 1;\n+\t  REG_N_REFS (regno) += pbi->bb->loop_depth + 1;\n \t  REG_N_SETS (regno)++;\n \t}\n       return 1;\n@@ -5126,7 +5191,7 @@ dump_bb (bb, outf)\n   edge e;\n \n   fprintf (outf, \";; Basic block %d, loop depth %d\",\n-\t   bb->index, bb->loop_depth - 1);\n+\t   bb->index, bb->loop_depth);\n   if (bb->eh_beg != -1 || bb->eh_end != -1)\n     fprintf (outf, \", eh regions %d/%d\", bb->eh_beg, bb->eh_end);\n   putc ('\\n', outf);\n@@ -5235,7 +5300,12 @@ print_rtl_with_bb (outf, rtx_first)\n \t  did_output = print_rtl_single (outf, tmp_rtx);\n \n \t  if ((bb = end[INSN_UID (tmp_rtx)]) != NULL)\n-\t    fprintf (outf, \";; End of basic block %d\\n\", bb->index);\n+\t    {\n+\t      fprintf (outf, \";; End of basic block %d, registers live:\\n\",\n+\t\t       bb->index);\n+\t      dump_regset (bb->global_live_at_end, outf);\n+\t      putc ('\\n', outf);\n+\t    }\n \n \t  if (did_output)\n \t    putc ('\\n', outf);\n@@ -5488,8 +5558,9 @@ compute_immediate_dominators (idom, dominators)\n /* Count for a single SET rtx, X.  */\n \n static void\n-count_reg_sets_1 (x)\n+count_reg_sets_1 (x, loop_depth)\n      rtx x;\n+     int loop_depth;\n {\n   register int regno;\n   register rtx reg = SET_DEST (x);\n@@ -5505,7 +5576,7 @@ count_reg_sets_1 (x)\n     {\n       register int i;\n       for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\tcount_reg_sets_1 (XVECEXP (reg, 0, i));\n+\tcount_reg_sets_1 (XVECEXP (reg, 0, i), loop_depth);\n       return;\n     }\n \n@@ -5526,21 +5597,22 @@ count_reg_sets_1 (x)\n    REG_N_REFS by the current loop depth for each SET or CLOBBER found.  */\n \n static void\n-count_reg_sets  (x)\n+count_reg_sets  (x, loop_depth)\n      rtx x;\n+     int loop_depth;\n {\n   register RTX_CODE code = GET_CODE (x);\n \n   if (code == SET || code == CLOBBER)\n-    count_reg_sets_1 (x);\n+    count_reg_sets_1 (x, loop_depth);\n   else if (code == PARALLEL)\n     {\n       register int i;\n       for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n \t{\n \t  code = GET_CODE (XVECEXP (x, 0, i));\n \t  if (code == SET || code == CLOBBER)\n-\t    count_reg_sets_1 (XVECEXP (x, 0, i));\n+\t    count_reg_sets_1 (XVECEXP (x, 0, i), loop_depth);\n \t}\n     }\n }\n@@ -5549,8 +5621,9 @@ count_reg_sets  (x)\n    found in X.  */\n \n static void\n-count_reg_references (x)\n+count_reg_references (x, loop_depth)\n      rtx x;\n+     int loop_depth;\n {\n   register RTX_CODE code;\n \n@@ -5578,7 +5651,7 @@ count_reg_references (x)\n       /* If we are clobbering a MEM, mark any registers inside the address\n \t as being used.  */\n       if (GET_CODE (XEXP (x, 0)) == MEM)\n-\tcount_reg_references (XEXP (XEXP (x, 0), 0));\n+\tcount_reg_references (XEXP (XEXP (x, 0), 0), loop_depth);\n       return;\n \n     case SUBREG:\n@@ -5588,7 +5661,7 @@ count_reg_references (x)\n       /* In case the SUBREG is not of a register, don't optimize */\n       if (GET_CODE (x) != REG)\n \t{\n-\t  count_reg_references (x);\n+\t  count_reg_references (x, loop_depth);\n \t  return;\n \t}\n \n@@ -5608,8 +5681,8 @@ count_reg_references (x)\n \t   show the address as being used.  */\n \tif (GET_CODE (testreg) == MEM)\n \t  {\n-\t    count_reg_references (XEXP (testreg, 0));\n-\t    count_reg_references (SET_SRC (x));\n+\t    count_reg_references (XEXP (testreg, 0), loop_depth);\n+\t    count_reg_references (SET_SRC (x), loop_depth);\n \t    return;\n \t  }\n \t    \n@@ -5644,9 +5717,9 @@ count_reg_references (x)\n \t     && GET_MODE (testreg) == BLKmode)\n \t    || GET_CODE (testreg) == REG)\n \t  {\n-\t    count_reg_references (SET_SRC (x));\n+\t    count_reg_references (SET_SRC (x), loop_depth);\n \t    if (mark_dest)\n-\t      count_reg_references (SET_DEST (x));\n+\t      count_reg_references (SET_DEST (x), loop_depth);\n \t    return;\n \t  }\n       }\n@@ -5672,13 +5745,13 @@ count_reg_references (x)\n \t\tx = XEXP (x, 0);\n \t\tgoto retry;\n \t      }\n-\t    count_reg_references (XEXP (x, i));\n+\t    count_reg_references (XEXP (x, i), loop_depth);\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n \t    register int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      count_reg_references (XVECEXP (x, i, j));\n+\t      count_reg_references (XVECEXP (x, i, j), loop_depth);\n \t  }\n       }\n   }\n@@ -5711,6 +5784,7 @@ recompute_reg_usage (f, loop_step)\n   rtx insn;\n   int i, max_reg;\n   int index;\n+  int loop_depth;\n \n   /* Clear out the old data.  */\n   max_reg = max_reg_num ();\n@@ -5735,21 +5809,22 @@ recompute_reg_usage (f, loop_step)\n \t      /* This call will increment REG_N_SETS for each SET or CLOBBER\n \t\t of a register in INSN.  It will also increment REG_N_REFS\n \t\t by the loop depth for each set of a register in INSN.  */\n-\t      count_reg_sets (PATTERN (insn));\n+\t      count_reg_sets (PATTERN (insn), loop_depth);\n \n \t      /* count_reg_sets does not detect autoincrement address modes, so\n \t\t detect them here by looking at the notes attached to INSN.  */\n \t      for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n \t\t{\n \t\t  if (REG_NOTE_KIND (links) == REG_INC)\n-\t\t    /* Count (weighted) references, stores, etc.  This counts a\n-\t\t       register twice if it is modified, but that is correct.  */\n+\t\t    /* Count (weighted) references, stores, etc.  This\n+\t\t       counts a register twice if it is modified, but\n+\t\t       that is correct.  */\n \t\t    REG_N_SETS (REGNO (XEXP (links, 0)))++;\n \t\t}\n \n-\t      /* This call will increment REG_N_REFS by the current loop depth for\n-\t\t each reference to a register in INSN.  */\n-\t      count_reg_references (PATTERN (insn));\n+\t      /* This call will increment REG_N_REFS by the current loop depth\n+\t\t for each reference to a register in INSN.  */\n+\t      count_reg_references (PATTERN (insn), loop_depth);\n \n \t      /* count_reg_references will not include counts for arguments to\n \t\t function calls, so detect them here by examining the\n@@ -5762,7 +5837,8 @@ recompute_reg_usage (f, loop_step)\n \t\t       note;\n \t\t       note = XEXP (note, 1))\n \t\t    if (GET_CODE (XEXP (note, 0)) == USE)\n-\t\t      count_reg_references (XEXP (XEXP (note, 0), 0));\n+\t\t      count_reg_references (XEXP (XEXP (note, 0), 0),\n+\t\t\t\t\t    loop_depth);\n \t\t}\n \t    }\n \t  if (insn == bb->end)"}]}