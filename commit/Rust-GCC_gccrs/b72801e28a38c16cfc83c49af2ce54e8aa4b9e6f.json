{"sha": "b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcyODAxZTI4YTM4YzE2Y2ZjODNjNDlhZjJjZTU0ZThhYTRiOWU2Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-06-20T15:42:55Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-06-20T15:42:55Z"}, "message": "call.c (build_conditional_expr): Use VOID_TYPE_P.\n\n\t* call.c (build_conditional_expr): Use VOID_TYPE_P.\n\t* cvt.c (cp_convert_to_pointer): Likewise.\n\t(convert_to_void): Likewise.\n\t* error.c (dump_expr): Likewise.\n\t* except.c (complete_ptr_ref_or_void_ptr_p): Likewise.\n\t* init.c (build_delete): Likewise.\n\t* method.c (emit_thunk): Likewise.\n\t* optmize.c (declare_return_variable): Likewise.\n\t* rtti.c (get_tinfo_decl_dynamic): Likewise.\n\t(get_typeid): Likewise.\n\t(build_dynamic_cast_1): Likewise.\n\t* typeck.c (composite_pointer_type): Likewise.\n\t(common_type): Likewise.\n\t(build_indirect_ref): Likewise.\n\t(build_binary_op): Likewise.\n\t(build_x_compound_expr): Likewise.\n\t(check_return_expr): Likewise.\n\t* typeck2.c (add_exception_specifier): Likewise.\n\n\t* mangle.c (write_method_parms): Use direct comparison for end\n\tof parmlist.\n\nFrom-SVN: r34617", "tree": {"sha": "1a84c7dc8a7a8ad8d466243edf26fc63e7d0d63c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a84c7dc8a7a8ad8d466243edf26fc63e7d0d63c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/comments", "author": null, "committer": null, "parents": [{"sha": "5ea634c774afe595d5933b61312e357bbf4d50a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ea634c774afe595d5933b61312e357bbf4d50a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ea634c774afe595d5933b61312e357bbf4d50a0"}], "stats": {"total": 98, "additions": 56, "deletions": 42}, "files": [{"sha": "b4167416a3c21db399d4843361edd7a2fb65acfa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -1,3 +1,27 @@\n+2000-06-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* call.c (build_conditional_expr): Use VOID_TYPE_P.\n+\t* cvt.c (cp_convert_to_pointer): Likewise.\n+\t(convert_to_void): Likewise.\n+\t* error.c (dump_expr): Likewise.\n+\t* except.c (complete_ptr_ref_or_void_ptr_p): Likewise.\n+\t* init.c (build_delete): Likewise.\n+\t* method.c (emit_thunk): Likewise.\n+\t* optmize.c (declare_return_variable): Likewise.\n+\t* rtti.c (get_tinfo_decl_dynamic): Likewise.\n+\t(get_typeid): Likewise.\n+\t(build_dynamic_cast_1): Likewise.\n+\t* typeck.c (composite_pointer_type): Likewise.\n+\t(common_type): Likewise.\n+\t(build_indirect_ref): Likewise.\n+\t(build_binary_op): Likewise.\n+\t(build_x_compound_expr): Likewise.\n+\t(check_return_expr): Likewise.\n+\t* typeck2.c (add_exception_specifier): Likewise.\n+\t\n+\t* mangle.c (write_method_parms): Use direct comparison for end\n+\tof parmlist.\n+\n 2000-06-19  Benjamin Chelf  <chelf@cabriolet.stanford.edu>\n \n \t* cp-tree.h (genrtl_try_block): Declare function."}, {"sha": "7b7d96b412c1b1e9b2803e43bff5eac11509bf36", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -2858,27 +2858,18 @@ build_conditional_expr (arg1, arg2, arg3)\n      and third operands.  */\n   arg2_type = TREE_TYPE (arg2);\n   arg3_type = TREE_TYPE (arg3);\n-  if (same_type_p (TYPE_MAIN_VARIANT (arg2_type), void_type_node)\n-      || same_type_p (TYPE_MAIN_VARIANT (arg3_type), void_type_node))\n+  if (VOID_TYPE_P (arg2_type) || VOID_TYPE_P (arg3_type))\n     {\n-      int arg2_void_p;\n-      int arg3_void_p;\n-\n       /* Do the conversions.  We don't these for `void' type arguments\n \t since it can't have any effect and since decay_conversion\n \t does not handle that case gracefully.  */\n-      if (!same_type_p (TYPE_MAIN_VARIANT (arg2_type), void_type_node))\n+      if (!VOID_TYPE_P (arg2_type))\n \targ2 = decay_conversion (arg2);\n-      if (!same_type_p (TYPE_MAIN_VARIANT (arg3_type), void_type_node))\n+      if (!VOID_TYPE_P (arg3_type))\n \targ3 = decay_conversion (arg3);\n       arg2_type = TREE_TYPE (arg2);\n       arg3_type = TREE_TYPE (arg3);\n \n-      arg2_void_p = same_type_p (TYPE_MAIN_VARIANT (arg2_type),\n-\t\t\t\t void_type_node);\n-      arg3_void_p = same_type_p (TYPE_MAIN_VARIANT (arg3_type),\n-\t\t\t\t void_type_node);\n-\n       /* [expr.cond]\n \n \t One of the following shall hold:\n@@ -2893,12 +2884,12 @@ build_conditional_expr (arg1, arg2, arg3)\n \t  ^ (TREE_CODE (arg3) == THROW_EXPR))\n \tresult_type = ((TREE_CODE (arg2) == THROW_EXPR) \n \t\t       ? arg3_type : arg2_type);\n-      else if (arg2_void_p && arg3_void_p)\n+      else if (VOID_TYPE_P (arg2_type) && VOID_TYPE_P (arg3_type))\n \tresult_type = void_type_node;\n       else\n \t{\n \t  cp_error (\"`%E' has type `void' and is not a throw-expression\",\n-\t\t    arg2_void_p ? arg2 : arg3);\n+\t\t    VOID_TYPE_P (arg2_type) ? arg2 : arg3);\n \t  return error_mark_node;\n \t}\n "}, {"sha": "e3e8692387553acad2e463e5d6660a771e3e52cf", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -99,7 +99,7 @@ cp_convert_to_pointer (type, expr)\n   /* Handle anachronistic conversions from (::*)() to cv void* or (*)().  */\n   if (TREE_CODE (type) == POINTER_TYPE\n       && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n-\t  || TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node))\n+\t  || VOID_TYPE_P (TREE_TYPE (type))))\n     {\n       /* Allow an implicit this pointer for pointer to member\n \t functions.  */\n@@ -860,7 +860,7 @@ convert_to_void (expr, implicit)\n     return error_mark_node;\n   if (!TREE_TYPE (expr))\n     return expr;\n-  if (same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (expr)), void_type_node))\n+  if (VOID_TYPE_P (TREE_TYPE (expr)))\n     return expr;\n   switch (TREE_CODE (expr))\n     {\n@@ -958,8 +958,7 @@ convert_to_void (expr, implicit)\n                     implicit, expr);\n   }\n   \n-  if (expr != error_mark_node\n-      && !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (expr)), void_type_node))\n+  if (expr != error_mark_node && !VOID_TYPE_P (TREE_TYPE (expr)))\n     {\n       /* FIXME: This is where we should check for expressions with no\n          effects.  At the moment we do that in both build_x_component_expr"}, {"sha": "8d2ad61225dacda7069b6a3bd97924b0488ee78e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -1730,9 +1730,11 @@ dump_expr (t, flags)\n       break;\n \n     case CONVERT_EXPR:\n-      if (same_type_p (TREE_TYPE (t), void_type_node))\n+      if (VOID_TYPE_P (TREE_TYPE (t)))\n \t{\n-\t  OB_PUTS (\"(void)\");\n+\t  OB_PUTC ('(');\n+\t  dump_type (TREE_TYPE (t), flags);\n+\t  OB_PUTC (')');\n \t  dump_expr (TREE_OPERAND (t, 0), flags);\n \t}\n       else"}, {"sha": "24b431004946032db5ded1fbec7d9262aa5e6ed5", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -1073,7 +1073,7 @@ complete_ptr_ref_or_void_ptr_p (type, from)\n     {\n       tree core = TREE_TYPE (type);\n   \n-      if (is_ptr && same_type_p (TYPE_MAIN_VARIANT (core), void_type_node))\n+      if (is_ptr && VOID_TYPE_P (core))\n         /* OK */;\n       else if (!complete_type_or_else (core, from))\n         return 0;"}, {"sha": "cf480a49f42a6bd224bd4ef4bb0d0d895375918c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -3163,7 +3163,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n   if (TREE_CODE (type) == POINTER_TYPE)\n     {\n       type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-      if (type != void_type_node && !complete_type_or_else (type, addr))\n+      if (!VOID_TYPE_P (type) && !complete_type_or_else (type, addr))\n \treturn error_mark_node;\n       if (TREE_CODE (type) == ARRAY_TYPE)\n \tgoto handle_array;"}, {"sha": "d6c7181f55b2d135a99347dc4a634f58c6702652", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -1467,7 +1467,7 @@ write_method_parms (parm_list, method_p)\n     {\n       tree parm = TREE_VALUE (parm_list);\n \n-      if (same_type_p (parm, void_type_node))\n+      if (parm == void_type_node)\n \t{\n \t  /* \"Empty parameter lists, whether declared as () or\n \t     conventionally as (void), are encoded with a void parameter"}, {"sha": "1f09addec5044bf4532bc4dc3ee72a5cc138c182", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -2271,10 +2271,10 @@ emit_thunk (thunk_fndecl)\n       t = tree_cons (NULL_TREE, a, t);\n     t = nreverse (t);\n     t = build_call (function, t);\n-    if (!same_type_p (TREE_TYPE (t), void_type_node))\n-      finish_return_stmt (t);\n-    else\n+    if (VOID_TYPE_P (TREE_TYPE (t)))\n       finish_expr_stmt (t);\n+    else\n+      finish_return_stmt (t);\n \n     /* The back-end expects DECL_INITIAL to contain a BLOCK, so we\n        create one.  */"}, {"sha": "d2b3c8e33e0ddd39593e01905cd6db708e2f4f1f", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -477,8 +477,7 @@ declare_return_variable (id, use_stmt)\n \n   /* We don't need to do anything for functions that don't return\n      anything.  */\n-  if (!result || same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (result)), \n-\t\t\t      void_type_node))\n+  if (!result || VOID_TYPE_P (TREE_TYPE (result)))\n     {\n       *use_stmt = NULL_TREE;\n       return NULL_TREE;"}, {"sha": "8bf17d985abde3d74fd63a159afad07329c4db61", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -233,7 +233,7 @@ get_tinfo_decl_dynamic (exp)\n   /* Peel off cv qualifiers.  */\n   type = TYPE_MAIN_VARIANT (type);\n   \n-  if (type != void_type_node)\n+  if (!VOID_TYPE_P (type))\n     type = complete_type_or_else (type, exp);\n   \n   if (!type)\n@@ -513,7 +513,7 @@ get_typeid (type)\n      that is the operand of typeid are always ignored.  */\n   type = TYPE_MAIN_VARIANT (type);\n \n-  if (type != void_type_node)\n+  if (!VOID_TYPE_P (type))\n     type = complete_type_or_else (type, NULL_TREE);\n   \n   if (!type)\n@@ -702,8 +702,7 @@ build_dynamic_cast_1 (type, expr)\n     {\n       tree expr1;\n       /* if TYPE is `void *', return pointer to complete object.  */\n-      if (tc == POINTER_TYPE\n-\t  && TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node)\n+      if (tc == POINTER_TYPE && VOID_TYPE_P (TREE_TYPE (type)))\n \t{\n \t  /* if b is an object, dynamic_cast<void *>(&b) == (void *)&b.  */\n \t  if (TREE_CODE (expr) == ADDR_EXPR"}, {"sha": "fe7a4df169cd3cf4e07d94b1120681c37413b98b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -443,13 +443,13 @@ composite_pointer_type (t1, t2, arg1, arg2, location)\n   \n   if (comp_target_types (t1, t2, 1))\n     result_type = common_type (t1, t2);\n-  else if (TYPE_MAIN_VARIANT (TREE_TYPE (t1)) == void_type_node)\n+  else if (VOID_TYPE_P (TREE_TYPE (t1)))\n     {\n       if (pedantic && TREE_CODE (t2) == FUNCTION_TYPE)\n \tpedwarn (\"ISO C++ forbids %s between pointer of type `void *' and pointer-to-function\", location);\n       result_type = qualify_type (t1, t2);\n     }\n-  else if (TYPE_MAIN_VARIANT (TREE_TYPE (t2)) == void_type_node)\n+  else if (VOID_TYPE_P (TREE_TYPE (t2)))\n     {\n       if (pedantic && TREE_CODE (t1) == FUNCTION_TYPE)\n \tpedwarn (\"ISO C++ forbids %s between pointer of type `void *' and pointer-to-function\", location);\n@@ -600,7 +600,7 @@ common_type (t1, t2)\n \n \tif (tt1 == tt2)\n \t  target = tt1;\n-\telse if (tt1 == void_type_node || tt2 == void_type_node)\n+\telse if (VOID_TYPE_P (tt1) || VOID_TYPE_P (tt2))\n \t  target = void_type_node;\n \telse if (tt1 == unknown_type_node)\n \t  target = tt2;\n@@ -2330,7 +2330,7 @@ build_indirect_ref (ptr, errorstring)\n \t types.  */\n       tree t = canonical_type_variant (TREE_TYPE (type));\n \n-      if (same_type_p (TYPE_MAIN_VARIANT (t), void_type_node))\n+      if (VOID_TYPE_P (t))\n         {\n           /* A pointer to incomplete type (other than cv void) can be\n              dereferenced [expr.unary.op]/1  */\n@@ -3582,15 +3582,15 @@ build_binary_op (code, orig_op0, orig_op1)\n \n \t  if (comp_target_types (type0, type1, 1))\n \t    result_type = common_type (type0, type1);\n-\t  else if (tt0 == void_type_node)\n+\t  else if (VOID_TYPE_P (tt0))\n \t    {\n \t      if (pedantic && TREE_CODE (tt1) == FUNCTION_TYPE\n \t\t  && tree_int_cst_lt (TYPE_SIZE (type0), TYPE_SIZE (type1)))\n \t\tpedwarn (\"ISO C++ forbids comparison of `void *' with function pointer\");\n \t      else if (TREE_CODE (tt1) == OFFSET_TYPE)\n \t\tpedwarn (\"ISO C++ forbids conversion of a pointer to member to `void *'\");\n \t    }\n-\t  else if (tt1 == void_type_node)\n+\t  else if (VOID_TYPE_P (tt1))\n \t    {\n \t      if (pedantic && TREE_CODE (tt0) == FUNCTION_TYPE\n \t\t  && tree_int_cst_lt (TYPE_SIZE (type1), TYPE_SIZE (type0)))\n@@ -5058,7 +5058,7 @@ build_x_compound_expr (list)\n          unless it was explicitly cast to (void).  */\n       if ((extra_warnings || warn_unused_value)\n            && !(TREE_CODE (TREE_VALUE(list)) == CONVERT_EXPR\n-                && TREE_TYPE (TREE_VALUE(list)) == void_type_node))\n+                && VOID_TYPE_P (TREE_TYPE (TREE_VALUE(list)))))\n         warning(\"left-hand operand of comma expression has no effect\");\n     }\n #if 0 /* this requires a gcc backend patch to export warn_if_unused_value */\n@@ -6799,7 +6799,7 @@ check_return_expr (retval)\n   result = DECL_RESULT (current_function_decl);\n   valtype = TREE_TYPE (result);\n   my_friendly_assert (valtype != NULL_TREE, 19990924);\n-  fn_returns_value_p = !same_type_p (valtype, void_type_node);\n+  fn_returns_value_p = !VOID_TYPE_P (valtype);\n   if (!retval && DECL_NAME (result) && fn_returns_value_p)\n     retval = result;\n \n@@ -6817,7 +6817,7 @@ check_return_expr (retval)\n      isn't supposed to return a value.  */\n   else if (retval && !fn_returns_value_p)\n     {     \n-      if (same_type_p (TREE_TYPE (retval), void_type_node))\n+      if (VOID_TYPE_P (TREE_TYPE (retval)))\n \t/* You can return a `void' value from a function of `void'\n \t   type.  In that case, we have to evaluate the expression for\n \t   its side-effects.  */"}, {"sha": "ce962e96eaa4363a1fe21b41b953c0ef895b617f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=b72801e28a38c16cfc83c49af2ce54e8aa4b9e6f", "patch": "@@ -1466,7 +1466,7 @@ add_exception_specifier (list, spec, complain)\n     core = TREE_TYPE (core);\n   if (complain < 0)\n     ok = 1;\n-  else if (TYPE_MAIN_VARIANT (core) == void_type_node)\n+  else if (VOID_TYPE_P (core))\n     ok = is_ptr;\n   else if (TREE_CODE (core) == TEMPLATE_TYPE_PARM)\n     ok = 1;"}]}