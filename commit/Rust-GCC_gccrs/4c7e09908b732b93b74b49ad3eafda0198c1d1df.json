{"sha": "4c7e09908b732b93b74b49ad3eafda0198c1d1df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM3ZTA5OTA4YjczMmI5M2I3NGI0OWFkM2VhZmRhMDE5OGMxZDFkZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-02-06T10:10:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-02-06T10:10:32Z"}, "message": "[multiple changes]\n\n2013-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Expression_With_Actions): Rewritten. This\n\troutine should be able to properly detect controlled transient\n\tobjects in its actions and generate the appropriate finalization\n\tactions.\n\t* exp_ch6.adb (Enclosing_Context): Removed.\n\t(Expand_Ctrl_Function_Call): Remove local subprogram and\n\tconstant. Use routine Within_Case_Or_If_Expression to determine\n\twhether the lifetime of the function result must be extended to\n\tmatch that of the context.\n\t* exp_util.ads, exp_util.adb (Within_Case_Or_If_Expression): New\n\troutine.\n\n2013-02-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Validate_Array_Type_Instance): Extend check\n\tfor subtype matching of component type of formal array type,\n\tto avoid spurious error when component type is a separate actual\n\tin the instance, and there may be a discrepancy between private\n\tand full view of component type.\n\nFrom-SVN: r195790", "tree": {"sha": "2339ff1bd35b72bb0decc57cd5f24dd2bbe5a808", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2339ff1bd35b72bb0decc57cd5f24dd2bbe5a808"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c7e09908b732b93b74b49ad3eafda0198c1d1df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c7e09908b732b93b74b49ad3eafda0198c1d1df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c7e09908b732b93b74b49ad3eafda0198c1d1df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c7e09908b732b93b74b49ad3eafda0198c1d1df/comments", "author": null, "committer": null, "parents": [{"sha": "088c2c8d37175054fd0af5b58734a1fbf6ecebd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/088c2c8d37175054fd0af5b58734a1fbf6ecebd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/088c2c8d37175054fd0af5b58734a1fbf6ecebd1"}], "stats": {"total": 506, "additions": 352, "deletions": 154}, "files": [{"sha": "6cc022acfe3603935e22083e8d390c59e284a6e8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4c7e09908b732b93b74b49ad3eafda0198c1d1df", "patch": "@@ -1,3 +1,25 @@\n+2013-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Expression_With_Actions): Rewritten. This\n+\troutine should be able to properly detect controlled transient\n+\tobjects in its actions and generate the appropriate finalization\n+\tactions.\n+\t* exp_ch6.adb (Enclosing_Context): Removed.\n+\t(Expand_Ctrl_Function_Call): Remove local subprogram and\n+\tconstant. Use routine Within_Case_Or_If_Expression to determine\n+\twhether the lifetime of the function result must be extended to\n+\tmatch that of the context.\n+\t* exp_util.ads, exp_util.adb (Within_Case_Or_If_Expression): New\n+\troutine.\n+\n+2013-02-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Validate_Array_Type_Instance): Extend check\n+\tfor subtype matching of component type of formal array type,\n+\tto avoid spurious error when component type is a separate actual\n+\tin the instance, and there may be a discrepancy between private\n+\tand full view of component type.\n+\n 2013-02-06  Robert Dewar  <dewar@adacore.com>\n \n \t* s-dim.ads, clean.adb: Minor reformatting."}, {"sha": "56b1d63059920287fb8ed3cacab343b02222d829", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 273, "deletions": 101, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=4c7e09908b732b93b74b49ad3eafda0198c1d1df", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -4984,145 +4984,317 @@ package body Exp_Ch4 is\n    --------------------------------------\n \n    procedure Expand_N_Expression_With_Actions (N : Node_Id) is\n+      In_Case_Or_If_Expression : constant Boolean :=\n+                                   Within_Case_Or_If_Expression (N);\n \n-      procedure Process_Transient_Object (Decl : Node_Id);\n-      --  Given the declaration of a controlled transient declared inside the\n-      --  Actions list of an Expression_With_Actions, generate all necessary\n-      --  types and hooks in order to properly finalize the transient. This\n-      --  mechanism works in conjunction with Build_Finalizer.\n+      function Process_Action (Act : Node_Id) return Traverse_Result;\n+      --  Inspect and process a single action of an expression_with_actions\n \n-      ------------------------------\n-      -- Process_Transient_Object --\n-      ------------------------------\n+      --------------------\n+      -- Process_Action --\n+      --------------------\n+\n+      function Process_Action (Act : Node_Id) return Traverse_Result is\n+         procedure Process_Transient_Object (Obj_Decl : Node_Id);\n+         --  Obj_Decl denotes the declaration of a transient controlled object.\n+         --  Generate all necessary types and hooks to properly finalize the\n+         --  result when the enclosing context is elaborated/evaluated.\n+\n+         ------------------------------\n+         -- Process_Transient_Object --\n+         ------------------------------\n+\n+         procedure Process_Transient_Object (Obj_Decl : Node_Id) is\n+            function Find_Enclosing_Context return Node_Id;\n+            --  Find the context where the expression_with_actions appears\n+\n+            ----------------------------\n+            -- Find_Enclosing_Context --\n+            ----------------------------\n+\n+            function Find_Enclosing_Context return Node_Id is\n+               function Is_Body_Or_Unit (N : Node_Id) return Boolean;\n+               --  Determine whether N denotes a body or unit declaration\n+\n+               ---------------------\n+               -- Is_Body_Or_Unit --\n+               ---------------------\n+\n+               function Is_Body_Or_Unit (N : Node_Id) return Boolean is\n+               begin\n+                  return Nkind_In (N, N_Entry_Body,\n+                                      N_Package_Body,\n+                                      N_Package_Declaration,\n+                                      N_Protected_Body,\n+                                      N_Subprogram_Body,\n+                                      N_Task_Body);\n+               end Is_Body_Or_Unit;\n+\n+               --  Local variables\n+\n+               Par : Node_Id;\n+               Top : Node_Id;\n+\n+            --  Start of processing for Find_Enclosing_Context\n+\n+            begin\n+               --  The expression_with_action is in a case or if expression and\n+               --  the lifetime of any temporary controlled object is therefore\n+               --  extended. Find a suitable insertion node by locating the top\n+               --  most case or if expressions.\n+\n+               if In_Case_Or_If_Expression then\n+                  Par := N;\n+                  Top := N;\n+                  while Present (Par) loop\n+                     if Nkind_In (Original_Node (Par), N_Case_Expression,\n+                                                       N_If_Expression)\n+                     then\n+                        Top := Par;\n+\n+                     --  Prevent the search from going too far\n+\n+                     elsif Is_Body_Or_Unit (Par) then\n+                        exit;\n+                     end if;\n+\n+                     Par := Parent (Par);\n+                  end loop;\n+\n+                  --  The topmost case or if expression is now recovered, but\n+                  --  it may still not be the correct place to add all the\n+                  --  generated code. Climb to find a parent that is part of a\n+                  --  declarative or statement list.\n+\n+                  Par := Top;\n+                  while Present (Par) loop\n+                     if Is_List_Member (Par)\n+                       and then\n+                          not Nkind_In (Par, N_Component_Association,\n+                                             N_Discriminant_Association,\n+                                             N_Parameter_Association,\n+                                             N_Pragma_Argument_Association)\n+                     then\n+                        return Par;\n+\n+                     --  Prevent the search from going too far\n+\n+                     elsif Is_Body_Or_Unit (Par) then\n+                        exit;\n+                     end if;\n+\n+                     Par := Parent (Par);\n+                  end loop;\n+\n+                  return Par;\n+\n+               --  Shor circuit operators in complex expressions are converted\n+               --  into expression_with_actions.\n+\n+               else\n+                  --  Take care of the case where the expression_with_actions\n+                  --  is burried deep inside an if statement. The temporary\n+                  --  function result must be finalized before the then, elsif\n+                  --  or else statements are evaluated.\n+\n+                  --    if Something\n+                  --      and then Ctrl_Func_Call\n+                  --    then\n+                  --       <result must be finalized at this point>\n+                  --       <statements>\n+                  --    end if;\n+\n+                  --  To achieve this, find the topmost logical operator. The\n+                  --  generated actions are then inserted before/after it.\n+\n+                  Par := N;\n+                  while Present (Par) loop\n+\n+                     --  Keep climbing past various operators\n+\n+                     if Nkind (Parent (Par)) in N_Op\n+                       or else Nkind_In (Parent (Par), N_And_Then, N_Or_Else)\n+                     then\n+                        Par := Parent (Par);\n+                     else\n+                        exit;\n+                     end if;\n+                  end loop;\n+\n+                  Top := Par;\n+\n+                  --  The expression_with_action might be located in a pragm\n+                  --  in which case locate the pragma itself:\n+\n+                  --    pragma Precondition (... and then Ctrl_Func_Call ...);\n+\n+                  --  Similar case occurs when the expression_with_actions is\n+                  --  related to an object declaration or assignment:\n+\n+                  --    Obj [: Some_Typ] := ... and then Ctrl_Func_Call ...;\n \n-      procedure Process_Transient_Object (Decl : Node_Id) is\n+                  while Present (Par) loop\n+                     if Nkind_In (Par, N_Assignment_Statement,\n+                                       N_Object_Declaration,\n+                                       N_Pragma)\n+                     then\n+                        return Par;\n+\n+                     elsif Is_Body_Or_Unit (Par) then\n+                        exit;\n+                     end if;\n+\n+                     Par := Parent (Par);\n+                  end loop;\n+\n+                  --  Return the topmost short circuit operator\n \n-         function Find_Insertion_Node return Node_Id;\n-         --  Complex conditions in if statements may be converted into nested\n-         --  EWAs. In this case, any generated code must be inserted before the\n-         --  if statement to ensure proper visibility of the hook objects. This\n-         --  routine returns the top most short circuit operator or the parent\n-         --  of the EWA if no nesting was detected.\n+                  return Top;\n+               end if;\n+            end Find_Enclosing_Context;\n+\n+            --  Local variables\n \n-         -------------------------\n-         -- Find_Insertion_Node --\n-         -------------------------\n+            Context   : constant Node_Id    := Find_Enclosing_Context;\n+            Loc       : constant Source_Ptr := Sloc (Obj_Decl);\n+            Obj_Id    : constant Entity_Id  := Defining_Identifier (Obj_Decl);\n+            Obj_Typ   : constant Node_Id    := Etype (Obj_Id);\n+            Desig_Typ : Entity_Id;\n+            Expr      : Node_Id;\n+            Ptr_Id    : Entity_Id;\n+            Temp_Id   : Entity_Id;\n \n-         function Find_Insertion_Node return Node_Id is\n-            Par : Node_Id;\n+         --  Start of processing for Process_Transient_Object\n \n          begin\n-            --  Climb up the branches of a complex condition\n+            --  Step 1: Create the access type which provides a reference to\n+            --  the transient object.\n \n-            Par := N;\n-            while Nkind_In (Parent (Par), N_And_Then, N_Op_Not, N_Or_Else) loop\n-               Par := Parent (Par);\n-            end loop;\n+            if Is_Access_Type (Obj_Typ) then\n+               Desig_Typ := Directly_Designated_Type (Obj_Typ);\n+            else\n+               Desig_Typ := Obj_Typ;\n+            end if;\n \n-            return Par;\n-         end Find_Insertion_Node;\n+            --  Generate:\n+            --    Ann : access [all] <Desig_Typ>;\n \n-         --  Local variables\n+            Ptr_Id := Make_Temporary (Loc, 'A');\n \n-         Ins_Node  : constant Node_Id    := Find_Insertion_Node;\n-         Loc       : constant Source_Ptr := Sloc (Decl);\n-         Obj_Id    : constant Entity_Id  := Defining_Identifier (Decl);\n-         Obj_Typ   : constant Entity_Id  := Etype (Obj_Id);\n-         Desig_Typ : Entity_Id;\n-         Expr      : Node_Id;\n-         Ptr_Decl  : Node_Id;\n-         Ptr_Id    : Entity_Id;\n-         Temp_Decl : Node_Id;\n-         Temp_Id   : Node_Id;\n+            Insert_Action (Context,\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => Ptr_Id,\n+                Type_Definition     =>\n+                  Make_Access_To_Object_Definition (Loc,\n+                    All_Present        =>\n+                      Ekind (Obj_Typ) = E_General_Access_Type,\n+                    Subtype_Indication => New_Reference_To (Desig_Typ, Loc))));\n \n-      --  Start of processing for Process_Transient_Object\n+            --  Step 2: Create a temporary which acts as a hook to the\n+            --  transient object. Generate:\n \n-      begin\n-         --  Step 1: Create the access type which provides a reference to the\n-         --  transient object.\n+            --    Temp : Ptr_Id := null;\n \n-         if Is_Access_Type (Obj_Typ) then\n-            Desig_Typ := Directly_Designated_Type (Obj_Typ);\n-         else\n-            Desig_Typ := Obj_Typ;\n-         end if;\n+            Temp_Id := Make_Temporary (Loc, 'T');\n \n-         --  Generate:\n-         --    Ann : access [all] <Desig_Typ>;\n+            Insert_Action (Context,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp_Id,\n+                Object_Definition   => New_Reference_To (Ptr_Id, Loc)));\n \n-         Ptr_Id := Make_Temporary (Loc, 'A');\n+            --  Mark this temporary as created for the purposes of exporting\n+            --  the transient declaration out of the Actions list. This signals\n+            --  the machinery in Build_Finalizer to recognize this special\n+            --  case.\n \n-         Ptr_Decl :=\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Ptr_Id,\n-             Type_Definition     =>\n-               Make_Access_To_Object_Definition (Loc,\n-                 All_Present        =>\n-                   Ekind (Obj_Typ) = E_General_Access_Type,\n-                 Subtype_Indication => New_Reference_To (Desig_Typ, Loc)));\n+            Set_Status_Flag_Or_Transient_Decl (Temp_Id, Obj_Decl);\n \n-         Insert_Action (Ins_Node, Ptr_Decl);\n-         Analyze (Ptr_Decl);\n+            --  Step 3: Hook the transient object to the temporary\n \n-         --  Step 2: Create a temporary which acts as a hook to the transient\n-         --  object. Generate:\n+            if Is_Access_Type (Obj_Typ) then\n+               Expr := Convert_To (Ptr_Id, New_Reference_To (Obj_Id, Loc));\n+            else\n+               Expr :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => New_Reference_To (Obj_Id, Loc),\n+                   Attribute_Name => Name_Unrestricted_Access);\n+            end if;\n \n-         --    Temp : Ptr_Id := null;\n+            --  Generate:\n+            --    Temp := Ptr_Id (Obj_Id);\n+            --      <or>\n+            --    Temp := Obj_Id'Unrestricted_Access;\n \n-         Temp_Id := Make_Temporary (Loc, 'T');\n+            Insert_After_And_Analyze (Obj_Decl,\n+              Make_Assignment_Statement (Loc,\n+                Name       => New_Reference_To (Temp_Id, Loc),\n+                Expression => Expr));\n \n-         Temp_Decl :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Temp_Id,\n-             Object_Definition   => New_Reference_To (Ptr_Id, Loc));\n+            --  Step 4: Finalize the function result after the context has been\n+            --  evaluated/elaborated. Generate:\n \n-         Insert_Action (Ins_Node, Temp_Decl);\n-         Analyze (Temp_Decl);\n+            --    if Temp /= null then\n+            --       [Deep_]Finalize (Temp.all);\n+            --       Temp := null;\n+            --    end if;\n \n-         --  Mark this temporary as created for the purposes of exporting the\n-         --  transient declaration out of the Actions list. This signals the\n-         --  machinery in Build_Finalizer to recognize this special case.\n+            Insert_Action_After (Context,\n+              Make_If_Statement (Loc,\n+                Condition =>\n+                  Make_Op_Ne (Loc,\n+                    Left_Opnd  => New_Reference_To (Temp_Id, Loc),\n+                    Right_Opnd => Make_Null (Loc)),\n \n-         Set_Status_Flag_Or_Transient_Decl (Temp_Id, Decl);\n+                Then_Statements => New_List (\n+                  Make_Final_Call\n+                    (Obj_Ref =>\n+                       Make_Explicit_Dereference (Loc,\n+                         Prefix => New_Reference_To (Temp_Id, Loc)),\n+                     Typ     => Desig_Typ),\n \n-         --  Step 3: Hook the transient object to the temporary\n+                  Make_Assignment_Statement (Loc,\n+                    Name       => New_Reference_To (Temp_Id, Loc),\n+                    Expression => Make_Null (Loc)))));\n+         end Process_Transient_Object;\n \n-         if Is_Access_Type (Obj_Typ) then\n-            Expr := Convert_To (Ptr_Id, New_Reference_To (Obj_Id, Loc));\n-         else\n-            Expr :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => New_Reference_To (Obj_Id, Loc),\n-                Attribute_Name => Name_Unrestricted_Access);\n+      --  Start of processing for Process_Action\n+\n+      begin\n+         if Nkind (Act) = N_Object_Declaration\n+           and then Is_Finalizable_Transient (Act, N)\n+         then\n+            Process_Transient_Object (Act);\n+\n+         --  Avoid processing temporary function results multiple times when\n+         --  dealing with nested expression_with_actions.\n+\n+         elsif Nkind (Act) = N_Expression_With_Actions then\n+            return Abandon;\n+\n+         --  Do not process temporary function results in loops. This is\n+         --  done by Expand_N_Loop_Statement and Build_Finalizer.\n+\n+         elsif Nkind (Act) = N_Loop_Statement then\n+            return Abandon;\n          end if;\n \n-         --  Generate:\n-         --    Temp := Ptr_Id (Obj_Id);\n-         --      <or>\n-         --    Temp := Obj_Id'Unrestricted_Access;\n+         return OK;\n+      end Process_Action;\n \n-         Insert_After_And_Analyze (Decl,\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Reference_To (Temp_Id, Loc),\n-             Expression => Expr));\n-      end Process_Transient_Object;\n+      procedure Process_Single_Action is new Traverse_Proc (Process_Action);\n \n       --  Local variables\n \n-      Decl : Node_Id;\n+      Act : Node_Id;\n \n    --  Start of processing for Expand_N_Expression_With_Actions\n \n    begin\n-      Decl := First (Actions (N));\n-      while Present (Decl) loop\n-         if Nkind (Decl) = N_Object_Declaration\n-           and then Is_Finalizable_Transient (Decl, N)\n-         then\n-            Process_Transient_Object (Decl);\n-         end if;\n+      Act := First (Actions (N));\n+      while Present (Act) loop\n+         Process_Single_Action (Act);\n \n-         Next (Decl);\n+         Next (Act);\n       end loop;\n    end Expand_N_Expression_With_Actions;\n "}, {"sha": "a2caf15fe93e63e8da3909abe51a59d1dffce577", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 6, "deletions": 48, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=4c7e09908b732b93b74b49ad3eafda0198c1d1df", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -4036,45 +4036,6 @@ package body Exp_Ch6 is\n    -------------------------------\n \n    procedure Expand_Ctrl_Function_Call (N : Node_Id) is\n-      function Enclosing_Context return Node_Id;\n-      --  Find the enclosing context where the function call appears\n-\n-      -----------------------\n-      -- Enclosing_Context --\n-      -----------------------\n-\n-      function Enclosing_Context return Node_Id is\n-         Context : Node_Id;\n-\n-      begin\n-         Context := Parent (N);\n-         while Present (Context) loop\n-\n-            --  The following could use a comment (and why is N_Case_Expression\n-            --  not treated in a similar manner ???\n-\n-            if Nkind (Context) = N_If_Expression then\n-               exit;\n-\n-            --  Stop the search when reaching any statement because we have\n-            --  gone too far up the tree.\n-\n-            elsif Nkind (Context) = N_Procedure_Call_Statement\n-              or else Nkind (Context) in N_Statement_Other_Than_Procedure_Call\n-            then\n-               exit;\n-            end if;\n-\n-            Context := Parent (Context);\n-         end loop;\n-\n-         return Context;\n-      end Enclosing_Context;\n-\n-      --  Local variables\n-\n-      Context : constant Node_Id := Enclosing_Context;\n-\n    begin\n       --  Optimization, if the returned value (which is on the sec-stack) is\n       --  returned again, no need to copy/readjust/finalize, we can just pass\n@@ -4096,15 +4057,12 @@ package body Exp_Ch6 is\n \n       Remove_Side_Effects (N);\n \n-      --  The function call is part of an if expression dependent expression.\n-      --  The temporary result must live as long as the if expression itself,\n-      --  otherwise it will be finalized too early. Mark the transient as\n-      --  processed to avoid untimely finalization.\n-\n-      --  Why no special handling for case expressions here ???\n+      --  When the temporary function result appears inside a case or an if\n+      --  expression, its lifetime must be extended to match that of the\n+      --  context. If not, the function result would be finalized prematurely\n+      --  and the evaluation of the expression could yield the wrong result.\n \n-      if Present (Context)\n-        and then Nkind (Context) = N_If_Expression\n+      if Within_Case_Or_If_Expression (N)\n         and then Nkind (N) = N_Explicit_Dereference\n       then\n          Set_Is_Processed_Transient (Entity (Prefix (N)));"}, {"sha": "3528fc9e8102db8cf01b275fe2901111269a3dee", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=4c7e09908b732b93b74b49ad3eafda0198c1d1df", "patch": "@@ -7944,6 +7944,43 @@ package body Exp_Util is\n       end if;\n    end Type_May_Have_Bit_Aligned_Components;\n \n+   ----------------------------------\n+   -- Within_Case_Or_If_Expression --\n+   ----------------------------------\n+\n+   function Within_Case_Or_If_Expression (N : Node_Id) return Boolean is\n+      Par : Node_Id;\n+\n+   begin\n+      --  Locate an enclosing case or if expression. Note that these constructs\n+      --  appear as expression_with_actions, hence the test using the original\n+      --  node.\n+\n+      Par := N;\n+      while Present (Par) loop\n+         if Nkind_In (Original_Node (Par), N_Case_Expression,\n+                                           N_If_Expression)\n+         then\n+            return True;\n+\n+         --  Prevent the search from going too far\n+\n+         elsif Nkind_In (Par, N_Entry_Body,\n+                              N_Package_Body,\n+                              N_Package_Declaration,\n+                              N_Protected_Body,\n+                              N_Subprogram_Body,\n+                              N_Task_Body)\n+         then\n+            return False;\n+         end if;\n+\n+         Par := Parent (Par);\n+      end loop;\n+\n+      return False;\n+   end Within_Case_Or_If_Expression;\n+\n    ----------------------------\n    -- Wrap_Cleanup_Procedure --\n    ----------------------------"}, {"sha": "e0b0e09f88be47a1a3eb6e4f3c4cf53bc9f6db6a", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=4c7e09908b732b93b74b49ad3eafda0198c1d1df", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -818,6 +818,9 @@ package Exp_Util is\n    --  is conservative, in that a result of False is decisive. A result of True\n    --  means that such a component may or may not be present.\n \n+   function Within_Case_Or_If_Expression (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N is within a case or an if expression\n+\n    procedure Wrap_Cleanup_Procedure (N : Node_Id);\n    --  Given an N_Subprogram_Body node, this procedure adds an Abort_Defer call\n    --  at the start of the statement sequence, and an Abort_Undefer call at the"}, {"sha": "267d50c6dca098f5e827f1d7bbb7836c17d7f97e", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7e09908b732b93b74b49ad3eafda0198c1d1df/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=4c7e09908b732b93b74b49ad3eafda0198c1d1df", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -10699,13 +10699,19 @@ package body Sem_Ch12 is\n          --  issues when the generic is a child unit and some aspect of the\n          --  generic type is declared in a parent unit of the generic. We do\n          --  the test to handle this special case only after a direct check\n-         --  for static matching has failed.\n+         --  for static matching has failed. The case where both the component\n+         --  type and the array type are separate formals, and the component\n+         --  type is a private view may also require special checking.\n \n          if Subtypes_Match\n            (Component_Type (A_Gen_T), Component_Type (Act_T))\n              or else Subtypes_Match\n-                      (Find_Actual_Type (Component_Type (A_Gen_T), A_Gen_T),\n-                       Component_Type (Act_T))\n+               (Find_Actual_Type (Component_Type (A_Gen_T), A_Gen_T),\n+               Component_Type (Act_T))\n+             or else Subtypes_Match\n+               (Base_Type\n+                 (Find_Actual_Type (Component_Type (A_Gen_T), A_Gen_T)),\n+               Component_Type (Act_T))\n          then\n             null;\n          else"}]}