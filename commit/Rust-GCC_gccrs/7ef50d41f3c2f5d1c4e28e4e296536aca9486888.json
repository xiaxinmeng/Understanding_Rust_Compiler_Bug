{"sha": "7ef50d41f3c2f5d1c4e28e4e296536aca9486888", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VmNTBkNDFmM2MyZjVkMWM0ZTI4ZTRlMjk2NTM2YWNhOTQ4Njg4OA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-01-26T10:25:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-01-26T10:25:52Z"}, "message": "par_sco.ads, [...] (Set_Statement_Entry): New handling of exits\n\n2010-01-26  Robert Dewar  <dewar@adacore.com>\n\n\t* par_sco.ads, par_sco.adb (Set_Statement_Entry): New handling of exits\n\t(Extend_Statement_Sequence): New procedures\n\t(Traverse_Declarations_Or_Statements): New handling for exits.\n\nFrom-SVN: r156241", "tree": {"sha": "5961d21e3346d48da4778fe1bf6f4eb9a5b35b85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5961d21e3346d48da4778fe1bf6f4eb9a5b35b85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ef50d41f3c2f5d1c4e28e4e296536aca9486888", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ef50d41f3c2f5d1c4e28e4e296536aca9486888", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ef50d41f3c2f5d1c4e28e4e296536aca9486888", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ef50d41f3c2f5d1c4e28e4e296536aca9486888/comments", "author": null, "committer": null, "parents": [{"sha": "82c7a5b12c3759b3e734ab87107de34f3351e700", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c7a5b12c3759b3e734ab87107de34f3351e700", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82c7a5b12c3759b3e734ab87107de34f3351e700"}], "stats": {"total": 154, "additions": 78, "deletions": 76}, "files": [{"sha": "4c9f2cd7e5f066a8e1c5779791d4161da101f78a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef50d41f3c2f5d1c4e28e4e296536aca9486888/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef50d41f3c2f5d1c4e28e4e296536aca9486888/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7ef50d41f3c2f5d1c4e28e4e296536aca9486888", "patch": "@@ -1,3 +1,9 @@\n+2010-01-26  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par_sco.ads, par_sco.adb (Set_Statement_Entry): New handling of exits\n+\t(Extend_Statement_Sequence): New procedures\n+\t(Traverse_Declarations_Or_Statements): New handling for exits.\n+\n 2010-01-26  Robert Dewar  <dewar@adacore.com>\n \n \t* par_sco.adb (Traverse_Declarations_Or_Statements): Add processing for"}, {"sha": "b4953b3e4bf9ed2d42019102d5fdb2b0dd62f9e7", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 67, "deletions": 58, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef50d41f3c2f5d1c4e28e4e296536aca9486888/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef50d41f3c2f5d1c4e28e4e296536aca9486888/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=7ef50d41f3c2f5d1c4e28e4e296536aca9486888", "patch": "@@ -760,11 +760,15 @@ package body Par_SCO is\n       Start : Source_Ptr;\n       Dummy : Source_Ptr;\n       Stop  : Source_Ptr;\n-      From  : Source_Ptr;\n-      To    : Source_Ptr;\n \n-      Term  : Boolean;\n-      --  Set False if current entity terminates statement list\n+      procedure Extend_Statement_Sequence (N : Node_Id);\n+      --  Extend the current statement sequence to encompass the node N\n+\n+      procedure Extend_Statement_Sequence (From : Node_Id; To : Node_Id);\n+      --  This version extends the current statement sequence with an entry\n+      --  that starts with the first token of From, and ends with the last\n+      --  token of To. It is used for example in a CASE statement to cover\n+      --  the range from the CASE token to the last token of the expression.\n \n       procedure Set_Statement_Entry;\n       --  If Start is No_Location, does nothing, otherwise outputs a SCO_Table\n@@ -779,15 +783,35 @@ package body Par_SCO is\n \n       procedure Set_Statement_Entry is\n       begin\n-         Term := True;\n-\n          if Start /= No_Location then\n             Set_Table_Entry ('S', ' ', Start, Stop, False);\n             Start := No_Location;\n             Stop  := No_Location;\n          end if;\n       end Set_Statement_Entry;\n \n+      -------------------------------\n+      -- Extend_Statement_Sequence --\n+      -------------------------------\n+\n+      procedure Extend_Statement_Sequence (N : Node_Id) is\n+      begin\n+         if Start = No_Location then\n+            Sloc_Range (N, Start, Stop);\n+         else\n+            Sloc_Range (N, Dummy, Stop);\n+         end if;\n+      end Extend_Statement_Sequence;\n+\n+      procedure Extend_Statement_Sequence (From : Node_Id; To : Node_Id) is\n+      begin\n+         if Start = No_Location then\n+            Sloc_Range (From, Start, Dummy);\n+         end if;\n+\n+         Sloc_Range (To, Dummy, Stop);\n+      end Extend_Statement_Sequence;\n+\n    --  Start of processing for Traverse_Declarations_Or_Statements\n \n    begin\n@@ -798,7 +822,11 @@ package body Par_SCO is\n          --  Loop through statements or declarations\n \n          while Present (N) loop\n-            Term := False;\n+\n+            --  Initialize or extend current statement sequence. Note that for\n+            --  special cases such as IF and Case statements we will modify\n+            --  the range to exclude internal statements that should not be\n+            --  counted as part of the current statement sequence.\n \n             case Nkind (N) is\n \n@@ -841,33 +869,37 @@ package body Par_SCO is\n                   Set_Statement_Entry;\n                   Traverse_Subprogram_Body (N);\n \n-               --  Exit statement\n+               --  Exit statement, which is an exit statement in the SCO sense,\n+               --  so it is included in the current statement sequence, but\n+               --  then it terminates this sequence. We also have to process\n+               --  any decisions in the exit statement expression.\n \n                when N_Exit_Statement =>\n+                  Extend_Statement_Sequence (N);\n                   Set_Statement_Entry;\n                   Process_Decisions (Condition (N), 'E');\n \n-                  --  This is an exit point\n-\n-                  Sloc_Range (N, From, To);\n-                  Set_Table_Entry ('T', ' ', From, To, False);\n-\n-               --  Label (breaks statement sequence)\n+               --  Label, which breaks the current statement sequence, and then\n+               --  we include the label in the subsequent statement sequence.\n \n                when N_Label =>\n                   Set_Statement_Entry;\n+                  Extend_Statement_Sequence (N);\n \n-               --  Block statement\n+               --  Block statement, which breaks the current statement seqeunce\n+               --  it probably does not need to, but for now it does.\n \n                when N_Block_Statement =>\n                   Set_Statement_Entry;\n                   Traverse_Declarations_Or_Statements (Declarations (N));\n                   Traverse_Handled_Statement_Sequence\n                     (Handled_Statement_Sequence (N));\n \n-               --  If statement\n+               --  If statement, which breaks the current statement sequence,\n+               --  but we include the condition in the current sequence.\n \n                when N_If_Statement =>\n+                  Extend_Statement_Sequence (N, Condition (N));\n                   Set_Statement_Entry;\n                   Process_Decisions (Condition (N), 'I');\n                   Traverse_Declarations_Or_Statements (Then_Statements (N));\n@@ -887,15 +919,12 @@ package body Par_SCO is\n \n                   Traverse_Declarations_Or_Statements (Else_Statements (N));\n \n-               --  Case statement\n+               --  Case statement, which breaks the current statement sequence,\n+               --  but we include the expression in the current sequence.\n \n                when N_Case_Statement =>\n \n-                  --  We include the expression, but not any of the case\n-                  --  branches in the generated statement sequence that\n-                  --  includes this case statement.\n-\n-                  Sloc_Range (Expression (N), Dummy, Stop);\n+                  Extend_Statement_Sequence (N, Expression (N));\n                   Set_Statement_Entry;\n                   Process_Decisions (Expression (N), 'X');\n \n@@ -912,29 +941,23 @@ package body Par_SCO is\n                      end loop;\n                   end;\n \n-               --  Unconditional exit points\n+               --  Unconditional exit points, which are included in the current\n+               --  statement sequence, but then terminate it\n \n                when N_Requeue_Statement |\n                     N_Goto_Statement    |\n                     N_Raise_Statement   =>\n+                  Extend_Statement_Sequence (N);\n                   Set_Statement_Entry;\n-                  Sloc_Range (N, From, To);\n-                  Set_Table_Entry ('T', ' ', From, To, False);\n \n-               --  Simple return statement\n+               --  Simple return statement. which is an exit point, but we\n+               --  have to process the return expression for decisions.\n \n                when N_Simple_Return_Statement =>\n+                  Extend_Statement_Sequence (N);\n                   Set_Statement_Entry;\n-\n-                  --  Process possible return expression\n-\n                   Process_Decisions (Expression (N), 'X');\n \n-                  --  Return is an exit point\n-\n-                  Sloc_Range (N, From, To);\n-                  Set_Table_Entry ('T', ' ', From, To, False);\n-\n                --  Extended return statement\n \n                when N_Extended_Return_Statement =>\n@@ -944,46 +967,32 @@ package body Par_SCO is\n                   Traverse_Handled_Statement_Sequence\n                     (Handled_Statement_Sequence (N));\n \n-                  --  Return is an exit point\n-\n-                  Sloc_Range (N, From, To);\n-                  Set_Table_Entry ('T', ' ', From, To, False);\n-\n-               --  Loop\n+               --  Loop ends the current statement sequence, but we include\n+               --  the iteration scheme if present in the current sequence.\n+               --  But the body of the loop starts a new sequence, since it\n+               --  may not be executed as part of the current sequence.\n \n                when N_Loop_Statement =>\n-\n-                  --  Even if not a while loop, we want a new statement seq\n-\n-                  Set_Statement_Entry;\n-\n                   if Present (Iteration_Scheme (N)) then\n+                     Extend_Statement_Sequence (N, Iteration_Scheme (N));\n                      Process_Decisions\n                        (Condition (Iteration_Scheme (N)), 'W');\n                   end if;\n \n+                  Set_Statement_Entry;\n                   Traverse_Declarations_Or_Statements (Statements (N));\n \n-               --  All other cases\n+               --  All other cases, which extend the current statement sequence\n+               --  but do not terminate it, even if they have nested decisions.\n \n                when others =>\n+                  Extend_Statement_Sequence (N);\n+\n                   if Has_Decision (N) then\n-                     Set_Statement_Entry;\n                      Process_Decisions (N, 'X');\n                   end if;\n             end case;\n \n-            --  If that element did not terminate the current sequence of\n-            --  statements, then establish or extend this sequence.\n-\n-            if not Term then\n-               if Start = No_Location then\n-                  Sloc_Range (N, Start, Stop);\n-               else\n-                  Sloc_Range (N, Dummy, Stop);\n-               end if;\n-            end if;\n-\n             Next (N);\n          end loop;\n "}, {"sha": "6cb68a714416a829f0ad15af92d32d02df5f67cd", "filename": "gcc/ada/par_sco.ads", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef50d41f3c2f5d1c4e28e4e296536aca9486888/gcc%2Fada%2Fpar_sco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef50d41f3c2f5d1c4e28e4e296536aca9486888/gcc%2Fada%2Fpar_sco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.ads?ref=7ef50d41f3c2f5d1c4e28e4e296536aca9486888", "patch": "@@ -79,11 +79,6 @@ package Par_SCO is\n    --      renaming_declaration\n    --      generic_instantiation\n \n-   --      ??? is this list complete ???\n-\n-   --    ??? what is the exact story on complex statements such as blocks ???\n-   --    ??? are the simple statements inside sufficient ???\n-\n    --  Statement lines\n \n    --    These lines correspond to a sequence of one or more statements which\n@@ -156,9 +151,8 @@ package Par_SCO is\n    --    The following is a grammar showing the structure of expression:\n \n    --      expression ::= term             (if expr is not logical operator)\n-   --      expression ::= & term term      (if expr is AND or AND THEN)\n-   --      expression ::= | term term      (if expr is OR or OR ELSE)\n-   --      expression ::= ^ term term      (if expr is XOR)\n+   --      expression ::= & term term      (if expr is AND THEN)\n+   --      expression ::= | term term      (if expr is OR ELSE)\n    --      expression ::= !term            (if expr is NOT)\n \n    --      term ::= element\n@@ -175,18 +169,11 @@ package Par_SCO is\n    --      where t/f are used to mark a condition that has been recognized by\n    --      the compiler as always being true or false.\n \n-   --    & indicates either AND or AND THEN connecting two conditions. In the\n-   --    context of couverture we only permit AND THEN in the source in any\n-   --    case, so & can always be understood to be AND THEN.\n-\n-   --    | indicates either OR or OR ELSE connection two conditions. In the\n-   --    context of couverture we only permit OR ELSE in the source in any\n-   --    case, so | can always be understood to be OR ELSE.\n+   --    & indicates either AND THEN connecting two conditions\n \n-   --    ^ indicates XOR connecting two conditions. In the context of\n-   --    couverture, we do not permit XOR, so this will never appear.\n+   --    | indicates either OR ELSE connection two conditions\n \n-   --    ! indicates NOT applied to the expression.\n+   --    ! indicates NOT applied to the expression\n \n    -----------------\n    -- Subprograms --"}]}