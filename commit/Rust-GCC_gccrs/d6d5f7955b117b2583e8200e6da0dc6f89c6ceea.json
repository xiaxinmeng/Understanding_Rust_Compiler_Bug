{"sha": "d6d5f7955b117b2583e8200e6da0dc6f89c6ceea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZkNWY3OTU1YjExN2IyNTgzZTgyMDBlNmRhMGRjNmY4OWM2Y2VlYQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-04-26T10:17:32Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-04-26T10:17:32Z"}, "message": "* cpplex.c: add comment describing lexer algorithm.\n\nFrom-SVN: r33443", "tree": {"sha": "637d4de861174c6addee5785e900b057b9dfd54d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/637d4de861174c6addee5785e900b057b9dfd54d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6d5f7955b117b2583e8200e6da0dc6f89c6ceea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d5f7955b117b2583e8200e6da0dc6f89c6ceea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6d5f7955b117b2583e8200e6da0dc6f89c6ceea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d5f7955b117b2583e8200e6da0dc6f89c6ceea/comments", "author": null, "committer": null, "parents": [{"sha": "6f0ae5b4f25738222c3c541be3a695a4488414a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f0ae5b4f25738222c3c541be3a695a4488414a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f0ae5b4f25738222c3c541be3a695a4488414a8"}], "stats": {"total": 90, "additions": 90, "deletions": 0}, "files": [{"sha": "56208927dd9c905eff2be738f92a41d402b1eecd", "filename": "gcc/cpplex.c", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d5f7955b117b2583e8200e6da0dc6f89c6ceea/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d5f7955b117b2583e8200e6da0dc6f89c6ceea/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=d6d5f7955b117b2583e8200e6da0dc6f89c6ceea", "patch": "@@ -2050,6 +2050,96 @@ _cpp_init_input_buffer (pfile)\n \n #if 0\n \n+/* Lexing algorithm.\n+\n+ The original lexer in cpplib was made up of two passes: a first pass\n+ that replaced trigraphs and deleted esacped newlines, and a second\n+ pass that tokenized the result of the first pass.  Tokenisation was\n+ performed by peeking at the next character in the input stream.  For\n+ example, if the input stream contained \"~=\", the handler for the ~\n+ character would peek at the next character, and if it were a '='\n+ would skip over it, and return a \"~=\" token, otherwise it would\n+ return just the \"~\" token.\n+\n+ To implement a single-pass lexer, this peeking ahead is unworkable.\n+ An arbitrary number of escaped newlines, and trigraphs (in particular\n+ ??/ which translates to the escape \\), could separate the '~' and '='\n+ in the input stream, yet the next token is still a \"~=\".\n+\n+ Suppose instead that we lex by one logical line at a time, producing\n+ a token list or stack for each logical line, and when seeing the '~'\n+ push a CPP_COMPLEMENT token on the list.  Then if the '~' is part of\n+ a longer token (\"~=\") we know we must see the remainder of the token\n+ by the time we reach the end of the logical line.  Thus we can have\n+ the '=' handler look at the previous token (at the end of the list /\n+ top of the stack) and see if it is a \"~\" token, and if so, instead of\n+ pushing a \"=\" token revise the existing token to be a \"~=\" token.\n+\n+ This works in the presence of escaped newlines, because the '\\' would\n+ have been pushed on the top of the stack as a CPP_BACKSLASH.  The\n+ newline ('\\n' or '\\r') handler looks at the token at the top of the\n+ stack to see if it is a CPP_BACKSLASH, and if so discards both.\n+ Otherwise it pushes the newline (CPP_VSPACE) token as normal.  Hence\n+ the '=' handler would never see any intervening escaped newlines.\n+\n+ To make trigraphs work in this context, as in precedence trigraphs\n+ are highest and converted before anything else, the '?' handler does\n+ lookahead to see if it is a trigraph, and if so skips the trigraph\n+ and pushes the token it represents onto the top of the stack.  This\n+ also works in the particular case of a CPP_BACKSLASH trigraph.\n+\n+ To the preprocessor, whitespace is only significant to the point of\n+ knowing whether whitespace precedes a particular token.  For example,\n+ the '=' handler needs to know whether there was whitespace between it\n+ and a \"~\" token on the top of the stack, to make the token conversion\n+ decision correctly.  So each token has a PREV_WHITESPACE flag to\n+ indicate this - the standard permits consecutive whitespace to be\n+ regarded as a single space.  The compiler front ends are not\n+ interested in whitespace at all; they just require a token stream.\n+ Another place where whitespace is significant to the preprocessor is\n+ a #define statment - if there is whitespace between the macro name\n+ and an initial \"(\" token the macro is \"object-like\", otherwise it is\n+ a function-like macro that takes arguments.\n+\n+ However, all is not rosy.  Parsing of identifiers, numbers, comments\n+ and strings becomes trickier because of the possibility of raw\n+ trigraphs and escaped newlines in the input stream.\n+\n+ The trigraphs are three consecutive characters beginning with two\n+ question marks.  A question mark is not a valid as part of a number\n+ or identifier, so parsing of a number or identifier terminates\n+ normally upon reaching it, returning to the mainloop which handles\n+ the trigraph just like it would in any other position.  Similarly for\n+ the backslash of a backslash-newline combination.  So we just need\n+ the escaped-newline dropper in the mainloop to check if the token on\n+ the top of the stack is a number or identifier, and to continue the\n+ processing of the token as if nothing had happened.\n+\n+ For strings, we replace trigraphs whenever we reach a quote or\n+ newline, because there might be a backslash trigraph escaping them.\n+ We need to be careful that we start trigraph replacing from where we\n+ left off previously, because it is possible for a first scan to leave\n+ \"fake\" trigraphs that a second scan would pick up as real (e.g. the\n+ sequence \"????\\\\n=\" would find a fake ??= trigraph after removing the\n+ escaped newline.)\n+\n+ For line comments, on reaching a newline we scan the previous\n+ character(s) to see if it escaped, and continue if it is.  Block\n+ comments ignore everything and just focus on finding the comment\n+ termination mark.  The only difficult thing, and it is surprisingly\n+ tricky, is checking if an asterisk precedes the final slash since\n+ they could be separated by escaped newlines.  If the preprocessor is\n+ invoked with the output comments option, we don't bother removing\n+ escaped newlines and replacing trigraphs for output.\n+\n+ Finally, numbers can begin with a period, which is pushed initially\n+ as a CPP_DOT token in its own right.  The digit handler checks if the\n+ previous token was a CPP_DOT not separated by whitespace, and if so\n+ pops it off the stack and pushes a period into the number's buffer\n+ before calling the number parser.\n+\n+*/\n+\n static void expand_comment_space PARAMS ((cpp_toklist *));\n void init_trigraph_map PARAMS ((void));\n static unsigned char* trigraph_replace PARAMS ((cpp_reader *, unsigned char *,"}]}