{"sha": "7af6648c5985b467eba67431d384b8bc26e13ad4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FmNjY0OGM1OTg1YjQ2N2ViYTY3NDMxZDM4NGI4YmMyNmUxM2FkNA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-08-23T10:22:18Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-08-23T10:22:18Z"}, "message": "re PR fortran/33095 (MAX with optional arguments gives run-time error)\n\n\tPR fortran/33095\n\n\t* trans-intrinsic.c (gfc_conv_intrinsic_minmax): Remove\n\truntime error checking.\n\n\t* gfortran.dg/min_max_optional_5.f90: New test.\n\t* gfortran.dg/min_max_optional_2.f90: Remove.\n\t* gfortran.dg/min_max_optional_3.f90: Remove.\n\t* gfortran.dg/min_max_optional_4.f90: Remove.\n\nFrom-SVN: r127732", "tree": {"sha": "84bf35d895cd7383b730ed7d676d980eb32f8772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84bf35d895cd7383b730ed7d676d980eb32f8772"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7af6648c5985b467eba67431d384b8bc26e13ad4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7af6648c5985b467eba67431d384b8bc26e13ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7af6648c5985b467eba67431d384b8bc26e13ad4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7af6648c5985b467eba67431d384b8bc26e13ad4/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3a47fe4af35469b8769711fa89c6c88fdc72dab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a47fe4af35469b8769711fa89c6c88fdc72dab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3a47fe4af35469b8769711fa89c6c88fdc72dab"}], "stats": {"total": 141, "additions": 48, "deletions": 93}, "files": [{"sha": "05e7b9f897b85110476557f803fbb901409e3f3e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7af6648c5985b467eba67431d384b8bc26e13ad4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7af6648c5985b467eba67431d384b8bc26e13ad4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7af6648c5985b467eba67431d384b8bc26e13ad4", "patch": "@@ -1,3 +1,9 @@\n+2007-08-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/33095\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_minmax): Remove\n+\truntime error checking.\n+\n 2007-08-22  Roger Sayle  <roger@eyesopen.com>\n \t    Tobias Schl\ufffdter <tobias.schlueter@physik.uni-muenchen.de>\n "}, {"sha": "a6802b33f7dcb7f1e843283d4f040bf195d6ed52", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 13, "deletions": 54, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7af6648c5985b467eba67431d384b8bc26e13ad4/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7af6648c5985b467eba67431d384b8bc26e13ad4/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=7af6648c5985b467eba67431d384b8bc26e13ad4", "patch": "@@ -1420,10 +1420,9 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n /* Get the minimum/maximum value of all the parameters.\n     minmax (a1, a2, a3, ...)\n     {\n-      if (a2 .op. a1 || isnan(a1))\n+      mvar = a1;\n+      if (a2 .op. mvar || isnan(mvar))\n         mvar = a2;\n-      else\n-        mvar = a1;\n       if (a3 .op. mvar || isnan(mvar))\n         mvar = a3;\n       ...\n@@ -1436,76 +1435,38 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n {\n-  tree limit;\n   tree tmp;\n   tree mvar;\n   tree val;\n   tree thencase;\n-  tree elsecase;\n   tree *args;\n   tree type;\n   gfc_actual_arglist *argexpr;\n-  unsigned int i;\n-  unsigned int nargs;\n+  unsigned int i, nargs;\n \n   nargs = gfc_intrinsic_argument_list_length (expr);\n   args = alloca (sizeof (tree) * nargs);\n \n   gfc_conv_intrinsic_function_args (se, expr, args, nargs);\n   type = gfc_typenode_for_spec (&expr->ts);\n \n-  /* The first and second arguments should be present, if they are\n-     optional dummy arguments.  */\n   argexpr = expr->value.function.actual;\n-  if (argexpr->expr->expr_type == EXPR_VARIABLE\n-      && argexpr->expr->symtree->n.sym->attr.optional\n-      && TREE_CODE (args[0]) == INDIRECT_REF)\n-    {\n-      /* Check the first argument.  */\n-      tree cond;\n-      char *msg;\n-\n-      asprintf (&msg, \"First argument of '%s' intrinsic should be present\",\n-\t\texpr->symtree->n.sym->name);\n-      cond = build2 (EQ_EXPR, boolean_type_node, TREE_OPERAND (args[0], 0),\n-\t\t     build_int_cst (TREE_TYPE (TREE_OPERAND (args[0], 0)), 0));\n-      gfc_trans_runtime_check (cond, &se->pre, &expr->where, msg);\n-      gfc_free (msg);\n-    }\n-\n-  if (argexpr->next->expr->expr_type == EXPR_VARIABLE\n-      && argexpr->next->expr->symtree->n.sym->attr.optional\n-      && TREE_CODE (args[1]) == INDIRECT_REF)\n-    {\n-      /* Check the second argument.  */\n-      tree cond;\n-      char *msg;\n-\n-      asprintf (&msg, \"Second argument of '%s' intrinsic should be present\",\n-\t\texpr->symtree->n.sym->name);\n-      cond = build2 (EQ_EXPR, boolean_type_node, TREE_OPERAND (args[1], 0),\n-\t\t     build_int_cst (TREE_TYPE (TREE_OPERAND (args[1], 0)), 0));\n-      gfc_trans_runtime_check (cond, &se->pre, &expr->where, msg);\n-      gfc_free (msg);\n-    }\n-\n-  limit = args[0];\n-  if (TREE_TYPE (limit) != type)\n-    limit = convert (type, limit);\n+  if (TREE_TYPE (args[0]) != type)\n+    args[0] = convert (type, args[0]);\n   /* Only evaluate the argument once.  */\n-  if (TREE_CODE (limit) != VAR_DECL && !TREE_CONSTANT (limit))\n-    limit = gfc_evaluate_now (limit, &se->pre);\n+  if (TREE_CODE (args[0]) != VAR_DECL && !TREE_CONSTANT (args[0]))\n+    args[0] = gfc_evaluate_now (args[0], &se->pre);\n \n   mvar = gfc_create_var (type, \"M\");\n-  elsecase = build2_v (MODIFY_EXPR, mvar, limit);\n+  gfc_add_modify_expr (&se->pre, mvar, args[0]);\n   for (i = 1, argexpr = argexpr->next; i < nargs; i++)\n     {\n       tree cond, isnan;\n \n       val = args[i]; \n \n       /* Handle absent optional arguments by ignoring the comparison.  */\n-      if (i > 0 && argexpr->expr->expr_type == EXPR_VARIABLE\n+      if (argexpr->expr->expr_type == EXPR_VARIABLE\n \t  && argexpr->expr->symtree->n.sym->attr.optional\n \t  && TREE_CODE (val) == INDIRECT_REF)\n \tcond = build2 (NE_EXPR, boolean_type_node, TREE_OPERAND (val, 0),\n@@ -1521,25 +1482,23 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n \n       thencase = build2_v (MODIFY_EXPR, mvar, convert (type, val));\n \n-      tmp = build2 (op, boolean_type_node, convert (type, val), limit);\n+      tmp = build2 (op, boolean_type_node, convert (type, val), mvar);\n \n       /* FIXME: When the IEEE_ARITHMETIC module is implemented, the call to\n \t __builtin_isnan might be made dependent on that module being loaded,\n \t to help performance of programs that don't rely on IEEE semantics.  */\n-      if (FLOAT_TYPE_P (TREE_TYPE (limit)))\n+      if (FLOAT_TYPE_P (TREE_TYPE (mvar)))\n \t{\n-\t  isnan = build_call_expr (built_in_decls[BUILT_IN_ISNAN], 1, limit);\n+\t  isnan = build_call_expr (built_in_decls[BUILT_IN_ISNAN], 1, mvar);\n \t  tmp = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, tmp,\n \t\t\t     fold_convert (boolean_type_node, isnan));\n \t}\n-      tmp = build3_v (COND_EXPR, tmp, thencase, elsecase);\n+      tmp = build3_v (COND_EXPR, tmp, thencase, build_empty_stmt ());\n \n       if (cond != NULL_TREE)\n \ttmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n \n       gfc_add_expr_to_block (&se->pre, tmp);\n-      elsecase = build_empty_stmt ();\n-      limit = mvar;\n       argexpr = argexpr->next;\n     }\n   se->expr = mvar;"}, {"sha": "2f3961dfe62e058db51996fd274298300d872400", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7af6648c5985b467eba67431d384b8bc26e13ad4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7af6648c5985b467eba67431d384b8bc26e13ad4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7af6648c5985b467eba67431d384b8bc26e13ad4", "patch": "@@ -1,3 +1,11 @@\n+2007-08-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/33095\n+\t* gfortran.dg/min_max_optional_5.f90: New test.\n+\t* gfortran.dg/min_max_optional_2.f90: Remove.\n+\t* gfortran.dg/min_max_optional_3.f90: Remove.\n+\t* gfortran.dg/min_max_optional_4.f90: Remove.\n+\n 2007-08-23  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* gcc.target/i386/cmov3.c: Fix scan-assembler."}, {"sha": "51e0feee641a8f2f22a20f8f966de96ea42446ec", "filename": "gcc/testsuite/gfortran.dg/min_max_optional_2.f90", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a47fe4af35469b8769711fa89c6c88fdc72dab/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a47fe4af35469b8769711fa89c6c88fdc72dab/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_2.f90?ref=e3a47fe4af35469b8769711fa89c6c88fdc72dab", "patch": "@@ -1,13 +0,0 @@\n-! { dg-do run }\n-! { dg-shouldfail \"\" }\n-  program test \n-    if (m1(3,4) /= 4) call abort\n-    if (m1(3) /= 3) call abort\n-    print *, m1() \n-  contains \n-    integer function m1(a1,a2) \n-      integer, optional :: a1,a2 \n-      m1 = max(a2, a1, 1, 2) \n-    end function m1 \n-  end \n-! { dg-output \"First argument of 'max' intrinsic should be present\" }"}, {"sha": "e0e6e29d969d6a11db844b26b27d17565c1e9600", "filename": "gcc/testsuite/gfortran.dg/min_max_optional_3.f90", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a47fe4af35469b8769711fa89c6c88fdc72dab/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a47fe4af35469b8769711fa89c6c88fdc72dab/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_3.f90?ref=e3a47fe4af35469b8769711fa89c6c88fdc72dab", "patch": "@@ -1,14 +0,0 @@\n-! { dg-do run }\n-! { dg-shouldfail \"\" }\n-  program test \n-    if (m1(1,2,3,4) /= 1) call abort\n-    if (m1(1,2,3) /= 1) call abort\n-    if (m1(1,2) /= 1) call abort\n-    print *, m1(1) \n-    print *, m1() \n-  contains \n-    integer function m1(a1,a2,a3,a4) \n-      integer, optional :: a1,a2,a3,a4 \n-      m1 = min(a1,a2,a3,a4) ! { dg-output \"Second argument of 'min' intrinsic should be present\" }\n-    end function m1 \n-  end "}, {"sha": "b749db0f8e369df2d645ce209a1f7902e9fa3339", "filename": "gcc/testsuite/gfortran.dg/min_max_optional_4.f90", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a47fe4af35469b8769711fa89c6c88fdc72dab/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a47fe4af35469b8769711fa89c6c88fdc72dab/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_4.f90?ref=e3a47fe4af35469b8769711fa89c6c88fdc72dab", "patch": "@@ -1,12 +0,0 @@\n-! { dg-do run }\n-! { dg-shouldfail \"\" }\n-program test\n-  call foo(\"foo\")\n-contains\n-  subroutine foo(a, b, c, d)\n-    character(len=*), optional :: a, b, c, d\n-    integer :: i\n-    i = len_trim(min(a,b,c,d)) ! { dg-output \"Second argument of 'MIN' intrinsic should be present\" }\n-    print *, i\n-  end subroutine foo\n-end"}, {"sha": "ae3344f790fc5a07fdaf072283fade185751cfe8", "filename": "gcc/testsuite/gfortran.dg/min_max_optional_5.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7af6648c5985b467eba67431d384b8bc26e13ad4/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7af6648c5985b467eba67431d384b8bc26e13ad4/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_5.f90?ref=7af6648c5985b467eba67431d384b8bc26e13ad4", "patch": "@@ -0,0 +1,21 @@\n+! More tests for MIN/MAX with optional arguments\n+! PR33095\n+!\n+! { dg-do run }\n+  if (m1(3,4) /= 4) call abort\n+  if (m1(3) /= 3) call abort\n+  if (m1() /= 2) call abort\n+\n+  if (m1(3,4) /= 4) call abort\n+  if (m1(3) /= 3) call abort\n+contains\n+  integer function m1(a1,a2)\n+    integer, optional, intent(in) :: a1, a2\n+    m1 = max(1, 2, a1, a2)\n+  end function m1\n+\n+  integer function m2(a1,a2)\n+    integer, optional, intent(in) :: a1, a2\n+    m2 = max(1, a1, 2, a2)\n+  end function m2\n+end"}]}