{"sha": "229a2e659eec385b9a2c74246d27d9615e23eda7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI5YTJlNjU5ZWVjMzg1YjlhMmM3NDI0NmQyN2Q5NjE1ZTIzZWRhNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-10-28T00:18:39Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-10-28T00:18:39Z"}, "message": "c-typeck.c (check_init_type_bitfields): Remove.\n\n\t* c-typeck.c (check_init_type_bitfields): Remove.\n\t(constructor_incremental): Likewise.\n\t(struct constructor_stack): Remove incremental bit.\n\t(struct initializer_stack): Likewise.\n\t(start_init): Don't play with constructor_incremental.\n\t(finish_init): Likewise.\n\t(really_start_incremental_init): Likewise.\n\t(push_init_level): Likewise.\n\t(pop_init_level): Likewise.\n\t(output_init_level): Likewise.\n\t(output_pending_init_elements): Likewise.\n\nFrom-SVN: r37096", "tree": {"sha": "eb73baa5fbb30c388a62c01abef113416c6627de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb73baa5fbb30c388a62c01abef113416c6627de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/229a2e659eec385b9a2c74246d27d9615e23eda7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229a2e659eec385b9a2c74246d27d9615e23eda7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/229a2e659eec385b9a2c74246d27d9615e23eda7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229a2e659eec385b9a2c74246d27d9615e23eda7/comments", "author": null, "committer": null, "parents": [{"sha": "63eb1269483a23914c535d12afd5b5e0f4e02391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63eb1269483a23914c535d12afd5b5e0f4e02391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63eb1269483a23914c535d12afd5b5e0f4e02391"}], "stats": {"total": 335, "additions": 40, "deletions": 295}, "files": [{"sha": "cebbe87f025fe0c86ebb0eddd48a853bf153872c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229a2e659eec385b9a2c74246d27d9615e23eda7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229a2e659eec385b9a2c74246d27d9615e23eda7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=229a2e659eec385b9a2c74246d27d9615e23eda7", "patch": "@@ -1,3 +1,17 @@\n+2000-10-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-typeck.c (check_init_type_bitfields): Remove.\n+\t(constructor_incremental): Likewise.\n+\t(struct constructor_stack): Remove incremental bit.\n+\t(struct initializer_stack): Likewise.\n+\t(start_init): Don't play with constructor_incremental.\n+\t(finish_init): Likewise.\n+\t(really_start_incremental_init): Likewise.\n+\t(push_init_level): Likewise.\n+\t(pop_init_level): Likewise.\n+\t(output_init_level): Likewise.\n+\t(output_pending_init_elements): Likewise.\n+\n 2000-10-21  Mike Coleman  <mcoleman2@kc.rr.com>\n \n \t* c-pragma.c (handle_pragma_pack): Initialize align to -1."}, {"sha": "a118619ffac431d06662361b8d41c60f2ad70f82", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 20, "deletions": 294, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229a2e659eec385b9a2c74246d27d9615e23eda7/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229a2e659eec385b9a2c74246d27d9615e23eda7/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=229a2e659eec385b9a2c74246d27d9615e23eda7", "patch": "@@ -74,7 +74,6 @@ static int spelling_length\t\tPARAMS ((void));\n static char *print_spelling\t\tPARAMS ((char *));\n static void warning_init\t\tPARAMS ((const char *));\n static tree digest_init\t\t\tPARAMS ((tree, tree, int, int));\n-static void check_init_type_bitfields\tPARAMS ((tree));\n static void output_init_element\t\tPARAMS ((tree, tree, tree, int));\n static void output_pending_init_elements PARAMS ((int));\n static void add_pending_init\t\tPARAMS ((tree, tree));\n@@ -4900,10 +4899,6 @@ int constructor_no_implicit = 0; /* 0 for C; 1 for some other languages.  */\n static int require_constant_value;\n static int require_constant_elements;\n \n-/* 1 if it is ok to output this constructor as we read it.\n-   0 means must accumulate a CONSTRUCTOR expression.  */\n-static int constructor_incremental;\n-\n /* DECL node for which an initializer is being read.\n    0 means we are reading a constructor expression\n    such as (struct foo) {...}.  */\n@@ -4941,7 +4936,6 @@ struct constructor_stack\n   char constant;\n   char simple;\n   char implicit;\n-  char incremental;\n   char erroneous;\n   char outer;\n };\n@@ -4963,7 +4957,6 @@ struct initializer_stack\n   struct spelling *spelling_base;\n   int spelling_size;\n   char top_level;\n-  char incremental;\n   char require_constant_value;\n   char require_constant_elements;\n   char deferred;\n@@ -4989,7 +4982,6 @@ start_init (decl, asmspec_tree, top_level)\n \n   p->decl = constructor_decl;\n   p->asmspec = constructor_asmspec;\n-  p->incremental = constructor_incremental;\n   p->require_constant_value = require_constant_value;\n   p->require_constant_elements = require_constant_elements;\n   p->constructor_stack = constructor_stack;\n@@ -5003,7 +4995,6 @@ start_init (decl, asmspec_tree, top_level)\n   initializer_stack = p;\n \n   constructor_decl = decl;\n-  constructor_incremental = top_level;\n   constructor_asmspec = asmspec;\n   constructor_subconstants_deferred = 0;\n   constructor_top_level = top_level;\n@@ -5020,8 +5011,6 @@ start_init (decl, asmspec_tree, top_level)\n \t       || TREE_CODE (TREE_TYPE (decl)) == UNION_TYPE\n \t       || TREE_CODE (TREE_TYPE (decl)) == QUAL_UNION_TYPE));\n       locus = IDENTIFIER_POINTER (DECL_NAME (decl));\n-      constructor_incremental \n-\t|= (TREE_STATIC (decl) && !DECL_CONTEXT (decl));\n     }\n   else\n     {\n@@ -5064,7 +5053,6 @@ finish_init ()\n   /* Pop back to the data of the outer initializer (if any).  */\n   constructor_decl = p->decl;\n   constructor_asmspec = p->asmspec;\n-  constructor_incremental = p->incremental;\n   require_constant_value = p->require_constant_value;\n   require_constant_elements = p->require_constant_elements;\n   constructor_stack = p->constructor_stack;\n@@ -5095,11 +5083,6 @@ really_start_incremental_init (type)\n   if (type == 0)\n     type = TREE_TYPE (constructor_decl);\n \n-  /* Turn off constructor_incremental if type is a struct with bitfields.\n-     Do this before the first push, so that the corrected value\n-     is available in finish_init.  */\n-  check_init_type_bitfields (type);\n-\n   p->type = constructor_type;\n   p->fields = constructor_fields;\n   p->index = constructor_index;\n@@ -5116,7 +5099,6 @@ really_start_incremental_init (type)\n   p->depth = constructor_depth;\n   p->replacement_value = 0;\n   p->implicit = 0;\n-  p->incremental = constructor_incremental;\n   p->outer = 0;\n   p->next = 0;\n   constructor_stack = p;\n@@ -5162,16 +5144,6 @@ really_start_incremental_init (type)\n       constructor_fields = constructor_type;\n       constructor_unfilled_fields = constructor_type;\n     }\n-\n-  if (constructor_incremental)\n-    {\n-      make_decl_rtl (constructor_decl, constructor_asmspec,\n-\t\t     constructor_top_level);\n-      assemble_variable (constructor_decl, constructor_top_level, 0, 1);\n-\n-      defer_addressed_constants ();\n-      constructor_subconstants_deferred = 1;\n-    }\n }\n \f\n /* Push down into a subobject, for initialization.\n@@ -5200,30 +5172,6 @@ push_init_level (implicit)\n \tbreak;\n     }\n \n-  /* Structure elements may require alignment.  Do this now if necessary\n-     for the subaggregate, and if it comes next in sequence.  Don't do\n-     this for subaggregates that will go on the pending list.  */\n-  if (constructor_incremental && constructor_type != 0\n-      && TREE_CODE (constructor_type) == RECORD_TYPE && constructor_fields\n-      && constructor_fields == constructor_unfilled_fields)\n-    {\n-      /* Advance to offset of this element.  */\n-      if (! tree_int_cst_equal (constructor_bit_index,\n-\t\t\t\tbit_position (constructor_fields)))\n-\tassemble_zeros\n-\t  (tree_low_cst\n-\t   (size_binop (TRUNC_DIV_EXPR,\n-\t\t\tsize_binop (MINUS_EXPR,\n-\t\t\t\t    bit_position (constructor_fields),\n-\t\t\t\t    constructor_bit_index),\n-\t\t\tbitsize_unit_node),\n-\t    1));\n-\n-      /* Indicate that we have now filled the structure up to the current\n-\t field.  */\n-      constructor_unfilled_fields = constructor_fields;\n-    }\n-\n   p = (struct constructor_stack *) xmalloc (sizeof (struct constructor_stack));\n   p->type = constructor_type;\n   p->fields = constructor_fields;\n@@ -5241,7 +5189,6 @@ push_init_level (implicit)\n   p->depth = constructor_depth;\n   p->replacement_value = 0;\n   p->implicit = implicit;\n-  p->incremental = constructor_incremental;\n   p->outer = 0;\n   p->next = constructor_stack;\n   constructor_stack = p;\n@@ -5267,18 +5214,13 @@ push_init_level (implicit)\n \t  constructor_type = TREE_TYPE (constructor_fields);\n \t  push_member_name (constructor_fields);\n \t  constructor_depth++;\n-\t  if (constructor_fields != constructor_unfilled_fields)\n-\t    constructor_incremental = 0;\n \t}\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n       constructor_type = TREE_TYPE (constructor_type);\n       push_array_bounds (tree_low_cst (constructor_index, 0));\n       constructor_depth++;\n-      if (! tree_int_cst_equal (constructor_index, constructor_unfilled_index)\n-\t  || constructor_range_end != 0)\n-\tconstructor_incremental = 0;\n     }\n \n   if (constructor_type == 0)\n@@ -5289,9 +5231,6 @@ push_init_level (implicit)\n       return;\n     }\n \n-  /* Turn off constructor_incremental if type is a struct with bitfields.  */\n-  check_init_type_bitfields (constructor_type);\n-\n   if (implicit && warn_missing_braces && !missing_braces_mentioned)\n     {\n       missing_braces_mentioned = 1;\n@@ -5335,45 +5274,6 @@ push_init_level (implicit)\n     }\n }\n \n-/* Don't read a struct incrementally if it has any bitfields,\n-   because the incremental reading code doesn't know how to\n-   handle bitfields yet.  */\n-\n-static void\n-check_init_type_bitfields (type)\n-     tree type;\n-{\n-  if (TREE_CODE (type) == RECORD_TYPE)\n-    {\n-      tree tail;\n-      for (tail = TYPE_FIELDS (type); tail;\n-\t   tail = TREE_CHAIN (tail))\n-\t{\n-\t  if (DECL_C_BIT_FIELD (tail))\n-\t    {\n-\t      constructor_incremental = 0;\n-\t      break;\n-\t    }\n-\n-\t  check_init_type_bitfields (TREE_TYPE (tail));\n-\t}\n-    }\n-\n-  else if (TREE_CODE (type) == UNION_TYPE)\n-    {\n-      tree tail = TYPE_FIELDS (type);\n-      if (tail && DECL_C_BIT_FIELD (tail))\n-\t/* We also use the nonincremental algorithm for initiliazation\n-\t   of unions whose first member is a bitfield, becuase the\n-\t   incremental algorithm has no code for dealing with\n-\t   bitfields. */\n-\tconstructor_incremental = 0;\n-    }\n-\n-  else if (TREE_CODE (type) == ARRAY_TYPE)\n-    check_init_type_bitfields (TREE_TYPE (type));\n-}\n-\n /* At the end of an implicit or explicit brace level, \n    finish up that level of constructor.\n    If we were outputting the elements as they are read, return 0\n@@ -5429,45 +5329,14 @@ pop_init_level (implicit)\n   /* Pad out the end of the structure.  */\n   \n   if (p->replacement_value)\n-    {\n-      /* If this closes a superfluous brace pair,\n-\t just pass out the element between them.  */\n-      constructor = p->replacement_value;\n-      /* If this is the top level thing within the initializer,\n-\t and it's for a variable, then since we already called\n-\t assemble_variable, we must output the value now.  */\n-      if (p->next == 0 && constructor_decl != 0\n-\t  && constructor_incremental)\n-\t{\n-\t  constructor = digest_init (constructor_type, constructor,\n-\t\t\t\t     require_constant_value,\n-\t\t\t\t     require_constant_elements);\n-\n-\t  /* If initializing an array of unknown size,\n-\t     determine the size now.  */\n-\t  if (TREE_CODE (constructor_type) == ARRAY_TYPE\n-\t      && TYPE_DOMAIN (constructor_type) == 0)\n-\t    {\n-\t      /* We shouldn't have an incomplete array type within\n-\t\t some other type.  */\n-\t      if (constructor_stack->next)\n-\t\tabort ();\n-\n-\t      if (complete_array_type (constructor_type, constructor, 0))\n-\t\tabort ();\n-\n-\t      size = int_size_in_bytes (constructor_type);\n-\t    }\n-\n-\t  output_constant (constructor, size);\n-\t}\n-    }\n+    /* If this closes a superfluous brace pair,\n+       just pass out the element between them.  */\n+    constructor = p->replacement_value;\n   else if (constructor_type == 0)\n     ;\n   else if (TREE_CODE (constructor_type) != RECORD_TYPE\n \t   && TREE_CODE (constructor_type) != UNION_TYPE\n-\t   && TREE_CODE (constructor_type) != ARRAY_TYPE\n-\t   && ! constructor_incremental)\n+\t   && TREE_CODE (constructor_type) != ARRAY_TYPE)\n     {\n       /* A nonincremental scalar initializer--just return\n \t the element, after verifying there is just one.  */\n@@ -5484,7 +5353,7 @@ pop_init_level (implicit)\n       else\n \tconstructor = TREE_VALUE (constructor_elements);\n     }\n-  else if (! constructor_incremental)\n+  else\n     {\n       if (constructor_erroneous)\n \tconstructor = error_mark_node;\n@@ -5498,58 +5367,7 @@ pop_init_level (implicit)\n \t    TREE_STATIC (constructor) = 1;\n \t}\n     }\n-  else\n-    {\n-      tree filled;\n \n-      if (TREE_CODE (constructor_type) == RECORD_TYPE\n-\t  || TREE_CODE (constructor_type) == UNION_TYPE)\n-\t/* Find the offset of the end of that field.  */\n-\tfilled = size_binop (CEIL_DIV_EXPR, constructor_bit_index,\n-\t\t\t     bitsize_unit_node);\n-\n-      else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n-\t{\n-\t  /* If initializing an array of unknown size,\n-\t     determine the size now.  */\n-\t  if (TREE_CODE (constructor_type) == ARRAY_TYPE\n-\t      && TYPE_DOMAIN (constructor_type) == 0)\n-\t    {\n-\t      tree maxindex\n-\t\t= copy_node (size_diffop (constructor_unfilled_index,\n-\t\t\t\t\t  bitsize_one_node));\n-\n-\t      TYPE_DOMAIN (constructor_type) = build_index_type (maxindex);\n-\t      TREE_TYPE (maxindex) = TYPE_DOMAIN (constructor_type);\n-\n-\t      /* TYPE_MAX_VALUE is always one less than the number of elements\n-\t\t in the array, because we start counting at zero.  Therefore,\n-\t\t warn only if the value is less than zero.  */\n-\t      if (pedantic\n-\t\t  && (tree_int_cst_sgn\n-\t\t      (TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type)))\n-\t\t      < 0))\n-\t\terror_with_decl (constructor_decl,\n-\t\t\t\t \"zero or negative array size `%s'\");\n-\n-\t      layout_type (constructor_type);\n-\t      size = int_size_in_bytes (constructor_type);\n-\t    }\n-\n-\t  filled\n-\t    = size_binop (MULT_EXPR, constructor_unfilled_index,\n-\t\t\t  convert (bitsizetype,\n-\t\t\t\t   TYPE_SIZE_UNIT\n-\t\t\t\t   (TREE_TYPE (constructor_type))));\n-\t}\n-      else\n-\tfilled = 0;\n-\n-      if (filled != 0)\n-\tassemble_zeros (size - tree_low_cst (filled, 1));\n-    }\n-\n-\t  \n   constructor_type = p->type;\n   constructor_fields = p->fields;\n   constructor_index = p->index;\n@@ -5564,7 +5382,6 @@ pop_init_level (implicit)\n   constructor_erroneous = p->erroneous;\n   constructor_pending_elts = p->pending_elts;\n   constructor_depth = p->depth;\n-  constructor_incremental = p->incremental;\n   RESTORE_SPELLING_DEPTH (constructor_depth);\n \n   constructor_stack = p->next;\n@@ -6002,45 +5819,13 @@ output_init_element (value, type, field, pending)\n \n       if (!duplicate)\n \t{\n-\t  if (! constructor_incremental)\n-\t    {\n-\t      if (field && TREE_CODE (field) == INTEGER_CST)\n-\t\tfield = copy_node (field);\n-\t      constructor_elements\n-\t\t= tree_cons (field, digest_init (type, value,\n-\t\t\t\t\t\t require_constant_value, \n-\t\t\t\t\t\t require_constant_elements),\n-\t\t\t     constructor_elements);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Structure elements may require alignment.\n-\t\t Do this, if necessary.  */\n-\t      if (TREE_CODE (constructor_type) == RECORD_TYPE\n-\t\t  && ! tree_int_cst_equal (constructor_bit_index,\n-\t\t\t\t\t   bit_position (field)))\n-\t\t/* Advance to offset of this element.  */\n-\t\tassemble_zeros\n-\t\t  (tree_low_cst\n-\t\t   (size_binop (TRUNC_DIV_EXPR,\n-\t\t\t\tsize_binop (MINUS_EXPR, bit_position (field),\n-\t\t\t\t\t    constructor_bit_index),\n-\t\t\t\tbitsize_unit_node),\n-\t\t    0));\n-\n-\t      output_constant (digest_init (type, value,\n-\t\t\t\t\t    require_constant_value,\n-\t\t\t\t\t    require_constant_elements),\n-\t\t\t       int_size_in_bytes (type));\n-\n-\t      /* For a record or union,\n-\t\t keep track of end position of last field.  */\n-\t      if (TREE_CODE (constructor_type) == RECORD_TYPE\n-\t\t  || TREE_CODE (constructor_type) == UNION_TYPE)\n-\t\tconstructor_bit_index\n-\t\t  = size_binop (PLUS_EXPR, bit_position (field),\n-\t\t\t\tDECL_SIZE (field));\n-\t    }\n+\t  if (field && TREE_CODE (field) == INTEGER_CST)\n+\t    field = copy_node (field);\n+\t  constructor_elements\n+\t    = tree_cons (field, digest_init (type, value,\n+\t\t\t\t\t     require_constant_value, \n+\t\t\t\t\t     require_constant_elements),\n+\t\t\t constructor_elements);\n \t}\n \n       /* Advance the variable that indicates sequential elements output.  */\n@@ -6196,66 +5981,13 @@ output_pending_init_elements (all)\n   if (! (all && next != 0))\n     return;\n \n-  /* Generate space up to the position of NEXT.  */\n-  if (constructor_incremental)\n-    {\n-      tree filled;\n-      tree nextpos_tree = bitsize_zero_node;\n-\n-      if (TREE_CODE (constructor_type) == RECORD_TYPE\n-\t  || TREE_CODE (constructor_type) == UNION_TYPE)\n-\t{\n-\t  tree tail;\n-\n-\t  /* Find the last field written out, if any.  */\n-\t  for (tail = TYPE_FIELDS (constructor_type); tail;\n-\t       tail = TREE_CHAIN (tail))\n-\t    if (TREE_CHAIN (tail) == constructor_unfilled_fields)\n-\t      break;\n-\n-\t  if (tail)\n-\t    /* Find the offset of the end of that field.  */\n-\t    filled = size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t size_binop (PLUS_EXPR, bit_position (tail),\n-\t\t\t\t\t     DECL_SIZE (tail)),\n-\t\t\t\t bitsize_unit_node);\n-\t  else\n-\t    filled = bitsize_zero_node;\n-\n-\t  nextpos_tree = convert (bitsizetype, byte_position (next));\n-\t  constructor_bit_index = bit_position (next);\n-\t  constructor_unfilled_fields = next;\n-\t}\n-      else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n-\t{\n-\t  filled\n-\t    = size_binop (MULT_EXPR, constructor_unfilled_index,\n-\t\t\t  convert (bitsizetype,\n-\t\t\t\t   TYPE_SIZE_UNIT\n-\t\t\t\t   (TREE_TYPE (constructor_type))));\n-\t  nextpos_tree\n-\t    = size_binop (MULT_EXPR, next,\n-\t\t\t  convert (bitsizetype, TYPE_SIZE_UNIT\n-\t\t\t\t   (TREE_TYPE (constructor_type))));\n-\t  constructor_unfilled_index = next;\n-\t}\n-      else\n-\tfilled = 0;\n-\n-      if (filled)\n-\tassemble_zeros (tree_low_cst (size_diffop (nextpos_tree, filled), 1));\n-    }\n-  else\n-    {\n-      /* If it's not incremental, just skip over the gap,\n-\t so that after jumping to retry we will output the next\n-\t successive element.  */\n-      if (TREE_CODE (constructor_type) == RECORD_TYPE\n-\t  || TREE_CODE (constructor_type) == UNION_TYPE)\n-\tconstructor_unfilled_fields = next;\n-      else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n-\tconstructor_unfilled_index = next;\n-    }\n+  /* If it's not incremental, just skip over the gap, so that after\n+     jumping to retry we will output the next successive element.  */\n+  if (TREE_CODE (constructor_type) == RECORD_TYPE\n+      || TREE_CODE (constructor_type) == UNION_TYPE)\n+    constructor_unfilled_fields = next;\n+  else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+    constructor_unfilled_index = next;\n \n   /* ELT now points to the node in the pending tree with the next\n      initializer to output.  */\n@@ -6268,13 +6000,7 @@ output_pending_init_elements (all)\n    to handle a partly-braced initializer.\n \n    Once this has found the correct level for the new element,\n-   it calls output_init_element.\n-\n-   Note: if we are incrementally outputting this constructor,\n-   this function may be called with a null argument\n-   representing a sub-constructor that was already incrementally output.\n-   When that happens, we output nothing, but we do the bookkeeping\n-   to skip past that element of the current constructor.  */\n+   it calls output_init_element.  */\n \n void\n process_init_element (value)"}, {"sha": "20f1e277b19a05403161f506d5ed4ff35e39fe58", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229a2e659eec385b9a2c74246d27d9615e23eda7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229a2e659eec385b9a2c74246d27d9615e23eda7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=229a2e659eec385b9a2c74246d27d9615e23eda7", "patch": "@@ -1,3 +1,8 @@\n+2000-10-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* gcc.dg/noncompile/init-2.c: Tweak to deal with multiple errors\n+\ton the same line.\n+\n 2000-10-27  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.old-deja/g++.other/eh2.C: New test."}, {"sha": "09916be79893948c02a5b688213bd015385469c2", "filename": "gcc/testsuite/gcc.dg/noncompile/init-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229a2e659eec385b9a2c74246d27d9615e23eda7/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Finit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229a2e659eec385b9a2c74246d27d9615e23eda7/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Finit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Finit-2.c?ref=229a2e659eec385b9a2c74246d27d9615e23eda7", "patch": "@@ -1 +1 @@\n-int d[][] = { {1}, {2}, {3} };\t/* { dg-error \"incomplete type\" } */\n+int d[][] = { {1}, {2}, {3} };\t/* { dg-error \"incomplete type|storage size|one element\" } */"}]}