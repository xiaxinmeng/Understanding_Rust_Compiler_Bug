{"sha": "9958c7eb586f40860546007fe0dc27165275c80d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk1OGM3ZWI1ODZmNDA4NjA1NDYwMDdmZTBkYzI3MTY1Mjc1YzgwZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2016-07-04T14:52:46Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2016-07-04T14:52:46Z"}, "message": "Fix std::vector's use of temporary objects\n\n\t* include/bits/stl_vector.h (emplace(const_iterator, _Args&&...)):\n\tDefine inline. Forward to _M_emplace_aux.\n\t(insert(const_iterator, value_type&&)): Forward to _M_insert_rval.\n\t(_M_insert_rval, _M_emplace_aux): Declare new functions.\n\t(_Temporary_value): New RAII type using allocator to construct/destroy.\n\t(_S_insert_aux_assign): Remove.\n\t(_M_insert_aux): Make non-variadic.\n\t* include/bits/vector.tcc (insert(const_iterator, const value_type&)):\n\tUse _Temporary_value.\n\t(emplace(const_iterator, _Args&&...)): Remove definition.\n\t(_M_insert_rval, _M_emplace_aux): Define.\n\t(_M_insert_aux): Make non-variadic, stop using _S_insert_aux_assign.\n\t(_M_fill_insert): Use _Temporary_value.\n\t* testsuite/23_containers/vector/allocator/construction.cc: New test.\n\t* testsuite/23_containers/vector/modifiers/insert_vs_emplace.cc:\n\tAdjust expected results for emplacing an lvalue with reallocation.\n\t* testsuite/23_containers/vector/check_construct_destroy.cc: Adjust\n\texpected results to account for construction/destruction of temporary\n\tusing allocator.\n\nFrom-SVN: r237985", "tree": {"sha": "4b2a3c27c66a41421f137be57c5d0b026e557dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b2a3c27c66a41421f137be57c5d0b026e557dea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9958c7eb586f40860546007fe0dc27165275c80d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9958c7eb586f40860546007fe0dc27165275c80d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9958c7eb586f40860546007fe0dc27165275c80d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9958c7eb586f40860546007fe0dc27165275c80d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf7499197fbb065123257c374064f6bb715c951b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf7499197fbb065123257c374064f6bb715c951b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf7499197fbb065123257c374064f6bb715c951b"}], "stats": {"total": 289, "additions": 242, "deletions": 47}, "files": [{"sha": "d10fc04363f8ba83f61f4d38090078165ce412c6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9958c7eb586f40860546007fe0dc27165275c80d", "patch": "@@ -1,3 +1,26 @@\n+2016-07-04  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/stl_vector.h (emplace(const_iterator, _Args&&...)):\n+\tDefine inline. Forward to _M_emplace_aux.\n+\t(insert(const_iterator, value_type&&)): Forward to _M_insert_rval.\n+\t(_M_insert_rval, _M_emplace_aux): Declare new functions.\n+\t(_Temporary_value): New RAII type using allocator to construct/destroy.\n+\t(_S_insert_aux_assign): Remove.\n+\t(_M_insert_aux): Make non-variadic.\n+\t* include/bits/vector.tcc (insert(const_iterator, const value_type&)):\n+\tUse _Temporary_value.\n+\t(emplace(const_iterator, _Args&&...)): Remove definition.\n+\t(_M_insert_rval, _M_emplace_aux): Define.\n+\t(_M_insert_aux): Make non-variadic, stop using _S_insert_aux_assign.\n+\t(_M_fill_insert): Use _Temporary_value.\n+\t* testsuite/23_containers/vector/allocator/construction.cc: New test.\n+\t* testsuite/23_containers/vector/modifiers/insert_vs_emplace.cc:\n+\tAdjust expected results for emplacing an lvalue with reallocation.\n+\t* testsuite/23_containers/vector/check_construct_destroy.cc: Adjust\n+\texpected results to account for construction/destruction of temporary\n+\tusing allocator.\n+\t* testsuite/backward/hash_set/check_construct_destroy.cc: Likewise.\n+\n 2016-07-04  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tPR libstdc++/71313"}, {"sha": "8e8aa7cf0d1d90e381ee40b5555902924b08d840", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=9958c7eb586f40860546007fe0dc27165275c80d", "patch": "@@ -995,7 +995,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       template<typename... _Args>\n \titerator\n-\templace(const_iterator __position, _Args&&... __args);\n+\templace(const_iterator __position, _Args&&... __args)\n+\t{ return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }\n \n       /**\n        *  @brief  Inserts given value into %vector before specified iterator.\n@@ -1040,7 +1041,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       iterator\n       insert(const_iterator __position, value_type&& __x)\n-      { return emplace(__position, std::move(__x)); }\n+      { return _M_insert_rval(__position, std::move(__x)); }\n \n       /**\n        *  @brief  Inserts an initializer_list into the %vector.\n@@ -1431,30 +1432,65 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_shrink_to_fit();\n #endif\n \n-      // Called by insert(p,x)\n #if __cplusplus < 201103L\n+      // Called by insert(p,x)\n       void\n       _M_insert_aux(iterator __position, const value_type& __x);\n #else\n-      template<typename... _Args>\n-\tstatic void\n-\t_S_insert_aux_assign(iterator __pos, _Args&&... __args)\n-\t{ *__pos =  _Tp(std::forward<_Args>(__args)...); }\n+      // A value_type object constructed with _Alloc_traits::construct()\n+      // and destroyed with _Alloc_traits::destroy().\n+      struct _Temporary_value\n+      {\n+\ttemplate<typename... _Args>\n+\t  explicit\n+\t  _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)\n+\t  {\n+\t    _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),\n+\t\t\t\t     std::forward<_Args>(__args)...);\n+\t  }\n \n-      static void\n-      _S_insert_aux_assign(iterator __pos, _Tp&& __arg)\n-      { *__pos = std::move(__arg); }\n+\t~_Temporary_value()\n+\t{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }\n \n-      template<typename... _Args>\n+\tvalue_type&\n+\t_M_val() { return *reinterpret_cast<_Tp*>(&__buf); }\n+\n+      private:\n+\tpointer\n+\t_M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }\n+\n+\tvector* _M_this;\n+\ttypename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;\n+      };\n+\n+      // Called by insert(p,x) and other functions when insertion needs to\n+      // reallocate or move existing elements. _Arg is either _Tp& or _Tp.\n+      template<typename _Arg>\n \tvoid\n-\t_M_insert_aux(iterator __position, _Args&&... __args);\n+\t_M_insert_aux(iterator __position, _Arg&& __arg);\n \n+      // Either move-construct at the end, or forward to _M_insert_aux.\n+      iterator\n+      _M_insert_rval(const_iterator __position, value_type&& __v);\n+\n+      // Called by push_back(x) and emplace_back(args) when they need to\n+      // reallocate.\n       template<typename... _Args>\n \tvoid\n \t_M_emplace_back_aux(_Args&&... __args);\n+\n+      // Try to emplace at the end, otherwise forward to _M_insert_aux.\n+      template<typename... _Args>\n+\titerator\n+\t_M_emplace_aux(const_iterator __position, _Args&&... __args);\n+\n+      // Emplacing an rvalue of the correct type can use _M_insert_rval.\n+      iterator\n+      _M_emplace_aux(const_iterator __position, value_type&& __v)\n+      { return _M_insert_rval(__position, std::move(__v)); }\n #endif\n \n-      // Called by the latter.\n+      // Called by _M_fill_insert, _M_insert_aux etc.\n       size_type\n       _M_check_len(size_type __n, const char* __s) const\n       {"}, {"sha": "dd0d288eaab82274a6df20751214179f1c5e4fbb", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 46, "deletions": 19, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=9958c7eb586f40860546007fe0dc27165275c80d", "patch": "@@ -124,8 +124,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  const auto __pos = begin() + (__position - cbegin());\n \t  if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n \t    {\n-\t      _Tp __x_copy = __x;\n-\t      _M_insert_aux(__pos, std::move(__x_copy));\n+\t      // __x could be an existing element of this vector, so make a\n+\t      // copy of it before _M_insert_aux moves elements around.\n+\t      _Temporary_value __x_copy(this, __x);\n+\t      _M_insert_aux(__pos, std::move(__x_copy._M_val()));\n \t    }\n \t  else\n \t    _M_insert_aux(__pos, __x);\n@@ -296,31 +298,50 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n #if __cplusplus >= 201103L\n+  template<typename _Tp, typename _Alloc>\n+    auto\n+    vector<_Tp, _Alloc>::\n+    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator\n+    {\n+      const auto __n = __position - cbegin();\n+      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage\n+\t  && __position == cend())\n+\t{\n+\t  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n+\t\t\t\t   std::move(__v));\n+\t  ++this->_M_impl._M_finish;\n+\t}\n+      else\n+\t_M_insert_aux(begin() + __n, std::move(__v));\n+      return iterator(this->_M_impl._M_start + __n);\n+    }\n+\n   template<typename _Tp, typename _Alloc>\n     template<typename... _Args>\n-      typename vector<_Tp, _Alloc>::iterator\n+      auto\n       vector<_Tp, _Alloc>::\n-      emplace(const_iterator __position, _Args&&... __args)\n+      _M_emplace_aux(const_iterator __position, _Args&&... __args)\n+      -> iterator\n       {\n-\tconst size_type __n = __position - begin();\n-\tif (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage\n-\t    && __position == end())\n+\tconst auto __n = __position - cbegin();\n+\tif (__position == cend())\n+\t  emplace_back(std::forward<_Args>(__args)...);\n+\telse\n \t  {\n-\t    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n-\t\t\t\t     std::forward<_Args>(__args)...);\n-\t    ++this->_M_impl._M_finish;\n+\t    // We need to construct a temporary because something in __args...\n+\t    // could alias one of the elements of the container and so we\n+\t    // need to use it before _M_insert_aux moves elements around.\n+\t    _Temporary_value __tmp(this, std::forward<_Args>(__args)...);\n+\t    _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));\n \t  }\n-\telse\n-\t  _M_insert_aux(begin() + (__position - cbegin()),\n-\t\t\tstd::forward<_Args>(__args)...);\n \treturn iterator(this->_M_impl._M_start + __n);\n       }\n \n   template<typename _Tp, typename _Alloc>\n-    template<typename... _Args>\n+    template<typename _Arg>\n       void\n       vector<_Tp, _Alloc>::\n-      _M_insert_aux(iterator __position, _Args&&... __args)\n+      _M_insert_aux(iterator __position, _Arg&& __arg)\n #else\n   template<typename _Tp, typename _Alloc>\n     void\n@@ -343,7 +364,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #if __cplusplus < 201103L\n \t  *__position = __x_copy;\n #else\n-\t  _S_insert_aux_assign(__position, std::forward<_Args>(__args)...);\n+\t  *__position = std::forward<_Arg>(__arg);\n #endif\n \t}\n       else\n@@ -355,14 +376,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  pointer __new_finish(__new_start);\n \t  __try\n \t    {\n-\t      // The order of the three operations is dictated by the C++0x\n+\t      // The order of the three operations is dictated by the C++11\n \t      // case, where the moves could alter a new element belonging\n \t      // to the existing vector.  This is an issue only for callers\n-\t      // taking the element by const lvalue ref (see 23.1/13).\n+\t      // taking the element by lvalue ref (see last bullet of C++11\n+\t      // [res.on.arguments]).\n \t      _Alloc_traits::construct(this->_M_impl,\n \t\t                       __new_start + __elems_before,\n #if __cplusplus >= 201103L\n-\t\t\t\t       std::forward<_Args>(__args)...);\n+\t\t\t\t       std::forward<_Arg>(__arg));\n #else\n \t                               __x);\n #endif\n@@ -455,7 +477,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  if (size_type(this->_M_impl._M_end_of_storage\n \t\t\t- this->_M_impl._M_finish) >= __n)\n \t    {\n+#if __cplusplus < 201103L\n \t      value_type __x_copy = __x;\n+#else\n+\t      _Temporary_value __tmp(this, __x);\n+\t      value_type& __x_copy = __tmp._M_val();\n+#endif\n \t      const size_type __elems_after = end() - __position;\n \t      pointer __old_finish(this->_M_impl._M_finish);\n \t      if (__elems_after > __n)"}, {"sha": "8040949c04c559c018f06a58df338d8b007d881b", "filename": "libstdc++-v3/testsuite/23_containers/vector/allocator/construction.cc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fconstruction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fconstruction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fconstruction.cc?ref=9958c7eb586f40860546007fe0dc27165275c80d", "patch": "@@ -0,0 +1,105 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+#include <vector>\n+\n+struct Tag { };\n+\n+template<typename T>\n+  struct TaggingAllocator\n+  {\n+    using value_type = T;\n+\n+    TaggingAllocator() = default;\n+\n+    template<typename U>\n+      TaggingAllocator(const TaggingAllocator<U>&) { }\n+\n+    T*\n+    allocate(std::size_t n) { return std::allocator<T>{}.allocate(n); }\n+\n+    void\n+    deallocate(T* p, std::size_t n) { std::allocator<T>{}.deallocate(p, n); }\n+\n+    template<typename U, typename... Args>\n+      void\n+      construct(U* p, Args&&... args)\n+      { ::new((void*)p) U(Tag{}, std::forward<Args>(args)...); }\n+\n+    template<typename U, typename... Args>\n+      void\n+      destroy(U* p)\n+      { p->~U(); }\n+  };\n+\n+template<typename T, typename U>\n+  bool\n+  operator==(const TaggingAllocator<T>&, const TaggingAllocator<U>&)\n+  { return true; }\n+\n+template<typename T, typename U>\n+  bool\n+  operator!=(const TaggingAllocator<T>&, const TaggingAllocator<U>&)\n+  { return false; }\n+\n+struct X\n+{\n+  // All constructors must be passed the Tag type.\n+\n+  // DefaultInsertable into vector<X, TaggingAllocator<X>>,\n+  X(Tag) { }\n+  // CopyInsertable into vector<X, TaggingAllocator<X>>,\n+  X(Tag, const X&) { }\n+  // MoveInsertable into vector<X, TaggingAllocator<X>>, and\n+  X(Tag, X&&) { }\n+\n+  // EmplaceConstructible into vector<X, TaggingAllocator<X>> from args.\n+  template<typename... Args>\n+    X(Tag, Args&&...) { }\n+\n+  // not DefaultConstructible, CopyConstructible or MoveConstructible.\n+  X() = delete;\n+  X(const X&) = delete;\n+  X(X&&) = delete;\n+\n+  // CopyAssignable.\n+  X& operator=(const X&) { return *this; }\n+\n+  // MoveAssignable.\n+  X& operator=(X&&) { return *this; }\n+\n+private:\n+  // Not Destructible.\n+  ~X() { }\n+\n+  // Erasable from vector<X, TaggingAllocator<X>>.\n+  friend class TaggingAllocator<X>;\n+};\n+\n+template class std::vector<X, TaggingAllocator<X>>;\n+\n+void test01()\n+{\n+  std::vector<X, TaggingAllocator<X>> v;\n+  v.reserve(3);\n+  v.emplace_back();\n+  v.emplace(v.begin());\n+  v.emplace(v.begin(), 1, 2, 3);\n+}"}, {"sha": "b92a1521aa258861679ca5c36258769582395625", "filename": "libstdc++-v3/testsuite/23_containers/vector/check_construct_destroy.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcheck_construct_destroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcheck_construct_destroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcheck_construct_destroy.cc?ref=9958c7eb586f40860546007fe0dc27165275c80d", "patch": "@@ -49,9 +49,9 @@ int main()\n     c.reserve(100);\n     tracker_allocator_counter::reset();\n     c.insert(c.begin(), arr10[0]);\n-    ok = check_construct_destroy(\"Insert element\", 1, 0) && ok;\n+    ok = check_construct_destroy(\"Insert element\", 2, 1) && ok;\n   }\n-  ok = check_construct_destroy(\"Insert element\", 1, 11) && ok;\n+  ok = check_construct_destroy(\"Insert element\", 2, 12) && ok;\n \n   {\n     Container c(arr10, arr10 + 10);"}, {"sha": "1b461240592c77fc0b3fef71e828abf2cfc53176", "filename": "libstdc++-v3/testsuite/23_containers/vector/modifiers/insert_vs_emplace.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Finsert_vs_emplace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Finsert_vs_emplace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Finsert_vs_emplace.cc?ref=9958c7eb586f40860546007fe0dc27165275c80d", "patch": "@@ -223,7 +223,8 @@ test03()\n void\n test04()\n {\n-  const X::special expected{ 0, 3, 1, 0, 3, 0 };\n+  const X::special expected_ins{ 0, 3, 1, 0, 3, 0 };\n+  const X::special expected_emp{ 0, 4, 1, 0, 4, 0 };\n   X::special ins, emp;\n   {\n     std::vector<X> v;\n@@ -253,8 +254,8 @@ test04()\n     // std::cout << \"----\\n\";\n     emp = X::sp;\n   }\n-  VERIFY( ins == emp );\n-  VERIFY( ins == expected );\n+  VERIFY( ins == expected_ins );\n+  VERIFY( emp == expected_emp );\n }\n \n // insert vs emplace xvalue reallocation"}, {"sha": "5740fe1bf8b15c54479c1b8a3da119775668dcff", "filename": "libstdc++-v3/testsuite/backward/hash_set/check_construct_destroy.cc", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2Fcheck_construct_destroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9958c7eb586f40860546007fe0dc27165275c80d/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2Fcheck_construct_destroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2Fcheck_construct_destroy.cc?ref=9958c7eb586f40860546007fe0dc27165275c80d", "patch": "@@ -39,45 +39,48 @@ int main()\n \n   int buckets;\n \n+  // Add 1 to all counts, because the std::vector used internally by the\n+  // hashtable creates and destroys a temporary object using the allocator.\n+\n   tracker_allocator_counter::reset();\n   {\n     Container c;\n     buckets = c.bucket_count();\n-    ok = check_construct_destroy(\"empty container\", buckets, 0) && ok;\n+    ok = check_construct_destroy(\"empty container\", buckets+1, 1) && ok;\n   }\n-  ok = check_construct_destroy(\"empty container\", buckets, buckets) && ok;\n+  ok = check_construct_destroy(\"empty container\", buckets+1, buckets+1) && ok;\n \n \n   tracker_allocator_counter::reset();\n   {\n     Container c(arr10, arr10 + 10);\n-    ok = check_construct_destroy(\"Construct from range\", buckets+10, 0) && ok;\n+    ok = check_construct_destroy(\"Construct from range\", buckets+10+1, 1) && ok;\n   }\n-  ok = check_construct_destroy(\"Construct from range\", buckets+10, buckets+10) && ok;\n+  ok = check_construct_destroy(\"Construct from range\", buckets+10+1, buckets+10+1) && ok;\n \n   tracker_allocator_counter::reset();\n   {\n     Container c(arr10, arr10 + 10);\n     c.insert(arr10a[0]);\n-    ok = check_construct_destroy(\"Insert element\", buckets+11, 0) && ok;\n+    ok = check_construct_destroy(\"Insert element\", buckets+11+1, 1) && ok;\n   }\n-  ok = check_construct_destroy(\"Insert element\", buckets+11, buckets+11) && ok;\n+  ok = check_construct_destroy(\"Insert element\", buckets+11+1, buckets+11+1) && ok;\n \n   tracker_allocator_counter::reset();\n   {\n     Container c(arr10, arr10 + 10);\n     c.insert(arr10a, arr10a+3);\n-    ok = check_construct_destroy(\"Insert short range\", buckets+13, 0) && ok;\n+    ok = check_construct_destroy(\"Insert short range\", buckets+13+1, 1) && ok;\n   }\n-  ok = check_construct_destroy(\"Insert short range\", buckets+13, buckets+13) && ok;\n+  ok = check_construct_destroy(\"Insert short range\", buckets+13+1, buckets+13+1) && ok;\n \n   tracker_allocator_counter::reset();\n   {\n     Container c(arr10, arr10 + 10);\n     c.insert(arr10a, arr10a+10);\n-    ok = check_construct_destroy(\"Insert long range\", buckets+20, 0) && ok;\n+    ok = check_construct_destroy(\"Insert long range\", buckets+20+1, 1) && ok;\n   }\n-  ok = check_construct_destroy(\"Insert long range\", buckets+20, buckets+20) && ok;\n+  ok = check_construct_destroy(\"Insert long range\", buckets+20+1, buckets+20+1) && ok;\n \n   return ok ? 0 : 1;\n }"}]}