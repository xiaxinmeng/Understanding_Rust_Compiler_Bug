{"sha": "1951a1b6ec34409492b954768578eb6d94b8a784", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk1MWExYjZlYzM0NDA5NDkyYjk1NDc2ODU3OGViNmQ5NGI4YTc4NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-04-12T14:15:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-04-12T14:15:48Z"}, "message": "cp-tree.h (TYPE_LINKAGE_IDENTIFIER): New macro.\n\n        * cp-tree.h (TYPE_LINKAGE_IDENTIFIER): New macro.\n        (TYPE_ANONYMOUS_P): New macro.\n        (TAGGED_TYPE_P): New macro.\n        * decl.c (check_tag_decl): Use TYPE_ANONYMOUS_P.\n        (grokfndecl, grokvardecl, grokdeclarator): Likewise.\n        * tree.c (no_linkage_helper): Likewise.\n        * semantics.c (begin_class_definition): Likewise.\n        * pt.c (convert_template_argument): Likewise.\n        * lex.c (check_for_missing_semicolon): Likewise.\n\nFrom-SVN: r41303", "tree": {"sha": "2f075aa812cbe41c0cdc490bd611f2c2b21d8a28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f075aa812cbe41c0cdc490bd611f2c2b21d8a28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1951a1b6ec34409492b954768578eb6d94b8a784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1951a1b6ec34409492b954768578eb6d94b8a784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1951a1b6ec34409492b954768578eb6d94b8a784", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1951a1b6ec34409492b954768578eb6d94b8a784/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d93aa33514f7b0ccf084c7284802f079d41ea061", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d93aa33514f7b0ccf084c7284802f079d41ea061", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d93aa33514f7b0ccf084c7284802f079d41ea061"}], "stats": {"total": 87, "additions": 53, "deletions": 34}, "files": [{"sha": "c26c7f55e0eb35ff42c8caf9ed6c8fdf0485c252", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1951a1b6ec34409492b954768578eb6d94b8a784", "patch": "@@ -1,3 +1,15 @@\n+2001-04-11  Jason Merrill  <jason_merrill@redhat.com>\n+\n+\t* cp-tree.h (TYPE_LINKAGE_IDENTIFIER): New macro.\n+\t(TYPE_ANONYMOUS_P): New macro.\n+\t(TAGGED_TYPE_P): New macro.\n+\t* decl.c (check_tag_decl): Use TYPE_ANONYMOUS_P.\n+\t(grokfndecl, grokvardecl, grokdeclarator): Likewise.\n+\t* tree.c (no_linkage_helper): Likewise.\n+\t* semantics.c (begin_class_definition): Likewise.\n+\t* pt.c (convert_template_argument): Likewise.\n+\t* lex.c (check_for_missing_semicolon): Likewise.\n+\n 2001-04-12  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* class.c (dfs_unshared_virtual_bases): New function."}, {"sha": "5a8a3ba06dbdd6448a3b8df2b9b79b6a64ee5434", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1951a1b6ec34409492b954768578eb6d94b8a784", "patch": "@@ -1163,12 +1163,18 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n \n /* Macros to make error reporting functions' lives easier.  */\n #define TYPE_IDENTIFIER(NODE) (DECL_NAME (TYPE_NAME (NODE)))\n+#define TYPE_LINKAGE_IDENTIFIER(NODE) \\\n+  (TYPE_IDENTIFIER (TYPE_MAIN_VARIANT (NODE)))\n #define TYPE_NAME_STRING(NODE) (IDENTIFIER_POINTER (TYPE_IDENTIFIER (NODE)))\n #define TYPE_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (TYPE_IDENTIFIER (NODE)))\n \n #define TYPE_ASSEMBLER_NAME_STRING(NODE) (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME  (NODE))))\n #define TYPE_ASSEMBLER_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (TYPE_NAME (NODE))))\n \n+/* Nonzero if NODE has no name for linkage purposes.  */\n+#define TYPE_ANONYMOUS_P(NODE) \\\n+  (TAGGED_TYPE_P (NODE) && ANON_AGGRNAME_P (TYPE_LINKAGE_IDENTIFIER (NODE)))\n+\n /* The _DECL for this _TYPE.  */\n #define TYPE_MAIN_DECL(NODE) (TYPE_STUB_DECL (TYPE_MAIN_VARIANT (NODE)))\n \n@@ -1198,8 +1204,9 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n #define IS_AGGR_TYPE_2(TYPE1,TYPE2) \\\n   (TREE_CODE (TYPE1) == TREE_CODE (TYPE2)\t\\\n    && IS_AGGR_TYPE (TYPE1) && IS_AGGR_TYPE (TYPE2))\n-#define IS_OVERLOAD_TYPE(t) \\\n-  (IS_AGGR_TYPE (t) || TREE_CODE (t) == ENUMERAL_TYPE)\n+#define TAGGED_TYPE_P(t) \\\n+  (CLASS_TYPE_P (t) || TREE_CODE (t) == ENUMERAL_TYPE)\n+#define IS_OVERLOAD_TYPE(T) TAGGED_TYPE_P (T)\n \n /* In a *_TYPE, nonzero means a built-in type.  */\n #define TYPE_BUILT_IN(NODE) TYPE_LANG_FLAG_6(NODE)"}, {"sha": "0e97ad1fc1bfe3aae9b5bdeca6d2c07e1cebd69c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1951a1b6ec34409492b954768578eb6d94b8a784", "patch": "@@ -2873,6 +2873,7 @@ pushtag (name, type, globalize)\n \t  else\n \t    d = pushdecl_with_scope (d, b);\n \n+\t  /* FIXME what if it gets a name from typedef?  */\n \t  if (ANON_AGGRNAME_P (name))\n \t    DECL_IGNORED_P (d) = 1;\n \n@@ -6972,12 +6973,9 @@ check_tag_decl (declspecs)\n   if (t == NULL_TREE && ! saw_friend)\n     pedwarn (\"declaration does not declare anything\");\n \n-  /* Check for an anonymous union.  We're careful\n-     accessing TYPE_IDENTIFIER because some built-in types, like\n-     pointer-to-member types, do not have TYPE_NAME.  */\n+  /* Check for an anonymous union.  */\n   else if (t && IS_AGGR_TYPE_CODE (TREE_CODE (t))\n-\t   && TYPE_NAME (t)\n-\t   && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t   && TYPE_ANONYMOUS_P (t))\n     {\n       /* 7/3 In a simple-declaration, the optional init-declarator-list\n          can be omitted only when declaring a class (clause 9) or\n@@ -8733,17 +8731,11 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n      int check, friendp, publicp, inlinep, funcdef_flag, template_count;\n      tree in_namespace;\n {\n-  tree cname, decl;\n+  tree decl;\n   int staticp = ctype && TREE_CODE (type) == FUNCTION_TYPE;\n   int has_default_arg = 0;\n   tree t;\n \n-  if (ctype)\n-    cname = TREE_CODE (TYPE_NAME (ctype)) == TYPE_DECL\n-      ? TYPE_IDENTIFIER (ctype) : TYPE_NAME (ctype);\n-  else\n-    cname = NULL_TREE;\n-\n   if (raises)\n     {\n       type = build_exception_variant (type, raises);\n@@ -8799,7 +8791,8 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \n   /* Members of anonymous types and local classes have no linkage; make\n      them internal.  */\n-  if (ctype && (ANON_AGGRNAME_P (TYPE_IDENTIFIER (ctype))\n+  /* FIXME what if it gets a name from typedef?  */\n+  if (ctype && (TYPE_ANONYMOUS_P (ctype)\n \t\t|| decl_function_context (TYPE_MAIN_DECL (ctype))))\n     publicp = 0;\n \n@@ -8813,13 +8806,19 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n       t = no_linkage_check (TREE_TYPE (decl));\n       if (t)\n \t{\n-\t  if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t  if (TYPE_ANONYMOUS_P (t))\n \t    {\n \t      if (DECL_EXTERN_C_P (decl))\n \t\t/* Allow this; it's pretty common in C.  */;\n \t      else\n-\t\tcp_pedwarn (\"non-local function `%#D' uses anonymous type\",\n-\t\t\t    decl);\n+\t\t{\n+\t\t  cp_pedwarn (\"non-local function `%#D' uses anonymous type\",\n+\t\t\t      decl);\n+\t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n+\t\t    cp_pedwarn_at (\"\\\n+`%#D' does not refer to the unqualified type, so it is not used for linkage\",\n+\t\t\t\tTYPE_NAME (t));\n+\t\t}\n \t    }\n \t  else\n \t    cp_pedwarn (\"non-local function `%#D' uses local type `%T'\",\n@@ -8931,7 +8930,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n   if (check < 0)\n     return decl;\n \n-  if (flags == NO_SPECIAL && ctype && constructor_name (cname) == declarator)\n+  if (flags == NO_SPECIAL && ctype && constructor_name (ctype) == declarator)\n     DECL_CONSTRUCTOR_P (decl) = 1;\n \n   /* Function gets the ugly name, field gets the nice one.  This call\n@@ -9095,7 +9094,7 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n       tree t = no_linkage_check (TREE_TYPE (decl));\n       if (t)\n \t{\n-\t  if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t  if (TYPE_ANONYMOUS_P (t))\n \t    /* Ignore for now; `enum { foo } e' is pretty common.  */;\n \t  else\n \t    cp_pedwarn (\"non-local variable `%#D' uses local type `%T'\",\n@@ -11037,7 +11036,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  && declarator\n \t  && TYPE_NAME (type)\n \t  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t  && ANON_AGGRNAME_P (TYPE_IDENTIFIER (type))\n+\t  && TYPE_ANONYMOUS_P (type)\n \t  && CP_TYPE_QUALS (type) == TYPE_UNQUALIFIED)\n \t{\n \t  tree oldname = TYPE_NAME (type);"}, {"sha": "5120f204ed3605bde54e6f0cab4553115d7f1607", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=1951a1b6ec34409492b954768578eb6d94b8a784", "patch": "@@ -1011,7 +1011,7 @@ check_for_missing_semicolon (type)\n        && yychar != SELFNAME)\n       || yychar == 0  /* EOF */)\n     {\n-      if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (type)))\n+      if (TYPE_ANONYMOUS_P (type))\n \terror (\"semicolon missing after %s declaration\",\n \t       TREE_CODE (type) == ENUMERAL_TYPE ? \"enum\" : \"struct\");\n       else"}, {"sha": "ac88beca8049e430f3679e42226c0d06aad7c47b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1951a1b6ec34409492b954768578eb6d94b8a784", "patch": "@@ -3389,7 +3389,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \t      tree t = no_linkage_check (val);\n \t      if (t)\n \t\t{\n-\t\t  if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t\t  if (TYPE_ANONYMOUS_P (t))\n \t\t    cp_pedwarn\n \t\t      (\"template-argument `%T' uses anonymous type\", val);\n \t\t  else"}, {"sha": "a6e13ec0f7876f25c5ce746a8402d7aeea4cb745", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1951a1b6ec34409492b954768578eb6d94b8a784", "patch": "@@ -1860,16 +1860,12 @@ begin_class_definition (t)\n   /* Reset the interface data, at the earliest possible\n      moment, as it might have been set via a class foo;\n      before.  */\n-  {\n-    tree name = TYPE_IDENTIFIER (t);\n-    \n-    if (! ANON_AGGRNAME_P (name))\n-      {\n-\tCLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n-\tSET_CLASSTYPE_INTERFACE_UNKNOWN_X\n-\t  (t, interface_unknown);\n-      }\n-  }\n+  if (! TYPE_ANONYMOUS_P (t))\n+    {\n+      CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n+      SET_CLASSTYPE_INTERFACE_UNKNOWN_X\n+\t(t, interface_unknown);\n+    }\n   reset_specialization();\n   \n   /* Make a declaration for this class in its own scope.  */"}, {"sha": "09aa0cde2e37ca76ef1ef6a2069fac90ba2c09a4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=1951a1b6ec34409492b954768578eb6d94b8a784", "patch": "@@ -1502,7 +1502,7 @@ no_linkage_helper (tp, walk_subtrees, data)\n   if (TYPE_P (t)\n       && (CLASS_TYPE_P (t) || TREE_CODE (t) == ENUMERAL_TYPE)\n       && (decl_function_context (TYPE_MAIN_DECL (t))\n-\t  || ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))))\n+\t  || TYPE_ANONYMOUS_P (t)))\n     return t;\n   return NULL_TREE;\n }"}, {"sha": "45c326bc716538221c711104107b69aa942b2e7b", "filename": "gcc/testsuite/g++.old-deja/g++.other/anon9.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1951a1b6ec34409492b954768578eb6d94b8a784/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon9.C?ref=1951a1b6ec34409492b954768578eb6d94b8a784", "patch": "@@ -0,0 +1,5 @@\n+// Test that we properly diagnose an attempt to use an anonymous class\n+// in declaring an external function.\n+\n+typedef const struct { int i; } T; // ERROR - referenced below\n+void f (T* t);\t\t\t// ERROR - uses unnamed type"}]}