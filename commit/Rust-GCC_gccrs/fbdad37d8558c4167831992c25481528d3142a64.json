{"sha": "fbdad37d8558c4167831992c25481528d3142a64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJkYWQzN2Q4NTU4YzQxNjc4MzE5OTJjMjU0ODE1MjhkMzE0MmE2NA==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-10-06T15:29:25Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-10-06T15:29:25Z"}, "message": "trans-stmt.c (gfc_trans_simple_do): New function.\n\n\t* trans-stmt.c (gfc_trans_simple_do): New function.\n\t(gfc_trans_do): Use it.  Evaluate iteration bounds before entering\n\tloop.  Update comments.\ntestsuite/\n\t* gfortran.dg/do_1.f90: New test.\n\nFrom-SVN: r88607", "tree": {"sha": "3ea97b8b954f9adbe82f28bd9a8d096d783e69d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ea97b8b954f9adbe82f28bd9a8d096d783e69d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbdad37d8558c4167831992c25481528d3142a64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdad37d8558c4167831992c25481528d3142a64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbdad37d8558c4167831992c25481528d3142a64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdad37d8558c4167831992c25481528d3142a64/comments", "author": null, "committer": null, "parents": [{"sha": "5a6aa19c251223f21394b015c49e79d218f26181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a6aa19c251223f21394b015c49e79d218f26181", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a6aa19c251223f21394b015c49e79d218f26181"}], "stats": {"total": 242, "additions": 214, "deletions": 28}, "files": [{"sha": "3147b28a2c7599b2eb4a48fa9e4d59d59218145b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdad37d8558c4167831992c25481528d3142a64/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdad37d8558c4167831992c25481528d3142a64/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fbdad37d8558c4167831992c25481528d3142a64", "patch": "@@ -1,3 +1,9 @@\n+2004-10-06  Paul Brook  <paul@codesourcery.com>\n+\n+\t* trans-stmt.c (gfc_trans_simple_do): New function.\n+\t(gfc_trans_do): Use it.  Evaluate iteration bounds before entering\n+\tloop.  Update comments.\n+\n 2004-10-04  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/17283"}, {"sha": "58bb1a1df6c74864f49ddd68aa41004b928c1611", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 124, "deletions": 28, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdad37d8558c4167831992c25481528d3142a64/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdad37d8558c4167831992c25481528d3142a64/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=fbdad37d8558c4167831992c25481528d3142a64", "patch": "@@ -485,13 +485,113 @@ gfc_trans_arithmetic_if (gfc_code * code)\n }\n \n \n+/* Translate the simple DO construct.  This is where the loop varable has\n+   integer type and step +-1.  We can't use this in the general case\n+   because integer overflow and floating point errors could give incorrect\n+   results.\n+   We translate a do loop from:\n+\n+   DO dovar = from, to, step\n+      body\n+   END DO\n+\n+   to:\n+\n+   [Evaluate loop bounds and step]\n+   dovar = from;\n+   if ((step > 0) ? (dovar <= to) : (dovar => to))\n+    {\n+      for (;;)\n+        {\n+\t  body;\n+   cycle_label:\n+\t  cond = (dovar == to);\n+\t  dovar += step;\n+\t  if (cond) goto end_label;\n+\t}\n+      }\n+   end_label:\n+\n+   This helps the optimizers by avoiding the extra induction variable\n+   used in the general case.  */\n+\n+static tree\n+gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n+\t\t     tree from, tree to, tree step)\n+{\n+  stmtblock_t body;\n+  tree type;\n+  tree cond;\n+  tree tmp;\n+  tree cycle_label;\n+  tree exit_label;\n+  \n+  type = TREE_TYPE (dovar);\n+\n+  /* Initialize the DO variable: dovar = from.  */\n+  gfc_add_modify_expr (pblock, dovar, from);\n+\n+  /* Cycle and exit statements are implemented with gotos.  */\n+  cycle_label = gfc_build_label_decl (NULL_TREE);\n+  exit_label = gfc_build_label_decl (NULL_TREE);\n+\n+  /* Put the labels where they can be found later. See gfc_trans_do().  */\n+  code->block->backend_decl = tree_cons (cycle_label, exit_label, NULL);\n+\n+  /* Loop body.  */\n+  gfc_start_block (&body);\n+\n+  /* Main loop body.  */\n+  tmp = gfc_trans_code (code->block->next);\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  /* Label for cycle statements (if needed).  */\n+  if (TREE_USED (cycle_label))\n+    {\n+      tmp = build1_v (LABEL_EXPR, cycle_label);\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n+  /* Evaluate the loop condition.  */\n+  cond = build2 (EQ_EXPR, boolean_type_node, dovar, to);\n+  cond = gfc_evaluate_now (cond, &body);\n+\n+  /* Increment the loop variable.  */\n+  tmp = build2 (PLUS_EXPR, type, dovar, step);\n+  gfc_add_modify_expr (&body, dovar, tmp);\n+\n+  /* The loop exit.  */\n+  tmp = build1_v (GOTO_EXPR, exit_label);\n+  TREE_USED (exit_label) = 1;\n+  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  /* Finish the loop body.  */\n+  tmp = gfc_finish_block (&body);\n+  tmp = build1_v (LOOP_EXPR, tmp);\n+\n+  /* Only execute the loop if the number of iterations is positive.  */\n+  if (tree_int_cst_sgn (step) > 0)\n+    cond = fold (build2 (LE_EXPR, boolean_type_node, dovar, to));\n+  else\n+    cond = fold (build2 (GE_EXPR, boolean_type_node, dovar, to));\n+  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+  gfc_add_expr_to_block (pblock, tmp);\n+\n+  /* Add the exit label.  */\n+  tmp = build1_v (LABEL_EXPR, exit_label);\n+  gfc_add_expr_to_block (pblock, tmp);\n+\n+  return gfc_finish_block (pblock);\n+}\n+\n /* Translate the DO construct.  This obviously is one of the most\n    important ones to get right with any compiler, but especially\n    so for Fortran.\n \n-   Currently we calculate the loop count before entering the loop, but\n-   it may be possible to optimize if step is a constant. The main\n-   advantage is that the loop test is a single GENERIC node\n+   We special case some loop forms as described in gfc_trans_simple_do.\n+   For other cases we implement them with a separate loop count,\n+   as described in the standard.\n \n    We translate a do loop from:\n \n@@ -501,30 +601,24 @@ gfc_trans_arithmetic_if (gfc_code * code)\n \n    to:\n \n-   pre_dovar;\n-   pre_from;\n-   pre_to;\n-   pre_step;\n-   temp1=to_expr-from_expr;\n-   step_temp=step_expr;\n-   range_temp=step_tmp/range_temp;\n-   for ( ; range_temp > 0 ; range_temp = range_temp - 1)\n+   [evaluate loop bounds and step]\n+   count = to + step - from;\n+   dovar = from;\n+   for (;;)\n      {\n        body;\n cycle_label:\n-       dovar_temp = dovar\n-       dovar=dovar_temp + step_temp;\n+       dovar += step\n+       count--;\n+       if (count <=0) goto exit_label;\n      }\n exit_label:\n \n-   Some optimization is done for empty do loops. We can't just let\n-   dovar=to because it's possible for from+range*loopcount!=to.  Anyone\n-   who writes empty DO deserves sub-optimal (but correct) code anyway.\n-\n    TODO: Large loop counts\n-   Does not work loop counts which do not fit into a signed integer kind,\n+   The code above assumes the loop count fits into a signed integer kind,\n    i.e. Does not work for loop counts > 2^31 for integer(kind=4) variables\n-   We must support the full range.  */\n+   We must support the full range.\n+   TODO: Real type do variables.  */\n \n tree\n gfc_trans_do (gfc_code * code)\n@@ -545,8 +639,7 @@ gfc_trans_do (gfc_code * code)\n \n   gfc_start_block (&block);\n \n-  /* Create GIMPLE versions of all expressions in the iterator.  */\n-\n+  /* Evaluate all the expressions in the iterator.  */\n   gfc_init_se (&se, NULL);\n   gfc_conv_expr_lhs (&se, code->ext.iterator->var);\n   gfc_add_block_to_block (&block, &se.pre);\n@@ -556,21 +649,24 @@ gfc_trans_do (gfc_code * code)\n   gfc_init_se (&se, NULL);\n   gfc_conv_expr_type (&se, code->ext.iterator->start, type);\n   gfc_add_block_to_block (&block, &se.pre);\n-  from = se.expr;\n+  from = gfc_evaluate_now (se.expr, &block);\n \n   gfc_init_se (&se, NULL);\n   gfc_conv_expr_type (&se, code->ext.iterator->end, type);\n   gfc_add_block_to_block (&block, &se.pre);\n-  to = se.expr;\n+  to = gfc_evaluate_now (se.expr, &block);\n \n   gfc_init_se (&se, NULL);\n   gfc_conv_expr_type (&se, code->ext.iterator->step, type);\n-\n-  /* We don't want this changing part way through.  */\n-  gfc_make_safe_expr (&se);\n   gfc_add_block_to_block (&block, &se.pre);\n-  step = se.expr;\n-\n+  step = gfc_evaluate_now (se.expr, &block);\n+\n+  /* Special case simple loops.  */\n+  if (TREE_CODE (type) == INTEGER_TYPE\n+      && (integer_onep (step)\n+\t|| tree_int_cst_equal (step, integer_minus_one_node)))\n+    return gfc_trans_simple_do (code, &block, dovar, from, to, step);\n+      \n   /* Initialize loop count. This code is executed before we enter the\n      loop body. We generate: count = (to + step - from) / step.  */\n "}, {"sha": "2896509f758a45650deddd58af6d0e99381d30b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdad37d8558c4167831992c25481528d3142a64/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdad37d8558c4167831992c25481528d3142a64/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fbdad37d8558c4167831992c25481528d3142a64", "patch": "@@ -1,3 +1,7 @@\n+2004-10-06  Paul Brook  <paul@codesourcery.com>\n+\n+\t* gfortran.dg/do_1.f90: New test.\n+\n 2004-10-06  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.c-torture/execute/builtins/lib/strcpy.c: Don't abort when"}, {"sha": "20e1f31ca674c2820e917c17f86ee19b778aebdb", "filename": "gcc/testsuite/gfortran.dg/do_1.f90", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdad37d8558c4167831992c25481528d3142a64/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdad37d8558c4167831992c25481528d3142a64/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_1.f90?ref=fbdad37d8558c4167831992c25481528d3142a64", "patch": "@@ -0,0 +1,80 @@\n+! { dg-do run }\n+! Program to check corner cases for DO statements.\n+program do_1\n+  implicit none\n+  integer i, j\n+\n+  ! limit=HUGE(i), step 1\n+  j = 0\n+  do i = HUGE(i) - 10, HUGE(i), 1\n+    j = j + 1\n+  end do\n+  if (j .ne. 11) call abort\n+  ! limit=HUGE(i), step > 1\n+  j = 0\n+  do i = HUGE(i) - 10, HUGE(i), 2\n+    j = j + 1\n+  end do\n+  if (j .ne. 6) call abort\n+  j = 0\n+  do i = HUGE(i) - 9, HUGE(i), 2\n+    j = j + 1\n+  end do\n+  if (j .ne. 5) call abort\n+\n+  ! Same again, but unknown loop step\n+  if (test1(10, 1) .ne. 11) call abort\n+  if (test1(10, 2) .ne. 6) call abort\n+  if (test1(9, 2) .ne. 5) call abort\n+\n+  ! Zero iterations\n+  j = 0\n+  do i = 1, 0, 1\n+    j = j + 1\n+  end do\n+  if (j .ne. 0) call abort\n+  j = 0\n+  do i = 1, 0, 2\n+    j = j + 1\n+  end do\n+  if (j .ne. 0) call abort\n+  j = 0\n+  do i = 1, 2, -1\n+    j = j + 1\n+  end do\n+  if (j .ne. 0) call abort\n+  call test2 (0, 1)\n+  call test2 (0, 2)\n+  call test2 (2, -1)\n+  call test2 (2, -2)\n+\n+  ! Bound near smallest value\n+  j = 0;\n+  do i = -HUGE(i), -HUGE(i), 10\n+    j = j + 1\n+  end do\n+  if (j .ne. 1) call abort\n+contains\n+! Returns the number of iterations performed.\n+function test1(r, step)\n+  implicit none\n+  integer test1, r, step\n+  integer k, n\n+  k = 0\n+  do n = HUGE(n) - r, HUGE(n), step\n+    k = k + 1\n+  end do\n+  test1 = k\n+end function\n+\n+subroutine test2 (lim, step)\n+  implicit none\n+  integer lim, step\n+  integer k, n\n+  k = 0\n+  do n = 1, lim, step\n+    k = k + 1\n+  end do\n+  if (k .ne. 0) call abort\n+end subroutine\n+end program"}]}