{"sha": "646e47bcd15483fcafcc695efefd7a0ddeb4c716", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ2ZTQ3YmNkMTU0ODNmY2FmY2M2OTVlZmVmZDdhMGRkZWI0YzcxNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:50:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:50:13Z"}, "message": "Extra subreg fold for variable-length CONST_VECTORs\n\nThe SVE support for the new CONST_VECTOR encoding needs to be able\nto extract the first N bits of the vector and duplicate it.  This patch\nadds a simplify_subreg rule for that.\n\nThe code is covered by the gcc.target/aarch64/sve_slp_*.c tests.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* simplify-rtx.c (simplify_immed_subreg): Add an inner_bytes\n\tparameter and use it instead of GET_MODE_SIZE (innermode).  Use\n\tinner_bytes * BITS_PER_UNIT instead of GET_MODE_BITSIZE (innermode).\n\tUse CEIL (inner_bytes, GET_MODE_UNIT_SIZE (innermode)) instead of\n\tGET_MODE_NUNITS (innermode).  Also add a first_elem parameter.\n\tChange innermode from fixed_mode_size to machine_mode.\n\t(simplify_subreg): Update call accordingly.  Handle a constant-sized\n\tsubreg of a variable-length CONST_VECTOR.\n\nFrom-SVN: r256610", "tree": {"sha": "24aedf96f7279bcfe8e5ea3de20792e7d0f722dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24aedf96f7279bcfe8e5ea3de20792e7d0f722dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/646e47bcd15483fcafcc695efefd7a0ddeb4c716", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646e47bcd15483fcafcc695efefd7a0ddeb4c716", "html_url": "https://github.com/Rust-GCC/gccrs/commit/646e47bcd15483fcafcc695efefd7a0ddeb4c716", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646e47bcd15483fcafcc695efefd7a0ddeb4c716/comments", "author": null, "committer": null, "parents": [{"sha": "729f495ad78e2596d166707444941b382dbfc29a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729f495ad78e2596d166707444941b382dbfc29a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/729f495ad78e2596d166707444941b382dbfc29a"}], "stats": {"total": 46, "additions": 35, "deletions": 11}, "files": [{"sha": "3f1919e774f78e8c82ee32af6176bbca2dd5f70d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/646e47bcd15483fcafcc695efefd7a0ddeb4c716/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/646e47bcd15483fcafcc695efefd7a0ddeb4c716/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=646e47bcd15483fcafcc695efefd7a0ddeb4c716", "patch": "@@ -1,3 +1,14 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* simplify-rtx.c (simplify_immed_subreg): Add an inner_bytes\n+\tparameter and use it instead of GET_MODE_SIZE (innermode).  Use\n+\tinner_bytes * BITS_PER_UNIT instead of GET_MODE_BITSIZE (innermode).\n+\tUse CEIL (inner_bytes, GET_MODE_UNIT_SIZE (innermode)) instead of\n+\tGET_MODE_NUNITS (innermode).  Also add a first_elem parameter.\n+\tChange innermode from fixed_mode_size to machine_mode.\n+\t(simplify_subreg): Update call accordingly.  Handle a constant-sized\n+\tsubreg of a variable-length CONST_VECTOR.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "b0a0178310141eb67ca431e67cc914eae2d12893", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/646e47bcd15483fcafcc695efefd7a0ddeb4c716/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/646e47bcd15483fcafcc695efefd7a0ddeb4c716/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=646e47bcd15483fcafcc695efefd7a0ddeb4c716", "patch": "@@ -5924,13 +5924,16 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n    or CONST_FIXED or CONST_VECTOR, returning another CONST_INT or\n    CONST_WIDE_INT or CONST_DOUBLE or CONST_FIXED or CONST_VECTOR.\n \n-   Works by unpacking OP into a collection of 8-bit values\n+   Works by unpacking INNER_BYTES bytes of OP into a collection of 8-bit values\n    represented as a little-endian array of 'unsigned char', selecting by BYTE,\n-   and then repacking them again for OUTERMODE.  */\n+   and then repacking them again for OUTERMODE.  If OP is a CONST_VECTOR,\n+   FIRST_ELEM is the number of the first element to extract, otherwise\n+   FIRST_ELEM is ignored.  */\n \n static rtx\n simplify_immed_subreg (fixed_size_mode outermode, rtx op,\n-\t\t       fixed_size_mode innermode, unsigned int byte)\n+\t\t       machine_mode innermode, unsigned int byte,\n+\t\t       unsigned int first_elem, unsigned int inner_bytes)\n {\n   enum {\n     value_bit = 8,\n@@ -5960,13 +5963,13 @@ simplify_immed_subreg (fixed_size_mode outermode, rtx op,\n \n   /* We support any size mode.  */\n   max_bitsize = MAX (GET_MODE_BITSIZE (outermode),\n-\t\t     GET_MODE_BITSIZE (innermode));\n+\t\t     inner_bytes * BITS_PER_UNIT);\n \n   /* Unpack the value.  */\n \n   if (GET_CODE (op) == CONST_VECTOR)\n     {\n-      num_elem = GET_MODE_NUNITS (innermode);\n+      num_elem = CEIL (inner_bytes, GET_MODE_UNIT_SIZE (innermode));\n       elem_bitsize = GET_MODE_UNIT_BITSIZE (innermode);\n     }\n   else\n@@ -5983,7 +5986,7 @@ simplify_immed_subreg (fixed_size_mode outermode, rtx op,\n     {\n       unsigned char * vp;\n       rtx el = (GET_CODE (op) == CONST_VECTOR\n-\t\t? CONST_VECTOR_ELT (op, elem)\n+\t\t? CONST_VECTOR_ELT (op, first_elem + elem)\n \t\t: op);\n \n       /* Vectors are kept in target memory order.  (This is probably\n@@ -6110,10 +6113,9 @@ simplify_immed_subreg (fixed_size_mode outermode, rtx op,\n   /* Renumber BYTE so that the least-significant byte is byte 0.  A special\n      case is paradoxical SUBREGs, which shouldn't be adjusted since they\n      will already have offset 0.  */\n-  if (GET_MODE_SIZE (innermode) >= GET_MODE_SIZE (outermode))\n+  if (inner_bytes >= GET_MODE_SIZE (outermode))\n     {\n-      unsigned ibyte = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode)\n-\t\t\t- byte);\n+      unsigned ibyte = inner_bytes - GET_MODE_SIZE (outermode) - byte;\n       unsigned word_byte = WORDS_BIG_ENDIAN ? ibyte : byte;\n       unsigned subword_byte = BYTES_BIG_ENDIAN ? ibyte : byte;\n       byte = (subword_byte % UNITS_PER_WORD\n@@ -6122,7 +6124,7 @@ simplify_immed_subreg (fixed_size_mode outermode, rtx op,\n \n   /* BYTE should still be inside OP.  (Note that BYTE is unsigned,\n      so if it's become negative it will instead be very large.)  */\n-  gcc_assert (byte < GET_MODE_SIZE (innermode));\n+  gcc_assert (byte < inner_bytes);\n \n   /* Convert from bytes to chunks of size value_bit.  */\n   value_start = byte * (BITS_PER_UNIT / value_bit);\n@@ -6311,7 +6313,18 @@ simplify_subreg (machine_mode outermode, rtx op,\n       if (is_a <fixed_size_mode> (outermode, &fs_outermode)\n \t  && is_a <fixed_size_mode> (innermode, &fs_innermode)\n \t  && byte.is_constant (&cbyte))\n-\treturn simplify_immed_subreg (fs_outermode, op, fs_innermode, cbyte);\n+\treturn simplify_immed_subreg (fs_outermode, op, fs_innermode, cbyte,\n+\t\t\t\t      0, GET_MODE_SIZE (fs_innermode));\n+\n+      /* Handle constant-sized outer modes and variable-sized inner modes.  */\n+      unsigned HOST_WIDE_INT first_elem;\n+      if (GET_CODE (op) == CONST_VECTOR\n+\t  && is_a <fixed_size_mode> (outermode, &fs_outermode)\n+\t  && constant_multiple_p (byte, GET_MODE_UNIT_SIZE (innermode),\n+\t\t\t\t  &first_elem))\n+\treturn simplify_immed_subreg (fs_outermode, op, innermode, 0,\n+\t\t\t\t      first_elem,\n+\t\t\t\t      GET_MODE_SIZE (fs_outermode));\n \n       return NULL_RTX;\n     }"}]}