{"sha": "4519c0a872bb216f274a27151b56566f3e53a948", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUxOWMwYTg3MmJiMjE2ZjI3NGEyNzE1MWI1NjU2NmYzZTUzYTk0OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-04T19:03:28Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-04T19:03:28Z"}, "message": "Make-lang.in (cc1plus): Depend on $(GGC).\n\n\t* Make-lang.in (cc1plus): Depend on $(GGC).\n\t* Makefile.in (OBJS): Add ggc-simple.o.\n\t(OBJDEPS): Likewise.\n\t* cp-tree.h (language_function): Rename members to `x_' versions;\n\twe now have x_named_labels, x_ctor_label, x_dtor_label,\n\tx_base_init_list, x_member_init_list, x_base_init_expr,\n\tx_current_class_ptr, x_current_class_ref, x_last_tree,\n\tx_last_expr_type, x_last_dtor_insn, x_last_parm_cleanup_insn, and\n\tx_result_rtx.\n\t(dtor_label, ctor_label, current_base_init_list,\n\tcurrent_member_init_list, base_init_expr, current_class_ptr,\n\tcurrent_class_ref, last_tree, last_expr_type): Adjust accordingly.\n\t* decl.c: Include ggc.h.\n\t(last_dtor_insn): Adjust to use x_ names.\n\t(last_parm_cleanup_insn): Likewise.\n\t(original_result_rtx): Likewise.\n\t(named_labels): Likewise.\n\t(mark_binding_level): New function.\n\t(mark_cp_function_context): Likewise.\n\t(mark_false_label_stack): Likewise.\n\t(lang_mark_tree): Likewise.\n\t(lang_cleanup_tree): Likewise.\n\nFrom-SVN: r29107", "tree": {"sha": "67c84975f8dd7114096f926803469fc728b032d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67c84975f8dd7114096f926803469fc728b032d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4519c0a872bb216f274a27151b56566f3e53a948", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4519c0a872bb216f274a27151b56566f3e53a948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4519c0a872bb216f274a27151b56566f3e53a948", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4519c0a872bb216f274a27151b56566f3e53a948/comments", "author": null, "committer": null, "parents": [{"sha": "0a25f1f5e2a425425b7d09e24a530bb6e0247393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a25f1f5e2a425425b7d09e24a530bb6e0247393", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a25f1f5e2a425425b7d09e24a530bb6e0247393"}], "stats": {"total": 199, "additions": 168, "deletions": 31}, "files": [{"sha": "67c1219b421c468fee82bac70196d374d764612c", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4519c0a872bb216f274a27151b56566f3e53a948/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4519c0a872bb216f274a27151b56566f3e53a948/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=4519c0a872bb216f274a27151b56566f3e53a948", "patch": "@@ -120,8 +120,9 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/repo.c $(srcdir)/cp/semantics.c \\\n  $(srcdir)/cp/dump.c\n \n-cc1plus$(exeext): $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o \\\n-\t$(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def $(srcdir)/cp/gxx.gperf hash.o\n+cc1plus$(exeext): $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o \\\n+        c-pragma.o $(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def \\\n+\t$(srcdir)/cp/gxx.gperf hash.o $(GGC)\n \tcd cp; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) ../cc1plus$(exeext)\n #\f\n # Build hooks:"}, {"sha": "4cc047f1d61c4f19a52d0b4e54d677adc281185a", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4519c0a872bb216f274a27151b56566f3e53a948/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4519c0a872bb216f274a27151b56566f3e53a948/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=4519c0a872bb216f274a27151b56566f3e53a948", "patch": "@@ -178,8 +178,8 @@ CXX_OBJS = call.o decl.o errfn.o expr.o pt.o typeck2.o \\\n  repo.o dump.o @extra_cxx_objs@\n \n # Language-independent object files.\n-OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o\n-OBJDEPS = ../stamp-objlist ../c-common.o ../c-pragma.o\n+OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o ../ggc-simple.o\n+OBJDEPS = ../stamp-objlist ../c-common.o ../c-pragma.o ../ggc-simple.o\n \n compiler: ../cc1plus$(exeext)\n ../cc1plus$(exeext): $(P) $(OBJDEPS) $(CXX_OBJS) $(LIBDEPS)"}, {"sha": "6d4cd851ddc6c77c51315df81c21fe59418e60c2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4519c0a872bb216f274a27151b56566f3e53a948/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4519c0a872bb216f274a27151b56566f3e53a948/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4519c0a872bb216f274a27151b56566f3e53a948", "patch": "@@ -437,20 +437,20 @@ extern tree cp_global_trees[CPTI_MAX];\n \n struct language_function\n {\n-  tree named_labels;\n-  tree ctor_label;\n-  tree dtor_label;\n-  tree base_init_list;\n-  tree member_init_list;\n-  tree base_init_expr;\n-  tree current_class_ptr;\n-  tree current_class_ref;\n-  tree last_tree;\n-  tree last_expr_type;\n-\n-  struct rtx_def *last_dtor_insn;\n-  struct rtx_def *last_parm_cleanup_insn;\n-  struct rtx_def *result_rtx;\n+  tree x_named_labels;\n+  tree x_ctor_label;\n+  tree x_dtor_label;\n+  tree x_base_init_list;\n+  tree x_member_init_list;\n+  tree x_base_init_expr;\n+  tree x_current_class_ptr;\n+  tree x_current_class_ref;\n+  tree x_last_tree;\n+  tree x_last_expr_type;\n+\n+  struct rtx_def *x_last_dtor_insn;\n+  struct rtx_def *x_last_parm_cleanup_insn;\n+  struct rtx_def *x_result_rtx;\n \n   int returns_value;\n   int returns_null;\n@@ -474,12 +474,12 @@ struct language_function\n /* In a destructor, the point at which all derived class destroying\n    has been done, just before any base class destroying will be done.  */\n \n-#define dtor_label cp_function_chain->dtor_label\n+#define dtor_label cp_function_chain->x_dtor_label\n \n /* In a constructor, the point at which we are ready to return\n    the pointer to the initialized object.  */\n \n-#define ctor_label cp_function_chain->ctor_label\n+#define ctor_label cp_function_chain->x_ctor_label\n \n /* In C++, structures with well-defined constructors are initialized by\n    those constructors, unasked.  CURRENT_BASE_INIT_LIST\n@@ -491,30 +491,30 @@ struct language_function\n    where each successive term can be handed down the constructor\n    line.  Perhaps this was not intended.  */\n \n-#define current_base_init_list cp_function_chain->base_init_list\n-#define current_member_init_list cp_function_chain->member_init_list\n+#define current_base_init_list cp_function_chain->x_base_init_list\n+#define current_member_init_list cp_function_chain->x_member_init_list\n \n /* Sequence of insns which represents base initialization.  */\n \n-#define base_init_expr cp_function_chain->base_init_expr\n+#define base_init_expr cp_function_chain->x_base_init_expr\n \n /* When we're processing a member function, current_class_ptr is the\n    PARM_DECL for the `this' pointer.  The current_class_ref is an\n    expression for `*this'.  */\n \n-#define current_class_ptr cp_function_chain->current_class_ptr\n-#define current_class_ref cp_function_chain->current_class_ref\n+#define current_class_ptr cp_function_chain->x_current_class_ptr\n+#define current_class_ref cp_function_chain->x_current_class_ref\n \n /* When building a statement-tree, this is the last node added to the\n    tree.  */\n \n-#define last_tree cp_function_chain->last_tree\n+#define last_tree cp_function_chain->x_last_tree\n \n /* The type of the last expression-statement we have seen.  This is\n    required because the type of a statement-expression is the type of\n    the last expression statement.  */\n \n-#define last_expr_type cp_function_chain->last_expr_type\n+#define last_expr_type cp_function_chain->x_last_expr_type\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */"}, {"sha": "bb1b8b9b66b57438af4163c4be93c911b4784046", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 140, "deletions": 4, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4519c0a872bb216f274a27151b56566f3e53a948/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4519c0a872bb216f274a27151b56566f3e53a948/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4519c0a872bb216f274a27151b56566f3e53a948", "patch": "@@ -43,6 +43,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"../hash.h\"\n #include \"defaults.h\"\n+#include \"ggc.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -198,6 +199,8 @@ static void check_initializer PROTO((tree, tree *));\n static void make_rtl_for_nonlocal_decl PROTO((tree, tree, const char *));\n static void push_cp_function_context PROTO((struct function *));\n static void pop_cp_function_context PROTO((struct function *));\n+static void mark_binding_level PROTO((void *));\n+static void mark_cp_function_context PROTO((struct function *));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -302,21 +305,21 @@ static int only_namespace_names;\n /* In a destructor, the last insn emitted after the start of the\n    function and the parms.  */\n \n-#define last_dtor_insn cp_function_chain->last_dtor_insn\n+#define last_dtor_insn cp_function_chain->x_last_dtor_insn\n \n /* In a constructor, the last insn emitted after the start of the\n    function and the parms, the exception specification and any\n    function-try-block.  The constructor initializers are emitted after\n    this insn.  */\n \n-#define last_parm_cleanup_insn cp_function_chain->last_parm_cleanup_insn\n+#define last_parm_cleanup_insn cp_function_chain->x_last_parm_cleanup_insn\n \n /* If original DECL_RESULT of current function was a register,\n    but due to being an addressable named return value, would up\n    on the stack, this variable holds the named return value's\n    original location.  */\n \n-#define original_result_rtx cp_function_chain->result_rtx\n+#define original_result_rtx cp_function_chain->x_result_rtx\n \n /* C++: Keep these around to reduce calls to `get_identifier'.\n    Identifiers for `this' in member functions and the auto-delete\n@@ -415,7 +418,7 @@ static tree current_function_parm_tags;\n    at the end of the function.  The TREE_VALUE is a LABEL_DECL; the\n    TREE_PURPOSE is the previous binding of the label.  */\n \n-#define named_labels cp_function_chain->named_labels\n+#define named_labels cp_function_chain->x_named_labels\n \n /* The FUNCTION_DECL for the function currently being compiled,\n    or 0 if between functions.  */\n@@ -1998,6 +2001,30 @@ wrapup_globals_for_namespace (namespace, data)\n   return result;\n }\n \n+\f\n+static void\n+mark_binding_level (arg)\n+     void *arg;\n+{\n+  struct binding_level *lvl = *(struct binding_level **)arg;\n+\n+  while (lvl)\n+    {\n+      ggc_mark_tree (lvl->names);\n+      ggc_mark_tree (lvl->tags);\n+      ggc_mark_tree (lvl->usings);\n+      ggc_mark_tree (lvl->using_directives);\n+      ggc_mark_tree (lvl->class_shadowed);\n+      ggc_mark_tree (lvl->type_shadowed);\n+      ggc_mark_tree (lvl->shadowed_labels);\n+      ggc_mark_tree (lvl->blocks);\n+      ggc_mark_tree (lvl->this_block);\n+      ggc_mark_tree (lvl->incomplete);\n+      ggc_mark_tree (lvl->dead_vars_from_for);\n+\n+      lvl = lvl->level_chain;\n+    }\n+}\n \f\n /* For debugging.  */\n static int no_print_functions = 0;\n@@ -14537,8 +14564,117 @@ pop_cp_function_context (f)\n   f->language = 0;\n }\n \n+void\n+mark_cp_function_context (f)\n+     struct function *f;\n+{\n+  struct language_function *p = f->language;\n+\n+  ggc_mark_tree (p->x_named_labels);\n+  ggc_mark_tree (p->x_ctor_label);\n+  ggc_mark_tree (p->x_dtor_label);\n+  ggc_mark_tree (p->x_base_init_list);\n+  ggc_mark_tree (p->x_member_init_list);\n+  ggc_mark_tree (p->x_base_init_expr);\n+  ggc_mark_tree (p->x_current_class_ptr);\n+  ggc_mark_tree (p->x_current_class_ref);\n+  ggc_mark_tree (p->x_last_tree);\n+  ggc_mark_tree (p->x_last_expr_type);\n+\n+  ggc_mark_rtx (p->x_last_dtor_insn);\n+  ggc_mark_rtx (p->x_last_parm_cleanup_insn);\n+  ggc_mark_rtx (p->x_result_rtx);\n+\n+  mark_binding_level (&p->binding_level);\n+}\n+\n+\n int\n in_function_p ()\n {\n   return function_depth != 0;\n }\n+\n+\n+void\n+lang_mark_false_label_stack (arg)\n+     void *arg;\n+{\n+  /* C++ doesn't use false_label_stack.  It better be NULL.  */\n+  if (*(void **)arg != NULL)\n+    abort();\n+}\n+\n+void\n+lang_mark_tree (t)\n+     tree t;\n+{\n+  enum tree_code code = TREE_CODE (t);\n+  if (code == IDENTIFIER_NODE)\n+    {\n+      struct lang_identifier *li = (struct lang_identifier *) t;\n+      struct lang_id2 *li2 = li->x;\n+      ggc_mark_tree (li->namespace_bindings);\n+      ggc_mark_tree (li->class_value);\n+      ggc_mark_tree (li->class_template_info);\n+\n+      if (li2)\n+\t{\n+\t  ggc_mark_tree (li2->label_value);\n+\t  ggc_mark_tree (li2->implicit_decl);\n+\t  ggc_mark_tree (li2->error_locus);\n+\t}\n+    }\n+  else if (TREE_CODE_CLASS (code) == 'd')\n+    {\n+      struct lang_decl *ld = DECL_LANG_SPECIFIC (t);\n+\n+      if (ld)\n+\t{\n+\t  ggc_mark_tree (ld->decl_flags.access);\n+\t  ggc_mark_tree (ld->decl_flags.context);\n+\t  if (TREE_CODE (t) != NAMESPACE_DECL)\n+\t    ggc_mark_tree (ld->decl_flags.u.template_info);\n+\t  if (CAN_HAVE_FULL_LANG_DECL_P (t))\n+\t    {\n+\t      ggc_mark_tree (ld->main_decl_variant);\n+\t      ggc_mark_tree (ld->befriending_classes);\n+\t      ggc_mark_tree (ld->saved_tree);\n+\t      if (TREE_CODE (t) == TYPE_DECL)\n+\t\tggc_mark_tree (ld->u.sorted_fields);\n+\t    }\n+\t}\n+    }\n+  else if (TREE_CODE_CLASS (code) == 't')\n+    {\n+      struct lang_type *lt = TYPE_LANG_SPECIFIC (t);\n+\n+      if (lt)\n+\t{\n+\t  ggc_mark_tree (lt->vfields);\n+\t  ggc_mark_tree (lt->vbases);\n+\t  ggc_mark_tree (lt->tags);\n+\t  ggc_mark_tree (lt->search_slot);\n+\t  ggc_mark_tree (lt->size);\n+\t  ggc_mark_tree (lt->abstract_virtuals);\n+\t  ggc_mark_tree (lt->friend_classes);\n+\t  ggc_mark_tree (lt->rtti);\n+\t  ggc_mark_tree (lt->methods);\n+\t  ggc_mark_tree (lt->template_info);\n+\t}\n+    }\n+}\n+\n+void\n+lang_cleanup_tree (t)\n+     tree t;\n+{\n+  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't'\n+      && TYPE_LANG_SPECIFIC (t) != NULL)\n+    {\n+#if 0\n+      /* This is currently allocated with an obstack.  This will change.  */\n+      free (TYPE_LANG_SPECIFIC (t));\n+#endif\n+    }\n+}"}]}