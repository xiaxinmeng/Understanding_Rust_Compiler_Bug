{"sha": "ea82015ce986194da3d0f20d48accede0174d3e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE4MjAxNWNlOTg2MTk0ZGEzZDBmMjBkNDhhY2NlZGUwMTc0ZDNlMg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-10-11T14:09:44Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-10-11T14:09:44Z"}, "message": "builtins.c (expand_builtin_memcpy): Optimize case when the two pointer arguments are the equal...\n\n\n\t* builtins.c (expand_builtin_memcpy): Optimize case when the two\n\tpointer arguments are the equal, non-volatile and side-effect free.\n\t(expand_builtin_mempcpy): Likewise.\n\t(expand_builtin_memmove): Likewise.\n\t(expand_builtin_strcpy): Likewise.\n\t(expand_builtin_memcmp): Likewise.\n\t(expand_builtin_strcmp): Likewise.\n\t(expand_builtin_strncmp): Likewise.\n\n\t* gcc.c-torture/execute/string-opt-18.c: New testcase.\n\nFrom-SVN: r72335", "tree": {"sha": "1553338bbed938f4292236cb778a152c34cc82d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1553338bbed938f4292236cb778a152c34cc82d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea82015ce986194da3d0f20d48accede0174d3e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea82015ce986194da3d0f20d48accede0174d3e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea82015ce986194da3d0f20d48accede0174d3e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea82015ce986194da3d0f20d48accede0174d3e2/comments", "author": null, "committer": null, "parents": [{"sha": "2981fafefcc843ed133c328e4f0f0187d661f186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2981fafefcc843ed133c328e4f0f0187d661f186", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2981fafefcc843ed133c328e4f0f0187d661f186"}], "stats": {"total": 165, "additions": 160, "deletions": 5}, "files": [{"sha": "3cfe32a027d941baddd7448aebb4a4feb20c8448", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea82015ce986194da3d0f20d48accede0174d3e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea82015ce986194da3d0f20d48accede0174d3e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea82015ce986194da3d0f20d48accede0174d3e2", "patch": "@@ -1,3 +1,14 @@\n+2003-10-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.c (expand_builtin_memcpy): Optimize case when the two\n+\tpointer arguments are the equal, non-volatile and side-effect free.\n+\t(expand_builtin_mempcpy): Likewise.\n+\t(expand_builtin_memmove): Likewise.\n+\t(expand_builtin_strcpy): Likewise.\n+\t(expand_builtin_memcmp): Likewise.\n+\t(expand_builtin_strcmp): Likewise.\n+\t(expand_builtin_strncmp): Likewise.\n+\n 2003-10-11  Roger Sayle  <roger@eyesopen.com>\n \n \t* combine.c (apply_distributive_law): Enable \"distributive\" floating"}, {"sha": "1af2a2d0889a6167e4b7061b7fb927dd5bd25d09", "filename": "gcc/builtins.c", "status": "modified", "additions": 69, "deletions": 5, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea82015ce986194da3d0f20d48accede0174d3e2/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea82015ce986194da3d0f20d48accede0174d3e2/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ea82015ce986194da3d0f20d48accede0174d3e2", "patch": "@@ -2561,11 +2561,34 @@ expand_builtin_mempcpy (tree arglist, rtx target, enum machine_mode mode,\n \t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n       rtx dest_mem, src_mem, len_rtx;\n \n-      /* If DEST is not a pointer type or LEN is not constant,\n-\t call the normal function.  */\n-      if (dest_align == 0 || !host_integerp (len, 1))\n+      /* If DEST is not a pointer type, call the normal function.  */\n+      if (dest_align == 0)\n \treturn 0;\n \n+      /* If SRC and DEST are the same (and not volatile), do nothing.  */\n+      if (operand_equal_p (src, dest, 0))\n+\t{\n+\t  tree expr;\n+\n+\t  if (endp == 0)\n+\t    {\n+\t      /* Evaluate and ignore LEN in case it has side-effects.  */\n+\t      expand_expr (len, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t      return expand_expr (dest, target, mode, EXPAND_NORMAL);\n+\t    }\n+\n+\t  if (endp == 2)\n+\t    len = fold (build (MINUS_EXPR, TREE_TYPE (len), dest,\n+\t\t\t       integer_one_node));\n+\t  len = convert (TREE_TYPE (dest), len);\n+\t  expr = fold (build (PLUS_EXPR, TREE_TYPE (dest), dest, len));\n+\t  return expand_expr (expr, target, mode, EXPAND_NORMAL);\n+\t}\n+\n+      /* If LEN is not constant, call the normal function.  */\n+      if (! host_integerp (len, 1))\n+\treturn 0;\n+  \n       /* If the LEN parameter is zero, return DEST.  */\n       if (tree_low_cst (len, 1) == 0)\n \t{\n@@ -2574,6 +2597,14 @@ expand_builtin_mempcpy (tree arglist, rtx target, enum machine_mode mode,\n \t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n \t}\n \n+      /* If SRC and DEST are the same (and not volatile), return DEST.  */\n+      if (operand_equal_p (src, dest, 0))\n+\t{\n+\t  /* Evaluate and ignore LEN in case it has side-effects.  */\n+\t  expand_expr (len, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n+\t}\n+\n       /* If either SRC is not a pointer type, don't do this\n          operation in-line.  */\n       if (src_align == 0)\n@@ -2651,6 +2682,14 @@ expand_builtin_memmove (tree arglist, rtx target, enum machine_mode mode)\n \t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n \t}\n \n+      /* If SRC and DEST are the same (and not volatile), return DEST.  */\n+      if (operand_equal_p (src, dest, 0))\n+\t{\n+\t  /* Evaluate and ignore LEN in case it has side-effects.  */\n+\t  expand_expr (len, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n+\t}\n+\n       /* If either SRC is not a pointer type, don't do this\n          operation in-line.  */\n       if (src_align == 0)\n@@ -2713,16 +2752,21 @@ expand_builtin_strcpy (tree arglist, rtx target, enum machine_mode mode)\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n \n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  dst = TREE_VALUE (arglist);\n+\n+  /* If SRC and DST are equal (and not volatile), return DST.  */\n+  if (operand_equal_p (src, dst, 0))\n+    return expand_expr (dst, target, mode, EXPAND_NORMAL);\n+\n   fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n   if (!fn)\n     return 0;\n \n-  src = TREE_VALUE (TREE_CHAIN (arglist));\n   len = c_strlen (src, 1);\n   if (len == 0 || TREE_SIDE_EFFECTS (len))\n     return 0;\n \n-  dst = TREE_VALUE (arglist);\n   len = size_binop (PLUS_EXPR, len, ssize_int (1));\n   arglist = build_tree_list (NULL_TREE, len);\n   arglist = tree_cons (NULL_TREE, src, arglist);\n@@ -3063,6 +3107,14 @@ expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n       return const0_rtx;\n     }\n \n+  /* If both arguments are equal (and not volatile), return zero.  */\n+  if (operand_equal_p (arg1, arg2, 0))\n+    {\n+      /* Evaluate and ignore len in case it has side-effects.  */\n+      expand_expr (len, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      return const0_rtx;\n+    }\n+\n   p1 = c_getstr (arg1);\n   p2 = c_getstr (arg2);\n \n@@ -3192,6 +3244,10 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n   arg1 = TREE_VALUE (arglist);\n   arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n \n+  /* If both arguments are equal (and not volatile), return zero.  */\n+  if (operand_equal_p (arg1, arg2, 0))\n+    return const0_rtx;\n+\n   p1 = c_getstr (arg1);\n   p2 = c_getstr (arg2);\n \n@@ -3332,6 +3388,14 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n       return const0_rtx;\n     }\n \n+  /* If arg1 and arg2 are equal (and not volatile), return zero.  */\n+  if (operand_equal_p (arg1, arg2, 0))\n+    {\n+      /* Evaluate and ignore arg3 in case it has side-effects.  */\n+      expand_expr (arg3, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      return const0_rtx;\n+    }\n+\n   p1 = c_getstr (arg1);\n   p2 = c_getstr (arg2);\n "}, {"sha": "86c18ce3a7df43c50939d8949be7c8f511cd9352", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea82015ce986194da3d0f20d48accede0174d3e2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea82015ce986194da3d0f20d48accede0174d3e2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ea82015ce986194da3d0f20d48accede0174d3e2", "patch": "@@ -1,3 +1,7 @@\n+2003-10-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.c-torture/execute/string-opt-18.c: New testcase.\n+\n 2003-10-10  Ian Lance Taylor  <ian@wasabisystems.com>\n \n \t* gcc.c-torture/compile/20031010-1.c: New test."}, {"sha": "610c4caf1ca2db2b4eb9113f211092c8e6b3043d", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-18.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea82015ce986194da3d0f20d48accede0174d3e2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea82015ce986194da3d0f20d48accede0174d3e2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-18.c?ref=ea82015ce986194da3d0f20d48accede0174d3e2", "patch": "@@ -0,0 +1,76 @@\n+/* Copyright (C) 2003  Free Software Foundation.\n+\n+   Test equal pointer optimizations don't break anything.\n+\n+   Written by Roger Sayle, July 14, 2003.  */\n+\n+extern void abort ();\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void *memcpy(void*, const void*, size_t);\n+extern void *mempcpy(void*, const void*, size_t);\n+extern void *memmove(void*, const void*, size_t);\n+extern char *strcpy(char*, const char*);\n+extern int memcmp(const void*, const void*, size_t);\n+extern int strcmp(const char*, const char*);\n+extern int strncmp(const char*, const char*, size_t);\n+\n+\n+void test1 (void *ptr)\n+{\n+  if (memcpy(ptr,ptr,8) != ptr)\n+    abort ();\n+}\n+\n+void test2 (char *ptr)\n+{\n+  if (mempcpy(ptr,ptr,8) != ptr+8)\n+    abort ();\n+}\n+\n+void test3 (void *ptr)\n+{\n+  if (memmove(ptr,ptr,8) != ptr)\n+    abort ();\n+}\n+\n+void test4 (char *ptr)\n+{\n+  if (strcpy(ptr,ptr) != ptr)\n+    abort ();\n+}\n+\n+void test5 (void *ptr)\n+{\n+  if (memcmp(ptr,ptr,8) != 0)\n+    abort ();\n+}\n+\n+void test6 (const char *ptr)\n+{\n+  if (strcmp(ptr,ptr) != 0)\n+    abort ();\n+}\n+\n+void test7 (const char *ptr)\n+{\n+  if (strncmp(ptr,ptr,8) != 0)\n+    abort ();\n+}\n+\n+\n+int main ()\n+{\n+  char buf[10];\n+\n+  test1 (buf);\n+  test2 (buf);\n+  test3 (buf);\n+  test4 (buf);\n+  test5 (buf);\n+  test6 (buf);\n+  test7 (buf);\n+\n+  return 0;\n+}\n+"}]}