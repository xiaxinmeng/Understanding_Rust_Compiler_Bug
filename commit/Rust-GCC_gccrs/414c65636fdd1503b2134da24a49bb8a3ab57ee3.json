{"sha": "414c65636fdd1503b2134da24a49bb8a3ab57ee3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE0YzY1NjM2ZmRkMTUwM2IyMTM0ZGEyNGE0OWJiOGEzYWI1N2VlMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T12:44:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T12:44:34Z"}, "message": "[multiple changes]\n\n2014-07-29  Thomas Quinot  <quinot@adacore.com>\n\n\t* errout.adb (Set_Error_Posted): When propagating flag to\n\tan enclosing named association, also propagate to the parent\n\tof that node, so that named and positional associations are\n\ttreated consistently.\n\n2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Resolve_Attribute, case 'Update):  Set\n\tDo_Range_Check properly on array component expressions that\n\thave a scalar type. In GNATprove mode, only checks on scalar\n\tcomponents must be marked by the front-end.\n\n2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Type_Conversion): If the type of the\n\texpression is a limited view, use the non-limited view when\n\tavailable.\n\n2014-07-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Case_Expression): Mark the generated\n\tcase statement as coming from a conditional expression.\n\t(Expand_N_If_Expression): Mark the generated if statement as\n\tcoming from a conditional expression.\n\t* exp_ch5.adb (Expand_N_Case_Statement): Do not process controlled\n\tobjects found in case statement alternatives when the case\n\tstatement is actually a case expression.\n\t(Expand_N_If_Statement):\n\tDo not process controlled objects found in an if statement when\n\tthe if statement is actually an if expression.\n\t* sinfo.adb (From_Conditional_Expression): New routine.\n\t(Set_From_Conditional_Expression): New routine.\n\t* sinfo.ads Add new semantic flag From_Conditional_Expression and\n\tupdate related nodes.\n\t(From_Conditional_Expression): New routine along with pragma Inline.\n\t(Set_From_Conditional_Expression): New routine along with pragma Inline.\n\nFrom-SVN: r213156", "tree": {"sha": "5b63d111086fa3f1a33066a40b49275d1befa3a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b63d111086fa3f1a33066a40b49275d1befa3a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/414c65636fdd1503b2134da24a49bb8a3ab57ee3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/414c65636fdd1503b2134da24a49bb8a3ab57ee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/414c65636fdd1503b2134da24a49bb8a3ab57ee3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/414c65636fdd1503b2134da24a49bb8a3ab57ee3/comments", "author": null, "committer": null, "parents": [{"sha": "0382062b3b87859411e98bb2d3347020e7f45f48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0382062b3b87859411e98bb2d3347020e7f45f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0382062b3b87859411e98bb2d3347020e7f45f48"}], "stats": {"total": 194, "additions": 176, "deletions": 18}, "files": [{"sha": "b74401a4a56cbfe10fbecbbc02192d301c35096e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=414c65636fdd1503b2134da24a49bb8a3ab57ee3", "patch": "@@ -1,3 +1,42 @@\n+2014-07-29  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* errout.adb (Set_Error_Posted): When propagating flag to\n+\tan enclosing named association, also propagate to the parent\n+\tof that node, so that named and positional associations are\n+\ttreated consistently.\n+\n+2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Resolve_Attribute, case 'Update):  Set\n+\tDo_Range_Check properly on array component expressions that\n+\thave a scalar type. In GNATprove mode, only checks on scalar\n+\tcomponents must be marked by the front-end.\n+\n+2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Type_Conversion): If the type of the\n+\texpression is a limited view, use the non-limited view when\n+\tavailable.\n+\n+2014-07-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Case_Expression): Mark the generated\n+\tcase statement as coming from a conditional expression.\n+\t(Expand_N_If_Expression): Mark the generated if statement as\n+\tcoming from a conditional expression.\n+\t* exp_ch5.adb (Expand_N_Case_Statement): Do not process controlled\n+\tobjects found in case statement alternatives when the case\n+\tstatement is actually a case expression.\n+\t(Expand_N_If_Statement):\n+\tDo not process controlled objects found in an if statement when\n+\tthe if statement is actually an if expression.\n+\t* sinfo.adb (From_Conditional_Expression): New routine.\n+\t(Set_From_Conditional_Expression): New routine.\n+\t* sinfo.ads Add new semantic flag From_Conditional_Expression and\n+\tupdate related nodes.\n+\t(From_Conditional_Expression): New routine along with pragma Inline.\n+\t(Set_From_Conditional_Expression): New routine along with pragma Inline.\n+\n 2014-07-29  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch7.adb (Build_BIP_Cleanup_Stmts): Remove"}, {"sha": "a18627cb582773654ccaf346307ba14e3d0158ec", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=414c65636fdd1503b2134da24a49bb8a3ab57ee3", "patch": "@@ -156,11 +156,12 @@ package body Errout is\n    --  variables Msg_Buffer are set on return Msglen.\n \n    procedure Set_Posted (N : Node_Id);\n-   --  Sets the Error_Posted flag on the given node, and all its parents\n-   --  that are subexpressions and then on the parent non-subexpression\n-   --  construct that contains the original expression (this reduces the\n-   --  number of cascaded messages). Note that this call only has an effect\n-   --  for a serious error. For a non-serious error, it has no effect.\n+   --  Sets the Error_Posted flag on the given node, and all its parents that\n+   --  are subexpressions and then on the parent non-subexpression construct\n+   --  that contains the original expression. If that parent is a named\n+   --  association, the flag is further propagated to its parent. This is done\n+   --  in order to guard against cascaded errors. Note that this call has an\n+   --  effect for a serious error only.\n \n    procedure Set_Qualification (N : Nat; E : Entity_Id);\n    --  Outputs up to N levels of qualification for the given entity. For\n@@ -3007,6 +3008,16 @@ package body Errout is\n             exit when Nkind (P) not in N_Subexpr;\n          end loop;\n \n+         if Nkind_In (P,\n+              N_Pragma_Argument_Association,\n+              N_Component_Association,\n+              N_Discriminant_Association,\n+              N_Generic_Association,\n+              N_Parameter_Association)\n+         then\n+            Set_Error_Posted (Parent (P));\n+         end if;\n+\n          --  A special check, if we just posted an error on an attribute\n          --  definition clause, then also set the entity involved as posted.\n          --  For example, this stops complaining about the alignment after"}, {"sha": "9abe25aaf1d7590bafd862825e23bd5f8701ab47", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=414c65636fdd1503b2134da24a49bb8a3ab57ee3", "patch": "@@ -4991,6 +4991,13 @@ package body Exp_Ch4 is\n           Expression   => Expression (N),\n           Alternatives => New_List);\n \n+      --  Preserve the original context for which the case statement is being\n+      --  generated. This is needed by the finalization machinery to prevent\n+      --  the premature finalization of controlled objects found within the\n+      --  case statement.\n+\n+      Set_From_Conditional_Expression (Cstmt);\n+\n       Actions := New_List;\n \n       --  Scalar case\n@@ -5354,9 +5361,16 @@ package body Exp_Ch4 is\n                      Prefix         => Relocate_Node (Elsex),\n                      Attribute_Name => Name_Unrestricted_Access))));\n \n-            New_N :=\n-              Make_Explicit_Dereference (Loc,\n-                Prefix => New_Occurrence_Of (Cnn, Loc));\n+         --  Preserve the original context for which the if statement is being\n+         --  generated. This is needed by the finalization machinery to prevent\n+         --  the premature finalization of controlled objects found within the\n+         --  if statement.\n+\n+         Set_From_Conditional_Expression (New_If);\n+\n+         New_N :=\n+           Make_Explicit_Dereference (Loc,\n+             Prefix => New_Occurrence_Of (Cnn, Loc));\n \n       --  For other types, we only need to expand if there are other actions\n       --  associated with either branch."}, {"sha": "338050e5758fa934d62e698ddb8dc19b1b24ffa6", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=414c65636fdd1503b2134da24a49bb8a3ab57ee3", "patch": "@@ -2524,7 +2524,13 @@ package body Exp_Ch5 is\n       if Compile_Time_Known_Value (Expr) then\n          Alt := Find_Static_Alternative (N);\n \n-         Process_Statements_For_Controlled_Objects (Alt);\n+         --  Do not consider controlled objects found in a case statement which\n+         --  actually models a case expression because their early finalization\n+         --  will affect the result of the expression.\n+\n+         if not From_Conditional_Expression (N) then\n+            Process_Statements_For_Controlled_Objects (Alt);\n+         end if;\n \n          --  Move statements from this alternative after the case statement.\n          --  They are already analyzed, so will be skipped by the analyzer.\n@@ -2603,10 +2609,16 @@ package body Exp_Ch5 is\n             --  effects.\n \n             Remove_Side_Effects (Expression (N));\n-\n             Alt := First (Alternatives (N));\n \n-            Process_Statements_For_Controlled_Objects (Alt);\n+            --  Do not consider controlled objects found in a case statement\n+            --  which actually models a case expression because their early\n+            --  finalization will affect the result of the expression.\n+\n+            if not From_Conditional_Expression (N) then\n+               Process_Statements_For_Controlled_Objects (Alt);\n+            end if;\n+\n             Insert_List_After (N, Statements (Alt));\n \n             --  That leaves the case statement as a shell. The alternative that\n@@ -2711,7 +2723,14 @@ package body Exp_Ch5 is\n \n          Alt := First_Non_Pragma (Alternatives (N));\n          while Present (Alt) loop\n-            Process_Statements_For_Controlled_Objects (Alt);\n+\n+            --  Do not consider controlled objects found in a case statement\n+            --  which actually models a case expression because their early\n+            --  finalization will affect the result of the expression.\n+\n+            if not From_Conditional_Expression (N) then\n+               Process_Statements_For_Controlled_Objects (Alt);\n+            end if;\n \n             if Has_SP_Choice (Alt) then\n                Expand_Static_Predicates_In_Choices (Alt);\n@@ -2914,7 +2933,13 @@ package body Exp_Ch5 is\n       --  these warnings for expander generated code.\n \n    begin\n-      Process_Statements_For_Controlled_Objects (N);\n+      --  Do not consider controlled objects found in an if statement which\n+      --  actually models an if expression because their early finalization\n+      --  will affect the result of the expression.\n+\n+      if not From_Conditional_Expression (N) then\n+         Process_Statements_For_Controlled_Objects (N);\n+      end if;\n \n       Adjust_Condition (Condition (N));\n \n@@ -3001,7 +3026,14 @@ package body Exp_Ch5 is\n       if Present (Elsif_Parts (N)) then\n          E := First (Elsif_Parts (N));\n          while Present (E) loop\n-            Process_Statements_For_Controlled_Objects (E);\n+\n+            --  Do not consider controlled objects found in an if statement\n+            --  which actually models an if expression because their early\n+            --  finalization will affect the result of the expression.\n+\n+            if not From_Conditional_Expression (N) then\n+               Process_Statements_For_Controlled_Objects (E);\n+            end if;\n \n             Adjust_Condition (Condition (E));\n "}, {"sha": "114f42e924ef5ed551a9d11f0902bc8c64fdb552", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=414c65636fdd1503b2134da24a49bb8a3ab57ee3", "patch": "@@ -10836,7 +10836,25 @@ package body Sem_Attr is\n                   while Present (Assoc) loop\n                      Expr  := Expression (Assoc);\n                      Resolve (Expr, Component_Type (Typ));\n-                     Aggregate_Constraint_Checks (Expr, Component_Type (Typ));\n+\n+                     --  For scalar array components set Do_Range_Check when\n+                     --  needed. Constraint checking on non-scalar components\n+                     --  is done in Aggregate_Constraint_Checks, but only if\n+                     --  full analysis is enabled. These flags are not set in\n+                     --  the front-end in GnatProve mode.\n+\n+                     if Is_Scalar_Type (Component_Type (Typ))\n+                       and then not Is_OK_Static_Expression (Expr)\n+                     then\n+                        if Is_Entity_Name (Expr)\n+                          and then Etype (Expr) = Component_Type (Typ)\n+                        then\n+                           null;\n+\n+                        else\n+                           Set_Do_Range_Check (Expr);\n+                        end if;\n+                     end if;\n \n                      --  The choices in the association are static constants,\n                      --  or static aggregates each of whose components belongs"}, {"sha": "51b151eeefbf9a7bc287754ba82a6f48c3736022", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=414c65636fdd1503b2134da24a49bb8a3ab57ee3", "patch": "@@ -10193,6 +10193,17 @@ package body Sem_Res is\n             Target : Entity_Id := Target_Typ;\n \n          begin\n+            --  If the type of the operand is a limited view, use the non-\n+            --  limited view when available.\n+\n+            if From_Limited_With (Opnd)\n+              and then Ekind (Opnd) in Incomplete_Kind\n+              and then Present (Non_Limited_View (Opnd))\n+            then\n+               Opnd := Non_Limited_View (Opnd);\n+               Set_Etype (Expression (N), Opnd);\n+            end if;\n+\n             if Is_Access_Type (Opnd) then\n                Opnd := Designated_Type (Opnd);\n             end if;"}, {"sha": "232e0bc1ebb64754d42a334511a6645de37a6a33", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=414c65636fdd1503b2134da24a49bb8a3ab57ee3", "patch": "@@ -1400,6 +1400,15 @@ package body Sinfo is\n       return Flag4 (N);\n    end From_At_Mod;\n \n+   function From_Conditional_Expression\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Case_Statement\n+        or else NT (N).Nkind = N_If_Statement);\n+      return Flag1 (N);\n+   end From_Conditional_Expression;\n+\n    function From_Default\n       (N : Node_Id) return Boolean is\n    begin\n@@ -4574,6 +4583,15 @@ package body Sinfo is\n       Set_Flag4 (N, Val);\n    end Set_From_At_Mod;\n \n+   procedure Set_From_Conditional_Expression\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Case_Statement\n+        or else NT (N).Nkind = N_If_Statement);\n+      Set_Flag1 (N, Val);\n+   end Set_From_Conditional_Expression;\n+\n    procedure Set_From_Default\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "f02fe51b1cd97db9a7b66017359263f03f700dc2", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/414c65636fdd1503b2134da24a49bb8a3ab57ee3/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=414c65636fdd1503b2134da24a49bb8a3ab57ee3", "patch": "@@ -1291,6 +1291,11 @@ package Sinfo is\n    --    must be a multiple of the given value, and the representation clause\n    --    is considered to be type specific instead of subtype specific.\n \n+   --  From_Conditional_Expression (Flag1-Sem)\n+   --    This flag is set on if and case statements generated by the expansion\n+   --    of if and case expressions respectively. The flag is used to suppress\n+   --    any finalization of controlled objects found within these statements.\n+\n    --  From_Default (Flag6-Sem)\n    --    This flag is set on the subprogram renaming declaration created in an\n    --    instance for a formal subprogram, when the formal is declared with a\n@@ -4569,6 +4574,7 @@ package Sinfo is\n       --  Elsif_Parts (List3) (set to No_List if none present)\n       --  Else_Statements (List4) (set to No_List if no else part present)\n       --  End_Span (Uint5) (set to Uint_0 if expander generated)\n+      --  From_Conditional_Expression (Flag1-Sem)\n \n       --  N_Elsif_Part\n       --  Sloc points to ELSIF\n@@ -4601,6 +4607,7 @@ package Sinfo is\n       --  Expression (Node3)\n       --  Alternatives (List4)\n       --  End_Span (Uint5) (set to Uint_0 if expander generated)\n+      --  From_Conditional_Expression (Flag1-Sem)\n \n       --  Note: Before Ada 2012, a pragma in a statement sequence is always\n       --  followed by a statement, and this is true in the tree even in Ada\n@@ -9031,6 +9038,9 @@ package Sinfo is\n    function From_At_Mod\n      (N : Node_Id) return Boolean;    -- Flag4\n \n+   function From_Conditional_Expression\n+     (N : Node_Id) return Boolean;    -- Flag1\n+\n    function From_Default\n      (N : Node_Id) return Boolean;    -- Flag6\n \n@@ -10032,15 +10042,18 @@ package Sinfo is\n    procedure Set_Forwards_OK\n      (N : Node_Id; Val : Boolean := True);    -- Flag5\n \n-   procedure Set_From_At_Mod\n-     (N : Node_Id; Val : Boolean := True);    -- Flag4\n-\n    procedure Set_From_Aspect_Specification\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n    procedure Set_From_At_End\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n+   procedure Set_From_At_Mod\n+     (N : Node_Id; Val : Boolean := True);    -- Flag4\n+\n+   procedure Set_From_Conditional_Expression\n+     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+\n    procedure Set_From_Default\n      (N : Node_Id; Val : Boolean := True);    -- Flag6\n \n@@ -12527,6 +12540,7 @@ package Sinfo is\n    pragma Inline (From_Aspect_Specification);\n    pragma Inline (From_At_End);\n    pragma Inline (From_At_Mod);\n+   pragma Inline (From_Conditional_Expression);\n    pragma Inline (From_Default);\n    pragma Inline (Generalized_Indexing);\n    pragma Inline (Generic_Associations);\n@@ -12861,6 +12875,7 @@ package Sinfo is\n    pragma Inline (Set_From_Aspect_Specification);\n    pragma Inline (Set_From_At_End);\n    pragma Inline (Set_From_At_Mod);\n+   pragma Inline (Set_From_Conditional_Expression);\n    pragma Inline (Set_From_Default);\n    pragma Inline (Set_Generalized_Indexing);\n    pragma Inline (Set_Generic_Associations);"}]}