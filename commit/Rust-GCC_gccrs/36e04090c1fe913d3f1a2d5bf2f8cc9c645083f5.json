{"sha": "36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZlMDQwOTBjMWZlOTEzZDNmMWEyZDViZjJmOGNjOWM2NDUwODNmNQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-01-18T19:31:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-01-18T19:31:15Z"}, "message": "200x-xx-xx Kazu Hirata <kazu@codesourcery.com> Richard Sandiford <richard@codesourcery.com>\n\ngcc/\n200x-xx-xx  Kazu Hirata  <kazu@codesourcery.com>\n\t    Richard Sandiford  <richard@codesourcery.com>\n\n\t* config/m68k/m68k.h (DATA_REGNO_P, ADDRESS_REGNO_P, INT_REGNO_P)\n\t(FP_REGNO_P): New macros.\n\t(REGNO_OK_FOR_INDEX_P, REGNO_OK_FOR_BASE_P, REGNO_OK_FOR_DATA_P)\n\t(REGNO_OK_FOR_FP_P, REG_OK_FOR_INDEX_P, REG_OK_FOR_BASE_P): Use them.\n\t(EH_RETURN_STACKADJ_RTX): Use A0_REG.\n\t* config/m68k/m68k.c (m68k_regno_mode_ok): Use the new REGNO macros.\n\nCo-Authored-By: Richard Sandiford <richard@codesourcery.com>\n\nFrom-SVN: r120918", "tree": {"sha": "993db98540ceb8844f3294db3526866f73cc666b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/993db98540ceb8844f3294db3526866f73cc666b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5/comments", "author": null, "committer": null, "parents": [{"sha": "47b41fa34abeff893fb1358c8154e681e68fdddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b41fa34abeff893fb1358c8154e681e68fdddd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47b41fa34abeff893fb1358c8154e681e68fdddd"}], "stats": {"total": 58, "additions": 44, "deletions": 14}, "files": [{"sha": "94e18bfc326e66f5d3a51222a86d966da013f94c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5", "patch": "@@ -1,3 +1,13 @@\n+2007-01-18  Kazu Hirata  <kazu@codesourcery.com>\n+\t    Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/m68k/m68k.h (DATA_REGNO_P, ADDRESS_REGNO_P, INT_REGNO_P)\n+\t(FP_REGNO_P): New macros.\n+\t(REGNO_OK_FOR_INDEX_P, REGNO_OK_FOR_BASE_P, REGNO_OK_FOR_DATA_P)\n+\t(REGNO_OK_FOR_FP_P, REG_OK_FOR_INDEX_P, REG_OK_FOR_BASE_P): Use them.\n+\t(EH_RETURN_STACKADJ_RTX): Use A0_REG.\n+\t* config/m68k/m68k.c (m68k_regno_mode_ok): Use the new REGNO macros.\n+\n 2007-01-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config.gcc (m68k-*-aout*, m68k-*-coff*, m68020-*-elf*, m68k-*-elf*)"}, {"sha": "393aec50989961e6bdf67180b1a669938604ca23", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5", "patch": "@@ -3832,13 +3832,13 @@ m68k_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n bool\n m68k_regno_mode_ok (int regno, enum machine_mode mode)\n {\n-  if (regno < 8)\n+  if (DATA_REGNO_P (regno))\n     {\n       /* Data Registers, can hold aggregate if fits in.  */\n       if (regno + GET_MODE_SIZE (mode) / 4 <= 8)\n \treturn true;\n     }\n-  else if (regno < 16)\n+  else if (ADDRESS_REGNO_P (regno))\n     {\n       /* Address Registers, can't hold bytes, can hold aggregate if\n \t fits in.  */\n@@ -3847,7 +3847,7 @@ m68k_regno_mode_ok (int regno, enum machine_mode mode)\n       if (regno + GET_MODE_SIZE (mode) / 4 <= 16)\n \treturn true;\n     }\n-  else if (regno < 24)\n+  else if (FP_REGNO_P (regno))\n     {\n       /* FPU registers, hold float or complex float of long double or\n \t smaller.  */"}, {"sha": "382a8bc074e514dd0edda08fa7750cd9611b796f", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=36e04090c1fe913d3f1a2d5bf2f8cc9c645083f5", "patch": "@@ -741,14 +741,33 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \n /* Macros to check register numbers against specific register classes.  */\n \n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-((REGNO) < 16 || (unsigned) reg_renumber[REGNO] < 16)\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-(((REGNO) ^ 010) < 8 || (unsigned) (reg_renumber[REGNO] ^ 010) < 8)\n-#define REGNO_OK_FOR_DATA_P(REGNO) \\\n-((REGNO) < 8 || (unsigned) reg_renumber[REGNO] < 8)\n-#define REGNO_OK_FOR_FP_P(REGNO) \\\n-(((REGNO) ^ 020) < 8 || (unsigned) (reg_renumber[REGNO] ^ 020) < 8)\n+/* True for data registers, D0 through D7.  */\n+#define DATA_REGNO_P(REGNO) ((unsigned int) (REGNO) < 8)\n+\n+/* True for address registers, A0 through A7.  */\n+#define ADDRESS_REGNO_P(REGNO) (((unsigned int) (REGNO) - 8) < 8)\n+\n+/* True for integer registers, D0 through D7 and A0 through A7.  */\n+#define INT_REGNO_P(REGNO) ((unsigned int) (REGNO) < 16)\n+\n+/* True for floating point registers, FP0 through FP7.  */\n+#define FP_REGNO_P(REGNO) (((unsigned int) (REGNO) - 16) < 8)\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\t\\\n+  (INT_REGNO_P (REGNO)\t\t\t\t\t\\\n+   || INT_REGNO_P (reg_renumber[REGNO]))\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\\\n+  (ADDRESS_REGNO_P (REGNO)\t\t\t\t\\\n+   || ADDRESS_REGNO_P (reg_renumber[REGNO]))\n+\n+#define REGNO_OK_FOR_DATA_P(REGNO)\t\t\t\\\n+  (DATA_REGNO_P (REGNO)\t\t\t\t\t\\\n+   || DATA_REGNO_P (reg_renumber[REGNO]))\n+\n+#define REGNO_OK_FOR_FP_P(REGNO)\t\t\t\\\n+  (FP_REGNO_P (REGNO)\t\t\t\t\t\\\n+   || FP_REGNO_P (reg_renumber[REGNO]))\n \n /* Now macros that check whether X is a register and also,\n    strictly, whether it is in a specified class.\n@@ -793,10 +812,11 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) ((REGNO (X) ^ 020) >= 8)\n+#define REG_OK_FOR_INDEX_P(X) !FP_REGNO_P (REGNO (X))\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) ((REGNO (X) & ~027) != 0)\n+#define REG_OK_FOR_BASE_P(X) \\\n+  (!DATA_REGNO_P (REGNO (X)) && !FP_REGNO_P (REGNO (X)))\n \n #else\n \n@@ -1077,7 +1097,7 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n /* Describe how we implement __builtin_eh_return.  */\n #define EH_RETURN_DATA_REGNO(N) \\\n   ((N) < 2 ? (N) : INVALID_REGNUM)\n-#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 8)\n+#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, A0_REG)\n #define EH_RETURN_HANDLER_RTX\t\t\t\t\t    \\\n   gen_rtx_MEM (Pmode,\t\t\t\t\t\t    \\\n \t       gen_rtx_PLUS (Pmode, arg_pointer_rtx,\t\t    \\"}]}