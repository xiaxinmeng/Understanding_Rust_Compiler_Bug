{"sha": "c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM0ZDUzNzQwYWYyZDg1ZTZmOWJmYmQxZjc1OTNhYmEwZWExY2FlNA==", "commit": {"author": {"name": "Michael Hayes", "email": "mph@paradise.net.nz", "date": "2000-07-30T10:35:03Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-07-30T10:35:03Z"}, "message": "basic-block.h (struct loops): New field rc_order.\n\n\t* basic-block.h (struct loops): New field rc_order.\n\t* flow.c (flow_loops_cfg_dump): Dump rc_order if computed.\n\t(flow_loops_free): Free rc_order.\n\t(flow_depth_first_order_compute): New parameter rc_order.\n\t(flow_loops_find): Allocate rc_order and swap usage with\n \tdfs_order.\n\nFrom-SVN: r35342", "tree": {"sha": "db2375f02ef87d269340221bf59afa90e17b4896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db2375f02ef87d269340221bf59afa90e17b4896"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4/comments", "author": null, "committer": null, "parents": [{"sha": "52695ce05ba7da1fd8b657c6da2c74b548f1dc57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52695ce05ba7da1fd8b657c6da2c74b548f1dc57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52695ce05ba7da1fd8b657c6da2c74b548f1dc57"}], "stats": {"total": 61, "additions": 49, "deletions": 12}, "files": [{"sha": "a90b9fc426ff0e01821eb8e1d62f38fcbf8928ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4", "patch": "@@ -1,3 +1,12 @@\n+2000-07-25  Michael Hayes  <mph@paradise.net.nz>\n+\n+\t* basic-block.h (struct loops): New field rc_order.\n+\t* flow.c (flow_loops_cfg_dump): Dump rc_order if computed.\n+\t(flow_loops_free): Free rc_order.\n+\t(flow_depth_first_order_compute): New parameter rc_order.\n+\t(flow_loops_find): Allocate rc_order and swap usage with\n+ \tdfs_order.\n+\n 2000-07-30 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n \t   Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n "}, {"sha": "084d56d5281351505d80e39e84defe76e37c2063", "filename": "gcc/basic-block.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4", "patch": "@@ -246,6 +246,7 @@ extern void tidy_fallthru_edge\t\tPARAMS ((edge, basic_block,\n /* Structure to hold information for each natural loop.  */\n struct loop\n {\n+  /* Index into loops array.  */\n   int num;\n \n   /* Basic block of loop header.  */\n@@ -369,6 +370,10 @@ struct loops\n \n     /* The ordering of the basic blocks in a depth first search.  */\n     int *dfs_order;\n+\n+    /* The reverse completion ordering of the basic blocks found in a\n+       depth first search.  */\n+    int *rc_order;\n   } cfg;\n \n   /* Headers shared by multiple loops that should be merged.  */"}, {"sha": "0d27ed9a97731a46f7622b44a9e97ab8f0b14536", "filename": "gcc/flow.c", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=c34d53740af2d85e6f9bfbd1f7593aba0ea1cae4", "patch": "@@ -397,7 +397,7 @@ static void flow_loops_cfg_dump\t\tPARAMS ((const struct loops *, FILE *));\n static int flow_loop_nested_p\t\tPARAMS ((struct loop *, struct loop *));\n static int flow_loop_exits_find\t\tPARAMS ((const sbitmap, edge **));\n static int flow_loop_nodes_find\tPARAMS ((basic_block, basic_block, sbitmap));\n-static int flow_depth_first_order_compute PARAMS ((int *));\n+static int flow_depth_first_order_compute PARAMS ((int *, int *));\n static basic_block flow_loop_pre_header_find PARAMS ((basic_block, const sbitmap *));\n static void flow_loop_tree_node_add\tPARAMS ((struct loop *, struct loop *));\n static void flow_loops_tree_build\tPARAMS ((struct loops *));\n@@ -7070,6 +7070,14 @@ flow_loops_cfg_dump (loops, file)\n \tfprintf (file, \"%d \", loops->cfg.dfs_order[i]);\n       fputs (\"\\n\", file);\n     }\n+  /* Dump the reverse completion node order.  */\n+  if (loops->cfg.rc_order)\n+    {\n+      fputs (\";; RC order: \", file);\n+      for (i = 0; i < n_basic_blocks; i++)\n+\tfprintf (file, \"%d \", loops->cfg.rc_order[i]);\n+      fputs (\"\\n\", file);\n+    }\n }\n \n \n@@ -7135,7 +7143,8 @@ flow_loops_dump (loops, file, verbose)\n \t\t     must be disjoint.  */\n \t\t  disjoint = ! flow_loop_nested_p (smaller ? loop : oloop,\n \t\t\t\t\t\t   smaller ? oloop : loop);\n-\t\t  fprintf (file, \";; loop header %d shared by loops %d, %d %s\\n\",\n+\t\t  fprintf (file, \n+\t\t\t   \";; loop header %d shared by loops %d, %d %s\\n\",\n \t\t\t   loop->header->index, i, j,\n \t\t\t   disjoint ? \"disjoint\" : \"nested\");\n \t\t}\n@@ -7307,16 +7316,20 @@ flow_loop_nodes_find (header, latch, nodes)\n \n \n /* Compute the depth first search order and store in the array\n-   DFS_ORDER, marking the nodes visited in VISITED.  Returns the\n-   number of nodes visited.  A depth first search tries to get as far\n-   away from the starting point as quickly as possible.  */\n+  DFS_ORDER if non-zero, marking the nodes visited in VISITED.  If\n+  RC_ORDER is non-zero, return the reverse completion number for each\n+  node.  Returns the number of nodes visited.  A depth first search\n+  tries to get as far away from the starting point as quickly as\n+  possible.  */\n static int\n-flow_depth_first_order_compute (dfs_order)\n+flow_depth_first_order_compute (dfs_order, rc_order)\n      int *dfs_order;\n+     int *rc_order;\n {\n   edge *stack;\n   int sp;\n   int dfsnum = 0;\n+  int rcnum = n_basic_blocks - 1;\n   sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n@@ -7348,6 +7361,9 @@ flow_depth_first_order_compute (dfs_order)\n \t{\n \t  /* Mark that we have visited the destination.  */\n \t  SET_BIT (visited, dest->index);\n+\t  \n+\t  if (dfs_order)\n+\t    dfs_order[dfsnum++] = dest->index;\n \n  \t  if (dest->succ)\n  \t    {\n@@ -7358,17 +7374,19 @@ flow_depth_first_order_compute (dfs_order)\n  \t  else\n  \t    {\n  \t      /* There are no successors for the DEST node so assign\n- \t\t its DFS number.  */\n- \t      dfs_order[n_basic_blocks - ++dfsnum] = dest->index;\n+ \t\t its reverse completion number.  */\n+\t      if (rc_order)\n+\t\trc_order[rcnum--] = dest->index;\n  \t    }\n \t}\n       else\n \t{\n \t  if (! e->succ_next && src != ENTRY_BLOCK_PTR)\n   \t    {\n  \t      /* There are no more successors for the SRC node\n- \t\t so assign its DFS number.  */\n- \t      dfs_order[n_basic_blocks - ++dfsnum] = src->index;\n+ \t\t so assign its reverse completion number.  */\n+\t      if (rc_order)\n+\t\trc_order[rcnum--] = src->index;\n   \t    }\n \t  \n \t  if (e->succ_next)\n@@ -7557,11 +7575,13 @@ flow_loops_find (loops)\n   sbitmap headers;\n   sbitmap *dom;\n   int *dfs_order;\n+  int *rc_order;\n   \n   loops->num = 0;\n   loops->array = NULL;\n   loops->tree = NULL;\n   dfs_order = NULL;\n+  rc_order = NULL;\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n@@ -7602,7 +7622,8 @@ flow_loops_find (loops)\n       /* Compute depth first search order of the CFG so that outer\n \t natural loops will be found before inner natural loops.  */\n       dfs_order = (int *) xmalloc (n_basic_blocks * sizeof (int));\n-      flow_depth_first_order_compute (dfs_order);\n+      rc_order = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+      flow_depth_first_order_compute (dfs_order, rc_order);\n \n       /* Allocate loop structures.  */\n       loops->array\n@@ -7623,7 +7644,7 @@ flow_loops_find (loops)\n \n \t  /* Search the nodes of the CFG in DFS order that we can find\n \t     outer loops first.  */\n-\t  header = BASIC_BLOCK (dfs_order[b]);\n+\t  header = BASIC_BLOCK (rc_order[b]);\n \t  \n \t  /* Look for all the possible latch blocks for this header.  */\n \t  for (e = header->pred; e; e = e->pred_next)\n@@ -7645,6 +7666,7 @@ flow_loops_find (loops)\n \t\t  \n \t\t  loop->header = header;\n \t\t  loop->latch = latch;\n+\t\t  loop->num = num_loops;\n \t\t  \n \t\t  /* Keep track of blocks that are loop headers so\n \t\t     that we can tell which loops should be merged.  */\n@@ -7696,6 +7718,7 @@ flow_loops_find (loops)\n   /* Save CFG derived information to avoid recomputing it.  */\n   loops->cfg.dom = dom;\n   loops->cfg.dfs_order = dfs_order;\n+  loops->cfg.rc_order = rc_order;\n \n   /* Build the loop hierarchy tree.  */\n   flow_loops_tree_build (loops);"}]}