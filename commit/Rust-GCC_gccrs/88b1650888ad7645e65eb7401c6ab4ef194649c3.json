{"sha": "88b1650888ad7645e65eb7401c6ab4ef194649c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhiMTY1MDg4OGFkNzY0NWU2NWViNzQwMWM2YWI0ZWYxOTQ2NDljMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-02-18T16:12:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-02-18T16:12:52Z"}, "message": "ipa-devirt.c (odr_subtypes_equivalent_p): Fix formating.\n\n\n\t* ipa-devirt.c (odr_subtypes_equivalent_p): Fix formating.\n\t(compare_virtual_tables): Be smarter about skipping typeinfos;\n\tdo sane output on virtual table table mismatch.\n\t(warn_odr): Be ready for forward declarations of enums;\n\toutput sane info on base mismatch and virtual table mismatch.\n\t(add_type_duplicate): Fix code choosing prevailing type; do not ICE\n\twhen only one type is polymorphic.\n\t(get_odr_type): Fix hashtable corruption.\n\t(dump_odr_type): Dump mangled names.\n\nFrom-SVN: r220790", "tree": {"sha": "6d7fe4978dad3e4785678d28d8e7678aca3f36d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d7fe4978dad3e4785678d28d8e7678aca3f36d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88b1650888ad7645e65eb7401c6ab4ef194649c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b1650888ad7645e65eb7401c6ab4ef194649c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b1650888ad7645e65eb7401c6ab4ef194649c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b1650888ad7645e65eb7401c6ab4ef194649c3/comments", "author": null, "committer": null, "parents": [{"sha": "196904d81317875a5ba0d89693384e6da33be785", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/196904d81317875a5ba0d89693384e6da33be785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/196904d81317875a5ba0d89693384e6da33be785"}], "stats": {"total": 285, "additions": 222, "deletions": 63}, "files": [{"sha": "edf5a0593220cb6dbd3d6735de2a83298a5fb67b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b1650888ad7645e65eb7401c6ab4ef194649c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b1650888ad7645e65eb7401c6ab4ef194649c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88b1650888ad7645e65eb7401c6ab4ef194649c3", "patch": "@@ -1,3 +1,15 @@\n+2015-02-18  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c (odr_subtypes_equivalent_p): Fix formating.\n+\t(compare_virtual_tables): Be smarter about skipping typeinfos;\n+\tdo sane output on virtual table table mismatch.\n+\t(warn_odr): Be ready for forward declarations of enums;\n+\toutput sane info on base mismatch and virtual table mismatch.\n+\t(add_type_duplicate): Fix code choosing prevailing type; do not ICE\n+\twhen only one type is polymorphic.\n+\t(get_odr_type): Fix hashtable corruption.\n+\t(dump_odr_type): Dump mangled names.\n+\n 2015-02-18  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/65063"}, {"sha": "c3f8b156a55f201221c16008431f8ed2145dcf41", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 210, "deletions": 63, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b1650888ad7645e65eb7401c6ab4ef194649c3/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b1650888ad7645e65eb7401c6ab4ef194649c3/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=88b1650888ad7645e65eb7401c6ab4ef194649c3", "patch": "@@ -551,7 +551,8 @@ set_type_binfo (tree type, tree binfo)\n /* Compare T2 and T2 based on name or structure.  */\n \n static bool\n-odr_subtypes_equivalent_p (tree t1, tree t2, hash_set<type_pair,pair_traits> *visited)\n+odr_subtypes_equivalent_p (tree t1, tree t2,\n+\t\t\t   hash_set<type_pair,pair_traits> *visited)\n {\n   bool an1, an2;\n \n@@ -618,7 +619,8 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t  prevailing = vtable;\n \t  vtable = tmp;\n \t}\n-      if (warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n+      if (warning_at (DECL_SOURCE_LOCATION\n+\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n \t\t      OPT_Wodr,\n \t\t      \"virtual table of type %qD violates one definition rule\",\n \t\t      DECL_CONTEXT (vtable->decl)))\n@@ -633,39 +635,118 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n     {\n       struct ipa_ref *ref1, *ref2;\n       bool end1, end2;\n+\n       end1 = !prevailing->iterate_reference (n1, ref1);\n       end2 = !vtable->iterate_reference (n2, ref2);\n-      if (end1 && end2)\n-\treturn;\n-      if (!end1 && !end2\n-\t  && DECL_ASSEMBLER_NAME (ref1->referred->decl)\n-\t     != DECL_ASSEMBLER_NAME (ref2->referred->decl)\n-\t  && !n2\n-\t  && !DECL_VIRTUAL_P (ref2->referred->decl)\n-\t  && DECL_VIRTUAL_P (ref1->referred->decl))\n+\n+      /* !DECL_VIRTUAL_P means RTTI entry;\n+\t We warn when RTTI is lost because non-RTTI previals; we silently\n+\t accept the other case.  */\n+      while (!end2\n+\t     && (end1\n+\t         || (DECL_ASSEMBLER_NAME (ref1->referred->decl)\n+\t\t     != DECL_ASSEMBLER_NAME (ref2->referred->decl)\n+\t             && DECL_VIRTUAL_P (ref1->referred->decl)))\n+\t     && !DECL_VIRTUAL_P (ref2->referred->decl))\n \t{\n-\t  if (warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n+\t  if (warning_at (DECL_SOURCE_LOCATION\n+\t\t\t    (TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n \t\t\t  \"virtual table of type %qD contains RTTI information\",\n \t\t\t  DECL_CONTEXT (vtable->decl)))\n \t    {\n-\t      inform (DECL_SOURCE_LOCATION (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n-\t\t      \"but is prevailed by one without from other translation unit\");\n-\t      inform (DECL_SOURCE_LOCATION (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t      inform (DECL_SOURCE_LOCATION\n+\t\t\t(TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t      \"but is prevailed by one without from other translation \"\n+\t\t      \"unit\");\n+\t      inform (DECL_SOURCE_LOCATION\n+\t\t\t(TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n \t\t      \"RTTI will not work on this type\");\n \t    }\n \t  n2++;\n           end2 = !vtable->iterate_reference (n2, ref2);\n \t}\n-      if (!end1 && !end2\n-\t  && DECL_ASSEMBLER_NAME (ref1->referred->decl)\n-\t     != DECL_ASSEMBLER_NAME (ref2->referred->decl)\n-\t  && !n1\n-\t  && !DECL_VIRTUAL_P (ref1->referred->decl)\n-\t  && DECL_VIRTUAL_P (ref2->referred->decl))\n+      while (!end1\n+\t     && (end2\n+\t         || (DECL_ASSEMBLER_NAME (ref2->referred->decl)\n+\t\t     != DECL_ASSEMBLER_NAME (ref1->referred->decl)\n+\t             && DECL_VIRTUAL_P (ref2->referred->decl)))\n+\t     && !DECL_VIRTUAL_P (ref1->referred->decl))\n \t{\n \t  n1++;\n           end1 = !vtable->iterate_reference (n1, ref1);\n \t}\n+\n+      /* Finished?  */\n+      if (end1 && end2)\n+\t{\n+\t  /* Extra paranoia; compare the sizes.  We do not have information\n+\t     about virtual inheritance offsets, so just be sure that these\n+\t     match.  \n+\t     Do this as very last check so the not very informative error\n+\t     is not output too often.  */\n+\t  if (DECL_SIZE (prevailing->decl) != DECL_SIZE (vtable->decl))\n+\t    {\n+\t      if (warning_at (DECL_SOURCE_LOCATION\n+\t\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n+\t\t\t      \"virtual table of type %qD violates \"\n+\t\t\t      \"one definition rule  \",\n+\t\t\t      DECL_CONTEXT (vtable->decl)))\n+\t\t{\n+\t\t  inform (DECL_SOURCE_LOCATION \n+\t\t\t    (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t\t  \"the conflicting type defined in another translation \"\n+\t\t\t  \"unit has virtual table of different size\");\n+\t\t}\n+\t    }\n+\t  return;\n+\t}\n+\n+      if (!end1 && !end2)\n+\t{\n+\t  if (DECL_ASSEMBLER_NAME (ref1->referred->decl)\n+\t      == DECL_ASSEMBLER_NAME (ref2->referred->decl))\n+\t    continue;\n+\n+\t  /* If the loops above stopped on non-virtual pointer, we have\n+\t     mismatch in RTTI information mangling.  */\n+\t  if (!DECL_VIRTUAL_P (ref1->referred->decl)\n+\t      && !DECL_VIRTUAL_P (ref2->referred->decl))\n+\t    {\n+\t      if (warning_at (DECL_SOURCE_LOCATION\n+\t\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n+\t\t\t      \"virtual table of type %qD violates \"\n+\t\t\t      \"one definition rule  \",\n+\t\t\t      DECL_CONTEXT (vtable->decl)))\n+\t\t{\n+\t\t  inform (DECL_SOURCE_LOCATION \n+\t\t\t    (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t\t  \"the conflicting type defined in another translation \"\n+\t\t\t  \"unit virtual table with different RTTI information\");\n+\t\t}\n+\t      return;\n+\t    }\n+\t  /* At this point both REF1 and REF2 points either to virtual table\n+\t     or virtual method.  If one points to virtual table and other to\n+\t     method we can complain the same way as if one table was shorter\n+\t     than other pointing out the extra method.  */\n+\t  gcc_assert (DECL_VIRTUAL_P (ref1->referred->decl)\n+\t\t      && (TREE_CODE (ref1->referred->decl) == FUNCTION_DECL\n+\t\t          || TREE_CODE (ref1->referred->decl) == VAR_DECL));\n+\t  gcc_assert (DECL_VIRTUAL_P (ref2->referred->decl)\n+\t\t      && (TREE_CODE (ref2->referred->decl) == FUNCTION_DECL\n+\t\t          || TREE_CODE (ref2->referred->decl) == VAR_DECL));\n+\t  if (TREE_CODE (ref1->referred->decl)\n+\t      != TREE_CODE (ref2->referred->decl))\n+\t    {\n+\t      if (TREE_CODE (ref1->referred->decl) == VAR_DECL)\n+\t\tend1 = true;\n+\t      else if (TREE_CODE (ref2->referred->decl) == VAR_DECL)\n+\t\tend2 = true;\n+\t    }\n+\t}\n+\n+      /* Complain about size mismatch.  Either we have too many virutal\n+ \t functions or too many virtual table pointers.  */\n       if (end1 || end2)\n \t{\n \t  if (end1)\n@@ -681,37 +762,56 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t\t\t  \"one definition rule\",\n \t\t\t  DECL_CONTEXT (vtable->decl)))\n \t    {\n-\t      inform (DECL_SOURCE_LOCATION\n-\t\t       (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n-\t\t      \"the conflicting type defined in another translation \"\n-\t\t      \"unit\");\n-\t      inform (DECL_SOURCE_LOCATION\n-\t\t        (TYPE_NAME (DECL_CONTEXT (ref1->referring->decl))),\n-\t\t      \"contains additional virtual method %qD\",\n-\t\t      ref1->referred->decl);\n+\t      if (TREE_CODE (ref1->referring->decl) == FUNCTION_DECL)\n+\t\t{\n+\t\t  inform (DECL_SOURCE_LOCATION\n+\t\t\t   (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t\t  \"the conflicting type defined in another translation \"\n+\t\t\t  \"unit\");\n+\t\t  inform (DECL_SOURCE_LOCATION\n+\t\t\t    (TYPE_NAME (DECL_CONTEXT (ref1->referring->decl))),\n+\t\t\t  \"contains additional virtual method %qD\",\n+\t\t\t  ref1->referred->decl);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  inform (DECL_SOURCE_LOCATION\n+\t\t\t   (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t\t  \"the conflicting type defined in another translation \"\n+\t\t\t  \"unit has virtual table table with more entries\");\n+\t\t}\n \t    }\n \t  return;\n \t}\n-      if (DECL_ASSEMBLER_NAME (ref1->referred->decl)\n-\t  != DECL_ASSEMBLER_NAME (ref2->referred->decl))\n+\n+      /* And in the last case we have either mistmatch in between two virtual\n+\t methods or two virtual table pointers.  */\n+      if (warning_at (DECL_SOURCE_LOCATION\n+\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n+\t\t      \"virtual table of type %qD violates \"\n+\t\t      \"one definition rule  \",\n+\t\t      DECL_CONTEXT (vtable->decl)))\n \t{\n-\t  if (warning_at (DECL_SOURCE_LOCATION\n-\t\t\t    (TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n-\t\t\t  \"virtual table of type %qD violates \"\n-\t\t\t  \"one definition rule  \",\n-\t\t\t  DECL_CONTEXT (vtable->decl)))\n+\t  if (TREE_CODE (ref1->referred->decl) == FUNCTION_DECL)\n \t    {\n \t      inform (DECL_SOURCE_LOCATION \n \t\t\t(TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n \t\t      \"the conflicting type defined in another translation \"\n \t\t      \"unit\");\n+\t      gcc_assert (TREE_CODE (ref2->referred->decl)\n+\t\t\t  == FUNCTION_DECL);\n \t      inform (DECL_SOURCE_LOCATION (ref1->referred->decl),\n \t\t      \"virtual method %qD\", ref1->referred->decl);\n \t      inform (DECL_SOURCE_LOCATION (ref2->referred->decl),\n \t\t      \"ought to match virtual method %qD but does not\",\n \t\t      ref2->referred->decl);\n-\t      return;\n \t    }\n+\t  else\n+\t    inform (DECL_SOURCE_LOCATION \n+\t\t      (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t    \"the conflicting type defined in another translation \"\n+\t\t    \"unit has virtual table table with different contents\");\n+\t  return;\n \t}\n     }\n }\n@@ -727,6 +827,8 @@ warn_odr (tree t1, tree t2, tree st1, tree st2,\n \t  bool warn, bool *warned, const char *reason)\n {\n   tree decl2 = TYPE_NAME (t2);\n+  if (warned)\n+    *warned = false;\n \n   if (!warn)\n     return;\n@@ -840,7 +942,8 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n       return false;\n     }\n \n-  if (TREE_CODE (t1) == ENUMERAL_TYPE)\n+  if (TREE_CODE (t1) == ENUMERAL_TYPE\n+      && TYPE_VALUES (t1) && TYPE_VALUES (t2))\n     {\n       tree v1, v2;\n       for (v1 = TYPE_VALUES (t1), v2 = TYPE_VALUES (t2);\n@@ -1056,8 +1159,20 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t  f2 = TREE_CHAIN (f2);\n \t\tif (!f1 || !f2)\n \t\t  break;\n+\t\tif (DECL_VIRTUAL_P (f1) != DECL_VIRTUAL_P (f2))\n+\t\t  {\n+\t\t    warn_odr (t1, t2, NULL, NULL, warn, warned,\n+\t\t\t      G_(\"a type with different virtual table pointers\"\n+\t\t\t         \" is defined in another translation unit\"));\n+\t\t    return false;\n+\t\t  }\n \t\tif (DECL_ARTIFICIAL (f1) != DECL_ARTIFICIAL (f2))\n-\t\t  break;\n+\t\t  {\n+\t\t    warn_odr (t1, t2, NULL, NULL, warn, warned,\n+\t\t\t      G_(\"a type with different bases is defined \"\n+\t\t\t\t \"in another translation unit\"));\n+\t\t    return false;\n+\t\t  }\n \t\tif (DECL_NAME (f1) != DECL_NAME (f2)\n \t\t    && !DECL_ARTIFICIAL (f1))\n \t\t  {\n@@ -1066,10 +1181,11 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t\t\t \"in another translation unit\"));\n \t\t    return false;\n \t\t  }\n-\t\tif (!odr_subtypes_equivalent_p (TREE_TYPE (f1), TREE_TYPE (f2), visited))\n+\t\tif (!odr_subtypes_equivalent_p (TREE_TYPE (f1),\n+\t\t\t\t\t\tTREE_TYPE (f2), visited))\n \t\t  {\n-\t\t    /* Do not warn about artificial fields and just go into generic\n-\t\t       field mismatch warning.  */\n+\t\t    /* Do not warn about artificial fields and just go into\n+ \t\t       generic field mismatch warning.  */\n \t\t    if (DECL_ARTIFICIAL (f1))\n \t\t      break;\n \n@@ -1082,11 +1198,11 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t  }\n \t\tif (!gimple_compare_field_offset (f1, f2))\n \t\t  {\n-\t\t    /* Do not warn about artificial fields and just go into generic\n-\t\t       field mismatch warning.  */\n+\t\t    /* Do not warn about artificial fields and just go into\n+\t\t       generic field mismatch warning.  */\n \t\t    if (DECL_ARTIFICIAL (f1))\n \t\t      break;\n-\t\t    warn_odr (t1, t2, t1, t2, warn, warned,\n+\t\t    warn_odr (t1, t2, f1, f2, warn, warned,\n \t\t\t      G_(\"fields has different layout \"\n \t\t\t\t \"in another translation unit\"));\n \t\t    return false;\n@@ -1099,18 +1215,18 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t       are not the same.  */\n \t    if (f1 || f2)\n \t      {\n-\t\tif (f1 && DECL_ARTIFICIAL (f1))\n-\t\t  f1 = NULL;\n-\t\tif (f2 && DECL_ARTIFICIAL (f2))\n-\t\t  f2 = NULL;\n-\t\tif (f1 || f2)\n-\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n-\t\t\t    G_(\"a type with different number of fields \"\n-\t\t\t       \"is defined in another translation unit\"));\n-\t\t/* Ideally we should never get this generic message.  */\n+\t\tif ((f1 && DECL_VIRTUAL_P (f1)) || (f2 && DECL_VIRTUAL_P (f2)))\n+\t\t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n+\t\t\t    G_(\"a type with different virtual table pointers\"\n+\t\t\t       \" is defined in another translation unit\"));\n+\t\tif ((f1 && DECL_ARTIFICIAL (f1))\n+\t\t    || (f2 && DECL_ARTIFICIAL (f2)))\n+\t\t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n+\t\t\t    G_(\"a type with different bases is defined \"\n+\t\t\t       \"in another translation unit\"));\n \t\telse\n \t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n-\t\t\t    G_(\"a type with different memory representation \"\n+\t\t\t    G_(\"a type with different number of fields \"\n \t\t\t       \"is defined in another translation unit\"));\n \t\t\n \t\treturn false;\n@@ -1207,12 +1323,24 @@ add_type_duplicate (odr_type val, tree type)\n     val->types_set = new hash_set<tree>;\n \n   /* Always prefer complete type to be the leader.  */\n-  if ((!COMPLETE_TYPE_P (val->type) || !TYPE_BINFO (val->type))\n-      && (COMPLETE_TYPE_P (type) && TYPE_BINFO (val->type)))\n+\n+  if (!COMPLETE_TYPE_P (val->type) && COMPLETE_TYPE_P (type))\n+    build_bases = true;\n+  else if (COMPLETE_TYPE_P (val->type) && !COMPLETE_TYPE_P (type))\n+    ;\n+  else if (TREE_CODE (val->type) == ENUMERAL_TYPE\n+\t   && TREE_CODE (type) == ENUMERAL_TYPE\n+\t   && !TYPE_VALUES (val->type) && TYPE_VALUES (type))\n+    build_bases = true;\n+  else if (TREE_CODE (val->type) == RECORD_TYPE\n+\t   && TREE_CODE (type) == RECORD_TYPE\n+\t   && TYPE_BINFO (type) && !TYPE_BINFO (val->type))\n+    build_bases = true;\n+\n+  if (build_bases)\n     {\n       tree tmp = type;\n \n-      build_bases = true;\n       type = val->type;\n       val->type = tmp;\n     }\n@@ -1303,11 +1431,14 @@ add_type_duplicate (odr_type val, tree type)\n \t\tif (base_mismatch)\n \t\t  {\n \t\t    if (!warned && !val->odr_violated)\n-\t\t      warn_odr (type, val->type, NULL, NULL,\n-\t\t\t\t!warned, &warned,\n-\t\t\t\t\"a type with the same name but different base \"\n-\t\t\t\t\"type is defined in another translation unit\");\n-\t\t    warn_types_mismatch (type1, type2);\n+\t\t      {\n+\t\t\twarn_odr (type, val->type, NULL, NULL,\n+\t\t\t\t  !warned, &warned,\n+\t\t\t\t  \"a type with the same name but different base \"\n+\t\t\t\t  \"type is defined in another translation unit\");\n+\t\t\tif (warned)\n+\t\t\t  warn_types_mismatch (type1, type2);\n+\t\t      }\n \t\t    break;\n \t\t  }\n \t\tif (BINFO_OFFSET (base1) != BINFO_OFFSET (base2))\n@@ -1320,6 +1451,18 @@ add_type_duplicate (odr_type val, tree type)\n \t\t\t\t\"layout is defined in another translation unit\");\n \t\t    break;\n \t\t  }\n+\t\t/* One base is polymorphic and the other not.\n+\t\t   This ought to be diagnosed earlier, but do not ICE in the\n+\t \t   checking bellow.  */\n+\t\tif (!TYPE_BINFO (type1) != !TYPE_BINFO (type2)\n+\t\t    || (TYPE_BINFO (type1)\n+\t\t\t&& polymorphic_type_binfo_p (TYPE_BINFO (type1))\n+\t\t           != polymorphic_type_binfo_p (TYPE_BINFO (type2))))\n+\t\t  {\n+\t\t    gcc_assert (val->odr_violated);\n+\t\t    base_mismatch = true;\n+\t\t    break;\n+\t\t  }\n \t      }\n #ifdef ENABLE_CHECKING\n \t  /* Sanity check that all bases will be build same way again.  */\n@@ -1468,6 +1611,7 @@ get_odr_type (tree type, bool insert)\n       val->anonymous_namespace = type_in_anonymous_namespace_p (type);\n       build_bases = COMPLETE_TYPE_P (val->type);\n       insert_to_odr_array = true;\n+      *slot = val;\n     }\n \n   if (build_bases && TREE_CODE (type) == RECORD_TYPE && TYPE_BINFO (type)\n@@ -1479,7 +1623,6 @@ get_odr_type (tree type, bool insert)\n       gcc_assert (BINFO_TYPE (TYPE_BINFO (val->type)) = type);\n   \n       val->all_derivations_known = type_all_derivations_known_p (type);\n-      *slot = val;\n       for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); i++)\n \t/* For now record only polymorphic types. other are\n \t   pointless for devirtualization and we can not precisely\n@@ -1557,6 +1700,10 @@ dump_odr_type (FILE *f, odr_type t, int indent=0)\n       fprintf (f, \"%*s defined at: %s:%i\\n\", indent * 2, \"\",\n \t       DECL_SOURCE_FILE (TYPE_NAME (t->type)),\n \t       DECL_SOURCE_LINE (TYPE_NAME (t->type)));\n+      if (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t->type)))\n+        fprintf (f, \"%*s mangled name: %s\\n\", indent * 2, \"\",\n+\t\t IDENTIFIER_POINTER\n+\t\t   (DECL_ASSEMBLER_NAME (TYPE_NAME (t->type))));\n     }\n   if (t->bases.length ())\n     {"}]}