{"sha": "3f803cd94cdc0aa589dc959da7d438437f992e04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y4MDNjZDk0Y2RjMGFhNTg5ZGM5NTlkYTdkNDM4NDM3Zjk5MmUwNA==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1995-12-22T20:24:09Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1995-12-22T20:24:09Z"}, "message": "(output_strlen_unroll): New function.\n\nFrom-SVN: r10830", "tree": {"sha": "bfe48f62f9915b14e15a440c44ba32edd0b93918", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfe48f62f9915b14e15a440c44ba32edd0b93918"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f803cd94cdc0aa589dc959da7d438437f992e04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f803cd94cdc0aa589dc959da7d438437f992e04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f803cd94cdc0aa589dc959da7d438437f992e04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f803cd94cdc0aa589dc959da7d438437f992e04/comments", "author": null, "committer": null, "parents": [{"sha": "f774631006fd20dec4465ad9f43e6c7194e13683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f774631006fd20dec4465ad9f43e6c7194e13683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f774631006fd20dec4465ad9f43e6c7194e13683"}], "stats": {"total": 191, "additions": 187, "deletions": 4}, "files": [{"sha": "3a40640857ef13d60528b0fa045e75689e2b4a1a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 187, "deletions": 4, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f803cd94cdc0aa589dc959da7d438437f992e04/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f803cd94cdc0aa589dc959da7d438437f992e04/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3f803cd94cdc0aa589dc959da7d438437f992e04", "patch": "@@ -195,8 +195,8 @@ override_options ()\n     if (! strcmp (ix86_cpu_string, processor_target_table[j].name))\n       {\n \tix86_cpu = processor_target_table[j].processor;\n-\tif (i > j)\n-\t  error (\"-mcpu=%s does not support -misa=%s\", ix86_cpu_string, ix86_isa_string);\n+\tif (i > j && (int)ix86_isa >= (int)PROCESSOR_PENTIUMPRO)\n+\t  error (\"-mcpu=%s does not support -march=%s\", ix86_cpu_string, ix86_isa_string);\n \n \ttarget_flags |= processor_target_table[j].target_enable;\n \ttarget_flags &= ~processor_target_table[j].target_disable;\n@@ -218,7 +218,7 @@ override_options ()\n \tfatal (\"-mregparm=%d is not between 0 and %d\", i386_regparm, REGPARM_MAX);\n     }\n \n-  def_align = (TARGET_386_ALIGNMENT) ? 2 : 4;\n+  def_align = (TARGET_386) ? 2 : 4;\n \n   /* Validate -malign-loops= value, or provide default */\n   if (i386_align_loops_string)\n@@ -1681,7 +1681,7 @@ function_epilogue (file, size)\n     {\n       /* If not an i386, mov & pop is faster than \"leave\". */\n \n-      if (TARGET_LEAVE)\n+      if (TARGET_USE_LEAVE)\n \toutput_asm_insn (\"leave\", xops);\n       else\n \t{\n@@ -3310,3 +3310,186 @@ assign_386_stack_local (mode, n)\n \n   return i386_stack_locals[(int) mode][n];\n }\n+\f\n+/* Output the approprate insns for doing strlen if not just doing repnz; scasb\n+\n+   operands[0] = result, initialized with the startaddress\n+   operands[1] = alignment of the address.\n+   operands[2] = scratch register, initialized with the startaddress when\n+   \t\t not aligned, otherwise undefined\n+\n+   This is just the body. It needs the initialisations mentioned above and\n+   some address computing at the end.  These things are done in i386.md.  */\n+\n+char *\n+output_strlen_unroll (operands)\n+     rtx operands[];\n+{\n+  rtx xops[18];\n+\n+  xops[0] = operands[0];\t\t/* Result */\n+  /*        operands[1];                 * Alignment */\n+  xops[1] = operands[2];\t\t/* Scratch */\n+  xops[2] = GEN_INT (0);\n+  xops[3] = GEN_INT (2);\n+  xops[4] = GEN_INT (3);\n+  xops[5] = GEN_INT (4);\n+  /* xops[6] = gen_label_rtx ();\t * label when aligned to 3-byte */\n+  /* xops[7] = gen_label_rtx ();\t * label when aligned to 2-byte */\n+  xops[8] = gen_label_rtx ();\t\t/* label of main loop */\n+  if(TARGET_USE_Q_REG && QI_REG_P (xops[1]))\n+    xops[9] = gen_label_rtx ();\t\t/* pentium optimisation */\n+  xops[10] = gen_label_rtx ();\t\t/* end label 2 */\n+  xops[11] = gen_label_rtx ();\t\t/* end label 1 */\n+  xops[12] = gen_label_rtx ();\t\t/* end label */\n+  /* xops[13]\t\t\t\t * Temporary used */\n+  xops[14] = GEN_INT (0xff);\n+  xops[15] = GEN_INT (0xff00);\n+  xops[16] = GEN_INT (0xff0000);\n+  xops[17] = GEN_INT (0xff000000);\n+\n+    /* Loop to check 1..3 bytes for null to get an aligned pointer */\n+\n+    /* is there a known alignment and is it less then 4 */\n+  if (GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) < 4)\n+    {\n+\t/* is there a known alignment and is it not 2 */\n+      if (GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) != 2)\n+\t{\n+\t  xops[6] = gen_label_rtx ();\t/* label when aligned to 3-byte */\n+\t  xops[7] = gen_label_rtx ();\t/* label when aligned to 2-byte */\n+\n+\t    /* leave just the 3 lower bits */\n+\t    /* if this is a q-register, then the high part is used later */\n+\t    /* therefore user andl rather than andb */\n+\t  output_asm_insn (AS2 (and%L1,%4,%1), xops);\n+\t    /* is aligned to 4-byte adress when zero */\n+\t  output_asm_insn (AS1 (je,%l8), xops);\n+\t    /* side-effect even Parity when %eax == 3 */\n+\t  output_asm_insn (AS1 (jp,%6), xops);\n+\n+\t    /* is it aligned to 2 bytes ? */\n+\t  if (QI_REG_P (xops[1]))\n+\t    output_asm_insn (AS2 (cmp%L1,%3,%1), xops);\n+\t  else\n+\t    output_asm_insn (AS2 (cmp%L1,%3,%1), xops);\n+\t  output_asm_insn (AS1 (je,%7), xops);\n+\t}\n+      else\n+        {\n+            /* since the alignment is 2, we have to check 2 or 0 bytes */\n+\n+\t    /* check if is aligned to 4 - byte */\n+\t  output_asm_insn (AS2 (and%L1,%3,%1), xops);\n+\t    /* is aligned to 4-byte adress when zero */\n+\t  output_asm_insn (AS1 (je,%l8), xops);\n+        }\n+\n+      xops[13] = gen_rtx (MEM, QImode, xops[0]);\n+\t/* now, compare the bytes */\n+\t/* compare with the high part of a q-reg gives shorter code */\n+      if (QI_REG_P (xops[1]))\n+        {\n+            /* compare the first n unaligned byte on a byte per byte basis */\n+          output_asm_insn (AS2 (cmp%B1,%h1,%13), xops);\n+            /* when zero we reached the end */\n+          output_asm_insn (AS1 (je,%l12), xops);\n+            /* increment the address */\n+          output_asm_insn (AS1 (inc%L0,%0), xops);\n+\n+\t    /* not needed with an alignment of 2 */\n+\t  if (GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) != 2)\n+\t    {\n+\t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (xops[7]));\n+\t      output_asm_insn (AS2 (cmp%B1,%h1,%13), xops);\n+\t      output_asm_insn (AS1 (je,%l12), xops);\n+\t      output_asm_insn (AS1 (inc%L0,%0), xops);\n+\n+\t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (xops[6]));\n+\t    }\n+          output_asm_insn (AS2 (cmp%B1,%h1,%13), xops);\n+        }\n+      else\n+        {\n+          output_asm_insn (AS2 (cmp%B13,%2,%13), xops);\n+          output_asm_insn (AS1 (je,%l12), xops);\n+          output_asm_insn (AS1 (inc%L0,%0), xops);\n+\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (xops[7]));\n+          output_asm_insn (AS2 (cmp%B13,%2,%13), xops);\n+          output_asm_insn (AS1 (je,%l12), xops);\n+          output_asm_insn (AS1 (inc%L0,%0), xops);\n+\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (xops[6]));\n+          output_asm_insn (AS2 (cmp%B13,%2,%13), xops);\n+        }\n+      output_asm_insn (AS1 (je,%l12), xops);\n+      output_asm_insn (AS1 (inc%L0,%0), xops);\n+    }\n+\n+    /* Generate loop to check 4 bytes at a time */\n+    /* IMHO it is not a good idea to align this loop.  It gives only */\n+    /* huge programms, but does not help to speed up */\n+  /* ASM_OUTPUT_LOOP_ALIGN (asm_out_file); */\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (xops[8]));\n+\n+  xops[13] = gen_rtx (MEM, SImode, xops[0]);\n+  output_asm_insn (AS2 (mov%L1,%13,%1), xops);\n+\n+  if (QI_REG_P (xops[1]))\n+    {\n+\t/* on i586 it is faster to compare the hi- and lo- part */\n+\t/* as a kind of lookahead.  If xoring both is zero, then one */\n+\t/* of both *could* be zero, otherwith none of both is zero */\n+\t/* this saves one instruction, on i486 this is slower */\n+\t/* testet with P-90, i486DX2-66, AMD486DX2-66 */\n+      if(TARGET_PENTIUM)\n+        {\n+\t  output_asm_insn (AS2 (test%B1,%h1,%b1), xops);\n+\t  output_asm_insn (AS1 (jne,%l9), xops);\n+        }\n+\n+\t/* check first byte */\n+      output_asm_insn (AS2 (test%B1,%b1,%b1), xops);\n+      output_asm_insn (AS1 (je,%l12), xops);\n+\n+\t/* check second byte */\n+      output_asm_insn (AS2 (test%B1,%h1,%h1), xops);\n+      output_asm_insn (AS1 (je,%l11), xops);\n+\n+      if(TARGET_PENTIUM)\n+          ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (xops[9]));\n+    }\n+  else\n+    {\n+\t/* check first byte */\n+      output_asm_insn (AS2 (test%L1,%14,%1), xops);\n+      output_asm_insn (AS1 (je,%l12), xops);\n+\n+\t/* check second byte */\n+      output_asm_insn (AS2 (test%L1,%15,%1), xops);\n+      output_asm_insn (AS1 (je,%l11), xops);\n+    }\n+\n+    /* check third byte */\n+  output_asm_insn (AS2 (test%L1,%16,%1), xops);\n+  output_asm_insn (AS1 (je,%l10), xops);\n+  \n+    /* check fourth byte and increment address */\n+  output_asm_insn (AS2 (add%L0,%5,%0), xops);\n+  output_asm_insn (AS2 (test%L1,%17,%1), xops);\n+  output_asm_insn (AS1 (jne,%l8), xops);\n+\n+    /* now generate fixups when the compare stops within a 4-byte word */\n+  output_asm_insn (AS2 (sub%L0,%4,%0), xops);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (xops[10]));\n+  output_asm_insn (AS1 (inc%L0,%0), xops);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (xops[11]));\n+  output_asm_insn (AS1 (inc%L0,%0), xops);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (xops[12]));\n+\n+  RET;\n+}"}]}