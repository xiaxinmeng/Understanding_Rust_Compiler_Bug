{"sha": "beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVlZDhmYzBiYjIzNTkwZmRmYTQ2NjVjM2FkNWIzY2E3ZWRiMTdmNw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2004-07-08T03:40:34Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2004-07-08T03:40:34Z"}, "message": "Introduce H8SX support.\n\n* expr.c (expand_strcpy): Renamed and moved to...\n* builtins.c (expand_movstr): ... here.  Tweak.\n(expand_builtin_strcpy): Adjust.  Use movstr if len can't be\ncomputed or has side effects.\n(expand_builtin_stpcpy): Likewise.  Use strcpy if return value is\nunused, or if mempcpy fails.  Adjust the return value in the\nlatter case.  Use movstr if everything else fails.\n* doc/md.texi (movstr): Document.\n(movmemM, clrmemM): Fix explanation of memory block operands.\n* config/h8300/h8300.md (stpcpy): Renamed to...\n(movstr): ... this.  Adjust.\n2004-07-07  Alexandre Oliva  <aoliva@redhat.com>\n* config/h8300/h8300.md: Rename movstr*, except for movstrict*, to\nmovmem* and clrstr* to clrmem*.\n2004-06-27  Alexandre Oliva  <aoliva@redhat.com>\n* config/h8300/h8300.c (h8300_reg_class_from_letter): Map 'D' to\nGENERAL_REGS, always.\n(h8300_swap_into_er6, h8300_swap_into_er6): Handle the case of\ngetting the stack pointer as addr.\n* config/h8300/h8300.h (PREDICATE_CODES): Remove constant rtxes\nfrom general_operand_dst.\n* config/h8300/h8300.md (movmd_internal_normal): New, normal-mode\nvariant of...\n(movmd_internal): ... this.  Add modes to operands.  Disparage `D'\ninstead of requiring it to match only before reload.\n(stpcpy_internal_normal): New, normal-mode variant of...\n(stpcpy_internal): ... this.  Add modes to operands.  Disparage\n`D' instead of requiring it to match only before reload.\n* config/h8300/h8300-protos.h (h8300_legitimate_address_p): Add\nmode argument.\n* config/h8300/h8300.h (GO_IF_LEGITIMATE_ADDRESS): Pass it to...\n* config/h8300/h8300.c (h8300_legitimate_address_p): Pass it to\nh8300_get_index.\n* config/h8300/h8300.md (attr type): Add call.\n(attr can_delay): If type is call, set it no.\n(call, call_value): Set type to call.\n2004-06-21  Alexandre Oliva  <aoliva@redhat.com>\n* config/h8300/h8300.md (logicalhi3_sn, logicalsi3_sn): New.\n2004-06-16  Alexandre Oliva  <aoliva@redhat.com>\n* tree.c (get_narrower): Don't narrow integral types into\nnon-integral types.\n* config/h8300/h8300.c (h8300_expand_epilogue): Initialize\nframe_size *before* the first use.\n* config/h8300/h8300.md (movstrictqi): Reintroduce post-increment\non input.\n(peephole2): Don't widen instructions that push SP.  Move\ndecrement of SP to the end of all stm-generating peepholes.\n2003-07-24  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.md (insv): Prefer to use AND to clear a bitfield\nand OR to set it to all ones.\n2003-07-24  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.md (can_delay): Default to \"no\" for bit branches.\n(call, call_value): Set can_delay to \"no\".\n2003-07-22  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.md (extzv): Make subreg check more robust.\n2003-07-21  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.md (*brabit): Remove.\n* config/h8300/h8300.md (*brabc, *brabs): Remove mode from\nzero_extract.  Use bit_memory_operand as the predicate for\noperand 1 and 'WU' as the constraint.  Check the difference\nbetween the base length and the final one when deciding which\ntype of branch to use.\n2003-07-21  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.md (extzv): Remove mode from operands 0 and 1.\nUse convert_move to extend the result for TARGET_H8300SX.  Check\nfor QImode memory references.  Optimize the case where the\ndestination is a paradoxical subreg.\n2003-07-21  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.md (*movsf_h8sx): Add an r <- G alternative.\n* config/h8300/h8300.md (andqi): Remove bclr from h8sx version.\n2003-07-21  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.md: Include mova.md\n(length_table): Add mova and mova_zero.\n* config/h8300/h8300.c (print_operand): Handle '%o'.  Print a length\nafter all constant addresses for '%R', '%X', '%T' and '%S'.\n(h8300_mova_length): New function.\n(h8300_insn_length_from_table): Use it to handle mova and mova_zero.\n* config/h8300/t-h8300 (mova.md): Generate from genmova.sh.  Add to\ndependencies for s-config, etc.\n* config/h8300/gemova.sh: New file.\n* config/h8300/mova.md: Generated.\n2003-07-20  Alexandre Oliva  <aoliva@redhat.com>\n* config/h8300/h8300.c (h8300_bitfield_length): New.\n(nibble_operand): Adjust.\n(h8300_binary_length): Handle conditional binary op.\n(h8300_insn_length_from_table): Handle bitfield and bitbranch.\n* config/h8300/h8300.h: Change constraints W# and Y# to P#>X and\nP#<X, respectively.  The original P is now IP4>X.  Introduced P#>0\nand P#<0, unused so far.  W and Y are now prefixes to multi-letter\nconstraints.  WU is introduced as a variant of U that requires a\nmem, and is therefore considered an EXTRA_MEMORY_CONSTRAINT.\n* config/h8300/h8300.md (attr type): Added bitbranch.\n(attr length_table): Added bitfield and bitbranch.\n(attr length): Compute bitbranch length.\n(andqi): Separate pattern for H8300SX.  Use bfld for loading the\nleast-significant bit of a byte.\n(brabit, brabc, brabs): New.\n(insv, extzv): Emit bfst and bfld on H8300SX.\n(bfld, bfst, seq, sne): New.\n(bstzhireg, cmpstz, bstz, bistz): New.\n(cmpcondbset, condbset, cmpcondbclr, condbclr): New.\n(cmpcondbsetreg, condbsetreg, cmpcondbclrreg, condbclrreg): New.\n2003-07-11  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.c (h8sx_binary_memory_operator): New function.\n(h8sx_unary_memory_operator): New function.\n* config/h8300/h8300.h (EXTRA_MEMORY_CONSTRAINT): Disable.\n(PREDICATE_CODES): Add h8sx_{unary,binary}_memory_operator.\n* config/h8300/h8300.md: Add peepholes to combine reloads and\narithmetic insns.\n2003-07-10  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h830.md (cmpqi): Use 'i' rather than 'n' in constraints.\n(*cmphi_h8300hs, *addqi3, *addhi3_h8sx, subhi3): Likewise.\n(and?i, ior?i, xor?i): Likewise.\n2003-07-10  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.c: Move enums and prototypes to head of file.\nVarious whitespace fixes.\n(h8300_constant_length): New function, split out from...\n(h8300_displacement_size): ...here.  Rename h8300_displacement_length.\n(h8300_classify_operand): Use IN_RANGE.\n(h8300_classify_operand): Use h8300_constant_length.\n(h8300_short_move_mem_p): Tighten size check.\n(h8sx_mergeable_memrefs_p): Tighten equality check.\n2003-06-30  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.h (TARGET_CPU_CPP_BUILTINS): Define __H8300SX__\nfor -msx.\n* config/h8300/crti.asm: Use .h8300sx or .h8300sxn for -msx code.\n* config/h8300/crtn.asm: Likewise.\n* config/h8300/lib1funcs.asm: Likewise.  Use 32-bit pointers\nif __H8300SX__ is defined.\n2003-06-27  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300-protos.h (h8300_get_index): Add mode parameter.\n* config/h8300/h8300.h (GO_IF_LEGITIMATE_ADDRESS): Update accordingly.\n(GO_IF_MODE_DEPENDENT_ADDRESS): Treat POST_DEC, PRE_INC and indexed\naddresses as mode-dependent.\n* config/h8300/h8300.c (print_operand_address): Update call to\nh8300_get_index.\n(h8300_get_index): Take a mode argument.  Rework to fix an\nearlier misunderstanding.\n2003-06-26  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.c (zero_extendqisi2): Force the source operand\ninto a register if TARGET_H8300SX.\n(*zero_extendqisi2_h8300hs, *extendqisi2_h8300): Disable for\nTARGET_H8300SX.  Also disable related define_splits.\n(*zero_extendqisi2_h8sx, *extendqisi2_h8sx): New patterns.\n2003-06-23  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.c (h8300_rtx_costs): Add h8sx handling.\n2003-06-20  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.h (OK_FOR_Z): New macro.\n(EXTRA_CONSTRAINT_STR): Check it.\n* config/h8300/h8300.c (h8300_classify_operand): Accept null\nclass arguments.\n(h8300_insn_length_from_table): Handle LENGTH_TABLE_MOV_IMM4.\n* config/h8300/h8300.md (length_table): Add mov_imm4.\n(movqi, movhi): Add Z <- W4 alternatives to h8sx patterns.\n2003-06-20  Richard Sandiford  <rsandifo@redhat.com>\n* genattrtab.c (write_eligible_delay): Allow candidate_insn to\nbe a label.\n* config/h8300/h8300.h (DELAY_SLOT_LENGTH): New macro.\n* config/h8300/h8300.c (h8300_reorg): New function.\n(TARGET_MACHINE_DEPENDENT_REORG): Define.\n* config/h8300/h8300.md (length): Subtract the length of the\ndelay slot from (pc) when checking the range of forward branches.\n(delay_slot, can_delay): New attributes.\n(define_delay): Add bra/s handling.\n(movmd_internal, return_h8sx, *return_1): Set can_delay to no.\n(jump): Add delayed-branch handling.\n2003-06-17  Richard Sandiford  <rsandifo@redhat.com>\n* expr.c (expand_strcpy): New function.\n* builtins.c (expand_builtin_strcpy): Fall back on expand_strcpy.\n(expand_builtin_stpcpy): Likewise.\n* config/h8300/h8300-protos.h (h8sx_split_movmd): Remove.\n(h8300_swap_into_er6, h8300_swap_out_of_er6): Declare.\n* config/h8300/h8300.c (h8300_reg_class_from_letter): Tweak 'd'\nhandling to improve register allocation for -fno-omit-frame-pointer.\n(h8sx_split_movmd): Delete, moving er6 handling into...\n(h8300_swap_into_er6, h8300_swap_out_of_er6): ...these new functions.\n* config/h8300/h8300.md (UNSPEC_STPCPY): New unspec constant.\n(movmd): Add calls to copy_rtx.\n(movmd_internal): In the second alternative, allow the initial and\nfinal destination registers to be different .  Update the splitter\naccordingly.  Call h8300_swap_into_er6 and h8300_swap_out_of_er6\ninstead of h8sx_split_movmd.\n(stpcpy, movsd): New expanders.\n(movsd_internal): New define_insn.\n2003-06-13  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300-protos.h (h8300_reg_class_from_letter): Declare.\n(h8sx_emit_movmd, h8sx_split_movmd): Declare.\n* config/h8300/h8300.h (reg_class): Add COUNTER_REGS, SOURCE_REGS\nand DESTINATION_REGS.\n(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update accordingly.\n(REGNO_REG_CLASS): Map er4, er5 and er6 to the new classes.\n(REG_CLASS_FROM_LETTER): Use h8300_reg_class_from_letter.\n(h8300_move_ratio): Declare.\n(MOVE_RATIO): Use it.\n* config/h8300/h8300.c (h8300_move_ratio): New variable.\n(h8300_init_once): Initialize it.\n(h8300_reg_class_from_letter): New function.\n(print_operand): Add an 'm' prefix for printing \".b\", \".w\" or \".l\".\n(h8sx_emit_movmd, h8sx_split_movmd): New functions.\n* config/h8300/h8300.md (UNSPEC_MOVMD): New unspec constant.\n(COUNTER_REG, SOURCE_REG, DESTINATION_REG): New register constants.\n(movstrsi, movmd): New expanders.\n(movmd_internal): New insn.\n2003-06-06  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.h (EXTRA_MEMORY_CONSTRAINT): Define.\n2003-06-04  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/elf.h (LINK_SPEC): Use -m h8300sxnelf for -msx -mn.\n* config/h8300/h8300.c (asm_file_start): Use .h8300sxn likewise.\n2003-06-03  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.c (nibble_operand): Fix warning.\n* config/h8300/h8300.md (movstricthi): Set adjust_length to no.\n(movsi_h8sx): Likewise here and the normal h8sx movhi pattern.\n(movsf_h8300h): Disable for TARGET_H8300SX.\n2003-06-03  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.h (PREDICATE_CODES): Add h8300_ldm_parallel,\nh8300_stm_parallel and h8300_return_parallel.\n* config/h8300/h8300.c (h8300_push_pop, h8300_stack_offset_p,\nh8300_ldm_stm_regno, h8300_ldm_stm_parallel, h8300_ldm_parallel,\nh8300_stm_parallel, h8300_return_parallel): New functions.\n(h8300_expand_prologue): Don't enforce ldm/stm register alignment\nif TARGET_H8300SX.  Use h8300_push_pop.\n(h8300_expand_epilogue): Likewise.  Try to merge the return insn\nand final pop when generating h8sx code.  Always emit some form\nof return insn.\n* config/h8300/h8300.md: Don't enforce register alignment in\nstm peepholes if TARGET_H8300SX.\n(ldm_h8300s, stm_h8300s, return_h8sx): New patterns.\n(ldm_h8300s_[234], stm_h8300_[234]): Disable.\n(epilogue): Expect h8300_expand_epilogue to emit a return insn.\n2003-06-03  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/t-h8300 (MULTILIB_OPTIONS): Add a -msx multilib.\n(MULTILIB_DIRNAMES): Add a directory for it.\n(MULTILIB_MATCHES): Delete.\n2003-05-28  Richard Sandiford  <rsandifo@redhat.com>\n* final.c (walk_alter_subreg): Handle addresses with subregs\ninside a ZERO_EXTEND or AND.\n* config/h8300/h8300-protos.h (h8300_get_index): Declare.\n* config/h8300/h8300.h (INDEX_REG_CLASS): Set to GENERAL_REGS\nif TARGET_H8300SX.\n(GO_IF_LEGITIMATE_ADDRESS): Use h8300_get_index.\n* config/h8300/h8300.c (print_operand_address): Handle @(dd,RnL.b),\n@(dd,Rn.w) and @(dd,ERn.L).\n(h8300_displacement_size): Take the whole address as argument.\n(h8300_classify_operand, h8300_short_move_mem_p): Adjust accordingly.\n2003-05-28  Richard Sandiford  <rsandifo@redhat.com>\n* config/mips/mips-protos.h (h8300_operands_match_p): Declare.\n(h8sx_mergeable_memrefs_p): Declare.\n* config/h8300/h8300.h (HAVE_POST_DECREMENT): Define to TARGET_H8300SX.\n(HAVE_PRE_INCREMENT): Likewise.\n(GO_IF_LEGITIMATE_ADDRESS): Accept pre/post increment/decrement\naddresses for TARGET_H8300SX,\n* config/h8300/h8300.c (print_operand_address): Deal with PRE_INC\nand POST_DEC.\n(movb_length_table, movl_length_table): New tables.\n(movw_length_table): Define to movb_length_table.\n(h8300_displacement_size): New, split out from...\n(h8300_classify_address): ...here.  Handle pre/post inc/dec.\n(h8300_short_immediate_length): Allow H8OP_MEM_COMPLEX operands.\n(h8300_insn_length_from_table): Add cases for movb, movw and movl.\n(h8sx_mergeable_memrefs_p, h8300_operands_match_p): New functions.\n(output_plussi): Use add.l #xx:3,Rn and sub.l #xx:3,Rn for h8sx.\n(compute_plussi_length, compute_plussi_cc): Update accordingly.\n(h8sx_unary_shift_operator): Get the mode from the operator.\n(binary_shift_operator): Likewise.\n* config/h8300/h8300.md: If a peephole2 applies gen_lowpart to\na memory reference, check whether the reference is offsettable.\n(length_table): Add movb, movw and movl.\n(movqi): Add new h8sx pattern.  Don't force one operand to be a\nregister when generating h8sx code.\n(movhi, movsi, movsf): Likewise.\n(movstrictqi): Use the length_table attribute.\n(movstricthi): Likewise.  Add h8sx alternative for mov.w #xx:3,Rn.\n(addqi3): Split into a define_expand and define_insn.  Don't accept\nmemory operands in the expander.  Use h8300_operands_match_p to\ncheck for matching operands in the define_insn.\n(subqi3, negqi2, one_cmplqi2): Likewise.\n(add[hs]i3): Don't accept memory operands in the expander.  Likewise\nin any patterns that are unused in h8sx code.  In the h8sx patterns,\nuse h8300_operands_match_p to check whether operands match.\n(sub[hs]i3, and[hi]3, ior[hs]i3, xor[hs]i3, neg[hsi]3,\none_cmpl[hs]i3): Likewise.\n(andqi3, iorqi3, xorqi3): Likewise.  Don't call fix_bit_operand\nin the expander.\n2003-05-23  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300-protos.h (expand_a_shift): Return a bool.\n(h8300_insn_length_from_table): Add a second parameter.\n(output_h8sx_shift): Declare.\n* config/h8300/h8300.h (OK_FOR_W, OK_FOR_Y): New macros.\n(EXTRA_CONSTRAINT): Replace with...\n(EXTRA_CONSTRAINT_STR): ...this.  Use OK_FOR_W and OK_FOR_Y.\n(CONSTRAINT_LEN): Define, returning 2 for 'W' and 'Y'.\n(PREDICATE_CODES): Add entries for h8sx_unary_shift_operator\nand h8sx_binary_shift_operator.\n* config/h8300/h8300.c (two_insn_adds_subs_operand): Return false\nfor TARGET_H8300SX.\n(bit_operand): Replace use of EXTRA_CONSTRAINT with OK_FOR_U.\n(bit_memory_operand, fix_bit_operand): Likewise.\n(h8300_length_table_for_insn): Remove.\n(h8300_classify_operand): Fix check for 16-bit operands in 32-bit\ninstructions.\n(h8300_short_immediate_length, h8300_binary_length): New functions.\n(h8300_insn_length_from_table): Add an opcodes parameter.  Rework.\n(output_plussi): Use sub to add negative constants.\n(compute_plussi_length): Adjust accordingly.\n(h8sx_single_shift_type): New enum.\n(h8sx_single_shift, h8sx_unary_shift_operator,\nh8sx_binary_shift_operator, output_h8sx_shift): New functions.\n(expand_a_shift, expand_a_rotate): Emit nothing if the shift is a\nsingle h8sx instruction.  Return false in this case.\n* config/h8300/h8300.md (length_table): Add short_immediate.\n(length): Pass the operand array to h8300_insn_length_from_table.\n(adjust_length): Assume \"no\" for insns with a length_table attribute.\n(*cmphi_h8300hs, cmpsi): Add alternatives for #xx:3.\n(*addhi3_h8300hs): Don't use for h8sx.\n(*addhi3_h8sx): New pattern, with alternatives for add.w #xx:3\nand sub.w #xx:3.\n(ashl[qhs]i3, lshr[qhs]i3, ashr[qhs]i3, rotl[qhs]i3): Change operand\n1's predicate to nonimmediate_operand.  Only skip default expansion\nif expand_a_shift or expand_a_rotate returns true.  Add new patterns\nfor single h8sx shift instructions.\n2003-05-22  Alexandre Oliva  <aoliva@redhat.com>\n* config/h8300/h8300.c (nibble_operand): Split out of...\n(reg_or_nibble_operand): ... this.\n* config/h8300/h8300.h (PREDICATE_CODES): Added nibble_operand.\n* config/h8300/h8300.md: (mulqihi3, mulhisi3, umulqihi3,\numulhisi3): Introduce expand, and introduce separate insns for\nsign- or zero-extended REG and already-extended CONST_INT.\n2003-05-20  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.c (h8300_unary_length): Fix miscounting.\n* config/h8300/h8300.md (subqi3): Generalize for h8sx.\n(subhi3): Likewise.  Don't accept immediates for operand 1.\nRemove the early clobber from second alternative of the h8300s pattern.\n(subsi3): Generalize for h8sx.  Force operand 2 into a register\non plain h8300 targets.\n(subsi3_h8300): Use h8300_dst_operand for consistency with expander.\n(subsi3_h8300h): Generalize for h8sx.\n(one_cmplqi2, one_cmplhi2, one_cmplsi2): Likewise.\n2003-05-19  Alexandre Oliva  <aoliva@redhat.com>\n* config/h8300/h8300.c (reg_or_nibble_operand): New.\n* config/h8300/h8300.h (PREDICATE_CODES): Adjust.\n(TARGET_H8300SXMUL): New.\n(CONST_OK_FOR_P): New.\n(CONST_OK_FOR_LETTER_P): Adjust.\n* config/h8300/h8300.md (mulqihi3, mulhisi3, umulqihi3,\numulhisi3): Accept 4-bit immediate on H8SX.\n(mulhi3, mulsi3, smulsi3_highpart, umulsi3_highpart): New.\n(udivsi3, divhi3, udivsi3, divsi3): New.\n2003-05-19  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300-protos.h (h8300_insn_length_from_table): Declare.\n* config/h8300/h8300.h (OK_FOR_Q): New macro.\n(EXTRA_CONSTRAINT): Use it to check the 'Q' constraint.\n(PREDICATE_CODES): Add h8300_src_operand and h8300_dst_operand.\nAdd ADDRESSOF to the bit_operand entry.\n* config/h8300/h8300.c (h8300_dst_operand): New predicate.\n(h8300_src_operand): Likewise.\n(bit_operand): Check nonimmediate_operand rather than general_operand.\nAccept any nonimmediate_operand in h8sx code.\n(h8300_and_costs): Initialize operands[1].\n(h8300_rtx_costs) <AND>: Return false if the operands aren't valid.\n(h8300_operand_class): New enum.\n(h8300_length_table): New typedef.\n(addb_length_table, addw_length_table, addl_length_table,\nlogicl_length_table): New tables.\n(logicb_length_table, logicw_length_table): New macros.\n(h8300_classify_operand, h8300_length_from_table,\nh8300_length_table_for_insn, h8300_unary_length,\nh8300_insn_length_from_table): New functions.\n(output_plussi): Only use adds and subs for register destinations.\nDisable redundant clause.\n(compute_plussi_cc): Likewise.\n(compute_plussi_length): Likewise.  Use h8300_length_from_table\nto work out the length of an insn.\n(output_logical_op): Only use narrower immediate instructions\nif the destination is a register.\n(compute_logical_op_cc): Likewise.\n(compute_logical_op_length): Likewise.  Use h8300_length_from_table.\n(h8300_adjust_insn_length): Tighten check for reg<->mem moves.\n* config/h8300/h8300.md (length_table): New attribute.\n(length): When an instruction has a length_table attribute, use\nh8300_insn_length_from_table to calculate its default length.\n(cmpqi): Use h8300_dst_operand for the first operand and\nh8300_src_operand for the second.\n(cmphi, *cmphi_h8300hs, cmpsi, negqi2, neghi2, neghi2_h8300h, negsi2,\nnegsi2_h8300h, addqi3, addhi3, *addhi3_h8300, *addhi3_h8300hs, addsi3,\naddsi_h8300, addsi_h8300h, andhi3, andsi3, iorhi3,\niorsi3, xorhi3, xorsi3): Likewise.\n(andqi3): Use h8300_src_operand for operand 2.  Adjust the condition\nso that it allows any combination of operands for TARGET_H8300SX.\n(iorqi3, xorqi3): Likewise.\n(cmpqi): Use the length_table attribute.\n(*cmphi_h8300hs, cmpsi, addqi, *addhi3_h8300hs, andqi3, iorqi3,\nxorqi3, negqi2, neghi2_h8300h, negsi2_h8300h): Likewise.\n(cmpqi): Add 'Q' constraint.\n(*cmphi_h8300hs, cmpsi, addqi, *addhi3_h8300hs, addsi_h8300h, andqi3,\niorqi3, xorqi3, negqi2, neghi2_h8300h, negsi2_h8300h): Likewise.\n2003-05-14  Richard Sandiford  <rsandifo@redhat.com>\n* config/h8300/h8300.h (MASK_H8300SX): New macro.\n(TARGET_H8300S): True for both -ms and -msx.\n(TARGET_H8300SX): New macro.\n(TARGET_SWITCHES): Add entries for -msx and -mno-sx.\n* config/h8300/h8300.c (asm_file_start): Write .h8300sx for -msx.\n* config/h8300/elf.h (LINK_SPEC): Use -m h8300sxelf for -msx.\n* config/h8300/t-h8300 (MULTILIB_MATCHES): Use -ms multilibs for -msx.\n[Temporary change.]\n2003-02-28  Alexandre Oliva  <aoliva@redhat.com>\n* config/h8300/h8300.h (SIZE_TYPE, PTRDIFF_TYPE): Use short with\n16-bit pointers and 32-bit ints.\n* config/h8300/h8300.h (LEGITIMATE_CONSTANT_P): Accept\nCONST_DOUBLE with mode no wider than SImode.\n* config/h8300/h8300.md (extendqisi2_h8300): Add constraints for\noutput operand.\n2003-02-27  Alexandre Oliva  <aoliva@redhat.com>\n* config/h8300/h8300.c (general_operand_src): Match CONSTANT_P_RTX\nor SUBREG thereof.\n* config/h8300/h8300.h (PREDICATE_CODES): Adjust.\n2003-02-22  Alexandre Oliva  <aoliva@redhat.com>\n* config/h8300/h8300.c (dosize): Truncate sign * size to Pmode.\n\nFrom-SVN: r84257", "tree": {"sha": "8638aa5488daa82f88fd688971c4bd8dce61d9be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8638aa5488daa82f88fd688971c4bd8dce61d9be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/comments", "author": null, "committer": null, "parents": [{"sha": "5c121a1b6828a7f3c77f8b5ef4da223b27421517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c121a1b6828a7f3c77f8b5ef4da223b27421517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c121a1b6828a7f3c77f8b5ef4da223b27421517"}], "stats": {"total": 5694, "additions": 4936, "deletions": 758}, "files": [{"sha": "c58997ae0083f76d82b92f2e1eae1e9f0704c66c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -1,3 +1,424 @@\n+2004-07-08  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tIntroduce H8SX support.\n+\t* expr.c (expand_strcpy): Renamed and moved to...\n+\t* builtins.c (expand_movstr): ... here.  Tweak.\n+\t(expand_builtin_strcpy): Adjust.  Use movstr if len can't be\n+\tcomputed or has side effects.\n+\t(expand_builtin_stpcpy): Likewise.  Use strcpy if return value is\n+\tunused, or if mempcpy fails.  Adjust the return value in the\n+\tlatter case.  Use movstr if everything else fails.\n+\t* doc/md.texi (movstr): Document.\n+\t(movmemM, clrmemM): Fix explanation of memory block operands.\n+\t* config/h8300/h8300.md (stpcpy): Renamed to...\n+\t(movstr): ... this.  Adjust.\n+\t2004-07-07  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/h8300/h8300.md: Rename movstr*, except for movstrict*, to\n+\tmovmem* and clrstr* to clrmem*.\n+\t2004-06-27  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/h8300/h8300.c (h8300_reg_class_from_letter): Map 'D' to\n+\tGENERAL_REGS, always.\n+\t(h8300_swap_into_er6, h8300_swap_into_er6): Handle the case of\n+\tgetting the stack pointer as addr.\n+\t* config/h8300/h8300.h (PREDICATE_CODES): Remove constant rtxes\n+\tfrom general_operand_dst.\n+\t* config/h8300/h8300.md (movmd_internal_normal): New, normal-mode\n+\tvariant of...\n+\t(movmd_internal): ... this.  Add modes to operands.  Disparage `D'\n+\tinstead of requiring it to match only before reload.\n+\t(stpcpy_internal_normal): New, normal-mode variant of...\n+\t(stpcpy_internal): ... this.  Add modes to operands.  Disparage\n+\t`D' instead of requiring it to match only before reload.\n+\t* config/h8300/h8300-protos.h (h8300_legitimate_address_p): Add\n+\tmode argument.\n+\t* config/h8300/h8300.h (GO_IF_LEGITIMATE_ADDRESS): Pass it to...\n+\t* config/h8300/h8300.c (h8300_legitimate_address_p): Pass it to\n+\th8300_get_index.\n+\t* config/h8300/h8300.md (attr type): Add call.\n+\t(attr can_delay): If type is call, set it no.\n+\t(call, call_value): Set type to call.\n+\t2004-06-21  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/h8300/h8300.md (logicalhi3_sn, logicalsi3_sn): New.\n+\t2004-06-16  Alexandre Oliva  <aoliva@redhat.com>\n+\t* tree.c (get_narrower): Don't narrow integral types into\n+\tnon-integral types.\n+\t* config/h8300/h8300.c (h8300_expand_epilogue): Initialize\n+\tframe_size *before* the first use.\n+\t* config/h8300/h8300.md (movstrictqi): Reintroduce post-increment\n+\ton input.\n+\t(peephole2): Don't widen instructions that push SP.  Move\n+\tdecrement of SP to the end of all stm-generating peepholes.\n+\t2003-07-24  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.md (insv): Prefer to use AND to clear a bitfield\n+\tand OR to set it to all ones.\n+\t2003-07-24  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.md (can_delay): Default to \"no\" for bit branches.\n+\t(call, call_value): Set can_delay to \"no\".\n+\t2003-07-22  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.md (extzv): Make subreg check more robust.\n+\t2003-07-21  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.md (*brabit): Remove.\n+\t* config/h8300/h8300.md (*brabc, *brabs): Remove mode from\n+\tzero_extract.  Use bit_memory_operand as the predicate for\n+\toperand 1 and 'WU' as the constraint.  Check the difference\n+\tbetween the base length and the final one when deciding which\n+\ttype of branch to use.\n+\t2003-07-21  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.md (extzv): Remove mode from operands 0 and 1.\n+\tUse convert_move to extend the result for TARGET_H8300SX.  Check\n+\tfor QImode memory references.  Optimize the case where the\n+\tdestination is a paradoxical subreg.\n+\t2003-07-21  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.md (*movsf_h8sx): Add an r <- G alternative.\n+\t* config/h8300/h8300.md (andqi): Remove bclr from h8sx version.\n+\t2003-07-21  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.md: Include mova.md\n+\t(length_table): Add mova and mova_zero.\n+\t* config/h8300/h8300.c (print_operand): Handle '%o'.  Print a length\n+\tafter all constant addresses for '%R', '%X', '%T' and '%S'.\n+\t(h8300_mova_length): New function.\n+\t(h8300_insn_length_from_table): Use it to handle mova and mova_zero.\n+\t* config/h8300/t-h8300 (mova.md): Generate from genmova.sh.  Add to\n+\tdependencies for s-config, etc.\n+\t* config/h8300/gemova.sh: New file.\n+\t* config/h8300/mova.md: Generated.\n+\t2003-07-20  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/h8300/h8300.c (h8300_bitfield_length): New.\n+\t(nibble_operand): Adjust.\n+\t(h8300_binary_length): Handle conditional binary op.\n+\t(h8300_insn_length_from_table): Handle bitfield and bitbranch.\n+\t* config/h8300/h8300.h: Change constraints W# and Y# to P#>X and\n+\tP#<X, respectively.  The original P is now IP4>X.  Introduced P#>0\n+\tand P#<0, unused so far.  W and Y are now prefixes to multi-letter\n+\tconstraints.  WU is introduced as a variant of U that requires a\n+\tmem, and is therefore considered an EXTRA_MEMORY_CONSTRAINT.\n+\t* config/h8300/h8300.md (attr type): Added bitbranch.\n+\t(attr length_table): Added bitfield and bitbranch.\n+\t(attr length): Compute bitbranch length.\n+\t(andqi): Separate pattern for H8300SX.  Use bfld for loading the\n+\tleast-significant bit of a byte.\n+\t(brabit, brabc, brabs): New.\n+\t(insv, extzv): Emit bfst and bfld on H8300SX.\n+\t(bfld, bfst, seq, sne): New.\n+\t(bstzhireg, cmpstz, bstz, bistz): New.\n+\t(cmpcondbset, condbset, cmpcondbclr, condbclr): New.\n+\t(cmpcondbsetreg, condbsetreg, cmpcondbclrreg, condbclrreg): New.\n+\t2003-07-11  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.c (h8sx_binary_memory_operator): New function.\n+\t(h8sx_unary_memory_operator): New function.\n+\t* config/h8300/h8300.h (EXTRA_MEMORY_CONSTRAINT): Disable.\n+\t(PREDICATE_CODES): Add h8sx_{unary,binary}_memory_operator.\n+\t* config/h8300/h8300.md: Add peepholes to combine reloads and\n+\tarithmetic insns.\n+\t2003-07-10  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h830.md (cmpqi): Use 'i' rather than 'n' in constraints.\n+\t(*cmphi_h8300hs, *addqi3, *addhi3_h8sx, subhi3): Likewise.\n+\t(and?i, ior?i, xor?i): Likewise.\n+\t2003-07-10  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.c: Move enums and prototypes to head of file.\n+\tVarious whitespace fixes.\n+\t(h8300_constant_length): New function, split out from...\n+\t(h8300_displacement_size): ...here.  Rename h8300_displacement_length.\n+\t(h8300_classify_operand): Use IN_RANGE.\n+\t(h8300_classify_operand): Use h8300_constant_length.\n+\t(h8300_short_move_mem_p): Tighten size check.\n+\t(h8sx_mergeable_memrefs_p): Tighten equality check.\n+\t2003-06-30  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.h (TARGET_CPU_CPP_BUILTINS): Define __H8300SX__\n+\tfor -msx.\n+\t* config/h8300/crti.asm: Use .h8300sx or .h8300sxn for -msx code.\n+\t* config/h8300/crtn.asm: Likewise.\n+\t* config/h8300/lib1funcs.asm: Likewise.  Use 32-bit pointers\n+\tif __H8300SX__ is defined.\n+\t2003-06-27  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300-protos.h (h8300_get_index): Add mode parameter.\n+\t* config/h8300/h8300.h (GO_IF_LEGITIMATE_ADDRESS): Update accordingly.\n+\t(GO_IF_MODE_DEPENDENT_ADDRESS): Treat POST_DEC, PRE_INC and indexed\n+\taddresses as mode-dependent.\n+\t* config/h8300/h8300.c (print_operand_address): Update call to\n+\th8300_get_index.\n+\t(h8300_get_index): Take a mode argument.  Rework to fix an\n+\tearlier misunderstanding.\n+\t2003-06-26  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.c (zero_extendqisi2): Force the source operand\n+\tinto a register if TARGET_H8300SX.\n+\t(*zero_extendqisi2_h8300hs, *extendqisi2_h8300): Disable for\n+\tTARGET_H8300SX.  Also disable related define_splits.\n+\t(*zero_extendqisi2_h8sx, *extendqisi2_h8sx): New patterns.\n+\t2003-06-23  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.c (h8300_rtx_costs): Add h8sx handling.\n+\t2003-06-20  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.h (OK_FOR_Z): New macro.\n+\t(EXTRA_CONSTRAINT_STR): Check it.\n+\t* config/h8300/h8300.c (h8300_classify_operand): Accept null\n+\tclass arguments.\n+\t(h8300_insn_length_from_table): Handle LENGTH_TABLE_MOV_IMM4.\n+\t* config/h8300/h8300.md (length_table): Add mov_imm4.\n+\t(movqi, movhi): Add Z <- W4 alternatives to h8sx patterns.\n+\t2003-06-20  Richard Sandiford  <rsandifo@redhat.com>\n+\t* genattrtab.c (write_eligible_delay): Allow candidate_insn to\n+\tbe a label.\n+\t* config/h8300/h8300.h (DELAY_SLOT_LENGTH): New macro.\n+\t* config/h8300/h8300.c (h8300_reorg): New function.\n+\t(TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t* config/h8300/h8300.md (length): Subtract the length of the\n+\tdelay slot from (pc) when checking the range of forward branches.\n+\t(delay_slot, can_delay): New attributes.\n+\t(define_delay): Add bra/s handling.\n+\t(movmd_internal, return_h8sx, *return_1): Set can_delay to no.\n+\t(jump): Add delayed-branch handling.\n+\t2003-06-17  Richard Sandiford  <rsandifo@redhat.com>\n+\t* expr.c (expand_strcpy): New function.\n+\t* builtins.c (expand_builtin_strcpy): Fall back on expand_strcpy.\n+\t(expand_builtin_stpcpy): Likewise.\n+\t* config/h8300/h8300-protos.h (h8sx_split_movmd): Remove.\n+\t(h8300_swap_into_er6, h8300_swap_out_of_er6): Declare.\n+\t* config/h8300/h8300.c (h8300_reg_class_from_letter): Tweak 'd'\n+\thandling to improve register allocation for -fno-omit-frame-pointer.\n+\t(h8sx_split_movmd): Delete, moving er6 handling into...\n+\t(h8300_swap_into_er6, h8300_swap_out_of_er6): ...these new functions.\n+\t* config/h8300/h8300.md (UNSPEC_STPCPY): New unspec constant.\n+\t(movmd): Add calls to copy_rtx.\n+\t(movmd_internal): In the second alternative, allow the initial and\n+\tfinal destination registers to be different .  Update the splitter\n+\taccordingly.  Call h8300_swap_into_er6 and h8300_swap_out_of_er6\n+\tinstead of h8sx_split_movmd.\n+\t(stpcpy, movsd): New expanders.\n+\t(movsd_internal): New define_insn.\n+\t2003-06-13  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300-protos.h (h8300_reg_class_from_letter): Declare.\n+\t(h8sx_emit_movmd, h8sx_split_movmd): Declare.\n+\t* config/h8300/h8300.h (reg_class): Add COUNTER_REGS, SOURCE_REGS\n+\tand DESTINATION_REGS.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update accordingly.\n+\t(REGNO_REG_CLASS): Map er4, er5 and er6 to the new classes.\n+\t(REG_CLASS_FROM_LETTER): Use h8300_reg_class_from_letter.\n+\t(h8300_move_ratio): Declare.\n+\t(MOVE_RATIO): Use it.\n+\t* config/h8300/h8300.c (h8300_move_ratio): New variable.\n+\t(h8300_init_once): Initialize it.\n+\t(h8300_reg_class_from_letter): New function.\n+\t(print_operand): Add an 'm' prefix for printing \".b\", \".w\" or \".l\".\n+\t(h8sx_emit_movmd, h8sx_split_movmd): New functions.\n+\t* config/h8300/h8300.md (UNSPEC_MOVMD): New unspec constant.\n+\t(COUNTER_REG, SOURCE_REG, DESTINATION_REG): New register constants.\n+\t(movstrsi, movmd): New expanders.\n+\t(movmd_internal): New insn.\n+\t2003-06-06  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.h (EXTRA_MEMORY_CONSTRAINT): Define.\n+\t2003-06-04  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/elf.h (LINK_SPEC): Use -m h8300sxnelf for -msx -mn.\n+\t* config/h8300/h8300.c (asm_file_start): Use .h8300sxn likewise.\n+\t2003-06-03  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.c (nibble_operand): Fix warning.\n+\t* config/h8300/h8300.md (movstricthi): Set adjust_length to no.\n+\t(movsi_h8sx): Likewise here and the normal h8sx movhi pattern.\n+\t(movsf_h8300h): Disable for TARGET_H8300SX.\n+\t2003-06-03  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.h (PREDICATE_CODES): Add h8300_ldm_parallel,\n+\th8300_stm_parallel and h8300_return_parallel.\n+\t* config/h8300/h8300.c (h8300_push_pop, h8300_stack_offset_p,\n+\th8300_ldm_stm_regno, h8300_ldm_stm_parallel, h8300_ldm_parallel,\n+\th8300_stm_parallel, h8300_return_parallel): New functions.\n+\t(h8300_expand_prologue): Don't enforce ldm/stm register alignment\n+\tif TARGET_H8300SX.  Use h8300_push_pop.\n+\t(h8300_expand_epilogue): Likewise.  Try to merge the return insn\n+\tand final pop when generating h8sx code.  Always emit some form\n+\tof return insn.\n+\t* config/h8300/h8300.md: Don't enforce register alignment in\n+\tstm peepholes if TARGET_H8300SX.\n+\t(ldm_h8300s, stm_h8300s, return_h8sx): New patterns.\n+\t(ldm_h8300s_[234], stm_h8300_[234]): Disable.\n+\t(epilogue): Expect h8300_expand_epilogue to emit a return insn.\n+\t2003-06-03  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/t-h8300 (MULTILIB_OPTIONS): Add a -msx multilib.\n+\t(MULTILIB_DIRNAMES): Add a directory for it.\n+\t(MULTILIB_MATCHES): Delete.\n+\t2003-05-28  Richard Sandiford  <rsandifo@redhat.com>\n+\t* final.c (walk_alter_subreg): Handle addresses with subregs\n+\tinside a ZERO_EXTEND or AND.\n+\t* config/h8300/h8300-protos.h (h8300_get_index): Declare.\n+\t* config/h8300/h8300.h (INDEX_REG_CLASS): Set to GENERAL_REGS\n+\tif TARGET_H8300SX.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Use h8300_get_index.\n+\t* config/h8300/h8300.c (print_operand_address): Handle @(dd,RnL.b),\n+\t@(dd,Rn.w) and @(dd,ERn.L).\n+\t(h8300_displacement_size): Take the whole address as argument.\n+\t(h8300_classify_operand, h8300_short_move_mem_p): Adjust accordingly.\n+\t2003-05-28  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/mips/mips-protos.h (h8300_operands_match_p): Declare.\n+\t(h8sx_mergeable_memrefs_p): Declare.\n+\t* config/h8300/h8300.h (HAVE_POST_DECREMENT): Define to TARGET_H8300SX.\n+\t(HAVE_PRE_INCREMENT): Likewise.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Accept pre/post increment/decrement\n+\taddresses for TARGET_H8300SX,\n+\t* config/h8300/h8300.c (print_operand_address): Deal with PRE_INC\n+\tand POST_DEC.\n+\t(movb_length_table, movl_length_table): New tables.\n+\t(movw_length_table): Define to movb_length_table.\n+\t(h8300_displacement_size): New, split out from...\n+\t(h8300_classify_address): ...here.  Handle pre/post inc/dec.\n+\t(h8300_short_immediate_length): Allow H8OP_MEM_COMPLEX operands.\n+\t(h8300_insn_length_from_table): Add cases for movb, movw and movl.\n+\t(h8sx_mergeable_memrefs_p, h8300_operands_match_p): New functions.\n+\t(output_plussi): Use add.l #xx:3,Rn and sub.l #xx:3,Rn for h8sx.\n+\t(compute_plussi_length, compute_plussi_cc): Update accordingly.\n+\t(h8sx_unary_shift_operator): Get the mode from the operator.\n+\t(binary_shift_operator): Likewise.\n+\t* config/h8300/h8300.md: If a peephole2 applies gen_lowpart to\n+\ta memory reference, check whether the reference is offsettable.\n+\t(length_table): Add movb, movw and movl.\n+\t(movqi): Add new h8sx pattern.  Don't force one operand to be a\n+\tregister when generating h8sx code.\n+\t(movhi, movsi, movsf): Likewise.\n+\t(movstrictqi): Use the length_table attribute.\n+\t(movstricthi): Likewise.  Add h8sx alternative for mov.w #xx:3,Rn.\n+\t(addqi3): Split into a define_expand and define_insn.  Don't accept\n+\tmemory operands in the expander.  Use h8300_operands_match_p to\n+\tcheck for matching operands in the define_insn.\n+\t(subqi3, negqi2, one_cmplqi2): Likewise.\n+\t(add[hs]i3): Don't accept memory operands in the expander.  Likewise\n+\tin any patterns that are unused in h8sx code.  In the h8sx patterns,\n+\tuse h8300_operands_match_p to check whether operands match.\n+\t(sub[hs]i3, and[hi]3, ior[hs]i3, xor[hs]i3, neg[hsi]3,\n+\tone_cmpl[hs]i3): Likewise.\n+\t(andqi3, iorqi3, xorqi3): Likewise.  Don't call fix_bit_operand\n+\tin the expander.\n+\t2003-05-23  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300-protos.h (expand_a_shift): Return a bool.\n+\t(h8300_insn_length_from_table): Add a second parameter.\n+\t(output_h8sx_shift): Declare.\n+\t* config/h8300/h8300.h (OK_FOR_W, OK_FOR_Y): New macros.\n+\t(EXTRA_CONSTRAINT): Replace with...\n+\t(EXTRA_CONSTRAINT_STR): ...this.  Use OK_FOR_W and OK_FOR_Y.\n+\t(CONSTRAINT_LEN): Define, returning 2 for 'W' and 'Y'.\n+\t(PREDICATE_CODES): Add entries for h8sx_unary_shift_operator\n+\tand h8sx_binary_shift_operator.\n+\t* config/h8300/h8300.c (two_insn_adds_subs_operand): Return false\n+\tfor TARGET_H8300SX.\n+\t(bit_operand): Replace use of EXTRA_CONSTRAINT with OK_FOR_U.\n+\t(bit_memory_operand, fix_bit_operand): Likewise.\n+\t(h8300_length_table_for_insn): Remove.\n+\t(h8300_classify_operand): Fix check for 16-bit operands in 32-bit\n+\tinstructions.\n+\t(h8300_short_immediate_length, h8300_binary_length): New functions.\n+\t(h8300_insn_length_from_table): Add an opcodes parameter.  Rework.\n+\t(output_plussi): Use sub to add negative constants.\n+\t(compute_plussi_length): Adjust accordingly.\n+\t(h8sx_single_shift_type): New enum.\n+\t(h8sx_single_shift, h8sx_unary_shift_operator,\n+\th8sx_binary_shift_operator, output_h8sx_shift): New functions.\n+\t(expand_a_shift, expand_a_rotate): Emit nothing if the shift is a\n+\tsingle h8sx instruction.  Return false in this case.\n+\t* config/h8300/h8300.md (length_table): Add short_immediate.\n+\t(length): Pass the operand array to h8300_insn_length_from_table.\n+\t(adjust_length): Assume \"no\" for insns with a length_table attribute.\n+\t(*cmphi_h8300hs, cmpsi): Add alternatives for #xx:3.\n+\t(*addhi3_h8300hs): Don't use for h8sx.\n+\t(*addhi3_h8sx): New pattern, with alternatives for add.w #xx:3\n+\tand sub.w #xx:3.\n+\t(ashl[qhs]i3, lshr[qhs]i3, ashr[qhs]i3, rotl[qhs]i3): Change operand\n+\t1's predicate to nonimmediate_operand.  Only skip default expansion\n+\tif expand_a_shift or expand_a_rotate returns true.  Add new patterns\n+\tfor single h8sx shift instructions.\n+\t2003-05-22  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/h8300/h8300.c (nibble_operand): Split out of...\n+\t(reg_or_nibble_operand): ... this.\n+\t* config/h8300/h8300.h (PREDICATE_CODES): Added nibble_operand.\n+\t* config/h8300/h8300.md: (mulqihi3, mulhisi3, umulqihi3,\n+\tumulhisi3): Introduce expand, and introduce separate insns for\n+\tsign- or zero-extended REG and already-extended CONST_INT.\n+\t2003-05-20  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.c (h8300_unary_length): Fix miscounting.\n+\t* config/h8300/h8300.md (subqi3): Generalize for h8sx.\n+\t(subhi3): Likewise.  Don't accept immediates for operand 1.\n+\tRemove the early clobber from second alternative of the h8300s pattern.\n+\t(subsi3): Generalize for h8sx.  Force operand 2 into a register\n+\ton plain h8300 targets.\n+\t(subsi3_h8300): Use h8300_dst_operand for consistency with expander.\n+\t(subsi3_h8300h): Generalize for h8sx.\n+\t(one_cmplqi2, one_cmplhi2, one_cmplsi2): Likewise.\n+\t2003-05-19  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/h8300/h8300.c (reg_or_nibble_operand): New.\n+\t* config/h8300/h8300.h (PREDICATE_CODES): Adjust.\n+\t(TARGET_H8300SXMUL): New.\n+\t(CONST_OK_FOR_P): New.\n+\t(CONST_OK_FOR_LETTER_P): Adjust.\n+\t* config/h8300/h8300.md (mulqihi3, mulhisi3, umulqihi3,\n+\tumulhisi3): Accept 4-bit immediate on H8SX.\n+\t(mulhi3, mulsi3, smulsi3_highpart, umulsi3_highpart): New.\n+\t(udivsi3, divhi3, udivsi3, divsi3): New.\n+\t2003-05-19  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300-protos.h (h8300_insn_length_from_table): Declare.\n+\t* config/h8300/h8300.h (OK_FOR_Q): New macro.\n+\t(EXTRA_CONSTRAINT): Use it to check the 'Q' constraint.\n+\t(PREDICATE_CODES): Add h8300_src_operand and h8300_dst_operand.\n+\tAdd ADDRESSOF to the bit_operand entry.\n+\t* config/h8300/h8300.c (h8300_dst_operand): New predicate.\n+\t(h8300_src_operand): Likewise.\n+\t(bit_operand): Check nonimmediate_operand rather than general_operand.\n+\tAccept any nonimmediate_operand in h8sx code.\n+\t(h8300_and_costs): Initialize operands[1].\n+\t(h8300_rtx_costs) <AND>: Return false if the operands aren't valid.\n+\t(h8300_operand_class): New enum.\n+\t(h8300_length_table): New typedef.\n+\t(addb_length_table, addw_length_table, addl_length_table,\n+\tlogicl_length_table): New tables.\n+\t(logicb_length_table, logicw_length_table): New macros.\n+\t(h8300_classify_operand, h8300_length_from_table,\n+\th8300_length_table_for_insn, h8300_unary_length,\n+\th8300_insn_length_from_table): New functions.\n+\t(output_plussi): Only use adds and subs for register destinations.\n+\tDisable redundant clause.\n+\t(compute_plussi_cc): Likewise.\n+\t(compute_plussi_length): Likewise.  Use h8300_length_from_table\n+\tto work out the length of an insn.\n+\t(output_logical_op): Only use narrower immediate instructions\n+\tif the destination is a register.\n+\t(compute_logical_op_cc): Likewise.\n+\t(compute_logical_op_length): Likewise.  Use h8300_length_from_table.\n+\t(h8300_adjust_insn_length): Tighten check for reg<->mem moves.\n+\t* config/h8300/h8300.md (length_table): New attribute.\n+\t(length): When an instruction has a length_table attribute, use\n+\th8300_insn_length_from_table to calculate its default length.\n+\t(cmpqi): Use h8300_dst_operand for the first operand and\n+\th8300_src_operand for the second.\n+\t(cmphi, *cmphi_h8300hs, cmpsi, negqi2, neghi2, neghi2_h8300h, negsi2,\n+\tnegsi2_h8300h, addqi3, addhi3, *addhi3_h8300, *addhi3_h8300hs, addsi3,\n+\taddsi_h8300, addsi_h8300h, andhi3, andsi3, iorhi3,\n+\tiorsi3, xorhi3, xorsi3): Likewise.\n+\t(andqi3): Use h8300_src_operand for operand 2.  Adjust the condition\n+\tso that it allows any combination of operands for TARGET_H8300SX.\n+\t(iorqi3, xorqi3): Likewise.\n+\t(cmpqi): Use the length_table attribute.\n+\t(*cmphi_h8300hs, cmpsi, addqi, *addhi3_h8300hs, andqi3, iorqi3,\n+\txorqi3, negqi2, neghi2_h8300h, negsi2_h8300h): Likewise.\n+\t(cmpqi): Add 'Q' constraint.\n+\t(*cmphi_h8300hs, cmpsi, addqi, *addhi3_h8300hs, addsi_h8300h, andqi3,\n+\tiorqi3, xorqi3, negqi2, neghi2_h8300h, negsi2_h8300h): Likewise.\n+\t2003-05-14  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/h8300/h8300.h (MASK_H8300SX): New macro.\n+\t(TARGET_H8300S): True for both -ms and -msx.\n+\t(TARGET_H8300SX): New macro.\n+\t(TARGET_SWITCHES): Add entries for -msx and -mno-sx.\n+\t* config/h8300/h8300.c (asm_file_start): Write .h8300sx for -msx.\n+\t* config/h8300/elf.h (LINK_SPEC): Use -m h8300sxelf for -msx.\n+\t* config/h8300/t-h8300 (MULTILIB_MATCHES): Use -ms multilibs for -msx.\n+\t[Temporary change.]\n+\t2003-02-28  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/h8300/h8300.h (SIZE_TYPE, PTRDIFF_TYPE): Use short with\n+\t16-bit pointers and 32-bit ints.\n+\t* config/h8300/h8300.h (LEGITIMATE_CONSTANT_P): Accept\n+\tCONST_DOUBLE with mode no wider than SImode.\n+\t* config/h8300/h8300.md (extendqisi2_h8300): Add constraints for\n+\toutput operand.\n+\t2003-02-27  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/h8300/h8300.c (general_operand_src): Match CONSTANT_P_RTX\n+\tor SUBREG thereof.\n+\t* config/h8300/h8300.h (PREDICATE_CODES): Adjust.\n+\t2003-02-22  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/h8300/h8300.c (dosize): Truncate sign * size to Pmode.\n+\n 2004-05-28  Aaron W. LaFramboise <aaronraolete36@aaronwl.com>\n \n \t* config.gcc (i[34567]86-*-mingw32*): Enable threads by default."}, {"sha": "72cf798a021dddb59270273dc96cfe8bd004f2b2", "filename": "gcc/builtins.c", "status": "modified", "additions": 118, "deletions": 20, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -2976,6 +2976,72 @@ expand_builtin_bcopy (tree arglist)\n   return expand_builtin_memmove (newarglist, const0_rtx, VOIDmode);\n }\n \n+#ifndef HAVE_movstr\n+# define HAVE_movstr 0\n+# define CODE_FOR_movstr CODE_FOR_nothing\n+#endif\n+\n+/* Expand into a movstr instruction, if one is available.  Return 0 if\n+   we failed, the caller should emit a normal call, otherwise try to\n+   get the result in TARGET, if convenient.  If ENDP is 0 return the\n+   destination pointer, if ENDP is 1 return the end pointer ala\n+   mempcpy, and if ENDP is 2 return the end pointer minus one ala\n+   stpcpy.  */\n+\n+static rtx\n+expand_movstr (tree dest, tree src, rtx target, int endp)\n+{\n+  rtx end;\n+  rtx dest_mem;\n+  rtx src_mem;\n+  rtx insn;\n+  const struct insn_data * data;\n+\n+  if (!HAVE_movstr)\n+    return 0;\n+\n+  dest_mem = get_memory_rtx (dest);\n+  src_mem = get_memory_rtx (src);\n+  if (!endp)\n+    {\n+      target = force_reg (Pmode, XEXP (dest_mem, 0));\n+      dest_mem = replace_equiv_address (dest_mem, target);\n+      end = gen_reg_rtx (Pmode);\n+    }\n+  else\n+    {\n+      if (target == 0 || target == const0_rtx)\n+\t{\n+\t  end = gen_reg_rtx (Pmode);\n+\t  if (target == 0)\n+\t    target = end;\n+\t}\n+      else\n+\tend = target;\n+    }\n+\n+  data = insn_data + CODE_FOR_movstr;\n+\n+  if (data->operand[0].mode != VOIDmode)\n+    end = gen_lowpart (data->operand[0].mode, end);\n+\n+  insn = data->genfun (end, dest_mem, src_mem);\n+\n+  if (insn == 0)\n+    abort ();\n+\n+  emit_insn (insn);\n+\n+  /* movstr is supposed to set end to the address of the NUL\n+     terminator.  If the caller requested a mempcpy-like return value,\n+     adjust it.  */\n+  if (endp == 1 && target != const0_rtx)\n+    emit_move_insn (target, plus_constant (gen_lowpart (GET_MODE (target),\n+\t\t\t\t\t\t\tend), 1));\n+\n+  return target;\n+}\n+\n /* Expand expression EXP, which is a call to the strcpy builtin.  Return 0\n    if we failed the caller should emit a normal call, otherwise try to get\n    the result in TARGET, if convenient (and in mode MODE if that's\n@@ -2996,12 +3062,14 @@ expand_builtin_strcpy (tree arglist, rtx target, enum machine_mode mode)\n   if (operand_equal_p (src, dst, 0))\n     return expand_expr (dst, target, mode, EXPAND_NORMAL);\n \n-  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-  if (!fn)\n-    return 0;\n-\n   len = c_strlen (src, 1);\n   if (len == 0 || TREE_SIDE_EFFECTS (len))\n+    return expand_movstr (TREE_VALUE (arglist),\n+\t\t\t  TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t  target, /*endp=*/0);\n+\n+  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+  if (!fn)\n     return 0;\n \n   len = size_binop (PLUS_EXPR, len, ssize_int (1));\n@@ -3020,37 +3088,67 @@ expand_builtin_strcpy (tree arglist, rtx target, enum machine_mode mode)\n static rtx\n expand_builtin_stpcpy (tree arglist, rtx target, enum machine_mode mode)\n {\n+  /* If return value is ignored, transform stpcpy into strcpy.  */\n+  if (target == const0_rtx)\n+    return expand_builtin_strcpy (arglist, target, mode);\n+\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n   else\n     {\n       tree dst, src, len;\n-\n-      /* If return value is ignored, transform stpcpy into strcpy.  */\n-      if (target == const0_rtx)\n-\t{\n-\t  tree fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n-\t  if (!fn)\n-\t    return 0;\n-\n-\t  return expand_expr (build_function_call_expr (fn, arglist),\n-\t\t\t      target, mode, EXPAND_NORMAL);\n-\t}\n+      tree narglist;\n+      rtx ret;\n \n       /* Ensure we get an actual string whose length can be evaluated at\n          compile-time, not an expression containing a string.  This is\n          because the latter will potentially produce pessimized code\n          when used to produce the return value.  */\n       src = TREE_VALUE (TREE_CHAIN (arglist));\n       if (! c_getstr (src) || ! (len = c_strlen (src, 0)))\n-\treturn 0;\n+\treturn expand_movstr (TREE_VALUE (arglist),\n+\t\t\t      TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t      target, /*endp=*/2);\n \n       dst = TREE_VALUE (arglist);\n       len = fold (size_binop (PLUS_EXPR, len, ssize_int (1)));\n-      arglist = build_tree_list (NULL_TREE, len);\n-      arglist = tree_cons (NULL_TREE, src, arglist);\n-      arglist = tree_cons (NULL_TREE, dst, arglist);\n-      return expand_builtin_mempcpy (arglist, target, mode, /*endp=*/2);\n+      narglist = build_tree_list (NULL_TREE, len);\n+      narglist = tree_cons (NULL_TREE, src, narglist);\n+      narglist = tree_cons (NULL_TREE, dst, narglist);\n+      ret = expand_builtin_mempcpy (narglist, target, mode, /*endp=*/2);\n+\n+      if (ret)\n+\treturn ret;\n+\n+      if (TREE_CODE (len) == INTEGER_CST)\n+\t{\n+\t  rtx len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n+\n+\t  if (GET_CODE (len_rtx) == CONST_INT)\n+\t    {\n+\t      ret = expand_builtin_strcpy (arglist, target, mode);\n+\n+\t      if (ret)\n+\t\t{\n+\t\t  if (! target)\n+\t\t    target = gen_reg_rtx (mode);\n+\t\t  if (GET_MODE (target) != GET_MODE (ret))\n+\t\t    ret = gen_lowpart (GET_MODE (target), ret);\n+\n+\t\t  ret = emit_move_insn (target,\n+\t\t\t\t\tplus_constant (ret,\n+\t\t\t\t\t\t       INTVAL (len_rtx)));\n+\t\t  if (! ret)\n+\t\t    abort ();\n+\n+\t\t  return target;\n+\t\t}\n+\t    }\n+\t}\n+\n+      return expand_movstr (TREE_VALUE (arglist),\n+\t\t\t    TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t    target, /*endp=*/2);\n     }\n }\n "}, {"sha": "3835698554f74bb8cb350c54c2e0500cdef4829a", "filename": "gcc/config/h8300/crti.asm", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fcrti.asm?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -51,6 +51,13 @@ Boston, MA 02111-1307, USA.  */\n #else\n \t.h8300s\n #endif\n+#endif\n+#ifdef __H8300SX__\n+#ifdef __NORMAL_MODE__\n+\t.h8300sxn\n+#else\n+\t.h8300sx\n+#endif\n #endif\n \n \t.section .init"}, {"sha": "2d0e04583611a9dfa7b92123ddb5506e1c3aa9f0", "filename": "gcc/config/h8300/crtn.asm", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fcrtn.asm?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -43,6 +43,13 @@ Boston, MA 02111-1307, USA.  */\n #else\n \t.h8300s\n #endif\n+#endif\n+#ifdef __H8300SX__\n+#ifdef __NORMAL_MODE__\n+\t.h8300sxn\n+#else\n+\t.h8300sx\n+#endif\n #endif\n \t.section .init\n \trts"}, {"sha": "542ffcf81a2bf3464e9faaac27ac3f6e75fc10a8", "filename": "gcc/config/h8300/elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Felf.h?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -40,6 +40,6 @@ Boston, MA 02111-1307, USA.  */\n #define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)\n \n #undef LINK_SPEC\n-#define LINK_SPEC \"%{mh:%{mn:-m h8300hnelf}} %{mh:%{!mn:-m h8300helf}} %{ms:%{mn:-m h8300snelf}} %{ms:%{!mn:-m h8300self}}\"\n+#define LINK_SPEC \"%{mh:%{mn:-m h8300hnelf}} %{mh:%{!mn:-m h8300helf}} %{ms:%{mn:-m h8300snelf}} %{ms:%{!mn:-m h8300self}} %{msx:%{mn:-m h8300sxnelf;:-m h8300sxelf}}\"\n \n #endif /* h8300/elf.h */"}, {"sha": "1988afa512a0cab0fdc4a8654d1b068d4c3f2ad2", "filename": "gcc/config/h8300/genmova.sh", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fgenmova.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fgenmova.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fgenmova.sh?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -0,0 +1,163 @@\n+#!/bin/sh\n+# Generate mova.md, a file containing patterns that can be implemented\n+# using the h8sx mova instruction.\n+\n+echo \";; -*- buffer-read-only: t -*-\"\n+echo \";; Generated automatically from genmova.sh\"\n+\n+# Loop over modes for the source operand (the index).  Only 8-bit and\n+# 16-bit indices are allowed.\n+for s in QI HI; do\n+\n+  # Set $src to the operand syntax for this size of index.\n+  case $s in\n+    QI) src=%X1.b;;\n+    HI) src=%T1.w;;\n+  esac\n+\n+  # A match_operand for the source.\n+  operand=\"(match_operand:$s 1 \\\"h8300_dst_operand\\\" \\\"0,rQ\\\")\"\n+\n+  # Loop over the destination register's mode.  The QI and HI versions use\n+  # the same instructions as the SI ones, they just ignore the upper bits\n+  # of the result.\n+  for d in QI HI SI; do\n+\n+    # If the destination is larger than the source, include a\n+    # zero_extend/plus pattern.  We could also match zero extensions\n+    # of memory without the plus, but it's not any smaller or faster\n+    # than separate insns.\n+    case $d:$s in\n+      SI:QI | SI:HI | HI:QI)\n+\tcat <<EOF\n+(define_insn \"\"\n+  [(set (match_operand:$d 0 \"register_operand\" \"=r,r\")\n+\t(plus:$d (zero_extend:$d $operand)\n+\t\t (match_operand:$d 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/b.l @(%o2,$src),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+EOF\n+\t;;\n+    esac\n+\n+    # Loop over the shift amount.\n+    for shift in 1 2; do\n+      case $shift in\n+\t1) opsize=w mult=2;;\n+\t2) opsize=l mult=4;;\n+      esac\n+\n+      # Calculate the mask of bits that will be nonzero after the source\n+      # has been extended and shifted.\n+      case $s:$shift in\n+\tQI:1) mask=510;;\n+\tQI:2) mask=1020;;\n+\tHI:1) mask=131070;;\n+\tHI:2) mask=262140;;\n+      esac\n+\n+      # There doesn't seem to be a well-established canonical form for\n+      # some of the patterns we need.  Emit both shift and multiplication\n+      # patterns.\n+      for form in mult ashift; do\n+\tcase $form in\n+\t  mult) amount=$mult;;\n+\t  ashift) amount=$shift;;\n+\tesac\n+\n+\tcase $d:$s in\n+\t  # If the source and destination are the same size, we can treat\n+\t  # mova as a sort of multiply-add instruction.\n+\t  QI:QI | HI:HI)\n+\t    cat <<EOF\n+(define_insn \"\"\n+  [(set (match_operand:$d 0 \"register_operand\" \"=r,r\")\n+\t(plus:$d ($form:$d $operand\n+\t\t\t   (const_int $amount))\n+\t\t (match_operand:$d 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/$opsize.l @(%o2,$src),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+EOF\n+\t    ;;\n+\n+\t  # Handle the cases where the source is smaller than the\n+\t  # destination.  Sometimes combine will keep the extension,\n+\t  # sometimes it will use an AND.\n+\t  SI:QI | SI:HI | HI:QI)\n+\n+\t    # Emit the forms that use zero_extend.\n+\t    cat <<EOF\n+(define_insn \"\"\n+  [(set (match_operand:$d 0 \"register_operand\" \"=r,r\")\n+\t($form:$d (zero_extend:$d $operand)\n+\t\t  (const_int $amount)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/$opsize.l @(0,$src),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:$d 0 \"register_operand\" \"=r,r\")\n+\t(plus:$d ($form:$d (zero_extend:$d $operand)\n+\t\t\t   (const_int $amount))\n+\t\t (match_operand:$d 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/$opsize.l @(%o2,$src),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+EOF\n+\n+\t    # Now emit the forms that use AND.  When the index is a register,\n+\t    # these forms are effectively $d-mode operations: the index will\n+\t    # be a $d-mode REG or SUBREG.  When the index is a memory\n+\t    # location, we will have a paradoxical subreg such as:\n+\t    #\n+\t    #\t(and:SI (mult:SI (subreg:SI (mem:QI ...) 0)\n+\t    #\t\t\t (const_int 4))\n+\t    #\t\t(const_int 1020))\n+\t    #\n+\t    # Match the two case separately: a $d-mode register_operand\n+\t    # or a $d-mode subreg of an $s-mode memory_operand.  Match the\n+\t    # memory form first since register_operand accepts mem subregs\n+\t    # before reload.\n+\t    memory=\"(match_operand:$s 1 \\\"memory_operand\\\" \\\"m\\\")\"\n+\t    memory=\"(subreg:$d $memory 0)\"\n+\t    register=\"(match_operand:$d 1 \\\"register_operand\\\" \\\"0\\\")\"\n+\t    for paradoxical in \"$memory\" \"$register\"; do\n+\t      cat <<EOF\n+(define_insn \"\"\n+  [(set (match_operand:$d 0 \"register_operand\" \"=r\")\n+\t(and:$d ($form:$d $paradoxical\n+\t\t\t  (const_int $amount))\n+\t\t(const_int $mask)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/$opsize.l @(0,$src),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:$d 0 \"register_operand\" \"=r\")\n+\t(plus:$d (and:$d ($form:$d $paradoxical\n+\t\t\t\t   (const_int $amount))\n+\t\t\t (const_int $mask))\n+\t\t (match_operand:$d 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/$opsize.l @(%o2,$src),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+EOF\n+\t      done\n+\t    ;;\n+\tesac\n+      done\n+    done\n+  done\n+done"}, {"sha": "6df3d71097134de2374b06cfab76838e76fca184", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -46,7 +46,7 @@ extern unsigned int compute_logical_op_length (enum machine_mode,\n \t\t\t\t\t       rtx *);\n extern int compute_logical_op_cc (enum machine_mode, rtx *);\n extern void h8300_expand_branch (enum rtx_code, rtx);\n-extern void expand_a_shift (enum machine_mode, int, rtx[]);\n+extern bool expand_a_shift (enum machine_mode, int, rtx[]);\n extern int h8300_shift_needs_scratch_p (int, enum machine_mode);\n extern int expand_a_rotate (rtx[]);\n extern int fix_bit_operand (rtx *, enum rtx_code);\n@@ -83,7 +83,7 @@ extern int same_cmp_preceding_p (rtx);\n extern int same_cmp_following_p (rtx);\n \n extern int h8300_legitimate_constant_p (rtx);\n-extern int h8300_legitimate_address_p (rtx, int);\n+extern int h8300_legitimate_address_p (enum machine_mode, rtx, int);\n \n /* Used in builtins.c */\n extern rtx h8300_return_addr_rtx (int, rtx);\n@@ -111,5 +111,14 @@ extern int h8300_hard_regno_mode_ok (int, enum machine_mode);\n struct cpp_reader;\n extern void h8300_pr_interrupt (struct cpp_reader *);\n extern void h8300_pr_saveall (struct cpp_reader *);\n+extern enum reg_class  h8300_reg_class_from_letter (int);\n+extern rtx             h8300_get_index (rtx, enum machine_mode mode, int *);\n+extern unsigned int    h8300_insn_length_from_table (rtx, rtx *);\n+extern const char *    output_h8sx_shift (rtx *, int, int);\n+extern bool            h8300_operands_match_p (rtx *);\n+extern bool            h8sx_mergeable_memrefs_p (rtx, rtx);\n+extern bool            h8sx_emit_movmd (rtx, rtx, rtx, HOST_WIDE_INT);\n+extern void            h8300_swap_into_er6 (rtx);\n+extern void            h8300_swap_out_of_er6 (rtx);\n \n #endif /* ! GCC_H8300_PROTOS_H */"}, {"sha": "f7d41c1ca11f6d737de0938376bf1603889faa0e", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 1586, "deletions": 185, "changes": 1771, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -46,6 +46,57 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n \n+/* Classifies a h8300_src_operand or h8300_dst_operand.\n+\n+   H8OP_IMMEDIATE\n+\tA constant operand of some sort.\n+\n+   H8OP_REGISTER\n+\tAn ordinary register.\n+\n+   H8OP_MEM_ABSOLUTE\n+\tA memory reference with a constant address.\n+\n+   H8OP_MEM_BASE\n+\tA memory reference with a register as its address.\n+\n+   H8OP_MEM_COMPLEX\n+\tSome other kind of memory reference.  */\n+enum h8300_operand_class\n+{\n+  H8OP_IMMEDIATE,\n+  H8OP_REGISTER,\n+  H8OP_MEM_ABSOLUTE,\n+  H8OP_MEM_BASE,\n+  H8OP_MEM_COMPLEX,\n+  NUM_H8OPS\n+};\n+\n+/* Classifies an h8sx shift operation.\n+\n+   H8SX_SHIFT_NONE\n+\tThe shift cannot be done in a single instruction.\n+\n+   H8SX_SHIFT_UNARY\n+\tThe shift is effectively a unary operation.  The instruction will\n+\tallow any sort of destination operand and have a format similar\n+\tto neg and not.  This is true of certain power-of-2 shifts.\n+\n+   H8SX_SHIFT_BINARY\n+\tThe shift is a binary operation.  The destination must be a\n+\tregister and the source can be a register or a constant.  */\n+enum h8sx_shift_type\n+{\n+  H8SX_SHIFT_NONE,\n+  H8SX_SHIFT_UNARY,\n+  H8SX_SHIFT_BINARY\n+};\n+\n+/* For a general two-operand instruction, element [X][Y] gives\n+   the length of the opcode fields when the first operand has class\n+   (X + 1) and the second has class Y.  */\n+typedef unsigned char h8300_length_table[NUM_H8OPS - 1][NUM_H8OPS];\n+\n /* Forward declarations.  */\n static const char *byte_reg (rtx, int);\n static int h8300_interrupt_function_p (tree);\n@@ -67,6 +118,22 @@ static void h8300_asm_named_section (const char *, unsigned int);\n #endif\n static int h8300_and_costs (rtx);\n static int h8300_shift_costs (rtx);\n+static void          h8300_push_pop               (int, int, int, int);\n+static int           h8300_stack_offset_p         (rtx, int);\n+static int           h8300_ldm_stm_regno          (rtx, int, int, int);\n+static int           h8300_ldm_stm_parallel       (rtvec, int, int);\n+static void          h8300_reorg                  (void);\n+static unsigned int  h8300_constant_length        (rtx);\n+static unsigned int  h8300_displacement_length    (rtx, int);\n+static unsigned int  h8300_classify_operand       (rtx, int, enum h8300_operand_class *);\n+static unsigned int  h8300_length_from_table      (rtx, rtx, const h8300_length_table *);\n+static unsigned int  h8300_unary_length           (rtx);\n+static unsigned int  h8300_short_immediate_length (rtx);\n+static unsigned int  h8300_bitfield_length        (rtx, rtx);\n+static unsigned int  h8300_binary_length          (rtx, const h8300_length_table *);\n+static bool          h8300_short_move_mem_p       (rtx, enum rtx_code);\n+static unsigned int  h8300_move_length            (rtx *, const h8300_length_table *);\n+enum h8sx_shift_type h8sx_classify_shift          (enum machine_mode, enum rtx_code, rtx);\n \n /* CPU_TYPE, says what cpu we're compiling for.  */\n int cpu_type;\n@@ -94,6 +161,9 @@ const char * const *h8_reg_names;\n \n const char *h8_push_op, *h8_pop_op, *h8_mov_op;\n \n+/* Value of MOVE_RATIO.  */\n+int h8300_move_ratio;\n+\n /* Machine-specific symbol_ref flags.  */\n #define SYMBOL_FLAG_FUNCVEC_FUNCTION\t(SYMBOL_FLAG_MACH_DEP << 0)\n #define SYMBOL_FLAG_EIGHTBIT_DATA\t(SYMBOL_FLAG_MACH_DEP << 1)\n@@ -328,6 +398,102 @@ h8300_init_once (void)\n       /* H8S */\n       shift_alg_hi[H8_S][SHIFT_ASHIFTRT][14] = SHIFT_LOOP;\n     }\n+\n+  /* Work out a value for MOVE_RATIO.  */\n+  if (!TARGET_H8300SX)\n+    {\n+      /* Memory-memory moves are quite expensive without the\n+\t h8sx instructions.  */\n+      h8300_move_ratio = 3;\n+    }\n+  else if (flag_omit_frame_pointer)\n+    {\n+      /* movmd sequences are fairly cheap when er6 isn't fixed.  They can\n+\t sometimes be as short as two individual memory-to-memory moves,\n+\t but since they use all the call-saved registers, it seems better\n+\t to allow up to three moves here.  */\n+      h8300_move_ratio = 4;\n+    }\n+  else if (optimize_size)\n+    {\n+      /* In this case we don't use movmd sequences since they tend\n+\t to be longer than calls to memcpy().  Memory-to-memory\n+\t moves are cheaper than for !TARGET_H8300SX, so it makes\n+\t sense to have a slightly higher threshold.  */\n+      h8300_move_ratio = 4;\n+    }\n+  else\n+    {\n+      /* We use movmd sequences for some moves since it can be quicker\n+\t than calling memcpy().  The sequences will need to save and\n+\t restore er6 though, so bump up the cost.  */\n+      h8300_move_ratio = 6;\n+    }\n+}\n+\n+/* Implement REG_CLASS_FROM_LETTER.\n+\n+   Some patterns need to use er6 as a scratch register.  This is\n+   difficult to arrange since er6 is the frame pointer and usually\n+   can't be spilled.\n+\n+   Such patterns should define two alternatives, one which allows only\n+   er6 and one which allows any general register.  The former alternative\n+   should have a 'd' constraint while the latter should be disparaged and\n+   use 'D'.\n+\n+   Normally, 'd' maps to DESTINATION_REGS and 'D' maps to GENERAL_REGS.\n+   However, there are cases where they should be NO_REGS:\n+\n+     - 'd' should be NO_REGS when reloading a function that uses the\n+       frame pointer.  In this case, DESTINATION_REGS won't contain any\n+       spillable registers, so the first alternative can't be used.\n+\n+     - -fno-omit-frame-pointer means that the frame pointer will\n+       always be in use.  It's therefore better to map 'd' to NO_REGS\n+       before reload so that register allocator will pick the second\n+       alternative.\n+\n+     - we would like 'D' to be be NO_REGS when the frame pointer isn't\n+       live, but we the frame pointer may turn out to be needed after\n+       we start reload, and then we may have already decided we don't\n+       have a choice, so we can't do that.  Forcing the register\n+       allocator to use er6 if possible might produce better code for\n+       small functions: it's more efficient to save and restore er6 in\n+       the prologue & epilogue than to do it in a define_split.\n+       Hopefully disparaging 'D' will have a similar effect, without\n+       forcing a reload failure if the frame pointer is found to be\n+       needed too late.  */\n+\n+enum reg_class\n+h8300_reg_class_from_letter (int c)\n+{\n+  switch (c)\n+    {\n+    case 'a':\n+      return MAC_REGS;\n+\n+    case 'c':\n+      return COUNTER_REGS;\n+\n+    case 'd':\n+      if (!flag_omit_frame_pointer && !reload_completed)\n+\treturn NO_REGS;\n+      if (frame_pointer_needed && reload_in_progress)\n+\treturn NO_REGS;\n+      return DESTINATION_REGS;\n+\n+    case 'D':\n+      /* The meaning of a constraint shouldn't change dynamically, so\n+\t we can't make this NO_REGS.  */\n+      return GENERAL_REGS;\n+\n+    case 'f':\n+      return SOURCE_REGS;\n+\n+    default:\n+      return NO_REGS;\n+    }\n }\n \n /* Return the byte register name for a register rtx X.  B should be 0\n@@ -474,6 +640,196 @@ pop (int rn)\n   REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_INC, stack_pointer_rtx, 0);\n }\n \n+/* Emit an instruction to push or pop NREGS consecutive registers\n+   starting at register REGNO.  POP_P selects a pop rather than a\n+   push and RETURN_P is true if the instruction should return.\n+\n+   It must be possible to do the requested operation in a single\n+   instruction.  If NREGS == 1 && !RETURN_P, use a normal push\n+   or pop insn.  Otherwise emit a parallel of the form:\n+\n+     (parallel\n+       [(return)  ;; if RETURN_P\n+\t(save or restore REGNO)\n+\t(save or restore REGNO + 1)\n+\t...\n+\t(save or restore REGNO + NREGS - 1)\n+\t(set sp (plus sp (const_int adjust)))]  */\n+\n+static void\n+h8300_push_pop (int regno, int nregs, int pop_p, int return_p)\n+{\n+  int i, j;\n+  rtvec vec;\n+  rtx sp, offset;\n+\n+  /* See whether we can use a simple push or pop.  */\n+  if (!return_p && nregs == 1)\n+    {\n+      if (pop_p)\n+\tpop (regno);\n+      else\n+\tpush (regno);\n+      return;\n+    }\n+\n+  /* We need one element for the return insn, if present, one for each\n+     register, and one for stack adjustment.  */\n+  vec = rtvec_alloc ((return_p != 0) + nregs + 1);\n+  sp = stack_pointer_rtx;\n+  i = 0;\n+\n+  /* Add the return instruction.  */\n+  if (return_p)\n+    {\n+      RTVEC_ELT (vec, i) = gen_rtx_RETURN (VOIDmode);\n+      i++;\n+    }\n+\n+  /* Add the register moves.  */\n+  for (j = 0; j < nregs; j++)\n+    {\n+      rtx lhs, rhs;\n+\n+      if (pop_p)\n+\t{\n+\t  /* Register REGNO + NREGS - 1 is popped first.  Before the\n+\t     stack adjustment, its slot is at address @sp.  */\n+\t  lhs = gen_rtx_REG (SImode, regno + j);\n+\t  rhs = gen_rtx_MEM (SImode, plus_constant (sp, (nregs - j - 1) * 4));\n+\t}\n+      else\n+\t{\n+\t  /* Register REGNO is pushed first and will be stored at @(-4,sp).  */\n+\t  lhs = gen_rtx_MEM (SImode, plus_constant (sp, (j + 1) * -4));\n+\t  rhs = gen_rtx_REG (SImode, regno + j);\n+\t}\n+      RTVEC_ELT (vec, i + j) = gen_rtx_SET (VOIDmode, lhs, rhs);\n+    }\n+\n+  /* Add the stack adjustment.  */\n+  offset = GEN_INT ((pop_p ? nregs : -nregs) * 4);\n+  RTVEC_ELT (vec, i + j) = gen_rtx_SET (VOIDmode, sp,\n+\t\t\t\t\tgen_rtx_PLUS (Pmode, sp, offset));\n+\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n+}\n+\n+/* Return true if X has the value sp + OFFSET.  */\n+\n+static int\n+h8300_stack_offset_p (rtx x, int offset)\n+{\n+  if (offset == 0)\n+    return x == stack_pointer_rtx;\n+\n+  return (GET_CODE (x) == PLUS\n+\t  && XEXP (x, 0) == stack_pointer_rtx\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (x, 1)) == offset);\n+}\n+\n+/* A subroutine of h8300_ldm_stm_parallel.  X is one pattern in\n+   something that may be an ldm or stm instruction.  If it fits\n+   the required template, return the register it loads or stores,\n+   otherwise return -1.\n+\n+   LOAD_P is true if X should be a load, false if it should be a store.\n+   NREGS is the number of registers that the whole instruction is expected\n+   to load or store.  INDEX is the index of the register that X should\n+   load or store, relative to the lowest-numbered register.  */\n+\n+static int\n+h8300_ldm_stm_regno (rtx x, int load_p, int index, int nregs)\n+{\n+  int regindex, memindex, offset;\n+\n+  if (load_p)\n+    regindex = 0, memindex = 1, offset = (nregs - index - 1) * 4;\n+  else\n+    memindex = 0, regindex = 1, offset = (index + 1) * -4;\n+\n+  if (GET_CODE (x) == SET\n+      && GET_CODE (XEXP (x, regindex)) == REG\n+      && GET_CODE (XEXP (x, memindex)) == MEM\n+      && h8300_stack_offset_p (XEXP (XEXP (x, memindex), 0), offset))\n+    return REGNO (XEXP (x, regindex));\n+\n+  return -1;\n+}\n+\n+/* Return true if the elements of VEC starting at FIRST describe an\n+   ldm or stm instruction (LOAD_P says which).  */\n+\n+static int\n+h8300_ldm_stm_parallel (rtvec vec, int load_p, int first)\n+{\n+  rtx last;\n+  int nregs, i, regno, adjust;\n+\n+  /* There must be a stack adjustment, a register move, and at least one\n+     other operation (a return or another register move).  */\n+  if (GET_NUM_ELEM (vec) < 3)\n+    return false;\n+\n+  /* Get the range of registers to be pushed or popped.  */\n+  nregs = GET_NUM_ELEM (vec) - first - 1;\n+  regno = h8300_ldm_stm_regno (RTVEC_ELT (vec, first), load_p, 0, nregs);\n+\n+  /* Check that the call to h8300_ldm_stm_regno succeeded and\n+     that we're only dealing with GPRs.  */\n+  if (regno < 0 || regno + nregs > 8)\n+    return false;\n+\n+  /* 2-register h8s instructions must start with an even-numbered register.\n+     3- and 4-register instructions must start with er0 or er4.  */\n+  if (!TARGET_H8300SX)\n+    {\n+      if ((regno & 1) != 0)\n+\treturn false;\n+      if (nregs > 2 && (regno & 3) != 0)\n+\treturn false;\n+    }\n+\n+  /* Check the other loads or stores.  */\n+  for (i = 1; i < nregs; i++)\n+    if (h8300_ldm_stm_regno (RTVEC_ELT (vec, first + i), load_p, i, nregs)\n+\t!= regno + i)\n+      return false;\n+\n+  /* Check the stack adjustment.  */\n+  last = RTVEC_ELT (vec, first + nregs);\n+  adjust = (load_p ? nregs : -nregs) * 4;\n+  return (GET_CODE (last) == SET\n+\t  && SET_DEST (last) == stack_pointer_rtx\n+\t  && h8300_stack_offset_p (SET_SRC (last), adjust));\n+}\n+\n+/* Return true if X is an ldm.l pattern.  X is known to be parallel.  */\n+\n+int\n+h8300_ldm_parallel (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return h8300_ldm_stm_parallel (XVEC (x, 0), 1, 0);\n+}\n+\n+/* Likewise stm.l.  */\n+\n+int\n+h8300_stm_parallel (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return h8300_ldm_stm_parallel (XVEC (x, 0), 0, 0);\n+}\n+\n+/* Likewise rts/l and rte/l.  Note that the .md pattern will check\n+   for the return so there's no need to do that here.  */\n+\n+int\n+h8300_return_parallel (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return h8300_ldm_stm_parallel (XVEC (x, 0), 1, 1);\n+}\n+\n /* This is what the stack looks like after the prolog of\n    a function with a frame has been set up:\n \n@@ -529,42 +885,20 @@ h8300_expand_prologue (void)\n \t  if (TARGET_H8300S)\n \t    {\n \t      /* See how many registers we can push at the same time.  */\n-\t      if ((regno == 0 || regno == 4)\n+\t      if ((!TARGET_H8300SX || (regno & 3) == 0)\n \t\t  && ((saved_regs >> regno) & 0x0f) == 0x0f)\n \t\tn_regs = 4;\n \n-\t      else if ((regno == 0 || regno == 4)\n+\t      else if ((!TARGET_H8300SX || (regno & 3) == 0)\n \t\t       && ((saved_regs >> regno) & 0x07) == 0x07)\n \t\tn_regs = 3;\n \n-\t      else if ((regno == 0 || regno == 2 || regno == 4 || regno == 6)\n+\t      else if ((!TARGET_H8300SX || (regno & 1) == 0)\n \t\t       && ((saved_regs >> regno) & 0x03) == 0x03)\n \t\tn_regs = 2;\n \t    }\n \n-\t  switch (n_regs)\n-\t    {\n-\t    case 1:\n-\t      push (regno);\n-\t      break;\n-\t    case 2:\n-\t      emit_insn (gen_stm_h8300s_2 (gen_rtx_REG (SImode, regno),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno + 1)));\n-\t      break;\n-\t    case 3:\n-\t      emit_insn (gen_stm_h8300s_3 (gen_rtx_REG (SImode, regno),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno + 1),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno + 2)));\n-\t      break;\n-\t    case 4:\n-\t      emit_insn (gen_stm_h8300s_4 (gen_rtx_REG (SImode, regno),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno + 1),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno + 2),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno + 3)));\n-\t      break;\n-\t    default:\n-\t      abort ();\n-\t    }\n+\t  h8300_push_pop (regno, n_regs, 0, 0);\n \t}\n     }\n \n@@ -592,14 +926,19 @@ h8300_expand_epilogue (void)\n   int regno;\n   int saved_regs;\n   int n_regs;\n+  HOST_WIDE_INT frame_size;\n+  bool returned_p;\n \n   if (h8300_os_task_function_p (current_function_decl))\n     /* OS_Task epilogues are nearly naked -- they just have an\n        rts instruction.  */\n     return;\n \n+  frame_size = round_frame_size (get_frame_size ());\n+  returned_p = false;\n+\n   /* Deallocate locals.  */\n-  h8300_emit_stack_adjustment (1, round_frame_size (get_frame_size ()));\n+  h8300_emit_stack_adjustment (1, frame_size);\n \n   /* Pop the saved registers in descending order.  */\n   saved_regs = compute_saved_regs ();\n@@ -611,48 +950,41 @@ h8300_expand_epilogue (void)\n \t  if (TARGET_H8300S)\n \t    {\n \t      /* See how many registers we can pop at the same time.  */\n-\t      if ((regno == 7 || regno == 3)\n-\t\t  && ((saved_regs >> (regno - 3)) & 0x0f) == 0x0f)\n+\t      if ((TARGET_H8300SX || (regno & 3) == 3)\n+\t\t  && ((saved_regs << 3 >> regno) & 0x0f) == 0x0f)\n \t\tn_regs = 4;\n \n-\t      else if ((regno == 6 || regno == 2)\n-\t\t       && ((saved_regs >> (regno - 2)) & 0x07) == 0x07)\n+\t      else if ((TARGET_H8300SX || (regno & 3) == 2)\n+\t\t       && ((saved_regs << 2 >> regno) & 0x07) == 0x07)\n \t\tn_regs = 3;\n \n-\t      else if ((regno == 7 || regno == 5 || regno == 3 || regno == 1)\n-\t\t       && ((saved_regs >> (regno - 1)) & 0x03) == 0x03)\n+\t      else if ((TARGET_H8300SX || (regno & 1) == 1)\n+\t\t       && ((saved_regs << 1 >> regno) & 0x03) == 0x03)\n \t\tn_regs = 2;\n \t    }\n \n-\t  switch (n_regs)\n-\t    {\n-\t    case 1:\n-\t      pop (regno);\n-\t      break;\n-\t    case 2:\n-\t      emit_insn (gen_ldm_h8300s_2 (gen_rtx_REG (SImode, regno - 1),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno)));\n-\t      break;\n-\t    case 3:\n-\t      emit_insn (gen_ldm_h8300s_3 (gen_rtx_REG (SImode, regno - 2),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno - 1),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno)));\n-\t      break;\n-\t    case 4:\n-\t      emit_insn (gen_ldm_h8300s_4 (gen_rtx_REG (SImode, regno - 3),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno - 2),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno - 1),\n-\t\t\t\t\t   gen_rtx_REG (SImode, regno)));\n-\t      break;\n-\t    default:\n-\t      abort ();\n-\t    }\n+\t  /* See if this pop would be the last insn before the return.\n+\t     If so, use rte/l or rts/l instead of pop or ldm.l.  */\n+\t  if (TARGET_H8300SX\n+\t      && !frame_pointer_needed\n+\t      && frame_size == 0\n+\t      && (saved_regs & ((1 << (regno - n_regs + 1)) - 1)) == 0)\n+\t    returned_p = true;\n+\n+\t  h8300_push_pop (regno - n_regs + 1, n_regs, 1, returned_p);\n \t}\n     }\n \n   /* Pop frame pointer if we had one.  */\n   if (frame_pointer_needed)\n-    pop (HARD_FRAME_POINTER_REGNUM);\n+    {\n+      if (TARGET_H8300SX)\n+\treturned_p = true;\n+      h8300_push_pop (HARD_FRAME_POINTER_REGNUM, 1, 1, returned_p);\n+    }\n+\n+  if (!returned_p)\n+    emit_insn (gen_rtx_RETURN (VOIDmode));\n }\n \n /* Return nonzero if the current function is an interrupt\n@@ -674,6 +1006,8 @@ h8300_file_start (void)\n \n   if (TARGET_H8300H)\n     fputs (TARGET_NORMAL_MODE ? \"\\t.h8300hn\\n\" : \"\\t.h8300h\\n\", asm_out_file);\n+  else if (TARGET_H8300SX)\n+    fputs (TARGET_NORMAL_MODE ? \"\\t.h8300sxn\\n\" : \"\\t.h8300sx\\n\", asm_out_file);\n   else if (TARGET_H8300S)\n     fputs (TARGET_NORMAL_MODE ? \"\\t.h8300sn\\n\" : \"\\t.h8300s\\n\", asm_out_file);\n }\n@@ -712,6 +1046,46 @@ general_operand_dst (rtx op, enum machine_mode mode)\n   return general_operand (op, mode);\n }\n \n+/* Return true if OP is a suitable first operand for a general arithmetic\n+   insn such as \"add\".  */\n+\n+int\n+h8300_dst_operand (rtx op, enum machine_mode mode)\n+{\n+  if (TARGET_H8300SX)\n+    return nonimmediate_operand (op, mode);\n+  return register_operand (op, mode);\n+}\n+\n+/* Likewise the second operand.  */\n+\n+int\n+h8300_src_operand (rtx op, enum machine_mode mode)\n+{\n+  if (TARGET_H8300SX)\n+    return general_operand (op, mode);\n+  return nonmemory_operand (op, mode);\n+}\n+\n+/* Check that an operand is either a register or an unsigned 4-bit\n+   constant.  */\n+\n+int\n+nibble_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (op) == CONST_INT && TARGET_H8300SX\n+\t  && INTVAL (op) >= 0 && INTVAL (op) <= 15);\n+}\n+\n+/* Check that an operand is either a register or an unsigned 4-bit\n+   constant.  */\n+\n+int\n+reg_or_nibble_operand (rtx op, enum machine_mode mode)\n+{\n+  return (nibble_operand (op, mode) || register_operand (op, mode));\n+}\n+\n /* Return true if OP is a constant that contains only one 1 in its\n    binary representation.  */\n \n@@ -769,6 +1143,9 @@ call_insn_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n two_insn_adds_subs_operand (rtx op, enum machine_mode mode)\n {\n+  if (TARGET_H8300SX)\n+    return 0;\n+\n   if (GET_CODE (op) == CONST_INT)\n     {\n       HOST_WIDE_INT value = INTVAL (op);\n@@ -901,11 +1278,15 @@ jump_address_operand (rtx op, enum machine_mode mode)\n int\n bit_operand (rtx op, enum machine_mode mode)\n {\n-  /* We can accept any general operand, except that MEM operands must\n+  /* We can accept any nonimmediate operand, except that MEM operands must\n      be limited to those that use addresses valid for the 'U' constraint.  */\n-  if (!general_operand (op, mode))\n+  if (!nonimmediate_operand (op, mode))\n     return 0;\n \n+  /* H8SX accepts pretty much anything here.  */\n+  if (TARGET_H8300SX)\n+    return 1;\n+\n   /* Accept any mem during RTL generation.  Otherwise, the code that does\n      insv and extzv will think that we can not handle memory.  However,\n      to avoid reload problems, we only accept 'U' MEM operands after RTL\n@@ -917,7 +1298,7 @@ bit_operand (rtx op, enum machine_mode mode)\n   if (GET_CODE (op) == SUBREG)\n     return 1;\n   return (GET_CODE (op) == MEM\n-\t  && EXTRA_CONSTRAINT (op, 'U'));\n+\t  && OK_FOR_U (op));\n }\n \n /* Return nonzero if OP is a MEM suitable for bit manipulation insns.  */\n@@ -926,7 +1307,7 @@ int\n bit_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == MEM\n-\t  && EXTRA_CONSTRAINT (op, 'U'));\n+\t  && OK_FOR_U (op));\n }\n \n /* Handle machine specific pragmas for compatibility with existing\n@@ -1038,7 +1419,7 @@ h8300_and_costs (rtx x)\n     return 100;\n \n   operands[0] = NULL;\n-  operands[1] = NULL;\n+  operands[1] = XEXP (x, 0);\n   operands[2] = XEXP (x, 1);\n   operands[3] = x;\n   return compute_logical_op_length (GET_MODE (x), operands) / 2;\n@@ -1068,12 +1449,35 @@ h8300_shift_costs (rtx x)\n static bool\n h8300_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n+  if (TARGET_H8300SX && outer_code == MEM)\n+    {\n+      /* Estimate the number of execution states needed to calculate\n+\t the address.  */\n+      if (register_operand (x, VOIDmode)\n+\t  || GET_CODE (x) == POST_INC\n+\t  || GET_CODE (x) == POST_DEC\n+\t  || CONSTANT_P (x))\n+\t*total = 0;\n+      else\n+\t*total = COSTS_N_INSNS (1);\n+      return true;\n+    }\n+\n   switch (code)\n     {\n     case CONST_INT:\n       {\n \tHOST_WIDE_INT n = INTVAL (x);\n \n+\tif (TARGET_H8300SX)\n+\t  {\n+\t    /* Constant operands need the same number of processor\n+\t       states as register operands.  Although we could try to\n+\t       use a size-based cost for optimize_size, the lack of\n+\t       of a mode makes the results very unpredictable.  */\n+\t    *total = 0;\n+\t    return true;\n+\t  }\n \tif (-4 <= n || n <= 4)\n \t  {\n \t    switch ((int) n)\n@@ -1103,6 +1507,12 @@ h8300_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:\n+      if (TARGET_H8300SX)\n+\t{\n+\t  /* See comment for CONST_INT.  */\n+\t  *total = 0;\n+\t  return true;\n+\t}\n       *total = 3;\n       return true;\n \n@@ -1111,23 +1521,68 @@ h8300_rtx_costs (rtx x, int code, int outer_code, int *total)\n       return true;\n \n     case AND:\n+      if (!h8300_dst_operand (XEXP (x, 0), VOIDmode)\n+\t  || !h8300_src_operand (XEXP (x, 1), VOIDmode))\n+\treturn false;\n       *total = COSTS_N_INSNS (h8300_and_costs (x));\n       return true;\n \n     /* We say that MOD and DIV are so expensive because otherwise we'll\n        generate some really horrible code for division of a power of two.  */\n     case MOD:\n     case DIV:\n-      *total = 60;\n+    case UMOD:\n+    case UDIV:\n+      if (TARGET_H8300SX)\n+\tswitch (GET_MODE (x))\n+\t  {\n+\t  case QImode:\n+\t  case HImode:\n+\t    *total = COSTS_N_INSNS (optimize_size ? 4 : 10);\n+\t    return false;\n+\n+\t  case SImode:\n+\t    *total = COSTS_N_INSNS (optimize_size ? 4 : 18);\n+\t    return false;\n+\n+\t  default:\n+\t    break;\n+\t  }\n+      *total = COSTS_N_INSNS (12);\n       return true;\n \n     case MULT:\n-      *total = 20;\n+      if (TARGET_H8300SX)\n+\tswitch (GET_MODE (x))\n+\t  {\n+\t  case QImode:\n+\t  case HImode:\n+\t    *total = COSTS_N_INSNS (2);\n+\t    return false;\n+\n+\t  case SImode:\n+\t    *total = COSTS_N_INSNS (5);\n+\t    return false;\n+\n+\t  default:\n+\t    break;\n+\t  }\n+      *total = COSTS_N_INSNS (4);\n       return true;\n \n     case ASHIFT:\n     case ASHIFTRT:\n     case LSHIFTRT:\n+      if (h8sx_binary_shift_operator (x, VOIDmode))\n+\t{\n+\t  *total = COSTS_N_INSNS (2);\n+\t  return false;\n+\t}\n+      else if (h8sx_unary_shift_operator (x, VOIDmode))\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return false;\n+\t}\n       *total = COSTS_N_INSNS (h8300_shift_costs (x));\n       return true;\n \n@@ -1140,8 +1595,8 @@ h8300_rtx_costs (rtx x, int code, int outer_code, int *total)\n       return true;\n \n     default:\n-      *total = 4;\n-      return true;\n+      *total = COSTS_N_INSNS (1);\n+      return false;\n     }\n }\n \f\n@@ -1167,6 +1622,8 @@ h8300_rtx_costs (rtx x, int code, int outer_code, int *total)\n        then +2. if const then least sig word\n    'j' print operand as condition code.\n    'k' print operand as reverse condition code.\n+   'm' convert an integer operand to a size suffix (.b, .w or .l)\n+   'o' print an integer without a leading '#'\n    's' print as low byte of 16 bit value\n    't' print as high byte of 16 bit value\n    'w' print as low byte of 32 bit value\n@@ -1373,6 +1830,21 @@ print_operand (FILE *file, rtx x, int code)\n     case 'k':\n       fputs (cond_string (reverse_condition (GET_CODE (x))), file);\n       break;\n+    case 'm':\n+      if (GET_CODE (x) != CONST_INT)\n+\tabort ();\n+      if (INTVAL (x) == 1)\n+\tfputs (\".b\", file);\n+      else if (INTVAL (x) == 2)\n+\tfputs (\".w\", file);\n+      else if (INTVAL (x) == 4)\n+\tfputs (\".l\", file);\n+      else\n+\tabort ();\n+      break;\n+    case 'o':\n+      print_operand_address (file, x);\n+      break;\n     case 's':\n       if (GET_CODE (x) == CONST_INT)\n \tfprintf (file, \"#%ld\", (INTVAL (x)) & 0xff);\n@@ -1445,32 +1917,41 @@ print_operand (FILE *file, rtx x, int code)\n \t    fprintf (file, \"@\");\n \t    output_address (addr);\n \n-\t    /* We fall back from smaller addressing to larger\n-\t       addressing in various ways depending on CODE.  */\n-\t    switch (code)\n-\t      {\n-\t      case 'R':\n-\t\t/* Used for mov.b and bit operations.  */\n-\t\tif (h8300_eightbit_constant_address_p (addr))\n-\t\t  {\n-\t\t    fprintf (file, \":8\");\n-\t\t    break;\n-\t\t  }\n-\n-\t\t/* Fall through.  We should not get here if we are\n-\t\t   processing bit operations on H8/300 or H8/300H\n-\t\t   because 'U' constraint does not allow bit\n-\t\t   operations on the tiny area on these machines.  */\n-\n-\t      case 'T':\n-\t      case 'S':\n-\t\t/* Used for mov.w and mov.l.  */\n-\t\tif (h8300_tiny_constant_address_p (addr))\n-\t\t  fprintf (file, \":16\");\n-\t\tbreak;\n-\t      default:\n-\t\tbreak;\n-\t      }\n+\t    /* Add a length suffix to constant addresses.  Although this\n+\t       is often unnecessary, it helps to avoid ambiguity in the\n+\t       syntax of mova.  If we wrote an insn like:\n+\n+\t\t    mova/w.l @(1,@foo.b),er0\n+\n+\t       then .b would be considered part of the symbol name.\n+\t       Adding a length after foo will avoid this.  */\n+\t    if (CONSTANT_P (addr))\n+\t      switch (code)\n+\t\t{\n+\t\tcase 'R':\n+\t\t  /* Used for mov.b and bit operations.  */\n+\t\t  if (h8300_eightbit_constant_address_p (addr))\n+\t\t    {\n+\t\t      fprintf (file, \":8\");\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  /* Fall through.  We should not get here if we are\n+\t\t     processing bit operations on H8/300 or H8/300H\n+\t\t     because 'U' constraint does not allow bit\n+\t\t     operations on the tiny area on these machines.  */\n+\n+\t\tcase 'X':\n+\t\tcase 'T':\n+\t\tcase 'S':\n+\t\t  if (h8300_constant_length (addr) == 2)\n+\t\t    fprintf (file, \":16\");\n+\t\t  else\n+\t\t    fprintf (file, \":32\");\n+\t\t  break;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n \t  }\n \t  break;\n \n@@ -1501,6 +1982,9 @@ print_operand (FILE *file, rtx x, int code)\n void\n print_operand_address (FILE *file, rtx addr)\n {\n+  rtx index;\n+  int size;\n+\n   switch (GET_CODE (addr))\n     {\n     case REG:\n@@ -1515,14 +1999,45 @@ print_operand_address (FILE *file, rtx addr)\n       fprintf (file, \"%s+\", h8_reg_names[REGNO (XEXP (addr, 0))]);\n       break;\n \n+    case PRE_INC:\n+      fprintf (file, \"+%s\", h8_reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case POST_DEC:\n+      fprintf (file, \"%s-\", h8_reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n     case PLUS:\n       fprintf (file, \"(\");\n-      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\n+      index = h8300_get_index (XEXP (addr, 0), VOIDmode, &size);\n+      if (GET_CODE (index) == REG)\n \t{\n \t  /* reg,foo */\n \t  print_operand_address (file, XEXP (addr, 1));\n \t  fprintf (file, \",\");\n-\t  print_operand_address (file, XEXP (addr, 0));\n+\t  switch (size)\n+\t    {\n+\t    case 0:\n+\t      print_operand_address (file, index);\n+\t      break;\n+\n+\t    case 1:\n+\t      print_operand (file, index, 'X');\n+\t      fputs (\".b\", file);\n+\t      break;\n+\n+\t    case 2:\n+\t      print_operand (file, index, 'T');\n+\t      fputs (\".w\", file);\n+\t      break;\n+\n+\t    case 4:\n+\t      print_operand (file, index, 'S');\n+\t      fputs (\".l\", file);\n+\t      break;\n+\t    }\n+\t  /* print_operand_address (file, XEXP (addr, 0)); */\n \t}\n       else\n \t{\n@@ -1731,125 +2246,826 @@ notice_update_cc (rtx body, rtx insn)\n \t}\n       break;\n \n-    case CC_COMPARE:\n-      /* The insn is a compare instruction.  */\n-      CC_STATUS_INIT;\n-      cc_status.value1 = SET_SRC (body);\n-      break;\n+    case CC_COMPARE:\n+      /* The insn is a compare instruction.  */\n+      CC_STATUS_INIT;\n+      cc_status.value1 = SET_SRC (body);\n+      break;\n+\n+    case CC_CLOBBER:\n+      /* Insn doesn't leave CC in a usable state.  */\n+      CC_STATUS_INIT;\n+      break;\n+    }\n+}\n+\n+/* Return nonzero if X is a stack pointer.  */\n+\n+int\n+stack_pointer_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return x == stack_pointer_rtx;\n+}\n+\n+/* Return nonzero if X is a constant whose absolute value is greater\n+   than 2.  */\n+\n+int\n+const_int_gt_2_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (x) == CONST_INT\n+\t  && abs (INTVAL (x)) > 2);\n+}\n+\n+/* Return nonzero if X is a constant whose absolute value is no\n+   smaller than 8.  */\n+\n+int\n+const_int_ge_8_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (x) == CONST_INT\n+\t  && abs (INTVAL (x)) >= 8);\n+}\n+\n+/* Return nonzero if X is a constant expressible in QImode.  */\n+\n+int\n+const_int_qi_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (x) == CONST_INT\n+\t  && (INTVAL (x) & 0xff) == INTVAL (x));\n+}\n+\n+/* Return nonzero if X is a constant expressible in HImode.  */\n+\n+int\n+const_int_hi_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (x) == CONST_INT\n+\t  && (INTVAL (x) & 0xffff) == INTVAL (x));\n+}\n+\n+/* Return nonzero if X is a constant suitable for inc/dec.  */\n+\n+int\n+incdec_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (x) == CONST_INT\n+\t  && (CONST_OK_FOR_M (INTVAL (x))\n+\t      || CONST_OK_FOR_O (INTVAL (x))));\n+}\n+\n+/* Return nonzero if X is either EQ or NE.  */\n+\n+int\n+eqne_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+\n+  return (code == EQ || code == NE);\n+}\n+\n+/* Return nonzero if X is either GT or LE.  */\n+\n+int\n+gtle_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+\n+  return (code == GT || code == LE);\n+}\n+\n+/* Return nonzero if X is either GTU or LEU.  */\n+\n+int\n+gtuleu_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+\n+  return (code == GTU || code == LEU);\n+}\n+\n+/* Return nonzero if X is either IOR or XOR.  */\n+\n+int\n+iorxor_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+\n+  return (code == IOR || code == XOR);\n+}\n+\n+/* Recognize valid operators for bit instructions.  */\n+\n+int\n+bit_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+\n+  return (code == XOR\n+\t  || code == AND\n+\t  || code == IOR);\n+}\n+\f\n+/* Given that X occurs in an address of the form (plus X constant),\n+   return the part of X that is expected to be a register.  There are\n+   four kinds of addressing mode to recognize:\n+\n+\t@(dd,Rn)\n+\t@(dd,RnL.b)\n+\t@(dd,Rn.w)\n+\t@(dd,ERn.l)\n+\n+   If SIZE is nonnull, and the address is one of the last three forms,\n+   set *SIZE to the index multiplication factor.  Set it to 0 for\n+   plain @(dd,Rn) addresses.\n+\n+   MODE is the mode of the value being accessed.  It can be VOIDmode\n+   if the address is known to be valid, but its mode is unknown.  */\n+\n+rtx\n+h8300_get_index (rtx x, enum machine_mode mode, int *size)\n+{\n+  int dummy, factor;\n+\n+  if (size == 0)\n+    size = &dummy;\n+\n+  factor = (mode == VOIDmode ? 0 : GET_MODE_SIZE (mode));\n+  if (TARGET_H8300SX\n+      && factor <= 4\n+      && (mode == VOIDmode\n+\t  || GET_MODE_CLASS (mode) == MODE_INT\n+\t  || GET_MODE_CLASS (mode) == MODE_FLOAT))\n+    {\n+      if (factor <= 1 && GET_CODE (x) == ZERO_EXTEND)\n+\t{\n+\t  /* When accessing byte-sized values, the index can be\n+\t     a zero-extended QImode or HImode register.  */\n+\t  *size = GET_MODE_SIZE (GET_MODE (XEXP (x, 0)));\n+\t  return XEXP (x, 0);\n+\t}\n+      else\n+\t{\n+\t  /* We're looking for addresses of the form:\n+\n+\t\t (mult X I)\n+\t      or (mult (zero_extend X) I)\n+\n+\t     where I is the size of the operand being accessed.\n+\t     The canonical form of the second expression is:\n+\n+\t\t (and (mult (subreg X) I) J)\n+\n+\t     where J == GET_MODE_MASK (GET_MODE (X)) * I.  */\n+\t  rtx index;\n+\n+\t  if (GET_CODE (x) == AND\n+\t      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t      && (factor == 0\n+\t\t  || INTVAL (XEXP (x, 1)) == 0xff * factor\n+\t\t  || INTVAL (XEXP (x, 1)) == 0xffff * factor))\n+\t    {\n+\t      index = XEXP (x, 0);\n+\t      *size = (INTVAL (XEXP (x, 1)) >= 0xffff ? 2 : 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      index = x;\n+\t      *size = 4;\n+\t    }\n+\n+\t  if (GET_CODE (index) == MULT\n+\t      && GET_CODE (XEXP (index, 1)) == CONST_INT\n+\t      && (factor == 0 || factor == INTVAL (XEXP (index, 1))))\n+\t    return XEXP (index, 0);\n+\t}\n+    }\n+  *size = 0;\n+  return x;\n+}\n+\f\n+static const h8300_length_table addb_length_table =\n+{\n+  /* #xx  Rs   @aa  @Rs  @xx  */\n+  {  2,   2,   4,   4,   4  }, /* add.b xx,Rd  */\n+  {  4,   4,   4,   4,   6  }, /* add.b xx,@aa */\n+  {  4,   4,   4,   4,   6  }, /* add.b xx,@Rd */\n+  {  6,   4,   4,   4,   6  }  /* add.b xx,@xx */\n+};\n+\n+static const h8300_length_table addw_length_table =\n+{\n+  /* #xx  Rs   @aa  @Rs  @xx  */\n+  {  2,   2,   4,   4,   4  }, /* add.w xx,Rd  */\n+  {  4,   4,   4,   4,   6  }, /* add.w xx,@aa */\n+  {  4,   4,   4,   4,   6  }, /* add.w xx,@Rd */\n+  {  4,   4,   4,   4,   6  }  /* add.w xx,@xx */\n+};\n+\n+static const h8300_length_table addl_length_table =\n+{\n+  /* #xx  Rs   @aa  @Rs  @xx  */\n+  {  2,   2,   4,   4,   4  }, /* add.l xx,Rd  */\n+  {  4,   4,   6,   6,   6  }, /* add.l xx,@aa */\n+  {  4,   4,   6,   6,   6  }, /* add.l xx,@Rd */\n+  {  4,   4,   6,   6,   6  }  /* add.l xx,@xx */\n+};\n+\n+#define logicb_length_table addb_length_table\n+#define logicw_length_table addw_length_table\n+\n+static const h8300_length_table logicl_length_table =\n+{\n+  /* #xx  Rs   @aa  @Rs  @xx  */\n+  {  2,   4,   4,   4,   4  }, /* and.l xx,Rd  */\n+  {  4,   4,   6,   6,   6  }, /* and.l xx,@aa */\n+  {  4,   4,   6,   6,   6  }, /* and.l xx,@Rd */\n+  {  4,   4,   6,   6,   6  }  /* and.l xx,@xx */\n+};\n+\n+static const h8300_length_table movb_length_table =\n+{\n+  /* #xx  Rs   @aa  @Rs  @xx  */\n+  {  2,   2,   2,   2,   4  }, /* mov.b xx,Rd  */\n+  {  4,   2,   4,   4,   4  }, /* mov.b xx,@aa */\n+  {  4,   2,   4,   4,   4  }, /* mov.b xx,@Rd */\n+  {  4,   4,   4,   4,   4  }  /* mov.b xx,@xx */\n+};\n+\n+#define movw_length_table movb_length_table\n+\n+static const h8300_length_table movl_length_table =\n+{\n+  /* #xx  Rs   @aa  @Rs  @xx  */\n+  {  2,   2,   4,   4,   4  }, /* mov.l xx,Rd  */\n+  {  4,   4,   4,   4,   4  }, /* mov.l xx,@aa */\n+  {  4,   4,   4,   4,   4  }, /* mov.l xx,@Rd */\n+  {  4,   4,   4,   4,   4  }  /* mov.l xx,@xx */\n+};\n+\n+/* Return the size of the given address or displacement constant.  */\n+\n+static unsigned int\n+h8300_constant_length (rtx constant)\n+{\n+  /* Check for (@d:16,Reg).  */\n+  if (GET_CODE (constant) == CONST_INT\n+      && IN_RANGE (INTVAL (constant), -0x8000, 0x7fff))\n+    return 2;\n+\n+  /* Check for (@d:16,Reg) in cases where the displacement is\n+     an absolute address.  */\n+  if (Pmode == HImode || h8300_tiny_constant_address_p (constant))\n+    return 2;\n+\n+  return 4;\n+}\n+\n+/* Return the size of a displacement field in address ADDR, which should\n+   have the form (plus X constant).  SIZE is the number of bytes being\n+   accessed.  */\n+\n+static unsigned int\n+h8300_displacement_length (rtx addr, int size)\n+{\n+  rtx offset;\n+\n+  offset = XEXP (addr, 1);\n+\n+  /* Check for @(d:2,Reg).  */\n+  if (register_operand (XEXP (addr, 0), VOIDmode)\n+      && GET_CODE (offset) == CONST_INT\n+      && (INTVAL (offset) == size\n+\t  || INTVAL (offset) == size * 2\n+\t  || INTVAL (offset) == size * 3))\n+    return 0;\n+\n+  return h8300_constant_length (offset);\n+}\n+\n+/* Store the class of operand OP in *CLASS and return the length of any\n+   extra operand fields.  SIZE is the number of bytes in OP.  CLASS\n+   can be null if only the length is needed.  */\n+\n+static unsigned int\n+h8300_classify_operand (rtx op, int size, enum h8300_operand_class *class)\n+{\n+  enum h8300_operand_class dummy;\n+\n+  if (class == 0)\n+    class = &dummy;\n+\n+  if (CONSTANT_P (op))\n+    {\n+      *class = H8OP_IMMEDIATE;\n+\n+      /* Byte-sized immediates are stored in the opcode fields.  */\n+      if (size == 1)\n+\treturn 0;\n+\n+      /* If this is a 32-bit instruction, see whether the constant\n+\t will fit into a 16-bit immediate field.  */\n+      if (TARGET_H8300SX\n+\t  && size == 4\n+\t  && GET_CODE (op) == CONST_INT\n+\t  && IN_RANGE (INTVAL (op), 0, 0xffff))\n+\treturn 2;\n+\n+      return size;\n+    }\n+  else if (GET_CODE (op) == MEM)\n+    {\n+      op = XEXP (op, 0);\n+      if (CONSTANT_P (op))\n+\t{\n+\t  *class = H8OP_MEM_ABSOLUTE;\n+\t  return h8300_constant_length (op);\n+\t}\n+      else if (GET_CODE (op) == PLUS && CONSTANT_P (XEXP (op, 1)))\n+\t{\n+\t  *class = H8OP_MEM_COMPLEX;\n+\t  return h8300_displacement_length (op, size);\n+\t}\n+      else if (GET_RTX_CLASS (GET_CODE (op)) == RTX_AUTOINC)\n+\t{\n+\t  *class = H8OP_MEM_COMPLEX;\n+\t  return 0;\n+\t}\n+      else if (register_operand (op, VOIDmode))\n+\t{\n+\t  *class = H8OP_MEM_BASE;\n+\t  return 0;\n+\t}\n+    }\n+  else if (register_operand (op, VOIDmode))\n+    {\n+      *class = H8OP_REGISTER;\n+      return 0;\n+    }\n+  abort ();\n+}\n+\n+/* Return the length of the instruction described by TABLE given that\n+   its operands are OP1 and OP2.  OP1 must be an h8300_dst_operand\n+   and OP2 must be an h8300_src_operand.  */\n+\n+static unsigned int\n+h8300_length_from_table (rtx op1, rtx op2, const h8300_length_table *table)\n+{\n+  enum h8300_operand_class op1_class, op2_class;\n+  unsigned int size, immediate_length;\n+\n+  size = GET_MODE_SIZE (GET_MODE (op1));\n+  immediate_length = (h8300_classify_operand (op1, size, &op1_class)\n+\t\t      + h8300_classify_operand (op2, size, &op2_class));\n+  return immediate_length + (*table)[op1_class - 1][op2_class];\n+}\n+\n+/* Return the length of a unary instruction such as neg or not given that\n+   its operand is OP.  */\n+\n+unsigned int\n+h8300_unary_length (rtx op)\n+{\n+  enum h8300_operand_class class;\n+  unsigned int size, operand_length;\n+\n+  size = GET_MODE_SIZE (GET_MODE (op));\n+  operand_length = h8300_classify_operand (op, size, &class);\n+  switch (class)\n+    {\n+    case H8OP_REGISTER:\n+      return 2;\n+\n+    case H8OP_MEM_BASE:\n+      return (size == 4 ? 6 : 4);\n+\n+    case H8OP_MEM_ABSOLUTE:\n+      return operand_length + (size == 4 ? 6 : 4);\n+\n+    case H8OP_MEM_COMPLEX:\n+      return operand_length + 6;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Likewise short immediate instructions such as add.w #xx:3,OP.  */\n+\n+static unsigned int\n+h8300_short_immediate_length (rtx op)\n+{\n+  enum h8300_operand_class class;\n+  unsigned int size, operand_length;\n+\n+  size = GET_MODE_SIZE (GET_MODE (op));\n+  operand_length = h8300_classify_operand (op, size, &class);\n+\n+  switch (class)\n+    {\n+    case H8OP_REGISTER:\n+      return 2;\n+\n+    case H8OP_MEM_BASE:\n+    case H8OP_MEM_ABSOLUTE:\n+    case H8OP_MEM_COMPLEX:\n+      return 4 + operand_length;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Likewise bitfield load and store instructions.  */\n \n-    case CC_CLOBBER:\n-      /* Insn doesn't leave CC in a usable state.  */\n-      CC_STATUS_INIT;\n-      break;\n+static unsigned int\n+h8300_bitfield_length (rtx op, rtx op2)\n+{\n+  enum h8300_operand_class class;\n+  unsigned int size, operand_length;\n+\n+  if (GET_CODE (op) == REG)\n+    op = op2;\n+  if (GET_CODE (op) == REG)\n+    abort ();\n+  \n+  size = GET_MODE_SIZE (GET_MODE (op));\n+  operand_length = h8300_classify_operand (op, size, &class);\n+\n+  switch (class)\n+    {\n+    case H8OP_MEM_BASE:\n+    case H8OP_MEM_ABSOLUTE:\n+    case H8OP_MEM_COMPLEX:\n+      return 4 + operand_length;\n+\n+    default:\n+      abort ();\n     }\n }\n \n-/* Return nonzero if X is a stack pointer.  */\n+/* Calculate the length of general binary instruction INSN using TABLE.  */\n \n-int\n-stack_pointer_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+static unsigned int\n+h8300_binary_length (rtx insn, const h8300_length_table *table)\n {\n-  return x == stack_pointer_rtx;\n+  rtx set;\n+\n+  set = single_set (insn);\n+  if (set == 0)\n+    abort ();\n+\n+  if (BINARY_P (SET_SRC (set)))\n+    return h8300_length_from_table (XEXP (SET_SRC (set), 0),\n+\t\t\t\t    XEXP (SET_SRC (set), 1), table);\n+  else if (GET_RTX_CLASS (GET_CODE (SET_SRC (set))) == RTX_TERNARY)\n+    return h8300_length_from_table (XEXP (XEXP (SET_SRC (set), 1), 0),\n+\t\t\t\t    XEXP (XEXP (SET_SRC (set), 1), 1),\n+\t\t\t\t    table);\n+  else\n+    abort ();\n }\n \n-/* Return nonzero if X is a constant whose absolute value is greater\n-   than 2.  */\n+/* Subroutine of h8300_move_length.  Return true if OP is 1- or 2-byte\n+   memory reference and either (1) it has the form @(d:16,Rn) or\n+   (2) its address has the code given by INC_CODE.  */\n \n-int\n-const_int_gt_2_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+static bool\n+h8300_short_move_mem_p (rtx op, enum rtx_code inc_code)\n {\n-  return (GET_CODE (x) == CONST_INT\n-\t  && abs (INTVAL (x)) > 2);\n+  rtx addr;\n+  unsigned int size;\n+\n+  if (GET_CODE (op) != MEM)\n+    return false;\n+\n+  addr = XEXP (op, 0);\n+  size = GET_MODE_SIZE (GET_MODE (op));\n+  if (size != 1 && size != 2)\n+    return false;\n+\n+  return (GET_CODE (addr) == inc_code\n+\t  || (GET_CODE (addr) == PLUS\n+\t      && GET_CODE (XEXP (addr, 0)) == REG\n+\t      && h8300_displacement_length (addr, size) == 2));\n }\n \n-/* Return nonzero if X is a constant whose absolute value is no\n-   smaller than 8.  */\n+/* Calculate the length of move instruction INSN using the given length\n+   table.  Although the tables are correct for most cases, there is some\n+   irregularity in the length of mov.b and mov.w.  The following forms:\n \n-int\n-const_int_ge_8_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+\tmov @ERs+, Rd\n+\tmov @(d:16,ERs), Rd\n+\tmov Rs, @-ERd\n+\tmov Rs, @(d:16,ERd)\n+\n+   are two bytes shorter than most other \"mov Rs, @complex\" or\n+   \"mov @complex,Rd\" combinations.  */\n+\n+static unsigned int\n+h8300_move_length (rtx *operands, const h8300_length_table *table)\n {\n-  return (GET_CODE (x) == CONST_INT\n-\t  && abs (INTVAL (x)) >= 8);\n+  unsigned int size;\n+\n+  size = h8300_length_from_table (operands[0], operands[1], table);\n+  if (REG_P (operands[0]) && h8300_short_move_mem_p (operands[1], POST_INC))\n+    size -= 2;\n+  if (REG_P (operands[1]) && h8300_short_move_mem_p (operands[0], PRE_DEC))\n+    size -= 2;\n+  return size;\n }\n \n-/* Return nonzero if X is a constant expressible in QImode.  */\n+/* Return the length of a mova instruction with the given operands.\n+   DEST is the register destination, SRC is the source address and\n+   OFFSET is the 16-bit or 32-bit displacement.  */\n \n-int\n-const_int_qi_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+static unsigned int\n+h8300_mova_length (rtx dest, rtx src, rtx offset)\n {\n-  return (GET_CODE (x) == CONST_INT\n-\t  && (INTVAL (x) & 0xff) == INTVAL (x));\n+  unsigned int size;\n+\n+  size = (2\n+\t  + h8300_constant_length (offset)\n+\t  + h8300_classify_operand (src, GET_MODE_SIZE (GET_MODE (src)), 0));\n+  if (!REG_P (dest) || !REG_P (src) || REGNO (src) != REGNO (dest))\n+    size += 2;\n+  return size;\n }\n \n-/* Return nonzero if X is a constant expressible in HImode.  */\n+/* Compute the length of INSN based on its length_table attribute.\n+   OPERANDS is the array of its operands.  */\n \n-int\n-const_int_hi_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+unsigned int\n+h8300_insn_length_from_table (rtx insn, rtx * operands)\n {\n-  return (GET_CODE (x) == CONST_INT\n-\t  && (INTVAL (x) & 0xffff) == INTVAL (x));\n+  switch (get_attr_length_table (insn))\n+    {\n+    case LENGTH_TABLE_NONE:\n+      abort ();\n+\n+    case LENGTH_TABLE_ADDB:\n+      return h8300_binary_length (insn, &addb_length_table);\n+\n+    case LENGTH_TABLE_ADDW:\n+      return h8300_binary_length (insn, &addw_length_table);\n+\n+    case LENGTH_TABLE_ADDL:\n+      return h8300_binary_length (insn, &addl_length_table);\n+\n+    case LENGTH_TABLE_LOGICB:\n+      return h8300_binary_length (insn, &logicb_length_table);\n+\n+    case LENGTH_TABLE_MOVB:\n+      return h8300_move_length (operands, &movb_length_table);\n+\n+    case LENGTH_TABLE_MOVW:\n+      return h8300_move_length (operands, &movw_length_table);\n+\n+    case LENGTH_TABLE_MOVL:\n+      return h8300_move_length (operands, &movl_length_table);\n+\n+    case LENGTH_TABLE_MOVA:\n+      return h8300_mova_length (operands[0], operands[1], operands[2]);\n+\n+    case LENGTH_TABLE_MOVA_ZERO:\n+      return h8300_mova_length (operands[0], operands[1], const0_rtx);\n+\n+    case LENGTH_TABLE_UNARY:\n+      return h8300_unary_length (operands[0]);\n+\n+    case LENGTH_TABLE_MOV_IMM4:\n+      return 2 + h8300_classify_operand (operands[0], 0, 0);\n+\n+    case LENGTH_TABLE_SHORT_IMMEDIATE:\n+      return h8300_short_immediate_length (operands[0]);\n+\n+    case LENGTH_TABLE_BITFIELD:\n+      return h8300_bitfield_length (operands[0], operands[1]);\n+      \n+    case LENGTH_TABLE_BITBRANCH:\n+      return h8300_bitfield_length (operands[1], operands[2]) - 2;\n+      \n+    }\n+  abort ();\n }\n \n-/* Return nonzero if X is a constant suitable for inc/dec.  */\n+/* Return true if LHS and RHS are memory references that can be mapped\n+   to the same h8sx assembly operand.  LHS appears as the destination of\n+   an instruction and RHS appears as a source.\n \n-int\n-incdec_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+   Three cases are allowed:\n+\n+\t- RHS is @+Rn or @-Rn, LHS is @Rn\n+\t- RHS is @Rn, LHS is @Rn+ or @Rn-\n+\t- RHS and LHS have the same address and neither has side effects.  */\n+\n+bool\n+h8sx_mergeable_memrefs_p (rtx lhs, rtx rhs)\n {\n-  return (GET_CODE (x) == CONST_INT\n-\t  && (CONST_OK_FOR_M (INTVAL (x))\n-\t      || CONST_OK_FOR_O (INTVAL (x))));\n+  if (GET_CODE (rhs) == MEM && GET_CODE (lhs) == MEM)\n+    {\n+      rhs = XEXP (rhs, 0);\n+      lhs = XEXP (lhs, 0);\n+\n+      if (GET_CODE (rhs) == PRE_INC || GET_CODE (rhs) == PRE_DEC)\n+\treturn rtx_equal_p (XEXP (rhs, 0), lhs);\n+\n+      if (GET_CODE (lhs) == POST_INC || GET_CODE (lhs) == POST_DEC)\n+\treturn rtx_equal_p (rhs, XEXP (lhs, 0));\n+\n+      if (rtx_equal_p (rhs, lhs))\n+\treturn true;\n+    }\n+  return false;\n }\n \n-/* Return nonzero if X is either EQ or NE.  */\n+/* Return true if OPERANDS[1] can be mapped to the same assembly\n+   operand as OPERANDS[0].  */\n \n-int\n-eqne_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+bool\n+h8300_operands_match_p (rtx *operands)\n {\n-  enum rtx_code code = GET_CODE (x);\n+  if (register_operand (operands[0], VOIDmode)\n+      && register_operand (operands[1], VOIDmode))\n+    return true;\n \n-  return (code == EQ || code == NE);\n+  if (h8sx_mergeable_memrefs_p (operands[0], operands[1]))\n+    return true;\n+\n+  return false;\n }\n \n-/* Return nonzero if X is either GT or LE.  */\n+/* Return true if OP is a binary operator in which it would be safe to\n+   replace register operands with memory operands.  */\n \n int\n-gtle_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+h8sx_binary_memory_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  enum rtx_code code = GET_CODE (x);\n+  if (!TARGET_H8300SX)\n+    return false;\n \n-  return (code == GT || code == LE);\n+  if (GET_MODE (op) != QImode\n+      && GET_MODE (op) != HImode\n+      && GET_MODE (op) != SImode)\n+    return false;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      return true;\n+\n+    default:\n+      return h8sx_unary_shift_operator (op, mode);\n+    }\n }\n \n-/* Return nonzero if X is either GTU or LEU.  */\n+/* Like h8sx_binary_memory_operator, but applies to unary operators.  */\n \n int\n-gtuleu_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+h8sx_unary_memory_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  enum rtx_code code = GET_CODE (x);\n+  if (!TARGET_H8300SX)\n+    return false;\n \n-  return (code == GTU || code == LEU);\n+  if (GET_MODE (op) != QImode\n+      && GET_MODE (op) != HImode\n+      && GET_MODE (op) != SImode)\n+    return false;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case NEG:\n+    case NOT:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n }\n+\f\n+/* Try using movmd to move LENGTH bytes from memory region SRC to memory\n+   region DEST.  The two regions do not overlap and have the common\n+   alignment given by ALIGNMENT.  Return true on success.\n \n-/* Return nonzero if X is either IOR or XOR.  */\n+   Using movmd for variable-length moves seems to involve some\n+   complex trade-offs.  For instance:\n \n-int\n-iorxor_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+      - Preparing for a movmd instruction is similar to preparing\n+\tfor a memcpy.  The main difference is that the arguments\n+\tare moved into er4, er5 and er6 rather than er0, er1 and er2.\n+\n+      - Since movmd clobbers the frame pointer, we need to save\n+\tand restore it somehow when frame_pointer_needed.  This can\n+\tsometimes make movmd sequences longer than calls to memcpy().\n+\n+      - The counter register is 16 bits, so the instruction is only\n+\tsuitable for variable-length moves when sizeof (size_t) == 2.\n+\tThat's only true in normal mode.\n+\n+      - We will often lack static alignment information.  Falling back\n+\ton movmd.b would likely be slower than calling memcpy(), at least\n+\tfor big moves.\n+\n+   This function therefore only uses movmd when the length is a\n+   known constant, and only then if -fomit-frame-pointer is in\n+   effect or if we're not optimizing for size.\n+\n+   At the moment the function uses movmd for all in-range constants,\n+   but it might be better to fall back on memcpy() for large moves\n+   if ALIGNMENT == 1.  */\n+\n+bool\n+h8sx_emit_movmd (rtx dest, rtx src, rtx length,\n+\t\t HOST_WIDE_INT alignment)\n {\n-  enum rtx_code code = GET_CODE (x);\n+  if (!flag_omit_frame_pointer && optimize_size)\n+    return false;\n \n-  return (code == IOR || code == XOR);\n+  if (GET_CODE (length) == CONST_INT)\n+    {\n+      rtx dest_reg, src_reg, first_dest, first_src;\n+      HOST_WIDE_INT n;\n+      int factor;\n+\n+      /* Use movmd.l if the alignment allows it, otherwise fall back\n+\t on movmd.b.  */\n+      factor = (alignment >= 2 ? 4 : 1);\n+\n+      /* Make sure the length is within range.  We can handle counter\n+\t values up to 65536, although HImode truncation will make\n+\t the count appear negative in rtl dumps.  */\n+      n = INTVAL (length);\n+      if (n <= 0 || n / factor > 65536)\n+\treturn false;\n+\n+      /* Create temporary registers for the source and destination\n+\t pointers.  Initialize them to the start of each region.  */\n+      dest_reg = copy_addr_to_reg (XEXP (dest, 0));\n+      src_reg = copy_addr_to_reg (XEXP (src, 0));\n+\n+      /* Create references to the movmd source and destination blocks.  */\n+      first_dest = replace_equiv_address (dest, dest_reg);\n+      first_src = replace_equiv_address (src, src_reg);\n+\n+      set_mem_size (first_dest, GEN_INT (n & -factor));\n+      set_mem_size (first_src, GEN_INT (n & -factor));\n+\n+      length = copy_to_mode_reg (HImode, gen_int_mode (n / factor, HImode));\n+      emit_insn (gen_movmd (first_dest, first_src, length, GEN_INT (factor)));\n+\n+      if ((n & -factor) != n)\n+\t{\n+\t  /* Move SRC and DEST past the region we just copied.\n+\t     This is done to update the memory attributes.  */\n+\t  dest = adjust_address (dest, BLKmode, n & -factor);\n+\t  src = adjust_address (src, BLKmode, n & -factor);\n+\n+\t  /* Replace the addresses with the source and destination\n+\t     registers, which movmd has left with the right values.  */\n+\t  dest = replace_equiv_address (dest, dest_reg);\n+\t  src = replace_equiv_address (src, src_reg);\n+\n+\t  /* Mop up the left-over bytes.  */\n+\t  if (n & 2)\n+\t    emit_move_insn (adjust_address (dest, HImode, 0),\n+\t\t\t    adjust_address (src, HImode, 0));\n+\t  if (n & 1)\n+\t    emit_move_insn (adjust_address (dest, QImode, n & 2),\n+\t\t\t    adjust_address (src, QImode, n & 2));\n+\t}\n+      return true;\n+    }\n+  return false;\n }\n \n-/* Recognize valid operators for bit instructions.  */\n+/* Move ADDR into er6 after pushing its old value onto the stack.  */\n \n-int\n-bit_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+void\n+h8300_swap_into_er6 (rtx addr)\n {\n-  enum rtx_code code = GET_CODE (x);\n+  push (HARD_FRAME_POINTER_REGNUM);\n+  emit_move_insn (hard_frame_pointer_rtx, addr);\n+  if (REGNO (addr) == SP_REG)\n+    emit_move_insn (hard_frame_pointer_rtx,\n+\t\t    plus_constant (hard_frame_pointer_rtx,\n+\t\t\t\t   GET_MODE_SIZE (word_mode)));\n+}\n \n-  return (code == XOR\n-\t  || code == AND\n-\t  || code == IOR);\n+/* Move the current value of er6 into ADDR and pop its old value\n+   from the stack.  */\n+\n+void\n+h8300_swap_out_of_er6 (rtx addr)\n+{\n+  if (REGNO (addr) != SP_REG)\n+    emit_move_insn (addr, hard_frame_pointer_rtx);\n+  pop (HARD_FRAME_POINTER_REGNUM);\n }\n \f\n /* Return the length of mov instruction.  */\n@@ -2137,13 +3353,16 @@ output_plussi (rtx *operands)\n     }\n   else\n     {\n-      if (GET_CODE (operands[2]) == REG)\n-\treturn \"add.l\\t%S2,%S0\";\n-\n-      if (GET_CODE (operands[2]) == CONST_INT)\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && register_operand (operands[1], VOIDmode))\n \t{\n \t  HOST_WIDE_INT intval = INTVAL (operands[2]);\n \n+\t  if (TARGET_H8300SX && (intval >= 1 && intval <= 7))\n+\t    return \"add.l\\t%S2,%S0\";\n+\t  if (TARGET_H8300SX && (intval >= -7 && intval <= -1))\n+\t    return \"sub.l\\t%G2,%S0\";\n+\n \t  /* See if we can finish with 2 bytes.  */\n \n \t  switch ((unsigned int) intval & 0xffffffff)\n@@ -2177,10 +3396,17 @@ output_plussi (rtx *operands)\n \t    }\n \t}\n \n+      if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n+\t{\n+\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n+\t  return \"sub.l\\t%S2,%S0\";\n+\t}\n       return \"add.l\\t%S2,%S0\";\n     }\n }\n \n+/* ??? It would be much easier to add the h8sx stuff if a single function\n+   classified the addition as either inc/dec, adds/subs, add.w or add.l.  */\n /* Compute the length of an addition insn.  */\n \n unsigned int\n@@ -2212,13 +3438,16 @@ compute_plussi_length (rtx *operands)\n     }\n   else\n     {\n-      if (GET_CODE (operands[2]) == REG)\n-\treturn 2;\n-\n-      if (GET_CODE (operands[2]) == CONST_INT)\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && register_operand (operands[1], VOIDmode))\n \t{\n \t  HOST_WIDE_INT intval = INTVAL (operands[2]);\n \n+\t  if (TARGET_H8300SX && (intval >= 1 && intval <= 7))\n+\t    return 2;\n+\t  if (TARGET_H8300SX && (intval >= -7 && intval <= -1))\n+\t    return 2;\n+\n \t  /* See if we can finish with 2 bytes.  */\n \n \t  switch ((unsigned int) intval & 0xffffffff)\n@@ -2247,6 +3476,13 @@ compute_plussi_length (rtx *operands)\n \t    return 4;\n \t}\n \n+      if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n+\treturn h8300_length_from_table (operands[0],\n+\t\t\t\t\tGEN_INT (-INTVAL (operands[2])),\n+\t\t\t\t\t&addl_length_table);\n+      else\n+\treturn h8300_length_from_table (operands[0], operands[2],\n+\t\t\t\t\t&addl_length_table);\n       return 6;\n     }\n }\n@@ -2267,13 +3503,16 @@ compute_plussi_cc (rtx *operands)\n     }\n   else\n     {\n-      if (GET_CODE (operands[2]) == REG)\n-\treturn CC_SET_ZN;\n-\n-      if (GET_CODE (operands[2]) == CONST_INT)\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && register_operand (operands[1], VOIDmode))\n \t{\n \t  HOST_WIDE_INT intval = INTVAL (operands[2]);\n \n+\t  if (TARGET_H8300SX && (intval >= 1 && intval <= 7))\n+\t    return CC_SET_ZN;\n+\t  if (TARGET_H8300SX && (intval >= -7 && intval <= -1))\n+\t    return CC_SET_ZN;\n+\n \t  /* See if we can finish with 2 bytes.  */\n \n \t  switch ((unsigned int) intval & 0xffffffff)\n@@ -2316,6 +3555,11 @@ output_logical_op (enum machine_mode mode, rtx *operands)\n   /* Pretend that every byte is affected if both operands are registers.  */\n   const unsigned HOST_WIDE_INT intval =\n     (unsigned HOST_WIDE_INT) ((GET_CODE (operands[2]) == CONST_INT)\n+\t\t\t      /* Always use the full instruction if the\n+\t\t\t\t first operand is in memory.  It is better\n+\t\t\t\t to use define_splits to generate the shorter\n+\t\t\t\t sequence where valid.  */\n+\t\t\t      && register_operand (operands[1], VOIDmode)\n \t\t\t      ? INTVAL (operands[2]) : 0x55555555);\n   /* The determinant of the algorithm.  If we perform an AND, 0\n      affects a bit.  Otherwise, 1 affects a bit.  */\n@@ -2492,6 +3736,11 @@ compute_logical_op_length (enum machine_mode mode, rtx *operands)\n   /* Pretend that every byte is affected if both operands are registers.  */\n   const unsigned HOST_WIDE_INT intval =\n     (unsigned HOST_WIDE_INT) ((GET_CODE (operands[2]) == CONST_INT)\n+\t\t\t      /* Always use the full instruction if the\n+\t\t\t\t first operand is in memory.  It is better\n+\t\t\t\t to use define_splits to generate the shorter\n+\t\t\t\t sequence where valid.  */\n+\t\t\t      && register_operand (operands[1], VOIDmode)\n \t\t\t      ? INTVAL (operands[2]) : 0x55555555);\n   /* The determinant of the algorithm.  If we perform an AND, 0\n      affects a bit.  Otherwise, 1 affects a bit.  */\n@@ -2516,10 +3765,8 @@ compute_logical_op_length (enum machine_mode mode, rtx *operands)\n \t  && b0 != 0\n \t  && b1 != 0)\n \t{\n-\t  if (REG_P (operands[2]))\n-\t    length += 2;\n-\t  else\n-\t    length += 4;\n+\t  length = h8300_length_from_table (operands[1], operands[2],\n+\t\t\t\t\t    &logicw_length_table);\n \t}\n       else\n \t{\n@@ -2555,10 +3802,8 @@ compute_logical_op_length (enum machine_mode mode, rtx *operands)\n \t  && !(code == IOR && w1 == 0xffff\n \t       && (w0 & 0x8000) != 0 && lower_half_easy_p))\n \t{\n-\t  if (REG_P (operands[2]))\n-\t    length += 4;\n-\t  else\n-\t    length += 6;\n+\t  length = h8300_length_from_table (operands[1], operands[2],\n+\t\t\t\t\t    &logicl_length_table);\n \t}\n       else\n \t{\n@@ -2637,6 +3882,11 @@ compute_logical_op_cc (enum machine_mode mode, rtx *operands)\n   /* Pretend that every byte is affected if both operands are registers.  */\n   const unsigned HOST_WIDE_INT intval =\n     (unsigned HOST_WIDE_INT) ((GET_CODE (operands[2]) == CONST_INT)\n+\t\t\t      /* Always use the full instruction if the\n+\t\t\t\t first operand is in memory.  It is better\n+\t\t\t\t to use define_splits to generate the shorter\n+\t\t\t\t sequence where valid.  */\n+\t\t\t      && register_operand (operands[1], VOIDmode)\n \t\t\t      ? INTVAL (operands[2]) : 0x55555555);\n   /* The determinant of the algorithm.  If we perform an AND, 0\n      affects a bit.  Otherwise, 1 affects a bit.  */\n@@ -2754,6 +4004,117 @@ h8300_expand_branch (enum rtx_code code, rtx label)\n    For the details of the shift algorithms for various shift counts,\n    refer to shift_alg_[qhs]i.  */\n \n+/* Classify a shift with the given mode and code.  OP is the shift amount.  */\n+\n+enum h8sx_shift_type\n+h8sx_classify_shift (enum machine_mode mode, enum rtx_code code, rtx op)\n+{\n+  if (!TARGET_H8300SX)\n+    return H8SX_SHIFT_NONE;\n+\n+  switch (code)\n+    {\n+    case ASHIFT:\n+    case LSHIFTRT:\n+      /* Check for variable shifts (shll Rs,Rd and shlr Rs,Rd).  */\n+      if (GET_CODE (op) != CONST_INT)\n+\treturn H8SX_SHIFT_BINARY;\n+\n+      /* Reject out-of-range shift amounts.  */\n+      if (INTVAL (op) <= 0 || INTVAL (op) >= GET_MODE_BITSIZE (mode))\n+\treturn H8SX_SHIFT_NONE;\n+\n+      /* Power-of-2 shifts are effectively unary operations.  */\n+      if (exact_log2 (INTVAL (op)) >= 0)\n+\treturn H8SX_SHIFT_UNARY;\n+\n+      return H8SX_SHIFT_BINARY;\n+\n+    case ASHIFTRT:\n+      if (op == const1_rtx || op == const2_rtx)\n+\treturn H8SX_SHIFT_UNARY;\n+      return H8SX_SHIFT_NONE;\n+\n+    case ROTATE:\n+      if (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) == 1\n+\t      || INTVAL (op) == 2\n+\t      || INTVAL (op) == GET_MODE_BITSIZE (mode) - 2\n+\t      || INTVAL (op) == GET_MODE_BITSIZE (mode) - 1))\n+\treturn H8SX_SHIFT_UNARY;\n+      return H8SX_SHIFT_NONE;\n+\n+    default:\n+      return H8SX_SHIFT_NONE;\n+    }\n+}\n+\n+/* Return true if X is a shift operation of type H8SX_SHIFT_UNARY.  */\n+\n+int\n+h8sx_unary_shift_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (BINARY_P (x) && NON_COMMUTATIVE_P (x)\n+\t  && (h8sx_classify_shift (GET_MODE (x), GET_CODE (x), XEXP (x, 1))\n+\t      == H8SX_SHIFT_UNARY));\n+}\n+\n+/* Likewise H8SX_SHIFT_BINARY.  */\n+\n+int\n+h8sx_binary_shift_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (BINARY_P (x) && NON_COMMUTATIVE_P (x)\n+\t  && (h8sx_classify_shift (GET_MODE (x), GET_CODE (x), XEXP (x, 1))\n+\t      == H8SX_SHIFT_BINARY));\n+}\n+\n+/* Return the asm template for a single h8sx shift instruction.\n+   OPERANDS[0] and OPERANDS[1] are the destination, OPERANDS[2]\n+   is the source and OPERANDS[3] is the shift.  SUFFIX is the\n+   size suffix ('b', 'w' or 'l') and OPTYPE is the print_operand\n+   prefix for the destination operand.  */\n+\n+const char *\n+output_h8sx_shift (rtx *operands, int suffix, int optype)\n+{\n+  static char buffer[16];\n+  const char *stem;\n+\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case ASHIFT:\n+      stem = \"shll\";\n+      break;\n+\n+    case ASHIFTRT:\n+      stem = \"shar\";\n+      break;\n+\n+    case LSHIFTRT:\n+      stem = \"shlr\";\n+      break;\n+\n+    case ROTATE:\n+      stem = \"rotl\";\n+      if (INTVAL (operands[2]) > 2)\n+\t{\n+\t  /* This is really a right rotate.  */\n+\t  operands[2] = GEN_INT (GET_MODE_BITSIZE (GET_MODE (operands[0]))\n+\t\t\t\t - INTVAL (operands[2]));\n+\t  stem = \"rotr\";\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+  if (operands[2] == const1_rtx)\n+    sprintf (buffer, \"%s.%c\\t%%%c0\", stem, suffix, optype);\n+  else\n+    sprintf (buffer, \"%s.%c\\t%%X2,%%%c0\", stem, suffix, optype);\n+  return buffer;\n+}\n int\n nshift_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n@@ -2771,9 +4132,22 @@ nshift_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n \n /* Emit code to do shifts.  */\n \n-void\n+bool\n expand_a_shift (enum machine_mode mode, int code, rtx operands[])\n {\n+  switch (h8sx_classify_shift (mode, code, operands[2]))\n+    {\n+    case H8SX_SHIFT_BINARY:\n+      operands[1] = force_reg (mode, operands[1]);\n+      return false;\n+\n+    case H8SX_SHIFT_UNARY:\n+      return false;\n+\n+    case H8SX_SHIFT_NONE:\n+      break;\n+    }\n+\n   emit_move_insn (operands[0], operands[1]);\n \n   /* Need a loop to get all the bits we want  - we generate the\n@@ -2787,6 +4161,7 @@ expand_a_shift (enum machine_mode mode, int code, rtx operands[])\n \t\t\t\t\t\t      operands[0], operands[2])),\n \t\t\t gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n+  return true;\n }\n \n /* Symbols of the various modes which can be used as indices.  */\n@@ -3911,6 +5286,9 @@ expand_a_rotate (rtx operands[])\n   rtx rotate_amount = operands[2];\n   enum machine_mode mode = GET_MODE (dst);\n \n+  if (h8sx_classify_shift (mode, ROTATE, rotate_amount) == H8SX_SHIFT_UNARY)\n+    return false;\n+\n   /* We rotate in place.  */\n   emit_move_insn (dst, src);\n \n@@ -4155,7 +5533,7 @@ fix_bit_operand (rtx *operands, enum rtx_code code)\n     {\n       /* OK to have a memory dest.  */\n       if (GET_CODE (operands[0]) == MEM\n-\t  && !EXTRA_CONSTRAINT (operands[0], 'U'))\n+\t  && !OK_FOR_U (operands[0]))\n \t{\n \t  rtx mem = gen_rtx_MEM (GET_MODE (operands[0]),\n \t\t\t\t copy_to_mode_reg (Pmode,\n@@ -4165,7 +5543,7 @@ fix_bit_operand (rtx *operands, enum rtx_code code)\n \t}\n \n       if (GET_CODE (operands[1]) == MEM\n-\t  && !EXTRA_CONSTRAINT (operands[1], 'U'))\n+\t  && !OK_FOR_U (operands[1]))\n \t{\n \t  rtx mem = gen_rtx_MEM (GET_MODE (operands[1]),\n \t\t\t\t copy_to_mode_reg (Pmode,\n@@ -4498,6 +5876,17 @@ output_simode_bld (int bild, rtx operands[])\n   return \"\";\n }\n \n+/* Delayed-branch scheduling is more effective if we have some idea\n+   how long each instruction will be.  Use a shorten_branches pass\n+   to get an initial estimate.  */\n+\n+static void\n+h8300_reorg (void)\n+{\n+  if (flag_delayed_branch)\n+    shorten_branches (get_insns ());\n+}\n+\n #ifndef OBJECT_FORMAT_ELF\n static void\n h8300_asm_named_section (const char *name, unsigned int flags ATTRIBUTE_UNUSED)\n@@ -4746,7 +6135,7 @@ h8300_rtx_ok_for_base_p (rtx x, int strict)\n    CONSTANT_ADDRESS.  */\n \n int\n-h8300_legitimate_address_p (rtx x, int strict)\n+h8300_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n {\n   /* The register indirect addresses like @er0 is always valid.  */\n   if (h8300_rtx_ok_for_base_p (x, strict))\n@@ -4755,9 +6144,18 @@ h8300_legitimate_address_p (rtx x, int strict)\n   if (CONSTANT_ADDRESS_P (x))\n     return 1;\n \n+  if (TARGET_H8300SX\n+      && (   GET_CODE (x) == PRE_INC\n+\t  || GET_CODE (x) == PRE_DEC\n+\t  || GET_CODE (x) == POST_INC\n+\t  || GET_CODE (x) == POST_DEC)\n+      && h8300_rtx_ok_for_base_p (XEXP (x, 0), strict))\n+    return 1;\n+\n   if (GET_CODE (x) == PLUS\n       && CONSTANT_ADDRESS_P (XEXP (x, 1))\n-      && h8300_rtx_ok_for_base_p (XEXP (x, 0), strict))\n+      && h8300_rtx_ok_for_base_p (h8300_get_index (XEXP (x, 0),\n+\t\t\t\t\t\t   mode, 0), strict))\n     return 1;\n \n   return 0;\n@@ -4839,4 +6237,7 @@ h8300_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY h8300_return_in_memory\n \n+#undef  TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG h8300_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "d7b73e8f3a0b0ed6898a747139ba0462fb4792b5", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 161, "deletions": 16, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -51,6 +51,14 @@ extern const char * const *h8_reg_names;\n \t      builtin_define (\"__NORMAL_MODE__\");\t\\\n \t    }\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n+      else if (TARGET_H8300SX)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  builtin_define (\"__H8300SX__\");\t\t\\\n+\t  if (TARGET_NORMAL_MODE)\t\t\t\\\n+\t    {\t\t\t\t\t\t\\\n+\t      builtin_define (\"__NORMAL_MODE__\");\t\\\n+\t    }\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n       else if (TARGET_H8300S)\t\t\t\t\\\n \t{\t\t\t\t\t\t\\\n \t  builtin_define (\"__H8300S__\");\t\t\\\n@@ -103,6 +111,7 @@ extern int target_flags;\n #define MASK_RELAX\t\t0x00000400\n #define MASK_H8300H\t\t0x00001000\n #define MASK_ALIGN_300\t\t0x00002000\n+#define MASK_H8300SX\t\t0x00004000\n \n /* Macros used in the machine description to test the flags.  */\n \n@@ -122,7 +131,12 @@ extern int target_flags;\n /* Select between the H8/300 and H8/300H CPUs.  */\n #define TARGET_H8300\t(! TARGET_H8300H && ! TARGET_H8300S)\n #define TARGET_H8300H\t(target_flags & MASK_H8300H)\n-#define TARGET_H8300S\t(target_flags & MASK_H8300S)\n+#define TARGET_H8300S\t(target_flags & (MASK_H8300S | MASK_H8300SX))\n+#define TARGET_H8300SX\t(target_flags & MASK_H8300SX)\n+/* Some multiply instructions are not available in all H8SX variants.\n+   Use this macro instead of TARGET_H8300SX to indicate this, even\n+   though we don't actually generate different code for now.  */\n+#define TARGET_H8300SXMUL TARGET_H8300SX\n #define TARGET_NORMAL_MODE (target_flags & MASK_NORMAL_MODE)\n \n /* mac register and relevant instructions are available.  */\n@@ -144,6 +158,8 @@ extern int target_flags;\n #define TARGET_SWITCHES\t\t\t\t\t\t\t    \\\n { {\"s\",\t\t\t MASK_H8300S, N_(\"Generate H8S code\")},\t\t    \\\n   {\"no-s\",\t\t-MASK_H8300S, N_(\"Do not generate H8S code\")},\t    \\\n+  {\"sx\",\t\t MASK_H8300SX, N_(\"Generate H8SX code\")},\t    \\\n+  {\"no-sx\",\t\t-MASK_H8300SX, N_(\"Do not generate H8SX code\")},    \\\n   {\"s2600\",\t\t MASK_MAC, N_(\"Generate H8S/2600 code\")},\t    \\\n   {\"no-s2600\",\t\t-MASK_MAC, N_(\"Do not generate H8S/2600 code\")},    \\\n   {\"int32\",\t\t MASK_INT32, N_(\"Make integers 32 bits wide\")},\t    \\\n@@ -398,24 +414,29 @@ extern int target_flags;\n    class that represents their union.  */\n \n enum reg_class {\n-  NO_REGS, GENERAL_REGS, MAC_REGS, ALL_REGS, LIM_REG_CLASSES\n+  NO_REGS, COUNTER_REGS, SOURCE_REGS, DESTINATION_REGS,\n+  GENERAL_REGS, MAC_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n #define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n \n /* Give names of register classes as strings for dump file.  */\n \n #define REG_CLASS_NAMES \\\n-{ \"NO_REGS\", \"GENERAL_REGS\", \"MAC_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n+{ \"NO_REGS\", \"COUNTER_REGS\", \"SOURCE_REGS\", \"DESTINATION_REGS\", \\\n+  \"GENERAL_REGS\", \"MAC_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS\t\t\t\\\n {      {0},\t\t/* No regs      */\t\\\n+   {0x010},\t\t/* COUNTER_REGS */\t\\\n+   {0x020},\t\t/* SOURCE_REGS */\t\\\n+   {0x040},\t\t/* DESTINATION_REGS */\t\\\n    {0xeff},\t\t/* GENERAL_REGS */\t\\\n-   {0x100},\t\t/* MAC_REGS */\t\\\n+   {0x100},\t\t/* MAC_REGS */\t\t\\\n    {0xfff},\t\t/* ALL_REGS\t*/\t\\\n }\n \n@@ -424,18 +445,23 @@ enum reg_class {\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#define REGNO_REG_CLASS(REGNO) (REGNO != MAC_REG ? GENERAL_REGS : MAC_REGS)\n+#define REGNO_REG_CLASS(REGNO)\t\t\t\t\\\n+  ((REGNO) == MAC_REG ? MAC_REGS\t\t\t\\\n+   : (REGNO) == COUNTER_REG ? COUNTER_REGS\t\t\\\n+   : (REGNO) == SOURCE_REG ? SOURCE_REGS\t\t\\\n+   : (REGNO) == DESTINATION_REG ? DESTINATION_REGS\t\\\n+   : GENERAL_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n \n-#define INDEX_REG_CLASS NO_REGS\n+#define INDEX_REG_CLASS (TARGET_H8300SX ? GENERAL_REGS : NO_REGS)\n #define BASE_REG_CLASS  GENERAL_REGS\n \n /* Get reg_class from a letter such as appears in the machine description.\n \n    'a' is the MAC register.  */\n \n-#define REG_CLASS_FROM_LETTER(C) ((C) == 'a' ? MAC_REGS : NO_REGS)\n+#define REG_CLASS_FROM_LETTER(C) (h8300_reg_class_from_letter (C))\n \n /* The letters I, J, K, L, M, N, O, P in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n@@ -458,6 +484,31 @@ enum reg_class {\n #define CONST_OK_FOR_O(VALUE)\t\t\t\t\\\n   ((VALUE) == -1 || (VALUE) == -2)\n \n+/* Multi-letter constraints for constant are always started with P\n+   (just because it was the only letter in the range left.  New\n+   constraints for constants should be added here.  */\n+#define CONST_OK_FOR_Ppositive(VALUE, NBITS)\t\t\\\n+  ((VALUE) > 0 && (VALUE) < (1 << (NBITS)))\n+#define CONST_OK_FOR_Pnegative(VALUE, NBITS)\t\t\\\n+  ((VALUE) < 0 && (VALUE) > -(1 << (NBITS)))\n+#define CONST_OK_FOR_P(VALUE, STR) \\\n+  ((STR)[1] >= '1' && (STR)[1] <= '9' && (STR)[2] == '<' \t\\\n+   ? (((STR)[3] == '0' || ((STR)[3] == 'X' && TARGET_H8300SX))\t\\\n+      && CONST_OK_FOR_Pnegative ((VALUE), (STR)[1] - '0'))\t\\\n+   : ((STR)[1] >= '1' && (STR)[1] <= '9' && (STR)[2] == '>')\t\\\n+   ? (((STR)[3] == '0' || ((STR)[3] == 'X' && TARGET_H8300SX))\t\\\n+      && CONST_OK_FOR_Ppositive ((VALUE), (STR)[1] - '0'))\t\\\n+   : 0)\n+#define CONSTRAINT_LEN_FOR_P(STR) \\\n+  ((((STR)[1] >= '1' && (STR)[1] <= '9')\t\t\t\\\n+    && ((STR)[2] == '<' || (STR)[2] == '>')\t\t\t\\\n+    && ((STR)[3] == 'X' || (STR)[3] == '0')) ? 4\t\t\\\n+   : 0)\n+\n+#define CONST_OK_FOR_CONSTRAINT_P(VALUE, C, STR)\t\\\n+  ((C) == 'P' ? CONST_OK_FOR_P ((VALUE), (STR))\t\t\\\n+   : CONST_OK_FOR_LETTER_P ((VALUE), (C)))\n+  \n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\\\n   ((C) == 'I' ? CONST_OK_FOR_I (VALUE) :\t\\\n    (C) == 'J' ? CONST_OK_FOR_J (VALUE) :\t\\\n@@ -753,6 +804,8 @@ struct cum_arg\n \n #define HAVE_POST_INCREMENT 1\n #define HAVE_PRE_DECREMENT 1\n+#define HAVE_POST_DECREMENT TARGET_H8300SX\n+#define HAVE_PRE_INCREMENT TARGET_H8300SX\n \n /* Macros to check register numbers against specific register classes.  */\n \n@@ -824,6 +877,9 @@ struct cum_arg\n \n /* Extra constraints.  */\n \n+#define OK_FOR_Q(OP)\t\t\t\t\t\\\n+  (TARGET_H8300SX && memory_operand ((OP), VOIDmode))\n+\n #define OK_FOR_R(OP)\t\t\t\t\t\\\n   (GET_CODE (OP) == CONST_INT\t\t\t\t\\\n    ? !h8300_shift_needs_scratch_p (INTVAL (OP), QImode)\t\\\n@@ -861,26 +917,87 @@ struct cum_arg\n    || (GET_CODE (OP) == MEM && TARGET_H8300S\t\t\t\t\\\n        && GET_CODE (XEXP (OP, 0)) == CONST_INT))\n \n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\\\n-  ((C) == 'R' ? OK_FOR_R (OP) :\t\t\t\\\n+/* Multi-letter constraints starting with W are to be used for\n+   operands that require a memory operand, i.e,. that are never used\n+   along with register constraints (see EXTRA_MEMORY_CONSTRAINTS).\n+   For operands that require a memory operand (or not) but that always\n+   accept a register, a multi-letter constraint starting with Y should\n+   be used instead.  */\n+\n+#define OK_FOR_WU(OP)\t\t\t\t\t\\\n+  (GET_CODE (OP) == MEM && OK_FOR_U (OP))\n+\n+#define OK_FOR_W(OP, STR)\t\t\t\t\\\n+  ((STR)[1] == 'U' ? OK_FOR_WU (OP)\t\t\t\\\n+   : 0)\n+\n+#define CONSTRAINT_LEN_FOR_W(STR)\t\t\t\\\n+  ((STR)[1] == 'U' ? 2\t\t\t\t\t\\\n+   : 0)\n+\n+/* We don't have any constraint starting with Y yet, but before\n+   someone uses it for a one-letter constraint and we're left without\n+   any upper-case constraints left, we reserve it for extensions\n+   here.  */\n+#define OK_FOR_Y(OP, STR)\t\t\t\t\\\n+  (0)\n+\n+#define CONSTRAINT_LEN_FOR_Y(STR)\t\t\t\\\n+  (0)\n+\n+#define OK_FOR_Z(OP)\t\t\t\t\t\\\n+  (TARGET_H8300SX\t\t\t\t\t\\\n+   && GET_CODE (OP) == MEM\t\t\t\t\\\n+   && CONSTANT_P (XEXP ((OP), 0)))\n+\n+#define EXTRA_CONSTRAINT_STR(OP, C, STR)\t\\\n+  ((C) == 'Q' ? OK_FOR_Q (OP) :\t\t\t\\\n+   (C) == 'R' ? OK_FOR_R (OP) :\t\t\t\\\n    (C) == 'S' ? OK_FOR_S (OP) :\t\t\t\\\n    (C) == 'T' ? OK_FOR_T (OP) :\t\t\t\\\n    (C) == 'U' ? OK_FOR_U (OP) :\t\t\t\\\n+   (C) == 'W' ? OK_FOR_W ((OP), (STR)) :\t\\\n+   (C) == 'Y' ? OK_FOR_Y ((OP), (STR)) :\t\\\n+   (C) == 'Z' ? OK_FOR_Z (OP) :\t\t\t\\\n    0)\n+\n+#define CONSTRAINT_LEN(C, STR) \\\n+  ((C) == 'P' ? CONSTRAINT_LEN_FOR_P (STR)\t\\\n+   : (C) == 'W' ? CONSTRAINT_LEN_FOR_W (STR)\t\\\n+   : (C) == 'Y' ? CONSTRAINT_LEN_FOR_Y (STR)\t\\\n+   : DEFAULT_CONSTRAINT_LEN ((C), (STR)))\n+\n+/* Experiments suggest that it's better not add 'Q' or 'U' here.  No\n+   patterns need it for correctness (no patterns use 'Q' and 'U'\n+   without also providing a register alternative).  And defining it\n+   will mean that a spilled pseudo could be replaced by its frame\n+   location in several consecutive insns.\n+\n+   Instead, it seems to be better to force pseudos to be reloaded\n+   into registers and then use peepholes to recombine insns when\n+   beneficial.\n+\n+   Unfortunately, for WU (unlike plain U, that matches regs as well),\n+   we must require a memory address.  In fact, all multi-letter\n+   constraints started with W are supposed to have this property, so\n+   we just test for W here.  */\n+#define EXTRA_MEMORY_CONSTRAINT(C, STR) \\\n+  ((C) == 'W')\n+\n \f\n #ifndef REG_OK_STRICT\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n-      if (h8300_legitimate_address_p ((X), 0))\t\\\n+      if (h8300_legitimate_address_p ((MODE), (X), 0))\t\\\n \tgoto ADDR;\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n #else\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n-      if (h8300_legitimate_address_p ((X), 1))\t\\\n+      if (h8300_legitimate_address_p ((MODE), (X), 1))\t\\\n \tgoto ADDR;\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n@@ -893,7 +1010,14 @@ struct cum_arg\n    (the amount of decrement or increment being the length of the operand).  */\n \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL) \\\n-  if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC) goto LABEL;\n+  if (GET_CODE (ADDR) == POST_INC \\\n+      || GET_CODE (ADDR) == POST_DEC \\\n+      || GET_CODE (ADDR) == PRE_INC \\\n+      || GET_CODE (ADDR) == PRE_DEC) \\\n+    goto LABEL; \\\n+  if (GET_CODE (ADDR) == PLUS \\\n+      && h8300_get_index (XEXP (ADDR, 0), VOIDmode, 0) != XEXP (ADDR, 0)) \\\n+    goto LABEL;\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n@@ -936,9 +1060,9 @@ struct cum_arg\n    We use longs for the H8/300H and the H8S because ints can be 16 or 32.\n    GCC requires SIZE_TYPE to be the same size as pointers.  */\n #define SIZE_TYPE\t\t\t\t\t\t\t\t\\\n-  (TARGET_H8300 || TARGET_NORMAL_MODE ? \"unsigned int\" : \"long unsigned int\")\n+  (TARGET_H8300 || TARGET_NORMAL_MODE ? TARGET_INT32 ? \"short unsigned int\" : \"unsigned int\" : \"long unsigned int\")\n #define PTRDIFF_TYPE\t\t\t\t\t\t\\\n-  (TARGET_H8300 || TARGET_NORMAL_MODE ? \"int\" : \"long int\")\n+  (TARGET_H8300 || TARGET_NORMAL_MODE ? TARGET_INT32 ? \"short int\" : \"int\" : \"long int\")\n \n #define POINTER_SIZE\t\t\t\t\t\t\t\\\n   ((TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE ? 32 : 16)\n@@ -951,6 +1075,12 @@ struct cum_arg\n    so give the MEM rtx a byte's mode.  */\n #define FUNCTION_MODE QImode\n \n+/* Return the length of JUMP's delay slot insn (0 if it has none).\n+   If JUMP is a delayed branch, NEXT_INSN (PREV_INSN (JUMP)) will\n+   be the containing SEQUENCE, not JUMP itself.  */\n+#define DELAY_SLOT_LENGTH(JUMP) \\\n+  (NEXT_INSN (PREV_INSN (JUMP)) == JUMP ? 0 : 2)\n+\n #define BRANCH_COST 0\n \n /* Tell final.c how to eliminate redundant test instructions.  */\n@@ -1139,14 +1269,29 @@ struct cum_arg\n   final_prescan_insn (insn, operand, nop)\n \n #define MOVE_RATIO 3\n+extern int h8300_move_ratio;\n+#undef  MOVE_RATIO\n+#define MOVE_RATIO h8300_move_ratio\n \n /* Define the codes that are matched by predicates in h8300.c.  */\n \n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n   {\"general_operand_src\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n \t\t\t   LABEL_REF, SUBREG, REG, MEM}},\t\t\\\n-  {\"general_operand_dst\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n-\t\t\t   LABEL_REF, SUBREG, REG, MEM}},\t\t\\\n+  {\"general_operand_dst\", {SUBREG, REG, MEM}},\t\t\t\t\\\n+  {\"h8300_src_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n+\t\t\t LABEL_REF, SUBREG, REG, MEM}},\t\t\t\\\n+  {\"h8300_dst_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n+  {\"nibble_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"reg_or_nibble_operand\", {CONST_INT, SUBREG, REG}},\t\t\t\\\n+  {\"h8sx_unary_shift_operator\", {ASHIFTRT, LSHIFTRT, ASHIFT, ROTATE}},\t\\\n+  {\"h8sx_binary_shift_operator\", {ASHIFTRT, LSHIFTRT, ASHIFT}},\t\t\\\n+  {\"h8sx_binary_memory_operator\", {PLUS, MINUS, AND, IOR, XOR, ASHIFT,\t\\\n+\t\t\t\t   ASHIFTRT, LSHIFTRT, ROTATE}},\t\\\n+  {\"h8sx_unary_memory_operator\", {NEG, NOT}},\t\t\t\t\\\n+  {\"h8300_ldm_parallel\", {PARALLEL}},\t\t\t\t\t\\\n+  {\"h8300_stm_parallel\", {PARALLEL}},\t\t\t\t\t\\\n+  {\"h8300_return_parallel\", {PARALLEL}},\t\t\t\t\\\n   {\"single_one_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"single_zero_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"call_insn_operand\", {MEM}},\t\t\t\t\t\t\\"}, {"sha": "e718a82e40b5884d361a1c58608581fbc3c3cc3e", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 1574, "deletions": 525, "changes": 2099, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -52,9 +52,16 @@\n   [(UNSPEC_INCDEC\t0)\n    (UNSPEC_MONITOR\t1)])\n \n+(define_constants\n+  [(UNSPEC_MOVMD\t100)\n+   (UNSPEC_STPCPY\t101)])\n+\n (define_constants\n   [(R0_REG\t 0)\n    (SC_REG\t 3)\n+   (COUNTER_REG  4)\n+   (SOURCE_REG   5)\n+   (DESTINATION_REG 6)\n    (HFP_REG\t 6)\n    (SP_REG\t 7)\n    (MAC_REG\t 8)\n@@ -69,16 +76,22 @@\n (define_attr \"cpu\" \"h8300,h8300h\"\n   (const (symbol_ref \"cpu_type\")))\n \n-(define_attr \"type\" \"branch,arith\"\n+(define_attr \"type\" \"branch,arith,bitbranch,call\"\n   (const_string \"arith\"))\n \n+(define_attr \"length_table\" \"none,addb,addw,addl,logicb,movb,movw,movl,mova_zero,mova,unary,mov_imm4,short_immediate,bitfield,bitbranch\"\n+  (const_string \"none\"))\n+\n ;; The size of instructions in bytes.\n \n (define_attr \"length\" \"\"\n   (cond [(eq_attr \"type\" \"branch\")\n+\t ;; In a forward delayed branch, (pc) represents the end of the\n+\t ;; delay sequence, not the end of the branch itself.\n \t (if_then_else (and (ge (minus (match_dup 0) (pc))\n \t\t\t\t(const_int -126))\n-\t\t\t    (le (minus (match_dup 0) (pc))\n+\t\t\t    (le (plus (minus (match_dup 0) (pc))\n+\t\t\t\t      (symbol_ref \"DELAY_SLOT_LENGTH (insn)\"))\n \t\t\t\t(const_int 126)))\n \t\t       (const_int 2)\n \t\t       (if_then_else (and (eq_attr \"cpu\" \"h8300h\")\n@@ -87,7 +100,30 @@\n \t\t\t\t\t       (le (minus (pc) (match_dup 0))\n \t\t\t\t\t\t   (const_int 32000))))\n \t\t\t\t     (const_int 4)\n-\t\t\t\t     (const_int 6)))]\n+\t\t\t\t     (const_int 6)))\n+\t (eq_attr \"type\" \"bitbranch\")\n+\t (if_then_else\n+\t  (and (ge (minus (match_dup 0) (pc))\n+\t\t   (const_int -126))\n+\t       (le (minus (match_dup 0) (pc))\n+\t\t   (const_int 126)))\n+\t  (plus\n+\t   (symbol_ref \"h8300_insn_length_from_table (insn, operands)\")\n+\t   (const_int 2))\n+\t  (if_then_else\n+\t   (and (eq_attr \"cpu\" \"h8300h\")\n+\t\t(and (ge (minus (pc) (match_dup 0))\n+\t\t\t (const_int -32000))\n+\t\t     (le (minus (pc) (match_dup 0))\n+\t\t\t (const_int 32000))))\n+\t   (plus\n+\t    (symbol_ref \"h8300_insn_length_from_table (insn, operands)\")\n+\t    (const_int 4))\n+\t   (plus\n+\t    (symbol_ref \"h8300_insn_length_from_table (insn, operands)\")\n+\t    (const_int 6))))\n+\t (eq_attr \"length_table\" \"!none\")\n+\t (symbol_ref \"h8300_insn_length_from_table (insn, operands)\")]\n \t(const_int 200)))\n \n ;; Condition code settings.\n@@ -104,6 +140,32 @@\n (define_attr \"cc\" \"none,none_0hit,set_znv,set_zn,compare,clobber\"\n   (const_string \"clobber\"))\n \n+;; Type of delay slot.  NONE means the instruction has no delay slot.\n+;; JUMP means it is an unconditional jump that (if short enough)\n+;; could be implemented using bra/s.\n+(define_attr \"delay_slot\" \"none,jump\"\n+  (const_string \"none\"))\n+\n+;; \"yes\" if the instruction can be put into a delay slot.  It's not\n+;; entirely clear that jsr is not valid in delay slots, but it\n+;; definitely doesn't have the effect of causing the called function\n+;; to return to the target of the delayed branch.\n+(define_attr \"can_delay\" \"no,yes\"\n+  (cond [(eq_attr \"type\" \"branch,bitbranch,call\")\n+\t   (const_string \"no\")\n+\t (ne (symbol_ref \"get_attr_length (insn)\") (const_int 2))\n+\t   (const_string \"no\")]\n+\t(const_string \"yes\")))\n+\n+;; Only allow jumps to have a delay slot if we think they might\n+;; be short enough.  This is just an optimisation: we don't know\n+;; for certain whether they will be or not.\n+(define_delay (and (eq_attr \"delay_slot\" \"jump\")\n+\t\t   (eq (symbol_ref \"get_attr_length (insn)\") (const_int 2)))\n+  [(eq_attr \"can_delay\" \"yes\")\n+   (nil)\n+   (nil)])\n+\n ;; Provide the maximum length of an assembly instruction in an asm\n ;; statement.  The maximum length of 14 bytes is achieved on H8SX.\n \n@@ -139,7 +201,7 @@\n (define_insn \"*movqi_h8300hs\"\n   [(set (match_operand:QI 0 \"general_operand_dst\" \"=r,r ,<,r,r,m\")\n \t(match_operand:QI 1 \"general_operand_src\" \" I,r>,r,n,m,r\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n+  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\n    && (register_operand (operands[0], QImode)\n        || register_operand (operands[1], QImode))\"\n   \"@\n@@ -153,34 +215,41 @@\n \t(symbol_ref \"compute_mov_length (operands)\"))\n    (set_attr \"cc\" \"set_zn,set_znv,set_znv,clobber,set_znv,set_znv\")])\n \n+(define_insn \"*movqi_h8sx\"\n+  [(set (match_operand:QI 0 \"general_operand_dst\" \"=Z,rQ\")\n+\t(match_operand:QI 1 \"general_operand_src\" \"P4>X,rQi\"))]\n+  \"TARGET_H8300SX\"\n+  \"@\n+    mov.b\t%X1,%X0\n+    mov.b\t%X1,%X0\"\n+  [(set_attr \"length_table\" \"mov_imm4,movb\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand_dst\" \"\")\n \t(match_operand:QI 1 \"general_operand_src\" \"\"))]\n   \"\"\n   \"\n {\n   /* One of the ops has to be in a register.  */\n-  if (!register_operand (operand0, QImode)\n+  if (!TARGET_H8300SX\n+      && !register_operand (operand0, QImode)\n       && !register_operand (operand1, QImode))\n     {\n       operands[1] = copy_to_mode_reg (QImode, operand1);\n     }\n }\")\n \n (define_insn \"movstrictqi\"\n-  [(set (strict_low_part\n-\t (match_operand:QI 0 \"register_operand\"    \"+r,r,r,r,r\"))\n-\t (match_operand:QI 1 \"general_operand_src\" \" I,r,n,>,m\"))]\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand_dst\" \"+r,r\"))\n+\t\t\t (match_operand:QI 1 \"general_operand_src\" \"I,rmi>\"))]\n   \"\"\n   \"@\n    sub.b\t%X0,%X0\n-   mov.b\t%X1,%X0\n-   mov.b\t%R1,%X0\n-   mov.b\t%X1,%X0\n-   mov.b\t%R1,%X0\"\n-  [(set (attr \"length\")\n-\t(symbol_ref \"compute_mov_length (operands)\"))\n-   (set_attr \"cc\" \"set_zn,set_znv,set_znv,set_znv,set_znv\")])\n+   mov.b\t%X1,%X0\"\n+  [(set_attr \"length\" \"2,*\")\n+   (set_attr \"length_table\" \"*,movb\")\n+   (set_attr \"cc\" \"set_zn,set_znv\")])\n \n ;; movhi\n \n@@ -209,7 +278,7 @@\n (define_insn \"*movhi_h8300hs\"\n   [(set (match_operand:HI 0 \"general_operand_dst\" \"=r,r,<,r,r,m\")\n \t(match_operand:HI 1 \"general_operand_src\" \"I,r>,r,i,m,r\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n+  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n   \"@\n@@ -223,6 +292,20 @@\n \t(symbol_ref \"compute_mov_length (operands)\"))\n    (set_attr \"cc\" \"set_zn,set_znv,set_znv,set_znv,set_znv,set_znv\")])\n \n+(define_insn \"*movhi_h8sx\"\n+  [(set (match_operand:HI 0 \"general_operand_dst\" \"=r,r,Z,Q,rQ\")\n+\t(match_operand:HI 1 \"general_operand_src\" \"I,P3>X,P4>X,IP8>X,rQi\"))]\n+  \"TARGET_H8300SX\"\n+  \"@\n+   sub.w\t%T0,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\"\n+  [(set_attr \"length_table\" \"*,*,mov_imm4,short_immediate,movw\")\n+   (set_attr \"length\" \"2,2,*,*,*\")\n+   (set_attr \"cc\" \"set_zn,set_znv,set_znv,set_znv,set_znv\")])\n+\n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand_dst\" \"\")\n \t(match_operand:HI 1 \"general_operand_src\" \"\"))]\n@@ -238,19 +321,16 @@\n }\")\n \n (define_insn \"movstricthi\"\n-  [(set (strict_low_part\n-\t (match_operand:HI 0 \"register_operand\"    \"+r,r,r,r,r\"))\n-\t (match_operand:HI 1 \"general_operand_src\" \" I,r,i,>,m\"))]\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand_dst\" \"+r,r,r\"))\n+\t\t\t (match_operand:HI 1 \"general_operand_src\" \"I,P3>X,rmi\"))]\n   \"\"\n   \"@\n    sub.w\t%T0,%T0\n    mov.w\t%T1,%T0\n-   mov.w\t%T1,%T0\n-   mov.w\t%T1,%T0\n    mov.w\t%T1,%T0\"\n-  [(set (attr \"length\")\n-\t(symbol_ref \"compute_mov_length (operands)\"))\n-   (set_attr \"cc\" \"set_zn,set_znv,set_znv,set_znv,set_znv\")])\n+  [(set_attr \"length\" \"2,2,*\")\n+   (set_attr \"length_table\" \"*,*,movw\")\n+   (set_attr \"cc\" \"set_zn,set_znv,set_znv\")])\n \n ;; movsi\n \n@@ -265,7 +345,7 @@\n       if (h8300_expand_movsi (operands))\n \tDONE;\n     }\n-  else\n+  else if (!TARGET_H8300SX)\n     {\n       /* One of the ops has to be in a register.  */\n       if (!register_operand (operand1, SImode)\n@@ -350,7 +430,7 @@\n (define_insn \"*movsi_h8300hs\"\n   [(set (match_operand:SI 0 \"general_operand_dst\" \"=r,r,r,<,r,r,m,*a,*a,r\")\n \t(match_operand:SI 1 \"general_operand_src\" \"I,r,i,r,>,m,r,I,r,*a\"))]\n-  \"(TARGET_H8300S || TARGET_H8300H)\n+  \"(TARGET_H8300S || TARGET_H8300H) && !TARGET_H8300SX\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\n    && !(GET_CODE (operands[0]) == MEM\n@@ -423,6 +503,273 @@\n \t(symbol_ref \"compute_mov_length (operands)\"))\n    (set_attr \"cc\" \"set_zn,set_znv,clobber,set_znv,set_znv,set_znv,set_znv,none_0hit,none_0hit,set_znv\")])\n \n+(define_insn \"*movsi_h8sx\"\n+  [(set (match_operand:SI 0 \"general_operand_dst\" \"=r,r,Q,rQ,*a,*a,r\")\n+\t(match_operand:SI 1 \"general_operand_src\" \"I,P3>X,IP8>X,rQi,I,r,*a\"))]\n+  \"TARGET_H8300SX\"\n+  \"@\n+   sub.l\t%S0,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\n+   clrmac\n+   clrmac\\;ldmac\t%1,macl\n+   stmac\tmacl,%0\"\n+  [(set_attr \"length_table\" \"*,*,short_immediate,movl,*,*,*\")\n+   (set_attr \"length\" \"2,2,*,*,2,6,4\")\n+   (set_attr \"cc\" \"set_zn,set_znv,set_znv,set_znv,none_0hit,none_0hit,set_znv\")])\n+\n+(define_insn \"*movsf_h8sx\"\n+  [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,rQ\")\n+\t(match_operand:SF 1 \"general_operand_src\" \"G,rQi\"))]\n+  \"TARGET_H8300SX\"\n+  \"@\n+    sub.l\t%S0,%S0\n+    mov.l\t%S1,%S0\"\n+  [(set_attr \"length\" \"2,*\")\n+   (set_attr \"length_table\" \"*,movl\")\n+   (set_attr \"cc\" \"set_zn,set_znv\")])\n+\n+;; Implement block moves using movmd.  Defining movmemsi allows the full\n+;; range of constant lengths (up to 0x40000 bytes when using movmd.l).\n+;; See h8sx_emit_movmd for details.\n+(define_expand \"movmemsi\"\n+  [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n+   (use (match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (use (match_operand:SI 2 \"\" \"\"))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n+  \"TARGET_H8300SX\"\n+  {\n+    if (h8sx_emit_movmd (operands[0], operands[1], operands[2],\n+\t\t\t INTVAL (operands[3])))\n+      DONE;\n+    else\n+      FAIL;\n+  })\n+\n+;; Expander for generating movmd insns.  Operand 0 is the destination\n+;; memory region, operand 1 is the source, operand 2 is the counter\n+;; register and operand 3 is the chunk size (1, 2 or 4).\n+(define_expand \"movmd\"\n+  [(parallel\n+       [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t     (match_operand:BLK 1 \"memory_operand\" \"\"))\n+\t(unspec [(match_operand:HI 2 \"register_operand\" \"\")\n+\t\t (match_operand:HI 3 \"const_int_operand\" \"\")] UNSPEC_MOVMD)\n+\t(clobber (match_dup 4))\n+\t(clobber (match_dup 5))\n+\t(set (match_dup 2)\n+\t     (const_int 0))])]\n+  \"TARGET_H8300SX\"\n+  {\n+    operands[4] = copy_rtx (XEXP (operands[0], 0));\n+    operands[5] = copy_rtx (XEXP (operands[1], 0));\n+  })\n+\n+\n+;; This is a difficult instruction to reload since operand 0 must be the\n+;; frame pointer.  See h8300_reg_class_from_letter for an explanation.\n+(define_insn \"movmd_internal_normal\"\n+  [(set (mem:BLK (match_operand:HI 3 \"register_operand\" \"0,r\"))\n+\t(mem:BLK (match_operand:HI 4 \"register_operand\" \"1,1\")))\n+   (unspec [(match_operand:HI 5 \"register_operand\" \"2,2\")\n+\t    (match_operand:HI 6 \"const_int_operand\" \"n,n\")] UNSPEC_MOVMD)\n+   (clobber (match_operand:HI 0 \"register_operand\" \"=d,??D\"))\n+   (clobber (match_operand:HI 1 \"register_operand\" \"=f,f\"))\n+   (set (match_operand:HI 2 \"register_operand\" \"=c,c\")\n+\t(const_int 0))]\n+  \"TARGET_H8300SX && TARGET_NORMAL_MODE\"\n+  \"@\n+    movmd%m6\n+    #\"\n+  [(set_attr \"length\" \"2,14\")\n+   (set_attr \"can_delay\" \"no\")\n+   (set_attr \"cc\" \"none,clobber\")])\n+\n+(define_insn \"movmd_internal\"\n+  [(set (mem:BLK (match_operand:SI 3 \"register_operand\" \"0,r\"))\n+\t(mem:BLK (match_operand:SI 4 \"register_operand\" \"1,1\")))\n+   (unspec [(match_operand:HI 5 \"register_operand\" \"2,2\")\n+\t    (match_operand:HI 6 \"const_int_operand\" \"n,n\")] UNSPEC_MOVMD)\n+   (clobber (match_operand:SI 0 \"register_operand\" \"=d,??D\"))\n+   (clobber (match_operand:SI 1 \"register_operand\" \"=f,f\"))\n+   (set (match_operand:HI 2 \"register_operand\" \"=c,c\")\n+\t(const_int 0))]\n+  \"TARGET_H8300SX && !TARGET_NORMAL_MODE\"\n+  \"@\n+    movmd%m6\n+    #\"\n+  [(set_attr \"length\" \"2,14\")\n+   (set_attr \"can_delay\" \"no\")\n+   (set_attr \"cc\" \"none,clobber\")])\n+\n+;; Split the above instruction if the destination register isn't er6.\n+;; We need a sequence like:\n+;;\n+;;\tmov.l\ter6,@-er7\n+;;\tmov.l\t<dest>,er6\n+;;\tmovmd.sz\n+;;\tmov.l\ter6,<dest>\n+;;\tmov.l\t@er7+,er6\n+;;\n+;; where <dest> is the current destination register (operand 4).\n+;; The fourth instruction will be deleted if <dest> dies here.\n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t(match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (unspec [(match_operand:HI 2 \"register_operand\" \"\")\n+\t    (match_operand:HI 3 \"const_int_operand\" \"\")] UNSPEC_MOVMD)\n+   (clobber (match_operand:HI 4 \"register_operand\" \"\"))\n+   (clobber (match_operand:HI 5 \"register_operand\" \"\"))\n+   (set (match_dup 2)\n+\t(const_int 0))]\n+  \"TARGET_H8300SX && TARGET_NORMAL_MODE\n+   && reload_completed\n+   && REGNO (operands[4]) != DESTINATION_REG\"\n+  [(const_int 0)]\n+  {\n+    rtx dest;\n+\n+    h8300_swap_into_er6 (XEXP (operands[0], 0));\n+    dest = replace_equiv_address (operands[0], hard_frame_pointer_rtx);\n+    emit_insn (gen_movmd (dest, operands[1], operands[2], operands[3]));\n+    h8300_swap_out_of_er6 (operands[4]);\n+    DONE;\n+  })\n+\n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t(match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (unspec [(match_operand:HI 2 \"register_operand\" \"\")\n+\t    (match_operand:HI 3 \"const_int_operand\" \"\")] UNSPEC_MOVMD)\n+   (clobber (match_operand:SI 4 \"register_operand\" \"\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"\"))\n+   (set (match_dup 2)\n+\t(const_int 0))]\n+  \"TARGET_H8300SX && !TARGET_NORMAL_MODE\n+   && reload_completed\n+   && REGNO (operands[4]) != DESTINATION_REG\"\n+  [(const_int 0)]\n+  {\n+    rtx dest;\n+\n+    h8300_swap_into_er6 (XEXP (operands[0], 0));\n+    dest = replace_equiv_address (operands[0], hard_frame_pointer_rtx);\n+    emit_insn (gen_movmd (dest, operands[1], operands[2], operands[3]));\n+    h8300_swap_out_of_er6 (operands[4]);\n+    DONE;\n+  })\n+\n+;; Expand a call to stpcpy() using movsd.  Operand 0 should point to\n+;; the final character, but movsd leaves it pointing to the character\n+;; after that.\n+(define_expand \"movstr\"\n+  [(use (match_operand 0 \"register_operand\" \"\"))\n+   (use (match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (use (match_operand:BLK 2 \"memory_operand\" \"\"))]\n+  \"TARGET_H8300SX\"\n+  {\n+    operands[1] = replace_equiv_address\n+      (operands[1], copy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n+    operands[2] = replace_equiv_address\n+      (operands[2], copy_to_mode_reg (Pmode, XEXP (operands[2], 0)));\n+    emit_insn (gen_movsd (operands[1], operands[2], gen_reg_rtx (Pmode)));\n+    emit_insn (gen_add3_insn (operands[0],\n+\t\t\t      XEXP (operands[1], 0),\n+\t\t\t      constm1_rtx));\n+    DONE;\n+  })\n+\n+;; Expander for generating a movsd instruction.  Operand 0 is the\n+;; destination string, operand 1 is the source string and operand 2\n+;; is a scratch register.\n+(define_expand \"movsd\"\n+  [(parallel\n+     [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t   (unspec:BLK [(match_operand:BLK 1 \"memory_operand\" \"\")]\n+\t\t       UNSPEC_STPCPY))\n+      (clobber (match_dup 3))\n+      (clobber (match_dup 4))\n+      (clobber (match_operand 2 \"register_operand\" \"\"))])]\n+  \"TARGET_H8300SX\"\n+  {\n+    operands[3] = copy_rtx (XEXP (operands[0], 0));\n+    operands[4] = copy_rtx (XEXP (operands[1], 0));\n+  })\n+\n+;; See comments above memcpy_internal().\n+(define_insn \"stpcpy_internal_normal\"\n+  [(set (mem:BLK (match_operand:HI 3 \"register_operand\" \"0,r\"))\n+\t(unspec:BLK [(mem:BLK (match_operand:HI 4 \"register_operand\" \"1,1\"))]\n+\t\tUNSPEC_STPCPY))\n+   (clobber (match_operand:HI 0 \"register_operand\" \"=d,??D\"))\n+   (clobber (match_operand:HI 1 \"register_operand\" \"=f,f\"))\n+   (clobber (match_operand:HI 2 \"register_operand\" \"=c,c\"))]\n+  \"TARGET_H8300SX && TARGET_NORMAL_MODE\"\n+  \"@\n+    \\n1:\\tmovsd\\t2f\\;bra\\t1b\\n2:\n+    #\"\n+  [(set_attr \"length\" \"6,18\")\n+   (set_attr \"cc\" \"none,clobber\")])\n+\n+(define_insn \"stpcpy_internal\"\n+  [(set (mem:BLK (match_operand:SI 3 \"register_operand\" \"0,r\"))\n+\t(unspec:BLK [(mem:BLK (match_operand:SI 4 \"register_operand\" \"1,1\"))]\n+\t\tUNSPEC_STPCPY))\n+   (clobber (match_operand:SI 0 \"register_operand\" \"=d,??D\"))\n+   (clobber (match_operand:SI 1 \"register_operand\" \"=f,f\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=c,c\"))]\n+  \"TARGET_H8300SX && !TARGET_NORMAL_MODE\"\n+  \"@\n+    \\n1:\\tmovsd\\t2f\\;bra\\t1b\\n2:\n+    #\"\n+  [(set_attr \"length\" \"6,18\")\n+   (set_attr \"cc\" \"none,clobber\")])\n+\n+;; Split the above instruction if the destination isn't er6.  This works\n+;; in the same way as the movmd splitter.\n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t(unspec:BLK [(match_operand:BLK 1 \"memory_operand\" \"\")] UNSPEC_STPCPY))\n+   (clobber (match_operand:HI 2 \"register_operand\" \"\"))\n+   (clobber (match_operand:HI 3 \"register_operand\" \"\"))\n+   (clobber (match_operand:HI 4 \"register_operand\" \"\"))]\n+  \"TARGET_H8300SX && TARGET_NORMAL_MODE\n+   && reload_completed\n+   && REGNO (operands[2]) != DESTINATION_REG\"\n+  [(const_int 0)]\n+  {\n+    rtx dest;\n+\n+    h8300_swap_into_er6 (XEXP (operands[0], 0));\n+    dest = replace_equiv_address (operands[0], hard_frame_pointer_rtx);\n+    emit_insn (gen_movsd (dest, operands[1], operands[4]));\n+    h8300_swap_out_of_er6 (operands[2]);\n+    DONE;\n+  })\n+\n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t(unspec:BLK [(match_operand:BLK 1 \"memory_operand\" \"\")] UNSPEC_STPCPY))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"\"))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"\"))\n+   (clobber (match_operand:SI 4 \"register_operand\" \"\"))]\n+  \"TARGET_H8300SX && !TARGET_NORMAL_MODE\n+   && reload_completed\n+   && REGNO (operands[2]) != DESTINATION_REG\"\n+  [(const_int 0)]\n+  {\n+    rtx dest;\n+\n+    h8300_swap_into_er6 (XEXP (operands[0], 0));\n+    dest = replace_equiv_address (operands[0], hard_frame_pointer_rtx);\n+    emit_insn (gen_movsd (dest, operands[1], operands[4]));\n+    h8300_swap_out_of_er6 (operands[2]);\n+    DONE;\n+  })\n+\n+(include \"mova.md\")\n+\n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand_dst\" \"\")\n \t(match_operand:SF 1 \"general_operand_src\" \"\"))]\n@@ -434,7 +781,7 @@\n       if (h8300_expand_movsi (operands))\n \tDONE;\n     }\n-  else\n+  else if (!TARGET_H8300SX)\n     {\n       /* One of the ops has to be in a register.  */\n       if (!register_operand (operand1, SFmode)\n@@ -504,7 +851,7 @@\n (define_insn \"*movsf_h8300hs\"\n   [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,r,r,m,<,r\")\n \t(match_operand:SF 1 \"general_operand_src\" \"G,r,im,r,r,>\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n+  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\n    && (register_operand (operands[0], SFmode)\n        || register_operand (operands[1], SFmode))\"\n   \"@\n@@ -641,7 +988,7 @@\n    btst\\\\t%Z1,%Y0\n    #\"\n   \"&& reload_completed\n-   && !EXTRA_CONSTRAINT (operands[0], 'U')\"\n+   && !OK_FOR_U (operands[0])\"\n   [(set (match_dup 2)\n \t(match_dup 0))\n    (parallel [(set (cc0) (zero_extract:SI (match_dup 2)\n@@ -707,7 +1054,7 @@\n    btst\\\\t%w1,%X0\n    #\"\n   \"&& reload_completed\n-   && !EXTRA_CONSTRAINT (operands[0], 'U')\"\n+   && !OK_FOR_U (operands[0])\"\n   [(set (match_dup 2)\n \t(match_dup 0))\n    (parallel [(set (cc0) (zero_extract:SI (zero_extend:SI (match_dup 2))\n@@ -760,17 +1107,17 @@\n \n (define_insn \"cmpqi\"\n   [(set (cc0)\n-\t(compare (match_operand:QI 0 \"register_operand\" \"r\")\n-\t\t (match_operand:QI 1 \"nonmemory_operand\" \"rn\")))]\n+\t(compare (match_operand:QI 0 \"h8300_dst_operand\" \"rQ\")\n+\t\t (match_operand:QI 1 \"h8300_src_operand\" \"rQi\")))]\n   \"\"\n   \"cmp.b\t%X1,%X0\"\n-  [(set_attr \"length\" \"2\")\n+  [(set_attr \"length_table\" \"addb\")\n    (set_attr \"cc\" \"compare\")])\n \n (define_expand \"cmphi\"\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (match_operand:HI 1 \"nonmemory_operand\" \"\")))]\n+\t(compare (match_operand:HI 0 \"h8300_dst_operand\" \"\")\n+\t\t (match_operand:HI 1 \"h8300_src_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -791,46 +1138,54 @@\n \n (define_insn \"*cmphi_h8300hs_znvc\"\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"r,r\")\n-\t\t (match_operand:HI 1 \"nonmemory_operand\" \"r,n\")))]\n+\t(compare (match_operand:HI 0 \"h8300_dst_operand\" \"rU,rQ\")\n+\t\t (match_operand:HI 1 \"h8300_src_operand\" \"P3>X,rQi\")))]\n   \"TARGET_H8300H || TARGET_H8300S\"\n   \"cmp.w\t%T1,%T0\"\n-  [(set_attr \"length\" \"2,4\")\n+  [(set_attr \"length_table\" \"short_immediate,addw\")\n    (set_attr \"cc\" \"compare,compare\")])\n \n (define_insn \"cmpsi\"\n   [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"r,r\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"r,i\")))]\n+\t(compare (match_operand:SI 0 \"h8300_dst_operand\" \"r,rQ\")\n+\t\t (match_operand:SI 1 \"h8300_src_operand\" \"P3>X,rQi\")))]\n   \"TARGET_H8300H || TARGET_H8300S\"\n   \"cmp.l\t%S1,%S0\"\n-  [(set_attr \"length\" \"2,6\")\n+  [(set_attr \"length\" \"2,*\")\n+   (set_attr \"length_table\" \"*,addl\")\n    (set_attr \"cc\" \"compare,compare\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; ADD INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"addqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(plus:QI (match_operand:QI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:QI 2 \"nonmemory_operand\" \"rn\")))]\n+(define_expand \"addqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(plus:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t (match_operand:QI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n+  \"\")\n+\n+(define_insn \"*addqi3\"\n+  [(set (match_operand:QI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(plus:QI (match_operand:QI 1 \"h8300_dst_operand\" \"%0\")\n+\t\t (match_operand:QI 2 \"h8300_src_operand\" \"rQi\")))]\n+  \"h8300_operands_match_p (operands)\"\n   \"add.b\t%X2,%X0\"\n-  [(set_attr \"length\" \"2\")\n+  [(set_attr \"length_table\" \"addb\")\n    (set_attr \"cc\" \"set_zn\")])\n \n (define_expand \"addhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+\t\t (match_operand:HI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n (define_insn \"*addhi3_h8300\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0\")\n-\t\t (match_operand:HI 2 \"nonmemory_operand\" \"L,N,J,n,r\")))]\n+\t\t (match_operand:HI 2 \"h8300_src_operand\" \"L,N,J,n,r\")))]\n   \"TARGET_H8300\"\n   \"@\n    adds\t%2,%T0\n@@ -873,8 +1228,8 @@\n (define_insn \"*addhi3_h8300hs\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0\")\n-\t\t (match_operand:HI 2 \"nonmemory_operand\" \"L,N,J,n,r\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+\t\t (match_operand:HI 2 \"h8300_src_operand\" \"L,N,J,n,r\")))]\n+  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\"\n   \"@\n    adds\t%2,%S0\n    subs\t%G2,%S0\n@@ -896,6 +1251,20 @@\n   [(set_attr \"length\" \"2,2\")\n    (set_attr \"cc\" \"set_zn,set_zn\")])\n \n+(define_insn \"*addhi3_h8sx\"\n+  [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rU,rU,r,rQ\")\n+\t(plus:HI (match_operand:HI 1 \"h8300_dst_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:HI 2 \"h8300_src_operand\" \"P3>X,P3<X,J,rQi\")))]\n+  \"TARGET_H8300SX && h8300_operands_match_p (operands)\"\n+  \"@\n+   add.w\t%T2,%T0\n+   sub.w\t%G2,%T0\n+   add.b\t%t2,%t0\n+   add.w\t%T2,%T0\"\n+  [(set_attr \"length_table\" \"short_immediate,short_immediate,*,addw\")\n+   (set_attr \"length\" \"*,*,2,*\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n (define_split\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(plus:HI (match_dup 0)\n@@ -907,14 +1276,14 @@\n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+\t\t (match_operand:SI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n (define_insn \"*addsi_h8300\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"n,r\")))]\n+\t\t (match_operand:SI 2 \"h8300_src_operand\" \"n,r\")))]\n   \"TARGET_H8300\"\n   \"* return output_plussi (operands);\"\n   [(set (attr \"length\")\n@@ -923,10 +1292,10 @@\n \t(symbol_ref \"compute_plussi_cc (operands)\"))])\n \n (define_insn \"*addsi_h8300hs\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"i,r\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ,rQ\")\n+\t(plus:SI (match_operand:SI 1 \"h8300_dst_operand\" \"%0,0\")\n+\t\t (match_operand:SI 2 \"h8300_src_operand\" \"i,rQ\")))]\n+  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n   \"* return output_plussi (operands);\"\n   [(set (attr \"length\")\n \t(symbol_ref \"compute_plussi_length (operands)\"))\n@@ -957,26 +1326,33 @@\n ;; SUBTRACT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"subqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(minus:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:QI 2 \"register_operand\" \"r\")))]\n+(define_expand \"subqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(minus:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:QI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n+  \"\")\n+\n+(define_insn \"*subqi3\"\n+  [(set (match_operand:QI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(minus:QI (match_operand:QI 1 \"h8300_dst_operand\" \"0\")\n+\t\t  (match_operand:QI 2 \"h8300_dst_operand\" \"rQ\")))]\n+  \"h8300_operands_match_p (operands)\"\n   \"sub.b\t%X2,%X0\"\n-  [(set_attr \"length\" \"2\")\n+  [(set_attr \"length_table\" \"addb\")\n    (set_attr \"cc\" \"set_zn\")])\n \n (define_expand \"subhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(minus:HI (match_operand:HI 1 \"general_operand\" \"\")\n-\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+\t(minus:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:HI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n (define_insn \"*subhi3_h8300\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n-\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"r,n\")))]\n+\t(minus:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t\t  (match_operand:HI 2 \"h8300_src_operand\" \"r,n\")))]\n   \"TARGET_H8300\"\n   \"@\n    sub.w\t%T2,%T0\n@@ -985,22 +1361,25 @@\n    (set_attr \"cc\" \"set_zn,clobber\")])\n \n (define_insn \"*subhi3_h8300hs\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n-\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"r,n\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rQ,rQ\")\n+\t(minus:HI (match_operand:HI 1 \"h8300_dst_operand\" \"0,0\")\n+\t\t  (match_operand:HI 2 \"h8300_src_operand\" \"rQ,i\")))]\n+  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n   \"@\n    sub.w\t%T2,%T0\n    sub.w\t%T2,%T0\"\n-  [(set_attr \"length\" \"2,4\")\n-   (set_attr \"cc\" \"set_zn,set_zn\")])\n+  [(set_attr \"length_table\" \"addw\")\n+   (set_attr \"cc\" \"set_zn\")])\n \n (define_expand \"subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+\t\t  (match_operand:SI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n-  \"\")\n+{\n+  if (TARGET_H8300)\n+    operands[2] = force_reg (SImode, operands[2]);\n+})\n \n (define_insn \"*subsi3_h8300\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1011,23 +1390,44 @@\n   [(set_attr \"length\" \"6\")])\n \n (define_insn \"*subsi3_h8300hs\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ,rQ\")\n+\t(minus:SI (match_operand:SI 1 \"h8300_dst_operand\" \"0,0\")\n+\t\t  (match_operand:SI 2 \"h8300_src_operand\" \"rQ,i\")))]\n+  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n   \"@\n    sub.l\t%S2,%S0\n    sub.l\t%S2,%S0\"\n-  [(set_attr \"length\" \"2,6\")\n-   (set_attr \"cc\" \"set_zn,set_zn\")])\n+  [(set_attr \"length_table\" \"addl\")\n+   (set_attr \"cc\" \"set_zn\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; MULTIPLY INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n ;; Note that the H8/300 can only handle umulqihi3.\n \n-(define_insn \"mulqihi3\"\n+(define_expand \"mulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"\"))\n+\t\t ;; intentionally-mismatched modes\n+\t\t (match_operand:QI 2 \"reg_or_nibble_operand\" \"\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\n+{\n+  if (GET_MODE (operands[2]) != VOIDmode)\n+    operands[2] = gen_rtx_SIGN_EXTEND (HImode, operands[2]);\n+}\")\n+\n+(define_insn \"*mulqihi3_const\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n+\t\t (match_operand:QI 2 \"nibble_operand\" \"IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"mulxs.b\t%X2,%T0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"*mulqihi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n \t\t (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n@@ -1036,7 +1436,28 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"set_zn\")])\n \n-(define_insn \"mulhisi3\"\n+(define_expand \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n+\t\t ;; intentionally-mismatched modes\n+\t\t (match_operand:HI 2 \"reg_or_nibble_operand\" \"\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\n+{\n+  if (GET_MODE (operands[2]) != VOIDmode)\n+    operands[2] = gen_rtx_SIGN_EXTEND (SImode, operands[2]);\n+}\")\n+\n+(define_insn \"*mulhisi3_const\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n+\t\t (match_operand:SI 2 \"nibble_operand\" \"IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"mulxs.w\t%T2,%S0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"*mulhisi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n \t\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n@@ -1045,16 +1466,58 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"set_zn\")])\n \n-(define_insn \"umulqihi3\"\n+(define_expand \"umulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"\"))\n+\t\t ;; intentionally-mismatched modes\n+\t\t (match_operand:QI 2 \"reg_or_nibble_operand\" \"\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\n+{\n+  if (GET_MODE (operands[2]) != VOIDmode)\n+    operands[2] = gen_rtx_ZERO_EXTEND (HImode, operands[2]);\n+}\")\n+\n+(define_insn \"*umulqihi3_const\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n+\t\t (match_operand:QI 2 \"nibble_operand\" \"IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"mulxu.b\t%X2,%T0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"*umulqihi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n \t\t (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n   \"\"\n-  \"mulxu\t%X2,%T0\"\n+  \"mulxu.b\t%X2,%T0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"none_0hit\")])\n \n-(define_insn \"umulhisi3\"\n+(define_expand \"umulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n+\t\t ;; intentionally-mismatched modes\n+\t\t (match_operand:HI 2 \"reg_or_nibble_operand\" \"\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\n+{\n+  if (GET_MODE (operands[2]) != VOIDmode)\n+    operands[2] = gen_rtx_ZERO_EXTEND (SImode, operands[2]);\n+}\")\n+\n+(define_insn \"*umulhisi3_const\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n+\t\t (match_operand:SI 2 \"nibble_operand\" \"IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"mulxu.w\t%T2,%S0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"*umulhisi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n \t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n@@ -1063,6 +1526,53 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"none_0hit\")])\n \n+;; We could have used mulu.[wl] here, but mulu.[lw] is only available\n+;; on a H8SX with a multiplier, whereas muls.w seems to be available\n+;; on all H8SX variants.\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (mult:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:HI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"muls.w\\\\t%T2,%T0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"muls.l\\\\t%S2,%S0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"smulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(truncate:SI\n+\t (lshiftrt:DI\n+\t  (mult:DI\n+\t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n+\t   (sign_extend:DI (match_operand:SI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))\n+\t  (const_int 32))))]\n+  \"TARGET_H8300SXMUL\"\n+  \"muls/u.l\\\\t%S2,%S0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"umulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(truncate:SI\n+\t (ashiftrt:DI\n+\t  (mult:DI\n+\t   (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n+\t   (zero_extend:DI (match_operand:SI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))\n+\t  (const_int 32))))]\n+  \"TARGET_H8300SX\"\n+  \"mulu/u.l\\\\t%S2,%S0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n ;; This is a \"bridge\" instruction.  Combine can't cram enough insns\n ;; together to crate a MAC instruction directly, but it can create\n ;; this instruction, which then allows combine to create the real\n@@ -1099,6 +1609,42 @@\n ;; DIVIDE/MOD INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n+(define_insn \"udivhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(udiv:HI\n+\t (match_operand:HI 1 \"register_operand\" \"0\")\n+\t (match_operand:HI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"divu.w\\\\t%T2,%T0\"\n+  [(set_attr \"length\" \"2\")])\n+  \n+(define_insn \"divhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(div:HI\n+\t (match_operand:HI 1 \"register_operand\" \"0\")\n+\t (match_operand:HI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"divs.w\\\\t%T2,%T0\"\n+  [(set_attr \"length\" \"2\")])\n+  \n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(udiv:SI\n+\t (match_operand:SI 1 \"register_operand\" \"0\")\n+\t (match_operand:SI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"divu.l\\\\t%S2,%S0\"\n+  [(set_attr \"length\" \"2\")])\n+  \n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(div:SI\n+\t (match_operand:SI 1 \"register_operand\" \"0\")\n+\t (match_operand:SI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"divs.l\\\\t%S2,%S0\"\n+  [(set_attr \"length\" \"2\")])\n+  \n (define_insn \"udivmodqi4\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n \t(truncate:QI\n@@ -1187,10 +1733,22 @@\n ;; AND INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n+(define_insn \"*andqi3_2\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=rQ,r\")\n+\t(and:QI (match_operand:QI 1 \"bit_operand\" \"%0,WU\")\n+\t\t(match_operand:QI 2 \"h8300_src_operand\" \"rQi,IP1>X\")))]\n+  \"TARGET_H8300SX\"\n+  \"@\n+   and\t%X2,%X0\n+   bfld\t%2,%1,%R0\"\n+  [(set_attr \"length\" \"*,8\")\n+   (set_attr \"length_table\" \"logicb,*\")\n+   (set_attr \"cc\" \"set_znv,none_0hit\")])\n+\n (define_insn \"andqi3_1\"\n   [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n \t(and:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,n\")))]\n+\t\t(match_operand:QI 2 \"h8300_src_operand\" \"rn,n\")))]\n   \"register_operand (operands[0], QImode)\n    || single_zero_operand (operands[2], QImode)\"\n   \"@\n@@ -1200,20 +1758,16 @@\n    (set_attr \"cc\" \"set_znv,none_0hit\")])\n \n (define_expand \"andqi3\"\n-  [(set (match_operand:QI 0 \"bit_operand\" \"\")\n-\t(and:QI (match_operand:QI 1 \"bit_operand\" \"\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(and:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t(match_operand:QI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (fix_bit_operand (operands, AND))\n-    DONE;\n-}\")\n+  \"\")\n \n (define_expand \"andhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(and:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+\t\t(match_operand:HI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n@@ -1275,7 +1829,7 @@\n (define_expand \"andsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+\t\t(match_operand:SI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n@@ -1284,39 +1838,36 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"iorqi3_1\"\n-  [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=rQ,U\")\n \t(ior:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,n\")))]\n-  \"register_operand (operands[0], QImode)\n+\t\t(match_operand:QI 2 \"h8300_src_operand\" \"rQi,n\")))]\n+  \"TARGET_H8300SX || register_operand (operands[0], QImode)\n    || single_one_operand (operands[2], QImode)\"\n   \"@\n    or\\\\t%X2,%X0\n    bset\\\\t%V2,%R0\"\n-  [(set_attr \"length\" \"2,8\")\n+  [(set_attr \"length\" \"*,8\")\n+   (set_attr \"length_table\" \"logicb,*\")\n    (set_attr \"cc\" \"set_znv,none_0hit\")])\n \n (define_expand \"iorqi3\"\n-  [(set (match_operand:QI 0 \"bit_operand\" \"\")\n-\t(ior:QI (match_operand:QI 1 \"bit_operand\" \"\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(ior:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t(match_operand:QI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (fix_bit_operand (operands, IOR))\n-    DONE;\n-}\")\n+  \"\")\n \n (define_expand \"iorhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(ior:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+\t\t(match_operand:HI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n (define_expand \"iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+\t\t(match_operand:SI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n@@ -1327,62 +1878,87 @@\n (define_insn \"xorqi3_1\"\n   [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n \t(xor:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,n\")))]\n-  \"register_operand (operands[0], QImode)\n+\t\t(match_operand:QI 2 \"h8300_src_operand\" \"rQi,n\")))]\n+  \"TARGET_H8300SX || register_operand (operands[0], QImode)\n    || single_one_operand (operands[2], QImode)\"\n   \"@\n    xor\\\\t%X2,%X0\n    bnot\\\\t%V2,%R0\"\n-  [(set_attr \"length\" \"2,8\")\n+  [(set_attr \"length\" \"*,8\")\n+   (set_attr \"length_table\" \"logicb,*\")\n    (set_attr \"cc\" \"set_znv,none_0hit\")])\n \n (define_expand \"xorqi3\"\n-  [(set (match_operand:QI 0 \"bit_operand\" \"\")\n-\t(xor:QI (match_operand:QI 1 \"bit_operand\" \"\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(xor:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t(match_operand:QI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (fix_bit_operand (operands, XOR))\n-    DONE;\n-}\")\n+  \"\")\n \n (define_expand \"xorhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(xor:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+\t\t(match_operand:HI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n (define_expand \"xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+\t\t(match_operand:SI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n ;; ----------------------------------------------------------------------\n ;; {AND,IOR,XOR}{HI3,SI3} PATTERNS\n ;; ----------------------------------------------------------------------\n \n+;; We need a separate pattern here because machines other than the\n+;; original H8300 don't have to split the 16-bit operand into a pair\n+;; of high/low instructions, so we can accept literal addresses, that\n+;; have to be loaded into a register on H8300.\n+(define_insn \"*logicalhi3_sn\"\n+  [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(match_operator:HI 3 \"bit_operator\"\n+\t  [(match_operand:HI 1 \"h8300_dst_operand\" \"%0\")\n+\t   (match_operand:HI 2 \"h8300_src_operand\" \"rQi\")]))]\n+  \"(TARGET_H8300S || TARGET_H8300H) && h8300_operands_match_p (operands)\"\n+  \"* return output_logical_op (HImode, operands);\"\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_logical_op_length (HImode, operands)\"))\n+   (set (attr \"cc\")\n+\t(symbol_ref \"compute_logical_op_cc (HImode, operands)\"))])\n+\n+(define_insn \"*logicalsi3_sn\"\n+  [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(match_operator:SI 3 \"bit_operator\"\n+\t  [(match_operand:SI 1 \"h8300_dst_operand\" \"%0\")\n+\t   (match_operand:SI 2 \"h8300_src_operand\" \"rQi\")]))]\n+  \"(TARGET_H8300S || TARGET_H8300H) && h8300_operands_match_p (operands)\"\n+  \"* return output_logical_op (SImode, operands);\"\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_logical_op_length (SImode, operands)\"))\n+   (set (attr \"cc\")\n+\t(symbol_ref \"compute_logical_op_cc (SImode, operands)\"))])\n+\n (define_insn \"*logicalhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rQ\")\n \t(match_operator:HI 3 \"bit_operator\"\n-\t  [(match_operand:HI 1 \"register_operand\" \"%0\")\n-\t   (match_operand:HI 2 \"nonmemory_operand\" \"rn\")]))]\n-  \"\"\n+\t  [(match_operand:HI 1 \"h8300_dst_operand\" \"%0\")\n+\t   (match_operand:HI 2 \"h8300_src_operand\" \"rQi\")]))]\n+  \"h8300_operands_match_p (operands)\"\n   \"* return output_logical_op (HImode, operands);\"\n   [(set (attr \"length\")\n \t(symbol_ref \"compute_logical_op_length (HImode, operands)\"))\n    (set (attr \"cc\")\n \t(symbol_ref \"compute_logical_op_cc (HImode, operands)\"))])\n \n (define_insn \"*logicalsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ\")\n \t(match_operator:SI 3 \"bit_operator\"\n-\t  [(match_operand:SI 1 \"register_operand\" \"%0\")\n-\t   (match_operand:SI 2 \"nonmemory_operand\" \"rn\")]))]\n-  \"\"\n+\t  [(match_operand:SI 1 \"h8300_dst_operand\" \"%0\")\n+\t   (match_operand:SI 2 \"h8300_src_operand\" \"rQi\")]))]\n+  \"h8300_operands_match_p (operands)\"\n   \"* return output_logical_op (SImode, operands);\"\n   [(set (attr \"length\")\n \t(symbol_ref \"compute_logical_op_length (SImode, operands)\"))\n@@ -1393,12 +1969,18 @@\n ;; NEGATION INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"negqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(neg:QI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+(define_expand \"negqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(neg:QI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*negqi2\"\n+  [(set (match_operand:QI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(neg:QI (match_operand:QI 1 \"h8300_dst_operand\" \"0\")))]\n   \"\"\n   \"neg\t%X0\"\n-  [(set_attr \"length\" \"2\")\n+  [(set_attr \"length_table\" \"unary\")\n    (set_attr \"cc\" \"set_zn\")])\n \n (define_expand \"neghi2\"\n@@ -1424,11 +2006,11 @@\n   \"operands[2] = gen_reg_rtx (HImode);\")\n \n (define_insn \"*neghi2_h8300hs\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(neg:HI (match_operand:HI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n-  \"neg\t%T0\"\n-  [(set_attr \"length\" \"2\")\n+  [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(neg:HI (match_operand:HI 1 \"h8300_dst_operand\" \"0\")))]\n+  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n+  \"neg.w\t%T0\"\n+  [(set_attr \"length_table\" \"unary\")\n    (set_attr \"cc\" \"set_zn\")])\n \n (define_expand \"negsi2\"\n@@ -1454,11 +2036,11 @@\n   \"operands[2] = gen_reg_rtx (SImode);\")\n \n (define_insn \"*negsi2_h8300hs\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n-  \"neg\t%S0\"\n-  [(set_attr \"length\" \"2\")\n+  [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(neg:SI (match_operand:SI 1 \"h8300_dst_operand\" \"0\")))]\n+  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n+  \"neg.l\t%S0\"\n+  [(set_attr \"length_table\" \"unary\")\n    (set_attr \"cc\" \"set_zn\")])\n \n (define_expand \"negsf2\"\n@@ -1509,17 +2091,23 @@\n ;; NOT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"one_cmplqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(not:QI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+(define_expand \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(not:QI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(not:QI (match_operand:QI 1 \"h8300_dst_operand\" \"0\")))]\n   \"\"\n   \"not\t%X0\"\n-  [(set_attr \"length\" \"2\")\n+  [(set_attr \"length_table\" \"unary\")\n    (set_attr \"cc\" \"set_znv\")])\n \n (define_expand \"one_cmplhi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(not:HI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(not:HI (match_operand:HI 1 \"register_operand\" \"\")))]\n   \"\"\n   \"\")\n \n@@ -1531,16 +2119,16 @@\n   [(set_attr \"length\" \"4\")])\n \n (define_insn \"*one_cmplhi2_h8300hs\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(not:HI (match_operand:HI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n-  \"not\t%T0\"\n+  [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(not:HI (match_operand:HI 1 \"h8300_dst_operand\" \"0\")))]\n+  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n+  \"not.w\t%T0\"\n   [(set_attr \"cc\" \"set_znv\")\n-   (set_attr \"length\" \"2\")])\n+   (set_attr \"length_table\" \"unary\")])\n \n (define_expand \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n   \"\"\n   \"\")\n \n@@ -1552,12 +2140,12 @@\n   [(set_attr \"length\" \"8\")])\n \n (define_insn \"*one_cmplsi2_h8300hs\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n-  \"not\t%S0\"\n+  [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(not:SI (match_operand:SI 1 \"h8300_dst_operand\" \"0\")))]\n+  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n+  \"not.l\t%S0\"\n   [(set_attr \"cc\" \"set_znv\")\n-   (set_attr \"length\" \"2\")])\n+   (set_attr \"length_table\" \"unary\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; JUMP INSTRUCTIONS\n@@ -1673,6 +2261,64 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"none\")])\n \n+(define_insn \"*brabc\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract (match_operand:QI 1 \"bit_memory_operand\" \"WU\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand:QI 2 \"immediate_operand\" \"n\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_H8300SX\"\n+  \"*\n+{\n+  switch (get_attr_length (insn)\n+\t  - h8300_insn_length_from_table (insn, operands))\n+    {\n+    case 2:\n+      return \\\"bra/bc\t%2,%R1,%l0\\\";\n+\n+    case 4:\n+      return \\\"bra/bc\t%2,%R1,%l0:16\\\";\n+\n+    default:\n+      return \\\"bra/bs\t%2,%R1,.Lh8BR%=\\;jmp\t@%l0\\\\n.Lh8BR%=:\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"bitbranch\")\n+   (set_attr \"length_table\" \"bitbranch\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"*brabs\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract (match_operand:QI 1 \"bit_memory_operand\" \"WU\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand:QI 2 \"immediate_operand\" \"n\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_H8300SX\"\n+  \"*\n+{\n+  switch (get_attr_length (insn)\n+\t  - h8300_insn_length_from_table (insn, operands))\n+    {\n+    case 2:\n+      return \\\"bra/bs\t%2,%R1,%l0\\\";\n+\n+    case 4:\n+      return \\\"bra/bs\t%2,%R1,%l0:16\\\";\n+\n+    default:\n+      return \\\"bra/bc\t%2,%R1,.Lh8BR%=\\;jmp\t@%l0\\\\n.Lh8BR%=:\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"bitbranch\")\n+   (set_attr \"length_table\" \"bitbranch\")\n+   (set_attr \"cc\" \"none\")])\n+\n ;; Unconditional and other jump instructions.\n \n (define_insn \"jump\"\n@@ -1681,14 +2327,42 @@\n   \"\"\n   \"*\n {\n-  if (get_attr_length (insn) == 2)\n+  if (final_sequence != 0)\n+    {\n+      if (get_attr_length (insn) == 2)\n+\treturn \\\"bra/s\t%l0\\\";\n+      else\n+\t{\n+\t  /* The branch isn't short enough to use bra/s.  Output the\n+\t     branch and delay slot in their normal order.\n+\n+\t     If this is a backward branch, it will now be branching two\n+\t     bytes further than previously thought.  The length-based\n+\t     test for bra vs. jump is very conservative though, so the\n+\t     branch will still be within range.  */\n+\t  rtvec vec;\n+\t  int seen;\n+\n+\t  vec = XVEC (final_sequence, 0);\n+\t  final_sequence = 0;\n+\t  final_scan_insn (RTVEC_ELT (vec, 1), asm_out_file, optimize, 0, 1, & seen);\n+\t  final_scan_insn (RTVEC_ELT (vec, 0), asm_out_file, optimize, 0, 1, & seen);\n+\t  INSN_DELETED_P (RTVEC_ELT (vec, 1)) = 1;\n+\t  return \\\"\\\";\n+\t}\n+    }\n+  else if (get_attr_length (insn) == 2)\n     return \\\"bra\t%l0\\\";\n   else if (get_attr_length (insn) == 4)\n     return \\\"bra\t%l0:16\\\";\n   else\n     return \\\"jmp\t@%l0\\\";\n }\"\n   [(set_attr \"type\" \"branch\")\n+   (set (attr \"delay_slot\")\n+\t(if_then_else (ne (symbol_ref \"TARGET_H8300SX\") (const_int 0))\n+\t\t      (const_string \"jump\")\n+\t\t      (const_string \"none\")))\n    (set_attr \"cc\" \"none\")])\n \n ;; This is a define expand, because pointers may be either 16 or 32 bits.\n@@ -1767,7 +2441,8 @@\n   else\n     return \\\"jsr\\\\t%0\\\";\n }\"\n-  [(set (attr \"length\")\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n \t(if_then_else (match_operand:QI 0 \"small_call_insn_operand\" \"\")\n \t\t      (const_int 2)\n \t\t      (const_int 4)))])\n@@ -1790,7 +2465,8 @@\n   else\n     return \\\"jsr\\\\t%1\\\";\n }\"\n-  [(set (attr \"length\")\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n \t(if_then_else (match_operand:QI 0 \"small_call_insn_operand\" \"\")\n \t\t      (const_int 2)\n \t\t      (const_int 4)))])\n@@ -1814,311 +2490,77 @@\n \n (define_expand \"push_h8300hs_advanced\"\n   [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-        (match_operand:SI 0 \"register_operand\" \"\"))]\n-  \"TARGET_H8300H && TARGET_H8300S && !TARGET_NORMAL_MODE\"\n-  \"\")\n-\n-(define_expand \"push_h8300hs_normal\"\n-  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-        (match_operand:SI 0 \"register_operand\" \"\"))]\n-  \"TARGET_H8300H && TARGET_H8300S && TARGET_NORMAL_MODE\"\n-  \"\")\n-\n-(define_expand \"pop_h8300\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(mem:HI (post_inc:HI (reg:HI SP_REG))))]\n-  \"TARGET_H8300\"\n-  \"\")\n-\n-(define_expand \"pop_h8300hs_advanced\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(mem:SI (post_inc:SI (reg:SI SP_REG))))]\n-  \"TARGET_H8300H && TARGET_H8300S && !TARGET_NORMAL_MODE\"\n-  \"\")\n-\n-(define_expand \"pop_h8300hs_normal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(mem:SI (post_inc:HI (reg:HI SP_REG))))]\n-  \"TARGET_H8300H && TARGET_H8300S && TARGET_NORMAL_MODE\"\n-  \"\")\n-\n-(define_insn \"stm_h8300s_2_advanced\"\n-  [(set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG) (const_int -8)))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (2, operands)\"\n-  \"stm.l\\\\t%S0-%S1,@-er7\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"stm_h8300s_2_normal\"\n-  [(set (reg:HI SP_REG)\n-\t(plus:HI (reg:HI SP_REG) (const_int -8)))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (2, operands)\"\n-  \"stm.l\\\\t%S0-%S1,@-er7\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_expand \"stm_h8300s_2\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")\n-   (match_operand:SI 1 \"register_operand\" \"\")]\n-  \"TARGET_H8300S\n-   && h8300_regs_ok_for_stm (2, operands)\"\n-  \"\n-{\n-  if (!TARGET_NORMAL_MODE)\n-    emit_insn (gen_stm_h8300s_2_advanced (operands[0], operands[1]));\n-  else\n-    emit_insn (gen_stm_h8300s_2_normal (operands[0], operands[1]));\n-  DONE;\n-}\")\n-\n-(define_insn \"stm_h8300s_3_advanced\"\n-  [(set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG) (const_int -12)))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (3, operands)\"\n-  \"stm.l\\\\t%S0-%S2,@-er7\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"stm_h8300s_3_normal\"\n-  [(set (reg:HI SP_REG)\n-\t(plus:HI (reg:HI SP_REG) (const_int -12)))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (3, operands)\"\n-  \"stm.l\\\\t%S0-%S2,@-er7\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_expand \"stm_h8300s_3\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")\n-   (match_operand:SI 1 \"register_operand\" \"\")\n-   (match_operand:SI 2 \"register_operand\" \"\")]\n-  \"TARGET_H8300S\n-   && h8300_regs_ok_for_stm (3, operands)\"\n-  \"\n-{\n-  if (!TARGET_NORMAL_MODE)\n-    emit_insn (gen_stm_h8300s_3_advanced (operands[0], operands[1],\n-\t\t\t\t\t  operands[2]));\n-  else\n-    emit_insn (gen_stm_h8300s_3_normal (operands[0], operands[1],\n-\t\t\t\t\toperands[2]));\n-  DONE;\n-}\")\n-\n-(define_insn \"stm_h8300s_4_advanced\"\n-  [(set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG) (const_int -16)))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -16)))\n-\t(match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (4, operands)\"\n-  \"stm.l\\\\t%S0-%S3,@-er7\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"stm_h8300s_4_normal\"\n-  [(set (reg:HI SP_REG)\n-\t(plus:HI (reg:HI SP_REG) (const_int -16)))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -16)))\n-\t(match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (4, operands)\"\n-  \"stm.l\\\\t%S0-%S3,@-er7\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_expand \"stm_h8300s_4\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")\n-   (match_operand:SI 1 \"register_operand\" \"\")\n-   (match_operand:SI 2 \"register_operand\" \"\")\n-   (match_operand:SI 3 \"register_operand\" \"\")]\n-  \"TARGET_H8300S\n-   && h8300_regs_ok_for_stm (4, operands)\"\n-  \"\n-{\n-  if (!TARGET_NORMAL_MODE)\n-    emit_insn (gen_stm_h8300s_4_advanced (operands[0], operands[1],\n-\t\t\t\t\t  operands[2], operands[3]));\n-  else\n-    emit_insn (gen_stm_h8300s_4_normal (operands[0], operands[1],\n-\t\t\t\t\toperands[2], operands[3]));\n-  DONE;\n-}\")\n-\n-(define_insn \"ldm_h8300s_2_advanced\"\n-  [(set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG) (const_int 8)))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 4)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (reg:SI SP_REG))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (2, operands)\"\n-  \"ldm.l\\\\t@er7+,%S0-%S1\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"ldm_h8300s_2_normal\"\n-  [(set (reg:HI SP_REG)\n-\t(plus:HI (reg:HI SP_REG) (const_int 8)))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int 4)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (reg:HI SP_REG))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (2, operands)\"\n-  \"ldm.l\\\\t@er7+,%S0-%S1\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_expand \"ldm_h8300s_2\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")\n-   (match_operand:SI 1 \"register_operand\" \"\")]\n-  \"TARGET_H8300S\n-   && h8300_regs_ok_for_stm (2, operands)\"\n-  \"\n-{\n-  if (!TARGET_NORMAL_MODE)\n-    emit_insn (gen_ldm_h8300s_2_advanced (operands[0], operands[1]));\n-  else\n-    emit_insn (gen_ldm_h8300s_2_normal (operands[0], operands[1]));\n-  DONE;\n-}\")\n+        (match_operand:SI 0 \"register_operand\" \"\"))]\n+  \"TARGET_H8300H && TARGET_H8300S && !TARGET_NORMAL_MODE\"\n+  \"\")\n \n-(define_insn \"ldm_h8300s_3_advanced\"\n-  [(set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG) (const_int 12)))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 8)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 4)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (reg:SI SP_REG))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (3, operands)\"\n-  \"ldm.l\\\\t@er7+,%S0-%S2\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"4\")])\n+(define_expand \"push_h8300hs_normal\"\n+  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n+        (match_operand:SI 0 \"register_operand\" \"\"))]\n+  \"TARGET_H8300H && TARGET_H8300S && TARGET_NORMAL_MODE\"\n+  \"\")\n \n-(define_insn \"ldm_h8300s_3_normal\"\n-  [(set (reg:HI SP_REG)\n-\t(plus:HI (reg:HI SP_REG) (const_int 12)))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int 8)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int 4)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (reg:HI SP_REG))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (3, operands)\"\n-  \"ldm.l\\\\t@er7+,%S0-%S2\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"4\")])\n+(define_expand \"pop_h8300\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mem:HI (post_inc:HI (reg:HI SP_REG))))]\n+  \"TARGET_H8300\"\n+  \"\")\n \n-(define_expand \"ldm_h8300s_3\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")\n-   (match_operand:SI 1 \"register_operand\" \"\")\n-   (match_operand:SI 2 \"register_operand\" \"\")]\n-  \"TARGET_H8300S\n-   && h8300_regs_ok_for_stm (3, operands)\"\n-  \"\n-{\n-  if (!TARGET_NORMAL_MODE)\n-    emit_insn (gen_ldm_h8300s_3_advanced (operands[0], operands[1],\n-\t\t\t\t\t  operands[2]));\n-  else\n-    emit_insn (gen_ldm_h8300s_3_normal (operands[0], operands[1],\n-\t\t\t\t\toperands[2]));\n-  DONE;\n-}\")\n+(define_expand \"pop_h8300hs_advanced\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mem:SI (post_inc:SI (reg:SI SP_REG))))]\n+  \"TARGET_H8300H && TARGET_H8300S && !TARGET_NORMAL_MODE\"\n+  \"\")\n \n-(define_insn \"ldm_h8300s_4_advanced\"\n-  [(set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG) (const_int 16)))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 12)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 8)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int 4)))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))\n-   (set (mem:SI (reg:SI SP_REG))\n-\t(match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (4, operands)\"\n-  \"ldm.l\\\\t@er7+,%S0-%S3\"\n+(define_expand \"pop_h8300hs_normal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mem:SI (post_inc:HI (reg:HI SP_REG))))]\n+  \"TARGET_H8300H && TARGET_H8300S && TARGET_NORMAL_MODE\"\n+  \"\")\n+\n+(define_insn \"ldm_h8300sx\"\n+  [(match_parallel           0 \"h8300_ldm_parallel\"\n+     [(set (match_operand:SI 1 \"register_operand\" \"\")\n+\t   (match_operand:SI 2 \"memory_operand\" \"\"))])]\n+  \"TARGET_H8300S\"\n+  {\n+    operands[3] = SET_DEST (XVECEXP (operands[0], 0,\n+\t\t\t\t     XVECLEN (operands[0], 0) - 2));\n+    return \"ldm.l\\t@er7+,%S1-%S3\";\n+  }\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn \"ldm_h8300s_4_normal\"\n-  [(set (reg:HI SP_REG)\n-\t(plus:HI (reg:HI SP_REG) (const_int 16)))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int 12)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int 8)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int 4)))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))\n-   (set (mem:SI (reg:HI SP_REG))\n-\t(match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (4, operands)\"\n-  \"ldm.l\\\\t@er7+,%S0-%S3\"\n+(define_insn \"stm_h8300sx\"\n+  [(match_parallel           0 \"h8300_stm_parallel\"\n+     [(set (match_operand:SI 1 \"memory_operand\" \"\")\n+\t   (match_operand:SI 2 \"register_operand\" \"\"))])]\n+  \"TARGET_H8300S\"\n+  {\n+    operands[3] = SET_SRC (XVECEXP (operands[0], 0,\n+\t\t\t\t    XVECLEN (operands[0], 0) - 2));\n+    return \"stm.l\\t%S2-%S3,@-er7\";\n+  }\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"4\")])\n \n-(define_expand \"ldm_h8300s_4\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")\n-   (match_operand:SI 1 \"register_operand\" \"\")\n-   (match_operand:SI 2 \"register_operand\" \"\")\n-   (match_operand:SI 3 \"register_operand\" \"\")]\n-  \"TARGET_H8300S\n-   && h8300_regs_ok_for_stm (4, operands)\"\n-  \"\n-{\n-  if (!TARGET_NORMAL_MODE)\n-    emit_insn (gen_ldm_h8300s_4_advanced (operands[0], operands[1],\n-\t\t\t\t\t  operands[2], operands[3]));\n-  else\n-    emit_insn (gen_ldm_h8300s_4_normal (operands[0], operands[1],\n-\t\t\t\t\toperands[2], operands[3]));\n-  DONE;\n-}\")\n+(define_insn \"return_h8sx\"\n+  [(match_parallel           0 \"h8300_return_parallel\"\n+     [(return)\n+      (set (match_operand:SI 1 \"register_operand\" \"\")\n+\t   (match_operand:SI 2 \"memory_operand\" \"\"))])]\n+  \"TARGET_H8300SX\"\n+  {\n+    operands[3] = SET_DEST (XVECEXP (operands[0], 0,\n+\t\t\t\t     XVECLEN (operands[0], 0) - 2));\n+    if (h8300_current_function_interrupt_function_p ())\n+      return \"rte/l\\t%S1-%S3\";\n+    else\n+      return \"rts/l\\t%S1-%S3\";\n+  }\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"can_delay\" \"no\")\n+   (set_attr \"length\" \"2\")])\n \n (define_expand \"return\"\n   [(return)]\n@@ -2136,6 +2578,7 @@\n     return \\\"rts\\\";\n }\"\n   [(set_attr \"cc\" \"none\")\n+   (set_attr \"can_delay\" \"no\")\n    (set_attr \"length\" \"2\")])\n \n (define_expand \"prologue\"\n@@ -2146,7 +2589,7 @@\n (define_expand \"epilogue\"\n   [(return)]\n   \"\"\n-  \"h8300_expand_epilogue ();\")\n+  \"h8300_expand_epilogue (); DONE;\")\n \n (define_insn \"monitor_prologue\"\n   [(unspec_volatile [(const_int 0)] UNSPEC_MONITOR)]\n@@ -2211,7 +2654,10 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"\")))]\n   \"\"\n-  \"\")\n+  {\n+    if (TARGET_H8300SX)\n+      operands[1] = force_reg (QImode, operands[1]);\n+  })\n \n (define_insn \"*zero_extendqisi2_h8300\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -2225,13 +2671,13 @@\n (define_insn \"*zero_extendqisi2_h8300hs\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\"\n   \"#\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n+  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\n    && reg_overlap_mentioned_p (operands[0], operands[1])\n    && reload_completed\"\n   [(set (match_dup 2)\n@@ -2246,7 +2692,7 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n+  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\n    && !reg_overlap_mentioned_p (operands[0], operands[1])\n    && reload_completed\"\n   [(set (match_dup 0)\n@@ -2255,6 +2701,14 @@\n \t(match_dup 1))]\n   \"operands[2] = gen_rtx_REG (QImode, REGNO (operands[0]));\")\n \n+(define_insn \"*zero_extendqisi2_h8sx\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"TARGET_H8300SX\"\n+  \"extu.l\\t#2,%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n (define_expand \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n@@ -2325,7 +2779,7 @@\n (define_insn_and_split \"*extendqisi2_h8300hs\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"0\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\"\n+  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2)\n@@ -2334,6 +2788,14 @@\n \t(sign_extend:SI (match_dup 2)))]\n   \"operands[2] = gen_rtx_REG (HImode, REGNO (operands[0]));\")\n \n+(define_insn \"*extendqisi2_h8sx\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"TARGET_H8300SX\"\n+  \"exts.l\\t#2,%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n (define_expand \"extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n@@ -2383,21 +2845,41 @@\n \t(ashift:QI (match_operand:QI 1 \"register_operand\" \"\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"expand_a_shift (QImode, ASHIFT, operands); DONE;\")\n+  \"if (expand_a_shift (QImode, ASHIFT, operands)) DONE;\")\n \n (define_expand \"ashrqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"expand_a_shift (QImode, ASHIFTRT, operands); DONE;\")\n+  \"if (expand_a_shift (QImode, ASHIFTRT, operands)) DONE;\")\n \n (define_expand \"lshrqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"expand_a_shift (QImode, LSHIFTRT, operands); DONE;\")\n+  \"if (expand_a_shift (QImode, LSHIFTRT, operands)) DONE;\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(match_operator:QI 3 \"h8sx_unary_shift_operator\"\n+\t\t\t[(match_operand:QI 1 \"h8300_dst_operand\" \"0\")\n+\t\t\t (match_operand:QI 2 \"const_int_operand\" \"\")]))]\n+  \"h8300_operands_match_p (operands)\"\n+  { return output_h8sx_shift (operands, 'b', 'X'); }\n+  [(set_attr \"length_table\" \"unary\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(match_operator:QI 3 \"h8sx_binary_shift_operator\"\n+\t\t\t[(match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:QI 2 \"nonmemory_operand\" \"r P3>X\")]))]\n+  \"\"\n+  { return output_h8sx_shift (operands, 'b', 'X'); }\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_znv\")])\n \n (define_insn \"*shiftqi\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n@@ -2416,24 +2898,44 @@\n \n (define_expand \"ashlhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(ashift:HI (match_operand:HI 1 \"nonmemory_operand\" \"\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"expand_a_shift (HImode, ASHIFT, operands); DONE;\")\n+  \"if (expand_a_shift (HImode, ASHIFT, operands)) DONE;\")\n \n (define_expand \"lshrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"expand_a_shift (HImode, LSHIFTRT, operands); DONE;\")\n+  \"if (expand_a_shift (HImode, LSHIFTRT, operands)) DONE;\")\n \n (define_expand \"ashrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"expand_a_shift (HImode, ASHIFTRT, operands); DONE;\")\n+  \"if (expand_a_shift (HImode, ASHIFTRT, operands)) DONE;\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(match_operator:HI 3 \"h8sx_unary_shift_operator\"\n+\t\t\t[(match_operand:HI 1 \"h8300_dst_operand\" \"0\")\n+\t\t\t (match_operand:QI 2 \"const_int_operand\" \"\")]))]\n+  \"h8300_operands_match_p (operands)\"\n+  { return output_h8sx_shift (operands, 'w', 'T'); }\n+  [(set_attr \"length_table\" \"unary\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_operator:HI 3 \"h8sx_binary_shift_operator\"\n+\t\t\t[(match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:QI 2 \"nonmemory_operand\" \"r P4>X\")]))]\n+  \"\"\n+  { return output_h8sx_shift (operands, 'w', 'T'); }\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_znv\")])\n \n (define_insn \"*shifthi\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n@@ -2452,24 +2954,44 @@\n \n (define_expand \"ashlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"expand_a_shift (SImode, ASHIFT, operands); DONE;\")\n+  \"if (expand_a_shift (SImode, ASHIFT, operands)) DONE;\")\n \n (define_expand \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"expand_a_shift (SImode, LSHIFTRT, operands); DONE;\")\n+  \"if (expand_a_shift (SImode, LSHIFTRT, operands)) DONE;\")\n \n (define_expand \"ashrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"expand_a_shift (SImode, ASHIFTRT, operands); DONE;\")\n+  \"if (expand_a_shift (SImode, ASHIFTRT, operands)) DONE;\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(match_operator:SI 3 \"h8sx_unary_shift_operator\"\n+\t\t\t[(match_operand:SI 1 \"h8300_dst_operand\" \"0\")\n+\t\t\t (match_operand:QI 2 \"const_int_operand\" \"\")]))]\n+  \"h8300_operands_match_p (operands)\"\n+  { return output_h8sx_shift (operands, 'l', 'S'); }\n+  [(set_attr \"length_table\" \"unary\")\n+   (set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 3 \"h8sx_binary_shift_operator\"\n+\t\t\t[(match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:QI 2 \"nonmemory_operand\" \"r P5>X\")]))]\n+  \"\"\n+  { return output_h8sx_shift (operands, 'l', 'S'); }\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_znv\")])\n \n (define_insn \"*shiftsi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -2560,7 +3082,7 @@\n \t(rotate:QI (match_operand:QI 1 \"register_operand\" \"\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"if (expand_a_rotate (operands)) DONE; else FAIL;\")\n+  \"if (expand_a_rotate (operands)) DONE;\")\n \n (define_insn \"rotlqi3_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n@@ -2576,7 +3098,7 @@\n \t(rotate:HI (match_operand:HI 1 \"register_operand\" \"\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"if (expand_a_rotate (operands)) DONE; else FAIL;\")\n+  \"if (expand_a_rotate (operands)) DONE;\")\n \n (define_insn \"rotlhi3_1\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n@@ -2592,7 +3114,7 @@\n \t(rotate:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"TARGET_H8300H || TARGET_H8300S\"\n-  \"if (expand_a_rotate (operands)) DONE; else FAIL;\")\n+  \"if (expand_a_rotate (operands)) DONE;\")\n \n (define_insn \"rotlsi3_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -2703,9 +3225,54 @@\n \t\t\t (match_operand:HI 1 \"general_operand\" \"\")\n \t\t\t (match_operand:HI 2 \"general_operand\" \"\"))\n \t(match_operand:HI 3 \"general_operand\" \"\"))]\n-  \"TARGET_H8300\"\n+  \"TARGET_H8300 || TARGET_H8300SX\"\n   \"\n {\n+  if (TARGET_H8300SX)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_INT\n+          && GET_CODE (operands[2]) == CONST_INT\n+          && INTVAL (operands[1]) <= 8\n+          && INTVAL (operands[2]) >= 0\n+          && INTVAL (operands[1]) + INTVAL (operands[2]) <= 8\n+\t  && memory_operand (operands[0], GET_MODE (operands[0])))\n+        {\n+\t  /* If the source operand is zero, it's better to use AND rather\n+\t     than BFST.  Likewise OR if the operand is all ones.  */\n+\t  if (GET_CODE (operands[3]) == CONST_INT)\n+\t    {\n+\t      HOST_WIDE_INT mask = (1 << INTVAL (operands[1])) - 1;\n+\t      if ((INTVAL (operands[3]) & mask) == 0)\n+\t\tFAIL;\n+\t      if ((INTVAL (operands[3]) & mask) == mask)\n+\t\tFAIL;\n+\t    }\n+          if (! bit_memory_operand (operands[0], GET_MODE (operands[0])))\n+\t    {\n+\t      if (no_new_pseudos)\n+\t\tFAIL;\n+\t      operands[0] =\n+\t        replace_equiv_address (operands[0],\n+\t\t\t\t       force_reg (Pmode,\n+\t\t\t\t\t\t  XEXP (operands[0], 0)));\n+\t    }\n+\t  operands[3] = gen_lowpart (QImode, operands[3]);\n+\t  if (! operands[3])\n+\t    FAIL;\n+\t  if (! register_operand (operands[3], QImode))\n+\t    {\n+\t      if (no_new_pseudos)\n+\t\tFAIL;\n+\t      operands[3] = force_reg (QImode, operands[3]);\n+\t    }\n+\t  emit_insn (gen_bfst (adjust_address (operands[0], QImode, 0),\n+\t\t\t       operands[3], operands[1], operands[2]));\n+\t  DONE;\n+        }\n+\n+      FAIL;\n+    }\n+\n   /* We only have single bit bit-field instructions.  */\n   if (INTVAL (operands[1]) != 1)\n     FAIL;\n@@ -2730,9 +3297,52 @@\n \t(zero_extract:HI (match_operand:HI 1 \"bit_operand\" \"\")\n \t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n \t\t\t (match_operand:HI 3 \"general_operand\" \"\")))]\n-  \"TARGET_H8300\"\n+  \"TARGET_H8300 || TARGET_H8300SX\"\n   \"\n {\n+  if (TARGET_H8300SX)\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && GET_CODE (operands[3]) == CONST_INT\n+          && INTVAL (operands[2]) <= 8\n+          && INTVAL (operands[3]) >= 0\n+          && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8\n+\t  && memory_operand (operands[1], QImode))\n+\t{\n+\t  rtx temp;\n+\n+\t  /* Optimize the case where we're extracting into a paradoxical\n+\t     subreg.  It's only necessary to extend to the inner reg.  */\n+\t  if (GET_CODE (operands[0]) == SUBREG\n+\t      && subreg_lowpart_p (operands[0])\n+\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (operands[0])))\n+\t\t  < GET_MODE_SIZE (GET_MODE (operands[0])))\n+\t      && (GET_MODE_CLASS (GET_MODE (SUBREG_REG (operands[0])))\n+\t\t  == MODE_INT))\n+\t    operands[0] = SUBREG_REG (operands[0]);\n+\n+\t  if (no_new_pseudos)\n+\t    temp = gen_lowpart (QImode, operands[0]);\n+\t  else\n+\t    temp = gen_reg_rtx (QImode);\n+\t  if (! temp)\n+\t    FAIL;\n+          if (! bit_memory_operand (operands[1], QImode))\n+\t    {\n+\t      if (no_new_pseudos)\n+\t\tFAIL;\n+\t      operands[1] =\n+\t        replace_equiv_address (operands[1],\n+\t\t\t\t       force_reg (Pmode,\n+\t\t\t\t\t\t  XEXP (operands[1], 0)));\n+\t    }\n+\t  emit_insn (gen_bfld (temp, operands[1], operands[2], operands[3]));\n+\t  convert_move (operands[0], temp, 1);\n+\t  DONE;\n+        }\n+      FAIL;\n+    }\n+\n   /* We only have single bit bit-field instructions.  */\n   if (INTVAL (operands[2]) != 1)\n     FAIL;\n@@ -2767,6 +3377,282 @@\n   \"\"\n   \"bld\t%Z2,%Y1\\;b%c5\t%Z4,%Y3\\;bst\t#0,%R0; bl3\"\n   [(set_attr \"length\" \"6\")])\n+\n+(define_insn \"bfld\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:QI (match_operand:QI 1 \"bit_memory_operand\" \"WU\")\n+\t\t\t (match_operand:QI 2 \"immediate_operand\" \"n\")\n+\t\t\t (match_operand:QI 3 \"immediate_operand\" \"n\")))]\n+  \"TARGET_H8300SX && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8\"\n+  \"*\n+{\n+  operands[2] = GEN_INT ((1 << (INTVAL (operands[2]) + INTVAL (operands[3])))\n+\t\t\t - (1 << INTVAL (operands[3])));\n+  return \\\"bfld\t%2,%1,%R0\\\";\n+}\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"bitfield\")])\n+\n+(define_insn \"bfst\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"+WU\")\n+\t\t\t (match_operand:QI 2 \"immediate_operand\" \"n\")\n+\t\t\t (match_operand:QI 3 \"immediate_operand\" \"n\"))\n+\t(match_operand:QI 1 \"register_operand\" \"r\"))]\n+  \"TARGET_H8300SX && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8\"\n+  \"*\n+{\n+  operands[2] = GEN_INT ((1 << (INTVAL (operands[2]) + INTVAL (operands[3])))\n+\t\t\t - (1 << INTVAL (operands[3])));\n+  return \\\"bfst\t%R1,%2,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"bitfield\")])\n+\n+(define_expand \"seq\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(eq:HI (cc0) (const_int 0)))]\n+  \"TARGET_H8300SX\"\n+  \"\")\n+\n+(define_expand \"sne\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ne:HI (cc0) (const_int 0)))]\n+  \"TARGET_H8300SX\"\n+  \"\")\n+\n+(define_insn \"*bstzhireg\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_operator:HI 1 \"eqne_operator\" [(cc0) (const_int 0)]))]\n+  \"TARGET_H8300SX\"\n+  \"mulu.w\t#0,%T0\\;b%k1\t.Lh8BR%=\\;inc.w\t#1,%T0\\\\n.Lh8BR%=:\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn_and_split \"*cmpstz\"\n+  [(set (zero_extract:QI\n+\t (match_operand:QI 0 \"bit_memory_operand\" \"+WU,+WU\")\n+\t (const_int 1)\n+\t (match_operand:QI 1 \"immediate_operand\" \"n,n\"))\n+\t(match_operator:QI\n+\t 2 \"eqne_operator\"\n+\t [(match_operand 3 \"h8300_dst_operand\" \"r,rQ\")\n+\t  (match_operand 4 \"h8300_src_operand\" \"I,rQi\")]))]\n+  \"TARGET_H8300SX\n+   && (GET_MODE (operands[3]) == GET_MODE (operands[4])\n+       || GET_CODE (operands[4]) == CONST_INT)\n+   && GET_MODE_CLASS (GET_MODE (operands[3])) == MODE_INT\n+   && GET_MODE_SIZE (GET_MODE (operands[3])) <= 4\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (cc0) (match_dup 5))\n+   (set (zero_extract:QI (match_dup 0) (const_int 1) (match_dup 1))\n+\t(match_op_dup:QI 2 [(cc0) (const_int 0)]))]\n+  \"\n+{\n+  if (operands[4] == const0_rtx && GET_CODE (operands[3]) == REG)\n+    operands[5] = operands[3];\n+  else\n+    operands[5] = gen_rtx_COMPARE (VOIDmode, operands[3], operands[4]);\n+}\"\n+  [(set_attr \"cc\" \"set_znv,compare\")])\n+   \n+(define_insn \"*bstz\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"+WU\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:QI 1 \"immediate_operand\" \"n\"))\n+\t(eq:QI (cc0) (const_int 0)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bstz\t%1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"unary\")])\n+\n+(define_insn \"*bistz\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"+WU\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:QI 1 \"immediate_operand\" \"n\"))\n+\t(ne:QI (cc0) (const_int 0)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bistz\t%1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"unary\")])\n+\n+(define_insn_and_split \"*cmpcondbset\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n+\t(if_then_else:QI\n+\t (match_operator\n+\t  1 \"eqne_operator\"\n+\t  [(match_operand 2 \"h8300_dst_operand\" \"r,rQ\")\n+\t   (match_operand 3 \"h8300_src_operand\" \"I,rQi\")])\n+\t (ior:QI\n+\t  (match_operand:QI 4 \"bit_memory_operand\" \"0,0\")\n+\t  (match_operand:QI 5 \"single_one_operand\" \"n,n\"))\n+\t (match_dup 4)))]\n+  \"TARGET_H8300SX\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (cc0) (match_dup 6))\n+   (set (match_dup 0)\n+\t(if_then_else:QI\n+\t (match_op_dup 1 [(cc0) (const_int 0)])\n+\t (ior:QI (match_dup 4) (match_dup 5)) (match_dup 4)))]\n+  \"\n+{\n+  if (operands[3] == const0_rtx && GET_CODE (operands[2]) == REG)\n+    operands[6] = operands[2];\n+  else\n+    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n+}\"\n+  [(set_attr \"cc\" \"set_znv,compare\")])\n+   \n+(define_insn \"*condbset\"\n+  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n+\t(if_then_else:QI\n+\t (match_operator:QI 2 \"eqne_operator\"\n+\t\t\t    [(cc0) (const_int 0)])\n+\t (ior:QI\n+\t  (match_operand:QI 3 \"bit_memory_operand\" \"0\")\n+\t  (match_operand:QI 1 \"single_one_operand\" \"n\"))\n+\t (match_dup 3)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bset/%j2\\t%V1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"logicb\")])\n+\n+(define_insn_and_split \"*cmpcondbclr\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n+\t(if_then_else:QI\n+\t (match_operator\n+\t  1 \"eqne_operator\"\n+\t  [(match_operand 2 \"h8300_dst_operand\" \"r,rQ\")\n+\t   (match_operand 3 \"h8300_src_operand\" \"I,rQi\")])\n+\t (and:QI\n+\t  (match_operand:QI 4 \"bit_memory_operand\" \"0,0\")\n+\t  (match_operand:QI 5 \"single_zero_operand\" \"n,n\"))\n+\t (match_dup 4)))]\n+  \"TARGET_H8300SX\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (cc0) (match_dup 6))\n+   (set (match_dup 0)\n+\t(if_then_else:QI\n+\t (match_op_dup 1 [(cc0) (const_int 0)])\n+\t (and:QI (match_dup 4) (match_dup 5)) (match_dup 4)))]\n+  \"\n+{\n+  if (operands[3] == const0_rtx && GET_CODE (operands[2]) == REG)\n+    operands[6] = operands[2];\n+  else\n+    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n+}\"\n+  [(set_attr \"cc\" \"set_znv,compare\")])\n+   \n+(define_insn \"*condbclr\"\n+  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n+\t(if_then_else:QI\n+\t (match_operator:QI 2 \"eqne_operator\"\n+\t\t\t    [(cc0) (const_int 0)])\n+\t (and:QI\n+\t  (match_operand:QI 3 \"bit_memory_operand\" \"0\")\n+\t  (match_operand:QI 1 \"single_zero_operand\" \"n\"))\n+\t (match_dup 3)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bclr/%j2\\t%W1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"logicb\")])\n+\n+(define_insn_and_split \"*cmpcondbsetreg\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n+\t(if_then_else:QI\n+\t (match_operator\n+\t  1 \"eqne_operator\"\n+\t  [(match_operand 2 \"h8300_dst_operand\" \"r,rQ\")\n+\t   (match_operand 3 \"h8300_src_operand\" \"I,rQi\")])\n+\t (ior:QI\n+\t  (match_operand:QI 4 \"bit_memory_operand\" \"0,0\")\n+\t  (ashift:QI (const_int 1)\n+\t\t     (match_operand:QI 5 \"register_operand\" \"r,r\")))\n+\t (match_dup 4)))]\n+  \"TARGET_H8300SX\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (cc0) (match_dup 6))\n+   (set (match_dup 0)\n+\t(if_then_else:QI\n+\t (match_op_dup 1 [(cc0) (const_int 0)])\n+\t (ior:QI (match_dup 4)\n+\t\t (ashift:QI (const_int 1)\n+\t\t\t    (match_operand:QI 5 \"register_operand\" \"r,r\")))\n+\t (match_dup 4)))]\n+  \"\n+{\n+  if (operands[3] == const0_rtx && GET_CODE (operands[2]) == REG)\n+    operands[6] = operands[2];\n+  else\n+    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n+}\"\n+  [(set_attr \"cc\" \"set_znv,compare\")])\n+   \n+(define_insn \"*condbsetreg\"\n+  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n+\t(if_then_else:QI\n+\t (match_operator:QI 2 \"eqne_operator\"\n+\t\t\t    [(cc0) (const_int 0)])\n+\t (ior:QI\n+\t  (match_operand:QI 3 \"bit_memory_operand\" \"0\")\n+\t  (ashift:QI (const_int 1)\n+\t\t     (match_operand:QI 1 \"register_operand\" \"r\")))\n+\t (match_dup 3)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bset/%j2\\t%R1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"logicb\")])\n+\n+(define_insn_and_split \"*cmpcondbclrreg\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n+\t(if_then_else:QI\n+\t (match_operator\n+\t  1 \"eqne_operator\"\n+\t  [(match_operand 2 \"h8300_dst_operand\" \"r,rQ\")\n+\t   (match_operand 3 \"h8300_src_operand\" \"I,rQi\")])\n+\t (and:QI\n+\t  (match_operand:QI 4 \"bit_memory_operand\" \"0,0\")\n+\t  (ashift:QI (const_int 1)\n+\t\t     (match_operand:QI 5 \"register_operand\" \"r,r\")))\n+\t (match_dup 4)))]\n+  \"TARGET_H8300SX\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (cc0) (match_dup 6))\n+   (set (match_dup 0)\n+\t(if_then_else:QI\n+\t (match_op_dup 1 [(cc0) (const_int 0)])\n+\t (and:QI (match_dup 4)\n+\t\t (ashift:QI (const_int 1)\n+\t\t\t    (match_operand:QI 5 \"register_operand\" \"r,r\")))\n+\t (match_dup 4)))]\n+  \"\n+{\n+  if (operands[3] == const0_rtx && GET_CODE (operands[2]) == REG)\n+    operands[6] = operands[2];\n+  else\n+    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n+}\"\n+  [(set_attr \"cc\" \"set_znv,compare\")])\n+   \n+(define_insn \"*condbclrreg\"\n+  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n+\t(if_then_else:QI\n+\t (match_operator:QI 2 \"eqne_operator\"\n+\t\t\t    [(cc0) (const_int 0)])\n+\t (and:QI\n+\t  (match_operand:QI 3 \"bit_memory_operand\" \"0\")\n+\t  (ashift:QI (const_int 1)\n+\t\t     (match_operand:QI 1 \"register_operand\" \"r\")))\n+\t (match_dup 3)))]\n+  \"TARGET_H8300SX && reload_completed\"\n+  \"bclr/%j2\\t%R1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"length_table\" \"logicb\")])\n+\n \f\n ;; -----------------------------------------------------------------\n ;; COMBINE PATTERNS\n@@ -3674,7 +4560,7 @@\n                    (plus:SI (reg:SI SP_REG) (const_int -4)))\n               (set (mem:QI (plus:SI (reg:SI SP_REG) (const_int -3)))\n                    (match_operand:QI 0 \"register_operand\" \"\"))])]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE\"\n+  \"TARGET_H8300S && !TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n   [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n \t(match_dup 0))]\n   \"operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\")\n@@ -3684,7 +4570,7 @@\n                    (plus:HI (reg:HI SP_REG) (const_int -4)))\n               (set (mem:QI (plus:HI (reg:HI SP_REG) (const_int -3)))\n                    (match_operand:QI 0 \"register_operand\" \"\"))])]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE\"\n+  \"TARGET_H8300S && TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n   [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n \t(match_dup 0))]\n   \"operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\")\n@@ -3697,7 +4583,7 @@\n                    (plus:SI (reg:SI SP_REG) (const_int -4)))\n               (set (mem:HI (plus:SI (reg:SI SP_REG) (const_int -2)))\n                    (match_operand:HI 0 \"register_operand\" \"\"))])]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE\"\n+  \"TARGET_H8300S && !TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n   [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n \t(match_dup 0))]\n   \"operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\")\n@@ -3707,7 +4593,7 @@\n                    (plus:HI (reg:HI SP_REG) (const_int -4)))\n               (set (mem:HI (plus:HI (reg:HI SP_REG) (const_int -2)))\n                    (match_operand:HI 0 \"register_operand\" \"\"))])]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE\"\n+  \"TARGET_H8300S && TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n   [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n \t(match_dup 0))]\n   \"operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\")\n@@ -3724,18 +4610,22 @@\n    (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n \t(match_operand:SI 3 \"register_operand\" \"\"))]\n   \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (4, operands)\"\n-  [(parallel [(set (reg:SI SP_REG)\n-\t\t   (plus:SI (reg:SI SP_REG)\n-\t\t\t    (const_int -16)))\n-\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n+   && (REGNO_REG_CLASS (REGNO (operands[3])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n+       && REGNO (operands[3]) == REGNO (operands[0]) + 3\n+       && (TARGET_H8300SX || REGNO (operands[0]) == 0))\"\n+  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n \t\t   (match_dup 0))\n \t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n \t\t   (match_dup 1))\n \t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))\n \t\t   (match_dup 2))\n \t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -16)))\n-\t\t   (match_dup 3))])]\n+\t\t   (match_dup 3))\n+\t      (set (reg:SI SP_REG)\n+\t\t   (plus:SI (reg:SI SP_REG)\n+\t\t\t    (const_int -16)))])]\n   \"\")\n \n (define_peephole2\n@@ -3748,18 +4638,22 @@\n    (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n \t(match_operand:SI 3 \"register_operand\" \"\"))]\n   \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (4, operands)\"\n-  [(parallel [(set (reg:HI SP_REG)\n-\t\t   (plus:HI (reg:HI SP_REG)\n-\t\t\t    (const_int -16)))\n-\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n+   && (REGNO_REG_CLASS (REGNO (operands[3])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n+       && REGNO (operands[3]) == REGNO (operands[0]) + 3\n+       && (TARGET_H8300SX || REGNO (operands[0]) == 0))\"\n+  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n \t\t   (match_dup 0))\n \t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n \t\t   (match_dup 1))\n \t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))\n \t\t   (match_dup 2))\n \t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -16)))\n-\t\t   (match_dup 3))])]\n+\t\t   (match_dup 3))\n+\t      (set (reg:HI SP_REG)\n+\t\t   (plus:HI (reg:HI SP_REG)\n+\t\t\t    (const_int -16)))])]\n   \"\")\n \n ;; Cram three pushes into stm.l.\n@@ -3772,16 +4666,19 @@\n    (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n \t(match_operand:SI 2 \"register_operand\" \"\"))]\n   \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (3, operands)\"\n-  [(parallel [(set (reg:SI SP_REG)\n-\t\t   (plus:SI (reg:SI SP_REG)\n-\t\t\t    (const_int -12)))\n-\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n+   && (REGNO_REG_CLASS (REGNO (operands[2])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n+       && (TARGET_H8300SX || (REGNO (operands[0]) & 3) == 0))\"\n+  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n \t\t   (match_dup 0))\n \t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n \t\t   (match_dup 1))\n \t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))\n-\t\t   (match_dup 2))])]\n+\t\t   (match_dup 2))\n+\t      (set (reg:SI SP_REG)\n+\t\t   (plus:SI (reg:SI SP_REG)\n+\t\t\t    (const_int -12)))])]\n   \"\")\n \n (define_peephole2\n@@ -3792,16 +4689,19 @@\n    (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n \t(match_operand:SI 2 \"register_operand\" \"\"))]\n   \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (3, operands)\"\n-  [(parallel [(set (reg:HI SP_REG)\n-\t\t   (plus:HI (reg:HI SP_REG)\n-\t\t\t    (const_int -12)))\n-\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n+   && (REGNO_REG_CLASS (REGNO (operands[2])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n+       && (TARGET_H8300SX || (REGNO (operands[0]) & 3) == 0))\"\n+  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n \t\t   (match_dup 0))\n \t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n \t\t   (match_dup 1))\n \t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))\n-\t\t   (match_dup 2))])]\n+\t\t   (match_dup 2))\n+\t      (set (reg:HI SP_REG)\n+\t\t   (plus:HI (reg:HI SP_REG)\n+\t\t\t    (const_int -12)))])]\n   \"\")\n \n ;; Cram two pushes into stm.l.\n@@ -3812,14 +4712,16 @@\n    (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n \t(match_operand:SI 1 \"register_operand\" \"\"))]\n   \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (2, operands)\"\n-  [(parallel [(set (reg:SI SP_REG)\n-\t\t   (plus:SI (reg:SI SP_REG)\n-\t\t\t    (const_int -8)))\n-\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n+   && (REGNO_REG_CLASS (REGNO (operands[1])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && (TARGET_H8300SX || (REGNO (operands[0]) & 1) == 0))\"\n+  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n \t\t   (match_dup 0))\n \t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n-\t\t   (match_dup 1))])]\n+\t\t   (match_dup 1))\n+\t      (set (reg:SI SP_REG)\n+\t\t   (plus:SI (reg:SI SP_REG)\n+\t\t\t    (const_int -8)))])]\n   \"\")\n \n (define_peephole2\n@@ -3828,14 +4730,16 @@\n    (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n \t(match_operand:SI 1 \"register_operand\" \"\"))]\n   \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && h8300_regs_ok_for_stm (2, operands)\"\n-  [(parallel [(set (reg:HI SP_REG)\n-\t\t   (plus:HI (reg:HI SP_REG)\n-\t\t\t    (const_int -8)))\n-\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n+   && (REGNO_REG_CLASS (REGNO (operands[1])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && (TARGET_H8300SX || (REGNO (operands[0]) & 1) == 0))\"\n+  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n \t\t   (match_dup 0))\n \t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n-\t\t   (match_dup 1))])]\n+\t\t   (match_dup 1))\n+\t      (set (reg:HI SP_REG)\n+\t\t   (plus:HI (reg:HI SP_REG)\n+\t\t\t    (const_int -8)))])]\n   \"\")\n \n ;; Turn\n@@ -4045,6 +4949,7 @@\n \t\t(const_int 255)))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n    && !reg_overlap_mentioned_p (operands[0], operands[1])\n+   && !(GET_CODE (operands[1]) == MEM && !offsettable_memref_p (operands[1]))\n    && !(GET_CODE (operands[1]) == MEM && MEM_VOLATILE_P (operands[1]))\"\n   [(set (match_dup 0)\n \t(const_int 0))\n@@ -4066,6 +4971,9 @@\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && REGNO (operands[0]) == REGNO (operands[2])\n    && !reg_overlap_mentioned_p (operands[2], operands[1])\n+   && !(GET_MODE (operands[1]) != QImode\n+\t&& GET_CODE (operands[1]) == MEM\n+\t&& !offsettable_memref_p (operands[1]))\n    && !(GET_MODE (operands[1]) != QImode\n \t&& GET_CODE (operands[1]) == MEM\n \t&& MEM_VOLATILE_P (operands[1]))\"\n@@ -4108,6 +5016,7 @@\n \t\t(match_operand:SI 2 \"const_int_operand\" \"\")))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n    && !MEM_VOLATILE_P (operands[1])\n+   && offsettable_memref_p (operands[1])\n    && (INTVAL (operands[2]) & ~0xffff) == 0\n    && INTVAL (operands[2]) != 255\"\n   [(set (match_dup 3)\n@@ -5064,3 +5973,143 @@\n    (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n \t(match_dup 0))]\n   \"\")\n+\n+;; Transform\n+;;\n+;;\tmov\tdst,reg\n+;;\top\tsrc,reg\n+;;\tmov\treg,dst\n+;;\n+;; into\n+;;\n+;;\top\tsrc,dst\n+;;\n+;; if \"reg\" dies at the end of the sequence.\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"memory_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(match_operator 2 \"h8sx_binary_memory_operator\"\n+\t   [(match_dup 0)\n+\t    (match_operand 3 \"h8300_src_operand\" \"\")]))\n+   (set (match_operand 4 \"memory_operand\" \"\")\n+\t(match_dup 0))]\n+  \"0 /* Disabale because it break compiling fp-bit.c.  */\n+   && TARGET_H8300SX\n+   && peep2_reg_dead_p (3, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[3])\n+   && !reg_overlap_mentioned_p (operands[0], operands[4])\n+   && h8sx_mergeable_memrefs_p (operands[4], operands[1])\"\n+  [(set (match_dup 4)\n+\t(match_dup 5))]\n+  {\n+    operands[5] = shallow_copy_rtx (operands[2]);\n+    XEXP (operands[5], 0) = operands[1];\n+  })\n+\n+;; Transform\n+;;\n+;;\tmov\tsrc,reg\n+;;\top\treg,dst\n+;;\n+;; into\n+;;\n+;;\top\tsrc,dst\n+;;\n+;; if \"reg\" dies in the second insn.\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"h8300_src_operand\" \"\"))\n+   (set (match_operand 2 \"h8300_dst_operand\" \"\")\n+\t(match_operator 3 \"h8sx_binary_memory_operator\"\n+\t   [(match_operand 4 \"h8300_dst_operand\" \"\")\n+\t    (match_dup 0)]))]\n+  \"0 /* Disabale because it break compiling fp-bit.c.  */\n+   && TARGET_H8300SX\n+   && peep2_reg_dead_p (2, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[4])\"\n+  [(set (match_dup 2)\n+\t(match_dup 5))]\n+  {\n+    operands[5] = shallow_copy_rtx (operands[3]);\n+    XEXP (operands[5], 1) = operands[1];\n+  })\n+\n+;; Transform\n+;;\n+;;\tmov\tdst,reg\n+;;\top\treg\n+;;\tmov\treg,dst\n+;;\n+;; into\n+;;\n+;;\top\tdst\n+;;\n+;; if \"reg\" dies at the end of the sequence.\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"memory_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(match_operator 2 \"h8sx_unary_memory_operator\"\n+\t   [(match_dup 0)]))\n+   (set (match_operand 3 \"memory_operand\" \"\")\n+\t(match_dup 0))]\n+  \"TARGET_H8300SX\n+   && peep2_reg_dead_p (3, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[3])\n+   && h8sx_mergeable_memrefs_p (operands[3], operands[1])\"\n+  [(set (match_dup 3)\n+\t(match_dup 4))]\n+  {\n+    operands[4] = shallow_copy_rtx (operands[2]);\n+    XEXP (operands[4], 0) = operands[1];\n+  })\n+\n+;; Transform\n+;;\n+;;\tmov\tsrc1,reg\n+;;\tcmp\treg,src2\n+;;\n+;; into\n+;;\n+;;\tcmp\tsrc1,src2\n+;;\n+;; if \"reg\" dies in the comparison.\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"h8300_dst_operand\" \"\"))\n+   (set (cc0)\n+\t(compare (match_dup 0)\n+\t\t (match_operand 2 \"h8300_src_operand\" \"\")))]\n+  \"TARGET_H8300SX\n+   && peep2_reg_dead_p (2, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[2])\"\n+  [(set (cc0)\n+\t(compare (match_dup 1)\n+\t\t (match_dup 2)))])\n+\n+;; Likewise for the second operand.\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"h8300_src_operand\" \"\"))\n+   (set (cc0)\n+\t(compare (match_operand 2 \"h8300_dst_operand\" \"\")\n+\t\t (match_dup 0)))]\n+  \"TARGET_H8300SX\n+   && peep2_reg_dead_p (2, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[2])\"\n+  [(set (cc0)\n+\t(compare (match_dup 2)\n+\t\t (match_dup 1)))])\n+\n+;; Combine two moves.\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"h8300_src_operand\" \"\"))\n+   (set (match_operand 2 \"h8300_dst_operand\" \"\")\n+\t(match_dup 0))]\n+  \"TARGET_H8300SX\n+   && peep2_reg_dead_p (2, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[2])\"\n+  [(set (match_dup 2)\n+\t(match_dup 1))])"}, {"sha": "a638d8d8e6d3ca4122846371395d6d8ca59315e5", "filename": "gcc/config/h8300/lib1funcs.asm", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Flib1funcs.asm?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -72,7 +72,7 @@ Boston, MA 02111-1307, USA.  */\n #define S2P\tr6\n #endif\n \n-#if defined (__H8300H__) || defined (__H8300S__)\n+#if defined (__H8300H__) || defined (__H8300S__) || defined (__H8300SX__)\n #define PUSHP\tpush.l\n #define POPP\tpop.l\n \n@@ -105,6 +105,13 @@ Boston, MA 02111-1307, USA.  */\n \t.h8300s\n #endif\n #endif\n+#ifdef __H8300SX__\n+#ifdef __NORMAL_MODE__\n+\t.h8300sxn\n+#else\n+\t.h8300sx\n+#endif\n+#endif\n \n #ifdef L_cmpsi2\n #ifdef __H8300__"}, {"sha": "5c4d5d9d9116678e12212a0332bb6bd01770b1e5", "filename": "gcc/config/h8300/mova.md", "status": "added", "additions": 841, "deletions": 0, "changes": 841, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fmova.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Fmova.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fmova.md?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -0,0 +1,841 @@\n+;; -*- buffer-read-only: t -*-\n+;; Generated automatically from genmova.sh\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+\t(plus:QI (mult:QI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\")\n+\t\t\t   (const_int 2))\n+\t\t (match_operand:QI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+\t(plus:QI (ashift:QI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\")\n+\t\t\t   (const_int 1))\n+\t\t (match_operand:QI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+\t(plus:QI (mult:QI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\")\n+\t\t\t   (const_int 4))\n+\t\t (match_operand:QI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+\t(plus:QI (ashift:QI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\")\n+\t\t\t   (const_int 2))\n+\t\t (match_operand:QI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(plus:HI (zero_extend:HI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/b.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 2)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(plus:HI (mult:HI (zero_extend:HI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 2))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(and:HI (mult:HI (subreg:HI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 2))\n+\t\t(const_int 510)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (and:HI (mult:HI (subreg:HI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 510))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(and:HI (mult:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 2))\n+\t\t(const_int 510)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (and:HI (mult:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 510))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:HI (zero_extend:HI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 1)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(plus:HI (ashift:HI (zero_extend:HI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 1))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(and:HI (ashift:HI (subreg:HI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 1))\n+\t\t(const_int 510)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (and:HI (ashift:HI (subreg:HI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 1))\n+\t\t\t (const_int 510))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(and:HI (ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 1))\n+\t\t(const_int 510)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (and:HI (ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 1))\n+\t\t\t (const_int 510))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 4)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(plus:HI (mult:HI (zero_extend:HI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 4))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(and:HI (mult:HI (subreg:HI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 4))\n+\t\t(const_int 1020)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (and:HI (mult:HI (subreg:HI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 4))\n+\t\t\t (const_int 1020))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(and:HI (mult:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 4))\n+\t\t(const_int 1020)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (and:HI (mult:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 4))\n+\t\t\t (const_int 1020))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:HI (zero_extend:HI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 2)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(plus:HI (ashift:HI (zero_extend:HI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 2))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(and:HI (ashift:HI (subreg:HI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 2))\n+\t\t(const_int 1020)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (and:HI (ashift:HI (subreg:HI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 1020))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(and:HI (ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 2))\n+\t\t(const_int 1020)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (and:HI (ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 1020))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (zero_extend:SI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/b.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(mult:SI (zero_extend:SI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 2)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (mult:SI (zero_extend:SI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 2))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (mult:SI (subreg:SI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 2))\n+\t\t(const_int 510)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (mult:SI (subreg:SI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 510))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 2))\n+\t\t(const_int 510)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 510))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:SI (zero_extend:SI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 1)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (ashift:SI (zero_extend:SI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 1))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (ashift:SI (subreg:SI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 1))\n+\t\t(const_int 510)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (ashift:SI (subreg:SI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 1))\n+\t\t\t (const_int 510))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 1))\n+\t\t(const_int 510)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 1))\n+\t\t\t (const_int 510))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(mult:SI (zero_extend:SI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 4)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (mult:SI (zero_extend:SI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 4))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (mult:SI (subreg:SI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 4))\n+\t\t(const_int 1020)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (mult:SI (subreg:SI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 4))\n+\t\t\t (const_int 1020))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 4))\n+\t\t(const_int 1020)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 4))\n+\t\t\t (const_int 1020))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:SI (zero_extend:SI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 2)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (ashift:SI (zero_extend:SI (match_operand:QI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 2))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (ashift:SI (subreg:SI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 2))\n+\t\t(const_int 1020)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (ashift:SI (subreg:SI (match_operand:QI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 1020))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 2))\n+\t\t(const_int 1020)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 1020))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%X1.b),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(plus:HI (mult:HI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\")\n+\t\t\t   (const_int 2))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(plus:HI (ashift:HI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\")\n+\t\t\t   (const_int 1))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(plus:HI (mult:HI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\")\n+\t\t\t   (const_int 4))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(plus:HI (ashift:HI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\")\n+\t\t\t   (const_int 2))\n+\t\t (match_operand:HI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (zero_extend:SI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/b.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 2)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (mult:SI (zero_extend:SI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 2))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (mult:SI (subreg:SI (match_operand:HI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 2))\n+\t\t(const_int 131070)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (mult:SI (subreg:SI (match_operand:HI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 131070))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 2))\n+\t\t(const_int 131070)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 131070))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:SI (zero_extend:SI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 1)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (ashift:SI (zero_extend:SI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 1))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (ashift:SI (subreg:SI (match_operand:HI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 1))\n+\t\t(const_int 131070)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (ashift:SI (subreg:SI (match_operand:HI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 1))\n+\t\t\t (const_int 131070))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 1))\n+\t\t(const_int 131070)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 1))\n+\t\t\t (const_int 131070))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/w.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 4)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (mult:SI (zero_extend:SI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 4))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (mult:SI (subreg:SI (match_operand:HI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 4))\n+\t\t(const_int 262140)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (mult:SI (subreg:SI (match_operand:HI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 4))\n+\t\t\t (const_int 262140))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 4))\n+\t\t(const_int 262140)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 4))\n+\t\t\t (const_int 262140))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:SI (zero_extend:SI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t  (const_int 2)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (ashift:SI (zero_extend:SI (match_operand:HI 1 \"h8300_dst_operand\" \"0,rQ\"))\n+\t\t\t   (const_int 2))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (ashift:SI (subreg:SI (match_operand:HI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t  (const_int 2))\n+\t\t(const_int 262140)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (ashift:SI (subreg:SI (match_operand:HI 1 \"memory_operand\" \"m\") 0)\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 262140))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (const_int 2))\n+\t\t(const_int 262140)))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(0,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova_zero\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t\t   (const_int 2))\n+\t\t\t (const_int 262140))\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"TARGET_H8300SX\"\n+  \"mova/l.l @(%o2,%T1.w),%S0\"\n+  [(set_attr \"length_table\" \"mova\")\n+   (set_attr \"cc\" \"none\")])\n+"}, {"sha": "1311d968711d92bbcf08eeb06687e9fafa23cf72", "filename": "gcc/config/h8300/t-h8300", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Ft-h8300", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fconfig%2Fh8300%2Ft-h8300", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Ft-h8300?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -27,9 +27,17 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#endif' >> fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n-MULTILIB_OPTIONS = mh/ms mn mint32\n-MULTILIB_DIRNAMES = h8300h h8300s normal int32\n+MULTILIB_OPTIONS = mh/ms/msx mn mint32\n+MULTILIB_DIRNAMES = h8300h h8300s h8sx normal int32\n MULTILIB_EXCEPTIONS = mint32 mn mn/mint32\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib\n+\n+s-config s-conditions s-flags s-codes s-constants s-emit s-recog \\\n+s-opinit s-extract s-peep s-attr s-attrtab s-output: \\\n+\t$(srcdir)/config/h8300/mova.md\n+\n+$(srcdir)/config/h8300/mova.md: $(srcdir)/config/h8300/genmova.sh\n+\t$(SHELL) $(srcdir)/config/h8300/genmova.sh \\\n+\t  > $(srcdir)/config/h8300/mova.md"}, {"sha": "bbd20437e797c72c670f570f8a4d0f77d33d89a2", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -2778,8 +2778,9 @@ The @samp{cmp@var{m}} patterns should be used instead.\n \n @cindex @code{movmem@var{m}} instruction pattern\n @item @samp{movmem@var{m}}\n-Block move instruction.  The addresses of the destination and source\n-strings are the first two operands, and both are in mode @code{Pmode}.\n+Block move instruction.  The destination and source blocks of memory\n+are the first two operands, and both are @code{mem:BLK}s with an\n+address in mode @code{Pmode}.\n \n The number of bytes to move is the third operand, in mode @var{m}.\n Usually, you specify @code{word_mode} for @var{m}.  However, if you can\n@@ -2803,12 +2804,21 @@ individually moved data units in the block.\n These patterns need not give special consideration to the possibility\n that the source and destination strings might overlap.\n \n+@cindex @code{movstr} instruction pattern\n+@item @samp{movstr}\n+String copy instruction, with @code{stpcpy} semantics.  Operand 0 is\n+an output operand in mode @code{Pmode}.  The addresses of the\n+destination and source strings are operands 1 and 2, and both are\n+@code{mem:BLK}s with addresses in mode @code{Pmode}.  The execution of\n+the expansion of this pattern should store in operand 0 the address in\n+which the @code{NUL} terminator was stored in the destination string.\n+\n @cindex @code{clrmem@var{m}} instruction pattern\n @item @samp{clrmem@var{m}}\n-Block clear instruction.  The addresses of the destination string is the\n-first operand, in mode @code{Pmode}.  The number of bytes to clear is\n-the second operand, in mode @var{m}.  See @samp{movmem@var{m}} for\n-a discussion of the choice of mode.\n+Block clear instruction.  The destination string is the first operand,\n+given as a @code{mem:BLK} whose address is in mode @code{Pmode}.  The\n+number of bytes to clear is the second operand, in mode @var{m}.  See\n+@samp{movmem@var{m}} for a discussion of the choice of mode.\n \n The third operand is the known alignment of the destination, in the form\n of a @code{const_int} rtx.  Thus, if the compiler knows that the"}, {"sha": "48be2929c83bff7e8c6e22c64028b20026dd6c82", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -2660,11 +2660,13 @@ walk_alter_subreg (rtx *xp)\n     {\n     case PLUS:\n     case MULT:\n+    case AND:\n       XEXP (x, 0) = walk_alter_subreg (&XEXP (x, 0));\n       XEXP (x, 1) = walk_alter_subreg (&XEXP (x, 1));\n       break;\n \n     case MEM:\n+    case ZERO_EXTEND:\n       XEXP (x, 0) = walk_alter_subreg (&XEXP (x, 0));\n       break;\n "}, {"sha": "4a9ad8c43af6153ce9ddfeb4eedbaaa142e8df1d", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -5525,6 +5525,11 @@ write_eligible_delay (const char *kind)\n   printf (\"  if (slot >= %d)\\n\", max_slots);\n   printf (\"    abort ();\\n\");\n   printf (\"\\n\");\n+  /* Allow dbr_schedule to pass labels, etc.  This can happen if try_split\n+     converts a compound instruction into a loop.  */\n+  printf (\"  if (!INSN_P (candidate_insn))\\n\");\n+  printf (\"    return 0;\\n\");\n+  printf (\"\\n\");\n \n   /* If more than one delay type, find out which type the delay insn is.  */\n "}, {"sha": "7b0e872711b5ad53a87eb42b9c301624b169d2a1", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=beed8fc0bb23590fdfa4665c3ad5b3ca7edb17f7", "patch": "@@ -4544,6 +4544,7 @@ get_narrower (tree op, int *unsignedp_ptr)\n   int uns = 0;\n   int first = 1;\n   tree win = op;\n+  bool integral_p = INTEGRAL_TYPE_P (TREE_TYPE (op));\n \n   while (TREE_CODE (op) == NOP_EXPR)\n     {\n@@ -4580,6 +4581,10 @@ get_narrower (tree op, int *unsignedp_ptr)\n \t    uns = TYPE_UNSIGNED (TREE_TYPE (op));\n \t  first = 0;\n \t  op = TREE_OPERAND (op, 0);\n+\t  /* Keep trying to narrow, but don't assign op to win if it\n+\t     would turn an integral type into something else.  */\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (op)) != integral_p)\n+\t    continue;\n \t}\n \n       win = op;"}]}