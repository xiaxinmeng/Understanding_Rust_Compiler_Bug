{"sha": "6f95a65aa12189f267de958ceb995f40e603131e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY5NWE2NWFhMTIxODlmMjY3ZGU5NThjZWI5OTVmNDBlNjAzMTMxZQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2007-10-06T15:08:58Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2007-10-06T15:08:58Z"}, "message": "re PR libstdc++/33487 (parallel v3: more functions not in right namespace)\n\n2007-10-06  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/33487\n\t* include/parallel/algorithmfwd.h (for_each, generate, generate_n,\n\ttransform, replace, replace_if, max_element, min_element, count,\n\tcount_if): Consistently construct overloads.\n\t* include/parallel/numericfwd.h (accumulate, adjacent_difference,\n\tinner_product): Same.\n\t* include/parallel/algobase.h: Same.\n\t* include/parallel/algo.h: Same.\n\t* include/parallel/numeric: Same.\n\n\t* include/bits/algorithmfwd.h: Correct find_end placement.\n\n\t* docs/html/parallel_mode.html: Document some of the interface\n\tconventions.\n\n\t* include/parallel/search.h (calc_borders): Only use operator ==.\n\t\n\t* include/parallel/algorithmfwd.h: Move __gnu_sequential bits to...\n\t* include/parallel/tags.h: ...here, and use a using directive.\n\n\t* include/parallel/random_shuffle.h: Include stl_numeric. Qualify\n\tuses of partial_num with __gnu_sequential.\n\n\t* include/parallel/tree.h: Formatting.\n\nFrom-SVN: r129054", "tree": {"sha": "b26821aeffd62dbc8ddb9938940040a30eb8e059", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b26821aeffd62dbc8ddb9938940040a30eb8e059"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f95a65aa12189f267de958ceb995f40e603131e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f95a65aa12189f267de958ceb995f40e603131e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f95a65aa12189f267de958ceb995f40e603131e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f95a65aa12189f267de958ceb995f40e603131e/comments", "author": null, "committer": null, "parents": [{"sha": "a0689cdfd56b38666775382da03da5af72761888", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0689cdfd56b38666775382da03da5af72761888", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0689cdfd56b38666775382da03da5af72761888"}], "stats": {"total": 2341, "additions": 1520, "deletions": 821}, "files": [{"sha": "90289e105beca68a676c54cbe5dd3f97213eac8e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -1,3 +1,30 @@\n+2007-10-06  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/33487\n+\t* include/parallel/algorithmfwd.h (for_each, generate, generate_n,\n+\ttransform, replace, replace_if, max_element, min_element, count,\n+\tcount_if): Consistently construct overloads.\n+\t* include/parallel/numericfwd.h (accumulate, adjacent_difference,\n+\tinner_product): Same.\n+\t* include/parallel/algobase.h: Same.\n+\t* include/parallel/algo.h: Same.\n+\t* include/parallel/numeric: Same.\n+\n+\t* include/bits/algorithmfwd.h: Correct find_end placement.\n+\n+\t* docs/html/parallel_mode.html: Document some of the interface\n+\tconventions.\n+\n+\t* include/parallel/search.h (calc_borders): Only use operator ==.\n+\t\n+\t* include/parallel/algorithmfwd.h: Move __gnu_sequential bits to...\n+\t* include/parallel/tags.h: ...here, and use a using directive.\n+\n+\t* include/parallel/random_shuffle.h: Include stl_numeric. Qualify\n+\tuses of partial_num with __gnu_sequential.\n+\n+\t* include/parallel/tree.h: Formatting.\n+\t\n 2007-10-05  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tFixes for --disable-libstdcxx-pch."}, {"sha": "5843ae8c3d103174f70725a436b7ba1284ad9d36", "filename": "libstdc++-v3/docs/html/parallel_mode.html", "status": "modified", "additions": 92, "deletions": 9, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fparallel_mode.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fparallel_mode.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fparallel_mode.html?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -388,26 +388,109 @@ <h4 class=\"left\">Parallel mode semantics</h4>\n <p> Something about compile-time settings and configuration, ie using\n <code>__gnu_parallel::Settings</code>. XXX Up in the air.</p>\n \n-<h4 class=\"left\">Interface basics and relevant namespaces</h4>\n+<h4 class=\"left\">Interface basics and general design</h4>\n+\n+<p>All parallel algorithms are intended to have signatures that are\n+equivalent to the ISO C++ algorithms replaced. For instance, the\n+<code>std::adjacent_find</code> function is declared as:\n+\n+<pre>\n+namespace std\n+{\n+  template&lt;typename _FIter&gt;\n+    _FIter\n+    adjacent_find(_FIter, _FIter);\n+}\n+</pre>\n+\n+Which means that there should be something equivalent for the parallel\n+version. Indeed, this is the case:\n+\n+<pre>\n+namespace std\n+{\n+  namespace __parallel\n+  {\n+    template&lt;typename _FIter&gt;\n+      _FIter\n+      adjacent_find(_FIter, _FIter);\n+\n+    ...\n+  }\n+}\n+</pre>\n+\n+<p>But.... why the elipses?\n+</p>\n \n-<p> Two namespaces contain the parallel mode:\n-<code>std::__parallel</code> and <code>__gnu_parallel</code>. \n+<p> The elipses in the example above represent additional overloads\n+required for the parallel version of the function. These additional\n+overloads are used to dispatch calls from the ISO C++ function\n+signature to the appropriate parallel function (or sequential\n+function, if no parallel functions are deemed worthy), based on either\n+compile-time or run-time conditions.\n+</p>\n+\n+<p> Compile-time conditions are referred to as \"embarrassingly\n+parallel,\" and are denoted with the appropriate dispatch object, ie\n+one of <code>__gnu_parallel::sequential_tag</code>,\n+<code>__gnu_parallel::parallel_tag</code>,\n+<code>__gnu_parallel::balanced_tag</code>,\n+<code>__gnu_parallel::unbalanced_tag</code>,\n+<code>__gnu_parallel::omp_loop_tag</code>, or\n+<code>__gnu_parallel::omp_loop_static_tag</code>.\n </p>\n \n+<p> Run-time conditions depend on the hardware being used, the number\n+of threads available, etc., and are denoted by the use of the enum\n+<code>__gnu_parallel::parallelism</code>. Values of this enum include\n+<code>__gnu_parallel::sequential</code>,\n+<code>__gnu_parallel::parallel_unbalanced</code>,\n+<code>__gnu_parallel::parallel_balanced</code>,\n+<code>__gnu_parallel::parallel_omp_loop</code>,\n+<code>__gnu_parallel::parallel_omp_loop_static</code>, or\n+<code>__gnu_parallel::parallel_taskqueue</code>.\n+</p>\n+\n+<p> Putting all this together, the general view of overloads for the\n+parallel algorithms look like this:\n+<p>\n+<ul>\n+   <li>ISO C++ signature</li>\n+   <li>ISO C++ signature + sequential_tag argument</li>\n+   <li>ISO C++ signature + parallelism argument</li>\n+</ul>\n+\n+<p> Please note that the implementation may use additional functions\n+(designated with the <code>_switch</code> suffix) to dispatch from the\n+ISO C++ signature to the correct parallel version. Also, some of the\n+algorithms do not have support for run-time conditions, so the last\n+overload is therefore missing.\n+</p>\n+\n+\n+<h4 class=\"left\">Relevant namespaces</h4>\n+\n <p> One namespace contain versions of code that are explicitly sequential:\n <code>__gnu_serial</code>.\n </p>\n \n-<p> Parallel implementations of the sequential standard components are\n-defined in <code>namespace std::__parallel</code>. For instance,\n-<code>std::transform</code> from &lt;algorithm&gt; has a parallel\n-counterpart in <code>std::__parallel::transform</code> from\n+<p> Two namespaces contain the parallel mode:\n+<code>std::__parallel</code> and <code>__gnu_parallel</code>. \n+</p>\n+\n+<p> Parallel implementations of standard components, including\n+template helpers to select parallelism, are defined in <code>namespace\n+std::__parallel</code>. For instance, <code>std::transform</code> from\n+&lt;algorithm&gt; has a parallel counterpart in\n+<code>std::__parallel::transform</code> from\n &lt;parallel/algorithm&gt;. In addition, these parallel\n implementatations are injected into <code>namespace\n-__gnu_parallel</code> with using declarations. \n+__gnu_parallel</code> with using declarations.\n </p>\n \n-<p> Support and infrastructure is in <code>namespace __gnu_parallel</code>.\n+<p> Support and general infrastructure is in <code>namespace\n+__gnu_parallel</code>.\n </p>\n \n <p> More information, and an organized index of types and functions"}, {"sha": "0e3047331213ddf84889dd74cea5cea313811a3c", "filename": "libstdc++-v3/include/bits/algorithmfwd.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -148,7 +148,15 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     fill_n(_OIter, _Size, const _Tp&);\n \n   // find\n-  // find_end\n+\n+  template<typename _FIter1, typename _FIter2>\n+    _FIter1\n+    find_end(_FIter1, _FIter1, _FIter2, _FIter2);\n+\n+  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>\n+    _FIter1\n+    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);\n+\n   // find_first_of\n   // find_if\n   // for_each\n@@ -389,14 +397,6 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_P)\n     _IIter \n     find(_IIter, _IIter, const _Tp&);\n \n-  template<typename _FIter1, typename _FIter2>\n-    _FIter1\n-    find_end(_FIter1, _FIter1, _FIter2, _FIter2);\n-\n-  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>\n-    _FIter1\n-    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);\n-\n   template<typename _FIter1, typename _FIter2>\n     _FIter1\n     find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);"}, {"sha": "71b7bff7395fd87a688dbb10b2216f1c39b1674e", "filename": "libstdc++-v3/include/parallel/algo.h", "status": "modified", "additions": 590, "deletions": 314, "changes": 904, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -71,23 +71,24 @@ namespace __parallel\n   // Sequential fallback\n   template<typename InputIterator, typename Function>\n   inline Function\n-  for_each(InputIterator begin, InputIterator end, Function f, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::for_each<InputIterator, Function>(begin, end, f);\n-  }\n+  for_each(InputIterator begin, InputIterator end, Function f, \n+\t   __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::for_each(begin, end, f); }\n \n   // Sequential fallback for input iterator case\n   template<typename InputIterator, typename Function, typename IteratorTag>\n   Function\n-  for_each_switch(InputIterator begin, InputIterator end, Function f, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n-  {\n-    return for_each<InputIterator, Function>(begin, end, f, __gnu_parallel::sequential_tag());\n-  }\n+  for_each_switch(InputIterator begin, InputIterator end, Function f, \n+\t\t  IteratorTag)\n+  { return for_each(begin, end, f, __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators\n   template<typename RandomAccessIterator, typename Function>\n   Function\n-  for_each_switch(RandomAccessIterator begin, RandomAccessIterator end, Function f, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  for_each_switch(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t  Function f, random_access_iterator_tag, \n+\t\t  __gnu_parallel::parallelism parallelism_tag\n+\t\t  = __gnu_parallel::parallel_balanced)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::for_each_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n@@ -96,26 +97,37 @@ namespace __parallel\n \treturn __gnu_parallel::for_each_template_random_access(begin, end, f, functionality, __gnu_parallel::dummy_reduct(), true, dummy, -1, parallelism_tag);\n       }\n     else\n-      return for_each<RandomAccessIterator, Function>(begin, end, f, __gnu_parallel::sequential_tag());\n+      return for_each(begin, end, f, __gnu_parallel::sequential_tag());\n   }\n \n   // Public interface\n   template<typename Iterator, typename Function>\n   inline Function\n-  for_each(Iterator begin, Iterator end, Function f, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  for_each(Iterator begin, Iterator end, Function f, \n+\t   __gnu_parallel::parallelism parallelism_tag)\n   {\n     typedef std::iterator_traits<Iterator> iterator_traits;\n     typedef typename iterator_traits::iterator_category iterator_category;\n+    return for_each_switch(begin, end, f, iterator_category(), \n+\t\t\t   parallelism_tag);\n+  }\n \n-    return for_each_switch(begin, end, f, iterator_category(), parallelism_tag);\n+  template<typename Iterator, typename Function>\n+  inline Function\n+  for_each(Iterator begin, Iterator end, Function f) \n+  {\n+    typedef std::iterator_traits<Iterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+    return for_each_switch(begin, end, f, iterator_category());\n   }\n \n \n   // Sequential fallback\n   template<typename InputIterator, typename T>\n   inline InputIterator\n-  find(InputIterator begin, InputIterator end, const T& val, __gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::find<InputIterator, T>(begin, end, val); }\n+  find(InputIterator begin, InputIterator end, const T& val, \n+       __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::find(begin, end, val); }\n \n   // Sequential fallback for input iterator case\n   template<typename InputIterator, typename T, typename IteratorTag>\n@@ -128,7 +140,8 @@ namespace __parallel\n   RandomAccessIterator\n   find_switch(RandomAccessIterator begin, RandomAccessIterator end, const T& val, random_access_iterator_tag)\n   {\n-    typedef typename iterator_traits<RandomAccessIterator>::value_type value_type;\n+    typedef iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n \n     if (_GLIBCXX_PARALLEL_CONDITION(true))\n       {\n@@ -152,26 +165,26 @@ namespace __parallel\n   // Sequential fallback\n   template<typename InputIterator, typename Predicate>\n   inline InputIterator\n-  find_if(InputIterator begin, InputIterator end, Predicate pred, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::find_if<InputIterator, Predicate>(begin, end, pred);\n-  }\n+  find_if(InputIterator begin, InputIterator end, Predicate pred, \n+\t  __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::find_if(begin, end, pred); }\n \n   // Sequential fallback for input iterator case\n   template<typename InputIterator, typename Predicate, typename IteratorTag>\n   inline InputIterator\n-  find_if_switch(InputIterator begin, InputIterator end, Predicate pred, IteratorTag)\n-  {\n-    return _GLIBCXX_STD_P::find_if(begin, end, pred);\n-  }\n+  find_if_switch(InputIterator begin, InputIterator end, Predicate pred, \n+\t\t IteratorTag)\n+  { return _GLIBCXX_STD_P::find_if(begin, end, pred); }\n \n   // Parallel find_if for random access iterators\n   template<typename RandomAccessIterator, typename Predicate>\n   RandomAccessIterator\n-  find_if_switch(RandomAccessIterator begin, RandomAccessIterator end, Predicate pred, random_access_iterator_tag)\n+  find_if_switch(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t Predicate pred, random_access_iterator_tag)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(true))\n-      return __gnu_parallel::find_template(begin, end, begin, pred, __gnu_parallel::find_if_selector()).first;\n+      return __gnu_parallel::find_template(begin, end, begin, pred, \n+\t\t\t\t   __gnu_parallel::find_if_selector()).first;\n     else\n       return _GLIBCXX_STD_P::find_if(begin, end, pred);\n   }\n@@ -189,10 +202,10 @@ namespace __parallel\n   // Sequential fallback\n   template<typename InputIterator, typename ForwardIterator>\n   inline InputIterator\n-  find_first_of(InputIterator begin1, InputIterator end1, ForwardIterator begin2, ForwardIterator end2, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::find_first_of(begin1, end1, begin2, end2);\n-  }\n+  find_first_of(InputIterator begin1, InputIterator end1, \n+\t\tForwardIterator begin2, ForwardIterator end2, \n+\t\t__gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::find_first_of(begin1, end1, begin2, end2); }\n \n   // Sequential fallback\n   template<typename InputIterator, typename ForwardIterator,\n@@ -201,24 +214,26 @@ namespace __parallel\n   find_first_of(InputIterator begin1, InputIterator end1,\n \t\tForwardIterator begin2, ForwardIterator end2,\n \t\tBinaryPredicate comp, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::find_first_of(begin1, end1, begin2, end2, comp);\n-  }\n+  { return _GLIBCXX_STD_P::find_first_of(begin1, end1, begin2, end2, comp); }\n \n   // Sequential fallback for input iterator type\n   template<typename InputIterator, typename ForwardIterator, typename IteratorTag1, typename IteratorTag2>\n   inline InputIterator\n   find_first_of_switch(InputIterator begin1, InputIterator end1,\n-\t\t       ForwardIterator begin2, ForwardIterator end2, IteratorTag1, IteratorTag2)\n+\t\t       ForwardIterator begin2, ForwardIterator end2, \n+\t\t       IteratorTag1, IteratorTag2)\n   {\n-    return find_first_of(begin1, end1, begin2, end2, __gnu_parallel::sequential_tag());\n+    return find_first_of(begin1, end1, begin2, end2, \n+\t\t\t __gnu_parallel::sequential_tag());\n   }\n \n   // Parallel algorithm for random access iterators\n   template<typename RandomAccessIterator, typename ForwardIterator, typename BinaryPredicate, typename IteratorTag>\n   inline RandomAccessIterator\n   find_first_of_switch(RandomAccessIterator begin1, RandomAccessIterator end1,\n-\t\t       ForwardIterator begin2, ForwardIterator end2, BinaryPredicate comp, random_access_iterator_tag, IteratorTag)\n+\t\t       ForwardIterator begin2, ForwardIterator end2, \n+\t\t       BinaryPredicate comp, random_access_iterator_tag, \n+\t\t       IteratorTag)\n   {\n     return __gnu_parallel::find_template(begin1, end1, begin1, comp, __gnu_parallel::find_first_of_selector<ForwardIterator>(begin2, end2)).first;\n   }\n@@ -228,70 +243,72 @@ namespace __parallel\n   inline\n   InputIterator\n   find_first_of_switch(InputIterator begin1, InputIterator end1,\n-\t\t       ForwardIterator begin2, ForwardIterator end2, BinaryPredicate comp, IteratorTag1, IteratorTag2)\n+\t\t       ForwardIterator begin2, ForwardIterator end2, \n+\t\t       BinaryPredicate comp, IteratorTag1, IteratorTag2)\n   {\n-    return find_first_of(begin1, end1, begin2, end2, comp, __gnu_parallel::sequential_tag());\n+    return find_first_of(begin1, end1, begin2, end2, comp, \n+\t\t\t __gnu_parallel::sequential_tag());\n   }\n \n   // Public interface\n   template<typename InputIterator, typename ForwardIterator, typename BinaryPredicate>\n   inline InputIterator\n   find_first_of(InputIterator begin1, InputIterator end1,\n-\t\tForwardIterator begin2, ForwardIterator end2, BinaryPredicate comp)\n+\t\tForwardIterator begin2, ForwardIterator end2, \n+\t\tBinaryPredicate comp)\n   {\n     typedef std::iterator_traits<InputIterator> iteratori_traits;\n     typedef std::iterator_traits<ForwardIterator> iteratorf_traits;\n     typedef typename iteratori_traits::iterator_category iteratori_category;\n     typedef typename iteratorf_traits::iterator_category iteratorf_category;\n \n-    return find_first_of_switch(begin1, end1, begin2, end2, comp, iteratori_category(), iteratorf_category());\n+    return find_first_of_switch(begin1, end1, begin2, end2, comp, \n+\t\t\t\titeratori_category(), iteratorf_category());\n   }\n \n   // Public interface, insert default comparator\n   template<typename InputIterator, typename ForwardIterator>\n   InputIterator\n-  find_first_of(InputIterator begin1, InputIterator end1, ForwardIterator begin2, ForwardIterator end2)\n+  find_first_of(InputIterator begin1, InputIterator end1, \n+\t\tForwardIterator begin2, ForwardIterator end2)\n   {\n     typedef std::iterator_traits<InputIterator> iteratori_traits;\n     typedef std::iterator_traits<ForwardIterator> iteratorf_traits;\n     typedef typename iteratori_traits::value_type valuei_type;\n     typedef typename iteratorf_traits::value_type valuef_type;\n \n-    return find_first_of(begin1, end1, begin2, end2, __gnu_parallel::equal_to<valuei_type, valuef_type>());\n+    return find_first_of(begin1, end1, begin2, end2, \n+\t\t\t __gnu_parallel::equal_to<valuei_type, valuef_type>());\n   }\n \n   // Sequential fallback\n   template<typename InputIterator, typename OutputIterator>\n   inline OutputIterator\n   unique_copy(InputIterator begin1, InputIterator end1, OutputIterator out,\n \t      __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::unique_copy<InputIterator, OutputIterator>(begin1, end1, out);\n-  }\n+  { return _GLIBCXX_STD_P::unique_copy(begin1, end1, out); }\n \n   // Sequential fallback\n   template<typename InputIterator, typename OutputIterator, typename Predicate>\n   inline OutputIterator\n   unique_copy(InputIterator begin1, InputIterator end1, OutputIterator out,\n \t      Predicate pred, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::unique_copy<InputIterator, OutputIterator, Predicate>(begin1, end1, out, pred);\n-  }\n+  { return _GLIBCXX_STD_P::unique_copy(begin1, end1, out, pred); }\n \n   // Sequential fallback for input iterator case\n   template<typename InputIterator, typename OutputIterator, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n   inline OutputIterator\n-  unique_copy_switch(InputIterator begin, InputIterator last, OutputIterator out,\n-\t\t     Predicate pred, IteratorTag1, IteratorTag2)\n-  {\n-    return _GLIBCXX_STD_P::unique_copy(begin, last, out, pred);\n-  }\n+  unique_copy_switch(InputIterator begin, InputIterator last, \n+\t\t     OutputIterator out, Predicate pred, \n+\t\t     IteratorTag1, IteratorTag2)\n+  { return _GLIBCXX_STD_P::unique_copy(begin, last, out, pred); }\n \n   // Parallel unique_copy for random access iterators\n   template<typename RandomAccessIterator, typename RandomAccessOutputIterator, typename Predicate>\n   RandomAccessOutputIterator\n-  unique_copy_switch(RandomAccessIterator begin, RandomAccessIterator last, RandomAccessOutputIterator out,\n-\t\t     Predicate pred, random_access_iterator_tag, random_access_iterator_tag)\n+  unique_copy_switch(RandomAccessIterator begin, RandomAccessIterator last, \n+\t\t     RandomAccessOutputIterator out, Predicate pred, \n+\t\t     random_access_iterator_tag, random_access_iterator_tag)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(last - begin) > __gnu_parallel::Settings::unique_copy_minimal_n))\n       return __gnu_parallel::parallel_unique_copy(begin, last, out, pred);\n@@ -325,7 +342,8 @@ namespace __parallel\n     typedef typename iteratori_traits::iterator_category iteratori_category;\n     typedef typename iteratoro_traits::iterator_category iteratoro_category;\n \n-    return unique_copy_switch(begin1, end1, out, pred, iteratori_category(), iteratoro_category());\n+    return unique_copy_switch(begin1, end1, out, pred, iteratori_category(), \n+\t\t\t      iteratoro_category());\n   }\n \n   // Sequential fallback\n@@ -334,26 +352,23 @@ namespace __parallel\n   set_union(InputIterator1 begin1, InputIterator1 end1,\n \t    InputIterator2 begin2, InputIterator2 end2,\n \t    OutputIterator out, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::set_union(begin1, end1, begin2, end2, out);\n-  }\n+  { return _GLIBCXX_STD_P::set_union(begin1, end1, begin2, end2, out); }\n \n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n   inline OutputIterator\n   set_union(InputIterator1 begin1, InputIterator1 end1,\n \t    InputIterator2 begin2, InputIterator2 end2,\n \t    OutputIterator out, Predicate pred, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::set_union(begin1, end1, begin2, end2, out, pred);\n-  }\n+  { return _GLIBCXX_STD_P::set_union(begin1, end1, begin2, end2, out, pred); }\n \n   // Sequential fallback for input iterator case\n   template<typename InputIterator1, typename InputIterator2, typename Predicate,\n \t   typename OutputIterator, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n   inline OutputIterator \n-  set_union_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n-\t\t   InputIterator2 end2, OutputIterator result, Predicate pred, IteratorTag1,\n+  set_union_switch(InputIterator1 begin1, InputIterator1 end1, \n+\t\t   InputIterator2 begin2, InputIterator2 end2, \n+\t\t   OutputIterator result, Predicate pred, IteratorTag1,\n \t\t   IteratorTag2, IteratorTag3)\n   {\n     return _GLIBCXX_STD_P::set_union(begin1, end1, begin2, end2, result, pred);\n@@ -363,9 +378,11 @@ namespace __parallel\n   template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n \t   typename OutputRandomAccessIterator, typename Predicate>\n   OutputRandomAccessIterator \n-  set_union_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2,\n-\t\t   RandomAccessIterator2 end2, OutputRandomAccessIterator result, Predicate pred,\n-\t\t   random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n+  set_union_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, \n+\t\t   RandomAccessIterator2 begin2, RandomAccessIterator2 end2, \n+\t\t   OutputRandomAccessIterator result, Predicate pred,\n+\t\t   random_access_iterator_tag, random_access_iterator_tag, \n+\t\t   random_access_iterator_tag)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1) >= __gnu_parallel::Settings::set_union_minimal_n || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2) >= __gnu_parallel::Settings::set_union_minimal_n))\n       return __gnu_parallel::parallel_set_union(begin1, end1, begin2, end2, result, pred);\n@@ -376,7 +393,8 @@ namespace __parallel\n   // Public interface\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n   inline OutputIterator \n-  set_union(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out)\n+  set_union(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t    InputIterator2 end2, OutputIterator out)\n   {\n     typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n     typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n@@ -387,8 +405,10 @@ namespace __parallel\n     typedef typename iteratori1_traits::value_type value1_type;\n     typedef typename iteratori2_traits::value_type value2_type;\n \n-    return set_union_switch(begin1, end1, begin2, end2, out, __gnu_parallel::less<value1_type, value2_type>(),\n-\t\t\t    iteratori1_category(), iteratori2_category(), iteratoro_category());\n+    return set_union_switch(begin1, end1, begin2, end2, out, \n+\t\t\t    __gnu_parallel::less<value1_type, value2_type>(), \n+\t\t\t    iteratori1_category(), iteratori2_category(), \n+\t\t\t    iteratoro_category());\n   }\n \n   // Public interface\n@@ -405,7 +425,8 @@ namespace __parallel\n     typedef typename iteratoro_traits::iterator_category iteratoro_category;\n \n     return set_union_switch(begin1, end1, begin2, end2, out, pred,\n-\t\t\t    iteratori1_category(), iteratori2_category(), iteratoro_category());\n+\t\t\t    iteratori1_category(), iteratori2_category(), \n+\t\t\t    iteratoro_category());\n   }\n \n   // Sequential fallback.\n@@ -423,40 +444,46 @@ namespace __parallel\n   inline OutputIterator\n   set_intersection(InputIterator1 begin1, InputIterator1 end1,\n \t\t   InputIterator2 begin2, InputIterator2 end2,\n-\t\t   OutputIterator out, Predicate pred, __gnu_parallel::sequential_tag)\n+\t\t   OutputIterator out, Predicate pred, \n+\t\t   __gnu_parallel::sequential_tag)\n   {\n-    return _GLIBCXX_STD_P::set_intersection(begin1, end1, begin2, end2, out, pred);\n+    return _GLIBCXX_STD_P::set_intersection(begin1, end1, begin2, end2, \n+\t\t\t\t\t    out, pred);\n   }\n \n   // Sequential fallback for input iterator case\n   template<typename InputIterator1, typename InputIterator2, typename Predicate,\n \t   typename OutputIterator, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n   inline OutputIterator \n-  set_intersection_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n-\t\t\t  InputIterator2 end2, OutputIterator result, Predicate pred, IteratorTag1,\n-\t\t\t  IteratorTag2, IteratorTag3)\n+  set_intersection_switch(InputIterator1 begin1, InputIterator1 end1, \n+\t\t\t  InputIterator2 begin2, InputIterator2 end2, \n+\t\t\t  OutputIterator result, Predicate pred, \n+\t\t\t  IteratorTag1, IteratorTag2, IteratorTag3)\n   {\n-    return _GLIBCXX_STD_P::set_intersection(begin1, end1, begin2, end2, result, pred);\n+    return _GLIBCXX_STD_P::set_intersection(begin1, end1, begin2, \n+\t\t\t\t\t    end2, result, pred);\n   }\n \n   // Parallel set_intersection for random access iterators\n   template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n \t   typename OutputRandomAccessIterator, typename Predicate>\n   OutputRandomAccessIterator \n-  set_intersection_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2,\n-\t\t\t  RandomAccessIterator2 end2, OutputRandomAccessIterator result, Predicate pred,\n-\t\t\t  random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n+  set_intersection_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator2 end2, OutputRandomAccessIterator result, Predicate pred, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1) >= __gnu_parallel::Settings::set_union_minimal_n || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2) >= __gnu_parallel::Settings::set_union_minimal_n))\n-      return __gnu_parallel::parallel_set_intersection(begin1, end1, begin2, end2, result, pred);\n+      return __gnu_parallel::parallel_set_intersection(begin1, end1, begin2, \n+\t\t\t\t\t\t       end2, result, pred);\n     else\n-      return _GLIBCXX_STD_P::set_intersection(begin1, end1, begin2, end2, result, pred);\n+      return _GLIBCXX_STD_P::set_intersection(begin1, end1, begin2, \n+\t\t\t\t\t      end2, result, pred);\n   }\n \n   // Public interface\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n   inline OutputIterator \n-  set_intersection(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out)\n+  set_intersection(InputIterator1 begin1, InputIterator1 end1, \n+\t\t   InputIterator2 begin2, InputIterator2 end2, \n+\t\t   OutputIterator out)\n   {\n     typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n     typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n@@ -467,8 +494,10 @@ namespace __parallel\n     typedef typename iteratori1_traits::value_type value1_type;\n     typedef typename iteratori2_traits::value_type value2_type;\n \n-    return set_intersection_switch(begin1, end1, begin2, end2, out, __gnu_parallel::less<value1_type, value2_type>(),\n-\t\t\t\t   iteratori1_category(), iteratori2_category(), iteratoro_category());\n+    return set_intersection_switch(begin1, end1, begin2, end2, out, \n+\t\t\t     __gnu_parallel::less<value1_type, value2_type>(),\n+\t\t       \t   iteratori1_category(), iteratori2_category(), \n+\t\t\t\t   iteratoro_category());\n   }\n \n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n@@ -484,7 +513,8 @@ namespace __parallel\n     typedef typename iteratoro_traits::iterator_category iteratoro_category;\n \n     return set_intersection_switch(begin1, end1, begin2, end2, out, pred,\n-\t\t\t\t   iteratori1_category(), iteratori2_category(), iteratoro_category());\n+\t\t\t          iteratori1_category(), iteratori2_category(),\n+\t\t\t\t   iteratoro_category());\n   }\n \n   // Sequential fallback\n@@ -495,7 +525,8 @@ namespace __parallel\n \t\t\t   InputIterator2 begin2, InputIterator2 end2,\n \t\t\t   OutputIterator out, __gnu_parallel::sequential_tag)\n   {\n-    return _GLIBCXX_STD_P::set_symmetric_difference(begin1,end1, begin2, end2, out);\n+    return _GLIBCXX_STD_P::set_symmetric_difference(begin1,end1, begin2, \n+\t\t\t\t\t\t    end2, out);\n   }\n \n   // Sequential fallback\n@@ -506,25 +537,24 @@ namespace __parallel\n \t\t\t   InputIterator2 begin2, InputIterator2 end2,\n \t\t\t   OutputIterator out, Predicate pred, __gnu_parallel::sequential_tag)\n   {\n-    return _GLIBCXX_STD_P::set_symmetric_difference(begin1, end1, begin2, end2, out, pred);\n+    return _GLIBCXX_STD_P::set_symmetric_difference(begin1, end1, begin2, \n+\t\t\t\t\t\t    end2, out, pred);\n   }\n \n   // Sequential fallback for input iterator case\n   template<typename InputIterator1, typename InputIterator2, typename Predicate, typename OutputIterator, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n   inline OutputIterator \n   set_symmetric_difference_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result, Predicate pred, IteratorTag1, IteratorTag2, IteratorTag3)\n   {\n-    return _GLIBCXX_STD_P::set_symmetric_difference(begin1, end1, begin2, end2, result, pred);\n+    return _GLIBCXX_STD_P::set_symmetric_difference(begin1, end1, begin2, end2,\n+\t\t\t\t\t\t    result, pred);\n   }\n \n   // Parallel set_symmetric_difference for random access iterators\n   template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n \t   typename OutputRandomAccessIterator, typename Predicate>\n   OutputRandomAccessIterator \n-  set_symmetric_difference_switch(RandomAccessIterator1 begin1,\n-\t\t\t\t  RandomAccessIterator1 end1, RandomAccessIterator2 begin2,\n-\t\t\t\t  RandomAccessIterator2 end2, OutputRandomAccessIterator result, Predicate pred,\n-\t\t\t\t  random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n+  set_symmetric_difference_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator2 end2, OutputRandomAccessIterator result, Predicate pred, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1) >= __gnu_parallel::Settings::set_symmetric_difference_minimal_n || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2) >= __gnu_parallel::Settings::set_symmetric_difference_minimal_n))\n       return __gnu_parallel::parallel_set_symmetric_difference(begin1, end1, begin2, end2, result, pred);\n@@ -546,15 +576,16 @@ namespace __parallel\n     typedef typename iteratori1_traits::value_type value1_type;\n     typedef typename iteratori2_traits::value_type value2_type;\n \n-    return set_symmetric_difference_switch(begin1, end1, begin2, end2, out, __gnu_parallel::less<value1_type, value2_type>(),\n-\t\t\t\t\t   iteratori1_category(), iteratori2_category(), iteratoro_category());\n+    return set_symmetric_difference_switch(begin1, end1, begin2, end2, out, \n+\t\t\t      __gnu_parallel::less<value1_type, value2_type>(),\n+\t\t\t\t  iteratori1_category(), iteratori2_category(),\n+\t\t\t\t\t   iteratoro_category());\n   }\n \n   // Public interface.\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n   inline OutputIterator \n-  set_symmetric_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n-\t\t\t   InputIterator2 end2, OutputIterator out, Predicate pred)\n+  set_symmetric_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out, Predicate pred)\n   {\n     typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n     typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n@@ -563,22 +594,26 @@ namespace __parallel\n     typedef typename iteratori2_traits::iterator_category iteratori2_category;\n     typedef typename iteratoro_traits::iterator_category iteratoro_category;\n \n-   return set_symmetric_difference_switch(begin1, end1, begin2, end2, out, pred,\n-\t\t\t\t\t  iteratori1_category(), iteratori2_category(), iteratoro_category());\n+   return set_symmetric_difference_switch(begin1, end1, begin2, end2, out,\n+\t\t\t\t\t  pred, iteratori1_category(), \n+\t\t\t\t  iteratori2_category(), iteratoro_category());\n   }\n \n   // Sequential fallback.\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n   inline OutputIterator\n-  set_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::set_difference(begin1,end1, begin2, end2, out);\n-  }\n+  set_difference(InputIterator1 begin1, InputIterator1 end1, \n+\t\t InputIterator2 begin2, InputIterator2 end2, \n+\t\t OutputIterator out, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::set_difference(begin1,end1, begin2, end2, out); }\n \n   // Sequential fallback.\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n   inline OutputIterator\n-  set_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out, Predicate pred, __gnu_parallel::sequential_tag)\n+  set_difference(InputIterator1 begin1, InputIterator1 end1, \n+\t\t InputIterator2 begin2, InputIterator2 end2, \n+\t\t OutputIterator out, Predicate pred, \n+\t\t __gnu_parallel::sequential_tag)\n   {\n     return _GLIBCXX_STD_P::set_difference(begin1, end1, begin2, end2, out, pred);\n   }\n@@ -587,8 +622,10 @@ namespace __parallel\n   template<typename InputIterator1, typename InputIterator2, typename Predicate,\n \t   typename OutputIterator, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n   inline OutputIterator\n-  set_difference_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n-\t\t\tInputIterator2 end2, OutputIterator result, Predicate pred, IteratorTag1, IteratorTag2, IteratorTag3)\n+  set_difference_switch(InputIterator1 begin1, InputIterator1 end1, \n+\t\t\tInputIterator2 begin2, InputIterator2 end2, \n+\t\t\tOutputIterator result, Predicate pred, \n+\t\t\tIteratorTag1, IteratorTag2, IteratorTag3)\n   {\n     return _GLIBCXX_STD_P::set_difference(begin1, end1, begin2, end2, result, pred);\n   }\n@@ -597,9 +634,7 @@ namespace __parallel\n   template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n \t   typename OutputRandomAccessIterator, typename Predicate>\n   OutputRandomAccessIterator\n-  set_difference_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2,\n-\t\t\tRandomAccessIterator2 end2, OutputRandomAccessIterator result, Predicate pred,\n-\t\t\trandom_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n+  set_difference_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator2 end2, OutputRandomAccessIterator result, Predicate pred, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1) >= __gnu_parallel::Settings::set_difference_minimal_n || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2) >= __gnu_parallel::Settings::set_difference_minimal_n))\n       return __gnu_parallel::parallel_set_difference(begin1, end1, begin2, end2, result, pred);\n@@ -610,7 +645,9 @@ namespace __parallel\n   // Public interface\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n   inline OutputIterator\n-  set_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out)\n+  set_difference(InputIterator1 begin1, InputIterator1 end1, \n+\t\t InputIterator2 begin2, InputIterator2 end2, \n+\t\t OutputIterator out)\n   {\n     typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n     typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n@@ -621,15 +658,18 @@ namespace __parallel\n     typedef typename iteratori1_traits::value_type value1_type;\n     typedef typename iteratori2_traits::value_type value2_type;\n \n-    return set_difference_switch(begin1, end1, begin2, end2, out, __gnu_parallel::less<value1_type, value2_type>(),\n-\t\t\t\t iteratori1_category(), iteratori2_category(), iteratoro_category());\n+    return set_difference_switch(begin1, end1, begin2, end2, out, \n+\t\t\t    __gnu_parallel::less<value1_type, value2_type>(), \n+\t\t\t\t iteratori1_category(), iteratori2_category(), \n+\t\t\t\t iteratoro_category());\n   }\n \n   // Public interface\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n   inline OutputIterator\n-  set_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n-\t\t InputIterator2 end2, OutputIterator out, Predicate pred)\n+  set_difference(InputIterator1 begin1, InputIterator1 end1, \n+\t\t InputIterator2 begin2, InputIterator2 end2, \n+\t\t OutputIterator out, Predicate pred)\n   {\n     typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n     typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n@@ -639,31 +679,32 @@ namespace __parallel\n     typedef typename iteratoro_traits::iterator_category iteratoro_category;\n \n     return set_difference_switch(begin1, end1, begin2, end2, out, pred,\n-\t\t\t\t iteratori1_category(), iteratori2_category(), iteratoro_category());\n+\t\t\t\t iteratori1_category(), iteratori2_category(), \n+\t\t\t\t iteratoro_category());\n   }\n \n   // Sequential fallback\n   template<typename ForwardIterator>\n   inline ForwardIterator\n-  adjacent_find(ForwardIterator begin, ForwardIterator end, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::adjacent_find<ForwardIterator>(begin, end);\n-  }\n+  adjacent_find(ForwardIterator begin, ForwardIterator end, \n+\t\t__gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::adjacent_find(begin, end); }\n \n   // Sequential fallback\n   template<typename ForwardIterator, typename BinaryPredicate>\n   inline ForwardIterator\n-  adjacent_find(ForwardIterator begin, ForwardIterator end, BinaryPredicate binary_pred, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::adjacent_find<ForwardIterator, BinaryPredicate>(begin, end, binary_pred);\n-  }\n+  adjacent_find(ForwardIterator begin, ForwardIterator end, \n+\t\tBinaryPredicate binary_pred, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::adjacent_find(begin, end, binary_pred); }\n \n   // Parallel algorithm for random access iterators\n   template<typename RandomAccessIterator>\n   RandomAccessIterator\n-  adjacent_find_switch(RandomAccessIterator begin, RandomAccessIterator end, random_access_iterator_tag)\n+  adjacent_find_switch(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t       random_access_iterator_tag)\n   {\n-    typedef typename iterator_traits<RandomAccessIterator>::value_type value_type;\n+    typedef iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n \n     if (_GLIBCXX_PARALLEL_CONDITION(true))\n       {\n@@ -674,138 +715,173 @@ namespace __parallel\n \t  return spot;\n       }\n     else\n-      return adjacent_find<RandomAccessIterator>(begin, end, __gnu_parallel::sequential_tag());\n+      return adjacent_find(begin, end, __gnu_parallel::sequential_tag());\n   }\n \n   // Sequential fallback for input iterator case\n   template<typename ForwardIterator, typename IteratorTag>\n   inline ForwardIterator\n   adjacent_find_switch(ForwardIterator begin, ForwardIterator end, IteratorTag)\n-  {\n-    return adjacent_find<ForwardIterator>(begin, end, __gnu_parallel::sequential_tag());\n-  }\n+  { return adjacent_find(begin, end, __gnu_parallel::sequential_tag()); }\n \n   // Public interface\n   template<typename ForwardIterator>\n   inline ForwardIterator\n   adjacent_find(ForwardIterator begin, ForwardIterator end)\n   {\n-    return adjacent_find_switch(begin, end, typename std::iterator_traits<ForwardIterator>::iterator_category());\n+    typedef iterator_traits<ForwardIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    return adjacent_find_switch(begin, end, iterator_category());\n   }\n \n   // Sequential fallback for input iterator case\n   template<typename ForwardIterator, typename BinaryPredicate, typename IteratorTag>\n   inline ForwardIterator\n-  adjacent_find_switch(ForwardIterator begin, ForwardIterator end, BinaryPredicate binary_pred, IteratorTag)\n-  {\n-    return adjacent_find<ForwardIterator, BinaryPredicate>(begin, end, binary_pred, __gnu_parallel::sequential_tag());\n-  }\n+  adjacent_find_switch(ForwardIterator begin, ForwardIterator end, \n+\t\t       BinaryPredicate pred, IteratorTag)\n+  { return adjacent_find(begin, end, pred, __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators\n   template<typename RandomAccessIterator, typename BinaryPredicate>\n   RandomAccessIterator\n-  adjacent_find_switch(RandomAccessIterator begin, RandomAccessIterator end, BinaryPredicate binary_pred, random_access_iterator_tag)\n+  adjacent_find_switch(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t       BinaryPredicate pred, random_access_iterator_tag)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(true))\n-      return __gnu_parallel::find_template(begin, end, begin, binary_pred, __gnu_parallel::adjacent_find_selector()).first;\n+      return __gnu_parallel::find_template(begin, end, begin, pred, \n+\t\t\t      __gnu_parallel::adjacent_find_selector()).first;\n     else\n-      return adjacent_find(begin, end, binary_pred, __gnu_parallel::sequential_tag());\n+      return adjacent_find(begin, end, pred, __gnu_parallel::sequential_tag());\n   }\n \n   // Public interface\n   template<typename ForwardIterator, typename BinaryPredicate>\n   inline ForwardIterator\n-  adjacent_find(ForwardIterator begin, ForwardIterator end, BinaryPredicate binary_pred)\n+  adjacent_find(ForwardIterator begin, ForwardIterator end, \n+\t\tBinaryPredicate pred)\n   {\n-    return adjacent_find_switch<ForwardIterator, BinaryPredicate>(begin, end, binary_pred, typename std::iterator_traits<ForwardIterator>::iterator_category());\n+    typedef iterator_traits<ForwardIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    return adjacent_find_switch(begin, end, pred, iterator_category());\n   }\n \n   // Sequential fallback\n   template<typename InputIterator, typename T>\n   inline typename iterator_traits<InputIterator>::difference_type\n-  count(InputIterator begin, InputIterator end, const T& value, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::count<InputIterator, T>(begin, end, value);\n-  }\n+  count(InputIterator begin, InputIterator end, const T& value, \n+\t__gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::count(begin, end, value); }\n \n   // Parallel code for random access iterators\n   template<typename RandomAccessIterator, typename T>\n   typename iterator_traits<RandomAccessIterator>::difference_type\n-  count_switch(RandomAccessIterator begin, RandomAccessIterator end, const T& value, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  count_switch(RandomAccessIterator begin, RandomAccessIterator end, \n+\t       const T& value, random_access_iterator_tag, \n+\t       __gnu_parallel::parallelism parallelism_tag \n+\t       = __gnu_parallel::parallel_unbalanced)\n   {\n-    typedef typename iterator_traits<RandomAccessIterator>::value_type value_type;\n-    typedef typename iterator_traits<RandomAccessIterator>::difference_type difference_type;\n+    typedef iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef __gnu_parallel::sequence_index_t sequence_index_t;\n \n-    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::count_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<sequence_index_t>(end - begin) >= __gnu_parallel::Settings::count_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n-\tdifference_type res = 0;\n \t__gnu_parallel::count_selector<RandomAccessIterator, difference_type> functionality;\n-\t__gnu_parallel::for_each_template_random_access(begin, end, value, functionality, std::plus<__gnu_parallel::sequence_index_t>(), res, res, -1, parallelism_tag);\n+\tdifference_type res = 0;\n+\t__gnu_parallel::for_each_template_random_access(begin, end, value, functionality, std::plus<sequence_index_t>(), res, res, -1, parallelism_tag);\n \treturn res;\n       }\n     else\n-      return count<RandomAccessIterator, T>(begin, end, value, __gnu_parallel::sequential_tag());\n+      return count(begin, end, value, __gnu_parallel::sequential_tag());\n   }\n \n   // Sequential fallback for input iterator case.\n   template<typename InputIterator, typename T, typename IteratorTag>\n   typename iterator_traits<InputIterator>::difference_type\n-  count_switch(InputIterator begin, InputIterator end, const T& value, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  count_switch(InputIterator begin, InputIterator end, const T& value, \n+\t       IteratorTag)\n+  { return count(begin, end, value, __gnu_parallel::sequential_tag()); }\n+\n+  // Public interface.\n+  template<typename InputIterator, typename T>\n+  inline typename iterator_traits<InputIterator>::difference_type\n+  count(InputIterator begin, InputIterator end, const T& value, \n+\t__gnu_parallel::parallelism parallelism_tag)\n   {\n-    return count<InputIterator, T>(begin, end, value, __gnu_parallel::sequential_tag());\n+    typedef iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    return count_switch(begin, end, value, iterator_category(), \n+\t\t\tparallelism_tag);\n   }\n \n-  // Public interface.\n   template<typename InputIterator, typename T>\n   inline typename iterator_traits<InputIterator>::difference_type\n-  count(InputIterator begin, InputIterator end, const T& value, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n+  count(InputIterator begin, InputIterator end, const T& value)\n   {\n-    return count_switch(begin, end, value, typename std::iterator_traits<InputIterator>::iterator_category(), parallelism_tag);\n+    typedef iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    return count_switch(begin, end, value, iterator_category());\n   }\n \n+\n   // Sequential fallback.\n   template<typename InputIterator, typename Predicate>\n   inline typename iterator_traits<InputIterator>::difference_type\n-  count_if(InputIterator begin, InputIterator end, Predicate pred, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::count_if(begin, end, pred);\n-  }\n+  count_if(InputIterator begin, InputIterator end, Predicate pred, \n+\t   __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::count_if(begin, end, pred); }\n \n   // Parallel count_if for random access iterators\n   template<typename RandomAccessIterator, typename Predicate>\n   typename iterator_traits<RandomAccessIterator>::difference_type\n-  count_if_switch(RandomAccessIterator begin, RandomAccessIterator end, Predicate pred, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  count_if_switch(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t  Predicate pred, random_access_iterator_tag, \n+\t\t  __gnu_parallel::parallelism parallelism_tag\n+\t\t  = __gnu_parallel::parallel_unbalanced)\n   {\n-    typedef typename iterator_traits<RandomAccessIterator>::value_type value_type;\n-    typedef typename iterator_traits<RandomAccessIterator>::difference_type difference_type;\n+    typedef iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef __gnu_parallel::sequence_index_t sequence_index_t;\n \n-    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::count_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<sequence_index_t>(end - begin) >= __gnu_parallel::Settings::count_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n \tdifference_type res = 0;\n \t__gnu_parallel::count_if_selector<RandomAccessIterator, difference_type> functionality;\n-\t__gnu_parallel::for_each_template_random_access(begin, end, pred, functionality, std::plus<__gnu_parallel::sequence_index_t>(), res, res, -1, parallelism_tag);\n+\t__gnu_parallel::for_each_template_random_access(begin, end, pred, functionality, std::plus<sequence_index_t>(), res, res, -1, parallelism_tag);\n \treturn res;\n       }\n     else\n-      return count_if<RandomAccessIterator, Predicate>(begin, end, pred, __gnu_parallel::sequential_tag());\n+      return count_if(begin, end, pred, __gnu_parallel::sequential_tag());\n   }\n \n   // Sequential fallback for input iterator case.\n   template<typename InputIterator, typename Predicate, typename IteratorTag>\n   typename iterator_traits<InputIterator>::difference_type\n-  count_if_switch(InputIterator begin, InputIterator end, Predicate pred, IteratorTag, __gnu_parallel::parallelism)\n+  count_if_switch(InputIterator begin, InputIterator end, Predicate pred, \n+\t\t  IteratorTag)\n+  { return count_if(begin, end, pred, __gnu_parallel::sequential_tag()); }\n+\n+  // Public interface.\n+  template<typename InputIterator, typename Predicate>\n+  inline typename iterator_traits<InputIterator>::difference_type\n+  count_if(InputIterator begin, InputIterator end, Predicate pred, \n+\t   __gnu_parallel::parallelism parallelism_tag)\n   {\n-    return count_if<InputIterator, Predicate>(begin, end, pred, __gnu_parallel::sequential_tag());\n+    typedef iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    return count_if_switch(begin, end, pred, iterator_category(), \n+\t\t\t   parallelism_tag);\n   }\n \n-  // Public interface.\n   template<typename InputIterator, typename Predicate>\n   inline typename iterator_traits<InputIterator>::difference_type\n-  count_if(InputIterator begin, InputIterator end, Predicate pred, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n+  count_if(InputIterator begin, InputIterator end, Predicate pred)\n   {\n     typedef iterator_traits<InputIterator> traits_type;\n     typedef typename traits_type::iterator_category iterator_category;\n-    return count_if_switch(begin, end, pred, iterator_category(), parallelism_tag);\n+    return count_if_switch(begin, end, pred, iterator_category());\n   }\n \n \n@@ -950,53 +1026,88 @@ namespace __parallel\n     return search_n_switch(begin, end, count, val, binary_pred, typename std::iterator_traits<ForwardIterator>::iterator_category());\n   }\n \n+\n   // Sequential fallback.\n   template<typename InputIterator, typename OutputIterator, typename UnaryOperation>\n   inline OutputIterator\n-  transform(InputIterator begin, InputIterator end, OutputIterator result, UnaryOperation unary_op, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::transform(begin, end, result, unary_op);\n-  }\n-\n-  // Sequential fallback\n-  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryOperation>\n-  inline OutputIterator\n-  transform(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, OutputIterator result, BinaryOperation binary_op, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::transform(begin1, end1, begin2, result, binary_op);\n-  }\n+  transform(InputIterator begin, InputIterator end, OutputIterator result, \n+\t    UnaryOperation unary_op, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::transform(begin, end, result, unary_op); }\n \n   // Parallel unary transform for random access iterators.\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator3, typename UnaryOperation>\n-  RandomAccessIterator3\n-  transform1_switch(RandomAccessIterator1 begin, RandomAccessIterator1 end, RandomAccessIterator3 result, UnaryOperation unary_op, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename UnaryOperation>\n+  RandomAccessIterator2\n+  transform1_switch(RandomAccessIterator1 begin, RandomAccessIterator1 end, RandomAccessIterator2 result, UnaryOperation unary_op, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::transform_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n \tbool dummy = true;\n-\ttypedef __gnu_parallel::iterator_pair<RandomAccessIterator1, RandomAccessIterator3, random_access_iterator_tag> ip;\n+\ttypedef __gnu_parallel::iterator_pair<RandomAccessIterator1, RandomAccessIterator2, random_access_iterator_tag> ip;\n \tip begin_pair(begin, result), end_pair(end, result + (end - begin));\n \t__gnu_parallel::transform1_selector<ip> functionality;\n \t__gnu_parallel::for_each_template_random_access(begin_pair, end_pair, unary_op, functionality, __gnu_parallel::dummy_reduct(), dummy, dummy, -1, parallelism_tag);\n \treturn functionality.finish_iterator;\n       }\n     else\n-      return transform(begin, end, result, unary_op, __gnu_parallel::sequential_tag());\n+      return transform(begin, end, result, unary_op, \n+\t\t       __gnu_parallel::sequential_tag());\n   }\n \n   // Sequential fallback for input iterator case.\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator3, typename UnaryOperation, typename IteratorTag1, typename IteratorTag2>\n-  inline RandomAccessIterator3\n-  transform1_switch(RandomAccessIterator1 begin, RandomAccessIterator1 end, RandomAccessIterator3 result, UnaryOperation unary_op, IteratorTag1, IteratorTag2, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename UnaryOperation, typename IteratorTag1, typename IteratorTag2>\n+  inline RandomAccessIterator2\n+  transform1_switch(RandomAccessIterator1 begin, RandomAccessIterator1 end, RandomAccessIterator2 result, UnaryOperation unary_op, IteratorTag1, IteratorTag2)\n+  { \n+    return transform(begin, end, result, unary_op, \n+\t\t     __gnu_parallel::sequential_tag()); \n+  }\n+\n+  // Public interface.\n+  template<typename InputIterator, typename OutputIterator, typename UnaryOperation>\n+  inline OutputIterator\n+  transform(InputIterator begin, InputIterator end, OutputIterator result,\n+\t    UnaryOperation unary_op, \n+\t    __gnu_parallel::parallelism parallelism_tag)\n   {\n-    return _GLIBCXX_STD_P::transform(begin, end, result, unary_op);\n+    typedef std::iterator_traits<InputIterator> iteratori_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori_traits::iterator_category iteratori_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+\n+    return transform1_switch(begin, end, result, unary_op,\n+\t\t\t     iteratori_category(), iteratoro_category(), \n+\t\t\t     parallelism_tag);\n+  }\n+\n+  template<typename InputIterator, typename OutputIterator, typename UnaryOperation>\n+  inline OutputIterator\n+  transform(InputIterator begin, InputIterator end, OutputIterator result,\n+\t    UnaryOperation unary_op)\n+  {\n+    typedef std::iterator_traits<InputIterator> iteratori_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori_traits::iterator_category iteratori_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+\n+    return transform1_switch(begin, end, result, unary_op,\n+\t\t\t     iteratori_category(), iteratoro_category());\n   }\n \n \n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryOperation>\n+  inline OutputIterator\n+  transform(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t    OutputIterator result, BinaryOperation binary_op, \n+\t    __gnu_parallel::sequential_tag)\n+  { \n+    return _GLIBCXX_STD_P::transform(begin1, end1, begin2, result, binary_op); \n+  }\n+\n   // Parallel binary transform for random access iterators.\n   template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename RandomAccessIterator3, typename BinaryOperation>\n   RandomAccessIterator3\n-  transform2_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator3 result, BinaryOperation binary_op, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  transform2_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator3 result, BinaryOperation binary_op, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION((end1 - begin1) >= __gnu_parallel::Settings::transform_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n@@ -1008,36 +1119,44 @@ namespace __parallel\n \treturn functionality.finish_iterator;\n       }\n     else\n-      return transform(begin1, end1, begin2, result, binary_op, __gnu_parallel::sequential_tag());\n+      return transform(begin1, end1, begin2, result, binary_op, \n+\t\t       __gnu_parallel::sequential_tag());\n   }\n \n   // Sequential fallback for input iterator case.\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename RandomAccessIterator3, typename BinaryOperation, typename tag1, typename tag2, typename tag3>\n-  inline RandomAccessIterator3\n-  transform2_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator3 result, BinaryOperation binary_op, tag1, tag2, tag3, __gnu_parallel::parallelism)\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryOperation, typename tag1, typename tag2, typename tag3>\n+  inline OutputIterator\n+  transform2_switch(InputIterator1 begin1, InputIterator1 end1, \n+\t\t    InputIterator2 begin2, OutputIterator result, \n+\t\t    BinaryOperation binary_op, tag1, tag2, tag3)\n   {\n-    return _GLIBCXX_STD_P::transform(begin1, end1, begin2, result, binary_op);\n+    return transform(begin1, end1, begin2, result, binary_op,\n+\t\t     __gnu_parallel::sequential_tag());\n   }\n \n   // Public interface.\n-  template<typename InputIterator, typename OutputIterator, typename UnaryOperation>\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryOperation>\n   inline OutputIterator\n-  transform(InputIterator begin, InputIterator end, OutputIterator result,\n-\t    UnaryOperation unary_op, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  transform(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t    OutputIterator result, BinaryOperation binary_op, \n+\t    __gnu_parallel::parallelism parallelism_tag)\n   {\n-    typedef std::iterator_traits<InputIterator> iteratori_traits;\n+    typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n+    typedef typename iteratori1_traits::iterator_category iteratori1_category;\n+    typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n+    typedef typename iteratori2_traits::iterator_category iteratori2_category;\n     typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n-    typedef typename iteratori_traits::iterator_category iteratori_category;\n     typedef typename iteratoro_traits::iterator_category iteratoro_category;\n \n-    return transform1_switch(begin, end, result, unary_op,\n-\t\t\t     iteratori_category(), iteratoro_category(), parallelism_tag);\n+    return transform2_switch(begin1, end1, begin2, result, binary_op,\n+\t\t\t     iteratori1_category(), iteratori2_category(), \n+\t\t\t     iteratoro_category(), parallelism_tag);\n   }\n \n-  // Public interface.\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryOperation>\n   inline OutputIterator\n-  transform(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, OutputIterator result, BinaryOperation binary_op, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  transform(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t    OutputIterator result, BinaryOperation binary_op)\n   {\n     typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n     typedef typename iteratori1_traits::iterator_category iteratori1_category;\n@@ -1046,54 +1165,87 @@ namespace __parallel\n     typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n     typedef typename iteratoro_traits::iterator_category iteratoro_category;\n \n-\n     return transform2_switch(begin1, end1, begin2, result, binary_op,\n-\t\t\t     iteratori1_category(), iteratori2_category(), iteratoro_category(), parallelism_tag);\n+\t\t\t     iteratori1_category(), iteratori2_category(), \n+\t\t\t     iteratoro_category());\n   }\n \n   // Sequential fallback\n   template<typename ForwardIterator, typename T>\n   inline void\n-  replace(ForwardIterator begin, ForwardIterator end, const T& old_value, const T& new_value, __gnu_parallel::sequential_tag)\n+  replace(ForwardIterator begin, ForwardIterator end, const T& old_value, \n+\t  const T& new_value, __gnu_parallel::sequential_tag)\n   { _GLIBCXX_STD_P::replace(begin, end, old_value, new_value); }\n \n   // Sequential fallback for input iterator case\n   template<typename ForwardIterator, typename T, typename IteratorTag>\n   void\n-  replace_switch(ForwardIterator begin, ForwardIterator end, const T& old_value, const T& new_value, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n-  { replace(begin, end, old_value, new_value, __gnu_parallel::sequential_tag()); }\n+  replace_switch(ForwardIterator begin, ForwardIterator end, \n+\t\t const T& old_value, const T& new_value, IteratorTag)\n+  { \n+    replace(begin, end, old_value, new_value, \n+\t    __gnu_parallel::sequential_tag());\n+  }\n \n   // Parallel replace for random access iterators\n   template<typename RandomAccessIterator, typename T>\n   void\n-  replace_switch(RandomAccessIterator begin, RandomAccessIterator end, const T& old_value, const T& new_value, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n-  { replace(begin, end, old_value, new_value, __gnu_parallel::sequential_tag()); }\n+  replace_switch(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t const T& old_value, const T& new_value, \n+\t\t random_access_iterator_tag, \n+\t\t __gnu_parallel::parallelism parallelism_tag\n+\t\t = __gnu_parallel::parallel_balanced)\n+  { \n+    // XXX parallel version is where?\n+    replace(begin, end, old_value, new_value, \n+\t    __gnu_parallel::sequential_tag()); \n+  }\n \n   // Public interface\n   template<typename ForwardIterator, typename T>\n   inline void\n-  replace(ForwardIterator begin, ForwardIterator end, const T& old_value, const T& new_value, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  replace(ForwardIterator begin, ForwardIterator end, const T& old_value, \n+\t  const T& new_value, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    typedef iterator_traits<ForwardIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    replace_switch(begin, end, old_value, new_value, iterator_category(), \n+\t\t   parallelism_tag);\n+  }\n+\n+  template<typename ForwardIterator, typename T>\n+  inline void\n+  replace(ForwardIterator begin, ForwardIterator end, const T& old_value, \n+\t  const T& new_value)\n   {\n-    replace_switch(begin, end, old_value, new_value, typename std::iterator_traits<ForwardIterator>::iterator_category(), parallelism_tag);\n+    typedef iterator_traits<ForwardIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    replace_switch(begin, end, old_value, new_value, iterator_category());\n   }\n \n \n   // Sequential fallback\n   template<typename ForwardIterator, typename Predicate, typename T>\n   inline void\n-  replace_if(ForwardIterator begin, ForwardIterator end, Predicate pred, const T& new_value, __gnu_parallel::sequential_tag)\n+  replace_if(ForwardIterator begin, ForwardIterator end, Predicate pred, \n+\t     const T& new_value, __gnu_parallel::sequential_tag)\n   { _GLIBCXX_STD_P::replace_if(begin, end, pred, new_value); }\n \n   // Sequential fallback for input iterator case\n   template<typename ForwardIterator, typename Predicate, typename T, typename IteratorTag>\n   void\n-  replace_if_switch(ForwardIterator begin, ForwardIterator end, Predicate pred, const T& new_value, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  replace_if_switch(ForwardIterator begin, ForwardIterator end, Predicate pred,\n+\t\t    const T& new_value, IteratorTag)\n   { replace_if(begin, end, pred, new_value, __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators.\n   template<typename RandomAccessIterator, typename Predicate, typename T>\n   void\n-  replace_if_switch(RandomAccessIterator begin, RandomAccessIterator end, Predicate pred, const T& new_value, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  replace_if_switch(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t    Predicate pred, const T& new_value, \n+\t\t    random_access_iterator_tag, \n+\t\t    __gnu_parallel::parallelism parallelism_tag\n+\t\t    = __gnu_parallel::parallel_balanced)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::replace_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n@@ -1102,38 +1254,54 @@ namespace __parallel\n \t__gnu_parallel::for_each_template_random_access(begin, end, pred, functionality, __gnu_parallel::dummy_reduct(), true, dummy, -1, parallelism_tag);\n       }\n     else\n-      replace_if(begin, end, pred, new_value, __gnu_parallel::sequential_tag());\n+      replace_if(begin, end, pred, new_value, \n+\t\t __gnu_parallel::sequential_tag());\n   }\n \n   // Public interface.\n   template<typename ForwardIterator, typename Predicate, typename T>\n   inline void\n   replace_if(ForwardIterator begin, ForwardIterator end,\n-\t     Predicate pred, const T& new_value, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+\t     Predicate pred, const T& new_value, \n+\t     __gnu_parallel::parallelism parallelism_tag)\n   {\n     typedef std::iterator_traits<ForwardIterator> iterator_traits;\n     typedef typename iterator_traits::iterator_category iterator_category;\n+    replace_if_switch(begin, end, pred, new_value, iterator_category(), \n+\t\t      parallelism_tag);\n+  }\n \n-    replace_if_switch(begin, end, pred, new_value, iterator_category(), parallelism_tag);\n+  template<typename ForwardIterator, typename Predicate, typename T>\n+  inline void\n+  replace_if(ForwardIterator begin, ForwardIterator end,\n+\t     Predicate pred, const T& new_value)\n+  {\n+    typedef std::iterator_traits<ForwardIterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+    replace_if_switch(begin, end, pred, new_value, iterator_category());\n   }\n \n   // Sequential fallback\n   template<typename ForwardIterator, typename Generator>\n   inline void\n-  generate(ForwardIterator begin, ForwardIterator end, Generator gen, __gnu_parallel::sequential_tag)\n-  { _GLIBCXX_STD_P::generate<ForwardIterator, Generator>(begin, end, gen); }\n+  generate(ForwardIterator begin, ForwardIterator end, Generator gen, \n+\t   __gnu_parallel::sequential_tag)\n+  { _GLIBCXX_STD_P::generate(begin, end, gen); }\n \n   // Sequential fallback for input iterator case.\n   template<typename ForwardIterator, typename Generator, typename IteratorTag>\n   void\n-  generate_switch(ForwardIterator begin, ForwardIterator end, Generator gen, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  generate_switch(ForwardIterator begin, ForwardIterator end, Generator gen, \n+\t\t  IteratorTag)\n   { generate(begin, end, gen, __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators.\n   template<typename RandomAccessIterator, typename Generator>\n   void\n   generate_switch(RandomAccessIterator begin, RandomAccessIterator end,\n-\t\t  Generator gen, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+\t\t  Generator gen, random_access_iterator_tag, \n+\t\t  __gnu_parallel::parallelism parallelism_tag\n+\t\t  = __gnu_parallel::parallel_balanced)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::generate_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n@@ -1149,53 +1317,82 @@ namespace __parallel\n   template<typename ForwardIterator, typename Generator>\n   inline void\n   generate(ForwardIterator begin, ForwardIterator end,\n-\t   Generator gen, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+\t   Generator gen, __gnu_parallel::parallelism parallelism_tag)\n   {\n     typedef std::iterator_traits<ForwardIterator> iterator_traits;\n     typedef typename iterator_traits::iterator_category iterator_category;\n     generate_switch(begin, end, gen, iterator_category(), parallelism_tag);\n   }\n \n+  template<typename ForwardIterator, typename Generator>\n+  inline void\n+  generate(ForwardIterator begin, ForwardIterator end, Generator gen)\n+  {\n+    typedef std::iterator_traits<ForwardIterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+    generate_switch(begin, end, gen, iterator_category());\n+  }\n+\n \n   // Sequential fallback.\n   template<typename OutputIterator, typename Size, typename Generator>\n   inline OutputIterator\n-  generate_n(OutputIterator begin, Size n, Generator gen, __gnu_parallel::sequential_tag)\n+  generate_n(OutputIterator begin, Size n, Generator gen, \n+\t     __gnu_parallel::sequential_tag)\n   { return _GLIBCXX_STD_P::generate_n(begin, n, gen); }\n \n   // Sequential fallback for input iterator case.\n   template<typename OutputIterator, typename Size, typename Generator, typename IteratorTag>\n   OutputIterator\n-  generate_n_switch(OutputIterator begin, Size n, Generator gen, IteratorTag, __gnu_parallel::parallelism)\n+  generate_n_switch(OutputIterator begin, Size n, Generator gen, IteratorTag)\n   { return generate_n(begin, n, gen, __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators.\n   template<typename RandomAccessIterator, typename Size, typename Generator>\n   RandomAccessIterator\n-  generate_n_switch(RandomAccessIterator begin, Size n, Generator gen, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n-  { return generate_n(begin, n, gen, __gnu_parallel::sequential_tag()); }\n+  generate_n_switch(RandomAccessIterator begin, Size n, Generator gen, \n+\t\t    random_access_iterator_tag, \n+\t\t    __gnu_parallel::parallelism parallelism_tag\n+\t\t    = __gnu_parallel::parallel_balanced)\n+  { \n+    // XXX parallel version is where?\n+    return generate_n(begin, n, gen, __gnu_parallel::sequential_tag()); \n+  }\n \n   // Public interface.\n   template<typename OutputIterator, typename Size, typename Generator>\n   inline OutputIterator\n-  generate_n(OutputIterator begin, Size n, Generator gen, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  generate_n(OutputIterator begin, Size n, Generator gen, \n+\t     __gnu_parallel::parallelism parallelism_tag)\n+  { \n+    typedef std::iterator_traits<OutputIterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+    return generate_n_switch(begin, n, gen, iterator_category(), \n+\t\t\t     parallelism_tag); \n+  }\n+\n+  template<typename OutputIterator, typename Size, typename Generator>\n+  inline OutputIterator\n+  generate_n(OutputIterator begin, Size n, Generator gen)\n   { \n     typedef std::iterator_traits<OutputIterator> iterator_traits;\n     typedef typename iterator_traits::iterator_category iterator_category;\n-    return generate_n_switch(begin, n, gen, iterator_category(), parallelism_tag); \n+    return generate_n_switch(begin, n, gen, iterator_category());\n   }\n \n \n   // Sequential fallback.\n   template<typename RandomAccessIterator>\n   inline void\n-  random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, __gnu_parallel::sequential_tag)\n+  random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t __gnu_parallel::sequential_tag)\n   { _GLIBCXX_STD_P::random_shuffle(begin, end); }\n \n   // Sequential fallback.\n   template<typename RandomAccessIterator, typename RandomNumberGenerator>\n   inline void\n-  random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator& rand, __gnu_parallel::sequential_tag)\n+  random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t RandomNumberGenerator& rand, __gnu_parallel::sequential_tag)\n   { _GLIBCXX_STD_P::random_shuffle(begin, end, rand); }\n \n \n@@ -1220,7 +1417,8 @@ namespace __parallel\n   // Parallel algorithm for random access iterators.\n   template<typename RandomAccessIterator, typename RandomNumberGenerator>\n   void\n-  random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator& rand)\n+  random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t RandomNumberGenerator& rand)\n   {\n     if (begin == end)\n       return;\n@@ -1262,19 +1460,23 @@ namespace __parallel\n   inline ForwardIterator\n   partition(ForwardIterator begin, ForwardIterator end, Predicate pred)\n   {\n-    return partition_switch(begin, end, pred, typename std::iterator_traits<ForwardIterator>::iterator_category());\n+    typedef iterator_traits<ForwardIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    return partition_switch(begin, end, pred, iterator_category());\n   }\n \n   // Sequential fallback\n   template<typename RandomAccessIterator>\n   inline void\n-  sort(RandomAccessIterator begin, RandomAccessIterator end, __gnu_parallel::sequential_tag)\n-  { _GLIBCXX_STD_P::sort<RandomAccessIterator>(begin, end); }\n+  sort(RandomAccessIterator begin, RandomAccessIterator end, \n+       __gnu_parallel::sequential_tag)\n+  { _GLIBCXX_STD_P::sort(begin, end); }\n \n   // Sequential fallback\n   template<typename RandomAccessIterator, typename Comparator>\n   inline void\n-  sort(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, __gnu_parallel::sequential_tag)\n+  sort(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp,\n+       __gnu_parallel::sequential_tag)\n   { _GLIBCXX_STD_P::sort<RandomAccessIterator, Comparator>(begin, end, comp); }\n \n   // Public interface, insert default comparator\n@@ -1299,91 +1501,93 @@ namespace __parallel\n \tif (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::sort_minimal_n))\n \t  __gnu_parallel::parallel_sort(begin, end, comp, false);\n \telse\n-\t  sort<RandomAccessIterator, Comparator>(begin, end, comp, __gnu_parallel::sequential_tag());\n+\t  sort(begin, end, comp, __gnu_parallel::sequential_tag());\n       }\n   }\n \n   // Sequential fallback.\n   template<typename RandomAccessIterator>\n   inline void\n-  stable_sort(RandomAccessIterator begin, RandomAccessIterator end, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::stable_sort<RandomAccessIterator>(begin, end);\n-  }\n+  stable_sort(RandomAccessIterator begin, RandomAccessIterator end, \n+\t      __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::stable_sort(begin, end); }\n \n   // Sequential fallback.\n   template<typename RandomAccessIterator, typename Comparator>\n   inline void\n-  stable_sort(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::stable_sort<RandomAccessIterator, Comparator>(begin, end, comp);\n-  }\n+  stable_sort(RandomAccessIterator begin, RandomAccessIterator end, \n+\t      Comparator comp, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::stable_sort(begin, end, comp); }\n \n   template<typename RandomAccessIterator>\n   void\n   stable_sort(RandomAccessIterator begin, RandomAccessIterator end)\n   {\n     typedef iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n-\n     stable_sort(begin, end, std::less<value_type>());\n   }\n \n   // Parallel algorithm for random access iterators\n   template<typename RandomAccessIterator, typename Comparator>\n   void\n-  stable_sort(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp)\n+  stable_sort(RandomAccessIterator begin, RandomAccessIterator end, \n+\t      Comparator comp)\n   {\n     if (begin != end)\n       {\n \tif (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::sort_minimal_n))\n \t  __gnu_parallel::parallel_sort(begin, end, comp, true);\n \telse\n-\t  stable_sort<RandomAccessIterator, Comparator>(begin, end, comp, __gnu_parallel::sequential_tag());\n+\t  stable_sort(begin, end, comp, __gnu_parallel::sequential_tag());\n       }\n   }\n \n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n   inline OutputIterator\n-  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result,\n+  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\tInputIterator2 end2, OutputIterator result,\n \t__gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::merge(begin1, end1, begin2, end2, result);\n-  }\n+  { return _GLIBCXX_STD_P::merge(begin1, end1, begin2, end2, result); }\n \n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Comparator>\n   inline OutputIterator\n-  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result, Comparator comp,\n+  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\tInputIterator2 end2, OutputIterator result, Comparator comp,\n \t__gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::merge(begin1, end1, begin2, end2, result, comp);\n-  }\n+  { return _GLIBCXX_STD_P::merge(begin1, end1, begin2, end2, result, comp); }\n \n   // Sequential fallback for input iterator case\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Comparator, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n   inline OutputIterator\n   merge_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result, Comparator comp, IteratorTag1, IteratorTag2, IteratorTag3)\n-  {\n-    return _GLIBCXX_STD_P::merge(begin1, end1, begin2, end2, result, comp);\n-  }\n+  { return _GLIBCXX_STD_P::merge(begin1, end1, begin2, end2, result, comp); }\n \n   // Parallel algorithm for random access iterators\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Comparator>\n   OutputIterator\n-  merge_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result, Comparator comp, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n+  merge_switch(InputIterator1 begin1, InputIterator1 end1, \n+\t       InputIterator2 begin2, InputIterator2 end2, \n+\t       OutputIterator result, Comparator comp, \n+\t       random_access_iterator_tag, random_access_iterator_tag, \n+\t       random_access_iterator_tag)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION((static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1) >= __gnu_parallel::Settings::merge_minimal_n || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2) >= __gnu_parallel::Settings::merge_minimal_n)))\n-      return __gnu_parallel::parallel_merge_advance(begin1, end1, begin2, end2, result, (end1 - begin1) + (end2 - begin2), comp);\n+      return __gnu_parallel::parallel_merge_advance(begin1, end1, begin2, end2,\n+\t\t\t      result, (end1 - begin1) + (end2 - begin2), comp);\n     else\n-      return __gnu_parallel::merge_advance(begin1, end1, begin2, end2, result, (end1 - begin1) + (end2 - begin2), comp);\n+      return __gnu_parallel::merge_advance(begin1, end1, begin2, end2, result, \n+\t\t\t\t\t   (end1 - begin1) + (end2 - begin2), \n+\t\t\t\t\t   comp);\n   }\n \n   // Public interface\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Comparator>\n   inline OutputIterator\n-  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result, Comparator comp)\n+  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\tInputIterator2 end2, OutputIterator result, Comparator comp)\n   {\n     typedef typename iterator_traits<InputIterator1>::value_type value_type;\n \n@@ -1394,39 +1598,47 @@ namespace __parallel\n     typedef typename iteratori2_traits::iterator_category iteratori2_category;\n     typedef typename iteratoro_traits::iterator_category iteratoro_category;\n \n-    return merge_switch(begin1, end1, begin2, end2, result, comp, iteratori1_category(), iteratori2_category(), iteratoro_category());\n+    return merge_switch(begin1, end1, begin2, end2, result, comp, \n+\t\t\titeratori1_category(), iteratori2_category(), \n+\t\t\titeratoro_category());\n   }\n \n \n   // Public interface, insert default comparator\n   template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n   inline OutputIterator\n-  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result)\n+  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\tInputIterator2 end2, OutputIterator result)\n   {\n     typedef std::iterator_traits<InputIterator1> iterator1_traits;\n     typedef std::iterator_traits<InputIterator2> iterator2_traits;\n     typedef typename iterator1_traits::value_type value1_type;\n     typedef typename iterator2_traits::value_type value2_type;\n \n-    return merge(begin1, end1, begin2, end2, result, __gnu_parallel::less<value1_type, value2_type>());\n+    return merge(begin1, end1, begin2, end2, result, \n+\t\t __gnu_parallel::less<value1_type, value2_type>());\n   }\n \n   // Sequential fallback\n   template<typename RandomAccessIterator>\n   inline void\n-  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, RandomAccessIterator end, __gnu_parallel::sequential_tag)\n+  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, \n+\t      RandomAccessIterator end, __gnu_parallel::sequential_tag)\n   { return _GLIBCXX_STD_P::nth_element(begin, nth, end); }\n \n   // Sequential fallback\n   template<typename RandomAccessIterator, typename Comparator>\n   void\n-  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, RandomAccessIterator end, Comparator comp, __gnu_parallel::sequential_tag)\n+  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, \n+\t      RandomAccessIterator end, Comparator comp, \n+\t      __gnu_parallel::sequential_tag)\n   { return _GLIBCXX_STD_P::nth_element(begin, nth, end, comp); }\n \n   // Public interface\n   template<typename RandomAccessIterator, typename Comparator>\n   inline void\n-  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, RandomAccessIterator end, Comparator comp)\n+  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, \n+\t      RandomAccessIterator end, Comparator comp)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::nth_element_minimal_n))\n       __gnu_parallel::parallel_nth_element(begin, nth, end, comp);\n@@ -1437,28 +1649,34 @@ namespace __parallel\n   // Public interface, insert default comparator\n   template<typename RandomAccessIterator>\n   void\n-  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, RandomAccessIterator end)\n+  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, \n+\t      RandomAccessIterator end)\n   {\n-    typedef typename iterator_traits<RandomAccessIterator>::value_type value_type;\n+    typedef iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n     nth_element(begin, nth, end, std::less<value_type>());\n   }\n \n   // Sequential fallback\n-  template<typename _RandomAccessIterator, typename _Compare>\n+  template<typename RandomAccessIterator, typename _Compare>\n   void\n-  partial_sort(_RandomAccessIterator begin, _RandomAccessIterator middle, _RandomAccessIterator end, _Compare comp, __gnu_parallel::sequential_tag)\n+  partial_sort(RandomAccessIterator begin, RandomAccessIterator middle, \n+\t       RandomAccessIterator end, _Compare comp, \n+\t       __gnu_parallel::sequential_tag)\n   { _GLIBCXX_STD_P::partial_sort(begin, middle, end, comp); }\n \n   // Sequential fallback\n-  template<typename _RandomAccessIterator>\n+  template<typename RandomAccessIterator>\n   void\n-  partial_sort(_RandomAccessIterator begin, _RandomAccessIterator middle, _RandomAccessIterator end, __gnu_parallel::sequential_tag)\n+  partial_sort(RandomAccessIterator begin, RandomAccessIterator middle, \n+\t       RandomAccessIterator end, __gnu_parallel::sequential_tag)\n   { _GLIBCXX_STD_P::partial_sort(begin, middle, end); }\n \n   // Public interface, parallel algorithm for random access iterators\n-  template<typename _RandomAccessIterator, typename _Compare>\n+  template<typename RandomAccessIterator, typename _Compare>\n   void\n-  partial_sort(_RandomAccessIterator begin, _RandomAccessIterator middle, _RandomAccessIterator end, _Compare comp)\n+  partial_sort(RandomAccessIterator begin, RandomAccessIterator middle, \n+\t       RandomAccessIterator end, _Compare comp)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::partial_sort_minimal_n))\n       __gnu_parallel::parallel_partial_sort(begin, middle, end, comp);\n@@ -1467,44 +1685,44 @@ namespace __parallel\n   }\n \n   // Public interface, insert default comparator\n-  template<typename _RandomAccessIterator>\n+  template<typename RandomAccessIterator>\n   void\n-  partial_sort(_RandomAccessIterator begin, _RandomAccessIterator middle, _RandomAccessIterator end)\n+  partial_sort(RandomAccessIterator begin, RandomAccessIterator middle, \n+\t       RandomAccessIterator end)\n   {\n-    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n+    typedef iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n     partial_sort(begin, middle, end, std::less<value_type>());\n   }\n \n   // Sequential fallback\n   template<typename ForwardIterator>\n   inline ForwardIterator\n-  max_element(ForwardIterator begin, ForwardIterator end, __gnu_parallel::sequential_tag)\n+  max_element(ForwardIterator begin, ForwardIterator end, \n+\t      __gnu_parallel::sequential_tag)\n   { return _GLIBCXX_STD_P::max_element(begin, end); }\n \n   // Sequential fallback\n   template<typename ForwardIterator, typename Comparator>\n   inline ForwardIterator\n-  max_element(ForwardIterator begin, ForwardIterator end, Comparator comp, __gnu_parallel::sequential_tag)\n+  max_element(ForwardIterator begin, ForwardIterator end, Comparator comp, \n+\t      __gnu_parallel::sequential_tag)\n   { return _GLIBCXX_STD_P::max_element(begin, end, comp); }\n \n   // Sequential fallback for input iterator case\n   template<typename ForwardIterator, typename Comparator, typename IteratorTag>\n   ForwardIterator\n-  max_element_switch(ForwardIterator begin, ForwardIterator end, Comparator comp, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  max_element_switch(ForwardIterator begin, ForwardIterator end, \n+\t\t     Comparator comp, IteratorTag)\n   { return max_element(begin, end, comp, __gnu_parallel::sequential_tag()); }\n \n-  // Public interface, insert default comparator\n-  template<typename ForwardIterator>\n-  inline ForwardIterator\n-  max_element(ForwardIterator begin, ForwardIterator end, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n-  {\n-    typedef typename iterator_traits<ForwardIterator>::value_type value_type;\n-    return max_element(begin, end, std::less<value_type>(), parallelism_tag);\n-  }\n-\n+  // Parallel algorithm for random access iterators\n   template<typename RandomAccessIterator, typename Comparator>\n   RandomAccessIterator\n-  max_element_switch(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  max_element_switch(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t     Comparator comp, random_access_iterator_tag, \n+\t\t     __gnu_parallel::parallelism parallelism_tag\n+\t\t     = __gnu_parallel::parallel_balanced)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::max_element_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n@@ -1514,49 +1732,78 @@ namespace __parallel\n \treturn res;\n       }\n     else\n-      return max_element(begin, end, __gnu_parallel::sequential_tag());\n+      return max_element(begin, end, comp, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface, insert default comparator\n+  template<typename ForwardIterator>\n+  inline ForwardIterator\n+  max_element(ForwardIterator begin, ForwardIterator end, \n+\t      __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    typedef typename iterator_traits<ForwardIterator>::value_type value_type;\n+    return max_element(begin, end, std::less<value_type>(), parallelism_tag);\n+  }\n+\n+  template<typename ForwardIterator>\n+  inline ForwardIterator\n+  max_element(ForwardIterator begin, ForwardIterator end)\n+  {\n+    typedef typename iterator_traits<ForwardIterator>::value_type value_type;\n+    return max_element(begin, end, std::less<value_type>());\n   }\n \n   // Public interface\n   template<typename ForwardIterator, typename Comparator>\n   inline ForwardIterator\n-  max_element(ForwardIterator begin, ForwardIterator end, Comparator comp, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  max_element(ForwardIterator begin, ForwardIterator end, Comparator comp, \n+\t      __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    typedef iterator_traits<ForwardIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    return max_element_switch(begin, end, comp, iterator_category(), \n+\t\t\t      parallelism_tag);\n+  }\n+\n+  template<typename ForwardIterator, typename Comparator>\n+  inline ForwardIterator\n+  max_element(ForwardIterator begin, ForwardIterator end, Comparator comp)\n   {\n-    return max_element_switch(begin, end, comp, typename std::iterator_traits<ForwardIterator>::iterator_category(), parallelism_tag);\n+    typedef iterator_traits<ForwardIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    return max_element_switch(begin, end, comp, iterator_category());\n   }\n \n+\n   // Sequential fallback\n   template<typename ForwardIterator>\n   inline\n   ForwardIterator\n-  min_element(ForwardIterator begin, ForwardIterator end, __gnu_parallel::sequential_tag)\n+  min_element(ForwardIterator begin, ForwardIterator end, \n+\t      __gnu_parallel::sequential_tag)\n   { return _GLIBCXX_STD_P::min_element(begin, end); }\n \n   // Sequential fallback\n   template<typename ForwardIterator, typename Comparator>\n   inline ForwardIterator\n-  min_element(ForwardIterator begin, ForwardIterator end, Comparator comp, __gnu_parallel::sequential_tag)\n+  min_element(ForwardIterator begin, ForwardIterator end, Comparator comp, \n+\t      __gnu_parallel::sequential_tag)\n   { return _GLIBCXX_STD_P::min_element(begin, end, comp); }\n \n-  // Public interface\n-  template<typename ForwardIterator>\n-  inline ForwardIterator\n-  min_element(ForwardIterator begin, ForwardIterator end, __gnu_parallel::parallelism parallelism_tag  = __gnu_parallel::parallel_balanced)\n-  {\n-    typedef typename iterator_traits<ForwardIterator>::value_type value_type;\n-    return min_element(begin, end, std::less<value_type>(), parallelism_tag);\n-  }\n-\n   // Sequential fallback for input iterator case\n   template<typename ForwardIterator, typename Comparator, typename IteratorTag>\n   ForwardIterator\n-  min_element_switch(ForwardIterator begin, ForwardIterator end, Comparator comp, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  min_element_switch(ForwardIterator begin, ForwardIterator end, \n+\t\t     Comparator comp, IteratorTag)\n   { return min_element(begin, end, comp, __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators\n   template<typename RandomAccessIterator, typename Comparator>\n   RandomAccessIterator\n-  min_element_switch(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  min_element_switch(RandomAccessIterator begin, RandomAccessIterator end, \n+\t\t     Comparator comp, random_access_iterator_tag, \n+\t\t     __gnu_parallel::parallelism parallelism_tag\n+\t\t     = __gnu_parallel::parallel_balanced)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::min_element_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n@@ -1566,17 +1813,46 @@ namespace __parallel\n \treturn res;\n       }\n     else\n-      return min_element(begin, end, __gnu_parallel::sequential_tag());\n+      return min_element(begin, end, comp, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface, insert default comparator\n+  template<typename ForwardIterator>\n+  inline ForwardIterator\n+  min_element(ForwardIterator begin, ForwardIterator end, \n+\t      __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    typedef typename iterator_traits<ForwardIterator>::value_type value_type;\n+    return min_element(begin, end, std::less<value_type>(), parallelism_tag);\n+  }\n+\n+  template<typename ForwardIterator>\n+  inline ForwardIterator\n+  min_element(ForwardIterator begin, ForwardIterator end)\n+  {\n+    typedef typename iterator_traits<ForwardIterator>::value_type value_type;\n+    return min_element(begin, end, std::less<value_type>());\n   }\n \n   // Public interface\n   template<typename ForwardIterator, typename Comparator>\n   inline ForwardIterator\n-  min_element(ForwardIterator begin, ForwardIterator end, Comparator comp, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  min_element(ForwardIterator begin, ForwardIterator end, Comparator comp,\n+\t      __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    typedef iterator_traits<ForwardIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    return min_element_switch(begin, end, comp, iterator_category(), \n+\t\t\t      parallelism_tag);\n+  }\n+\n+  template<typename ForwardIterator, typename Comparator>\n+  inline ForwardIterator\n+  min_element(ForwardIterator begin, ForwardIterator end, Comparator comp)\n   {\n     typedef iterator_traits<ForwardIterator> traits_type;\n     typedef typename traits_type::iterator_category iterator_category;\n-    return min_element_switch(begin, end, comp, iterator_category(), parallelism_tag);\n+    return min_element_switch(begin, end, comp, iterator_category());\n   }\n } // end namespace\n } // end namespace"}, {"sha": "a345b0f695a501e2697678a85b99a52f3cd9340f", "filename": "libstdc++-v3/include/parallel/algobase.h", "status": "modified", "additions": 60, "deletions": 29, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -59,15 +59,15 @@ namespace __parallel\n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2>\n   inline bool\n-  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::equal<InputIterator1, InputIterator2>(begin1, end1, begin2);\n-  }\n+  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t__gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::equal(begin1, end1, begin2); }\n \n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2, typename Predicate>\n   inline bool\n-  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, Predicate pred, __gnu_parallel::sequential_tag)\n+  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\tPredicate pred, __gnu_parallel::sequential_tag)\n   { return _GLIBCXX_STD_P::equal(begin1, end1, begin2, pred); }\n \n   // Public interface\n@@ -79,41 +79,45 @@ namespace __parallel\n   // Public interface\n   template<typename InputIterator1, typename InputIterator2, typename Predicate>\n   inline bool\n-  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, Predicate pred)\n+  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\tPredicate pred)\n   { return mismatch(begin1, end1, begin2, pred).first == end1; }\n \n   // NB: lexicographical_compare equires mismatch.\n \n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2>\n   inline pair<InputIterator1, InputIterator2>\n-  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::mismatch<InputIterator1, InputIterator2>(begin1, end1, begin2);\n-  }\n+  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t   __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2); }\n \n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2, typename Predicate>\n   inline pair<InputIterator1, InputIterator2>\n-  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, Predicate pred, __gnu_parallel::sequential_tag)\n+  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+\t   Predicate pred, __gnu_parallel::sequential_tag)\n   { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred); }\n \n   // Sequential fallback for input iterator case\n   template<typename InputIterator1, typename InputIterator2, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n   inline pair<InputIterator1, InputIterator2>\n-  mismatch_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, Predicate pred, IteratorTag1, IteratorTag2)\n+  mismatch_switch(InputIterator1 begin1, InputIterator1 end1, \n+\t\t  InputIterator2 begin2, Predicate pred, IteratorTag1, \n+\t\t  IteratorTag2)\n   { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred); }\n \n   // Parallel mismatch for random access iterators\n   template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Predicate>\n   pair<RandomAccessIterator1, RandomAccessIterator2>\n-  mismatch_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Predicate pred, random_access_iterator_tag, random_access_iterator_tag)\n+  mismatch_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, \n+\t\t  RandomAccessIterator2 begin2, Predicate pred, \n+\t\t  random_access_iterator_tag, random_access_iterator_tag)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(true))\n       {\n-\tRandomAccessIterator1 res_first =\n-\t  __gnu_parallel::find_template(begin1, end1, begin2, pred, __gnu_parallel::mismatch_selector()).first;\n-\treturn make_pair(res_first, begin2 + (res_first - begin1));\n+\tRandomAccessIterator1 res = __gnu_parallel::find_template(begin1, end1, begin2, pred, __gnu_parallel::mismatch_selector()).first;\n+\treturn make_pair(res , begin2 + (res - begin1));\n       }\n     else\n       return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred);\n@@ -131,7 +135,10 @@ namespace __parallel\n     typedef typename iterator1_traits::iterator_category iterator1_category;\n     typedef typename iterator2_traits::iterator_category iterator2_category;\n \n-    return mismatch_switch(begin1, end1, begin2, __gnu_parallel::equal_to<value1_type, value2_type>(), iterator1_category(), iterator2_category());\n+    typedef __gnu_parallel::equal_to<value1_type, value2_type> equal_to_type;\n+\n+    return mismatch_switch(begin1, end1, begin2, equal_to_type(),\n+\t\t\t   iterator1_category(), iterator2_category());\n   }\n \n   // Public interface\n@@ -145,38 +152,52 @@ namespace __parallel\n     typedef typename iterator1_traits::iterator_category iterator1_category;\n     typedef typename iterator2_traits::iterator_category iterator2_category;\n \n-    return mismatch_switch(begin1, end1, begin2, pred, iterator1_category(), iterator2_category());\n+    return mismatch_switch(begin1, end1, begin2, pred, iterator1_category(), \n+\t\t\t   iterator2_category());\n   }\n \n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2>\n   inline bool\n-  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, __gnu_parallel::sequential_tag)\n+  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, \n+\t\t\t  InputIterator2 begin2, InputIterator2 end2, \n+\t\t\t  __gnu_parallel::sequential_tag)\n   {\n-    return _GLIBCXX_STD_P::lexicographical_compare<InputIterator1, InputIterator2>(begin1, end1, begin2, end2);\n+    return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, begin2, end2);\n   }\n \n   // Sequential fallback\n   template<typename InputIterator1, typename InputIterator2, typename Predicate>\n   inline bool\n-  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, Predicate pred, __gnu_parallel::sequential_tag)\n+  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, \n+\t\t\t  InputIterator2 begin2, InputIterator2 end2, \n+\t\t\t  Predicate pred, __gnu_parallel::sequential_tag)\n   {\n-    return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, begin2, end2, pred);\n+    return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, \n+\t\t\t\t\t\t   begin2, end2, pred);\n   }\n \n   // Sequential fallback for input iterator case\n   template<typename InputIterator1, typename InputIterator2, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n   inline bool\n-  lexicographical_compare_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, Predicate pred, IteratorTag1, IteratorTag2)\n+  lexicographical_compare_switch(InputIterator1 begin1, InputIterator1 end1, \n+\t\t\t\t InputIterator2 begin2, InputIterator2 end2, \n+\t\t\t\t Predicate pred, IteratorTag1, IteratorTag2)\n   {\n-    return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, begin2, end2, pred);\n+    return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, \n+\t\t\t\t\t\t   begin2, end2, pred);\n   }\n \n   // Parallel lexicographical_compare for random access iterators\n   // Limitation: Both valuetypes must be the same\n   template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Predicate>\n   bool\n-  lexicographical_compare_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator2 end2, Predicate pred, random_access_iterator_tag, random_access_iterator_tag)\n+  lexicographical_compare_switch(RandomAccessIterator1 begin1, \n+\t\t\t\t RandomAccessIterator1 end1, \n+\t\t\t\t RandomAccessIterator2 begin2, \n+\t\t\t\t RandomAccessIterator2 end2, Predicate pred, \n+\t\t\t\t random_access_iterator_tag, \n+\t\t\t\t random_access_iterator_tag)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(true))\n       {\n@@ -192,7 +213,10 @@ namespace __parallel\n \tif ((end1 - begin1) < (end2 - begin2))\n \t  {\n \t    typedef pair<RandomAccessIterator1, RandomAccessIterator2> pair_type;\n-\t    pair_type mm = mismatch_switch(begin1, end1, begin2, equal_type(pred), random_access_iterator_tag(), random_access_iterator_tag());\n+\t    pair_type mm = mismatch_switch(begin1, end1, begin2, \n+\t\t\t\t\t   equal_type(pred), \n+\t\t\t\t\t   random_access_iterator_tag(), \n+\t\t\t\t\t   random_access_iterator_tag());\n \n \t    // Less because shorter.\n \t    const bool lbs = mm.first == end1;\n@@ -205,7 +229,10 @@ namespace __parallel\n \telse\n \t  {\n \t    typedef pair<RandomAccessIterator2, RandomAccessIterator1> pair_type;\n-\t    pair_type mm = mismatch_switch(begin2, end2, begin1, equal_type(pred), random_access_iterator_tag(), random_access_iterator_tag());\n+\t    pair_type mm = mismatch_switch(begin2, end2, begin1, \n+\t\t\t\t\t   equal_type(pred), \n+\t\t\t\t\t   random_access_iterator_tag(), \n+\t\t\t\t\t   random_access_iterator_tag());\n \n \t    // Less because shorter.\n \t    const bool lbs = mm.first != end2;\n@@ -234,7 +261,9 @@ namespace __parallel\n     typedef typename traits2_type::iterator_category iterator2_category;\n     typedef __gnu_parallel::less<value1_type, value2_type> less_type;\n \n-    return lexicographical_compare_switch(begin1, end1, begin2, end2, less_type(), iterator1_category(), iterator2_category());\n+    return lexicographical_compare_switch(begin1, end1, begin2, end2, \n+\t\t\t\t\t  less_type(), iterator1_category(), \n+\t\t\t\t\t  iterator2_category());\n   }\n \n   // Public interface\n@@ -248,7 +277,9 @@ namespace __parallel\n     typedef iterator_traits<InputIterator2> traits2_type;\n     typedef typename traits2_type::iterator_category iterator2_category;\n \n-    return lexicographical_compare_switch(begin1, end1, begin2, end2, pred, iterator1_category(), iterator2_category());\n+    return lexicographical_compare_switch(begin1, end1, begin2, end2, pred, \n+\t\t\t\t\t  iterator1_category(), \n+\t\t\t\t\t  iterator2_category());\n   }\n } // end namespace\n } // end namespace"}, {"sha": "ad36de527e5fa45fba861dad0f1ebebd9386415e", "filename": "libstdc++-v3/include/parallel/algorithmfwd.h", "status": "modified", "additions": 366, "deletions": 292, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -45,450 +45,540 @@ namespace std\n namespace __parallel\n {\n   template<typename _FIter>\n-  inline _FIter\n-  adjacent_find(_FIter, _FIter, __gnu_parallel::sequential_tag);\n-\n-  template<typename _FIter, typename BinaryPredicate>\n-  inline _FIter\n-  adjacent_find(_FIter, _FIter, BinaryPredicate, __gnu_parallel::sequential_tag);\n+    _FIter\n+    adjacent_find(_FIter, _FIter);\n \n   template<typename _FIter>\n-  inline _FIter\n-  adjacent_find(_FIter, _FIter);\n+    _FIter\n+    adjacent_find(_FIter, _FIter, __gnu_parallel::sequential_tag);\n \n-  template<typename _FIter, typename BinaryPredicate>\n-  inline _FIter\n-  adjacent_find(_FIter, _FIter, BinaryPredicate);\n+  template<typename _FIter, typename _IterTag>\n+    _FIter\n+    adjacent_find_switch(_FIter, _FIter, _IterTag);\n \n   template<typename _RAIter>\n-  _RAIter\n-  adjacent_find_switch(_RAIter, _RAIter, random_access_iterator_tag);\n+    _RAIter\n+    adjacent_find_switch(_RAIter, _RAIter, random_access_iterator_tag);\n \n-  template<typename _FIter, typename IteratorTag>\n-  inline _FIter\n-  adjacent_find_switch(_FIter, _FIter, IteratorTag);\n \n-  template<typename _FIter, typename BinaryPredicate, typename IteratorTag>\n-  inline _FIter\n-  adjacent_find_switch(_FIter, _FIter, BinaryPredicate, IteratorTag);\n+  template<typename _FIter, typename _BiPredicate>\n+    _FIter\n+    adjacent_find(_FIter, _FIter, _BiPredicate);\n \n-  template<typename _RAIter, typename BinaryPredicate>\n-  _RAIter\n-  adjacent_find_switch(_RAIter, _RAIter, BinaryPredicate, random_access_iterator_tag);\n+  template<typename _FIter, typename _BiPredicate>\n+    _FIter\n+    adjacent_find(_FIter, _FIter, _BiPredicate,\n+\t\t  __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter, typename _BiPredicate, typename _IterTag>\n+    _FIter\n+    adjacent_find_switch(_FIter, _FIter, _BiPredicate, _IterTag);\n \n+  template<typename _RAIter, typename _BiPredicate>\n+    _RAIter\n+    adjacent_find_switch(_RAIter, _RAIter, _BiPredicate, \n+\t\t\t random_access_iterator_tag);\n+\n+\n+  template<typename _IIter, typename _Tp>\n+    typename iterator_traits<_IIter>::difference_type\n+    count(_IIter, _IIter, const _Tp&);\n \n   template<typename _IIter, typename T>\n-  inline typename iterator_traits<_IIter>::difference_type\n-  count(_IIter, _IIter, const T& value, __gnu_parallel::sequential_tag);\n+    typename iterator_traits<_IIter>::difference_type\n+    count(_IIter, _IIter, const T&, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename T>\n-  inline typename iterator_traits<_IIter>::difference_type\n-  count(_IIter, _IIter, const T& value, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+    typename iterator_traits<_IIter>::difference_type\n+    count(_IIter, _IIter, const T&, __gnu_parallel::parallelism);\n+\n+  template<typename _IIter, typename T, typename _IterTag>\n+    typename iterator_traits<_IIter>::difference_type\n+    count_switch(_IIter, _IIter, const T&, _IterTag);\n \n   template<typename _RAIter, typename T>\n-  typename iterator_traits<_RAIter>::difference_type\n-  count_switch(_RAIter, _RAIter, const T& value, random_access_iterator_tag, __gnu_parallel::parallelism);\n+    typename iterator_traits<_RAIter>::difference_type\n+    count_switch(_RAIter, _RAIter, const T&, random_access_iterator_tag,\n+\t\t __gnu_parallel::parallelism);\n \n-  template<typename _IIter, typename T, typename IteratorTag>\n-  typename iterator_traits<_IIter>::difference_type\n-  count_switch(_IIter, _IIter, const T& value, IteratorTag, __gnu_parallel::parallelism);\n \n+  template<typename _IIter, typename Predicate>\n+    typename iterator_traits<_IIter>::difference_type\n+    count_if(_IIter, _IIter, Predicate);\n \n   template<typename _IIter, typename Predicate>\n-  inline typename iterator_traits<_IIter>::difference_type\n-  count_if(_IIter, _IIter, Predicate, __gnu_parallel::sequential_tag);\n+    typename iterator_traits<_IIter>::difference_type\n+    count_if(_IIter, _IIter, Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename Predicate>\n-  inline typename iterator_traits<_IIter>::difference_type\n-  count_if(_IIter, _IIter, Predicate, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+    typename iterator_traits<_IIter>::difference_type\n+    count_if(_IIter, _IIter, Predicate, __gnu_parallel::parallelism);\n \n-  template<typename _RAIter, typename Predicate>\n-  typename iterator_traits<_RAIter>::difference_type\n-  count_if_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag, __gnu_parallel::parallelism);\n+  template<typename _IIter, typename Predicate, typename _IterTag>\n+    typename iterator_traits<_IIter>::difference_type\n+    count_if_switch(_IIter, _IIter, Predicate, _IterTag);\n \n-  template<typename _IIter, typename Predicate, typename IteratorTag>\n-  typename iterator_traits<_IIter>::difference_type\n-  count_if_switch(_IIter, _IIter, Predicate, IteratorTag, __gnu_parallel::parallelism);\n+  template<typename _RAIter, typename Predicate>\n+    typename iterator_traits<_RAIter>::difference_type\n+    count_if_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag, \n+\t\t    __gnu_parallel::parallelism);\n \n   // algobase.h\n   template<typename _IIter1, typename _IIter2>\n-  inline bool\n+  bool\n   equal(_IIter1, _IIter1, _IIter2, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename Predicate>\n-  inline bool\n+  bool\n   equal(_IIter1, _IIter1, _IIter2, Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2>\n-  inline bool\n+  bool\n   equal(_IIter1, _IIter1, _IIter2);\n \n   template<typename _IIter1, typename _IIter2, typename Predicate>\n-  inline bool\n+  bool\n   equal(_IIter1, _IIter1, _IIter2, Predicate);\n \n   template<typename _IIter, typename T>\n-  inline _IIter\n+  _IIter\n   find(_IIter, _IIter, const T&, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename T>\n-  inline _IIter\n+  _IIter\n   find(_IIter, _IIter, const T& val);\n \n-  template<typename _IIter, typename T, typename IteratorTag>\n-  inline _IIter\n-  find_switch(_IIter, _IIter, const T&, IteratorTag);\n+  template<typename _IIter, typename T, typename _IterTag>\n+  _IIter\n+  find_switch(_IIter, _IIter, const T&, _IterTag);\n \n   template<typename _RAIter, typename T>\n   _RAIter\n   find_switch(_RAIter, _RAIter, const T&, random_access_iterator_tag);\n \n   template<typename _IIter, typename Predicate>\n-  inline _IIter\n+  _IIter\n   find_if(_IIter, _IIter, Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename Predicate>\n-  inline _IIter\n+  _IIter\n   find_if(_IIter, _IIter, Predicate);\n \n-  template<typename _IIter, typename Predicate, typename IteratorTag>\n-  inline _IIter\n-  find_if_switch(_IIter, _IIter, Predicate, IteratorTag);\n+  template<typename _IIter, typename Predicate, typename _IterTag>\n+  _IIter\n+  find_if_switch(_IIter, _IIter, Predicate, _IterTag);\n \n   template<typename _RAIter, typename Predicate>\n   _RAIter\n   find_if_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag);\n \n   template<typename _IIter, typename _FIter>\n-  inline _IIter\n+  _IIter\n   find_first_of(_IIter, _IIter, _FIter, _FIter, __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter, typename _FIter, typename BinaryPredicate>\n-  inline _IIter\n-  find_first_of(_IIter, _IIter, _FIter, _FIter, BinaryPredicate, __gnu_parallel::sequential_tag);\n+  template<typename _IIter, typename _FIter, typename _BiPredicate>\n+  _IIter\n+  find_first_of(_IIter, _IIter, _FIter, _FIter, _BiPredicate, __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter, typename _FIter, typename BinaryPredicate>\n-  inline _IIter\n-  find_first_of(_IIter, _IIter, _FIter, _FIter, BinaryPredicate);\n+  template<typename _IIter, typename _FIter, typename _BiPredicate>\n+  _IIter\n+  find_first_of(_IIter, _IIter, _FIter, _FIter, _BiPredicate);\n \n   template<typename _IIter, typename _FIter>\n   _IIter\n   find_first_of(_IIter, _IIter, _FIter, _FIter);\n \n-  template<typename _IIter, typename _FIter, typename IteratorTag1, typename IteratorTag2>\n-  inline _IIter\n-  find_first_of_switch(_IIter, _IIter, _FIter, _FIter, IteratorTag1, IteratorTag2);\n+  template<typename _IIter, typename _FIter, typename _IterTag1, typename _IterTag2>\n+  _IIter\n+  find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _IterTag1, _IterTag2);\n \n-  template<typename _RAIter, typename _FIter, typename BinaryPredicate, typename IteratorTag>\n-  inline _RAIter\n-  find_first_of_switch(_RAIter, _RAIter, _FIter, _FIter, BinaryPredicate, random_access_iterator_tag, IteratorTag);\n+  template<typename _RAIter, typename _FIter, typename _BiPredicate, typename _IterTag>\n+  _RAIter\n+  find_first_of_switch(_RAIter, _RAIter, _FIter, _FIter, _BiPredicate, random_access_iterator_tag, _IterTag);\n \n-  template<typename _IIter, typename _FIter, typename BinaryPredicate, typename IteratorTag1, typename IteratorTag2>\n-  inline _IIter\n-  find_first_of_switch(_IIter, _IIter, _FIter, _FIter, BinaryPredicate, IteratorTag1, IteratorTag2);\n+  template<typename _IIter, typename _FIter, typename _BiPredicate, typename _IterTag1, typename _IterTag2>\n+  _IIter\n+  find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _BiPredicate, _IterTag1, _IterTag2);\n \n \n   template<typename _IIter, typename Function>\n-  inline Function\n-  for_each(_IIter, _IIter, Function f, __gnu_parallel::sequential_tag);\n+    Function\n+    for_each(_IIter, _IIter, Function);\n+\n+  template<typename _IIter, typename Function>\n+    Function\n+    for_each(_IIter, _IIter, Function, __gnu_parallel::sequential_tag);\n \n   template<typename Iterator, typename Function>\n-  inline Function\n-  for_each(Iterator, Iterator, Function f, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+    Function\n+    for_each(Iterator, Iterator, Function, __gnu_parallel::parallelism);\n \n-  template<typename _IIter, typename Function, typename IteratorTag>\n-  Function\n-  for_each_switch(_IIter, _IIter, Function f, IteratorTag, __gnu_parallel::parallelism);\n+  template<typename _IIter, typename Function, typename _IterTag>\n+    Function\n+    for_each_switch(_IIter, _IIter, Function, _IterTag);\n \n   template<typename _RAIter, typename Function>\n-  Function\n-  for_each_switch(_RAIter, _RAIter, Function f, random_access_iterator_tag, __gnu_parallel::parallelism);\n+    Function\n+    for_each_switch(_RAIter, _RAIter, Function, random_access_iterator_tag, \n+\t\t    __gnu_parallel::parallelism);\n+\n \n   template<typename _FIter, typename Generator>\n-  inline void\n-  generate(_FIter, _FIter, Generator, __gnu_parallel::sequential_tag);\n+    void\n+    generate(_FIter, _FIter, Generator);\n \n   template<typename _FIter, typename Generator>\n-  inline void\n-  generate(_FIter, _FIter, Generator, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+    void\n+    generate(_FIter, _FIter, Generator, __gnu_parallel::sequential_tag);\n \n-  template<typename _FIter, typename Generator, typename IteratorTag>\n-  void\n-  generate_switch(_FIter, _FIter, Generator, IteratorTag, __gnu_parallel::parallelism);\n+  template<typename _FIter, typename Generator>\n+    void\n+    generate(_FIter, _FIter, Generator, __gnu_parallel::parallelism);\n+\n+  template<typename _FIter, typename Generator, typename _IterTag>\n+    void\n+    generate_switch(_FIter, _FIter, Generator, _IterTag);\n \n   template<typename _RAIter, typename Generator>\n-  void\n-  generate_switch(_RAIter, _RAIter, Generator, random_access_iterator_tag, __gnu_parallel::parallelism);\n+    void\n+    generate_switch(_RAIter, _RAIter, Generator, random_access_iterator_tag, \n+\t\t    __gnu_parallel::parallelism);\n \n   template<typename _OIter, typename Size, typename Generator>\n-  inline _OIter\n-  generate_n(_OIter, Size, Generator, __gnu_parallel::sequential_tag);\n+    _OIter\n+    generate_n(_OIter, Size, Generator);\n \n   template<typename _OIter, typename Size, typename Generator>\n-  inline _OIter\n-  generate_n(_OIter, Size, Generator, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+    _OIter\n+    generate_n(_OIter, Size, Generator, __gnu_parallel::sequential_tag);\n \n-  template<typename _OIter, typename Size, typename Generator, typename IteratorTag>\n-  _OIter\n-  generate_n_switch(_OIter, Size, Generator, IteratorTag, __gnu_parallel::parallelism);\n+  template<typename _OIter, typename Size, typename Generator>\n+    _OIter\n+    generate_n(_OIter, Size, Generator, __gnu_parallel::parallelism);\n+\n+  template<typename _OIter, typename Size, typename Generator, typename _IterTag>\n+    _OIter\n+    generate_n_switch(_OIter, Size, Generator, _IterTag);\n \n   template<typename _RAIter, typename Size, typename Generator>\n-  _RAIter\n-  generate_n_switch(_RAIter, Size, Generator, random_access_iterator_tag, __gnu_parallel::parallelism);\n+    _RAIter\n+    generate_n_switch(_RAIter, Size, Generator, random_access_iterator_tag, \n+\t\t      __gnu_parallel::parallelism);\n \n   template<typename _IIter1, typename _IIter2>\n-  inline bool\n+  bool\n   lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename Predicate>\n-  inline bool\n+  bool\n   lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2>\n-  inline bool\n+  bool\n   lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);\n \n   template<typename _IIter1, typename _IIter2, typename Predicate>\n-  inline bool\n+  bool\n   lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, Predicate);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n-  inline bool\n-  lexicographical_compare_switch(_IIter1, _IIter1, _IIter2, _IIter2, Predicate, IteratorTag1, IteratorTag2);\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename _IterTag1, typename _IterTag2>\n+  bool\n+  lexicographical_compare_switch(_IIter1, _IIter1, _IIter2, _IIter2, Predicate, _IterTag1, _IterTag2);\n \n   template<typename _RAIter1, typename _RAIter2, typename Predicate>\n   bool\n   lexicographical_compare_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Predicate, random_access_iterator_tag, random_access_iterator_tag);\n \n   // algo.h\n   template<typename _IIter1, typename _IIter2>\n-  inline pair<_IIter1, _IIter2>\n+  pair<_IIter1, _IIter2>\n   mismatch(_IIter1, _IIter1, _IIter2, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename Predicate>\n-  inline pair<_IIter1, _IIter2>\n+  pair<_IIter1, _IIter2>\n   mismatch(_IIter1, _IIter1, _IIter2, Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2>\n-  inline pair<_IIter1, _IIter2>\n+  pair<_IIter1, _IIter2>\n   mismatch(_IIter1, _IIter1, _IIter2);\n \n   template<typename _IIter1, typename _IIter2, typename Predicate>\n-  inline pair<_IIter1, _IIter2>\n+  pair<_IIter1, _IIter2>\n   mismatch(_IIter1, _IIter1, _IIter2, Predicate);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n-  inline pair<_IIter1, _IIter2>\n-  mismatch_switch(_IIter1, _IIter1, _IIter2, Predicate, IteratorTag1, IteratorTag2);\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename _IterTag1, typename _IterTag2>\n+  pair<_IIter1, _IIter2>\n+  mismatch_switch(_IIter1, _IIter1, _IIter2, Predicate, _IterTag1, _IterTag2);\n \n   template<typename _RAIter1, typename _RAIter2, typename Predicate>\n   pair<_RAIter1, _RAIter2>\n   mismatch_switch(_RAIter1, _RAIter1, _RAIter2, Predicate, random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _FIter1, typename _FIter2>\n-  inline _FIter1\n+  _FIter1\n   search(_FIter1, _FIter1, _FIter2, _FIter2, __gnu_parallel::sequential_tag);\n \n   template<typename _FIter1, typename _FIter2>\n-  inline _FIter1\n+  _FIter1\n   search(_FIter1, _FIter1, _FIter2, _FIter2);\n \n-  template<typename _FIter1, typename _FIter2, typename BinaryPredicate>\n-  inline _FIter1\n-  search(_FIter1, _FIter1, _FIter2, _FIter2, BinaryPredicate, __gnu_parallel::sequential_tag);\n+  template<typename _FIter1, typename _FIter2, typename _BiPredicate>\n+  _FIter1\n+  search(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate, __gnu_parallel::sequential_tag);\n \n-  template<typename _FIter1, typename _FIter2, typename BinaryPredicate>\n-  inline _FIter1\n-  search(_FIter1, _FIter1, _FIter2, _FIter2, BinaryPredicate);\n+  template<typename _FIter1, typename _FIter2, typename _BiPredicate>\n+  _FIter1\n+  search(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate);\n \n   template<typename _RAIter1, typename _RAIter2>\n   _RAIter1\n   search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, random_access_iterator_tag, random_access_iterator_tag);\n \n-  template<typename _FIter1, typename _FIter2, typename IteratorTag1, typename IteratorTag2>\n-  inline _FIter1\n-  search_switch(_FIter1, _FIter1, _FIter2, _FIter2, IteratorTag1, IteratorTag2);\n+  template<typename _FIter1, typename _FIter2, typename _IterTag1, typename _IterTag2>\n+  _FIter1\n+  search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _IterTag1, _IterTag2);\n \n-  template<typename _RAIter1, typename _RAIter2, typename BinaryPredicate>\n+  template<typename _RAIter1, typename _RAIter2, typename _BiPredicate>\n   _RAIter1\n-  search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, BinaryPredicate , random_access_iterator_tag, random_access_iterator_tag);\n+  search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, _BiPredicate , random_access_iterator_tag, random_access_iterator_tag);\n \n-  template<typename _FIter1, typename _FIter2, typename BinaryPredicate, typename IteratorTag1, typename IteratorTag2>\n-  inline _FIter1\n-  search_switch(_FIter1, _FIter1, _FIter2, _FIter2, BinaryPredicate, IteratorTag1, IteratorTag2);\n+  template<typename _FIter1, typename _FIter2, typename _BiPredicate, typename _IterTag1, typename _IterTag2>\n+  _FIter1\n+  search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate, _IterTag1, _IterTag2);\n \n   template<typename _FIter, typename Integer, typename T>\n-  inline _FIter\n+  _FIter\n   search_n(_FIter, _FIter, Integer, const T&, __gnu_parallel::sequential_tag);\n \n-  template<typename _FIter, typename Integer, typename T, typename BinaryPredicate>\n-  inline _FIter\n-  search_n(_FIter, _FIter, Integer, const T&, BinaryPredicate, __gnu_parallel::sequential_tag);\n+  template<typename _FIter, typename Integer, typename T, typename _BiPredicate>\n+  _FIter\n+  search_n(_FIter, _FIter, Integer, const T&, _BiPredicate, __gnu_parallel::sequential_tag);\n     \n   template<typename _FIter, typename Integer, typename T>\n-  inline _FIter\n+  _FIter\n   search_n(_FIter, _FIter, Integer, const T& val);\n \n-  template<typename _FIter, typename Integer, typename T, typename BinaryPredicate>\n-  inline _FIter\n-  search_n(_FIter, _FIter, Integer, const T&, BinaryPredicate);\n+  template<typename _FIter, typename Integer, typename T, typename _BiPredicate>\n+  _FIter\n+  search_n(_FIter, _FIter, Integer, const T&, _BiPredicate);\n \n-  template<typename _RAIter, typename Integer, typename T, typename BinaryPredicate>\n+  template<typename _RAIter, typename Integer, typename T, typename _BiPredicate>\n   _RAIter\n-  search_n_switch(_RAIter, _RAIter, Integer, const T&, BinaryPredicate, random_access_iterator_tag);\n+  search_n_switch(_RAIter, _RAIter, Integer, const T&, _BiPredicate, random_access_iterator_tag);\n \n-  template<typename _FIter, typename Integer, typename T, typename BinaryPredicate, typename IteratorTag>\n-  inline _FIter\n-  search_n_switch(_FIter, _FIter, Integer, const T&, BinaryPredicate, IteratorTag);\n+  template<typename _FIter, typename Integer, typename T, typename _BiPredicate, typename _IterTag>\n+  _FIter\n+  search_n_switch(_FIter, _FIter, Integer, const T&, _BiPredicate, _IterTag);\n \n \n   template<typename _IIter, typename _OIter, typename UnaryOperation>\n-  inline _OIter\n-  transform(_IIter, _IIter, _OIter, UnaryOperation, __gnu_parallel::sequential_tag);\n+    _OIter\n+    transform(_IIter, _IIter, _OIter, UnaryOperation);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename BinaryOperation>\n-  inline _OIter\n-  transform(_IIter1, _IIter1, _IIter2, _OIter, BinaryOperation binary_op, __gnu_parallel::sequential_tag);\n+  template<typename _IIter, typename _OIter, typename UnaryOperation>\n+    _OIter\n+    transform(_IIter, _IIter, _OIter, UnaryOperation, \n+\t      __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter, typename UnaryOperation>\n-  inline _OIter\n-  transform(_IIter, _IIter, _OIter, UnaryOperation, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+    _OIter\n+    transform(_IIter, _IIter, _OIter, UnaryOperation, \n+\t      __gnu_parallel::parallelism);\n+\n+  template<typename _IIter, typename _OIter, typename UnaryOperation, typename _IterTag1, typename _IterTag2>\n+    _OIter\n+    transform1_switch(_IIter, _IIter, _OIter, UnaryOperation, \n+\t\t      _IterTag1, _IterTag2);\n+    \n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename BinaryOperation>\n-  inline _OIter\n-  transform(_IIter1, _IIter1, _IIter2, _OIter, BinaryOperation binary_op, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+  template<typename _RAIIter, typename _RAOIter, typename UnaryOperation>\n+    _RAOIter\n+    transform1_switch(_RAIIter, _RAIIter, _RAOIter, UnaryOperation, \n+\t\t      random_access_iterator_tag, random_access_iterator_tag, \n+\t\t      __gnu_parallel::parallelism);\n \n-  template<typename _RAIter1, typename _RAIter3, typename UnaryOperation>\n-  _RAIter3\n-  transform1_switch(_RAIter1, _RAIter1, _RAIter3, UnaryOperation, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n \n-  template<typename _RAIter1, typename _RAIter3, typename UnaryOperation, typename IteratorTag1, typename IteratorTag2>\n-  inline _RAIter3\n-  transform1_switch(_RAIter1, _RAIter1, _RAIter3, UnaryOperation, IteratorTag1, IteratorTag2, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n-    \n-  template<typename _RAIter1, typename _RAIter2, typename _RAIter3, typename BinaryOperation>\n-  _RAIter3\n-  transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, BinaryOperation binary_op, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename _BiOperation>\n+    _OIter\n+    transform(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename _BiOperation>\n+    _OIter\n+    transform(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n+\t      __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename _BiOperation>\n+    _OIter\n+    transform(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n+\t      __gnu_parallel::parallelism);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename _RAIter3, typename _BiOperation>\n+    _RAIter3\n+    transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, _BiOperation, \n+\t\t      random_access_iterator_tag, random_access_iterator_tag, \n+\t\t      random_access_iterator_tag, \n+\t\t      __gnu_parallel::parallelism parallelism_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename _BiOperation, typename tag1, typename tag2, typename tag3>\n+    _OIter\n+    transform2_switch(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n+\t\t      tag1, tag2, tag3);\n \n-  template<typename _RAIter1, typename _RAIter2, typename _RAIter3, typename BinaryOperation, typename tag1, typename tag2, typename tag3>\n-  inline _RAIter3\n-  transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, BinaryOperation binary_op, tag1, tag2, tag3, __gnu_parallel::parallelism);\n \n   template<typename _FIter, typename T>\n-  inline void\n-  replace(_FIter, _FIter, const T&, const T&, __gnu_parallel::sequential_tag);\n+    void\n+    replace(_FIter, _FIter, const T&, const T&);\n \n   template<typename _FIter, typename T>\n-  inline void\n-  replace(_FIter, _FIter, const T&, const T&, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+    void\n+    replace(_FIter, _FIter, const T&, const T&, \n+\t    __gnu_parallel::sequential_tag);\n \n-  template<typename _FIter, typename T, typename IteratorTag>\n-  void\n-  replace_switch(_FIter, _FIter, const T&, const T&, IteratorTag, __gnu_parallel::parallelism);\n+  template<typename _FIter, typename T>\n+    void\n+    replace(_FIter, _FIter, const T&, const T&, __gnu_parallel::parallelism);\n+\n+  template<typename _FIter, typename T, typename _IterTag>\n+    void\n+    replace_switch(_FIter, _FIter, const T&, const T&, _IterTag);\n \n   template<typename _RAIter, typename T>\n-  void\n-  replace_switch(_RAIter, _RAIter, const T&, const T&, random_access_iterator_tag, __gnu_parallel::parallelism);\n+    void\n+    replace_switch(_RAIter, _RAIter, const T&, const T&, \n+\t\t   random_access_iterator_tag, __gnu_parallel::parallelism);\n \n \n   template<typename _FIter, typename Predicate, typename T>\n-  inline void\n-  replace_if(_FIter, _FIter, Predicate, const T&, __gnu_parallel::sequential_tag);\n+    void\n+    replace_if(_FIter, _FIter, Predicate, const T&);\n \n   template<typename _FIter, typename Predicate, typename T>\n-  inline void\n-  replace_if(_FIter, _FIter, Predicate, const T&, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n-\n-  template<typename _FIter, typename Predicate, typename T, typename IteratorTag>\n-  void\n-  replace_if_switch(_FIter, _FIter, Predicate, const T&, IteratorTag, __gnu_parallel::parallelism);\n+    void\n+    replace_if(_FIter, _FIter, Predicate, const T&, \n+\t       __gnu_parallel::sequential_tag);\n \n+  template<typename _FIter, typename Predicate, typename T>\n+    void\n+    replace_if(_FIter, _FIter, Predicate, const T&, \n+\t       __gnu_parallel::parallelism);\n+\n+  template<typename _FIter, typename Predicate, typename T, typename _IterTag>\n+    void\n+    replace_if_switch(_FIter, _FIter, Predicate, const T&, _IterTag);\n+ \n   template<typename _RAIter, typename Predicate, typename T>\n-  void\n-  replace_if_switch(_RAIter, _RAIter, Predicate, const T&, random_access_iterator_tag, __gnu_parallel::parallelism);\n+    void\n+    replace_if_switch(_RAIter, _RAIter, Predicate, const T&, \n+\t\t      random_access_iterator_tag, __gnu_parallel::parallelism);\n+\n \n   template<typename _FIter>\n-  inline _FIter\n-  max_element(_FIter, _FIter, __gnu_parallel::sequential_tag);\n+    _FIter\n+    max_element(_FIter, _FIter);\n \n-  template<typename _FIter, typename _Compare>\n-  inline _FIter\n-  max_element(_FIter, _FIter, _Compare, __gnu_parallel::sequential_tag);\n+  template<typename _FIter>\n+    _FIter\n+    max_element(_FIter, _FIter, __gnu_parallel::sequential_tag);\n \n   template<typename _FIter>\n-  inline _FIter\n-  max_element(_FIter, _FIter, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+    _FIter\n+    max_element(_FIter, _FIter, __gnu_parallel::parallelism parallelism_tag);\n \n   template<typename _FIter, typename _Compare>\n-  inline _FIter\n-  max_element(_FIter, _FIter, _Compare, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+    _FIter\n+    max_element(_FIter, _FIter, _Compare);\n \n-  template<typename _FIter, typename _Compare, typename IteratorTag>\n-  _FIter\n-  max_element_switch(_FIter, _FIter, _Compare, IteratorTag, __gnu_parallel::parallelism);\n+  template<typename _FIter, typename _Compare>\n+    _FIter\n+    max_element(_FIter, _FIter, _Compare, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter, typename _Compare>\n+    _FIter\n+    max_element(_FIter, _FIter, _Compare, __gnu_parallel::parallelism);\n+\n+  template<typename _FIter, typename _Compare, typename _IterTag>\n+    _FIter\n+    max_element_switch(_FIter, _FIter, _Compare, _IterTag);\n \n   template<typename _RAIter, typename _Compare>\n-  _RAIter\n-  max_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, __gnu_parallel::parallelism);\n+    _RAIter\n+    max_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, \n+\t\t       __gnu_parallel::parallelism);\n+\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  inline _OIter\n-  merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n+    _OIter\n+    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, \n+\t  __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare>\n-  inline _OIter\n-  merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, __gnu_parallel::sequential_tag);\n+    _OIter\n+    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n+\t  __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare>\n-  inline _OIter\n-  merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n+    _OIter\n+    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  inline _OIter\n-  merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+    _OIter\n+    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n-  template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n-  inline _OIter\n-  merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, IteratorTag1, IteratorTag2, IteratorTag3);\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare, typename _IterTag1, typename _IterTag2, typename _IterTag3>\n+    _OIter\n+    merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n+\t\t _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare>\n-  _OIter\n-  merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n+    _OIter\n+    merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n+\t\t random_access_iterator_tag, random_access_iterator_tag, \n+\t\t random_access_iterator_tag);\n+\n \n   template<typename _FIter>\n-  inline _FIter\n-  min_element(_FIter, _FIter, __gnu_parallel::sequential_tag);\n+    _FIter\n+    min_element(_FIter, _FIter);\n \n-  template<typename _FIter, typename _Compare>\n-  inline _FIter\n-  min_element(_FIter, _FIter, _Compare, __gnu_parallel::sequential_tag);\n+  template<typename _FIter>\n+    _FIter\n+    min_element(_FIter, _FIter, __gnu_parallel::sequential_tag);\n \n   template<typename _FIter>\n-  inline _FIter\n-  min_element(_FIter, _FIter, __gnu_parallel::parallelism parallelism_tag  = __gnu_parallel::parallel_balanced);\n+    _FIter\n+    min_element(_FIter, _FIter, __gnu_parallel::parallelism parallelism_tag);\n \n   template<typename _FIter, typename _Compare>\n-  inline _FIter\n-  min_element(_FIter, _FIter, _Compare, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+    _FIter\n+    min_element(_FIter, _FIter, _Compare);\n \n-  template<typename _FIter, typename _Compare, typename IteratorTag>\n-  _FIter\n-  min_element_switch(_FIter, _FIter, _Compare, IteratorTag, __gnu_parallel::parallelism);\n+  template<typename _FIter, typename _Compare>\n+    _FIter\n+    min_element(_FIter, _FIter, _Compare, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter, typename _Compare>\n+    _FIter\n+    min_element(_FIter, _FIter, _Compare, __gnu_parallel::parallelism);\n+\n+  template<typename _FIter, typename _Compare, typename _IterTag>\n+    _FIter\n+    min_element_switch(_FIter, _FIter, _Compare, _IterTag);\n \n   template<typename _RAIter, typename _Compare>\n-  _RAIter\n-  min_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, __gnu_parallel::parallelism);\n+    _RAIter\n+    min_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, \n+\t\t       __gnu_parallel::parallelism);\n \n   template<typename _RAIter>\n-  inline void\n+  void\n   nth_element(_RAIter, _RAIter, _RAIter, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter, typename _Compare>\n   void\n   nth_element(_RAIter, _RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter, typename _Compare>\n-  inline void\n+  void\n   nth_element(_RAIter, _RAIter, _RAIter, _Compare);\n \n   template<typename _RAIter>\n@@ -512,157 +602,157 @@ namespace __parallel\n   partial_sort(_RAIter, _RAIter, _RAIter);\n \n   template<typename _FIter, typename Predicate>\n-  inline _FIter\n+  _FIter\n   partition(_FIter, _FIter, Predicate, __gnu_parallel::sequential_tag);\n     \n   template<typename _FIter, typename Predicate>\n-  inline _FIter\n+  _FIter\n   partition(_FIter, _FIter, Predicate);\n \n-  template<typename _FIter, typename Predicate, typename IteratorTag>\n-  inline _FIter\n-  partition_switch(_FIter, _FIter, Predicate, IteratorTag);\n+  template<typename _FIter, typename Predicate, typename _IterTag>\n+  _FIter\n+  partition_switch(_FIter, _FIter, Predicate, _IterTag);\n     \n   template<typename _RAIter, typename Predicate>\n   _RAIter\n   partition_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag);\n \n   template<typename _RAIter>\n-  inline void\n+  void\n   random_shuffle(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter, typename RandomNumberGenerator>\n-  inline void\n+  void\n   random_shuffle(_RAIter, _RAIter, RandomNumberGenerator& rand, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter>\n-  inline void\n+  void\n   random_shuffle(_RAIter, _RAIter);\n \n   template<typename _RAIter, typename RandomNumberGenerator>\n   void\n   random_shuffle(_RAIter, _RAIter, RandomNumberGenerator& rand);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  inline _OIter\n+  _OIter\n   set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  inline _OIter\n+  _OIter\n   set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  inline _OIter \n+  _OIter \n   set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  inline _OIter \n+  _OIter \n   set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n-  inline _OIter \n-  set_union_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, IteratorTag1, IteratorTag2, IteratorTag3);\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename _IterTag1, typename _IterTag2, typename _IterTag3>\n+  _OIter \n+  set_union_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n   Output_RAIter \n   set_union_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  inline _OIter\n+  _OIter\n   set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  inline _OIter\n+  _OIter\n   set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  inline _OIter \n+  _OIter \n   set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  inline _OIter \n+  _OIter \n   set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n-  inline _OIter \n-  set_intersection_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, IteratorTag1, IteratorTag2, IteratorTag3);\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename _IterTag1, typename _IterTag2, typename _IterTag3>\n+  _OIter \n+  set_intersection_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n   Output_RAIter \n   set_intersection_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  inline _OIter\n+  _OIter\n   set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  inline _OIter\n+  _OIter\n   set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  inline _OIter \n+  _OIter \n   set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  inline _OIter \n+  _OIter \n   set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n-  inline _OIter \n-  set_symmetric_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, IteratorTag1, IteratorTag2, IteratorTag3);\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename _IterTag1, typename _IterTag2, typename _IterTag3>\n+  _OIter \n+  set_symmetric_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n   Output_RAIter \n   set_symmetric_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n \n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  inline _OIter\n+  _OIter\n   set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  inline _OIter\n+  _OIter\n   set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n-  inline _OIter\n+  _OIter\n   set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n-  inline _OIter\n+  _OIter\n   set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n-  inline _OIter\n-  set_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, IteratorTag1, IteratorTag2, IteratorTag3);\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename _IterTag1, typename _IterTag2, typename _IterTag3>\n+  _OIter\n+  set_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n   Output_RAIter\n   set_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n \n \n   template<typename _RAIter>\n-  inline void\n+  void\n   sort(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter, typename _Compare>\n-  inline void\n+  void\n   sort(_RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter>\n-  inline void\n+  void\n   sort(_RAIter, _RAIter);\n \n   template<typename _RAIter, typename _Compare>\n   void\n   sort(_RAIter, _RAIter, _Compare);\n \n   template<typename _RAIter>\n-  inline void\n+  void\n   stable_sort(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter, typename _Compare>\n-  inline void\n+  void\n   stable_sort(_RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter>\n@@ -674,46 +764,30 @@ namespace __parallel\n   stable_sort(_RAIter, _RAIter, _Compare);\n \n   template<typename _IIter, typename _OIter>\n-  inline _OIter\n+  _OIter\n   unique_copy(_IIter, _IIter, _OIter, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter, typename Predicate>\n-  inline _OIter\n+  _OIter\n   unique_copy(_IIter, _IIter, _OIter, Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter>\n-  inline _OIter\n+  _OIter\n   unique_copy(_IIter, _IIter, _OIter);\n \n   template<typename _IIter, typename _OIter, typename Predicate>\n-  inline _OIter\n+  _OIter\n   unique_copy(_IIter, _IIter, _OIter, Predicate);\n \n-  template<typename _IIter, typename _OIter, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n-  inline _OIter\n-  unique_copy_switch(_IIter, _IIter, _OIter, Predicate, IteratorTag1, IteratorTag2);\n+  template<typename _IIter, typename _OIter, typename Predicate, typename _IterTag1, typename _IterTag2>\n+  _OIter\n+  unique_copy_switch(_IIter, _IIter, _OIter, Predicate, _IterTag1, _IterTag2);\n \n   template<typename _RAIter, typename RandomAccess_OIter, typename Predicate>\n   RandomAccess_OIter\n-  unique_copy_switch(_RAIter, _RAIter, RandomAccess_OIter, Predicate, random_access_iterator_tag, random_access_iterator_tag);\n+  unique_copy_switch(_RAIter, _RAIter, RandomAccess_OIter, Predicate, \n+\t\t     random_access_iterator_tag, random_access_iterator_tag);\n } // end namespace __parallel\n } // end namespace std\n \n-// NB: cannot use _GLIBCXX_STD_P directly here, as it is both scoped\n-// (std::__norm) and unscoped (std::).\n-namespace __gnu_sequential\n-{\n-#ifdef _GLIBCXX_PARALLEL\n-  using std::__norm::partition;\n-  using std::__norm::sort;\n-  using std::__norm::stable_sort;\n-  using std::__norm::random_shuffle;\n-#else\n-  using std::partition;\n-  using std::sort;\n-  using std::stable_sort;\n-  using std::random_shuffle;    \n-#endif    \n-}\n-\n #endif"}, {"sha": "52fa600ddbac078c1a8c38afdf120849aa1ef47c", "filename": "libstdc++-v3/include/parallel/numeric", "status": "modified", "additions": 152, "deletions": 42, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -59,10 +59,10 @@ namespace __parallel\n   // Sequential fallback.\n   template<typename InputIterator, typename T>\n   inline T\n-  accumulate(InputIterator begin, InputIterator end, T init, __gnu_parallel::sequential_tag)\n+  accumulate(InputIterator begin, InputIterator end, T init, \n+\t     __gnu_parallel::sequential_tag)\n   { return _GLIBCXX_STD_P::accumulate(begin, end, init); }\n \n-  // Sequential fallback.\n   template<typename InputIterator, typename T, typename BinaryOperation>\n   inline T\n   accumulate(InputIterator begin, InputIterator end, T init,\n@@ -72,29 +72,25 @@ namespace __parallel\n   // Sequential fallback for input iterator case.\n   template<typename InputIterator, typename T, typename IteratorTag>\n   inline T\n-  accumulate_switch(InputIterator begin, InputIterator end, T init, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n-  { return accumulate(begin, end, init, __gnu_parallel::sequential_tag()); }\n+  accumulate_switch(InputIterator begin, InputIterator end, T init, IteratorTag)  { return accumulate(begin, end, init, __gnu_parallel::sequential_tag()); }\n \n-  // Public interface.\n-  template<typename InputIterator, typename T>\n-  inline T\n-  accumulate(InputIterator begin, InputIterator end, T init, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n-  {\n-    return accumulate_switch(begin, end, init, std::plus<typename std::iterator_traits<InputIterator>::value_type>(), typename std::iterator_traits<InputIterator>::iterator_category(), parallelism_tag);\n-  }\n-\n-  // Sequential fallback for input iterator case.\n   template<typename InputIterator, typename T, typename BinaryOperation, typename IteratorTag>\n   T\n-  accumulate_switch(InputIterator begin, InputIterator end, T init, BinaryOperation binary_op, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  accumulate_switch(InputIterator begin, InputIterator end, T init, \n+\t\t    BinaryOperation binary_op, IteratorTag)\n   {\n-    return accumulate(begin, end, init, binary_op, __gnu_parallel::sequential_tag());\n+    return accumulate(begin, end, init, binary_op, \n+\t\t      __gnu_parallel::sequential_tag());\n   }\n \n   // Parallel algorithm for random access iterators.\n   template<typename _RandomAccessIterator, typename T, typename BinaryOperation>\n   T\n-  accumulate_switch(_RandomAccessIterator begin, _RandomAccessIterator end, T init, BinaryOperation binary_op, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  accumulate_switch(_RandomAccessIterator begin, _RandomAccessIterator end, \n+\t\t    T init, BinaryOperation binary_op, \n+\t\t    random_access_iterator_tag, \n+\t\t    __gnu_parallel::parallelism parallelism_tag  \n+\t\t    = __gnu_parallel::parallel_unbalanced)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::accumulate_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n@@ -104,38 +100,81 @@ namespace __parallel\n \treturn res;\n       }\n     else\n-      return accumulate(begin, end, init, binary_op, __gnu_parallel::sequential_tag());\n+      return accumulate(begin, end, init, binary_op, \n+\t\t\t__gnu_parallel::sequential_tag());\n   }\n \n   // Public interface.\n-  template<typename InputIterator, typename T, typename BinaryOperation>\n+  template<typename InputIterator, typename T>\n   inline T\n-  accumulate(InputIterator begin, InputIterator end, T init, BinaryOperation binary_op, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n+  accumulate(InputIterator begin, InputIterator end, T init, \n+\t     __gnu_parallel::parallelism parallelism_tag)\n   {\n-    return accumulate_switch(begin, end, init, binary_op, typename std::iterator_traits<InputIterator>::iterator_category(), parallelism_tag);\n+    typedef std::iterator_traits<InputIterator> iterator_traits;\n+    typedef typename iterator_traits::value_type value_type;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+\n+    return accumulate_switch(begin, end, init, std::plus<value_type>(), \n+\t\t\t     iterator_category(), parallelism_tag);\n   }\n \n+  template<typename InputIterator, typename T>\n+  inline T\n+  accumulate(InputIterator begin, InputIterator end, T init)\n+  {\n+    typedef std::iterator_traits<InputIterator> iterator_traits;\n+    typedef typename iterator_traits::value_type value_type;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n \n-  // Sequential fallback.\n-  template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n+    return accumulate_switch(begin, end, init, std::plus<value_type>(), \n+\t\t\t     iterator_category());\n+  }\n+\n+  template<typename InputIterator, typename T, typename BinaryOperation>\n   inline T\n-  inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, __gnu_parallel::sequential_tag)\n+  accumulate(InputIterator begin, InputIterator end, T init, \n+\t     BinaryOperation binary_op, \n+\t     __gnu_parallel::parallelism parallelism_tag)\n   {\n-    return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init, binary_op1, binary_op2);\n+    typedef iterator_traits<InputIterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+    return accumulate_switch(begin, end, init, binary_op, \n+\t\t\t     iterator_category(), parallelism_tag);\n   }\n \n+  template<typename InputIterator, typename T, typename BinaryOperation>\n+  inline T\n+  accumulate(InputIterator begin, InputIterator end, T init, \n+\t     BinaryOperation binary_op) \n+  {\n+    typedef iterator_traits<InputIterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+    return accumulate_switch(begin, end, init, binary_op, \n+\t\t\t     iterator_category());\n+  }\n+\n+\n   // Sequential fallback.\n   template<typename InputIterator1, typename InputIterator2, typename T>\n   inline T\n-  inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, __gnu_parallel::sequential_tag)\n+  inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\tInputIterator2 first2, T init, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init); }\n+\n+  template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n+  inline T\n+  inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\tInputIterator2 first2, T init, BinaryFunction1 binary_op1, \n+\t\tBinaryFunction2 binary_op2, __gnu_parallel::sequential_tag)\n   {\n-    return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init);\n+    return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init, \n+\t\t\t\t\t binary_op1, binary_op2);\n   }\n \n   // Parallel algorithm for random access iterators.\n   template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n   T\n-  inner_product_switch(RandomAccessIterator1 first1, RandomAccessIterator1 last1, RandomAccessIterator2 first2, T init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  inner_product_switch(RandomAccessIterator1 first1, RandomAccessIterator1 last1, RandomAccessIterator2 first2, T init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION((last1 - first1) >= __gnu_parallel::Settings::accumulate_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n@@ -145,41 +184,80 @@ namespace __parallel\n \treturn res;\n       }\n     else\n-      return inner_product(first1, last1, first2, init, __gnu_parallel::sequential_tag());\n+      return inner_product(first1, last1, first2, init, \n+\t\t\t   __gnu_parallel::sequential_tag());\n   }\n \n   // No parallelism for input iterators.\n   template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2, typename IteratorTag1, typename IteratorTag2>\n   inline T\n-  inner_product_switch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, IteratorTag1, IteratorTag2, __gnu_parallel::parallelism parallelism_tag)\n+  inner_product_switch(InputIterator1 first1, InputIterator1 last1, \n+\t\t       InputIterator2 first2, T init, \n+\t\t       BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, \n+\t\t       IteratorTag1, IteratorTag2)\n   {\n-    return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init, binary_op1, binary_op2);\n+    return inner_product(first1, last1, first2, init, binary_op1, binary_op2,\n+\t\t\t __gnu_parallel::sequential_tag());\n+  }\n+\n+  template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n+  inline T\n+  inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\tInputIterator2 first2, T init, BinaryFunction1 binary_op1, \n+\t\tBinaryFunction2 binary_op2, \n+\t\t__gnu_parallel::parallelism parallelism_tag)\n+  {\n+    typedef iterator_traits<InputIterator1> traits1_type;\n+    typedef typename traits1_type::iterator_category iterator1_category;\n+\n+    typedef iterator_traits<InputIterator2> traits2_type;\n+    typedef typename traits2_type::iterator_category iterator2_category;\n+\n+    return inner_product_switch(first1, last1, first2, init, binary_op1, \n+\t\t\t\tbinary_op2, iterator1_category(), \n+\t\t\t\titerator2_category(), parallelism_tag);\n   }\n \n   template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n   inline T\n-  inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n+  inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\tInputIterator2 first2, T init, BinaryFunction1 binary_op1, \n+\t\tBinaryFunction2 binary_op2)\n   {\n     typedef iterator_traits<InputIterator1> traits1_type;\n     typedef typename traits1_type::iterator_category iterator1_category;\n \n     typedef iterator_traits<InputIterator2> traits2_type;\n     typedef typename traits2_type::iterator_category iterator2_category;\n \n-    return inner_product_switch(first1, last1, first2, init, binary_op1, binary_op2, iterator1_category(), iterator2_category(), parallelism_tag);\n+    return inner_product_switch(first1, last1, first2, init, binary_op1, \n+\t\t\t\tbinary_op2, iterator1_category(),\n+\t\t\t\titerator2_category());\n   }\n \n   template<typename InputIterator1, typename InputIterator2, typename T>\n   inline T\n-  inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n+  inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\tInputIterator2 first2, T init, \n+\t\t__gnu_parallel::parallelism parallelism_tag)\n   {\n     typedef iterator_traits<InputIterator1> traits_type;\n     typedef typename traits_type::value_type value_type;\n-\n     return inner_product(first1, last1, first2, init, std::plus<value_type>(), \n \t\t\t std::multiplies<value_type>(), parallelism_tag);\n   }\n \n+  template<typename InputIterator1, typename InputIterator2, typename T>\n+  inline T\n+  inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\tInputIterator2 first2, T init)\n+  {\n+    typedef iterator_traits<InputIterator1> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    return inner_product(first1, last1, first2, init, std::plus<value_type>(), \n+\t\t\t std::multiplies<value_type>());\n+  }\n+\n   // Sequential fallback.\n   template<typename InputIterator, typename OutputIterator>\n   inline OutputIterator\n@@ -262,16 +340,21 @@ namespace __parallel\n   inline OutputIterator\n   adjacent_difference_switch(InputIterator begin, InputIterator end,\n \t\t\t     OutputIterator result, BinaryOperation bin_op,\n-\t\t\t     IteratorTag1, IteratorTag2, __gnu_parallel::parallelism)\n-  { return adjacent_difference(begin, end, result, bin_op); }\n+\t\t\t     IteratorTag1, IteratorTag2)\n+  { \n+    return adjacent_difference(begin, end, result, bin_op,  \n+\t\t\t       __gnu_parallel::sequential_tag()); \n+  }\n \n   // Parallel algorithm for random access iterators.\n   template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n   OutputIterator\n   adjacent_difference_switch(InputIterator begin, InputIterator end,\n \t\t\t     OutputIterator result, BinaryOperation bin_op,\n-\t\t\t     random_access_iterator_tag, random_access_iterator_tag,\n-\t\t\t     __gnu_parallel::parallelism parallelism_tag)\n+\t\t\t     random_access_iterator_tag, \n+\t\t\t     random_access_iterator_tag,\n+\t\t\t     __gnu_parallel::parallelism parallelism_tag\n+\t\t\t     = __gnu_parallel::parallel_balanced)\n   {\n     if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::adjacent_difference_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n       {\n@@ -284,27 +367,38 @@ namespace __parallel\n \treturn functionality.finish_iterator;\n       }\n     else\n-      return adjacent_difference(begin, end, result, bin_op, __gnu_parallel::sequential_tag());\n+      return adjacent_difference(begin, end, result, bin_op, \n+\t\t\t\t __gnu_parallel::sequential_tag());\n   }\n \n   // Public interface.\n   template<typename InputIterator, typename OutputIterator>\n   inline OutputIterator\n   adjacent_difference(InputIterator begin, InputIterator end,\n \t\t      OutputIterator result,\n-\t\t      __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+\t\t      __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    typedef iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    return adjacent_difference(begin, end, result, std::minus<value_type>(), \n+\t\t\t       parallelism_tag);\n+  }\n+\n+  template<typename InputIterator, typename OutputIterator>\n+  inline OutputIterator\n+  adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t      OutputIterator result)\n   {\n     typedef iterator_traits<InputIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     return adjacent_difference(begin, end, result, std::minus<value_type>());\n   }\n \n-  // Public interface.\n   template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n   inline OutputIterator\n   adjacent_difference(InputIterator begin, InputIterator end,\n \t\t      OutputIterator result, BinaryOperation binary_op,\n-\t\t      __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+\t\t      __gnu_parallel::parallelism parallelism_tag)\n   {\n     typedef iterator_traits<InputIterator> traitsi_type;\n     typedef typename traitsi_type::iterator_category iteratori_category;\n@@ -316,6 +410,22 @@ namespace __parallel\n \t\t\t\t      iteratori_category(), \n \t\t\t\t      iteratoro_category(), parallelism_tag);\n   }\n+\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+  inline OutputIterator\n+  adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t      OutputIterator result, BinaryOperation binary_op)\n+  {\n+    typedef iterator_traits<InputIterator> traitsi_type;\n+    typedef typename traitsi_type::iterator_category iteratori_category;\n+\n+    typedef iterator_traits<OutputIterator> traitso_type;\n+    typedef typename traitso_type::iterator_category iteratoro_category;\n+\n+    return adjacent_difference_switch(begin, end, result, binary_op,\n+\t\t\t\t      iteratori_category(), \n+\t\t\t\t      iteratoro_category());\n+  }\n } // end namespace\n } // end namespace\n "}, {"sha": "4181132c13a87cf0eba47cf5ac6191d1389df03e", "filename": "libstdc++-v3/include/parallel/numericfwd.h", "status": "modified", "additions": 59, "deletions": 21, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -46,81 +46,119 @@ namespace __parallel\n {\n   template<typename _IIter, typename T>\n   inline T\n-  accumulate(_IIter, _IIter, T, __gnu_parallel::sequential_tag);\n+  accumulate(_IIter, _IIter, T);\n \n-  template<typename _IIter, typename T, typename _BinaryOper>\n+  template<typename _IIter, typename T>\n   inline T\n-  accumulate(_IIter, _IIter, T, _BinaryOper, __gnu_parallel::sequential_tag);\n+  accumulate(_IIter, _IIter, T, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename T>\n   inline T\n-  accumulate(_IIter, _IIter, T, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+  accumulate(_IIter, _IIter, T, __gnu_parallel::parallelism parallelism_tag);\n+\n+  template<typename _IIter, typename T, typename _Tag>\n+  inline T\n+  accumulate_switch(_IIter, _IIter, T, _Tag);\n \n   template<typename _IIter, typename T, typename _BinaryOper>\n   inline T\n-  accumulate(_IIter, _IIter, T, _BinaryOper, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+  accumulate(_IIter, _IIter, T, _BinaryOper);\n \n-  template<typename _IIter, typename T, typename _Tag>\n+  template<typename _IIter, typename T, typename _BinaryOper>\n   inline T\n-  accumulate_switch(_IIter, _IIter, T, _Tag, __gnu_parallel::parallelism parallelism_tag);\n+  accumulate(_IIter, _IIter, T, _BinaryOper, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename T, typename _BinaryOper>\n+  inline T\n+  accumulate(_IIter, _IIter, T, _BinaryOper, \n+\t     __gnu_parallel::parallelism parallelism_tag);\n \n   template<typename _IIter, typename T, typename _BinaryOper, typename _Tag>\n   T\n-  accumulate_switch(_IIter, _IIter, T, _BinaryOper, _Tag, __gnu_parallel::parallelism parallelism_tag);\n+  accumulate_switch(_IIter, _IIter, T, _BinaryOper, _Tag);\n \n   template<typename _RAIter, typename T, typename _BinaryOper>\n   T\n-  accumulate_switch(_RAIter, _RAIter, T, _BinaryOper, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag);\n+  accumulate_switch(_RAIter, _RAIter, T, _BinaryOper, \n+\t\t    random_access_iterator_tag, __gnu_parallel::parallelism);\n+\n \n+ template<typename _IIter, typename _OIter>\n+  inline _OIter\n+  adjacent_difference(_IIter, _IIter, _OIter);\n+\n+  template<typename _IIter, typename _OIter, typename _BinaryOper>\n+  inline _OIter\n+  adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper);\n \n   template<typename _IIter, typename _OIter>\n   inline _OIter\n   adjacent_difference(_IIter, _IIter, _OIter, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n   inline _OIter\n-  adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, __gnu_parallel::sequential_tag);\n+  adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, \n+\t\t      __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter>\n   inline _OIter\n-  adjacent_difference(_IIter, _IIter, _OIter, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+  adjacent_difference(_IIter, _IIter, _OIter, __gnu_parallel::parallelism);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n   inline _OIter\n-  adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+  adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, \n+\t\t      __gnu_parallel::parallelism);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper, typename _Tag1, typename _Tag2>\n   inline _OIter\n-  adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, _Tag1, _Tag2, __gnu_parallel::parallelism);\n+  adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, _Tag1, _Tag2);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n   _OIter\n-  adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag);\n+  adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, \n+\t\t\t     random_access_iterator_tag, \n+\t\t\t     random_access_iterator_tag, \n+\t\t\t     __gnu_parallel::parallelism);\n \n \n-  template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n+  template<typename _IIter1, typename _IIter2, typename T>\n   inline T\n-  inner_product(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2, __gnu_parallel::sequential_tag);\n+  inner_product(_IIter1, _IIter1, _IIter2, T);\n \n   template<typename _IIter1, typename _IIter2, typename T>\n   inline T\n   inner_product(_IIter1, _IIter1, _IIter2, T, __gnu_parallel::sequential_tag);\n \n+  template<typename _IIter1, typename _IIter2, typename T>\n+  inline T\n+  inner_product(_IIter1, _IIter1, _IIter2, T, __gnu_parallel::parallelism);\n+\n+\n   template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n   inline T\n-  inner_product(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+  inner_product(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2);\n \n-  template<typename _IIter1, typename _IIter2, typename T>\n+  template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n+  inline T\n+  inner_product(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2,\n+\t\t__gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n   inline T\n-  inner_product(_IIter1, _IIter1, _IIter2, T, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+  inner_product(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2,\n+\t\t__gnu_parallel::parallelism);\n \n   template<typename _RAIter1, typename _RAIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n   T\n-  inner_product_switch(_RAIter1, _RAIter1, _RAIter2, T, BinaryFunction1, BinaryFunction2, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag);\n+  inner_product_switch(_RAIter1, _RAIter1, _RAIter2, T, BinaryFunction1, \n+\t\t       BinaryFunction2, random_access_iterator_tag, \n+\t\t       random_access_iterator_tag, \n+\t\t       __gnu_parallel::parallelism);\n \n   template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2, typename _Tag1, typename _Tag2>\n   inline T\n-  inner_product_switch(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2, _Tag1, _Tag2, __gnu_parallel::parallelism parallelism_tag);\n+  inner_product_switch(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, \n+\t\t       BinaryFunction2, _Tag1, _Tag2);\n \n \n   template<typename _IIter, typename _OIter>"}, {"sha": "7a0f9a164cfd8b76288510b6f04115b0de099b39", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -39,12 +39,8 @@\n #define _GLIBCXX_PARALLEL_RANDOM_SHUFFLE_H 1\n \n #include <limits>\n-\n-#include <parallel/basic_iterator.h>\n-#include <bits/stl_algo.h>\n-\n+#include <bits/stl_numeric.h>\n #include <parallel/parallel.h>\n-#include <parallel/base.h>\n #include <parallel/random_number.h>\n #include <parallel/timing.h>\n \n@@ -125,15 +121,16 @@ namespace __gnu_parallel\n    *  @param rng Random number generator to use.\n    */\n   template<typename RandomNumberGenerator>\n-  inline int random_number_pow2(int logp, RandomNumberGenerator& rng)\n-  {\n-    return rng.genrand_bits(logp);\n-  }\n+  inline int\n+  random_number_pow2(int logp, RandomNumberGenerator& rng)\n+  { return rng.genrand_bits(logp); }\n \n   /** @brief Random shuffle code executed by each thread.\n    *  @param pus Array of thread-local data records. */\n   template<typename RandomAccessIterator, typename RandomNumberGenerator>\n-  inline void parallel_random_shuffle_drs_pu(DRSSorterPU<RandomAccessIterator, RandomNumberGenerator>* pus)\n+  inline void \n+  parallel_random_shuffle_drs_pu(DRSSorterPU<RandomAccessIterator, \n+\t\t\t\t RandomNumberGenerator>* pus)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n@@ -184,7 +181,9 @@ namespace __gnu_parallel\n       // Sum up bins, sd->dist[s + 1][d->num_threads] now contains the\n       // total number of items in bin s\n       for (bin_index s = 0; s < sd->num_bins; s++)\n-\tpartial_sum(sd->dist[s + 1], sd->dist[s + 1] + d->num_threads + 1, sd->dist[s + 1]);\n+\t__gnu_sequential::partial_sum(sd->dist[s + 1],\n+\t\t\t\t      sd->dist[s + 1] + d->num_threads + 1,\n+\t\t\t\t      sd->dist[s + 1]);\n     }\n \n #pragma omp barrier\n@@ -263,7 +262,8 @@ namespace __gnu_parallel\n   /** @brief Round up to the next greater power of 2.\n    *  @param x Integer to round up */\n   template<typename T>\n-  T round_up_to_pow2(T x)\n+  T \n+  round_up_to_pow2(T x)\n   {\n     if (x <= 1)\n       return 1;\n@@ -396,7 +396,9 @@ namespace __gnu_parallel\n    */\n   template<typename RandomAccessIterator, typename RandomNumberGenerator>\n   inline void\n-  sequential_random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator& rng)\n+  sequential_random_shuffle(RandomAccessIterator begin, \n+\t\t\t    RandomAccessIterator end, \n+\t\t\t    RandomNumberGenerator& rng)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n@@ -468,7 +470,7 @@ namespace __gnu_parallel\n \tt.tic();\n \n \t// Sum up bins.\n-\tpartial_sum(dist0, dist0 + num_bins + 1, dist0);\n+\t__gnu_sequential::partial_sum(dist0, dist0 + num_bins + 1, dist0);\n \n \tfor (int b = 0; b < num_bins + 1; b++)\n \t  dist1[b] = dist0[b];\n@@ -503,7 +505,8 @@ namespace __gnu_parallel\n    */\n   template<typename RandomAccessIterator, typename RandomNumberGenerator>\n   inline void\n-  parallel_random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator rng = random_number())\n+  parallel_random_shuffle(RandomAccessIterator begin, RandomAccessIterator end,\n+\t\t\t  RandomNumberGenerator rng = random_number())\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::difference_type difference_type;"}, {"sha": "91a049fcbe853afe989f410af2fffbeac9f1b991", "filename": "libstdc++-v3/include/parallel/search.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -55,7 +55,8 @@ namespace __gnu_parallel\n    */\n   template<typename RandomAccessIterator, typename _DifferenceTp>\n   void\n-  calc_borders(RandomAccessIterator elements, _DifferenceTp length, _DifferenceTp* off)\n+  calc_borders(RandomAccessIterator elements, _DifferenceTp length, \n+\t       _DifferenceTp* off)\n   {\n     typedef _DifferenceTp difference_type;\n \n@@ -65,7 +66,7 @@ namespace __gnu_parallel\n     difference_type k = 0;\n     for (difference_type j = 2; j <= length; j++)\n       {\n-\twhile ((k >= 0) && (elements[k] != elements[j-1]))\n+\twhile ((k >= 0) && !(elements[k] == elements[j-1]))\n \t  k = off[k];\n \toff[j] = ++k;\n       }"}, {"sha": "c3d33e882c67f96187f11969b5851daa4a8f641a", "filename": "libstdc++-v3/include/parallel/tags.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -49,7 +49,14 @@ namespace std\n  * @namespace __gnu_sequential\n  * @brief GNU sequential classes for public use.\n  */\n-namespace __gnu_sequential { }\n+namespace __gnu_sequential \n+{ \n+#ifdef _GLIBCXX_PARALLEL\n+  using namespace std::__norm;\n+#else\n+  using namespace std;\n+#endif   \n+}\n \n /**\n  * @namespace __gnu_parallel"}, {"sha": "9b2efc46dae1d9c37970eeacdb5b775f74fef70f", "filename": "libstdc++-v3/include/parallel/tree.h", "status": "modified", "additions": 136, "deletions": 87, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f95a65aa12189f267de958ceb995f40e603131e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h?ref=6f95a65aa12189f267de958ceb995f40e603131e", "patch": "@@ -159,7 +159,8 @@ namespace __gnu_parallel\n    *  @param _Alloc Allocator for the elements */\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n \t   typename _Compare, typename _Alloc = std::allocator<_Val> >\n-  class _Rb_tree : public std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>\n+  class _Rb_tree \n+  : public std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>\n   {\n   private:\n     /** @brief Sequential tree */\n@@ -214,7 +215,8 @@ namespace __gnu_parallel\n      * @param a Allocator object with which to initialize the class comparator\n      */\n     _Rb_tree(const _Compare& c, const _Alloc& a)\n-    : base_type(c, a), strictly_less(base_type::_M_impl._M_key_compare), less_equal(base_type::_M_impl._M_key_compare)\n+    : base_type(c, a), strictly_less(base_type::_M_impl._M_key_compare), \n+      less_equal(base_type::_M_impl._M_key_compare)\n     { }\n \n     /** @brief Copy constructor.\n@@ -224,7 +226,8 @@ namespace __gnu_parallel\n      * @param __x Parallel red-black instance to copy\n      */\n     _Rb_tree(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)\n-    : base_type(__x), strictly_less(base_type::_M_impl._M_key_compare), less_equal(base_type::_M_impl._M_key_compare)\n+    : base_type(__x), strictly_less(base_type::_M_impl._M_key_compare), \n+      less_equal(base_type::_M_impl._M_key_compare)\n     { }\n \n     /** @brief Parallel replacement of the sequential\n@@ -244,12 +247,14 @@ namespace __gnu_parallel\n       if (_GLIBCXX_PARALLEL_CONDITION(true))\n \tif (base_type::_M_impl._M_node_count == 0)\n \t  {\n-\t    _M_bulk_insertion_construction(__first, __last, true, strictly_less);\n+\t    _M_bulk_insertion_construction(__first, __last, true, \n+\t\t\t\t\t   strictly_less);\n \t    _GLIBCXX_PARALLEL_ASSERT(rb_verify());\n \t  }\n \telse\n \t  {\n-\t    _M_bulk_insertion_construction(__first, __last, false, strictly_less);\n+\t    _M_bulk_insertion_construction(__first, __last, false, \n+\t\t\t\t\t   strictly_less);\n \t    _GLIBCXX_PARALLEL_ASSERT(rb_verify());\n \t  }\n       else\n@@ -293,8 +298,9 @@ namespace __gnu_parallel\n     class nodes_initializer\n     {\n       /** @brief Renaming of tree size_type */\n-\n-      typedef typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type size_type;\n+      \n+      typedef _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> tree_type;\n+      typedef typename tree_type::size_type size_type;\n     public:\n \n       /** @brief mask[%i]= 0..01..1, where the number of 1s is %i+1 */\n@@ -328,7 +334,8 @@ namespace __gnu_parallel\n        * @param _n Total number of (used) nodes\n        * @param _num_threads Number of threads into which divide the work\n        * @param _rank Helper object to mind potential gaps in @c r_init */\n-      nodes_initializer(const _Rb_tree_node_ptr* r, const size_type _n, const thread_index_t _num_threads, const ranker& _rank):\n+      nodes_initializer(const _Rb_tree_node_ptr* r, const size_type _n, \n+\t\t\tconst thread_index_t _num_threads, const ranker& _rank):\n \tr_init(r),\n \tn(_n),\n \tnum_threads(_num_threads),\n@@ -352,24 +359,21 @@ namespace __gnu_parallel\n \n       /** @brief Query for tree height\n        * @return Tree height */\n-      int get_height() const\n-      {\n-\treturn height;\n-      }\n+      int \n+      get_height() const\n+      { return height; }\n \n       /** @brief Query for the splitting point\n        * @return Splitting point */\n-      size_type get_shifted_splitting_point() const\n-      {\n-\treturn rank.get_shifted_rank(splitting_point, 0);\n-      }\n+      size_type \n+      get_shifted_splitting_point() const\n+      { return rank.get_shifted_rank(splitting_point, 0); }\n \n       /** @brief Query for the tree root node\n        * @return Tree root node */\n-      _Rb_tree_node_ptr get_root() const\n-      {\n-\treturn  r_init[rank.get_shifted_rank(rank_root,num_threads/2)];\n-      }\n+      _Rb_tree_node_ptr \n+      get_root() const\n+      { return  r_init[rank.get_shifted_rank(rank_root,num_threads/2)]; }\n \n       /** @brief Calculation of the parent position in the array of nodes\n        * @hideinitializer */\n@@ -386,7 +390,8 @@ namespace __gnu_parallel\n        * @param iam Partition of the array in which the node is, where\n        * iam is in [0..num_threads)\n        * @sa link_complete */\n-      void link_incomplete(const _Rb_tree_node_ptr& r, const int iam) const\n+      void \n+      link_incomplete(const _Rb_tree_node_ptr& r, const int iam) const\n       {\n \tsize_type real_pos = rank.get_real_rank(&r-r_init, iam);\n \tsize_type l_s, r_s, p_s;\n@@ -438,7 +443,8 @@ namespace __gnu_parallel\n        * iam is in [0..@c num_threads)\n        * @sa link_incomplete\n        */\n-      void link_complete(const _Rb_tree_node_ptr& r, const int iam) const\n+      void \n+      link_complete(const _Rb_tree_node_ptr& r, const int iam) const\n       {\n \tsize_type real_pos = rank.get_real_rank(&r-r_init, iam);\n \tsize_type p_s;\n@@ -477,20 +483,18 @@ namespace __gnu_parallel\n        * @param pos Rank in the actual incomplete tree\n        * @return Rank in the corresponding complete tree\n        * @sa complete_to_original  */\n-      int original_to_complete(const int pos) const\n-      {\n-\treturn (pos << 1) - splitting_point;\n-      }\n+      int \n+      original_to_complete(const int pos) const\n+      { return (pos << 1) - splitting_point; }\n \n       /** @brief Change of \"base\": Convert the rank if the tree was\n \t  complete into the corresponding rank in the actual tree\n        * @param pos Rank in the complete tree\n        * @return Rank in the actual incomplete tree\n        * @sa original_to_complete */\n-      int complete_to_original(const int pos) const\n-      {\n-\treturn (pos + splitting_point) >> 1;\n-      }\n+      int \n+      complete_to_original(const int pos) const\n+      { return (pos + splitting_point) >> 1; }\n \n \n       /** @brief Calculate the rank in the complete tree of the parent\n@@ -506,7 +510,10 @@ namespace __gnu_parallel\n        * @param parent_shift Rank in the complete tree of the parent\n        * of pos (out parameter)\n        */\n-      void calculate_shifts_pos_level(const size_type pos, const int level, size_type& left_shift, size_type& right_shift, size_type& parent_shift) const\n+      void \n+      calculate_shifts_pos_level(const size_type pos, const int level, \n+\t\t\t\t size_type& left_shift, size_type& right_shift,\n+\t\t\t\t size_type& parent_shift) const\n       {\n \tint stride =  1 << (level -1);\n \tleft_shift = pos - stride;\n@@ -523,7 +530,8 @@ namespace __gnu_parallel\n        * @return Position of the first 0 bit in @c x (starting to\n        * count with 1)\n        */\n-      int first_0_right(const size_type x) const\n+      int \n+      first_0_right(const size_type x) const\n       {\n \tif ((x & 0x2) == 0)\n \t  return 1;\n@@ -540,7 +548,8 @@ namespace __gnu_parallel\n        * whose first 0 bit must be calculated\n        * @param k_beg Position in which to start searching. By default is 2.\n        * @return Position of the first 0 bit in x (starting to count with 1) */\n-      int first_0_right_bs(const size_type x, int k_beg=2) const\n+      int \n+      first_0_right_bs(const size_type x, int k_beg=2) const\n       {\n \tint k_end = sizeof(size_type)*8;\n \tsize_type not_x = x ^ mask[k_end-1];\n@@ -566,7 +575,8 @@ namespace __gnu_parallel\n     class ranker_gaps\n     {\n       /** @brief Renaming of tree's size_type */\n-      typedef typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type size_type;\n+      typedef _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> tree_type;\n+      typedef typename tree_type::size_type size_type;\n \n       /** @brief Array containing the beginning ranks of all the\n \t  num_threads partitions just considering the valid nodes, not\n@@ -594,7 +604,8 @@ namespace __gnu_parallel\n        * gaps at the beginning of each partition\n        * @param _num_threads Number of partitions (and threads that\n        * work on it) */\n-      ranker_gaps(const size_type* size_p, const size_type* shift_r, const thread_index_t _num_threads) :\n+      ranker_gaps(const size_type* size_p, const size_type* shift_r, \n+\t\t  const thread_index_t _num_threads) :\n \tbeg_shift_partition(size_p),\n \trank_shift(shift_r),\n \tnum_threads(_num_threads)\n@@ -616,9 +627,7 @@ namespace __gnu_parallel\n        * been allocated for beg_partition array\n        */\n       ~ranker_gaps()\n-      {\n-\tdelete[] beg_partition;\n-      }\n+      { delete[] beg_partition; }\n \n       /** @brief Convert a rank in the array of nodes considering\n \t  valid nodes and gaps, to the corresponding considering only\n@@ -628,10 +637,9 @@ namespace __gnu_parallel\n        * @return Rank in the array of nodes considering only the valid nodes\n        * @sa get_shifted_rank\n        */\n-      size_type get_real_rank(const size_type pos, const int index) const\n-      {\n-\treturn pos - rank_shift[index];\n-      }\n+      size_type \n+      get_real_rank(const size_type pos, const int index) const\n+      { return pos - rank_shift[index]; }\n \n       /** @brief Inverse of get_real_rank: Convert a rank in the array\n \t  of nodes considering only valid nodes, to the corresponding\n@@ -644,7 +652,8 @@ namespace __gnu_parallel\n        * @post 0 <= @c return <= number_of_elements\n        * @sa get_real_rank()\n        */\n-      size_type get_shifted_rank(const size_type pos, const int index) const\n+      size_type \n+      get_shifted_rank(const size_type pos, const int index) const\n       {\n \t// Heuristic.\n \tif (beg_partition[index] <= pos and pos < beg_partition[index+1])\n@@ -662,7 +671,8 @@ namespace __gnu_parallel\n        * if there were no gaps\n        * @return Rank in the array of nodes considering valid nodes and gaps\n        */\n-      size_type get_shifted_rank_loop(const size_type pos, int index) const\n+      size_type \n+      get_shifted_rank_loop(const size_type pos, int index) const\n       {\n \twhile (pos >= beg_partition[index+1])\n \t  ++index;\n@@ -681,7 +691,8 @@ namespace __gnu_parallel\n     class ranker_no_gaps\n     {\n       /** @brief Renaming of tree's size_type */\n-      typedef typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type size_type;\n+      typedef _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> tree_type;\n+      typedef typename tree_type::size_type size_type;\n \n     public:\n       /** @brief Convert a rank in the array of nodes considering\n@@ -693,10 +704,9 @@ namespace __gnu_parallel\n        * @param pos Rank in the array of nodes considering valid nodes and gaps\n        * @param index Partition which the rank belongs to, unused here\n        * @return Rank in the array of nodes considering only the valid nodes */\n-      size_type get_real_rank(const size_type pos, const int index) const\n-      {\n-\treturn pos;\n-      }\n+      size_type \n+      get_real_rank(const size_type pos, const int index) const\n+      { return pos; }\n \n       /** @brief Inverse of get_real_rank: Convert a rank in the array\n        * of nodes considering only valid nodes, to the corresponding\n@@ -708,10 +718,9 @@ namespace __gnu_parallel\n        * @param index Partition which the rank belongs to, unused here\n        * @return Rank in the array of nodes considering valid nodes and gaps\n        */\n-      size_type get_shifted_rank(const size_type pos, const int index) const\n-      {\n-\treturn pos;\n-      }\n+      size_type \n+      get_shifted_rank(const size_type pos, const int index) const\n+      { return pos; }\n     };\n \n \n@@ -777,7 +786,8 @@ namespace __gnu_parallel\n        * the element pointed by the the class member @c prev */\n       void operator()(const _InputIterator it)\n       {\n-\tif (sorted and it != prev and comp(_KeyOfValue()(*it),_KeyOfValue()(*prev)))\n+\tif (sorted and it != prev and comp(_KeyOfValue()(*it),\n+\t\t\t\t\t   _KeyOfValue()(*prev)))\n \t  sorted = false;\n \tprev = it;\n       }\n@@ -840,8 +850,10 @@ namespace __gnu_parallel\n       { return c(k, base_type::_S_key(r)); }\n     };\n \n-    /** @brief Helper comparator: compare a key with the key of a value pointed by an iterator\n-     * @param _Comparator Comparator for keys */\n+    /** @brief Helper comparator: compare a key with the key of a\n+\tvalue pointed by an iterator\n+     * @param _Comparator Comparator for keys \n+     */\n     template<typename _Iterator, typename _Comparator>\n     struct compare_value_key\n     {\n@@ -914,7 +926,8 @@ namespace __gnu_parallel\n      * @param Comparator Comparator for values\n      * @param _ValuePtr Pointer to values */\n     template<typename Comparator, typename _ValuePtr>\n-    class PtrComparator : public std::binary_function<_ValuePtr, _ValuePtr, bool>\n+    class PtrComparator \n+    : public std::binary_function<_ValuePtr, _ValuePtr, bool>\n     {\n       /** @brief Comparator for values */\n       Comparator comp;\n@@ -1108,11 +1121,9 @@ namespace __gnu_parallel\n        * @param _par_problem Parent concatenation problem to solve\n        * when @c is_ready = READY_YES\n        */\n-      concat_problem(const _Rb_tree_node_ptr _t, const int _black_h, concat_problem* _par_problem):\n-\tt(_t),\n-\tblack_h(_black_h),\n-\tis_ready(READY_NO),\n-\tpar_problem(_par_problem)\n+      concat_problem(const _Rb_tree_node_ptr _t, const int _black_h, \n+\t\t     concat_problem* _par_problem)\n+      : t(_t), black_h(_black_h), is_ready(READY_NO), par_problem(_par_problem)\n       {\n \t// The root of an insertion problem must be black.\n \tif (t != NULL and t->_M_color == std::_S_red)\n@@ -1131,7 +1142,8 @@ namespace __gnu_parallel\n     struct insertion_problem\n     {\n       /** @brief Renaming of _Rb_tree @c size_type */\n-      typedef typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type size_type;\n+      typedef _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> tree_type;\n+      typedef typename tree_type::size_type size_type;\n \n       /** @brief Root of the tree where the elements are to be inserted */\n       _Rb_tree_node_ptr t;\n@@ -1166,8 +1178,10 @@ namespace __gnu_parallel\n        * @param _conc Concatenation problem to solve once the\n        * insertion problem is finished\n        */\n-      insertion_problem(const size_type b, const size_type e, const int array_p, concat_problem* _conc)\n-      : t(_conc->t), pos_beg(b), pos_end(e), array_partition(array_p), conc(_conc)\n+      insertion_problem(const size_type b, const size_type e, \n+\t\t\tconst int array_p, concat_problem* _conc)\n+      : t(_conc->t), pos_beg(b), pos_end(e), array_partition(array_p), \n+\tconc(_conc)\n       {\n \t_GLIBCXX_PARALLEL_ASSERT(pos_beg <= pos_end);\n \n@@ -1233,9 +1247,11 @@ namespace __gnu_parallel\n \t    }\n \n \t  if (is_construction)\n-\t    _M_sorted_bulk_construction(access, beg_partition, n, num_threads, strictly_less_or_less_equal);\n+\t    _M_sorted_bulk_construction(access, beg_partition, n, num_threads, \n+\t\t\t\t\tstrictly_less_or_less_equal);\n \t  else\n-\t    _M_sorted_bulk_insertion(access, beg_partition, n, num_threads, strictly_less_or_less_equal);\n+\t    _M_sorted_bulk_insertion(access, beg_partition, n, num_threads, \n+\t\t\t\t     strictly_less_or_less_equal);\n \t}\n \n       t.tic(\"main work\");\n@@ -1262,15 +1278,18 @@ namespace __gnu_parallel\n      * @param is_construction If true, the tree was empty and so, this\n      * is constructed. Otherwise, the elements are added to an\n      * existing tree.\n-     * @param strictly_less_or_less_equal Comparator to deal transparently with repetitions with respect to the uniqueness of the wrapping container */\n+     * @param strictly_less_or_less_equal Comparator to deal\n+     * transparently with repetitions with respect to the uniqueness\n+     * of the wrapping container \n+     */\n     template<typename _InputIterator, typename StrictlyLessOrLessEqual>\n     void\n     _M_not_sorted_bulk_insertion_construction(_InputIterator* access,\n \t\t\t\t\t      size_type* beg_partition,\n \t\t\t\t\t      const size_type n,\n \t\t\t\t\t      const thread_index_t num_threads,\n \t\t\t\t\t      const bool is_construction,\n-\t\t\t\t\t      StrictlyLessOrLessEqual strictly_less_or_less_equal)\n+\t\t\t   StrictlyLessOrLessEqual strictly_less_or_less_equal)\n     {\n       // Copy entire elements. In the case of a map, we would be\n       // copying the pair. Therefore, the copy should be reconsidered\n@@ -1360,7 +1379,8 @@ namespace __gnu_parallel\n      * @param black_h Black height of the resulting tree (out)\n      */\n     static _Rb_tree_node_ptr\n-    simple_tree_construct(_Rb_tree_node_ptr* r_array, const size_type pos_beg, const size_type pos_end, int& black_h)\n+    simple_tree_construct(_Rb_tree_node_ptr* r_array, const size_type pos_beg, \n+\t\t\t  const size_type pos_end, int& black_h)\n     {\n       if (pos_beg == pos_end)\n \t{\n@@ -1416,7 +1436,8 @@ namespace __gnu_parallel\n      * going to be shared\n      */\n     template<typename _Iterator>\n-    _Rb_tree_node_ptr* _M_unsorted_bulk_allocation_and_initialization(const _Iterator* access, const size_type* beg_partition, const size_type n, const thread_index_t num_threads)\n+    _Rb_tree_node_ptr* \n+    _M_unsorted_bulk_allocation_and_initialization(const _Iterator* access, const size_type* beg_partition, const size_type n, const thread_index_t num_threads)\n     {\n       _Rb_tree_node_ptr* r = static_cast<_Rb_tree_node_ptr*> (::operator new (sizeof(_Rb_tree_node_ptr)*(n+1)));\n \n@@ -1471,7 +1492,8 @@ namespace __gnu_parallel\n      * of the wrapping container\n      */\n     template<typename _Iterator, typename StrictlyLessOrLessEqual>\n-    _Rb_tree_node_ptr* _M_sorted_bulk_allocation_and_initialization(_Iterator* access, size_type*  beg_partition, size_type* rank_shift, const size_type n, thread_index_t& num_threads, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n+    _Rb_tree_node_ptr* \n+    _M_sorted_bulk_allocation_and_initialization(_Iterator* access, size_type*  beg_partition, size_type* rank_shift, const size_type n, thread_index_t& num_threads, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n     {\n       // Ghost node at the end to avoid extra comparisons in nodes_initializer.\n       _Rb_tree_node_ptr* r = static_cast<_Rb_tree_node_ptr*> (::operator new (sizeof(_Rb_tree_node_ptr)*(n+1)));\n@@ -1598,7 +1620,8 @@ namespace __gnu_parallel\n      * of the wrapping container\n      */\n     template<typename _Iterator, typename StrictlyLessOrLessEqual>\n-    _Rb_tree_node_ptr* _M_sorted_no_gapped_bulk_allocation_and_initialization(_Iterator* access, size_type* beg_partition, size_type& n, const thread_index_t num_threads, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n+    _Rb_tree_node_ptr* \n+    _M_sorted_no_gapped_bulk_allocation_and_initialization(_Iterator* access, size_type* beg_partition, size_type& n, const thread_index_t num_threads, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n     {\n       size_type* sums = static_cast<size_type*> (::operator new (sizeof(size_type)*n));\n       // Allocate and initialize the nodes\n@@ -2260,7 +2283,8 @@ namespace __gnu_parallel\n      *  @return Resulting tree after the elements have been inserted\n      */\n     template<typename StrictlyLessOrLessEqual>\n-    _Rb_tree_node_ptr _M_bulk_insertion_merge(_Rb_tree_node_ptr* r_array, _Rb_tree_node_ptr t, const size_type pos_beg, const size_type pos_end,  size_type& existing, int& black_h, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n+    _Rb_tree_node_ptr \n+    _M_bulk_insertion_merge(_Rb_tree_node_ptr* r_array, _Rb_tree_node_ptr t, const size_type pos_beg, const size_type pos_end,  size_type& existing, int& black_h, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n     {\n #ifndef NDEBUG\n       int count;\n@@ -2333,7 +2357,8 @@ namespace __gnu_parallel\n      *  of the wrapping container\n      */\n     template<typename StrictlyLessOrLessEqual>\n-    void _M_bulk_insertion_merge_concatenate(_Rb_tree_node_ptr* r, insertion_problem& ip, size_type& existing, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n+    void \n+    _M_bulk_insertion_merge_concatenate(_Rb_tree_node_ptr* r, insertion_problem& ip, size_type& existing, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n     {\n       concat_problem* conc = ip.conc;\n       _GLIBCXX_PARALLEL_ASSERT(ip.pos_beg <= ip.pos_end);\n@@ -2675,7 +2700,8 @@ namespace __gnu_parallel\n     static int\n     black_height(const _Rb_tree_node_ptr t)\n     {\n-      if (t == NULL) return 0;\n+      if (t == NULL) \n+\treturn 0;\n       int bh = black_height (static_cast<const _Rb_tree_node_ptr> (t->_M_left));\n       if (t->_M_color == std::_S_black)\n \t++bh;\n@@ -2719,7 +2745,8 @@ namespace __gnu_parallel\n      */\n     template<typename S>\n     static _Rb_tree_node_ptr\n-    plant(const _Rb_tree_node_ptr root, const _Rb_tree_node_ptr l, const _Rb_tree_node_ptr r)\n+    plant(const _Rb_tree_node_ptr root, const _Rb_tree_node_ptr l, \n+\t  const _Rb_tree_node_ptr r)\n     {\n       S::left(root) = l;\n       S::right(root) = r;\n@@ -2744,7 +2771,9 @@ namespace __gnu_parallel\n      *  @post @c t is correct red-black tree with height @c black_h.\n      */\n     void\n-    concatenate(_Rb_tree_node_ptr root, _Rb_tree_node_ptr l, _Rb_tree_node_ptr r,  int black_h_l, int black_h_r, _Rb_tree_node_ptr& t, int& black_h) const\n+    concatenate(_Rb_tree_node_ptr root, _Rb_tree_node_ptr l, \n+\t\t_Rb_tree_node_ptr r,  int black_h_l, int black_h_r, \n+\t\t_Rb_tree_node_ptr& t, int& black_h) const\n     {\n #ifndef NDEBUG\n       int count = 0, count1 = 0, count2 = 0;\n@@ -2826,7 +2855,9 @@ namespace __gnu_parallel\n      */\n     template<typename S>\n     static void\n-    concatenate(const _Rb_tree_node_ptr rt, _Rb_tree_node_ptr l, _Rb_tree_node_ptr r, int black_h_l, int black_h_r, _Rb_tree_node_ptr& t, int& black_h)\n+    concatenate(const _Rb_tree_node_ptr rt, _Rb_tree_node_ptr l, \n+\t\t_Rb_tree_node_ptr r, int black_h_l, int black_h_r, \n+\t\t_Rb_tree_node_ptr& t, int& black_h)\n     {\n       _Rb_tree_node_base* root = l;\n       _Rb_tree_node_ptr parent = NULL;\n@@ -2888,7 +2919,10 @@ namespace __gnu_parallel\n      *  @return Black height of t */\n     template<typename StrictlyLessOrEqual>\n     int\n-    split(_Rb_tree_node_ptr t, const key_type& key, const key_type& prev_k, _Rb_tree_node_ptr& root, _Rb_tree_node_ptr& l,  _Rb_tree_node_ptr& r, int& black_h_l, int& black_h_r, StrictlyLessOrEqual strictly_less_or_less_equal) const\n+    split(_Rb_tree_node_ptr t, const key_type& key, const key_type& prev_k, \n+\t  _Rb_tree_node_ptr& root, _Rb_tree_node_ptr& l, _Rb_tree_node_ptr& r, \n+\t  int& black_h_l, int& black_h_r, \n+\t  StrictlyLessOrEqual strictly_less_or_less_equal) const\n     {\n       if (t != NULL)\n \t{\n@@ -2936,7 +2970,11 @@ namespace __gnu_parallel\n      *  @return Black height of t */\n     template<typename StrictlyLessOrEqual>\n     int\n-    split_not_null(const _Rb_tree_node_ptr t, const key_type& key, const key_type& prev_k, _Rb_tree_node_ptr& root, _Rb_tree_node_ptr& l, _Rb_tree_node_ptr& r, int& black_h_l, int& black_h_r, StrictlyLessOrEqual strictly_less_or_equal) const\n+    split_not_null(const _Rb_tree_node_ptr t, const key_type& key, \n+\t\t   const key_type& prev_k, _Rb_tree_node_ptr& root, \n+\t\t   _Rb_tree_node_ptr& l, _Rb_tree_node_ptr& r, int& black_h_l, \n+\t\t   int& black_h_r, \n+\t\t   StrictlyLessOrEqual strictly_less_or_equal) const\n     {\n       _GLIBCXX_PARALLEL_ASSERT (t != NULL);\n       int black_h, b_h;\n@@ -3039,7 +3077,8 @@ namespace __gnu_parallel\n      *  @param black_h_r Black height of the right subtree.\n      *  @return Black height of the original tree  */\n     int\n-    extract_min(const _Rb_tree_node_ptr t, _Rb_tree_node_ptr& root, _Rb_tree_node_ptr& r, int& black_h_r) const\n+    extract_min(const _Rb_tree_node_ptr t, _Rb_tree_node_ptr& root, \n+\t\t_Rb_tree_node_ptr& r, int& black_h_r) const\n     {\n       _GLIBCXX_PARALLEL_ASSERT (t != NULL);\n       int black_h, b_h;\n@@ -3087,7 +3126,8 @@ namespace __gnu_parallel\n      *  @param black_h_l Black height of the left subtree.\n      *  @return Black height of the original tree  */\n     int\n-    extract_max(const _Rb_tree_node_ptr t, _Rb_tree_node_ptr& root, _Rb_tree_node_ptr& l, int& black_h_l) const\n+    extract_max(const _Rb_tree_node_ptr t, _Rb_tree_node_ptr& root, \n+\t\t_Rb_tree_node_ptr& l, int& black_h_l) const\n     {\n       _GLIBCXX_PARALLEL_ASSERT (t != NULL);\n       int black_h, b_h;\n@@ -3138,7 +3178,9 @@ namespace __gnu_parallel\n      *  @param black_h_r Black height of the right subtree.\n      *  @return Black height of the original tree */\n     int\n-    split(const _Rb_tree_node_ptr t, const key_type& key, _Rb_tree_node_ptr& l, _Rb_tree_node_ptr& r, int& black_h_l, int& black_h_r) const\n+    split(const _Rb_tree_node_ptr t, const key_type& key, \n+\t  _Rb_tree_node_ptr& l, _Rb_tree_node_ptr& r, int& black_h_l, \n+\t  int& black_h_r) const\n     {\n       if (t != NULL)\n \t{\n@@ -3197,7 +3239,9 @@ namespace __gnu_parallel\n      *  @return Resulting tree after insertion */\n     template<typename StrictlyLessOrLessEqual>\n     _Rb_tree_node_ptr\n-    _M_insert_local(_Rb_tree_node_base* t, const _Rb_tree_node_ptr new_t, size_type& existing, int& black_h, StrictlyLessOrLessEqual strictly_less_or_less_equal)\n+    _M_insert_local(_Rb_tree_node_base* t, const _Rb_tree_node_ptr new_t, \n+\t\t    size_type& existing, int& black_h, \n+\t\t    StrictlyLessOrLessEqual strictly_less_or_less_equal)\n     {\n       _GLIBCXX_PARALLEL_ASSERT(t != NULL);\n       if (_M_insert_local_top_down(t, new_t, NULL, NULL, true, strictly_less_or_less_equal))\n@@ -3233,7 +3277,11 @@ namespace __gnu_parallel\n      */\n     template<typename StrictlyLessOrLessEqual>\n     bool\n-    _M_insert_local_top_down(_Rb_tree_node_base* t, const _Rb_tree_node_ptr new_t, _Rb_tree_node_base* eq_t, _Rb_tree_node_base* parent, const bool is_left, StrictlyLessOrLessEqual strictly_less_or_less_equal) const\n+    _M_insert_local_top_down(_Rb_tree_node_base* t, \n+\t\t\t     const _Rb_tree_node_ptr new_t, \n+\t\t\t     _Rb_tree_node_base* eq_t, \n+\t\t\t     _Rb_tree_node_base* parent, const bool is_left, \n+\t\t    StrictlyLessOrLessEqual strictly_less_or_less_equal) const\n     {\n       if (t != NULL)\n \t{\n@@ -3398,7 +3446,8 @@ namespace __gnu_parallel\n      *  @return Tree correct. \n      */\n     static bool\n-    rb_verify_tree(const typename base_type::_Const_Link_type __x, int& count, int& black_h)\n+    rb_verify_tree(const typename base_type::_Const_Link_type __x, int& count, \n+\t\t   int& black_h)\n     {\n       if (__x == NULL)\n \t{"}]}