{"sha": "ffa16a4590ad47e3f4ba098e2090c3a53dccd5c7", "node_id": "C_kwDOANBUbNoAKGZmYTE2YTQ1OTBhZDQ3ZTNmNGJhMDk4ZTIwOTBjM2E1M2RjY2Q1Yzc", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T13:46:32Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-01-31T13:16:50Z"}, "message": "gccrs: Create canonical process of compiling constant items\n\nIn order to compile a block expression constant, the simplest way for us\nwas to reuse what code we have and to generate an artifical function which\ndoes not get added to the translation unit. The constant then becomes\na CALL_EXPR to this artifical function which we can pass to the constexpr\nevaluator to resolve the result of this artifical 'CALL_EXPR'.\n\nBefore this patch we seperated the difference between block expressions\nand non block expressions in constants. So for non block expressions we\nsimply compiled them as if it was a simple constant but this is not\nguaranteed to be the case in rust, for example coercion sites can generate\ntemporaries during autoderef which we let the constant evaluator resolve\nfor us. This makes all constants handled in the same way to simplify the\nlogic here.\n\ngcc/rust/ChangeLog:\n\n\t* backend/rust-compile-base.cc: Improve compilation pipeline and simplify\n\tfunction.", "tree": {"sha": "ecccc37166c3d8b9d3d408f80ccdd29226bfdee7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecccc37166c3d8b9d3d408f80ccdd29226bfdee7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffa16a4590ad47e3f4ba098e2090c3a53dccd5c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa16a4590ad47e3f4ba098e2090c3a53dccd5c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa16a4590ad47e3f4ba098e2090c3a53dccd5c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa16a4590ad47e3f4ba098e2090c3a53dccd5c7/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1eabeb5aecc954d2c237f5997605a73a37dd1c12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eabeb5aecc954d2c237f5997605a73a37dd1c12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eabeb5aecc954d2c237f5997605a73a37dd1c12"}], "stats": {"total": 103, "additions": 55, "deletions": 48}, "files": [{"sha": "568abf9ca2c51fa5688724a1f5f9573582e55d06", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa16a4590ad47e3f4ba098e2090c3a53dccd5c7/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa16a4590ad47e3f4ba098e2090c3a53dccd5c7/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=ffa16a4590ad47e3f4ba098e2090c3a53dccd5c7", "patch": "@@ -652,65 +652,72 @@ HIRCompileBase::compile_constant_item (\n   bool is_block_expr\n     = const_value_expr->get_expression_type () == HIR::Expr::ExprType::Block;\n \n-  // compile the expression\n-  tree folded_expr = error_mark_node;\n-  if (!is_block_expr)\n-    {\n-      tree value = CompileExpr::Compile (const_value_expr, ctx);\n-      folded_expr = fold_expr (value);\n-    }\n-  else\n-    {\n-      // in order to compile a block expr we want to reuse as much existing\n-      // machineary that we already have. This means the best approach is to\n-      // make a _fake_ function with a block so it can hold onto temps then\n-      // use our constexpr code to fold it completely or error_mark_node\n-      Backend::typed_identifier receiver;\n-      tree compiled_fn_type = ctx->get_backend ()->function_type (\n-\treceiver, {}, {Backend::typed_identifier (\"_\", const_type, locus)},\n-\tNULL, locus);\n-\n-      tree fndecl\n-\t= ctx->get_backend ()->function (compiled_fn_type, ident, \"\", 0, locus);\n-      TREE_READONLY (fndecl) = 1;\n+  // in order to compile a block expr we want to reuse as much existing\n+  // machineary that we already have. This means the best approach is to\n+  // make a _fake_ function with a block so it can hold onto temps then\n+  // use our constexpr code to fold it completely or error_mark_node\n+  Backend::typed_identifier receiver;\n+  tree compiled_fn_type = ctx->get_backend ()->function_type (\n+    receiver, {}, {Backend::typed_identifier (\"_\", const_type, locus)}, NULL,\n+    locus);\n+\n+  tree fndecl\n+    = ctx->get_backend ()->function (compiled_fn_type, ident, \"\", 0, locus);\n+  TREE_READONLY (fndecl) = 1;\n+\n+  tree enclosing_scope = NULL_TREE;\n \n-      tree enclosing_scope = NULL_TREE;\n+  Location start_location = const_value_expr->get_locus ();\n+  Location end_location = const_value_expr->get_locus ();\n+  if (is_block_expr)\n+    {\n       HIR::BlockExpr *function_body\n \t= static_cast<HIR::BlockExpr *> (const_value_expr);\n-      Location start_location = function_body->get_locus ();\n-      Location end_location = function_body->get_end_locus ();\n+      start_location = function_body->get_locus ();\n+      end_location = function_body->get_end_locus ();\n+    }\n \n-      tree code_block\n-\t= ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n-\t\t\t\t      start_location, end_location);\n-      ctx->push_block (code_block);\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n \n-      bool address_is_taken = false;\n-      tree ret_var_stmt = NULL_TREE;\n-      Bvariable *return_address\n-\t= ctx->get_backend ()->temporary_variable (fndecl, code_block,\n-\t\t\t\t\t\t   const_type, NULL,\n-\t\t\t\t\t\t   address_is_taken, locus,\n-\t\t\t\t\t\t   &ret_var_stmt);\n+  bool address_is_taken = false;\n+  tree ret_var_stmt = NULL_TREE;\n+  Bvariable *return_address\n+    = ctx->get_backend ()->temporary_variable (fndecl, code_block, const_type,\n+\t\t\t\t\t       NULL, address_is_taken, locus,\n+\t\t\t\t\t       &ret_var_stmt);\n \n-      ctx->add_statement (ret_var_stmt);\n-      ctx->push_fn (fndecl, return_address);\n+  ctx->add_statement (ret_var_stmt);\n+  ctx->push_fn (fndecl, return_address);\n \n+  if (is_block_expr)\n+    {\n+      HIR::BlockExpr *function_body\n+\t= static_cast<HIR::BlockExpr *> (const_value_expr);\n       compile_function_body (ctx, fndecl, *function_body, true);\n-      tree bind_tree = ctx->pop_block ();\n+    }\n+  else\n+    {\n+      tree value = CompileExpr::Compile (const_value_expr, ctx);\n+      tree return_expr = ctx->get_backend ()->return_statement (\n+\tfndecl, {value}, const_value_expr->get_locus ());\n+      ctx->add_statement (return_expr);\n+    }\n \n-      gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n-      DECL_SAVED_TREE (fndecl) = bind_tree;\n-      DECL_DECLARED_CONSTEXPR_P (fndecl) = 1;\n-      maybe_save_constexpr_fundef (fndecl);\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+  DECL_DECLARED_CONSTEXPR_P (fndecl) = 1;\n+  maybe_save_constexpr_fundef (fndecl);\n \n-      ctx->pop_fn ();\n+  ctx->pop_fn ();\n \n-      // lets fold it into a call expr\n-      tree call = build_call_array_loc (locus.gcc_location (), const_type,\n-\t\t\t\t\tfndecl, 0, NULL);\n-      folded_expr = fold_expr (call);\n-    }\n+  // lets fold it into a call expr\n+  tree call\n+    = build_call_array_loc (locus.gcc_location (), const_type, fndecl, 0, NULL);\n+  tree folded_expr = fold_expr (call);\n \n   return named_constant_expression (const_type, ident, folded_expr, locus);\n }"}]}