{"sha": "3eb92a3d25d596acb8a45d2ec335c6e3f6950391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ViOTJhM2QyNWQ1OTZhY2I4YTQ1ZDJlYzMzNWM2ZTNmNjk1MDM5MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-11T02:51:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-11T02:51:51Z"}, "message": "* tree.c (verify_type_variant): Check TYPE_VALUES_RAW and TYPE_PRECISION\n\nFrom-SVN: r222991", "tree": {"sha": "f7a72b16b05c7ebdc2b5c58192838b426f8fcfd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7a72b16b05c7ebdc2b5c58192838b426f8fcfd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3eb92a3d25d596acb8a45d2ec335c6e3f6950391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb92a3d25d596acb8a45d2ec335c6e3f6950391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eb92a3d25d596acb8a45d2ec335c6e3f6950391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb92a3d25d596acb8a45d2ec335c6e3f6950391/comments", "author": null, "committer": null, "parents": [{"sha": "dafb7b56f1c4dd89194621bb76609e99deb0bc72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dafb7b56f1c4dd89194621bb76609e99deb0bc72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dafb7b56f1c4dd89194621bb76609e99deb0bc72"}], "stats": {"total": 96, "additions": 96, "deletions": 0}, "files": [{"sha": "c305d2efa45f61804e2ede82b144d9989c710cc2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb92a3d25d596acb8a45d2ec335c6e3f6950391/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb92a3d25d596acb8a45d2ec335c6e3f6950391/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3eb92a3d25d596acb8a45d2ec335c6e3f6950391", "patch": "@@ -1,3 +1,7 @@\n+2015-05-09  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree.c (verify_type_variant): Check TYPE_VALUES_RAW and TYPE_PRECISION\n+\n 2015-05-09  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPatch by Richard Biener"}, {"sha": "0c97667b6a047cc49f91148320bc9848bcd1496d", "filename": "gcc/tree.c", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb92a3d25d596acb8a45d2ec335c6e3f6950391/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb92a3d25d596acb8a45d2ec335c6e3f6950391/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3eb92a3d25d596acb8a45d2ec335c6e3f6950391", "patch": "@@ -12577,6 +12577,98 @@ verify_type_variant (const_tree t, tree tv)\n       debug_tree (TYPE_BINFO (t));\n       return false;\n     }\n+\n+  /* Check various uses of TYPE_VALUES_RAW.  */\n+  if (TREE_CODE (t) == ENUMERAL_TYPE\n+      && TYPE_VALUES (t) != TYPE_VALUES (tv))\n+    {\n+      error (\"type variant has different TYPE_VALUES\");\n+      debug_tree (tv);\n+      error (\"type variant's TYPE_VALUES\");\n+      debug_tree (TYPE_VALUES (tv));\n+      error (\"type's TYPE_VALUES\");\n+      debug_tree (TYPE_VALUES (t));\n+      return false;\n+    }\n+  else if (TREE_CODE (t) == ARRAY_TYPE\n+\t   && TYPE_DOMAIN (t) != TYPE_DOMAIN (tv))\n+    {\n+      error (\"type variant has different TYPE_DOMAIN\");\n+      debug_tree (tv);\n+      error (\"type variant's TYPE_DOMAIN\");\n+      debug_tree (TYPE_DOMAIN (tv));\n+      error (\"type's TYPE_DOMAIN\");\n+      debug_tree (TYPE_DOMAIN (t));\n+      return false;\n+    }\n+  /* Permit incomplete variants of complete type.  While FEs may complete\n+     all variants, this does not happen for C++ templates in all cases.  */\n+  else if (RECORD_OR_UNION_TYPE_P (t)\n+\t   && COMPLETE_TYPE_P (t)\n+\t   && TYPE_FIELDS (t) != TYPE_FIELDS (tv))\n+    {\n+      tree f1, f2;\n+\n+      /* Fortran builds qualified variants as new records with items of\n+\t qualified type. Verify that they looks same.  */\n+      for (f1 = TYPE_FIELDS (t), f2 = TYPE_FIELDS (tv);\n+\t   f1 && f2;\n+\t   f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\tif (TREE_CODE (f1) != FIELD_DECL || TREE_CODE (f2) != FIELD_DECL\n+\t    || (TYPE_MAIN_VARIANT (TREE_TYPE (f1))\n+\t\t != TYPE_MAIN_VARIANT (TREE_TYPE (f2))\n+\t\t/* FIXME: gfc_nonrestricted_type builds all types as variants\n+\t\t   with exception of pointer types.  It deeply copies the type\n+\t\t   which means that we may end up with a variant type\n+\t\t   referring non-variant pointer.  We may change it to\n+\t\t   produce types as variants, too, like\n+\t\t   objc_get_protocol_qualified_type does.  */\n+\t\t&& !POINTER_TYPE_P (TREE_TYPE (f1)))\n+\t    || DECL_FIELD_OFFSET (f1) != DECL_FIELD_OFFSET (f2)\n+\t    || DECL_FIELD_BIT_OFFSET (f1) != DECL_FIELD_BIT_OFFSET (f2))\n+\t  break;\n+      if (f1 || f2)\n+\t{\n+\t  error (\"type variant has different TYPE_FIELDS\");\n+\t  debug_tree (tv);\n+\t  error (\"first mismatch is field\");\n+\t  debug_tree (f1);\n+\t  error (\"and field\");\n+\t  debug_tree (f2);\n+          return false;\n+\t}\n+    }\n+  else if ((TREE_CODE (t) == FUNCTION_TYPE || TREE_CODE (t) == METHOD_TYPE)\n+\t   && TYPE_ARG_TYPES (t) != TYPE_ARG_TYPES (tv))\n+    {\n+      error (\"type variant has different TYPE_ARG_TYPES\");\n+      debug_tree (tv);\n+      return false;\n+    }\n+  /* For C++ the qualified variant of array type is really an array type\n+     of qualified TREE_TYPE.\n+     objc builds variants of pointer where pointer to type is a variant, too\n+     in objc_get_protocol_qualified_type.  */\n+  if (TREE_TYPE (t) != TREE_TYPE (tv)\n+      && ((TREE_CODE (t) != ARRAY_TYPE\n+\t   && !POINTER_TYPE_P (t))\n+\t  || TYPE_MAIN_VARIANT (TREE_TYPE (t))\n+\t     != TYPE_MAIN_VARIANT (TREE_TYPE (tv))))\n+    {\n+      error (\"type variant has different TREE_TYPE\");\n+      debug_tree (tv);\n+      error (\"type variant's TREE_TYPE\");\n+      debug_tree (TREE_TYPE (tv));\n+      error (\"type's TREE_TYPE\");\n+      debug_tree (TREE_TYPE (t));\n+      return false;\n+    }\n+  if (TYPE_PRECISION (t) != TYPE_PRECISION (tv))\n+    {\n+      error (\"type variant has different TYPE_PRECISION\");\n+      debug_tree (tv);\n+      return false;\n+    }\n   return true;\n }\n "}]}