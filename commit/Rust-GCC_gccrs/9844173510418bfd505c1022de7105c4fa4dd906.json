{"sha": "9844173510418bfd505c1022de7105c4fa4dd906", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg0NDE3MzUxMDQxOGJmZDUwNWMxMDIyZGU3MTA1YzRmYTRkZDkwNg==", "commit": {"author": {"name": "Kugan Vivekanandarajah", "email": "kuganv@linaro.org", "date": "2015-07-12T11:22:42Z"}, "committer": {"name": "Kugan Vivekanandarajah", "email": "kugan@gcc.gnu.org", "date": "2015-07-12T11:22:42Z"}, "message": "re PR tree-optimization/66726 (missed optimization, factor conversion out of COND_EXPR)\n\ngcc/testsuite/ChangeLog:\n\n2015-07-12  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\t    Jeff Law  <law@redhat.com>\n\n\tPR middle-end/66726\n\t* g++.dg/tree-ssa/pr66726.c: New test.\n\t* gcc.dg/tree-ssa/pr66726-2.c: New test.\n\t* gcc.dg/tree-ssa/pr66726.c: New test.\n\n\ngcc/ChangeLog:\n\n2015-07-12  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\tPR middle-end/66726\n\t* tree-ssa-phiopt.c(factor_out_conditional_conversion): New function.\n\ttree_ssa_phiopt_worker): Call it.\n\n\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r225722", "tree": {"sha": "92b0d0d5684ccad1ea32bc354f7c394dbd0bf8d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92b0d0d5684ccad1ea32bc354f7c394dbd0bf8d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9844173510418bfd505c1022de7105c4fa4dd906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9844173510418bfd505c1022de7105c4fa4dd906", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9844173510418bfd505c1022de7105c4fa4dd906", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9844173510418bfd505c1022de7105c4fa4dd906/comments", "author": null, "committer": null, "parents": [{"sha": "7f7379f6f4f28376ac4fa9a807217f1fec2488fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f7379f6f4f28376ac4fa9a807217f1fec2488fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f7379f6f4f28376ac4fa9a807217f1fec2488fc"}], "stats": {"total": 246, "additions": 246, "deletions": 0}, "files": [{"sha": "694ee96b15e18bc39ce23ccb4a9f81f98197b6fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9844173510418bfd505c1022de7105c4fa4dd906", "patch": "@@ -1,3 +1,9 @@\n+2015-07-12  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\tPR middle-end/66726\n+\t* tree-ssa-phiopt.c(factor_out_conditional_conversion): New function.\n+\ttree_ssa_phiopt_worker): Call it.\n+\n 2015-07-12  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* cse.c (cse_insn): Calculate src_eqv for ZERO_EXTRACT."}, {"sha": "3d939b1f6776ce928cd56758ea6169fd877e6f11", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9844173510418bfd505c1022de7105c4fa4dd906", "patch": "@@ -1,3 +1,11 @@\n+2015-07-12  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\tPR middle-end/66726\n+\t* g++.dg/tree-ssa/pr66726.c: New test.\n+\t* gcc.dg/tree-ssa/pr66726-2.c: New test.\n+\t* gcc.dg/tree-ssa/pr66726.c: New test.\n+\n 2015-07-11  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58734"}, {"sha": "9b3bd8fa9ca5037a99dbdccefc9657787e7b18d0", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr66726.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr66726.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr66726.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr66726.c?ref=9844173510418bfd505c1022de7105c4fa4dd906", "patch": "@@ -0,0 +1,36 @@\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+/* Execution test for converting VIEW_CONVERT_EXPR.  */\n+\n+struct cpp_num {\n+  bool f;\n+};\n+\n+extern cpp_num  __attribute__((noinline))\n+foo (cpp_num lhs,\n+     cpp_num rhs)\n+{\n+  lhs.f = lhs.f || rhs.f;\n+  return lhs;\n+}\n+\n+cpp_num lhs, rhs, r;\n+\n+int main ()\n+{\n+\n+  lhs.f = false;\n+  rhs.f = false;\n+  r = foo (lhs, rhs);\n+  if (r.f)\n+    __builtin_abort ();\n+\n+\n+  lhs.f = false;\n+  rhs.f = true;\n+  r = foo (lhs, rhs);\n+  if (!r.f)\n+    __builtin_abort ();\n+}"}, {"sha": "ab43d4835d2c78d05f3f9910a1ae04ef00d17dc6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr66726-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66726-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66726-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66726-2.c?ref=9844173510418bfd505c1022de7105c4fa4dd906", "patch": "@@ -0,0 +1,19 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-phiopt1-details\" } */\n+\n+extern void bar (char, char);\n+int\n+foo (char b)\n+{\n+  char a;\n+  a = b;\n+  b = 'b';\n+  bar (a, b);\n+  b = a;\n+  if (b == 0)\n+    a++;\n+  return a + b;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"factor conversion out\" 0 \"phiopt1\" } } */"}, {"sha": "a4c7418205907a4cabdc9cb1ae74aa0b7498197d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr66726.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66726.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66726.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66726.c?ref=9844173510418bfd505c1022de7105c4fa4dd906", "patch": "@@ -0,0 +1,15 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-phiopt1-details\" } */\n+\n+extern unsigned short mode_size[];\n+\n+int\n+oof (int mode)\n+{\n+  return (64 < mode_size[mode] ? 64 : mode_size[mode]);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"factor conversion out\" 1 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"phiopt1\" } } */\n+"}, {"sha": "cab20bcd0c81a5a40cf38171e5c8988f994455cd", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9844173510418bfd505c1022de7105c4fa4dd906/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=9844173510418bfd505c1022de7105c4fa4dd906", "patch": "@@ -61,6 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n static unsigned int tree_ssa_phiopt_worker (bool, bool);\n static bool conditional_replacement (basic_block, basic_block,\n \t\t\t\t     edge, edge, gphi *, tree, tree);\n+static bool factor_out_conditional_conversion (edge, edge, gphi *, tree, tree);\n static int value_replacement (basic_block, basic_block,\n \t\t\t      edge, edge, gimple, tree, tree);\n static bool minmax_replacement (basic_block, basic_block,\n@@ -323,6 +324,19 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n \t     node.  */\n \t  gcc_assert (arg0 != NULL && arg1 != NULL);\n \n+\t  if (factor_out_conditional_conversion (e1, e2, phi, arg0, arg1))\n+\t    {\n+\t      /* factor_out_conditional_conversion may create a new PHI in\n+\t\t BB2 and eliminate an existing PHI in BB2.  Recompute values\n+\t\t that may be affected by that change.  */\n+\t      phis = phi_nodes (bb2);\n+\t      phi = single_non_singleton_phi_for_edges (phis, e1, e2);\n+\t      gcc_assert (phi);\n+\t      arg0 = gimple_phi_arg_def (phi, e1->dest_idx);\n+\t      arg1 = gimple_phi_arg_def (phi, e2->dest_idx);\n+\t      gcc_assert (arg0 != NULL && arg1 != NULL);\n+\t    }\n+\n \t  /* Do the replacement of conditional if it can be done.  */\n \t  if (conditional_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n@@ -398,6 +412,134 @@ replace_phi_edge_with_variable (basic_block cond_block,\n \t      bb->index);\n }\n \n+/* PR66726: Factor conversion out of COND_EXPR.  If the arguments of the PHI\n+   stmt are CONVERT_STMT, factor out the conversion and perform the conversion\n+   to the result of PHI stmt.  */\n+\n+static bool\n+factor_out_conditional_conversion (edge e0, edge e1, gphi *phi,\n+\t\t\t\t   tree arg0, tree arg1)\n+{\n+  gimple arg0_def_stmt = NULL, arg1_def_stmt = NULL, new_stmt;\n+  tree new_arg0 = NULL_TREE, new_arg1 = NULL_TREE;\n+  tree temp, result;\n+  gphi *newphi;\n+  gimple_stmt_iterator gsi, gsi_for_def;\n+  source_location locus = gimple_location (phi);\n+  enum tree_code convert_code;\n+\n+  /* Handle only PHI statements with two arguments.  TODO: If all\n+     other arguments to PHI are INTEGER_CST or if their defining\n+     statement have the same unary operation, we can handle more\n+     than two arguments too.  */\n+  if (gimple_phi_num_args (phi) != 2)\n+    return false;\n+\n+  /* First canonicalize to simplify tests.  */\n+  if (TREE_CODE (arg0) != SSA_NAME)\n+    {\n+      std::swap (arg0, arg1);\n+      std::swap (e0, e1);\n+    }\n+\n+  if (TREE_CODE (arg0) != SSA_NAME\n+      || (TREE_CODE (arg1) != SSA_NAME\n+\t  && TREE_CODE (arg1) != INTEGER_CST))\n+    return false;\n+\n+  /* Check if arg0 is an SSA_NAME and the stmt which defines arg0 is\n+     a conversion.  */\n+  arg0_def_stmt = SSA_NAME_DEF_STMT (arg0);\n+  if (!is_gimple_assign (arg0_def_stmt)\n+      || !gimple_assign_cast_p (arg0_def_stmt))\n+    return false;\n+\n+  /* Use the RHS as new_arg0.  */\n+  convert_code = gimple_assign_rhs_code (arg0_def_stmt);\n+  new_arg0 = gimple_assign_rhs1 (arg0_def_stmt);\n+  if (convert_code == VIEW_CONVERT_EXPR)\n+    new_arg0 = TREE_OPERAND (new_arg0, 0);\n+\n+  if (TREE_CODE (arg1) == SSA_NAME)\n+    {\n+      /* Check if arg1 is an SSA_NAME and the stmt which defines arg1\n+\t is a conversion.  */\n+      arg1_def_stmt = SSA_NAME_DEF_STMT (arg1);\n+      if (!is_gimple_assign (arg1_def_stmt)\n+\t  || gimple_assign_rhs_code (arg1_def_stmt) != convert_code)\n+\treturn false;\n+\n+      /* Use the RHS as new_arg1.  */\n+      new_arg1 = gimple_assign_rhs1 (arg1_def_stmt);\n+      if (convert_code == VIEW_CONVERT_EXPR)\n+\tnew_arg1 = TREE_OPERAND (new_arg1, 0);\n+    }\n+  else\n+    {\n+      /* If arg1 is an INTEGER_CST, fold it to new type.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (new_arg0))\n+\t  && int_fits_type_p (arg1, TREE_TYPE (new_arg0)))\n+\t{\n+\t  if (gimple_assign_cast_p (arg0_def_stmt))\n+\t    new_arg1 = fold_convert (TREE_TYPE (new_arg0), arg1);\n+\t  else\n+\t    return false;\n+\t}\n+      else\n+\treturn false;\n+    }\n+\n+  /*  If arg0/arg1 have > 1 use, then this transformation actually increases\n+      the number of expressions evaluated at runtime.  */\n+  if (!has_single_use (arg0)\n+      || (arg1_def_stmt && !has_single_use (arg1)))\n+    return false;\n+\n+  /* If types of new_arg0 and new_arg1 are different bailout.  */\n+  if (!types_compatible_p (TREE_TYPE (new_arg0), TREE_TYPE (new_arg1)))\n+    return false;\n+\n+  /* Create a new PHI stmt.  */\n+  result = PHI_RESULT (phi);\n+  temp = make_ssa_name (TREE_TYPE (new_arg0), NULL);\n+  newphi = create_phi_node (temp, gimple_bb (phi));\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"PHI \");\n+      print_generic_expr (dump_file, gimple_phi_result (phi), 0);\n+      fprintf (dump_file,\n+\t       \" changed to factor conversion out from COND_EXPR.\\n\");\n+      fprintf (dump_file, \"New stmt with CAST that defines \");\n+      print_generic_expr (dump_file, result, 0);\n+      fprintf (dump_file, \".\\n\");\n+    }\n+\n+  /* Remove the old cast(s) that has single use.  */\n+  gsi_for_def = gsi_for_stmt (arg0_def_stmt);\n+  gsi_remove (&gsi_for_def, true);\n+  if (arg1_def_stmt)\n+    {\n+      gsi_for_def = gsi_for_stmt (arg1_def_stmt);\n+      gsi_remove (&gsi_for_def, true);\n+    }\n+\n+  add_phi_arg (newphi, new_arg0, e0, locus);\n+  add_phi_arg (newphi, new_arg1, e1, locus);\n+\n+  /* Create the conversion stmt and insert it.  */\n+  if (convert_code == VIEW_CONVERT_EXPR)\n+    temp = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (result), temp);\n+  new_stmt = gimple_build_assign (result,  convert_code, temp);\n+  gsi = gsi_after_labels (gimple_bb (phi));\n+  gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n+\n+  /* Remove he original PHI stmt.  */\n+  gsi = gsi_for_stmt (phi);\n+  gsi_remove (&gsi, true);\n+  return true;\n+}\n+\n /*  The function conditional_replacement does the main work of doing the\n     conditional replacement.  Return true if the replacement is done.\n     Otherwise return false.\n@@ -2130,6 +2272,26 @@ gate_hoist_loads (void)\n    This pass also performs a fifth transformation of a slightly different\n    flavor.\n \n+   Factor conversion in COND_EXPR\n+   ------------------------------\n+\n+   This transformation factors the conversion out of COND_EXPR with\n+   factor_out_conditional_conversion.\n+\n+   For example:\n+   if (a <= CST) goto <bb 3>; else goto <bb 4>;\n+   <bb 3>:\n+   tmp = (int) a;\n+   <bb 4>:\n+   tmp = PHI <tmp, CST>\n+\n+   Into:\n+   if (a <= CST) goto <bb 3>; else goto <bb 4>;\n+   <bb 3>:\n+   <bb 4>:\n+   a = PHI <a, CST>\n+   tmp = (int) a;\n+\n    Adjacent Load Hoisting\n    ----------------------\n "}]}