{"sha": "0253134551ad49baaba9fb7ab4b6cfe3374316ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI1MzEzNDU1MWFkNDliYWFiYTlmYjdhYjRiNmNmZTMzNzQzMTZiYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-12-18T14:52:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-18T14:52:24Z"}, "message": "except.c: Remove register_exception_table{,_p}.\n\n\t* except.c: Remove register_exception_table{,_p}.\n\t* decl2.c (finish_file): Remove call to register_exception_table.\n\t* cp-tree.def: Add AGGR_INIT_EXPR.\n\t* error.c, tree.c, typeck.c: Replace uses of NEW_EXPR with\n\tAGGR_INIT_EXPR where appropriate.\n\t* expr.c (cplus_expand_expr): Likewise.  Simplify.\n\nFrom-SVN: r17132", "tree": {"sha": "c726c6b091f665d017918111954fb31f428d7a35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c726c6b091f665d017918111954fb31f428d7a35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0253134551ad49baaba9fb7ab4b6cfe3374316ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0253134551ad49baaba9fb7ab4b6cfe3374316ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0253134551ad49baaba9fb7ab4b6cfe3374316ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0253134551ad49baaba9fb7ab4b6cfe3374316ba/comments", "author": null, "committer": null, "parents": [{"sha": "63d96a955940981de3a4bdf2645080068d10faa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d96a955940981de3a4bdf2645080068d10faa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63d96a955940981de3a4bdf2645080068d10faa1"}], "stats": {"total": 179, "additions": 55, "deletions": 124}, "files": [{"sha": "25a230144f0791a1ed0a2b0dc68bac1b3e21c547", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0253134551ad49baaba9fb7ab4b6cfe3374316ba", "patch": "@@ -1,3 +1,7 @@\n+Thu Dec 18 14:51:12 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* except.c: Remove register_exception_table{,_p}.\n+\n Thu Dec 18 14:57:29 1997  Gavin Koch  <gavin@cygnus.com>\n \n \t* dwarf2out.c (dwarf2out_frame_debug): Handle adjustments of the"}, {"sha": "c320ff1aa32ecda6ae587f069998bd4d63aae290", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0253134551ad49baaba9fb7ab4b6cfe3374316ba", "patch": "@@ -1,3 +1,12 @@\n+Thu Dec 18 14:43:19 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.def: Add AGGR_INIT_EXPR.\n+\t* error.c, tree.c, typeck.c: Replace uses of NEW_EXPR with\n+\tAGGR_INIT_EXPR where appropriate.\n+\t* expr.c (cplus_expand_expr): Likewise.  Simplify.\n+\n+\t* decl2.c (finish_file): Remove call to register_exception_table.\n+\n Wed Dec 17 17:08:52 1997  Benjamin Kosnik  <bkoz@rhino.cygnus.com>\n \n \t* pt.c (instantiate_class_template): Don't do injection when"}, {"sha": "fc66b2cb58dfbf572a8a520b40d337c8216cf67a", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=0253134551ad49baaba9fb7ab4b6cfe3374316ba", "patch": "@@ -29,6 +29,12 @@ Boston, MA 02111-1307, USA.  */\n    just won't work for us.  */\n DEFTREECODE (OFFSET_REF, \"offset_ref\", 'r', 2)\n \n+/* For NEW_EXPR, operand 0 is the placement list.\n+   Operand 1 is the new-declarator.\n+   Operand 2 is the initializer.  */\n+DEFTREECODE (NEW_EXPR, \"nw_expr\", 'e', 3)\n+DEFTREECODE (VEC_NEW_EXPR, \"vec_nw_expr\", 'e', 3)\n+\n /* For DELETE_EXPR, operand 0 is the store to be destroyed.\n    Operand 1 is the value to pass to the destroying function\n    saying whether the store should be deallocated as well.  */\n@@ -50,11 +56,10 @@ DEFTREECODE (MEMBER_REF, \"member_ref\", 'r', 2)\n    operator converts to.  Operand is expression to be converted.  */\n DEFTREECODE (TYPE_EXPR, \"type_expr\", 'e', 1)\n \n-/* For NEW_EXPR, operand 0 is function which performs initialization,\n+/* For AGGR_INIT_EXPR, operand 0 is function which performs initialization,\n    operand 1 is argument list to initialization function,\n    and operand 2 is the slot which was allocated for this expression.  */\n-DEFTREECODE (NEW_EXPR, \"nw_expr\", 'e', 3)\n-DEFTREECODE (VEC_NEW_EXPR, \"vec_nw_expr\", 'e', 3)\n+DEFTREECODE (AGGR_INIT_EXPR, \"nw_expr\", 'e', 3)\n \n /* A throw expression.  operand 0 is the expression, if there was one,\n    else it is NULL_TREE.  */"}, {"sha": "8b5134a59433c1b3029860a215bdbd81615def61", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0253134551ad49baaba9fb7ab4b6cfe3374316ba", "patch": "@@ -2971,7 +2971,7 @@ finish_file ()\n       rest_of_decl_compilation (TREE_VALUE (vars), 0, 1, 1);\n   vars = static_aggregates;\n \n-  if (static_ctors || vars || register_exception_table_p ())\n+  if (static_ctors || vars)\n     needs_messing_up = 1;\n   if (static_dtors)\n     needs_cleaning = 1;\n@@ -3070,9 +3070,6 @@ finish_file ()\n       push_momentary ();\n       expand_start_bindings (0);\n \n-      if (register_exception_table_p ())\n-\tregister_exception_table ();\n-\n       while (vars)\n \t{\n \t  tree decl = TREE_VALUE (vars);"}, {"sha": "b318126211ebfc12657478bfa2b2a6bb9f98dcc3", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=0253134551ad49baaba9fb7ab4b6cfe3374316ba", "patch": "@@ -1205,7 +1205,7 @@ dump_expr (t, nop)\n \t}\n       break;\n \n-    case NEW_EXPR:\n+    case AGGR_INIT_EXPR:\n       OB_PUTID (TYPE_IDENTIFIER (TREE_TYPE (t)));\n       OB_PUTC ('(');\n       if (TREE_OPERAND (t, 1))"}, {"sha": "a2c166999f432634bdc2c1e2007a5a47cb32b7a2", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 25, "deletions": 85, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=0253134551ad49baaba9fb7ab4b6cfe3374316ba", "patch": "@@ -59,7 +59,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \n   switch (code)\n     {\n-    case NEW_EXPR:\n+    case AGGR_INIT_EXPR:\n       {\n \t/* Something needs to be initialized, but we didn't know\n \t   where that thing was when building the tree.  For example,\n@@ -76,8 +76,6 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \ttree func = TREE_OPERAND (exp, 0);\n \ttree args = TREE_OPERAND (exp, 1);\n \ttree type = TREE_TYPE (exp), slot;\n-\ttree fn_type = TREE_TYPE (TREE_TYPE (func));\n-\ttree return_type = TREE_TYPE (fn_type);\n \ttree call_exp;\n \trtx call_target, return_target;\n \tint pcc_struct_return = 0;\n@@ -86,14 +84,8 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t   `target' represents.  SLOT holds the slot for TARGET.  */\n \tslot = TREE_OPERAND (exp, 2);\n \n-\tif (target == 0)\n-\t  {\n-\t    /* Should always be called with a target in BLKmode case.  */\n-\t    my_friendly_assert (mode != BLKmode, 205);\n-\t    my_friendly_assert (DECL_RTL (slot) != 0, 206);\n-\n-\t    target = gen_reg_rtx (mode);\n-\t  }\n+\t/* Should always be called with a target.  */\n+\tmy_friendly_assert (target != NULL_RTX, 205);\n \n \t/* The target the initializer will initialize (CALL_TARGET)\n \t   must now be directed to initialize the target we are\n@@ -118,11 +110,6 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t      TREE_VALUE (args) = build1 (ADDR_EXPR, type, slot);\n \t    call_target = 0;\n \t  }\n-\telse if (TREE_CODE (return_type) == REFERENCE_TYPE)\n-\t  {\n-\t    type = return_type;\n-\t    call_target = 0;\n-\t  }\n \telse\n \t  {\n #ifdef PCC_STATIC_STRUCT_RETURN\n@@ -132,89 +119,42 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t    call_target = target;\n #endif\n \t  }\n-\tif (call_target)\n-\t  {\n-\t    /* Make this a valid memory address now.  The code below assumes\n-\t       that it can compare rtx and make assumptions based on the\n-\t       result.  The assumptions are true only if the address was\n-\t       valid to begin with.  */\n-\t    call_target = validize_mem (call_target);\n-\n-\t    /* If this is a reference to a symbol, expand_inline_function\n-\t       will do this transformation and return a different target\n-\t       than the one we gave it, though functionally equivalent.  Do\n-\t       the transformation here to avoid confusion.  */\n-\t    if (! cse_not_expected && GET_CODE (call_target) == MEM\n-\t\t&& GET_CODE (XEXP (call_target, 0)) == SYMBOL_REF)\n-\t      {\n-\t\tcall_target = gen_rtx\n-\t\t  (MEM, mode, memory_address (mode, XEXP (call_target, 0)));\n-\t\tMEM_IN_STRUCT_P (call_target) = 1;\n-\t      }\n-\t  }\n \n \tcall_exp = build (CALL_EXPR, type, func, args, NULL_TREE);\n \tTREE_SIDE_EFFECTS (call_exp) = 1;\n \treturn_target = expand_call (call_exp, call_target, ignore);\n-\tif (call_target == 0)\n-\t  {\n-\t    if (pcc_struct_return)\n-\t      {\n-\t\textern int flag_access_control;\n-\t\tint old_ac = flag_access_control;\n-\n-\t\ttree init = build_decl (VAR_DECL, 0, type);\n-\t\tTREE_ADDRESSABLE (init) = 1;\n-\t\tDECL_RTL (init) = return_target;\n-\n-\t\tflag_access_control = 0;\n-\t\texpand_aggr_init (slot, init, 0, LOOKUP_ONLYCONVERTING);\n-\t\tflag_access_control = old_ac;\n-\n-\t\tif (TYPE_NEEDS_DESTRUCTOR (type))\n-\t\t  {\n-\t\t    init = build_decl (VAR_DECL, 0,\n-\t\t\t\t       build_reference_type (type));\n-\t\t    DECL_RTL (init) = XEXP (return_target, 0);\n-\n-\t\t    init = maybe_build_cleanup (convert_from_reference (init));\n-\t\t    if (init != NULL_TREE)\n-\t\t      expand_expr (init, const0_rtx, VOIDmode, 0);\n-\t\t  }\n-\t\tcall_target = return_target = DECL_RTL (slot);\n-\t      }\n-\t    else\n-\t      call_target = return_target;\n-\t  }\n \n-\tif (call_target != return_target)\n+\tif (call_target)\n \t  {\n-\t    my_friendly_assert (TYPE_HAS_TRIVIAL_INIT_REF (type), 317);\n-\t    if (GET_MODE (return_target) == BLKmode)\n-\t      emit_block_move (call_target, return_target, expr_size (exp),\n-\t\t\t       TYPE_ALIGN (type) / BITS_PER_UNIT);\n-\t    else\n-\t      emit_move_insn (call_target, return_target);\n+\t    my_friendly_assert (rtx_equal_p (call_target, return_target)\n+\t\t\t\t|| TYPE_HAS_TRIVIAL_INIT_REF (type), 317);\n+\t    return return_target;\n \t  }\n \n-\tif (TREE_CODE (return_type) == REFERENCE_TYPE)\n+\t/* If we're suffering under the ancient PCC_STATIC_STRUCT_RETURN\n+\t   calling convention, we need to copy the return value out of\n+\t   the static return buffer into slot.  */\n+\tif (pcc_struct_return)\n \t  {\n-\t    tree init;\n-\n-\t    if (GET_CODE (call_target) == REG\n-\t\t&& REGNO (call_target) < FIRST_PSEUDO_REGISTER)\n-\t      my_friendly_abort (39);\n+\t    extern int flag_access_control;\n+\t    int old_ac = flag_access_control;\n \n-\t    type = TREE_TYPE (exp);\n+\t    tree init = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t    build_reference_type (type));\n+\t    DECL_RTL (init) = XEXP (return_target, 0);\n \n-\t    init = build (RTL_EXPR, return_type, 0, call_target);\n-\t    /* We got back a reference to the type we want.  Now initialize\n-\t       target with that.  */\n+\t    flag_access_control = 0;\n \t    expand_aggr_init (slot, init, 0, LOOKUP_ONLYCONVERTING);\n+\t    flag_access_control = old_ac;\n+\n+\t    if (TYPE_NEEDS_DESTRUCTOR (type))\n+\t      {\n+\t\tinit = maybe_build_cleanup (convert_from_reference (init));\n+\t\tif (init != NULL_TREE)\n+\t\t  expand_expr (init, const0_rtx, VOIDmode, 0);\n+\t      }\n \t  }\n \n-\tif (DECL_RTL (slot) != target)\n-\t  emit_move_insn (DECL_RTL (slot), target);\n \treturn DECL_RTL (slot);\n       }\n "}, {"sha": "735e1a7abde1fee556b8fcbe14208d6311760acf", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0253134551ad49baaba9fb7ab4b6cfe3374316ba", "patch": "@@ -244,13 +244,13 @@ build_cplus_new (type, init)\n   tree slot;\n   tree rval;\n \n-  if (TREE_CODE (init) != CALL_EXPR && TREE_CODE (init) != NEW_EXPR)\n+  if (TREE_CODE (init) != CALL_EXPR && TREE_CODE (init) != AGGR_INIT_EXPR)\n     return init;\n \n   slot = build (VAR_DECL, type);\n   DECL_ARTIFICIAL (slot) = 1;\n   layout_decl (slot, 0);\n-  rval = build (NEW_EXPR, type,\n+  rval = build (AGGR_INIT_EXPR, type,\n \t\tTREE_OPERAND (init, 0), TREE_OPERAND (init, 1), slot);\n   TREE_SIDE_EFFECTS (rval) = 1;\n   rval = build (TARGET_EXPR, type, slot, rval, NULL_TREE, NULL_TREE);\n@@ -1498,7 +1498,7 @@ mapcar (t, func)\n \n     case COND_EXPR:\n     case TARGET_EXPR:\n-    case NEW_EXPR:\n+    case AGGR_INIT_EXPR:\n       t = copy_node (t);\n       TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n@@ -1761,7 +1761,7 @@ bot_manip (t)\n     return t;\n   else if (TREE_CODE (t) == TARGET_EXPR)\n     {\n-      if (TREE_CODE (TREE_OPERAND (t, 1)) == NEW_EXPR)\n+      if (TREE_CODE (TREE_OPERAND (t, 1)) == AGGR_INIT_EXPR)\n \t{\n \t  mark_used (TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (t, 1), 0), 0));\n \t  return build_cplus_new"}, {"sha": "3656187432450345107d6bf5b7016beef342b6b7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0253134551ad49baaba9fb7ab4b6cfe3374316ba", "patch": "@@ -7310,10 +7310,10 @@ c_expand_return (retval)\n \t  return;\n \t}\n \n-      /* We can't initialize a register from a NEW_EXPR.  */\n+      /* We can't initialize a register from a AGGR_INIT_EXPR.  */\n       else if (! current_function_returns_struct\n \t       && TREE_CODE (retval) == TARGET_EXPR\n-\t       && TREE_CODE (TREE_OPERAND (retval, 1)) == NEW_EXPR)\n+\t       && TREE_CODE (TREE_OPERAND (retval, 1)) == AGGR_INIT_EXPR)\n \tretval = build (COMPOUND_EXPR, TREE_TYPE (retval), retval,\n \t\t\tTREE_OPERAND (retval, 0));\n \n@@ -7337,7 +7337,7 @@ c_expand_return (retval)\n \t  if (TREE_CODE (whats_returned) == ADDR_EXPR)\n \t    {\n \t      whats_returned = TREE_OPERAND (whats_returned, 0);\n-\t      while (TREE_CODE (whats_returned) == NEW_EXPR\n+\t      while (TREE_CODE (whats_returned) == AGGR_INIT_EXPR\n \t\t     || TREE_CODE (whats_returned) == TARGET_EXPR)\n \t\t{\n \t\t  /* Get the target.  */"}, {"sha": "c12185f04dd0fa63df1051b87b34b74310aad9bb", "filename": "gcc/except.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0253134551ad49baaba9fb7ab4b6cfe3374316ba/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=0253134551ad49baaba9fb7ab4b6cfe3374316ba", "patch": "@@ -1559,18 +1559,6 @@ exception_table_p ()\n   return 0;\n }\n \n-/* 1 if we need a static constructor to register EH table info.  */\n-\n-int\n-register_exception_table_p ()\n-{\n-#if defined (DWARF2_UNWIND_INFO)\n-  return 0;\n-#endif\n-\n-  return exception_table_p ();\n-}\n-\n /* Output the entry of the exception table corresponding to to the\n    exception region numbered N to file FILE. \n \n@@ -1628,18 +1616,6 @@ output_exception_table ()\n   assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n   putc ('\\n', asm_out_file);\t\t/* blank line */\n }\n-\n-/* Generate code to initialize the exception table at program startup\n-   time.  */\n-\n-void\n-register_exception_table ()\n-{\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__register_exceptions\"), 0,\n-\t\t     VOIDmode, 1,\n-\t\t     gen_rtx (SYMBOL_REF, Pmode, \"__EXCEPTION_TABLE__\"),\n-\t\t     Pmode);\n-}\n \f\n /* Emit code to get EH context.\n    "}]}