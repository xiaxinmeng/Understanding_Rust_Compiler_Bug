{"sha": "f7c12ec44d2380c17e50bff0195c4678899d338a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdjMTJlYzQ0ZDIzODBjMTdlNTBiZmYwMTk1YzQ2Nzg4OTlkMzM4YQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2017-06-07T14:59:11Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2017-06-07T14:59:11Z"}, "message": "rs6000: Remove TARGET_E500_{SINGLE,DOUBLE}\n\nTARGET_E500_{SINGLE,DOUBLE} is always false now.\n\n\n\t* config/rs6000/predicates.md: Replace TARGET_E500_DOUBLE and\n\tTARGET_E500_SINGLE by 0, simplify.\n\t* config/rs6000/rs6000.c: Ditto.\n\t(rs6000_option_override_internal): Delete CHECK_E500_OPTIONS.\n\t(spe_build_register_parallel): Delete.\n\t* config/rs6000/rs6000.h: Delete TARGET_E500_SINGLE,\n\tTARGET_E500_DOUBLE, and CHECK_E500_OPTIONS.\n\t* config/rs6000/rs6000.md: Replace TARGET_E500_DOUBLE,\n\tTARGET_E500_SINGLE, and <E500_CONVERT> by 0, simplify.\n\t(E500_CONVERT): Delete.\n\t* config/rs6000/spe.md: Remove many patterns and all define_constants.\n\nFrom-SVN: r248975", "tree": {"sha": "bfb7b8f71f406ce37638f3370f8571d74ab6ba48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfb7b8f71f406ce37638f3370f8571d74ab6ba48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7c12ec44d2380c17e50bff0195c4678899d338a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7c12ec44d2380c17e50bff0195c4678899d338a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7c12ec44d2380c17e50bff0195c4678899d338a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7c12ec44d2380c17e50bff0195c4678899d338a/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11d8d07e31ce544fed5d4f2d2b4526b19672b558", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11d8d07e31ce544fed5d4f2d2b4526b19672b558", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11d8d07e31ce544fed5d4f2d2b4526b19672b558"}], "stats": {"total": 894, "additions": 74, "deletions": 820}, "files": [{"sha": "c6ffccf3a82541ba513a2ad25510399394005048", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7c12ec44d2380c17e50bff0195c4678899d338a", "patch": "@@ -1,3 +1,17 @@\n+2017-06-07  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/predicates.md: Replace TARGET_E500_DOUBLE and\n+\tTARGET_E500_SINGLE by 0, simplify.\n+\t* config/rs6000/rs6000.c: Ditto.\n+\t(rs6000_option_override_internal): Delete CHECK_E500_OPTIONS.\n+\t(spe_build_register_parallel): Delete.\n+\t* config/rs6000/rs6000.h: Delete TARGET_E500_SINGLE,\n+\tTARGET_E500_DOUBLE, and CHECK_E500_OPTIONS.\n+\t* config/rs6000/rs6000.md: Replace TARGET_E500_DOUBLE,\n+\tTARGET_E500_SINGLE, and <E500_CONVERT> by 0, simplify.\n+\t(E500_CONVERT): Delete.\n+\t* config/rs6000/spe.md: Remove many patterns and all define_constants.\n+\n 2017-06-07  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/darwin.md: Replace TARGET_FPRS by 1 and simplify."}, {"sha": "dd961a7e9edc08b40bc5415020f326531a05bd72", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=f7c12ec44d2380c17e50bff0195c4678899d338a", "patch": "@@ -299,7 +299,7 @@\n (define_predicate \"gpc_reg_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if ((TARGET_E500_DOUBLE || TARGET_SPE) && invalid_e500_subreg (op, mode))\n+  if (TARGET_SPE && invalid_e500_subreg (op, mode))\n     return 0;\n \n   if (GET_CODE (op) == SUBREG)\n@@ -331,7 +331,7 @@\n (define_predicate \"int_reg_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if ((TARGET_E500_DOUBLE || TARGET_SPE) && invalid_e500_subreg (op, mode))\n+  if (TARGET_SPE && invalid_e500_subreg (op, mode))\n     return 0;\n \n   if (GET_CODE (op) == SUBREG)\n@@ -357,7 +357,7 @@\n (define_predicate \"int_reg_operand_not_pseudo\"\n   (match_operand 0 \"register_operand\")\n {\n-  if ((TARGET_E500_DOUBLE || TARGET_SPE) && invalid_e500_subreg (op, mode))\n+  if (TARGET_SPE && invalid_e500_subreg (op, mode))\n     return 0;\n \n   if (GET_CODE (op) == SUBREG)\n@@ -606,7 +606,7 @@\n     return 0;\n \n   /* Consider all constants with -msoft-float to be easy.  */\n-  if ((TARGET_SOFT_FLOAT || TARGET_E500_SINGLE \n+  if ((TARGET_SOFT_FLOAT\n       || (TARGET_HARD_FLOAT && (TARGET_SINGLE_FLOAT && ! TARGET_DOUBLE_FLOAT)))\n       && mode != DImode)\n     return 1;\n@@ -1014,10 +1014,9 @@\n ;; Return 1 if the operand is either an easy FP constant or memory or reg.\n (define_predicate \"reg_or_none500mem_operand\"\n   (if_then_else (match_code \"mem\")\n-     (and (match_test \"!TARGET_E500_DOUBLE\")\n-\t  (ior (match_operand 0 \"memory_operand\")\n-\t       (ior (match_test \"macho_lo_sum_memory_operand (op, mode)\")\n-\t\t    (match_operand 0 \"volatile_mem_operand\"))))\n+     (ior (match_operand 0 \"memory_operand\")\n+\t  (match_test \"macho_lo_sum_memory_operand (op, mode)\")\n+\t  (match_operand 0 \"volatile_mem_operand\"))\n      (match_operand 0 \"gpc_reg_operand\")))\n \n ;; Return 1 if the operand is CONST_DOUBLE 0, register or memory operand.\n@@ -1137,7 +1136,7 @@\n     return 1;\n \n   /* Do not allow invalid E500 subregs.  */\n-  if ((TARGET_E500_DOUBLE || TARGET_SPE)\n+  if (TARGET_SPE\n       && GET_CODE (op) == SUBREG\n       && invalid_e500_subreg (op, mode))\n     return 0;\n@@ -1205,7 +1204,7 @@\n (define_predicate \"rs6000_nonimmediate_operand\"\n   (match_code \"reg,subreg,mem\")\n {\n-  if ((TARGET_E500_DOUBLE || TARGET_SPE)\n+  if (TARGET_SPE\n       && GET_CODE (op) == SUBREG\n       && invalid_e500_subreg (op, mode))\n     return 0;"}, {"sha": "f1819b3fded5eb92e6ba3e1a419fd6cb3a080cb3", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 12, "deletions": 176, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f7c12ec44d2380c17e50bff0195c4678899d338a", "patch": "@@ -2082,15 +2082,6 @@ rs6000_hard_regno_nregs_internal (int regno, machine_mode mode)\n   else if (ALTIVEC_REGNO_P (regno))\n     reg_size = UNITS_PER_ALTIVEC_WORD;\n \n-  /* The value returned for SCmode in the E500 double case is 2 for\n-     ABI compatibility; storing an SCmode value in a single register\n-     would require function_arg and rs6000_spe_function_arg to handle\n-     SCmode so as to pass the value correctly in a pair of\n-     registers.  */\n-  else if (TARGET_E500_DOUBLE && FLOAT_MODE_P (mode) && mode != SCmode\n-\t   && !DECIMAL_FLOAT_MODE_P (mode) && SPE_SIMD_REGNO_P (regno))\n-    reg_size = UNITS_PER_FP_WORD;\n-\n   else\n     reg_size = UNITS_PER_WORD;\n \n@@ -2862,12 +2853,6 @@ rs6000_debug_reg_global (void)\n   fprintf (stderr, DEBUG_FMT_S, \"soft_float\",\n \t   (TARGET_SOFT_FLOAT ? \"true\" : \"false\"));\n \n-  fprintf (stderr, DEBUG_FMT_S, \"e500_single\",\n-\t   (TARGET_E500_SINGLE ? \"true\" : \"false\"));\n-\n-  fprintf (stderr, DEBUG_FMT_S, \"e500_double\",\n-\t   (TARGET_E500_DOUBLE ? \"true\" : \"false\"));\n-\n   if (TARGET_LINK_STACK)\n     fprintf (stderr, DEBUG_FMT_S, \"link_stack\", \"true\");\n \n@@ -2989,8 +2974,7 @@ rs6000_setup_reg_addr_masks (void)\n \t\t  && !complex_p\n \t\t  && !small_int_vsx_p\n \t\t  && (m2 != DFmode || !TARGET_UPPER_REGS_DF)\n-\t\t  && (m2 != SFmode || !TARGET_UPPER_REGS_SF)\n-\t\t  && !(TARGET_E500_DOUBLE && msize == 8))\n+\t\t  && (m2 != SFmode || !TARGET_UPPER_REGS_SF))\n \t\t{\n \t\t  addr_mask |= RELOAD_REG_PRE_INCDEC;\n \n@@ -3738,9 +3722,6 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t}\n     }\n \n-  if (TARGET_E500_DOUBLE)\n-    rs6000_class_max_nregs[DFmode][GENERAL_REGS] = 1;\n-\n   /* Calculate which modes to automatically generate code to use a the\n      reciprocal divide and square root instructions.  In the future, possibly\n      automatically generate the instructions even if the user did not specify\n@@ -5147,8 +5128,8 @@ rs6000_option_override_internal (bool global_init_p)\n     case PROCESSOR_PPCE5500:\n     case PROCESSOR_PPCE6500:\n \n-      rs6000_single_float = TARGET_E500_SINGLE || TARGET_E500_DOUBLE;\n-      rs6000_double_float = TARGET_E500_DOUBLE;\n+      rs6000_single_float = 0;\n+      rs6000_double_float = 0;\n \n       rs6000_isa_flags &= ~OPTION_MASK_STRING;\n \n@@ -5172,9 +5153,6 @@ rs6000_option_override_internal (bool global_init_p)\n \t       \"point\");\n     }\n \n-  /* Detect invalid option combinations with E500.  */\n-  CHECK_E500_OPTIONS;\n-\n   rs6000_always_hint = (rs6000_cpu != PROCESSOR_POWER4\n \t\t\t&& rs6000_cpu != PROCESSOR_POWER5\n \t\t\t&& rs6000_cpu != PROCESSOR_POWER6\n@@ -8232,36 +8210,6 @@ rs6000_split_v4si_init (rtx operands[])\n bool\n invalid_e500_subreg (rtx op, machine_mode mode)\n {\n-  if (TARGET_E500_DOUBLE)\n-    {\n-      /* Reject (subreg:SI (reg:DF)); likewise with subreg:DI or\n-\t subreg:TI and reg:TF.  Decimal float modes are like integer\n-\t modes (only low part of each register used) for this\n-\t purpose.  */\n-      if (GET_CODE (op) == SUBREG\n-\t  && (mode == SImode || mode == DImode || mode == TImode\n-\t      || mode == DDmode || mode == TDmode || mode == PTImode)\n-\t  && REG_P (SUBREG_REG (op))\n-\t  && (GET_MODE (SUBREG_REG (op)) == DFmode\n-\t      || GET_MODE (SUBREG_REG (op)) == TFmode\n-\t      || GET_MODE (SUBREG_REG (op)) == IFmode\n-\t      || GET_MODE (SUBREG_REG (op)) == KFmode))\n-\treturn true;\n-\n-      /* Reject (subreg:DF (reg:DI)); likewise with subreg:TF and\n-\t reg:TI.  */\n-      if (GET_CODE (op) == SUBREG\n-\t  && (mode == DFmode || mode == TFmode || mode == IFmode\n-\t      || mode == KFmode)\n-\t  && REG_P (SUBREG_REG (op))\n-\t  && (GET_MODE (SUBREG_REG (op)) == DImode\n-\t      || GET_MODE (SUBREG_REG (op)) == TImode\n-\t      || GET_MODE (SUBREG_REG (op)) == PTImode\n-\t      || GET_MODE (SUBREG_REG (op)) == DDmode\n-\t      || GET_MODE (SUBREG_REG (op)) == TDmode))\n-\treturn true;\n-    }\n-\n   if (TARGET_SPE\n       && GET_CODE (op) == SUBREG\n       && mode == SImode\n@@ -8292,13 +8240,6 @@ rs6000_data_alignment (tree type, unsigned int align, enum data_align how)\n \t  else if (align < 128)\n \t    align = 128;\n \t}\n-      else if (TARGET_E500_DOUBLE\n-\t       && TREE_CODE (type) == REAL_TYPE\n-\t       && TYPE_MODE (type) == DFmode)\n-\t{\n-\t  if (align < 64)\n-\t    align = 64;\n-\t}\n     }\n \n   if (how != align_abi)\n@@ -8952,14 +8893,6 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n     case DFmode:\n     case DDmode:\n     case DImode:\n-      /* On e500v2, we may have:\n-\n-\t   (subreg:DF (mem:DI (plus (reg) (const_int))) 0).\n-\n-         Which gets addressed with evldd instructions.  */\n-      if (TARGET_E500_DOUBLE)\n-\treturn SPE_CONST_OFFSET_OK (offset);\n-\n       /* If we are using VSX scalar loads, restrict ourselves to reg+reg\n \t addressing.  */\n       if (VECTOR_MEM_VSX_P (mode))\n@@ -8979,10 +8912,6 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n     case TDmode:\n     case TImode:\n     case PTImode:\n-      if (TARGET_E500_DOUBLE)\n-\treturn (SPE_CONST_OFFSET_OK (offset)\n-\t\t&& SPE_CONST_OFFSET_OK (offset + 8));\n-\n       extra = 8;\n       if (!worst_case)\n \tbreak;\n@@ -9071,9 +9000,6 @@ legitimate_lo_sum_address_p (machine_mode mode, rtx x, int strict)\n   /* quad word addresses are restricted, and we can't use LO_SUM.  */\n   if (mode_supports_vsx_dform_quad (mode))\n     return false;\n-  /* Restrict addressing for DI because of our SUBREG hackery.  */\n-  if (TARGET_E500_DOUBLE && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n-    return false;\n   x = XEXP (x, 1);\n \n   if (TARGET_ELF || TARGET_MACHO)\n@@ -9190,8 +9116,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && ((unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 1)) + 0x8000)\n \t  >= 0x10000 - extra)\n-      && !(SPE_VECTOR_MODE (mode)\n-\t   || (TARGET_E500_DOUBLE && GET_MODE_SIZE (mode) > UNITS_PER_WORD)))\n+      && !SPE_VECTOR_MODE (mode))\n     {\n       HOST_WIDE_INT high_int, low_int;\n       rtx sum;\n@@ -9216,8 +9141,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       return gen_rtx_PLUS (Pmode, XEXP (x, 0),\n \t\t\t   force_reg (Pmode, force_operand (XEXP (x, 1), 0)));\n     }\n-  else if (SPE_VECTOR_MODE (mode)\n-\t   || (TARGET_E500_DOUBLE && GET_MODE_SIZE (mode) > UNITS_PER_WORD))\n+  else if (SPE_VECTOR_MODE (mode))\n     {\n       if (mode == DImode)\n \treturn x;\n@@ -9981,7 +9905,6 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n       && CONST_INT_P (XEXP (x, 1))\n       && reg_offset_p\n       && !SPE_VECTOR_MODE (mode)\n-      && !(TARGET_E500_DOUBLE && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n       && (quad_offset_p || !VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode)))\n     {\n       HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n@@ -10240,8 +10163,7 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n   if (!FLOAT128_2REG_P (mode)\n       && ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n \t  || TARGET_POWERPC64\n-\t  || (mode != DFmode && mode != DDmode)\n-\t  || (TARGET_E500_DOUBLE && mode != DDmode))\n+\t  || (mode != DFmode && mode != DDmode))\n       && (TARGET_POWERPC64 || mode != DImode)\n       && (mode != TImode || VECTOR_MEM_VSX_P (TImode))\n       && mode != PTImode\n@@ -11429,10 +11351,9 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n    fit into 1, whereas DI still needs two.  */\n \n static bool\n-rs6000_member_type_forces_blk (const_tree field, machine_mode mode)\n+rs6000_member_type_forces_blk (const_tree field, machine_mode)\n {\n-  return ((TARGET_SPE && TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE)\n-\t  || (TARGET_E500_DOUBLE && mode == DFmode));\n+  return (TARGET_SPE && TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE);\n }\n \f\n /* Nonzero if we can use a floating-point register to pass this arg.  */\n@@ -12547,66 +12468,13 @@ rs6000_function_arg_advance (cumulative_args_t cum, machine_mode mode,\n \t\t\t\t 0);\n }\n \n-static rtx\n-spe_build_register_parallel (machine_mode mode, int gregno)\n-{\n-  rtx r1, r3, r5, r7;\n-\n-  switch (mode)\n-    {\n-    case DFmode:\n-      r1 = gen_rtx_REG (DImode, gregno);\n-      r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n-      return gen_rtx_PARALLEL (mode, gen_rtvec (1, r1));\n-\n-    case DCmode:\n-    case TFmode:\n-      r1 = gen_rtx_REG (DImode, gregno);\n-      r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n-      r3 = gen_rtx_REG (DImode, gregno + 2);\n-      r3 = gen_rtx_EXPR_LIST (VOIDmode, r3, GEN_INT (8));\n-      return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r3));\n-\n-    case TCmode:\n-      r1 = gen_rtx_REG (DImode, gregno);\n-      r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n-      r3 = gen_rtx_REG (DImode, gregno + 2);\n-      r3 = gen_rtx_EXPR_LIST (VOIDmode, r3, GEN_INT (8));\n-      r5 = gen_rtx_REG (DImode, gregno + 4);\n-      r5 = gen_rtx_EXPR_LIST (VOIDmode, r5, GEN_INT (16));\n-      r7 = gen_rtx_REG (DImode, gregno + 6);\n-      r7 = gen_rtx_EXPR_LIST (VOIDmode, r7, GEN_INT (24));\n-      return gen_rtx_PARALLEL (mode, gen_rtvec (4, r1, r3, r5, r7));\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n /* Determine where to put a SIMD argument on the SPE.  */\n static rtx\n rs6000_spe_function_arg (const CUMULATIVE_ARGS *cum, machine_mode mode,\n \t\t\t const_tree type)\n {\n   int gregno = cum->sysv_gregno;\n \n-  /* On E500 v2, double arithmetic is done on the full 64-bit GPR, but\n-     are passed and returned in a pair of GPRs for ABI compatibility.  */\n-  if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n-\t\t\t     || mode == DCmode || mode == TCmode))\n-    {\n-      int n_words = rs6000_arg_size (mode, type);\n-\n-      /* Doubles go in an odd/even register pair (r5/r6, etc).  */\n-      if (mode == DFmode)\n-\tgregno += (1 - gregno) & 1;\n-\n-      /* Multi-reg args are not split between registers and stack.  */\n-      if (gregno + n_words - 1 > GP_ARG_MAX_REG)\n-\treturn NULL_RTX;\n-\n-      return spe_build_register_parallel (mode, gregno);\n-    }\n   if (cum->stdarg)\n     {\n       int n_words = rs6000_arg_size (mode, type);\n@@ -13099,12 +12967,7 @@ rs6000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t  return gen_rtx_REG (part_mode, GP_ARG_MIN_REG + align_words);\n \t}\n     }\n-  else if (TARGET_SPE_ABI && TARGET_SPE\n-\t   && (SPE_VECTOR_MODE (mode)\n-\t       || (TARGET_E500_DOUBLE && (mode == DFmode\n-\t\t\t\t\t  || mode == DCmode\n-\t\t\t\t\t  || mode == TFmode\n-\t\t\t\t\t  || mode == TCmode))))\n+  else if (TARGET_SPE_ABI && TARGET_SPE && SPE_VECTOR_MODE (mode))\n     return rs6000_spe_function_arg (cum, mode, type);\n \n   else if (abi == ABI_V4)\n@@ -23350,16 +23213,6 @@ rs6000_cannot_change_mode_class (machine_mode from,\n \treturn false;\n     }\n \n-  if (TARGET_E500_DOUBLE\n-      && ((((to) == DFmode) + ((from) == DFmode)) == 1\n-\t  || (((to) == TFmode) + ((from) == TFmode)) == 1\n-\t  || (((to) == IFmode) + ((from) == IFmode)) == 1\n-\t  || (((to) == KFmode) + ((from) == KFmode)) == 1\n-\t  || (((to) == DDmode) + ((from) == DDmode)) == 1\n-\t  || (((to) == TDmode) + ((from) == TDmode)) == 1\n-\t  || (((to) == DImode) + ((from) == DImode)) == 1))\n-    return true;\n-\n   /* Since the VSX register set includes traditional floating point registers\n      and altivec registers, just check for the size being different instead of\n      trying to check whether the modes are vector modes.  Otherwise it won't\n@@ -24220,7 +24073,7 @@ print_operand (FILE *file, rtx x, int code)\n \ttmp = XEXP (x, 0);\n \n \t/* Ugly hack because %y is overloaded.  */\n-\tif ((TARGET_SPE || TARGET_E500_DOUBLE)\n+\tif (TARGET_SPE\n \t    && (GET_MODE_SIZE (GET_MODE (x)) == 8\n \t\t|| FLOAT128_2REG_P (GET_MODE (x))\n \t\t|| GET_MODE (x) == TImode\n@@ -26562,8 +26415,6 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT) ? DFmode : SFmode);\n   else if (ALTIVEC_REGNO_P (reg))\n     reg_mode = V16QImode;\n-  else if (TARGET_E500_DOUBLE && FLOAT128_2REG_P (mode))\n-    reg_mode = DFmode;\n   else\n     reg_mode = word_mode;\n   reg_mode_size = GET_MODE_SIZE (reg_mode);\n@@ -27684,9 +27535,6 @@ spe_func_has_64bit_regs_p (void)\n \n \t      if (SPE_VECTOR_MODE (mode))\n \t\treturn true;\n-\t      if (TARGET_E500_DOUBLE\n-\t\t  && (mode == DFmode || FLOAT128_2REG_P (mode)))\n-\t\treturn true;\n \t    }\n \t}\n     }\n@@ -28635,7 +28483,6 @@ emit_frame_save (rtx frame_reg, machine_mode mode,\n   /* Some cases that need register indexed addressing.  */\n   gcc_checking_assert (!((TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n \t\t\t || (TARGET_VSX && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n-\t\t\t || (TARGET_E500_DOUBLE && mode == DFmode)\n \t\t\t || (TARGET_SPE_ABI\n \t\t\t     && SPE_VECTOR_MODE (mode)\n \t\t\t     && !SPE_CONST_OFFSET_OK (offset))));\n@@ -28656,8 +28503,7 @@ gen_frame_mem_offset (machine_mode mode, rtx reg, int offset)\n \n   int_rtx = GEN_INT (offset);\n \n-  if ((TARGET_SPE_ABI && SPE_VECTOR_MODE (mode) && !SPE_CONST_OFFSET_OK (offset))\n-      || (TARGET_E500_DOUBLE && mode == DFmode))\n+  if (TARGET_SPE_ABI && SPE_VECTOR_MODE (mode) && !SPE_CONST_OFFSET_OK (offset))\n     {\n       offset_rtx = gen_rtx_REG (Pmode, FIXED_SCRATCH);\n       emit_move_insn (offset_rtx, int_rtx);\n@@ -38762,10 +38608,6 @@ rs6000_function_value (const_tree valtype,\n \t   && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI\n \t   && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n     regno = ALTIVEC_ARG_RETURN;\n-  else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n-\t   && (mode == DFmode || mode == DCmode\n-\t       || FLOAT128_IBM_P (mode) || mode == TCmode))\n-    return spe_build_register_parallel (mode, GP_ARG_RETURN);\n   else\n     regno = GP_ARG_RETURN;\n \n@@ -38798,10 +38640,6 @@ rs6000_libcall_value (machine_mode mode)\n     regno = ALTIVEC_ARG_RETURN;\n   else if (COMPLEX_MODE_P (mode) && targetm.calls.split_complex_arg)\n     return rs6000_complex_function_value (mode);\n-  else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n-\t   && (mode == DFmode || mode == DCmode\n-\t       || FLOAT128_IBM_P (mode) || mode == TCmode))\n-    return spe_build_register_parallel (mode, GP_ARG_RETURN);\n   else\n     regno = GP_ARG_RETURN;\n \n@@ -38904,9 +38742,7 @@ rs6000_dwarf_register_span (rtx reg)\n \n   if (TARGET_SPE\n       && regno < 32\n-      && (SPE_VECTOR_MODE (GET_MODE (reg))\n-\t  || (TARGET_E500_DOUBLE && FLOAT_MODE_P (mode)\n-\t      && mode != SFmode && mode != SDmode && mode != SCmode)))\n+      && SPE_VECTOR_MODE (GET_MODE (reg)))\n     ;\n   else\n     return NULL_RTX;"}, {"sha": "66f8170d68a2020687ea21f5795c55668859ac4a", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f7c12ec44d2380c17e50bff0195c4678899d338a", "patch": "@@ -572,9 +572,6 @@ extern int rs6000_vector_align[];\n #define TARGET_SPE_ABI 0\n #define TARGET_SPE 0\n #define TARGET_ISEL64 (TARGET_ISEL && TARGET_POWERPC64)\n-#define TARGET_E500_SINGLE 0\n-#define TARGET_E500_DOUBLE 0\n-#define CHECK_E500_OPTIONS do { } while (0)\n \n /* ISA 2.01 allowed FCFID to be done in 32-bit, previously it was 64-bit only.\n    Enable 32-bit fcfid's on any of the switches for newer ISA machines or\n@@ -1276,13 +1273,9 @@ enum data_align { align_abi, align_opt, align_both };\n      && ((MODE) == VOIDmode || ALTIVEC_OR_VSX_VECTOR_MODE (MODE))\t\\\n      && FP_REGNO_P (REGNO)\t\t\t\t\t\t\\\n    ? V2DFmode\t\t\t\t\t\t\t\t\\\n-   : TARGET_E500_DOUBLE && (MODE) == SImode\t\t\t\t\\\n-   ? SImode\t\t\t\t\t\t\t\t\\\n-   : TARGET_E500_DOUBLE && ((MODE) == VOIDmode || (MODE) == DFmode)\t\\\n+   : FLOAT128_IBM_P (MODE) && FP_REGNO_P (REGNO)\t\t\t\\\n    ? DFmode\t\t\t\t\t\t\t\t\\\n-   : !TARGET_E500_DOUBLE && FLOAT128_IBM_P (MODE) && FP_REGNO_P (REGNO)\t\\\n-   ? DFmode\t\t\t\t\t\t\t\t\\\n-   : !TARGET_E500_DOUBLE && (MODE) == TDmode && FP_REGNO_P (REGNO)\t\\\n+   : (MODE) == TDmode && FP_REGNO_P (REGNO)\t\t\t\t\\\n    ? DImode\t\t\t\t\t\t\t\t\\\n    : choose_hard_reg_mode ((REGNO), (NREGS), false))\n "}, {"sha": "efca26cfd76a4712efe423e329891bf825e79be3", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 16, "deletions": 57, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=f7c12ec44d2380c17e50bff0195c4678899d338a", "patch": "@@ -372,8 +372,8 @@\n \n ; Any hardware-supported floating-point mode\n (define_mode_iterator FP [\n-  (SF \"TARGET_HARD_FLOAT && (TARGET_SINGLE_FLOAT || TARGET_E500_SINGLE)\")\n-  (DF \"TARGET_HARD_FLOAT && (TARGET_DOUBLE_FLOAT || TARGET_E500_DOUBLE)\")\n+  (SF \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\")\n+  (DF \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\")\n   (TF \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\")\n   (IF \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\")\n   (KF \"TARGET_FLOAT128_TYPE\")\n@@ -454,8 +454,7 @@\n (define_mode_attr f64_p9  [(DF \"wb\") (DD \"wn\")])\n \n ; These modes do not fit in integer registers in 32-bit mode.\n-; but on e500v2, the gpr are 64 bit registers\n-(define_mode_iterator DIFD [DI (DF \"!TARGET_E500_DOUBLE\") DD])\n+(define_mode_iterator DIFD [DI DF DD])\n \n ; Iterator for reciprocal estimate instructions\n (define_mode_iterator RECIPF [SF DF V4SF V2DF])\n@@ -614,9 +613,6 @@\n (define_mode_attr SI_CONVERT_FP [(SF \"TARGET_FCFIDS\")\n \t\t\t\t (DF \"TARGET_FCFID\")])\n \n-(define_mode_attr E500_CONVERT [(SF \"0\")\n-\t\t\t\t(DF \"TARGET_E500_DOUBLE\")])\n-\n (define_mode_attr TARGET_FLOAT [(SF \"TARGET_SINGLE_FLOAT\")\n \t\t\t\t(DF \"TARGET_DOUBLE_FLOAT\")])\n \n@@ -4646,7 +4642,7 @@\n (define_expand \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\")\n \t(float_extend:DF (match_operand:SF 1 \"reg_or_none500mem_operand\")))]\n-  \"TARGET_HARD_FLOAT && (TARGET_DOUBLE_FLOAT || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n {\n   if (HONOR_SNANS (SFmode))\n     operands[1] = force_reg (SFmode, operands[1]);\n@@ -4684,7 +4680,7 @@\n (define_expand \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n \t(float_truncate:SF (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && (TARGET_DOUBLE_FLOAT || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"\")\n \n (define_insn \"*truncdfsf2_fpr\"\n@@ -5258,17 +5254,10 @@\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))\n \t      (clobber (match_dup 6))])]\n-  \"TARGET_HARD_FLOAT && (TARGET_DOUBLE_FLOAT || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"\n {\n-  if (TARGET_E500_DOUBLE)\n-    {\n-      if (!REG_P (operands[1]))\n-\toperands[1] = force_reg (SImode, operands[1]);\n-      emit_insn (gen_spe_floatsidf2 (operands[0], operands[1]));\n-      DONE;\n-    }\n-  else if (TARGET_LFIWAX && TARGET_FCFID)\n+  if (TARGET_LFIWAX && TARGET_FCFID)\n     {\n       emit_insn (gen_floatsidf2_lfiwax (operands[0], operands[1]));\n       DONE;\n@@ -5359,17 +5348,10 @@\n \t      (use (match_dup 3))\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))])]\n-  \"TARGET_HARD_FLOAT && (TARGET_DOUBLE_FLOAT || TARGET_E500_DOUBLE)\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"\n {\n-  if (TARGET_E500_DOUBLE)\n-    {\n-      if (!REG_P (operands[1]))\n-\toperands[1] = force_reg (SImode, operands[1]);\n-      emit_insn (gen_spe_floatunssidf2 (operands[0], operands[1]));\n-      DONE;\n-    }\n-  else if (TARGET_LFIWZX && TARGET_FCFID)\n+  if (TARGET_LFIWZX && TARGET_FCFID)\n     {\n       emit_insn (gen_floatunssidf2_lfiwzx (operands[0], operands[1]));\n       DONE;\n@@ -5532,10 +5514,10 @@\n (define_expand \"fix_trunc<mode>si2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && (<TARGET_FLOAT> || <E500_CONVERT>)\"\n+  \"TARGET_HARD_FLOAT && <TARGET_FLOAT>\"\n   \"\n {\n-  if (!<E500_CONVERT> && !TARGET_VSX_SMALL_INTEGER)\n+  if (!TARGET_VSX_SMALL_INTEGER)\n     {\n       rtx src = force_reg (<MODE>mode, operands[1]);\n \n@@ -5680,11 +5662,10 @@\n (define_expand \"fixuns_trunc<mode>si2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\n-   && ((<TARGET_FLOAT> && TARGET_FCTIWUZ && TARGET_STFIWX) || <E500_CONVERT>)\"\n+  \"TARGET_HARD_FLOAT && <TARGET_FLOAT> && TARGET_FCTIWUZ && TARGET_STFIWX\"\n   \"\n {\n-  if (!<E500_CONVERT> && !TARGET_VSX_SMALL_INTEGER)\n+  if (!TARGET_VSX_SMALL_INTEGER)\n     {\n       emit_insn (gen_fixuns_trunc<mode>si2_stfiwx (operands[0], operands[1]));\n       DONE;\n@@ -7432,8 +7413,7 @@\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r\")\n \t(match_operand:FMOVE64 1 \"input_operand\" \"r,Y,r,G,H,F\"))]\n   \"! TARGET_POWERPC64 \n-   && (TARGET_SINGLE_FLOAT || TARGET_SOFT_FLOAT || TARGET_E500_SINGLE\n-       || (<MODE>mode == DDmode && TARGET_E500_DOUBLE))\n+   && (TARGET_SINGLE_FLOAT || TARGET_SOFT_FLOAT)\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"#\"\n@@ -7565,11 +7545,6 @@\n {\n   if (FLOAT128_IEEE_P (<MODE>mode))\n     rs6000_expand_float128_convert (operands[0], operands[1], false);\n-  else if (TARGET_E500_DOUBLE)\n-    {\n-      gcc_assert (<MODE>mode == TFmode);\n-      emit_insn (gen_spe_extenddftf2 (operands[0], operands[1]));\n-    }\n   else if (TARGET_VSX)\n     {\n       if (<MODE>mode == TFmode)\n@@ -7693,11 +7668,6 @@\n {\n   if (FLOAT128_IEEE_P (<MODE>mode))\n     rs6000_expand_float128_convert (operands[0], operands[1], false);\n-  else if (TARGET_E500_DOUBLE)\n-    {\n-      gcc_assert (<MODE>mode == TFmode);\n-      emit_insn (gen_spe_trunctfsf2 (operands[0], operands[1]));\n-    }\n   else if (<MODE>mode == TFmode)\n     emit_insn (gen_trunctfsf2_fprs (operands[0], operands[1]));\n   else if (<MODE>mode == IFmode)\n@@ -7777,8 +7747,6 @@\n     {\n       if (FLOAT128_IEEE_P (<MODE>mode))\n \trs6000_expand_float128_convert (op0, op1, false);\n-      else if (TARGET_E500_DOUBLE && <MODE>mode == TFmode)\n-\temit_insn (gen_spe_fix_trunctfsi2 (op0, op1));\n       else if (<MODE>mode == TFmode)\n \temit_insn (gen_fix_trunctfsi2_fprs (op0, op1));\n       else if (<MODE>mode == IFmode)\n@@ -7980,14 +7948,7 @@\n     }\n \n   label = gen_label_rtx ();\n-  if (TARGET_E500_DOUBLE && <MODE>mode == TFmode)\n-    {\n-      if (flag_finite_math_only && !flag_trapping_math)\n-\temit_insn (gen_spe_abstf2_tst (operands[0], operands[1], label));\n-      else\n-\temit_insn (gen_spe_abstf2_cmp (operands[0], operands[1], label));\n-    }\n-  else if (<MODE>mode == TFmode)\n+  if (<MODE>mode == TFmode)\n     emit_insn (gen_abstf2_internal (operands[0], operands[1], label));\n   else if (<MODE>mode == TFmode)\n     emit_insn (gen_absif2_internal (operands[0], operands[1], label));\n@@ -9791,16 +9752,14 @@\n ;; clobber outputs.  Although those sets expand to multi-ppc-insn\n ;; sequences, using get_attr_length here will smash the operands\n ;; array.  Neither is there an early_cobbler_p predicate.\n-;; Disallow subregs for E500 so we don't munge frob_di_df_2.\n ;; Also this optimization interferes with scalars going into\n ;; altivec registers (the code does reloading through the FPRs).\n (define_peephole2\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"any_operand\" \"\"))\n    (set (match_operand:DF 2 \"gpc_reg_operand\" \"\")\n \t(match_dup 0))]\n-  \"!(TARGET_E500_DOUBLE && GET_CODE (operands[2]) == SUBREG)\n-   && !TARGET_UPPER_REGS_DF\n+  \"!TARGET_UPPER_REGS_DF\n    && peep2_reg_dead_p (2, operands[0])\"\n   [(set (match_dup 2) (match_dup 1))])\n "}, {"sha": "536697b8a9c80983cbaf1cbae942e8be54f41a3d", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 21, "deletions": 568, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7c12ec44d2380c17e50bff0195c4678899d338a/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=f7c12ec44d2380c17e50bff0195c4678899d338a", "patch": "@@ -18,21 +18,6 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-(define_constants\n-  [(CMPDFEQ_GPR\t\t1006)\n-   (TSTDFEQ_GPR\t\t1007)\n-   (CMPDFGT_GPR\t\t1008)\n-   (TSTDFGT_GPR\t\t1009)\n-   (CMPDFLT_GPR\t\t1010)\n-   (TSTDFLT_GPR\t\t1011)\n-   (CMPTFEQ_GPR\t\t1012)\n-   (TSTTFEQ_GPR\t\t1013)\n-   (CMPTFGT_GPR\t\t1014)\n-   (TSTTFGT_GPR\t\t1015)\n-   (CMPTFLT_GPR\t\t1016)\n-   (TSTTFLT_GPR\t\t1017)\n-   ])\n-\n ;; Modes using a 64-bit register.\n (define_mode_iterator SPE64 [DF V4HI V2SF V1DI V2SI])\n \n@@ -42,43 +27,6 @@\n ;; DImode and TImode.\n (define_mode_iterator DITI [DI TI])\n \n-;; Floating point conversion instructions.\n-\n-(define_insn \"spe_fixuns_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(unsigned_fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efdctuiz %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"spe_extendsfdf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n-\t(float_extend:DF (match_operand:SF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efdcfs %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"spe_fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efdctsiz %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"spe_floatunssidf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n-        (unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efdcfui %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"spe_floatsidf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n-\t(float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efdcfsi %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n ;; SPE SIMD instructions\n \n (define_insn \"absv2si2\"\n@@ -2215,8 +2163,7 @@\n (define_insn \"*frob_<SPE64:mode>_<DITI:mode>\"\n   [(set (match_operand:SPE64 0 \"nonimmediate_operand\" \"=r,r\")\n         (subreg:SPE64 (match_operand:DITI 1 \"input_operand\" \"r,m\") 0))]\n-  \"(TARGET_E500_DOUBLE && <SPE64:MODE>mode == DFmode)\n-   || (TARGET_SPE && <SPE64:MODE>mode != DFmode)\"\n+  \"TARGET_SPE && <SPE64:MODE>mode != DFmode\"\n {\n   switch (which_alternative)\n     {\n@@ -2235,32 +2182,18 @@\n (define_insn \"*frob_<SPE64:mode>_ti_8\"\n   [(set (match_operand:SPE64 0 \"nonimmediate_operand\" \"=r\")\n         (subreg:SPE64 (match_operand:TI 1 \"input_operand\" \"r\") 8))]\n-  \"(TARGET_E500_DOUBLE && <SPE64:MODE>mode == DFmode)\n-   || (TARGET_SPE && <SPE64:MODE>mode != DFmode)\"\n+  \"TARGET_SPE && <SPE64:MODE>mode != DFmode\"\n {\n   if (WORDS_BIG_ENDIAN)\n     return \"evmergelo %0,%Y1,%Z1\";\n   else\n     return \"evmergelo %0,%Z1,%Y1\";\n })\n \n-(define_insn \"*frob_tf_ti\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=r\")\n-        (subreg:TF (match_operand:TI 1 \"gpc_reg_operand\" \"r\") 0))]\n-  \"TARGET_E500_DOUBLE\"\n-{\n-  if (WORDS_BIG_ENDIAN)\n-    return \"evmergelo %0,%1,%L1\\;evmergelo %L0,%Y1,%Z1\";\n-  else\n-    return \"evmergelo %L0,%Z1,%Y1\\;evmergelo %0,%L1,%1\";\n-}\n-  [(set_attr \"length\" \"8\")])\n-\n (define_insn \"*frob_<mode>_di_2\"\n   [(set (subreg:DI (match_operand:SPE64TF 0 \"nonimmediate_operand\" \"+&r,r\") 0)\n         (match_operand:DI 1 \"input_operand\" \"r,m\"))]\n-  \"(TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-   || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode)\"\n+  \"TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\"\n {\n   switch (which_alternative)\n     {\n@@ -2276,30 +2209,10 @@\n     }\n })\n \n-(define_insn \"*frob_tf_di_8_2\"\n-  [(set (subreg:DI (match_operand:TF 0 \"nonimmediate_operand\" \"+&r,r\") 8)\n-        (match_operand:DI 1 \"input_operand\" \"r,m\"))]\n-  \"TARGET_E500_DOUBLE\"\n-{\n-  switch (which_alternative)\n-    {\n-    default:\n-      gcc_unreachable ();\n-    case 0:\n-      if (WORDS_BIG_ENDIAN)\n-\treturn \"evmergelo %L0,%1,%L1\";\n-      else\n-\treturn \"evmergelo %L0,%L1,%1\";\n-    case 1:\n-      return \"evldd%X1 %L0,%y1\";\n-    }\n-})\n-\n (define_insn \"*frob_di_<mode>\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r\")\n         (subreg:DI (match_operand:SPE64TF 1 \"input_operand\" \"r\") 0))]\n-  \"(TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-   || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode)\"\n+  \"TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\"\n {\n   if (WORDS_BIG_ENDIAN)\n     return \"evmergehi %0,%1,%1\\;mr %L0,%1\";\n@@ -2308,23 +2221,10 @@\n }\n   [(set_attr \"length\" \"8\")])\n \n-(define_insn \"*frob_ti_tf\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=&r\")\n-        (subreg:TI (match_operand:TF 1 \"input_operand\" \"r\") 0))]\n-  \"TARGET_E500_DOUBLE\"\n-{\n-  if (WORDS_BIG_ENDIAN)\n-    return \"evmergehi %0,%1,%1\\;mr %L0,%1\\;evmergehi %Y0,%L1,%L1\\;mr %Z0,%L1\";\n-  else\n-    return \"evmergehi %Z0,%L1,%L1\\;mr %Y0,%L1\\;evmergehi %L0,%1,%1\\;mr %0,%1\";\n-}\n-  [(set_attr \"length\" \"16\")])\n-\n (define_insn \"*frob_<DITI:mode>_<SPE64:mode>_2\"\n   [(set (subreg:SPE64 (match_operand:DITI 0 \"register_operand\" \"+&r,r\") 0)\n \t(match_operand:SPE64 1 \"input_operand\" \"r,m\"))]\n-  \"(TARGET_E500_DOUBLE && <SPE64:MODE>mode == DFmode)\n-   || (TARGET_SPE && <SPE64:MODE>mode != DFmode)\"\n+  \"TARGET_SPE && <SPE64:MODE>mode != DFmode\"\n   \"*\n {\n   switch (which_alternative)\n@@ -2373,8 +2273,7 @@\n (define_insn \"*frob_ti_<mode>_8_2\"\n   [(set (subreg:SPE64 (match_operand:TI 0 \"register_operand\" \"+&r,r\") 8)\n \t(match_operand:SPE64 1 \"input_operand\" \"r,m\"))]\n-  \"(TARGET_E500_DOUBLE && <MODE>mode == DFmode)\n-   || (TARGET_SPE && <MODE>mode != DFmode)\"\n+  \"TARGET_SPE && <MODE>mode != DFmode\"\n   \"*\n {\n   switch (which_alternative)\n@@ -2412,24 +2311,11 @@\n }\"\n   [(set_attr \"length\" \"8,8\")])\n \n-(define_insn \"*frob_ti_tf_2\"\n-  [(set (subreg:TF (match_operand:TI 0 \"gpc_reg_operand\" \"=&r\") 0)\n-\t(match_operand:TF 1 \"input_operand\" \"r\"))]\n-  \"TARGET_E500_DOUBLE\"\n-{\n-  if (WORDS_BIG_ENDIAN)\n-    return \"evmergehi %0,%1,%1\\;mr %L0,%1\\;evmergehi %Y0,%L1,%L1\\;mr %Z0,%L1\";\n-  else\n-    return \"evmergehi %Z0,%L1,%L1\\;mr %Y0,%L1\\;evmergehi %L0,%1,%1\\;mr %0,%1\";\n-}\n-  [(set_attr \"length\" \"16\")])\n-\n (define_insn \"mov_si<mode>_e500_subreg0_be\"\n   [(set (subreg:SI (match_operand:SPE64TF 0 \"register_operand\" \"+r,&r\") 0)\n \t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n   \"WORDS_BIG_ENDIAN\n-   && ((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-       || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\"\n+   && (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode)\"\n   \"@\n    evmergelo %0,%1,%0\n    evmergelohi %0,%0,%0\\;lwz%U1%X1 %0,%1\\;evmergelohi %0,%0,%0\"\n@@ -2439,8 +2325,7 @@\n   [(set (subreg:SI (match_operand:SPE64TF 0 \"register_operand\" \"+r,r\") 0)\n \t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n   \"!WORDS_BIG_ENDIAN\n-   && ((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-       || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\"\n+   && (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode)\"\n   \"@\n    mr %0,%1\n    lwz%U1%X1 %0,%1\")\n@@ -2450,9 +2335,8 @@\n \t(lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")\n \t\t   (match_operand 2 \"\" \"\")))]\n   \"WORDS_BIG_ENDIAN\n-   && (((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-\t|| (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\n-       && TARGET_ELF && !TARGET_64BIT && can_create_pseudo_p ())\"\n+   && TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\n+   && TARGET_ELF && !TARGET_64BIT && can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n   [(pc)]\n@@ -2469,9 +2353,8 @@\n \t(lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")\n \t\t   (match_operand 2 \"\" \"\")))]\n   \"!WORDS_BIG_ENDIAN\n-   && (((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-\t|| (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\n-       && TARGET_ELF && !TARGET_64BIT)\"\n+   && TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\n+   && TARGET_ELF && !TARGET_64BIT\"\n   \"addi %0,%1,%K2\")\n \n ;; ??? Could use evstwwe for memory stores in some cases, depending on\n@@ -2480,8 +2363,7 @@\n   [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,m\")\n \t(subreg:SI (match_operand:SPE64TF 1 \"register_operand\" \"+r,&r\") 0))]\n   \"WORDS_BIG_ENDIAN\n-   && ((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-       || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\"\n+   && TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\"\n   \"@\n    evmergelohi %0,%1,%1\n    evmergelohi %1,%1,%1\\;stw%U0%X0 %1,%0\"\n@@ -2491,8 +2373,7 @@\n   [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,m\")\n \t(subreg:SI (match_operand:SPE64TF 1 \"register_operand\" \"r,r\") 0))]\n   \"!WORDS_BIG_ENDIAN\n-   && ((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-       || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\"\n+   && TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\"\n   \"@\n    mr %0,%1\n    stw%U0%X0 %1,%0\")\n@@ -2501,8 +2382,7 @@\n   [(set (subreg:SI (match_operand:SPE64TF 0 \"register_operand\" \"+r,r\") 4)\n \t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n   \"WORDS_BIG_ENDIAN\n-   && ((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-       || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\"\n+   && TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\"\n   \"@\n    mr %0,%1\n    lwz%U1%X1 %0,%1\")\n@@ -2511,8 +2391,7 @@\n   [(set (subreg:SI (match_operand:SPE64TF 0 \"register_operand\" \"+r,&r\") 4)\n \t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n   \"!WORDS_BIG_ENDIAN\n-   && ((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-       || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\"\n+   && TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\"\n   \"@\n    evmergelo %0,%1,%0\n    evmergelohi %0,%0,%0\\;lwz%U1%X1 %0,%1\\;evmergelohi %0,%0,%0\"\n@@ -2523,8 +2402,7 @@\n \t(lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")\n \t\t   (match_operand 2 \"\" \"\")))]\n   \"WORDS_BIG_ENDIAN\n-   && ((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-       || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\n+   && TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\n    && TARGET_ELF && !TARGET_64BIT\"\n   \"addi %0,%1,%K2\")\n \n@@ -2533,9 +2411,8 @@\n \t(lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")\n \t\t   (match_operand 2 \"\" \"\")))]\n   \"!WORDS_BIG_ENDIAN\n-   && (((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-\t|| (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\n-       && TARGET_ELF && !TARGET_64BIT && can_create_pseudo_p ())\"\n+   && TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\n+   && TARGET_ELF && !TARGET_64BIT && can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n   [(pc)]\n@@ -2551,8 +2428,7 @@\n   [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,m\")\n \t(subreg:SI (match_operand:SPE64TF 1 \"register_operand\" \"r,r\") 4))]\n   \"WORDS_BIG_ENDIAN\n-   && ((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-       || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\"\n+   && TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\"\n   \"@\n    mr %0,%1\n    stw%U0%X0 %1,%0\")\n@@ -2561,287 +2437,12 @@\n   [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,m\")\n \t(subreg:SI (match_operand:SPE64TF 1 \"register_operand\" \"+r,&r\") 4))]\n   \"!WORDS_BIG_ENDIAN\n-   && ((TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n-       || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode))\"\n+   && TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode\"\n   \"@\n    evmergelohi %0,%1,%1\n    evmergelohi %1,%1,%1\\;stw%U0%X0 %1,%0\"\n   [(set_attr \"length\" \"4,8\")])\n \n-(define_insn \"*mov_sitf_e500_subreg8_be\"\n-  [(set (subreg:SI (match_operand:TF 0 \"register_operand\" \"+r,&r\") 8)\n-\t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n-  \"WORDS_BIG_ENDIAN && TARGET_E500_DOUBLE\"\n-  \"@\n-   evmergelo %L0,%1,%L0\n-   evmergelohi %L0,%L0,%L0\\;lwz%U1%X1 %L0,%1\\;evmergelohi %L0,%L0,%L0\"\n-  [(set_attr \"length\" \"4,12\")])\n-\n-(define_insn \"*mov_sitf_e500_subreg8_le\"\n-  [(set (subreg:SI (match_operand:TF 0 \"register_operand\" \"+r,r\") 8)\n-\t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n-  \"!WORDS_BIG_ENDIAN && TARGET_E500_DOUBLE\"\n-  \"@\n-   mr %L0,%1\n-   lwz%U1%X1 %L0,%1\")\n-\n-(define_insn \"*mov_sitf_e500_subreg8_2_be\"\n-  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,m\")\n-\t(subreg:SI (match_operand:TF 1 \"register_operand\" \"+r,&r\") 8))]\n-  \"WORDS_BIG_ENDIAN && TARGET_E500_DOUBLE\"\n-  \"@\n-   evmergelohi %0,%L1,%L1\n-   evmergelohi %L1,%L1,%L1\\;stw%U0%X0 %L1,%0\"\n-  [(set_attr \"length\" \"4,8\")])\n-\n-(define_insn \"*mov_sitf_e500_subreg8_2_le\"\n-  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,m\")\n-\t(subreg:SI (match_operand:TF 1 \"register_operand\" \"r,r\") 8))]\n-  \"!WORDS_BIG_ENDIAN && TARGET_E500_DOUBLE\"\n-  \"@\n-   mr %0,%L1\n-   stw%U0%X0 %L1,%0\")\n-\n-(define_insn \"*mov_sitf_e500_subreg12_be\"\n-  [(set (subreg:SI (match_operand:TF 0 \"register_operand\" \"+r,r\") 12)\n-\t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n-  \"WORDS_BIG_ENDIAN && TARGET_E500_DOUBLE\"\n-  \"@\n-   mr %L0,%1\n-   lwz%U1%X1 %L0,%1\")\n-\n-(define_insn \"*mov_sitf_e500_subreg12_le\"\n-  [(set (subreg:SI (match_operand:TF 0 \"register_operand\" \"+r,&r\") 12)\n-\t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n-  \"!WORDS_BIG_ENDIAN && TARGET_E500_DOUBLE\"\n-  \"@\n-   evmergelo %L0,%1,%L0\n-   evmergelohi %L0,%L0,%L0\\;lwz%U1%X1 %L0,%1\\;evmergelohi %L0,%L0,%L0\"\n-  [(set_attr \"length\" \"4,12\")])\n-\n-(define_insn \"*mov_sitf_e500_subreg12_2_be\"\n-  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,m\")\n-\t(subreg:SI (match_operand:TF 1 \"register_operand\" \"r,r\") 12))]\n-  \"WORDS_BIG_ENDIAN && TARGET_E500_DOUBLE\"\n-  \"@\n-   mr %0,%L1\n-   stw%U0%X0 %L1,%0\")\n-\n-(define_insn \"*mov_sitf_e500_subreg12_2_le\"\n-  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,m\")\n-\t(subreg:SI (match_operand:TF 1 \"register_operand\" \"+r,&r\") 12))]\n-  \"!WORDS_BIG_ENDIAN && TARGET_E500_DOUBLE\"\n-  \"@\n-   evmergelohi %0,%L1,%L1\n-   evmergelohi %L1,%L1,%L1\\;stw%U0%X0 %L1,%0\"\n-  [(set_attr \"length\" \"4,8\")])\n-\n-;; FIXME: Allow r=CONST0.\n-(define_insn \"*movdf_e500_double\"\n-  [(set (match_operand:DF 0 \"rs6000_nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,m,r\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\n-    && (gpc_reg_operand (operands[0], DFmode)\n-        || gpc_reg_operand (operands[1], DFmode))\"\n-  \"*\n- {\n-   switch (which_alternative)\n-     {\n-     case 0:\n-       return \\\"evor %0,%1,%1\\\";\n-     case 1:\n-       return \\\"evldd%X1 %0,%y1\\\";\n-     case 2:\n-       return \\\"evstdd%X0 %1,%y0\\\";\n-     default:\n-       gcc_unreachable ();\n-     }\n- }\"\n-  [(set_attr \"type\" \"*,vecload,vecstore\")\n-   (set_attr \"length\" \"*,*,*\")])\n-\n-(define_insn \"spe_truncdfsf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-\t(float_truncate:SF (match_operand:DF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efscfd %0,%1\")\n-\n-(define_insn \"spe_absdf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n-\t(abs:DF (match_operand:DF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efdabs %0,%1\")\n-\n-(define_insn \"spe_nabsdf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n-\t(neg:DF (abs:DF (match_operand:DF 1 \"gpc_reg_operand\" \"r\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efdnabs %0,%1\")\n-\n-(define_insn \"spe_negdf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n-\t(neg:DF (match_operand:DF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efdneg %0,%1\")\n-\n-(define_insn \"spe_adddf3\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n-\t(plus:DF (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efdadd %0,%1,%2\")\n-\n-(define_insn \"spe_subdf3\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n-\t(minus:DF (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n-\t\t  (match_operand:DF 2 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efdsub %0,%1,%2\")\n-\n-(define_insn \"spe_muldf3\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n-\t(mult:DF (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efdmul %0,%1,%2\")\n-\n-(define_insn \"spe_divdf3\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n-\t(div:DF (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n-\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n-  \"efddiv %0,%1,%2\")\n-\n-;; Double-precision floating point instructions for IBM long double.\n-\n-(define_insn_and_split \"spe_trunctfdf2_internal1\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r,?r\")\n-\t(float_truncate:DF (match_operand:TF 1 \"gpc_reg_operand\" \"0,r\")))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n-  \"@\n-   #\n-   evor %0,%1,%1\"\n-  \"&& reload_completed && REGNO (operands[0]) == REGNO (operands[1])\"\n-  [(const_int 0)]\n-{\n-  emit_note (NOTE_INSN_DELETED);\n-  DONE;\n-})\n-\n-(define_insn_and_split \"spe_trunctfsf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-\t(float_truncate:SF (match_operand:TF 1 \"gpc_reg_operand\" \"r\")))\n-   (clobber (match_scratch:DF 2 \"=r\"))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 2)\n-\t(float_truncate:DF (match_dup 1)))\n-   (set (match_dup 0)\n-\t(float_truncate:SF (match_dup 2)))]\n-  \"\")\n-\n-(define_insn \"spe_extenddftf2\"\n-  [(set (match_operand:TF 0 \"rs6000_nonimmediate_operand\" \"=r,?r,r,o\")\n-\t(float_extend:TF (match_operand:DF 1 \"input_operand\" \"0,r,m,r\")))\n-   (clobber (match_scratch:DF 2 \"=X,X,X,&r\"))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n-  \"@\n-   evxor %L0,%L0,%L0\n-   evor %0,%1,%1\\;evxor %L0,%L0,%L0\n-   evldd%X1 %0,%y1\\;evxor %L0,%L0,%L0\n-   evstdd%X0 %1,%y0\\;evxor %2,%2,%2\\;evstdd %2,%Y0\"\n-  [(set_attr \"length\" \"4,8,8,12\")])\n-\n-(define_expand \"spe_fix_trunctfsi2\"\n-  [(parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t\t   (fix:SI (match_operand:TF 1 \"gpc_reg_operand\" \"\")))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))\n-\t      (clobber (match_dup 4))])]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n-{\n-  operands[2] = gen_reg_rtx (DFmode);\n-  operands[3] = gen_reg_rtx (SImode);\n-  operands[4] = gen_reg_rtx (SImode);\n-})\n-\n-; Like fix_trunc_helper, add with rounding towards 0.\n-(define_insn \"spe_fix_trunctfsi2_internal\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-        (fix:SI (match_operand:TF 1 \"gpc_reg_operand\" \"r\")))\n-   (clobber (match_operand:DF 2 \"gpc_reg_operand\" \"=r\"))\n-   (clobber (match_operand:SI 3 \"gpc_reg_operand\" \"=&r\"))\n-   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=&r\"))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n-  \"mfspefscr %3\\;rlwinm %4,%3,0,0,29\\;ori %4,%4,1\\;efdadd %2,%1,%L1\\;mtspefscr %3\\;efdctsiz %0, %2\"\n-  [(set_attr \"length\" \"24\")])\n-\n-(define_insn \"spe_negtf2_internal\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=r\")\n-\t(neg:TF (match_operand:TF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n-  \"*\n-{\n-  if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-    return \\\"efdneg %L0,%L1\\;efdneg %0,%1\\\";\n-  else\n-    return \\\"efdneg %0,%1\\;efdneg %L0,%L1\\\";\n-}\"\n-  [(set_attr \"length\" \"8\")])\n-\n-(define_expand \"spe_abstf2_cmp\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n-\t(match_operand:TF 1 \"gpc_reg_operand\" \"f\"))\n-   (set (match_dup 3) (match_dup 5))\n-   (set (match_dup 5) (abs:DF (match_dup 5)))\n-   (set (match_dup 4) (unspec:CCFP [(compare:CCFP (match_dup 3)\n-                                                  (match_dup 5))] CMPDFEQ_GPR))\n-   (set (pc) (if_then_else (eq (match_dup 4) (const_int 0))\n-\t\t\t   (label_ref (match_operand 2 \"\" \"\"))\n-\t\t\t   (pc)))\n-   (set (match_dup 6) (neg:DF (match_dup 6)))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n-  \"\n-{\n-  const int hi_word = LONG_DOUBLE_LARGE_FIRST ? 0 : GET_MODE_SIZE (DFmode);\n-  const int lo_word = LONG_DOUBLE_LARGE_FIRST ? GET_MODE_SIZE (DFmode) : 0;\n-  operands[3] = gen_reg_rtx (DFmode);\n-  operands[4] = gen_reg_rtx (CCFPmode);\n-  operands[5] = simplify_gen_subreg (DFmode, operands[0], TFmode, hi_word);\n-  operands[6] = simplify_gen_subreg (DFmode, operands[0], TFmode, lo_word);\n-}\")\n-\n-(define_expand \"spe_abstf2_tst\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n-\t(match_operand:TF 1 \"gpc_reg_operand\" \"f\"))\n-   (set (match_dup 3) (match_dup 5))\n-   (set (match_dup 5) (abs:DF (match_dup 5)))\n-   (set (match_dup 4) (unspec:CCFP [(compare:CCFP (match_dup 3)\n-                                                  (match_dup 5))] TSTDFEQ_GPR))\n-   (set (pc) (if_then_else (eq (match_dup 4) (const_int 0))\n-\t\t\t   (label_ref (match_operand 2 \"\" \"\"))\n-\t\t\t   (pc)))\n-   (set (match_dup 6) (neg:DF (match_dup 6)))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n-  \"\n-{\n-  const int hi_word = LONG_DOUBLE_LARGE_FIRST ? 0 : GET_MODE_SIZE (DFmode);\n-  const int lo_word = LONG_DOUBLE_LARGE_FIRST ? GET_MODE_SIZE (DFmode) : 0;\n-  operands[3] = gen_reg_rtx (DFmode);\n-  operands[4] = gen_reg_rtx (CCFPmode);\n-  operands[5] = simplify_gen_subreg (DFmode, operands[0], TFmode, hi_word);\n-  operands[6] = simplify_gen_subreg (DFmode, operands[0], TFmode, lo_word);\n-}\")\n-\n ;; Vector move instructions.\n \n (define_expand \"movv2si\"\n@@ -3155,154 +2756,6 @@\n ;; We have 2 variants for each.  One for IEEE compliant math and one\n ;; for non IEEE compliant math.\n \n-;; Same thing, but for double-precision.\n-\n-(define_insn \"cmpdfeq_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n-\t CMPDFEQ_GPR))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\n-   && !(flag_finite_math_only && !flag_trapping_math)\"\n-  \"efdcmpeq %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmp\")])\n-\n-(define_insn \"tstdfeq_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n-\t TSTDFEQ_GPR))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\n-   && flag_finite_math_only && !flag_trapping_math\"\n-  \"efdtsteq %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmpsimple\")])\n-\n-(define_insn \"cmpdfgt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n-\t CMPDFGT_GPR))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\n-   && !(flag_finite_math_only && !flag_trapping_math)\"\n-  \"efdcmpgt %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmp\")])\n-\n-(define_insn \"tstdfgt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n-\t TSTDFGT_GPR))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\n-   && flag_finite_math_only && !flag_trapping_math\"\n-  \"efdtstgt %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmpsimple\")])\n-\n-(define_insn \"cmpdflt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n-\t CMPDFLT_GPR))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\n-   && !(flag_finite_math_only && !flag_trapping_math)\"\n-  \"efdcmplt %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmp\")])\n-\n-(define_insn \"tstdflt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n-\t TSTDFLT_GPR))]\n-  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\n-   && flag_finite_math_only && !flag_trapping_math\"\n-  \"efdtstlt %0,%1,%2\"\n-  [(set_attr \"type\" \"veccmpsimple\")])\n-\n-;; Same thing, but for IBM long double.\n-\n-(define_insn \"cmptfeq_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n-\t CMPTFEQ_GPR))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n-   && !(flag_finite_math_only && !flag_trapping_math)\"\n-  \"efdcmpeq %0,%1,%2\\;bng %0,$+8\\;efdcmpeq %0,%L1,%L2\"\n-  [(set_attr \"type\" \"veccmp\")\n-   (set_attr \"length\" \"12\")])\n-\n-(define_insn \"tsttfeq_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n-\t TSTTFEQ_GPR))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n-   && flag_finite_math_only && !flag_trapping_math\"\n-  \"efdtsteq %0,%1,%2\\;bng %0,$+8\\;efdtsteq %0,%L1,%L2\"\n-  [(set_attr \"type\" \"veccmpsimple\")\n-   (set_attr \"length\" \"12\")])\n-\n-(define_insn \"cmptfgt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n-\t CMPTFGT_GPR))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n-   && !(flag_finite_math_only && !flag_trapping_math)\"\n-  \"efdcmpgt %0,%1,%2\\;bgt %0,$+16\\;efdcmpeq %0,%1,%2\\;bng %0,$+8\\;efdcmpgt %0,%L1,%L2\"\n-  [(set_attr \"type\" \"veccmp\")\n-   (set_attr \"length\" \"20\")])\n-\n-(define_insn \"tsttfgt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n-\t TSTTFGT_GPR))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n-   && flag_finite_math_only && !flag_trapping_math\"\n-  \"efdtstgt %0,%1,%2\\;bgt %0,$+16\\;efdtsteq %0,%1,%2\\;bng %0,$+8\\;efdtstgt %0,%L1,%L2\"\n-  [(set_attr \"type\" \"veccmpsimple\")\n-   (set_attr \"length\" \"20\")])\n-\n-(define_insn \"cmptflt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n-\t CMPTFLT_GPR))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n-   && !(flag_finite_math_only && !flag_trapping_math)\"\n-  \"efdcmplt %0,%1,%2\\;bgt %0,$+16\\;efdcmpeq %0,%1,%2\\;bng %0,$+8\\;efdcmplt %0,%L1,%L2\"\n-  [(set_attr \"type\" \"veccmp\")\n-   (set_attr \"length\" \"20\")])\n-\n-(define_insn \"tsttflt_gpr\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CCFP\n-\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n-\t TSTTFLT_GPR))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n-   && flag_finite_math_only && !flag_trapping_math\"\n-  \"efdtstlt %0,%1,%2\\;bgt %0,$+16\\;efdtsteq %0,%1,%2\\;bng %0,$+8\\;efdtstlt %0,%L1,%L2\"\n-  [(set_attr \"type\" \"veccmpsimple\")\n-   (set_attr \"length\" \"20\")])\n-\n ;; Out-of-line prologues and epilogues.\n (define_insn \"*save_gpregs_spe\"\n   [(match_parallel 0 \"any_parallel_operand\""}]}