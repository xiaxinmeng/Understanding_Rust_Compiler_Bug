{"sha": "4bbed9ce68818456826d1d25441ef7c1e0d2d85b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJiZWQ5Y2U2ODgxODQ1NjgyNmQxZDI1NDQxZWY3YzFlMGQyZDg1Yg==", "commit": {"author": {"name": "Dominik Vogt", "email": "vogt@linux.vnet.ibm.com", "date": "2014-10-28T17:29:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-28T17:29:40Z"}, "message": "godump.c (precision_to_units): New helper function.\n\ngcc/:\n        * godump.c (precision_to_units): New helper function.\n        (go_append_artificial_name): Ditto.\n        (go_append_decl_name): Ditto.\n        (go_append_bitfield): Ditto.\n        (go_get_uinttype_for_precision): Ditto.\n        (go_append_padding): Ditto.\n        (go_force_record_alignment): Ditto.\n        (go_format_type): Represent unions with an array of uints of the size\n        of the alignment in go.  This fixes the 'random' size of the union's\n        representation using just the first field.\n        (go_format_type): Add argument that indicates whether a record is\n        nested (used for generation of artificial go names).\n        (go_output_fndecl): Adapt to new go_format_type signature.\n        (go_output_typedef): Ditto.\n        (go_output_var): Ditto.\n        (go_output_var): Prefer to output type as alias (typedef).\n        (go_format_type): Bitfields in records are simulated as arrays of bytes\n        in go.\n\n        * godump.c (go_format_type): Fix handling of arrays with zero elements.\ngcc/testsuite/:\n        * gcc.misc-tests/godump.exp: New.\n        * gcc.misc-tests/godump-1.c: New.\n\nFrom-SVN: r216806", "tree": {"sha": "b48b4e78ca9ac203cf3205763cdd885ebe111c72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b48b4e78ca9ac203cf3205763cdd885ebe111c72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bbed9ce68818456826d1d25441ef7c1e0d2d85b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bbed9ce68818456826d1d25441ef7c1e0d2d85b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bbed9ce68818456826d1d25441ef7c1e0d2d85b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bbed9ce68818456826d1d25441ef7c1e0d2d85b/comments", "author": {"login": "vogtd", "id": 9690100, "node_id": "MDQ6VXNlcjk2OTAxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/9690100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vogtd", "html_url": "https://github.com/vogtd", "followers_url": "https://api.github.com/users/vogtd/followers", "following_url": "https://api.github.com/users/vogtd/following{/other_user}", "gists_url": "https://api.github.com/users/vogtd/gists{/gist_id}", "starred_url": "https://api.github.com/users/vogtd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vogtd/subscriptions", "organizations_url": "https://api.github.com/users/vogtd/orgs", "repos_url": "https://api.github.com/users/vogtd/repos", "events_url": "https://api.github.com/users/vogtd/events{/privacy}", "received_events_url": "https://api.github.com/users/vogtd/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c582198bd9e28ee85e7bf4d4caa68e1ce9b0d924", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c582198bd9e28ee85e7bf4d4caa68e1ce9b0d924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c582198bd9e28ee85e7bf4d4caa68e1ce9b0d924"}], "stats": {"total": 907, "additions": 813, "deletions": 94}, "files": [{"sha": "a2f87f76557e70418722118af9e7e4ce9ce09efa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbed9ce68818456826d1d25441ef7c1e0d2d85b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbed9ce68818456826d1d25441ef7c1e0d2d85b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bbed9ce68818456826d1d25441ef7c1e0d2d85b", "patch": "@@ -1,3 +1,26 @@\n+2014-10-28  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+        * godump.c (precision_to_units): New helper function.\n+        (go_append_artificial_name): Ditto.\n+        (go_append_decl_name): Ditto.\n+        (go_append_bitfield): Ditto.\n+        (go_get_uinttype_for_precision): Ditto.\n+        (go_append_padding): Ditto.\n+        (go_force_record_alignment): Ditto.\n+        (go_format_type): Represent unions with an array of uints of the size\n+        of the alignment in go.  This fixes the 'random' size of the union's\n+        representation using just the first field.\n+        (go_format_type): Add argument that indicates whether a record is\n+        nested (used for generation of artificial go names).\n+        (go_output_fndecl): Adapt to new go_format_type signature.\n+        (go_output_typedef): Ditto.\n+        (go_output_var): Ditto.\n+        (go_output_var): Prefer to output type as alias (typedef).\n+        (go_format_type): Bitfields in records are simulated as arrays of bytes\n+        in go.\n+\n+        * godump.c (go_format_type): Fix handling of arrays with zero elements.\n+\n 2014-10-28  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* cgraph.h: Flatten.  Remove all include files."}, {"sha": "7a0566485f6fbc132d72478357a19525ba5406bd", "filename": "gcc/godump.c", "status": "modified", "additions": 267, "deletions": 94, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbed9ce68818456826d1d25441ef7c1e0d2d85b/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbed9ce68818456826d1d25441ef7c1e0d2d85b/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=4bbed9ce68818456826d1d25441ef7c1e0d2d85b", "patch": "@@ -37,6 +37,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"obstack.h\"\n #include \"debug.h\"\n #include \"wide-int-print.h\"\n+#include \"stor-layout.h\"\n+#include \"defaults.h\"\n \n /* We dump this information from the debug hooks.  This gives us a\n    stable and maintainable API to hook into.  In order to work\n@@ -73,6 +75,15 @@ struct macro_hash_value\n   char *value;\n };\n \n+/* Returns the number of units necessary to represent an integer with the given\n+   PRECISION (in bits).  */\n+\n+static inline unsigned int\n+precision_to_units (unsigned int precision)\n+{\n+  return (precision + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n+}\n+\n /* Calculate the hash value for an entry in the macro hash table.  */\n \n static hashval_t\n@@ -552,19 +563,132 @@ go_append_string (struct obstack *ob, tree id)\n   obstack_grow (ob, IDENTIFIER_POINTER (id), IDENTIFIER_LENGTH (id));\n }\n \n+/* Given an integer PRECISION in bits, returns a constant string that is the\n+   matching go int or uint type (depending on the IS_UNSIGNED flag).  Returns a\n+   NULL pointer if there is no matching go type.  */\n+\n+static const char *\n+go_get_uinttype_for_precision (unsigned int precision, bool is_unsigned)\n+{\n+  switch (precision)\n+    {\n+    case 8:\n+      return is_unsigned ? \"uint8\" : \"int8\";\n+    case 16:\n+      return is_unsigned ? \"uint16\" : \"int16\";\n+    case 32:\n+      return is_unsigned ? \"uint32\" : \"int32\";\n+    case 64:\n+      return is_unsigned ? \"uint64\" : \"int64\";\n+    default:\n+      return NULL;\n+    }\n+}\n+\n+/* Append an artificial variable name with the suffix _INDEX to OB.  Returns\n+   INDEX + 1.  */\n+\n+static unsigned int\n+go_append_artificial_name (struct obstack *ob, unsigned int index)\n+{\n+  char buf[100];\n+\n+  /* FIXME: identifier may not be unique.  */\n+  obstack_grow (ob, \"Godump_\", 7);\n+  snprintf (buf, sizeof buf, \"%u\", index);\n+  obstack_grow (ob, buf, strlen (buf));\n+\n+  return index + 1;\n+}\n+\n+/* Append the variable name from DECL to OB.  If the name is in the\n+   KEYWORD_HASH, prepend an '_'.  */\n+\n+static void\n+go_append_decl_name (struct obstack *ob, tree decl, htab_t keyword_hash)\n+{\n+  const char *var_name;\n+  void **slot;\n+\n+  /* Start variable name with an underscore if a keyword.  */\n+  var_name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+  slot = htab_find_slot (keyword_hash, var_name, NO_INSERT);\n+  if (slot != NULL)\n+    obstack_1grow (ob, '_');\n+  go_append_string (ob, DECL_NAME (decl));\n+}\n+\n+/* Appends a byte array with the necessary number of elements and the name\n+   \"Godump_INDEX_pad\" to pad from FROM_OFFSET to TO_OFFSET to OB assuming that\n+   the next field is automatically aligned to ALIGN_UNITS.  Returns INDEX + 1,\n+   or INDEX if no padding had to be appended.  The resulting offset where the\n+   next field is allocated is returned through RET_OFFSET.  */\n+\n+static unsigned int\n+go_append_padding (struct obstack *ob, unsigned int from_offset,\n+\t\t   unsigned int to_offset, unsigned int align_units,\n+\t\t   unsigned int index, unsigned int *ret_offset)\n+{\n+  if (from_offset % align_units > 0)\n+    from_offset += align_units - (from_offset % align_units);\n+  gcc_assert (to_offset >= from_offset);\n+  if (to_offset > from_offset)\n+    {\n+      char buf[100];\n+\n+      index = go_append_artificial_name (ob, index);\n+      snprintf (buf, sizeof buf, \"_pad [%u]byte; \", to_offset - from_offset);\n+      obstack_grow (ob, buf, strlen (buf));\n+    }\n+  *ret_offset = to_offset;\n+\n+  return index;\n+}\n+\n+/* Appends an array of type TYPE_STRING with zero elements and the name\n+   \"Godump_INDEX_align\" to OB.  If TYPE_STRING is a null pointer, ERROR_STRING\n+   is appended instead of the type.  Returns INDEX + 1.  */\n+\n+static unsigned int\n+go_force_record_alignment (struct obstack *ob, const char *type_string,\n+\t\t\t   unsigned int index, const char *error_string)\n+{\n+  index = go_append_artificial_name (ob, index);\n+  obstack_grow (ob, \"_align \", 7);\n+  if (type_string == NULL)\n+    obstack_grow (ob, error_string, strlen (error_string));\n+  else\n+    {\n+      obstack_grow (ob, \"[0]\", 3);\n+      obstack_grow (ob, type_string, strlen (type_string));\n+    }\n+  obstack_grow (ob, \"; \", 2);\n+\n+  return index;\n+}\n+\n /* Write the Go version of TYPE to CONTAINER->TYPE_OBSTACK.\n    USE_TYPE_NAME is true if we can simply use a type name here without\n    needing to define it.  IS_FUNC_OK is true if we can output a func\n-   type here; the \"func\" keyword will already have been added.  Return\n-   true if the type can be represented in Go, false otherwise.  */\n+   type here; the \"func\" keyword will already have been added.\n+   Return true if the type can be represented in Go, false otherwise.\n+   P_ART_I is used for indexing artificial elements in nested structures and\n+   should always be a NULL pointer when called, except by certain recursive\n+   calls from go_format_type() itself.  */\n \n static bool\n go_format_type (struct godump_container *container, tree type,\n-\t\tbool use_type_name, bool is_func_ok)\n+\t\tbool use_type_name, bool is_func_ok, unsigned int *p_art_i)\n {\n   bool ret;\n   struct obstack *ob;\n+  unsigned int art_i_dummy;\n \n+  if (p_art_i == NULL)\n+    {\n+      art_i_dummy = 0;\n+      p_art_i = &art_i_dummy;\n+    }\n   ret = true;\n   ob = &container->type_obstack;\n \n@@ -618,27 +742,15 @@ go_format_type (struct godump_container *container, tree type,\n \tconst char *s;\n \tchar buf[100];\n \n-\tswitch (TYPE_PRECISION (type))\n+\ts = go_get_uinttype_for_precision (TYPE_PRECISION (type),\n+\t\t\t\t\t   TYPE_UNSIGNED (type));\n+\tif (s == NULL)\n \t  {\n-\t  case 8:\n-\t    s = TYPE_UNSIGNED (type) ? \"uint8\" : \"int8\";\n-\t    break;\n-\t  case 16:\n-\t    s = TYPE_UNSIGNED (type) ? \"uint16\" : \"int16\";\n-\t    break;\n-\t  case 32:\n-\t    s = TYPE_UNSIGNED (type) ? \"uint32\" : \"int32\";\n-\t    break;\n-\t  case 64:\n-\t    s = TYPE_UNSIGNED (type) ? \"uint64\" : \"int64\";\n-\t    break;\n-\t  default:\n \t    snprintf (buf, sizeof buf, \"INVALID-int-%u%s\",\n \t\t      TYPE_PRECISION (type),\n \t\t      TYPE_UNSIGNED (type) ? \"u\" : \"\");\n \t    s = buf;\n \t    ret = false;\n-\t    break;\n \t  }\n \tobstack_grow (ob, s, strlen (s));\n       }\n@@ -710,7 +822,7 @@ go_format_type (struct godump_container *container, tree type,\n       else\n \t{\n \t  if (!go_format_type (container, TREE_TYPE (type), use_type_name,\n-\t\t\t       true))\n+\t\t\t       true, NULL))\n \t    ret = false;\n \t}\n       break;\n@@ -732,64 +844,64 @@ go_format_type (struct godump_container *container, tree type,\n \t\t    tree_to_shwi (TYPE_MAX_VALUE (TYPE_DOMAIN (type))));\n \t  obstack_grow (ob, buf, strlen (buf));\n \t}\n+      else\n+\tobstack_1grow (ob, '0');\n       obstack_1grow (ob, ']');\n-      if (!go_format_type (container, TREE_TYPE (type), use_type_name, false))\n+      if (!go_format_type (container, TREE_TYPE (type), use_type_name, false,\n+\t\t\t   NULL))\n \tret = false;\n       break;\n \n-    case UNION_TYPE:\n     case RECORD_TYPE:\n       {\n+\tunsigned int prev_field_end;\n+\tunsigned int most_strict_known_alignment;\n \ttree field;\n-\tint i;\n \n+\t/* FIXME: Why is this necessary?  Without it we can get a core\n+\t   dump on the s390x headers, or from a file containing simply\n+\t   \"typedef struct S T;\".  */\n+\tlayout_type (type);\n+\n+\tprev_field_end = 0;\n+\tmost_strict_known_alignment = 1;\n \tobstack_grow (ob, \"struct { \", 9);\n-\ti = 0;\n \tfor (field = TYPE_FIELDS (type);\n \t     field != NULL_TREE;\n \t     field = TREE_CHAIN (field))\n \t  {\n-\t    struct obstack hold_type_obstack;\n \t    bool field_ok;\n \n-\t    if (TREE_CODE (type) == UNION_TYPE)\n-\t      {\n-\t\thold_type_obstack = container->type_obstack;\n-\t\tobstack_init (&container->type_obstack);\n-\t      }\n-\n+\t    if (TREE_CODE (field) != FIELD_DECL)\n+\t      continue;\n \t    field_ok = true;\n-\n-\t    if (DECL_NAME (field) == NULL)\n-\t      {\n-\t\tchar buf[100];\n-\n-\t\tobstack_grow (ob, \"Godump_\", 7);\n-\t\tsnprintf (buf, sizeof buf, \"%d\", i);\n-\t\tobstack_grow (ob, buf, strlen (buf));\n-\t\ti++;\n-\t      }\n-\t    else\n-              {\n-\t\tconst char *var_name;\n-\t\tvoid **slot;\n-\n-\t\t/* Start variable name with an underscore if a keyword.  */\n-\t\tvar_name = IDENTIFIER_POINTER (DECL_NAME (field));\n-\t\tslot = htab_find_slot (container->keyword_hash, var_name,\n-\t\t\t\t       NO_INSERT);\n-\t\tif (slot != NULL)\n-\t\t  obstack_1grow (ob, '_');\n-\t\tgo_append_string (ob, DECL_NAME (field));\n-\t      }\n-\t    obstack_1grow (ob, ' ');\n \t    if (DECL_BIT_FIELD (field))\n-\t      {\n-\t\tobstack_grow (ob, \"INVALID-bit-field\", 17);\n-\t\tfield_ok = false;\n-\t      }\n+\t      continue;\n \t    else\n               {\n+\t\t{\n+\t\t  unsigned int decl_align_unit;\n+\t\t  unsigned int decl_offset;\n+\n+\t\t  decl_align_unit = DECL_ALIGN_UNIT (field);\n+\t\t  decl_offset =\n+\t\t    TREE_INT_CST_LOW (DECL_FIELD_OFFSET (field))\n+\t\t    + precision_to_units\n+\t\t    (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field)));\n+\t\t  if (decl_align_unit > most_strict_known_alignment)\n+\t\t    most_strict_known_alignment = decl_align_unit;\n+\t\t  *p_art_i = go_append_padding\n+\t\t    (ob, prev_field_end, decl_offset, decl_align_unit, *p_art_i,\n+\t\t     &prev_field_end);\n+\t\t  if (DECL_SIZE_UNIT (field))\n+\t\t    prev_field_end += TREE_INT_CST_LOW (DECL_SIZE_UNIT (field));\n+\t\t}\n+\t\tif (DECL_NAME (field) == NULL)\n+\t\t  *p_art_i = go_append_artificial_name (ob, *p_art_i);\n+\t\telse\n+\t\t  go_append_decl_name (ob, field, container->keyword_hash);\n+\t\tobstack_1grow (ob, ' ');\n+\n \t\t/* Do not expand type if a record or union type or a\n \t\t   function pointer.  */\n \t\tif (TYPE_NAME (TREE_TYPE (field)) != NULL_TREE\n@@ -815,40 +927,76 @@ go_format_type (struct godump_container *container, tree type,\n \t\telse\n \t\t  {\n \t\t    if (!go_format_type (container, TREE_TYPE (field), true,\n-\t\t\t\t\t false))\n+\t\t\t\t\t false, p_art_i))\n \t\t      field_ok = false;\n \t\t  }\n+\t\tobstack_grow (ob, \"; \", 2);\n               }\n-\t    obstack_grow (ob, \"; \", 2);\n+\t    if (!field_ok)\n+\t      ret = false;\n+\t  }\n+\t/* Alignment and padding as necessary.  */\n+\t{\n+\t  unsigned int type_align_unit;\n+\n+\t  type_align_unit = TYPE_ALIGN_UNIT (type);\n+\t  /* Padding.  */\n+\t  *p_art_i = go_append_padding\n+\t    (ob, prev_field_end, TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type)),\n+\t     type_align_unit, *p_art_i, &prev_field_end);\n+\t  if (most_strict_known_alignment < type_align_unit)\n+\t  {\n+\t    const char *s;\n+\t    char buf[100];\n \n-\t    /* Only output the first successful field of a union, and\n-\t       hope for the best.  */\n-\t    if (TREE_CODE (type) == UNION_TYPE)\n+\t    /* Enforce proper record alignment.  */\n+\t    s = go_get_uinttype_for_precision\n+\t      (TYPE_ALIGN (type), TYPE_UNSIGNED (type));\n+\t    if (s == NULL)\n \t      {\n-\t\tif (!field_ok && TREE_CHAIN (field) == NULL_TREE)\n-\t\t  {\n-\t\t    field_ok = true;\n-\t\t    ret = false;\n-\t\t  }\n-\t\tif (field_ok)\n-\t\t  {\n-\t\t    unsigned int sz;\n-\n-\t\t    sz = obstack_object_size (&container->type_obstack);\n-\t\t    obstack_grow (&hold_type_obstack,\n-\t\t\t\t  obstack_base (&container->type_obstack),\n-\t\t\t\t  sz);\n-\t\t  }\n-\t\tobstack_free (&container->type_obstack, NULL);\n-\t\tcontainer->type_obstack = hold_type_obstack;\n-\t\tif (field_ok)\n-\t\t  break;\n+\t\tsnprintf (buf, sizeof buf, \"INVALID-int-%u%s\",\n+\t\t\t  TYPE_ALIGN (type), TYPE_UNSIGNED (type) ? \"u\" : \"\");\n+\t\ts = buf;\n+\t\tret = false;\n \t      }\n+\t    *p_art_i = go_force_record_alignment (ob, s, *p_art_i, buf);\n+\t  }\n+\t}\n+\tobstack_1grow (ob, '}');\n+      }\n+      break;\n+\n+    case UNION_TYPE:\n+      {\n+\tconst char *s;\n+\tunsigned int sz_units;\n+\n+\tlayout_type (type);\n+\tsz_units = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type));\n+\ts = go_get_uinttype_for_precision (TYPE_ALIGN (type), true);\n+\tobstack_grow (ob, \"struct { \", 9);\n+\tif (s == NULL)\n+\t  {\n+\t    ret = false;\n+\t    s = \"INVALID-union-alignment\";\n+\t    obstack_grow (ob, s, strlen (s));\n+\t  }\n+\telse\n+\t  {\n+\t    char buf[100];\n+\t    tree field;\n+\n+\t    field = TYPE_FIELDS (type);\n+\t    /* Use the same index as the byte field's artificial name for\n+\t       padding.  */\n+\t    if (field != NULL_TREE && DECL_NAME (field) != NULL)\n+\t      go_append_decl_name (ob, field, container->keyword_hash);\n \t    else\n-\t      {\n-\t\tif (!field_ok)\n-\t\t  ret = false;\n-\t      }\n+\t      *p_art_i = go_append_artificial_name (ob, *p_art_i);\n+\t    snprintf (buf, sizeof buf, \" [%u]byte; \", sz_units);\n+\t    obstack_grow (ob, buf, strlen (buf));\n+\t    if (TYPE_ALIGN_UNIT (type) > 1)\n+\t      *p_art_i = go_force_record_alignment (ob, s, *p_art_i, NULL);\n \t  }\n \tobstack_1grow (ob, '}');\n       }\n@@ -879,7 +1027,7 @@ go_format_type (struct godump_container *container, tree type,\n \t      break;\n \t    if (seen_arg)\n \t      obstack_grow (ob, \", \", 2);\n-\t    if (!go_format_type (container, arg_type, true, false))\n+\t    if (!go_format_type (container, arg_type, true, false, NULL))\n \t      ret = false;\n \t    seen_arg = true;\n \t  }\n@@ -895,7 +1043,7 @@ go_format_type (struct godump_container *container, tree type,\n \tif (!VOID_TYPE_P (result))\n \t  {\n \t    obstack_1grow (ob, ' ');\n-\t    if (!go_format_type (container, result, use_type_name, false))\n+\t    if (!go_format_type (container, result, use_type_name, false, NULL))\n \t      ret = false;\n \t  }\n       }\n@@ -929,7 +1077,7 @@ go_output_type (struct godump_container *container)\n static void\n go_output_fndecl (struct godump_container *container, tree decl)\n {\n-  if (!go_format_type (container, TREE_TYPE (decl), false, true))\n+  if (!go_format_type (container, TREE_TYPE (decl), false, true, NULL))\n     fprintf (go_dump_file, \"// \");\n   fprintf (go_dump_file, \"func _%s \",\n \t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n@@ -1004,7 +1152,7 @@ go_output_typedef (struct godump_container *container, tree decl)\n \treturn;\n       *slot = CONST_CAST (void *, (const void *) type);\n \n-      if (!go_format_type (container, TREE_TYPE (decl), false, false))\n+      if (!go_format_type (container, TREE_TYPE (decl), false, false, NULL))\n \t{\n \t  fprintf (go_dump_file, \"// \");\n \t  slot = htab_find_slot (container->invalid_hash, type, INSERT);\n@@ -1040,7 +1188,7 @@ go_output_typedef (struct godump_container *container, tree decl)\n          return;\n        *slot = CONST_CAST (void *, (const void *) type);\n \n-       if (!go_format_type (container, TREE_TYPE (decl), false, false))\n+       if (!go_format_type (container, TREE_TYPE (decl), false, false, NULL))\n \t {\n \t   fprintf (go_dump_file, \"// \");\n \t   slot = htab_find_slot (container->invalid_hash, type, INSERT);\n@@ -1069,14 +1217,41 @@ static void\n go_output_var (struct godump_container *container, tree decl)\n {\n   bool is_valid;\n+  tree type_name;\n+  tree id;\n \n   if (container->decls_seen.contains (decl)\n       || container->decls_seen.contains (DECL_NAME (decl)))\n     return;\n   container->decls_seen.add (decl);\n   container->decls_seen.add (DECL_NAME (decl));\n \n-  is_valid = go_format_type (container, TREE_TYPE (decl), true, false);\n+  type_name = TYPE_NAME (TREE_TYPE (decl));\n+  id = NULL_TREE;\n+  if (type_name != NULL_TREE && TREE_CODE (type_name) == IDENTIFIER_NODE)\n+    id = type_name;\n+  else if (type_name != NULL_TREE && TREE_CODE (type_name) == TYPE_DECL\n+\t   && DECL_SOURCE_LOCATION (type_name) != BUILTINS_LOCATION\n+\t   && DECL_NAME (type_name))\n+    id = DECL_NAME (type_name);\n+  if (id != NULL_TREE\n+      && (!htab_find_slot (container->type_hash, IDENTIFIER_POINTER (id),\n+\t\t\t   NO_INSERT)\n+\t  || htab_find_slot (container->invalid_hash, IDENTIFIER_POINTER (id),\n+\t\t\t     NO_INSERT)))\n+    id = NULL_TREE;\n+  if (id != NULL_TREE)\n+    {\n+      struct obstack *ob;\n+\n+      ob = &container->type_obstack;\n+      obstack_1grow (ob, '_');\n+      go_append_string (ob, id);\n+      is_valid = htab_find_slot (container->type_hash, IDENTIFIER_POINTER (id),\n+\t\t\t\t NO_INSERT) != NULL;\n+    }\n+  else\n+    is_valid = go_format_type (container, TREE_TYPE (decl), true, false, NULL);\n   if (is_valid\n       && htab_find_slot (container->type_hash,\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (decl)),\n@@ -1096,10 +1271,8 @@ go_output_var (struct godump_container *container, tree decl)\n \n   /* Sometimes an extern variable is declared with an unknown struct\n      type.  */\n-  if (TYPE_NAME (TREE_TYPE (decl)) != NULL_TREE\n-      && RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl)))\n+  if (type_name != NULL_TREE && RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl)))\n     {\n-      tree type_name = TYPE_NAME (TREE_TYPE (decl));\n       if (TREE_CODE (type_name) == IDENTIFIER_NODE)\n \tcontainer->pot_dummy_types.add (IDENTIFIER_POINTER (type_name));\n       else if (TREE_CODE (type_name) == TYPE_DECL)"}, {"sha": "20efac7344a92fb36c35a4ab274710e2e2c218e3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbed9ce68818456826d1d25441ef7c1e0d2d85b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbed9ce68818456826d1d25441ef7c1e0d2d85b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4bbed9ce68818456826d1d25441ef7c1e0d2d85b", "patch": "@@ -1,3 +1,8 @@\n+2014-10-28  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+        * gcc.misc-tests/godump.exp: New.\n+        * gcc.misc-tests/godump-1.c: New.\n+\n 2014-10-28  Max Ostapenko  <m.ostapenko@partner.samsung.com>\n \n \t* c-c++-common/asan/no-redundant-instrumentation-1.c: Updated test."}, {"sha": "876cf28c26d6c6a568e1519ebaf6ef369be71fbb", "filename": "gcc/testsuite/gcc.misc-tests/godump-1.c", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbed9ce68818456826d1d25441ef7c1e0d2d85b/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgodump-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbed9ce68818456826d1d25441ef7c1e0d2d85b/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgodump-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgodump-1.c?ref=4bbed9ce68818456826d1d25441ef7c1e0d2d85b", "patch": "@@ -0,0 +1,482 @@\n+/* Test -fdump-go-specs option.  */\n+\n+/* { dg-options \"-c -fdump-go-spec=godump-1.out\" } */\n+/* { dg-do compile } */\n+\n+#include <stdint.h>\n+\n+/* integer based types */\n+typedef char c_t;\n+char c_v1;\n+c_t c_v2;\n+typedef short s_t;\n+short s_v1;\n+s_t s_v2;\n+typedef int i_t;\n+int i_v1;\n+i_t i_v2;\n+typedef long l_t;\n+long l_v1;\n+l_t l_v2;\n+typedef long long ll_t;\n+long long ll_v1;\n+ll_t ll_v2;\n+typedef unsigned char uc_t;\n+unsigned char uc_v1;\n+uc_t uc_v2;\n+typedef unsigned short us_t;\n+unsigned short us_v1;\n+us_t us_v2;\n+typedef unsigned int ui_t;\n+unsigned int ui_v1;\n+ui_t ui_v2;\n+typedef unsigned long ul_t;\n+unsigned long ul_v1;\n+ul_t ul_v2;\n+typedef unsigned long long ull_t;\n+unsigned long long ull_v1;\n+ull_t ull_v2;\n+typedef signed char sc_t;\n+signed char sc_v1;\n+sc_t sc_v2;\n+typedef signed short ss_t;\n+signed short ss_v1;\n+ss_t ss_v2;\n+typedef signed int si_t;\n+signed int si_v1;\n+si_t si_v2;\n+typedef signed long sl_t;\n+signed long sl_v1;\n+sl_t sl_v2;\n+typedef signed long long sll_t;\n+signed long long sll_v1;\n+sll_t sll_v2;\n+typedef int8_t i8_t;\n+int8_t i8_v1;\n+i8_t i8_v2;\n+typedef int16_t i16_t;\n+int16_t i16_v1;\n+i16_t i16_v2;\n+typedef int32_t i32_t;\n+int32_t i32_v1;\n+i32_t i32_v2;\n+typedef int64_t i64_t;\n+int64_t i64_v1;\n+i64_t i64_v2;\n+typedef uint8_t ui8_t;\n+uint8_t ui8_v1;\n+ui8_t ui8_v2;\n+typedef uint16_t iu16_t;\n+uint16_t iu16_v1;\n+iu16_t iu16_v2;\n+typedef uint32_t iu32_t;\n+uint32_t iu32_v1;\n+iu32_t iu32_v2;\n+typedef uint64_t iu64_t;\n+uint64_t iu64_v1;\n+iu64_t iu64_v2;\n+typedef const char cc_t;\n+const char cc_v1;\n+cc_t cc_v2;\n+\n+/* pointer and array types */\n+typedef void *vp_t;\n+void *vp_v1;\n+vp_t vp_v2;\n+typedef int **ipp_t;\n+int **ipp_v1;\n+ipp_t ipp_v2;\n+typedef char ca_t[];\n+char ca_v1[]; /* { dg-warning \"array 'ca_v1' assumed to have one element\" } */\n+char ca_v1b[2];\n+ca_t ca_v2; /* { dg-warning \"array 'ca_v2' assumed to have one element\" } */\n+typedef short sa2_t[2];\n+short sa2_v1[2];\n+sa2_t sa2_v2;\n+\n+/* floating point types */\n+typedef float f_t;\n+float f_v1;\n+f_t f_v2;\n+typedef double d_t;\n+double d_v1;\n+d_t d_v2;\n+typedef long double ld_t;\n+long double ld_v1;\n+ld_t ld_v2;\n+\n+/* nested typedefs */\n+typedef int ni_t;\n+typedef ni_t ni2_t;\n+ni2_t ni2_v2;\n+typedef ni2_t ni3_t;\n+ni3_t ni3_v2;\n+\n+/* enums */\n+enum { E11 };\n+enum { EV11 } e1_v1;\n+enum { E21, E22 };\n+enum { EV21, EV22 } e2_v1;\n+enum { EN1 = 3, EN2 = 77, EN3 = -1, EN4 };\n+typedef enum { ET1, ET2 } et_t;\n+enum { ETV1, ETV2 } et_v1;\n+et_t et_v2;\n+\n+/* simple structs */\n+typedef struct { } ts0e;\n+struct { } s0e;\n+typedef struct { int8_t e1; } ts1e;\n+struct { int8_t e1; } s1e;\n+typedef struct { int8_t e1; void *e2; } ts2el;\n+struct { int8_t e1; void *e2; } s2el;\n+typedef struct { void *e1; int8_t e2; } ts2eg;\n+struct { void *e1; int8_t e2; } s2eg;\n+typedef struct { int64_t l; int8_t c; int32_t i; int16_t s; } tsme;\n+struct { int64_t l; int8_t c; int32_t i; int16_t s; } sme;\n+typedef struct { int16_t sa[3]; int8_t ca[3]; } tsae;\n+struct { int16_t sa[3]; int8_t ca[3]; } sae;\n+typedef struct { float f; } tsf_equiv;\n+struct { float f; } sf_equiv;\n+typedef struct { float f; uint8_t : 0; } tsf_not_equiv;\n+struct { float f; uint8_t : 0; } sf_not_equiv;\n+typedef struct { double d; } tsd_equiv;\n+struct { double d; } sd_equiv;\n+typedef struct { double d; uint8_t : 0; } tsd_not_equiv;\n+struct { double d; uint8_t : 0; } sd_not_equiv;\n+typedef struct s_undef_t s_undef_t2;\n+\n+/* nested structs */\n+typedef struct { struct { uint8_t ca[3]; } s; uint32_t i; } tsn;\n+struct { struct { uint8_t ca[3]; } s; uint32_t i; } sn;\n+typedef struct { struct { uint8_t a; uint16_t s; }; uint8_t b; } tsn_anon;\n+struct { struct { uint8_t a; uint16_t s; }; uint8_t b; } sn_anon;\n+\n+/* structs with bitfields */\n+typedef struct { uint8_t : 0; uint8_t c; } tsbf_anon_pad1;\n+struct { uint8_t : 0; uint8_t c; } sbf_anon_pad1;\n+typedef struct { uint8_t : 1; uint8_t c; } tsbf_anon_pad2;\n+struct { uint8_t : 1; uint8_t c; } sbf_anon_pad2;\n+typedef struct { uint8_t : 7; uint8_t c; } tsbf_anon_pad3;\n+struct { uint8_t : 7; uint8_t c; } sbf_anon_pad3;\n+typedef struct { uint8_t : 8; uint8_t c; } tsbf_anon_pad4;\n+struct { uint8_t : 8; uint8_t c; } sbf_anon_pad4;\n+typedef struct { uint64_t : 0; uint8_t c; } tsbf_anon_pad5;\n+struct { uint64_t : 0; uint8_t c; } sbf_anon_pad5;\n+typedef struct { uint64_t : 1; uint8_t c; } tsbf_anon_pad6;\n+struct { uint64_t : 1; uint8_t c; } sbf_anon_pad6;\n+typedef struct { uint64_t : 63; uint8_t c; } tsbf_anon_pad7;\n+struct { uint64_t : 63; uint8_t c; } sbf_anon_pad7;\n+typedef struct { uint64_t : 64; uint8_t c; } tsbf_anon_pad8;\n+struct { uint64_t : 64; uint8_t c; } sbf_anon_pad8;\n+typedef struct { uint8_t bf : 1; uint8_t c; } tsbf_pad8_1;\n+struct { uint8_t bf : 1; uint8_t c; } sbf_pad8_1;\n+typedef struct { uint8_t bf : 7; uint8_t c; } tsbf_pad8_2;\n+struct { uint8_t bf : 7; uint8_t c; } sbf_pad8_2;\n+typedef struct { uint8_t bf : 8; uint8_t c; } tsbf_pad8_3;\n+struct { uint8_t bf : 8; uint8_t c; } sbf_pad8_3;\n+typedef struct { uint16_t bf : 1; uint8_t c; } tsbf_pad16_1;\n+struct { uint16_t bf : 1; uint8_t c; } sbf_pad16_1;\n+typedef struct { uint16_t bf : 15; uint8_t c; } tsbf_pad16_2;\n+struct { uint16_t bf : 15; uint8_t c; } sbf_pad16_2;\n+typedef struct { uint16_t bf : 16; uint8_t c; } tsbf_pad16_3;\n+struct { uint16_t bf : 16; uint8_t c; } sbf_pad16_3;\n+typedef struct { uint32_t bf : 1; uint8_t c; } tsbf_pad32_1;\n+struct { uint32_t bf : 1; uint8_t c; } sbf_pad32_1;\n+typedef struct { uint32_t bf : 31; uint8_t c; } tsbf_pad32_2;\n+struct { uint32_t bf : 31; uint8_t c; } sbf_pad32_2;\n+typedef struct { uint32_t bf : 32; uint8_t c; } tsbf_pad32_3;\n+struct { uint32_t bf : 32; uint8_t c; } sbf_pad32_3;\n+typedef struct { uint64_t bf : 1; uint8_t c; } tsbf_pad64_1;\n+struct { uint64_t bf : 1; uint8_t c; } sbf_pad64_1;\n+typedef struct { uint64_t bf : 63; uint8_t c; } tsbf_pad64_2;\n+struct { uint64_t bf : 63; uint8_t c; } sbf_pad64_2;\n+typedef struct { uint64_t bf : 64; uint8_t c; } tsbf_pad64_3;\n+struct { uint64_t bf : 64; uint8_t c; } sbf_pad64_3;\n+typedef struct { uint8_t b1 : 1; } tsbf_1b;\n+struct { uint8_t b1 : 1; } sbf_1b;\n+typedef struct\n+{\n+  uint8_t b1 : 1; uint8_t b2 : 1; uint8_t b3 : 1; uint8_t b4 : 1;\n+  uint8_t b5 : 1; uint8_t b6 : 1; uint8_t b7 : 1; uint8_t b8 : 1;\n+} tsbf_8b;\n+struct\n+{\n+  uint8_t b1 : 1; uint8_t b2 : 1; uint8_t b3 : 1; uint8_t b4 : 1;\n+  uint8_t b5 : 1; uint8_t b6 : 1; uint8_t b7 : 1; uint8_t b8 : 1;\n+} sbf_8b;\n+typedef struct {\n+  uint8_t b1 : 1; uint8_t b2 : 1; uint8_t b3 : 1; uint8_t b4 : 1;\n+  uint8_t b5 : 1; uint8_t b6 : 1; uint8_t b7 : 1; uint8_t b8 : 1;\n+  uint8_t b9 : 1;\n+} tsbf_9b;\n+struct {\n+  uint8_t b1 : 1; uint8_t b2 : 1; uint8_t b3 : 1; uint8_t b4 : 1;\n+  uint8_t b5 : 1; uint8_t b6 : 1; uint8_t b7 : 1; uint8_t b8 : 1;\n+  uint8_t b9 : 1;\n+} sbf_9b;\n+typedef struct {\n+  uint8_t b1 : 7; uint8_t b2 : 7; uint8_t b3 : 2;\n+} tsbf_18b;\n+struct {\n+  uint8_t b1 : 7; uint8_t b2 : 7; uint8_t b3 : 2;\n+} sbf_18b;\n+struct\n+{\n+  uint16_t bf1 : 8;\n+  uint8_t c;\n+  uint16_t bf2 : 8;\n+  uint32_t bf3 : 12;\n+  uint16_t s;\n+} sbf_gaps;\n+typedef struct\n+{\n+  uint16_t bf1 : 8;\n+  uint8_t c;\n+  uint16_t bf2 : 8;\n+  uint32_t bf3 : 12;\n+  uint16_t s;\n+} tsbf_gaps;\n+\n+/* unions */\n+typedef union { } tue;\n+union { } ue;\n+typedef union { uint8_t c; uint64_t l; } tu1;\n+union { uint8_t c; uint64_t l; } u1;\n+typedef union { uint64_t l; uint8_t c; } tu2;\n+union { uint64_t l; uint8_t c; } u2;\n+typedef union { uint64_t l[3]; uint8_t c; } tu3;\n+union { uint64_t l[3]; uint8_t c; } u3;\n+typedef struct { union { uint8_t c; uint64_t l; }; } tsu_anon;\n+struct { union { uint8_t c; uint64_t l; }; } su_anon;\n+typedef union { uint64_t bf : 1; uint8_t ca[5]; } tu_size;\n+union { uint64_t bf : 1; uint8_t ca[5]; } u_size;\n+typedef union { uint64_t : 1; uint8_t ca[5]; } tu2_size;\n+union { uint64_t : 1; uint8_t ca[5]; } u2_size;\n+typedef union u_undef_t u_undef_t2;\n+typedef union { uint64_t b : 1; uint8_t ca[5]; } tu3_size;\n+union { uint64_t b : 1; uint8_t ca[5]; } u3_size;\n+\n+/* functions */\n+extern uint32_t func1(uint8_t c);\n+typedef int8_t (*func_t)(void *p);\n+\n+/* Necessary quoting in the regexp patters:\n+\n+     (?n) at beginning of pattern to make ^ and $ work.\n+     \"     ->  \\\"\n+     *, +  ->  \"*\", \"+\"\n+     [, ]  ->  \"\\[\", \"\\]\"\n+     (, )  ->  \"\\[(\\]\", \"\\[)\\]\"\n+     {, }  ->  \"\\{\", \"\\}\"\n+*/\n+\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _c_t u?int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _s_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _i_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _l_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ll_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _uc_t uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _us_t uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ui_t uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ul_t uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ull_t uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _sc_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ss_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _si_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _sl_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _sll_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _i8_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _i16_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _i32_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _i64_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ui8_t uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _iu16_t uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _iu32_t uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _iu64_t uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _cc_t u?int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _vp_t \\\\*byte$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ipp_t \\\\*\\\\*int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ca_t \\\\\\[0\\\\\\]u?int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _sa2_t \\\\\\[1\\\\+1\\\\\\]int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _f_t float\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _d_t float\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^// type _ld_t INVALID-float-\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ni_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ni2_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ni3_t int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _et_t int$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ts0e struct \\{ \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ts1e struct \\{ e1 int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ts2el struct \\{ e1 int\\[0-9\\]*; e2 \\\\*byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _ts2eg struct \\{ e1 \\\\*byte; e2 int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsme struct \\{ l int\\[0-9\\]*; c int\\[0-9\\]*; i int\\[0-9\\]*; s int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsae struct \\{ sa \\\\\\[2\\\\+1\\\\\\]int\\[0-9\\]*; ca \\\\\\[2\\\\+1\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsf_equiv struct \\{ f float\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsf_not_equiv struct \\{ f float\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsd_equiv struct \\{ d float\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsd_not_equiv struct \\{ d float\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsn struct \\{ s struct \\{ ca \\\\\\[2\\\\+1\\\\\\]uint\\[0-9\\]*; \\}; i uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsn_anon struct \\{ Godump_0 struct \\{ a uint\\[0-9\\]*; s uint\\[0-9\\]*; \\}; b uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_anon_pad1 struct \\{ c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_anon_pad2 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_anon_pad3 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_anon_pad4 struct \\{ Godump_0 uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_anon_pad5 struct \\{ c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_anon_pad6 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_anon_pad7 struct \\{ Godump_0_pad \\\\\\[8\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_anon_pad8 struct \\{ Godump_0 uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad8_1 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad8_2 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad8_3 struct \\{ bf uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad16_1 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad16_2 struct \\{ Godump_0_pad \\\\\\[2\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad16_3 struct \\{ bf uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad32_1 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad32_2 struct \\{ Godump_0_pad \\\\\\[4\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad32_3 struct \\{ bf uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad64_1 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad64_2 struct \\{ Godump_0_pad \\\\\\[8\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_pad64_3 struct \\{ bf uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_1b struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_8b struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_9b struct \\{ Godump_0_pad \\\\\\[2\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_18b struct \\{ Godump_0_pad \\\\\\[3\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsbf_gaps struct \\{ bf1 uint\\[0-9\\]*; c uint\\[0-9\\]*; bf2 uint\\[0-9\\]*; Godump_0_pad \\\\\\[2\\\\\\]byte; s uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tue struct \\{ Godump_0 \\\\\\[0\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tu1 struct \\{ c \\\\\\[8\\\\\\]byte; Godump_0_align \\\\\\[0\\\\\\]uint64; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tu2 struct \\{ l \\\\\\[8\\\\\\]byte; Godump_0_align \\\\\\[0\\\\\\]uint64; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tu3 struct \\{ l \\\\\\[24\\\\\\]byte; Godump_0_align \\\\\\[0\\\\\\]uint64; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tsu_anon struct \\{ Godump_0 struct \\{ c \\\\\\[8\\\\\\]byte; Godump_1_align \\\\\\[0\\\\\\]uint64; \\}; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tu_size struct \\{ bf \\\\\\[8\\\\\\]byte; Godump_0_align \\\\\\[0\\\\\\]uint64; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tu2_size struct \\{ Godump_0 \\\\\\[5\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _tu3_size struct \\{ b \\\\\\[8\\\\\\]byte; Godump_0_align \\\\\\[0\\\\\\]uint64; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^type _func_t func\\[(\\]\\\\*byte\\[)\\] int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _c_v1 u?int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _c_v2 _c_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _s_v1 int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _s_v2 _s_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _i_v1 int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _i_v2 _i_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _l_v1 int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _l_v2 _l_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ll_v1 int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ll_v2 _ll_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _uc_v1 uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _uc_v2 _uc_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _us_v1 uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _us_v2 _us_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ui_v1 uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ui_v2 _ui_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ul_v1 uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ul_v2 _ul_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ull_v1 uint\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ull_v2 _ull_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sc_v1 int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sc_v2 _sc_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ss_v1 int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ss_v2 _ss_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _si_v1 int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _si_v2 _si_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sl_v1 int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sl_v2 _sl_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sll_v1 int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sll_v2 _sll_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _i8_v1 _int8_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _i8_v2 _i8_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _i16_v1 _int16_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _i16_v2 _i16_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _i32_v1 _int32_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _i32_v2 _i32_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _i64_v1 _int64_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _i64_v2 _i64_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ui8_v1 _uint8_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ui8_v2 _ui8_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _iu16_v1 _uint16_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _iu16_v2 _iu16_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _iu32_v1 _uint32_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _iu32_v2 _iu32_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _iu64_v1 _uint64_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _iu64_v2 _iu64_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _cc_v1 u?int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _cc_v2 _cc_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _vp_v1 \\\\*byte$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _vp_v2 _vp_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ipp_v1 \\\\*\\\\*int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ipp_v2 _ipp_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ca_v1 \\\\\\[0\\\\+1\\\\\\]u?int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ca_v1b \\\\\\[1\\\\+1\\\\\\]u?int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ca_v2 \\\\\\[0\\\\+1\\\\\\]u?int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sa2_v1 \\\\\\[1\\\\+1\\\\\\]int\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sa2_v2 _sa2_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _f_v1 float\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _f_v2 _f_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _d_v1 float\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _d_v2 _d_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^// var _ld_v1 INVALID-float-\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^// var _ld_v2 INVALID-float-\\[0-9\\]*$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ni2_v2 _ni2_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ni3_v2 _ni3_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _e1_v1 int$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _e2_v1 int$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _et_v1 int$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _et_v2 _et_t$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _s0e struct \\{ \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _s1e struct \\{ e1 int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _s2el struct \\{ e1 int\\[0-9\\]*; e2 \\\\*byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _s2eg struct \\{ e1 \\\\*byte; e2 int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sme struct \\{ l int\\[0-9\\]*; c int\\[0-9\\]*; i int\\[0-9\\]*; s int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sae struct \\{ sa \\\\\\[2\\\\+1\\\\\\]int\\[0-9\\]*; ca \\\\\\[2\\\\+1\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sf_equiv struct \\{ f float\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sf_not_equiv struct \\{ f float\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sd_equiv struct \\{ d float\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sd_not_equiv struct \\{ d float\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sn struct \\{ s struct \\{ ca \\\\\\[2\\\\+1\\\\\\]uint\\[0-9\\]*; \\}; i uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sn_anon struct \\{ Godump_0 struct \\{ a uint\\[0-9\\]*; s uint\\[0-9\\]*; \\}; b uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_anon_pad1 struct \\{ c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_anon_pad2 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_anon_pad3 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_anon_pad4 struct \\{ Godump_0 uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_anon_pad5 struct \\{ c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_anon_pad6 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_anon_pad7 struct \\{ Godump_0_pad \\\\\\[8\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_anon_pad8 struct \\{ Godump_0 uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad8_1 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad8_2 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad8_3 struct \\{ bf uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad16_1 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad16_2 struct \\{ Godump_0_pad \\\\\\[2\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad16_3 struct \\{ bf uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad32_1 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad32_2 struct \\{ Godump_0_pad \\\\\\[4\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad32_3 struct \\{ bf uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad64_1 struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad64_2 struct \\{ Godump_0_pad \\\\\\[8\\\\\\]byte; c uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_pad64_3 struct \\{ bf uint\\[0-9\\]*; c uint\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_1b struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_8b struct \\{ Godump_0_pad \\\\\\[1\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_9b struct \\{ Godump_0_pad \\\\\\[2\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_18b struct \\{ Godump_0_pad \\\\\\[3\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _sbf_gaps struct \\{ bf1 uint\\[0-9\\]*; c uint\\[0-9\\]*; bf2 uint\\[0-9\\]*; Godump_0_pad \\\\\\[2\\\\\\]byte; s uint\\[0-9\\]*; Godump_1_align \\\\\\[0\\\\\\]int\\[0-9\\]*; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _ue struct \\{ Godump_0 \\\\\\[0\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _u1 struct \\{ c \\\\\\[8\\\\\\]byte; Godump_0_align \\\\\\[0\\\\\\]uint64; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _u2 struct \\{ l \\\\\\[8\\\\\\]byte; Godump_0_align \\\\\\[0\\\\\\]uint64; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _u3 struct \\{ l \\\\\\[24\\\\\\]byte; Godump_0_align \\\\\\[0\\\\\\]uint64; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _su_anon struct \\{ Godump_0 struct \\{ c \\\\\\[8\\\\\\]byte; Godump_1_align \\\\\\[0\\\\\\]uint64; \\}; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _u_size struct \\{ bf \\\\\\[8\\\\\\]byte; Godump_0_align \\\\\\[0\\\\\\]uint64; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _u2_size struct \\{ Godump_0 \\\\\\[5\\\\\\]byte; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^var _u3_size struct \\{ b \\\\\\[8\\\\\\]byte; Godump_0_align \\\\\\[0\\\\\\]uint64; \\}$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^func _func1 \\[(\\]uint\\[0-9\\]*\\[)\\] uint\\[0-9\\]* __asm__\\[(\\]\\\"func1\\\"\\[)\\]$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _E11 = 0$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _E21 = 0$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _E22 = 1$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _EN1 = 3$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _EN2 = 77$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _EN3 = -1$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _EN4 = 0$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _ET1 = 0$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _ET2 = 1$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _ETV1 = 0$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _ETV2 = 1$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _EV11 = 0$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _EV21 = 0$\" } } */\n+/* { dg-final { scan-file godump-1.out \"(?n)^const _EV22 = 1$\" } } */"}, {"sha": "96812c46f6bbd6d7ed7ff960245dcd669b8bac2d", "filename": "gcc/testsuite/gcc.misc-tests/godump.exp", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbed9ce68818456826d1d25441ef7c1e0d2d85b/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgodump.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbed9ce68818456826d1d25441ef7c1e0d2d85b/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgodump.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgodump.exp?ref=4bbed9ce68818456826d1d25441ef7c1e0d2d85b", "patch": "@@ -0,0 +1,36 @@\n+# Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/godump-*.c]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}]}