{"sha": "caa6ec8dc54d2661eb3e7557a4f555867190d63b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FhNmVjOGRjNTRkMjY2MWViM2U3NTU3YTRmNTU1ODY3MTkwZDYzYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-11-25T12:53:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-11-25T12:53:44Z"}, "message": "reg-stack.c (subst_stack_regs_pat): Swap operands in commutative operations when needed.\n\n\t* reg-stack.c (subst_stack_regs_pat): Swap operands in commutative\n\toperations when needed.\n\t* i386.md (fop_?f_comm): New.\n\t(fop_?f_1): Do not accept commutative operands.\n\nFrom-SVN: r30664", "tree": {"sha": "a4bf9453290b36a89996ebbd090aa3032a51500f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4bf9453290b36a89996ebbd090aa3032a51500f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caa6ec8dc54d2661eb3e7557a4f555867190d63b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caa6ec8dc54d2661eb3e7557a4f555867190d63b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caa6ec8dc54d2661eb3e7557a4f555867190d63b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caa6ec8dc54d2661eb3e7557a4f555867190d63b/comments", "author": null, "committer": null, "parents": [{"sha": "58dbe05f3a8d62d7c5e9982c9caf35ec4d403595", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58dbe05f3a8d62d7c5e9982c9caf35ec4d403595", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58dbe05f3a8d62d7c5e9982c9caf35ec4d403595"}], "stats": {"total": 60, "additions": 59, "deletions": 1}, "files": [{"sha": "17119fba470de8926ca3737bdff37978bd260d8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa6ec8dc54d2661eb3e7557a4f555867190d63b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa6ec8dc54d2661eb3e7557a4f555867190d63b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=caa6ec8dc54d2661eb3e7557a4f555867190d63b", "patch": "@@ -1,3 +1,10 @@\n+Wed Nov 24 17:08:09 MET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* reg-stack.c (subst_stack_regs_pat): Swap operands in commutative\n+\toperations when needed.\n+\t* i386.md (fop_?f_comm): New.\n+\t(fop_?f_1): Do not accept commutative operands.\n+\n 1999-11-25  Andreas Jaeger  <aj@suse.de>\n \n \t* config/mips/mips.md (casesi_internal): Add missing brace."}, {"sha": "e7f9a140b72ea5e79062fefeec17500108200674", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa6ec8dc54d2661eb3e7557a4f555867190d63b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa6ec8dc54d2661eb3e7557a4f555867190d63b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=caa6ec8dc54d2661eb3e7557a4f555867190d63b", "patch": "@@ -7272,12 +7272,51 @@\n ;; SImode if the target mode DFmode, but only SImode if the target mode\n ;; is SFmode.\n \n+;; Gcc is slightly more smart about handling normal two address instructions\n+;; so use special patterns for add and mull.\n+(define_insn \"*fop_sf_comm\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(match_operator:SF 3 \"binary_fp_operator\"\n+\t\t\t[(match_operand:SF 1 \"register_operand\" \"%0\")\n+\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm\")]))]\n+  \"TARGET_80387 && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (if_then_else (match_operand:SF 3 \"mult_operator\" \"\") \n+           (const_string \"fmul\")\n+           (const_string \"fop\")))])\n+\n+(define_insn \"*fop_df_comm\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(match_operator:DF 3 \"binary_fp_operator\"\n+\t\t\t[(match_operand:DF 1 \"register_operand\" \"%0\")\n+\t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm\")]))]\n+  \"TARGET_80387 && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (if_then_else (match_operand:DF 3 \"mult_operator\" \"\") \n+           (const_string \"fmul\")\n+           (const_string \"fop\")))])\n+\n+(define_insn \"*fop_xf_comm\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(match_operator:XF 3 \"binary_fp_operator\"\n+\t\t\t[(match_operand:XF 1 \"register_operand\" \"%0\")\n+\t\t\t (match_operand:XF 2 \"register_operand\" \"f\")]))]\n+  \"TARGET_80387 && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (if_then_else (match_operand:XF 3 \"mult_operator\" \"\") \n+           (const_string \"fmul\")\n+           (const_string \"fop\")))])\n+\n (define_insn \"*fop_sf_1\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n \t(match_operator:SF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"0,fm\")\n \t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0\")]))]\n   \"TARGET_80387\n+   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -7328,6 +7367,7 @@\n \t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"0,fm\")\n \t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm,0\")]))]\n   \"TARGET_80387\n+   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -7409,7 +7449,8 @@\n \t(match_operator:XF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:XF 1 \"register_operand\" \"0,f\")\n \t\t\t (match_operand:XF 2 \"register_operand\" \"f,0\")]))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387\n+   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n         (cond [(match_operand:XF 3 \"mult_operator\" \"\") "}, {"sha": "aa2b01010f6ba445177ce96d17c08115562ba028", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa6ec8dc54d2661eb3e7557a4f555867190d63b/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa6ec8dc54d2661eb3e7557a4f555867190d63b/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=caa6ec8dc54d2661eb3e7557a4f555867190d63b", "patch": "@@ -1631,6 +1631,16 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n \t\treplace_reg (dest, get_hard_regnum (regstack, *dest));\n \t      }\n+\n+\t    /* Keep operand 1 maching with destination.  */\n+\t    if (GET_RTX_CLASS (GET_CODE (pat_src)) == 'c'\n+\t\t&& REG_P (*src1) && REG_P (*src2)\n+\t\t&& REGNO (*src1) != REGNO (*dest))\n+\t     {\n+\t\trtx tmp = *src1;\n+\t\t*src1 = *src2;\n+\t\t*src2 = tmp;\n+\t     }\n \t    break;\n \n \t  case UNSPEC:"}]}