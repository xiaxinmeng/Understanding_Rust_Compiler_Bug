{"sha": "b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE1MmY1YTJiMzNiMjUxYWIxODc0YTQzZDk3Y2U3M2QxMWVlYzBhNA==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2016-08-11T08:58:55Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2016-08-11T08:58:55Z"}, "message": "Replace KISS PRNG with xorshift1024* using per-thread state.\n\nfrontend:\n\n2016-08-11  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* check.c (gfc_check_random_seed): Use new seed size in check.\n\t* intrinsic.texi (RANDOM_NUMBER): Updated documentation.\n\t(RANDOM_SEED): Likewise.\n\n\ntestsuite:\n\n2016-08-11  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* gfortran.dg/random_7.f90: Take into account that the last seed\n\tvalue is the special p value.\n\t* gfortran.dg/random_seed_1.f90: Seed size is now constant.\n\n\nlibgfortran:\n2016-08-11  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* intrinsics/random.c: Replace KISS with xorshift1024* using\n\tper-thread state.\n\t* runtime/main.c (init): Don't call random_seed_i4.\n\nFrom-SVN: r239356", "tree": {"sha": "60f87a35243956cff30462d3be48f97f4ba10d65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60f87a35243956cff30462d3be48f97f4ba10d65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/comments", "author": null, "committer": null, "parents": [{"sha": "bb7ebad1c0f641753ffb60a22d2f3c546c406e1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb7ebad1c0f641753ffb60a22d2f3c546c406e1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb7ebad1c0f641753ffb60a22d2f3c546c406e1b"}], "stats": {"total": 771, "additions": 434, "deletions": 337}, "files": [{"sha": "4b9b7398e80f33dad7c2ef1ccb92cc86c419fbc0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "patch": "@@ -1,3 +1,9 @@\n+2016-08-11  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* check.c (gfc_check_random_seed): Use new seed size in check.\n+\t* intrinsic.texi (RANDOM_NUMBER): Updated documentation.\n+\t(RANDOM_SEED): Likewise.\n+\n 2016-08-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/72716"}, {"sha": "ff5e80b9df51c955346ee783efb622f4fc68c942", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "patch": "@@ -5527,16 +5527,14 @@ gfc_check_random_number (gfc_expr *harvest)\n bool\n gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n {\n-  unsigned int nargs = 0, kiss_size;\n+  unsigned int nargs = 0, seed_size;\n   locus *where = NULL;\n   mpz_t put_size, get_size;\n-  bool have_gfc_real_16; /* Try and mimic HAVE_GFC_REAL_16 in libgfortran.  */\n \n-  have_gfc_real_16 = gfc_validate_kind (BT_REAL, 16, true) != -1;\n-\n-  /* Keep the number of bytes in sync with kiss_size in\n-     libgfortran/intrinsics/random.c.  */\n-  kiss_size = (have_gfc_real_16 ? 48 : 32) / gfc_default_integer_kind;\n+  /* Keep the number of bytes in sync with master_state in\n+     libgfortran/intrinsics/random.c. +1 due to the integer p which is\n+     part of the state too.  */\n+  seed_size = 128 / gfc_default_integer_kind + 1;\n \n   if (size != NULL)\n     {\n@@ -5579,11 +5577,11 @@ gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n \treturn false;\n \n       if (gfc_array_size (put, &put_size)\n-\t  && mpz_get_ui (put_size) < kiss_size)\n+\t  && mpz_get_ui (put_size) < seed_size)\n \tgfc_error (\"Size of %qs argument of %qs intrinsic at %L \"\n \t\t   \"too small (%i/%i)\",\n \t\t   gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n-\t\t   where, (int) mpz_get_ui (put_size), kiss_size);\n+\t\t   where, (int) mpz_get_ui (put_size), seed_size);\n     }\n \n   if (get != NULL)\n@@ -5611,11 +5609,11 @@ gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n \treturn false;\n \n        if (gfc_array_size (get, &get_size)\n- \t  && mpz_get_ui (get_size) < kiss_size)\n+\t   && mpz_get_ui (get_size) < seed_size)\n \tgfc_error (\"Size of %qs argument of %qs intrinsic at %L \"\n \t\t   \"too small (%i/%i)\",\n \t\t   gfc_current_intrinsic_arg[2]->name, gfc_current_intrinsic,\n-\t\t   where, (int) mpz_get_ui (get_size), kiss_size);\n+\t\t   where, (int) mpz_get_ui (get_size), seed_size);\n     }\n \n   /* RANDOM_SEED may not have more than one non-optional argument.  */"}, {"sha": "67b023153445a4f727290c829d009e33aa739d9b", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 31, "deletions": 68, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "patch": "@@ -11126,23 +11126,16 @@ end program test_rand\n Returns a single pseudorandom number or an array of pseudorandom numbers\n from the uniform distribution over the range @math{ 0 \\leq x < 1}.\n \n-The runtime-library implements George Marsaglia's KISS (Keep It Simple \n-Stupid) random number generator (RNG). This RNG combines:\n-@enumerate\n-@item The congruential generator @math{x(n) = 69069 \\cdot x(n-1) + 1327217885}\n-with a period of @math{2^{32}},\n-@item A 3-shift shift-register generator with a period of @math{2^{32} - 1},\n-@item  Two 16-bit multiply-with-carry generators with a period of\n-@math{597273182964842497 > 2^{59}}.\n-@end enumerate\n-The overall period exceeds @math{2^{123}}.\n+The runtime-library implements the xorshift1024* random number\n+generator (RNG). This generator has a period of @math{2^{1024} - 1},\n+and when using multiple threads up to @math{2^{512}} threads can each\n+generate @math{2^{512}} random numbers before any aliasing occurs.\n+\n+Note that in a multi-threaded program (e.g. using OpenMP directives),\n+each thread will have its own random number state. For details of the\n+seeding procedure, see the documentation for the @code{RANDOM_SEED}\n+intrinsic.\n \n-Please note, this RNG is thread safe if used within OpenMP directives,\n-i.e., its state will be consistent while called from multiple threads.\n-However, the KISS generator does not create random numbers in parallel \n-from multiple sources, but in sequence from a single source. If an\n-OpenMP-enabled application heavily relies on random numbers, one should \n-consider employing a dedicated parallel random number generator instead.\n \n @item @emph{Standard}:\n Fortran 95 and later\n@@ -11184,12 +11177,23 @@ end program\n Restarts or queries the state of the pseudorandom number generator used by \n @code{RANDOM_NUMBER}.\n \n-If @code{RANDOM_SEED} is called without arguments, it is initialized\n-to a default state. The example below shows how to initialize the\n-random seed with a varying seed in order to ensure a different random\n-number sequence for each invocation of the program. Note that setting\n-any of the seed values to zero should be avoided as it can result in\n-poor quality random numbers being generated.\n+If @code{RANDOM_SEED} is called without arguments, it is seeded with\n+random data retrieved from the operating system.\n+\n+As an extension to the Fortran standard, the GFortran\n+@code{RANDOM_NUMBER} supports multiple threads. Each thread in a\n+multi-threaded program has its own seed.  When @code{RANDOM_SEED} is\n+called either without arguments or with the @var{PUT} argument, the\n+given seed is copied into a master seed as well as the seed of the\n+current thread. When a new thread uses @code{RANDOM_NUMBER} for the\n+first time, the seed is copied from the master seed, and forwarded\n+@math{N * 2^{512}} steps to guarantee that the random stream does not\n+alias any other stream in the system, where @var{N} is the number of\n+threads that have used @code{RANDOM_NUMBER} so far during the program\n+execution.\n+\n+Note that setting any of the seed values to zero should be avoided as\n+it can result in poor quality random numbers being generated.\n \n @item @emph{Standard}:\n Fortran 95 and later\n@@ -11217,57 +11221,16 @@ the @var{SIZE} argument.\n \n @item @emph{Example}:\n @smallexample\n-subroutine init_random_seed()\n-  use iso_fortran_env, only: int64\n+program test_random_seed\n   implicit none\n   integer, allocatable :: seed(:)\n-  integer :: i, n, un, istat, dt(8), pid\n-  integer(int64) :: t\n+  integer :: n\n \n   call random_seed(size = n)\n   allocate(seed(n))\n-  ! First try if the OS provides a random number generator\n-  open(newunit=un, file=\"/dev/urandom\", access=\"stream\", &\n-       form=\"unformatted\", action=\"read\", status=\"old\", iostat=istat)\n-  if (istat == 0) then\n-     read(un) seed\n-     close(un)\n-  else\n-     ! Fallback to XOR:ing the current time and pid. The PID is\n-     ! useful in case one launches multiple instances of the same\n-     ! program in parallel.\n-     call system_clock(t)\n-     if (t == 0) then\n-        call date_and_time(values=dt)\n-        t = (dt(1) - 1970) * 365_int64 * 24 * 60 * 60 * 1000 &\n-             + dt(2) * 31_int64 * 24 * 60 * 60 * 1000 &\n-             + dt(3) * 24_int64 * 60 * 60 * 1000 &\n-             + dt(5) * 60 * 60 * 1000 &\n-             + dt(6) * 60 * 1000 + dt(7) * 1000 &\n-             + dt(8)\n-     end if\n-     pid = getpid()\n-     t = ieor(t, int(pid, kind(t)))\n-     do i = 1, n\n-        seed(i) = lcg(t)\n-     end do\n-  end if\n-  call random_seed(put=seed)\n-contains\n-  ! This simple PRNG might not be good enough for real work, but is\n-  ! sufficient for seeding a better PRNG.\n-  function lcg(s)\n-    integer :: lcg\n-    integer(int64) :: s\n-    if (s == 0) then\n-       s = 104729\n-    else\n-       s = mod(s, 4294967296_int64)\n-    end if\n-    s = mod(s * 279470273_int64, 4294967291_int64)\n-    lcg = int(mod(s, int(huge(0), int64)), kind(0))\n-  end function lcg\n-end subroutine init_random_seed\n+  call random_seed(get=seed)\n+  write (*, *) seed\n+end program test_random_seed\n @end smallexample\n \n @item @emph{See also}:"}, {"sha": "7bca99a8b3b723c1832177fa59f33cc7d8022cd8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "patch": "@@ -1,3 +1,9 @@\n+2016-08-11  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* gfortran.dg/random_7.f90: Take into account that the last seed\n+\tvalue is the special p value.\n+\t* gfortran.dg/random_seed_1.f90: Seed size is now constant.\n+\n 2016-08-11  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/ssa-dom-thread-7.c: Adjust."}, {"sha": "aafe346de7b80110f53e8a1aee6f6fe5cdd07188", "filename": "gcc/testsuite/gfortran.dg/random_7.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_7.f90?ref=b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "patch": "@@ -10,8 +10,8 @@ program trs\n   seed(:) = huge(seed) / 17\n   call test_random_seed(put=seed)\n   call test_random_seed(get=check)\n-  print *, seed\n-  print *, check\n+  ! In the current implementation seed(17) is special\n+  seed(17) = check(17)\n   if (any (seed /= check)) call abort\n contains\n   subroutine test_random_seed(size, put, get)"}, {"sha": "39c81ce51b794b769dfcd7c2302b3a345ceb2ed8", "filename": "gcc/testsuite/gfortran.dg/random_seed_1.f90", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_1.f90?ref=b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "patch": "@@ -3,30 +3,18 @@\n ! Emit a diagnostic for too small PUT array at compile time\n ! See PR fortran/37159\n \n-! Possible improvement:\n-! Provide a separate testcase for systems that support REAL(16),\n-! to test the minimum size of 12 (instead of 8).\n-!\n ! Updated to check for arrays of unexpected size,\n ! this also works for -fdefault-integer-8.\n !\n \n PROGRAM random_seed_1\n   IMPLICIT NONE\n \n-  ! Find out what the's largest kind size\n-  INTEGER, PARAMETER :: k1 = kind (0.d0)\n-  INTEGER, PARAMETER :: &\n-    k2 = max (k1, selected_real_kind (precision (0._k1) + 1))\n-  INTEGER, PARAMETER :: &\n-    k3 = max (k2, selected_real_kind (precision (0._k2) + 1))\n-  INTEGER, PARAMETER :: &\n-    k4 = max (k3, selected_real_kind (precision (0._k3) + 1))\n-\n-  INTEGER, PARAMETER :: nbytes = MERGE(48, 32, k4 == 16)\n+  INTEGER, PARAMETER :: nbytes = 128\n \n+  ! +1 due to the special 'p' value in xorshift1024*\n   ! '+1' to avoid out-of-bounds warnings\n-  INTEGER, PARAMETER    :: n = nbytes / KIND(n) + 1\n+  INTEGER, PARAMETER    :: n = nbytes / KIND(n) + 2\n   INTEGER, DIMENSION(n) :: seed\n \n   ! Get seed, array too small"}, {"sha": "ca2c8edc45c31d4c188660db93a3b6ca46df90a7", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "patch": "@@ -1,3 +1,9 @@\n+2016-08-11  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* intrinsics/random.c: Replace KISS with xorshift1024* using\n+\tper-thread state.\n+\t* runtime/main.c (init): Don't call random_seed_i4.\n+\n 2016-07-22  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \t* caf/libcaf.h: Add parameter stat to caf_get() and"}, {"sha": "6084ebe4bb20f78d693d3f8624052524962881f0", "filename": "libgfortran/intrinsics/random.c", "status": "modified", "additions": 371, "deletions": 239, "changes": 610, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/libgfortran%2Fintrinsics%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/libgfortran%2Fintrinsics%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frandom.c?ref=b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "patch": "@@ -1,7 +1,7 @@\n /* Implementation of the RANDOM intrinsics\n    Copyright (C) 2002-2016 Free Software Foundation, Inc.\n-   Contributed by Lars Segerlund <seger@linuxmail.org>\n-   and Steve Kargl.\n+   Contributed by Lars Segerlund <seger@linuxmail.org>,\n+   Steve Kargl and Janne Blomqvist.\n \n This file is part of the GNU Fortran runtime library (libgfortran).\n \n@@ -28,6 +28,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <gthr.h>\n #include <string.h>\n \n+/* For getosrandom.  */\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include \"time_1.h\"\n+\n+#ifdef __MINGW32__\n+#define HAVE_GETPID 1\n+#include <process.h>\n+#endif\n+\n extern void random_r4 (GFC_REAL_4 *);\n iexport_proto(random_r4);\n \n@@ -141,154 +157,222 @@ rnumber_16 (GFC_REAL_16 *f, GFC_UINTEGER_8 v1, GFC_UINTEGER_8 v2)\n     + (GFC_REAL_16) v2 * GFC_REAL_16_LITERAL(0x1.p-128);\n }\n #endif\n-/* libgfortran previously had a Mersenne Twister, taken from the paper:\n-  \n-\tMersenne Twister:\t623-dimensionally equidistributed\n-\t\t\t\tuniform pseudorandom generator.\n-\n-\tby Makoto Matsumoto & Takuji Nishimura\n-\twhich appeared in the: ACM Transactions on Modelling and Computer\n-\tSimulations: Special Issue on Uniform Random Number\n-\tGeneration. ( Early in 1998 ).\n-\n-   The Mersenne Twister code was replaced due to\n-\n-    (1) Simple user specified seeds lead to really bad sequences for\n-        nearly 100000 random numbers.\n-    (2) open(), read(), and close() were not properly declared via header\n-        files.\n-    (3) The global index i was abused and caused unexpected behavior with\n-        GET and PUT.\n-    (4) See PR 15619.\n-\n-\n-   libgfortran currently uses George Marsaglia's KISS (Keep It Simple Stupid)\n-   random number generator.  This PRNG combines:\n-\n-   (1) The congruential generator x(n)=69069*x(n-1)+1327217885 with a period\n-       of 2^32,\n-   (2) A 3-shift shift-register generator with a period of 2^32-1,\n-   (3) Two 16-bit multiply-with-carry generators with a period of\n-       597273182964842497 > 2^59.\n-\n-   The overall period exceeds 2^123.\n-\n-   http://www.ciphersbyritter.com/NEWS4/RANDC.HTM#369F6FCA.74C7C041@stat.fsu.edu\n-\n-   The above web site has an archive of a newsgroup posting from George\n-   Marsaglia with the statement:\n-\n-   Subject: Random numbers for C: Improvements.\n-   Date: Fri, 15 Jan 1999 11:41:47 -0500\n-   From: George Marsaglia <geo@stat.fsu.edu>\n-   Message-ID: <369F6FCA.74C7C041@stat.fsu.edu>\n-   References: <369B5E30.65A55FD1@stat.fsu.edu>\n-   Newsgroups: sci.stat.math,sci.math,sci.math.numer-analysis\n-   Lines: 93\n-\n-   As I hoped, several suggestions have led to\n-   improvements in the code for RNG's I proposed for\n-   use in C. (See the thread \"Random numbers for C: Some\n-   suggestions\" in previous postings.) The improved code\n-   is listed below.\n-\n-   A question of copyright has also been raised.  Unlike\n-   DIEHARD, there is no copyright on the code below. You\n-   are free to use it in any way you want, but you may\n-   wish to acknowledge the source, as a courtesy.\n-\n-\"There is no copyright on the code below.\" included the original\n-KISS algorithm.  */\n-\n-/* We use three KISS random number generators, with different\n-   seeds.\n-   As a matter of Quality of Implementation, the random numbers\n-   we generate for different REAL kinds, starting from the same\n-   seed, are always the same up to the precision of these types.\n-   We do this by using three generators with different seeds, the\n-   first one always for the most significant bits, the second one\n-   for bits 33..64 (if present in the REAL kind), and the third one\n-   (called twice) for REAL(16).  */\n-\n-#define GFC_SL(k, n)\t((k)^((k)<<(n)))\n-#define GFC_SR(k, n)\t((k)^((k)>>(n)))\n-\n-/*   Reference for the seed:\n-   From: \"George Marsaglia\" <g...@stat.fsu.edu>\n-   Newsgroups: sci.math\n-   Message-ID: <e7CcnWxczriWssCjXTWc3A@comcast.com>\n-  \n-   The KISS RNG uses four seeds, x, y, z, c,\n-   with 0<=x<2^32, 0<y<2^32, 0<=z<2^32, 0<=c<698769069\n-   except that the two pairs\n-   z=0,c=0 and z=2^32-1,c=698769068\n-   should be avoided.  */\n-\n-/* Any modifications to the seeds that change KISS_SIZE below need to be\n-   reflected in check.c (gfc_check_random_seed) to enable correct\n-   compile-time checking of PUT size for the RANDOM_SEED intrinsic.  */\n-\n-#define KISS_DEFAULT_SEED_1 123456789, 362436069, 521288629, 316191069\n-#define KISS_DEFAULT_SEED_2 987654321, 458629013, 582859209, 438195021\n-#ifdef HAVE_GFC_REAL_16\n-#define KISS_DEFAULT_SEED_3 573658661, 185639104, 582619469, 296736107\n-#endif\n \n-static GFC_UINTEGER_4 kiss_seed[] = {\n-  KISS_DEFAULT_SEED_1,\n-  KISS_DEFAULT_SEED_2,\n-#ifdef HAVE_GFC_REAL_16\n-  KISS_DEFAULT_SEED_3\n-#endif\n-};\n \n-static GFC_UINTEGER_4 kiss_default_seed[] = {\n-  KISS_DEFAULT_SEED_1,\n-  KISS_DEFAULT_SEED_2,\n-#ifdef HAVE_GFC_REAL_16\n-  KISS_DEFAULT_SEED_3\n-#endif\n+/*\n+\n+   We use the xorshift1024* generator, a fast high-quality generator\n+   that:\n+\n+   - passes TestU1 without any failures\n+\n+   - provides a \"jump\" function making it easy to provide many\n+     independent parallel streams.\n+\n+   - Long period of 2**1024 - 1\n+\n+   A description can be found at\n+\n+   http://vigna.di.unimi.it/ftp/papers/xorshift.pdf\n+\n+   or\n+\n+   http://arxiv.org/abs/1402.6246\n+\n+   The paper includes public domain source code which is the basis for\n+   the implementation below.\n+\n+*/\n+typedef struct\n+{\n+  bool init;\n+  int p;\n+  uint64_t s[16];\n+}\n+xorshift1024star_state;\n+\n+\n+/* How many times we have jumped. This and master_state are the only\n+   variables protected by random_lock.  */\n+static unsigned njumps;\n+static uint64_t master_state[] = {\n+  0xad63fa1ed3b55f36ULL, 0xd94473e78978b497ULL, 0xbc60592a98172477ULL,\n+  0xa3de7c6e81265301ULL, 0x586640c5e785af27ULL, 0x7a2a3f63b67ce5eaULL,\n+  0x9fde969f922d9b82ULL, 0xe6fe34379b3f3822ULL, 0x6c277eac3e99b6c2ULL,\n+  0x9197290ab0d3f069ULL, 0xdb227302f6c25576ULL, 0xee0209aee527fae9ULL,\n+  0x675666a793cd05b9ULL, 0xd048c99fbc70c20fULL, 0x775f8c3dba385ef5ULL,\n+  0x625288bc262faf33ULL\n };\n \n-#define KISS_SIZE (sizeof(kiss_seed)/sizeof(kiss_seed[0]))\n \n-static GFC_UINTEGER_4 * const kiss_seed_1 = kiss_seed;\n-static GFC_UINTEGER_4 * const kiss_seed_2 = kiss_seed + 4;\n+static __gthread_key_t rand_state_key;\n \n-#ifdef HAVE_GFC_REAL_16\n-static GFC_UINTEGER_4 * const kiss_seed_3 = kiss_seed + 8;\n-#endif\n+static xorshift1024star_state*\n+get_rand_state (void)\n+{\n+  /* For single threaded apps.  */\n+  static xorshift1024star_state rand_state;\n+\n+  if (__gthread_active_p ())\n+    {\n+      void* p = __gthread_getspecific (rand_state_key);\n+      if (!p)\n+\t{\n+\t  p = xcalloc (1, sizeof (xorshift1024star_state));\n+\t  __gthread_setspecific (rand_state_key, p);\n+\t}\n+      return p;\n+    }\n+  else\n+    return &rand_state;\n+}\n \n-/* kiss_random_kernel() returns an integer value in the range of\n-   (0, GFC_UINTEGER_4_HUGE].  The distribution of pseudorandom numbers\n-   should be uniform.  */\n \n-static GFC_UINTEGER_4\n-kiss_random_kernel(GFC_UINTEGER_4 * seed)\n+static uint64_t\n+xorshift1024star (xorshift1024star_state* rs)\n {\n-  GFC_UINTEGER_4 kiss;\n+  int p = rs->p;\n+  const uint64_t s0 = rs->s[p];\n+  uint64_t s1 = rs->s[p = (p + 1) & 15];\n+  s1 ^= s1 << 31;\n+  rs->s[p] = s1 ^ s0 ^ (s1 >> 11) ^ (s0 >> 30);\n+  rs->p = p;\n+  return rs->s[p] * UINT64_C(1181783497276652981);\n+}\n \n-  seed[0] = 69069 * seed[0] + 1327217885;\n-  seed[1] = GFC_SL(GFC_SR(GFC_SL(seed[1],13),17),5);\n-  seed[2] = 18000 * (seed[2] & 65535) + (seed[2] >> 16);\n-  seed[3] = 30903 * (seed[3] & 65535) + (seed[3] >> 16);\n-  kiss = seed[0] + seed[1] + (seed[2] << 16) + seed[3];\n \n-  return kiss;\n+/* This is the jump function for the generator. It is equivalent to\n+   2^512 calls to xorshift1024star(); it can be used to generate 2^512\n+   non-overlapping subsequences for parallel computations. */\n+\n+static void\n+jump (xorshift1024star_state* rs)\n+{\n+  static const uint64_t JUMP[] = {\n+    0x84242f96eca9c41dULL, 0xa3c65b8776f96855ULL, 0x5b34a39f070b5837ULL,\n+    0x4489affce4f31a1eULL, 0x2ffeeb0a48316f40ULL, 0xdc2d9891fe68c022ULL,\n+    0x3659132bb12fea70ULL, 0xaac17d8efa43cab8ULL, 0xc4cb815590989b13ULL,\n+    0x5ee975283d71c93bULL, 0x691548c86c1bd540ULL, 0x7910c41d10a1e6a5ULL,\n+    0x0b5fc64563b3e2a8ULL, 0x047f7684e9fc949dULL, 0xb99181f2d8f685caULL,\n+    0x284600e3f30e38c3ULL\n+  };\n+\n+  uint64_t t[16] = { 0 };\n+  for(unsigned int i = 0; i < sizeof JUMP / sizeof *JUMP; i++)\n+    for(int b = 0; b < 64; b++)\n+      {\n+\tif (JUMP[i] & 1ULL << b)\n+\t  for(int j = 0; j < 16; j++)\n+\t    t[j] ^= rs->s[(j + rs->p) & 15];\n+\txorshift1024star (rs);\n+      }\n+  for(int j = 0; j < 16; j++)\n+    rs->s[(j + rs->p) & 15] = t[j];\n }\n \n+\n+/* Initialize the random number generator for the current thread,\n+   using the master state and the number of times we must jump.  */\n+\n+static void\n+init_rand_state (xorshift1024star_state* rs, const bool locked)\n+{\n+  if (!locked)\n+    __gthread_mutex_lock (&random_lock);\n+  memcpy (&rs->s, master_state, sizeof (master_state));\n+  unsigned n = njumps++;\n+  if (!locked)\n+    __gthread_mutex_unlock (&random_lock);\n+  for (unsigned i = 0; i < n; i++)\n+    jump (rs);\n+  rs->init = true;\n+}\n+\n+\n+/* Super-simple LCG generator used in getosrandom () if /dev/urandom\n+   doesn't exist.  */\n+\n+#define M 2147483647 /* 2^31 - 1 (A large prime number) */\n+#define A 16807      /* Prime root of M, passes statistical tests and produces a full cycle */\n+#define Q 127773 /* M / A (To avoid overflow on A * seed) */\n+#define R 2836   /* M % A (To avoid overflow on A * seed) */\n+\n+static uint32_t\n+lcg_parkmiller(uint32_t seed)\n+{\n+    uint32_t hi = seed / Q;\n+    uint32_t lo = seed % Q;\n+    int32_t test = A * lo - R * hi;\n+    if (test <= 0)\n+        test += M;\n+    return test;\n+}\n+\n+#undef M\n+#undef A\n+#undef Q\n+#undef R\n+\n+/* Get some random bytes from the operating system in order to seed\n+   the PRNG.  */\n+\n+static int\n+getosrandom (void *buf, size_t buflen)\n+{\n+  /* TODO: On Windows one could use CryptGenRandom\n+\n+     TODO: When glibc adds a wrapper for the getrandom() system call\n+     on Linux, one could use that.\n+\n+     TODO: One could use getentropy() on OpenBSD.  */\n+  int flags = O_RDONLY;\n+#ifdef O_CLOEXEC\n+  flags |= O_CLOEXEC;\n+#endif\n+  int fd = open(\"/dev/urandom\", flags);\n+  if (fd != -1)\n+    {\n+      int res = read(fd, buf, buflen);\n+      close (fd);\n+      return res;\n+    }\n+  uint32_t seed = 1234567890;\n+  time_t secs;\n+  long usecs;\n+  if (gf_gettime (&secs, &usecs) == 0)\n+    {\n+      seed ^= secs;\n+      seed ^= usecs;\n+    }\n+#ifdef HAVE_GETPID\n+  pid_t pid = getpid();\n+  seed ^= pid;\n+#endif\n+  uint32_t* ub = buf;\n+  for (size_t i = 0; i < buflen; i++)\n+    {\n+      ub[i] = seed;\n+      seed = lcg_parkmiller (seed);\n+    }\n+  return buflen;\n+}\n+\n+\n /*  This function produces a REAL(4) value from the uniform distribution\n     with range [0,1).  */\n \n void\n random_r4 (GFC_REAL_4 *x)\n {\n-  GFC_UINTEGER_4 kiss;\n-\n-  __gthread_mutex_lock (&random_lock);\n-  kiss = kiss_random_kernel (kiss_seed_1);\n-  rnumber_4 (x, kiss);\n-  __gthread_mutex_unlock (&random_lock);\n+  xorshift1024star_state* rs = get_rand_state();\n+\n+  if (unlikely (!rs->init))\n+    init_rand_state (rs, false);\n+  uint64_t r = xorshift1024star (rs);\n+  /* Take the higher bits, ensuring that a stream of real(4), real(8),\n+     and real(10) will be identical (except for precision).  */\n+  uint32_t high = (uint32_t) (r >> 32);\n+  rnumber_4 (x, high);\n }\n iexport(random_r4);\n \n@@ -298,13 +382,13 @@ iexport(random_r4);\n void\n random_r8 (GFC_REAL_8 *x)\n {\n-  GFC_UINTEGER_8 kiss;\n+  GFC_UINTEGER_8 r;\n+  xorshift1024star_state* rs = get_rand_state();\n \n-  __gthread_mutex_lock (&random_lock);\n-  kiss = ((GFC_UINTEGER_8) kiss_random_kernel (kiss_seed_1)) << 32;\n-  kiss += kiss_random_kernel (kiss_seed_2);\n-  rnumber_8 (x, kiss);\n-  __gthread_mutex_unlock (&random_lock);\n+  if (unlikely (!rs->init))\n+    init_rand_state (rs, false);\n+  r = xorshift1024star (rs);\n+  rnumber_8 (x, r);\n }\n iexport(random_r8);\n \n@@ -316,13 +400,13 @@ iexport(random_r8);\n void\n random_r10 (GFC_REAL_10 *x)\n {\n-  GFC_UINTEGER_8 kiss;\n+  GFC_UINTEGER_8 r;\n+  xorshift1024star_state* rs = get_rand_state();\n \n-  __gthread_mutex_lock (&random_lock);\n-  kiss = ((GFC_UINTEGER_8) kiss_random_kernel (kiss_seed_1)) << 32;\n-  kiss += kiss_random_kernel (kiss_seed_2);\n-  rnumber_10 (x, kiss);\n-  __gthread_mutex_unlock (&random_lock);\n+  if (unlikely (!rs->init))\n+    init_rand_state (rs, false);\n+  r = xorshift1024star (rs);\n+  rnumber_10 (x, r);\n }\n iexport(random_r10);\n \n@@ -336,22 +420,20 @@ iexport(random_r10);\n void\n random_r16 (GFC_REAL_16 *x)\n {\n-  GFC_UINTEGER_8 kiss1, kiss2;\n-\n-  __gthread_mutex_lock (&random_lock);\n-  kiss1 = ((GFC_UINTEGER_8) kiss_random_kernel (kiss_seed_1)) << 32;\n-  kiss1 += kiss_random_kernel (kiss_seed_2);\n-\n-  kiss2 = ((GFC_UINTEGER_8) kiss_random_kernel (kiss_seed_3)) << 32;\n-  kiss2 += kiss_random_kernel (kiss_seed_3);\n-\n-  rnumber_16 (x, kiss1, kiss2);\n-  __gthread_mutex_unlock (&random_lock);\n+  GFC_UINTEGER_8 r1, r2;\n+  xorshift1024star_state* rs = get_rand_state();\n+\n+  if (unlikely (!rs->init))\n+    init_rand_state (rs, false);\n+  r1 = xorshift1024star (rs);\n+  r2 = xorshift1024star (rs);\n+  rnumber_16 (x, r1, r2);\n }\n iexport(random_r16);\n \n \n #endif\n+\n /*  This function fills a REAL(4) array with values from the uniform\n     distribution with range [0,1).  */\n \n@@ -364,9 +446,10 @@ arandom_r4 (gfc_array_r4 *x)\n   index_type stride0;\n   index_type dim;\n   GFC_REAL_4 *dest;\n-  GFC_UINTEGER_4 kiss;\n+  xorshift1024star_state* rs = get_rand_state();\n   int n;\n \n+\n   dest = x->base_addr;\n \n   dim = GFC_DESCRIPTOR_RANK (x);\n@@ -382,13 +465,15 @@ arandom_r4 (gfc_array_r4 *x)\n \n   stride0 = stride[0];\n \n-  __gthread_mutex_lock (&random_lock);\n+  if (unlikely (!rs->init))\n+    init_rand_state (rs, false);\n \n   while (dest)\n     {\n       /* random_r4 (dest);  */\n-      kiss = kiss_random_kernel (kiss_seed_1);\n-      rnumber_4 (dest, kiss);\n+      uint64_t r = xorshift1024star (rs);\n+      uint32_t high = (uint32_t) (r >> 32);\n+      rnumber_4 (dest, high);\n \n       /* Advance to the next element.  */\n       dest += stride0;\n@@ -416,7 +501,6 @@ arandom_r4 (gfc_array_r4 *x)\n             }\n         }\n     }\n-  __gthread_mutex_unlock (&random_lock);\n }\n \n /*  This function fills a REAL(8) array with values from the uniform\n@@ -431,7 +515,7 @@ arandom_r8 (gfc_array_r8 *x)\n   index_type stride0;\n   index_type dim;\n   GFC_REAL_8 *dest;\n-  GFC_UINTEGER_8 kiss;\n+  xorshift1024star_state* rs = get_rand_state();\n   int n;\n \n   dest = x->base_addr;\n@@ -449,14 +533,14 @@ arandom_r8 (gfc_array_r8 *x)\n \n   stride0 = stride[0];\n \n-  __gthread_mutex_lock (&random_lock);\n+  if (unlikely (!rs->init))\n+    init_rand_state (rs, false);\n \n   while (dest)\n     {\n       /* random_r8 (dest);  */\n-      kiss = ((GFC_UINTEGER_8) kiss_random_kernel (kiss_seed_1)) << 32;\n-      kiss += kiss_random_kernel (kiss_seed_2);\n-      rnumber_8 (dest, kiss);\n+      uint64_t r = xorshift1024star (rs);\n+      rnumber_8 (dest, r);\n \n       /* Advance to the next element.  */\n       dest += stride0;\n@@ -484,7 +568,6 @@ arandom_r8 (gfc_array_r8 *x)\n             }\n         }\n     }\n-  __gthread_mutex_unlock (&random_lock);\n }\n \n #ifdef HAVE_GFC_REAL_10\n@@ -501,7 +584,7 @@ arandom_r10 (gfc_array_r10 *x)\n   index_type stride0;\n   index_type dim;\n   GFC_REAL_10 *dest;\n-  GFC_UINTEGER_8 kiss;\n+  xorshift1024star_state* rs = get_rand_state();\n   int n;\n \n   dest = x->base_addr;\n@@ -519,14 +602,14 @@ arandom_r10 (gfc_array_r10 *x)\n \n   stride0 = stride[0];\n \n-  __gthread_mutex_lock (&random_lock);\n+  if (unlikely (!rs->init))\n+    init_rand_state (rs, false);\n \n   while (dest)\n     {\n       /* random_r10 (dest);  */\n-      kiss = ((GFC_UINTEGER_8) kiss_random_kernel (kiss_seed_1)) << 32;\n-      kiss += kiss_random_kernel (kiss_seed_2);\n-      rnumber_10 (dest, kiss);\n+      uint64_t r = xorshift1024star (rs);\n+      rnumber_10 (dest, r);\n \n       /* Advance to the next element.  */\n       dest += stride0;\n@@ -554,7 +637,6 @@ arandom_r10 (gfc_array_r10 *x)\n             }\n         }\n     }\n-  __gthread_mutex_unlock (&random_lock);\n }\n \n #endif\n@@ -573,7 +655,7 @@ arandom_r16 (gfc_array_r16 *x)\n   index_type stride0;\n   index_type dim;\n   GFC_REAL_16 *dest;\n-  GFC_UINTEGER_8 kiss1, kiss2;\n+  xorshift1024star_state* rs = get_rand_state();\n   int n;\n \n   dest = x->base_addr;\n@@ -591,18 +673,15 @@ arandom_r16 (gfc_array_r16 *x)\n \n   stride0 = stride[0];\n \n-  __gthread_mutex_lock (&random_lock);\n+  if (unlikely (!rs->init))\n+    init_rand_state (rs, false);\n \n   while (dest)\n     {\n       /* random_r16 (dest);  */\n-      kiss1 = ((GFC_UINTEGER_8) kiss_random_kernel (kiss_seed_1)) << 32;\n-      kiss1 += kiss_random_kernel (kiss_seed_2);\n-\n-      kiss2 = ((GFC_UINTEGER_8) kiss_random_kernel (kiss_seed_3)) << 32;\n-      kiss2 += kiss_random_kernel (kiss_seed_3);\n-\n-      rnumber_16 (dest, kiss1, kiss2);\n+      uint64_t r1 = xorshift1024star (rs);\n+      uint64_t r2 = xorshift1024star (rs);\n+      rnumber_16 (dest, r1, r2);\n \n       /* Advance to the next element.  */\n       dest += stride0;\n@@ -630,7 +709,6 @@ arandom_r16 (gfc_array_r16 *x)\n             }\n         }\n     }\n-  __gthread_mutex_unlock (&random_lock);\n }\n \n #endif\n@@ -665,22 +743,57 @@ unscramble_seed (unsigned char *dest, unsigned char *src, int size)\n void\n random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n {\n-  unsigned char seed[4 * KISS_SIZE];\n-\n-  __gthread_mutex_lock (&random_lock);\n+  unsigned char seed[sizeof (master_state)];\n+#define SZ (sizeof (master_state) / sizeof (GFC_INTEGER_4))\n \n   /* Check that we only have one argument present.  */\n   if ((size ? 1 : 0) + (put ? 1 : 0) + (get ? 1 : 0) > 1)\n     runtime_error (\"RANDOM_SEED should have at most one argument present.\");\n \n+  if (size != NULL)\n+    *size = SZ + 1;\n+\n+  xorshift1024star_state* rs = get_rand_state();\n+\n+  /* Return the seed to GET data.  */\n+  if (get != NULL)\n+    {\n+      /* If the rank of the array is not 1, abort.  */\n+      if (GFC_DESCRIPTOR_RANK (get) != 1)\n+\truntime_error (\"Array rank of GET is not 1.\");\n+\n+      /* If the array is too small, abort.  */\n+      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) SZ + 1)\n+\truntime_error (\"Array size of GET is too small.\");\n+\n+      if (!rs->init)\n+\tinit_rand_state (rs, false);\n+\n+      /* Unscramble the seed.  */\n+      unscramble_seed (seed, (unsigned char *) rs->s, sizeof seed);\n+\n+      /*  Then copy it back to the user variable.  */\n+      for (size_t i = 0; i < SZ ; i++)\n+\tmemcpy (&(get->base_addr[(SZ - 1 - i) * GFC_DESCRIPTOR_STRIDE(get,0)]),\n+               seed + i * sizeof(GFC_UINTEGER_4),\n+               sizeof(GFC_UINTEGER_4));\n+\n+      /* Finally copy the value of p after the seed.  */\n+      get->base_addr[SZ * GFC_DESCRIPTOR_STRIDE(get, 0)] = rs->p;\n+    }\n+\n+  else\n+    {\n+  __gthread_mutex_lock (&random_lock);\n+\n   /* From the standard: \"If no argument is present, the processor assigns\n      a processor-dependent value to the seed.\"  */\n   if (size == NULL && put == NULL && get == NULL)\n-      for (size_t i = 0; i < KISS_SIZE; i++)\n-\tkiss_seed[i] = kiss_default_seed[i];\n-\n-  if (size != NULL)\n-    *size = KISS_SIZE;\n+    {\n+      getosrandom (master_state, sizeof (master_state));\n+      njumps = 0;\n+      init_rand_state (rs, true);\n+    }\n \n   if (put != NULL)\n     {\n@@ -689,106 +802,125 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n         runtime_error (\"Array rank of PUT is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) KISS_SIZE)\n+      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) SZ + 1)\n         runtime_error (\"Array size of PUT is too small.\");\n \n       /*  We copy the seed given by the user.  */\n-      for (size_t i = 0; i < KISS_SIZE; i++)\n+      for (size_t i = 0; i < SZ; i++)\n \tmemcpy (seed + i * sizeof(GFC_UINTEGER_4),\n-\t\t&(put->base_addr[(KISS_SIZE - 1 - i) * GFC_DESCRIPTOR_STRIDE(put,0)]),\n+\t\t&(put->base_addr[(SZ - 1 - i) * GFC_DESCRIPTOR_STRIDE(put,0)]),\n \t\tsizeof(GFC_UINTEGER_4));\n \n       /* We put it after scrambling the bytes, to paper around users who\n \t provide seeds with quality only in the lower or upper part.  */\n-      scramble_seed ((unsigned char *) kiss_seed, seed, 4 * KISS_SIZE);\n-    }\n-\n-  /* Return the seed to GET data.  */\n-  if (get != NULL)\n-    {\n-      /* If the rank of the array is not 1, abort.  */\n-      if (GFC_DESCRIPTOR_RANK (get) != 1)\n-\truntime_error (\"Array rank of GET is not 1.\");\n+      scramble_seed ((unsigned char *) master_state, seed, sizeof seed);\n+      njumps = 0;\n+      init_rand_state (rs, true);\n \n-      /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) KISS_SIZE)\n-\truntime_error (\"Array size of GET is too small.\");\n+      rs->p = put->base_addr[SZ * GFC_DESCRIPTOR_STRIDE(put, 0)] & 15;\n+    }\n \n-      /* Unscramble the seed.  */\n-      unscramble_seed (seed, (unsigned char *) kiss_seed, 4 * KISS_SIZE);\n \n-      /*  Then copy it back to the user variable.  */\n-      for (size_t i = 0; i < KISS_SIZE; i++)\n-\tmemcpy (&(get->base_addr[(KISS_SIZE - 1 - i) * GFC_DESCRIPTOR_STRIDE(get,0)]),\n-               seed + i * sizeof(GFC_UINTEGER_4),\n-               sizeof(GFC_UINTEGER_4));\n-    }\n \n   __gthread_mutex_unlock (&random_lock);\n+    }\n+#undef SZ\n }\n iexport(random_seed_i4);\n \n \n void\n random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n {\n-  __gthread_mutex_lock (&random_lock);\n-\n   /* Check that we only have one argument present.  */\n   if ((size ? 1 : 0) + (put ? 1 : 0) + (get ? 1 : 0) > 1)\n     runtime_error (\"RANDOM_SEED should have at most one argument present.\");\n \n-  /* From the standard: \"If no argument is present, the processor assigns\n-     a processor-dependent value to the seed.\"  */\n-  if (size == NULL && put == NULL && get == NULL)\n-      for (size_t i = 0; i < KISS_SIZE; i++)\n-\tkiss_seed[i] = kiss_default_seed[i];\n-\n+#define SZ (sizeof (master_state) / sizeof (GFC_INTEGER_8))\n   if (size != NULL)\n-    *size = KISS_SIZE / 2;\n+    *size = SZ + 1;\n \n-  if (put != NULL)\n+  xorshift1024star_state* rs = get_rand_state();\n+\n+  /* Return the seed to GET data.  */\n+  if (get != NULL)\n     {\n       /* If the rank of the array is not 1, abort.  */\n-      if (GFC_DESCRIPTOR_RANK (put) != 1)\n-        runtime_error (\"Array rank of PUT is not 1.\");\n+      if (GFC_DESCRIPTOR_RANK (get) != 1)\n+\truntime_error (\"Array rank of GET is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) KISS_SIZE / 2)\n-        runtime_error (\"Array size of PUT is too small.\");\n+      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) SZ + 1)\n+\truntime_error (\"Array size of GET is too small.\");\n+\n+      if (!rs->init)\n+\tinit_rand_state (rs, false);\n \n       /*  This code now should do correct strides.  */\n-      for (size_t i = 0; i < KISS_SIZE / 2; i++)\n-\tmemcpy (&kiss_seed[2*i], &(put->base_addr[i * GFC_DESCRIPTOR_STRIDE(put,0)]),\n+      for (size_t i = 0; i < SZ; i++)\n+\tmemcpy (&(get->base_addr[i * GFC_DESCRIPTOR_STRIDE(get,0)]), &rs->s[i],\n \t\tsizeof (GFC_UINTEGER_8));\n+\n+      get->base_addr[SZ * GFC_DESCRIPTOR_STRIDE(get, 0)] = rs->p;\n     }\n \n-  /* Return the seed to GET data.  */\n-  if (get != NULL)\n+  else\n+    {\n+  __gthread_mutex_lock (&random_lock);\n+\n+  /* From the standard: \"If no argument is present, the processor assigns\n+     a processor-dependent value to the seed.\"  */\n+  if (size == NULL && put == NULL && get == NULL)\n+    {\n+      getosrandom (master_state, sizeof (master_state));\n+      njumps = 0;\n+      init_rand_state (rs, true);\n+    }\n+\n+  if (put != NULL)\n     {\n       /* If the rank of the array is not 1, abort.  */\n-      if (GFC_DESCRIPTOR_RANK (get) != 1)\n-\truntime_error (\"Array rank of GET is not 1.\");\n+      if (GFC_DESCRIPTOR_RANK (put) != 1)\n+        runtime_error (\"Array rank of PUT is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) KISS_SIZE / 2)\n-\truntime_error (\"Array size of GET is too small.\");\n+      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) SZ + 1)\n+        runtime_error (\"Array size of PUT is too small.\");\n \n       /*  This code now should do correct strides.  */\n-      for (size_t i = 0; i < KISS_SIZE / 2; i++)\n-\tmemcpy (&(get->base_addr[i * GFC_DESCRIPTOR_STRIDE(get,0)]), &kiss_seed[2*i],\n+      for (size_t i = 0; i < SZ; i++)\n+\tmemcpy (&master_state[i], &(put->base_addr[i * GFC_DESCRIPTOR_STRIDE(put,0)]),\n \t\tsizeof (GFC_UINTEGER_8));\n-    }\n+\n+      njumps = 0;\n+      init_rand_state (rs, true);\n+      rs->p = put->base_addr[SZ * GFC_DESCRIPTOR_STRIDE(put, 0)] & 15;\n+     }\n+\n \n   __gthread_mutex_unlock (&random_lock);\n+    }\n }\n iexport(random_seed_i8);\n \n \n-#ifndef __GTHREAD_MUTEX_INIT\n+#if !defined __GTHREAD_MUTEX_INIT || defined __GTHREADS\n static void __attribute__((constructor))\n-init (void)\n+constructor_random (void)\n {\n+#ifndef __GTHREAD_MUTEX_INIT\n   __GTHREAD_MUTEX_INIT_FUNCTION (&random_lock);\n+#endif\n+  if (__gthread_active_p ())\n+    __gthread_key_create (&rand_state_key, &free);\n+}\n+#endif\n+\n+#ifdef __GTHREADS\n+static void __attribute__((destructor))\n+destructor_random (void)\n+{\n+  if (__gthread_active_p ())\n+    __gthread_key_delete (rand_state_key);\n }\n #endif"}, {"sha": "09b89bc3df3417e19357826643516dd16667f9a2", "filename": "libgfortran/runtime/main.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/libgfortran%2Fruntime%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b152f5a2b33b251ab1874a43d97ce73d11eec0a4/libgfortran%2Fruntime%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fmain.c?ref=b152f5a2b33b251ab1874a43d97ce73d11eec0a4", "patch": "@@ -119,8 +119,6 @@ init (void)\n     set_fpu ();\n \n   init_compile_options ();\n-\n-  random_seed_i4 (NULL, NULL, NULL);\n }\n \n "}]}