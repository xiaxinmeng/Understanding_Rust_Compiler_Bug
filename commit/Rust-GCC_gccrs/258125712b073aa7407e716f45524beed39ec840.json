{"sha": "258125712b073aa7407e716f45524beed39ec840", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU4MTI1NzEyYjA3M2FhNzQwN2U3MTZmNDU1MjRiZWVkMzllYzg0MA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-10-29T20:30:51Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-10-29T20:30:51Z"}, "message": "PR fortran 57893\n\n2013-10-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran 57893\n\t* trans-types.c (gfc_typenode_for_spec): Add typenode for\n\tBT_HOLLERITH. Note that the length is incorrect but unusable.\n\n\tPR fortran 58858\n\t* target-memory.c (gfc_element_size): Add element sizes for\n\tBT_VOID and BT_ASSUMED, using gfc_typenode_for_spec.\n\n2013-10-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran 57893\n\t* gfortran.dg/unlimited_polymorphic_13.f90 : Use real variables\n\tto determine sizes of real kinds.\n\n\tPR fortran 58858\n\t* gfortran.dg/unlimited_polymorphic_14.f90 : New test.\n\nFrom-SVN: r204177", "tree": {"sha": "4cf1871702dc5b6ae4ecb07871b04a2fb9cb952e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cf1871702dc5b6ae4ecb07871b04a2fb9cb952e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/258125712b073aa7407e716f45524beed39ec840", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258125712b073aa7407e716f45524beed39ec840", "html_url": "https://github.com/Rust-GCC/gccrs/commit/258125712b073aa7407e716f45524beed39ec840", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258125712b073aa7407e716f45524beed39ec840/comments", "author": null, "committer": null, "parents": [{"sha": "d19245aa46952d4eff8d4b4a72c81977daf23f3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19245aa46952d4eff8d4b4a72c81977daf23f3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d19245aa46952d4eff8d4b4a72c81977daf23f3a"}], "stats": {"total": 97, "additions": 77, "deletions": 20}, "files": [{"sha": "86ce782a005797fee3cec341f61e8714915989c7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258125712b073aa7407e716f45524beed39ec840/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258125712b073aa7407e716f45524beed39ec840/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=258125712b073aa7407e716f45524beed39ec840", "patch": "@@ -1,3 +1,13 @@\n+2013-10-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran 57893\n+\t* trans-types.c (gfc_typenode_for_spec): Add typenode for\n+\tBT_HOLLERITH. Note that the length is incorrect but unusable.\n+\n+\tPR fortran 58858\n+\t* target-memory.c (gfc_element_size): Add element sizes for\n+\tBT_VOID and BT_ASSUMED, using gfc_typenode_for_spec.\n+\n 2013-10-24  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/44646"}, {"sha": "e905b3a67dcb503894826893343ed3f7be91719b", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258125712b073aa7407e716f45524beed39ec840/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258125712b073aa7407e716f45524beed39ec840/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=258125712b073aa7407e716f45524beed39ec840", "patch": "@@ -32,7 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-types.h\"\n #include \"target-memory.h\"\n \n-/* --------------------------------------------------------------- */ \n+/* --------------------------------------------------------------- */\n /* Calculate the size of an expression.  */\n \n \n@@ -109,6 +109,8 @@ gfc_element_size (gfc_expr *e)\n       return e->representation.length;\n     case BT_DERIVED:\n     case BT_CLASS:\n+    case BT_VOID:\n+    case BT_ASSUMED:\n       {\n \t/* Determine type size without clobbering the typespec for ISO C\n \t   binding types.  */\n@@ -151,7 +153,7 @@ gfc_target_expr_size (gfc_expr *e)\n }\n \n \n-/* The encode_* functions export a value into a buffer, and \n+/* The encode_* functions export a value into a buffer, and\n    return the number of bytes of the buffer that have been\n    used.  */\n \n@@ -286,7 +288,7 @@ gfc_target_encode_expr (gfc_expr *source, unsigned char *buffer,\n \t      || source->expr_type == EXPR_STRUCTURE\n \t      || source->expr_type == EXPR_SUBSTRING);\n \n-  /* If we already have a target-memory representation, we use that rather \n+  /* If we already have a target-memory representation, we use that rather\n      than recreating one.  */\n   if (source->representation.string)\n     {\n@@ -496,7 +498,7 @@ gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *resu\n       /* Needed as gfc_typenode_for_spec as gfc_typenode_for_spec\n \t sets this to BT_INTEGER.  */\n       result->ts.type = BT_DERIVED;\n-      e = gfc_get_constant_expr (cmp->ts.type, cmp->ts.kind, &result->where); \n+      e = gfc_get_constant_expr (cmp->ts.type, cmp->ts.kind, &result->where);\n       c = gfc_constructor_append_expr (&result->value.constructor, e, NULL);\n       c->n.component = cmp;\n       gfc_target_interpret_expr (buffer, buffer_size, e, true);\n@@ -511,7 +513,7 @@ gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *resu\n     {\n       gfc_constructor *c;\n       gfc_expr *e = gfc_get_constant_expr (cmp->ts.type, cmp->ts.kind,\n-\t\t\t\t\t   &result->where); \n+\t\t\t\t\t   &result->where);\n       e->ts = cmp->ts;\n \n       /* Copy shape, if needed.  */\n@@ -551,7 +553,7 @@ gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *resu\n \n       gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr, e, true);\n     }\n-    \n+\n   return int_size_in_bytes (type);\n }\n \n@@ -567,39 +569,39 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n   switch (result->ts.type)\n     {\n     case BT_INTEGER:\n-      result->representation.length = \n+      result->representation.length =\n         gfc_interpret_integer (result->ts.kind, buffer, buffer_size,\n \t\t\t       result->value.integer);\n       break;\n \n     case BT_REAL:\n-      result->representation.length = \n+      result->representation.length =\n         gfc_interpret_float (result->ts.kind, buffer, buffer_size,\n     \t\t\t     result->value.real);\n       break;\n \n     case BT_COMPLEX:\n-      result->representation.length = \n+      result->representation.length =\n         gfc_interpret_complex (result->ts.kind, buffer, buffer_size,\n \t\t\t       result->value.complex);\n       break;\n \n     case BT_LOGICAL:\n-      result->representation.length = \n+      result->representation.length =\n         gfc_interpret_logical (result->ts.kind, buffer, buffer_size,\n \t\t\t       &result->value.logical);\n       break;\n \n     case BT_CHARACTER:\n-      result->representation.length = \n+      result->representation.length =\n         gfc_interpret_character (buffer, buffer_size, result);\n       break;\n \n     case BT_CLASS:\n       result->ts = CLASS_DATA (result)->ts;\n       /* Fall through.  */\n     case BT_DERIVED:\n-      result->representation.length = \n+      result->representation.length =\n         gfc_interpret_derived (buffer, buffer_size, result);\n       gcc_assert (result->representation.length >= 0);\n       break;\n@@ -626,7 +628,7 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n }\n \n \n-/* --------------------------------------------------------------- */ \n+/* --------------------------------------------------------------- */\n /* Two functions used by trans-common.c to write overlapping\n    equivalence initializers to a buffer.  This is added to the union\n    and the original initializers freed.  */\n@@ -791,7 +793,7 @@ gfc_convert_boz (gfc_expr *expr, gfc_typespec *ts)\n       gfc_interpret_complex (ts->kind, buffer, buffer_size,\n \t\t\t     expr->value.complex);\n     }\n-  expr->is_boz = 0;  \n+  expr->is_boz = 0;\n   expr->ts.type = ts->type;\n   expr->ts.kind = ts->kind;\n "}, {"sha": "fa84d5dab8154d1b5083bebb1ade09b26e1aa107", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258125712b073aa7407e716f45524beed39ec840/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258125712b073aa7407e716f45524beed39ec840/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=258125712b073aa7407e716f45524beed39ec840", "patch": "@@ -1099,6 +1099,12 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n \tbasetype = gfc_get_character_type (spec->kind, spec->u.cl);\n       break;\n \n+    case BT_HOLLERITH:\n+      /* Since this cannot be used, return a length one character.  */\n+      basetype = gfc_get_character_type_len (gfc_default_character_kind,\n+\t\t\t\t\t     gfc_index_one_node);\n+      break;\n+\n     case BT_DERIVED:\n     case BT_CLASS:\n       basetype = gfc_get_derived_type (spec->u.derived);"}, {"sha": "1d18289397f4367a046a07840f3e371aa38d8e74", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258125712b073aa7407e716f45524beed39ec840/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258125712b073aa7407e716f45524beed39ec840/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=258125712b073aa7407e716f45524beed39ec840", "patch": "@@ -1,3 +1,12 @@\n+2013-10-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran 57893\n+\t* gfortran.dg/unlimited_polymorphic_13.f90 : Use real variables\n+\tto determine sizes of real kinds.\n+\n+\tPR fortran 58858\n+\t* gfortran.dg/unlimited_polymorphic_14.f90 : New test.\n+\n 2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* c-c++-common/cilk-plus/CK/compound_cilk_spawn.c: New test."}, {"sha": "10f644535b2c06244947b1c09f7cb1cc4a6508b3", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_13.f90", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258125712b073aa7407e716f45524beed39ec840/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258125712b073aa7407e716f45524beed39ec840/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_13.f90?ref=258125712b073aa7407e716f45524beed39ec840", "patch": "@@ -13,6 +13,10 @@ module m\n   integer, parameter :: c2 = real_kinds(2)\n   integer, parameter :: c3 = real_kinds(size(real_kinds)-1)\n   integer, parameter :: c4 = real_kinds(size(real_kinds))\n+  real(c1) :: r1\n+  real(c2) :: r2\n+  real(c3) :: r3\n+  real(c4) :: r4\n contains\n  subroutine s(o, k)\n     class(*) :: o\n@@ -21,11 +25,13 @@ subroutine s(o, k)\n \n     select case (k)\n      case (4)\n-      sz = 32*2\n+      sz = storage_size(r1)*2\n      case (8)\n-      sz = 64*2\n-     case (10,16)\n-      sz = 128*2\n+      sz = storage_size(r2)*2\n+     case (10)\n+      sz = storage_size(r3)*2\n+     case (16)\n+      sz = storage_size(r4)*2\n      case default\n        call abort()\n     end select\n@@ -36,8 +42,6 @@ subroutine s(o, k)\n         if (storage_size(o) /= sz) call abort()\n       type is (complex(c2))\n         if (storage_size(o) /= sz) call abort()\n-    end select\n-    select type (o)\n       type is (complex(c3))\n         if (storage_size(o) /= sz) call abort()\n       type is (complex(c4))"}, {"sha": "215b03f64ee7b43b8d0401fe44b20a734b2870c8", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_14.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258125712b073aa7407e716f45524beed39ec840/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258125712b073aa7407e716f45524beed39ec840/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_14.f90?ref=258125712b073aa7407e716f45524beed39ec840", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+!\n+! Uncovered in fixing PR fortran/58793\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+! Barfed on the hollerith argument\n+!\n+program test\n+  logical l\n+  call up(\"abc\", l)\n+  if (l) call abort\n+  call up(3habc, l) ! { dg-warning \"Legacy Extension\" }\n+  if (.not. l) call abort\n+contains\n+  subroutine up(x, l)\n+    class(*) :: x\n+    logical l\n+    select type(x)\n+     type is (character(*))\n+      l = .false.\n+     class default\n+      l = .true.\n+    end select\n+  end subroutine\n+end program test"}]}