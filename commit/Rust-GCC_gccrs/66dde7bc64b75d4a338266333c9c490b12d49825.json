{"sha": "66dde7bc64b75d4a338266333c9c490b12d49825", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZkZGU3YmM2NGI3NWQ0YTMzODI2NjMzM2M5YzQ5MGIxMmQ0OTgyNQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-11-30T19:32:28Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-11-30T19:32:28Z"}, "message": "Add analyzer plugin support and CPython GIL example\n\nThis patch adds a new GCC plugin event: PLUGIN_ANALYZER_INIT, called\nwhen -fanalyzer is starting, allowing for GCC plugins to register\nadditional state-machine-based checks within -fanalyzer.  The idea\nis that 3rd-party code might want to add domain-specific checks for\nits own APIs - with the caveat that the analyzer is itself still\nrather experimental.\n\nAs an example, the patch adds a proof-of-concept plugin to the testsuite\nfor checking CPython code: verifying that code that relinquishes\nCPython's global interpreter lock doesn't attempt to do anything with\nPyObjects in the sections where the lock isn't held.  It also adds a\nwarning about nested releases of the lock, which is forbidden.\nFor example:\n\ndemo.c: In function 'foo':\ndemo.c:11:3: warning: use of PyObject '*(obj)' without the GIL\n   11 |   Py_INCREF (obj);\n      |   ^~~~~~~~~\n  'test': events 1-3\n    |\n    |   15 | void test (PyObject *obj)\n    |      |      ^~~~\n    |      |      |\n    |      |      (1) entry to 'test'\n    |   16 | {\n    |   17 |   Py_BEGIN_ALLOW_THREADS\n    |      |   ~~~~~~~~~~~~~~~~~~~~~~\n    |      |   |\n    |      |   (2) releasing the GIL here\n    |   18 |   foo (obj);\n    |      |   ~~~~~~~~~\n    |      |   |\n    |      |   (3) calling 'foo' from 'test'\n    |\n    +--> 'foo': events 4-5\n           |\n           |    9 | foo (PyObject *obj)\n           |      | ^~~\n           |      | |\n           |      | (4) entry to 'foo'\n           |   10 | {\n           |   11 |   Py_INCREF (obj);\n           |      |   ~~~~~~~~~\n           |      |   |\n           |      |   (5) PyObject '*(obj)' used here without the GIL\n           |\n\nDoing so requires adding some logic for ignoring macro expansions in\nanalyzer diagnostics, since the insides of Py_INCREF and\nPy_BEGIN_ALLOW_THREADS are not of interest to the user for these cases.\n\ngcc/analyzer/ChangeLog:\n\t* analyzer-pass.cc (pass_analyzer::execute): Move sorry call to...\n\t(sorry_no_analyzer): New.\n\t* analyzer.h (class state_machine): New forward decl.\n\t(class logger): New forward decl.\n\t(class plugin_analyzer_init_iface): New.\n\t(sorry_no_analyzer): New decl.\n\t* checker-path.cc (checker_path::fixup_locations): New.\n\t* checker-path.h (checker_event::set_location): New.\n\t(checker_path::fixup_locations): New decl.\n\t* diagnostic-manager.cc\n\t(diagnostic_manager::emit_saved_diagnostic): Call\n\tchecker_path::fixup_locations, and call fixup_location\n\ton the primary location.\n\t* engine.cc: Include \"plugin.h\".\n\t(class plugin_analyzer_init_impl): New.\n\t(impl_run_checkers): Invoke PLUGIN_ANALYZER_INIT callbacks.\n\t* pending-diagnostic.h (pending_diagnostic::fixup_location): New\n\tvfunc.\n\ngcc/ChangeLog:\n\t* doc/plugins.texi (Plugin callbacks): Add PLUGIN_ANALYZER_INIT.\n\t* plugin.c (register_callback): Likewise.\n\t(invoke_plugin_callbacks_full): Likewise.\n\t* plugin.def (PLUGIN_ANALYZER_INIT): New event.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/analyzer_gil_plugin.c: New test.\n\t* gcc.dg/plugin/gil-1.c: New test.\n\t* gcc.dg/plugin/gil.h: New header.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the new plugin\n\tand test.", "tree": {"sha": "5f44f4fbd3e979b9557c8d390fca30745ce042c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f44f4fbd3e979b9557c8d390fca30745ce042c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66dde7bc64b75d4a338266333c9c490b12d49825", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66dde7bc64b75d4a338266333c9c490b12d49825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66dde7bc64b75d4a338266333c9c490b12d49825", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66dde7bc64b75d4a338266333c9c490b12d49825/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ddb6eca28a2b58656c5d786a4462024ab74618f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ddb6eca28a2b58656c5d786a4462024ab74618f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ddb6eca28a2b58656c5d786a4462024ab74618f"}], "stats": {"total": 662, "additions": 658, "deletions": 4}, "files": [{"sha": "1f65bf8b154753635e17e97eceb409de0ede42d5", "filename": "gcc/analyzer/analyzer-pass.cc", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fanalyzer-pass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fanalyzer-pass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-pass.cc?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -83,9 +83,7 @@ pass_analyzer::execute (function *)\n #if ENABLE_ANALYZER\n   ana::run_checkers ();\n #else\n-  sorry (\"%qs was not enabled in this build of GCC\"\n-\t \" (missing configure-time option %qs)\",\n-\t \"-fanalyzer\", \"--enable-analyzer\");\n+  sorry_no_analyzer ();\n #endif\n \n   return 0;\n@@ -100,3 +98,17 @@ make_pass_analyzer (gcc::context *ctxt)\n {\n   return new pass_analyzer (ctxt);\n }\n+\n+#if !ENABLE_ANALYZER\n+\n+/* Issue a \"sorry\" diagnostic that the analyzer was not enabled.  */\n+\n+void\n+sorry_no_analyzer ()\n+{\n+  sorry (\"%qs was not enabled in this build of GCC\"\n+\t \" (missing configure-time option %qs)\",\n+\t \"-fanalyzer\", \"--enable-analyzer\");\n+}\n+\n+#endif /* #if !ENABLE_ANALYZER */"}, {"sha": "cd46bfc0d0d6707d1e32dce14bd39efb907487af", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -189,6 +189,15 @@ class region_offset\n \n extern location_t get_stmt_location (const gimple *stmt, function *fun);\n \n+/* Passed by pointer to PLUGIN_ANALYZER_INIT callbacks.  */\n+\n+class plugin_analyzer_init_iface\n+{\n+public:\n+  virtual void register_state_machine (state_machine *) = 0;\n+  virtual logger *get_logger () const = 0;\n+};\n+\n } // namespace ana\n \n extern bool is_special_named_call_p (const gcall *call, const char *funcname,\n@@ -309,4 +318,8 @@ class consolidation_map\n #pragma GCC diagnostic ignored \"-Wformat-diag\"\n #endif\n \n+#if !ENABLE_ANALYZER\n+extern void sorry_no_analyzer ();\n+#endif /* #if !ENABLE_ANALYZER */\n+\n #endif /* GCC_ANALYZER_ANALYZER_H */"}, {"sha": "062730cc789f0dfbfb75cdca76180cebd14c823b", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -982,6 +982,15 @@ checker_path::add_final_event (const state_machine *sm,\n   add_event (end_of_path);\n }\n \n+void\n+checker_path::fixup_locations (pending_diagnostic *pd)\n+{\n+  checker_event *e;\n+  int i;\n+  FOR_EACH_VEC_ELT (m_events, i, e)\n+    e->set_location (pd->fixup_location (e->get_location ()));\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "79553baec97261c3070731f5587e39be06f1bdfa", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -105,6 +105,8 @@ class checker_event : public diagnostic_event\n \n   void dump (pretty_printer *pp) const;\n \n+  void set_location (location_t loc) { m_loc = loc; }\n+\n  public:\n   const enum event_kind m_kind;\n  protected:\n@@ -504,6 +506,8 @@ class checker_path : public diagnostic_path\n       e->prepare_for_emission (this, pd, diagnostic_event_id_t (i));\n   }\n \n+  void fixup_locations (pending_diagnostic *pd);\n+\n   void record_setjmp_event (const exploded_node *enode,\n \t\t\t    diagnostic_event_id_t setjmp_emission_id)\n   {"}, {"sha": "9739ca6ee449b05f183d1dd08b4d4103056e0501", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -665,7 +665,14 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n \n   emission_path.prepare_for_emission (sd.m_d);\n \n-  gcc_rich_location rich_loc (get_stmt_location (stmt, sd.m_snode->m_fun));\n+  location_t loc = get_stmt_location (stmt, sd.m_snode->m_fun);\n+\n+  /* Allow the pending_diagnostic to fix up the primary location\n+     and any locations for events.  */\n+  loc = sd.m_d->fixup_location (loc);\n+  emission_path.fixup_locations (sd.m_d);\n+\n+  gcc_rich_location rich_loc (loc);\n   rich_loc.set_path (&emission_path);\n \n   auto_diagnostic_group d;"}, {"sha": "d022b3a8edb9a642159ed67d9f457f2948290f5d", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/state-purge.h\"\n #include \"analyzer/bar-chart.h\"\n #include <zlib.h>\n+#include \"plugin.h\"\n \n /* For an overview, see gcc/doc/analyzer.texi.  */\n \n@@ -4638,6 +4639,33 @@ dump_analyzer_json (const supergraph &sg,\n   free (filename);\n }\n \n+/* Concrete subclass of plugin_analyzer_init_iface, allowing plugins\n+   to register new state machines.  */\n+\n+class plugin_analyzer_init_impl : public plugin_analyzer_init_iface\n+{\n+public:\n+  plugin_analyzer_init_impl (auto_delete_vec <state_machine> *checkers,\n+\t\t\t     logger *logger)\n+  : m_checkers (checkers),\n+    m_logger (logger)\n+  {}\n+\n+  void register_state_machine (state_machine *sm) FINAL OVERRIDE\n+  {\n+    m_checkers->safe_push (sm);\n+  }\n+\n+  logger *get_logger () const FINAL OVERRIDE\n+  {\n+    return m_logger;\n+  }\n+\n+private:\n+  auto_delete_vec <state_machine> *m_checkers;\n+  logger *m_logger;\n+};\n+\n /* Run the analysis \"engine\".  */\n \n void\n@@ -4683,6 +4711,9 @@ impl_run_checkers (logger *logger)\n   auto_delete_vec <state_machine> checkers;\n   make_checkers (checkers, logger);\n \n+  plugin_analyzer_init_impl data (&checkers, logger);\n+  invoke_plugin_callbacks (PLUGIN_ANALYZER_INIT, &data);\n+\n   if (logger)\n     {\n       int i;"}, {"sha": "0cec27a66e52ed64b3565677ec9552ec1844efa1", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -175,6 +175,14 @@ class pending_diagnostic\n      diagnostic deduplication.  */\n   static bool same_tree_p (tree t1, tree t2);\n \n+  /* A vfunc for fixing up locations (both the primary location for the\n+     diagnostic, and for events in their paths), e.g. to avoid unwinding\n+     inside specific macros.  */\n+  virtual location_t fixup_location (location_t loc) const\n+  {\n+    return loc;\n+  }\n+\n   /* For greatest precision-of-wording, the various following \"describe_*\"\n      virtual functions give the pending diagnostic a way to describe events\n      in a diagnostic_path in terms that make sense for that diagnostic."}, {"sha": "1c211bbacf1c121563a222e7ffb64459484b279e", "filename": "gcc/doc/plugins.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fdoc%2Fplugins.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fdoc%2Fplugins.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fplugins.texi?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -218,6 +218,10 @@ enum plugin_event\n    as a const char* pointer.  */\n   PLUGIN_INCLUDE_FILE,\n \n+  /* Called when -fanalyzer starts. The event data is an\n+     ana::plugin_analyzer_init_iface *.  */\n+  PLUGIN_ANALYZER_INIT,\n+\n   PLUGIN_EVENT_FIRST_DYNAMIC    /* Dummy event used for indexing callback\n                                    array.  */\n @};"}, {"sha": "76069e647982fcf3a5010f0a66b2df77d604e6be", "filename": "gcc/plugin.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -497,6 +497,7 @@ register_callback (const char *plugin_name,\n       case PLUGIN_EARLY_GIMPLE_PASSES_END:\n       case PLUGIN_NEW_PASS:\n       case PLUGIN_INCLUDE_FILE:\n+      case PLUGIN_ANALYZER_INIT:\n         {\n           struct callback_info *new_callback;\n           if (!callback)\n@@ -577,6 +578,7 @@ invoke_plugin_callbacks_full (int event, void *gcc_data)\n       case PLUGIN_EARLY_GIMPLE_PASSES_END:\n       case PLUGIN_NEW_PASS:\n       case PLUGIN_INCLUDE_FILE:\n+      case PLUGIN_ANALYZER_INIT:\n         {\n           /* Iterate over every callback registered with this event and\n              call it.  */"}, {"sha": "b8110190d3aa143a5dacd91e0fb470a7ee07418c", "filename": "gcc/plugin.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fplugin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Fplugin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.def?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -99,6 +99,10 @@ DEFEVENT (PLUGIN_NEW_PASS)\n    as a const char* pointer.  */\n DEFEVENT (PLUGIN_INCLUDE_FILE)\n \n+/* Called when -fanalyzer starts. The event data is an\n+   ana::plugin_analyzer_init_iface *.  */\n+DEFEVENT (PLUGIN_ANALYZER_INIT)\n+\n /* When adding a new hard-coded plugin event, don't forget to edit in\n    file plugin.c the functions register_callback and\n    invoke_plugin_callbacks_full accordingly!  */"}, {"sha": "05133d5250e881aa74229ce789e96c3aa083daff", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_gil_plugin.c", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -0,0 +1,436 @@\n+/* Proof-of-concept of a -fanalyzer plugin.\n+   Detect (some) uses of CPython API outside of the Global Interpreter Lock.\n+   https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock\n+*/\n+/* { dg-options \"-g\" } */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-walk.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"json.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+static bool\n+type_based_on_pyobject_p (tree type)\n+{\n+  /* Ideally we'd also check for \"subclasses\" here by iterating up the\n+     first field of each struct.  */\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return false;\n+  tree name = TYPE_IDENTIFIER (type);\n+  if (!name)\n+    return false;\n+  return id_equal (name, \"PyObject\");\n+}\n+\n+/* An experimental state machine, for tracking whether the GIL is held,\n+   as global state..  */\n+\n+class gil_state_machine : public state_machine\n+{\n+public:\n+  gil_state_machine (logger *logger);\n+\n+  bool inherited_state_p () const FINAL OVERRIDE { return false; }\n+\n+  bool on_stmt (sm_context *sm_ctxt,\n+\t\tconst supernode *node,\n+\t\tconst gimple *stmt) const FINAL OVERRIDE;\n+\n+  void on_condition (sm_context *sm_ctxt,\n+\t\t     const supernode *node,\n+\t\t     const gimple *stmt,\n+\t\t     tree lhs,\n+\t\t     enum tree_code op,\n+\t\t     tree rhs) const FINAL OVERRIDE;\n+\n+  bool can_purge_p (state_t s) const FINAL OVERRIDE;\n+\n+  void check_for_pyobject_usage_without_gil (sm_context *sm_ctxt,\n+\t\t\t\t\t     const supernode *node,\n+\t\t\t\t\t     const gimple *stmt,\n+\t\t\t\t\t     tree op) const;\n+\n+ private:\n+  void check_for_pyobject_in_call (sm_context *sm_ctxt,\n+\t\t\t\t   const supernode *node,\n+\t\t\t\t   const gcall *call,\n+\t\t\t\t   tree callee_fndecl) const;\n+\n+ public:\n+  /* These states are \"global\", rather than per-expression.  */\n+\n+  /* State for when we've released the GIL.  */\n+  state_t m_released_gil;\n+\n+  /* Stop state.  */\n+  state_t m_stop;\n+};\n+\n+/* Subclass for diagnostics involving the GIL.  */\n+\n+class gil_diagnostic : public pending_diagnostic\n+{\n+public:\n+  location_t fixup_location (location_t loc) const FINAL OVERRIDE\n+  {\n+    /* Ideally we'd check for specific macros here, and only\n+       resolve certain macros.  */\n+    if (linemap_location_from_macro_expansion_p (line_table, loc))\n+      loc = linemap_resolve_location (line_table, loc,\n+\t\t\t\t      LRK_MACRO_EXPANSION_POINT, NULL);\n+    return loc;\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.is_global_p ()\n+\t&& change.m_new_state == m_sm.m_released_gil)\n+      return change.formatted_print (\"releasing the GIL here\");\n+    if (change.is_global_p ()\n+\t&& change.m_new_state == m_sm.get_start_state ())\n+      return change.formatted_print (\"acquiring the GIL here\");\n+    return label_text ();\n+  }\n+\n+ protected:\n+  gil_diagnostic (const gil_state_machine &sm) : m_sm (sm)\n+  {\n+  }\n+\n+ private:\n+  const gil_state_machine &m_sm;\n+};\n+\n+class double_save_thread : public gil_diagnostic\n+{\n+ public:\n+  double_save_thread (const gil_state_machine &sm, const gcall *call)\n+  : gil_diagnostic (sm), m_call (call)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE\n+  {\n+    return \"double_save_thread\";\n+  }\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const OVERRIDE\n+  {\n+    const double_save_thread &sub_other\n+      = (const double_save_thread &)base_other;\n+    return m_call == sub_other.m_call;\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    return warning_at (rich_loc, 0,\n+\t\t       \"nested usage of %qs\", \"Py_BEGIN_ALLOW_THREADS\");\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    return ev.formatted_print (\"nested usage of %qs here\",\n+\t\t\t       \"Py_BEGIN_ALLOW_THREADS\");\n+  }\n+\n+ private:\n+  const gcall *m_call;\n+};\n+\n+class fncall_without_gil : public gil_diagnostic\n+{\n+ public:\n+  fncall_without_gil (const gil_state_machine &sm, const gcall *call,\n+\t\t      tree callee_fndecl, unsigned arg_idx)\n+  : gil_diagnostic (sm), m_call (call), m_callee_fndecl (callee_fndecl),\n+    m_arg_idx (arg_idx)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE\n+  {\n+    return \"fncall_without_gil\";\n+  }\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const OVERRIDE\n+  {\n+    const fncall_without_gil &sub_other\n+      = (const fncall_without_gil &)base_other;\n+    return (m_call == sub_other.m_call\n+\t    && m_callee_fndecl == sub_other.m_callee_fndecl\n+\t    && m_arg_idx == sub_other.m_arg_idx);\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    auto_diagnostic_group d;\n+    /* There isn't a warning ID for use to use.  */\n+    if (m_callee_fndecl)\n+      return warning_at (rich_loc, 0,\n+\t\t\t \"use of PyObject as argument %i of %qE\"\n+\t\t\t \" without the GIL\",\n+\t\t\t m_arg_idx + 1, m_callee_fndecl);\n+    else\n+      return warning_at (rich_loc, 0,\n+\t\t\t \"use of PyObject as argument %i of call\"\n+\t\t\t \" without the GIL\",\n+\t\t\t m_arg_idx + 1, m_callee_fndecl);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_callee_fndecl)\n+      return ev.formatted_print (\"use of PyObject as argument %i of %qE here\"\n+\t\t\t\t \" without the GIL\",\n+\t\t\t\t m_arg_idx + 1, m_callee_fndecl);\n+    else\n+      return ev.formatted_print (\"use of PyObject as argument %i of call here\"\n+\t\t\t\t \" without the GIL\",\n+\t\t\t\t m_arg_idx + 1, m_callee_fndecl);\n+  }\n+\n+ private:\n+  const gcall *m_call;\n+  tree m_callee_fndecl;\n+  unsigned m_arg_idx;\n+};\n+\n+class pyobject_usage_without_gil : public gil_diagnostic\n+{\n+ public:\n+  pyobject_usage_without_gil (const gil_state_machine &sm, tree expr)\n+  : gil_diagnostic (sm), m_expr (expr)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE\n+  {\n+    return \"pyobject_usage_without_gil\";\n+  }\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const OVERRIDE\n+  {\n+    return same_tree_p (m_expr,\n+\t\t\t((const pyobject_usage_without_gil&)base_other).m_expr);\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    auto_diagnostic_group d;\n+    /* There isn't a warning ID for use to use.  */\n+    return warning_at (rich_loc, 0,\n+\t\t       \"use of PyObject %qE without the GIL\", m_expr);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    return ev.formatted_print (\"PyObject %qE used here without the GIL\",\n+\t\t\t       m_expr);\n+  }\n+\n+ private:\n+  tree m_expr;\n+};\n+\n+/* gil_state_machine's ctor.  */\n+\n+gil_state_machine::gil_state_machine (logger *logger)\n+: state_machine (\"gil\", logger)\n+{\n+  m_released_gil = add_state (\"released_gil\");\n+  m_stop = add_state (\"stop\");\n+}\n+\n+struct cb_data\n+{\n+  cb_data (const gil_state_machine &sm, sm_context *sm_ctxt,\n+\t   const supernode *snode, const gimple *stmt)\n+  : m_sm (sm), m_sm_ctxt (sm_ctxt), m_snode (snode), m_stmt (stmt)\n+  {\n+  }\n+\n+  const gil_state_machine &m_sm;\n+  sm_context *m_sm_ctxt;\n+  const supernode *m_snode;\n+  const gimple *m_stmt;\n+};\n+\n+static bool\n+check_for_pyobject (gimple *, tree op, tree, void *data)\n+{\n+  cb_data *d = (cb_data *)data;\n+  d->m_sm.check_for_pyobject_usage_without_gil (d->m_sm_ctxt, d->m_snode,\n+\t\t\t\t\t\td->m_stmt, op);\n+  return true;\n+}\n+\n+/* Assuming that the GIL has been released, complain about any\n+   PyObject * arguments passed to CALL.  */\n+\n+void\n+gil_state_machine::check_for_pyobject_in_call (sm_context *sm_ctxt,\n+\t\t\t\t\t       const supernode *node,\n+\t\t\t\t\t       const gcall *call,\n+\t\t\t\t\t       tree callee_fndecl) const\n+{\n+  for (unsigned i = 0; i < gimple_call_num_args (call); i++)\n+    {\n+      tree arg = gimple_call_arg (call, i);\n+      if (TREE_CODE (TREE_TYPE (arg)) != POINTER_TYPE)\n+\tcontinue;\n+      tree type = TREE_TYPE (TREE_TYPE (arg));\n+      if (type_based_on_pyobject_p (type))\n+\t{\n+\t  sm_ctxt->warn (node, call, NULL_TREE,\n+\t\t\t new fncall_without_gil (*this, call,\n+\t\t\t\t\t\t callee_fndecl,\n+\t\t\t\t\t\t i));\n+\t  sm_ctxt->set_global_state (m_stop);\n+\t}\n+    }\n+}\n+\n+/* Implementation of state_machine::on_stmt vfunc for gil_state_machine.  */\n+\n+bool\n+gil_state_machine::on_stmt (sm_context *sm_ctxt,\n+\t\t\t    const supernode *node,\n+\t\t\t    const gimple *stmt) const\n+{\n+  const state_t global_state = sm_ctxt->get_global_state ();\n+  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+    {\n+      if (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\n+\t{\n+\t  if (is_named_call_p (callee_fndecl, \"PyEval_SaveThread\", call, 0))\n+\t    {\n+\t      if (0)\n+\t\tinform (input_location, \"found call to %qs\",\n+\t\t\t\"PyEval_SaveThread\");\n+\t      if (global_state == m_released_gil)\n+\t\t{\n+\t\t  sm_ctxt->warn (node, stmt, NULL_TREE,\n+\t\t\t\t new double_save_thread (*this, call));\n+\t\t  sm_ctxt->set_global_state (m_stop);\n+\t\t}\n+\t      else\n+\t\tsm_ctxt->set_global_state (m_released_gil);\n+\t      return true;\n+\t    }\n+\t  else if (is_named_call_p (callee_fndecl, \"PyEval_RestoreThread\",\n+\t\t\t\t    call, 1))\n+\t    {\n+\t      if (0)\n+\t\tinform (input_location, \"found call to %qs\",\n+\t\t\t\"PyEval_SaveThread\");\n+\t      if (global_state == m_released_gil)\n+\t\tsm_ctxt->set_global_state (m_start);\n+\t      return true;\n+\t    }\n+\t  else if (global_state == m_released_gil)\n+\t    {\n+\t      /* Find PyObject * args of calls to fns with unknown bodies.  */\n+\t      if (!fndecl_has_gimple_body_p (callee_fndecl))\n+\t\tcheck_for_pyobject_in_call (sm_ctxt, node, call, callee_fndecl);\n+\t    }\n+\t}\n+      else if (global_state == m_released_gil)\n+\tcheck_for_pyobject_in_call (sm_ctxt, node, call, NULL);\n+    }\n+  else\n+    if (global_state == m_released_gil)\n+      {\n+\t/* Walk the stmt, finding uses of PyObject (or \"subclasses\").  */\n+\tcb_data d (*this, sm_ctxt, node, stmt);\n+\twalk_stmt_load_store_addr_ops (const_cast <gimple *> (stmt), &d,\n+\t\t\t\t       check_for_pyobject,\n+\t\t\t\t       check_for_pyobject,\n+\t\t\t\t       check_for_pyobject);\n+    }\n+  return false;\n+}\n+\n+/* Implementation of state_machine::on_condition vfunc for\n+   gil_state_machine.  */\n+\n+void\n+gil_state_machine::on_condition (sm_context *sm_ctxt ATTRIBUTE_UNUSED,\n+\t\t\t\t const supernode *node ATTRIBUTE_UNUSED,\n+\t\t\t\t const gimple *stmt ATTRIBUTE_UNUSED,\n+\t\t\t\t tree lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t enum tree_code op ATTRIBUTE_UNUSED,\n+\t\t\t\t tree rhs ATTRIBUTE_UNUSED) const\n+{\n+  // Empty\n+}\n+\n+bool\n+gil_state_machine::can_purge_p (state_t s ATTRIBUTE_UNUSED) const\n+{\n+  return true;\n+}\n+\n+void\n+gil_state_machine::check_for_pyobject_usage_without_gil (sm_context *sm_ctxt,\n+\t\t\t\t\t\t\t const supernode *node,\n+\t\t\t\t\t\t\t const gimple *stmt,\n+\t\t\t\t\t\t\t tree op) const\n+{\n+  tree type = TREE_TYPE (op);\n+  if (type_based_on_pyobject_p (type))\n+    {\n+      sm_ctxt->warn (node, stmt, NULL_TREE,\n+\t\t     new pyobject_usage_without_gil (*this, op));\n+      sm_ctxt->set_global_state (m_stop);\n+    }\n+}\n+\n+/* Callback handler for the PLUGIN_ANALYZER_INIT event.  */\n+\n+static void\n+gil_analyzer_init_cb (void *gcc_data, void */*user_data*/)\n+{\n+  ana::plugin_analyzer_init_iface *iface\n+    = (ana::plugin_analyzer_init_iface *)gcc_data;\n+  LOG_SCOPE (iface->get_logger ());\n+  if (0)\n+    inform (input_location, \"got here: gil_analyzer_init_cb\");\n+  iface->register_state_machine (new gil_state_machine (iface->get_logger ()));\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+#if ENABLE_ANALYZER\n+  const char *plugin_name = plugin_info->base_name;\n+  if (0)\n+    inform (input_location, \"got here; %qs\", plugin_name);\n+  register_callback (plugin_info->base_name,\n+\t\t     PLUGIN_ANALYZER_INIT,\n+\t\t     ana::gil_analyzer_init_cb,\n+\t\t     NULL); /* void *user_data */\n+#else\n+  sorry_no_analyzer ();\n+#endif\n+  return 0;\n+}"}, {"sha": "4e8f535ba857da7757f9e738f496891c7340d8e6", "filename": "gcc/testsuite/gcc.dg/plugin/gil-1.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fgil-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fgil-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fgil-1.c?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+\n+#include \"gil.h\"\n+\n+void test_1 (void)\n+{\n+  Py_BEGIN_ALLOW_THREADS\n+  Py_END_ALLOW_THREADS\n+}\n+\n+void test_2 (PyObject *obj)\n+{\n+  Py_BEGIN_ALLOW_THREADS /* { dg-message \"releasing the GIL here\" } */\n+\n+  Py_INCREF (obj); /* { dg-warning \"use of PyObject '\\\\*\\\\(obj\\\\)' without the GIL\" } */\n+  Py_DECREF (obj);\n+\n+  Py_END_ALLOW_THREADS\n+}\n+\n+void test_3 (PyObject *obj)\n+{\n+  Py_BEGIN_ALLOW_THREADS /* { dg-message \"releasing the GIL here\" } */\n+\n+  Py_BEGIN_ALLOW_THREADS /* { dg-warning \"nested usage of 'Py_BEGIN_ALLOW_THREADS'\" } */\n+  Py_END_ALLOW_THREADS\n+\n+  Py_END_ALLOW_THREADS\n+}\n+\n+void test_4 (PyObject *obj)\n+{\n+  /* These aren't nested, so should be OK.  */\n+  Py_BEGIN_ALLOW_THREADS\n+  Py_END_ALLOW_THREADS\n+\n+  Py_BEGIN_ALLOW_THREADS\n+  Py_END_ALLOW_THREADS\n+}\n+\n+/* Interprocedural example of erroneously nested usage.  */\n+\n+static void  __attribute__((noinline))\n+called_by_test_5 (void)\n+{\n+  Py_BEGIN_ALLOW_THREADS /* { dg-warning \"nested usage of 'Py_BEGIN_ALLOW_THREADS'\" } */\n+  Py_END_ALLOW_THREADS\n+}\n+\n+void test_5 (PyObject *obj)\n+{\n+  Py_BEGIN_ALLOW_THREADS /* { dg-message \"releasing the GIL here\" } */\n+  called_by_test_5 ();\n+  Py_END_ALLOW_THREADS\n+}\n+\n+/* Interprocedural example of bogusly using a PyObject outside of GIL.  */\n+\n+static void  __attribute__((noinline))\n+called_by_test_6 (PyObject *obj)\n+{\n+  Py_INCREF (obj); /* { dg-warning \"use of PyObject '\\\\*\\\\(obj\\\\)' without the GIL\" } */\n+  Py_DECREF (obj);\n+}\n+\n+void test_6 (PyObject *obj)\n+{\n+  Py_BEGIN_ALLOW_THREADS /* { dg-message \"releasing the GIL here\" } */\n+  called_by_test_6 (obj);\n+  Py_END_ALLOW_THREADS\n+}\n+\n+extern void called_by_test_7 (PyObject *obj);\n+\n+void test_7 (PyObject *obj)\n+{\n+  Py_BEGIN_ALLOW_THREADS /* { dg-message \"releasing the GIL here\" } */\n+  called_by_test_7 (obj); /* { dg-warning \"use of PyObject as argument 1 of 'called_by_test_7' without the GIL\" } */\n+  Py_END_ALLOW_THREADS\n+}\n+\n+typedef void (*callback_t) (PyObject *);\n+\n+void test_8 (PyObject *obj, callback_t cb)\n+{\n+  Py_BEGIN_ALLOW_THREADS /* { dg-message \"releasing the GIL here\" } */\n+  cb (obj); /* { dg-warning \"use of PyObject as argument 1 of call without the GIL\" } */\n+  Py_END_ALLOW_THREADS\n+}"}, {"sha": "b0610cd749e1c01d62ca3cc3b3880ee917c96af4", "filename": "gcc/testsuite/gcc.dg/plugin/gil.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fgil.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fgil.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fgil.h?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -0,0 +1,32 @@\n+/* Adapted from CPython 3.8's ceval.h.  */\n+typedef struct PyThreadState PyThreadState;\n+extern PyThreadState * PyEval_SaveThread(void);\n+extern void PyEval_RestoreThread(PyThreadState *);\n+\n+#define Py_BEGIN_ALLOW_THREADS { \\\n+                        PyThreadState *_save; \\\n+                        _save = PyEval_SaveThread();\n+#define Py_BLOCK_THREADS        PyEval_RestoreThread(_save);\n+#define Py_UNBLOCK_THREADS      _save = PyEval_SaveThread();\n+#define Py_END_ALLOW_THREADS    PyEval_RestoreThread(_save); \\\n+                 }\n+\n+/* Adapted/hacked up from CPython 3.8's object.h.  */\n+\n+typedef struct _object {\n+    int ob_refcnt;\n+} PyObject;\n+\n+#define _PyObject_CAST(op) ((PyObject*)(op))\n+\n+extern void _Py_Dealloc(PyObject *);\n+\n+#define _Py_INCREF(OP) do { (OP)->ob_refcnt++; } while (0);\n+#define _Py_DECREF(OP) do {\t  \\\n+    if (--(OP)->ob_refcnt == 0) { \\\n+      _Py_Dealloc(OP);\t\t  \\\n+    }\t\t\t\t  \\\n+  } while (0)\n+\n+#define Py_INCREF(op) _Py_INCREF(_PyObject_CAST(op))\n+#define Py_DECREF(op) _Py_DECREF(_PyObject_CAST(op))"}, {"sha": "7f0ffd68f8b7298c279b2ad01a22b713ada22031", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dde7bc64b75d4a338266333c9c490b12d49825/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=66dde7bc64b75d4a338266333c9c490b12d49825", "patch": "@@ -118,6 +118,8 @@ set plugin_test_list [list \\\n     { dump_plugin.c \\\n \t  dump-1.c \\\n \t  dump-2.c } \\\n+    { analyzer_gil_plugin.c \\\n+\t  gil-1.c } \\\n ]\n \n foreach plugin_test $plugin_test_list {"}]}