{"sha": "8c6a82695b85f8ed74cdc67f2cf74c5a62d0d91d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM2YTgyNjk1Yjg1ZjhlZDc0Y2RjNjdmMmNmNzRjNWE2MmQwZDkxZA==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-06-04T12:07:52Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-06-04T12:07:52Z"}, "message": "calls.c (expand_call): Avoid calling pure or const functions when the result is ignored (or void) and...\n\n\n\t* calls.c (expand_call): Avoid calling pure or const functions\n\twhen the result is ignored (or void) and none of the arguments\n\tare volatile.  Move warning diagnostic earlier in function.\n\nFrom-SVN: r67436", "tree": {"sha": "3db65d6f6c47477a6b251f457addfa72eb727e45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3db65d6f6c47477a6b251f457addfa72eb727e45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c6a82695b85f8ed74cdc67f2cf74c5a62d0d91d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6a82695b85f8ed74cdc67f2cf74c5a62d0d91d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c6a82695b85f8ed74cdc67f2cf74c5a62d0d91d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6a82695b85f8ed74cdc67f2cf74c5a62d0d91d/comments", "author": null, "committer": null, "parents": [{"sha": "e2d8bb2946c433461b613996567250b72b87cd24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2d8bb2946c433461b613996567250b72b87cd24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2d8bb2946c433461b613996567250b72b87cd24"}], "stats": {"total": 45, "additions": 39, "deletions": 6}, "files": [{"sha": "4199b5091a80704b4d4718195e22da43df464c27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6a82695b85f8ed74cdc67f2cf74c5a62d0d91d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6a82695b85f8ed74cdc67f2cf74c5a62d0d91d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c6a82695b85f8ed74cdc67f2cf74c5a62d0d91d", "patch": "@@ -1,3 +1,9 @@\n+2003-06-04  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* calls.c (expand_call): Avoid calling pure or const functions\n+\twhen the result is ignored (or void) and none of the arguments\n+\tare volatile.  Move warning diagnostic earlier in function.\n+\n 2003-06-04  Andreas Jaeger  <aj@suse.de>\n \n \t* system.h: Do not poison TDESC_SECTION_ASM_OP,\n@@ -15,7 +21,8 @@\n \t* cse.c: Include params.h.\n \t(PATHLENGTH): Removed.\n \t(struct cse_basic_block_data): Make path array dynamic.\n-\t(cse_end_of_basic_block): Use PARAM_MAX_CSE_PATH_LENGTH instead of PATHLENGTH.\n+\t(cse_end_of_basic_block): Use PARAM_MAX_CSE_PATH_LENGTH instead\n+\tof PATHLENGTH.\n \t(cse_main, cse_basic_block): Allocate path array.\n \t* params.def (PARAM_MAX_CSE_PATH_LENGTH): New.\n "}, {"sha": "db6b884be1ea6896d82bf421bbea965cedf10f9b", "filename": "gcc/calls.c", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6a82695b85f8ed74cdc67f2cf74c5a62d0d91d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6a82695b85f8ed74cdc67f2cf74c5a62d0d91d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=8c6a82695b85f8ed74cdc67f2cf74c5a62d0d91d", "patch": "@@ -2211,6 +2211,37 @@ expand_call (exp, target, ignore)\n   else\n     flags |= flags_from_decl_or_type (TREE_TYPE (TREE_TYPE (p)));\n \n+  /* Warn if this value is an aggregate type,\n+     regardless of which calling convention we are using for it.  */\n+  if (warn_aggregate_return && AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n+    warning (\"function call has aggregate value\");\n+\n+  /* If the result of a pure or const function call is ignored (or void),\n+     and none of its arguments are volatile, we can avoid expanding the\n+     call and just evaluate the arguments for side-effects.  */\n+  if ((flags & (ECF_CONST | ECF_PURE))\n+      && (ignore || target == const0_rtx\n+\t  || TYPE_MODE (TREE_TYPE (exp)) == VOIDmode))\n+    {\n+      bool volatilep = false;\n+      tree arg;\n+\n+      for (arg = actparms; arg; arg = TREE_CHAIN (arg))\n+\tif (TREE_THIS_VOLATILE (TREE_VALUE (arg)))\n+\t  {\n+\t    volatilep = true;\n+\t    break;\n+\t  }\n+\n+      if (! volatilep)\n+\t{\n+\t  for (arg = actparms; arg; arg = TREE_CHAIN (arg))\n+\t    expand_expr (TREE_VALUE (arg), const0_rtx,\n+\t\t\t VOIDmode, EXPAND_NORMAL);\n+\t  return const0_rtx;\n+\t}\n+    }\n+\n #ifdef REG_PARM_STACK_SPACE\n #ifdef MAYBE_REG_PARM_STACK_SPACE\n   reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n@@ -2224,11 +2255,6 @@ expand_call (exp, target, ignore)\n     must_preallocate = 1;\n #endif\n \n-  /* Warn if this value is an aggregate type,\n-     regardless of which calling convention we are using for it.  */\n-  if (warn_aggregate_return && AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n-    warning (\"function call has aggregate value\");\n-\n   /* Set up a place to return a structure.  */\n \n   /* Cater to broken compilers.  */"}]}