{"sha": "8b5fb3a36f12edc290b5a2c90db551d406df4edf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI1ZmIzYTM2ZjEyZWRjMjkwYjVhMmM5MGRiNTUxZDQwNmRmNGVkZg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2007-05-18T21:15:50Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2007-05-18T21:15:50Z"}, "message": "mips.c (mips_offset_within_alignment_p): New.\n\n* config/mips/mips.c (mips_offset_within_alignment_p): New.\n(mips_symbolic_constant_p): Call it for TPREL and DTPREL symbols.\n\nFrom-SVN: r124833", "tree": {"sha": "fef9a3ec65178bef08656cfbe3309ae6f361e725", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fef9a3ec65178bef08656cfbe3309ae6f361e725"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b5fb3a36f12edc290b5a2c90db551d406df4edf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b5fb3a36f12edc290b5a2c90db551d406df4edf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b5fb3a36f12edc290b5a2c90db551d406df4edf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b5fb3a36f12edc290b5a2c90db551d406df4edf/comments", "author": null, "committer": null, "parents": [{"sha": "e7e0aaeca8ab3390677fa3a950504c93d75c2060", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7e0aaeca8ab3390677fa3a950504c93d75c2060", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7e0aaeca8ab3390677fa3a950504c93d75c2060"}], "stats": {"total": 41, "additions": 38, "deletions": 3}, "files": [{"sha": "630e06dffb6a0271532dfa38976d9d1f1b5021eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b5fb3a36f12edc290b5a2c90db551d406df4edf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b5fb3a36f12edc290b5a2c90db551d406df4edf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b5fb3a36f12edc290b5a2c90db551d406df4edf", "patch": "@@ -1,3 +1,8 @@\n+2007-05-18  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/mips/mips.c (mips_offset_within_alignment_p): New.\n+\t(mips_symbolic_constant_p): Call it for TPREL and DTPREL symbols.\n+\n 2007-05-18  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* longlong.h (__x86_64__): Add definitions for add_ssaaaa,"}, {"sha": "ff83eb7f4f9a1d4e5d30f347fb15d66a90f08e64", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b5fb3a36f12edc290b5a2c90db551d406df4edf/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b5fb3a36f12edc290b5a2c90db551d406df4edf/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=8b5fb3a36f12edc290b5a2c90db551d406df4edf", "patch": "@@ -412,6 +412,7 @@ static rtx mips_expand_builtin_bposge (enum mips_builtin_type, rtx);\n static void mips_encode_section_info (tree, rtx, int);\n static void mips_extra_live_on_entry (bitmap);\n static int mips_mode_rep_extended (enum machine_mode, enum machine_mode);\n+static bool mips_offset_within_alignment_p (rtx, HOST_WIDE_INT);\n \n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n@@ -1350,6 +1351,28 @@ mips_classify_symbol (rtx x)\n   return SYMBOL_GENERAL;\n }\n \n+/* Returns true if OFFSET is within the range [0, ALIGN), where ALIGN\n+   is the alignment (in bytes) of SYMBOL_REF X.  */\n+\n+static bool\n+mips_offset_within_alignment_p (rtx x, HOST_WIDE_INT offset)\n+{\n+  /* If for some reason we can't get the alignment for the\n+     symbol, initializing this to one means we won't accept any\n+     offset.  */\n+  HOST_WIDE_INT align = 1;\n+  tree t;\n+\n+  /* Get the alignment of the symbol we're referring to.  */\n+  t = SYMBOL_REF_DECL (x);\n+  if (t)\n+    align = DECL_ALIGN_UNIT (t);\n+\n+  if (offset >= 0 && offset < align)\n+    return true;\n+  return false;\n+}\n+\n /* Return true if X is a symbolic constant that can be calculated in\n    the same way as a bare symbol.  If it is, store the type of the\n    symbol in *SYMBOL_TYPE.  */\n@@ -1361,7 +1384,10 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n \n   split_const (x, &x, &offset);\n   if (UNSPEC_ADDRESS_P (x))\n-    *symbol_type = UNSPEC_ADDRESS_TYPE (x);\n+    {\n+      *symbol_type = UNSPEC_ADDRESS_TYPE (x);\n+      x = UNSPEC_ADDRESS (x);\n+    }\n   else if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n     {\n       *symbol_type = mips_classify_symbol (x);\n@@ -1416,14 +1442,18 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n \t to GOT overflow.  */\n       return SMALL_INT (offset);\n \n+    case SYMBOL_TPREL:\n+    case SYMBOL_DTPREL:\n+      /* There is no carry between the HI and LO REL relocations, so the\n+\t offset is only valid if we know it won't lead to such a carry.  */\n+      return mips_offset_within_alignment_p (x, INTVAL (offset));\n+\n     case SYMBOL_GOT_DISP:\n     case SYMBOL_GOTOFF_DISP:\n     case SYMBOL_GOTOFF_CALL:\n     case SYMBOL_GOTOFF_LOADGP:\n     case SYMBOL_TLSGD:\n     case SYMBOL_TLSLDM:\n-    case SYMBOL_DTPREL:\n-    case SYMBOL_TPREL:\n     case SYMBOL_GOTTPREL:\n     case SYMBOL_TLS:\n     case SYMBOL_HALF:"}]}