{"sha": "831c1763640089a3b6d044a3f59488e04ff94e99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMxYzE3NjM2NDAwODlhM2I2ZDA0NGEzZjU5NDg4ZTA0ZmY5NGU5OQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@one.net.au", "date": "2001-04-13T05:59:10Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2001-04-13T05:59:10Z"}, "message": "pa.c: Formatting and white space fixes throughout file.\n\n\t* pa.c: Formatting and white space fixes throughout file.\n\t(zdepi_cint_p): Describe zdepi insn.\n\nFrom-SVN: r41330", "tree": {"sha": "af46dd17cd0d943a5c4774572356b13dbaaba1af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af46dd17cd0d943a5c4774572356b13dbaaba1af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/831c1763640089a3b6d044a3f59488e04ff94e99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/831c1763640089a3b6d044a3f59488e04ff94e99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/831c1763640089a3b6d044a3f59488e04ff94e99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/831c1763640089a3b6d044a3f59488e04ff94e99/comments", "author": null, "committer": null, "parents": [{"sha": "fbdd633b879ed8afb77fbf098b53fbb6e884dbd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdd633b879ed8afb77fbf098b53fbb6e884dbd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbdd633b879ed8afb77fbf098b53fbb6e884dbd4"}], "stats": {"total": 94, "additions": 50, "deletions": 44}, "files": [{"sha": "218fda9c5e03a768456f0c7dd50124659f5af630", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/831c1763640089a3b6d044a3f59488e04ff94e99/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/831c1763640089a3b6d044a3f59488e04ff94e99/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=831c1763640089a3b6d044a3f59488e04ff94e99", "patch": "@@ -2,6 +2,8 @@\n \n \t* pa.c (hppa_init_pic_save): Set rtx_unchanging for\n \tPIC_OFFSET_TABLE_SAVE_RTX.\n+\t(zdepi_cint_p): Describe zdepi insn.\n+\tFormatting and white space fixes throughout file.\n \n \t* pa.c (uint32_operand): Don't use long constant >= 2^32.\n \t(emit_move_sequence): Use HOST_WIDE_INT constants.  Don't worry"}, {"sha": "e6c76f9d605367cc0c152837fedc7fcc6eb98bdf", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/831c1763640089a3b6d044a3f59488e04ff94e99/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/831c1763640089a3b6d044a3f59488e04ff94e99/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=831c1763640089a3b6d044a3f59488e04ff94e99", "patch": "@@ -584,7 +584,9 @@ arith5_operand (op, mode)\n   return register_operand (op, mode) || int5_operand (op, mode);\n }\n \n-/* True iff zdepi can be used to generate this CONST_INT.  */\n+/* True iff zdepi can be used to generate this CONST_INT.\n+   zdepi first sign extends a 5 bit signed number to a given field\n+   length, then places this field anywhere in a zero.  */\n int\n zdepi_cint_p (x)\n      unsigned HOST_WIDE_INT x;\n@@ -1818,7 +1820,7 @@ compute_zdepdi_operands (imm, op)\n       /* Find the width of the bitstring in IMM.  */\n       for (len = 5; len < HOST_BITS_PER_WIDE_INT; len++)\n \t{\n-\t  if ((imm & ((unsigned HOST_WIDE_INT)1 << len)) == 0)\n+\t  if ((imm & ((unsigned HOST_WIDE_INT) 1 << len)) == 0)\n \t    break;\n \t}\n \n@@ -1901,7 +1903,7 @@ output_move_double (operands)\n \t      return \"{stws|stw},ma %1,-8(%0)\\n\\tstw %R1,12(%0)\";\n \t    }\n \t  else\n-\t    abort();\n+\t    abort ();\n \t}\n       else if (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)\n \t{\n@@ -1921,7 +1923,7 @@ output_move_double (operands)\n \t      return \"{stws|stw},mb %1,-8(%0)\\n\\tstw %R1,4(%0)\";\n \t    }\n \t  else\n-\t    abort();\n+\t    abort ();\n \t}\n     }\n   if (optype1 == MEMOP)\n@@ -2336,7 +2338,7 @@ output_and (operands)\n \t  break;\n \n       if (ms0 != 32)\n-\tabort();\n+\tabort ();\n \n       if (ls1 == 32)\n \t{\n@@ -2437,7 +2439,7 @@ output_ior (operands)\n       break;\n \n   if (bs1 != 32 && ((unsigned HOST_WIDE_INT) 1 << bs1) <= mask)\n-    abort();\n+    abort ();\n \n   p = 31 - bs0;\n   len = bs1 - bs0;\n@@ -2678,8 +2680,8 @@ remove_useless_addtr_insns (insns, check_notes)\n \t\t  /* Reverse our condition.  */\n \t\t  tmp = PATTERN (insn);\n \t\t  PUT_CODE (XEXP (tmp, 1),\n-\t\t    reverse_condition_maybe_unordered (GET_CODE (XEXP (tmp,\n-\t\t      1))));\n+\t\t\t    (reverse_condition_maybe_unordered\n+\t\t\t     (GET_CODE (XEXP (tmp, 1)))));\n \t\t}\n \t    }\n \t}\n@@ -2689,8 +2691,8 @@ remove_useless_addtr_insns (insns, check_notes)\n \n }\n \f\n-/* You may have trouble believing this, but this is the 32 bit HP-PA stack\n-   layout.  Wow.\n+/* You may have trouble believing this, but this is the 32 bit HP-PA\n+   stack layout.  Wow.\n \n    Offset\t\tContents\n \n@@ -2914,7 +2916,7 @@ output_function_prologue (file, size)\n     {\n       unsigned int old_total = total_code_bytes;\n \n-      total_code_bytes += INSN_ADDRESSES (INSN_UID (get_last_insn()));\n+      total_code_bytes += INSN_ADDRESSES (INSN_UID (get_last_insn ()));\n       total_code_bytes += FUNCTION_BOUNDARY / BITS_PER_UNIT;\n \n       /* Be prepared to handle overflows.  */\n@@ -3935,7 +3937,7 @@ print_operand (file, x, code)\n     case 'R':\n       /* Print out the second register name of a register pair.\n \t I.e., R (6) => 7.  */\n-      fputs (reg_names[REGNO (x)+1], file);\n+      fputs (reg_names[REGNO (x) + 1], file);\n       return;\n     case 'r':\n       /* A register or zero. */\n@@ -4025,8 +4027,8 @@ print_operand (file, x, code)\n \t  abort ();\n \t}\n       return;\n-    /* For floating point comparisons. Note that the output predicates are the\n-       complement of the desired mode. */\n+    /* For floating point comparisons.  Note that the output\n+       predicates are the complement of the desired mode.  */\n     case 'Y':\n       switch (GET_CODE (x))\n \t{\n@@ -4122,42 +4124,42 @@ print_operand (file, x, code)\n \t  fprintf (file, \"%d\", ~INTVAL (x));\n \t  return;\n \t}\n-      abort();\n+      abort ();\n     case 'Q':\n       if (GET_CODE (x) == CONST_INT)\n \t{\n \t  fprintf (file, \"%d\", 64 - (INTVAL (x) & 63));\n \t  return;\n \t}\n-      abort();\n+      abort ();\n     case 'L':\n       if (GET_CODE (x) == CONST_INT)\n \t{\n \t  fprintf (file, \"%d\", 32 - (INTVAL (x) & 31));\n \t  return;\n \t}\n-      abort();\n+      abort ();\n     case 'O':\n       if (GET_CODE (x) == CONST_INT && exact_log2 (INTVAL (x)) >= 0)\n \t{\n \t  fprintf (file, \"%d\", exact_log2 (INTVAL (x)));\n \t  return;\n \t}\n-      abort();\n+      abort ();\n     case 'p':\n       if (GET_CODE (x) == CONST_INT)\n \t{\n \t  fprintf (file, \"%d\", 63 - (INTVAL (x) & 63));\n \t  return;\n \t}\n-      abort();\n+      abort ();\n     case 'P':\n       if (GET_CODE (x) == CONST_INT)\n \t{\n \t  fprintf (file, \"%d\", 31 - (INTVAL (x) & 31));\n \t  return;\n \t}\n-      abort();\n+      abort ();\n     case 'I':\n       if (GET_CODE (x) == CONST_INT)\n \tfputs (\"i\", file);\n@@ -4318,7 +4320,7 @@ output_global_address (file, x, round_constant)\n \t  output_addr_const (file, base);\n \t}\n       else if (GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n-\toffset = INTVAL (XEXP (XEXP (x, 0),1));\n+\toffset = INTVAL (XEXP (XEXP (x, 0), 1));\n       else abort ();\n \n       /* How bogus.  The compiler is apparently responsible for\n@@ -4351,7 +4353,7 @@ output_global_address (file, x, round_constant)\n       if (!read_only_operand (base, VOIDmode) && !flag_pic)\n \tfputs (\"-$global$\", file);\n       if (offset)\n-\tfprintf (file,\"%s%d\", sep, offset);\n+\tfprintf (file, \"%s%d\", sep, offset);\n     }\n   else\n     output_addr_const (file, x);\n@@ -4385,7 +4387,7 @@ output_deferred_plabels (file)\n \n enum millicodes { remI, remU, divI, divU, mulI, mulU, end1000 };\n static void import_milli\t\t\tPARAMS ((enum millicodes));\n-static char imported[(int)end1000];\n+static char imported[(int) end1000];\n static const char * const milli_names[] = {\"remI\", \"remU\", \"divI\", \"divU\", \"mulI\", \"mulU\"};\n static char import_string[] = \".IMPORT $$....,MILLICODE\";\n #define MILLI_START 10\n@@ -4396,11 +4398,11 @@ import_milli (code)\n {\n   char str[sizeof (import_string)];\n \n-  if (!imported[(int)code])\n+  if (!imported[(int) code])\n     {\n-      imported[(int)code] = 1;\n+      imported[(int) code] = 1;\n       strcpy (str, import_string);\n-      strncpy (str + MILLI_START, milli_names[(int)code], 4);\n+      strncpy (str + MILLI_START, milli_names[(int) code], 4);\n       output_asm_insn (str, 0);\n     }\n }\n@@ -5104,7 +5106,7 @@ output_cbranch (operands, nullify, length, negated, insn)\n \treturn \"ldw -16(%%r30),%%r1\";\n \t\n       default:\n-\tabort();\n+\tabort ();\n     }\n   return buf;\n }\n@@ -5251,7 +5253,7 @@ output_bb (operands, nullify, length, negated, insn, which)\n \tbreak;\n \n       default:\n-\tabort();\n+\tabort ();\n     }\n   return buf;\n }\n@@ -5399,7 +5401,7 @@ output_bvb (operands, nullify, length, negated, insn, which)\n \tbreak;\n \n       default:\n-\tabort();\n+\tabort ();\n     }\n   return buf;\n }\n@@ -5424,8 +5426,8 @@ output_dbra (operands, insn, which_alternative)\n \treturn \"ldo %1(%0),%0\";\n       else if (which_alternative == 1)\n \t{\n-\t  output_asm_insn (\"{fstws|fstw} %0,-16(%%r30)\",operands);\n-\t  output_asm_insn (\"ldw -16(%%r30),%4\",operands);\n+\t  output_asm_insn (\"{fstws|fstw} %0,-16(%%r30)\", operands);\n+\t  output_asm_insn (\"ldw -16(%%r30),%4\", operands);\n \t  output_asm_insn (\"ldo %1(%4),%4\\n\\tstw %4,-16(%%r30)\", operands);\n \t  return \"{fldws|fldw} -16(%%r30),%0\";\n \t}\n@@ -5481,15 +5483,16 @@ output_dbra (operands, insn, which_alternative)\n \t    return \"addi,%N2 %1,%0,%0\\n\\tb %3\";\n \t}\n       else\n-\tabort();\n+\tabort ();\n     }\n   /* Deal with gross reload from FP register case.  */\n   else if (which_alternative == 1)\n     {\n       /* Move loop counter from FP register to MEM then into a GR,\n \t increment the GR, store the GR into MEM, and finally reload\n \t the FP register from MEM from within the branch's delay slot.  */\n-      output_asm_insn (\"{fstws|fstw} %0,-16(%%r30)\\n\\tldw -16(%%r30),%4\",operands);\n+      output_asm_insn (\"{fstws|fstw} %0,-16(%%r30)\\n\\tldw -16(%%r30),%4\",\n+\t\t       operands);\n       output_asm_insn (\"ldo %1(%4),%4\\n\\tstw %4,-16(%%r30)\", operands);\n       if (get_attr_length (insn) == 24)\n \treturn \"{comb|cmpb},%S2 %%r0,%4,%3\\n\\t{fldws|fldw} -16(%%r30),%0\";\n@@ -5530,7 +5533,7 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n \treturn \"copy %1,%0\";\n       else if (which_alternative == 1)\n \t{\n-\t  output_asm_insn (\"stw %1,-16(%%r30)\",operands);\n+\t  output_asm_insn (\"stw %1,-16(%%r30)\", operands);\n \t  return \"{fldws|fldw} -16(%%r30),%0\";\n \t}\n       else if (which_alternative == 2)\n@@ -5588,15 +5591,15 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n \t    return \"or,%N2 %1,%%r0,%0\\n\\tb %3\";\n \t}\n       else\n-\tabort();\n+\tabort ();\n     }\n   /* Deal with gross reload from FP register case.  */\n   else if (which_alternative == 1)\n     {\n       /* Move loop counter from FP register to MEM then into a GR,\n \t increment the GR, store the GR into MEM, and finally reload\n \t the FP register from MEM from within the branch's delay slot.  */\n-      output_asm_insn (\"stw %1,-16(%%r30)\",operands);\n+      output_asm_insn (\"stw %1,-16(%%r30)\", operands);\n       if (get_attr_length (insn) == 12)\n \treturn \"{comb|cmpb},%S2 %%r0,%1,%3\\n\\t{fldws|fldw} -16(%%r30),%0\";\n       else\n@@ -6057,7 +6060,7 @@ hppa_encode_label (sym)\n   *p++ = '@';\n   strcpy (p, str);\n \n-  XSTR (sym,0) = ggc_alloc_string (newstr, len);\n+  XSTR (sym, 0) = ggc_alloc_string (newstr, len);\n }\n \n int\n@@ -6774,8 +6777,10 @@ pa_combine_instructions (insns)\n \t\t\t done with this pass.  */\n \t\t      if (pa_can_combine_p (new, anchor, floater, 1,\n \t\t\t\t\t    SET_DEST (PATTERN (floater)),\n-\t\t\t\t\t    XEXP (SET_SRC (PATTERN(floater)),0),\n-\t\t\t\t\t    XEXP(SET_SRC(PATTERN(floater)),1)))\n+\t\t\t\t\t    XEXP (SET_SRC (PATTERN (floater)),\n+\t\t\t\t\t\t  0),\n+\t\t\t\t\t    XEXP (SET_SRC (PATTERN (floater)),\n+\t\t\t\t\t\t  1)))\n \t\t\tbreak;\n \t\t    }\n \t\t}\n@@ -6998,15 +7003,15 @@ function_arg (cum, mode, type, named, incoming)\n \t      rtx loc[8];\n \t      int i, offset = 0, ub;\n               ub = FUNCTION_ARG_SIZE (mode, type); \n-\t      ub = MIN(ub,\n-                       MAX(0, max_arg_words - cum->words - (cum->words & 1)));\n+\t      ub = MIN (ub,\n+\t\t\tMAX (0, max_arg_words - cum->words - (cum->words & 1)));\n \t      gpr_reg_base -= (cum->words & 1);\n \t      for (i = 0; i < ub; i++)\n \t\t{\n \t\t  loc[i] = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t      gen_rtx_REG (DImode,\n \t\t\t\t\t\t\t   gpr_reg_base),\n-\t\t\t\t\t      GEN_INT(offset));\n+\t\t\t\t\t      GEN_INT (offset));\n \t\t  gpr_reg_base -= 1;\n \t\t  offset += 8;\n \t\t}\n@@ -7015,7 +7020,7 @@ function_arg (cum, mode, type, named, incoming)\n \t      else if (ub == 1)\n \t\treturn XEXP (loc[0], 0);\n \t      else\n-\t\treturn gen_rtx_PARALLEL(mode, gen_rtvec_v(ub, loc));\n+\t\treturn gen_rtx_PARALLEL (mode, gen_rtvec_v (ub, loc));\n \t    }\n \t}\n     }\n@@ -7131,7 +7136,6 @@ function_arg_partial_nregs (cum, mode, type, named)\n   else\n     /* Arg is split. */\n     return max_arg_words - cum->words - offset;\n-\n }\n \n "}]}