{"sha": "98a1fb705ead9258642f2dec0431f11508a9b13c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThhMWZiNzA1ZWFkOTI1ODY0MmYyZGVjMDQzMWYxMTUwOGE5YjEzYw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-01-08T15:02:04Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-01-08T15:02:04Z"}, "message": "c++: Fix access checking of scoped non-static member [PR98515]\n\nIn the first testcase below, we incorrectly reject the use of the\nprotected non-static member A::var0 from C<int>::g() because\ncheck_accessibility_of_qualified_id, at template parse time, determines\nthat the access doesn't go through 'this'.  (This happens because the\ndependent base B<T> of C<T> doesn't have a binfo object, so it appears\nto DERIVED_FROM_P that A is not an indirect base of C<T>.)  From there\nwe create the corresponding deferred access check, which we then\nperform at instantiation time and which (expectedly) fails.\n\nThe problem ultimately seems to be that we can't in general determine\nwhether a use of a scoped non-static member goes through 'this' until\ninstantiation time, as the second testcase below illustrates.  So this\npatch makes check_accessibility_of_qualified_id punt in such situations\nto avoid creating a bogus deferred access check.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/98515\n\t* semantics.c (check_accessibility_of_qualified_id): Punt if\n\twe're checking access of a scoped non-static member inside a\n\tclass template.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/98515\n\t* g++.dg/template/access32.C: New test.\n\t* g++.dg/template/access33.C: New test.", "tree": {"sha": "84788f3c172bcaa2186c829f65a5efa4e8602346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84788f3c172bcaa2186c829f65a5efa4e8602346"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98a1fb705ead9258642f2dec0431f11508a9b13c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98a1fb705ead9258642f2dec0431f11508a9b13c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98a1fb705ead9258642f2dec0431f11508a9b13c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98a1fb705ead9258642f2dec0431f11508a9b13c/comments", "author": null, "committer": null, "parents": [{"sha": "76be18f442948d1a4bc49a7d670b07097f9e5983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76be18f442948d1a4bc49a7d670b07097f9e5983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76be18f442948d1a4bc49a7d670b07097f9e5983"}], "stats": {"total": 37, "additions": 32, "deletions": 5}, "files": [{"sha": "c6b4c70dc0f0c3b719ec3fad1d9261a1c6dc1b41", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98a1fb705ead9258642f2dec0431f11508a9b13c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98a1fb705ead9258642f2dec0431f11508a9b13c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=98a1fb705ead9258642f2dec0431f11508a9b13c", "patch": "@@ -2107,14 +2107,24 @@ check_accessibility_of_qualified_id (tree decl,\n       /* If the reference is to a non-static member of the\n \t current class, treat it as if it were referenced through\n \t `this'.  */\n-      tree ct;\n       if (DECL_NONSTATIC_MEMBER_P (decl)\n-\t  && current_class_ptr\n-\t  && DERIVED_FROM_P (scope, ct = current_nonlambda_class_type ()))\n-\tqualifying_type = ct;\n+\t  && current_class_ptr)\n+\tif (tree current = current_nonlambda_class_type ())\n+\t  {\n+\t    if (dependent_type_p (current))\n+\t    /* In general we can't know whether this access goes through\n+\t       `this' until instantiation time.  Punt now, or else we might\n+\t       create a deferred access check that's not relative to `this'\n+\t       when it ought to be.  We'll check this access again after\n+\t       substitution, e.g. from tsubst_qualified_id.  */\n+\t      return true;\n+\n+\t    if (DERIVED_FROM_P (scope, current))\n+\t      qualifying_type = current;\n+\t  }\n       /* Otherwise, use the type indicated by the\n \t nested-name-specifier.  */\n-      else\n+      if (!qualifying_type)\n \tqualifying_type = nested_name_specifier;\n     }\n   else"}, {"sha": "08faa9f0f974381c5551a1d07b0fbb4b9e03bd62", "filename": "gcc/testsuite/g++.dg/template/access32.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98a1fb705ead9258642f2dec0431f11508a9b13c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess32.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98a1fb705ead9258642f2dec0431f11508a9b13c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess32.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess32.C?ref=98a1fb705ead9258642f2dec0431f11508a9b13c", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/98515\n+// { dg-do compile }\n+\n+struct A { protected: int var0; };\n+template <class> struct B : public A { };\n+template <class T> struct C : public B<T> { void g(); };\n+template <class T> void C<T>::g() { A::var0++; }\n+template class C<int>;"}, {"sha": "9fb9b9a12367fe01d460592b4d9a5ff402db77f9", "filename": "gcc/testsuite/g++.dg/template/access33.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98a1fb705ead9258642f2dec0431f11508a9b13c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess33.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98a1fb705ead9258642f2dec0431f11508a9b13c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess33.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess33.C?ref=98a1fb705ead9258642f2dec0431f11508a9b13c", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/98515\n+// { dg-do compile }\n+\n+struct A { protected: int var0; };\n+template <class> struct B : public A { };\n+template <class T> struct C : public B<T> { void g(); };\n+template <class T> void C<T>::g() { A::var0++; } // { dg-error \"protected|invalid\" }\n+template <> struct B<char> { };\n+template class C<char>;"}]}