{"sha": "7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM1MWJjYWE2NDdmZTJiN2M2ZWY3MmVjYTA3OGI3OWY1ZTVmZmM3ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-07-03T13:18:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-07-03T13:18:28Z"}, "message": "loop-24.c: Update dump file matching; enable -O2.\n\n\t* gcc.dg/tree-ssa/loop-24.c: Update dump file matching; enable -O2.\n\t* gcc.dg/tree-ssa/loop-25.c: Likewise.\n\t* gcc.dg/tree-ssa/loop-26.c: Likewise.\n\t* gcc.dg/tree-ssa/pr32044.c: Likewise.\n\t* gcc.dg/tree-ssa/loop-29.c: Likewise.\n\t* gcc.dg/tree-ssa/loop-10.c: Likewise.\n\t* gnat.dg/loop_optimization6.adb: Enable -O2.\n\n\t* ipa-pure-const.c (analyze): Update loop optimizer init.\n\t* tree-ssa-loop-iv-canon.c (empty_loop_p, remove_empty_loop,\n\ttry_remove_empty_loop, remove_empty_loops): Remove.\n\t* tree-ssa-loop.c (tree_ssa_empty_loop, pass_empty_loop): Remove.\n\t* tree-ssa-dce.c (find_obviously_necessary_stmts): Use finiteness info\n\tto mark regular loops as neccesary.\n\t(degenerate_phi_p): New function.\n\t(propagate_necessity, remove_dead_phis): Use it.\n\t(forward_edge_to_pdom): Likewise.\n\t(eliminate_unnecessary_stmts): Take care to remove uses of results of\n\tvirtual PHI nodes that became unreachable.\n\t(perform_tree_ssa_dce): Initialize/deinitialize loop optimizer.\n\t* tree-flow.h (remove_empty_loops): Remove.\n\t* passes.c (init_optimization_passes): Remove.\n\nFrom-SVN: r149206", "tree": {"sha": "5ae15df89724e96bf58d1a0b6e82cf43aa9b2617", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ae15df89724e96bf58d1a0b6e82cf43aa9b2617"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/comments", "author": null, "committer": null, "parents": [{"sha": "5071eab79a946632010c75349494c745f35ae1e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5071eab79a946632010c75349494c745f35ae1e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5071eab79a946632010c75349494c745f35ae1e6"}], "stats": {"total": 413, "additions": 152, "deletions": 261}, "files": [{"sha": "c2655c81146b1510c9f13796e23108631246549a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -1,3 +1,20 @@\n+2009-07-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-pure-const.c (analyze): Update loop optimizer init.\n+\t* tree-ssa-loop-iv-canon.c (empty_loop_p, remove_empty_loop,\n+\ttry_remove_empty_loop, remove_empty_loops): Remove.\n+\t* tree-ssa-loop.c (tree_ssa_empty_loop, pass_empty_loop): Remove.\n+\t* tree-ssa-dce.c (find_obviously_necessary_stmts): Use finiteness info\n+\tto mark regular loops as neccesary.\n+\t(degenerate_phi_p): New function.\n+\t(propagate_necessity, remove_dead_phis): Use it.\n+\t(forward_edge_to_pdom): Likewise.\n+\t(eliminate_unnecessary_stmts): Take care to remove uses of results of\n+\tvirtual PHI nodes that became unreachable.\n+\t(perform_tree_ssa_dce): Initialize/deinitialize loop optimizer.\n+\t* tree-flow.h (remove_empty_loops): Remove.\n+\t* passes.c (init_optimization_passes): Remove.\n+\n 2009-07-03  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (fix_trunc<mode>_fisttp_i387_1): Use"}, {"sha": "4e62eb187a42a2fa87e2623939b242ade7d7c5ec", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -535,7 +535,11 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \t effect.  */\n       if (mark_dfs_back_edges ())\n         {\n-\t  loop_optimizer_init (LOOPS_HAVE_PREHEADERS);\n+\t  /* Preheaders are needed for SCEV to work.\n+\t     Simple lateches and recorded exits improve chances that loop will\n+\t     proved to be finite in testcases such as in loop-15.c and loop-24.c  */\n+\t  loop_optimizer_init (LOOPS_NORMAL\n+\t\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    flow_loops_dump (dump_file, NULL, 0);\n \t  if (mark_irreducible_loops ())"}, {"sha": "ca69beefd322c4f9dbca668ee3edc15d3fc17084", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -651,7 +651,6 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_lim);\n \t  NEXT_PASS (pass_tree_unswitch);\n \t  NEXT_PASS (pass_scev_cprop);\n-\t  NEXT_PASS (pass_empty_loop);\n \t  NEXT_PASS (pass_record_bounds);\n \t  NEXT_PASS (pass_check_data_deps);\n \t  NEXT_PASS (pass_loop_distribution);"}, {"sha": "42a5374dd4805d25b66a6046525e0435a16aea67", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -1,3 +1,13 @@\n+2009-07-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-24.c: Update dump file matching; enable -O2.\n+\t* gcc.dg/tree-ssa/loop-25.c: Likewise.\n+\t* gcc.dg/tree-ssa/loop-26.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr32044.c: Likewise.\n+\t* gcc.dg/tree-ssa/loop-29.c: Likewise.\n+\t* gcc.dg/tree-ssa/loop-10.c: Likewise.\n+\t* gnat.dg/loop_optimization6.adb: Enable -O2.\n+\n 2009-07-02  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/warn/null4.C: Extend."}, {"sha": "c8d118e37715782ab525da4abc22c4aebdefba29", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-10.c?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n /* { dg-require-effective-target int32plus } */\n \n int bar (void);"}, {"sha": "5632b067990b1407457f906149996163570b25a9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-24.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-24.c?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fstrict-overflow -fdump-tree-empty\" } */\n+/* { dg-options \"-O2 -fstrict-overflow -fdump-tree-optimized\" } */\n \n void foo(int a, int b)\n { for(;a!=b;a+=4); }\n@@ -13,5 +13,5 @@ void foo3(int*a, int* b)\n void foo4(int*a, int*b)\n { for(;a!=b;a++); }\n \n-/* { dg-final { scan-tree-dump-times \"Removing empty loop\" 4 \"empty\" } } */\n-/* { dg-final { cleanup-tree-dump \"empty\" } } */\n+/* { dg-final { scan-tree-dump-not \"if\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "479ed81d97002d3a5e7bcfb137492c05e214e487", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-25.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-25.c?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-profile\" } */\n+/* { dg-options \"-O1 -fdump-tree-profile\" } */\n \n int foo(void);\n void bla(void);"}, {"sha": "f8bc8e010ae881c7fcf3b1ed24065895100e1c69", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-26.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-26.c?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -2,7 +2,7 @@\n    determine number of iterations of the following loops unconditionally.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O -fstrict-overflow -fdump-tree-empty\" } */\n+/* { dg-options \"-O2 -fstrict-overflow -fdump-tree-optimized-blocks\" } */\n \n unsigned foo(unsigned int n)\n {\n@@ -25,5 +25,5 @@ int foo0(int i0, int i1)\n   return j;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Removing empty loop\" 2 \"empty\" } } */\n-/* { dg-final { cleanup-tree-dump \"empty\" } } */\n+/* { dg-final { scan-tree-dump-times \"if\" 2 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c900dbf9bfbf0f73cb1b6fdbe9b64fdaa8e363c2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-29.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-29.c?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -1,7 +1,7 @@\n /* PR 31885 */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-empty\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n \n struct s {\n     int *blah;\n@@ -17,5 +17,5 @@ foo (struct s *p)\n     p++;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Removing empty loop\" 1 \"empty\" } } */\n-/* { dg-final { cleanup-tree-dump \"empty\" } } */\n+/* { dg-final { scan-tree-dump-not \"if\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "58a62662b4f76e9e440d508fbd1c9210a7177c45", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr32044.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-empty -fdump-tree-optimized\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n \n int foo (int n)\n {\n@@ -43,13 +43,12 @@ int baz (int n)\n   return i;\n }\n \n-/* The loops computing division/modulo by 64 should be eliminated.  */\n-/* { dg-final { scan-tree-dump-times \"Removing empty loop\" 2 \"empty\" } } */\n+/* The loops computing division/modulo by 64 should be eliminated */\n+/* { dg-final { scan-tree-dump-times \"if\" 6 \"optimized\" } } */\n \n /* There should be no division/modulo in the final dump (division and modulo\n    by 64 are done using bit operations).  */\n /* { dg-final { scan-tree-dump-times \"/\" 0 \"optimized\" } } */\n /* { dg-final { scan-tree-dump-times \"%\" 0 \"optimized\" } } */\n \n-/* { dg-final { cleanup-tree-dump \"empty\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "7a0f6d38803fed3967cb7c812f4ee478cff72fac", "filename": "gcc/testsuite/gnat.dg/loop_optimization6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization6.adb?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -1,5 +1,5 @@\n -- { dg-do compile }\n--- { dg-options \"-O -gnatp -fdump-tree-optimized\" }\n+-- { dg-options \"-O2 -gnatp -fdump-tree-optimized\" }\n \n package body Loop_Optimization6 is\n   procedure Foo is"}, {"sha": "8d9b393e56ee0a40524971e626649772a57bf258", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -745,7 +745,6 @@ unsigned int tree_ssa_unswitch_loops (void);\n unsigned int canonicalize_induction_variables (void);\n unsigned int tree_unroll_loops_completely (bool, bool);\n unsigned int tree_ssa_prefetch_arrays (void);\n-unsigned int remove_empty_loops (void);\n void tree_ssa_iv_optimize (void);\n unsigned tree_predictive_commoning (void);\n tree canonicalize_loop_ivs (struct loop *, htab_t, tree *);"}, {"sha": "fdfdda5e95f761bc80dffae7909b9aa2555668e0", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 105, "deletions": 27, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -434,17 +434,42 @@ find_obviously_necessary_stmts (struct edge_list *el)\n \t}\n     }\n \n+  /* Pure and const functions are finite and thus have no infinite loops in\n+     them.  */\n+  if ((TREE_READONLY (current_function_decl)\n+       || DECL_PURE_P (current_function_decl))\n+      && !DECL_LOOPING_CONST_OR_PURE_P (current_function_decl))\n+    return;\n+\n+  /* Prevent the empty possibly infinite loops from being removed.  */\n   if (el)\n     {\n-      /* Prevent the loops from being removed.  We must keep the infinite loops,\n-\t and we currently do not have a means to recognize the finite ones.  */\n-      FOR_EACH_BB (bb)\n-\t{\n-\t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    if (e->flags & EDGE_DFS_BACK)\n-\t      mark_control_dependent_edges_necessary (e->dest, el);\n-\t}\n+      loop_iterator li;\n+      struct loop *loop;\n+      scev_initialize ();\n+      if (mark_irreducible_loops ())\n+\tFOR_EACH_BB (bb)\n+\t  {\n+\t    edge_iterator ei;\n+\t    FOR_EACH_EDGE (e, ei, bb->succs)\n+\t      if ((e->flags & EDGE_DFS_BACK)\n+\t\t  && (e->flags & EDGE_IRREDUCIBLE_LOOP))\n+\t\t{\n+\t          if (dump_file)\n+\t            fprintf (dump_file, \"Marking back edge of irreducible loop %i->%i\\n\",\n+\t\t    \t     e->src->index, e->dest->index);\n+\t\t  mark_control_dependent_edges_necessary (e->dest, el);\n+\t\t}\n+\t  }\n+\n+      FOR_EACH_LOOP (li, loop, 0)\n+\tif (!finite_loop_p (loop))\n+\t  {\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"can not prove finiteness of loop %i\\n\", loop->num);\n+\t    mark_control_dependent_edges_necessary (loop->latch, el);\n+\t  }\n+      scev_finalize ();\n     }\n }\n \n@@ -570,6 +595,19 @@ mark_all_reaching_defs_necessary (gimple stmt)\n \t\t      mark_all_reaching_defs_necessary_1, NULL, &visited);\n }\n \n+/* Return true for PHI nodes with one or identical arguments\n+   can be removed.  */\n+static bool\n+degenerate_phi_p (gimple phi)\n+{\n+  unsigned int i;\n+  tree op = gimple_phi_arg_def (phi, 0);\n+  for (i = 1; i < gimple_phi_num_args (phi); i++)\n+    if (gimple_phi_arg_def (phi, i) != op)\n+      return false;\n+  return true;\n+}\n+\n /* Propagate necessity using the operands of necessary statements.\n    Process the uses on each statement in the worklist, and add all\n    feeding statements which contribute to the calculation of this\n@@ -632,7 +670,7 @@ propagate_necessity (struct edge_list *el)\n \t\tmark_operand_necessary (arg);\n \t    }\n \n-\t  if (aggressive)\n+\t  if (aggressive && !degenerate_phi_p (stmt))\n \t    {\n \t      for (k = 0; k < gimple_phi_num_args (stmt); k++)\n \t\t{\n@@ -822,23 +860,13 @@ remove_dead_phis (basic_block bb)\n          very simple dead PHI removal here.  */\n       if (!is_gimple_reg (gimple_phi_result (phi)))\n \t{\n-\t  unsigned i;\n-\t  tree vuse;\n-\n \t  /* Virtual PHI nodes with one or identical arguments\n \t     can be removed.  */\n-\t  vuse = gimple_phi_arg_def (phi, 0);\n-\t  for (i = 1; i < gimple_phi_num_args (phi); ++i)\n-\t    {\n-\t      if (gimple_phi_arg_def (phi, i) != vuse)\n-\t\t{\n-\t\t  vuse = NULL_TREE;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (vuse != NULL_TREE)\n+\t  if (degenerate_phi_p (phi))\n \t    {\n \t      tree vdef = gimple_phi_result (phi);\n+\t      tree vuse = gimple_phi_arg_def (phi, 0);\n+\n \t      use_operand_p use_p;\n \t      imm_use_iterator iter;\n \t      gimple use_stmt;\n@@ -899,7 +927,7 @@ static edge\n forward_edge_to_pdom (edge e, basic_block post_dom_bb)\n {\n   gimple_stmt_iterator gsi;\n-  edge e2;\n+  edge e2 = NULL;\n   edge_iterator ei;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -924,6 +952,7 @@ forward_edge_to_pdom (edge e, basic_block post_dom_bb)\n       for (gsi = gsi_start_phis (post_dom_bb); !gsi_end_p (gsi);)\n \t{\n \t  gimple phi = gsi_stmt (gsi);\n+\t  tree op;\n \n \t  /* Dead PHI do not imply control dependency.  */\n           if (!gimple_plf (phi, STMT_NECESSARY)\n@@ -947,8 +976,12 @@ forward_edge_to_pdom (edge e, basic_block post_dom_bb)\n \t      remove_phi_node (&gsi, true);\n \t      continue;\n \t    }\n-          gcc_assert (e2);\n-\t  add_phi_arg (phi, gimple_phi_arg_def (phi, e2->dest_idx), e);\n+\t  if (!e2)\n+\t    op = gimple_phi_arg_def (phi, e->dest_idx == 0 ? 1 : 0);\n+\t  else\n+\t    op = gimple_phi_arg_def (phi, e2->dest_idx);\n+\t  add_phi_arg (phi, op, e);\n+\t  gcc_assert (e2 || degenerate_phi_p (phi));\n \t  gsi_next (&gsi);\n \t}\n     }\n@@ -1094,7 +1127,42 @@ eliminate_unnecessary_stmts (void)\n \t    }\n \t}\n     }\n-\n+  /* Since we don't track liveness of virtual PHI nodes, it is possible that we\n+     rendered some PHI nodes unreachable while they are still in use.\n+     Mark them for renaming.  */\n+  if (cfg_altered)\n+    {\n+      basic_block next_bb;\n+      find_unreachable_blocks ();\n+      for (bb = ENTRY_BLOCK_PTR->next_bb; bb != EXIT_BLOCK_PTR; bb = next_bb)\n+\t{\n+\t  next_bb = bb->next_bb;\n+\t  if (!(bb->flags & BB_REACHABLE))\n+\t    {\n+\t      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t\tif (!is_gimple_reg (gimple_phi_result (gsi_stmt (gsi))))\n+\t\t  {\n+\t\t    bool found = false;\n+\t\t    imm_use_iterator iter;\n+\n+\t\t    FOR_EACH_IMM_USE_STMT (stmt, iter, gimple_phi_result (gsi_stmt (gsi)))\n+\t\t      {\n+\t\t\tif (!(gimple_bb (stmt)->flags & BB_REACHABLE))\n+\t\t\t  continue;\n+\t\t\tif (gimple_code (stmt) == GIMPLE_PHI\n+\t\t\t    || gimple_plf (stmt, STMT_NECESSARY))\n+\t\t\t  {\n+\t\t\t    found = true;\n+\t\t\t    BREAK_FROM_IMM_USE_STMT (iter);\n+\t\t\t  }\n+\t\t      }\n+\t\t    if (found)\n+\t\t      mark_virtual_phi_result_for_renaming (gsi_stmt (gsi));\n+\t\t  }\n+\t      delete_basic_block (bb);\n+\t    }\n+\t}\n+    }\n   FOR_EACH_BB (bb)\n     {\n       /* Remove dead PHI nodes.  */\n@@ -1197,6 +1265,13 @@ perform_tree_ssa_dce (bool aggressive)\n   struct edge_list *el = NULL;\n   bool something_changed = 0;\n \n+  /* Preheaders are needed for SCEV to work.\n+     Simple lateches and recorded exits improve chances that loop will\n+     proved to be finite in testcases such as in loop-15.c and loop-24.c  */\n+  if (aggressive)\n+    loop_optimizer_init (LOOPS_NORMAL\n+\t\t\t | LOOPS_HAVE_RECORDED_EXITS);\n+\n   tree_dce_init (aggressive);\n \n   if (aggressive)\n@@ -1216,6 +1291,9 @@ perform_tree_ssa_dce (bool aggressive)\n \n   find_obviously_necessary_stmts (el);\n \n+  if (aggressive)\n+    loop_optimizer_finalize ();\n+\n   longest_chain = 0;\n   total_chain = 0;\n   chain_ovfl = false;"}, {"sha": "a04466a402755c9471174fe27e5b7dfef12ae3fb", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -558,187 +558,3 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \n   return 0;\n }\n-\n-/* Checks whether LOOP is empty.  */\n-\n-static bool\n-empty_loop_p (struct loop *loop)\n-{\n-  edge exit;\n-  basic_block *body;\n-  gimple_stmt_iterator gsi;\n-  unsigned i;\n-\n-  /* If the loop has multiple exits, it is too hard for us to handle.\n-     Similarly, if the exit is not dominating, we cannot determine\n-     whether the loop is not infinite.  */\n-  exit = single_dom_exit (loop);\n-  if (!exit)\n-    return false;\n-\n-  /* The loop must be finite.  */\n-  if (!finite_loop_p (loop))\n-    return false;\n-\n-  /* Values of all loop exit phi nodes must be invariants.  */\n-  for (gsi = gsi_start(phi_nodes (exit->dest)); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple phi = gsi_stmt (gsi);\n-      tree def;\n-\n-      if (!is_gimple_reg (PHI_RESULT (phi)))\n-\tcontinue;\n-\n-      def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n-\n-      if (!expr_invariant_in_loop_p (loop, def))\n-\treturn false;\n-    }\n-\n-  /* And there should be no memory modifying or from other reasons\n-     unremovable statements.  */\n-  body = get_loop_body (loop);\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      /* Irreducible region might be infinite.  */\n-      if (body[i]->flags & BB_IRREDUCIBLE_LOOP)\n-\t{\n-\t  free (body);\n-\t  return false;\n-\t}\n-\t\n-      for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\n-\t  if (gimple_vdef (stmt)\n-\t      || gimple_has_volatile_ops (stmt))\n-\t    {\n-\t      free (body);\n-\t      return false;\n-\t    }\n-\n-\t  /* Also, asm statements and calls may have side effects and we\n-\t     cannot change the number of times they are executed.  */\n-\t  switch (gimple_code (stmt))\n-\t    {\n-\t    case GIMPLE_CALL:\n-\t      if (gimple_has_side_effects (stmt))\n-\t\t{\n-\t\t  free (body);\n-\t\t  return false;\n-\t\t}\n-\t      break;\n-\n-\t    case GIMPLE_ASM:\n-\t      /* We cannot remove volatile assembler.  */\n-\t      if (gimple_asm_volatile_p (stmt))\n-\t\t{\n-\t\t  free (body);\n-\t\t  return false;\n-\t\t}\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-      }\n-  free (body);\n-\n-  return true;\n-}\n-\n-/* Remove LOOP by making it exit in the first iteration.  */\n-\n-static void\n-remove_empty_loop (struct loop *loop)\n-{\n-  edge exit = single_dom_exit (loop), non_exit;\n-  gimple cond_stmt = last_stmt (exit->src);\n-  basic_block *body;\n-  unsigned n_before, freq_in, freq_h;\n-  gcov_type exit_count = exit->count;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"Removing empty loop %d\\n\", loop->num);\n-\n-  non_exit = EDGE_SUCC (exit->src, 0);\n-  if (non_exit == exit)\n-    non_exit = EDGE_SUCC (exit->src, 1);\n-\n-  if (exit->flags & EDGE_TRUE_VALUE)\n-    gimple_cond_make_true (cond_stmt);\n-  else\n-    gimple_cond_make_false (cond_stmt);\n-  update_stmt (cond_stmt);\n-\n-  /* Let us set the probabilities of the edges coming from the exit block.  */\n-  exit->probability = REG_BR_PROB_BASE;\n-  non_exit->probability = 0;\n-  non_exit->count = 0;\n-\n-  /* Update frequencies and counts.  Everything before\n-     the exit needs to be scaled FREQ_IN/FREQ_H times,\n-     where FREQ_IN is the frequency of the entry edge\n-     and FREQ_H is the frequency of the loop header.\n-     Everything after the exit has zero frequency.  */\n-  freq_h = loop->header->frequency;\n-  freq_in = EDGE_FREQUENCY (loop_preheader_edge (loop));\n-  if (freq_h != 0)\n-    {\n-      body = get_loop_body_in_dom_order (loop);\n-      for (n_before = 1; n_before <= loop->num_nodes; n_before++)\n-\tif (body[n_before - 1] == exit->src)\n-\t  break;\n-      scale_bbs_frequencies_int (body, n_before, freq_in, freq_h);\n-      scale_bbs_frequencies_int (body + n_before, loop->num_nodes - n_before,\n-\t\t\t\t 0, 1);\n-      free (body);\n-    }\n-\n-  /* Number of executions of exit is not changed, thus we need to restore\n-     the original value.  */\n-  exit->count = exit_count;\n-}\n-\n-/* Removes LOOP if it is empty.  Returns true if LOOP is removed.  CHANGED\n-   is set to true if LOOP or any of its subloops is removed.  */\n-\n-static bool\n-try_remove_empty_loop (struct loop *loop, bool *changed)\n-{\n-  bool nonempty_subloop = false;\n-  struct loop *sub;\n-\n-  /* First, all subloops must be removed.  */\n-  for (sub = loop->inner; sub; sub = sub->next)\n-    nonempty_subloop |= !try_remove_empty_loop (sub, changed);\n-\n-  if (nonempty_subloop || !empty_loop_p (loop))\n-    return false;\n-\n-  remove_empty_loop (loop);\n-  *changed = true;\n-  return true;\n-}\n-\n-/* Remove the empty loops.  */\n-\n-unsigned int\n-remove_empty_loops (void)\n-{\n-  bool changed = false;\n-  struct loop *loop;\n-\n-  for (loop = current_loops->tree_root->inner; loop; loop = loop->next)\n-    try_remove_empty_loop (loop, &changed);\n-\n-  if (changed)\n-    {\n-      scev_reset ();\n-      return TODO_cleanup_cfg;\n-    }\n-  return 0;\n-}\n-"}, {"sha": "4dcdc02d2d6557b9b10e693cf3ef77bb5e1922d3", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=7351bcaa647fe2b7c6ef72eca078b79f5e5ffc7e", "patch": "@@ -433,37 +433,6 @@ struct gimple_opt_pass pass_scev_cprop =\n  }\n };\n \n-/* Remove empty loops.  */\n-\n-static unsigned int\n-tree_ssa_empty_loop (void)\n-{\n-  if (number_of_loops () <= 1)\n-    return 0;\n-\n-  return remove_empty_loops ();\n-}\n-\n-struct gimple_opt_pass pass_empty_loop =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"empty\",\t\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  tree_ssa_empty_loop,\t\t       \t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_COMPLETE_UNROLL,\t  \t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_verify_loops \n-    | TODO_ggc_collect\t\t\t/* todo_flags_finish */\n- }\n-};\n-\n /* Record bounds on numbers of iterations of loops.  */\n \n static unsigned int"}]}