{"sha": "bef32d4a28595e933f24fef378cf052a30b674a7", "node_id": "C_kwDOANBUbNoAKGJlZjMyZDRhMjg1OTVlOTMzZjI0ZmVmMzc4Y2YwNTJhMzBiNjc0YTc", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-11-02T19:45:22Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-11-17T22:34:12Z"}, "message": "libcpp: capture and underline ranges in -Wbidi-chars= [PR103026]\n\nThis patch converts the bidi::vec to use a struct so that we can\ncapture location_t values for the bidirectional control characters.\n\nBefore:\n\n  Wbidi-chars-1.c: In function \u2018main\u2019:\n  Wbidi-chars-1.c:6:43: warning: unpaired UTF-8 bidirectional control character detected [-Wbidi-chars=]\n      6 |     /*<U+202E> } <U+2066>if (isAdmin)<U+2069> <U+2066> begin admins only */\n        |                                                                           ^\n  Wbidi-chars-1.c:9:28: warning: unpaired UTF-8 bidirectional control character detected [-Wbidi-chars=]\n      9 |     /* end admins only <U+202E> { <U+2066>*/\n        |                                            ^\n\nAfter:\n\n  Wbidi-chars-1.c: In function \u2018main\u2019:\n  Wbidi-chars-1.c:6:43: warning: unpaired UTF-8 bidirectional control characters detected [-Wbidi-chars=]\n      6 |     /*<U+202E> } <U+2066>if (isAdmin)<U+2069> <U+2066> begin admins only */\n        |       ~~~~~~~~                                ~~~~~~~~                    ^\n        |       |                                       |                           |\n        |       |                                       |                           end of bidirectional context\n        |       U+202E (RIGHT-TO-LEFT OVERRIDE)         U+2066 (LEFT-TO-RIGHT ISOLATE)\n  Wbidi-chars-1.c:9:28: warning: unpaired UTF-8 bidirectional control characters detected [-Wbidi-chars=]\n      9 |     /* end admins only <U+202E> { <U+2066>*/\n        |                        ~~~~~~~~   ~~~~~~~~ ^\n        |                        |          |        |\n        |                        |          |        end of bidirectional context\n        |                        |          U+2066 (LEFT-TO-RIGHT ISOLATE)\n        |                        U+202E (RIGHT-TO-LEFT OVERRIDE)\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>\n\ngcc/testsuite/ChangeLog:\n\tPR preprocessor/103026\n\t* c-c++-common/Wbidi-chars-ranges.c: New test.\n\nlibcpp/ChangeLog:\n\tPR preprocessor/103026\n\t* lex.c (struct bidi::context): New.\n\t(bidi::vec): Convert to a vec of context rather than unsigned\n\tchar.\n\t(bidi::ctx_at): Rename to...\n\t(bidi::pop_kind_at): ...this and reimplement for above change.\n\t(bidi::current_ctx): Update for change to vec.\n\t(bidi::current_ctx_ucn_p): Likewise.\n\t(bidi::current_ctx_loc): New.\n\t(bidi::on_char): Update for usage of context struct.  Add \"loc\"\n\tparam and pass it when pushing contexts.\n\t(get_location_for_byte_range_in_cur_line): New.\n\t(get_bidi_utf8): Rename to...\n\t(get_bidi_utf8_1): ...this, reintroducing...\n\t(get_bidi_utf8): ...as a wrapper, setting *OUT when the result is\n\tnot NONE.\n\t(get_bidi_ucn): Rename to...\n\t(get_bidi_ucn_1): ...this, reintroducing...\n\t(get_bidi_ucn): ...as a wrapper, setting *OUT when the result is\n\tnot NONE.\n\t(class unpaired_bidi_rich_location): New.\n\t(maybe_warn_bidi_on_close): Use unpaired_bidi_rich_location when\n\treporting on unpaired bidi chars.  Split into singular vs plural\n\tspellings.\n\t(maybe_warn_bidi_on_char): Pass in a location_t rather than a\n\tconst uchar * and use it when emitting warnings, and when calling\n\tbidi::on_char.\n\t(_cpp_skip_block_comment): Capture location when kind is not NONE\n\tand pass it to maybe_warn_bidi_on_char.\n\t(skip_line_comment): Likewise.\n\t(forms_identifier_p): Likewise.\n\t(lex_raw_string): Likewise.\n\t(lex_string): Likewise.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "653ba145d21f3c570e12bc3eb4d44f8fc7ad516b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/653ba145d21f3c570e12bc3eb4d44f8fc7ad516b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bef32d4a28595e933f24fef378cf052a30b674a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef32d4a28595e933f24fef378cf052a30b674a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bef32d4a28595e933f24fef378cf052a30b674a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef32d4a28595e933f24fef378cf052a30b674a7/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a7f2c0774129750fdf73e9f1b78f0ce983c9ab3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a7f2c0774129750fdf73e9f1b78f0ce983c9ab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a7f2c0774129750fdf73e9f1b78f0ce983c9ab3"}], "stats": {"total": 305, "additions": 257, "deletions": 48}, "files": [{"sha": "298750a2a64c881b447552f4b2f72330a2e8dc3b", "filename": "gcc/testsuite/c-c++-common/Wbidi-chars-ranges.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef32d4a28595e933f24fef378cf052a30b674a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWbidi-chars-ranges.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef32d4a28595e933f24fef378cf052a30b674a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWbidi-chars-ranges.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWbidi-chars-ranges.c?ref=bef32d4a28595e933f24fef378cf052a30b674a7", "patch": "@@ -0,0 +1,54 @@\n+/* PR preprocessor/103026 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wbidi-chars=unpaired -fdiagnostics-show-caret\" } */\n+/* Verify that we escape and underline pertinent bidirectional\n+   control characters when quoting the source.  */\n+\n+int test_unpaired_bidi () {\n+    int isAdmin = 0;\n+    /*\u202e } \u2066if (isAdmin)\u2069 \u2066 begin admins only */\n+/* { dg-warning \"bidirectional\" \"\" { target *-*-* } .-1 } */\n+#if 0\n+   { dg-begin-multiline-output \"\" }\n+     /*<U+202E> } <U+2066>if (isAdmin)<U+2069> <U+2066> begin admins only */\n+       ~~~~~~~~                                ~~~~~~~~                    ^\n+       |                                       |                           |\n+       |                                       |                           end of bidirectional context\n+       U+202E (RIGHT-TO-LEFT OVERRIDE)         U+2066 (LEFT-TO-RIGHT ISOLATE)\n+   { dg-end-multiline-output \"\" }\n+#endif\n+\n+        __builtin_printf(\"You are an admin.\\n\");\n+    /* end admins only \u202e { \u2066*/\n+/* { dg-warning \"bidirectional\" \"\" { target *-*-* } .-1 } */\n+#if 0\n+   { dg-begin-multiline-output \"\" }\n+     /* end admins only <U+202E> { <U+2066>*/\n+                        ~~~~~~~~   ~~~~~~~~ ^\n+                        |          |        |\n+                        |          |        end of bidirectional context\n+                        |          U+2066 (LEFT-TO-RIGHT ISOLATE)\n+                        U+202E (RIGHT-TO-LEFT OVERRIDE)\n+   { dg-end-multiline-output \"\" }\n+#endif\n+\n+    return 0;\n+}\n+\n+int LRE_\u202a_PDF_\\u202c;\n+/* { dg-warning \"mismatch\" \"\" { target *-*-* } .-1 } */\n+#if 0\n+   { dg-begin-multiline-output \"\" }\n+ int LRE_<U+202A>_PDF_\\u202c;\n+         ~~~~~~~~     ^~~~~~\n+   { dg-end-multiline-output \"\" }\n+#endif\n+\n+const char *s1 = \"LRE_\u202a_PDF_\\u202c\";\n+/* { dg-warning \"mismatch\" \"\" { target *-*-* } .-1 } */\n+#if 0\n+   { dg-begin-multiline-output \"\" }\n+ const char *s1 = \"LRE_<U+202A>_PDF_\\u202c\";\n+                       ~~~~~~~~     ^~~~~~\n+   { dg-end-multiline-output \"\" }\n+#endif"}, {"sha": "94c36f0d0148f2ddce48aa0d1398ef7cc97d1bf3", "filename": "libcpp/lex.c", "status": "modified", "additions": 203, "deletions": 48, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef32d4a28595e933f24fef378cf052a30b674a7/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef32d4a28595e933f24fef378cf052a30b674a7/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=bef32d4a28595e933f24fef378cf052a30b674a7", "patch": "@@ -1172,11 +1172,34 @@ namespace bidi {\n   /* All the UTF-8 encodings of bidi characters start with E2.  */\n   constexpr uchar utf8_start = 0xe2;\n \n+  struct context\n+  {\n+    context () {}\n+    context (location_t loc, kind k, bool pdf, bool ucn)\n+    : m_loc (loc), m_kind (k), m_pdf (pdf), m_ucn (ucn)\n+    {\n+    }\n+\n+    kind get_pop_kind () const\n+    {\n+      return m_pdf ? kind::PDF : kind::PDI;\n+    }\n+    bool ucn_p () const\n+    {\n+      return m_ucn;\n+    }\n+\n+    location_t m_loc;\n+    kind m_kind;\n+    unsigned m_pdf : 1;\n+    unsigned m_ucn : 1;\n+  };\n+\n   /* A vector holding currently open bidi contexts.  We use a char for\n      each context, its LSB is 1 if it represents a PDF context, 0 if it\n      represents a PDI context.  The next bit is 1 if this context was open\n      by a bidi character written as a UCN, and 0 when it was UTF-8.  */\n-  semi_embedded_vec <unsigned char, 16> vec;\n+  semi_embedded_vec <context, 16> vec;\n \n   /* Close the whole comment/identifier/string literal/character constant\n      context.  */\n@@ -1193,19 +1216,19 @@ namespace bidi {\n     vec.truncate (len - 1);\n   }\n \n-  /* Return the context of the Ith element.  */\n-  kind ctx_at (unsigned int i)\n+  /* Return the pop kind of the context of the Ith element.  */\n+  kind pop_kind_at (unsigned int i)\n   {\n-    return (vec[i] & 1) ? kind::PDF : kind::PDI;\n+    return vec[i].get_pop_kind ();\n   }\n \n-  /* Return which context is currently opened.  */\n+  /* Return the pop kind of the context that is currently opened.  */\n   kind current_ctx ()\n   {\n     unsigned int len = vec.count ();\n     if (len == 0)\n       return kind::NONE;\n-    return ctx_at (len - 1);\n+    return vec[len - 1].get_pop_kind ();\n   }\n \n   /* Return true if the current context comes from a UCN origin, that is,\n@@ -1214,24 +1237,32 @@ namespace bidi {\n   {\n     unsigned int len = vec.count ();\n     gcc_checking_assert (len > 0);\n-    return (vec[len - 1] >> 1) & 1;\n+    return vec[len - 1].m_ucn;\n   }\n \n-  /* We've read a bidi char, update the current vector as necessary.  */\n-  void on_char (kind k, bool ucn_p)\n+  location_t current_ctx_loc ()\n+  {\n+    unsigned int len = vec.count ();\n+    gcc_checking_assert (len > 0);\n+    return vec[len - 1].m_loc;\n+  }\n+\n+  /* We've read a bidi char, update the current vector as necessary.\n+     LOC is only valid when K is not kind::NONE.  */\n+  void on_char (kind k, bool ucn_p, location_t loc)\n   {\n     switch (k)\n       {\n       case kind::LRE:\n       case kind::RLE:\n       case kind::LRO:\n       case kind::RLO:\n-\tvec.push (ucn_p ? 3u : 1u);\n+\tvec.push (context (loc, k, true, ucn_p));\n \tbreak;\n       case kind::LRI:\n       case kind::RLI:\n       case kind::FSI:\n-\tvec.push (ucn_p ? 2u : 0u);\n+\tvec.push (context (loc, k, false, ucn_p));\n \tbreak;\n       /* PDF terminates the scope of the last LRE, RLE, LRO, or RLO\n \t whose scope has not yet been terminated.  */\n@@ -1245,7 +1276,7 @@ namespace bidi {\n \t yet been terminated.  */\n       case kind::PDI:\n \tfor (int i = vec.count () - 1; i >= 0; --i)\n-\t  if (ctx_at (i) == kind::PDI)\n+\t  if (pop_kind_at (i) == kind::PDI)\n \t    {\n \t      vec.truncate (i);\n \t      break;\n@@ -1295,10 +1326,47 @@ namespace bidi {\n   }\n }\n \n+/* Get location_t for the range of bytes [START, START + NUM_BYTES)\n+   within the current line in FILE, with the caret at START.  */\n+\n+static location_t\n+get_location_for_byte_range_in_cur_line (cpp_reader *pfile,\n+\t\t\t\t\t const unsigned char *const start,\n+\t\t\t\t\t size_t num_bytes)\n+{\n+  gcc_checking_assert (num_bytes > 0);\n+\n+  /* CPP_BUF_COLUMN and linemap_position_for_column both refer\n+     to offsets in bytes, but CPP_BUF_COLUMN is 0-based,\n+     whereas linemap_position_for_column is 1-based.  */\n+\n+  /* Get 0-based offsets within the line.  */\n+  size_t start_offset = CPP_BUF_COLUMN (pfile->buffer, start);\n+  size_t end_offset = start_offset + num_bytes - 1;\n+\n+  /* Now convert to location_t, where \"columns\" are 1-based byte offsets.  */\n+  location_t start_loc = linemap_position_for_column (pfile->line_table,\n+\t\t\t\t\t\t      start_offset + 1);\n+  location_t end_loc = linemap_position_for_column (pfile->line_table,\n+\t\t\t\t\t\t     end_offset + 1);\n+\n+  if (start_loc == end_loc)\n+    return start_loc;\n+\n+  source_range src_range;\n+  src_range.m_start = start_loc;\n+  src_range.m_finish = end_loc;\n+  location_t combined_loc = COMBINE_LOCATION_DATA (pfile->line_table,\n+\t\t\t\t\t\t   start_loc,\n+\t\t\t\t\t\t   src_range,\n+\t\t\t\t\t\t   NULL);\n+  return combined_loc;\n+}\n+\n /* Parse a sequence of 3 bytes starting with P and return its bidi code.  */\n \n static bidi::kind\n-get_bidi_utf8 (const unsigned char *const p)\n+get_bidi_utf8_1 (const unsigned char *const p)\n {\n   gcc_checking_assert (p[0] == bidi::utf8_start);\n \n@@ -1340,10 +1408,25 @@ get_bidi_utf8 (const unsigned char *const p)\n   return bidi::kind::NONE;\n }\n \n+/* Parse a sequence of 3 bytes starting with P and return its bidi code.\n+   If the kind is not NONE, write the location to *OUT.*/\n+\n+static bidi::kind\n+get_bidi_utf8 (cpp_reader *pfile, const unsigned char *const p, location_t *out)\n+{\n+  bidi::kind result = get_bidi_utf8_1 (p);\n+  if (result != bidi::kind::NONE)\n+    {\n+      /* We have a sequence of 3 bytes starting at P.  */\n+      *out = get_location_for_byte_range_in_cur_line (pfile, p, 3);\n+    }\n+  return result;\n+}\n+\n /* Parse a UCN where P points just past \\u or \\U and return its bidi code.  */\n \n static bidi::kind\n-get_bidi_ucn (const unsigned char *p, bool is_U)\n+get_bidi_ucn_1 (const unsigned char *p, bool is_U)\n {\n   /* 6.4.3 Universal Character Names\n       \\u hex-quad\n@@ -1412,6 +1495,62 @@ get_bidi_ucn (const unsigned char *p, bool is_U)\n   return bidi::kind::NONE;\n }\n \n+/* Parse a UCN where P points just past \\u or \\U and return its bidi code.\n+   If the kind is not NONE, write the location to *OUT.*/\n+\n+static bidi::kind\n+get_bidi_ucn (cpp_reader *pfile,  const unsigned char *p, bool is_U,\n+\t      location_t *out)\n+{\n+  bidi::kind result = get_bidi_ucn_1 (p, is_U);\n+  if (result != bidi::kind::NONE)\n+    {\n+      const unsigned char *start = p - 2;\n+      size_t num_bytes = 2 + (is_U ? 8 : 4);\n+      *out = get_location_for_byte_range_in_cur_line (pfile, start, num_bytes);\n+    }\n+  return result;\n+}\n+\n+/* Subclass of rich_location for reporting on unpaired UTF-8\n+   bidirectional control character(s).\n+   Escape the source lines on output, and show all unclosed\n+   bidi context, labelling everything.  */\n+\n+class unpaired_bidi_rich_location : public rich_location\n+{\n+ public:\n+  class custom_range_label : public range_label\n+  {\n+   public:\n+     label_text get_text (unsigned range_idx) const FINAL OVERRIDE\n+     {\n+       /* range 0 is the primary location; each subsequent range i + 1\n+\t  is for bidi::vec[i].  */\n+       if (range_idx > 0)\n+\t {\n+\t   const bidi::context &ctxt (bidi::vec[range_idx - 1]);\n+\t   return label_text::borrow (bidi::to_str (ctxt.m_kind));\n+\t }\n+       else\n+\t return label_text::borrow (_(\"end of bidirectional context\"));\n+     }\n+  };\n+\n+  unpaired_bidi_rich_location (cpp_reader *pfile, location_t loc)\n+  : rich_location (pfile->line_table, loc, &m_custom_label)\n+  {\n+    set_escape_on_output (true);\n+    for (unsigned i = 0; i < bidi::vec.count (); i++)\n+      add_range (bidi::vec[i].m_loc,\n+\t\t SHOW_RANGE_WITHOUT_CARET,\n+\t\t &m_custom_label);\n+  }\n+\n+ private:\n+   custom_range_label m_custom_label;\n+};\n+\n /* We're closing a bidi context, that is, we've encountered a newline,\n    are closing a C-style comment, or are at the end of a string literal,\n    character constant, or identifier.  Warn if this context was not\n@@ -1427,24 +1566,31 @@ maybe_warn_bidi_on_close (cpp_reader *pfile, const uchar *p)\n       const location_t loc\n \t= linemap_position_for_column (pfile->line_table,\n \t\t\t\t       CPP_BUF_COLUMN (pfile->buffer, p));\n-      rich_location rich_loc (pfile->line_table, loc);\n-      rich_loc.set_escape_on_output (true);\n-      cpp_warning_at (pfile, CPP_W_BIDIRECTIONAL, &rich_loc,\n-\t\t      \"unpaired UTF-8 bidirectional control character \"\n-\t\t      \"detected\");\n+      unpaired_bidi_rich_location rich_loc (pfile, loc);\n+      /* cpp_callbacks doesn't yet have a way to handle singular vs plural\n+\t forms of a diagnostic, so fake it for now.  */\n+      if (bidi::vec.count () > 1)\n+\tcpp_warning_at (pfile, CPP_W_BIDIRECTIONAL, &rich_loc,\n+\t\t\t\"unpaired UTF-8 bidirectional control characters \"\n+\t\t\t\"detected\");\n+      else\n+\tcpp_warning_at (pfile, CPP_W_BIDIRECTIONAL, &rich_loc,\n+\t\t\t\"unpaired UTF-8 bidirectional control character \"\n+\t\t\t\"detected\");\n     }\n   /* We're done with this context.  */\n   bidi::on_close ();\n }\n \n /* We're at the beginning or in the middle of an identifier/comment/string\n    literal/character constant.  Warn if we've encountered a bidi character.\n-   KIND says which bidi character it was; P points to it in the character\n-   stream.  UCN_P is true iff this bidi character was written as a UCN.  */\n+   KIND says which bidi control character it was; UCN_P is true iff this bidi\n+   control character was written as a UCN.  LOC is the location of the\n+   character, but is only valid if KIND != bidi::kind::NONE.  */\n \n static void\n-maybe_warn_bidi_on_char (cpp_reader *pfile, const uchar *p, bidi::kind kind,\n-\t\t\t bool ucn_p)\n+maybe_warn_bidi_on_char (cpp_reader *pfile, bidi::kind kind,\n+\t\t\t bool ucn_p, location_t loc)\n {\n   if (__builtin_expect (kind == bidi::kind::NONE, 1))\n     return;\n@@ -1453,9 +1599,6 @@ maybe_warn_bidi_on_char (cpp_reader *pfile, const uchar *p, bidi::kind kind,\n \n   if (warn_bidi != bidirectional_none)\n     {\n-      const location_t loc\n-\t= linemap_position_for_column (pfile->line_table,\n-\t\t\t\t       CPP_BUF_COLUMN (pfile->buffer, p));\n       rich_location rich_loc (pfile->line_table, loc);\n       rich_loc.set_escape_on_output (true);\n \n@@ -1467,9 +1610,12 @@ maybe_warn_bidi_on_char (cpp_reader *pfile, const uchar *p, bidi::kind kind,\n \t{\n \t  if (warn_bidi == bidirectional_unpaired\n \t      && bidi::current_ctx_ucn_p () != ucn_p)\n-\t    cpp_warning_at (pfile, CPP_W_BIDIRECTIONAL, &rich_loc,\n-\t\t\t    \"UTF-8 vs UCN mismatch when closing \"\n-\t\t\t    \"a context by \\\"%s\\\"\", bidi::to_str (kind));\n+\t    {\n+\t      rich_loc.add_range (bidi::current_ctx_loc ());\n+\t      cpp_warning_at (pfile, CPP_W_BIDIRECTIONAL, &rich_loc,\n+\t\t\t      \"UTF-8 vs UCN mismatch when closing \"\n+\t\t\t      \"a context by \\\"%s\\\"\", bidi::to_str (kind));\n+\t    }\n \t}\n       else if (warn_bidi == bidirectional_any)\n \t{\n@@ -1484,7 +1630,7 @@ maybe_warn_bidi_on_char (cpp_reader *pfile, const uchar *p, bidi::kind kind,\n \t}\n     }\n   /* We're done with this context.  */\n-  bidi::on_char (kind, ucn_p);\n+  bidi::on_char (kind, ucn_p, loc);\n }\n \n /* Skip a C-style block comment.  We find the end of the comment by\n@@ -1552,8 +1698,9 @@ _cpp_skip_block_comment (cpp_reader *pfile)\n \t a bidirectional control character.  */\n       else if (__builtin_expect (c == bidi::utf8_start, 0) && warn_bidi_p)\n \t{\n-\t  bidi::kind kind = get_bidi_utf8 (cur - 1);\n-\t  maybe_warn_bidi_on_char (pfile, cur, kind, /*ucn_p=*/false);\n+\t  location_t loc;\n+\t  bidi::kind kind = get_bidi_utf8 (pfile, cur - 1, &loc);\n+\t  maybe_warn_bidi_on_char (pfile, kind, /*ucn_p=*/false, loc);\n \t}\n     }\n \n@@ -1586,9 +1733,9 @@ skip_line_comment (cpp_reader *pfile)\n \t    {\n \t      if (__builtin_expect (*buffer->cur == bidi::utf8_start, 0))\n \t\t{\n-\t\t  bidi::kind kind = get_bidi_utf8 (buffer->cur);\n-\t\t  maybe_warn_bidi_on_char (pfile, buffer->cur, kind,\n-\t\t\t\t\t   /*ucn_p=*/false);\n+\t\t  location_t loc;\n+\t\t  bidi::kind kind = get_bidi_utf8 (pfile, buffer->cur, &loc);\n+\t\t  maybe_warn_bidi_on_char (pfile, kind, /*ucn_p=*/false, loc);\n \t\t}\n \t      buffer->cur++;\n \t    }\n@@ -1737,9 +1884,9 @@ forms_identifier_p (cpp_reader *pfile, int first,\n \t  if (__builtin_expect (*buffer->cur == bidi::utf8_start, 0)\n \t      && warn_bidi_p)\n \t    {\n-\t      bidi::kind kind = get_bidi_utf8 (buffer->cur);\n-\t      maybe_warn_bidi_on_char (pfile, buffer->cur, kind,\n-\t\t\t\t       /*ucn_p=*/false);\n+\t      location_t loc;\n+\t      bidi::kind kind = get_bidi_utf8 (pfile, buffer->cur, &loc);\n+\t      maybe_warn_bidi_on_char (pfile, kind, /*ucn_p=*/false, loc);\n \t    }\n \t  if (_cpp_valid_utf8 (pfile, &buffer->cur, buffer->rlimit, 1 + !first,\n \t\t\t       state, &s))\n@@ -1751,10 +1898,12 @@ forms_identifier_p (cpp_reader *pfile, int first,\n \t  buffer->cur += 2;\n \t  if (warn_bidi_p)\n \t    {\n-\t      bidi::kind kind = get_bidi_ucn (buffer->cur,\n-\t\t\t\t\t      buffer->cur[-1] == 'U');\n-\t      maybe_warn_bidi_on_char (pfile, buffer->cur, kind,\n-\t\t\t\t       /*ucn_p=*/true);\n+\t      location_t loc;\n+\t      bidi::kind kind = get_bidi_ucn (pfile,\n+\t\t\t\t\t      buffer->cur,\n+\t\t\t\t\t      buffer->cur[-1] == 'U',\n+\t\t\t\t\t      &loc);\n+\t      maybe_warn_bidi_on_char (pfile, kind, /*ucn_p=*/true, loc);\n \t    }\n \t  if (_cpp_valid_ucn (pfile, &buffer->cur, buffer->rlimit, 1 + !first,\n \t\t\t      state, &s, NULL, NULL))\n@@ -2375,8 +2524,11 @@ lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n \t}\n       else if (__builtin_expect ((unsigned char) c == bidi::utf8_start, 0)\n \t       && warn_bidi_p)\n-\tmaybe_warn_bidi_on_char (pfile, pos - 1, get_bidi_utf8 (pos - 1),\n-\t\t\t\t /*ucn_p=*/false);\n+\t{\n+\t  location_t loc;\n+\t  bidi::kind kind = get_bidi_utf8 (pfile, pos - 1, &loc);\n+\t  maybe_warn_bidi_on_char (pfile, kind, /*ucn_p=*/false, loc);\n+\t}\n     }\n \n   if (warn_bidi_p)\n@@ -2486,8 +2638,10 @@ lex_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n \t{\n \t  if ((cur[0] == 'u' || cur[0] == 'U') && warn_bidi_p)\n \t    {\n-\t      bidi::kind kind = get_bidi_ucn (cur + 1, cur[0] == 'U');\n-\t      maybe_warn_bidi_on_char (pfile, cur, kind, /*ucn_p=*/true);\n+\t      location_t loc;\n+\t      bidi::kind kind = get_bidi_ucn (pfile, cur + 1, cur[0] == 'U',\n+\t\t\t\t\t      &loc);\n+\t      maybe_warn_bidi_on_char (pfile, kind, /*ucn_p=*/true, loc);\n \t    }\n \t  cur++;\n \t}\n@@ -2515,8 +2669,9 @@ lex_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n \tsaw_NUL = true;\n       else if (__builtin_expect (c == bidi::utf8_start, 0) && warn_bidi_p)\n \t{\n-\t  bidi::kind kind = get_bidi_utf8 (cur - 1);\n-\t  maybe_warn_bidi_on_char (pfile, cur - 1, kind, /*ucn_p=*/false);\n+\t  location_t loc;\n+\t  bidi::kind kind = get_bidi_utf8 (pfile, cur - 1, &loc);\n+\t  maybe_warn_bidi_on_char (pfile, kind, /*ucn_p=*/false, loc);\n \t}\n     }\n "}]}