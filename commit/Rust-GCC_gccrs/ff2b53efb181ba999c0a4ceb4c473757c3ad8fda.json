{"sha": "ff2b53efb181ba999c0a4ceb4c473757c3ad8fda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYyYjUzZWZiMTgxYmE5OTljMGE0Y2ViNGM0NzM3NTdjM2FkOGZkYQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-04-06T07:56:14Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-06T07:56:14Z"}, "message": "cpphash.c (CPP_IS_MACRO_BUFFER, [...]): Delete.\n\n\t* cpphash.c (CPP_IS_MACRO_BUFFER, FORWARD, PEEKC): Delete.\n\t(macro_cleanup): No need to cast pbuf->macro.\n\t(collect_expansion): Use _cpp_get_define_token.  Goto done if\n\tit returns VSPACE.  Remove check for trailing space after\n\tCPP_COMMENT.\n\t(_cpp_create_definition): Don't diddle flags here.  Return\n\tdirectly on error.\n\t(unsafe_chars): Handle c1 being EOF.\n\t(push_macro_expansion): Use unsafe_chars for both accidental-paste\n\tchecks.  Don't push the buffer till after we're done with\n\tthem.\n\t* cpplex.c (PEEKBUF, GETBUF, FORWARDBUF): New.\n\t(PEEKN, FORWARD, GETC, PEEKC): Use them.\n\t(cpp_push_buffer): Don't set new->alimit.  Set new->mark\n\tappropriately.\n\t(_cpp_parse_assertion): Don't NUL terminate.\n\t(_cpp_lex_token): Fix -traditional macro handling.  Don't skip\n\thspace before calling _cpp_parse_assertion.  Remove all sets\n\tof only_seen_white. Treat '\\f' as hspace.  Don't do anything\n\tspecial with '\\n' here.\n\t(maybe_macroexpand): Handle T_EMPTY hash entries without\n\tpushing a buffer at all.\n\t(cpp_get_token): Handle clearing only_seen_white here.  Handle\n\tincrementing the line number here.  Clear\n\tpotential_control_macro as well as only_seen_white, if\n\tappropriate.\n\t(cpp_get_non_space_token): Don't eat CPP_POP tokens.\n\t(_cpp_get_define_token): New function, basically like\n\t_cpp_get_directive_token was but doesn't eat horizontal space.\n\tDon't do anything with only_seen_white here.\n\t(_cpp_get_directive_token): Just call _cpp_get_define_token\n\trepeatedly till it returns non-hspace.\n\n\t* cpplib.c (PEEKN, FORWARD, GETC, PEEKC): Delete.\n\t(conditional_skip, skip_if_group): Return int.\n\t(DIRECTIVE_TABLE): Change origin of all conditional directives\n\tto \"COND\".\n\t(TRAD_DIRECT_P): New macro.\n\t(_cpp_handle_directive): Use _cpp_get_directive_token.  Issue\n\tan error for a bogus directive, unless -lang-asm.  Use\n\tTRAD_DIRECT_P. Loop calling handler functions till one returns\n\tzero.\n\t(get_macro_name): Don't diddle flags here.\n\t(do_define): Diddle flags here.  Use _cpp_get_directive_token.\n\tCreate T_EMPTY nodes for #define macro /* nothing */.\n\t(do_undef): Don't copy the name.  Use _cpp_get_directive_token.\n\tUse hp->name when calling pass_thru_directive.\n\t(do_if, do_else, do_elif, do_ifdef, do_ifndef, conditional_skip):\n\tReturn the result of conditional_skip and/or skip_if_group.\n\tDon't call _cpp_output_line_command.\n\t(consider_directive_while_skipping): Use _cpp_get_directive_token.\n\tIssue -Wtraditional warnings as appropriate.  Don't complain\n\tabout unrecognized directives.  If we are to stop skipping,\n\treturn the number of the directive that ended the skip.\n\t(skip_if_group): Use _cpp_get_directive_token.  Turn off macro\n\texpansion and line commands while skipping.  Return the result\n\tof consider_directive_while_skipping, if nonzero.\n\t(do_endif): Just set potential_control_macro here.\n\t(validate_else): Use _cpp_get_directive_token.\n\t(do_assert, do_unassert): Don't save pointers into the\n\ttoken_buffer across calls to the lexer.  Use\n\t_cpp_get_directive_token.\n\n\t* cpplib.h (cpp_buffer): Remove alimit and colno.  Make mark a\n\tpointer, not an offset.  Replace 'data', which was a generic\n\tpointer, with 'macro', which points to a struct hashnode.\n\t(cpp_reader): Add 'potential_control_macro' pointer.\n\t* cpphash.h (T_UNUSED): Replace with T_EMPTY.\n\t(CPP_BUF_GET, CPP_FORWARD): Delete.\n\t(CPP_IN_COLUMN_1, ADJACENT_TO_MARK): New macros.\n\t(CPP_IS_MACRO_BUFFER, CPP_SET_BUF_MARK, CPP_GOTO_BUF_MARK,\n\tACTIVE_MARK_P): Update.\n\t(_cpp_get_define_token): New internal function.\n\t* cppfiles.c (read_include_file): Don't set fp->alimit or fp->colno.\n\nFrom-SVN: r32965", "tree": {"sha": "a3ed58746ede412e1a5592098f6237d21c4b4ed3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3ed58746ede412e1a5592098f6237d21c4b4ed3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/comments", "author": null, "committer": null, "parents": [{"sha": "edea3682660f51f996f0889202c029882a33788a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edea3682660f51f996f0889202c029882a33788a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edea3682660f51f996f0889202c029882a33788a"}], "stats": {"total": 998, "additions": 581, "deletions": 417}, "files": [{"sha": "e1003f4d6bc78ee550b6917bc6cfd5763c49f994", "filename": "gcc/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff2b53efb181ba999c0a4ceb4c473757c3ad8fda", "patch": "@@ -1,3 +1,80 @@\n+2000-04-06  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpphash.c (CPP_IS_MACRO_BUFFER, FORWARD, PEEKC): Delete.\n+\t(macro_cleanup): No need to cast pbuf->macro.\n+\t(collect_expansion): Use _cpp_get_define_token.  Goto done if\n+\tit returns VSPACE.  Remove check for trailing space after\n+\tCPP_COMMENT.\n+\t(_cpp_create_definition): Don't diddle flags here.  Return\n+\tdirectly on error.\n+\t(unsafe_chars): Handle c1 being EOF.\n+\t(push_macro_expansion): Use unsafe_chars for both accidental-paste\n+\tchecks.  Don't push the buffer till after we're done with\n+\tthem.\n+\t* cpplex.c (PEEKBUF, GETBUF, FORWARDBUF): New.\n+\t(PEEKN, FORWARD, GETC, PEEKC): Use them.\n+\t(cpp_push_buffer): Don't set new->alimit.  Set new->mark\n+\tappropriately.\n+\t(_cpp_parse_assertion): Don't NUL terminate.\n+\t(_cpp_lex_token): Fix -traditional macro handling.  Don't skip\n+\thspace before calling _cpp_parse_assertion.  Remove all sets\n+\tof only_seen_white. Treat '\\f' as hspace.  Don't do anything\n+\tspecial with '\\n' here.\n+\t(maybe_macroexpand): Handle T_EMPTY hash entries without\n+\tpushing a buffer at all.\n+\t(cpp_get_token): Handle clearing only_seen_white here.  Handle\n+\tincrementing the line number here.  Clear\n+\tpotential_control_macro as well as only_seen_white, if\n+\tappropriate.\n+\t(cpp_get_non_space_token): Don't eat CPP_POP tokens.\n+\t(_cpp_get_define_token): New function, basically like\n+\t_cpp_get_directive_token was but doesn't eat horizontal space.\n+\tDon't do anything with only_seen_white here.\n+\t(_cpp_get_directive_token): Just call _cpp_get_define_token\n+\trepeatedly till it returns non-hspace.\n+\n+\t* cpplib.c (PEEKN, FORWARD, GETC, PEEKC): Delete.\n+\t(conditional_skip, skip_if_group): Return int.\n+\t(DIRECTIVE_TABLE): Change origin of all conditional directives\n+\tto \"COND\".\n+\t(TRAD_DIRECT_P): New macro.\n+\t(_cpp_handle_directive): Use _cpp_get_directive_token.  Issue\n+\tan error for a bogus directive, unless -lang-asm.  Use\n+\tTRAD_DIRECT_P. Loop calling handler functions till one returns\n+\tzero.\n+\t(get_macro_name): Don't diddle flags here.\n+\t(do_define): Diddle flags here.  Use _cpp_get_directive_token.\n+\tCreate T_EMPTY nodes for #define macro /* nothing */.\n+\t(do_undef): Don't copy the name.  Use _cpp_get_directive_token.\n+\tUse hp->name when calling pass_thru_directive.\n+\t(do_if, do_else, do_elif, do_ifdef, do_ifndef, conditional_skip):\n+\tReturn the result of conditional_skip and/or skip_if_group.\n+\tDon't call _cpp_output_line_command.\n+\t(consider_directive_while_skipping): Use _cpp_get_directive_token.\n+\tIssue -Wtraditional warnings as appropriate.  Don't complain\n+\tabout unrecognized directives.  If we are to stop skipping,\n+\treturn the number of the directive that ended the skip.\n+\t(skip_if_group): Use _cpp_get_directive_token.  Turn off macro\n+\texpansion and line commands while skipping.  Return the result\n+\tof consider_directive_while_skipping, if nonzero.\n+\t(do_endif): Just set potential_control_macro here.\n+\t(validate_else): Use _cpp_get_directive_token.\n+\t(do_assert, do_unassert): Don't save pointers into the\n+\ttoken_buffer across calls to the lexer.  Use\n+\t_cpp_get_directive_token.  \n+\n+\t* cpplib.h (cpp_buffer): Remove alimit and colno.  Make mark a \n+\tpointer, not an offset.  Replace 'data', which was a generic\n+\tpointer, with 'macro', which points to a struct hashnode.\n+\t(cpp_reader): Add 'potential_control_macro' pointer.\n+\t* cpphash.h (T_UNUSED): Replace with T_EMPTY.\n+\t(CPP_BUF_GET, CPP_FORWARD): Delete.\n+\t(CPP_IN_COLUMN_1, ADJACENT_TO_MARK): New macros.\n+\t(CPP_IS_MACRO_BUFFER, CPP_SET_BUF_MARK, CPP_GOTO_BUF_MARK,\n+\tACTIVE_MARK_P): Update.\n+\t(_cpp_get_define_token): New internal function.\n+\t* cppfiles.c (read_include_file): Don't set fp->alimit or fp->colno.\n+\n 2000-04-05   Benjamin Kosnik  <bkoz@cygnus.com>\n \n         * configure.in: And here."}, {"sha": "2be195aa90c1db2e29afd5e30dcaea0d393264a9", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=ff2b53efb181ba999c0a4ceb4c473757c3ad8fda", "patch": "@@ -742,12 +742,11 @@ read_include_file (pfile, fd, ihash)\n     ihash->control_macro = (const U_CHAR *) \"\";  /* never re-include */\n \n   close (fd);\n-  fp->rlimit = fp->alimit = fp->buf + length;\n+  fp->rlimit = fp->buf + length;\n   fp->cur = fp->buf;\n   if (ihash->foundhere != ABSOLUTE_PATH)\n       fp->system_header_p = ihash->foundhere->sysp;\n   fp->lineno = 1;\n-  fp->colno = 1;\n   fp->line_base = fp->buf;\n   fp->cleanup = file_cleanup;\n "}, {"sha": "4578ca728f271815f184923ab46eb07f48e1d224", "filename": "gcc/cpphash.c", "status": "modified", "additions": 44, "deletions": 69, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=ff2b53efb181ba999c0a4ceb4c473757c3ad8fda", "patch": "@@ -45,10 +45,6 @@ static enum cpp_token macarg\t PARAMS ((cpp_reader *, int));\n static struct tm *timestamp\t PARAMS ((cpp_reader *));\n static void special_symbol\t PARAMS ((HASHNODE *, cpp_reader *));\n \n-#define CPP_IS_MACRO_BUFFER(PBUF) ((PBUF)->data != NULL)\n-#define FORWARD(N) CPP_FORWARD (CPP_BUFFER (pfile), (N))\n-#define PEEKC() CPP_BUF_PEEK (CPP_BUFFER (pfile))\n-\n /* Initial hash table size.  (It can grow if necessary - see hashtab.c.)  */\n #define HASHSIZE 500\n \n@@ -266,7 +262,7 @@ macro_cleanup (pbuf, pfile)\n      cpp_buffer *pbuf;\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n {\n-  HASHNODE *macro = (HASHNODE *) pbuf->data;\n+  HASHNODE *macro = pbuf->macro;\n   if (macro->type == T_DISABLED)\n     macro->type = T_MACRO;\n   if (macro->type != T_MACRO || pbuf->buf != macro->value.defn->expansion)\n@@ -314,26 +310,18 @@ collect_expansion (pfile, arglist)\n   last -= 2;  /* two extra chars for the leading escape */\n   for (;;)\n     {\n-      /* We use cpp_get_token because _cpp_get_directive_token would\n-\t discard whitespace and we can't cope with that yet.  Macro\n-\t expansion is off, so we are guaranteed not to see POP or EOF.  */\n-\n-      while (PEEKC () == '\\r')\n-\t{\n-\t  FORWARD (1);\n-\t  CPP_BUMP_LINE (pfile);\n-\t}\n-      if (PEEKC () == '\\n')\n-\tgoto done;\n+      /* Macro expansion is off, so we are guaranteed not to see POP\n+\t or EOF.  */\n       here = CPP_WRITTEN (pfile);\n-      token = cpp_get_token (pfile);\n+      token = _cpp_get_define_token (pfile);\n       tok = pfile->token_buffer + here;\n       switch (token)\n \t{\n \tcase CPP_POP:\n \tcase CPP_EOF:\n+\t  cpp_ice (pfile, \"EOF in collect_expansion\");\n+\t  /* fall through */\n \tcase CPP_VSPACE:\n-\t  cpp_ice (pfile, \"EOF or VSPACE in collect_expansion\");\n \t  goto done;\n \n \tcase CPP_HSPACE:\n@@ -386,16 +374,14 @@ collect_expansion (pfile, arglist)\n \tcase CPP_COMMENT:\n \t  /* We must be in -traditional mode.  Pretend this was a\n \t     token paste, but only if there was no leading or\n-\t     trailing space and it's in the middle of the line.  */\n+\t     trailing space and it's in the middle of the line.\n+\t     _cpp_lex_token won't return a COMMENT if there was trailing\n+\t     space.  */\n \t  CPP_SET_WRITTEN (pfile, here);\n \t  if (last_token == START)\n \t    break;\n \t  if (is_hspace (pfile->token_buffer[here-1]))\n \t    break;\n-\t  if (is_hspace (PEEKC ()))\n-\t    break;\n-\t  if (PEEKC () == '\\n')\n-\t    break;\n \t  if (last_token == ARG)\n \t    endpat->raw_after = 1;\n \t  last_token = PASTE;\n@@ -738,38 +724,21 @@ _cpp_create_definition (pfile, funlike)\n   cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n   file = CPP_BUFFER (pfile)->nominal_fname;\n \n-  pfile->no_macro_expand++;\n-  pfile->parsing_define_directive++;\n-  CPP_OPTION (pfile, discard_comments)++;\n-  CPP_OPTION (pfile, no_line_commands)++;\n-  \n   if (funlike)\n     {\n       args = collect_formal_parameters (pfile);\n       if (args == 0)\n-\tgoto err;\n+\treturn 0;\n     }\n \n   defn = collect_expansion (pfile, args);\n   if (defn == 0)\n-    goto err;\n+    return 0;\n \n   defn->line = line;\n   defn->file = file;\n   defn->col  = col;\n-\n-  pfile->no_macro_expand--;\n-  pfile->parsing_define_directive--;\n-  CPP_OPTION (pfile, discard_comments)--;\n-  CPP_OPTION (pfile, no_line_commands)--;\n   return defn;\n-\n- err:\n-  pfile->no_macro_expand--;\n-  pfile->parsing_define_directive--;\n-  CPP_OPTION (pfile, discard_comments)--;\n-  CPP_OPTION (pfile, no_line_commands)--;\n-  return 0;\n }\n \n /*\n@@ -1446,6 +1415,18 @@ unsafe_chars (pfile, c1, c2)\n {\n   switch (c1)\n     {\n+    case EOF:\n+      /* We don't know what the previous character was.  We do know\n+\t that it can't have been an idchar (or else it would have been\n+\t pasted with the idchars of the macro name), and there are a\n+\t number of second characters for which it doesn't matter what\n+\t the first was.  */\n+      if (is_idchar (c2) || c2 == '\\'' || c2 == '\\\"'\n+\t  || c2 == '(' || c2 == '[' || c2 == '{'\n+\t  || c2 == ')' || c2 == ']' || c2 == '}')\n+\treturn 0;\n+      return 1;\n+\n     case '+':  case '-':\n       if (c2 == c1 || c2 == '=')\n \treturn 1;\n@@ -1488,17 +1469,14 @@ unsafe_chars (pfile, c1, c2)\n }\n \n static void\n-push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n+push_macro_expansion (pfile, xbuf, len, hp)\n      cpp_reader *pfile;\n      register U_CHAR *xbuf;\n-     int xbuf_len;\n+     int len;\n      HASHNODE *hp;\n {\n-  register cpp_buffer *mbuf = cpp_push_buffer (pfile, xbuf, xbuf_len);\n-  if (mbuf == NULL)\n-    return;\n-  mbuf->cleanup = macro_cleanup;\n-  mbuf->data = hp;\n+  cpp_buffer *mbuf;\n+  int advance_cur = 0;\n \n   /* The first chars of the expansion should be a \"\\r \" added by\n      collect_expansion.  This is to prevent accidental token-pasting\n@@ -1507,34 +1485,31 @@ push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n \n      We would like to avoid adding unneeded spaces (for the sake of\n      tools that use cpp, such as imake).  In some common cases we can\n-     tell that it is safe to omit the space.\n-\n-     The character before the macro invocation cannot have been an\n-     idchar (or else it would have been pasted with the idchars of\n-     the macro name).  Therefore, if the first non-space character\n-     of the expansion is an idchar, we do not need the extra space\n-     to prevent token pasting.\n-\n-     Also, we don't need the extra space if the first char is '(',\n-     or some other (less common) characters.  */\n+     tell that it is safe to omit the space.  */\n \n   if (xbuf[0] == '\\r' && xbuf[1] == ' '\n-      && (is_idchar(xbuf[2]) || xbuf[2] == '(' || xbuf[2] == '\\''\n-\t  || xbuf[2] == '\\\"'))\n-    mbuf->cur += 2;\n+      && !unsafe_chars (pfile, EOF, xbuf[2]))\n+    advance_cur = 1;\n \n   /* Likewise, avoid the extra space at the end of the macro expansion\n      if this is safe.  We can do a better job here since we can know\n      what the next char will be.  */\n-  if (xbuf_len >= 3\n-      && mbuf->rlimit[-2] == '\\r'\n-      && mbuf->rlimit[-1] == ' ')\n+  if (len >= 3\n+      && xbuf[len-2] == '\\r'\n+      && xbuf[len-1] == ' ')\n     {\n-      int c1 = mbuf->rlimit[-3];\n-      int c2 = CPP_BUF_PEEK (CPP_PREV_BUFFER (CPP_BUFFER (pfile)));\n-      if (c2 == EOF || !unsafe_chars (pfile, c1, c2))\n-\tmbuf->rlimit -= 2;\n+      int c = CPP_BUF_PEEK (CPP_BUFFER (pfile));\n+      if (c == EOF || !unsafe_chars (pfile, xbuf[len-3], c))\n+\tlen -= 2;\n     }\n+\n+  mbuf = cpp_push_buffer (pfile, xbuf, len);\n+  if (mbuf == NULL)\n+    return;\n+  if (advance_cur)\n+    mbuf->cur += 2;\n+  mbuf->cleanup = macro_cleanup;\n+  mbuf->macro = hp;\n }\n \n /* Return zero if two DEFINITIONs are isomorphic.  */"}, {"sha": "abf0d2bc12044e5c7453dcfd44112795db5c6153", "filename": "gcc/cpphash.h", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=ff2b53efb181ba999c0a4ceb4c473757c3ad8fda", "patch": "@@ -98,7 +98,7 @@ enum node_type\n   T_MACRO,\t   /* macro defined by `#define' */\n   T_DISABLED,\t   /* macro temporarily turned off for rescan */\n   T_POISON,\t   /* macro defined with `#pragma poison' */\n-  T_UNUSED\t   /* Used for something not defined.  */\n+  T_EMPTY\t   /* macro defined to nothing */\n };\n \n /* different kinds of things that can appear in the value field\n@@ -192,11 +192,11 @@ extern unsigned char _cpp_IStable[256];\n \n /* Macros.  */\n \n+/* One character lookahead in the input buffer.  Note that if this\n+   returns EOF, it does *not* necessarily mean the file's end has been\n+   reached.  */\n #define CPP_BUF_PEEK(BUFFER) \\\n   ((BUFFER)->cur < (BUFFER)->rlimit ? *(BUFFER)->cur : EOF)\n-#define CPP_BUF_GET(BUFFER) \\\n-  ((BUFFER)->cur < (BUFFER)->rlimit ? *(BUFFER)->cur++ : EOF)\n-#define CPP_FORWARD(BUFFER, N) ((BUFFER)->cur += (N))\n \n /* Make sure PFILE->token_buffer has space for at least N more characters. */\n #define CPP_RESERVE(PFILE, N) \\\n@@ -223,6 +223,11 @@ extern unsigned char _cpp_IStable[256];\n #define CPP_BUMP_LINE(PFILE) CPP_BUMP_BUFFER_LINE(CPP_BUFFER(PFILE))\n #define CPP_PREV_BUFFER(BUFFER) ((BUFFER)->prev)\n \n+/* Are we in column 1 right now?  Used mainly for -traditional handling\n+   of directives.  */\n+#define CPP_IN_COLUMN_1(PFILE) \\\n+(CPP_BUFFER (PFILE)->cur - CPP_BUFFER (PFILE)->line_base == 1)\n+\n #define CPP_PRINT_DEPS(PFILE) CPP_OPTION (PFILE, print_deps)\n #define CPP_TRADITIONAL(PFILE) CPP_OPTION (PFILE, traditional)\n #define CPP_PEDANTIC(PFILE) \\\n@@ -232,7 +237,7 @@ extern unsigned char _cpp_IStable[256];\n \n /* CPP_IS_MACRO_BUFFER is true if the buffer contains macro expansion.\n    (Note that it is false while we're expanding macro *arguments*.) */\n-#define CPP_IS_MACRO_BUFFER(PBUF) ((PBUF)->data != NULL)\n+#define CPP_IS_MACRO_BUFFER(PBUF) ((PBUF)->macro != NULL)\n \n /* Remember the current position of PFILE so it may be returned to\n    after looking ahead a bit.\n@@ -241,14 +246,18 @@ extern unsigned char _cpp_IStable[256];\n    may not forget about it and continue parsing.  You may not pop a\n    buffer with an active mark.  You may not call CPP_BUMP_LINE while a\n    mark is active.  */\n-#define CPP_SET_BUF_MARK(IP)   ((IP)->mark = (IP)->cur - (IP)->buf)\n-#define CPP_GOTO_BUF_MARK(IP)  ((IP)->cur = (IP)->buf + (IP)->mark, \\\n-\t\t\t\t(IP)->mark = -1)\n+#define CPP_SET_BUF_MARK(IP)   ((IP)->mark = (IP)->cur)\n+#define CPP_GOTO_BUF_MARK(IP)  ((IP)->cur = (IP)->mark,\t(IP)->mark = 0)\n #define CPP_SET_MARK(PFILE)  CPP_SET_BUF_MARK(CPP_BUFFER(PFILE))\n #define CPP_GOTO_MARK(PFILE) CPP_GOTO_BUF_MARK(CPP_BUFFER(PFILE))\n \n /* ACTIVE_MARK_P is true if there's a live mark in the buffer.  */\n-#define ACTIVE_MARK_P(PFILE) (CPP_BUFFER (PFILE)->mark != -1)\n+#define ACTIVE_MARK_P(PFILE) (CPP_BUFFER (PFILE)->mark != 0)\n+\n+/* Are mark and point adjacent characters?  Used mostly to deal with\n+   the somewhat annoying semantic of #define.  */\n+#define ADJACENT_TO_MARK(PFILE) \\\n+ (CPP_BUFFER(PFILE)->cur - CPP_BUFFER(PFILE)->mark == 1)\n \n /* Last arg to output_line_command.  */\n enum file_change_code {same_file, rename_file, enter_file, leave_file};\n@@ -296,6 +305,8 @@ extern void _cpp_init_input_buffer\tPARAMS ((cpp_reader *));\n extern void _cpp_grow_token_buffer\tPARAMS ((cpp_reader *, long));\n extern enum cpp_token _cpp_get_directive_token\n \t\t\t\t\tPARAMS ((cpp_reader *));\n+extern enum cpp_token _cpp_get_define_token\n+\t\t\t\t\tPARAMS ((cpp_reader *));\n \n /* In cpplib.c */\n extern int _cpp_handle_directive\tPARAMS ((cpp_reader *));"}, {"sha": "2e791200e456f201d2ed131d5170c9ebfe6a06f4", "filename": "gcc/cpplex.c", "status": "modified", "additions": 121, "deletions": 60, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=ff2b53efb181ba999c0a4ceb4c473757c3ad8fda", "patch": "@@ -25,11 +25,16 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-#define PEEKN(N) (CPP_BUFFER (pfile)->rlimit - CPP_BUFFER (pfile)->cur >= (N) \\\n-\t\t  ? CPP_BUFFER (pfile)->cur[N] : EOF)\n-#define FORWARD(N) CPP_FORWARD (CPP_BUFFER (pfile), (N))\n-#define GETC() CPP_BUF_GET (CPP_BUFFER (pfile))\n-#define PEEKC() CPP_BUF_PEEK (CPP_BUFFER (pfile))\n+#define PEEKBUF(BUFFER, N) \\\n+  ((BUFFER)->rlimit - (BUFFER)->cur > (N) ? (BUFFER)->cur[N] : EOF)\n+#define GETBUF(BUFFER) \\\n+  ((BUFFER)->cur < (BUFFER)->rlimit ? *(BUFFER)->cur++ : EOF)\n+#define FORWARDBUF(BUFFER, N) ((BUFFER)->cur += (N))\n+\n+#define PEEKN(N) PEEKBUF (CPP_BUFFER (pfile), N)\n+#define FORWARD(N) FORWARDBUF (CPP_BUFFER (pfile), (N))\n+#define GETC() GETBUF (CPP_BUFFER (pfile))\n+#define PEEKC() PEEKBUF (CPP_BUFFER (pfile), 0)\n \n static void skip_block_comment\tPARAMS ((cpp_reader *));\n static void skip_line_comment\tPARAMS ((cpp_reader *));\n@@ -87,9 +92,9 @@ cpp_push_buffer (pfile, buffer, length)\n   new->if_stack = pfile->if_stack;\n   new->cleanup = null_cleanup;\n   new->buf = new->cur = buffer;\n-  new->alimit = new->rlimit = buffer + length;\n+  new->rlimit = buffer + length;\n   new->prev = buf;\n-  new->mark = -1;\n+  new->mark = NULL;\n   new->line_base = NULL;\n \n   CPP_BUFFER (pfile) = new;\n@@ -667,7 +672,6 @@ _cpp_parse_assertion (pfile)\n   else\n     CPP_PUTC (pfile, ')');\n \n-  CPP_NUL_TERMINATE (pfile);\n   return 2;\n }\n \n@@ -702,8 +706,16 @@ _cpp_lex_token (pfile)\n \t  \n       /* Comments are equivalent to spaces.\n \t For -traditional, a comment is equivalent to nothing.  */\n-      if (CPP_TRADITIONAL (pfile) || !CPP_OPTION (pfile, discard_comments))\n+      if (!CPP_OPTION (pfile, discard_comments))\n \treturn CPP_COMMENT;\n+      else if (CPP_TRADITIONAL (pfile)\n+\t       && ! is_space (PEEKC ()))\n+\t{\n+\t  if (pfile->parsing_define_directive)\n+\t    return CPP_COMMENT;\n+\t  else\n+\t    goto get_next;\n+\t}\n       else\n \t{\n \t  CPP_PUTC (pfile, c);\n@@ -713,7 +725,6 @@ _cpp_lex_token (pfile)\n     case '#':\n       if (pfile->parsing_if_directive)\n \t{\n-\t  _cpp_skip_hspace (pfile);\n \t  if (_cpp_parse_assertion (pfile))\n \t    return CPP_ASSERTION;\n \t  goto randomchar;\n@@ -740,7 +751,6 @@ _cpp_lex_token (pfile)\n     case '\\\"':\n     case '\\'':\n       parse_string (pfile, c);\n-      pfile->only_seen_white = 0;\n       return c == '\\'' ? CPP_CHAR : CPP_STRING;\n \n     case '$':\n@@ -787,7 +797,6 @@ _cpp_lex_token (pfile)\n \t    {\n \t      /* In C++, there's a ->* operator.  */\n \t      token = CPP_OTHER;\n-\t      pfile->only_seen_white = 0;\n \t      CPP_RESERVE (pfile, 4);\n \t      CPP_PUTC_Q (pfile, c);\n \t      CPP_PUTC_Q (pfile, GETC ());\n@@ -851,7 +860,6 @@ _cpp_lex_token (pfile)\n       if (c3 == '=')\n \tCPP_PUTC_Q (pfile, GETC ());\n       CPP_NUL_TERMINATE_Q (pfile);\n-      pfile->only_seen_white = 0;\n       return CPP_OTHER;\n \n     case '.':\n@@ -876,14 +884,12 @@ _cpp_lex_token (pfile)\n \t  CPP_PUTC_Q (pfile, '.');\n \t  FORWARD (2);\n \t  CPP_NUL_TERMINATE_Q (pfile);\n-\t  pfile->only_seen_white = 0;\n \t  return CPP_3DOTS;\n \t}\n       goto randomchar;\n \n     op2:\n       token = CPP_OTHER;\n-      pfile->only_seen_white = 0;\n       CPP_RESERVE(pfile, 3);\n       CPP_PUTC_Q (pfile, c);\n       CPP_PUTC_Q (pfile, GETC ());\n@@ -897,7 +903,6 @@ _cpp_lex_token (pfile)\n \t  CPP_PUTC (pfile, c);\n \t  c = GETC ();\n \t  parse_string (pfile, c);\n-\t  pfile->only_seen_white = 0;\n \t  return c == '\\'' ? CPP_WCHAR : CPP_WSTRING;\n \t}\n       goto letter;\n@@ -923,13 +928,11 @@ _cpp_lex_token (pfile)\n \tc2= c;\n       }\n     CPP_NUL_TERMINATE_Q (pfile);\n-    pfile->only_seen_white = 0;\n     return CPP_NUMBER;\n     case 'b': case 'c': case 'd': case 'h': case 'o':\n     case 'B': case 'C': case 'D': case 'H': case 'O':\n       if (CPP_OPTION (pfile, chill) && PEEKC () == '\\'')\n \t{\n-\t  pfile->only_seen_white = 0;\n \t  CPP_RESERVE (pfile, 2);\n \t  CPP_PUTC_Q (pfile, c);\n \t  CPP_PUTC_Q (pfile, '\\'');\n@@ -970,11 +973,10 @@ _cpp_lex_token (pfile)\n     case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n     case 'Y': case 'Z':\n     letter:\n-    pfile->only_seen_white = 0;\n     _cpp_parse_name (pfile, c);\n     return CPP_MACRO;\n \n-    case ' ':  case '\\t':  case '\\v':\n+    case ' ': case '\\t': case '\\v': case '\\f':\n       for (;;)\n \t{\n \t  CPP_PUTC (pfile, c);\n@@ -998,6 +1000,8 @@ _cpp_lex_token (pfile)\n \t    }\n \t  else if (c == ' ')\n \t    {\n+\t      /* \"\\r \" means a space, but only if necessary to prevent\n+\t\t accidental token concatenation.  */\n \t      CPP_RESERVE (pfile, 2);\n \t      if (pfile->output_escapes)\n \t\tCPP_PUTC_Q (pfile, '\\r');\n@@ -1019,15 +1023,6 @@ _cpp_lex_token (pfile)\n \n     case '\\n':\n       CPP_PUTC (pfile, c);\n-      if (pfile->only_seen_white == 0)\n-\tpfile->only_seen_white = 1;\n-      CPP_BUMP_LINE (pfile);\n-      if (! CPP_OPTION (pfile, no_line_commands))\n-\t{\n-\t  pfile->lineno++;\n-\t  if (CPP_BUFFER (pfile)->lineno != pfile->lineno)\n-\t    _cpp_output_line_command (pfile, same_file);\n-\t}\n       return CPP_VSPACE;\n \n     case '(': token = CPP_LPAREN;    goto char1;\n@@ -1041,7 +1036,6 @@ _cpp_lex_token (pfile)\n     default:\n       token = CPP_OTHER;\n     char1:\n-      pfile->only_seen_white = 0;\n       CPP_PUTC (pfile, c);\n       return token;\n     }\n@@ -1075,6 +1069,13 @@ maybe_macroexpand (pfile, written)\n \t}\n       return 0;\n     }\n+  if (hp->type == T_EMPTY)\n+    {\n+      /* Special case optimization: macro expands to nothing.  */\n+      CPP_SET_WRITTEN (pfile, written);\n+      CPP_PUTC_Q (pfile, ' ');\n+      return 1;\n+    }\n \n   /* If macro wants an arglist, verify that a '(' follows.  */\n   if (hp->type == T_MACRO && hp->value.defn->nargs >= 0)\n@@ -1146,16 +1147,37 @@ cpp_get_token (pfile)\n   switch (token)\n     {\n     default:\n+      pfile->potential_control_macro = 0;\n+      pfile->only_seen_white = 0;\n+      return token;\n+\n+    case CPP_VSPACE:\n+      if (pfile->only_seen_white == 0)\n+\tpfile->only_seen_white = 1;\n+      CPP_BUMP_LINE (pfile);\n+      if (! CPP_OPTION (pfile, no_line_commands))\n+\t{\n+\t  pfile->lineno++;\n+\t  if (CPP_BUFFER (pfile)->lineno != pfile->lineno)\n+\t    _cpp_output_line_command (pfile, same_file);\n+\t}\n+      return token;\n+\n+    case CPP_HSPACE:\n+    case CPP_COMMENT:\n       return token;\n \n     case CPP_DIRECTIVE:\n+      pfile->potential_control_macro = 0;\n       if (_cpp_handle_directive (pfile))\n \treturn CPP_DIRECTIVE;\n       pfile->only_seen_white = 0;\n       CPP_PUTC (pfile, '#');\n       return CPP_OTHER;\n \n     case CPP_MACRO:\n+      pfile->potential_control_macro = 0;\n+      pfile->only_seen_white = 0;\n       if (! pfile->no_macro_expand\n \t  && maybe_macroexpand (pfile, written))\n \tgoto get_next;\n@@ -1192,57 +1214,96 @@ cpp_get_non_space_token (pfile)\n   for (;;)\n     {\n       enum cpp_token token = cpp_get_token (pfile);\n-      if (token != CPP_COMMENT && token != CPP_POP\n-\t  && token != CPP_HSPACE && token != CPP_VSPACE)\n+      if (token != CPP_COMMENT && token != CPP_HSPACE && token != CPP_VSPACE)\n \treturn token;\n       CPP_SET_WRITTEN (pfile, old_written);\n     }\n }\n \n-/* Like cpp_get_token, except that it does not read past end-of-line.\n-   Also, horizontal space is skipped, and macros are popped.  */\n+/* Like cpp_get_token, except that it does not execute directives,\n+   does not consume vertical space, and automatically pops off macro\n+   buffers.\n \n+   XXX This function will exist only till collect_expansion doesn't\n+   need to see whitespace anymore, then it'll be merged with\n+   _cpp_get_directive_token (below).  */\n enum cpp_token\n-_cpp_get_directive_token (pfile)\n+_cpp_get_define_token (pfile)\n      cpp_reader *pfile;\n {\n-  long old_written = CPP_WRITTEN (pfile);\n+  long old_written;\n   enum cpp_token token;\n \n-  for (;;)\n+ get_next:\n+  old_written = CPP_WRITTEN (pfile);\n+  token = _cpp_lex_token (pfile);\n+  switch (token)\n     {\n-      _cpp_skip_hspace (pfile);\n-      if (PEEKC () == '\\n')\n-\treturn CPP_VSPACE;\n+    default:\n+      return token;\n \n-      token = cpp_get_token (pfile);\n-      /* token could be hspace at the beginning of a macro.  */\n-      if (token == CPP_HSPACE || token == CPP_COMMENT)\n-\t{\n-\t  CPP_SET_WRITTEN (pfile, old_written);\n-\t  continue;\n-\t}\n+    case CPP_VSPACE:\n+      /* Put it back and return VSPACE.  */\n+      FORWARD(-1);\n+      CPP_ADJUST_WRITTEN (pfile, -1);\n+      return CPP_VSPACE;\n \n-      /* token cannot be vspace, it would have been caught above.  */\n-      if (token == CPP_VSPACE)\n+    case CPP_HSPACE:\n+      if (CPP_PEDANTIC (pfile))\n \t{\n-\t  cpp_ice (pfile, \"VSPACE in get_directive_token\");\n-\t  return token;\n+\t  U_CHAR *p, *limit;\n+\t  p = pfile->token_buffer + old_written;\n+\t  limit = CPP_PWRITTEN (pfile);\n+\t  while (p < limit)\n+\t    {\n+\t      if (*p == '\\v' || *p == '\\f')\n+\t\tcpp_pedwarn (pfile, \"%s in preprocessing directive\",\n+\t\t\t     *p == '\\f' ? \"formfeed\" : \"vertical tab\");\n+\t      p++;\n+\t    }\n \t}\n+      return CPP_HSPACE;\n \n-      /* token cannot be POP unless the buffer is a macro buffer.  */\n-      if (token != CPP_POP)\n-\treturn token;\n+    case CPP_DIRECTIVE:\n+      /* Don't execute the directive, but don't smash it to OTHER either.  */\n+      CPP_PUTC (pfile, '#');\n+      return CPP_DIRECTIVE;\n+\n+    case CPP_MACRO:\n+      if (! pfile->no_macro_expand\n+\t  && maybe_macroexpand (pfile, old_written))\n+\tgoto get_next;\n+      return CPP_NAME;\n \n-      if (! CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n+    case CPP_EOF:\n+      if (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n \t{\n-\t  cpp_ice (pfile, \"POP of file buffer in get_directive_token\");\n-\t  return token;\n+\t  cpp_pop_buffer (pfile);\n+\t  goto get_next;\n \t}\n+      else\n+\t/* This can happen for files that don't end with a newline,\n+\t   and for cpp_define and friends.  Pretend they do, so\n+\t   callers don't have to deal.  A warning will be issued by\n+\t   someone else, if necessary.  */\n+\treturn CPP_VSPACE;\n+    }\n+}\n+\n+/* Just like _cpp_get_define_token except that it discards horizontal\n+   whitespace.  */\n \n-      /* We must pop the buffer by hand, or else cpp_get_token might\n-\t hand us white space or newline on the next invocation.  */\n-      cpp_pop_buffer (pfile);\n+enum cpp_token\n+_cpp_get_directive_token (pfile)\n+     cpp_reader *pfile;\n+{\n+  int old_written = CPP_WRITTEN (pfile);\n+  for (;;)\n+    {\n+      enum cpp_token token = _cpp_get_define_token (pfile);\n+      if (token != CPP_COMMENT && token != CPP_HSPACE)\n+\treturn token;\n+      CPP_SET_WRITTEN (pfile, old_written);\n     }\n }\n "}, {"sha": "52e83ba3a4cb0cf6cc203eeddd11728177937e8c", "filename": "gcc/cpplib.c", "status": "modified", "additions": 312, "deletions": 273, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ff2b53efb181ba999c0a4ceb4c473757c3ad8fda", "patch": "@@ -28,12 +28,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #include \"symcat.h\"\n \n-#define PEEKN(N) (CPP_BUFFER (pfile)->rlimit - CPP_BUFFER (pfile)->cur >= (N) \\\n-\t\t  ? CPP_BUFFER (pfile)->cur[N] : EOF)\n-#define FORWARD(N) CPP_FORWARD (CPP_BUFFER (pfile), (N))\n-#define GETC() CPP_BUF_GET (CPP_BUFFER (pfile))\n-#define PEEKC() CPP_BUF_PEEK (CPP_BUFFER (pfile))\n-\n /* `struct directive' defines one #-directive, including how to handle it.  */\n \n struct directive\n@@ -63,9 +57,9 @@ typedef struct if_stack IF_STACK;\n static void validate_else\t\tPARAMS ((cpp_reader *, const char *));\n static int parse_ifdef\t\t\tPARAMS ((cpp_reader *, const char *));\n static unsigned int parse_include\tPARAMS ((cpp_reader *, const char *));\n-static void conditional_skip\t\tPARAMS ((cpp_reader *, int, int,\n+static int conditional_skip\t\tPARAMS ((cpp_reader *, int, int,\n \t\t\t\t\t\t U_CHAR *));\n-static void skip_if_group\t\tPARAMS ((cpp_reader *));\n+static int skip_if_group\t\tPARAMS ((cpp_reader *));\n static void pass_thru_directive\t\tPARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t\t cpp_reader *, int));\n static int read_line_number\t\tPARAMS ((cpp_reader *, int *));\n@@ -74,8 +68,14 @@ static int consider_directive_while_skipping\n \t\t\t\t\tPARAMS ((cpp_reader *, IF_STACK *));\n static int get_macro_name\t\tPARAMS ((cpp_reader *));\n \n-/* Values for the \"origin\" field of the table below.  */\n-enum { KANDR = 0, STDC89, EXTENSION };\n+/* Values for the \"origin\" field of the table below.  KANDR and COND\n+   directives come from traditional (K&R) C.  The difference is, if we\n+   care about it while skipping a failed conditional block, its origin\n+   is COND.  STDC89 directives come from the 1989 C standard.\n+   EXTENSION directives are extensions, with origins noted below.  */\n+enum { KANDR = 0, COND, STDC89, EXTENSION };\n+\n+#define TRAD_DIRECT_P(x) ((x) == KANDR || (x) == COND)\n \n /* This is the table of directive handlers.  It is ordered by\n    frequency of occurrence; the numbers at the end are directive\n@@ -95,16 +95,16 @@ enum { KANDR = 0, STDC89, EXTENSION };\n #endif\n \n #define DIRECTIVE_TABLE\t\t\t\t\t\t\t\\\n-D(define,\tT_DEFINE,\tKANDR)\t\t/* 270554 */\t\t\\\n+D(define,\tT_DEFINE = 0,\tKANDR)\t\t/* 270554 */\t\t\\\n D(include,\tT_INCLUDE,\tKANDR)\t\t/*  52262 */\t\t\\\n-D(endif,\tT_ENDIF,\tKANDR)\t\t/*  45855 */\t\t\\\n-D(ifdef,\tT_IFDEF,\tKANDR)\t\t/*  22000 */\t\t\\\n-D(if,\t\tT_IF,\t\tKANDR)\t\t/*  18162 */\t\t\\\n-D(else,\t\tT_ELSE,\t\tKANDR)\t\t/*   9863 */\t\t\\\n-D(ifndef,\tT_IFNDEF,\tKANDR)\t\t/*   9675 */\t\t\\\n+D(endif,\tT_ENDIF,\tCOND)\t\t/*  45855 */\t\t\\\n+D(ifdef,\tT_IFDEF,\tCOND)\t\t/*  22000 */\t\t\\\n+D(if,\t\tT_IF,\t\tCOND)\t\t/*  18162 */\t\t\\\n+D(else,\t\tT_ELSE,\t\tCOND)\t\t/*   9863 */\t\t\\\n+D(ifndef,\tT_IFNDEF,\tCOND)\t\t/*   9675 */\t\t\\\n D(undef,\tT_UNDEF,\tKANDR)\t\t/*   4837 */\t\t\\\n D(line,\t\tT_LINE,\t\tKANDR)\t\t/*   2465 */\t\t\\\n-D(elif,\t\tT_ELIF,\t\tKANDR)\t\t/*    610 */\t\t\\\n+D(elif,\t\tT_ELIF,\t\tCOND)\t\t/*    610 */\t\t\\\n D(error,\tT_ERROR,\tSTDC89)\t\t/*    475 */\t\t\\\n D(pragma,\tT_PRAGMA,\tSTDC89)\t\t/*    195 */\t\t\\\n D(warning,\tT_WARNING,\tEXTENSION)\t/*     22 - GNU   */\t\\\n@@ -152,30 +152,38 @@ int\n _cpp_handle_directive (pfile)\n      cpp_reader *pfile;\n {\n-  int c, i;\n+  int i;\n   int hash_at_bol;\n   unsigned int len;\n   U_CHAR *ident;\n   long old_written = CPP_WRITTEN (pfile);\n+  enum cpp_token tok;\n \n   if (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n     {\n       cpp_ice (pfile, \"handle_directive called on macro buffer\");\n       return 0;\n     }\n \n-  /* -traditional directives are recognized only with the # in column 1.\n-     XXX Layering violation.  */\n-  hash_at_bol = (CPP_BUFFER (pfile)->cur - CPP_BUFFER (pfile)->line_base == 1);\n-  \n-  _cpp_skip_hspace (pfile);\n+  /* -traditional directives are recognized only with the # in column 1.  */\n+  hash_at_bol = CPP_IN_COLUMN_1 (pfile);\n+\n+  /* Scan the next token, then pretend we didn't.  */\n+  CPP_SET_MARK (pfile);\n+  pfile->no_macro_expand++;\n+  tok = _cpp_get_directive_token (pfile);\n+  pfile->no_macro_expand--;\n+\n+  ident = pfile->token_buffer + old_written;\n+  len = CPP_PWRITTEN (pfile) - ident;\n+  CPP_SET_WRITTEN (pfile, old_written);\n+  CPP_GOTO_MARK (pfile);\n \n-  c = PEEKC ();\n   /* # followed by a number is equivalent to #line.  Do not recognize\n      this form in assembly language source files.  Complain about this\n      form if we're being pedantic, but not if this is regurgitated\n      input (preprocessed or fed back in by the C++ frontend).  */\n-  if (c >= '0' && c <= '9')\n+  if (tok == CPP_NUMBER)\n     {\n       if (CPP_OPTION (pfile, lang_asm))\n \treturn 0;\n@@ -190,62 +198,86 @@ _cpp_handle_directive (pfile)\n \n   /* If we are rescanning preprocessed input, don't obey any directives\n      other than # nnn.  */\n-  if (CPP_OPTION (pfile, preprocessed))\n+  else if (CPP_OPTION (pfile, preprocessed))\n     return 0;\n \n-  /* Now find the directive name.  */\n-  CPP_PUTC (pfile, '#');\n-  _cpp_parse_name (pfile, GETC());\n-  ident = pfile->token_buffer + old_written + 1;\n-  len = CPP_PWRITTEN (pfile) - ident;\n-  if (len == 0)\n+  /* A line of just # becomes blank.  */\n+  else if (tok == CPP_VSPACE)\n+    return 1;\n+\n+  /* A NAME token might in fact be a directive!  */\n+  else if (tok == CPP_NAME)\n     {\n-      /* A line of just # becomes blank.  A line with something\n-\t other than an identifier after the # is reparsed as a non-\n-\t directive line.  */\n-      CPP_SET_WRITTEN (pfile, old_written);\n-      return (PEEKC() == '\\n');\n+      for (i = 0; i < N_DIRECTIVES; i++)\n+\t{\n+\t  if (dtable[i].length == len\n+\t      && !strncmp (dtable[i].name, ident, len)) \n+\t    goto real_directive;\n+\t}\n+      /* Don't complain about invalid directives in assembly source,\n+\t we don't know where the comments are, and # may introduce\n+\t assembler pseudo-ops.  */\n+      if (!CPP_OPTION (pfile, lang_asm))\n+\tcpp_error (pfile, \"invalid preprocessing directive #%s\", ident);\n+      return 0;\n     }\n+  /* And anything else means the # wasn't a directive marker.   */\n+  else\n+    return 0;\n \n-  /* Decode the keyword and call the appropriate expansion routine.  */\n-  for (i = 0; i < N_DIRECTIVES; i++)\n+ real_directive:\n+\n+  /* In -traditional mode, a directive is ignored unless its # is in\n+     column 1.  */\n+  if (CPP_TRADITIONAL (pfile) && !hash_at_bol)\n     {\n-      if (dtable[i].length == len\n-\t  && !strncmp (dtable[i].name, ident, len)) \n-\tbreak;\n+      if (CPP_WTRADITIONAL (pfile))\n+\tcpp_warning (pfile, \"ignoring #%s because of its indented #\",\n+\t\t     dtable[i].name);\n+      return 0;\n     }\n-  if (i == N_DIRECTIVES)\n-    /* # identifier, but not a legit directive.  Pass onward as a\n-       CPP_DIRECTIVE token anyway - let the consumer worry about it.  */\n-    return 1;\n-\n-  CPP_SET_WRITTEN (pfile, old_written);\n \n+  /* no_directives is set when we are parsing macro arguments.  Directives\n+     in macro arguments are undefined behavior (C99 6.10.3.11); this\n+     implementation chooses to make them hard errors.  */\n   if (pfile->no_directives)\n     {\n-      cpp_error (pfile, \"`#%s' may not be used inside a macro argument\",\n+      cpp_error (pfile, \"#%s may not be used inside a macro argument\",\n \t\t dtable[i].name);\n       _cpp_skip_rest_of_line (pfile);\n       return 1;\n     }\n \n+  /* Issue -pedantic warnings for extended directives.   */\n   if (CPP_PEDANTIC (pfile) && dtable[i].origin == EXTENSION)\n     cpp_pedwarn (pfile, \"ISO C does not allow #%s\", dtable[i].name);\n+\n+  /* -Wtraditional gives warnings about directives with inappropriate\n+     indentation of #.  */\n   if (CPP_WTRADITIONAL (pfile))\n     {\n-      if (!hash_at_bol && dtable[i].origin == KANDR)\n+      if (!hash_at_bol && TRAD_DIRECT_P (dtable[i].origin))\n \tcpp_warning (pfile, \"traditional C ignores #%s with the # indented\",\n \t\t     dtable[i].name);\n-      else if (hash_at_bol && dtable[i].origin != KANDR)\n+      else if (hash_at_bol && ! TRAD_DIRECT_P (dtable[i].origin))\n \tcpp_warning (pfile,\n-\t\t     \"traditional C rejects #%s unless the # is indented\",\n+\t\t\"suggest hiding #%s from traditional C with an indented #\",\n \t\t     dtable[i].name);\n     }\n \n-  if (CPP_TRADITIONAL (pfile) && !hash_at_bol)\n-    return 0;\n+  /* Unfortunately, it's necessary to scan the directive name again,\n+     now we know we're going to consume it.  FIXME.  */\n+\n+  pfile->no_macro_expand++;\n+  _cpp_get_directive_token (pfile);\n+  pfile->no_macro_expand--;\n+  CPP_SET_WRITTEN (pfile, old_written);\n \n-  (*dtable[i].func) (pfile);\n+  /* Some directives (e.g. #if) may return a request to execute\n+     another directive handler immediately.  No directive ever\n+     requests that #define be executed immediately, so it is safe for\n+     the loop to terminate when some function returns 0 (== T_DEFINE).  */\n+  while ((i = dtable[i].func (pfile)));\n   return 1;\n }\n \n@@ -282,7 +314,6 @@ get_macro_name (pfile)\n   long here, len;\n \n   here = CPP_WRITTEN (pfile);\n-  pfile->no_macro_expand++;\n   if (_cpp_get_directive_token (pfile) != CPP_NAME)\n     {\n       cpp_error (pfile, \"`#define' must be followed by an identifier\");\n@@ -296,12 +327,10 @@ get_macro_name (pfile)\n       goto invalid;\n     }\n \n-  pfile->no_macro_expand--;\n   return len;\n \n  invalid:\n   _cpp_skip_rest_of_line (pfile);\n-  pfile->no_macro_expand--;\n   return 0;\n }\n \n@@ -312,38 +341,52 @@ do_define (pfile)\n      cpp_reader *pfile;\n {\n   HASHNODE **slot;\n-  DEFINITION *def;\n+  DEFINITION *def = 0;\n   long here;\n   unsigned long hash;\n-  int len, c;\n-  int funlike = 0;\n+  int len;\n+  int funlike = 0, empty = 0;\n   U_CHAR *sym;\n+  enum cpp_token token;\n+\n+  pfile->no_macro_expand++;\n+  pfile->parsing_define_directive++;\n+  CPP_OPTION (pfile, discard_comments)++;\n+  CPP_OPTION (pfile, no_line_commands)++;\n \n   here = CPP_WRITTEN (pfile);\n   len = get_macro_name (pfile);\n   if (len == 0)\n-    return 0;\n+    goto out;\n \n   /* Copy out the name so we can pop the token buffer.  */\n   len = CPP_WRITTEN (pfile) - here;\n   sym = (U_CHAR *) alloca (len + 1);\n   memcpy (sym, pfile->token_buffer + here, len);\n   sym[len] = '\\0';\n-  CPP_SET_WRITTEN (pfile, here);\n \n   /* If the next character, with no intervening whitespace, is '(',\n-     then this is a function-like macro.  */\n-  c = PEEKC ();\n-  if (c == '(')\n+     then this is a function-like macro.\n+     XXX Layering violation.  */\n+  CPP_SET_MARK (pfile);\n+  token = _cpp_get_directive_token (pfile);\n+  if (token == CPP_VSPACE)\n+    empty = 0;  /* Empty definition of object like macro.  */\n+  else if (token == CPP_LPAREN && ADJACENT_TO_MARK (pfile))\n     funlike = 1;\n-  else if (c != '\\n' && !is_hspace (c))\n-    /* Otherwise, C99 requires white space after the name.  We treat it\n-       as an object-like macro if this happens, with a warning.  */\n+  else if (ADJACENT_TO_MARK (pfile))\n+    /* If this is an object-like macro, C99 requires white space after\n+       the name.  */\n     cpp_pedwarn (pfile, \"missing white space after `#define %.*s'\", len, sym);\n+  CPP_GOTO_MARK (pfile);\n+  CPP_SET_WRITTEN (pfile, here);\n \n-  def = _cpp_create_definition (pfile, funlike);\n-  if (def == 0)\n-    return 0;\n+  if (! empty)\n+    {\n+      def = _cpp_create_definition (pfile, funlike);\n+      if (def == 0)\n+\tgoto out;\n+    }\n \n   slot = _cpp_lookup_slot (pfile, sym, len, 1, &hash);\n   if (*slot)\n@@ -353,7 +396,9 @@ do_define (pfile)\n \n       /* Redefining a macro is ok if the definitions are the same.  */\n       if (hp->type == T_MACRO)\n-\tok = ! _cpp_compare_defs (pfile, def, hp->value.defn);\n+\tok = ! empty && ! _cpp_compare_defs (pfile, def, hp->value.defn);\n+      else if (hp->type == T_EMPTY)\n+\tok = empty;\n       /* Redefining a constant is ok with -D.  */\n       else if (hp->type == T_CONST || hp->type == T_STDC)\n         ok = ! pfile->done_initializing;\n@@ -379,8 +424,16 @@ do_define (pfile)\n \t  /* Replace the old definition.  */\n \t  if (hp->type == T_MACRO)\n \t    _cpp_free_definition (hp->value.defn);\n-\t  hp->type = T_MACRO;\n-\t  hp->value.defn = def;\n+\t  if (empty)\n+\t    {\n+\t      hp->type = T_EMPTY;\n+\t      hp->value.defn = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      hp->type = T_MACRO;\n+\t      hp->value.defn = def;\n+\t    }\n \t}\n     }\n   else\n@@ -396,6 +449,11 @@ do_define (pfile)\n   else if (CPP_OPTION (pfile, dump_macros) == dump_names)\n     pass_thru_directive (sym, len, pfile, T_DEFINE);\n \n+ out:\n+  pfile->no_macro_expand--;\n+  pfile->parsing_define_directive--;\n+  CPP_OPTION (pfile, discard_comments)--;\n+  CPP_OPTION (pfile, no_line_commands)--;\n   return 0;\n }\n \n@@ -774,50 +832,45 @@ do_undef (pfile)\n {\n   int len;\n   HASHNODE **slot;\n-  U_CHAR *buf, *name, *limit;\n-  int c;\n+  U_CHAR *name;\n   long here = CPP_WRITTEN (pfile);\n   enum cpp_token token;\n \n-  _cpp_skip_hspace (pfile);\n-  c = GETC();\n-  if (! is_idstart(c))\n-  {\n+  pfile->no_macro_expand++;\n+  token = _cpp_get_directive_token (pfile);\n+  pfile->no_macro_expand--;\n+\n+  if (token != CPP_NAME)\n+    {\n       cpp_error (pfile, \"token after #undef is not an identifier\");\n       _cpp_skip_rest_of_line (pfile);\n-      return 1;\n-  }\n-\n-  _cpp_parse_name (pfile, c);\n-  buf = pfile->token_buffer + here;\n-  limit = CPP_PWRITTEN(pfile);\n-\n-  /* Copy out the token so we can pop the token buffer. */\n-  len = limit - buf;\n-  name = (U_CHAR *) alloca (len + 1);\n-  memcpy (name, buf, len);\n-  name[len] = '\\0';\n+      return 0;\n+    }\n+  len = CPP_WRITTEN (pfile) - here;\n \n   token = _cpp_get_directive_token (pfile);\n   if (token != CPP_VSPACE)\n   {\n       cpp_pedwarn (pfile, \"junk on line after #undef\");\n       _cpp_skip_rest_of_line (pfile);\n   }\n+\n+  name = pfile->token_buffer + here;\n   CPP_SET_WRITTEN (pfile, here);\n \n   slot = _cpp_lookup_slot (pfile, name, len, 0, 0);\n   if (slot)\n     {\n       HASHNODE *hp = *slot;\n-      /* If we are generating additional info for debugging (with -g) we\n-\t need to pass through all effective #undef commands.  */\n-      if (CPP_OPTION (pfile, debug_output))\n-\tpass_thru_directive (name, len, pfile, T_UNDEF);\n       if (hp->type == T_POISON)\n \tcpp_error (pfile, \"cannot undefine poisoned `%s'\", hp->name);\n-      else \n+      else\n \t{\n+\t  /* If we are generating additional info for debugging (with -g) we\n+\t     need to pass through all effective #undef commands.  */\n+\t  if (CPP_OPTION (pfile, debug_output))\n+\t    pass_thru_directive (hp->name, len, pfile, T_UNDEF);\n+\n \t  if (hp->type != T_MACRO)\n \t    cpp_warning (pfile, \"undefining `%s'\", hp->name);\n \n@@ -1184,8 +1237,7 @@ do_if (pfile)\n {\n   U_CHAR *control_macro = detect_if_not_defined (pfile);\n   int value = _cpp_parse_expr (pfile);\n-  conditional_skip (pfile, value == 0, T_IF, control_macro);\n-  return 0;\n+  return conditional_skip (pfile, value == 0, T_IF, control_macro);\n }\n \n /*\n@@ -1214,17 +1266,11 @@ do_elif (pfile)\n     }\n \n   if (pfile->if_stack->if_succeeded)\n-    skip_if_group (pfile);\n-  else\n-    {\n-      if (_cpp_parse_expr (pfile) == 0)\n-\tskip_if_group (pfile);\n-      else\n-\t{\n-\t  ++pfile->if_stack->if_succeeded;\t/* continue processing input */\n-\t  _cpp_output_line_command (pfile, same_file);\n-\t}\n-    }\n+    return skip_if_group (pfile);\n+  if (_cpp_parse_expr (pfile) == 0)\n+    return skip_if_group (pfile);\n+\n+  ++pfile->if_stack->if_succeeded;\t/* continue processing input */\n   return 0;\n }\n \n@@ -1291,8 +1337,7 @@ do_ifdef (pfile)\n      cpp_reader *pfile;\n {\n   int skip = ! parse_ifdef (pfile, dtable[T_IFDEF].name);\n-  conditional_skip (pfile, skip, T_IFDEF, 0);\n-  return 0;\n+  return conditional_skip (pfile, skip, T_IFDEF, 0);\n }\n \n /* #ifndef is a tad more complex, because we need to check for a\n@@ -1311,16 +1356,15 @@ do_ifndef (pfile)\n   if (start_of_file && !skip)\n     control_macro = (U_CHAR *) xstrdup (CPP_PWRITTEN (pfile));\n \n-  conditional_skip (pfile, skip, T_IFNDEF, control_macro);\n-  return 0;\n+  return conditional_skip (pfile, skip, T_IFNDEF, control_macro);\n }\n \n /* Push TYPE on stack; then, if SKIP is nonzero, skip ahead.\n    If this is a #ifndef starting at the beginning of a file,\n    CONTROL_MACRO is the macro name tested by the #ifndef.\n    Otherwise, CONTROL_MACRO is 0.  */\n \n-static void\n+static int\n conditional_skip (pfile, skip, type, control_macro)\n      cpp_reader *pfile;\n      int skip;\n@@ -1337,139 +1381,154 @@ conditional_skip (pfile, skip, type, control_macro)\n \n   pfile->if_stack->type = type;\n \n-  if (skip != 0) {\n-    skip_if_group (pfile);\n-    return;\n-  } else {\n-    ++pfile->if_stack->if_succeeded;\n-    _cpp_output_line_command (pfile, same_file);\n-  }\n+  if (skip != 0)\n+    return skip_if_group (pfile);\n+\n+  ++pfile->if_stack->if_succeeded;\n+  return 0;\n }\n \n-/* Subroutine of skip_if_group.\t Examine one preprocessing directive and\n-   return 0 if skipping should continue, 1 if it should halt.  Also\n-   adjusts the if_stack as appropriate.\n-   The `#' has been read, but not the identifier. */\n+/* Subroutine of skip_if_group.  Examine one preprocessing directive\n+   and return 0 if skipping should continue, or the directive number\n+   of the directive that ends the block if it should halt.\n+\n+   Also adjusts the if_stack as appropriate.  The `#' has been read,\n+   but not the identifier. */\n \n static int\n consider_directive_while_skipping (pfile, stack)\n     cpp_reader *pfile;\n     IF_STACK *stack; \n {\n   long ident;\n-  const struct directive *kt;\n-  int i;\n+  int i, hash_at_bol;\n   unsigned int len;\n   IF_STACK *temp;\n-    \n-  _cpp_skip_hspace (pfile);\n+\n+  /* -traditional directives are recognized only with the # in column 1.  */\n+  hash_at_bol = CPP_IN_COLUMN_1 (pfile);\n \n   ident = CPP_WRITTEN (pfile);\n-  _cpp_parse_name (pfile, GETC());\n+  if (_cpp_get_directive_token (pfile) != CPP_NAME)\n+    return 0;\n   len = CPP_WRITTEN (pfile) - ident;\n \n-  CPP_SET_WRITTEN (pfile, ident);\n-\n   for (i = 0; i < N_DIRECTIVES; i++)\n     {\n-      kt = &dtable[i];\n-      if (kt->length == len\n-\t  && strncmp (pfile->token_buffer + ident, kt->name, kt->length) == 0)\n-\tswitch (i)\n-\t  {\n-\t  case T_IF:\n-\t  case T_IFDEF:\n-\t  case T_IFNDEF:\n-\t    temp = (IF_STACK *) xmalloc (sizeof (IF_STACK));\n-\t    temp->next = pfile->if_stack;\n-\t    pfile->if_stack = temp;\n-\t    temp->type = i;\n-\t    return 0;\n-\n-\t  case T_ELSE:\n-\t    if (pfile->if_stack != stack)\n-\t      validate_else (pfile, dtable[i].name);\n-\t    /* fall through */\n-\t  case T_ELIF:\n-\t    if (pfile->if_stack == stack)\n-\t      return 1;\n-\t    else\n-\t      {\n-\t\tpfile->if_stack->type = i;\n-\t\treturn 0;\n-\t      }\n-\n-\t  case T_ENDIF:\n-\t    if (pfile->if_stack != stack)\n-\t      validate_else (pfile, dtable[i].name);\n-\n-\t    if (pfile->if_stack == stack)\n-\t      return 1;\n-\t\t    \n-\t    temp = pfile->if_stack;\n-\t    pfile->if_stack = temp->next;\n-\t    free (temp);\n-\t    return 0;\n-\n-\t  default:\n-\t    return 0;\n-\t  }\n+      if (dtable[i].length == len\n+\t  && !strncmp (dtable[i].name, pfile->token_buffer + ident, len)) \n+\tgoto real_directive;\n     }\n+  return 0;\n+\n+ real_directive:\n \n-    /* Don't let erroneous code go by.\t*/\n-    if (!CPP_OPTION (pfile, lang_asm) && CPP_PEDANTIC (pfile))\n-\tcpp_pedwarn (pfile, \"invalid preprocessor directive name\");\n+  /* If it's not a directive of interest to us, return now.  */\n+  if (dtable[i].origin != COND)\n     return 0;\n+\n+  /* First, deal with -traditional and -Wtraditional.\n+     All COND directives are from K+R.  */\n+\n+  if (! hash_at_bol)\n+    {\n+      if (CPP_TRADITIONAL (pfile))\n+\t{\n+\t  if (CPP_WTRADITIONAL (pfile))\n+\t    cpp_warning (pfile, \"ignoring #%s because of its indented #\",\n+\t\t\t dtable[i].name);\n+\t  return 0;\n+\t}\n+      if (CPP_WTRADITIONAL (pfile))\n+\tcpp_warning (pfile, \"traditional C ignores %s with the # indented\",\n+\t\t     dtable[i].name);\n+    }\n+  \n+  switch (i)\n+    {\n+    default:\n+      cpp_ice (pfile, \"non COND directive in switch in c_d_w_s\");\n+      return 0;\n+\n+    case T_IF:\n+    case T_IFDEF:\n+    case T_IFNDEF:\n+      temp = (IF_STACK *) xcalloc (1, sizeof (IF_STACK));\n+      temp->lineno = CPP_BUFFER (pfile)->lineno;\n+      temp->next = pfile->if_stack;\n+      temp->type = i;\n+      pfile->if_stack = temp;\n+      return 0;\n+\n+    case T_ELSE:\n+      if (pfile->if_stack != stack)\n+\tvalidate_else (pfile, dtable[i].name);\n+      /* fall through */\n+    case T_ELIF:\n+      if (pfile->if_stack == stack)\n+\treturn i;\n+\n+      pfile->if_stack->type = i;\n+      return 0;\n+\n+    case T_ENDIF:\n+      if (pfile->if_stack != stack)\n+\tvalidate_else (pfile, dtable[i].name);\n+\n+      if (pfile->if_stack == stack)\n+\treturn i;\n+\t\t    \n+      temp = pfile->if_stack;\n+      pfile->if_stack = temp->next;\n+      free (temp);\n+      return 0;\n+    }\n }\n \n-/* skip to #endif, #else, or #elif.  adjust line numbers, etc.\n- * leaves input ptr at the sharp sign found.\n- */\n-static void\n+/* Skip to #endif, #else, or #elif.  Consumes the directive that\n+   causes it to stop, but not its argument.  Returns the number of\n+   that directive, which must be passed back up to\n+   _cpp_handle_directive, which will execute it.  */\n+static int\n skip_if_group (pfile)\n     cpp_reader *pfile;\n {\n-  int c;\n+  enum cpp_token token;\n   IF_STACK *save_if_stack = pfile->if_stack; /* don't pop past here */\n-  const U_CHAR *beg_of_line;\n   long old_written;\n+  int ret = 0;\n \n   old_written = CPP_WRITTEN (pfile);\n-  \n+  pfile->no_macro_expand++;\n+  CPP_OPTION (pfile, no_line_commands)++;\n   for (;;)\n     {\n-      beg_of_line = CPP_BUFFER (pfile)->cur;\n+      token = _cpp_get_directive_token (pfile);\n \n-      if (! CPP_TRADITIONAL (pfile))\n-\t_cpp_skip_hspace (pfile);\n-      c = GETC();\n-      if (c == '\\n')\n+      if (token == CPP_DIRECTIVE)\n \t{\n-\t  CPP_BUMP_LINE (pfile);\n-\t  continue;\n-\t}\n-      else if (c == '#')\n-\t{\n-\t  if (consider_directive_while_skipping (pfile, save_if_stack))\n+\t  ret = consider_directive_while_skipping (pfile, save_if_stack);\n+\t  if (ret)\n \t    break;\n \t}\n-      else if (c == EOF)\n-\treturn;\t /* Caller will issue error. */\n-\n-      FORWARD(-1);\n-      _cpp_skip_rest_of_line (pfile);\n \n-      c = GETC();\n-      if (c == EOF)\n-\treturn;\t /* Caller will issue error. */\n-      else\n-\tCPP_BUMP_LINE (pfile);\n-    }\t  \n+      if (token != CPP_VSPACE)\n+\t_cpp_skip_rest_of_line (pfile);\n \n-  /* Back up to the beginning of this line.  Caller will process the\n-     directive. */\n-  CPP_BUFFER (pfile)->cur = beg_of_line;\n-  pfile->only_seen_white = 1;\n+      /* Only cpp_get_token knows how to advance the line number\n+\t properly.  */\n+      token = cpp_get_token (pfile);\n+      if (token == CPP_POP)\n+\tbreak;  /* Caller will issue error.  */\n+      \n+      else if (token != CPP_VSPACE)\n+\tcpp_ice (pfile, \"cpp_get_token returned %d in skip_if_group\", token);\n+      CPP_SET_WRITTEN (pfile, old_written);\n+    }\n+  CPP_SET_WRITTEN (pfile, old_written);\n+  pfile->no_macro_expand--;\n+  CPP_OPTION (pfile, no_line_commands)--;\n+  return ret;\n }\n \n /*\n@@ -1507,12 +1566,9 @@ do_else (pfile)\n     }\n \n   if (pfile->if_stack->if_succeeded)\n-    skip_if_group (pfile);\n-  else\n-    {\n-      ++pfile->if_stack->if_succeeded;\t/* continue processing input */\n-      _cpp_output_line_command (pfile, same_file);\n-    }\n+    return skip_if_group (pfile);\n+  \n+  ++pfile->if_stack->if_succeeded;\t/* continue processing input */\n   return 0;\n }\n \n@@ -1534,33 +1590,8 @@ do_endif (pfile)\n       IF_STACK *temp = pfile->if_stack;\n       pfile->if_stack = temp->next;\n       if (temp->control_macro != 0)\n-\t{\n-\t  /* This #endif matched a #ifndef at the start of the file.\n-\t     See if it is at the end of the file.  */\n-\t  int c;\n-\n-\t  CPP_SET_MARK (pfile);\n-\n-\t  for (;;)\n-\t    {\n-\t      _cpp_skip_hspace (pfile);\n-\t      c = GETC ();\n-\t      if (c != '\\n')\n-\t\tbreak;\n-\t    }\n-\t  CPP_GOTO_MARK (pfile);\n-\n-\t  if (c == EOF)\n-\t    {\n-\t      /* This #endif ends a #ifndef\n-\t\t that contains all of the file (aside from whitespace).\n-\t\t Arrange not to include the file again\n-\t\t if the macro that was tested is defined. */\n-\t      CPP_BUFFER (pfile)->ihash->control_macro = temp->control_macro;\n-\t    }\n-        }\n+\tpfile->potential_control_macro = temp->control_macro;\n       free (temp);\n-      _cpp_output_line_command (pfile, same_file);\n     }\n   return 0;\n }\n@@ -1574,13 +1605,17 @@ validate_else (pfile, directive)\n      cpp_reader *pfile;\n      const char *directive;\n {\n+  long old_written;\n   if (! CPP_PEDANTIC (pfile))\n     return;\n \n-  _cpp_skip_hspace (pfile);\n-  if (PEEKC () != '\\n')\n+  old_written = CPP_WRITTEN (pfile);\n+  pfile->no_macro_expand++;\n+  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n     cpp_pedwarn (pfile,\n \t\t \"text following `#%s' violates ANSI standard\", directive);\n+  CPP_SET_WRITTEN (pfile, old_written);\n+  pfile->no_macro_expand--;\n }\n \n void\n@@ -1604,6 +1639,13 @@ _cpp_handle_eof (pfile)\n     }\n   pfile->if_stack = ifs;\n \n+  if (pfile->potential_control_macro)\n+    {\n+      CPP_BUFFER (pfile)->ihash->control_macro\n+\t= pfile->potential_control_macro;\n+      pfile->potential_control_macro = 0;\n+    }\n+\n   if (CPP_BUFFER (pfile)->nominal_fname && next_buf != NULL)\n     {\n       /* We're about to return from an #include file.\n@@ -1623,38 +1665,37 @@ static int\n do_assert (pfile)\n      cpp_reader *pfile;\n {\n+  long old_written;\n   U_CHAR *sym;\n-  int ret, c;\n+  int ret;\n   HASHNODE *base, *this;\n   HASHNODE **bslot, **tslot;\n   size_t blen, tlen;\n   unsigned long bhash, thash;\n \n-  _cpp_skip_hspace (pfile);\n-  sym = CPP_PWRITTEN (pfile);\t/* remember where it starts */\n+  old_written = CPP_WRITTEN (pfile);\t/* remember where it starts */\n   ret = _cpp_parse_assertion (pfile);\n   if (ret == 0)\n     goto error;\n   else if (ret == 1)\n     {\n-      cpp_error (pfile, \"missing token-sequence in `#assert'\");\n+      cpp_error (pfile, \"missing token-sequence in #assert\");\n       goto error;\n     }\n+  tlen = CPP_WRITTEN (pfile) - old_written;\n \n-  _cpp_skip_hspace (pfile);\n-  c = PEEKC();\n-  if (c != EOF && c != '\\n')\n+  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n     {\n-      cpp_error (pfile, \"junk at end of `#assert'\");\n+      cpp_error (pfile, \"junk at end of #assert\");\n       goto error;\n     }\n \n-  tlen = strlen (sym);\n+  sym = pfile->token_buffer + old_written;\n   blen = (U_CHAR *) strchr (sym, '(') - sym;\n   tslot = _cpp_lookup_slot (pfile, sym, tlen, 1, &thash);\n   if (*tslot)\n     {\n-      cpp_warning (pfile, \"`%s' re-asserted\", sym);\n+      cpp_warning (pfile, \"%s re-asserted\", sym);\n       goto error;\n     }\n \n@@ -1677,38 +1718,37 @@ do_assert (pfile)\n   *tslot = this = _cpp_make_hashnode (sym, tlen, T_ASSERT, thash);\n   this->value.aschain = base->value.aschain;\n   base->value.aschain = this;\n-  \n-  pfile->limit = sym;\t\t/* Pop */\n-  return 0;\n \n  error:\n   _cpp_skip_rest_of_line (pfile);\n-  pfile->limit = sym;\t\t/* Pop */\n+  CPP_SET_WRITTEN (pfile, old_written);\n   return 0;\n }\n \n static int\n do_unassert (pfile)\n      cpp_reader *pfile;\n {\n-  int c, ret;\n+  int ret;\n+  long old_written;\n   U_CHAR *sym;\n   long baselen, thislen;\n   HASHNODE *base, *this, *next;\n-  \n-  _cpp_skip_hspace (pfile);\n \n-  sym = CPP_PWRITTEN (pfile);\t/* remember where it starts */\n+  old_written = CPP_WRITTEN (pfile);\n   ret = _cpp_parse_assertion (pfile);\n   if (ret == 0)\n     goto error;\n-  \n-  _cpp_skip_hspace (pfile);\n-  c = PEEKC ();\n-  if (c != EOF && c != '\\n')\n-      cpp_error (pfile, \"junk at end of `#unassert'\");\n+  thislen = CPP_WRITTEN (pfile) - old_written;\n+\n+  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n+    {\n+      cpp_error (pfile, \"junk at end of #unassert\");\n+      goto error;\n+    }\n+  sym = pfile->token_buffer + old_written;\n+  CPP_SET_WRITTEN (pfile, old_written);\n \n-  thislen = strlen (sym);\n   if (ret == 1)\n     {\n       base = _cpp_lookup (pfile, sym, thislen);\n@@ -1743,12 +1783,11 @@ do_unassert (pfile)\n \t/* Last answer for this predicate deleted. */\n \thtab_remove_elt (pfile->hashtab, base);\n     }\n-  \n-  pfile->limit = sym;\t\t/* Pop */\n   return 0;\n+  \n  error:\n   _cpp_skip_rest_of_line (pfile);\n-  pfile->limit = sym;\t\t/* Pop */\n+  CPP_SET_WRITTEN (pfile, old_written);\n   return 0;\n }\n "}, {"sha": "8133d69af40c79ff0c7192ef09b53093dee791f9", "filename": "gcc/cpplib.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2b53efb181ba999c0a4ceb4c473757c3ad8fda/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=ff2b53efb181ba999c0a4ceb4c473757c3ad8fda", "patch": "@@ -67,8 +67,8 @@ struct cpp_buffer\n   const unsigned char *cur;\t /* current position */\n   const unsigned char *rlimit; /* end of valid data */\n   const unsigned char *buf;\t /* entire buffer */\n-  const unsigned char *alimit; /* end of allocated buffer */\n   const unsigned char *line_base; /* start of current line */\n+  const unsigned char *mark;  /* Saved position for lengthy backtrack. */\n \n   struct cpp_buffer *prev;\n \n@@ -84,10 +84,11 @@ struct cpp_buffer\n   struct ihash *ihash;\n \n   long lineno; /* Line number at CPP_LINE_BASE. */\n-  long colno; /* Column number at CPP_LINE_BASE. */\n-  long mark;  /* Saved position for lengthy backtrack. */\n   parse_cleanup_t cleanup;\n-  void *data;\n+\n+  /* If the buffer is the expansion of a macro, this points to the\n+     macro's hash table entry.  */\n+  struct hashnode *macro;\n \n   /* Value of if_stack at start of this file.\n      Used to prohibit unmatched #endif (etc) in an include file.  */\n@@ -347,6 +348,7 @@ struct cpp_reader\n   unsigned int max_include_len;\n \n   struct if_stack *if_stack;\n+  const unsigned char *potential_control_macro;\n \n   long lineno;\n "}]}