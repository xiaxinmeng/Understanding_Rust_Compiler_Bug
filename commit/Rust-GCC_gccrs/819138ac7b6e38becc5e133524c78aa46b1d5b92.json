{"sha": "819138ac7b6e38becc5e133524c78aa46b1d5b92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE5MTM4YWM3YjZlMzhiZWNjNWUxMzM1MjRjNzhhYTQ2YjFkNWI5Mg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-11-13T17:43:41Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-11-13T17:43:41Z"}, "message": "Makefile.in: Rebuilt.\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (ordinary_java_source_files): Added JNIWeakRef.java.\n\t* jni.cc: Include JNIWeakRef.h.\n\t(unwrap): New function.\n\t(_Jv_JNI_DefineClass): Use it.\n\t(_Jv_JNI_GetSuperclass): Likewise.\n\t(_Jv_JNI_IsAssignableFrom): Likewise.\n\t(_Jv_JNI_Throw): Likewise.\n\t(_Jv_JNI_ThrowNew): Likewise.\n\t(_Jv_JNI_IsSameObject): Likewise.\n\t(_Jv_JNI_AllocObject): Likewise.\n\t(_Jv_JNI_GetObjectClass): Likewise.\n\t(_Jv_JNI_IsInstanceOf): Likewise.\n\t(_Jv_JNI_GetAnyMethodID): Likewise.\n\t(array_from_valist): Likewise.\n\t(_Jv_JNI_CallAnyMethodV): Likewise.\n\t(_Jv_JNI_CallAnyMethodA): Likewise.\n\t(_Jv_JNI_CallAnyVoidMethodV): Likewise.\n\t(_Jv_JNI_CallAnyVoidMethodA): Likewise.\n\t(_Jv_JNI_CallStaticMethodV): Likewise.\n\t(_Jv_JNI_CallStaticMethod): Likewise.\n\t(_Jv_JNI_CallStaticMethodA): Likewise.\n\t(_Jv_JNI_NewObjectV): Likewise.\n\t(_Jv_JNI_NewObject): Likewise.\n\t(_Jv_JNI_NewObjectA): Likewise.\n\t(_Jv_JNI_GetField): Likewise.\n\t(_Jv_JNI_SetField): Likewise.\n\t(_Jv_JNI_GetAnyFieldID): Likewise.\n\t(_Jv_JNI_SetStaticField): Likewise.\n\t(_Jv_JNI_GetStringLength): Likewise.\n\t(_Jv_JNI_GetStringChars): Likewise.\n\t(_Jv_JNI_ReleaseStringChars): Likewise.\n\t(_Jv_JNI_GetStringUTFLength): Likewise\n\t(_Jv_JNI_GetStringUTFChars): Likewise.\n\t(_Jv_JNI_GetStringRegion): Likewise.\n\t(_Jv_JNI_GetStringUTFRegion): Likewise.\n\t(_Jv_JNI_GetStringCritical): Likewise.\n\t(_Jv_JNI_GetArrayLength): Likewise.\n\t(_Jv_JNI_NewObjectArray): Likewise.\n\t(_Jv_JNI_GetObjectArrayElement): Likewise.\n\t(_Jv_JNI_SetObjectArrayElement): Likewise.\n\t(_Jv_JNI_GetPrimitiveArrayElements): Likewise.\n\t(_Jv_JNI_ReleasePrimitiveArrayElements): Likewise.\n\t(_Jv_JNI_GetPrimitiveArrayRegion): Likewise.\n\t(_Jv_JNI_SetPrimitiveArrayRegion): Likewise.\n\t(_Jv_JNI_MonitorEnter): Likewise.\n\t(_Jv_JNI_MonitorExit): Likewise.\n\t(_Jv_JNI_ToReflectedField): Likewise.\n\t(_Jv_JNI_FromReflectedField): Likewise.\n\t(_Jv_JNI_ToReflectedMethod): Likewise.\n\t(_Jv_JNI_FromReflectedMethod): Likewise.\n\t(_Jv_JNI_NewGlobalRef): Likewise.\n\t(_Jv_JNI_DeleteGlobalRef): Likewise.\n\t(_Jv_JNI_DeleteLocalRef): Likewise.\n\t(_Jv_JNI_NewLocalRef): Likewise.\n\t(_Jv_JNI_NewWeakGlobalRef): New function.\n\t(_Jv_JNI_DeleteWeakGlobalRef): Likewise.\n\t(_Jv_JNIFunctions): Updated for new methods.\n\t(NOT_IMPL): Removed.\n\t* gnu/gcj/runtime/JNIWeakRef.java: New file.\n\nFrom-SVN: r46990", "tree": {"sha": "2690d4efad98af7f4c5f296174403fcb6141e75c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2690d4efad98af7f4c5f296174403fcb6141e75c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/819138ac7b6e38becc5e133524c78aa46b1d5b92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819138ac7b6e38becc5e133524c78aa46b1d5b92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/819138ac7b6e38becc5e133524c78aa46b1d5b92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819138ac7b6e38becc5e133524c78aa46b1d5b92/comments", "author": null, "committer": null, "parents": [{"sha": "89fc10a522f5cda8b2f303e0dcaf197037a9e918", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89fc10a522f5cda8b2f303e0dcaf197037a9e918", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89fc10a522f5cda8b2f303e0dcaf197037a9e918"}], "stats": {"total": 262, "additions": 241, "deletions": 21}, "files": [{"sha": "9dfcd7b32e9febe147c60b3a26b26a2118a4b535", "filename": "libjava/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819138ac7b6e38becc5e133524c78aa46b1d5b92/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819138ac7b6e38becc5e133524c78aa46b1d5b92/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=819138ac7b6e38becc5e133524c78aa46b1d5b92", "patch": "@@ -1,3 +1,66 @@\n+2001-11-07  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (ordinary_java_source_files): Added JNIWeakRef.java.\n+\t* jni.cc: Include JNIWeakRef.h.\n+\t(unwrap): New function.\n+\t(_Jv_JNI_DefineClass): Use it.\n+\t(_Jv_JNI_GetSuperclass): Likewise.\n+\t(_Jv_JNI_IsAssignableFrom): Likewise.\n+\t(_Jv_JNI_Throw): Likewise.\n+\t(_Jv_JNI_ThrowNew): Likewise.\n+\t(_Jv_JNI_IsSameObject): Likewise.\n+\t(_Jv_JNI_AllocObject): Likewise.\n+\t(_Jv_JNI_GetObjectClass): Likewise.\n+\t(_Jv_JNI_IsInstanceOf): Likewise.\n+\t(_Jv_JNI_GetAnyMethodID): Likewise.\n+\t(array_from_valist): Likewise.\n+\t(_Jv_JNI_CallAnyMethodV): Likewise.\n+\t(_Jv_JNI_CallAnyMethodA): Likewise.\n+\t(_Jv_JNI_CallAnyVoidMethodV): Likewise.\n+\t(_Jv_JNI_CallAnyVoidMethodA): Likewise.\n+\t(_Jv_JNI_CallStaticMethodV): Likewise.\n+\t(_Jv_JNI_CallStaticMethod): Likewise.\n+\t(_Jv_JNI_CallStaticMethodA): Likewise.\n+\t(_Jv_JNI_NewObjectV): Likewise.\n+\t(_Jv_JNI_NewObject): Likewise.\n+\t(_Jv_JNI_NewObjectA): Likewise.\n+\t(_Jv_JNI_GetField): Likewise.\n+\t(_Jv_JNI_SetField): Likewise.\n+\t(_Jv_JNI_GetAnyFieldID): Likewise.\n+\t(_Jv_JNI_SetStaticField): Likewise.\n+\t(_Jv_JNI_GetStringLength): Likewise.\n+\t(_Jv_JNI_GetStringChars): Likewise.\n+\t(_Jv_JNI_ReleaseStringChars): Likewise.\n+\t(_Jv_JNI_GetStringUTFLength): Likewise\n+\t(_Jv_JNI_GetStringUTFChars): Likewise.\n+\t(_Jv_JNI_GetStringRegion): Likewise.\n+\t(_Jv_JNI_GetStringUTFRegion): Likewise.\n+\t(_Jv_JNI_GetStringCritical): Likewise.\n+\t(_Jv_JNI_GetArrayLength): Likewise.\n+\t(_Jv_JNI_NewObjectArray): Likewise.\n+\t(_Jv_JNI_GetObjectArrayElement): Likewise.\n+\t(_Jv_JNI_SetObjectArrayElement): Likewise.\n+\t(_Jv_JNI_GetPrimitiveArrayElements): Likewise.\n+\t(_Jv_JNI_ReleasePrimitiveArrayElements): Likewise.\n+\t(_Jv_JNI_GetPrimitiveArrayRegion): Likewise.\n+\t(_Jv_JNI_SetPrimitiveArrayRegion): Likewise.\n+\t(_Jv_JNI_MonitorEnter): Likewise.\n+\t(_Jv_JNI_MonitorExit): Likewise.\n+\t(_Jv_JNI_ToReflectedField): Likewise.\n+\t(_Jv_JNI_FromReflectedField): Likewise.\n+\t(_Jv_JNI_ToReflectedMethod): Likewise.\n+\t(_Jv_JNI_FromReflectedMethod): Likewise.\n+\t(_Jv_JNI_NewGlobalRef): Likewise.\n+\t(_Jv_JNI_DeleteGlobalRef): Likewise.\n+\t(_Jv_JNI_DeleteLocalRef): Likewise.\n+\t(_Jv_JNI_NewLocalRef): Likewise.\n+\t(_Jv_JNI_NewWeakGlobalRef): New function.\n+\t(_Jv_JNI_DeleteWeakGlobalRef): Likewise.\n+\t(_Jv_JNIFunctions): Updated for new methods.\n+\t(NOT_IMPL): Removed.\n+\t* gnu/gcj/runtime/JNIWeakRef.java: New file.\n+\n 2001-11-12  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* boehm.cc (_Jv_GCCanReclaimSoftReference): Fix warning."}, {"sha": "eaf3f12b793b3ccb764535295e6176bbc2e305d9", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819138ac7b6e38becc5e133524c78aa46b1d5b92/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819138ac7b6e38becc5e133524c78aa46b1d5b92/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=819138ac7b6e38becc5e133524c78aa46b1d5b92", "patch": "@@ -1263,6 +1263,7 @@ gnu/gcj/protocol/jar/Handler.java \\\n gnu/gcj/runtime/FileDeleter.java \\\n gnu/gcj/runtime/FinalizerThread.java \\\n gnu/gcj/runtime/FirstThread.java \\\n+gnu/gcj/runtime/JNIWeakRef.java \\\n gnu/gcj/runtime/SharedLibLoader.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n gnu/java/io/ClassLoaderObjectInputStream.java \\"}, {"sha": "7696a378ad970a39dfbbf5bc0a15cedc3941a2f4", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819138ac7b6e38becc5e133524c78aa46b1d5b92/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819138ac7b6e38becc5e133524c78aa46b1d5b92/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=819138ac7b6e38becc5e133524c78aa46b1d5b92", "patch": "@@ -996,6 +996,7 @@ gnu/gcj/protocol/jar/Handler.java \\\n gnu/gcj/runtime/FileDeleter.java \\\n gnu/gcj/runtime/FinalizerThread.java \\\n gnu/gcj/runtime/FirstThread.java \\\n+gnu/gcj/runtime/JNIWeakRef.java \\\n gnu/gcj/runtime/SharedLibLoader.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n gnu/java/io/ClassLoaderObjectInputStream.java \\\n@@ -1636,7 +1637,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/protocol/jar/Handler.P \\\n .deps/gnu/gcj/runtime/FileDeleter.P \\\n .deps/gnu/gcj/runtime/FinalizerThread.P \\\n-.deps/gnu/gcj/runtime/FirstThread.P \\\n+.deps/gnu/gcj/runtime/FirstThread.P .deps/gnu/gcj/runtime/JNIWeakRef.P \\\n .deps/gnu/gcj/runtime/SharedLibLoader.P \\\n .deps/gnu/gcj/runtime/VMClassLoader.P \\\n .deps/gnu/gcj/runtime/natFinalizerThread.P \\"}, {"sha": "c0c76cdb6f516ee2225dec5526185011822291c5", "filename": "libjava/gnu/gcj/runtime/JNIWeakRef.java", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819138ac7b6e38becc5e133524c78aa46b1d5b92/libjava%2Fgnu%2Fgcj%2Fruntime%2FJNIWeakRef.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819138ac7b6e38becc5e133524c78aa46b1d5b92/libjava%2Fgnu%2Fgcj%2Fruntime%2FJNIWeakRef.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FJNIWeakRef.java?ref=819138ac7b6e38becc5e133524c78aa46b1d5b92", "patch": "@@ -0,0 +1,24 @@\n+// JNIWeakRef.java - Wrapper class for JNI-specific weak references.\n+\n+/* Copyright (C) 2001  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.runtime;\n+\n+import java.lang.ref.*;\n+\n+// This wrapper is used by the JNI implementation to keep track of\n+// global weak references.  Each such reference is wrapped in an\n+// instance of this class, and automatically unwrapped when used.\n+public final class JNIWeakRef extends WeakReference\n+{\n+  public JNIWeakRef (Object referent)\n+  {\n+    super (referent);\n+  }\n+}"}, {"sha": "1aa77bc2c04417d5a667afa144e0030fa8e6ed5c", "filename": "libjava/jni.cc", "status": "modified", "additions": 151, "deletions": 20, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819138ac7b6e38becc5e133524c78aa46b1d5b92/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819138ac7b6e38becc5e133524c78aa46b1d5b92/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=819138ac7b6e38becc5e133524c78aa46b1d5b92", "patch": "@@ -41,6 +41,7 @@ details.  */\n #include <java/lang/Integer.h>\n #include <java/lang/ThreadGroup.h>\n #include <java/lang/Thread.h>\n+#include <gnu/gcj/runtime/JNIWeakRef.h>\n \n #include <gcj/method.h>\n #include <gcj/field.h>\n@@ -194,18 +195,45 @@ unmark_for_gc (jobject obj, java::util::IdentityHashMap *ref_table)\n     ref_table->put (obj, new Integer (val));\n }\n \n+// \"Unwrap\" some random non-reference type.  This exists to simplify\n+// other template functions.\n+template<typename T>\n+static T\n+unwrap (T val)\n+{\n+  return val;\n+}\n+\n+// Unwrap a weak reference, if required.\n+template<typename T>\n+static T *\n+unwrap (T *obj)\n+{\n+  using namespace gnu::gcj::runtime;\n+  // We can compare the class directly because JNIWeakRef is `final'.\n+  // Doing it this way is much faster.\n+  if (obj == NULL || obj->getClass () == &JNIWeakRef::class$)\n+    return obj;\n+  JNIWeakRef *wr = reinterpret_cast<JNIWeakRef *> (obj);\n+  return reinterpret_cast<T *> (wr->get ());\n+}\n+\n \f\n \n static jobject\n _Jv_JNI_NewGlobalRef (JNIEnv *, jobject obj)\n {\n+  // This seems weird but I think it is correct.\n+  obj = unwrap (obj);\n   mark_for_gc (obj, global_ref_table);\n   return obj;\n }\n \n static void\n _Jv_JNI_DeleteGlobalRef (JNIEnv *, jobject obj)\n {\n+  // This seems weird but I think it is correct.\n+  obj = unwrap (obj);\n   unmark_for_gc (obj, global_ref_table);\n }\n \n@@ -214,6 +242,9 @@ _Jv_JNI_DeleteLocalRef (JNIEnv *env, jobject obj)\n {\n   _Jv_JNI_LocalFrame *frame;\n \n+  // This seems weird but I think it is correct.\n+  obj = unwrap (obj);\n+\n   for (frame = env->locals; frame != NULL; frame = frame->next)\n     {\n       for (int i = 0; i < frame->size; ++i)\n@@ -277,6 +308,9 @@ _Jv_JNI_PushLocalFrame (JNIEnv *env, jint size)\n static jobject\n _Jv_JNI_NewLocalRef (JNIEnv *env, jobject obj)\n {\n+  // This seems weird but I think it is correct.\n+  obj = unwrap (obj);\n+\n   // Try to find an open slot somewhere in the topmost frame.\n   _Jv_JNI_LocalFrame *frame = env->locals;\n   bool done = false, set = false;\n@@ -403,6 +437,8 @@ _Jv_JNI_DefineClass (JNIEnv *env, jobject loader,\n {\n   try\n     {\n+      loader = unwrap (loader);\n+\n       jbyteArray bytes = JvNewByteArray (bufLen);\n \n       jbyte *elts = elements (bytes);\n@@ -460,19 +496,20 @@ _Jv_JNI_FindClass (JNIEnv *env, const char *name)\n static jclass\n _Jv_JNI_GetSuperclass (JNIEnv *env, jclass clazz)\n {\n-  return (jclass) wrap_value (env, clazz->getSuperclass ());\n+  return (jclass) wrap_value (env, unwrap (clazz)->getSuperclass ());\n }\n \n static jboolean\n _Jv_JNI_IsAssignableFrom(JNIEnv *, jclass clazz1, jclass clazz2)\n {\n-  return clazz1->isAssignableFrom (clazz2);\n+  return unwrap (clazz1)->isAssignableFrom (unwrap (clazz2));\n }\n \n static jint\n _Jv_JNI_Throw (JNIEnv *env, jthrowable obj)\n {\n   // We check in case the user did some funky cast.\n+  obj = unwrap (obj);\n   JvAssert (obj != NULL && java::lang::Throwable::class$.isInstance (obj));\n   env->ex = obj;\n   return 0;\n@@ -483,6 +520,7 @@ _Jv_JNI_ThrowNew (JNIEnv *env, jclass clazz, const char *message)\n {\n   using namespace java::lang::reflect;\n \n+  clazz = unwrap (clazz);\n   JvAssert (java::lang::Throwable::class$.isAssignableFrom (clazz));\n \n   int r = JNI_OK;\n@@ -550,7 +588,7 @@ _Jv_JNI_FatalError (JNIEnv *, const char *message)\n static jboolean\n _Jv_JNI_IsSameObject (JNIEnv *, jobject obj1, jobject obj2)\n {\n-  return obj1 == obj2;\n+  return unwrap (obj1) == unwrap (obj2);\n }\n \n static jobject\n@@ -561,6 +599,7 @@ _Jv_JNI_AllocObject (JNIEnv *env, jclass clazz)\n \n   try\n     {\n+      clazz = unwrap (clazz);\n       JvAssert (clazz && ! clazz->isArray ());\n       if (clazz->isInterface() || Modifier::isAbstract(clazz->getModifiers()))\n \tenv->ex = new java::lang::InstantiationException ();\n@@ -581,14 +620,15 @@ _Jv_JNI_AllocObject (JNIEnv *env, jclass clazz)\n static jclass\n _Jv_JNI_GetObjectClass (JNIEnv *env, jobject obj)\n {\n+  obj = unwrap (obj);\n   JvAssert (obj);\n   return (jclass) wrap_value (env, obj->getClass());\n }\n \n static jboolean\n _Jv_JNI_IsInstanceOf (JNIEnv *, jobject obj, jclass clazz)\n {\n-  return clazz->isInstance(obj);\n+  return unwrap (clazz)->isInstance(unwrap (obj));\n }\n \n \f\n@@ -604,6 +644,7 @@ _Jv_JNI_GetAnyMethodID (JNIEnv *env, jclass clazz,\n {\n   try\n     {\n+      clazz = unwrap (clazz);\n       _Jv_InitClass (clazz);\n \n       _Jv_Utf8Const *name_u = _Jv_makeUtf8Const ((char *) name, -1);\n@@ -676,7 +717,7 @@ array_from_valist (jvalue *values, JArray<jclass> *arg_types, va_list vargs)\n       else\n \t{\n \t  // An object.\n-\t  values[i].l = va_arg (vargs, jobject);\n+\t  values[i].l = unwrap (va_arg (vargs, jobject));\n \t}\n     }\n }\n@@ -688,6 +729,9 @@ static T\n _Jv_JNI_CallAnyMethodV (JNIEnv *env, jobject obj, jclass klass,\n \t\t\tjmethodID id, va_list vargs)\n {\n+  obj = unwrap (obj);\n+  klass = unwrap (klass);\n+\n   if (style == normal)\n     id = _Jv_LookupDeclaredMethod (obj->getClass (), id->name, id->signature);\n \n@@ -748,6 +792,9 @@ static T\n _Jv_JNI_CallAnyMethodA (JNIEnv *env, jobject obj, jclass klass,\n \t\t\tjmethodID id, jvalue *args)\n {\n+  obj = unwrap (obj);\n+  klass = unwrap (klass);\n+\n   if (style == normal)\n     id = _Jv_LookupDeclaredMethod (obj->getClass (), id->name, id->signature);\n \n@@ -765,10 +812,21 @@ _Jv_JNI_CallAnyMethodA (JNIEnv *env, jobject obj, jclass klass,\n       if (style == constructor)\n \treturn_type = klass;\n \n+      // Unwrap arguments as required.  Eww.\n+      jclass *type_elts = elements (arg_types);\n+      jvalue arg_copy[arg_types->length];\n+      for (int i = 0; i < arg_types->length; ++i)\n+\t{\n+\t  if (type_elts[i]->isPrimitive ())\n+\t    arg_copy[i] = args[i];\n+\t  else\n+\t    arg_copy[i].l = unwrap (args[i].l);\n+\t}\n+\n       jvalue result;\n       jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n \t\t\t\t\t  style == constructor,\n-\t\t\t\t\t  arg_types, args, &result);\n+\t\t\t\t\t  arg_types, arg_copy, &result);\n \n       if (ex != NULL)\n \tenv->ex = ex;\n@@ -789,6 +847,9 @@ static void\n _Jv_JNI_CallAnyVoidMethodV (JNIEnv *env, jobject obj, jclass klass,\n \t\t\t    jmethodID id, va_list vargs)\n {\n+  obj = unwrap (obj);\n+  klass = unwrap (klass);\n+\n   if (style == normal)\n     id = _Jv_LookupDeclaredMethod (obj->getClass (), id->name, id->signature);\n \n@@ -852,6 +913,17 @@ _Jv_JNI_CallAnyVoidMethodA (JNIEnv *env, jobject obj, jclass klass,\n       _Jv_GetTypesFromSignature (id, decl_class,\n \t\t\t\t &arg_types, &return_type);\n \n+      // Unwrap arguments as required.  Eww.\n+      jclass *type_elts = elements (arg_types);\n+      jvalue arg_copy[arg_types->length];\n+      for (int i = 0; i < arg_types->length; ++i)\n+\t{\n+\t  if (type_elts[i]->isPrimitive ())\n+\t    arg_copy[i] = args[i];\n+\t  else\n+\t    arg_copy[i].l = unwrap (args[i].l);\n+\t}\n+\n       jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n \t\t\t\t\t  style == constructor,\n \t\t\t\t\t  arg_types, args, NULL);\n@@ -929,7 +1001,7 @@ _Jv_JNI_CallStaticMethodV (JNIEnv *env, jclass klass,\n \t\t\t   jmethodID id, va_list args)\n {\n   JvAssert (((id->accflags) & java::lang::reflect::Modifier::STATIC));\n-  JvAssert (java::lang::Class::class$.isInstance (klass));\n+  JvAssert (java::lang::Class::class$.isInstance (unwrap (klass)));\n \n   return _Jv_JNI_CallAnyMethodV<T, static_type> (env, NULL, klass, id, args);\n }\n@@ -944,7 +1016,7 @@ _Jv_JNI_CallStaticMethod (JNIEnv *env, jclass klass, jmethodID id, ...)\n   T result;\n \n   JvAssert (((id->accflags) & java::lang::reflect::Modifier::STATIC));\n-  JvAssert (java::lang::Class::class$.isInstance (klass));\n+  JvAssert (java::lang::Class::class$.isInstance (unwrap (klass)));\n \n   va_start (args, id);\n   result = _Jv_JNI_CallAnyMethodV<T, static_type> (env, NULL, klass,\n@@ -962,7 +1034,7 @@ _Jv_JNI_CallStaticMethodA (JNIEnv *env, jclass klass, jmethodID id,\n \t\t\t   jvalue *args)\n {\n   JvAssert (((id->accflags) & java::lang::reflect::Modifier::STATIC));\n-  JvAssert (java::lang::Class::class$.isInstance (klass));\n+  JvAssert (java::lang::Class::class$.isInstance (unwrap (klass)));\n \n   return _Jv_JNI_CallAnyMethodA<T, static_type> (env, NULL, klass, id, args);\n }\n@@ -1048,6 +1120,7 @@ template<typename T>\n static T\n _Jv_JNI_GetField (JNIEnv *env, jobject obj, jfieldID field)\n {\n+  obj = unwrap (obj);\n   JvAssert (obj);\n   T *ptr = (T *) ((char *) obj + field->getOffset ());\n   return wrap_value (env, *ptr);\n@@ -1057,6 +1130,9 @@ template<typename T>\n static void\n _Jv_JNI_SetField (JNIEnv *, jobject obj, jfieldID field, T value)\n {\n+  obj = unwrap (obj);\n+  value = unwrap (value);\n+\n   JvAssert (obj);\n   T *ptr = (T *) ((char *) obj + field->getOffset ());\n   *ptr = value;\n@@ -1069,6 +1145,8 @@ _Jv_JNI_GetAnyFieldID (JNIEnv *env, jclass clazz,\n {\n   try\n     {\n+      clazz = unwrap (clazz);\n+\n       _Jv_InitClass (clazz);\n \n       _Jv_Utf8Const *a_name = _Jv_makeUtf8Const ((char *) name, -1);\n@@ -1133,6 +1211,7 @@ template<typename T>\n static void\n _Jv_JNI_SetStaticField (JNIEnv *, jclass, jfieldID field, T value)\n {\n+  value = unwrap (value);\n   T *ptr = (T *) field->u.addr;\n   *ptr = value;\n }\n@@ -1155,12 +1234,13 @@ _Jv_JNI_NewString (JNIEnv *env, const jchar *unichars, jsize len)\n static jsize\n _Jv_JNI_GetStringLength (JNIEnv *, jstring string)\n {\n-  return string->length();\n+  return unwrap (string)->length();\n }\n \n static const jchar *\n _Jv_JNI_GetStringChars (JNIEnv *, jstring string, jboolean *isCopy)\n {\n+  string = unwrap (string);\n   jchar *result = _Jv_GetStringChars (string);\n   mark_for_gc (string, global_ref_table);\n   if (isCopy)\n@@ -1171,7 +1251,7 @@ _Jv_JNI_GetStringChars (JNIEnv *, jstring string, jboolean *isCopy)\n static void\n _Jv_JNI_ReleaseStringChars (JNIEnv *, jstring string, const jchar *)\n {\n-  unmark_for_gc (string, global_ref_table);\n+  unmark_for_gc (unwrap (string), global_ref_table);\n }\n \n static jstring\n@@ -1192,12 +1272,13 @@ _Jv_JNI_NewStringUTF (JNIEnv *env, const char *bytes)\n static jsize\n _Jv_JNI_GetStringUTFLength (JNIEnv *, jstring string)\n {\n-  return JvGetStringUTFLength (string);\n+  return JvGetStringUTFLength (unwrap (string));\n }\n \n static const char *\n _Jv_JNI_GetStringUTFChars (JNIEnv *env, jstring string, jboolean *isCopy)\n {\n+  string = unwrap (string);\n   jsize len = JvGetStringUTFLength (string);\n   try\n     {\n@@ -1227,6 +1308,7 @@ static void\n _Jv_JNI_GetStringRegion (JNIEnv *env, jstring string, jsize start, jsize len,\n \t\t\t jchar *buf)\n {\n+  string = unwrap (string);\n   jchar *result = _Jv_GetStringChars (string);\n   if (start < 0 || start > string->length ()\n       || len < 0 || start + len > string->length ())\n@@ -1248,6 +1330,8 @@ static void\n _Jv_JNI_GetStringUTFRegion (JNIEnv *env, jstring str, jsize start,\n \t\t\t    jsize len, char *buf)\n {\n+  str = unwrap (str);\n+    \n   if (start < 0 || start > str->length ()\n       || len < 0 || start + len > str->length ())\n     {\n@@ -1267,7 +1351,7 @@ _Jv_JNI_GetStringUTFRegion (JNIEnv *env, jstring str, jsize start,\n static const jchar *\n _Jv_JNI_GetStringCritical (JNIEnv *, jstring str, jboolean *isCopy)\n {\n-  jchar *result = _Jv_GetStringChars (str);\n+  jchar *result = _Jv_GetStringChars (unwrap (str));\n   if (isCopy)\n     *isCopy = false;\n   return result;\n@@ -1282,7 +1366,7 @@ _Jv_JNI_ReleaseStringCritical (JNIEnv *, jstring, const jchar *)\n static jsize\n _Jv_JNI_GetArrayLength (JNIEnv *, jarray array)\n {\n-  return array->length;\n+  return unwrap (array)->length;\n }\n \n static jarray\n@@ -1291,6 +1375,9 @@ _Jv_JNI_NewObjectArray (JNIEnv *env, jsize length, jclass elementClass,\n {\n   try\n     {\n+      elementClass = unwrap (elementClass);\n+      init = unwrap (init);\n+\n       jarray result = JvNewObjectArray (length, elementClass, init);\n       return (jarray) wrap_value (env, result);\n     }\n@@ -1304,7 +1391,7 @@ _Jv_JNI_NewObjectArray (JNIEnv *env, jsize length, jclass elementClass,\n static jobject\n _Jv_JNI_GetObjectArrayElement (JNIEnv *env, jobjectArray array, jsize index)\n {\n-  jobject *elts = elements (array);\n+  jobject *elts = elements (unwrap (array));\n   return wrap_value (env, elts[index]);\n }\n \n@@ -1314,6 +1401,9 @@ _Jv_JNI_SetObjectArrayElement (JNIEnv *env, jobjectArray array, jsize index,\n {\n   try\n     {\n+      array = unwrap (array);\n+      value = unwrap (value);\n+\n       _Jv_CheckArrayStore (array, value);\n       jobject *elts = elements (array);\n       elts[index] = value;\n@@ -1344,6 +1434,7 @@ static T *\n _Jv_JNI_GetPrimitiveArrayElements (JNIEnv *, JArray<T> *array,\n \t\t\t\t   jboolean *isCopy)\n {\n+  array = unwrap (array);\n   T *elts = elements (array);\n   if (isCopy)\n     {\n@@ -1359,6 +1450,7 @@ static void\n _Jv_JNI_ReleasePrimitiveArrayElements (JNIEnv *, JArray<T> *array,\n \t\t\t\t       T *, jint /* mode */)\n {\n+  array = unwrap (array);\n   // Note that we ignore MODE.  We can do this because we never copy\n   // the array elements.  My reading of the JNI documentation is that\n   // this is an option for the implementor.\n@@ -1371,6 +1463,8 @@ _Jv_JNI_GetPrimitiveArrayRegion (JNIEnv *env, JArray<T> *array,\n \t\t\t\t jsize start, jsize len,\n \t\t\t\t T *buf)\n {\n+  array = unwrap (array);\n+\n   // The cast to unsigned lets us save a comparison.\n   if (start < 0 || len < 0\n       || (unsigned long) (start + len) > (unsigned long) array->length)\n@@ -1398,6 +1492,8 @@ static void\n _Jv_JNI_SetPrimitiveArrayRegion (JNIEnv *env, JArray<T> *array,\n \t\t\t\t jsize start, jsize len, T *buf)\n {\n+  array = unwrap (array);\n+\n   // The cast to unsigned lets us save a comparison.\n   if (start < 0 || len < 0\n       || (unsigned long) (start + len) > (unsigned long) array->length)\n@@ -1423,6 +1519,7 @@ static void *\n _Jv_JNI_GetPrimitiveArrayCritical (JNIEnv *, jarray array,\n \t\t\t\t   jboolean *isCopy)\n {\n+  array = unwrap (array);\n   // FIXME: does this work?\n   jclass klass = array->getClass()->getComponentType();\n   JvAssert (klass->isPrimitive ());\n@@ -1443,7 +1540,7 @@ _Jv_JNI_MonitorEnter (JNIEnv *env, jobject obj)\n {\n   try\n     {\n-      _Jv_MonitorEnter (obj);\n+      _Jv_MonitorEnter (unwrap (obj));\n       return 0;\n     }\n   catch (jthrowable t)\n@@ -1458,7 +1555,7 @@ _Jv_JNI_MonitorExit (JNIEnv *env, jobject obj)\n {\n   try\n     {\n-      _Jv_MonitorExit (obj);\n+      _Jv_MonitorExit (unwrap (obj));\n       return 0;\n     }\n   catch (jthrowable t)\n@@ -1475,6 +1572,7 @@ _Jv_JNI_ToReflectedField (JNIEnv *env, jclass cls, jfieldID fieldID,\n {\n   try\n     {\n+      cls = unwrap (cls);\n       java::lang::reflect::Field *field = new java::lang::reflect::Field();\n       field->declaringClass = cls;\n       field->offset = (char*) fieldID - (char *) cls->fields;\n@@ -1494,6 +1592,7 @@ _Jv_JNI_FromReflectedField (JNIEnv *, jobject f)\n {\n   using namespace java::lang::reflect;\n \n+  f = unwrap (f);\n   Field *field = reinterpret_cast<Field *> (f);\n   return _Jv_FromReflectedField (field);\n }\n@@ -1505,6 +1604,7 @@ _Jv_JNI_ToReflectedMethod (JNIEnv *env, jclass klass, jmethodID id,\n   using namespace java::lang::reflect;\n \n   jobject result = NULL;\n+  klass = unwrap (klass);\n \n   try\n     {\n@@ -1536,12 +1636,44 @@ static jmethodID\n _Jv_JNI_FromReflectedMethod (JNIEnv *, jobject method)\n {\n   using namespace java::lang::reflect;\n+  method = unwrap (method);\n   if (Method::class$.isInstance (method))\n     return _Jv_FromReflectedMethod (reinterpret_cast<Method *> (method));\n   return\n     _Jv_FromReflectedConstructor (reinterpret_cast<Constructor *> (method));\n }\n \n+// JDK 1.2.\n+jweak\n+_Jv_JNI_NewWeakGlobalRef (JNIEnv *env, jobject obj)\n+{\n+  using namespace gnu::gcj::runtime;\n+  JNIWeakRef *ref = NULL;\n+\n+  try\n+    {\n+      // This seems weird but I think it is correct.\n+      obj = unwrap (obj);\n+      ref = new JNIWeakRef (obj);\n+      mark_for_gc (ref, global_ref_table);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+    }\n+\n+  return reinterpret_cast<jweak> (ref);\n+}\n+\n+void\n+_Jv_JNI_DeleteWeakGlobalRef (JNIEnv *, jweak obj)\n+{\n+  using namespace gnu::gcj::runtime;\n+  JNIWeakRef *ref = reinterpret_cast<JNIWeakRef *> (obj);\n+  unmark_for_gc (ref, global_ref_table);\n+  ref->clear ();\n+}\n+\n \f\n \n // Hash table of native methods.\n@@ -2218,7 +2350,6 @@ _Jv_JNI_GetJavaVM (JNIEnv *, JavaVM **vm)\n \n \f\n \n-#define NOT_IMPL NULL\n #define RESERVED NULL\n \n struct JNINativeInterface _Jv_JNIFunctions =\n@@ -2462,8 +2593,8 @@ struct JNINativeInterface _Jv_JNIFunctions =\n   _Jv_JNI_GetStringCritical,\t\t    // GetStringCritical\n   _Jv_JNI_ReleaseStringCritical,\t    // ReleaseStringCritical\n \n-  NOT_IMPL /* newweakglobalref */,\n-  NOT_IMPL /* deleteweakglobalref */,\n+  _Jv_JNI_NewWeakGlobalRef,\t\t    // NewWeakGlobalRef\n+  _Jv_JNI_DeleteWeakGlobalRef,\t\t    // DeleteWeakGlobalRef\n \n   _Jv_JNI_ExceptionCheck\n };"}]}