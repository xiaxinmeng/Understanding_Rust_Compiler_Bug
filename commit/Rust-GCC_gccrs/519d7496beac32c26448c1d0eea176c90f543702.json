{"sha": "519d7496beac32c26448c1d0eea176c90f543702", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE5ZDc0OTZiZWFjMzJjMjY0NDhjMWQwZWVhMTc2YzkwZjU0MzcwMg==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2019-12-20T01:20:38Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2019-12-20T01:20:38Z"}, "message": "OpenACC 2.6 deep copy: C and C++ front-end parts\n\n\tgcc/c-family/\n\t* c-common.h (c_omp_map_clause_name): Add prototype.\n\t* c-omp.c (c_omp_map_clause_name): New function.\n\t* c-pragma.h (pragma_omp_clause): Add PRAGMA_OACC_CLAUSE_ATTACH and\n\tPRAGMA_OACC_CLAUSE_DETACH.\n\n\tgcc/c/\n\t* c-parser.c (c_parser_omp_clause_name): Add parsing of attach and\n\tdetach clauses.\n\t(c_parser_omp_variable_list): Add ALLOW_DEREF optional parameter.\n\tAllow deref (->) in variable lists if true.\n\t(c_parser_omp_var_list_parens): Add ALLOW_DEREF optional parameter.\n\tPass to c_parser_omp_variable_list.\n\t(c_parser_oacc_data_clause): Support attach and detach clauses.  Update\n\tcall to c_parser_omp_variable_list.\n\t(c_parser_oacc_all_clauses): Support attach and detach clauses.\n\t(OACC_DATA_CLAUSE_MASK, OACC_ENTER_DATA_CLAUSE_MASK,\n\tOACC_KERNELS_CLAUSE_MASK, OACC_PARALLEL_CLAUSE_MASK,\n\tOACC_SERIAL_CLAUSE_MASK): Add PRAGMA_OACC_CLAUSE_ATTACH.\n\t(OACC_EXIT_DATA_CLAUSE_MASK): Add PRAGMA_OACC_CLAUSE_DETACH.\n\t* c-typeck.c (handle_omp_array_sections_1): Reject subarrays for attach\n\tand detach.  Support deref.\n\t(handle_omp_array_sections): Use GOMP_MAP_ATTACH_DETACH instead of\n\tGOMP_MAP_ALWAYS_POINTER for OpenACC.\n\t(c_oacc_check_attachments): New function.\n\t(c_finish_omp_clauses): Check attach/detach arguments for being\n\tpointers using above.  Support deref.\n\n\tgcc/cp/\n\t* parser.c (cp_parser_omp_clause_name): Support attach and detach\n\tclauses.\n\t(cp_parser_omp_var_list_no_open): Add ALLOW_DEREF optional parameter.\n\tParse deref if true.\n\t(cp_parser_omp_var_list): Add ALLOW_DEREF optional parameter.  Pass to\n\tcp_parser_omp_var_list_no_open.\n\t(cp_parser_oacc_data_clause): Support attach and detach clauses.\n\tUpdate call to cp_parser_omp_var_list_no_open.\n\t(cp_parser_oacc_all_clauses): Support attach and detach.\n\t(OACC_DATA_CLAUSE_MASK, OACC_ENTER_DATA_CLAUSE_MASK,\n\tOACC_KERNELS_CLAUSE_MASK, OACC_PARALLEL_CLAUSE_MASK,\n\tOACC_SERIAL_CLAUSE_MASK): Add PRAGMA_OACC_CLAUSE_ATTACH.\n\t(OACC_EXIT_DATA_CLAUSE_MASK): Add PRAGMA_OACC_CLAUSE_DETACH.\n\t* semantics.c (handle_omp_array_sections_1): Reject subarrays for\n\tattach and detach.\n\t(handle_omp_array_sections): Use GOMP_MAP_ATTACH_DETACH instead of\n\tGOMP_MAP_ALWAYS_POINTER for OpenACC.\n\t(cp_oacc_check_attachments): New function.\n\t(finish_omp_clauses): Use above function.  Allow structure fields and\n\tclass members to appear in OpenACC data clauses.  Support\n\tGOMP_MAP_ATTACH_DETACH.  Support deref.\n\n\tgcc/testsuite/\n\t* c-c++-common/goacc/deep-copy-arrayofstruct.c: New test.\n\t* c-c++-common/goacc/mdc-1.c: New test.\n\t* c-c++-common/goacc/mdc-2.c: New test.\n\t* gcc.dg/goacc/mdc.C: New test.\n\nCo-Authored-By: Cesar Philippidis <cesar@codesourcery.com>\n\nFrom-SVN: r279627", "tree": {"sha": "20537e9c463b72f2dca5a286adbe9d39ae91beea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20537e9c463b72f2dca5a286adbe9d39ae91beea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/519d7496beac32c26448c1d0eea176c90f543702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519d7496beac32c26448c1d0eea176c90f543702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/519d7496beac32c26448c1d0eea176c90f543702", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519d7496beac32c26448c1d0eea176c90f543702/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fd872bc0c6b4d48141f7d7e884c20b8e5e3979d"}], "stats": {"total": 652, "additions": 618, "deletions": 34}, "files": [{"sha": "30cbc133dc391f0a872c13997b34235f065a4c86", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -1,3 +1,10 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\n+\t* c-common.h (c_omp_map_clause_name): Add prototype.\n+\t* c-omp.c (c_omp_map_clause_name): New function.\n+\t* c-pragma.h (pragma_omp_clause): Add PRAGMA_OACC_CLAUSE_ATTACH and\n+\tPRAGMA_OACC_CLAUSE_DETACH.\n+\n 2019-12-19  Julian Brown  <julian@codesourcery.com>\n \t    Maciej W. Rozycki  <macro@codesourcery.com>\n \t    Tobias Burnus  <tobias@codesourcery.com>"}, {"sha": "2d89451b6934d9cead2990f0bae8445202e71f86", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -1205,6 +1205,7 @@ extern bool c_omp_predefined_variable (tree);\n extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);\n extern tree c_omp_check_context_selector (location_t, tree);\n extern void c_omp_mark_declare_variant (location_t, tree, tree);\n+extern const char *c_omp_map_clause_name (tree, bool);\n \n /* Return next tree in the chain for chain_next walking of tree nodes.  */\n static inline tree"}, {"sha": "04f2c0b06824ee6ebd932e2c60dc02a21ab55423", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -2259,3 +2259,36 @@ c_omp_mark_declare_variant (location_t loc, tree variant, tree construct)\n     error_at (loc, \"%qD used as a variant with incompatible %<construct%> \"\n \t\t   \"selector sets\", variant);\n }\n+\n+/* For OpenACC, the OMP_CLAUSE_MAP_KIND of an OMP_CLAUSE_MAP is used internally\n+   to distinguish clauses as seen by the user.  Return the \"friendly\" clause\n+   name for error messages etc., where possible.  See also\n+   c/c-parser.c:c_parser_oacc_data_clause and\n+   cp/parser.c:cp_parser_oacc_data_clause.  */\n+\n+const char *\n+c_omp_map_clause_name (tree clause, bool oacc)\n+{\n+  if (oacc && OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP)\n+    switch (OMP_CLAUSE_MAP_KIND (clause))\n+    {\n+    case GOMP_MAP_FORCE_ALLOC:\n+    case GOMP_MAP_ALLOC: return \"create\";\n+    case GOMP_MAP_FORCE_TO:\n+    case GOMP_MAP_TO: return \"copyin\";\n+    case GOMP_MAP_FORCE_FROM:\n+    case GOMP_MAP_FROM: return \"copyout\";\n+    case GOMP_MAP_FORCE_TOFROM:\n+    case GOMP_MAP_TOFROM: return \"copy\";\n+    case GOMP_MAP_RELEASE: return \"delete\";\n+    case GOMP_MAP_FORCE_PRESENT: return \"present\";\n+    case GOMP_MAP_ATTACH: return \"attach\";\n+    case GOMP_MAP_FORCE_DETACH:\n+    case GOMP_MAP_DETACH: return \"detach\";\n+    case GOMP_MAP_DEVICE_RESIDENT: return \"device_resident\";\n+    case GOMP_MAP_LINK: return \"link\";\n+    case GOMP_MAP_FORCE_DEVICEPTR: return \"deviceptr\";\n+    default: break;\n+    }\n+  return omp_clause_code_name[OMP_CLAUSE_CODE (clause)];\n+}"}, {"sha": "bf57d3ddb6d0e104c42644a00068cc0210a3ac20", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -143,11 +143,13 @@ enum pragma_omp_clause {\n \n   /* Clauses for OpenACC.  */\n   PRAGMA_OACC_CLAUSE_ASYNC,\n+  PRAGMA_OACC_CLAUSE_ATTACH,\n   PRAGMA_OACC_CLAUSE_AUTO,\n   PRAGMA_OACC_CLAUSE_COPY,\n   PRAGMA_OACC_CLAUSE_COPYOUT,\n   PRAGMA_OACC_CLAUSE_CREATE,\n   PRAGMA_OACC_CLAUSE_DELETE,\n+  PRAGMA_OACC_CLAUSE_DETACH,\n   PRAGMA_OACC_CLAUSE_DEVICEPTR,\n   PRAGMA_OACC_CLAUSE_DEVICE_RESIDENT,\n   PRAGMA_OACC_CLAUSE_FINALIZE,"}, {"sha": "469dc5d5d3483a246622f28d9ee76985e1f5fbcf", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -1,3 +1,27 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\n+\t* c-parser.c (c_parser_omp_clause_name): Add parsing of attach and\n+\tdetach clauses.\n+\t(c_parser_omp_variable_list): Add ALLOW_DEREF optional parameter.\n+\tAllow deref (->) in variable lists if true.\n+\t(c_parser_omp_var_list_parens): Add ALLOW_DEREF optional parameter.\n+\tPass to c_parser_omp_variable_list.\n+\t(c_parser_oacc_data_clause): Support attach and detach clauses.  Update\n+\tcall to c_parser_omp_variable_list.\n+\t(c_parser_oacc_all_clauses): Support attach and detach clauses.\n+\t(OACC_DATA_CLAUSE_MASK, OACC_ENTER_DATA_CLAUSE_MASK,\n+\tOACC_KERNELS_CLAUSE_MASK, OACC_PARALLEL_CLAUSE_MASK,\n+\tOACC_SERIAL_CLAUSE_MASK): Add PRAGMA_OACC_CLAUSE_ATTACH.\n+\t(OACC_EXIT_DATA_CLAUSE_MASK): Add PRAGMA_OACC_CLAUSE_DETACH.\n+\t* c-typeck.c (handle_omp_array_sections_1): Reject subarrays for attach\n+\tand detach.  Support deref.\n+\t(handle_omp_array_sections): Use GOMP_MAP_ATTACH_DETACH instead of\n+\tGOMP_MAP_ALWAYS_POINTER for OpenACC.\n+\t(c_oacc_check_attachments): New function.\n+\t(c_finish_omp_clauses): Check attach/detach arguments for being\n+\tpointers using above.  Support deref.\n+\n 2019-12-19  Julian Brown  <julian@codesourcery.com>\n \t    Maciej W. Rozycki  <macro@codesourcery.com>\n \t    Tobias Burnus  <tobias@codesourcery.com>"}, {"sha": "b3763c2e8886a238f6e28338e1794db3730b0291", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -12564,6 +12564,8 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_ALIGNED;\n \t  else if (!strcmp (\"async\", p))\n \t    result = PRAGMA_OACC_CLAUSE_ASYNC;\n+\t  else if (!strcmp (\"attach\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_ATTACH;\n \t  break;\n \tcase 'b':\n \t  if (!strcmp (\"bind\", p))\n@@ -12590,6 +12592,8 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OACC_CLAUSE_DELETE;\n \t  else if (!strcmp (\"depend\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DEPEND;\n+\t  else if (!strcmp (\"detach\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_DETACH;\n \t  else if (!strcmp (\"device\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DEVICE;\n \t  else if (!strcmp (\"deviceptr\", p))\n@@ -12835,12 +12839,16 @@ c_parser_oacc_wait_list (c_parser *parser, location_t clause_loc, tree list)\n    If KIND is nonzero, CLAUSE_LOC is the location of the clause.\n \n    If KIND is zero, create a TREE_LIST with the decl in TREE_PURPOSE;\n-   return the list created.  */\n+   return the list created.\n+\n+   The optional ALLOW_DEREF argument is true if list items can use the deref\n+   (->) operator.  */\n \n static tree\n c_parser_omp_variable_list (c_parser *parser,\n \t\t\t    location_t clause_loc,\n-\t\t\t    enum omp_clause_code kind, tree list)\n+\t\t\t    enum omp_clause_code kind, tree list,\n+\t\t\t    bool allow_deref = false)\n {\n   auto_vec<c_token> tokens;\n   unsigned int tokens_avail = 0;\n@@ -12967,9 +12975,13 @@ c_parser_omp_variable_list (c_parser *parser,\n \t    case OMP_CLAUSE_MAP:\n \t    case OMP_CLAUSE_FROM:\n \t    case OMP_CLAUSE_TO:\n-\t      while (c_parser_next_token_is (parser, CPP_DOT))\n+\t      while (c_parser_next_token_is (parser, CPP_DOT)\n+\t\t     || (allow_deref\n+\t\t\t && c_parser_next_token_is (parser, CPP_DEREF)))\n \t\t{\n \t\t  location_t op_loc = c_parser_peek_token (parser)->location;\n+\t\t  if (c_parser_next_token_is (parser, CPP_DEREF))\n+\t\t    t = build_simple_mem_ref (t);\n \t\t  c_parser_consume_token (parser);\n \t\t  if (!c_parser_next_token_is (parser, CPP_NAME))\n \t\t    {\n@@ -13091,19 +13103,20 @@ c_parser_omp_variable_list (c_parser *parser,\n }\n \n /* Similarly, but expect leading and trailing parenthesis.  This is a very\n-   common case for OpenACC and OpenMP clauses.  */\n+   common case for OpenACC and OpenMP clauses.  The optional ALLOW_DEREF\n+   argument is true if list items can use the deref (->) operator.  */\n \n static tree\n c_parser_omp_var_list_parens (c_parser *parser, enum omp_clause_code kind,\n-\t\t\t      tree list)\n+\t\t\t      tree list, bool allow_deref = false)\n {\n   /* The clauses location.  */\n   location_t loc = c_parser_peek_token (parser)->location;\n \n   matching_parens parens;\n   if (parens.require_open (parser))\n     {\n-      list = c_parser_omp_variable_list (parser, loc, kind, list);\n+      list = c_parser_omp_variable_list (parser, loc, kind, list, allow_deref);\n       parens.skip_until_found_close (parser);\n     }\n   return list;\n@@ -13118,7 +13131,9 @@ c_parser_omp_var_list_parens (c_parser *parser, enum omp_clause_code kind,\n    present ( variable-list )\n \n    OpenACC 2.6:\n-   no_create ( variable-list ) */\n+   no_create ( variable-list )\n+   attach ( variable-list )\n+   detach ( variable-list ) */\n \n static tree\n c_parser_oacc_data_clause (c_parser *parser, pragma_omp_clause c_kind,\n@@ -13127,6 +13142,9 @@ c_parser_oacc_data_clause (c_parser *parser, pragma_omp_clause c_kind,\n   enum gomp_map_kind kind;\n   switch (c_kind)\n     {\n+    case PRAGMA_OACC_CLAUSE_ATTACH:\n+      kind = GOMP_MAP_ATTACH;\n+      break;\n     case PRAGMA_OACC_CLAUSE_COPY:\n       kind = GOMP_MAP_TOFROM;\n       break;\n@@ -13142,6 +13160,9 @@ c_parser_oacc_data_clause (c_parser *parser, pragma_omp_clause c_kind,\n     case PRAGMA_OACC_CLAUSE_DELETE:\n       kind = GOMP_MAP_RELEASE;\n       break;\n+    case PRAGMA_OACC_CLAUSE_DETACH:\n+      kind = GOMP_MAP_DETACH;\n+      break;\n     case PRAGMA_OACC_CLAUSE_DEVICE:\n       kind = GOMP_MAP_FORCE_TO;\n       break;\n@@ -13164,7 +13185,7 @@ c_parser_oacc_data_clause (c_parser *parser, pragma_omp_clause c_kind,\n       gcc_unreachable ();\n     }\n   tree nl, c;\n-  nl = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_MAP, list);\n+  nl = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_MAP, list, true);\n \n   for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n     OMP_CLAUSE_SET_MAP_KIND (c, kind);\n@@ -15879,6 +15900,10 @@ c_parser_oacc_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t\t clauses);\n \t  c_name = \"auto\";\n \t  break;\n+\tcase PRAGMA_OACC_CLAUSE_ATTACH:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"attach\";\n+\t  break;\n \tcase PRAGMA_OACC_CLAUSE_COLLAPSE:\n \t  clauses = c_parser_omp_clause_collapse (parser, clauses);\n \t  c_name = \"collapse\";\n@@ -15907,6 +15932,10 @@ c_parser_oacc_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_default (parser, clauses, true);\n \t  c_name = \"default\";\n \t  break;\n+\tcase PRAGMA_OACC_CLAUSE_DETACH:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"detach\";\n+\t  break;\n \tcase PRAGMA_OACC_CLAUSE_DEVICE:\n \t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n \t  c_name = \"device\";\n@@ -16421,7 +16450,8 @@ c_parser_oacc_cache (location_t loc, c_parser *parser)\n */\n \n #define OACC_DATA_CLAUSE_MASK\t\t\t\t\t\t\\\n-\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ATTACH)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n@@ -16605,6 +16635,7 @@ c_parser_oacc_declare (c_parser *parser)\n #define OACC_ENTER_DATA_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ATTACH)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT) )\n@@ -16614,6 +16645,7 @@ c_parser_oacc_declare (c_parser *parser)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DELETE) \t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DETACH) \t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_FINALIZE) \t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT) )\n \n@@ -16753,6 +16785,7 @@ c_parser_oacc_loop (location_t loc, c_parser *parser, char *p_name,\n \n #define OACC_KERNELS_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ATTACH)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n@@ -16769,6 +16802,7 @@ c_parser_oacc_loop (location_t loc, c_parser *parser, char *p_name,\n \n #define OACC_PARALLEL_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ATTACH)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n@@ -16788,6 +16822,7 @@ c_parser_oacc_loop (location_t loc, c_parser *parser, char *p_name,\n \n #define OACC_SERIAL_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ATTACH)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\"}, {"sha": "4fe4ab6f273f3e26004b7b2ccf638dddee95d36d", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 72, "deletions": 4, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -12897,7 +12897,6 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t  return error_mark_node;\n \t}\n       if (TREE_CODE (t) == COMPONENT_REF\n-\t  && ort == C_ORT_OMP\n \t  && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FROM))\n@@ -12918,6 +12917,15 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t  return error_mark_node;\n \t\t}\n \t      t = TREE_OPERAND (t, 0);\n+\t      if (ort == C_ORT_ACC && TREE_CODE (t) == MEM_REF)\n+\t\t{\n+\t\t  if (maybe_ne (mem_ref_offset (t), 0))\n+\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t      \"cannot dereference %qE in %qs clause\", t,\n+\t\t\t      omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  else\n+\t\t    t = TREE_OPERAND (t, 0);\n+\t\t}\n \t    }\n \t}\n       if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n@@ -13003,7 +13011,18 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n     length = fold_convert (sizetype, length);\n   if (low_bound == NULL_TREE)\n     low_bound = integer_zero_node;\n-\n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+      && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n+\t  || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_DETACH))\n+    {\n+      if (length != integer_one_node)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"expected single pointer in %qs clause\",\n+\t\t    c_omp_map_clause_name (c, ort == C_ORT_ACC));\n+\t  return error_mark_node;\n+\t}\n+    }\n   if (length != NULL_TREE)\n     {\n       if (!integer_nonzerop (length))\n@@ -13444,7 +13463,11 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n       if (ort != C_ORT_OMP && ort != C_ORT_ACC)\n \tOMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_POINTER);\n       else if (TREE_CODE (t) == COMPONENT_REF)\n-\tOMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALWAYS_POINTER);\n+\t{\n+\t  gomp_map_kind k = (ort == C_ORT_ACC) ? GOMP_MAP_ATTACH_DETACH\n+\t\t\t\t\t       : GOMP_MAP_ALWAYS_POINTER;\n+\t  OMP_CLAUSE_SET_MAP_KIND (c2, k);\n+\t}\n       else\n \tOMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_FIRSTPRIVATE_POINTER);\n       if (OMP_CLAUSE_MAP_KIND (c2) != GOMP_MAP_FIRSTPRIVATE_POINTER\n@@ -13681,6 +13704,35 @@ c_omp_finish_iterators (tree iter)\n   return ret;\n }\n \n+/* Ensure that pointers are used in OpenACC attach and detach clauses.\n+   Return true if an error has been detected.  */\n+\n+static bool\n+c_oacc_check_attachments (tree c)\n+{\n+  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+    return false;\n+\n+  /* OpenACC attach / detach clauses must be pointers.  */\n+  if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n+      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_DETACH)\n+    {\n+      tree t = OMP_CLAUSE_DECL (c);\n+\n+      while (TREE_CODE (t) == TREE_LIST)\n+\tt = TREE_CHAIN (t);\n+\n+      if (TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c), \"expected pointer in %qs clause\",\n+\t\t    c_omp_map_clause_name (c, true));\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* For all elements of CLAUSES, validate them against their constraints.\n    Remove any elements from the list that are invalid.  */\n \n@@ -14434,15 +14486,22 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t}\n \t\t    }\n \t\t}\n+\t      if (c_oacc_check_attachments (c))\n+\t\tremove = true;\n \t      break;\n \t    }\n \t  if (t == error_mark_node)\n \t    {\n \t      remove = true;\n \t      break;\n \t    }\n+\t  /* OpenACC attach / detach clauses must be pointers.  */\n+\t  if (c_oacc_check_attachments (c))\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n \t  if (TREE_CODE (t) == COMPONENT_REF\n-\t      && (ort & C_ORT_OMP)\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE__CACHE_)\n \t    {\n \t      if (DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n@@ -14477,6 +14536,15 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t      break;\n \t\t    }\n \t\t  t = TREE_OPERAND (t, 0);\n+\t\t  if (ort == C_ORT_ACC && TREE_CODE (t) == MEM_REF)\n+\t\t    {\n+\t\t      if (maybe_ne (mem_ref_offset (t), 0))\n+\t\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t  \"cannot dereference %qE in %qs clause\", t,\n+\t\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      else\n+\t\t\tt = TREE_OPERAND (t, 0);\n+\t\t    }\n \t\t}\n \t      if (remove)\n \t\tbreak;"}, {"sha": "2b90d0ca7cfd9887b1a47f8bc0516941867dc713", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -1,3 +1,28 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\n+\t* parser.c (cp_parser_omp_clause_name): Support attach and detach\n+\tclauses.\n+\t(cp_parser_omp_var_list_no_open): Add ALLOW_DEREF optional parameter.\n+\tParse deref if true.\n+\t(cp_parser_omp_var_list): Add ALLOW_DEREF optional parameter.  Pass to\n+\tcp_parser_omp_var_list_no_open.\n+\t(cp_parser_oacc_data_clause): Support attach and detach clauses.\n+\tUpdate call to cp_parser_omp_var_list_no_open.\n+\t(cp_parser_oacc_all_clauses): Support attach and detach.\n+\t(OACC_DATA_CLAUSE_MASK, OACC_ENTER_DATA_CLAUSE_MASK,\n+\tOACC_KERNELS_CLAUSE_MASK, OACC_PARALLEL_CLAUSE_MASK,\n+\tOACC_SERIAL_CLAUSE_MASK): Add PRAGMA_OACC_CLAUSE_ATTACH.\n+\t(OACC_EXIT_DATA_CLAUSE_MASK): Add PRAGMA_OACC_CLAUSE_DETACH.\n+\t* semantics.c (handle_omp_array_sections_1): Reject subarrays for\n+\tattach and detach.\n+\t(handle_omp_array_sections): Use GOMP_MAP_ATTACH_DETACH instead of\n+\tGOMP_MAP_ALWAYS_POINTER for OpenACC.\n+\t(cp_oacc_check_attachments): New function.\n+\t(finish_omp_clauses): Use above function.  Allow structure fields and\n+\tclass members to appear in OpenACC data clauses.  Support\n+\tGOMP_MAP_ATTACH_DETACH.  Support deref.\n+\n 2019-12-19  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/52320 - EH cleanups for partially constructed arrays."}, {"sha": "c3c968d9ce413e638f3c22635a1dbc8a45c12aa3", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -33538,6 +33538,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_ALIGNED;\n \t  else if (!strcmp (\"async\", p))\n \t    result = PRAGMA_OACC_CLAUSE_ASYNC;\n+\t  else if (!strcmp (\"attach\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_ATTACH;\n \t  break;\n \tcase 'b':\n \t  if (!strcmp (\"bind\", p))\n@@ -33562,6 +33564,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_DEFAULTMAP;\n \t  else if (!strcmp (\"depend\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DEPEND;\n+\t  else if (!strcmp (\"detach\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_DETACH;\n \t  else if (!strcmp (\"device\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DEVICE;\n \t  else if (!strcmp (\"deviceptr\", p))\n@@ -33766,11 +33770,15 @@ check_no_duplicate_clause (tree clauses, enum omp_clause_code code,\n \n    COLON can be NULL if only closing parenthesis should end the list,\n    or pointer to bool which will receive false if the list is terminated\n-   by closing parenthesis or true if the list is terminated by colon.  */\n+   by closing parenthesis or true if the list is terminated by colon.\n+\n+   The optional ALLOW_DEREF argument is true if list items can use the deref\n+   (->) operator.  */\n \n static tree\n cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n-\t\t\t\ttree list, bool *colon)\n+\t\t\t\ttree list, bool *colon,\n+\t\t\t\tbool allow_deref = false)\n {\n   cp_token *token;\n   bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n@@ -33851,15 +33859,20 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t    case OMP_CLAUSE_MAP:\n \t    case OMP_CLAUSE_FROM:\n \t    case OMP_CLAUSE_TO:\n-\t      while (cp_lexer_next_token_is (parser->lexer, CPP_DOT))\n+\t      while (cp_lexer_next_token_is (parser->lexer, CPP_DOT)\n+\t\t     || (allow_deref\n+\t\t\t && cp_lexer_next_token_is (parser->lexer, CPP_DEREF)))\n \t\t{\n+\t\t  cpp_ttype ttype\n+\t\t    = cp_lexer_next_token_is (parser->lexer, CPP_DOT)\n+\t\t      ? CPP_DOT : CPP_DEREF;\n \t\t  location_t loc\n \t\t    = cp_lexer_peek_token (parser->lexer)->location;\n \t\t  cp_id_kind idk = CP_ID_KIND_NONE;\n \t\t  cp_lexer_consume_token (parser->lexer);\n \t\t  decl = convert_from_reference (decl);\n \t\t  decl\n-\t\t    = cp_parser_postfix_dot_deref_expression (parser, CPP_DOT,\n+\t\t    = cp_parser_postfix_dot_deref_expression (parser, ttype,\n \t\t\t\t\t\t\t      decl, false,\n \t\t\t\t\t\t\t      &idk, loc);\n \t\t}\n@@ -33977,10 +33990,12 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n    common case for omp clauses.  */\n \n static tree\n-cp_parser_omp_var_list (cp_parser *parser, enum omp_clause_code kind, tree list)\n+cp_parser_omp_var_list (cp_parser *parser, enum omp_clause_code kind, tree list,\n+\t\t\tbool allow_deref = false)\n {\n   if (cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n-    return cp_parser_omp_var_list_no_open (parser, kind, list, NULL);\n+    return cp_parser_omp_var_list_no_open (parser, kind, list, NULL,\n+\t\t\t\t\t   allow_deref);\n   return list;\n }\n \n@@ -33993,7 +34008,9 @@ cp_parser_omp_var_list (cp_parser *parser, enum omp_clause_code kind, tree list)\n    present ( variable-list )\n \n    OpenACC 2.6:\n-   no_create ( variable-list ) */\n+   no_create ( variable-list )\n+   attach ( variable-list )\n+   detach ( variable-list ) */\n \n static tree\n cp_parser_oacc_data_clause (cp_parser *parser, pragma_omp_clause c_kind,\n@@ -34002,6 +34019,9 @@ cp_parser_oacc_data_clause (cp_parser *parser, pragma_omp_clause c_kind,\n   enum gomp_map_kind kind;\n   switch (c_kind)\n     {\n+    case PRAGMA_OACC_CLAUSE_ATTACH:\n+      kind = GOMP_MAP_ATTACH;\n+      break;\n     case PRAGMA_OACC_CLAUSE_COPY:\n       kind = GOMP_MAP_TOFROM;\n       break;\n@@ -34017,6 +34037,9 @@ cp_parser_oacc_data_clause (cp_parser *parser, pragma_omp_clause c_kind,\n     case PRAGMA_OACC_CLAUSE_DELETE:\n       kind = GOMP_MAP_RELEASE;\n       break;\n+    case PRAGMA_OACC_CLAUSE_DETACH:\n+      kind = GOMP_MAP_DETACH;\n+      break;\n     case PRAGMA_OACC_CLAUSE_DEVICE:\n       kind = GOMP_MAP_FORCE_TO;\n       break;\n@@ -34039,7 +34062,7 @@ cp_parser_oacc_data_clause (cp_parser *parser, pragma_omp_clause c_kind,\n       gcc_unreachable ();\n     }\n   tree nl, c;\n-  nl = cp_parser_omp_var_list (parser, OMP_CLAUSE_MAP, list);\n+  nl = cp_parser_omp_var_list (parser, OMP_CLAUSE_MAP, list, true);\n \n   for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n     OMP_CLAUSE_SET_MAP_KIND (c, kind);\n@@ -36517,6 +36540,10 @@ cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t\t  clauses);\n \t  c_name = \"auto\";\n \t  break;\n+\tcase PRAGMA_OACC_CLAUSE_ATTACH:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"attach\";\n+\t  break;\n \tcase PRAGMA_OACC_CLAUSE_COLLAPSE:\n \t  clauses = cp_parser_omp_clause_collapse (parser, clauses, here);\n \t  c_name = \"collapse\";\n@@ -36545,6 +36572,10 @@ cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  clauses = cp_parser_omp_clause_default (parser, clauses, here, true);\n \t  c_name = \"default\";\n \t  break;\n+\tcase PRAGMA_OACC_CLAUSE_DETACH:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"detach\";\n+\t  break;\n \tcase PRAGMA_OACC_CLAUSE_DEVICE:\n \t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n \t  c_name = \"device\";\n@@ -40397,10 +40428,12 @@ cp_parser_oacc_cache (cp_parser *parser, cp_token *pragma_tok)\n      structured-block  */\n \n #define OACC_DATA_CLAUSE_MASK\t\t\t\t\t\t\\\n-\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ATTACH)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DETACH)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DEVICEPTR)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_NO_CREATE)\t\t\\\n@@ -40601,6 +40634,7 @@ cp_parser_oacc_declare (cp_parser *parser, cp_token *pragma_tok)\n \n #define OACC_ENTER_DATA_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ATTACH)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n@@ -40611,6 +40645,7 @@ cp_parser_oacc_declare (cp_parser *parser, cp_token *pragma_tok)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DELETE) \t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DETACH)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_FINALIZE) \t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT) )\n \n@@ -40718,6 +40753,7 @@ cp_parser_oacc_loop (cp_parser *parser, cp_token *pragma_tok, char *p_name,\n \n #define OACC_KERNELS_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ATTACH)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n@@ -40734,6 +40770,7 @@ cp_parser_oacc_loop (cp_parser *parser, cp_token *pragma_tok, char *p_name,\n \n #define OACC_PARALLEL_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ATTACH)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n@@ -40753,6 +40790,7 @@ cp_parser_oacc_loop (cp_parser *parser, cp_token *pragma_tok, char *p_name,\n \n #define OACC_SERIAL_CLAUSE_MASK\t\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ATTACH)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\"}, {"sha": "a3058d7a78751b6bd9e39d27d11153d71bc7e3d1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 86, "deletions": 12, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -4744,7 +4744,6 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \tt = TREE_OPERAND (t, 0);\n       ret = t;\n       if (TREE_CODE (t) == COMPONENT_REF\n-\t  && ort == C_ORT_OMP\n \t  && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FROM)\n@@ -4768,6 +4767,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t  return error_mark_node;\n \t\t}\n \t      t = TREE_OPERAND (t, 0);\n+\t      if (ort == C_ORT_ACC && TREE_CODE (t) == INDIRECT_REF)\n+\t\tt = TREE_OPERAND (t, 0);\n \t    }\n \t  if (REFERENCE_REF_P (t))\n \t    t = TREE_OPERAND (t, 0);\n@@ -4867,6 +4868,18 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n   if (low_bound == NULL_TREE)\n     low_bound = integer_zero_node;\n \n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+      && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n+\t  || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_DETACH))\n+    {\n+      if (length != integer_one_node)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"expected single pointer in %qs clause\",\n+\t\t    c_omp_map_clause_name (c, ort == C_ORT_ACC));\n+\t  return error_mark_node;\n+\t}\n+    }\n   if (length != NULL_TREE)\n     {\n       if (!integer_nonzerop (length))\n@@ -5315,12 +5328,18 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t  if ((ort & C_ORT_OMP_DECLARE_SIMD) != C_ORT_OMP && ort != C_ORT_ACC)\n \t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_POINTER);\n \t  else if (TREE_CODE (t) == COMPONENT_REF)\n-\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALWAYS_POINTER);\n+\t    {\n+\t      gomp_map_kind k = (ort == C_ORT_ACC) ? GOMP_MAP_ATTACH_DETACH\n+\t\t\t\t\t\t   : GOMP_MAP_ALWAYS_POINTER;\n+\t      OMP_CLAUSE_SET_MAP_KIND (c2, k);\n+\t    }\n \t  else if (REFERENCE_REF_P (t)\n \t\t   && TREE_CODE (TREE_OPERAND (t, 0)) == COMPONENT_REF)\n \t    {\n \t      t = TREE_OPERAND (t, 0);\n-\t      OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALWAYS_POINTER);\n+\t      gomp_map_kind k = (ort == C_ORT_ACC) ? GOMP_MAP_ATTACH_DETACH\n+\t\t\t\t\t\t   : GOMP_MAP_ALWAYS_POINTER;\n+\t      OMP_CLAUSE_SET_MAP_KIND (c2, k);\n \t    }\n \t  else\n \t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_FIRSTPRIVATE_POINTER);\n@@ -6243,6 +6262,41 @@ cp_omp_finish_iterators (tree iter)\n   return ret;\n }\n \n+/* Ensure that pointers are used in OpenACC attach and detach clauses.\n+   Return true if an error has been detected.  */\n+\n+static bool\n+cp_oacc_check_attachments (tree c)\n+{\n+  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+    return false;\n+\n+  /* OpenACC attach / detach clauses must be pointers.  */\n+  if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n+      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_DETACH)\n+    {\n+      tree t = OMP_CLAUSE_DECL (c);\n+      tree type;\n+\n+      while (TREE_CODE (t) == TREE_LIST)\n+\tt = TREE_CHAIN (t);\n+\n+      type = TREE_TYPE (t);\n+\n+      if (TREE_CODE (type) == REFERENCE_TYPE)\n+\ttype = TREE_TYPE (type);\n+\n+      if (TREE_CODE (type) != POINTER_TYPE)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c), \"expected pointer in %qs clause\",\n+\t\t    c_omp_map_clause_name (c, true));\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* For all elements of CLAUSES, validate them vs OpenMP constraints.\n    Remove any elements from the list that are invalid.  */\n \n@@ -6507,7 +6561,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    t = OMP_CLAUSE_DECL (c);\n \tcheck_dup_generic_t:\n \t  if (t == current_class_ptr\n-\t      && (ort != C_ORT_OMP_DECLARE_SIMD\n+\t      && ((ort != C_ORT_OMP_DECLARE_SIMD && ort != C_ORT_ACC)\n \t\t  || (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_LINEAR\n \t\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_UNIFORM)))\n \t    {\n@@ -6577,8 +6631,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \thandle_field_decl:\n \t  if (!remove\n \t      && TREE_CODE (t) == FIELD_DECL\n-\t      && t == OMP_CLAUSE_DECL (c)\n-\t      && ort != C_ORT_ACC)\n+\t      && t == OMP_CLAUSE_DECL (c))\n \t    {\n \t      OMP_CLAUSE_DECL (c)\n \t\t= omp_privatize_field (t, (OMP_CLAUSE_CODE (c)\n@@ -6645,7 +6698,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    omp_note_field_privatization (t, OMP_CLAUSE_DECL (c));\n \t  else\n \t    t = OMP_CLAUSE_DECL (c);\n-\t  if (t == current_class_ptr)\n+\t  if (ort != C_ORT_ACC && t == current_class_ptr)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n@@ -7134,7 +7187,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  if (t == error_mark_node)\n \t    remove = true;\n-\t  else if (t == current_class_ptr)\n+\t  else if (ort != C_ORT_ACC && t == current_class_ptr)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n@@ -7266,21 +7319,34 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t}\n \t\t    }\n \t\t}\n+\t      if (cp_oacc_check_attachments (c))\n+\t\tremove = true;\n \t      break;\n \t    }\n \t  if (t == error_mark_node)\n \t    {\n \t      remove = true;\n \t      break;\n \t    }\n+\t  /* OpenACC attach / detach clauses must be pointers.  */\n+\t  if (cp_oacc_check_attachments (c))\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n \t  if (REFERENCE_REF_P (t)\n \t      && TREE_CODE (TREE_OPERAND (t, 0)) == COMPONENT_REF)\n \t    {\n \t      t = TREE_OPERAND (t, 0);\n \t      OMP_CLAUSE_DECL (c) = t;\n \t    }\n+\t  if (ort == C_ORT_ACC\n+\t      && TREE_CODE (t) == COMPONENT_REF\n+\t      && TREE_CODE (TREE_OPERAND (t, 0)) == INDIRECT_REF)\n+\t    t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n \t  if (TREE_CODE (t) == COMPONENT_REF\n-\t      && (ort & C_ORT_OMP_DECLARE_SIMD) == C_ORT_OMP\n+\t      && ((ort & C_ORT_OMP_DECLARE_SIMD) == C_ORT_OMP\n+\t\t  || ort == C_ORT_ACC)\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE__CACHE_)\n \t    {\n \t      if (type_dependent_expression_p (t))\n@@ -7330,7 +7396,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\tbreak;\n \t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t  && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n-\t\t      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_POINTER))\n+\t\t      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_POINTER\n+\t\t      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH))\n \t\tbreak;\n \t      if (DECL_P (t))\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n@@ -7412,7 +7479,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      else\n \t\tbitmap_set_bit (&generic_head, DECL_UID (t));\n \t    }\n-\t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n+\t  else if (bitmap_bit_p (&map_head, DECL_UID (t))\n+\t\t   && (ort != C_ORT_ACC\n+\t\t       || !bitmap_bit_p (&map_field_head, DECL_UID (t))))\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n@@ -7467,7 +7536,12 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t      OMP_CLAUSE_MAP);\n \t\t  if (TREE_CODE (t) == COMPONENT_REF)\n-\t\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALWAYS_POINTER);\n+\t\t    {\n+\t\t      gomp_map_kind k\n+\t\t\t= (ort == C_ORT_ACC) ? GOMP_MAP_ATTACH_DETACH\n+\t\t\t\t\t     : GOMP_MAP_ALWAYS_POINTER;\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (c2, k);\n+\t\t    }\n \t\t  else\n \t\t    OMP_CLAUSE_SET_MAP_KIND (c2,\n \t\t\t\t\t     GOMP_MAP_FIRSTPRIVATE_REFERENCE);"}, {"sha": "9cd38fd2a1a1f8608ec4a56a34bdea250ef1669a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -1,3 +1,11 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\n+\t* c-c++-common/goacc/deep-copy-arrayofstruct.c: New test.\n+\t* c-c++-common/goacc/mdc-1.c: New test.\n+\t* c-c++-common/goacc/mdc-2.c: New test.\n+\t* gcc.dg/goacc/mdc.C: New test.\n+\n 2019-12-19  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/92905"}, {"sha": "d411bcfa8e7cd41473e4c82ef03f08fb61f77f66", "filename": "gcc/testsuite/c-c++-common/goacc/deep-copy-arrayofstruct.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeep-copy-arrayofstruct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeep-copy-arrayofstruct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeep-copy-arrayofstruct.c?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-do compile } */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+typedef struct {\n+  int *a;\n+  int *b;\n+  int *c;\n+} mystruct;\n+\n+int main(int argc, char* argv[])\n+{\n+  const int N = 1024;\n+  const int S = 32;\n+  mystruct *m = (mystruct *) calloc (S, sizeof (*m));\n+  int i, j;\n+\n+  for (i = 0; i < S; i++)\n+    {\n+      m[i].a = (int *) malloc (N * sizeof (int));\n+      m[i].b = (int *) malloc (N * sizeof (int));\n+      m[i].c = (int *) malloc (N * sizeof (int));\n+    }\n+\n+  for (j = 0; j < S; j++)\n+    for (i = 0; i < N; i++)\n+      {\n+\tm[j].a[i] = 0;\n+\tm[j].b[i] = 0;\n+\tm[j].c[i] = 0;\n+      }\n+\n+#pragma acc enter data copyin(m[0:1])\n+\n+  for (int i = 0; i < 99; i++)\n+    {\n+      int j, k;\n+      for (k = 0; k < S; k++)\n+#pragma acc parallel loop copy(m[k].a[0:N]) /* { dg-error \"expected .\\\\\\). before .\\\\\\.. token\" } */\n+        for (j = 0; j < N; j++)\n+          m[k].a[j]++;\n+\n+      for (k = 0; k < S; k++)\n+#pragma acc parallel loop copy(m[k].b[0:N], m[k].c[5:N-10]) /* { dg-error \"expected .\\\\\\). before .\\\\\\.. token\" } */\n+\t/* { dg-error \".m. appears more than once in data clauses\" \"\" { target c++ } .-1 } */\n+\tfor (j = 0; j < N; j++)\n+\t  {\n+\t    m[k].b[j]++;\n+\t    if (j > 5 && j < N - 5)\n+\t      m[k].c[j]++;\n+\t}\n+    }\n+\n+#pragma acc exit data copyout(m[0:1])\n+\n+  for (j = 0; j < S; j++)\n+    {\n+      for (i = 0; i < N; i++)\n+\t{\n+\t  if (m[j].a[i] != 99)\n+\t    abort ();\n+\t  if (m[j].b[i] != 99)\n+\t    abort ();\n+\t  if (i > 5 && i < N-5)\n+\t    {\n+\t      if (m[j].c[i] != 99)\n+\t\tabort ();\n+\t    }\n+\t  else\n+\t    {\n+\t      if (m[j].c[i] != 0)\n+\t\tabort ();\n+\t    }\n+\t}\n+\n+      free (m[j].a);\n+      free (m[j].b);\n+      free (m[j].c);\n+    }\n+  free (m);\n+\n+  return 0;\n+}"}, {"sha": "6c6a81ea73a5dcc108a3429b3de8b1b74869fba9", "filename": "gcc/testsuite/c-c++-common/goacc/mdc-1.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fmdc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fmdc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fmdc-1.c?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -0,0 +1,55 @@\n+/* Test OpenACC's support for manual deep copy, including the attach\n+   and detach clauses.  */\n+\n+/* { dg-do compile { target int32 } } */\n+/* { dg-additional-options \"-fdump-tree-omplower\" } */\n+\n+void\n+t1 ()\n+{\n+  struct foo {\n+    int *a, *b, c, d, *e;\n+  } s;\n+\n+  int *a, *z;\n+\n+#pragma acc enter data copyin(s)\n+  {\n+#pragma acc data copy(s.a[0:10]) copy(z[0:10])\n+    {\n+      s.e = z;\n+#pragma acc parallel loop attach(s.e)\n+      for (int i = 0; i < 10; i++)\n+        s.a[i] = s.e[i];\n+\n+\n+      a = s.e;\n+#pragma acc enter data attach(a)\n+#pragma acc exit data detach(a)\n+    }\n+\n+#pragma acc enter data copyin(a)\n+#pragma acc acc enter data attach(s.e)\n+#pragma acc exit data detach(s.e)\n+\n+#pragma acc data attach(s.e)\n+    {\n+    }\n+#pragma acc exit data delete(a)\n+\n+#pragma acc exit data detach(a) finalize\n+#pragma acc exit data detach(s.a) finalize\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_enter_exit_data map.to:s .len: 32..\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_data map.tofrom:.z .len: 40.. map.struct:s .len: 1.. map.alloc:s.a .len: 8.. map.tofrom:._1 .len: 40.. map.attach:s.a .bias: 0..\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_parallel map.attach:s.e .bias: 8.. map.tofrom:s .len: 32\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_enter_exit_data map.attach:a .bias: 8..\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_enter_exit_data map.detach:a .bias: 8..\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_enter_exit_data map.to:a .len: 8..\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_enter_exit_data map.detach:s.e .bias: 8..\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_data map.attach:s.e .bias: 8..\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_enter_exit_data map.release:a .len: 8..\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_enter_exit_data finalize map.force_detach:a .bias: 8..\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_enter_exit_data finalize map.force_detach:s.a .bias: 8..\" 1 \"omplower\" } } */"}, {"sha": "fae86671fc991a5400414161fce06729cda8bc98", "filename": "gcc/testsuite/c-c++-common/goacc/mdc-2.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fmdc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fmdc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fmdc-2.c?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -0,0 +1,62 @@\n+/* Test OpenACC's support for manual deep copy, including the attach\n+   and detach clauses.  */\n+\n+void\n+t1 ()\n+{\n+  struct foo {\n+    int *a, *b, c, d, *e;\n+  } s;\n+\n+  int *a, *z, scalar, **y;\n+\n+#pragma acc enter data copyin(s) detach(z) /* { dg-error \".detach. is not valid for\" } */\n+  {\n+#pragma acc data copy(s.a[0:10]) copy(z[0:10])\n+    {\n+      s.e = z;\n+#pragma acc parallel loop attach(s.e) detach(s.b) /* { dg-error \".detach. is not valid for\" } */\n+      for (int i = 0; i < 10; i++)\n+        s.a[i] = s.e[i];\n+\n+      a = s.e;\n+#pragma acc enter data attach(a) detach(s.c) /* { dg-error \".detach. is not valid for\" } */\n+#pragma acc exit data detach(a)\n+    }\n+\n+#pragma acc enter data attach(z[:5]) /* { dg-error \"expected single pointer in .attach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc exit data detach(z[:5]) /* { dg-error \"expected single pointer in .detach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc enter data attach(z[1:]) /* { dg-error \"expected single pointer in .attach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc exit data detach(z[1:]) /* { dg-error \"expected single pointer in .detach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc enter data attach(z[:]) /* { dg-error \"expected single pointer in .attach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc exit data detach(z[:]) /* { dg-error \"expected single pointer in .detach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc enter data attach(z[3]) /* { dg-error \"expected pointer in .attach. clause\" } */\n+#pragma acc exit data detach(z[3]) /* { dg-error \"expected pointer in .detach. clause\" } */\n+\n+#pragma acc acc enter data attach(s.e)\n+#pragma acc exit data detach(s.e) attach(z) /* { dg-error \".attach. is not valid for\" } */\n+\n+#pragma acc data attach(s.e)\n+    {\n+    }\n+#pragma acc exit data delete(a) attach(s.a) /* { dg-error \".attach. is not valid for\" } */\n+\n+#pragma acc enter data attach(scalar) /* { dg-error \"expected pointer in .attach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc exit data detach(scalar) /* { dg-error \"expected pointer in .detach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc enter data attach(s) /* { dg-error \"expected pointer in .attach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc exit data detach(s) /* { dg-error \"expected pointer in .detach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+  }\n+\n+#pragma acc enter data attach(y[10])\n+#pragma acc exit data detach(y[10])\n+}"}, {"sha": "b3abab304230abf78f20b248ec08996b9fbe3aeb", "filename": "gcc/testsuite/g++.dg/goacc/mdc.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fmdc.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519d7496beac32c26448c1d0eea176c90f543702/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fmdc.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fmdc.C?ref=519d7496beac32c26448c1d0eea176c90f543702", "patch": "@@ -0,0 +1,68 @@\n+/* Test OpenACC's support for manual deep copy, including the attach\n+   and detach clauses.  */\n+\n+void\n+t1 ()\n+{\n+  struct foo {\n+    int *a, *b, c, d, *e;\n+  } s;\n+\n+  struct foo& rs = s;\n+  \n+  int *a, *z, scalar, **y;\n+  int* const &ra = a;\n+  int* const &rz = z;\n+  int& rscalar = scalar;\n+  int** const &ry = y;\n+\n+#pragma acc enter data copyin(rs) detach(rz) /* { dg-error \".detach. is not valid for\" } */\n+  {\n+#pragma acc data copy(rs.a[0:10]) copy(rz[0:10])\n+    {\n+      s.e = z;\n+#pragma acc parallel loop attach(rs.e) detach(rs.b) /* { dg-error \".detach. is not valid for\" } */\n+      for (int i = 0; i < 10; i++)\n+        s.a[i] = s.e[i];\n+\n+      a = s.e;\n+#pragma acc enter data attach(ra) detach(rs.c) /* { dg-error \".detach. is not valid for\" } */\n+#pragma acc exit data detach(ra)\n+    }\n+\n+#pragma acc enter data attach(rz[:5]) /* { dg-error \"expected single pointer in .attach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc exit data detach(rz[:5]) /* { dg-error \"expected single pointer in .detach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc enter data attach(rz[1:]) /* { dg-error \"expected single pointer in .attach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc exit data detach(rz[1:]) /* { dg-error \"expected single pointer in .detach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc enter data attach(rz[:]) /* { dg-error \"expected single pointer in .attach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc exit data detach(rz[:]) /* { dg-error \"expected single pointer in .detach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc enter data attach(rz[3]) /* { dg-error \"expected pointer in .attach. clause\" } */\n+#pragma acc exit data detach(rz[3]) /* { dg-error \"expected pointer in .detach. clause\" } */\n+\n+#pragma acc acc enter data attach(rs.e)\n+#pragma acc exit data detach(rs.e) attach(rz) /* { dg-error \".attach. is not valid for\" } */\n+\n+#pragma acc data attach(rs.e)\n+    {\n+    }\n+#pragma acc exit data delete(ra) attach(rs.a) /* { dg-error \".attach. is not valid for\" } */\n+\n+#pragma acc enter data attach(rscalar) /* { dg-error \"expected pointer in .attach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc exit data detach(rscalar) /* { dg-error \"expected pointer in .detach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc enter data attach(rs) /* { dg-error \"expected pointer in .attach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+#pragma acc exit data detach(rs) /* { dg-error \"expected pointer in .detach. clause\" } */\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } .-1 } */\n+  }\n+\n+#pragma acc enter data attach(ry[10])\n+#pragma acc exit data detach(ry[10])\n+}"}]}