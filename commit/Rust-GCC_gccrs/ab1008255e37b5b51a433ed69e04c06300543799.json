{"sha": "ab1008255e37b5b51a433ed69e04c06300543799", "node_id": "C_kwDOANBUbNoAKGFiMTAwODI1NWUzN2I1YjUxYTQzM2VkNjllMDRjMDYzMDA1NDM3OTk", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-10-27T12:49:01Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-10-27T13:11:47Z"}, "message": "ipa-cp: Select saner profile count to base heuristics on\n\nWhen profile feedback is available, IPA-CP takes the count of the\nhottest node and then evaluates all call contexts relative to it.\nThis means that typically almost no clones for specialized contexts\nare ever created because the maximum is some special function, called\nfrom everywhere (that is likely to get inlined anyway) and all the\nexamined edges look cold compared to it.\n\nThis patch changes the selection.  It simply sorts counts of all edges\neligible for cloning in a vector and then picks the count in 90th\npercentile (the actual number is configurable via a parameter).\n\nI also tried more complex approaches which were summing the counts and\npicking the edge which together with all hotter edges accounted for a\ngiven portion of the total sum of all edge counts.  But first it was\nnot apparently clear to me that they make more logical sense that the\nsimple method and practically I always also had to ignore a few\npercent of the hottest edges with really extreme counts (looking at\nbash and python).  And when I had to do that anyway, it seemed simpler\nto just \"ignore\" more and take the first non-ignored count as the\nbase.\n\nNevertheless, if people think some more sophisticated method should be\nused anyway, I am willing to be persuaded.  But this patch is a clear\nimprovement over the current situation.\n\ngcc/ChangeLog:\n\n2021-10-26  Martin Jambor  <mjambor@suse.cz>\n\n\t* params.opt (param_ipa_cp_profile_count_base): New parameter.\n\t* doc/invoke.texi (Optimize Options): Add entry for\n\tipa-cp-profile-count-base.\n\t* ipa-cp.c (max_count): Replace with base_count, replace all\n\toccurrences too, unless otherwise stated.\n\t(ipcp_cloning_candidate_p): identify mostly-directly called\n\tfunctions based on their counts, not max_count.\n\t(compare_edge_profile_counts): New function.\n\t(ipcp_propagate_stage): Instead of setting max_count, find the\n\tappropriate edge count in a sorted vector of counts of eligible\n\tedges and make it the base_count.", "tree": {"sha": "ed0d96d90686965d9ab41850716c5d28b84d29ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed0d96d90686965d9ab41850716c5d28b84d29ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab1008255e37b5b51a433ed69e04c06300543799", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmF5UBMACgkQv2PBvD+k\nNUBi/hAAs/GB+8zpzmSjog40Qt+YDrb64YCyAcoHgL6Ksmtzej1V4hg7kSbEbVq6\nK+qOEQN/zwE12GnHfijXlfsX+8WKrtOBdudZmU3ipWemk4PBjlYjqHmJsSop3Yid\niVbO4F1XGHh3LEeXQBM+8nVpcsjtV9tZ79cTzAQBEduQ6l8e8GOxC+1xFag1MS/q\nH+tczwuh7m/in7A6PowRJJanOF7HIw4FqHphYVtJjPK9k9vFG+2tEIvHrh5pZ/N+\nDRLmXwfEMFwEyxZGWvMb4mhuRuPOlKuq7prrSwAdFiZLdz90hcM13BuQwIick9Jk\nWXAkPm3h9OEG/IAM3wgDP+nGQwK7AmFRGaA/llBeieNWywWh665yrGmkSwktEEeS\na23ycLixzd9Jy0STIihb5BnX2DFd6jAhIm46Q/1KWm6tMJgGHspUf3WfKfp17oI7\n2jMI5gh21y5lmYoUsb9IfTUe17wzBP4OBehJn94zkkTzbqF5ZeRUF4tnLcWT3Vx0\nyj9WK23H0DfEYmwf4fxglkYtQXAuqTfaSoSRRcnEUHkH3PLPYp30z2tS6BL7063n\niPIs9r/0yYTxDTy2nopwICmZdMSE3gXlVe97W+lawbLMqIe0DsLUlImE68rGF8si\nsJ1/QLtuunsGEOKawSVFEjvqZeDrvnHqyEYkqgxloeSPAZcQbDU=\n=8RI/\n-----END PGP SIGNATURE-----", "payload": "tree ed0d96d90686965d9ab41850716c5d28b84d29ea\nparent d1e2e4f9ce4df50564f1244dcea9befc3066faa8\nauthor Martin Jambor <mjambor@suse.cz> 1635338941 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1635340307 +0200\n\nipa-cp: Select saner profile count to base heuristics on\n\nWhen profile feedback is available, IPA-CP takes the count of the\nhottest node and then evaluates all call contexts relative to it.\nThis means that typically almost no clones for specialized contexts\nare ever created because the maximum is some special function, called\nfrom everywhere (that is likely to get inlined anyway) and all the\nexamined edges look cold compared to it.\n\nThis patch changes the selection.  It simply sorts counts of all edges\neligible for cloning in a vector and then picks the count in 90th\npercentile (the actual number is configurable via a parameter).\n\nI also tried more complex approaches which were summing the counts and\npicking the edge which together with all hotter edges accounted for a\ngiven portion of the total sum of all edge counts.  But first it was\nnot apparently clear to me that they make more logical sense that the\nsimple method and practically I always also had to ignore a few\npercent of the hottest edges with really extreme counts (looking at\nbash and python).  And when I had to do that anyway, it seemed simpler\nto just \"ignore\" more and take the first non-ignored count as the\nbase.\n\nNevertheless, if people think some more sophisticated method should be\nused anyway, I am willing to be persuaded.  But this patch is a clear\nimprovement over the current situation.\n\ngcc/ChangeLog:\n\n2021-10-26  Martin Jambor  <mjambor@suse.cz>\n\n\t* params.opt (param_ipa_cp_profile_count_base): New parameter.\n\t* doc/invoke.texi (Optimize Options): Add entry for\n\tipa-cp-profile-count-base.\n\t* ipa-cp.c (max_count): Replace with base_count, replace all\n\toccurrences too, unless otherwise stated.\n\t(ipcp_cloning_candidate_p): identify mostly-directly called\n\tfunctions based on their counts, not max_count.\n\t(compare_edge_profile_counts): New function.\n\t(ipcp_propagate_stage): Instead of setting max_count, find the\n\tappropriate edge count in a sorted vector of counts of eligible\n\tedges and make it the base_count.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab1008255e37b5b51a433ed69e04c06300543799", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab1008255e37b5b51a433ed69e04c06300543799", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab1008255e37b5b51a433ed69e04c06300543799/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1e2e4f9ce4df50564f1244dcea9befc3066faa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e2e4f9ce4df50564f1244dcea9befc3066faa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e2e4f9ce4df50564f1244dcea9befc3066faa8"}], "stats": {"total": 91, "additions": 83, "deletions": 8}, "files": [{"sha": "b64ec18ae46e744a12577ddeafbe275215a5bf4f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab1008255e37b5b51a433ed69e04c06300543799/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab1008255e37b5b51a433ed69e04c06300543799/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ab1008255e37b5b51a433ed69e04c06300543799", "patch": "@@ -14246,6 +14246,11 @@ Maximum depth of recursive cloning for self-recursive function.\n Recursive cloning only when the probability of call being executed exceeds\n the parameter.\n \n+@item ipa-cp-profile-count-base\n+When using @option{-fprofile-use} option, IPA-CP will consider the measured\n+execution count of a call graph edge at this percentage position in their\n+histogram as the basis for its heuristics calculation.\n+\n @item ipa-cp-recursive-freq-factor\n The number of times interprocedural copy propagation expects recursive\n functions to call themselves."}, {"sha": "4d07a6d0a5861f0205a58d5a3f3a7c01233cf0cd", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 74, "deletions": 8, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab1008255e37b5b51a433ed69e04c06300543799/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab1008255e37b5b51a433ed69e04c06300543799/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ab1008255e37b5b51a433ed69e04c06300543799", "patch": "@@ -400,9 +400,9 @@ object_allocator<ipcp_value_source<tree> > ipcp_sources_pool\n object_allocator<ipcp_agg_lattice> ipcp_agg_lattice_pool\n   (\"IPA_CP aggregate lattices\");\n \n-/* Maximal count found in program.  */\n+/* Base count to use in heuristics when using profile feedback.  */\n \n-static profile_count max_count;\n+static profile_count base_count;\n \n /* Original overall size of the program.  */\n \n@@ -809,7 +809,8 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   /* When profile is available and function is hot, propagate into it even if\n      calls seems cold; constant propagation can improve function's speed\n      significantly.  */\n-  if (max_count > profile_count::zero ())\n+  if (stats.count_sum > profile_count::zero ()\n+      && node->count.ipa ().initialized_p ())\n     {\n       if (stats.count_sum > node->count.ipa ().apply_scale (90, 100))\n \t{\n@@ -3310,10 +3311,10 @@ good_cloning_opportunity_p (struct cgraph_node *node, sreal time_benefit,\n \n   ipa_node_params *info = ipa_node_params_sum->get (node);\n   int eval_threshold = opt_for_fn (node->decl, param_ipa_cp_eval_threshold);\n-  if (max_count > profile_count::zero ())\n+  if (base_count > profile_count::zero ())\n     {\n \n-      sreal factor = count_sum.probability_in (max_count).to_sreal ();\n+      sreal factor = count_sum.probability_in (base_count).to_sreal ();\n       sreal evaluation = (time_benefit * factor) / size_cost;\n       evaluation = incorporate_penalties (node, info, evaluation);\n       evaluation *= 1000;\n@@ -3950,6 +3951,21 @@ value_topo_info<valtype>::propagate_effects ()\n     }\n }\n \n+/* Callback for qsort to sort counts of all edges.  */\n+\n+static int\n+compare_edge_profile_counts (const void *a, const void *b)\n+{\n+  const profile_count *cnt1 = (const profile_count *) a;\n+  const profile_count *cnt2 = (const profile_count *) b;\n+\n+  if (*cnt1 < *cnt2)\n+    return 1;\n+  if (*cnt1 > *cnt2)\n+    return -1;\n+  return 0;\n+}\n+\n \n /* Propagate constants, polymorphic contexts and their effects from the\n    summaries interprocedurally.  */\n@@ -3962,8 +3978,10 @@ ipcp_propagate_stage (class ipa_topo_info *topo)\n   if (dump_file)\n     fprintf (dump_file, \"\\n Propagating constants:\\n\\n\");\n \n-  max_count = profile_count::uninitialized ();\n+  base_count = profile_count::uninitialized ();\n \n+  bool compute_count_base = false;\n+  unsigned base_count_pos_percent = 0;\n   FOR_EACH_DEFINED_FUNCTION (node)\n   {\n     if (node->has_gimple_body_p ()\n@@ -3981,9 +3999,57 @@ ipcp_propagate_stage (class ipa_topo_info *topo)\n     ipa_size_summary *s = ipa_size_summaries->get (node);\n     if (node->definition && !node->alias && s != NULL)\n       overall_size += s->self_size;\n-    max_count = max_count.max (node->count.ipa ());\n+    if (node->count.ipa ().initialized_p ())\n+      {\n+\tcompute_count_base = true;\n+\tunsigned pos_percent = opt_for_fn (node->decl,\n+\t\t\t\t\t   param_ipa_cp_profile_count_base);\n+\tbase_count_pos_percent = MAX (base_count_pos_percent, pos_percent);\n+      }\n   }\n \n+  if (compute_count_base)\n+    {\n+      auto_vec<profile_count> all_edge_counts;\n+      all_edge_counts.reserve_exact (symtab->edges_count);\n+      FOR_EACH_DEFINED_FUNCTION (node)\n+\tfor (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n+\t  {\n+\t    profile_count count = cs->count.ipa ();\n+\t    if (!(count > profile_count::zero ()))\n+\t      continue;\n+\n+\t    enum availability avail;\n+\t    cgraph_node *tgt\n+\t      = cs->callee->function_or_virtual_thunk_symbol (&avail);\n+\t    ipa_node_params *info = ipa_node_params_sum->get (tgt);\n+\t    if (info && info->versionable)\n+\t      all_edge_counts.quick_push (count);\n+\t  }\n+\n+      if (!all_edge_counts.is_empty ())\n+\t{\n+\t  gcc_assert (base_count_pos_percent <= 100);\n+\t  all_edge_counts.qsort (compare_edge_profile_counts);\n+\n+\t  unsigned base_count_pos\n+\t    = ((all_edge_counts.length () * (base_count_pos_percent)) / 100);\n+\t  base_count = all_edge_counts[base_count_pos];\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"\\nSelected base_count from %u edges at \"\n+\t\t       \"position %u, arriving at: \", all_edge_counts.length (),\n+\t\t       base_count_pos);\n+\t      base_count.dump (dump_file);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t}\n+      else if (dump_file)\n+\tfprintf (dump_file, \"\\nNo candidates with non-zero call count found, \"\n+\t\t \"continuing as if without profile feedback.\\n\");\n+    }\n+\n   orig_overall_size = overall_size;\n \n   if (dump_file)\n@@ -6567,7 +6633,7 @@ make_pass_ipa_cp (gcc::context *ctxt)\n void\n ipa_cp_c_finalize (void)\n {\n-  max_count = profile_count::uninitialized ();\n+  base_count = profile_count::uninitialized ();\n   overall_size = 0;\n   orig_overall_size = 0;\n   ipcp_free_transformation_sum ();"}, {"sha": "7ee7820f11f973e78b328bf922525accd9c2dbd1", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab1008255e37b5b51a433ed69e04c06300543799/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab1008255e37b5b51a433ed69e04c06300543799/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=ab1008255e37b5b51a433ed69e04c06300543799", "patch": "@@ -273,6 +273,10 @@ The size of translation unit that IPA-CP pass considers large.\n Common Joined UInteger Var(param_ipa_cp_value_list_size) Init(8) Param Optimization\n Maximum size of a list of values associated with each parameter for interprocedural constant propagation.\n \n+-param=ipa-cp-profile-count-base=\n+Common Joined UInteger Var(param_ipa_cp_profile_count_base) Init(10) IntegerRange(0, 100) Param Optimization\n+When using profile feedback, use the edge at this percentage position in frequncy histogram as the bases for IPA-CP heuristics.\n+\n -param=ipa-jump-function-lookups=\n Common Joined UInteger Var(param_ipa_jump_function_lookups) Init(8) Param Optimization\n Maximum number of statements visited during jump function offset discovery."}]}