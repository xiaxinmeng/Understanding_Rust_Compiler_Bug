{"sha": "a4dd85e01599890286d9af5b106a1ab20e51169e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRkZDg1ZTAxNTk5ODkwMjg2ZDlhZjViMTA2YTFhYjIwZTUxMTY5ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-14T00:46:16Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-14T00:46:16Z"}, "message": "openmp: Add support for non-VLA {,first}private allocate on omp task\n\nThis patch adds support for custom allocators on private/firstprivate\nclauses for task (and taskloop) constructs.  Private didn't need anything\nspecial, but firstprivate if it is passed by reference needs the GOMP_alloc\ncalls in the copyfn and GOMP_free in the task body.\n\n2020-11-14  Jakub Jelinek  <jakub@redhat.com>\n\n\t* gimplify.c (gimplify_omp_for): Add OMP_CLAUSE_ALLOCATE_ALLOCATOR\n\tdecls as firstprivate on task clauses even when allocate clause\n\tdecl is not lastprivate.\n\t* omp-low.c (install_var_field): Don't dereference omp_is_reference\n\ttypes if mask is 33 rather than 1.\n\t(scan_sharing_clauses): Populate allocate_map even for task\n\tconstructs.  For now remove it back for variables mentioned in\n\treduction and in_reduction clauses on task/taskloop constructs\n\tor on VLA task firstprivates.  For firstprivate on task construct,\n\tinstall the var field into field_map with by_ref and 33 instead\n\tof false and 1 if mentioned in allocate clause.\n\t(lower_private_allocate): Set TREE_THIS_NOTRAP on the created\n\tMEM_REF.\n\t(lower_rec_input_clauses): Handle allocate for task firstprivatized\n\tnon-VLA variables.\n\t(create_task_copyfn): Likewise.\n\n\t* testsuite/libgomp.c-c++-common/allocate-1.c (struct S): New type.\n\t(foo): Add tests for non-VLA private and firstprivate clauses on\n\tomp task.\n\t(bar): Likewise.  Remove taking of address from private/firstprivate\n\tvariables.\n\t* testsuite/libgomp.c++/allocate-1.C (struct S): New type.\n\t(foo): Add p, q, px and s arguments.  Add tests for array reductions\n\tand for non-VLA private and firstprivate clauses on omp task.\n\t(bar): Removed.\n\t(main): Adjust foo caller.  Don't call bar.", "tree": {"sha": "3ea1bdeca840ecb5e7708bb78903693eeae47cf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ea1bdeca840ecb5e7708bb78903693eeae47cf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4dd85e01599890286d9af5b106a1ab20e51169e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4dd85e01599890286d9af5b106a1ab20e51169e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4dd85e01599890286d9af5b106a1ab20e51169e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4dd85e01599890286d9af5b106a1ab20e51169e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77f67db2a4709388b905397421bd3a851fbbf884", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77f67db2a4709388b905397421bd3a851fbbf884", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77f67db2a4709388b905397421bd3a851fbbf884"}], "stats": {"total": 413, "additions": 300, "deletions": 113}, "files": [{"sha": "2566ec7f0af8dc844901ad0bda2a73fdb4383b4d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dd85e01599890286d9af5b106a1ab20e51169e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dd85e01599890286d9af5b106a1ab20e51169e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=a4dd85e01599890286d9af5b106a1ab20e51169e", "patch": "@@ -12463,22 +12463,22 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t  /* Allocate clause we duplicate on task and inner taskloop\n \t     if the decl is lastprivate, otherwise just put on task.  */\n \t  case OMP_CLAUSE_ALLOCATE:\n+\t    if (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)\n+\t\t&& DECL_P (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)))\n+\t      {\n+\t\t/* Additionally, put firstprivate clause on task\n+\t\t   for the allocator if it is not constant.  */\n+\t\t*gtask_clauses_ptr\n+\t\t  = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t      OMP_CLAUSE_FIRSTPRIVATE);\n+\t\tOMP_CLAUSE_DECL (*gtask_clauses_ptr)\n+\t\t  = OMP_CLAUSE_ALLOCATE_ALLOCATOR (c);\n+\t\tgtask_clauses_ptr = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);\n+\t      }\n \t    if (lastprivate_uids\n \t\t&& bitmap_bit_p (lastprivate_uids,\n \t\t\t\t DECL_UID (OMP_CLAUSE_DECL (c))))\n \t      {\n-\t\tif (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)\n-\t\t    && DECL_P (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)))\n-\t\t  {\n-\t\t    /* Additionally, put firstprivate clause on task\n-\t\t       for the allocator if it is not constant.  */\n-\t\t    *gtask_clauses_ptr\n-\t\t      = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t  OMP_CLAUSE_FIRSTPRIVATE);\n-\t\t    OMP_CLAUSE_DECL (*gtask_clauses_ptr)\n-\t\t      = OMP_CLAUSE_ALLOCATE_ALLOCATOR (c);\n-\t\t    gtask_clauses_ptr = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);\n-\t\t  }\n \t\t*gfor_clauses_ptr = c;\n \t\tgfor_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n \t\t*gtask_clauses_ptr = copy_node (c);"}, {"sha": "09a8cbdc433ab9ec6be9dc2d728470cf941c9ba0", "filename": "gcc/omp-low.c", "status": "modified", "additions": 93, "deletions": 15, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dd85e01599890286d9af5b106a1ab20e51169e/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dd85e01599890286d9af5b106a1ab20e51169e/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=a4dd85e01599890286d9af5b106a1ab20e51169e", "patch": "@@ -803,7 +803,7 @@ install_var_field (tree var, bool by_ref, int mask, omp_context *ctx)\n     }\n   else if (by_ref)\n     type = build_pointer_type (type);\n-  else if ((mask & 3) == 1 && omp_is_reference (var))\n+  else if ((mask & (32 | 3)) == 1 && omp_is_reference (var))\n     type = TREE_TYPE (type);\n \n   field = build_decl (DECL_SOURCE_LOCATION (var),\n@@ -1141,8 +1141,6 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t    /* omp_default_mem_alloc is 1 */\n \t    || !integer_onep (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c))))\n       {\n-\tif (is_task_ctx (ctx))\n-\t  continue; /* For now.  */\n \tif (ctx->allocate_map == NULL)\n \t  ctx->allocate_map = new hash_map<tree, tree>;\n \tctx->allocate_map->put (OMP_CLAUSE_DECL (c),\n@@ -1222,18 +1220,20 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t      ctx->local_reduction_clauses\n \t\t= tree_cons (NULL, c, ctx->local_reduction_clauses);\n \t    }\n-\t  if ((OMP_CLAUSE_REDUCTION_INSCAN (c)\n-\t       || OMP_CLAUSE_REDUCTION_TASK (c)) && ctx->allocate_map)\n+\t  /* FALLTHRU */\n+\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (ctx->allocate_map\n+\t      && ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t   && (OMP_CLAUSE_REDUCTION_INSCAN (c)\n+\t\t       || OMP_CLAUSE_REDUCTION_TASK (c)))\n+\t\t  || is_task_ctx (ctx)))\n \t    {\n-\t      tree decl = OMP_CLAUSE_DECL (c);\n \t      /* For now.  */\n \t      if (ctx->allocate_map->get (decl))\n \t\tctx->allocate_map->remove (decl);\n \t    }\n-\t  /* FALLTHRU */\n-\n-\tcase OMP_CLAUSE_IN_REDUCTION:\n-\t  decl = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (decl) == MEM_REF)\n \t    {\n \t      tree t = TREE_OPERAND (decl, 0);\n@@ -1317,7 +1317,16 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  if (is_variable_sized (decl))\n \t    {\n \t      if (is_task_ctx (ctx))\n-\t\tinstall_var_field (decl, false, 1, ctx);\n+\t\t{\n+\t\t  if (ctx->allocate_map\n+\t\t      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE)\n+\t\t    {\n+\t\t      /* For now.  */\n+\t\t      if (ctx->allocate_map->get (decl))\n+\t\t\tctx->allocate_map->remove (decl);\n+\t\t    }\n+\t\t  install_var_field (decl, false, 1, ctx);\n+\t\t}\n \t      break;\n \t    }\n \t  else if (is_taskreg_ctx (ctx))\n@@ -1329,7 +1338,11 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t      if (is_task_ctx (ctx)\n \t\t  && (global || by_ref || omp_is_reference (decl)))\n \t\t{\n-\t\t  install_var_field (decl, false, 1, ctx);\n+\t\t  if (ctx->allocate_map\n+\t\t      && ctx->allocate_map->get (decl))\n+\t\t    install_var_field (decl, by_ref, 32 | 1, ctx);\n+\t\t  else\n+\t\t    install_var_field (decl, false, 1, ctx);\n \t\t  if (!global)\n \t\t    install_var_field (decl, by_ref, 2, ctx);\n \t\t}\n@@ -4498,7 +4511,9 @@ lower_private_allocate (tree var, tree new_var, tree &allocator,\n   gimple_seq_add_stmt (ilist, g);\n   if (!is_ref)\n     {\n-      SET_DECL_VALUE_EXPR (new_var, build_simple_mem_ref (allocate_ptr));\n+      tree x = build_simple_mem_ref (allocate_ptr);\n+      TREE_THIS_NOTRAP (x) = 1;\n+      SET_DECL_VALUE_EXPR (new_var, x);\n       DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n     }\n   return true;\n@@ -5409,7 +5424,18 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      if (c_kind == OMP_CLAUSE_FIRSTPRIVATE && is_task_ctx (ctx))\n \t\t{\n \t\t  x = build_receiver_ref (var, false, ctx);\n-\t\t  x = build_fold_addr_expr_loc (clause_loc, x);\n+\t\t  if (ctx->allocate_map)\n+\t\t    if (tree *allocatep = ctx->allocate_map->get (var))\n+\t\t      {\n+\t\t\tallocator = *allocatep;\n+\t\t\tif (TREE_CODE (allocator) != INTEGER_CST)\n+\t\t\t  allocator = build_outer_var_ref (allocator, ctx);\n+\t\t\tallocator = fold_convert (pointer_sized_int_node,\n+\t\t\t\t\t\t  allocator);\n+\t\t\tallocate_ptr = unshare_expr (x);\n+\t\t      }\n+\t\t  if (allocator == NULL_TREE)\n+\t\t    x = build_fold_addr_expr_loc (clause_loc, x);\n \t\t}\n \t      else if (lower_private_allocate (var, new_var, allocator,\n \t\t\t\t\t       allocate_ptr,\n@@ -5676,6 +5702,18 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\tgimplify_and_add (x, dlist);\n \t      if (allocator)\n \t\t{\n+\t\t  if (!is_gimple_val (allocator))\n+\t\t    {\n+\t\t      tree avar = create_tmp_var (TREE_TYPE (allocator));\n+\t\t      gimplify_assign (avar, allocator, dlist);\n+\t\t      allocator = avar;\n+\t\t    }\n+\t\t  if (!is_gimple_val (allocate_ptr))\n+\t\t    {\n+\t\t      tree apvar = create_tmp_var (TREE_TYPE (allocate_ptr));\n+\t\t      gimplify_assign (apvar, allocate_ptr, dlist);\n+\t\t      allocate_ptr = apvar;\n+\t\t    }\n \t\t  tree f = builtin_decl_explicit (BUILT_IN_GOMP_FREE);\n \t\t  gimple *g\n \t\t    = gimple_build_call (f, 2, allocate_ptr, allocator);\n@@ -5704,6 +5742,18 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t   || use_pointer_for_field (var, NULL))\n \t\t    {\n \t\t      x = build_receiver_ref (var, false, ctx);\n+\t\t      if (ctx->allocate_map)\n+\t\t\tif (tree *allocatep = ctx->allocate_map->get (var))\n+\t\t\t  {\n+\t\t\t    allocator = *allocatep;\n+\t\t\t    if (TREE_CODE (allocator) != INTEGER_CST)\n+\t\t\t      allocator = build_outer_var_ref (allocator, ctx);\n+\t\t\t    allocator = fold_convert (pointer_sized_int_node,\n+\t\t\t\t\t\t      allocator);\n+\t\t\t    allocate_ptr = unshare_expr (x);\n+\t\t\t    x = build_simple_mem_ref (x);\n+\t\t\t    TREE_THIS_NOTRAP (x) = 1;\n+\t\t\t  }\n \t\t      SET_DECL_VALUE_EXPR (new_var, x);\n \t\t      DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n \t\t      goto do_dtor;\n@@ -11290,7 +11340,35 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)\n \tif (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE)\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n \telse\n-\t  t = lang_hooks.decls.omp_clause_copy_ctor (c, dst, src);\n+\t  {\n+\t    if (ctx->allocate_map)\n+\t      if (tree *allocatorp = ctx->allocate_map->get (decl))\n+\t\t{\n+\t\t  tree allocator = *allocatorp;\n+\t\t  if (TREE_CODE (allocator) != INTEGER_CST)\n+\t\t    {\n+\t\t      n = splay_tree_lookup (ctx->sfield_map,\n+\t\t\t\t\t     (splay_tree_key) allocator);\n+\t\t      allocator = (tree) n->value;\n+\t\t      if (tcctx.cb.decl_map)\n+\t\t\tallocator = *tcctx.cb.decl_map->get (allocator);\n+\t\t      tree a = build_simple_mem_ref_loc (loc, sarg);\n+\t\t      allocator = omp_build_component_ref (a, allocator);\n+\t\t    }\n+\t\t  allocator = fold_convert (pointer_sized_int_node, allocator);\n+\t\t  tree a = builtin_decl_explicit (BUILT_IN_GOMP_ALLOC);\n+\t\t  tree align = build_int_cst (size_type_node,\n+\t\t\t\t\t      DECL_ALIGN_UNIT (decl));\n+\t\t  tree sz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (dst)));\n+\t\t  tree ptr = build_call_expr_loc (loc, a, 3, align, sz,\n+\t\t\t\t\t\t  allocator);\n+\t\t  ptr = fold_convert (TREE_TYPE (dst), ptr);\n+\t\t  t = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, ptr);\n+\t\t  append_to_statement_list (t, &list);\n+\t\t  dst = build_simple_mem_ref_loc (loc, dst);\n+\t\t}\n+\t    t = lang_hooks.decls.omp_clause_copy_ctor (c, dst, src);\n+\t  }\n \tappend_to_statement_list (t, &list);\n \tbreak;\n       case OMP_CLAUSE_PRIVATE:"}, {"sha": "0876719f0a1c248be85c14f5e8af9cd44e1311cd", "filename": "libgomp/testsuite/libgomp.c++/allocate-1.C", "status": "modified", "additions": 91, "deletions": 78, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dd85e01599890286d9af5b106a1ab20e51169e/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fallocate-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dd85e01599890286d9af5b106a1ab20e51169e/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fallocate-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fallocate-1.C?ref=a4dd85e01599890286d9af5b106a1ab20e51169e", "patch": "@@ -2,17 +2,26 @@\n #include <stdlib.h>\n #include <stdint.h>\n \n+struct S { int a, b; };\n+\n void\n-foo (int &x, int &y, int &r, int &l, int (&l2)[4], int &l3, int &n, omp_allocator_handle_t h, int fl)\n+foo (int &x, int &y, int &r, int &l, int (&l2)[4], int &l3, int &n, int *&p,\n+     int *&q, int &px, struct S &s, omp_allocator_handle_t h, int fl)\n {\n   int i;\n   typedef int T[x];\n   T v, w;\n   T &v2 = v;\n   T &w2 = w;\n+  int r1[4] = { 0, 0, 0, 0 };\n+  int (&r2)[4] = r1;\n   int xo = x;\n   for (i = 0; i < x; i++)\n     w[i] = i;\n+  for (i = 0; i < 4; i++)\n+    p[i] = 0;\n+  for (i = 0; i < 3; i++)\n+    q[i] = 0;\n   #pragma omp parallel private (y, v2) firstprivate (x) allocate (x, y, v2)\n   {\n     int *volatile p1 = &x;\n@@ -66,6 +75,7 @@ foo (int &x, int &y, int &r, int &l, int (&l2)[4], int &l3, int &n, omp_allocato\n \t\t\t| (uintptr_t) &l | (uintptr_t) &n) & 63) != 0)\n \tabort ();\n     }\n+  x = xo;\n   #pragma omp parallel\n   {\n     #pragma omp for lastprivate (l2) allocate (h: l2, l3) lastprivate (conditional: l3)\n@@ -80,84 +90,86 @@ foo (int &x, int &y, int &r, int &l, int (&l2)[4], int &l3, int &n, omp_allocato\n \tif ((fl & 1) && (((uintptr_t) &l2[0] | (uintptr_t) &l3) & 63) != 0)\n \t  abort ();\n       }\n-  }\n-  if (r != 64 * 63 / 2 || l != 63 || n != 8 + 16 * 64)\n-    abort ();\n-  if (l2[0] != 63 || l2[1] != 63 + 1 || l2[2] != 63 + 2 || l2[3] != 63 + 3 || l3 != 36)\n-    abort ();\n-}\n-\n-void\n-bar (int &x, int &y, int &r, int &l, int (&l2)[4], int &l3, int &n, omp_allocator_handle_t h)\n-{\n-  int i;\n-  typedef int T[x];\n-  T v, w;\n-  T &v2 = v;\n-  T &w2 = w;\n-  int xo = x;\n-  for (i = 0; i < x; i++)\n-    w[i] = i;\n-  #pragma omp parallel private (y, v2) firstprivate (x) allocate (x, y, v2)\n-  {\n-    int *volatile p1 = &x;\n-    int *volatile p2 = &y;\n-    if (x != 42)\n-      abort ();\n-    #pragma omp barrier\n-    *p2 = 1;\n-    p1[0]++;\n-    v2[0] = 7;\n-    v2[41] = 8;\n-    #pragma omp barrier\n-    if (x != 43 || y != 1)\n-      abort ();\n-    if (v2[0] != 7 || v2[41] != 8)\n-      abort ();\n-  }\n-  x = xo;\n-  #pragma omp teams\n-  #pragma omp parallel private (y) firstprivate (x, w2) allocate (h: x, y, w2)\n-  {\n-    int *volatile p1 = &x;\n-    int *volatile p2 = &y;\n-    if (x != 42 || w2[17] != 17 || w2[41] != 41)\n-      abort ();\n-    #pragma omp barrier\n-    *p2 = 1;\n-    p1[0]++;\n-    #pragma omp barrier\n-    if (x != 43 || y != 1)\n-      abort ();\n-  }\n-  x = xo;\n-  #pragma omp parallel for private (y) firstprivate (x) allocate (h: x, y, r, l, n) reduction(+: r) lastprivate (l) linear (n: 16)\n-  for (i = 0; i < 64; i++)\n+    #pragma omp for reduction(+:p[2:px], q[:3], r2) allocate(h: p, q, r2)\n+    for (i = 0; i < 32; i++)\n+      {\n+\tp[2] += i;\n+\tp[3] += 2 * i;\n+\tq[0] += 3 * i;\n+\tq[2] += 4 * i;\n+\tr2[0] += 5 * i;\n+\tr2[3] += 6 * i;\n+\t/* Can't really rely on alignment of &p[0], the implementation could\n+\t   allocate the whole array or do what GCC does and allocate only part\n+\t   of it.  */\n+\tif ((fl & 1) && (((uintptr_t) &q[0] | (uintptr_t) &r2[0]) & 63) != 0)\n+\t  abort ();\n+      }\n+    #pragma omp task private(y) firstprivate(x) allocate(x, y)\n     {\n+      int *volatile p1 = &x;\n+      int *volatile p2 = &y;\n       if (x != 42)\n \tabort ();\n-      y = 1;\n-      l = i;\n-      n += y + 15;\n-      r += i;\n+      p1[0]++;\n+      p2[0] = 21;\n+      if (x != 43 || y != 21)\n+\tabort ();\n+      if ((fl & 2) && (((uintptr_t) p1 | (uintptr_t) p2) & 63) != 0)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(x) allocate(h: x, y)\n+    {\n+      int *volatile p1 = &x;\n+      int *volatile p2 = &y;\n+      if (x != 42)\n+\tabort ();\n+      p1[0]++;\n+      p2[0] = 21;\n+      if (x != 43 || y != 21)\n+\tabort ();\n+      if ((fl & 1) && (((uintptr_t) p1 | (uintptr_t) p2) & 63) != 0)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(s) allocate(s, y)\n+    {\n+      int *volatile p1 = &s.a;\n+      int *volatile p2 = &s.b;\n+      int *volatile p3 = &y;\n+      if (s.a != 27 || s.b != 29)\n+\tabort ();\n+      p1[0]++;\n+      p2[0]++;\n+      p3[0] = 21;\n+      if (s.a != 28 || s.b != 30 || y != 21)\n+\tabort ();\n+      if ((fl & 2) && (((uintptr_t) p1 | (uintptr_t) p3) & 63) != 0)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(s) allocate(h: s, y)\n+    {\n+      int *volatile p1 = &s.a;\n+      int *volatile p2 = &s.b;\n+      int *volatile p3 = &y;\n+      if (s.a != 27 || s.b != 29)\n+\tabort ();\n+      p1[0]++;\n+      p2[0]++;\n+      p3[0] = 21;\n+      if (s.a != 28 || s.b != 30 || y != 21)\n+\tabort ();\n+      if ((fl & 1) && (((uintptr_t) p1 | (uintptr_t) p3) & 63) != 0)\n+\tabort ();\n     }\n-  #pragma omp parallel\n-  {\n-    #pragma omp for lastprivate (l2) allocate (h: l2, l3) lastprivate (conditional: l3)\n-    for (i = 0; i < 64; i++)\n-      {\n-\tl2[0] = i;\n-\tl2[1] = i + 1;\n-\tl2[2] = i + 2;\n-\tl2[3] = i + 3;\n-\tif (i < 37)\n-\t  l3 = i;\n-      }\n   }\n   if (r != 64 * 63 / 2 || l != 63 || n != 8 + 16 * 64)\n     abort ();\n   if (l2[0] != 63 || l2[1] != 63 + 1 || l2[2] != 63 + 2 || l2[3] != 63 + 3 || l3 != 36)\n     abort ();\n+  if (p[2] != (32 * 31) / 2 || p[3] != 2 * (32 * 31) / 2\n+      || q[0] != 3 * (32 * 31) / 2 || q[2] != 4 * (32 * 31) / 2\n+      || r2[0] != 5 * (32 * 31) / 2 || r2[3] != 6 * (32 * 31) / 2)\n+    abort ();\n }\n \n int\n@@ -171,24 +183,25 @@ main ()\n   if (a == omp_null_allocator)\n     abort ();\n   omp_set_default_allocator (omp_default_mem_alloc);\n+  struct S s = { 27, 29 };\n+  int p1[4], q1[3], px = 2;\n+  int *p = p1;\n+  int *q = q1;\n   int x = 42, y = 0, r = 0, l, l2[4], l3, n = 8;\n-  foo (x, y, r, l, l2, l3, n, omp_null_allocator, 0);\n+  foo (x, y, r, l, l2, l3, n, p, q, px, s, omp_null_allocator, 0);\n   x = 42; y = 0; r = 0; l = -1; l2[0] = -1; l2[1] = -1;\n   l2[2] = -1; l2[3] = -1; n = 8;\n-  foo (x, y, r, l, l2, l3, n, omp_default_mem_alloc, 0);\n+  foo (x, y, r, l, l2, l3, n, p, q, px, s, omp_default_mem_alloc, 0);\n   x = 42; y = 0; r = 0; l = -1; l2[0] = -1; l2[1] = -1;\n   l2[2] = -1; l2[3] = -1; n = 8;\n-  foo (x, y, r, l, l2, l3, n, a, 1);\n+  foo (x, y, r, l, l2, l3, n, p, q, px, s, a, 1);\n   x = 42; y = 0; r = 0; l = -1; l2[0] = -1; l2[1] = -1;\n   l2[2] = -1; l2[3] = -1; n = 8;\n   omp_set_default_allocator (a);\n-  foo (x, y, r, l, l2, l3, n, omp_null_allocator, 3);\n-  x = 42; y = 0; r = 0; l = -1; l2[0] = -1; l2[1] = -1;\n-  l2[2] = -1; l2[3] = -1; n = 8;\n-  foo (x, y, r, l, l2, l3, n, omp_default_mem_alloc, 2);\n+  foo (x, y, r, l, l2, l3, n, p, q, px, s, omp_null_allocator, 3);\n   x = 42; y = 0; r = 0; l = -1; l2[0] = -1; l2[1] = -1;\n   l2[2] = -1; l2[3] = -1; n = 8;\n-  bar (x, y, r, l, l2, l3, n, a);\n+  foo (x, y, r, l, l2, l3, n, p, q, px, s, omp_default_mem_alloc, 2);\n   omp_destroy_allocator (a);\n   return 0;\n }"}, {"sha": "4398ff957ef0e805d2af307f4255ceae01849018", "filename": "libgomp/testsuite/libgomp.c-c++-common/allocate-1.c", "status": "modified", "additions": 104, "deletions": 8, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dd85e01599890286d9af5b106a1ab20e51169e/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dd85e01599890286d9af5b106a1ab20e51169e/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-1.c?ref=a4dd85e01599890286d9af5b106a1ab20e51169e", "patch": "@@ -2,6 +2,8 @@\n #include <stdlib.h>\n #include <stdint.h>\n \n+struct S { int a, b; };\n+\n void\n foo (int x, int *p, int *q, int px, omp_allocator_handle_t h, int fl)\n {\n@@ -13,6 +15,7 @@ foo (int x, int *p, int *q, int px, omp_allocator_handle_t h, int fl)\n   int v[x], w[x];\n   int r2[4] = { 0, 0, 0, 0 };\n   int xo = x;\n+  struct S s = { 27, 29 };\n   for (i = 0; i < 4; i++)\n     p[i] = 0;\n   for (i = 0; i < 3; i++)\n@@ -72,6 +75,7 @@ foo (int x, int *p, int *q, int px, omp_allocator_handle_t h, int fl)\n \t\t\t| (uintptr_t) &l | (uintptr_t) &n) & 63) != 0)\n \tabort ();\n     }\n+  x = xo;\n   #pragma omp parallel\n   {\n     #pragma omp for lastprivate (l2) private (i1) allocate (h: l2, l3, i1) lastprivate (conditional: l3)\n@@ -137,6 +141,62 @@ foo (int x, int *p, int *q, int px, omp_allocator_handle_t h, int fl)\n \tif ((fl & 1) && (((uintptr_t) &q[0] | (uintptr_t) &r2[0]) & 63) != 0)\n \t  abort ();\n       }\n+    #pragma omp task private(y) firstprivate(x) allocate(x, y)\n+    {\n+      int *volatile p1 = &x;\n+      int *volatile p2 = &y;\n+      if (x != 42)\n+\tabort ();\n+      p1[0]++;\n+      p2[0] = 21;\n+      if (x != 43 || y != 21)\n+\tabort ();\n+      if ((fl & 2) && (((uintptr_t) p1 | (uintptr_t) p2) & 63) != 0)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(x) allocate(h: x, y)\n+    {\n+      int *volatile p1 = &x;\n+      int *volatile p2 = &y;\n+      if (x != 42)\n+\tabort ();\n+      p1[0]++;\n+      p2[0] = 21;\n+      if (x != 43 || y != 21)\n+\tabort ();\n+      if ((fl & 1) && (((uintptr_t) p1 | (uintptr_t) p2) & 63) != 0)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(s) allocate(s, y)\n+    {\n+      int *volatile p1 = &s.a;\n+      int *volatile p2 = &s.b;\n+      int *volatile p3 = &y;\n+      if (s.a != 27 || s.b != 29)\n+\tabort ();\n+      p1[0]++;\n+      p2[0]++;\n+      p3[0] = 21;\n+      if (s.a != 28 || s.b != 30 || y != 21)\n+\tabort ();\n+      if ((fl & 2) && (((uintptr_t) p1 | (uintptr_t) p3) & 63) != 0)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(s) allocate(h: s, y)\n+    {\n+      int *volatile p1 = &s.a;\n+      int *volatile p2 = &s.b;\n+      int *volatile p3 = &y;\n+      if (s.a != 27 || s.b != 29)\n+\tabort ();\n+      p1[0]++;\n+      p2[0]++;\n+      p3[0] = 21;\n+      if (s.a != 28 || s.b != 30 || y != 21)\n+\tabort ();\n+      if ((fl & 1) && (((uintptr_t) p1 | (uintptr_t) p3) & 63) != 0)\n+\tabort ();\n+    }\n   }\n   if (r != 64 * 63 / 2 || l != 63 || n != 8 + 16 * 64)\n     abort ();\n@@ -164,16 +224,15 @@ bar (int x, omp_allocator_handle_t h)\n   int i3, j3, n3 = 10, l5;\n   int i4, j4, n4 = 11, l6;\n   int i5;\n+  struct S s = { 27, 29 };\n   int xo = x;\n   #pragma omp parallel private (y) firstprivate (x) allocate (x, y)\n   {\n-    int *volatile p1 = &x;\n-    int *volatile p2 = &y;\n     if (x != 42)\n       abort ();\n     #pragma omp barrier\n-    *p2 = 1;\n-    p1[0]++;\n+    y = 1;\n+    x++;\n     #pragma omp barrier\n     if (x != 43 || y != 1)\n       abort ();\n@@ -182,13 +241,11 @@ bar (int x, omp_allocator_handle_t h)\n   #pragma omp teams\n   #pragma omp parallel private (y) firstprivate (x) allocate (h: x, y)\n   {\n-    int *volatile p1 = &x;\n-    int *volatile p2 = &y;\n     if (x != 42)\n       abort ();\n     #pragma omp barrier\n-    *p2 = 1;\n-    p1[0]++;\n+    y = 1;\n+    x++;\n     #pragma omp barrier\n     if (x != 43 || y != 1)\n       abort ();\n@@ -204,6 +261,7 @@ bar (int x, omp_allocator_handle_t h)\n       n += y + 15;\n       r += i;\n     }\n+  x = xo;\n   #pragma omp parallel\n   {\n     #pragma omp for lastprivate (l2) private (i1) allocate (h: l2, l3, i1) lastprivate (conditional: l3)\n@@ -240,6 +298,44 @@ bar (int x, omp_allocator_handle_t h)\n     #pragma omp for lastprivate (i5) allocate (i5)\n     for (i5 = 1; i5 < 17; i5 += 3)\n       ;\n+    #pragma omp task private(y) firstprivate(x) allocate(x, y)\n+    {\n+      if (x != 42)\n+\tabort ();\n+      x++;\n+      y = 21;\n+      if (x != 43 || y != 21)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(x) allocate(h: x, y)\n+    {\n+      if (x != 42)\n+\tabort ();\n+      x++;\n+      y = 21;\n+      if (x != 43 || y != 21)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(s) allocate(s, y)\n+    {\n+      if (s.a != 27 || s.b != 29)\n+\tabort ();\n+      s.a++;\n+      s.b++;\n+      y = 21;\n+      if (s.a != 28 || s.b != 30 || y != 21)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(s) allocate(h: s, y)\n+    {\n+      if (s.a != 27 || s.b != 29)\n+\tabort ();\n+      s.a++;\n+      s.b++;\n+      y = 21;\n+      if (s.a != 28 || s.b != 30 || y != 21)\n+\tabort ();\n+    }\n   }\n   if (r != 64 * 63 / 2 || l != 63 || n != 8 + 16 * 64)\n     abort ();"}]}