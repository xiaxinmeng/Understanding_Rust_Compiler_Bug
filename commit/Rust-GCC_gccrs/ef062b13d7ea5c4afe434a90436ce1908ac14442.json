{"sha": "ef062b13d7ea5c4afe434a90436ce1908ac14442", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYwNjJiMTNkN2VhNWM0YWZlNDM0YTkwNDM2Y2UxOTA4YWMxNDQ0Mg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2013-11-22T05:45:37Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2013-11-22T05:45:37Z"}, "message": "add auto_vec\n\n2013-11-22  Trevor Saunders  <tsaunders@mozilla.com>\n\ngcc/\n\t* vec.h (auto_vec): New class.\n\t* cfganal.c, cfgloop.c, cgraphunit.c, config/i386/i386.c, dwarf2out.c,\n\tfunction.c, genautomata.c, gimple.c, haifa-sched.c, ipa-inline.c,\n\tira-build.c, loop-unroll.c, omp-low.c, ree.c, trans-mem.c,\ntree-call-cdce.c, tree-eh.c, tree-if-conv.c, tree-into-ssa.c,\ntree-loop-distribution.c, tree-predcom.c, tree-sra.c,\ntree-sssa-forwprop.c, tree-ssa-loop-manip.c, tree-ssa-pre.c,\ntree-ssa-reassoc.c, tree-ssa-sccvn.c, tree-ssa-structalias.c,\n\ttree-vect-loop.c, tree-vect-stmts.c: Use auto_vec and stack_vec as\n\tappropriate instead of vec for local variables.\n\n\tcp/\n\t* parser.c, semantics.c: Change some local variables from vec to\n\tauto_vec or stack_vec.\n\nFrom-SVN: r205244", "tree": {"sha": "15430a70b98350e546a27451e278ea2bc1aec992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15430a70b98350e546a27451e278ea2bc1aec992"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef062b13d7ea5c4afe434a90436ce1908ac14442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef062b13d7ea5c4afe434a90436ce1908ac14442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef062b13d7ea5c4afe434a90436ce1908ac14442", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef062b13d7ea5c4afe434a90436ce1908ac14442/comments", "author": null, "committer": null, "parents": [{"sha": "d41d612242e589882364ba581c586094599952e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d41d612242e589882364ba581c586094599952e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d41d612242e589882364ba581c586094599952e3"}], "stats": {"total": 328, "additions": 107, "deletions": 221}, "files": [{"sha": "3aa74c0329b5b2ebaccfdcd16a0fd444b32e74a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1,3 +1,16 @@\n+2013-11-22  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* vec.h (auto_vec): New class.\n+\t* cfganal.c, cfgloop.c, cgraphunit.c, config/i386/i386.c, dwarf2out.c,\n+\tfunction.c, genautomata.c, gimple.c, haifa-sched.c, ipa-inline.c,\n+\tira-build.c, loop-unroll.c, omp-low.c, ree.c, trans-mem.c,\n+\ttree-call-cdce.c, tree-eh.c, tree-if-conv.c, tree-into-ssa.c,\n+\ttree-loop-distribution.c, tree-predcom.c, tree-sra.c,\n+\ttree-sssa-forwprop.c, tree-ssa-loop-manip.c, tree-ssa-pre.c,\n+\ttree-ssa-reassoc.c, tree-ssa-sccvn.c, tree-ssa-structalias.c,\n+\ttree-vect-loop.c, tree-vect-stmts.c: Use auto_vec and stack_vec as\n+\tappropriate instead of vec for local variables.\n+\n 2013-11-21  Teresa Johnson  <tejohnson@google.com>\n \n \tPR target/59233"}, {"sha": "ad5928a40b413acba61b71bcefc842223e5cf32a", "filename": "gcc/cfganal.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1286,11 +1286,10 @@ compute_idf (bitmap def_blocks, bitmap_head *dfs)\n {\n   bitmap_iterator bi;\n   unsigned bb_index, i;\n-  vec<int> work_stack;\n   bitmap phi_insertion_points;\n \n   /* Each block can appear at most twice on the work-stack.  */\n-  work_stack.create (2 * n_basic_blocks_for_fn (cfun));\n+  auto_vec<int> work_stack (2 * n_basic_blocks_for_fn (cfun));\n   phi_insertion_points = BITMAP_ALLOC (NULL);\n \n   /* Seed the work list with all the blocks in DEF_BLOCKS.  We use\n@@ -1324,8 +1323,6 @@ compute_idf (bitmap def_blocks, bitmap_head *dfs)\n \t}\n     }\n \n-  work_stack.release ();\n-\n   return phi_insertion_points;\n }\n "}, {"sha": "09029c9ac857c1fecb88f6e6abc28fa472a4f594", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -405,7 +405,6 @@ flow_loops_find (struct loops *loops)\n   int *rc_order;\n   int b;\n   unsigned i;\n-  vec<loop_p> larray;\n \n   /* Ensure that the dominators are computed.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n@@ -434,7 +433,7 @@ flow_loops_find (struct loops *loops)\n \n   /* Gather all loop headers in reverse completion order and allocate\n      loop structures for loops that are not already present.  */\n-  larray.create (loops->larray->length ());\n+  auto_vec<loop_p> larray (loops->larray->length ());\n   for (b = 0; b < n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS; b++)\n     {\n       basic_block header = BASIC_BLOCK (rc_order[b]);\n@@ -510,8 +509,6 @@ flow_loops_find (struct loops *loops)\n \t}\n     }\n \n-  larray.release ();\n-\n   return loops;\n }\n "}, {"sha": "b10d75531b034288b6a99609006659419ec5fd54", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1525,7 +1525,6 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks)\n       int i;\n       tree resdecl;\n       tree restmp = NULL;\n-      vec<tree> vargs;\n \n       gimple call;\n       gimple ret;\n@@ -1579,7 +1578,7 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks)\n \n       for (arg = a; arg; arg = DECL_CHAIN (arg))\n         nargs++;\n-      vargs.create (nargs);\n+      auto_vec<tree> vargs (nargs);\n       if (this_adjusting)\n         vargs.quick_push (thunk_adjust (&bsi, a, 1, fixed_offset,\n \t\t\t\t\tvirtual_offset));\n@@ -1591,7 +1590,6 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks)\n \t  vargs.quick_push (arg);\n       call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);\n       node->callees->call_stmt = call;\n-      vargs.release ();\n       gimple_call_set_from_thunk (call, true);\n       if (restmp)\n \t{"}, {"sha": "c818cb9dc4aead6da758fcc8f52354c7e2668a06", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -30708,7 +30708,6 @@ ix86_generate_version_dispatcher_body (void *node_p)\n {\n   tree resolver_decl;\n   basic_block empty_bb;\n-  vec<tree> fn_ver_vec = vNULL;\n   tree default_ver_decl;\n   struct cgraph_node *versn;\n   struct cgraph_node *node;\n@@ -30738,7 +30737,7 @@ ix86_generate_version_dispatcher_body (void *node_p)\n \n   push_cfun (DECL_STRUCT_FUNCTION (resolver_decl));\n \n-  fn_ver_vec.create (2);\n+  stack_vec<tree, 2> fn_ver_vec;\n \n   for (versn_info = node_version_info->next; versn_info;\n        versn_info = versn_info->next)\n@@ -30756,7 +30755,6 @@ ix86_generate_version_dispatcher_body (void *node_p)\n     }\n \n   dispatch_function_versions (resolver_decl, &fn_ver_vec, &empty_bb);\n-  fn_ver_vec.release ();\n   rebuild_cgraph_edges (); \n   pop_cfun ();\n   return resolver_decl;"}, {"sha": "5e769c30eecf32369bf590a50c610b1a6d85a9e3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1,3 +1,8 @@\n+2013-11-22  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* parser.c, semantics.c: Change some local variables from vec to\n+\tauto_vec or stack_vec.\n+\n 2013-11-18  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* decl.c (reshape_init_array_1): Use tree_to_uhwi rather than"}, {"sha": "bc86697793c37ea96fd171e91d783ffb480292ab", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -30345,7 +30345,7 @@ static void\n cp_parser_omp_declare_reduction (cp_parser *parser, cp_token *pragma_tok,\n \t\t\t\t enum pragma_context)\n {\n-  vec<tree> types = vNULL;\n+  auto_vec<tree> types;\n   enum tree_code reduc_code = ERROR_MARK;\n   tree reduc_id = NULL_TREE, orig_reduc_id = NULL_TREE, type;\n   unsigned int i;\n@@ -30460,7 +30460,6 @@ cp_parser_omp_declare_reduction (cp_parser *parser, cp_token *pragma_tok,\n     {\n      fail:\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      types.release ();\n       return;\n     }\n \n@@ -30565,7 +30564,6 @@ cp_parser_omp_declare_reduction (cp_parser *parser, cp_token *pragma_tok,\n     }\n \n   cp_parser_require_pragma_eol (parser, pragma_tok);\n-  types.release ();\n }\n \n /* OpenMP 4.0"}, {"sha": "cd5a91d2c60c3ed8f90d1d820a496e2820205e9f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -4376,24 +4376,17 @@ handle_omp_array_sections (tree c)\n {\n   bool maybe_zero_len = false;\n   unsigned int first_non_one = 0;\n-  vec<tree> types = vNULL;\n+  auto_vec<tree> types;\n   tree first = handle_omp_array_sections_1 (c, OMP_CLAUSE_DECL (c), types,\n \t\t\t\t\t    maybe_zero_len, first_non_one);\n   if (first == error_mark_node)\n-    {\n-      types.release ();\n-      return true;\n-    }\n+    return true;\n   if (first == NULL_TREE)\n-    {\n-      types.release ();\n-      return false;\n-    }\n+    return false;\n   if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n     {\n       tree t = OMP_CLAUSE_DECL (c);\n       tree tem = NULL_TREE;\n-      types.release ();\n       if (processing_template_decl)\n \treturn false;\n       /* Need to evaluate side effects in the length expressions\n@@ -4423,10 +4416,7 @@ handle_omp_array_sections (tree c)\n       if (int_size_in_bytes (TREE_TYPE (first)) <= 0)\n \tmaybe_zero_len = true;\n       if (processing_template_decl && maybe_zero_len)\n-\t{\n-\t  types.release ();\n-\t  return false;\n-\t}\n+\treturn false;\n \n       for (i = num, t = OMP_CLAUSE_DECL (c); i > 0;\n \t   t = TREE_CHAIN (t))\n@@ -4469,7 +4459,6 @@ handle_omp_array_sections (tree c)\n \t\t\t\t\"array section is not contiguous in %qs \"\n \t\t\t\t\"clause\",\n \t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n-\t\t      types.release ();\n \t\t      return true;\n \t\t    }\n \t\t}\n@@ -4525,7 +4514,6 @@ handle_omp_array_sections (tree c)\n \t\tsize = size_binop (MULT_EXPR, size, l);\n \t    }\n \t}\n-      types.release ();\n       if (!processing_template_decl)\n \t{\n \t  if (side_effects)"}, {"sha": "bd372b733a7289a180979c80d24cc5c5b3e03937", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -19111,7 +19111,7 @@ static char *\n gen_producer_string (void)\n {\n   size_t j;\n-  vec<dchar_p> switches = vNULL;\n+  auto_vec<dchar_p> switches;\n   const char *language_string = lang_hooks.name;\n   char *producer, *tail;\n   const char *p;\n@@ -19192,7 +19192,6 @@ gen_producer_string (void)\n     }\n \n   *tail = '\\0';\n-  switches.release ();\n   return producer;\n }\n "}, {"sha": "3789352a7dc6a9487e55d27b4eba84f67d2c30a8", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -5722,9 +5722,8 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n   rtx label;\n   edge_iterator ei;\n   edge e;\n-  vec<basic_block> src_bbs;\n+  auto_vec<basic_block> src_bbs (EDGE_COUNT (last_bb->preds));\n \n-  src_bbs.create (EDGE_COUNT (last_bb->preds));\n   FOR_EACH_EDGE (e, ei, last_bb->preds)\n     if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n       src_bbs.quick_push (e->src);"}, {"sha": "5580c69a352dd87ffa685d873aba427c0206b098", "filename": "gcc/genautomata.c", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -3340,7 +3340,6 @@ static alt_state_t\n uniq_sort_alt_states (alt_state_t alt_states_list)\n {\n   alt_state_t curr_alt_state;\n-  vec<alt_state_t> alt_states;\n   size_t i;\n   size_t prev_unique_state_ind;\n   alt_state_t result;\n@@ -3350,7 +3349,7 @@ uniq_sort_alt_states (alt_state_t alt_states_list)\n   if (alt_states_list->next_alt_state == 0)\n     return alt_states_list;\n \n-  alt_states.create (150);\n+  stack_vec<alt_state_t, 150> alt_states;\n   for (curr_alt_state = alt_states_list;\n        curr_alt_state != NULL;\n        curr_alt_state = curr_alt_state->next_alt_state)\n@@ -3374,7 +3373,6 @@ uniq_sort_alt_states (alt_state_t alt_states_list)\n \n   result = alt_states[0];\n \n-  alt_states.release ();\n   return result;\n }\n \n@@ -5148,7 +5146,6 @@ check_regexp_units_distribution (const char *insn_reserv_name,\n   bool annotation_reservation_message_reported_p;\n   regexp_t seq, allof, unit;\n   struct unit_usage *unit_usage_ptr;\n-  vec<int> marked;\n \n   if (regexp == NULL || regexp->mode != rm_oneof)\n     return;\n@@ -5228,7 +5225,7 @@ check_regexp_units_distribution (const char *insn_reserv_name,\n \t unit_usage_ptr = unit_usage_ptr->next)\n       unit_usage_ptr->unit_decl->last_distribution_check_cycle = -1;\n   n_alts = REGEXP_ONEOF (regexp)->regexps_num;\n-  marked.create (n_alts);\n+  auto_vec<int> marked (n_alts);\n   for (i = 0; i < n_alts; i++)\n     marked.safe_push (0);\n   annotation_reservation_message_reported_p = false;\n@@ -5294,7 +5291,6 @@ check_regexp_units_distribution (const char *insn_reserv_name,\n \t    }\n \t}\n     }\n-  marked.release ();\n   cycle_alt_unit_usages.release ();\n   obstack_free (&unit_usages, NULL);\n }\n@@ -5488,8 +5484,7 @@ form_ainsn_with_same_reservs (automaton_t automaton)\n {\n   ainsn_t curr_ainsn;\n   size_t i;\n-  vec<ainsn_t> last_insns;\n-  last_insns.create (150);\n+  stack_vec<ainsn_t, 150> last_insns;\n \n   for (curr_ainsn = automaton->ainsn_list;\n        curr_ainsn != NULL;\n@@ -5519,7 +5514,6 @@ form_ainsn_with_same_reservs (automaton_t automaton)\n             curr_ainsn->first_insn_with_same_reservs = 1;\n           }\n       }\n-  last_insns.release ();\n }\n \n /* Forming unit reservations which can affect creating the automaton\n@@ -5561,8 +5555,7 @@ make_automaton (automaton_t automaton)\n   state_t state;\n   state_t start_state;\n   state_t state2;\n-  vec<state_t> state_stack;\n-  state_stack.create (150);\n+  stack_vec<state_t, 150> state_stack;\n   int states_n;\n   reserv_sets_t reservs_matter = form_reservs_matter (automaton);\n \n@@ -5621,7 +5614,6 @@ make_automaton (automaton_t automaton)\n         }\n       add_arc (state, state2, automaton->advance_ainsn);\n     }\n-  state_stack.release ();\n }\n \n /* Form lists of all arcs of STATE marked by the same ainsn.  */\n@@ -5764,12 +5756,10 @@ NDFA_to_DFA (automaton_t automaton)\n   state_t start_state;\n   state_t state;\n   decl_t decl;\n-  vec<state_t> state_stack;\n+  auto_vec<state_t> state_stack;\n   int i;\n   int states_n;\n \n-  state_stack.create (0);\n-\n   /* Create the start state (empty state).  */\n   start_state = automaton->start_state;\n   start_state->it_was_placed_in_stack_for_DFA_forming = 1;\n@@ -5810,7 +5800,6 @@ NDFA_to_DFA (automaton_t automaton)\n \t    add_arc (state, state, automaton->collapse_ainsn);\n \t}\n     }\n-  state_stack.release ();\n }\n \n /* The following variable value is current number (1, 2, ...) of passing\n@@ -6258,13 +6247,11 @@ set_new_cycle_flags (state_t state)\n static void\n minimize_DFA (automaton_t automaton)\n {\n-  vec<state_t> equiv_classes = vNULL;\n+  auto_vec<state_t> equiv_classes;\n \n   evaluate_equiv_classes (automaton, &equiv_classes);\n   merge_states (automaton, equiv_classes);\n   pass_states (automaton, set_new_cycle_flags);\n-\n-  equiv_classes.release ();\n }\n \n /* Values of two variables are counted number of states and arcs in an"}, {"sha": "67730bc6dbdc031f357e143510e04258e39c0340", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -2051,8 +2051,7 @@ gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)\n {\n   int i;\n   int nargs = gimple_call_num_args (stmt);\n-  vec<tree> vargs;\n-  vargs.create (nargs);\n+  auto_vec<tree> vargs (nargs);\n   gimple new_stmt;\n \n   for (i = 0; i < nargs; i++)\n@@ -2064,7 +2063,7 @@ gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)\n \t\t\t\t\t       vargs);\n   else\n     new_stmt = gimple_build_call_vec (gimple_call_fn (stmt), vargs);\n-  vargs.release ();\n+\n   if (gimple_call_lhs (stmt))\n     gimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));\n "}, {"sha": "380244094fb899e13a3c444edb3f5fc3aca6189c", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -4223,7 +4223,7 @@ undo_replacements_for_backtrack (struct haifa_saved_data *save)\n static void\n unschedule_insns_until (rtx insn)\n {\n-  vec<rtx> recompute_vec = vNULL;\n+  auto_vec<rtx> recompute_vec;\n \n   /* Make two passes over the insns to be unscheduled.  First, we clear out\n      dependencies and other trivial bookkeeping.  */\n@@ -4281,7 +4281,6 @@ unschedule_insns_until (rtx insn)\n       else if (QUEUE_INDEX (con) != QUEUE_SCHEDULED)\n \tTODO_SPEC (con) = recompute_todo_spec (con, true);\n     }\n-  recompute_vec.release ();\n }\n \n /* Restore scheduler state from the topmost entry on the backtracking queue."}, {"sha": "54ec74ee19155884df672b687f5ef85de780448e", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1524,7 +1524,7 @@ inline_small_functions (void)\n   fibheap_t edge_heap = fibheap_new ();\n   bitmap updated_nodes = BITMAP_ALLOC (NULL);\n   int min_size, max_size;\n-  vec<cgraph_edge_p> new_indirect_edges = vNULL;\n+  auto_vec<cgraph_edge_p> new_indirect_edges;\n   int initial_size = 0;\n   struct cgraph_node **order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   struct cgraph_edge_hook_list *edge_removal_hook_holder;\n@@ -1815,7 +1815,6 @@ inline_small_functions (void)\n     }\n \n   free_growth_caches ();\n-  new_indirect_edges.release ();\n   fibheap_delete (edge_heap);\n   if (dump_file)\n     fprintf (dump_file,"}, {"sha": "09e22d74f6bd1101c4e0f7f6bee6b53b7b8dfb71", "filename": "gcc/ira-build.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1711,7 +1711,7 @@ ira_loop_tree_body_rev_postorder (ira_loop_tree_node_t loop_node ATTRIBUTE_UNUSE\n     {\n       ira_loop_tree_node_t subloop_node;\n       unsigned int i;\n-      vec<ira_loop_tree_node_t> dfs_stack;\n+      auto_vec<ira_loop_tree_node_t> dfs_stack;\n \n       /* This is a bit of strange abuse of the BB_VISITED flag:  We use\n \t the flag to mark blocks we still have to visit to add them to\n@@ -1765,7 +1765,6 @@ ira_loop_tree_body_rev_postorder (ira_loop_tree_node_t loop_node ATTRIBUTE_UNUSE\n \t}\n \n #undef BB_TO_VISIT\n-      dfs_stack.release ();\n     }\n \n   gcc_assert (topsort_nodes.length () == n_loop_preorder);\n@@ -1807,8 +1806,7 @@ ira_traverse_loop_tree (bool bb_p, ira_loop_tree_node_t loop_node,\n \n   if (bb_p)\n     {\n-      vec<ira_loop_tree_node_t>\n-\t  loop_preorder = vNULL;\n+      auto_vec<ira_loop_tree_node_t> loop_preorder;\n       unsigned int i;\n \n       /* Add all nodes to the set of nodes to visit.  The IRA loop tree\n@@ -1832,8 +1830,6 @@ ira_traverse_loop_tree (bool bb_p, ira_loop_tree_node_t loop_node,\n \t    (*postorder_func) (subloop_node);\n \t  loop_rev_postorder.release ();\n \t}\n-\n-      loop_preorder.release ();\n     }\n \n   for (subloop_node = loop_node->subloops;"}, {"sha": "9c871678f6b74dc7b958d9ae8a5119e3f159bc5a", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -578,7 +578,6 @@ peel_loop_completely (struct loop *loop)\n   sbitmap wont_exit;\n   unsigned HOST_WIDE_INT npeel;\n   unsigned i;\n-  vec<edge> remove_edges;\n   edge ein;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   struct opt_info *opt_info = NULL;\n@@ -595,8 +594,7 @@ peel_loop_completely (struct loop *loop)\n       if (desc->noloop_assumptions)\n \tbitmap_clear_bit (wont_exit, 1);\n \n-      remove_edges.create (0);\n-\n+      auto_vec<edge> remove_edges;\n       if (flag_split_ivs_in_unroller)\n         opt_info = analyze_insns_in_loop (loop);\n \n@@ -622,7 +620,6 @@ peel_loop_completely (struct loop *loop)\n       /* Remove the exit edges.  */\n       FOR_EACH_VEC_ELT (remove_edges, i, ein)\n \tremove_path (ein);\n-      remove_edges.release ();\n     }\n \n   ein = desc->in_edge;\n@@ -760,7 +757,6 @@ unroll_loop_constant_iterations (struct loop *loop)\n   unsigned exit_mod;\n   sbitmap wont_exit;\n   unsigned i;\n-  vec<edge> remove_edges;\n   edge e;\n   unsigned max_unroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n@@ -778,7 +774,7 @@ unroll_loop_constant_iterations (struct loop *loop)\n   wont_exit = sbitmap_alloc (max_unroll + 1);\n   bitmap_ones (wont_exit);\n \n-  remove_edges.create (0);\n+  auto_vec<edge> remove_edges;\n   if (flag_split_ivs_in_unroller\n       || flag_variable_expansion_in_unroller)\n     opt_info = analyze_insns_in_loop (loop);\n@@ -928,7 +924,6 @@ unroll_loop_constant_iterations (struct loop *loop)\n   /* Remove the edges.  */\n   FOR_EACH_VEC_ELT (remove_edges, i, e)\n     remove_path (e);\n-  remove_edges.release ();\n \n   if (dump_file)\n     fprintf (dump_file,\n@@ -1099,11 +1094,9 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   rtx old_niter, niter, init_code, branch_code, tmp;\n   unsigned i, j, p;\n   basic_block preheader, *body, swtch, ezc_swtch;\n-  vec<basic_block> dom_bbs;\n   sbitmap wont_exit;\n   int may_exit_copy;\n   unsigned n_peel;\n-  vec<edge> remove_edges;\n   edge e;\n   bool extra_zero_check, last_may_exit;\n   unsigned max_unroll = loop->lpt_decision.times;\n@@ -1117,7 +1110,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n     opt_info = analyze_insns_in_loop (loop);\n \n   /* Remember blocks whose dominators will have to be updated.  */\n-  dom_bbs.create (0);\n+  auto_vec<basic_block> dom_bbs;\n \n   body = get_loop_body (loop);\n   for (i = 0; i < loop->num_nodes; i++)\n@@ -1174,7 +1167,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   /* Precondition the loop.  */\n   split_edge_and_insert (loop_preheader_edge (loop), init_code);\n \n-  remove_edges.create (0);\n+  auto_vec<edge> remove_edges;\n \n   wont_exit = sbitmap_alloc (max_unroll + 2);\n \n@@ -1298,7 +1291,6 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   /* Remove the edges.  */\n   FOR_EACH_VEC_ELT (remove_edges, i, e)\n     remove_path (e);\n-  remove_edges.release ();\n \n   /* We must be careful when updating the number of iterations due to\n      preconditioning and the fact that the value must be valid at entry\n@@ -1335,8 +1327,6 @@ unroll_loop_runtime_iterations (struct loop *loop)\n \t     \";; Unrolled loop %d times, counting # of iterations \"\n \t     \"in runtime, %i insns\\n\",\n \t     max_unroll, num_loop_insns (loop));\n-\n-  dom_bbs.release ();\n }\n \n /* Decide whether to simply peel LOOP and how much.  */"}, {"sha": "29950608b9f61bcd0f2655a2ce0eac3a4af4a6c0", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -6901,7 +6901,6 @@ static void\n expand_omp_sections (struct omp_region *region)\n {\n   tree t, u, vin = NULL, vmain, vnext, l2;\n-  vec<tree> label_vec;\n   unsigned len;\n   basic_block entry_bb, l0_bb, l1_bb, l2_bb, default_bb;\n   gimple_stmt_iterator si, switch_si;\n@@ -6954,7 +6953,7 @@ expand_omp_sections (struct omp_region *region)\n \n   /* Use vec::quick_push on label_vec throughout, since we know the size\n      in advance.  */\n-  label_vec.create (len);\n+  auto_vec<tree> label_vec (len);\n \n   /* The call to GOMP_sections_start goes in ENTRY_BB, replacing the\n      GIMPLE_OMP_SECTIONS statement.  */\n@@ -7050,7 +7049,6 @@ expand_omp_sections (struct omp_region *region)\n   stmt = gimple_build_switch (vmain, u, label_vec);\n   gsi_insert_after (&switch_si, stmt, GSI_SAME_STMT);\n   gsi_remove (&switch_si, true);\n-  label_vec.release ();\n \n   si = gsi_start_bb (default_bb);\n   stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);"}, {"sha": "87427fdb00ec2817ac5cbf7bf9112914dbe39d71", "filename": "gcc/ree.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -862,7 +862,7 @@ find_and_remove_re (void)\n   rtx curr_insn = NULL_RTX;\n   int num_re_opportunities = 0, num_realized = 0, i;\n   vec<ext_cand> reinsn_list;\n-  vec<rtx> reinsn_del_list;\n+  auto_vec<rtx> reinsn_del_list;\n   ext_state state;\n \n   /* Construct DU chain to get all reaching definitions of each\n@@ -873,7 +873,6 @@ find_and_remove_re (void)\n   df_set_flags (DF_DEFER_INSN_RESCAN);\n \n   max_insn_uid = get_max_uid ();\n-  reinsn_del_list.create (0);\n   reinsn_list = find_removable_extensions ();\n   state.defs_list.create (0);\n   state.copies_list.create (0);\n@@ -910,7 +909,6 @@ find_and_remove_re (void)\n     delete_insn (curr_insn);\n \n   reinsn_list.release ();\n-  reinsn_del_list.release ();\n   state.defs_list.release ();\n   state.copies_list.release ();\n   state.modified_list.release ();"}, {"sha": "9e6f4d9cec7b26f61154ee97b5ef86623b48fdc0", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1944,10 +1944,10 @@ tm_region_init (struct tm_region *region)\n   edge_iterator ei;\n   edge e;\n   basic_block bb;\n-  vec<basic_block> queue = vNULL;\n+  auto_vec<basic_block> queue;\n   bitmap visited_blocks = BITMAP_ALLOC (NULL);\n   struct tm_region *old_region;\n-  vec<tm_region_p> bb_regions = vNULL;\n+  auto_vec<tm_region_p> bb_regions;\n \n   all_tm_regions = region;\n   bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n@@ -1991,9 +1991,7 @@ tm_region_init (struct tm_region *region)\n \t  }\n     }\n   while (!queue.is_empty ());\n-  queue.release ();\n   BITMAP_FREE (visited_blocks);\n-  bb_regions.release ();\n }\n \n /* The \"gate\" function for all transactional memory expansion and optimization\n@@ -4521,7 +4519,6 @@ ipa_tm_scan_irr_function (struct cgraph_node *node, bool for_clone)\n {\n   struct tm_ipa_cg_data *d;\n   bitmap new_irr, old_irr;\n-  vec<basic_block> queue;\n   bool ret = false;\n \n   /* Builtin operators (operator new, and such).  */\n@@ -4533,7 +4530,7 @@ ipa_tm_scan_irr_function (struct cgraph_node *node, bool for_clone)\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   d = get_cg_data (&node, true);\n-  queue.create (10);\n+  stack_vec<basic_block, 10> queue;\n   new_irr = BITMAP_ALLOC (&tm_obstack);\n \n   /* Scan each tm region, propagating irrevocable status through the tree.  */\n@@ -4600,7 +4597,6 @@ ipa_tm_scan_irr_function (struct cgraph_node *node, bool for_clone)\n   else\n     BITMAP_FREE (new_irr);\n \n-  queue.release ();\n   pop_cfun ();\n \n   return ret;\n@@ -5207,7 +5203,7 @@ ipa_tm_transform_calls (struct cgraph_node *node, struct tm_region *region,\n   bool need_ssa_rename = false;\n   edge e;\n   edge_iterator ei;\n-  vec<basic_block> queue = vNULL;\n+  auto_vec<basic_block> queue;\n   bitmap visited_blocks = BITMAP_ALLOC (NULL);\n \n   queue.safe_push (bb);\n@@ -5233,7 +5229,6 @@ ipa_tm_transform_calls (struct cgraph_node *node, struct tm_region *region,\n     }\n   while (!queue.is_empty ());\n \n-  queue.release ();\n   BITMAP_FREE (visited_blocks);\n \n   return need_ssa_rename;"}, {"sha": "c0dcf484b2d6607e05d9a3f17fc9487587f35c19", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -871,7 +871,7 @@ tree_call_cdce (void)\n   basic_block bb;\n   gimple_stmt_iterator i;\n   bool something_changed = false;\n-  vec<gimple> cond_dead_built_in_calls = vNULL;\n+  auto_vec<gimple> cond_dead_built_in_calls;\n   FOR_EACH_BB (bb)\n     {\n       /* Collect dead call candidates.  */\n@@ -900,8 +900,6 @@ tree_call_cdce (void)\n   something_changed\n     = shrink_wrap_conditional_dead_built_in_calls (cond_dead_built_in_calls);\n \n-  cond_dead_built_in_calls.release ();\n-\n   if (something_changed)\n     {\n       free_dominance_info (CDI_DOMINATORS);"}, {"sha": "778c0a798b1a1b86c692edd7fba214c20ef95e48", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -3569,7 +3569,7 @@ lower_eh_dispatch (basic_block src, gimple stmt)\n     {\n     case ERT_TRY:\n       {\n-\tvec<tree> labels = vNULL;\n+\tauto_vec<tree> labels;\n \ttree default_label = NULL;\n \teh_catch c;\n \tedge_iterator ei;\n@@ -3657,8 +3657,6 @@ lower_eh_dispatch (basic_block src, gimple stmt)\n \n \t    x = gimple_build_switch (filter, default_label, labels);\n \t    gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n-\n-\t    labels.release ();\n \t  }\n \tpointer_set_destroy (seen_values);\n       }"}, {"sha": "cf08386ed3c2e737decba7973494e955dbe92b1e", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1215,7 +1215,6 @@ if_convertible_loop_p (struct loop *loop)\n \tfree (dr->aux);\n     }\n \n-  loop_nest.release ();\n   free_data_refs (refs);\n   free_dependence_relations (ddrs);\n   return res;"}, {"sha": "41c0896b97c0b0f61f125c2ab7035dafafc9ac78", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -764,7 +764,6 @@ find_dfsnum_interval (struct dom_dfsnum *defs, unsigned n, unsigned s)\n static void\n prune_unused_phi_nodes (bitmap phis, bitmap kills, bitmap uses)\n {\n-  vec<int> worklist;\n   bitmap_iterator bi;\n   unsigned i, b, p, u, top;\n   bitmap live_phis;\n@@ -836,7 +835,7 @@ prune_unused_phi_nodes (bitmap phis, bitmap kills, bitmap uses)\n      dfs_out numbers, increase the dfs number by one (so that it corresponds\n      to the start of the following interval, not to the end of the current\n      one).  We use WORKLIST as a stack.  */\n-  worklist.create (n_defs + 1);\n+  auto_vec<int> worklist (n_defs + 1);\n   worklist.quick_push (1);\n   top = 1;\n   n_defs = 1;\n@@ -923,7 +922,6 @@ prune_unused_phi_nodes (bitmap phis, bitmap kills, bitmap uses)\n \t}\n     }\n \n-  worklist.release ();\n   bitmap_copy (phis, live_phis);\n   BITMAP_FREE (live_phis);\n   free (defs);\n@@ -1084,11 +1082,10 @@ insert_phi_nodes (bitmap_head *dfs)\n   hash_table <var_info_hasher>::iterator hi;\n   unsigned i;\n   var_info_p info;\n-  vec<var_info_p> vars;\n \n   timevar_push (TV_TREE_INSERT_PHI_NODES);\n \n-  vars.create (var_infos.elements ());\n+  auto_vec<var_info_p> vars (var_infos.elements ());\n   FOR_EACH_HASH_TABLE_ELEMENT (var_infos, info, var_info_p, hi)\n     if (info->info.need_phi_state != NEED_PHI_STATE_NO)\n       vars.quick_push (info);\n@@ -1104,8 +1101,6 @@ insert_phi_nodes (bitmap_head *dfs)\n       BITMAP_FREE (idf);\n     }\n \n-  vars.release ();\n-\n   timevar_pop (TV_TREE_INSERT_PHI_NODES);\n }\n "}, {"sha": "6121236f99b03967bccba139724e35352c82f54a", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1406,7 +1406,6 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n \t\t control_dependences *cd, int *nb_calls)\n {\n   struct graph *rdg;\n-  vec<partition_t> partitions;\n   partition_t partition;\n   bool any_builtin;\n   int i, nbp;\n@@ -1432,7 +1431,7 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_rdg (dump_file, rdg);\n \n-  partitions.create (3);\n+  stack_vec<partition_t, 3> partitions;\n   rdg_build_partitions (rdg, stmts, &partitions);\n \n   any_builtin = false;\n@@ -1658,7 +1657,6 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n \n   FOR_EACH_VEC_ELT (partitions, i, partition)\n     partition_free (partition);\n-  partitions.release ();\n \n   free_rdg (rdg);\n   return nbp - *nb_calls;\n@@ -1687,7 +1685,7 @@ tree_loop_distribution (void)\n      walking to innermost loops.  */\n   FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     {\n-      vec<gimple> work_list = vNULL;\n+      auto_vec<gimple> work_list;\n       basic_block *bbs;\n       int num = loop->num;\n       unsigned int i;\n@@ -1769,8 +1767,6 @@ tree_loop_distribution (void)\n \t}\n       else if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Loop %d is the same.\\n\", num);\n-\n-      work_list.release ();\n     }\n \n   if (cd)"}, {"sha": "0d3c66cc877f633e1fe4ef81eb67fb8472cee7f3", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1538,7 +1538,7 @@ initialize_root_vars_lm (struct loop *loop, dref root, bool written,\n static void\n execute_load_motion (struct loop *loop, chain_p chain, bitmap tmp_vars)\n {\n-  vec<tree> vars;\n+  auto_vec<tree> vars;\n   dref a;\n   unsigned n_writes = 0, ridx, i;\n   tree var;\n@@ -1577,8 +1577,6 @@ execute_load_motion (struct loop *loop, chain_p chain, bitmap tmp_vars)\n       replace_ref_with (a->stmt, vars[ridx],\n \t\t\t!is_read, !is_read);\n     }\n-\n-  vars.release ();\n }\n \n /* Returns the single statement in that NAME is used, excepting\n@@ -2272,7 +2270,7 @@ try_combine_chains (vec<chain_p> *chains)\n {\n   unsigned i, j;\n   chain_p ch1, ch2, cch;\n-  vec<chain_p> worklist = vNULL;\n+  auto_vec<chain_p> worklist;\n \n   FOR_EACH_VEC_ELT (*chains, i, ch1)\n     if (chain_can_be_combined_p (ch1))\n@@ -2298,8 +2296,6 @@ try_combine_chains (vec<chain_p> *chains)\n \t    }\n \t}\n     }\n-\n-  worklist.release ();\n }\n \n /* Prepare initializers for CHAIN in LOOP.  Returns false if this is"}, {"sha": "60b633f34e11896254833b2217f647619851d0b0", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -3784,10 +3784,9 @@ analyze_modified_params (vec<access_p> representatives)\n static void\n propagate_dereference_distances (void)\n {\n-  vec<basic_block> queue;\n   basic_block bb;\n \n-  queue.create (last_basic_block_for_function (cfun));\n+  auto_vec<basic_block> queue (last_basic_block_for_function (cfun));\n   queue.quick_push (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   FOR_EACH_BB (bb)\n     {\n@@ -3847,8 +3846,6 @@ propagate_dereference_distances (void)\n \t    queue.quick_push (e->src);\n \t  }\n     }\n-\n-  queue.release ();\n }\n \n /* Dump a dereferences TABLE with heading STR to file F.  */"}, {"sha": "0fe3afe3fdfe44ba2df3c061d9ebda3ac2d8ba52", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1281,8 +1281,7 @@ static void\n simplify_gimple_switch_label_vec (gimple stmt, tree index_type)\n {\n   unsigned int branch_num = gimple_switch_num_labels (stmt);\n-  vec<tree> labels;\n-  labels.create (branch_num);\n+  auto_vec<tree> labels (branch_num);\n   unsigned int i, len;\n \n   /* Collect the existing case labels in a VEC, and preprocess it as if\n@@ -1343,8 +1342,6 @@ simplify_gimple_switch_label_vec (gimple stmt, tree index_type)\n \t} \n       BITMAP_FREE (target_blocks);\n     }\n-\n-  labels.release ();\n }\n \n /* STMT is a SWITCH_EXPR for which we attempt to find equivalent forms of"}, {"sha": "031b7c757e62b93134894e7277c8f0cbe515237b", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -187,15 +187,14 @@ compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n {\n   unsigned i;\n   bitmap_iterator bi;\n-  vec<basic_block> worklist;\n   struct loop *def_loop = def_bb->loop_father;\n   unsigned def_loop_depth = loop_depth (def_loop);\n   bitmap def_loop_exits;\n \n   /* Normally the work list size is bounded by the number of basic\n      blocks in the largest loop.  We don't know this number, but we\n      can be fairly sure that it will be relatively small.  */\n-  worklist.create (MAX (8, n_basic_blocks_for_fn (cfun) / 128));\n+  auto_vec<basic_block> worklist (MAX (8, n_basic_blocks_for_fn (cfun) / 128));\n \n   EXECUTE_IF_SET_IN_BITMAP (use_blocks, 0, i, bi)\n     {\n@@ -258,7 +257,6 @@ compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n \t  worklist.quick_push (pred);\n \t}\n     }\n-  worklist.release ();\n \n   def_loop_exits = BITMAP_ALLOC (&loop_renamer_obstack);\n   for (struct loop *loop = def_loop;\n@@ -1046,7 +1044,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   unsigned new_est_niter, i, prob;\n   unsigned irr = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;\n   sbitmap wont_exit;\n-  vec<edge> to_remove = vNULL;\n+  auto_vec<edge> to_remove;\n \n   est_niter = expected_loop_iterations (loop);\n   determine_exit_conditions (loop, desc, factor,\n@@ -1194,7 +1192,6 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n       ok = remove_path (e);\n       gcc_assert (ok);\n     }\n-  to_remove.release ();\n   update_ssa (TODO_update_ssa);\n \n   /* Ensure that the frequencies in the loop match the new estimated"}, {"sha": "79eb0fbd914d4f68d45423ee9733bc1844e9f6b2", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -2182,11 +2182,10 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n      phis to translate through.  */\n   else\n     {\n-      vec<basic_block> worklist;\n       size_t i;\n       basic_block bprime, first = NULL;\n \n-      worklist.create (EDGE_COUNT (block->succs));\n+      auto_vec<basic_block> worklist (EDGE_COUNT (block->succs));\n       FOR_EACH_EDGE (e, ei, block->succs)\n \t{\n \t  if (!first\n@@ -2224,7 +2223,6 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \t  else\n \t    bitmap_set_and (ANTIC_OUT, ANTIC_IN (bprime));\n \t}\n-      worklist.release ();\n     }\n \n   /* Prune expressions that are clobbered in block and thus become\n@@ -2346,11 +2344,10 @@ compute_partial_antic_aux (basic_block block,\n      them.  */\n   else\n     {\n-      vec<basic_block> worklist;\n       size_t i;\n       basic_block bprime;\n \n-      worklist.create (EDGE_COUNT (block->succs));\n+      auto_vec<basic_block> worklist (EDGE_COUNT (block->succs));\n       FOR_EACH_EDGE (e, ei, block->succs)\n \t{\n \t  if (e->flags & EDGE_DFS_BACK)\n@@ -2382,7 +2379,6 @@ compute_partial_antic_aux (basic_block block,\n \t\t\t\t\t\texpression_for_id (i));\n \t    }\n \t}\n-      worklist.release ();\n     }\n \n   /* Prune expressions that are clobbered in block and thus become\n@@ -3462,7 +3458,6 @@ do_regular_insertion (basic_block block, basic_block dom)\n     }\n \n   exprs.release ();\n-  avail.release ();\n   return new_stuff;\n }\n \n@@ -3480,7 +3475,7 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n   bool new_stuff = false;\n   vec<pre_expr> exprs;\n   pre_expr expr;\n-  vec<pre_expr> avail = vNULL;\n+  auto_vec<pre_expr> avail;\n   int i;\n \n   exprs = sorted_array_from_bitmap_set (PA_IN (block));\n@@ -3601,7 +3596,6 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n     }\n \n   exprs.release ();\n-  avail.release ();\n   return new_stuff;\n }\n \n@@ -3826,7 +3820,7 @@ compute_avail (void)\n \t      {\n \t\tvn_reference_t ref;\n \t\tpre_expr result = NULL;\n-\t\tvec<vn_reference_op_s> ops = vNULL;\n+\t\tauto_vec<vn_reference_op_s> ops;\n \n \t\t/* We can value number only calls to real functions.  */\n \t\tif (gimple_call_internal_p (stmt))\n@@ -3836,7 +3830,6 @@ compute_avail (void)\n \t\tvn_reference_lookup_pieces (gimple_vuse (stmt), 0,\n \t\t\t\t\t    gimple_expr_type (stmt),\n \t\t\t\t\t    ops, &ref, VN_NOWALK);\n-\t\tops.release ();\n \t\tif (!ref)\n \t\t  continue;\n "}, {"sha": "e8f56cf7099d8cfe2e52a96d7ba7a1ef26c4c685", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -2660,8 +2660,8 @@ maybe_optimize_range_tests (gimple stmt)\n   basic_block bb;\n   edge_iterator ei;\n   edge e;\n-  vec<operand_entry_t> ops = vNULL;\n-  vec<inter_bb_range_test_entry> bbinfo = vNULL;\n+  auto_vec<operand_entry_t> ops;\n+  auto_vec<inter_bb_range_test_entry> bbinfo;\n   bool any_changes = false;\n \n   /* Consider only basic blocks that end with GIMPLE_COND or\n@@ -2975,8 +2975,6 @@ maybe_optimize_range_tests (gimple stmt)\n \t    break;\n \t}\n     }\n-  bbinfo.release ();\n-  ops.release ();\n }\n \n /* Return true if OPERAND is defined by a PHI node which uses the LHS\n@@ -4401,7 +4399,7 @@ reassociate_bb (basic_block bb)\n \n \t  if (associative_tree_code (rhs_code))\n \t    {\n-\t      vec<operand_entry_t> ops = vNULL;\n+\t      auto_vec<operand_entry_t> ops;\n \t      tree powi_result = NULL_TREE;\n \n \t      /* There may be no immediate uses left by the time we\n@@ -4489,8 +4487,6 @@ reassociate_bb (basic_block bb)\n \t\t      gsi_insert_after (&gsi, mul_stmt, GSI_NEW_STMT);\n \t\t    }\n \t\t}\n-\n-\t      ops.release ();\n \t    }\n \t}\n     }"}, {"sha": "925fcf1850328efa720a1e4678bb075e937b19b8", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1751,8 +1751,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n       tree base2;\n       HOST_WIDE_INT offset2, size2, maxsize2;\n       int i, j;\n-      vec<vn_reference_op_s>\n-\t  rhs = vNULL;\n+      auto_vec<vn_reference_op_s> rhs;\n       vn_reference_op_t vro;\n       ao_ref r;\n \n@@ -1815,7 +1814,6 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n \tvr->operands.truncate (i + 1 + rhs.length ());\n       FOR_EACH_VEC_ELT (rhs, j, vro)\n \tvr->operands[i + 1 + j] = *vro;\n-      rhs.release ();\n       vr->operands = valueize_refs (vr->operands);\n       vr->hashcode = vn_reference_compute_hash (vr);\n \n@@ -3787,7 +3785,7 @@ process_scc (vec<tree> scc)\n static bool\n extract_and_process_scc_for_name (tree name)\n {\n-  vec<tree> scc = vNULL;\n+  auto_vec<tree> scc;\n   tree x;\n \n   /* Found an SCC, pop the components off the SCC stack and\n@@ -3809,7 +3807,6 @@ extract_and_process_scc_for_name (tree name)\n \t\t \"SCC size %u exceeding %u\\n\", scc.length (),\n \t\t (unsigned)PARAM_VALUE (PARAM_SCCVN_MAX_SCC_SIZE));\n \n-      scc.release ();\n       return false;\n     }\n \n@@ -3821,8 +3818,6 @@ extract_and_process_scc_for_name (tree name)\n \n   process_scc (scc);\n \n-  scc.release ();\n-\n   return true;\n }\n "}, {"sha": "b8e79fabc2a7555e7f41cf379301cd19a6efb0eb", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -2573,7 +2573,7 @@ eliminate_indirect_cycles (unsigned int node)\n       && !bitmap_empty_p (get_varinfo (node)->solution))\n     {\n       unsigned int i;\n-      vec<unsigned> queue = vNULL;\n+      auto_vec<unsigned> queue;\n       int queuepos;\n       unsigned int to = find (graph->indirect_cycles[node]);\n       bitmap_iterator bi;\n@@ -2597,7 +2597,6 @@ eliminate_indirect_cycles (unsigned int node)\n \t{\n \t  unify_nodes (graph, to, i, true);\n \t}\n-      queue.release ();\n       return true;\n     }\n   return false;\n@@ -3477,7 +3476,7 @@ get_constraint_for_1 (tree t, vec<ce_s> *results, bool address_p,\n \t    {\n \t      unsigned int i;\n \t      tree val;\n-\t      vec<ce_s> tmp = vNULL;\n+\t      auto_vec<ce_s> tmp;\n \t      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (t), i, val)\n \t\t{\n \t\t  struct constraint_expr *rhsp;\n@@ -3487,7 +3486,6 @@ get_constraint_for_1 (tree t, vec<ce_s> *results, bool address_p,\n \t\t    results->safe_push (*rhsp);\n \t\t  tmp.truncate (0);\n \t\t}\n-\t      tmp.release ();\n \t      /* We do not know whether the constructor was complete,\n \t         so technically we have to add &NOTHING or &ANYTHING\n \t\t like we do for an empty constructor as well.  */\n@@ -3577,8 +3575,8 @@ static void\n do_structure_copy (tree lhsop, tree rhsop)\n {\n   struct constraint_expr *lhsp, *rhsp;\n-  vec<ce_s> lhsc = vNULL;\n-  vec<ce_s> rhsc = vNULL;\n+  auto_vec<ce_s> lhsc;\n+  auto_vec<ce_s> rhsc;\n   unsigned j;\n \n   get_constraint_for (lhsop, &lhsc);\n@@ -3637,9 +3635,6 @@ do_structure_copy (tree lhsop, tree rhsop)\n     }\n   else\n     gcc_unreachable ();\n-\n-  lhsc.release ();\n-  rhsc.release ();\n }\n \n /* Create constraints ID = { rhsc }.  */\n@@ -3664,10 +3659,9 @@ make_constraints_to (unsigned id, vec<ce_s> rhsc)\n static void\n make_constraint_to (unsigned id, tree op)\n {\n-  vec<ce_s> rhsc = vNULL;\n+  auto_vec<ce_s> rhsc;\n   get_constraint_for_rhs (op, &rhsc);\n   make_constraints_to (id, rhsc);\n-  rhsc.release ();\n }\n \n /* Create a constraint ID = &FROM.  */\n@@ -3938,15 +3932,14 @@ handle_rhs_call (gimple stmt, vec<ce_s> *results)\n       && gimple_call_lhs (stmt) != NULL_TREE\n       && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (stmt))))\n     {\n-      vec<ce_s> tmpc = vNULL;\n+      auto_vec<ce_s> tmpc;\n       struct constraint_expr lhsc, *c;\n       get_constraint_for_address_of (gimple_call_lhs (stmt), &tmpc);\n       lhsc.var = escaped_id;\n       lhsc.offset = 0;\n       lhsc.type = SCALAR;\n       FOR_EACH_VEC_ELT (tmpc, i, c)\n \tprocess_constraint (new_constraint (lhsc, *c));\n-      tmpc.release ();\n     }\n \n   /* Regular functions return nonlocal memory.  */\n@@ -3964,7 +3957,7 @@ static void\n handle_lhs_call (gimple stmt, tree lhs, int flags, vec<ce_s> rhsc,\n \t\t tree fndecl)\n {\n-  vec<ce_s> lhsc = vNULL;\n+  auto_vec<ce_s> lhsc;\n \n   get_constraint_for (lhs, &lhsc);\n   /* If the store is to a global decl make sure to\n@@ -4019,8 +4012,6 @@ handle_lhs_call (gimple stmt, tree lhs, int flags, vec<ce_s> rhsc,\n     }\n   else\n     process_all_all_constraints (lhsc, rhsc);\n-\n-  lhsc.release ();\n }\n \n /* For non-IPA mode, generate constraints necessary for a call of a\n@@ -4049,13 +4040,12 @@ handle_const_call (gimple stmt, vec<ce_s> *results)\n   for (k = 0; k < gimple_call_num_args (stmt); ++k)\n     {\n       tree arg = gimple_call_arg (stmt, k);\n-      vec<ce_s> argc = vNULL;\n+      auto_vec<ce_s> argc;\n       unsigned i;\n       struct constraint_expr *argp;\n       get_constraint_for_rhs (arg, &argc);\n       FOR_EACH_VEC_ELT (argc, i, argp)\n \tresults->safe_push (*argp);\n-      argc.release ();\n     }\n \n   /* May return addresses of globals.  */\n@@ -4854,7 +4844,7 @@ find_func_clobbers (gimple origt)\n {\n   gimple t = origt;\n   vec<ce_s> lhsc = vNULL;\n-  vec<ce_s> rhsc = vNULL;\n+  auto_vec<ce_s> rhsc;\n   varinfo_t fi;\n \n   /* Add constraints for clobbered/used in IPA mode.\n@@ -5119,8 +5109,6 @@ find_func_clobbers (gimple origt)\n       make_constraint_from (first_vi_for_offset (fi, fi_uses),\n \t\t\t    anything_id);\n     }\n-\n-  rhsc.release ();\n }\n \n \n@@ -5623,7 +5611,7 @@ create_variable_info_for_1 (tree decl, const char *name)\n   varinfo_t vi, newvi;\n   tree decl_type = TREE_TYPE (decl);\n   tree declsize = DECL_P (decl) ? DECL_SIZE (decl) : TYPE_SIZE (decl_type);\n-  vec<fieldoff_s> fieldstack = vNULL;\n+  auto_vec<fieldoff_s> fieldstack;\n   fieldoff_s *fo;\n   unsigned int i;\n \n@@ -5726,8 +5714,6 @@ create_variable_info_for_1 (tree decl, const char *name)\n \t}\n     }\n \n-  fieldstack.release ();\n-\n   return vi;\n }\n \n@@ -5778,7 +5764,7 @@ create_variable_info_for (tree decl, const char *name)\n \t  if (DECL_INITIAL (decl)\n \t      && vnode->definition)\n \t    {\n-\t      vec<ce_s> rhsc = vNULL;\n+\t      auto_vec<ce_s> rhsc;\n \t      struct constraint_expr lhs, *rhsp;\n \t      unsigned i;\n \t      get_constraint_for_rhs (DECL_INITIAL (decl), &rhsc);\n@@ -5797,7 +5783,6 @@ create_variable_info_for (tree decl, const char *name)\n \t\t  FOR_EACH_VEC_ELT (rhsc, i, rhsp)\n \t\t    process_constraint (new_constraint (lhs, *rhsp));\n \t\t}\n-\t      rhsc.release ();\n \t    }\n \t}\n     }"}, {"sha": "bcd351621c9a58edc2051b480aac139be849755f", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -3802,14 +3802,14 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n   bool extract_scalar_result = false;\n   gimple use_stmt, orig_stmt, reduction_phi = NULL;\n   bool nested_in_vect_loop = false;\n-  vec<gimple> new_phis = vNULL;\n-  vec<gimple> inner_phis = vNULL;\n+  auto_vec<gimple> new_phis;\n+  auto_vec<gimple> inner_phis;\n   enum vect_def_type dt = vect_unknown_def_type;\n   int j, i;\n-  vec<tree> scalar_results = vNULL;\n+  auto_vec<tree> scalar_results;\n   unsigned int group_size = 1, k, ratio;\n-  vec<tree> vec_initial_defs = vNULL;\n-  vec<gimple> phis;\n+  auto_vec<tree> vec_initial_defs;\n+  auto_vec<gimple> phis;\n   bool slp_reduc = false;\n   tree new_phi_result;\n   gimple inner_phi = NULL;\n@@ -3913,8 +3913,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n         }\n     }\n \n-  vec_initial_defs.release ();\n-\n   /* 2. Create epilog code.\n         The reduction epilog code operates across the elements of the vector\n         of partial results computed by the vectorized loop.\n@@ -4594,10 +4592,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n \n       phis.release ();\n     }\n-\n-  scalar_results.release ();\n-  inner_phis.release ();\n-  new_phis.release ();\n }\n \n \n@@ -4685,10 +4679,10 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   struct loop * def_stmt_loop, *outer_loop = NULL;\n   tree def_arg;\n   gimple def_arg_stmt;\n-  vec<tree> vec_oprnds0 = vNULL;\n-  vec<tree> vec_oprnds1 = vNULL;\n-  vec<tree> vect_defs = vNULL;\n-  vec<gimple> phis = vNULL;\n+  auto_vec<tree> vec_oprnds0;\n+  auto_vec<tree> vec_oprnds1;\n+  auto_vec<tree> vect_defs;\n+  auto_vec<gimple> phis;\n   int vec_num;\n   tree def0, def1, tem, op0, op1 = NULL_TREE;\n \n@@ -5304,11 +5298,6 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n                                     epilog_reduc_code, phis, reduc_index,\n                                     double_reduc, slp_node);\n \n-  phis.release ();\n-  vect_defs.release ();\n-  vec_oprnds0.release ();\n-  vec_oprnds1.release ();\n-\n   return true;\n }\n "}, {"sha": "1aede48dc77547eed9df3c708ad1f7e947a8e8b7", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1580,10 +1580,8 @@ vect_get_vec_defs (tree op0, tree op1, gimple stmt,\n   if (slp_node)\n     {\n       int nops = (op1 == NULL_TREE) ? 1 : 2;\n-      vec<tree> ops;\n-      ops.create (nops);\n-      vec<vec<tree> > vec_defs;\n-      vec_defs.create (nops);\n+      auto_vec<tree> ops (nops);\n+      auto_vec<vec<tree> > vec_defs (nops);\n \n       ops.quick_push (op0);\n       if (op1)\n@@ -1594,9 +1592,6 @@ vect_get_vec_defs (tree op0, tree op1, gimple stmt,\n       *vec_oprnds0 = vec_defs[0];\n       if (op1)\n \t*vec_oprnds1 = vec_defs[1];\n-\n-      ops.release ();\n-      vec_defs.release ();\n     }\n   else\n     {\n@@ -1907,8 +1902,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n \t  if (slp_node)\n \t    {\n-\t      vec<vec<tree> > vec_defs;\n-\t      vec_defs.create (nargs);\n+\t      auto_vec<vec<tree> > vec_defs (nargs);\n \t      vec<tree> vec_oprnds0;\n \n \t      for (i = 0; i < nargs; i++)\n@@ -1937,7 +1931,6 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t  vec<tree> vec_oprndsi = vec_defs[i];\n \t\t  vec_oprndsi.release ();\n \t\t}\n-\t      vec_defs.release ();\n \t      continue;\n \t    }\n \n@@ -2004,8 +1997,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n \t  if (slp_node)\n \t    {\n-\t      vec<vec<tree> > vec_defs;\n-\t      vec_defs.create (nargs);\n+\t      auto_vec<vec<tree> > vec_defs (nargs);\n \t      vec<tree> vec_oprnds0;\n \n \t      for (i = 0; i < nargs; i++)\n@@ -2036,7 +2028,6 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t  vec<tree> vec_oprndsi = vec_defs[i];\n \t\t  vec_oprndsi.release ();\n \t\t}\n-\t      vec_defs.release ();\n \t      continue;\n \t    }\n "}, {"sha": "03455851b0fd64f9de9048c01c06adf4b679470e", "filename": "gcc/vec.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef062b13d7ea5c4afe434a90436ce1908ac14442/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=ef062b13d7ea5c4afe434a90436ce1908ac14442", "patch": "@@ -1184,6 +1184,17 @@ struct vec<T, va_heap, vl_ptr>\n };\n \n \n+/* auto_vec is a sub class of vec whose storage is released when it is\n+  destroyed. */\n+template<typename T>\n+class auto_vec : public vec<T, va_heap>\n+{\n+public:\n+  auto_vec () { this->m_vec = NULL; }\n+  auto_vec (size_t n) { this->create (n); }\n+  ~auto_vec () { this->release (); }\n+};\n+\n /* stack_vec is a subclass of vec containing N elements of internal storage.\n   You probably only want to allocate this on the stack because if the array\n   ends up being larger or much smaller than N it will be wasting space. */"}]}