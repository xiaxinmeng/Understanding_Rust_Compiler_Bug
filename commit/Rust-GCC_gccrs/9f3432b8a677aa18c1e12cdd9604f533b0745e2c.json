{"sha": "9f3432b8a677aa18c1e12cdd9604f533b0745e2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYzNDMyYjhhNjc3YWExOGMxZTEyY2RkOTYwNGY1MzNiMDc0NWUyYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2007-02-16T23:40:52Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-02-16T23:40:52Z"}, "message": "trans.c (call_to_gnu): Use build_call_list instead of build3 to build the call expression.\n\n\t* trans.c (call_to_gnu):  Use build_call_list instead of build3 to\n\tbuild the call expression.\n\t(gnat_stabilize_reference_1): Handle tcc_vl_exp.\n\t* utils.c (max_size) <tcc_exceptional>: Delete.\n\t<tcc_vl_exp>: New case.\n\t<tcc_expression>: Delete CALL_EXPR subcase.\n\t(build_global_cdtor): Use build_call_nary instead of build3.\n\t* utils2.c (build_call_1_expr): Likewise.\n\t(build_call_2_expr): Likewise.\n\t(build_call_0_expr): Likewise.\n\t(build_call_alloc_dealloc): Likewise.\n\n\nCo-Authored-By: Sandra Loosemore <sandra@codesourcery.com>\n\nFrom-SVN: r122058", "tree": {"sha": "f2b1452445646bd9dfaa1a7a6c7e058bcdedd189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2b1452445646bd9dfaa1a7a6c7e058bcdedd189"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f3432b8a677aa18c1e12cdd9604f533b0745e2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f3432b8a677aa18c1e12cdd9604f533b0745e2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f3432b8a677aa18c1e12cdd9604f533b0745e2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f3432b8a677aa18c1e12cdd9604f533b0745e2c/comments", "author": null, "committer": null, "parents": [{"sha": "599b39ce9dcaba10e1c53934e50cca5f671a7f6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599b39ce9dcaba10e1c53934e50cca5f671a7f6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/599b39ce9dcaba10e1c53934e50cca5f671a7f6e"}], "stats": {"total": 136, "additions": 66, "deletions": 70}, "files": [{"sha": "493a41ef4e1824968726ac16df9f8a010544e900", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3432b8a677aa18c1e12cdd9604f533b0745e2c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3432b8a677aa18c1e12cdd9604f533b0745e2c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9f3432b8a677aa18c1e12cdd9604f533b0745e2c", "patch": "@@ -1,3 +1,18 @@\n+2007-02-16  Eric Botcazou  <ebotcazou@adacore.com>\n+            Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* trans.c (call_to_gnu):  Use build_call_list instead of build3 to\n+\tbuild the call expression.\n+\t(gnat_stabilize_reference_1): Handle tcc_vl_exp.\n+\t* utils.c (max_size) <tcc_exceptional>: Delete.\n+\t<tcc_vl_exp>: New case.\n+\t<tcc_expression>: Delete CALL_EXPR subcase.\n+\t(build_global_cdtor): Use build_call_nary instead of build3.\n+\t* utils2.c (build_call_1_expr): Likewise.\n+\t(build_call_2_expr): Likewise.\n+\t(build_call_0_expr): Likewise.\n+\t(build_call_alloc_dealloc): Likewise.\n+\n 2007-02-07  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* raise-gcc.c (get_region_description_for, get_call_site_action_for,"}, {"sha": "678801225032d624bf95b004ed3f102b0fad140b", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3432b8a677aa18c1e12cdd9604f533b0745e2c/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3432b8a677aa18c1e12cdd9604f533b0745e2c/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=9f3432b8a677aa18c1e12cdd9604f533b0745e2c", "patch": "@@ -389,12 +389,12 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      enclosing block, but we have no way of testing that right now.\n \n      ??? We used to essentially set the TREE_ADDRESSABLE flag on the variable\n-\ufffd \ufffd \ufffdhere, but it can now be removed by the Tree aliasing machinery if the\n-\ufffd \ufffd \ufffdaddress of the variable is never taken. \ufffdAll we can do is to make the\n-\ufffd \ufffd \ufffdvariable volatile, which might incur the generation of temporaries just\n-     to access the memory in some circumstances. \ufffdThis can be avoided for\n-\ufffd \ufffd \ufffdvariables of non-constant size because they are automatically allocated\n-\ufffd \ufffd \ufffdto memory.  There might be no way of allocating a proper temporary for\n+     here, but it can now be removed by the Tree aliasing machinery if the\n+     address of the variable is never taken.  All we can do is to make the\n+     variable volatile, which might incur the generation of temporaries just\n+     to access the memory in some circumstances.  This can be avoided for\n+     variables of non-constant size because they are automatically allocated\n+     to memory.  There might be no way of allocating a proper temporary for\n      them in any case.  We only do this for SJLJ though.  */\n   if (TREE_VALUE (gnu_except_ptr_stack)\n       && TREE_CODE (gnu_result) == VAR_DECL\n@@ -1992,9 +1992,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       gnu_actual_list = tree_cons (NULL_TREE, gnu_actual, gnu_actual_list);\n     }\n \n-  gnu_subprog_call = build3 (CALL_EXPR, TREE_TYPE (gnu_subprog_type),\n-\t\t\t     gnu_subprog_addr, nreverse (gnu_actual_list),\n-\t\t\t     NULL_TREE);\n+  gnu_subprog_call = build_call_list (TREE_TYPE (gnu_subprog_type),\n+\t\t\t\t      gnu_subprog_addr,\n+\t\t\t\t      nreverse (gnu_actual_list));\n \n   /* If we return by passing a target, we emit the call and return the target\n      as our result.  */\n@@ -6132,6 +6132,7 @@ gnat_stabilize_reference_1 (tree e, bool force)\n     case tcc_statement:\n     case tcc_expression:\n     case tcc_reference:\n+    case tcc_vl_exp:\n       /* If this is a COMPONENT_REF of a fat pointer, save the entire\n \t fat pointer.  This may be more efficient, but will also allow\n \t us to more easily find the match for the PLACEHOLDER_EXPR.  */"}, {"sha": "6dc47de6cb340ad140fee19494a9b0bf9f7b79a8", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3432b8a677aa18c1e12cdd9604f533b0745e2c/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3432b8a677aa18c1e12cdd9604f533b0745e2c/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=9f3432b8a677aa18c1e12cdd9604f533b0745e2c", "patch": "@@ -2335,12 +2335,18 @@ max_size (tree exp, bool max_p)\n     case tcc_constant:\n       return exp;\n \n-    case tcc_exceptional:\n-      if (code == TREE_LIST)\n-\treturn tree_cons (TREE_PURPOSE (exp),\n-\t\t\t  max_size (TREE_VALUE (exp), max_p),\n-\t\t\t  TREE_CHAIN (exp)\n-\t\t\t  ? max_size (TREE_CHAIN (exp), max_p) : NULL_TREE);\n+    case tcc_vl_exp:\n+      if (code == CALL_EXPR)\n+\t{\n+\t  tree *argarray;\n+\t  int i, n = call_expr_nargs (exp);\n+\t  gcc_assert (n > 0);\n+\n+\t  argarray = (tree *) alloca (n * sizeof (tree));\n+\t  for (i = 0; i < n; i++)\n+\t    argarray[i] = max_size (CALL_EXPR_ARG (exp, i), max_p);\n+\t  return build_call_array (type, CALL_EXPR_FN (exp), n, argarray);\n+\t}\n       break;\n \n     case tcc_reference:\n@@ -2428,9 +2434,6 @@ max_size (tree exp, bool max_p)\n \t    return fold (build2 (max_p ? MAX_EXPR : MIN_EXPR, type,\n \t\t\t\t max_size (TREE_OPERAND (exp, 1), max_p),\n \t\t\t\t max_size (TREE_OPERAND (exp, 2), max_p)));\n-\t  else if (code == CALL_EXPR && TREE_OPERAND (exp, 1))\n-\t    return build3 (CALL_EXPR, type, TREE_OPERAND (exp, 0),\n-\t\t\t   max_size (TREE_OPERAND (exp, 1), max_p), NULL);\n \t}\n \n       /* Other tree classes cannot happen.  */\n@@ -3745,8 +3748,7 @@ build_global_cdtor (int method_type, tree *vec, int len)\n     {\n       tree fntype = TREE_TYPE (vec[i]);\n       tree fnaddr = build1 (ADDR_EXPR, build_pointer_type (fntype), vec[i]);\n-      tree fncall = build3 (CALL_EXPR, TREE_TYPE (fntype), fnaddr, NULL_TREE,\n-\t\t\t    NULL_TREE);\n+      tree fncall = build_call_nary (TREE_TYPE (fntype), fnaddr, 0);\n       append_to_statement_list (fncall, &body);\n     }\n "}, {"sha": "31b0c6db9fdeb3845f1f3bb5c8f86a410696dcef", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 28, "deletions": 50, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3432b8a677aa18c1e12cdd9604f533b0745e2c/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3432b8a677aa18c1e12cdd9604f533b0745e2c/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=9f3432b8a677aa18c1e12cdd9604f533b0745e2c", "patch": "@@ -1394,13 +1394,10 @@ build_return_expr (tree result_decl, tree ret_val)\n tree\n build_call_1_expr (tree fundecl, tree arg)\n {\n-  tree call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n-\t\t      build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n-\t\t      chainon (NULL_TREE, build_tree_list (NULL_TREE, arg)),\n-\t\t      NULL_TREE);\n-\n+  tree call = build_call_nary (TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t\t       1, arg);\n   TREE_SIDE_EFFECTS (call) = 1;\n-\n   return call;\n }\n \n@@ -1410,15 +1407,10 @@ build_call_1_expr (tree fundecl, tree arg)\n tree\n build_call_2_expr (tree fundecl, tree arg1, tree arg2)\n {\n-  tree call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n-\t\t      build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n-\t\t      chainon (chainon (NULL_TREE,\n-\t\t\t\t\tbuild_tree_list (NULL_TREE, arg1)),\n-\t\t\t       build_tree_list (NULL_TREE, arg2)),\n-\t\t     NULL_TREE);\n-\n+  tree call = build_call_nary (TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t\t       2, arg1, arg2);\n   TREE_SIDE_EFFECTS (call) = 1;\n-\n   return call;\n }\n \n@@ -1427,13 +1419,11 @@ build_call_2_expr (tree fundecl, tree arg1, tree arg2)\n tree\n build_call_0_expr (tree fundecl)\n {\n-  tree call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n-\t\t      build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n-\t\t      NULL_TREE, NULL_TREE);\n-\n-  /* We rely on build3 to compute TREE_SIDE_EFFECTS.  This makes it possible\n-     to propagate the DECL_IS_PURE flag on parameterless functions.  */\n-\n+  /* We rely on build_call_nary to compute TREE_SIDE_EFFECTS.  This makes\n+     it possible to propagate DECL_IS_PURE on parameterless functions.  */\n+  tree call = build_call_nary (TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t\t       0);\n   return call;\n }\n \f\n@@ -1721,30 +1711,22 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \t  tree gnu_proc_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_proc);\n \t  tree gnu_pool = gnat_to_gnu (gnat_pool);\n \t  tree gnu_pool_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_pool);\n-\t  tree gnu_args = NULL_TREE;\n \t  tree gnu_call;\n \n+\t  gnu_size = convert (gnu_size_type, gnu_size);\n+\t  gnu_align = convert (gnu_size_type, gnu_align);\n+\n \t  /* The first arg is always the address of the storage pool; next\n \t     comes the address of the object, for a deallocator, then the\n \t     size and alignment.  */\n-\t  gnu_args\n-\t    = chainon (gnu_args, build_tree_list (NULL_TREE, gnu_pool_addr));\n-\n \t  if (gnu_obj)\n-\t    gnu_args\n-\t      = chainon (gnu_args, build_tree_list (NULL_TREE, gnu_obj));\n-\n-\t  gnu_args\n-\t    = chainon (gnu_args,\n-\t\t       build_tree_list (NULL_TREE,\n-\t\t\t\t\tconvert (gnu_size_type, gnu_size)));\n-\t  gnu_args\n-\t    = chainon (gnu_args,\n-\t\t       build_tree_list (NULL_TREE,\n-\t\t\t\t\tconvert (gnu_size_type, gnu_align)));\n-\n-\t  gnu_call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t     gnu_proc_addr, gnu_args, NULL_TREE);\n+\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t\tgnu_proc_addr, 4, gnu_pool_addr,\n+\t\t\t\t\tgnu_obj, gnu_size, gnu_align);\n+\t  else\n+\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t\tgnu_proc_addr, 3, gnu_pool_addr,\n+\t\t\t\t\tgnu_size, gnu_align);\n \t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n \t  return gnu_call;\n \t}\n@@ -1758,22 +1740,18 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \t  tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n \t  tree gnu_proc = gnat_to_gnu (gnat_proc);\n \t  tree gnu_proc_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_proc);\n-\t  tree gnu_args = NULL_TREE;\n \t  tree gnu_call;\n \n+\t  gnu_size = convert (gnu_size_type, gnu_size);\n+\n \t  /* The first arg is the address of the object, for a\n \t     deallocator, then the size */\n \t  if (gnu_obj)\n-\t    gnu_args\n-\t      = chainon (gnu_args, build_tree_list (NULL_TREE, gnu_obj));\n-\n-\t  gnu_args\n-\t    = chainon (gnu_args,\n-\t\t       build_tree_list (NULL_TREE,\n-\t\t\t\t\tconvert (gnu_size_type, gnu_size)));\n-\n-\t  gnu_call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t     gnu_proc_addr, gnu_args, NULL_TREE);\n+\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t\tgnu_proc_addr, 2, gnu_obj, gnu_size);\n+\t  else\n+\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t\tgnu_proc_addr, 1, gnu_size);\n \t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n \t  return gnu_call;\n \t}"}]}