{"sha": "6f21ed26f63b49c96d8bedc34cda55614cac5893", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYyMWVkMjZmNjNiNDljOTZkOGJlZGMzNGNkYTU1NjE0Y2FjNTg5Mw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@gnat.com", "date": "2004-10-04T15:00:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-04T15:00:06Z"}, "message": "sem_ch5.adb (Unblocked_Exit_Count): Now used for blocks as well as IF and CASE.\n\n2004-10-04  Robert Dewar  <dewar@gnat.com>\n\n\t* sem_ch5.adb (Unblocked_Exit_Count): Now used for blocks as well as\n\tIF and CASE.\n\t(Analyze_Block_Statement): Add circuitry to detect following dead code\n\t(Check_Unreachable_Code): Handle case of block exit\n\nFrom-SVN: r88503", "tree": {"sha": "a77f41035375f7ab29c452898be34c08b4cdad1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a77f41035375f7ab29c452898be34c08b4cdad1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f21ed26f63b49c96d8bedc34cda55614cac5893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f21ed26f63b49c96d8bedc34cda55614cac5893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f21ed26f63b49c96d8bedc34cda55614cac5893", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f21ed26f63b49c96d8bedc34cda55614cac5893/comments", "author": null, "committer": null, "parents": [{"sha": "4cded177ca59ebcb3eae73f708e4cd71c7e27615", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cded177ca59ebcb3eae73f708e4cd71c7e27615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cded177ca59ebcb3eae73f708e4cd71c7e27615"}], "stats": {"total": 196, "additions": 134, "deletions": 62}, "files": [{"sha": "32e47e1f14ba40450eb84a615da49e0ee255e477", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f21ed26f63b49c96d8bedc34cda55614cac5893/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f21ed26f63b49c96d8bedc34cda55614cac5893/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6f21ed26f63b49c96d8bedc34cda55614cac5893", "patch": "@@ -1,3 +1,10 @@\n+2004-10-04  Robert Dewar  <dewar@gnat.com>\n+\n+\t* sem_ch5.adb (Unblocked_Exit_Count): Now used for blocks as well as\n+\tIF and CASE.\n+\t(Analyze_Block_Statement): Add circuitry to detect following dead code\n+\t(Check_Unreachable_Code): Handle case of block exit\n+\n 2004-10-04  Robert Dewar  <dewar@gnat.com>\n \n \t* g-spipat.adb: (XMatch): Avoid warning for Logic_Error call"}, {"sha": "1aff311a343ead2553fafbbc6d37a674372fec7f", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 127, "deletions": 62, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f21ed26f63b49c96d8bedc34cda55614cac5893/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f21ed26f63b49c96d8bedc34cda55614cac5893/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=6f21ed26f63b49c96d8bedc34cda55614cac5893", "patch": "@@ -54,13 +54,16 @@ with Uintp;    use Uintp;\n package body Sem_Ch5 is\n \n    Unblocked_Exit_Count : Nat := 0;\n-   --  This variable is used when processing if statements or case\n-   --  statements, it counts the number of branches of the conditional\n-   --  that are not blocked by unconditional transfer instructions. At\n-   --  the end of processing, if the count is zero, it means that control\n-   --  cannot fall through the conditional statement. This is used for\n-   --  the generation of warning messages. This variable is recursively\n-   --  saved on entry to processing an if or case, and restored on exit.\n+   --  This variable is used when processing if statements, case statements,\n+   --  and block statements. It counts the number of exit points that are\n+   --  not blocked by unconditional transfer instructions (for IF and CASE,\n+   --  these are the branches of the conditional, for a block, they are the\n+   --  statement sequence of the block, and the statement sequences of any\n+   --  exception handlers that are part of the block. When processing is\n+   --  complete, if this count is zero, it means that control cannot fall\n+   --  through the IF, CASE or block statement. This is used for the\n+   --  generation of warning messages. This variable is recursively saved\n+   --  on entry to processing the construct, and restored on exit.\n \n    -----------------------\n    -- Local Subprograms --\n@@ -514,82 +517,111 @@ package body Sem_Ch5 is\n    procedure Analyze_Block_Statement (N : Node_Id) is\n       Decls : constant List_Id := Declarations (N);\n       Id    : constant Node_Id := Identifier (N);\n-      Ent   : Entity_Id        := Empty;\n+      HSS   : constant Node_Id := Handled_Statement_Sequence (N);\n \n    begin\n-      --  If a label is present analyze it and mark it as referenced\n+      --  If no handled statement sequence is present, things are really\n+      --  messed up, and we just return immediately (this is a defence\n+      --  against previous errors).\n \n-      if Present (Id) then\n-         Analyze (Id);\n-         Ent := Entity (Id);\n+      if No (HSS) then\n+         return;\n+      end if;\n \n-         --  An error defense. If we have an identifier, but no entity, then\n-         --  something is wrong. If we have previous errors, then just remove\n-         --  the identifier and continue, otherwise raise an exception.\n+      --  Normal processing with HSS present\n \n-         if No (Ent) then\n-            if Total_Errors_Detected /= 0 then\n-               Set_Identifier (N, Empty);\n-            else\n-               raise Program_Error;\n-            end if;\n+      declare\n+         EH  : constant List_Id := Exception_Handlers (HSS);\n+         Ent : Entity_Id        := Empty;\n+         S   : Entity_Id;\n \n-         else\n-            Set_Ekind (Ent, E_Block);\n-            Generate_Reference (Ent, N, ' ');\n-            Generate_Definition (Ent);\n+         Save_Unblocked_Exit_Count : constant Nat := Unblocked_Exit_Count;\n+         --  Recursively save value of this global, will be restored on exit\n \n-            if Nkind (Parent (Ent)) = N_Implicit_Label_Declaration then\n-               Set_Label_Construct (Parent (Ent), N);\n-            end if;\n+      begin\n+         --  Initialize unblocked exit count for statements of begin block\n+         --  plus one for each excption handler that is present.\n+\n+         Unblocked_Exit_Count := 1;\n+\n+         if Present (EH) then\n+            Unblocked_Exit_Count := Unblocked_Exit_Count + List_Length (EH);\n          end if;\n-      end if;\n \n-      --  If no entity set, create a label entity\n+         --  If a label is present analyze it and mark it as referenced\n \n-      if No (Ent) then\n-         Ent := New_Internal_Entity (E_Block, Current_Scope, Sloc (N), 'B');\n-         Set_Identifier (N, New_Occurrence_Of (Ent, Sloc (N)));\n-         Set_Parent (Ent, N);\n-      end if;\n+         if Present (Id) then\n+            Analyze (Id);\n+            Ent := Entity (Id);\n \n-      Set_Etype (Ent, Standard_Void_Type);\n-      Set_Block_Node (Ent, Identifier (N));\n-      New_Scope (Ent);\n+            --  An error defense. If we have an identifier, but no entity,\n+            --  then something is wrong. If we have previous errors, then\n+            --  just remove the identifier and continue, otherwise raise\n+            --  an exception.\n \n-      if Present (Decls) then\n-         Analyze_Declarations (Decls);\n-         Check_Completion;\n-      end if;\n+            if No (Ent) then\n+               if Total_Errors_Detected /= 0 then\n+                  Set_Identifier (N, Empty);\n+               else\n+                  raise Program_Error;\n+               end if;\n \n-      Analyze (Handled_Statement_Sequence (N));\n-      Process_End_Label (Handled_Statement_Sequence (N), 'e', Ent);\n+            else\n+               Set_Ekind (Ent, E_Block);\n+               Generate_Reference (Ent, N, ' ');\n+               Generate_Definition (Ent);\n \n-      --  Analyze exception handlers if present. Note that the test for\n-      --  HSS being present is an error defence against previous errors.\n+               if Nkind (Parent (Ent)) = N_Implicit_Label_Declaration then\n+                  Set_Label_Construct (Parent (Ent), N);\n+               end if;\n+            end if;\n+         end if;\n \n-      if Present (Handled_Statement_Sequence (N))\n-        and then Present (Exception_Handlers (Handled_Statement_Sequence (N)))\n-      then\n-         declare\n-            S : Entity_Id := Scope (Ent);\n+         --  If no entity set, create a label entity\n \n-         begin\n-            --  Indicate that enclosing scopes contain a block with handlers.\n-            --  Only non-generic scopes need to be marked.\n+         if No (Ent) then\n+            Ent := New_Internal_Entity (E_Block, Current_Scope, Sloc (N), 'B');\n+            Set_Identifier (N, New_Occurrence_Of (Ent, Sloc (N)));\n+            Set_Parent (Ent, N);\n+         end if;\n+\n+         Set_Etype (Ent, Standard_Void_Type);\n+         Set_Block_Node (Ent, Identifier (N));\n+         New_Scope (Ent);\n+\n+         if Present (Decls) then\n+            Analyze_Declarations (Decls);\n+            Check_Completion;\n+         end if;\n \n+         Analyze (HSS);\n+         Process_End_Label (HSS, 'e', Ent);\n+\n+         --  If exception handlers are present, then we indicate that\n+         --  enclosing scopes contain a block with handlers. We only\n+         --  need to mark non-generic scopes.\n+\n+         if Present (EH) then\n+            S := Scope (Ent);\n             loop\n                Set_Has_Nested_Block_With_Handler (S);\n                exit when Is_Overloadable (S)\n                  or else Ekind (S) = E_Package\n                  or else Is_Generic_Unit (S);\n                S := Scope (S);\n             end loop;\n-         end;\n-      end if;\n+         end if;\n \n-      Check_References (Ent);\n-      End_Scope;\n+         Check_References (Ent);\n+         End_Scope;\n+\n+         if Unblocked_Exit_Count = 0 then\n+            Unblocked_Exit_Count := Save_Unblocked_Exit_Count;\n+            Check_Unreachable_Code (N);\n+         else\n+            Unblocked_Exit_Count := Save_Unblocked_Exit_Count;\n+         end if;\n+      end;\n    end Analyze_Block_Statement;\n \n    ----------------------------\n@@ -1557,7 +1589,15 @@ package body Sem_Ch5 is\n          begin\n             Nxt := Original_Node (Next (N));\n \n-            if Present (Nxt)\n+            --  If a label follows us, then we never have dead code, since\n+            --  someone could branch to the label, so we just ignore it.\n+\n+            if Nkind (Nxt) = N_Label then\n+               return;\n+\n+            --  Otherwise see if we have a real statement following us\n+\n+            elsif Present (Nxt)\n               and then Comes_From_Source (Nxt)\n               and then Is_Statement (Nxt)\n             then\n@@ -1613,28 +1653,53 @@ package body Sem_Ch5 is\n \n             --  If the unconditional transfer of control instruction is\n             --  the last statement of a sequence, then see if our parent\n-            --  is an IF statement, and if so adjust the unblocked exit\n-            --  count of the if statement to reflect the fact that this\n-            --  branch of the if is indeed blocked by a transfer of control.\n+            --  is one of the constructs for which we count unblocked exits,\n+            --  and if so, adjust the count.\n \n             else\n                P := Parent (N);\n \n+               --  Statements in THEN part or ELSE part of IF statement\n+\n                if Nkind (P) = N_If_Statement then\n                   null;\n \n+               --  Statements in ELSIF part of an IF statement\n+\n                elsif Nkind (P) = N_Elsif_Part then\n                   P := Parent (P);\n                   pragma Assert (Nkind (P) = N_If_Statement);\n \n+               --  Statements in CASE statement alternative\n+\n                elsif Nkind (P) = N_Case_Statement_Alternative then\n                   P := Parent (P);\n                   pragma Assert (Nkind (P) = N_Case_Statement);\n \n+               --  Statements in body of block\n+\n+               elsif Nkind (P) = N_Handled_Sequence_Of_Statements\n+                 and then Nkind (Parent (P)) = N_Block_Statement\n+               then\n+                  null;\n+\n+               --  Statements in exception handler in a block\n+\n+               elsif Nkind (P) = N_Exception_Handler\n+                 and then Nkind (Parent (P)) = N_Handled_Sequence_Of_Statements\n+                 and then Nkind (Parent (Parent (P))) = N_Block_Statement\n+               then\n+                  null;\n+\n+               --  None of these cases, so return\n+\n                else\n                   return;\n                end if;\n \n+               --  This was one of the cases we are looking for (i.e. the\n+               --  parent construct was IF, CASE or block) so decrement count.\n+\n                Unblocked_Exit_Count := Unblocked_Exit_Count - 1;\n             end if;\n          end;"}]}