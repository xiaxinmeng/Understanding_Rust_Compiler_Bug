{"sha": "06c2756e824cfe409d280fc78a0c4f68a9123e49", "node_id": "C_kwDOANBUbNoAKDA2YzI3NTZlODI0Y2ZlNDA5ZDI4MGZjNzhhMGM0ZjY4YTkxMjNlNDk", "commit": {"author": {"name": "Takayuki 'January June' Suwa", "email": "jjsuwa_sys3175@yahoo.co.jp", "date": "2022-09-08T21:16:31Z"}, "committer": {"name": "Max Filippov", "email": "jcmvbkbc@gmail.com", "date": "2022-09-09T22:19:50Z"}, "message": "xtensa: Eliminate unused stack frame allocation/freeing\n\nIn the example below, 'x' is once placed on the stack frame and then read\ninto registers as the argument value of bar():\n\n    /* example */\n    struct foo {\n      int a, b;\n    };\n    extern struct foo bar(struct foo);\n    struct foo test(void) {\n      struct foo x = { 0, 1 };\n      return bar(x);\n    }\n\nThanks to the dead store elimination, the initialization of 'x' turns into\nmerely loading the immediates to registers, but corresponding stack frame\ngrowth is not rolled back.  As a result:\n\n    ;; prereq: the CALL0 ABI\n    ;; before\n    test:\n\taddi\tsp, sp, -16\t// unused stack frame allocation/freeing\n\tmovi.n\ta2, 0\n\tmovi.n\ta3, 1\n\taddi\tsp, sp, 16\t// because no instructions that refer to\n\tj.l\tbar, a9\t\t// the stack pointer between the two\n\nThis patch eliminates such unused stack frame allocation/freeing:\n\n    ;; after\n    test:\n\tmovi.n\ta2, 0\n\tmovi.n\ta3, 1\n\tj.l\tbar, a9\n\ngcc/ChangeLog:\n\n\t* config/xtensa/xtensa.cc (machine_function): New boolean member as\n\ta flag that controls whether to emit the insns for stack pointer\n\tadjustment inside of the pro/epilogue.\n\t(xtensa_emit_adjust_stack_ptr): New function to share the common\n\tcodes and to emit insns if not inhibited.\n\t(xtensa_expand_epilogue): Change to use the function mentioned\n\tabove when using the CALL0 ABI.\n\t(xtensa_expand_prologue): Ditto.\n\tAnd also change to set the inhibit flag used by\n\txtensa_emit_adjust_stack_ptr() to true if the stack pointer is only\n\tused for its own adjustment.", "tree": {"sha": "0ea450458e0da5cb3da09c4429bd1e2e9b20e314", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ea450458e0da5cb3da09c4429bd1e2e9b20e314"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06c2756e824cfe409d280fc78a0c4f68a9123e49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c2756e824cfe409d280fc78a0c4f68a9123e49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c2756e824cfe409d280fc78a0c4f68a9123e49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c2756e824cfe409d280fc78a0c4f68a9123e49/comments", "author": {"login": "jjsuwa-sys3175", "id": 73290592, "node_id": "MDQ6VXNlcjczMjkwNTky", "avatar_url": "https://avatars.githubusercontent.com/u/73290592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jjsuwa-sys3175", "html_url": "https://github.com/jjsuwa-sys3175", "followers_url": "https://api.github.com/users/jjsuwa-sys3175/followers", "following_url": "https://api.github.com/users/jjsuwa-sys3175/following{/other_user}", "gists_url": "https://api.github.com/users/jjsuwa-sys3175/gists{/gist_id}", "starred_url": "https://api.github.com/users/jjsuwa-sys3175/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jjsuwa-sys3175/subscriptions", "organizations_url": "https://api.github.com/users/jjsuwa-sys3175/orgs", "repos_url": "https://api.github.com/users/jjsuwa-sys3175/repos", "events_url": "https://api.github.com/users/jjsuwa-sys3175/events{/privacy}", "received_events_url": "https://api.github.com/users/jjsuwa-sys3175/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jcmvbkbc", "id": 166731, "node_id": "MDQ6VXNlcjE2NjczMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/166731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcmvbkbc", "html_url": "https://github.com/jcmvbkbc", "followers_url": "https://api.github.com/users/jcmvbkbc/followers", "following_url": "https://api.github.com/users/jcmvbkbc/following{/other_user}", "gists_url": "https://api.github.com/users/jcmvbkbc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcmvbkbc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcmvbkbc/subscriptions", "organizations_url": "https://api.github.com/users/jcmvbkbc/orgs", "repos_url": "https://api.github.com/users/jcmvbkbc/repos", "events_url": "https://api.github.com/users/jcmvbkbc/events{/privacy}", "received_events_url": "https://api.github.com/users/jcmvbkbc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c81b60b8c6ff3d4db2e395a628e114df812cfc48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c81b60b8c6ff3d4db2e395a628e114df812cfc48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c81b60b8c6ff3d4db2e395a628e114df812cfc48"}], "stats": {"total": 164, "additions": 80, "deletions": 84}, "files": [{"sha": "0f586b09dfb1388964b428ca0c7c197b1fdcc955", "filename": "gcc/config/xtensa/xtensa.cc", "status": "modified", "additions": 80, "deletions": 84, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06c2756e824cfe409d280fc78a0c4f68a9123e49/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06c2756e824cfe409d280fc78a0c4f68a9123e49/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc?ref=06c2756e824cfe409d280fc78a0c4f68a9123e49", "patch": "@@ -102,6 +102,7 @@ struct GTY(()) machine_function\n   int callee_save_size;\n   bool frame_laid_out;\n   bool epilogue_done;\n+  bool inhibit_logues_a1_adjusts;\n };\n \n /* Vector, indexed by hard register number, which contains 1 for a\n@@ -3048,7 +3049,7 @@ xtensa_output_literal (FILE *file, rtx x, machine_mode mode, int labelno)\n }\n \n static bool\n-xtensa_call_save_reg(int regno)\n+xtensa_call_save_reg (int regno)\n {\n   if (TARGET_WINDOWED_ABI)\n     return false;\n@@ -3084,7 +3085,7 @@ compute_frame_size (poly_int64 size)\n   cfun->machine->callee_save_size = 0;\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n     {\n-      if (xtensa_call_save_reg(regno))\n+      if (xtensa_call_save_reg (regno))\n \tcfun->machine->callee_save_size += UNITS_PER_WORD;\n     }\n \n@@ -3139,6 +3140,49 @@ xtensa_initial_elimination_offset (int from, int to ATTRIBUTE_UNUSED)\n   return offset;\n }\n \n+#define ADJUST_SP_NONE      0x0\n+#define ADJUST_SP_NEED_NOTE 0x1\n+#define ADJUST_SP_FRAME_PTR 0x2\n+static void\n+xtensa_emit_adjust_stack_ptr (HOST_WIDE_INT offset, int flags)\n+{\n+  rtx_insn *insn;\n+  rtx ptr = (flags & ADJUST_SP_FRAME_PTR) ? hard_frame_pointer_rtx\n+\t\t\t\t\t  : stack_pointer_rtx;\n+\n+  if (cfun->machine->inhibit_logues_a1_adjusts)\n+    return;\n+\n+  if (xtensa_simm8 (offset)\n+      || xtensa_simm8x256 (offset))\n+    insn = emit_insn (gen_addsi3 (stack_pointer_rtx, ptr, GEN_INT (offset)));\n+  else\n+    {\n+      rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);\n+\n+      if (offset < 0)\n+\t{\n+\t  emit_move_insn (tmp_reg, GEN_INT (-offset));\n+\t  insn = emit_insn (gen_subsi3 (stack_pointer_rtx, ptr, tmp_reg));\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (tmp_reg, GEN_INT (offset));\n+\t  insn = emit_insn (gen_addsi3 (stack_pointer_rtx, ptr,\ttmp_reg));\n+\t}\n+    }\n+\n+  if (flags & ADJUST_SP_NEED_NOTE)\n+    {\n+      rtx note_rtx = gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t offset));\n+\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+    }\n+}\n+\n /* minimum frame = reg save area (4 words) plus static chain (1 word)\n    and the total number of words must be a multiple of 128 bits.  */\n #define MIN_FRAME_SIZE (8 * UNITS_PER_WORD)\n@@ -3174,17 +3218,30 @@ xtensa_expand_prologue (void)\n       int regno;\n       HOST_WIDE_INT offset = 0;\n       int callee_save_size = cfun->machine->callee_save_size;\n+      df_ref ref;\n+      bool stack_pointer_needed = frame_pointer_needed\n+\t\t\t\t  || crtl->calls_eh_return;\n+\n+      /* Check if the function body really needs the stack pointer.  */\n+      if (!stack_pointer_needed)\n+\tfor (ref = DF_REG_USE_CHAIN (A1_REG);\n+\t     ref; ref = DF_REF_NEXT_REG (ref))\n+\t  if (DF_REF_CLASS (ref) == DF_REF_REGULAR\n+\t      && NONJUMP_INSN_P (DF_REF_INSN (ref)))\n+\t    stack_pointer_needed = true;\n+      /* Check if callee-saved registers really need saving to the stack.  */\n+      if (!stack_pointer_needed)\n+\tfor (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+\t  if (xtensa_call_save_reg (regno))\n+\t    stack_pointer_needed = true;\n+\n+      cfun->machine->inhibit_logues_a1_adjusts = !stack_pointer_needed;\n \n       /* -128 is a limit of single addi instruction. */\n       if (IN_RANGE (total_size, 1, 128))\n \t{\n-\t  insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t\tGEN_INT (-total_size)));\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  note_rtx = gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t -total_size));\n-\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+\t  xtensa_emit_adjust_stack_ptr (-total_size,\n+\t\t\t\t\tADJUST_SP_NEED_NOTE);\n \t  offset = total_size - UNITS_PER_WORD;\n \t}\n       else if (callee_save_size)\n@@ -3194,33 +3251,14 @@ xtensa_expand_prologue (void)\n \t   * move it to its final location. */\n \t  if (total_size > 1024)\n \t    {\n-\t      insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t\t    GEN_INT (-callee_save_size)));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      note_rtx = gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t     -callee_save_size));\n-\t      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+\t      xtensa_emit_adjust_stack_ptr (-callee_save_size,\n+\t\t\t\t\t    ADJUST_SP_NEED_NOTE);\n \t      offset = callee_save_size - UNITS_PER_WORD;\n \t    }\n \t  else\n \t    {\n-\t      if (xtensa_simm8x256 (-total_size))\n-\t\tinsn = emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t\t      GEN_INT (-total_size)));\n-\t      else\n-\t\t{\n-\t\t  rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);\n-\t\t  emit_move_insn (tmp_reg, GEN_INT (total_size));\n-\t\t  insn = emit_insn (gen_subsi3 (stack_pointer_rtx,\n-\t\t\t\t\t\tstack_pointer_rtx, tmp_reg));\n-\t\t}\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      note_rtx = gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t     -total_size));\n-\t      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+\t      xtensa_emit_adjust_stack_ptr (-total_size,\n+\t\t\t\t\t    ADJUST_SP_NEED_NOTE);\n \t      offset = total_size - UNITS_PER_WORD;\n \t    }\n \t}\n@@ -3242,27 +3280,8 @@ xtensa_expand_prologue (void)\n \t}\n       if (total_size > 1024\n \t  || (!callee_save_size && total_size > 128))\n-\t{\n-\t  if (xtensa_simm8x256 (callee_save_size - total_size))\n-\t    insn = emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t  GEN_INT (callee_save_size -\n-\t\t\t\t\t\t   total_size)));\n-\t  else\n-\t    {\n-\t      rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);\n-\t      emit_move_insn (tmp_reg, GEN_INT (total_size -\n-\t\t\t\t\t\tcallee_save_size));\n-\t      insn = emit_insn (gen_subsi3 (stack_pointer_rtx,\n-\t\t\t\t\t    stack_pointer_rtx, tmp_reg));\n-\t    }\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  note_rtx = gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t callee_save_size -\n-\t\t\t\t\t\t total_size));\n-\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n-\t}\n+\txtensa_emit_adjust_stack_ptr (callee_save_size - total_size,\n+\t\t\t\t      ADJUST_SP_NEED_NOTE);\n     }\n \n   if (frame_pointer_needed)\n@@ -3329,21 +3348,11 @@ xtensa_expand_epilogue (bool sibcall_p)\n \n       if (cfun->machine->current_frame_size > (frame_pointer_needed ? 127 : 1024))\n \t{\n-\t  if (xtensa_simm8x256 (cfun->machine->current_frame_size -\n-\t\t\t\tcfun->machine->callee_save_size))\n-\t    emit_insn (gen_addsi3 (stack_pointer_rtx, frame_pointer_needed ?\n-\t\t\t\t   hard_frame_pointer_rtx : stack_pointer_rtx,\n-\t\t\t\t   GEN_INT (cfun->machine->current_frame_size -\n-\t\t\t\t\t    cfun->machine->callee_save_size)));\n-\t  else\n-\t    {\n-\t      rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);\n-\t      emit_move_insn (tmp_reg, GEN_INT (cfun->machine->current_frame_size -\n-\t\t\t\t\t\tcfun->machine->callee_save_size));\n-\t      emit_insn (gen_addsi3 (stack_pointer_rtx, frame_pointer_needed ?\n-\t\t\t\t     hard_frame_pointer_rtx : stack_pointer_rtx,\n-\t\t\t\t     tmp_reg));\n-\t    }\n+\t  xtensa_emit_adjust_stack_ptr (cfun->machine->current_frame_size -\n+\t\t\t\t\tcfun->machine->callee_save_size,\n+\t\t\t\t\tframe_pointer_needed\n+\t\t\t\t\t? ADJUST_SP_FRAME_PTR\n+\t\t\t\t\t: ADJUST_SP_NONE);\n \t  offset = cfun->machine->callee_save_size - UNITS_PER_WORD;\n \t}\n       else\n@@ -3384,24 +3393,11 @@ xtensa_expand_epilogue (bool sibcall_p)\n \t      else\n \t\toffset = cfun->machine->callee_save_size;\n \t      if (offset)\n-\t\temit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       GEN_INT (offset)));\n+\t\txtensa_emit_adjust_stack_ptr (offset, ADJUST_SP_NONE);\n \t    }\n \t  else\n-\t    {\n-\t      if (xtensa_simm8x256 (cfun->machine->current_frame_size))\n-\t\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t       GEN_INT (cfun->machine->current_frame_size)));\n-\t      else\n-\t\t{\n-\t\t  rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);\n-\t\t  emit_move_insn (tmp_reg,\n-\t\t\t\t  GEN_INT (cfun->machine->current_frame_size));\n-\t\t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t\t tmp_reg));\n-\t\t}\n-\t    }\n+\t    xtensa_emit_adjust_stack_ptr (cfun->machine->current_frame_size,\n+\t\t\t\t\t  ADJUST_SP_NONE);\n \t}\n \n       if (crtl->calls_eh_return)"}]}