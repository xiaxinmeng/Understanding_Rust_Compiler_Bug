{"sha": "d4920f402af2591fa9864863f8c4ddcad1f9ebc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ5MjBmNDAyYWYyNTkxZmE5ODY0ODYzZjhjNGRkY2FkMWY5ZWJjMQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-11-09T10:16:09Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-11-09T10:16:09Z"}, "message": "[PR86438] compare-elim: cope with set of in_b\n\nWhen in_a resolves to a register set in the prev_clobber insn, we may\nuse the SET_SRC for the compare instead.  However, when in_b so\nresolves, we proceed to use the reg with its earlier value.  When both\nresolve to the same register and prev_clobber is an insn that modifies\nthe register, this arrangement may cause the compare to match (when it\nshouldn't) and the elimination of the compare to incorrectly succeed.\n\n(set (reg 1) (plus (reg 1) (const_int N)))\n(set (reg 2) (reg 1))\n(set (reg flags) (compare (reg 1) (reg 2)))\n\nin_a: (reg 1)            --> (plus (reg 1) (const_int N))\nin_b: (reg 2) -> (reg 1) -/> oops\n\n(parallel [\n (set (reg flags) (compare (plus (reg 1) (const_int N))\n                           (reg 1))) ;; should be (plus...)\n (set (reg 1) (plus (reg 1) (const_int N)))])\n(set (reg 2) (reg 1))\n\nThis patch arranges for in_b to also undergo SET_SRC substitution\nwhen appropriate, with a shortcut for when in_a and in_b are the same\nrtx.\n\n\nfor  gcc/ChangeLog\n\n\tPR rtl-optimization/86438\n\t* compare-elim.c (try_eliminate_compare): Use SET_SRC instead\n\tof in_b for the compare if in_b is SET_DEST.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR rtl-optimization/86438\n\t* gcc.dg/torture/pr86438.c: New.\n\nFrom-SVN: r265957", "tree": {"sha": "fca3caf0766d3151c362068508b4da0f0763b702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fca3caf0766d3151c362068508b4da0f0763b702"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4920f402af2591fa9864863f8c4ddcad1f9ebc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4920f402af2591fa9864863f8c4ddcad1f9ebc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4920f402af2591fa9864863f8c4ddcad1f9ebc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4920f402af2591fa9864863f8c4ddcad1f9ebc1/comments", "author": null, "committer": null, "parents": [{"sha": "b759ea284782b95cf0196c8e813e3ab7e1233c47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b759ea284782b95cf0196c8e813e3ab7e1233c47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b759ea284782b95cf0196c8e813e3ab7e1233c47"}], "stats": {"total": 61, "additions": 53, "deletions": 8}, "files": [{"sha": "46ab4e955b9d1c84762bbbcbbc086ceeef535b06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4920f402af2591fa9864863f8c4ddcad1f9ebc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4920f402af2591fa9864863f8c4ddcad1f9ebc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4920f402af2591fa9864863f8c4ddcad1f9ebc1", "patch": "@@ -1,5 +1,9 @@\n 2018-11-09  Alexandre Oliva <aoliva@redhat.com>\n \n+\tPR rtl-optimization/86438\n+\t* compare-elim.c (try_eliminate_compare): Use SET_SRC instead\n+\tof in_b for the compare if in_b is SET_DEST.\n+\n \tPR target/87793\n \t* config/i386/i386.c (ix86_const_not_ok_for_debug_p): Reject\n \tnon-toplevel UNSPEC."}, {"sha": "8afbe76c502bdd0f3cd87c7191425f6229e6ba50", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4920f402af2591fa9864863f8c4ddcad1f9ebc1/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4920f402af2591fa9864863f8c4ddcad1f9ebc1/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=d4920f402af2591fa9864863f8c4ddcad1f9ebc1", "patch": "@@ -734,7 +734,7 @@ try_merge_compare (struct comparison *cmp)\n static bool\n try_eliminate_compare (struct comparison *cmp)\n {\n-  rtx flags, in_a, in_b, cmp_src;\n+  rtx flags, in_a, in_b, cmp_a, cmp_b;\n \n   if (try_merge_compare (cmp))\n     return true;\n@@ -786,7 +786,7 @@ try_eliminate_compare (struct comparison *cmp)\n \n   rtx x = XVECEXP (PATTERN (insn), 0, 0);\n   if (rtx_equal_p (SET_DEST (x), in_a))\n-    cmp_src = SET_SRC (x);\n+    cmp_a = SET_SRC (x);\n \n   /* Also check operations with implicit extensions, e.g.:\n      [(set (reg:DI)\n@@ -800,7 +800,7 @@ try_eliminate_compare (struct comparison *cmp)\n \t   && (GET_CODE (SET_SRC (x)) == ZERO_EXTEND\n \t       || GET_CODE (SET_SRC (x)) == SIGN_EXTEND)\n \t   && GET_MODE (XEXP (SET_SRC (x), 0)) == GET_MODE (in_a))\n-    cmp_src = XEXP (SET_SRC (x), 0);\n+    cmp_a = XEXP (SET_SRC (x), 0);\n \n   /* Also check fully redundant comparisons, e.g.:\n      [(set (reg:SI)\n@@ -811,25 +811,34 @@ try_eliminate_compare (struct comparison *cmp)\n \t   && GET_CODE (SET_SRC (x)) == MINUS\n \t   && rtx_equal_p (XEXP (SET_SRC (x), 0), in_a)\n \t   && rtx_equal_p (XEXP (SET_SRC (x), 1), in_b))\n-    cmp_src = in_a;\n+    cmp_a = in_a;\n \n   else\n     return false;\n \n   /* If the source uses addressing modes with side effects, we can't\n      do the merge because we'd end up with a PARALLEL that has two\n      instances of that side effect in it.  */\n-  if (side_effects_p (cmp_src))\n+  if (side_effects_p (cmp_a))\n+    return false;\n+\n+  if (in_a == in_b)\n+    cmp_b = cmp_a;\n+  else if (rtx_equal_p (SET_DEST (x), in_b))\n+    cmp_b = SET_SRC (x);\n+  else\n+    cmp_b = in_b;\n+  if (side_effects_p (cmp_b))\n     return false;\n \n   /* Determine if we ought to use a different CC_MODE here.  */\n-  flags = maybe_select_cc_mode (cmp, cmp_src, in_b);\n+  flags = maybe_select_cc_mode (cmp, cmp_a, cmp_b);\n   if (flags == NULL)\n     flags = gen_rtx_REG (cmp->orig_mode, targetm.flags_regnum);\n \n   /* Generate a new comparison for installation in the setter.  */\n-  rtx y = copy_rtx (cmp_src);\n-  y = gen_rtx_COMPARE (GET_MODE (flags), y, in_b);\n+  rtx y = copy_rtx (cmp_a);\n+  y = gen_rtx_COMPARE (GET_MODE (flags), y, copy_rtx (cmp_b));\n   y = gen_rtx_SET (flags, y);\n \n   /* Canonicalize instruction to:"}, {"sha": "6434be07cfa7a4135d5cc616fbdc9630d9303ae6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4920f402af2591fa9864863f8c4ddcad1f9ebc1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4920f402af2591fa9864863f8c4ddcad1f9ebc1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d4920f402af2591fa9864863f8c4ddcad1f9ebc1", "patch": "@@ -1,5 +1,8 @@\n 2018-11-09  Alexandre Oliva <aoliva@redhat.com>\n \n+\tPR rtl-optimization/86438\n+\t* gcc.dg/torture/pr86438.c: New.\n+\n \tPR target/87793\n \t* gcc.dg/pr87793.c: New.\n "}, {"sha": "3e95515ae6a6b4df66cfb0b4ce9ddfb96a130d1f", "filename": "gcc/testsuite/gcc.dg/torture/pr86438.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4920f402af2591fa9864863f8c4ddcad1f9ebc1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr86438.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4920f402af2591fa9864863f8c4ddcad1f9ebc1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr86438.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr86438.c?ref=d4920f402af2591fa9864863f8c4ddcad1f9ebc1", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+\n+typedef unsigned int u32;\n+#if __SIZEOF_INT128__\n+typedef unsigned long long u64;\n+typedef unsigned __int128 u128;\n+#else\n+typedef unsigned long u64;\n+typedef unsigned long long u128;\n+#endif\n+\n+u128 g;\n+\n+static __attribute__ ((noinline, noclone))\n+void check (u64 a, u64 b)\n+{\n+  if (a != 0 || b != 4)\n+    __builtin_abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  u64 d = (g ? 5 : 4);\n+  u32 f = __builtin_sub_overflow_p (d, (u128) d, (u64) 0);\n+  u128 x = g + f + d;\n+  check (x >> (sizeof (u64) * __CHAR_BIT__), x);\n+  return 0;\n+}"}]}