{"sha": "824523999285e704ff2c549d8dbd8d20bb1c6ac0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI0NTIzOTk5Mjg1ZTcwNGZmMmM1NDlkOGRiZDhkMjBiYjFjNmFjMA==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@arm.com", "date": "2009-03-31T21:23:29Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2009-03-31T21:23:29Z"}, "message": "common.opt (frtl-abstract-sequences): Delete.\n\n2009-03-31  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n\t* common.opt (frtl-abstract-sequences): Delete.\n\t* doc/invoke.texi (Option Summary): Likewise.\n\t(Optimize Options): Likewise.\n\t* rtl-factoring.c: Delete file.\n\t* Makefile.in (OBJS-common): Remove rtl-factoring.o.\n\t* passes.c (init_optimization_passes): Remove rtl_abstr_seq pass.\n\n\n2009-03-31  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n\t* gcc.c-torture/compile/pr33009.c: Delete.\n\t* gcc.c-torture/compile/pr11832.c: Likewise.\n\nFrom-SVN: r145374", "tree": {"sha": "5ad82d1f0bc2b3f9ef01549ecef14b0054cb9fed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ad82d1f0bc2b3f9ef01549ecef14b0054cb9fed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/824523999285e704ff2c549d8dbd8d20bb1c6ac0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/824523999285e704ff2c549d8dbd8d20bb1c6ac0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/824523999285e704ff2c549d8dbd8d20bb1c6ac0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/824523999285e704ff2c549d8dbd8d20bb1c6ac0/comments", "author": null, "committer": null, "parents": [{"sha": "207bf79d7f23a3883694578f431c08960c348e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207bf79d7f23a3883694578f431c08960c348e38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/207bf79d7f23a3883694578f431c08960c348e38"}], "stats": {"total": 1575, "additions": 6, "deletions": 1569}, "files": [{"sha": "79780e930e242a928c7314b40371ee67853b4d6b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=824523999285e704ff2c549d8dbd8d20bb1c6ac0", "patch": "@@ -1169,7 +1169,6 @@ OBJS-common = \\\n \treorg.o \\\n \tresource.o \\\n \trtl-error.o \\\n-\trtl-factoring.o \\\n \trtl.o \\\n \trtlanal.o \\\n \trtlhooks.o \\\n@@ -2193,10 +2192,6 @@ tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_DUMP_H) $(EXCEPT_H) langhooks.h $(CFGLOOP_H) tree-pass.h \\\n    $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h $(HASHTAB_H) $(TOPLEV_H) \\\n    tree-ssa-propagate.h tree-scalar-evolution.h\n-rtl-factoring.o : rtl-factoring.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n-   coretypes.h $(TM_H) $(BASIC_BLOCK_H) $(RESOURCE_H) $(GGC_H) $(REGS_H) \\\n-   $(PARAMS_H) $(EXPR_H) addresses.h $(TM_P_H) tree-pass.h $(TREE_FLOW_H) \\\n-   $(TIMEVAR_H) output.h $(DF_H)\n tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(FUNCTION_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(EXCEPT_H) tree-pass.h $(FLAGS_H) langhooks.h \\"}, {"sha": "1cc0ac267a055a0995d18d5e13ca6967195036c9", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=824523999285e704ff2c549d8dbd8d20bb1c6ac0", "patch": "@@ -1037,10 +1037,6 @@ fsection-anchors\n Common Report Var(flag_section_anchors) Optimization\n Access data in the same section from shared anchor points\n \n-frtl-abstract-sequences\n-Common Report Var(flag_rtl_seqabstr) Optimization\n-Perform sequence abstraction optimization on RTL\n-\n fsee\n Common Report Var(flag_see) Init(0)\n Eliminate redundant sign extensions using LCM."}, {"sha": "131633db1b7c571753b5de5967141ea56311675e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=824523999285e704ff2c549d8dbd8d20bb1c6ac0", "patch": "@@ -356,7 +356,7 @@ Objective-C and Objective-C++ Dialects}.\n -freciprocal-math -fregmove -frename-registers -freorder-blocks @gol\n -freorder-blocks-and-partition -freorder-functions @gol\n -frerun-cse-after-loop -freschedule-modulo-scheduled-loops @gol\n--frounding-math -frtl-abstract-sequences -fsched2-use-superblocks @gol\n+-frounding-math -fsched2-use-superblocks @gol\n -fsched2-use-traces -fsched-spec-load -fsched-spec-load-dangerous @gol\n -fsched-stalled-insns-dep[=@var{n}] -fsched-stalled-insns[=@var{n}] @gol\n -fschedule-insns -fschedule-insns2 -fsection-anchors -fsee @gol\n@@ -6954,14 +6954,6 @@ Future versions of GCC may provide finer control of this setting\n using C99's @code{FENV_ACCESS} pragma.  This command line option\n will be used to specify the default state for @code{FENV_ACCESS}.\n \n-@item -frtl-abstract-sequences\n-@opindex frtl-abstract-sequences\n-It is a size optimization method. This option is to find identical\n-sequences of code, which can be turned into pseudo-procedures  and\n-then  replace  all  occurrences with  calls to  the  newly created\n-subroutine. It is kind of an opposite of @option{-finline-functions}.\n-This optimization runs at RTL level.\n-\n @item -fsignaling-nans\n @opindex fsignaling-nans\n Compile code assuming that IEEE signaling NaNs may generate user-visible"}, {"sha": "6ebceb34f1c2499004ed9052747eaa62bab73918", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=824523999285e704ff2c549d8dbd8d20bb1c6ac0", "patch": "@@ -787,7 +787,6 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_branch_target_load_optimize1);\n \t  NEXT_PASS (pass_thread_prologue_and_epilogue);\n \t  NEXT_PASS (pass_rtl_dse2);\n-\t  NEXT_PASS (pass_rtl_seqabstr);\n \t  NEXT_PASS (pass_stack_adjustments);\n \t  NEXT_PASS (pass_peephole2);\n \t  NEXT_PASS (pass_if_after_reload);"}, {"sha": "4c879691e9f32f2d89340e8ef16599e7034ade5a", "filename": "gcc/rtl-factoring.c", "status": "removed", "additions": 0, "deletions": 1474, "changes": 1474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf79d7f23a3883694578f431c08960c348e38/gcc%2Frtl-factoring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf79d7f23a3883694578f431c08960c348e38/gcc%2Frtl-factoring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-factoring.c?ref=207bf79d7f23a3883694578f431c08960c348e38", "patch": "@@ -1,1474 +0,0 @@\n-/* RTL factoring (sequence abstraction).\n-   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"obstack.h\"\n-#include \"basic-block.h\"\n-#include \"resource.h\"\n-#include \"flags.h\"\n-#include \"ggc.h\"\n-#include \"regs.h\"\n-#include \"params.h\"\n-#include \"expr.h\"\n-#include \"tm_p.h\"\n-#include \"tree-pass.h\"\n-#include \"tree-flow.h\"\n-#include \"timevar.h\"\n-#include \"output.h\"\n-#include \"df.h\"\n-#include \"addresses.h\"\n-\n-/* Sequence abstraction:\n-\n-   It is a size optimization method. The main idea of this technique is to\n-   find identical sequences of code, which can be turned into procedures and\n-   then replace all occurrences with calls to the newly created subroutine.\n-   It is kind of an opposite of function inlining.\n-\n-   There are four major parts of this file:\n-\n-   sequence fingerprint\n-     In order to avoid the comparison of every insn with every other, hash\n-     value will be designed for every insn by COMPUTE_HASH.\n-     These hash values are used for grouping the sequence candidates. So\n-     we only need to compare every insn with every other in same hash group.\n-\n-     FILL_HASH_BUCKET creates all hash values and stores into HASH_BUCKETS.\n-     The result is used by COLLECT_PATTERN_SEQS.\n-\n-   code matching\n-     In code matching the algorithm compares every two possible sequence\n-     candidates which last insns are in the same hash group. If these\n-     sequences are identical they will be stored and do further searches for\n-     finding more sequences which are identical with the first one.\n-\n-     COLLECT_PATTERN_SEQS does the code matching and stores the results into\n-     PATTERN_SEQS.\n-\n-   gain computation\n-     This part computes the gain of abstraction which could be archived when\n-     turning the pattern sequence into a pseudo-function and its matching\n-     sequences into pseudo-calls. After it the most effective sequences will\n-     be marked for abstraction.\n-\n-     RECOMPUTE_GAIN does the gain computation. The sequences with the maximum\n-     gain is on the top of PATTERN_SEQS.\n-\n-   abstract code\n-     This part turns the pattern sequence into a pseudo-function and its\n-     matching sequences into pseudo-calls.\n-\n-     ABSTRACT_BEST_SEQ does the code merging.\n-\n-\n-   C code example:\n-\n-   // Original source            // After sequence abstraction\n-   {                             {\n-                                   void *jump_label;\n-     ...                           ...\n-                                   jump_label = &&exit_0;\n-                                 entry_0:\n-     I0;                           I0;\n-     I1;                           I1;\n-     I2;                           I2;\n-     I3;                           I3;\n-                                   goto *jump_label;\n-                                 exit_0:\n-     ...                           ...\n-                                   jump_label = &&exit_1;\n-                                 goto entry_0;\n-     I0;\n-     I1;\n-     I2;\n-     I3;\n-                                 exit_1:\n-     ...                           ...\n-                                   jump_label = &&exit_2;\n-                                   goto entry_0;\n-     I0;\n-     I1;\n-     I2;\n-     I3;\n-                                 exit_2:\n-     ...                           ...\n-                                   jump_label = &&exit_3;\n-                                   goto entry_0;\n-     I0;\n-     I1;\n-     I2;\n-     I3;\n-                                exit_3:\n-     ...                           ...\n-   }                             }\n-\n-\n-   TODO:\n-   - Use REG_ALLOC_ORDER when choosing link register.\n-   - Handle JUMP_INSNs. Also handle volatile function calls (handle them\n-     similar to unconditional jumps.)\n-   - Test command line option -fpic.\n-*/\n-\n-/* Predicate yielding nonzero iff X is an abstractable insn.  Non-jump insns are\n-   abstractable.  */\n-#define ABSTRACTABLE_INSN_P(X) (INSN_P (X) && !JUMP_P (X))\n-\n-/* First parameter of the htab_create function call.  */\n-#define HASH_INIT 1023\n-\n-/* Multiplier for cost of sequence call to avoid abstracting short\n-   sequences.  */\n-#ifndef SEQ_CALL_COST_MULTIPLIER\n-#define SEQ_CALL_COST_MULTIPLIER 2\n-#endif\n-\n-/* Recomputes the cost of MSEQ pattern/matching sequence.  */\n-#define RECOMPUTE_COST(SEQ)                                 \\\n-{                                                           \\\n-  int l;                                                    \\\n-  rtx x = SEQ->insn;                                        \\\n-  SEQ->cost = 0;                                            \\\n-  for (l = 0; l < SEQ->abstracted_length; l++)              \\\n-    {                                                       \\\n-      SEQ->cost += compute_rtx_cost (x);                    \\\n-      x = prev_insn_in_block (x);                           \\\n-    }                                                       \\\n-}\n-\n-/* A sequence matching a pattern sequence.  */\n-typedef struct matching_seq_def\n-{\n-  /* The last insn in the matching sequence.  */\n-  rtx insn;\n-\n-  /* Index of INSN instruction.  */\n-  unsigned long idx;\n-\n-  /* The number of insns matching in this sequence and the pattern sequence.\n-   */\n-  int matching_length;\n-\n-  /* The number of insns selected to abstract from this sequence. Less than\n-     or equal to MATCHING_LENGTH.  */\n-  int abstracted_length;\n-\n-  /* The cost of the sequence.  */\n-  int cost;\n-\n-  /* The next sequence in the chain matching the same pattern.  */\n-  struct matching_seq_def *next_matching_seq;\n-} *matching_seq;\n-\n-\n-/* A pattern instruction sequence.  */\n-typedef struct pattern_seq_def\n-{\n-  /* The last insn in the pattern sequence.  */\n-  rtx insn;\n-\n-  /* Index of INSN instruction.  */\n-  unsigned long idx;\n-\n-  /* The gain of transforming the pattern sequence into a pseudo-function and\n-     the matching sequences into pseudo-calls.  */\n-  int gain;\n-\n-  /* The maximum of the ABSTRACTED_LENGTH of the matching sequences.  */\n-  int abstracted_length;\n-\n-  /* The cost of the sequence.  */\n-  int cost;\n-\n-  /* The register used to hold the return address during the pseudo-call.  */\n-  rtx link_reg;\n-\n-  /* The sequences matching this pattern.  */\n-  matching_seq matching_seqs;\n-\n-  /* The next pattern sequence in the chain.  */\n-  struct pattern_seq_def *next_pattern_seq;\n-} *pattern_seq;\n-\n-\n-/* A block of a pattern sequence.  */\n-typedef struct seq_block_def\n-{\n-  /* The number of insns in the block.  */\n-  int length;\n-\n-  /* The code_label of the block.  */\n-  rtx label;\n-\n-  /* The sequences entering the pattern sequence at LABEL.  */\n-  matching_seq matching_seqs;\n-\n-  /* The next block in the chain. The blocks are sorted by LENGTH in\n-     ascending order.  */\n-  struct seq_block_def *next_seq_block;\n-} *seq_block;\n-\n-/* Contains same sequence candidates for further searching.  */\n-typedef struct hash_bucket_def\n-{\n-  /* The hash value of the group.  */\n-  unsigned int hash;\n-\n-  /* List of sequence candidates.  */\n-  htab_t seq_candidates;\n-} *p_hash_bucket;\n-typedef const struct hash_bucket_def *const_p_hash_bucket;\n-\n-/* Contains the last insn of the sequence, and its index value.  */\n-typedef struct hash_elem_def\n-{\n-  /* Unique index; ordered by FILL_HASH_BUCKET.  */\n-  unsigned long idx;\n-\n-  /* The last insn in the sequence.  */\n-  rtx insn;\n-\n-  /* The cached length of the insn.  */\n-  int length;\n-} *p_hash_elem;\n-typedef const struct hash_elem_def *const_p_hash_elem;\n-\n-/* The list of same sequence candidates.  */\n-static htab_t hash_buckets;\n-\n-/* The pattern sequences collected from the current functions.  */\n-static pattern_seq pattern_seqs;\n-\n-/* The blocks of the current pattern sequence.  */\n-static seq_block seq_blocks;\n-\n-/* Cost of calling sequence.  */\n-static int seq_call_cost;\n-\n-/* Cost of jump.  */\n-static int seq_jump_cost;\n-\n-/* Cost of returning.  */\n-static int seq_return_cost;\n-\n-/* Returns the first insn preceding INSN for which INSN_P is true and belongs to\n-   the same basic block. Returns NULL_RTX if no such insn can be found.  */\n-\n-static rtx\n-prev_insn_in_block (rtx insn)\n-{\n-  basic_block bb = BLOCK_FOR_INSN (insn);\n-\n-  if (!bb)\n-    return NULL_RTX;\n-\n-  while (insn != BB_HEAD (bb))\n-    {\n-      insn = PREV_INSN (insn);\n-      if (INSN_P (insn))\n-        return insn;\n-    }\n-  return NULL_RTX;\n-}\n-\n-/* Returns the hash value of INSN.  */\n-\n-static unsigned int\n-compute_hash (rtx insn)\n-{\n-  unsigned int hash = 0;\n-  rtx prev;\n-\n-  hash = INSN_CODE (insn) * 100;\n-\n-  prev = prev_insn_in_block (insn);\n-  if (prev)\n-    hash += INSN_CODE (prev);\n-\n-  return hash;\n-}\n-\n-/* Compute the cost of INSN rtx for abstraction.  */\n-\n-static int\n-compute_rtx_cost (rtx insn)\n-{\n-  struct hash_bucket_def tmp_bucket;\n-  p_hash_bucket bucket;\n-  struct hash_elem_def tmp_elem;\n-  p_hash_elem elem = NULL;\n-  int cost = -1;\n-\n-  /* Compute hash value for INSN.  */\n-  tmp_bucket.hash = compute_hash (insn);\n-\n-  /* Select the hash group.  */\n-  bucket = (p_hash_bucket) htab_find (hash_buckets, &tmp_bucket);\n-\n-  if (bucket)\n-  {\n-    tmp_elem.insn = insn;\n-\n-    /* Select the insn.  */\n-    elem = (p_hash_elem) htab_find (bucket->seq_candidates, &tmp_elem);\n-\n-    /* If INSN is parsed the cost will be the cached length.  */\n-    if (elem)\n-      cost = elem->length;\n-  }\n-\n-  /* If we can't parse the INSN cost will be the instruction length.  */\n-  if (cost == -1)\n-  {\n-    cost = get_attr_length (insn);\n-\n-    /* Cache the length.  */\n-    if (elem)\n-      elem->length = cost;\n-  }\n-\n-  /* If we can't get an accurate estimate for a complex instruction,\n-     assume that it has the same cost as a single fast instruction.  */\n-  return cost != 0 ? cost : COSTS_N_INSNS (1);\n-}\n-\n-/* Determines the number of common insns in the sequences ending in INSN1 and\n-   INSN2. Returns with LEN number of common insns and COST cost of sequence.\n-*/\n-\n-static void\n-matching_length (rtx insn1, rtx insn2, int* len, int* cost)\n-{\n-  rtx x1;\n-  rtx x2;\n-\n-  x1 = insn1;\n-  x2 = insn2;\n-  *len = 0;\n-  *cost = 0;\n-  while (x1 && x2 && (x1 != insn2) && (x2 != insn1)\n-         && rtx_equal_p (PATTERN (x1), PATTERN (x2)))\n-    {\n-      (*len)++;\n-      (*cost) += compute_rtx_cost (x1);\n-      x1 = prev_insn_in_block (x1);\n-      x2 = prev_insn_in_block (x2);\n-    }\n-}\n-\n-/* Adds E0 as a pattern sequence to PATTERN_SEQS with E1 as a matching\n-   sequence.  */\n-\n-static void\n-match_seqs (p_hash_elem e0, p_hash_elem e1)\n-{\n-  int len;\n-  int cost;\n-  matching_seq mseq, p_prev, p_next;\n-\n-  /* Determines the cost of the sequence and return without doing anything\n-     if it is too small to produce any gain.  */\n-  matching_length (e0->insn, e1->insn, &len, &cost);\n-  if (cost <= seq_call_cost)\n-    return;\n-\n-  /* Prepend a new PATTERN_SEQ to PATTERN_SEQS if the last pattern sequence\n-     does not end in E0->INSN. This assumes that once the E0->INSN changes\n-     the old value will never appear again.  */\n-  if (!pattern_seqs || pattern_seqs->insn != e0->insn)\n-    {\n-      pattern_seq pseq =\n-        (pattern_seq) xmalloc (sizeof (struct pattern_seq_def));\n-      pseq->insn = e0->insn;\n-      pseq->idx = e0->idx;\n-      pseq->gain = 0;                 /* Set to zero to force recomputing.  */\n-      pseq->abstracted_length = 0;\n-      pseq->cost = 0;\n-      pseq->link_reg = NULL_RTX;\n-      pseq->matching_seqs = NULL;\n-      pseq->next_pattern_seq = pattern_seqs;\n-      pattern_seqs = pseq;\n-    }\n-\n-  /* Find the position of E1 in the matching sequences list.  */\n-  p_prev = NULL;\n-  p_next = pattern_seqs->matching_seqs;\n-  while (p_next && p_next->idx < e1->idx)\n-    {\n-      p_prev = p_next;\n-      p_next = p_next->next_matching_seq;\n-    }\n-\n-  /* Add a new E1 matching sequence to the pattern sequence. We know that\n-     it ends in E0->INSN.  */\n-  mseq = (matching_seq) xmalloc (sizeof (struct matching_seq_def));\n-  mseq->insn = e1->insn;\n-  mseq->idx = e1->idx;\n-  mseq->matching_length = len;\n-  mseq->abstracted_length = 0;\n-  mseq->cost = cost;\n-\n-  if (p_prev == NULL)\n-    pattern_seqs->matching_seqs = mseq;\n-  else\n-    p_prev->next_matching_seq = mseq;\n-  mseq->next_matching_seq = p_next;\n-}\n-\n-/* Collects all pattern sequences and their matching sequences and puts them\n-   into PATTERN_SEQS.  */\n-\n-static void\n-collect_pattern_seqs (void)\n-{\n-  htab_iterator hti0, hti1, hti2;\n-  p_hash_bucket hash_bucket;\n-  p_hash_elem e0, e1;\n-#if defined STACK_REGS || defined HAVE_cc0\n-  basic_block bb;\n-  bitmap_head dont_collect;\n-\n-  /* Extra initialization step to ensure that no stack registers (if present)\n-     or cc0 code (if present) are live across abnormal edges.\n-     Set a flag in DONT_COLLECT for an insn if a stack register is live\n-     after the insn or the insn is cc0 setter or user.  */\n-  bitmap_initialize (&dont_collect, NULL);\n-\n-#ifdef STACK_REGS\n-  FOR_EACH_BB (bb)\n-  {\n-    regset_head live;\n-    rtx insn;\n-    rtx prev;\n-\n-    /* Initialize liveness propagation.  */\n-    INIT_REG_SET (&live);\n-    bitmap_copy (&live, DF_LR_OUT (bb));\n-    df_simulate_initialize_backwards (bb, &live);\n-\n-    /* Propagate liveness info and mark insns where a stack reg is live.  */\n-    insn = BB_END (bb);\n-    for (insn = BB_END (bb); ; insn = prev)\n-      {\n-\tprev = PREV_INSN (insn);\n-\tif (INSN_P (insn))\n-\t  {\n-\t    int reg;\n-\t    for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n-\t      {\n-\t\tif (REGNO_REG_SET_P (&live, reg))\n-\t\t  {\n-\t\t    bitmap_set_bit (&dont_collect, INSN_UID (insn));\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    \n-\t  }\n-\tif (insn == BB_HEAD (bb))\n-\t  break;\n-\tdf_simulate_one_insn_backwards (bb, insn, &live);\n-\tinsn = prev;\n-      }\n-\n-    /* Free unused data.  */\n-    CLEAR_REG_SET (&live);\n-  }\n-#endif\n-\n-#ifdef HAVE_cc0\n-  /* Mark CC0 setters and users as ineligible for collection into sequences.\n-     This is an over-conservative fix, since it is OK to include\n-     a cc0_setter, but only if we also include the corresponding cc0_user,\n-     and vice versa.  */\n-  FOR_EACH_BB (bb)\n-  {\n-    rtx insn;\n-    rtx next_tail;\n-\n-    next_tail = NEXT_INSN (BB_END (bb));\n-\n-    for (insn = BB_HEAD (bb); insn != next_tail; insn = NEXT_INSN (insn))\n-      {\n-\tif (INSN_P (insn) && reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n-\t  bitmap_set_bit (&dont_collect, INSN_UID (insn));\n-      }\n-  }\n-#endif\n-\n-#endif /* defined STACK_REGS || defined HAVE_cc0 */\n-\n-  /* Initialize PATTERN_SEQS to empty.  */\n-  pattern_seqs = 0;\n-\n-  /* Try to match every abstractable insn with every other insn in the same\n-     HASH_BUCKET.  */\n-\n-  FOR_EACH_HTAB_ELEMENT (hash_buckets, hash_bucket, p_hash_bucket, hti0)\n-    if (htab_elements (hash_bucket->seq_candidates) > 1)\n-      FOR_EACH_HTAB_ELEMENT (hash_bucket->seq_candidates, e0, p_hash_elem, hti1)\n-        FOR_EACH_HTAB_ELEMENT (hash_bucket->seq_candidates, e1, p_hash_elem,\n-                               hti2)\n-          if (e0 != e1\n-#if defined STACK_REGS || defined HAVE_cc0\n-              && !bitmap_bit_p (&dont_collect, INSN_UID (e0->insn))\n-              && !bitmap_bit_p (&dont_collect, INSN_UID (e1->insn))\n-#endif\n-             )\n-            match_seqs (e0, e1);\n-#if defined STACK_REGS || defined HAVE_cc0\n-  /* Free unused data.  */\n-  bitmap_clear (&dont_collect);\n-#endif\n-}\n-\n-/* Transforms a regset to a HARD_REG_SET. Every hard register in REGS is added\n-   to hregs. Additionally, the hard counterpart of every renumbered pseudo\n-   register is also added.  */\n-\n-static void\n-renumbered_reg_set_to_hard_reg_set (HARD_REG_SET * hregs, regset regs)\n-{\n-  int r;\n-\n-  REG_SET_TO_HARD_REG_SET (*hregs, regs);\n-  for (r = FIRST_PSEUDO_REGISTER; r < max_regno; r++)\n-    if (REGNO_REG_SET_P (regs, r) && reg_renumber[r] >= 0)\n-      SET_HARD_REG_BIT (*hregs, reg_renumber[r]);\n-}\n-\n-/* Clears the bits in REGS for all registers, which are live in the sequence\n-   give by its last INSN and its LENGTH.  */\n-\n-static void\n-clear_regs_live_in_seq (HARD_REG_SET * regs, rtx insn, int length)\n-{\n-  basic_block bb;\n-  regset_head live;\n-  HARD_REG_SET hlive;\n-  rtx x;\n-  int i;\n-\n-  /* Initialize liveness propagation.  */\n-  bb = BLOCK_FOR_INSN (insn);\n-  INIT_REG_SET (&live);\n-  bitmap_copy (&live, DF_LR_OUT (bb));\n-  df_simulate_initialize_backwards (bb, &live);\n-\n-  /* Propagate until INSN if found.  */\n-  for (x = BB_END (bb); x != insn; x = PREV_INSN (x))\n-    df_simulate_one_insn_backwards (bb, x, &live);\n-\n-  /* Clear registers live after INSN.  */\n-  renumbered_reg_set_to_hard_reg_set (&hlive, &live);\n-  AND_COMPL_HARD_REG_SET (*regs, hlive);\n-\n-  /* Clear registers live in and before the sequence.  */\n-  for (i = 0; i < length;)\n-    {\n-      rtx prev = PREV_INSN (x);\n-      df_simulate_one_insn_backwards (bb, x, &live);\n-\n-      if (INSN_P (x))\n-        {\n-          renumbered_reg_set_to_hard_reg_set (&hlive, &live);\n-          AND_COMPL_HARD_REG_SET (*regs, hlive);\n-          i++;\n-        }\n-\n-      x = prev;\n-    }\n-\n-  /* Free unused data.  */\n-  CLEAR_REG_SET (&live);\n-}\n-\n-/* Computes the gain of turning PSEQ into a pseudo-function and its matching\n-   sequences into pseudo-calls. Also computes and caches the number of insns to\n-   abstract from  the matching sequences.  */\n-\n-static void\n-recompute_gain_for_pattern_seq (pattern_seq pseq)\n-{\n-  matching_seq mseq;\n-  rtx x;\n-  int i;\n-  int hascall;\n-  HARD_REG_SET linkregs;\n-\n-  /* Initialize data.  */\n-  SET_HARD_REG_SET (linkregs);\n-  pseq->link_reg = NULL_RTX;\n-  pseq->abstracted_length = 0;\n-\n-  pseq->gain = -(seq_call_cost - seq_jump_cost + seq_return_cost);\n-\n-  /* Determine ABSTRACTED_LENGTH and COST for matching sequences of PSEQ.\n-     ABSTRACTED_LENGTH may be less than MATCHING_LENGTH if sequences in the\n-     same block overlap. */\n-\n-  for (mseq = pseq->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n-    {\n-      /* Determine ABSTRACTED_LENGTH.  */\n-      if (mseq->next_matching_seq)\n-        mseq->abstracted_length = (int)(mseq->next_matching_seq->idx -\n-                                        mseq->idx);\n-      else\n-        mseq->abstracted_length = mseq->matching_length;\n-\n-      if (mseq->abstracted_length > mseq->matching_length)\n-        mseq->abstracted_length = mseq->matching_length;\n-\n-      /* Compute the cost of sequence.  */\n-      RECOMPUTE_COST (mseq);\n-\n-      /* If COST is big enough registers live in this matching sequence\n-         should not be used as a link register. Also set ABSTRACTED_LENGTH\n-         of PSEQ.  */\n-      if (mseq->cost > seq_call_cost)\n-        {\n-          clear_regs_live_in_seq (&linkregs, mseq->insn,\n-                                  mseq->abstracted_length);\n-          if (mseq->abstracted_length > pseq->abstracted_length)\n-            pseq->abstracted_length = mseq->abstracted_length;\n-        }\n-    }\n-\n-  /* Modify ABSTRACTED_LENGTH of PSEQ if pattern sequence overlaps with one\n-     of the matching sequences.  */\n-  for (mseq = pseq->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n-    {\n-      x = pseq->insn;\n-      for (i = 0; (i < pseq->abstracted_length) && (x != mseq->insn); i++)\n-        x = prev_insn_in_block (x);\n-      pseq->abstracted_length = i;\n-    }\n-\n-  /* Compute the cost of pattern sequence.  */\n-  RECOMPUTE_COST (pseq);\n-\n-  /* No gain if COST is too small.  */\n-  if (pseq->cost <= seq_call_cost)\n-  {\n-    pseq->gain = -1;\n-    return;\n-  }\n-\n-  /* Ensure that no matching sequence is longer than the pattern sequence.  */\n-  for (mseq = pseq->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n-    {\n-      if (mseq->abstracted_length > pseq->abstracted_length)\n-        {\n-          mseq->abstracted_length = pseq->abstracted_length;\n-          RECOMPUTE_COST (mseq);\n-        }\n-      /* Once the length is stabilizing the gain can be calculated.  */\n-      if (mseq->cost > seq_call_cost)\n-        pseq->gain += mseq->cost - seq_call_cost;\n-    }\n-\n-  /* No need to do further work if there is no gain.  */\n-  if (pseq->gain <= 0)\n-    return;\n-\n-  /* Should not use registers live in the pattern sequence as link register.\n-   */\n-  clear_regs_live_in_seq (&linkregs, pseq->insn, pseq->abstracted_length);\n-\n-  /* Determine whether pattern sequence contains a call_insn.  */\n-  hascall = 0;\n-  x = pseq->insn;\n-  for (i = 0; i < pseq->abstracted_length; i++)\n-    {\n-      if (CALL_P (x))\n-        {\n-          hascall = 1;\n-          break;\n-        }\n-      x = prev_insn_in_block (x);\n-    }\n-\n-  /* Should not use a register as a link register if - it is a fixed\n-     register, or - the sequence contains a call insn and the register is a\n-     call used register, or - the register needs to be saved if used in a\n-     function but was not used before (since saving it can invalidate already\n-     computed frame pointer offsets), or - the register cannot be used as a\n-     base register.  */\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (fixed_regs[i]\n-#ifdef REGNO_OK_FOR_INDIRECT_JUMP_P\n-        || (!REGNO_OK_FOR_INDIRECT_JUMP_P (i, Pmode))\n-#else\n-        || (!ok_for_base_p_1 (i, Pmode, MEM, SCRATCH))\n-        || (!reg_class_subset_p (REGNO_REG_CLASS (i),\n-\t\t\t\t base_reg_class (VOIDmode, MEM, SCRATCH)))\n-#endif\n-        || (hascall && call_used_regs[i])\n-        || (!call_used_regs[i] && !df_regs_ever_live_p (i)))\n-      CLEAR_HARD_REG_BIT (linkregs, i);\n-\n-  /* Find an appropriate register to be used as the link register.  */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (TEST_HARD_REG_BIT (linkregs, i))\n-      {\n-        pseq->link_reg = gen_rtx_REG (Pmode, i);\n-        break;\n-      }\n-\n-  /* Abstraction is not possible if no link register is available, so set\n-     gain to 0.  */\n-  if (!pseq->link_reg)\n-    pseq->gain = 0;\n-}\n-\n-/* Deallocates memory occupied by PSEQ and its matching seqs.  */\n-\n-static void\n-free_pattern_seq (pattern_seq pseq)\n-{\n-  while (pseq->matching_seqs)\n-    {\n-      matching_seq mseq = pseq->matching_seqs;\n-      pseq->matching_seqs = mseq->next_matching_seq;\n-      free (mseq);\n-    }\n-  free (pseq);\n-}\n-\n-\n-/* Computes the gain for pattern sequences. Pattern sequences producing no gain\n-   are deleted. The pattern sequence with the biggest gain is moved to the first\n-   place of PATTERN_SEQS.  */\n-\n-static void\n-recompute_gain (void)\n-{\n-  pattern_seq *pseq;\n-  int maxgain;\n-\n-  maxgain = 0;\n-  for (pseq = &pattern_seqs; *pseq;)\n-    {\n-      if ((*pseq)->gain <= 0)\n-        recompute_gain_for_pattern_seq (*pseq);\n-\n-      if ((*pseq)->gain > 0)\n-        {\n-          if ((*pseq)->gain > maxgain)\n-            {\n-              pattern_seq temp = *pseq;\n-              (*pseq) = temp->next_pattern_seq;\n-              temp->next_pattern_seq = pattern_seqs;\n-              pattern_seqs = temp;\n-              maxgain = pattern_seqs->gain;\n-            }\n-          else\n-            {\n-              pseq = &(*pseq)->next_pattern_seq;\n-            }\n-        }\n-      else\n-        {\n-          pattern_seq temp = *pseq;\n-          *pseq = temp->next_pattern_seq;\n-          free_pattern_seq (temp);\n-        }\n-    }\n-}\n-\n-/* Updated those pattern sequences and matching sequences, which overlap with\n-   the sequence given by INSN and LEN. Deletes sequences shrinking below a\n-   limit.  */\n-\n-static void\n-erase_from_pattern_seqs (rtx insn, int len)\n-{\n-  pattern_seq *pseq;\n-  matching_seq *mseq;\n-  rtx x;\n-  int plen, mlen;\n-  int pcost, mcost;\n-\n-  while (len > 0)\n-    {\n-      for (pseq = &pattern_seqs; *pseq;)\n-        {\n-          plen = 0;\n-          pcost = 0;\n-          for (x = (*pseq)->insn; x && (x != insn);\n-               x = prev_insn_in_block (x))\n-            {\n-              plen++;\n-              pcost += compute_rtx_cost (x);\n-            }\n-\n-          if (pcost <= seq_call_cost)\n-            {\n-              pattern_seq temp = *pseq;\n-              *pseq = temp->next_pattern_seq;\n-              free_pattern_seq (temp);\n-            }\n-          else\n-            {\n-              for (mseq = &(*pseq)->matching_seqs; *mseq;)\n-                {\n-                  mlen = 0;\n-                  mcost = 0;\n-                  for (x = (*mseq)->insn;\n-                       x && (x != insn) && (mlen < plen)\n-                       && (mlen < (*mseq)->matching_length);\n-                       x = prev_insn_in_block (x))\n-                    {\n-                      mlen++;\n-                      mcost += compute_rtx_cost (x);\n-                    }\n-\n-                  if (mcost <= seq_call_cost)\n-                    {\n-                      matching_seq temp = *mseq;\n-                      *mseq = temp->next_matching_seq;\n-                      free (temp);\n-                      /* Set to 0 to force gain recomputation.  */\n-                      (*pseq)->gain = 0;\n-                    }\n-                  else\n-                    {\n-                      if (mlen < (*mseq)->matching_length)\n-                        {\n-                          (*mseq)->cost = mcost;\n-                          (*mseq)->matching_length = mlen;\n-                          /* Set to 0 to force gain recomputation.  */\n-                          (*pseq)->gain = 0;\n-                        }\n-                      mseq = &(*mseq)->next_matching_seq;\n-                    }\n-                }\n-\n-              pseq = &(*pseq)->next_pattern_seq;\n-            }\n-        }\n-\n-      len--;\n-      insn = prev_insn_in_block (insn);\n-    }\n-}\n-\n-/* Updates those pattern sequences and matching sequences, which overlap with\n-   the pattern sequence with the biggest gain and its matching sequences.  */\n-\n-static void\n-update_pattern_seqs (void)\n-{\n-  pattern_seq bestpseq;\n-  matching_seq mseq;\n-\n-  bestpseq = pattern_seqs;\n-  pattern_seqs = bestpseq->next_pattern_seq;\n-\n-  for (mseq = bestpseq->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n-    if (mseq->cost > seq_call_cost)\n-      erase_from_pattern_seqs (mseq->insn, mseq->abstracted_length);\n-  erase_from_pattern_seqs (bestpseq->insn, bestpseq->abstracted_length);\n-\n-  bestpseq->next_pattern_seq = pattern_seqs;\n-  pattern_seqs = bestpseq;\n-}\n-\n-/* Groups together those matching sequences of the best pattern sequence, which\n-   have the same ABSTRACTED_LENGTH and puts these groups in ascending order.\n-   SEQ_BLOCKS contains the result.  */\n-\n-static void\n-determine_seq_blocks (void)\n-{\n-  seq_block sb;\n-  matching_seq *mseq;\n-  matching_seq m;\n-\n-  /* Initialize SEQ_BLOCKS to empty.  */\n-  seq_blocks = 0;\n-\n-  /* Process all matching sequences.  */\n-  for (mseq = &pattern_seqs->matching_seqs; *mseq;)\n-    {\n-      /* Deal only with matching sequences being long enough. */\n-      if ((*mseq)->cost <= seq_call_cost)\n-        {\n-          mseq = &(*mseq)->next_matching_seq;\n-          continue;\n-        }\n-\n-      /* Ensure that SB contains a seq_block with the appropriate length.\n-         Insert a new seq_block if necessary.  */\n-      if (!seq_blocks || ((*mseq)->abstracted_length < seq_blocks->length))\n-        {\n-          sb = (seq_block) xmalloc (sizeof (struct seq_block_def));\n-          sb->length = (*mseq)->abstracted_length;\n-          sb->label = NULL_RTX;\n-          sb->matching_seqs = 0;\n-          sb->next_seq_block = seq_blocks;\n-          seq_blocks = sb;\n-        }\n-      else\n-        {\n-          for (sb = seq_blocks; sb; sb = sb->next_seq_block)\n-            {\n-              if ((*mseq)->abstracted_length == sb->length)\n-                break;\n-              if (!sb->next_seq_block\n-                  || ((*mseq)->abstracted_length <\n-                      sb->next_seq_block->length))\n-                {\n-                  seq_block temp =\n-                    (seq_block) xmalloc (sizeof (struct seq_block_def));\n-                  temp->length = (*mseq)->abstracted_length;\n-                  temp->label = NULL_RTX;\n-                  temp->matching_seqs = 0;\n-                  temp->next_seq_block = sb->next_seq_block;\n-                  sb->next_seq_block = temp;\n-                }\n-            }\n-        }\n-\n-      /* Remove the matching sequence from the linked list of the pattern\n-         sequence and link it to SB.  */\n-      m = *mseq;\n-      *mseq = m->next_matching_seq;\n-      m->next_matching_seq = sb->matching_seqs;\n-      sb->matching_seqs = m;\n-    }\n-}\n-\n-/* Builds a symbol_ref for LABEL.  */\n-\n-static rtx\n-gen_symbol_ref_rtx_for_label (const_rtx label)\n-{\n-  char name[20];\n-  rtx sym;\n-\n-  ASM_GENERATE_INTERNAL_LABEL (name, \"L\", CODE_LABEL_NUMBER (label));\n-  sym = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n-  SYMBOL_REF_FLAGS (sym) = SYMBOL_FLAG_LOCAL;\n-  return sym;\n-}\n-\n-/* Splits basic block at the requested insn and rebuilds dataflow.  */\n-\n-static basic_block\n-split_block_and_df_analyze (basic_block bb, rtx insn)\n-{\n-  basic_block next;\n-  next = split_block (bb, insn)->dest;\n-  df_analyze ();\n-  return next;\n-}\n-\n-/* Ensures that INSN is the last insn in its block and returns the block label\n-   of the next block.  */\n-\n-static rtx\n-block_label_after (rtx insn)\n-{\n-  basic_block bb = BLOCK_FOR_INSN (insn);\n-  if ((insn == BB_END (bb)) && (bb->next_bb != EXIT_BLOCK_PTR))\n-    return block_label (bb->next_bb);\n-  else\n-    return block_label (split_block_and_df_analyze (bb, insn));\n-}\n-\n-/* Ensures that the last insns of the best pattern and its matching sequences\n-   are the last insns in their block. Additionally, extends the live set at the\n-   end of the pattern sequence with the live sets at the end of the matching\n-   sequences.  */\n-\n-static void\n-split_blocks_after_seqs (void)\n-{\n-  seq_block sb;\n-  matching_seq mseq;\n-\n-  block_label_after (pattern_seqs->insn);\n-  for (sb = seq_blocks; sb; sb = sb->next_seq_block)\n-    {\n-      for (mseq = sb->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n-        {\n-          block_label_after (mseq->insn);\n-          IOR_REG_SET (df_get_live_out (BLOCK_FOR_INSN (pattern_seqs->insn)),\n-                       df_get_live_out (BLOCK_FOR_INSN (mseq->insn)));\n-        }\n-    }\n-}\n-\n-/* Splits the best pattern sequence according to SEQ_BLOCKS. Emits pseudo-call\n-   and -return insns before and after the sequence.  */\n-\n-static void\n-split_pattern_seq (void)\n-{\n-  rtx insn;\n-  basic_block bb;\n-  rtx retlabel, retjmp, saveinsn;\n-  int i;\n-  seq_block sb;\n-\n-  insn = pattern_seqs->insn;\n-  bb = BLOCK_FOR_INSN (insn);\n-\n-  /* Get the label after the sequence. This will be the return address. The\n-     label will be referenced using a symbol_ref so protect it from\n-     deleting.  */\n-  retlabel = block_label_after (insn);\n-  LABEL_PRESERVE_P (retlabel) = 1;\n-\n-  /* Emit an indirect jump via the link register after the sequence acting\n-     as the return insn.  Also emit a barrier and update the basic block.  */\n-  if (!find_reg_note (BB_END (bb), REG_NORETURN, NULL))\n-    retjmp = emit_jump_insn_after (gen_indirect_jump (pattern_seqs->link_reg),\n-                                   BB_END (bb));\n-  emit_barrier_after (BB_END (bb));\n-\n-  /* Replace all outgoing edges with a new one to the block of RETLABEL.  */\n-  while (EDGE_COUNT (bb->succs) != 0)\n-    remove_edge (EDGE_SUCC (bb, 0));\n-  make_edge (bb, BLOCK_FOR_INSN (retlabel), EDGE_ABNORMAL);\n-\n-  /* Split the sequence according to SEQ_BLOCKS and cache the label of the\n-     resulting basic blocks.  */\n-  i = 0;\n-  for (sb = seq_blocks; sb; sb = sb->next_seq_block)\n-    {\n-      for (; i < sb->length; i++)\n-        insn = prev_insn_in_block (insn);\n-\n-      sb->label = block_label (split_block_and_df_analyze (bb, insn));\n-    }\n-\n-  /* Emit an insn saving the return address to the link register before the\n-     sequence.  */\n-  saveinsn = emit_insn_after (gen_move_insn (pattern_seqs->link_reg,\n-                              gen_symbol_ref_rtx_for_label\n-                              (retlabel)), BB_END (bb));\n-  /* Update liveness info.  */\n-  SET_REGNO_REG_SET (df_get_live_out (bb),\n-                     REGNO (pattern_seqs->link_reg));\n-}\n-\n-/* Deletes the insns of the matching sequences of the best pattern sequence and\n-   replaces them with pseudo-calls to the pattern sequence.  */\n-\n-static void\n-erase_matching_seqs (void)\n-{\n-  seq_block sb;\n-  matching_seq mseq;\n-  rtx insn;\n-  basic_block bb;\n-  rtx retlabel, saveinsn, callinsn;\n-  int i;\n-\n-  for (sb = seq_blocks; sb; sb = sb->next_seq_block)\n-    {\n-      for (mseq = sb->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n-        {\n-          insn = mseq->insn;\n-          bb = BLOCK_FOR_INSN (insn);\n-\n-          /* Get the label after the sequence. This will be the return\n-             address. The label will be referenced using a symbol_ref so\n-             protect it from deleting.  */\n-          retlabel = block_label_after (insn);\n-          LABEL_PRESERVE_P (retlabel) = 1;\n-\n-          /* Delete the insns of the sequence.  */\n-          for (i = 0; i < sb->length; i++)\n-            insn = prev_insn_in_block (insn);\n-          delete_basic_block (split_block_and_df_analyze (bb, insn));\n-\n-          /* Emit an insn saving the return address to the link register\n-             before the deleted sequence.  */\n-          saveinsn = emit_insn_after (gen_move_insn (pattern_seqs->link_reg,\n-                                      gen_symbol_ref_rtx_for_label\n-                                      (retlabel)),\n-                                      BB_END (bb));\n-          BLOCK_FOR_INSN (saveinsn) = bb;\n-\n-          /* Emit a jump to the appropriate part of the pattern sequence\n-             after the save insn. Also update the basic block.  */\n-          callinsn = emit_jump_insn_after (gen_jump (sb->label), saveinsn);\n-          JUMP_LABEL (callinsn) = sb->label;\n-          LABEL_NUSES (sb->label)++;\n-          BLOCK_FOR_INSN (callinsn) = bb;\n-          BB_END (bb) = callinsn;\n-\n-          /* Maintain control flow and liveness information.  */\n-          SET_REGNO_REG_SET (df_get_live_out (bb),\n-                             REGNO (pattern_seqs->link_reg));\n-          emit_barrier_after (BB_END (bb));\n-          make_single_succ_edge (bb, BLOCK_FOR_INSN (sb->label), 0);\n-          IOR_REG_SET (df_get_live_out (bb),\n-\t\t       df_get_live_in (BLOCK_FOR_INSN (sb->label)));\n-\n-          make_edge (BLOCK_FOR_INSN (seq_blocks->label),\n-                     BLOCK_FOR_INSN (retlabel), EDGE_ABNORMAL);\n-        }\n-    }\n-}\n-\n-/* Deallocates SEQ_BLOCKS and all the matching sequences.  */\n-\n-static void\n-free_seq_blocks (void)\n-{\n-  while (seq_blocks)\n-    {\n-      seq_block sb = seq_blocks;\n-      while (sb->matching_seqs)\n-        {\n-          matching_seq mseq = sb->matching_seqs;\n-          sb->matching_seqs = mseq->next_matching_seq;\n-          free (mseq);\n-        }\n-      seq_blocks = sb->next_seq_block;\n-      free (sb);\n-    }\n-}\n-\n-/* Transforms the best pattern sequence into a pseudo-function and its matching\n-   sequences to pseudo-calls. Afterwards the best pattern sequence is removed\n-   from PATTERN_SEQS.  */\n-\n-static void\n-abstract_best_seq (void)\n-{\n-  pattern_seq bestpseq;\n-\n-  /* Do the abstraction.  */\n-  determine_seq_blocks ();\n-  split_blocks_after_seqs ();\n-  split_pattern_seq ();\n-  erase_matching_seqs ();\n-  free_seq_blocks ();\n-\n-  /* Record the usage of the link register.  */\n-  df_set_regs_ever_live (REGNO (pattern_seqs->link_reg), true);\n-\n-  /* Remove the best pattern sequence.  */\n-  bestpseq = pattern_seqs;\n-  pattern_seqs = bestpseq->next_pattern_seq;\n-  free_pattern_seq (bestpseq);\n-}\n-\n-/* Prints info on the pattern sequences to the dump file.  */\n-\n-static void\n-dump_pattern_seqs (void)\n-{\n-  pattern_seq pseq;\n-  matching_seq mseq;\n-\n-  if (!dump_file)\n-    return;\n-\n-  fprintf (dump_file, \";; Pattern sequences\\n\");\n-  for (pseq = pattern_seqs; pseq; pseq = pseq->next_pattern_seq)\n-    {\n-      fprintf (dump_file, \"Pattern sequence at insn %d matches sequences at\",\n-               INSN_UID (pseq->insn));\n-      for (mseq = pseq->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n-        {\n-          fprintf (dump_file, \" insn %d (length %d)\", INSN_UID (mseq->insn),\n-                   mseq->matching_length);\n-          if (mseq->next_matching_seq)\n-            fprintf (dump_file, \",\");\n-        }\n-      fprintf (dump_file, \".\\n\");\n-    }\n-  fprintf (dump_file, \"\\n\");\n-}\n-\n-/* Prints info on the best pattern sequence transformed in the ITER-th\n-   iteration to the dump file.  */\n-\n-static void\n-dump_best_pattern_seq (int iter)\n-{\n-  matching_seq mseq;\n-\n-  if (!dump_file)\n-    return;\n-\n-  fprintf (dump_file, \";; Iteration %d\\n\", iter);\n-  fprintf (dump_file,\n-           \"Best pattern sequence with %d gain is at insn %d (length %d).\\n\",\n-           pattern_seqs->gain, INSN_UID (pattern_seqs->insn),\n-           pattern_seqs->abstracted_length);\n-  fprintf (dump_file, \"Matching sequences are at\");\n-  for (mseq = pattern_seqs->matching_seqs; mseq;\n-       mseq = mseq->next_matching_seq)\n-    {\n-      fprintf (dump_file, \" insn %d (length %d)\", INSN_UID (mseq->insn),\n-               mseq->abstracted_length);\n-      if (mseq->next_matching_seq)\n-        fprintf (dump_file, \",\");\n-    }\n-  fprintf (dump_file, \".\\n\");\n-  fprintf (dump_file, \"Using reg %d as link register.\\n\\n\",\n-           REGNO (pattern_seqs->link_reg));\n-}\n-\n-/* Htab hash function for hash_bucket_def structure.  */\n-\n-static unsigned int\n-htab_hash_bucket (const void *p)\n-{\n-  const_p_hash_bucket bucket = (const_p_hash_bucket) p;\n-  return bucket->hash;\n-}\n-\n-/* Htab equal function for hash_bucket_def structure.  */\n-\n-static int\n-htab_eq_bucket (const void *p0, const void *p1)\n-{\n-  return htab_hash_bucket (p0) == htab_hash_bucket (p1);\n-}\n-\n-/* Htab delete function for hash_bucket_def structure.  */\n-\n-static void\n-htab_del_bucket (void *p)\n-{\n-  p_hash_bucket bucket = (p_hash_bucket) p;\n-\n-  if (bucket->seq_candidates)\n-    htab_delete (bucket->seq_candidates);\n-\n-  free (bucket);\n-}\n-\n-/* Htab hash function for hash_bucket_def structure.  */\n-\n-static unsigned int\n-htab_hash_elem (const void *p)\n-{\n-  const_p_hash_elem elem = (const_p_hash_elem) p;\n-  return htab_hash_pointer (elem->insn);\n-}\n-\n-/* Htab equal function for hash_bucket_def structure.  */\n-\n-static int\n-htab_eq_elem (const void *p0, const void *p1)\n-{\n-  return htab_hash_elem (p0) == htab_hash_elem (p1);\n-}\n-\n-/* Htab delete function for hash_bucket_def structure.  */\n-\n-static void\n-htab_del_elem (void *p)\n-{\n-  p_hash_elem elem = (p_hash_elem) p;\n-  free (elem);\n-}\n-\n-/* Creates a hash value for each sequence candidate and saves them\n-   in HASH_BUCKET.  */\n-\n-static void\n-fill_hash_bucket (void)\n-{\n-  basic_block bb;\n-  rtx insn;\n-  void **slot;\n-  p_hash_bucket bucket;\n-  struct hash_bucket_def tmp_bucket;\n-  p_hash_elem elem;\n-  unsigned long insn_idx;\n-\n-  insn_idx = 0;\n-  FOR_EACH_BB (bb)\n-    {\n-      FOR_BB_INSNS_REVERSE (bb, insn)\n-        {\n-          if (!ABSTRACTABLE_INSN_P (insn))\n-            continue;\n-\n-          /* Compute hash value for INSN.  */\n-          tmp_bucket.hash = compute_hash (insn);\n-\n-          /* Select the hash group.  */\n-          bucket = (p_hash_bucket) htab_find (hash_buckets, &tmp_bucket);\n-\n-          if (!bucket)\n-            {\n-              /* Create a new hash group.  */\n-              bucket = (p_hash_bucket) xcalloc (1,\n-                                        sizeof (struct hash_bucket_def));\n-              bucket->hash = tmp_bucket.hash;\n-              bucket->seq_candidates = NULL;\n-\n-              slot = htab_find_slot (hash_buckets, &tmp_bucket, INSERT);\n-              *slot = bucket;\n-            }\n-\n-          /* Create new list for storing sequence candidates.  */\n-          if (!bucket->seq_candidates)\n-              bucket->seq_candidates = htab_create (HASH_INIT,\n-                                                    htab_hash_elem,\n-                                                    htab_eq_elem,\n-                                                    htab_del_elem);\n-\n-          elem = (p_hash_elem) xcalloc (1, sizeof (struct hash_elem_def));\n-          elem->insn = insn;\n-          elem->idx = insn_idx;\n-          elem->length = get_attr_length (insn);\n-\n-          /* Insert INSN into BUCKET hash bucket.  */\n-          slot = htab_find_slot (bucket->seq_candidates, elem, INSERT);\n-          *slot = elem;\n-\n-          insn_idx++;\n-        }\n-    }\n-}\n-\n-/* Computes the cost of calling sequence and the cost of return.  */\n-\n-static void\n-compute_init_costs (void)\n-{\n-  rtx rtx_jump, rtx_store, rtx_return, reg, label;\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    if (BB_HEAD (bb))\n-      break;\n-\n-  label = block_label (bb);\n-  reg = gen_rtx_REG (Pmode, 0);\n-\n-  /* Pattern for indirect jump.  */\n-  rtx_jump = gen_indirect_jump (reg);\n-\n-  /* Pattern for storing address.  */\n-  rtx_store = gen_rtx_SET (VOIDmode, reg, gen_symbol_ref_rtx_for_label (label));\n-\n-  /* Pattern for return insn.  */\n-  rtx_return = gen_jump (label);\n-\n-  /* The cost of jump.  */\n-  seq_jump_cost = compute_rtx_cost (make_jump_insn_raw (rtx_jump));\n-\n-  /* The cost of calling sequence.  */\n-  seq_call_cost = seq_jump_cost + compute_rtx_cost (make_insn_raw (rtx_store));\n-\n-  /* The cost of return.  */\n-  seq_return_cost = compute_rtx_cost (make_jump_insn_raw (rtx_return));\n-\n-  /* Simple heuristic for minimal sequence cost.  */\n-  seq_call_cost   = (int)(seq_call_cost * (double)SEQ_CALL_COST_MULTIPLIER);\n-}\n-\n-/* Finds equivalent insn sequences in the current function and retains only one\n-   instance of them which is turned into a pseudo-function. The additional\n-   copies are erased and replaced by pseudo-calls to the retained sequence.  */\n-\n-static void\n-rtl_seqabstr (void)\n-{\n-  int iter;\n-  df_set_flags (DF_LR_RUN_DCE);\n-  df_analyze ();\n-\n-  /* Create a hash list for COLLECT_PATTERN_SEQS.  */\n-  hash_buckets = htab_create (HASH_INIT, htab_hash_bucket , htab_eq_bucket ,\n-                              htab_del_bucket);\n-  fill_hash_bucket ();\n-\n-  /* Compute the common cost of abstraction.  */\n-  compute_init_costs ();\n-\n-  /* Build an initial set of pattern sequences from the current function.  */\n-  collect_pattern_seqs ();\n-  dump_pattern_seqs ();\n-\n-  /* Iterate until there are no sequences to abstract.  */\n-  for (iter = 1;; iter++)\n-    {\n-      /* Recompute gain for sequences if necessary and select sequence with\n-         biggest gain.  */\n-      recompute_gain ();\n-      if (!pattern_seqs)\n-        break;\n-      dump_best_pattern_seq (iter);\n-      /* Update the cached info of the other sequences and force gain\n-         recomputation where needed.  */\n-      update_pattern_seqs ();\n-      /* Turn best sequences into pseudo-functions and -calls.  */\n-      abstract_best_seq ();\n-    }\n-\n-  /* Cleanup hash tables.  */\n-  htab_delete (hash_buckets);\n-}\n-\n-/* The gate function for TREE_OPT_PASS.  */\n-\n-static bool\n-gate_rtl_seqabstr (void)\n-{\n-  return flag_rtl_seqabstr;\n-}\n-\n-/* The entry point of the sequence abstraction algorithm.  */\n-\n-static unsigned int\n-rest_of_rtl_seqabstr (void)\n-{\n-  /* Abstract out common insn sequences. */\n-  rtl_seqabstr ();\n-  return 0;\n-}\n-\n-struct rtl_opt_pass pass_rtl_seqabstr = \n-{\n- {\n-  RTL_PASS,\n-  \"seqabstr\",                           /* name */\n-  gate_rtl_seqabstr,                    /* gate */\n-  rest_of_rtl_seqabstr,                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_SEQABSTR,                          /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_dump_func |\n-  TODO_ggc_collect                      /* todo_flags_finish */\n- }\n-};"}, {"sha": "99a310be5ad091ba7ee05ad7d5c652aa2d26ca00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=824523999285e704ff2c549d8dbd8d20bb1c6ac0", "patch": "@@ -1,3 +1,8 @@\n+2009-03-31  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+\t* gcc.c-torture/compile/pr33009.c: Delete.\n+\t* gcc.c-torture/compile/pr11832.c: Likewise.\n+\n 2009-03-31  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/448"}, {"sha": "ad14c0cd076d598247d34c208aac02beaf719bae", "filename": "gcc/testsuite/gcc.c-torture/compile/pr11832.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf79d7f23a3883694578f431c08960c348e38/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr11832.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf79d7f23a3883694578f431c08960c348e38/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr11832.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr11832.c?ref=207bf79d7f23a3883694578f431c08960c348e38", "patch": "@@ -1,35 +0,0 @@\n-/* { dg-do compile } */\n-/* Currently ICEs for Alpha, IA64, HPPA, MIPS, CRIS, Xtensa, PowerPC, SH and SPARC; see PR33642.  */\n-/* { dg-xfail-if \"PR33642\" { alpha*-*-* hppa*-*-* mips*-*-* powerpc*-*-* cris-*-* crisv32-*-* ia64-*-* xtensa*-*-* sh*-*-* sparc*-*-* s390*-*-* } { \"*\" } { \"\" } } */\n-/* Currently ICEs for (x86 && ilp32 && pic).  */\n-/* { dg-xfail-if \"PR33642/36240\" { { i?86-*-* x86_64-*-* } && { ilp32 && { ! nonpic } } } { \"*\" } { \"\" } } */\n-/* { dg-prune-output \".*internal compiler error.*\" }\n-/* { dg-options \"-frtl-abstract-sequences\" } */\n-\n-int a, b, e;\n-unsigned char *c;\n-void foo()\n-{\n-  int d = 13;\n-  b = -1;   \n-  switch (e) {\n-    case 1:\n-      b++; c[b] = (unsigned char)d;\n-      break;\n-    case 2:\n-      b++; c[b] = (unsigned char)d;\n-      b++; c[b] = (unsigned char)d;\n-      break;\n-    case 3:\n-      b++; c[b] = (unsigned char)d;\n-      b++; c[b] = (unsigned char)d;\n-      b++; c[b] = (unsigned char)d;\n-      break;\n-    default:\n-      a = 1;\n-      b++; c[b] = (unsigned char)d;\n-      b++; c[b] = (unsigned char)d;\n-      b++; c[b] = (unsigned char)d;\n-      b++; c[b] = (unsigned char)d;\n-  }\n-}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gcc.c-torture/compile/pr33009.c", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr33009.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824523999285e704ff2c549d8dbd8d20bb1c6ac0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr33009.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr33009.c?ref=824523999285e704ff2c549d8dbd8d20bb1c6ac0", "patch": "@@ -1,41 +0,0 @@\n-/* { dg-do compile } */\n-/* Currently ICEs for Alpha, IA64, HPPA, MIPS, CRIS, Xtensa, PowerPC, SH and SPARC; see PR33642.  */\n-/* { dg-xfail-if \"PR33642\" { alpha*-*-* hppa*-*-* mips*-*-* powerpc*-*-* cris-*-* crisv32-*-* ia64-*-* xtensa*-*-* sh*-*-* sparc*-*-* s390*-*-* } { \"*\" } { \"\" } } */\n-/* Currently ICEs for (x86 && ilp32 && pic).  */\n-/* { dg-xfail-if \"PR33642/36240\" { { i?86-*-* x86_64-*-* } && { ilp32 && { ! nonpic } } } { \"*\" } { \"\" } } */\n-/* { dg-prune-output \".*internal compiler error.*\" }\n-/* { dg-options \"-frtl-abstract-sequences\" } */\n-\n-char *progName;\n-int bar0 (char *, ...);\n-void bar1 (char *);\n-void exit (int);\n-\n-\n-#define SAME \\\n- bar0 (\"%s: Bad flag `%s'\\n\", argv[i], argv[i] );\\\n- bar1 ( progName ); \\\n- exit ( 1 );\n-\n-\n-int foo ( int argc, char *argv[] )\n-{\n-    int i;\n-    for (i = 0; i < argc; i++) {\n-\tswitch (argv[i][0]) {\n-\tcase 'c':\n-\t    break;\n-\tdefault: \n-\t\n-\t    SAME\n-\t    \n-\t    break;\n-\t}\n-    }\n-    for (i = 0; i < argc; i++) {\n-    \n-\tSAME\n-\t\n-    }\n-    return 0;\n-}"}]}