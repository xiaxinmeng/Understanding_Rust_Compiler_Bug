{"sha": "0c9687d0daa08c33456210b87e4060d6397ff4d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM5Njg3ZDBkYWEwOGMzMzQ1NjIxMGI4N2U0MDYwZDYzOTdmZjRkOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-16T15:31:30Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-16T15:31:30Z"}, "message": "Disable some bogus -Wmaybe-uninitialized warnings\n\ngcc/ChangeLog:\n\tPR middle-end/97840\n\t* ipa-modref.c (analyze_ssa_name_flags): Skip clobbers if inlining\n\tis done.\n\t* tree-ssa-uninit.c (maybe_warn_pass_by_reference): Make stmt gcall;\n\tskip const calls and unused arguments.\n\t(warn_uninitialized_vars): Update prototype.\n\ngcc/testsuite/ChangeLog:\n\t* g++.dg/warn/uninit-1.C: New test.", "tree": {"sha": "8986ca4e89585c82fc63b24e4f9a2e972a92374b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8986ca4e89585c82fc63b24e4f9a2e972a92374b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c9687d0daa08c33456210b87e4060d6397ff4d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9687d0daa08c33456210b87e4060d6397ff4d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c9687d0daa08c33456210b87e4060d6397ff4d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9687d0daa08c33456210b87e4060d6397ff4d8/comments", "author": null, "committer": null, "parents": [{"sha": "c84df34aec3bb845b22384c7e85f0449ca00dd99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c84df34aec3bb845b22384c7e85f0449ca00dd99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c84df34aec3bb845b22384c7e85f0449ca00dd99"}], "stats": {"total": 52, "additions": 48, "deletions": 4}, "files": [{"sha": "c7f763eaeff0c3aeb089cebea762376eb0193e96", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9687d0daa08c33456210b87e4060d6397ff4d8/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9687d0daa08c33456210b87e4060d6397ff4d8/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=0c9687d0daa08c33456210b87e4060d6397ff4d8", "patch": "@@ -1333,7 +1333,14 @@ analyze_ssa_name_flags (tree name, vec<unsigned char> &known_flags, int depth)\n \t  /* Handle *name = exp.  */\n \t  else if (assign\n \t\t   && memory_access_to (gimple_assign_lhs (assign), name))\n-\t    flags &= ~(EAF_UNUSED | EAF_NOCLOBBER);\n+\t    {\n+\t      /* In general we can not ignore clobbers because they are\n+\t\t barriers for code motion, however after inlining it is safe to\n+\t\t do because local optimization passes do not consider clobbers\n+\t\t from other functions.  Similar logic is in ipa-pure-const.c.  */\n+\t      if (!cfun->after_inlining || !gimple_clobber_p (assign))\n+\t\tflags &= ~(EAF_UNUSED | EAF_NOCLOBBER);\n+\t    }\n \t  /* ASM statements etc.  */\n \t  else if (!assign)\n \t    {"}, {"sha": "30f3ceae19196220796bf32d1760cc5379889ddd", "filename": "gcc/testsuite/g++.dg/warn/uninit-1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9687d0daa08c33456210b87e4060d6397ff4d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funinit-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9687d0daa08c33456210b87e4060d6397ff4d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funinit-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funinit-1.C?ref=0c9687d0daa08c33456210b87e4060d6397ff4d8", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wmaybe-uninitialized\" } */\n+struct a {int a;};\n+__attribute__ ((noinline))\n+void\n+nowarn (const struct a *ptr)\n+{\n+  if (ptr)\n+    asm volatile (\"\");\n+}\n+void\n+test()\n+{\n+  struct a ptr;\n+  nowarn (&ptr);\n+}\n+__attribute__ ((noinline))\n+int\n+nowarn2 (const struct a *ptr, const struct a ptr2)\n+{\n+  return ptr != 0 || ptr2.a;\n+}\n+int mem;\n+int\n+test2()\n+{\n+  struct a ptr,ptr2={0};\n+  return nowarn2 (&ptr, ptr2);\n+}"}, {"sha": "c94831bfb75647c677b7a9779d10324e716fdca3", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9687d0daa08c33456210b87e4060d6397ff4d8/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9687d0daa08c33456210b87e4060d6397ff4d8/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=0c9687d0daa08c33456210b87e4060d6397ff4d8", "patch": "@@ -443,7 +443,7 @@ maybe_warn_operand (ao_ref &ref, gimple *stmt, tree lhs, tree rhs,\n    access implying read access to those objects.  */\n \n static void\n-maybe_warn_pass_by_reference (gimple *stmt, wlimits &wlims)\n+maybe_warn_pass_by_reference (gcall *stmt, wlimits &wlims)\n {\n   if (!wlims.wmaybe_uninit)\n     return;\n@@ -457,6 +457,10 @@ maybe_warn_pass_by_reference (gimple *stmt, wlimits &wlims)\n   if (!fntype)\n     return;\n \n+  /* Const function do not read their arguments.  */\n+  if (gimple_call_flags (stmt) & ECF_CONST)\n+    return;\n+\n   const built_in_function fncode\n     = (fndecl && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL)\n        ? DECL_FUNCTION_CODE (fndecl) : (built_in_function)BUILT_IN_LAST);\n@@ -523,6 +527,10 @@ maybe_warn_pass_by_reference (gimple *stmt, wlimits &wlims)\n \t   (but not definitive) read access.  */\n \twlims.always_executed = false;\n \n+      /* Ignore args we are not going to read from.  */\n+      if (gimple_call_arg_flags (stmt, argno - 1) & EAF_UNUSED)\n+\tcontinue;\n+\n       tree arg = gimple_call_arg (stmt, argno - 1);\n \n       ao_ref ref;\n@@ -639,8 +647,8 @@ warn_uninitialized_vars (bool wmaybe_uninit)\n \t  if (gimple_vdef (stmt))\n \t    wlims.vdef_cnt++;\n \n-\t  if (is_gimple_call (stmt))\n-\t    maybe_warn_pass_by_reference (stmt, wlims);\n+\t  if (gcall *call = dyn_cast <gcall *> (stmt))\n+\t    maybe_warn_pass_by_reference (call, wlims);\n \t  else if (gimple_assign_load_p (stmt)\n \t\t   && gimple_has_location (stmt))\n \t    {"}]}