{"sha": "640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQwNjcwYzdmNGVjMTNkNGVmM2FhYjczZjdiN2VhN2ViMDViN2E5ZA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-10-29T14:13:44Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-10-29T14:13:44Z"}, "message": "[multiple changes]\n\n2007-10-29  Paul Thomas  <pault@gcc.gnu.org>\n\n        PR fortran/31217\n        PR fortran/33811\n        PR fortran/33686\n        * trans-array.c (gfc_conv_loop_setup): Send a complete type to\n        gfc_trans_create_temp_array if the temporary is character.\n        * trans-stmt.c (gfc_trans_assign_need_temp): Do likewise for\n        allocate_temp_for_forall_nest.\n        (forall_replace): New function.\n        (forall_replace_symtree): New function.\n        (forall_restore): New function.\n        (forall_restore_symtree): New function.\n        (forall_make_variable_temp): New function.\n        (check_forall_dependencies): New function.\n        (cleanup_forall_symtrees): New function.\n        gfc_trans_forall_1): Add and initialize pre and post blocks.\n        Call check_forall_dependencies to check for all dependencies\n        and either trigger second forall block to copy temporary or\n        copy lval, outside the forall construct and replace all\n        dependent references. After assignment clean-up and coalesce\n        the blocks at the end of the function.\n        * gfortran.h : Add prototypes for gfc_traverse_expr and\n        find_forall_index.\n        expr.c (gfc_traverse_expr): New function to traverse expression\n        and visit all subexpressions, under control of a logical flag,\n        a symbol and an integer pointer. The slave function is caller\n        defined and is only called on EXPR_VARIABLE.\n        (expr_set_symbols_referenced): Called by above to set symbols\n        referenced.\n        (gfc_expr_set_symbols_referenced): Rework of this function to\n        use two new functions above.\n        * resolve.c (find_forall_index): Rework with gfc_traverse_expr,\n        using forall_index.\n        (forall_index): New function used by previous.\n        * dependency.c (gfc_check_dependency): Use gfc_dep_resolver for\n        all references, not just REF_ARRAY.\n        (gfc_dep_resolver): Correct the logic for substrings so that\n        overlapping arrays are handled correctly.\n\n2007-10-29 Paul Thomas <pault@gcc.gnu.org>\n\n        PR fortran/31217\n        PR fortran/33811\n        * gfortran.dg/forall_12.f90: New test.\n\n        PR fortran/33686\n        * gfortran.dg/forall_13.f90: New test.\n\nFrom-SVN: r129720", "tree": {"sha": "965c87505ca071b2707c92dabd1c972a1673e22b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/965c87505ca071b2707c92dabd1c972a1673e22b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/comments", "author": null, "committer": null, "parents": [{"sha": "a270181e4059512728c286f6aff14219354cf0cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a270181e4059512728c286f6aff14219354cf0cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a270181e4059512728c286f6aff14219354cf0cf"}], "stats": {"total": 608, "additions": 448, "deletions": 160}, "files": [{"sha": "a761a9535699e2f9914e9569eac47aafb702aae2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "patch": "@@ -1,3 +1,44 @@\n+2007-10-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31217\n+\tPR fortran/33811\n+\tPR fortran/33686\n+\n+\t* trans-array.c (gfc_conv_loop_setup): Send a complete type to\n+\tgfc_trans_create_temp_array if the temporary is character.\n+\t* trans-stmt.c (gfc_trans_assign_need_temp): Do likewise for\n+\tallocate_temp_for_forall_nest.\n+\t(forall_replace): New function.\n+\t(forall_replace_symtree): New function.\n+\t(forall_restore): New function.\n+\t(forall_restore_symtree): New function.\n+\t(forall_make_variable_temp): New function.\n+\t(check_forall_dependencies): New function.\n+\t(cleanup_forall_symtrees): New function.\n+\tgfc_trans_forall_1): Add and initialize pre and post blocks.\n+\tCall check_forall_dependencies to check for all dependencies\n+\tand either trigger second forall block to copy temporary or\n+\tcopy lval, outside the forall construct and replace all\n+\tdependent references. After assignment clean-up and coalesce\n+\tthe blocks at the end of the function.\n+\t* gfortran.h : Add prototypes for gfc_traverse_expr and\n+\tfind_forall_index.\n+\texpr.c (gfc_traverse_expr): New function to traverse expression\n+\tand visit all subexpressions, under control of a logical flag,\n+\ta symbol and an integer pointer. The slave function is caller\n+\tdefined and is only called on EXPR_VARIABLE.\n+\t(expr_set_symbols_referenced): Called by above to set symbols\n+\treferenced.\n+\t(gfc_expr_set_symbols_referenced): Rework of this function to\n+\tuse two new functions above.\n+\t* resolve.c (find_forall_index): Rework with gfc_traverse_expr,\n+\tusing forall_index.\n+\t(forall_index): New function used by previous.\n+\t* dependency.c (gfc_check_dependency): Use gfc_dep_resolver for\n+\tall references, not just REF_ARRAY.\n+\t(gfc_dep_resolver): Correct the logic for substrings so that\n+\toverlapping arrays are handled correctly.\n+\n 2007-10-28  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \tPR fortran/32147"}, {"sha": "29a5237e6eb555d320264f6e0631cad3fdfc2888", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "patch": "@@ -657,8 +657,7 @@ gfc_check_dependency (gfc_expr *expr1, gfc_expr *expr2, bool identical)\n \n       /* Identical and disjoint ranges return 0,\n \t overlapping ranges return 1.  */\n-      /* Return zero if we refer to the same full arrays.  */\n-      if (expr1->ref->type == REF_ARRAY && expr2->ref->type == REF_ARRAY)\n+      if (expr1->ref && expr2->ref)\n \treturn gfc_dep_resolver (expr1->ref, expr2->ref);\n \n       return 1;\n@@ -1197,8 +1196,9 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref)\n \t  break;\n \t  \n \tcase REF_SUBSTRING:\n-\t  /* Substring overlaps are handled by the string assignment code.  */\n-\t  return 0;\n+\t  /* Substring overlaps are handled by the string assignment code\n+\t     if there is not an underlying dependency.  */\n+\t  return (fin_dep == GFC_DEP_OVERLAP) ? 1 : 0;\n \t\n \tcase REF_ARRAY:\n \t  if (lref->u.ar.dimen != rref->u.ar.dimen)"}, {"sha": "c7edb49770258fa731c30b21fa4ba815db8dc058", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 68, "deletions": 30, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "patch": "@@ -2998,32 +2998,36 @@ gfc_get_variable_expr (gfc_symtree *var)\n }\n \n \n-/* Traverse expr, marking all EXPR_VARIABLE symbols referenced.  */\n+/* General expression traversal function.  */\n \n-void\n-gfc_expr_set_symbols_referenced (gfc_expr *expr)\n+bool\n+gfc_traverse_expr (gfc_expr *expr, gfc_symbol *sym,\n+\t\t   bool (*func)(gfc_expr *, gfc_symbol *, int*),\n+\t\t   int f)\n {\n-  gfc_actual_arglist *arg;\n-  gfc_constructor *c;\n+  gfc_array_ref ar;\n   gfc_ref *ref;\n+  gfc_actual_arglist *args;\n+  gfc_constructor *c;\n   int i;\n \n-  if (!expr) return;\n+  if (!expr)\n+    return false;\n \n   switch (expr->expr_type)\n     {\n-    case EXPR_OP:\n-      gfc_expr_set_symbols_referenced (expr->value.op.op1);\n-      gfc_expr_set_symbols_referenced (expr->value.op.op2);\n-      break;\n+    case EXPR_VARIABLE:\n+      gcc_assert (expr->symtree->n.sym);\n \n-    case EXPR_FUNCTION:\n-      for (arg = expr->value.function.actual; arg; arg = arg->next)\n-\tgfc_expr_set_symbols_referenced (arg->expr);\n-      break;\n+      if ((*func) (expr, sym, &f))\n+\treturn true;\n \n-    case EXPR_VARIABLE:\n-      gfc_set_sym_referenced (expr->symtree->n.sym);\n+    case EXPR_FUNCTION:\n+      for (args = expr->value.function.actual; args; args = args->next)\n+\t{\n+\t  if (gfc_traverse_expr (args->expr, sym, func, f))\n+\t    return true;\n+\t}\n       break;\n \n     case EXPR_CONSTANT:\n@@ -3037,33 +3041,67 @@ gfc_expr_set_symbols_referenced (gfc_expr *expr)\n \tgfc_expr_set_symbols_referenced (c->expr);\n       break;\n \n+    case EXPR_OP:\n+      if (gfc_traverse_expr (expr->value.op.op1, sym, func, f))\n+\treturn true;\n+      if (gfc_traverse_expr (expr->value.op.op2, sym, func, f))\n+\treturn true;\n+      break;\n+\n     default:\n       gcc_unreachable ();\n       break;\n     }\n \n-    for (ref = expr->ref; ref; ref = ref->next)\n+  ref = expr->ref;\n+  while (ref != NULL)\n+    {\n       switch (ref->type)\n \t{\n-\tcase REF_ARRAY:\n-\t  for (i = 0; i < ref->u.ar.dimen; i++)\n+\tcase  REF_ARRAY:\n+\t  ar = ref->u.ar;\n+\t  for (i = 0; i < GFC_MAX_DIMENSIONS; i++)\n \t    {\n-\t      gfc_expr_set_symbols_referenced (ref->u.ar.start[i]);\n-\t      gfc_expr_set_symbols_referenced (ref->u.ar.end[i]);\n-\t      gfc_expr_set_symbols_referenced (ref->u.ar.stride[i]);\n+\t      if (gfc_traverse_expr (ar.start[i], sym, func, f))\n+\t\treturn true;\n+\t      if (gfc_traverse_expr (ar.end[i], sym, func, f))\n+\t\treturn true;\n+\t      if (gfc_traverse_expr (ar.stride[i], sym, func, f))\n+\t\treturn true;\n \t    }\n \t  break;\n-\t   \n-\tcase REF_COMPONENT:\n-\t  break;\n-\t   \n+\n \tcase REF_SUBSTRING:\n-\t  gfc_expr_set_symbols_referenced (ref->u.ss.start);\n-\t  gfc_expr_set_symbols_referenced (ref->u.ss.end);\n+\t  if (gfc_traverse_expr (ref->u.ss.start, sym, func, f))\n+\t    return true;\n+\t  if (gfc_traverse_expr (ref->u.ss.end, sym, func, f))\n+\t    return true;\n \t  break;\n-\t   \n+\n+\t  case REF_COMPONENT:\n+\t    break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n-\t  break;\n \t}\n+      ref = ref->next;\n+    }\n+  return false;\n+}\n+\n+/* Traverse expr, marking all EXPR_VARIABLE symbols referenced.  */\n+\n+static bool\n+expr_set_symbols_referenced (gfc_expr *expr,\n+\t\t\t     gfc_symbol *sym ATTRIBUTE_UNUSED,\n+\t\t\t     int *f ATTRIBUTE_UNUSED)\n+{\n+  gfc_set_sym_referenced (expr->symtree->n.sym);\n+  return false;\n+}\n+\n+void\n+gfc_expr_set_symbols_referenced (gfc_expr *expr)\n+{\n+  gfc_traverse_expr (expr, NULL, expr_set_symbols_referenced, 0);\n }"}, {"sha": "bc8fad67ee8e1b0cb235014023c003cf86aa9670", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "patch": "@@ -2233,6 +2233,9 @@ try gfc_check_assign_symbol (gfc_symbol *, gfc_expr *);\n gfc_expr *gfc_default_initializer (gfc_typespec *);\n gfc_expr *gfc_get_variable_expr (gfc_symtree *);\n \n+bool gfc_traverse_expr (gfc_expr *, gfc_symbol *,\n+\t\t\tbool (*)(gfc_expr *, gfc_symbol *, int*),\n+\t\t\tint);\n void gfc_expr_set_symbols_referenced (gfc_expr *);\n \n /* st.c */\n@@ -2252,6 +2255,7 @@ int gfc_impure_variable (gfc_symbol *);\n int gfc_pure (gfc_symbol *);\n int gfc_elemental (gfc_symbol *);\n try gfc_resolve_iterator (gfc_iterator *, bool);\n+try find_forall_index (gfc_expr *, gfc_symbol *, int);\n try gfc_resolve_index (gfc_expr *, int);\n try gfc_resolve_dim_arg (gfc_expr *);\n int gfc_is_formal_arg (void);"}, {"sha": "69d2c5179b2ab080e937049f7b1767508def7dcf", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 29, "deletions": 121, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "patch": "@@ -4322,131 +4322,39 @@ gfc_resolve_iterator (gfc_iterator *iter, bool real_ok)\n }\n \n \n-/* Check whether the FORALL index appears in the expression or not.\n-   Returns SUCCESS if SYM is found in EXPR.  */\n+/* Traversal function for find_forall_index.  f == 2 signals that\n+   that variable itself is not to be checked - only the references.  */\n \n-static try\n-find_forall_index (gfc_expr *expr, gfc_symbol *symbol)\n+static bool\n+forall_index (gfc_expr *expr, gfc_symbol *sym, int *f)\n {\n-  gfc_array_ref ar;\n-  gfc_ref *tmp;\n-  gfc_actual_arglist *args;\n-  int i;\n+  gcc_assert (expr->expr_type == EXPR_VARIABLE);\n \n-  if (!expr)\n-    return FAILURE;\n-\n-  switch (expr->expr_type)\n+  /* A scalar assignment  */\n+  if (!expr->ref || *f == 1)\n     {\n-    case EXPR_VARIABLE:\n-      gcc_assert (expr->symtree->n.sym);\n-\n-      /* A scalar assignment  */\n-      if (!expr->ref)\n-\t{\n-\t  if (expr->symtree->n.sym == symbol)\n-\t    return SUCCESS;\n-\t  else\n-\t    return FAILURE;\n-\t}\n-\n-      /* the expr is array ref, substring or struct component.  */\n-      tmp = expr->ref;\n-      while (tmp != NULL)\n-\t{\n-\t  switch (tmp->type)\n-\t    {\n-\t    case  REF_ARRAY:\n-\t      /* Check if the symbol appears in the array subscript.  */\n-\t      ar = tmp->u.ar;\n-\t      for (i = 0; i < GFC_MAX_DIMENSIONS; i++)\n-\t\t{\n-\t\t  if (ar.start[i])\n-\t\t    if (find_forall_index (ar.start[i], symbol) == SUCCESS)\n-\t\t      return SUCCESS;\n-\n-\t\t  if (ar.end[i])\n-\t\t    if (find_forall_index (ar.end[i], symbol) == SUCCESS)\n-\t\t      return SUCCESS;\n-\n-\t\t  if (ar.stride[i])\n-\t\t    if (find_forall_index (ar.stride[i], symbol) == SUCCESS)\n-\t\t      return SUCCESS;\n-\t\t}  /* end for  */\n-\t      break;\n-\n-\t    case REF_SUBSTRING:\n-\t      if (expr->symtree->n.sym == symbol)\n-\t\treturn SUCCESS;\n-\t      tmp = expr->ref;\n-\t      /* Check if the symbol appears in the substring section.  */\n-\t      if (find_forall_index (tmp->u.ss.start, symbol) == SUCCESS)\n-\t\treturn SUCCESS;\n-\t      if (find_forall_index (tmp->u.ss.end, symbol) == SUCCESS)\n-\t\treturn SUCCESS;\n-\t      break;\n-\n-\t    case REF_COMPONENT:\n-\t      break;\n-\n-\t    default:\n-\t      gfc_error(\"expression reference type error at %L\", &expr->where);\n-\t    }\n-\t  tmp = tmp->next;\n-\t}\n-      break;\n-\n-    /* If the expression is a function call, then check if the symbol\n-       appears in the actual arglist of the function.  */\n-    case EXPR_FUNCTION:\n-      for (args = expr->value.function.actual; args; args = args->next)\n-\t{\n-\t  if (find_forall_index(args->expr,symbol) == SUCCESS)\n-\t    return SUCCESS;\n-\t}\n-      break;\n-\n-    /* It seems not to happen.  */\n-    case EXPR_SUBSTRING:\n-      if (expr->ref)\n-\t{\n-\t  tmp = expr->ref;\n-\t  gcc_assert (expr->ref->type == REF_SUBSTRING);\n-\t  if (find_forall_index (tmp->u.ss.start, symbol) == SUCCESS)\n-\t    return SUCCESS;\n-\t  if (find_forall_index (tmp->u.ss.end, symbol) == SUCCESS)\n-\t    return SUCCESS;\n-\t}\n-      break;\n-\n-    /* It seems not to happen.  */\n-    case EXPR_STRUCTURE:\n-    case EXPR_ARRAY:\n-      gfc_error (\"Unsupported statement while finding forall index in \"\n-\t\t \"expression\");\n-      break;\n+      if (expr->symtree->n.sym == sym)\n+\treturn true;\n+      else\n+\treturn false;\n+    }\n \n-    case EXPR_OP:\n-      /* Find the FORALL index in the first operand.  */\n-      if (expr->value.op.op1)\n-\t{\n-\t  if (find_forall_index (expr->value.op.op1, symbol) == SUCCESS)\n-\t    return SUCCESS;\n-\t}\n+  if (*f == 2)\n+    *f = 1;\n+  return false;\n+}\n \n-      /* Find the FORALL index in the second operand.  */\n-      if (expr->value.op.op2)\n-\t{\n-\t  if (find_forall_index (expr->value.op.op2, symbol) == SUCCESS)\n-\t    return SUCCESS;\n-\t}\n-      break;\n \n-    default:\n-      break;\n-    }\n+/* Check whether the FORALL index appears in the expression or not.\n+   Returns SUCCESS if SYM is found in EXPR.  */\n \n-  return FAILURE;\n+try\n+find_forall_index (gfc_expr *expr, gfc_symbol *sym, int f)\n+{\n+  if (gfc_traverse_expr (expr, sym, forall_index, f))\n+    return SUCCESS;\n+  else\n+    return FAILURE;\n }\n \n \n@@ -4502,11 +4410,11 @@ resolve_forall_iterators (gfc_forall_iterator *it)\n     for (iter2 = iter; iter2; iter2 = iter2->next)\n       {\n \tif (find_forall_index (iter2->start,\n-\t\t\t       iter->var->symtree->n.sym) == SUCCESS\n+\t\t\t       iter->var->symtree->n.sym, 0) == SUCCESS\n \t    || find_forall_index (iter2->end,\n-\t\t\t\t  iter->var->symtree->n.sym) == SUCCESS\n+\t\t\t\t  iter->var->symtree->n.sym, 0) == SUCCESS\n \t    || find_forall_index (iter2->stride,\n-\t\t\t\t  iter->var->symtree->n.sym) == SUCCESS)\n+\t\t\t\t  iter->var->symtree->n.sym, 0) == SUCCESS)\n \t  gfc_error (\"FORALL index '%s' may not appear in triplet \"\n \t\t     \"specification at %L\", iter->var->symtree->name,\n \t\t     &iter2->start->where);\n@@ -5726,7 +5634,7 @@ gfc_resolve_assign_in_forall (gfc_code *code, int nvar, gfc_expr **var_expr)\n \t  /* If one of the FORALL index variables doesn't appear in the\n \t     assignment target, then there will be a many-to-one\n \t     assignment.  */\n-\t  if (find_forall_index (code->expr, forall_index) == FAILURE)\n+\t  if (find_forall_index (code->expr, forall_index, 0) == FAILURE)\n \t    gfc_error (\"The FORALL with index '%s' cause more than one \"\n \t\t       \"assignment to this object at %L\",\n \t\t       var_expr[n]->symtree->name, &code->expr->where);"}, {"sha": "1c47b24e184ed9d128856e0bb5010a4796e50dda", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "patch": "@@ -3376,6 +3376,13 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n   if (loop->temp_ss != NULL)\n     {\n       gcc_assert (loop->temp_ss->type == GFC_SS_TEMP);\n+\n+      /* Make absolutely sure that this is a complete type.  */\n+      if (loop->temp_ss->string_length)\n+\tloop->temp_ss->data.temp.type\n+\t\t= gfc_get_character_type_len (gfc_default_character_kind,\n+\t\t\t\t\t      loop->temp_ss->string_length);\n+\n       tmp = loop->temp_ss->data.temp.type;\n       len = loop->temp_ss->string_length;\n       n = loop->temp_ss->data.temp.dimen;"}, {"sha": "cbb15a5ce45af4b03b45d9f4ad0c461617d838ee", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 232, "deletions": 5, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "patch": "@@ -1510,6 +1510,205 @@ gfc_trans_select (gfc_code * code)\n }\n \n \n+/* Traversal function to substitute a replacement symtree if the symbol\n+   in the expression is the same as that passed.  f == 2 signals that\n+   that variable itself is not to be checked - only the references.\n+   This group of functions is used when the variable expression in a\n+   FORALL assignment has internal references.  For example:\n+\t\tFORALL (i = 1:4) p(p(i)) = i\n+   The only recourse here is to store a copy of 'p' for the index\n+   expression.  */\n+\n+static gfc_symtree *new_symtree;\n+static gfc_symtree *old_symtree;\n+\n+static bool\n+forall_replace (gfc_expr *expr, gfc_symbol *sym, int *f)\n+{\n+  gcc_assert (expr->expr_type == EXPR_VARIABLE);\n+\n+  if (*f == 2)\n+    *f = 1;\n+  else if (expr->symtree->n.sym == sym)\n+    expr->symtree = new_symtree;\n+\n+  return false;\n+}\n+\n+static void\n+forall_replace_symtree (gfc_expr *e, gfc_symbol *sym, int f)\n+{\n+  gfc_traverse_expr (e, sym, forall_replace, f);\n+}\n+\n+static bool\n+forall_restore (gfc_expr *expr,\n+\t\tgfc_symbol *sym ATTRIBUTE_UNUSED,\n+\t\tint *f ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (expr->expr_type == EXPR_VARIABLE);\n+\n+  if (expr->symtree == new_symtree)\n+    expr->symtree = old_symtree;\n+\n+  return false;\n+}\n+\n+static void\n+forall_restore_symtree (gfc_expr *e)\n+{\n+  gfc_traverse_expr (e, NULL, forall_restore, 0);\n+}\n+\n+static void\n+forall_make_variable_temp (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n+{\n+  gfc_se tse;\n+  gfc_se rse;\n+  gfc_expr *e;\n+  gfc_symbol *new_sym;\n+  gfc_symbol *old_sym;\n+  gfc_symtree *root;\n+  tree tmp;\n+\n+  /* Build a copy of the lvalue.  */\n+  old_symtree = c->expr->symtree;\n+  old_sym = old_symtree->n.sym;\n+  e = gfc_lval_expr_from_sym (old_sym);\n+  if (old_sym->attr.dimension)\n+    {\n+      gfc_init_se (&tse, NULL);\n+      gfc_conv_subref_array_arg (&tse, e, 0, INTENT_IN);\n+      gfc_add_block_to_block (pre, &tse.pre);\n+      gfc_add_block_to_block (post, &tse.post);\n+      tse.expr = build_fold_indirect_ref (tse.expr);\n+\n+      if (e->ts.type != BT_CHARACTER)\n+\t{\n+\t  /* Use the variable offset for the temporary.  */\n+\t  tmp = gfc_conv_descriptor_offset (tse.expr);\n+\t  gfc_add_modify_expr (pre, tmp,\n+\t\tgfc_conv_array_offset (old_sym->backend_decl));\n+\t}\n+    }\n+  else\n+    {\n+      gfc_init_se (&tse, NULL);\n+      gfc_init_se (&rse, NULL);\n+      gfc_conv_expr (&rse, e);\n+      if (e->ts.type == BT_CHARACTER)\n+\t{\n+\t  tse.string_length = rse.string_length;\n+\t  tmp = gfc_get_character_type_len (gfc_default_character_kind,\n+\t\t\t\t\t    tse.string_length);\n+\t  tse.expr = gfc_conv_string_tmp (&tse, build_pointer_type (tmp),\n+\t\t\t\t\t  rse.string_length);\n+\t  gfc_add_block_to_block (pre, &tse.pre);\n+\t  gfc_add_block_to_block (post, &tse.post);\n+\t}\n+      else\n+\t{\n+\t  tmp = gfc_typenode_for_spec (&e->ts);\n+\t  tse.expr = gfc_create_var (tmp, \"temp\");\n+\t}\n+\n+      tmp = gfc_trans_scalar_assign (&tse, &rse, e->ts, true,\n+\t\t\t\t     e->expr_type == EXPR_VARIABLE);\n+      gfc_add_expr_to_block (pre, tmp);\n+    }\n+  gfc_free_expr (e);\n+\n+  /* Create a new symbol to represent the lvalue.  */\n+  new_sym = gfc_new_symbol (old_sym->name, NULL);\n+  new_sym->ts = old_sym->ts;\n+  new_sym->attr.referenced = 1;\n+  new_sym->attr.dimension = old_sym->attr.dimension;\n+  new_sym->attr.flavor = old_sym->attr.flavor;\n+\n+  /* Use the temporary as the backend_decl.  */\n+  new_sym->backend_decl = tse.expr;\n+\n+  /* Create a fake symtree for it.  */\n+  root = NULL;\n+  new_symtree = gfc_new_symtree (&root, old_sym->name);\n+  new_symtree->n.sym = new_sym;\n+  gcc_assert (new_symtree == root);\n+\n+  /* Go through the expression reference replacing the old_symtree\n+     with the new.  */\n+  forall_replace_symtree (c->expr, old_sym, 2);\n+\n+  /* Now we have made this temporary, we might as well use it for\n+  the right hand side.  */\n+  forall_replace_symtree (c->expr2, old_sym, 1);\n+}\n+\n+\n+/* Handles dependencies in forall assignments.  */\n+static int\n+check_forall_dependencies (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n+{\n+  gfc_ref *lref;\n+  gfc_ref *rref;\n+  int need_temp;\n+  gfc_symbol *lsym;\n+\n+  lsym = c->expr->symtree->n.sym;\n+  need_temp = gfc_check_dependency (c->expr, c->expr2, 0);\n+\n+  /* Now check for dependencies within the 'variable'\n+     expression itself.  These are treated by making a complete\n+     copy of variable and changing all the references to it\n+     point to the copy instead.  Note that the shallow copy of\n+     the variable will not suffice for derived types with\n+     pointer components.  We therefore leave these to their\n+     own devices.  */\n+  if (lsym->ts.type == BT_DERIVED\n+\t&& lsym->ts.derived->attr.pointer_comp)\n+    return need_temp;\n+\n+  new_symtree = NULL;\n+  if (find_forall_index (c->expr, lsym, 2) == SUCCESS)\n+    {\n+      forall_make_variable_temp (c, pre, post);\n+      need_temp = 0;\n+    }\n+\n+  /* Substrings with dependencies are treated in the same\n+     way.  */\n+  if (c->expr->ts.type == BT_CHARACTER\n+\t&& c->expr->ref\n+\t&& c->expr2->expr_type == EXPR_VARIABLE\n+\t&& lsym == c->expr2->symtree->n.sym)\n+    {\n+      for (lref = c->expr->ref; lref; lref = lref->next)\n+\tif (lref->type == REF_SUBSTRING)\n+\t  break;\n+      for (rref = c->expr2->ref; rref; rref = rref->next)\n+\tif (rref->type == REF_SUBSTRING)\n+\t  break;\n+\n+      if (rref && lref\n+\t    && gfc_dep_compare_expr (rref->u.ss.start, lref->u.ss.start) < 0)\n+\t{\n+\t  forall_make_variable_temp (c, pre, post);\n+\t  need_temp = 0;\n+\t}\n+    }\n+  return need_temp;\n+}\n+\n+\n+static void\n+cleanup_forall_symtrees (gfc_code *c)\n+{\n+  forall_restore_symtree (c->expr);\n+  forall_restore_symtree (c->expr2);\n+  gfc_free (new_symtree->n.sym);\n+  gfc_free (new_symtree);\n+}\n+\n+\n /* Generate the loops for a FORALL block, specified by FORALL_TMP.  BODY\n    is the contents of the FORALL block/stmt to be iterated.  MASK_FLAG\n    indicates whether we should generate code to test the FORALLs mask\n@@ -2172,7 +2371,20 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \t\t\t\t\t&lss, &rss);\n \n   /* The type of LHS. Used in function allocate_temp_for_forall_nest */\n-  type = gfc_typenode_for_spec (&expr1->ts);\n+  if (expr1->ts.type == BT_CHARACTER && expr1->ts.cl->length)\n+    {\n+      if (!expr1->ts.cl->backend_decl)\n+\t{\n+\t  gfc_se tse;\n+\t  gfc_init_se (&tse, NULL);\n+\t  gfc_conv_expr (&tse, expr1->ts.cl->length);\n+\t  expr1->ts.cl->backend_decl = tse.expr;\n+\t}\n+      type = gfc_get_character_type_len (gfc_default_character_kind,\n+\t\t\t\t         expr1->ts.cl->backend_decl);\n+    }\n+  else\n+    type = gfc_typenode_for_spec (&expr1->ts);\n \n   /* Allocate temporary for nested forall construct according to the\n      information in nested_forall_info and inner_size.  */\n@@ -2412,6 +2624,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n static tree\n gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n {\n+  stmtblock_t pre;\n+  stmtblock_t post;\n   stmtblock_t block;\n   stmtblock_t body;\n   tree *var;\n@@ -2459,7 +2673,9 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   /* Allocate the space for info.  */\n   info = (forall_info *) gfc_getmem (sizeof (forall_info));\n \n-  gfc_start_block (&block);\n+  gfc_start_block (&pre);\n+  gfc_init_block (&post);\n+  gfc_init_block (&block);\n \n   n = 0;\n   for (fa = code->ext.forall_iterator; fa; fa = fa->next)\n@@ -2619,8 +2835,11 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       switch (c->op)\n \t{\n \tcase EXEC_ASSIGN:\n-          /* A scalar or array assignment.  */\n-\t  need_temp = gfc_check_dependency (c->expr, c->expr2, 0);\n+          /* A scalar or array assignment.  DO the simple check for\n+\t     lhs to rhs dependencies.  These make a temporary for the\n+\t     rhs and form a second forall block to copy to variable.  */\n+\t  need_temp = check_forall_dependencies(c, &pre, &post);\n+\n           /* Temporaries due to array assignment data dependencies introduce\n              no end of problems.  */\n \t  if (need_temp)\n@@ -2637,6 +2856,11 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n               gfc_add_expr_to_block (&block, tmp);\n             }\n \n+\t  /* Cleanup any temporary symtrees that have been made to deal\n+\t     with dependencies.  */\n+\t  if (new_symtree)\n+\t    cleanup_forall_symtrees (c);\n+\n \t  break;\n \n         case EXEC_WHERE:\n@@ -2706,7 +2930,10 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   if (maskindex)\n     pushdecl (maskindex);\n \n-  return gfc_finish_block (&block);\n+  gfc_add_block_to_block (&pre, &block);\n+  gfc_add_block_to_block (&pre, &post);\n+\n+  return gfc_finish_block (&pre);\n }\n \n "}, {"sha": "5c533f3da859c7a89715381427a9f523ea6c7117", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "patch": "@@ -1,3 +1,12 @@\n+2007-10-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31217\n+\tPR fortran/33811\n+\t* gfortran.dg/forall_12.f90: New test.\n+\n+\tPR fortran/33686\n+\t* gfortran.dg/forall_13.f90: New test.\n+\n 2007-10-28  Paolo Carlini  <pcarlini@suse.de>\n \t    Mark Mitchell  <mark@codesourcery.com>\n "}, {"sha": "207977c51440356f07408ada7517f417da87dd1c", "filename": "gcc/testsuite/gfortran.dg/forall_12.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_12.f90?ref=640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+! Tests the fix for PR31217 and PR33811 , in which dependencies were not\n+! correctly handled for the assignments below and, when this was fixed,\n+! the last two ICEd on trying to create the temorary.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!              Dominique d'Humieres <dominiq@lps.ens.fr>\n+!                   and Paul Thomas <pault@gcc.gnu.org>\n+!\n+  character(len=1) :: a = \"1\"\n+  character(len=1) :: b(4) = (/\"1\",\"2\",\"3\",\"4\"/), c(4)\n+  c = b\n+  forall(i=1:1) a(i:i) = a(i:i)         ! This was the original PR31217\n+  forall(i=1:1) b(i:i) = b(i:i)         ! The rest were found to be broken\n+  forall(i=1:1) b(:)(i:i) = b(:)(i:i)\n+  forall(i=1:1) b(1:3)(i:i) = b(2:4)(i:i)\n+  if (any (b .ne. (/\"2\",\"3\",\"4\",\"4\"/))) call abort ()\n+  b = c\n+  forall(i=1:1) b(2:4)(i:i) = b(1:3)(i:i)\n+  if (any (b .ne. (/\"1\",\"1\",\"2\",\"3\"/))) call abort ()\n+  b = c\n+  do i = 1, 1\n+    b(2:4)(i:i) = b(1:3)(i:i)           ! This was PR33811 and Paul's bit\n+  end do\n+  if (any (b .ne. (/\"1\",\"1\",\"2\",\"3\"/))) call abort ()\n+  call foo\n+contains\n+  subroutine foo\n+    character(LEN=12) :: a(2) = \"123456789012\"\n+    character(LEN=12) :: b = \"123456789012\"\n+! These are Dominique's\n+    forall (i = 3:10) a(:)(i:i+2) = a(:)(i-2:i)\n+    IF (a(1) .ne. \"121234567890\") CALL abort ()\n+    forall (i = 3:10) a(2)(i:i+2) = a(1)(i-2:i)\n+    IF (a(2) .ne. \"121212345678\") call abort ()\n+    forall (i = 3:10) b(i:i+2) = b(i-2:i)\n+    IF (b .ne. \"121234567890\") CALL abort ()\n+  end subroutine\n+end\n+"}, {"sha": "97f6062bd55a86db93e2d77da04f0980afe1ff00", "filename": "gcc/testsuite/gfortran.dg/forall_13.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_13.f90?ref=640670c7f4ec13d4ef3aab73f7b7ea7eb05b7a9d", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! Tests the fix for PR33686, in which dependencies were not\n+! correctly handled for the assignments below.\n+!\n+! Contributed by Dick Hendrickson on comp.lang.fortran,\n+! \" Most elegant syntax for inverting a permutation?\" 20071006\n+!\n+  integer :: p(4) = (/2,4,1,3/)\n+  forall (i = 1:4) p(p(i)) = i                ! This was the original\n+  if (any (p .ne. (/3,1,4,2/))) call abort ()\n+\n+  forall (i = 1:4) p(5 - p(i)) = p(5 - i)     ! This is a more complicated version\n+  if (any (p .ne. (/1,2,3,4/))) call abort ()\n+end"}]}