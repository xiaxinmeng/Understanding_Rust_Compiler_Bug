{"sha": "56f9e2595ddbcf507de6bf68c3fbadad0a6f18a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZmOWUyNTk1ZGRiY2Y1MDdkZTZiZjY4YzNmYmFkYWQwYTZmMThhMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-19T21:07:14Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-19T21:07:14Z"}, "message": "(HARD_REGNO_MODE_OK): Allow any mode in general regs.\n\nFloat regs may only hold SFmode and DFmode.\n(FUNCTION_ARG): Only MODE_INT and MODE_FLOAT with size <= 8 are\npassed in registers.\n(FUNCTION_ARG_ADVANCE): Update accordingly.\n(FUNCTION_ARG_PARTIAL_NREG): Undefine.\n\nFrom-SVN: r6114", "tree": {"sha": "74692523acc7c1c797c5ead8a5f81c139f43959a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74692523acc7c1c797c5ead8a5f81c139f43959a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56f9e2595ddbcf507de6bf68c3fbadad0a6f18a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56f9e2595ddbcf507de6bf68c3fbadad0a6f18a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56f9e2595ddbcf507de6bf68c3fbadad0a6f18a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56f9e2595ddbcf507de6bf68c3fbadad0a6f18a0/comments", "author": null, "committer": null, "parents": [{"sha": "e5c1a9d28f9681d28ff08e0c1683a8c5a36458fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c1a9d28f9681d28ff08e0c1683a8c5a36458fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5c1a9d28f9681d28ff08e0c1683a8c5a36458fa"}], "stats": {"total": 78, "additions": 47, "deletions": 31}, "files": [{"sha": "b24c3d4fb78c490c1943a728fee0d67f285ef80e", "filename": "gcc/config/clipper/clipper.h", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f9e2595ddbcf507de6bf68c3fbadad0a6f18a0/gcc%2Fconfig%2Fclipper%2Fclipper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f9e2595ddbcf507de6bf68c3fbadad0a6f18a0/gcc%2Fconfig%2Fclipper%2Fclipper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.h?ref=56f9e2595ddbcf507de6bf68c3fbadad0a6f18a0", "patch": "@@ -196,6 +196,7 @@ extern int target_flags;\n    variables `fixed_regs' and `call_used_regs' (both of type `char\n    []') after they have been initialized from the two preceding\n    macros. A C400 has additional floating registers f8 -> f15 */\n+\n #define CONDITIONAL_REGISTER_USAGE\t\\\n    if (target_flags & TARGET_C400)\t\\\n      { int i;\t\t\t\t\\\n@@ -211,15 +212,14 @@ extern int target_flags;\n   ((REGNO) >= 16 ? 1 \\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the clipper, 0-15 hold int, 16-31 hold float. DImode regs must be\n-   even */\n+   On the clipper 0-15 may hold any mode but DImode and DFmode must be even.\n+   Registers 16-31 hold SFmode and DFmode */\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n-  ((GET_MODE_CLASS(MODE) == MODE_FLOAT)\t\t\\\n-   ? (REGNO) >= 16\t\t\t\t\\\n-   : (REGNO) < 16 && ((MODE) !=DImode || ((REGNO) & 1) == 0))\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n+  ((REGNO) < 16 \t\t\t\t\t\t\t\\\n+   ? ((MODE) != DImode && (MODE) != DFmode || ((REGNO) & 1) == 0)\t\\\n+   : ((MODE) == SFmode || (MODE) == DFmode))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -482,20 +482,30 @@ struct _clipper_cum_args { int num; int size; };\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if ((CUM).num == 0 && (MODE) == DImode)\t\t\t\t\\\n-    (CUM).num = 2;\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    (CUM).num++;       \t\t\t\t\t\t\t\\\n-  if ((CUM).num > 2 || (MODE) == BLKmode)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int align = FUNCTION_ARG_BOUNDARY (MODE, TYPE) / BITS_PER_UNIT;\t\\\n-      (CUM).size += align - 1;\t\t\t\t\t\t\\\n-      (CUM).size &= align - 1;\t\t\t\t\t\t\\\n-      (CUM).size += CLIPPER_ARG_SIZE (MODE, TYPE);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t      \\\n+do\t\t\t\t\t\t\t\t\t      \\\n+{\t\t\t\t\t\t\t\t\t      \\\n+  int reg = 0;\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+  if ((CUM).num < 2\t\t\t\t\t\t\t      \\\n+      && (GET_MODE_CLASS(MODE)==MODE_INT || GET_MODE_CLASS(MODE)==MODE_FLOAT) \\\n+      && (GET_MODE_SIZE (MODE) <= 8)\t\t\t\t\t      \\\n+      && ((MODE) != DImode || (CUM).num == 0))\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      reg = 1;\t\t\t\t\t\t\t\t      \\\n+      if ((MODE) == DImode)\t\t\t\t\t\t      \\\n+\t(CUM).num = 1;\t\t\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+  (CUM).num++;\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+  if (! reg)\t\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      int align = FUNCTION_ARG_BOUNDARY (MODE, TYPE) / BITS_PER_UNIT;\t      \\\n+      (CUM).size += align - 1;\t\t\t\t\t\t      \\\n+      (CUM).size &= align - 1;\t\t\t\t\t\t      \\\n+      (CUM).size += CLIPPER_ARG_SIZE (MODE, TYPE);\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n } while (0)\n \n /* Define where to put the arguments to a function.\n@@ -509,15 +519,20 @@ do\t\t\t\t\t\t\t\t\t\\\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n    NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n+    (otherwise it is an extra parameter matching an ellipsis).\n \n-/* 2 args go into regs, float in f0/f1, anything else in r0/r1 */\n+   2 args may go into regs. These must be MODE_INT or MODE_FLOAT but only\n+   if they really fit into ONE register. The exception is a DImode arg\n+   that occupies both register slots. */\n \n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n-  (((CUM).num >= 2 || (MODE) == BLKmode || \t\\\n-    ((MODE) == DImode && (CUM).num)) ? 0 :\t\\\n-   gen_rtx (REG, (MODE),\t\t\t\t\t\\\n-\t    GET_MODE_CLASS(MODE) == MODE_FLOAT ? (CUM).num+16 : (CUM).num))\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t     \\\n+  (((CUM).num < 2\t\t\t\t\t\t\t     \\\n+    && (GET_MODE_CLASS(MODE)==MODE_INT || GET_MODE_CLASS(MODE)==MODE_FLOAT)  \\\n+    && (GET_MODE_SIZE (MODE) <= 8)\t\t\t\t\t     \\\n+    && ((MODE) != DImode || (CUM).num == 0))\t\t\t\t     \\\n+   ? gen_rtx (REG, (MODE),\t\t\t\t\t\t     \\\n+\t      GET_MODE_CLASS(MODE) == MODE_FLOAT ? (CUM).num+16 : (CUM).num) \\\n+   : 0)\n \n /* If defined, a C expression that gives the alignment boundary, in bits,\n    of an argument with the specified mode and type.  If it is not defined,\n@@ -529,14 +544,15 @@ do\t\t\t\t\t\t\t\t\t\\\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n+   For args passed entirely in registers or entirely in memory, zero.\n+   Clipper never passed args partially in regs/mem. */\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)  0\n+/* #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)  0 */\n \n /* Generate necessary RTL for __builtin_saveregs().\n    ARGLIST is the argument list; see expr.c.  */\n-#define EXPAND_BUILTIN_SAVEREGS(ARGLIST) clipper_builtin_saveregs (ARGLIST)\n \n+#define EXPAND_BUILTIN_SAVEREGS(ARGLIST) clipper_builtin_saveregs (ARGLIST)\n \n /* This macro generates the assembly code for function entry.\n    FILE is a stdio stream to output the code to."}]}