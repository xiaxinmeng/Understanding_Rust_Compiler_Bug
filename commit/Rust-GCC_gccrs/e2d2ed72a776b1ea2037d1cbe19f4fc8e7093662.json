{"sha": "e2d2ed72a776b1ea2037d1cbe19f4fc8e7093662", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJkMmVkNzJhNzc2YjFlYTIwMzdkMWNiZTE5ZjRmYzhlNzA5MzY2Mg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2001-04-09T15:20:26Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2001-04-09T15:20:26Z"}, "message": "gcse.c (oprs_unchanged_p): Pass basic_block to load_killed_in_block_p.\n\n2001-04-09  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* gcse.c (oprs_unchanged_p): Pass basic_block to load_killed_in_block_p.\n\t(load_killed_in_block_p): Change bb parameter from int to basic_block.\n\t(oprs_not_set_p): Pass basic_blocks instead of ints as parameters.\n\t(handle_rd_kill_set): Change bb parameter from int to basic_block.\n\t(compute_kill_rd): Pass basic_blocks instead of ints as parameters.\n\t(expr_killed_p): Change bb parameter from int to basic_block, pass\n\tbasic_blocks instead of ints as parameters.\n\t(compute_ae_kill): Pass basic_blocks instead of ints as parameters.\n\t(expr_reaches_here_p_work, expr_reaches_here_p): Change bb parameter\n\tfrom int to basic_block, pass basic_blocks instead of ints as parms.\n\t(pre_expr_reaches_here_p_work, pre_expr_reaches_here_p): Change bb\n\tparameter from int to basic_block, pass basic_blocks instead of ints.\n\t(process_insert_insn): Pass basic_blocks instead of ints as parameters.\n\t(insert_insn_end_bb): Change bb parameter from int to basic_block,\n\tpass basic_blocks instead of ints.\n\t(pre_edge_insert, pre_insert_copy_insn, pre_insert_copies): Pass\n\tbasic_blocks instead of ints as parameters.\n\t(pre_delete): Pass basic_blocks instead of ints as parameters.\n\t(hoist_expr_reaches_here_p): Change bb parameter from int to\n\tbasic_block, pass basic_blocks instead of ints.\n\t(hoist_code): Pass basic_blocks instead of ints as parameters.\n\t(reg_set_info, store_ops_ok, store_killed_after, store_killed_before):\n\tChange bb parameter from int to basic_block.\n\t(build_store_vectors): Pass basic_blocks instead of ints as parameters.\n\t(insert_insn_start_bb): Change bb parameter from int to basic_block,\n\tpass basic_blocks instead of ints.\n\t(insert_store): Pass basic_blocks instead of ints as parameters.\n\t(replace_store_insn, delete_store): Change bb parameter from int to\n\tbasic_block, pass basic_blocks instead of ints.\n\t(store_motion): Pass basic_blocks instead of ints as parameters.\n\nFrom-SVN: r41209", "tree": {"sha": "6dd48c551b0810a2658142415205aa028567aed5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dd48c551b0810a2658142415205aa028567aed5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2d2ed72a776b1ea2037d1cbe19f4fc8e7093662", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2d2ed72a776b1ea2037d1cbe19f4fc8e7093662", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2d2ed72a776b1ea2037d1cbe19f4fc8e7093662", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2d2ed72a776b1ea2037d1cbe19f4fc8e7093662/comments", "author": null, "committer": null, "parents": [{"sha": "ccbaf064ff496fbf0ace8bf2b38a3047b4ad497b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccbaf064ff496fbf0ace8bf2b38a3047b4ad497b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccbaf064ff496fbf0ace8bf2b38a3047b4ad497b"}], "stats": {"total": 300, "additions": 171, "deletions": 129}, "files": [{"sha": "c25f0eedddb0ea1f2d4b851a3fb185956dcf3fd2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d2ed72a776b1ea2037d1cbe19f4fc8e7093662/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d2ed72a776b1ea2037d1cbe19f4fc8e7093662/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2d2ed72a776b1ea2037d1cbe19f4fc8e7093662", "patch": "@@ -1,3 +1,36 @@\n+2001-04-09  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* gcse.c (oprs_unchanged_p): Pass basic_block to load_killed_in_block_p.\n+\t(load_killed_in_block_p): Change bb parameter from int to basic_block.\n+\t(oprs_not_set_p): Pass basic_blocks instead of ints as parameters.\n+\t(handle_rd_kill_set): Change bb parameter from int to basic_block.\n+\t(compute_kill_rd): Pass basic_blocks instead of ints as parameters.\n+\t(expr_killed_p): Change bb parameter from int to basic_block, pass \n+\tbasic_blocks instead of ints as parameters.\n+\t(compute_ae_kill): Pass basic_blocks instead of ints as parameters.\n+\t(expr_reaches_here_p_work, expr_reaches_here_p): Change bb parameter \n+\tfrom int to basic_block, pass basic_blocks instead of ints as parms.\n+\t(pre_expr_reaches_here_p_work, pre_expr_reaches_here_p): Change bb \n+\tparameter from int to basic_block, pass basic_blocks instead of ints.\n+\t(process_insert_insn): Pass basic_blocks instead of ints as parameters.\n+\t(insert_insn_end_bb): Change bb parameter from int to basic_block, \n+\tpass basic_blocks instead of ints.\n+\t(pre_edge_insert, pre_insert_copy_insn, pre_insert_copies): Pass \n+\tbasic_blocks instead of ints as parameters.\n+\t(pre_delete): Pass basic_blocks instead of ints as parameters.\n+\t(hoist_expr_reaches_here_p): Change bb parameter from int to \n+\tbasic_block, pass basic_blocks instead of ints.\n+\t(hoist_code): Pass basic_blocks instead of ints as parameters.\n+\t(reg_set_info, store_ops_ok, store_killed_after, store_killed_before): \n+\tChange bb parameter from int to basic_block.\n+\t(build_store_vectors): Pass basic_blocks instead of ints as parameters.\n+\t(insert_insn_start_bb): Change bb parameter from int to basic_block, \n+\tpass basic_blocks instead of ints.\n+\t(insert_store): Pass basic_blocks instead of ints as parameters.\n+\t(replace_store_insn, delete_store): Change bb parameter from int to \n+\tbasic_block, pass basic_blocks instead of ints.\n+\t(store_motion): Pass basic_blocks instead of ints as parameters.\n+\n 2001-04-09  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* basic-block.h (set_new_block_for_insns): New Prototype."}, {"sha": "7f4b3069f43007a44015c13207482f4fbe019683", "filename": "gcc/gcse.c", "status": "modified", "additions": 138, "deletions": 129, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d2ed72a776b1ea2037d1cbe19f4fc8e7093662/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d2ed72a776b1ea2037d1cbe19f4fc8e7093662/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e2d2ed72a776b1ea2037d1cbe19f4fc8e7093662", "patch": "@@ -623,16 +623,17 @@ static int cprop_jump\t\tPARAMS ((rtx, rtx, rtx));\n static int cprop_cc0_jump\tPARAMS ((rtx, struct reg_use *, rtx));\n #endif\n static void mems_conflict_for_gcse_p PARAMS ((rtx, rtx, void *));\n-static int load_killed_in_block_p    PARAMS ((int, int, rtx, int));\n+static int load_killed_in_block_p    PARAMS ((basic_block, int, rtx, int));\n static void canon_list_insert        PARAMS ((rtx, rtx, void *));\n static int cprop_insn\t\tPARAMS ((rtx, int));\n static int cprop\t\tPARAMS ((int));\n static int one_cprop_pass\tPARAMS ((int, int));\n static void alloc_pre_mem\tPARAMS ((int, int));\n static void free_pre_mem\tPARAMS ((void));\n static void compute_pre_data\tPARAMS ((void));\n-static int pre_expr_reaches_here_p PARAMS ((int, struct expr *, int));\n-static void insert_insn_end_bb\tPARAMS ((struct expr *, int, int));\n+static int pre_expr_reaches_here_p PARAMS ((basic_block, struct expr *, \n+\t\t\t\t\t    basic_block));\n+static void insert_insn_end_bb\tPARAMS ((struct expr *, basic_block, int));\n static void pre_insert_copy_insn PARAMS ((struct expr *, rtx));\n static void pre_insert_copies\tPARAMS ((void));\n static int pre_delete\t\tPARAMS ((void));\n@@ -643,21 +644,22 @@ static void alloc_code_hoist_mem PARAMS ((int, int));\n static void free_code_hoist_mem\tPARAMS ((void));\n static void compute_code_hoist_vbeinout\tPARAMS ((void));\n static void compute_code_hoist_data PARAMS ((void));\n-static int hoist_expr_reaches_here_p PARAMS ((int, int, int, char *));\n+static int hoist_expr_reaches_here_p PARAMS ((basic_block, int, basic_block, \n+\t\t\t\t\t      char *));\n static void hoist_code\t\tPARAMS ((void));\n static int one_code_hoisting_pass PARAMS ((void));\n static void alloc_rd_mem\tPARAMS ((int, int));\n static void free_rd_mem\t\tPARAMS ((void));\n-static void handle_rd_kill_set\tPARAMS ((rtx, int, int));\n+static void handle_rd_kill_set\tPARAMS ((rtx, int, basic_block));\n static void compute_kill_rd\tPARAMS ((void));\n static void compute_rd\t\tPARAMS ((void));\n static void alloc_avail_expr_mem PARAMS ((int, int));\n static void free_avail_expr_mem PARAMS ((void));\n static void compute_ae_gen\tPARAMS ((void));\n-static int expr_killed_p\tPARAMS ((rtx, int));\n+static int expr_killed_p\tPARAMS ((rtx, basic_block));\n static void compute_ae_kill\tPARAMS ((sbitmap *, sbitmap *));\n static int expr_reaches_here_p\tPARAMS ((struct occr *, struct expr *,\n-\t\t\t\t\t int, int));\n+\t\t\t\t\t basic_block, int));\n static rtx computing_insn\tPARAMS ((struct expr *, rtx));\n static int def_reaches_here_p\tPARAMS ((rtx, rtx));\n static int can_disregard_other_sets PARAMS ((struct reg_set **, rtx, int));\n@@ -671,9 +673,9 @@ static void delete_null_pointer_checks_1 PARAMS ((varray_type *, unsigned int *,\n static rtx process_insert_insn\tPARAMS ((struct expr *));\n static int pre_edge_insert\tPARAMS ((struct edge_list *, struct expr **));\n static int expr_reaches_here_p_work PARAMS ((struct occr *, struct expr *,\n-\t\t\t\t\t     int, int, char *));\n-static int pre_expr_reaches_here_p_work\tPARAMS ((int, struct expr *,\n-\t\t\t\t\t\t int, char *));\n+\t\t\t\t\t     basic_block, int, char *));\n+static int pre_expr_reaches_here_p_work\tPARAMS ((basic_block, struct expr *,\n+\t\t\t\t\t\t basic_block, char *));\n static struct ls_expr * ldst_entry \tPARAMS ((rtx));\n static void free_ldst_entry \t\tPARAMS ((struct ls_expr *));\n static void free_ldst_mems\t\tPARAMS ((void));\n@@ -688,19 +690,20 @@ static void compute_ld_motion_mems\tPARAMS ((void));\n static void trim_ld_motion_mems\t\tPARAMS ((void));\n static void update_ld_motion_stores\tPARAMS ((struct expr *));\n static void reg_set_info\t\tPARAMS ((rtx, rtx, void *));\n-static int store_ops_ok\t\t\tPARAMS ((rtx, int));\n+static int store_ops_ok\t\t\tPARAMS ((rtx, basic_block));\n static void find_moveable_store\t\tPARAMS ((rtx));\n static int compute_store_table\t\tPARAMS ((void));\n static int load_kills_store\t\tPARAMS ((rtx, rtx));\n static int find_loads\t\t\tPARAMS ((rtx, rtx));\n static int store_killed_in_insn\t\tPARAMS ((rtx, rtx));\n-static int store_killed_after\t\tPARAMS ((rtx, rtx, int));\n-static int store_killed_before\t\tPARAMS ((rtx, rtx, int));\n+static int store_killed_after\t\tPARAMS ((rtx, rtx, basic_block));\n+static int store_killed_before\t\tPARAMS ((rtx, rtx, basic_block));\n static void build_store_vectors\t\tPARAMS ((void));\n-static void insert_insn_start_bb\tPARAMS ((rtx, int));\n+static void insert_insn_start_bb\tPARAMS ((rtx, basic_block));\n static int insert_store\t\t\tPARAMS ((struct ls_expr *, edge));\n-static void replace_store_insn\t\tPARAMS ((rtx, rtx, int));\n-static void delete_store\t\tPARAMS ((struct ls_expr *, int));\n+static void replace_store_insn\t\tPARAMS ((rtx, rtx, basic_block));\n+static void delete_store\t\tPARAMS ((struct ls_expr *, \n+\t\t\t\t\t\t basic_block));\n static void free_store_memory\t\tPARAMS ((void));\n static void store_motion\t\tPARAMS ((void));\n \f\n@@ -1392,7 +1395,7 @@ oprs_unchanged_p (x, insn, avail_p)\n \t\t|| reg_first_set[REGNO (x)] >= INSN_CUID (insn));\n \n     case MEM:\n-      if (load_killed_in_block_p (BLOCK_NUM (insn), INSN_CUID (insn),\n+      if (load_killed_in_block_p (BLOCK_FOR_INSN (insn), INSN_CUID (insn),\n \t\t\t\t  x, avail_p))\n \treturn 0;\n       if (avail_p && mem_last_set != NEVER_SET\n@@ -1506,12 +1509,12 @@ mems_conflict_for_gcse_p (dest, setter, data)\n \n static int\n load_killed_in_block_p (bb, uid_limit, x, avail_p)\n-     int bb;\n+     basic_block bb;\n      int uid_limit;\n      rtx x;\n      int avail_p;\n {\n-  rtx list_entry = modify_mem_list[bb];\n+  rtx list_entry = modify_mem_list[bb->index];\n   while (list_entry)\n     {\n       rtx setter;\n@@ -2783,7 +2786,8 @@ oprs_not_set_p (x, insn)\n       return 1;\n \n     case MEM:\n-      if (load_killed_in_block_p (BLOCK_NUM (insn), INSN_CUID (insn), x, 0))\n+      if (load_killed_in_block_p (BLOCK_FOR_INSN (insn), \n+\t\t\t\t  INSN_CUID (insn), x, 0))\n \treturn 0;\n       if (mem_last_set != 0)\n \treturn 0;\n@@ -2948,13 +2952,14 @@ free_rd_mem ()\n static void\n handle_rd_kill_set (insn, regno, bb)\n      rtx insn;\n-     int regno, bb;\n+     int regno;\n+     basic_block bb;\n {\n   struct reg_set *this_reg;\n \n   for (this_reg = reg_set_table[regno]; this_reg; this_reg = this_reg ->next)\n     if (BLOCK_NUM (this_reg->insn) != BLOCK_NUM (insn))\n-      SET_BIT (rd_kill[bb], INSN_CUID (this_reg->insn));\n+      SET_BIT (rd_kill[bb->index], INSN_CUID (this_reg->insn));\n }\n \n /* Compute the set of kill's for reaching definitions.  */\n@@ -2999,7 +3004,7 @@ compute_kill_rd ()\n #endif\n \t\t       && regno != FRAME_POINTER_REGNUM)\n \t\t      || global_regs[regno])\n-\t\t    handle_rd_kill_set (insn, regno, bb);\n+\t\t    handle_rd_kill_set (insn, regno, BASIC_BLOCK (bb));\n \t\t}\n \t    }\n \n@@ -3013,13 +3018,13 @@ compute_kill_rd ()\n \t\t      && GET_CODE (XEXP (XVECEXP (pat, 0, i), 0)) == REG)\n \t\t    handle_rd_kill_set (insn,\n \t\t\t\t\tREGNO (XEXP (XVECEXP (pat, 0, i), 0)),\n-\t\t\t\t\tbb);\n+\t\t\t\t\tBASIC_BLOCK (bb));\n \t\t}\n \t    }\n \t  else if (GET_CODE (pat) == SET && GET_CODE (SET_DEST (pat)) == REG)\n \t    /* Each setting of this register outside of this block\n \t       must be marked in the set of kills in this block.  */\n-\t    handle_rd_kill_set (insn, REGNO (SET_DEST (pat)), bb);\n+\t    handle_rd_kill_set (insn, REGNO (SET_DEST (pat)), BASIC_BLOCK (bb));\n \t}\n }\n \n@@ -3108,7 +3113,7 @@ compute_ae_gen ()\n static int\n expr_killed_p (x, bb)\n      rtx x;\n-     int bb;\n+     basic_block bb;\n {\n   int i, j;\n   enum rtx_code code;\n@@ -3121,12 +3126,12 @@ expr_killed_p (x, bb)\n   switch (code)\n     {\n     case REG:\n-      return TEST_BIT (reg_set_in_block[bb], REGNO (x));\n+      return TEST_BIT (reg_set_in_block[bb->index], REGNO (x));\n \n     case MEM:\n       if (load_killed_in_block_p (bb, get_max_uid () + 1, x, 0))\n \treturn 1;\n-      if (mem_set_in_block[bb])\n+      if (mem_set_in_block[bb->index])\n \treturn 1;\n       else\n \treturn expr_killed_p (XEXP (x, 0), bb);\n@@ -3185,7 +3190,7 @@ compute_ae_kill (ae_gen, ae_kill)\n \t  if (TEST_BIT (ae_gen[bb], expr->bitmap_index))\n \t    continue;\n \n-\t  if (expr_killed_p (expr->expr, bb))\n+\t  if (expr_killed_p (expr->expr, BASIC_BLOCK (bb)))\n \t    SET_BIT (ae_kill[bb], expr->bitmap_index);\n \t}\n }\n@@ -3212,50 +3217,50 @@ static int\n expr_reaches_here_p_work (occr, expr, bb, check_self_loop, visited)\n      struct occr *occr;\n      struct expr *expr;\n-     int bb;\n+     basic_block bb;\n      int check_self_loop;\n      char *visited;\n {\n   edge pred;\n \n-  for (pred = BASIC_BLOCK(bb)->pred; pred != NULL; pred = pred->pred_next)\n+  for (pred = bb->pred; pred != NULL; pred = pred->pred_next)\n     {\n-      int pred_bb = pred->src->index;\n+      basic_block pred_bb = pred->src;\n \n-      if (visited[pred_bb])\n+      if (visited[pred_bb->index])\n \t/* This predecessor has already been visited. Nothing to do.  */\n \t  ;\n       else if (pred_bb == bb)\n \t{\n \t  /* BB loops on itself.  */\n \t  if (check_self_loop\n-\t      && TEST_BIT (ae_gen[pred_bb], expr->bitmap_index)\n-\t      && BLOCK_NUM (occr->insn) == pred_bb)\n+\t      && TEST_BIT (ae_gen[pred_bb->index], expr->bitmap_index)\n+\t      && BLOCK_NUM (occr->insn) == pred_bb->index)\n \t    return 1;\n \n-\t  visited[pred_bb] = 1;\n+\t  visited[pred_bb->index] = 1;\n \t}\n \n       /* Ignore this predecessor if it kills the expression.  */\n-      else if (TEST_BIT (ae_kill[pred_bb], expr->bitmap_index))\n-\tvisited[pred_bb] = 1;\n+      else if (TEST_BIT (ae_kill[pred_bb->index], expr->bitmap_index))\n+\tvisited[pred_bb->index] = 1;\n \n       /* Does this predecessor generate this expression?  */\n-      else if (TEST_BIT (ae_gen[pred_bb], expr->bitmap_index))\n+      else if (TEST_BIT (ae_gen[pred_bb->index], expr->bitmap_index))\n \t{\n \t  /* Is this the occurrence we're looking for?\n \t     Note that there's only one generating occurrence per block\n \t     so we just need to check the block number.  */\n-\t  if (BLOCK_NUM (occr->insn) == pred_bb)\n+\t  if (BLOCK_NUM (occr->insn) == pred_bb->index)\n \t    return 1;\n \n-\t  visited[pred_bb] = 1;\n+\t  visited[pred_bb->index] = 1;\n \t}\n \n       /* Neither gen nor kill.  */\n       else\n \t{\n-\t  visited[pred_bb] = 1;\n+\t  visited[pred_bb->index] = 1;\n \t  if (expr_reaches_here_p_work (occr, expr, pred_bb, check_self_loop, \n \t      visited))\n \n@@ -3274,7 +3279,7 @@ static int\n expr_reaches_here_p (occr, expr, bb, check_self_loop)\n      struct occr *occr;\n      struct expr *expr;\n-     int bb;\n+     basic_block bb;\n      int check_self_loop;\n {\n   int rval;\n@@ -3296,11 +3301,11 @@ computing_insn (expr, insn)\n      struct expr *expr;\n      rtx insn;\n {\n-  int bb = BLOCK_NUM (insn);\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n \n   if (expr->avail_occr->next == NULL)\n     {    \n-      if (BLOCK_NUM (expr->avail_occr->insn) == bb)\n+      if (BLOCK_FOR_INSN (expr->avail_occr->insn) == bb)\n \t/* The available expression is actually itself\n \t   (i.e. a loop in the flow graph) so do nothing.  */\n \treturn NULL;\n@@ -3320,7 +3325,7 @@ computing_insn (expr, insn)\n \n       for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n \t{\n-\t  if (BLOCK_NUM (occr->insn) == bb)\n+\t  if (BLOCK_FOR_INSN (occr->insn) == bb)\n \t    {\n \t      /* The expression is generated in this block.\n \t\t The only time we care about this is when the expression\n@@ -4575,41 +4580,41 @@ compute_pre_data ()\n \n static int\n pre_expr_reaches_here_p_work (occr_bb, expr, bb, visited)\n-     int occr_bb;\n+     basic_block occr_bb;\n      struct expr *expr;\n-     int bb;\n+     basic_block bb;\n      char *visited;\n {\n   edge pred;\n \n-  for (pred = BASIC_BLOCK (bb)->pred; pred != NULL; pred = pred->pred_next)\n+  for (pred = bb->pred; pred != NULL; pred = pred->pred_next)\n     {\n-      int pred_bb = pred->src->index;\n+      basic_block pred_bb = pred->src;\n \n       if (pred->src == ENTRY_BLOCK_PTR\n \t  /* Has predecessor has already been visited?  */\n-\t  || visited[pred_bb])\n+\t  || visited[pred_bb->index])\n \t;/* Nothing to do.  */\n \n       /* Does this predecessor generate this expression?  */\n-      else if (TEST_BIT (comp[pred_bb], expr->bitmap_index))\n+      else if (TEST_BIT (comp[pred_bb->index], expr->bitmap_index))\n \t{\n \t  /* Is this the occurrence we're looking for?\n \t     Note that there's only one generating occurrence per block\n \t     so we just need to check the block number.  */\n \t  if (occr_bb == pred_bb)\n \t    return 1;\n \n-\t  visited[pred_bb] = 1;\n+\t  visited[pred_bb->index] = 1;\n \t}\n       /* Ignore this predecessor if it kills the expression.  */\n-      else if (! TEST_BIT (transp[pred_bb], expr->bitmap_index))\n-\tvisited[pred_bb] = 1;\n+      else if (! TEST_BIT (transp[pred_bb->index], expr->bitmap_index))\n+\tvisited[pred_bb->index] = 1;\n \n       /* Neither gen nor kill.  */\n       else\n \t{\n-\t  visited[pred_bb] = 1;\n+\t  visited[pred_bb->index] = 1;\n \t  if (pre_expr_reaches_here_p_work (occr_bb, expr, pred_bb, visited))\n \t    return 1;\n \t}\n@@ -4624,9 +4629,9 @@ pre_expr_reaches_here_p_work (occr_bb, expr, bb, visited)\n \n static int\n pre_expr_reaches_here_p (occr_bb, expr, bb)\n-     int occr_bb;\n+     basic_block occr_bb;\n      struct expr *expr;\n-     int bb;\n+     basic_block bb;\n {\n   int rval;\n   char *visited = (char *) xcalloc (n_basic_blocks, 1);\n@@ -4680,10 +4685,10 @@ process_insert_insn (expr)\n static void\n insert_insn_end_bb (expr, bb, pre)\n      struct expr *expr;\n-     int bb;\n+     basic_block bb;\n      int pre;\n {\n-  rtx insn = BLOCK_END (bb);\n+  rtx insn = bb->end;\n   rtx new_insn;\n   rtx reg = expr->reaching_reg;\n   int regno = REGNO (reg);\n@@ -4724,7 +4729,7 @@ insert_insn_end_bb (expr, bb, pre)\n \t}\n #endif\n       /* FIXME: What if something in cc0/jump uses value set in new insn?  */\n-      new_insn = emit_block_insn_before (pat, insn, BASIC_BLOCK (bb));\n+      new_insn = emit_block_insn_before (pat, insn, bb);\n     }\n \n   /* Likewise if the last insn is a call, as will happen in the presence\n@@ -4745,8 +4750,8 @@ insert_insn_end_bb (expr, bb, pre)\n \t Check this.  */\n \n       if (pre\n-\t  && !TEST_BIT (antloc[bb], expr->bitmap_index)\n-          && !TEST_BIT (transp[bb], expr->bitmap_index))\n+\t  && !TEST_BIT (antloc[bb->index], expr->bitmap_index)\n+          && !TEST_BIT (transp[bb->index], expr->bitmap_index))\n \tabort ();\n \n       /* Since different machines initialize their parameter registers\n@@ -4766,7 +4771,7 @@ insert_insn_end_bb (expr, bb, pre)\n \t  }\n \n       /* Search backward for the first set of a register in this set.  */\n-      while (nparm_regs && BLOCK_HEAD (bb) != insn)\n+      while (nparm_regs && bb->head != insn)\n \t{\n \t  insn = PREV_INSN (insn);\n \t  p = single_set (insn);\n@@ -4791,12 +4796,12 @@ insert_insn_end_bb (expr, bb, pre)\n \t     || NOTE_INSN_BASIC_BLOCK_P (insn))\n \tinsn = NEXT_INSN (insn);\n \n-      new_insn = emit_block_insn_before (pat, insn, BASIC_BLOCK (bb));\n+      new_insn = emit_block_insn_before (pat, insn, bb);\n     }\n   else\n     {\n       new_insn = emit_insn_after (pat, insn);\n-      BLOCK_END (bb) = new_insn;\n+      bb->end = new_insn;\n     }\n \n   /* Keep block number table up to date.\n@@ -4808,7 +4813,7 @@ insert_insn_end_bb (expr, bb, pre)\n \t{\n \t  rtx insn = XVECEXP (pat, 0, i);\n \n-\t  set_block_for_insn (insn, BASIC_BLOCK (bb));\n+\t  set_block_for_insn (insn, bb);\n \t  if (INSN_P (insn))\n \t    add_label_notes (PATTERN (insn), new_insn);\n \n@@ -4818,7 +4823,7 @@ insert_insn_end_bb (expr, bb, pre)\n   else\n     {\n       add_label_notes (SET_SRC (pat), new_insn);\n-      set_block_for_new_insns (new_insn, BASIC_BLOCK (bb));\n+      set_block_for_new_insns (new_insn, bb);\n \n       /* Keep register set table up to date.  */\n       record_one_set (regno, new_insn);\n@@ -4829,7 +4834,7 @@ insert_insn_end_bb (expr, bb, pre)\n   if (gcse_file)\n     {\n       fprintf (gcse_file, \"PRE/HOIST: end of bb %d, insn %d, \",\n-\t       bb, INSN_UID (new_insn));\n+\t       bb->index, INSN_UID (new_insn));\n       fprintf (gcse_file, \"copying expression %d to reg %d\\n\",\n \t       expr->bitmap_index, regno);\n     }\n@@ -4857,8 +4862,7 @@ pre_edge_insert (edge_list, index_map)\n   for (e = 0; e < num_edges; e++)\n     {\n       int indx;\n-      basic_block pred = INDEX_EDGE_PRED_BB (edge_list, e);\n-      int bb = pred->index;\n+      basic_block bb = INDEX_EDGE_PRED_BB (edge_list, e);\n \n       for (i = indx = 0; i < set_size; i++, indx += SBITMAP_ELT_BITS)\n \t{\n@@ -4901,7 +4905,7 @@ pre_edge_insert (edge_list, index_map)\n \t\t\tif (gcse_file)\n \t\t\t  {\n \t\t\t    fprintf (gcse_file, \"PRE/HOIST: edge (%d,%d), \",\n-\t\t\t\t     bb,\n+\t\t\t\t     bb->index,\n \t\t\t\t     INDEX_EDGE_SUCC_BB (edge_list, e)->index);\n \t\t\t    fprintf (gcse_file, \"copy expression %d\\n\",\n \t\t\t\t     expr->bitmap_index);\n@@ -4933,7 +4937,7 @@ pre_insert_copy_insn (expr, insn)\n   int indx = expr->bitmap_index;\n   rtx set = single_set (insn);\n   rtx new_insn;\n-  int bb = BLOCK_NUM (insn);\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n \n   if (!set)\n     abort ();\n@@ -4942,12 +4946,12 @@ pre_insert_copy_insn (expr, insn)\n \t\t\t      insn);\n \n   /* Keep block number table up to date.  */\n-  set_block_for_new_insns (new_insn, BASIC_BLOCK (bb));\n+  set_block_for_new_insns (new_insn, bb);\n \n   /* Keep register set table up to date.  */\n   record_one_set (regno, new_insn);\n-  if (insn == BLOCK_END (bb))\n-    BLOCK_END (bb) = new_insn;\n+  if (insn == bb->end)\n+    bb->end = new_insn;\n \n   gcse_create_count++;\n \n@@ -5004,8 +5008,9 @@ pre_insert_copies ()\n \t\t  continue;\n \n \t\t/* Or if the expression doesn't reach the deleted one.  */\n-\t\tif (! pre_expr_reaches_here_p (BLOCK_NUM (avail->insn), expr,\n-\t\t\t\t\t       BLOCK_NUM (occr->insn)))\n+\t\tif (! pre_expr_reaches_here_p (BLOCK_FOR_INSN (avail->insn), \n+\t\t\t\t\t       expr,\n+\t\t\t\t\t       BLOCK_FOR_INSN (occr->insn)))\n \t\t  continue;\n \n \t\t/* Copy the result of avail to reaching_reg.  */\n@@ -5044,9 +5049,9 @@ pre_delete ()\n \t  {\n \t    rtx insn = occr->insn;\n \t    rtx set;\n-\t    int bb = BLOCK_NUM (insn);\n+\t    basic_block bb = BLOCK_FOR_INSN (insn);\n \n-\t    if (TEST_BIT (pre_delete_map[bb], indx))\n+\t    if (TEST_BIT (pre_delete_map[bb->index], indx))\n \t      {\n \t\tset = single_set (insn);\n \t\tif (! set)\n@@ -5081,7 +5086,7 @@ pre_delete ()\n \t\t\t     \"PRE: redundant insn %d (expression %d) in \",\n \t\t\t       INSN_UID (insn), indx);\n \t\t    fprintf (gcse_file, \"bb %d, reaching reg is %d\\n\",\n-\t\t\t     bb, REGNO (expr->reaching_reg));\n+\t\t\t     bb->index, REGNO (expr->reaching_reg));\n \t\t  }\n \t      }\n \t  }\n@@ -5721,9 +5726,9 @@ compute_code_hoist_data ()\n \n static int\n hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n-     int expr_bb;\n+     basic_block expr_bb;\n      int expr_index;\n-     int bb;\n+     basic_block bb;\n      char *visited;\n {\n   edge pred;\n@@ -5736,25 +5741,25 @@ hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n        visited = xcalloc (n_basic_blocks, 1);\n     }\n \n-  for (pred = BASIC_BLOCK (bb)->pred; pred != NULL; pred = pred->pred_next)\n+  for (pred = bb->pred; pred != NULL; pred = pred->pred_next)\n     {\n-      int pred_bb = pred->src->index;\n+      basic_block pred_bb = pred->src;\n \n       if (pred->src == ENTRY_BLOCK_PTR)\n \tbreak;\n-      else if (visited[pred_bb])\n+      else if (visited[pred_bb->index])\n \tcontinue;\n \n       /* Does this predecessor generate this expression?  */\n-      else if (TEST_BIT (comp[pred_bb], expr_index))\n+      else if (TEST_BIT (comp[pred_bb->index], expr_index))\n \tbreak;\n-      else if (! TEST_BIT (transp[pred_bb], expr_index))\n+      else if (! TEST_BIT (transp[pred_bb->index], expr_index))\n \tbreak;\n \n       /* Not killed.  */\n       else\n \t{\n-\t  visited[pred_bb] = 1;\n+\t  visited[pred_bb->index] = 1;\n \t  if (! hoist_expr_reaches_here_p (expr_bb, expr_index,\n \t\t\t\t\t   pred_bb, visited))\n \t    break;\n@@ -5822,7 +5827,8 @@ hoist_code ()\n \n \t\t     Keep track of how many times this expression is hoistable\n \t\t     from a dominated block into BB.  */\n-\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL))\n+\t\t  if (hoist_expr_reaches_here_p (BASIC_BLOCK (bb), i, \n+\t\t\t\t\t\t BASIC_BLOCK (dominated), NULL))\n \t\t    hoistable++;\n \t\t}\n \n@@ -5879,7 +5885,8 @@ hoist_code ()\n \t\t     dominated block.  Now we have to determine if the\n \t\t     expresion would reach the dominated block if it was\n \t\t     placed at the end of BB.  */\n-\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL))\n+\t\t  if (hoist_expr_reaches_here_p (BASIC_BLOCK (bb), i, \n+\t\t\t\t\t\t BASIC_BLOCK (dominated), NULL))\n \t\t    {\n \t\t      struct expr *expr = index_map[i];\n \t\t      struct occr *occr = expr->antic_occr;\n@@ -5921,7 +5928,8 @@ hoist_code ()\n \t\t\t  occr->deleted_p = 1;\n \t\t\t  if (!insn_inserted_p)\n \t\t\t    {\n-\t\t\t      insert_insn_end_bb (index_map[i], bb, 0);\n+\t\t\t      insert_insn_end_bb (index_map[i], \n+\t\t\t\t\t\t  BASIC_BLOCK (bb), 0);\n \t\t\t      insn_inserted_p = 1;\n \t\t\t    }\n \t\t\t}\n@@ -6409,7 +6417,7 @@ reg_set_info (dest, setter, data)\n static int\n store_ops_ok (x, bb)\n      rtx x;\n-     int bb;\n+     basic_block bb;\n {\n   int i;\n   enum rtx_code code;\n@@ -6427,7 +6435,7 @@ store_ops_ok (x, bb)\n     case REG:\n \t/* If a reg has changed after us in this\n \t   block, the operand has been killed.  */\n-\treturn TEST_BIT (reg_set_in_block[bb], REGNO (x));\n+\treturn TEST_BIT (reg_set_in_block[bb->index], REGNO (x));\n \n     case MEM:\n       x = XEXP (x, 0);\n@@ -6679,9 +6687,9 @@ store_killed_in_insn (x, insn)\n static int \n store_killed_after (x, insn, bb)\n      rtx x, insn;\n-     int bb;\n+     basic_block bb;\n {\n-   rtx last = BLOCK_END (bb);\n+   rtx last = bb->end;\n    \n    if (insn == last)\n      return 0;\n@@ -6706,9 +6714,9 @@ store_killed_after (x, insn, bb)\n static int \n store_killed_before (x, insn, bb)\n      rtx x, insn;\n-     int bb;\n+     basic_block bb;\n {\n-   rtx first = BLOCK_HEAD (bb);\n+   rtx first = bb->head;\n \n    if (insn == first)\n      return store_killed_in_insn (x, insn);\n@@ -6737,7 +6745,8 @@ store_killed_before (x, insn, bb)\n static void\n build_store_vectors () \n {\n-  int bb;\n+  basic_block bb;\n+  int b;\n   rtx insn, st;\n   struct ls_expr * ptr;\n \n@@ -6759,7 +6768,7 @@ build_store_vectors ()\n       for (st = store_list; st != NULL; st = XEXP (st, 1))\n \t{\n \t  insn = XEXP (st, 0);\n-\t  bb = BLOCK_NUM (insn);\n+\t  bb = BLOCK_FOR_INSN (insn);\n \t  \n \t  if (!store_killed_after (ptr->pattern, insn, bb))\n \t    {\n@@ -6768,12 +6777,12 @@ build_store_vectors ()\n \t\t the block), and replace it with this one). We'll copy the\n \t\t old SRC expression to an unused register in case there\n \t\t are any side effects.  */\n-\t      if (TEST_BIT (ae_gen[bb], ptr->index))\n+\t      if (TEST_BIT (ae_gen[bb->index], ptr->index))\n \t\t{\n \t\t  /* Find previous store.  */\n \t\t  rtx st;\n \t\t  for (st = AVAIL_STORE_LIST (ptr); st ; st = XEXP (st, 1))\n-\t\t    if (BLOCK_NUM (XEXP (st, 0)) == bb)\n+\t\t    if (BLOCK_FOR_INSN (XEXP (st, 0)) == bb)\n \t\t      break;\n \t\t  if (st)\n \t\t    {\n@@ -6785,7 +6794,7 @@ build_store_vectors ()\n \t\t      continue;\n \t\t    }\n \t\t}\n-\t      SET_BIT (ae_gen[bb], ptr->index);\n+\t      SET_BIT (ae_gen[bb->index], ptr->index);\n \t      AVAIL_STORE_LIST (ptr) = alloc_INSN_LIST (insn,\n \t\t\t\t\t\t\tAVAIL_STORE_LIST (ptr));\n \t    }\n@@ -6809,9 +6818,9 @@ build_store_vectors ()\n   sbitmap_vector_zero (transp, n_basic_blocks);\n \n   for (ptr = first_ls_expr (); ptr != NULL; ptr = next_ls_expr (ptr))\n-    for (bb = 0; bb < n_basic_blocks; bb++)\n+    for (b = 0; b < n_basic_blocks; b++)\n       {\n-\tif (store_killed_after (ptr->pattern, BLOCK_HEAD (bb), bb))\n+\tif (store_killed_after (ptr->pattern, BLOCK_HEAD (b), BASIC_BLOCK (b)))\n \t  {\n \t    /* The anticipatable expression is not killed if it's gen'd. */\n \t    /*\n@@ -6828,11 +6837,11 @@ build_store_vectors ()\n \t\t    gcc.c-torture/execute/960311-1.c with -O3\n \t      If we always kill it in this case, we'll sometimes do\n \t      uneccessary work, but it shouldn't actually hurt anything.\n-\t    if (!TEST_BIT (ae_gen[bb], ptr->index)).  */\n-\t    SET_BIT (ae_kill[bb], ptr->index);\n+\t    if (!TEST_BIT (ae_gen[b], ptr->index)).  */\n+\t    SET_BIT (ae_kill[b], ptr->index);\n \t  }\n \telse\n-\t  SET_BIT (transp[bb], ptr->index);\n+\t  SET_BIT (transp[b], ptr->index);\n       }\n \n   /* Any block with no exits calls some non-returning function, so\n@@ -6856,34 +6865,34 @@ build_store_vectors ()\n static void \n insert_insn_start_bb (insn, bb)\n      rtx insn;\n-     int bb;\n+     basic_block bb;\n {\n   /* Insert at start of successor block.  */\n-  rtx prev = PREV_INSN (BLOCK_HEAD (bb));\n-  rtx before = BLOCK_HEAD (bb);\n+  rtx prev = PREV_INSN (bb->head);\n+  rtx before = bb->head;\n   while (before != 0)\n     {\n       if (GET_CODE (before) != CODE_LABEL\n \t  && (GET_CODE (before) != NOTE\n \t      || NOTE_LINE_NUMBER (before) != NOTE_INSN_BASIC_BLOCK))\n \tbreak;\n       prev = before;\n-      if (prev == BLOCK_END (bb))\n+      if (prev == bb->end)\n \tbreak;\n       before = NEXT_INSN (before);\n     }\n \n   insn = emit_insn_after (insn, prev);\n \n-  if (prev == BLOCK_END (bb))\n-    BLOCK_END (bb) = insn;\n+  if (prev == bb->end)\n+    bb->end = insn;\n \n-  set_block_for_new_insns (insn, BASIC_BLOCK (bb));\n+  set_block_for_new_insns (insn, bb);\n \n   if (gcse_file)\n     {\n       fprintf (gcse_file, \"STORE_MOTION  insert store at start of BB %d:\\n\",\n-\t       bb);\n+\t       bb->index);\n       print_inline_rtx (gcse_file, insn, 6);\n       fprintf (gcse_file, \"\\n\");\n     }\n@@ -6899,7 +6908,7 @@ insert_store (expr, e)\n      edge e;\n {\n   rtx reg, insn;\n-  int bb;\n+  basic_block bb;\n   edge tmp;\n \n   /* We did all the deleted before this insert, so if we didn't delete a\n@@ -6913,7 +6922,7 @@ insert_store (expr, e)\n   /* If we are inserting this expression on ALL predecessor edges of a BB,\n      insert it at the start of the BB, and reset the insert bits on the other\n      edges so we don;t try to insert it on the other edges.  */\n-  bb = e->dest->index;\n+  bb = e->dest;\n   for (tmp = e->dest->pred; tmp ; tmp = tmp->pred_next)\n     {\n       int index = EDGE_INDEX (edge_list, tmp->src, tmp->dest);\n@@ -6925,7 +6934,7 @@ insert_store (expr, e)\n \n   /* If tmp is NULL, we found an insertion on every edge, blank the\n      insertion vector for these edges, and insert at the start of the BB.  */\n-  if (!tmp && bb != EXIT_BLOCK)\n+  if (!tmp && bb != EXIT_BLOCK_PTR)\n     {\n       for (tmp = e->dest->pred; tmp ; tmp = tmp->pred_next)\n \t{\n@@ -6962,29 +6971,29 @@ insert_store (expr, e)\n static void\n replace_store_insn (reg, del, bb)\n      rtx reg, del;\n-     int bb;\n+     basic_block bb;\n {\n   rtx insn;\n   \n   insn = gen_move_insn (reg, SET_SRC (PATTERN (del)));\n   insn = emit_insn_after (insn, del);\n-  set_block_for_new_insns (insn, BASIC_BLOCK (bb));\n+  set_block_for_new_insns (insn, bb);\n   \n   if (gcse_file)\n     {\n       fprintf (gcse_file, \n-\t       \"STORE_MOTION  delete insn in BB %d:\\n      \", bb);\n+\t       \"STORE_MOTION  delete insn in BB %d:\\n      \", bb->index);\n       print_inline_rtx (gcse_file, del, 6);\n       fprintf(gcse_file, \"\\nSTORE MOTION  replaced with insn:\\n      \");\n       print_inline_rtx (gcse_file, insn, 6);\n       fprintf(gcse_file, \"\\n\");\n     }\n   \n-  if (BLOCK_END (bb) == del)\n-    BLOCK_END (bb) = insn;\n+  if (bb->end == del)\n+    bb->end = insn;\n   \n-  if (BLOCK_HEAD (bb) == del)\n-    BLOCK_HEAD (bb) = insn;\n+  if (bb->head == del)\n+    bb->head = insn;\n   \n   delete_insn (del);\n }\n@@ -6996,7 +7005,7 @@ replace_store_insn (reg, del, bb)\n static void\n delete_store (expr, bb)\n      struct ls_expr * expr;\n-     int bb;\n+     basic_block bb;\n {\n   rtx reg, i, del;\n \n@@ -7011,7 +7020,7 @@ delete_store (expr, bb)\n   for (i = AVAIL_STORE_LIST (expr); i; i = XEXP (i, 1))\n     {\n       del = XEXP (i, 0);\n-      if (BLOCK_NUM (del) == bb)\n+      if (BLOCK_FOR_INSN (del) == bb)\n \t{\n \t  /* We know there is only one since we deleted redundant \n \t     ones during the available computation.  */\n@@ -7088,7 +7097,7 @@ store_motion ()\n     {\n       for (x = 0; x < n_basic_blocks; x++)\n \tif (TEST_BIT (pre_delete_map[x], ptr->index))\n-\t  delete_store (ptr, x);\n+\t  delete_store (ptr, BASIC_BLOCK (x));\n \n       for (x = 0; x < NUM_EDGES (edge_list); x++)\n \tif (TEST_BIT (pre_insert_map[x], ptr->index))"}]}