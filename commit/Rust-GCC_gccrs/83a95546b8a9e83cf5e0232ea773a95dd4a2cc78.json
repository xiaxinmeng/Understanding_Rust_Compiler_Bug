{"sha": "83a95546b8a9e83cf5e0232ea773a95dd4a2cc78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNhOTU1NDZiOGE5ZTgzY2Y1ZTAyMzJlYTc3M2E5NWRkNGEyY2M3OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-09-13T08:30:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-09-13T08:30:48Z"}, "message": "tree-loop-distribution.c (struct rdg_component, [...]): Remove.\n\n2013-09-13  Richard Biener  <rguenther@suse.de>\n\n\t* tree-loop-distribution.c (struct rdg_component,\n\trdg_defs_used_in_other_loops_p, free_rdg_components,\n\trdg_build_components): Remove.\n\t(stmts_from_loop): Do not record virtual PHIs.\n\t(generate_loops_for_partition): Skip virtual PHIs.\n\t(build_rdg_partition_for_component): Rename to ...\n\t(build_rdg_partition_for_vertex): ... this and adjust.\n\t(rdg_build_partitions): Take a vector of starting vertices\n\tinstead of components.  Remove unnecessary leftover handling.\n\t(ldist_gen): Do not build components or record other stores.\n\t(distribute_loop): Do not distribute loops containing stmts\n\twith side-effects.\n\nFrom-SVN: r202558", "tree": {"sha": "7cf63b204b2406147c96404d093c5f4d50a65125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7cf63b204b2406147c96404d093c5f4d50a65125"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83a95546b8a9e83cf5e0232ea773a95dd4a2cc78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a95546b8a9e83cf5e0232ea773a95dd4a2cc78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83a95546b8a9e83cf5e0232ea773a95dd4a2cc78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a95546b8a9e83cf5e0232ea773a95dd4a2cc78/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0ecf7f1cb60961adeb05cac3de981ec1587d302", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0ecf7f1cb60961adeb05cac3de981ec1587d302", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0ecf7f1cb60961adeb05cac3de981ec1587d302"}], "stats": {"total": 237, "additions": 56, "deletions": 181}, "files": [{"sha": "ba2929930ed69df981f55438663dab8e75a19f95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a95546b8a9e83cf5e0232ea773a95dd4a2cc78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a95546b8a9e83cf5e0232ea773a95dd4a2cc78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83a95546b8a9e83cf5e0232ea773a95dd4a2cc78", "patch": "@@ -1,3 +1,18 @@\n+2013-09-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-loop-distribution.c (struct rdg_component,\n+\trdg_defs_used_in_other_loops_p, free_rdg_components,\n+\trdg_build_components): Remove.\n+\t(stmts_from_loop): Do not record virtual PHIs.\n+\t(generate_loops_for_partition): Skip virtual PHIs.\n+\t(build_rdg_partition_for_component): Rename to ...\n+\t(build_rdg_partition_for_vertex): ... this and adjust.\n+\t(rdg_build_partitions): Take a vector of starting vertices\n+\tinstead of components.  Remove unnecessary leftover handling.\n+\t(ldist_gen): Do not build components or record other stores.\n+\t(distribute_loop): Do not distribute loops containing stmts\n+\twith side-effects.\n+\n 2013-09-13  Christian Bruel  <christian.bruel@st.com>\n \n \tPR target/58314"}, {"sha": "ac1af30424616ca68bfb8a774e2d81d68476420c", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 41, "deletions": 181, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a95546b8a9e83cf5e0232ea773a95dd4a2cc78/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a95546b8a9e83cf5e0232ea773a95dd4a2cc78/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=83a95546b8a9e83cf5e0232ea773a95dd4a2cc78", "patch": "@@ -115,14 +115,6 @@ typedef struct rdg_edge\n #define RDGE_LEVEL(E)       ((struct rdg_edge *) ((E)->data))->level\n #define RDGE_RELATION(E)    ((struct rdg_edge *) ((E)->data))->relation\n \n-/* Strongly connected components of the reduced data dependence graph.  */\n-\n-typedef struct rdg_component\n-{\n-  int num;\n-  vec<int> vertices;\n-} *rdgc;\n-\n /* Dump vertex I in RDG to FILE.  */\n \n static void\n@@ -452,7 +444,8 @@ stmts_from_loop (struct loop *loop, vec<gimple> *stmts)\n       gimple stmt;\n \n       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\tstmts->safe_push (gsi_stmt (bsi));\n+\tif (!virtual_operand_p (gimple_phi_result (gsi_stmt (bsi))))\n+\t  stmts->safe_push (gsi_stmt (bsi));\n \n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n@@ -564,34 +557,6 @@ build_rdg (vec<loop_p> loop_nest)\n   return rdg;\n }\n \n-/* Determines whether the statement from vertex V of the RDG has a\n-   definition used outside the loop that contains this statement.  */\n-\n-static bool\n-rdg_defs_used_in_other_loops_p (struct graph *rdg, int v)\n-{\n-  gimple stmt = RDG_STMT (rdg, v);\n-  struct loop *loop = loop_containing_stmt (stmt);\n-  use_operand_p imm_use_p;\n-  imm_use_iterator iterator;\n-  ssa_op_iter it;\n-  def_operand_p def_p;\n-\n-  if (!loop)\n-    return true;\n-\n-  FOR_EACH_PHI_OR_STMT_DEF (def_p, stmt, it, SSA_OP_DEF)\n-    {\n-      FOR_EACH_IMM_USE_FAST (imm_use_p, iterator, DEF_FROM_PTR (def_p))\n-\t{\n-\t  if (loop_containing_stmt (USE_STMT (imm_use_p)) != loop)\n-\t    return true;\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n \n \n enum partition_kind {\n@@ -751,7 +716,8 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n \tbasic_block bb = bbs[i];\n \n \tfor (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t  if (!bitmap_bit_p (partition->stmts, x++))\n+\t  if (!virtual_operand_p (gimple_phi_result (gsi_stmt (bsi)))\n+\t      && !bitmap_bit_p (partition->stmts, x++))\n \t    reset_debug_uses (gsi_stmt (bsi));\n \n \tfor (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n@@ -769,7 +735,8 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n       basic_block bb = bbs[i];\n \n       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi);)\n-\tif (!bitmap_bit_p (partition->stmts, x++))\n+\tif (!virtual_operand_p (gimple_phi_result (gsi_stmt (bsi)))\n+\t    && !bitmap_bit_p (partition->stmts, x++))\n \t  {\n \t    gimple phi = gsi_stmt (bsi);\n \t    if (virtual_operand_p (gimple_phi_result (phi)))\n@@ -1174,88 +1141,20 @@ rdg_flag_loop_exits (struct graph *rdg, partition_t partition,\n   conds.release ();\n }\n \n-/* Returns a bitmap in which all the statements needed for computing\n-   the strongly connected component C of the RDG are flagged, also\n-   including the loop exit conditions.  */\n+/* Returns a partition with all the statements needed for computing\n+   the vertex V of the RDG, also including the loop exit conditions.  */\n \n static partition_t\n-build_rdg_partition_for_component (struct graph *rdg, rdgc c)\n+build_rdg_partition_for_vertex (struct graph *rdg, int v)\n {\n   partition_t partition = partition_alloc (NULL, NULL);\n   bitmap processed = BITMAP_ALLOC (NULL);\n-\n-  /* Flag the first vertex of the component and its dependent nodes.\n-     Other members of the component are included in its dependencies.\n-     ???  What do we need components for again?  To early merge initial\n-     vertices that are in a SCC of the RDG?  */\n-  rdg_flag_vertex_and_dependent (rdg, c->vertices[0], partition, processed);\n-\n+  rdg_flag_vertex_and_dependent (rdg, v, partition, processed);\n   rdg_flag_loop_exits (rdg, partition, processed);\n-\n   BITMAP_FREE (processed);\n   return partition;\n }\n \n-/* Free memory for COMPONENTS.  */\n-\n-static void\n-free_rdg_components (vec<rdgc> components)\n-{\n-  int i;\n-  rdgc x;\n-\n-  FOR_EACH_VEC_ELT (components, i, x)\n-    {\n-      x->vertices.release ();\n-      free (x);\n-    }\n-\n-  components.release ();\n-}\n-\n-/* Build the COMPONENTS vector with the strongly connected components\n-   of RDG in which the STARTING_VERTICES occur.  */\n-\n-static void\n-rdg_build_components (struct graph *rdg, vec<int> starting_vertices,\n-\t\t      vec<rdgc> *components)\n-{\n-  int i, v;\n-  bitmap saved_components = BITMAP_ALLOC (NULL);\n-  int n_components = graphds_scc (rdg, NULL);\n-  /* ??? Macros cannot process template types with more than one\n-     argument, so we need this typedef.  */\n-  typedef vec<int> vec_int_heap;\n-  vec<int> *all_components = XNEWVEC (vec_int_heap, n_components);\n-\n-  for (i = 0; i < n_components; i++)\n-    all_components[i].create (3);\n-\n-  for (i = 0; i < rdg->n_vertices; i++)\n-    all_components[rdg->vertices[i].component].safe_push (i);\n-\n-  FOR_EACH_VEC_ELT (starting_vertices, i, v)\n-    {\n-      int c = rdg->vertices[v].component;\n-\n-      if (bitmap_set_bit (saved_components, c))\n-\t{\n-\t  rdgc x = XCNEW (struct rdg_component);\n-\t  x->num = c;\n-\t  x->vertices = all_components[c];\n-\n-\t  components->safe_push (x);\n-\t}\n-    }\n-\n-  for (i = 0; i < n_components; i++)\n-    if (!bitmap_bit_p (saved_components, i))\n-      all_components[i].release ();\n-\n-  free (all_components);\n-  BITMAP_FREE (saved_components);\n-}\n-\n /* Classifies the builtin kind we can generate for PARTITION of RDG and LOOP.\n    For the moment we detect only the memset zero pattern.  */\n \n@@ -1472,23 +1371,22 @@ similar_memory_accesses (struct graph *rdg, partition_t partition1,\n    distributed in different loops.  */\n \n static void\n-rdg_build_partitions (struct graph *rdg, vec<rdgc> components,\n-\t\t      vec<int> *other_stores,\n-\t\t      vec<partition_t> *partitions, bitmap processed)\n+rdg_build_partitions (struct graph *rdg,\n+\t\t      vec<int> starting_vertices,\n+\t\t      vec<partition_t> *partitions)\n {\n-  int i;\n-  rdgc x;\n+  bitmap processed = BITMAP_ALLOC (NULL);\n+  int i, v;\n   partition_t partition = partition_alloc (NULL, NULL);\n \n-  FOR_EACH_VEC_ELT (components, i, x)\n+  FOR_EACH_VEC_ELT (starting_vertices, i, v)\n     {\n       partition_t np;\n-      int v = x->vertices[0];\n \n       if (bitmap_bit_p (processed, v))\n \tcontinue;\n \n-      np = build_rdg_partition_for_component (rdg, x);\n+      np = build_rdg_partition_for_vertex (rdg, v);\n       bitmap_ior_into (partition->stmts, np->stmts);\n       partition->has_writes = partition_has_writes (np);\n       bitmap_ior_into (processed, np->stmts);\n@@ -1507,36 +1405,23 @@ rdg_build_partitions (struct graph *rdg, vec<rdgc> components,\n \t}\n     }\n \n-  /* Add the nodes from the RDG that were not marked as processed, and\n-     that are used outside the current loop.  These are scalar\n-     computations that are not yet part of previous partitions.  */\n-  for (i = 0; i < rdg->n_vertices; i++)\n-    if (!bitmap_bit_p (processed, i)\n-\t&& rdg_defs_used_in_other_loops_p (rdg, i))\n-      other_stores->safe_push (i);\n-\n-  /* If there are still statements left in the OTHER_STORES array,\n-     create other components and partitions with these stores and\n-     their dependences.  */\n-  if (other_stores->length () > 0)\n-    {\n-      vec<rdgc> comps;\n-      comps.create (3);\n-      vec<int> foo;\n-      foo.create (3);\n+  /* All vertices should have been assigned to at least one partition now,\n+     other than vertices belonging to dead code.  */\n \n-      rdg_build_components (rdg, *other_stores, &comps);\n-      rdg_build_partitions (rdg, comps, &foo, partitions, processed);\n+  if (!bitmap_empty_p (partition->stmts))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"remaining partition:\\n\");\n+\t  dump_bitmap (dump_file, partition->stmts);\n+\t}\n \n-      foo.release ();\n-      free_rdg_components (comps);\n+      partitions->safe_push (partition);\n     }\n-\n-  /* If there is something left in the last partition, save it.  */\n-  if (bitmap_count_bits (partition->stmts) > 0)\n-    partitions->safe_push (partition);\n   else\n     partition_free (partition);\n+\n+  BITMAP_FREE (processed);\n }\n \n /* Dump to FILE the PARTITIONS.  */\n@@ -1627,42 +1512,12 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n \t   vec<int> starting_vertices)\n {\n   int i, nbp;\n-  vec<rdgc> components;\n-  components.create (3);\n   vec<partition_t> partitions;\n   partitions.create (3);\n-  vec<int> other_stores;\n-  other_stores.create (3);\n   partition_t partition;\n-  bitmap processed = BITMAP_ALLOC (NULL);\n   bool any_builtin;\n \n-  for (i = 0; i < rdg->n_vertices; i++)\n-    {\n-      /* Save in OTHER_STORES all the memory writes that are not in\n-\t STARTING_VERTICES.  */\n-      if (RDG_MEM_WRITE_STMT (rdg, i))\n-\t{\n-\t  int v;\n-\t  unsigned j;\n-\t  bool found = false;\n-\n-\t  FOR_EACH_VEC_ELT (starting_vertices, j, v)\n-\t    if (i == v)\n-\t      {\n-\t\tfound = true;\n-\t\tbreak;\n-\t      }\n-\n-\t  if (!found)\n-\t    other_stores.safe_push (i);\n-\t}\n-    }\n-\n-  rdg_build_components (rdg, starting_vertices, &components);\n-  rdg_build_partitions (rdg, components, &other_stores, &partitions,\n-\t\t\tprocessed);\n-  BITMAP_FREE (processed);\n+  rdg_build_partitions (rdg, starting_vertices, &partitions);\n \n   any_builtin = false;\n   FOR_EACH_VEC_ELT (partitions, i, partition)\n@@ -1718,9 +1573,6 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n \t       partitions.iterate (j, &partition); ++j)\n \t    {\n \t      if (!partition_builtin_p (partition)\n-\t\t  /* ???  The following is horribly inefficient,\n-\t\t     we are re-computing and analyzing data-references\n-\t\t     of the stmts in the partitions all the time.  */\n \t\t  && similar_memory_accesses (rdg, into, partition))\n \t\t{\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1786,9 +1638,7 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n   FOR_EACH_VEC_ELT (partitions, i, partition)\n     partition_free (partition);\n \n-  other_stores.release ();\n   partitions.release ();\n-  free_rdg_components (components);\n   return nbp;\n }\n \n@@ -1820,7 +1670,7 @@ distribute_loop (struct loop *loop, vec<gimple> stmts)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"FIXME: Loop %d not distributed: failed to build the RDG.\\n\",\n+\t\t \"Loop %d not distributed: failed to build the RDG.\\n\",\n \t\t loop->num);\n \n       loop_nest.release ();\n@@ -1903,6 +1753,15 @@ tree_loop_distribution (void)\n \t  for (gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n \t      gimple stmt = gsi_stmt (gsi);\n+\n+\t      /* If there is a stmt with side-effects bail out - we\n+\t         cannot and should not distribute this loop.  */\n+\t      if (gimple_has_side_effects (stmt))\n+\t\t{\n+\t\t  work_list.truncate (0);\n+\t\t  goto out;\n+\t\t}\n+\n \t      /* Distribute stmts which have defs that are used outside of\n \t         the loop.  */\n \t      if (stmt_has_scalar_dependences_outside_loop (loop, stmt))\n@@ -1915,6 +1774,7 @@ tree_loop_distribution (void)\n \t      work_list.safe_push (stmt);\n \t    }\n \t}\n+out:\n       free (bbs);\n \n       if (work_list.length () > 0)"}]}