{"sha": "7555009aa9f076bf73814094beb5bdbd6982db54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU1NTAwOWFhOWYwNzZiZjczODE0MDk0YmViNWJkYmQ2OTgyZGI1NA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-10-05T19:50:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-10-05T19:50:57Z"}, "message": "re PR debug/41558 (gfortran -O code excessive DW_OP_deref's)\n\n\tPR debug/41558\n\t* dwarf2out.c (loc_by_reference): Removed.\n\t(dw_loc_list_1): New function.\n\t(dw_loc_list): Remove toplev argument, add want_address argument.\n\tDon't look at decl_by_reference_p at all.  Use dw_loc_list_1.\n\t(loc_list_from_tree) <case VAR_DECL>: Pass want_address rather than\n\twant_address == 2 to dw_loc_list.  For successful dw_loc_list\n\tset have_address to 1 only if want_address is not 0.\n\n\t* gcc.dg/guality/guality.exp: Move gdb-test proc into...\n\t* lib/gcc-gdb-test.exp: ... here.  New file.\n\t* gfortran.dg/guality/guality.exp: New file.\n\t* gfortran.dg/guality/pr41558.f90: New test.\n\t* gfortran.dg/guality/arg1.f90: New test.\n\nFrom-SVN: r152467", "tree": {"sha": "7d28fdb724db7f0330b86b43540f99b54afc7865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d28fdb724db7f0330b86b43540f99b54afc7865"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7555009aa9f076bf73814094beb5bdbd6982db54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7555009aa9f076bf73814094beb5bdbd6982db54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7555009aa9f076bf73814094beb5bdbd6982db54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7555009aa9f076bf73814094beb5bdbd6982db54/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c640a3bd210fb2fddbfc5118e37a99dbe8a0a14b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c640a3bd210fb2fddbfc5118e37a99dbe8a0a14b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c640a3bd210fb2fddbfc5118e37a99dbe8a0a14b"}], "stats": {"total": 427, "additions": 250, "deletions": 177}, "files": [{"sha": "d4b7a7fcf91447372ed738ba4bbfbd026d94938f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7555009aa9f076bf73814094beb5bdbd6982db54", "patch": "@@ -1,3 +1,14 @@\n+2009-10-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/41558\n+\t* dwarf2out.c (loc_by_reference): Removed.\n+\t(dw_loc_list_1): New function.\n+\t(dw_loc_list): Remove toplev argument, add want_address argument.\n+\tDon't look at decl_by_reference_p at all.  Use dw_loc_list_1.\n+\t(loc_list_from_tree) <case VAR_DECL>: Pass want_address rather than\n+\twant_address == 2 to dw_loc_list.  For successful dw_loc_list\n+\tset have_address to 1 only if want_address is not 0.\n+\n 2009-10-05  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips-protos.h (mips_trampoline_code_size): Declare."}, {"sha": "b92f69ce87209537622e32c67f368880f5d7fc56", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 84, "deletions": 101, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7555009aa9f076bf73814094beb5bdbd6982db54", "patch": "@@ -13596,71 +13596,101 @@ decl_by_reference_p (tree decl)\n \t  && DECL_BY_REFERENCE (decl));\n }\n \n+/* Return single element location list containing loc descr REF.  */\n \n-/* Dereference a location expression LOC if DECL is passed by invisible\n-   reference.  */\n-\n-static dw_loc_descr_ref\n-loc_by_reference (dw_loc_descr_ref loc, tree decl)\n+static dw_loc_list_ref\n+single_element_loc_list (dw_loc_descr_ref ref)\n {\n-  HOST_WIDE_INT size;\n-  enum dwarf_location_atom op;\n+  return new_loc_list (ref, NULL, NULL, NULL, 0);\n+}\n \n-  if (loc == NULL)\n-    return NULL;\n+/* Helper function for dw_loc_list.  Compute proper Dwarf location descriptor\n+   for VARLOC.  */\n \n-  if (!decl_by_reference_p (decl))\n-    return loc;\n+static dw_loc_descr_ref\n+dw_loc_list_1 (tree loc, rtx varloc, int want_address,\n+\t       enum var_init_status initialized)\n+{\n+  int have_address = 0;\n+  dw_loc_descr_ref descr;\n+  enum machine_mode mode;\n \n-  /* If loc is DW_OP_reg{0...31,x}, don't add DW_OP_deref, instead\n-     change it into corresponding DW_OP_breg{0...31,x} 0.  Then the\n-     location expression is considered to be address of a memory location,\n-     rather than the register itself.  */\n-  if (((loc->dw_loc_opc >= DW_OP_reg0 && loc->dw_loc_opc <= DW_OP_reg31)\n-       || loc->dw_loc_opc == DW_OP_regx)\n-      && (loc->dw_loc_next == NULL\n-\t  || (loc->dw_loc_next->dw_loc_opc == DW_OP_GNU_uninit\n-\t      && loc->dw_loc_next->dw_loc_next == NULL)))\n+  if (want_address != 2)\n     {\n-      if (loc->dw_loc_opc == DW_OP_regx)\n+      gcc_assert (GET_CODE (varloc) == VAR_LOCATION);\n+      /* Single part.  */\n+      if (GET_CODE (XEXP (varloc, 1)) != PARALLEL)\n \t{\n-\t  loc->dw_loc_opc = DW_OP_bregx;\n-\t  loc->dw_loc_oprnd2.v.val_int = 0;\n+\t  varloc = XEXP (XEXP (varloc, 1), 0);\n+\t  mode = GET_MODE (varloc);\n+\t  if (MEM_P (varloc))\n+\t    {\n+\t      varloc = XEXP (varloc, 0);\n+\t      have_address = 1;\n+\t    }\n+\t  descr = mem_loc_descriptor (varloc, mode, initialized);\n \t}\n       else\n+\treturn 0;\n+    }\n+  else\n+    {\n+      descr = loc_descriptor (varloc, DECL_MODE (loc), initialized);\n+      have_address = 1;\n+    }\n+\n+  if (!descr)\n+    return 0;\n+\n+  if (want_address == 2 && !have_address\n+      && (dwarf_version >= 4 || !dwarf_strict))\n+    {\n+      if (int_size_in_bytes (TREE_TYPE (loc)) > DWARF2_ADDR_SIZE)\n \t{\n-\t  loc->dw_loc_opc\n-\t    = (enum dwarf_location_atom)\n-\t      (loc->dw_loc_opc + (DW_OP_breg0 - DW_OP_reg0));\n-\t  loc->dw_loc_oprnd1.v.val_int = 0;\n+\t  expansion_failed (loc, NULL_RTX,\n+\t\t\t    \"DWARF address size mismatch\");\n+\t  return 0;\n \t}\n-      return loc;\n+      add_loc_descr (&descr, new_loc_descr (DW_OP_stack_value, 0, 0));\n+      have_address = 1;\n+    }\n+  /* Show if we can't fill the request for an address.  */\n+  if (want_address && !have_address)\n+    {\n+      expansion_failed (loc, NULL_RTX,\n+\t\t\t\"Want address and only have value\");\n+      return 0;\n     }\n \n-  size = int_size_in_bytes (TREE_TYPE (decl));\n-  if (size > DWARF2_ADDR_SIZE || size == -1)\n-    return 0;\n-  else if (size == DWARF2_ADDR_SIZE)\n-    op = DW_OP_deref;\n-  else\n-    op = DW_OP_deref_size;\n-  add_loc_descr (&loc, new_loc_descr (op, size, 0));\n-  return loc;\n-}\n+  /* If we've got an address and don't want one, dereference.  */\n+  if (!want_address && have_address)\n+    {\n+      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (loc));\n+      enum dwarf_location_atom op;\n \n-/* Return single element location list containing loc descr REF.  */\n+      if (size > DWARF2_ADDR_SIZE || size == -1)\n+\t{\n+\t  expansion_failed (loc, NULL_RTX,\n+\t\t\t    \"DWARF address size mismatch\");\n+\t  return 0;\n+\t}\n+      else if (size == DWARF2_ADDR_SIZE)\n+\top = DW_OP_deref;\n+      else\n+\top = DW_OP_deref_size;\n \n-static dw_loc_list_ref\n-single_element_loc_list (dw_loc_descr_ref ref)\n-{\n-  return new_loc_list (ref, NULL, NULL, NULL, 0);\n+      add_loc_descr (&descr, new_loc_descr (op, size, 0));\n+    }\n+\n+  return descr;\n }\n \n /* Return dwarf representation of location list representing for\n-   LOC_LIST of DECL.  */\n+   LOC_LIST of DECL.  WANT_ADDRESS has the same meaning as in\n+   loc_list_from_tree function.  */\n \n static dw_loc_list_ref\n-dw_loc_list (var_loc_list * loc_list, tree decl, bool toplevel)\n+dw_loc_list (var_loc_list * loc_list, tree decl, int want_address)\n {\n   const char *endname, *secname;\n   dw_loc_list_ref list;\n@@ -13670,8 +13700,6 @@ dw_loc_list (var_loc_list * loc_list, tree decl, bool toplevel)\n   dw_loc_descr_ref descr;\n   char label_id[MAX_ARTIFICIAL_LABEL_BYTES];\n \n-  bool by_reference = decl_by_reference_p (decl);\n-\n   /* Now that we know what section we are using for a base,\n      actually construct the list of locations.\n      The first location information is what is passed to the\n@@ -13684,28 +13712,14 @@ dw_loc_list (var_loc_list * loc_list, tree decl, bool toplevel)\n      a range of [last location start, end of function label].  */\n \n   node = loc_list->first;\n-  varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n   secname = secname_for_decl (decl);\n \n   if (NOTE_VAR_LOCATION_LOC (node->var_loc_note))\n     initialized = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n   else\n     initialized = VAR_INIT_STATUS_INITIALIZED;\n-\n-  if (!toplevel || by_reference)\n-    {\n-      gcc_assert (GET_CODE (varloc) == VAR_LOCATION);\n-      /* Single part.  */\n-      if (GET_CODE (XEXP (varloc, 1)) != PARALLEL)\n-\tdescr = loc_by_reference (mem_loc_descriptor (XEXP (XEXP (varloc, 1), 0),\n-\t\t\t\t\t\t      TYPE_MODE (TREE_TYPE (decl)),\n-\t\t\t\t\t\t      initialized),\n-\t\t\t\t  decl);\n-      else\n-\tdescr = NULL;\n-    }\n-  else\n-    descr = loc_descriptor (varloc, DECL_MODE (decl), initialized);\n+  varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n+  descr = dw_loc_list_1 (decl, varloc, want_address, initialized);\n \n   if (loc_list && loc_list->first != loc_list->last)\n     list = new_loc_list (descr, node->label, node->next->label, secname, 1);\n@@ -13721,22 +13735,9 @@ dw_loc_list (var_loc_list * loc_list, tree decl, bool toplevel)\n       {\n \t/* The variable has a location between NODE->LABEL and\n \t   NODE->NEXT->LABEL.  */\n-\tenum var_init_status initialized =\n-\t  NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n+\tinitialized = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n \tvarloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-\tif (!toplevel || by_reference)\n-\t  {\n-\t    gcc_assert (GET_CODE (varloc) == VAR_LOCATION);\n-\t    /* Single part.  */\n-\t    if (GET_CODE (XEXP (varloc, 1)) != PARALLEL)\n-\t      descr = mem_loc_descriptor (XEXP (XEXP (varloc, 1), 0),\n-\t      \t\t\t\t  TYPE_MODE (TREE_TYPE (decl)), initialized);\n-\t    else\n-\t      descr = NULL;\n-\t    descr = loc_by_reference (descr, decl);\n-\t  }\n-\telse\n-\t  descr = loc_descriptor (varloc, DECL_MODE (decl), initialized);\n+\tdescr = dw_loc_list_1 (decl, varloc, want_address, initialized);\n \tadd_loc_descr_to_loc_list (&list, descr,\n \t\t\t\t   node->label, node->next->label, secname);\n       }\n@@ -13745,9 +13746,6 @@ dw_loc_list (var_loc_list * loc_list, tree decl, bool toplevel)\n      it keeps its location until the end of function.  */\n   if (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n     {\n-      enum var_init_status initialized =\n-\tNOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n-\n       if (!current_function_decl)\n \tendname = text_end_label;\n       else\n@@ -13757,20 +13755,9 @@ dw_loc_list (var_loc_list * loc_list, tree decl, bool toplevel)\n \t  endname = ggc_strdup (label_id);\n \t}\n \n+      initialized = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n       varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-      if (!toplevel || by_reference)\n-\t{\n-\t  gcc_assert (GET_CODE (varloc) == VAR_LOCATION);\n-\t  /* Single part.  */\n-\t  if (GET_CODE (XEXP (varloc, 1)) != PARALLEL)\n-\t    descr = mem_loc_descriptor (XEXP (XEXP (varloc, 1), 0),\n-\t    \t\t\t\tTYPE_MODE (TREE_TYPE (decl)), initialized);\n-\t  else\n-\t    descr = NULL;\n-\t  descr = loc_by_reference (descr, decl);\n-\t}\n-      else\n-\tdescr = loc_descriptor (varloc, DECL_MODE (decl), initialized);\n+      descr = dw_loc_list_1 (decl, varloc, want_address, initialized);\n       add_loc_descr_to_loc_list (&list, descr, node->label, endname, secname);\n     }\n   return list;\n@@ -13948,11 +13935,7 @@ loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev)\n    If WANT_ADDRESS is 1, expression computing address of LOC will be returned\n    if WANT_ADDRESS is 2, expression computing address useable in location\n      will be returned (i.e. DW_OP_reg can be used\n-     to refer to register values) \n-   TODO: Dwarf4 adds types to the stack machine that ought to be used here\n-   DW_OP_stack_value will help in cases where we fail to find address of the\n-   expression.\n- */\n+     to refer to register values).  */\n \n static dw_loc_list_ref\n loc_list_from_tree (tree loc, int want_address)\n@@ -14087,8 +14070,8 @@ loc_list_from_tree (tree loc, int want_address)\n \tvar_loc_list *loc_list = lookup_decl_loc (loc);\n \n \tif (loc_list && loc_list->first\n-\t    && (list_ret = dw_loc_list (loc_list, loc, want_address == 2)))\n-\t  have_address = 1;\n+\t    && (list_ret = dw_loc_list (loc_list, loc, want_address)))\n+\t  have_address = want_address != 0;\n \telse if (rtl == NULL_RTX)\n \t  {\n \t    expansion_failed (loc, NULL_RTX, \"DECL has no RTL\");"}, {"sha": "e2b31f38513941da45c0172f886d5b462eb7b8b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7555009aa9f076bf73814094beb5bdbd6982db54", "patch": "@@ -1,3 +1,12 @@\n+2009-10-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/41558\n+\t* gcc.dg/guality/guality.exp: Move gdb-test proc into...\n+\t* lib/gcc-gdb-test.exp: ... here.  New file.\n+\t* gfortran.dg/guality/guality.exp: New file.\n+\t* gfortran.dg/guality/pr41558.f90: New test.\n+\t* gfortran.dg/guality/arg1.f90: New test.\n+\n 2009-10-05  Paul Thomas  <pault@gcc.gnu.org>\n \n \t* gfortran.dg/dynamic_dispatch_1.f90: New test."}, {"sha": "d4ee6864ba47a6825016bfcccaea2de5db11fa65", "filename": "gcc/testsuite/gcc.dg/guality/guality.exp", "status": "modified", "additions": 1, "deletions": 76, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.exp?ref=7555009aa9f076bf73814094beb5bdbd6982db54", "patch": "@@ -1,6 +1,7 @@\n # This harness is for tests that should be run at all optimisation levels.\n \n load_lib gcc-dg.exp\n+load_lib gcc-gdb-test.exp\n \n # Disable on darwin until radr://7264615 is resolved.\n if { [istarget *-*-darwin*] } {\n@@ -20,82 +21,6 @@ proc check_guality {args} {\n     return $ret\n }\n \n-# Utility for testing variable values using gdb, invoked via dg-final.\n-# Call pass if variable has the desired value, otherwise fail.\n-#\n-# Argument 0 is the line number on which to put a breakpoint\n-# Argument 1 is the name of the variable to be checked\n-# Argument 2 is the expected value of the variable\n-# Argument 3 handles expected failures and the like\n-proc gdb-test { args } {\n-    if { ![isnative] || [is_remote target] } { return }\n-\n-    if { [llength $args] >= 4 } {\n-\tswitch [dg-process-target [lindex $args 3]] {\n-\t    \"S\" { }\n-\t    \"N\" { return }\n-\t    \"F\" { setup_xfail \"*-*-*\" }\n-\t    \"P\" { }\n-\t}\n-    }\n-\n-    # This assumes that we are three frames down from dg-test, and that\n-    # it still stores the filename of the testcase in a local variable \"name\".\n-    # A cleaner solution would require a new DejaGnu release.\n-    upvar 2 name testcase\n-    upvar 2 prog prog\n-\n-    set gdb_name $::env(GUALITY_GDB_NAME)\n-    set testname \"$testcase line [lindex $args 0] [lindex $args 1] == [lindex $args 2]\"\n-    set output_file \"[file rootname [file tail $prog]].exe\"\n-    set cmd_file \"[file rootname [file tail $prog]].gdb\"\n-\n-    set fd [open $cmd_file \"w\"]\n-    puts $fd \"break [lindex $args 0]\"\n-    puts $fd \"run\"\n-    puts $fd \"print [lindex $args 1]\"\n-    puts $fd \"print [lindex $args 2]\"\n-    puts $fd \"quit\"\n-    close $fd\n-\n-    send_log \"Spawning: $gdb_name -nx -nw -quiet -x $cmd_file ./$output_file\\n\"\n-    set res [remote_spawn target \"$gdb_name -nx -nw -quiet -x $cmd_file ./$output_file\"]\n-    if { $res < 0 || $res == \"\" } {\n-\tunsupported \"$testname\"\n-\treturn\n-    }\n-\n-    remote_expect target [timeout_value] {\n-\t-re {[\\n\\r]\\$1 = ([^\\n\\r]*)[\\n\\r]+\\$2 = ([^\\n\\r]*)[\\n\\r]} {\n-\t    set first $expect_out(1,string)\n-\t    set second $expect_out(2,string)\n-\t    if { $first == $second } {\n-\t\tpass \"$testname\"\n-\t    } else {\n-\t\tsend_log \"$first != $second\\n\"\n-\t\tfail \"$testname\"\n-\t    }\n-\t    remote_close target\n-\t    return\n-\t}\n-\t# Too old GDB\n-\t-re \"Unhandled dwarf expression|Error in sourced command file\" {\n-\t    unsupported \"$testname\"\n-\t    remote_close target\n-\t    return\n-\t}\n-\ttimeout {\n-\t    unsupported \"$testname\"\n-\t    remote_close target\n-\t    return\n-\t}\n-    }\n-\n-    remote_close target\n-    unsupported \"$testname\"\n-    return\n-}\n-\n dg-init\n \n global GDB"}, {"sha": "332a4ed1d872eb9874791670ccd0c4b97ad7160c", "filename": "gcc/testsuite/gfortran.dg/guality/arg1.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2Fgfortran.dg%2Fguality%2Farg1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2Fgfortran.dg%2Fguality%2Farg1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fguality%2Farg1.f90?ref=7555009aa9f076bf73814094beb5bdbd6982db54", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do run }\n+! { dg-options \"-g\" }\n+  integer :: a(10), b(12)\n+  call sub (a, 10)\n+  call sub (b, 12)\n+  write (*,*) a, b\n+end\n+\n+subroutine sub (a, n)\n+  integer :: a(n), n\n+  do i = 1, n\n+    a(i) = i\n+  end do\n+  write (*,*) a\t! { dg-final { gdb-test 14 \"a(10)\" \"10\" } }\n+end subroutine"}, {"sha": "2444d8de7b8ce0857439fa12c4a04ade83cbb423", "filename": "gcc/testsuite/gfortran.dg/guality/guality.exp", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2Fgfortran.dg%2Fguality%2Fguality.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2Fgfortran.dg%2Fguality%2Fguality.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fguality%2Fguality.exp?ref=7555009aa9f076bf73814094beb5bdbd6982db54", "patch": "@@ -0,0 +1,29 @@\n+# This harness is for tests that should be run at all optimisation levels.\n+\n+load_lib gfortran-dg.exp\n+load_lib gcc-gdb-test.exp\n+\n+# Disable on darwin until radr://7264615 is resolved.\n+if { [istarget *-*-darwin*] } {\n+  return\n+}\n+\n+dg-init\n+\n+global GDB\n+if ![info exists ::env(GUALITY_GDB_NAME)] {\n+    if [info exists GDB] {\n+\tset guality_gdb_name \"$GDB\"\n+    } else {\n+\tset guality_gdb_name \"[transform gdb]\"\n+    }\n+    setenv GUALITY_GDB_NAME \"$guality_gdb_name\"\n+}\n+\n+gfortran-dg-runtest [lsort [glob $srcdir/$subdir/*.\\[fF\\]{,90,95,03,08} ]] \"\"\n+\n+if [info exists guality_gdb_name] {\n+    unsetenv GUALITY_GDB_NAME\n+}\n+\n+dg-finish"}, {"sha": "9d1e833998feb662e15a907ca979df9f5213f926", "filename": "gcc/testsuite/gfortran.dg/guality/pr41558.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2Fgfortran.dg%2Fguality%2Fpr41558.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2Fgfortran.dg%2Fguality%2Fpr41558.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fguality%2Fpr41558.f90?ref=7555009aa9f076bf73814094beb5bdbd6982db54", "patch": "@@ -0,0 +1,10 @@\n+! PR debug/41558\n+! { dg-do run }\n+! { dg-options \"-g\" }\n+\n+subroutine f (s)\n+  character(len=3) :: s\n+  write (*,*), s ! { dg-final { gdb-test 7 \"s\" \"'foo'\" } }\n+end\n+  call f ('foo')\n+end"}, {"sha": "c8933c2b930ffa30bc3a888d5639414f8f0ea779", "filename": "gcc/testsuite/lib/gcc-gdb-test.exp", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2Flib%2Fgcc-gdb-test.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7555009aa9f076bf73814094beb5bdbd6982db54/gcc%2Ftestsuite%2Flib%2Fgcc-gdb-test.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-gdb-test.exp?ref=7555009aa9f076bf73814094beb5bdbd6982db54", "patch": "@@ -0,0 +1,91 @@\n+#   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Utility for testing variable values using gdb, invoked via dg-final.\n+# Call pass if variable has the desired value, otherwise fail.\n+#\n+# Argument 0 is the line number on which to put a breakpoint\n+# Argument 1 is the name of the variable to be checked\n+# Argument 2 is the expected value of the variable\n+# Argument 3 handles expected failures and the like\n+proc gdb-test { args } {\n+    if { ![isnative] || [is_remote target] } { return }\n+\n+    if { [llength $args] >= 4 } {\n+\tswitch [dg-process-target [lindex $args 3]] {\n+\t    \"S\" { }\n+\t    \"N\" { return }\n+\t    \"F\" { setup_xfail \"*-*-*\" }\n+\t    \"P\" { }\n+\t}\n+    }\n+\n+    # This assumes that we are three frames down from dg-test, and that\n+    # it still stores the filename of the testcase in a local variable \"name\".\n+    # A cleaner solution would require a new DejaGnu release.\n+    upvar 2 name testcase\n+    upvar 2 prog prog\n+\n+    set gdb_name $::env(GUALITY_GDB_NAME)\n+    set testname \"$testcase line [lindex $args 0] [lindex $args 1] == [lindex $args 2]\"\n+    set output_file \"[file rootname [file tail $prog]].exe\"\n+    set cmd_file \"[file rootname [file tail $prog]].gdb\"\n+\n+    set fd [open $cmd_file \"w\"]\n+    puts $fd \"break [lindex $args 0]\"\n+    puts $fd \"run\"\n+    puts $fd \"print [lindex $args 1]\"\n+    puts $fd \"print [lindex $args 2]\"\n+    puts $fd \"quit\"\n+    close $fd\n+\n+    send_log \"Spawning: $gdb_name -nx -nw -quiet -x $cmd_file ./$output_file\\n\"\n+    set res [remote_spawn target \"$gdb_name -nx -nw -quiet -x $cmd_file ./$output_file\"]\n+    if { $res < 0 || $res == \"\" } {\n+\tunsupported \"$testname\"\n+\treturn\n+    }\n+\n+    remote_expect target [timeout_value] {\n+\t-re {[\\n\\r]\\$1 = ([^\\n\\r]*)[\\n\\r]+\\$2 = ([^\\n\\r]*)[\\n\\r]} {\n+\t    set first $expect_out(1,string)\n+\t    set second $expect_out(2,string)\n+\t    if { $first == $second } {\n+\t\tpass \"$testname\"\n+\t    } else {\n+\t\tsend_log \"$first != $second\\n\"\n+\t\tfail \"$testname\"\n+\t    }\n+\t    remote_close target\n+\t    return\n+\t}\n+\t# Too old GDB\n+\t-re \"Unhandled dwarf expression|Error in sourced command file\" {\n+\t    unsupported \"$testname\"\n+\t    remote_close target\n+\t    return\n+\t}\n+\ttimeout {\n+\t    unsupported \"$testname\"\n+\t    remote_close target\n+\t    return\n+\t}\n+    }\n+\n+    remote_close target\n+    unsupported \"$testname\"\n+    return\n+}"}]}