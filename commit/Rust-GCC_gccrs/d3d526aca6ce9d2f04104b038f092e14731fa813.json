{"sha": "d3d526aca6ce9d2f04104b038f092e14731fa813", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNkNTI2YWNhNmNlOWQyZjA0MTA0YjAzOGYwOTJlMTQ3MzFmYTgxMw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-03-07T06:53:23Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-03-07T06:53:23Z"}, "message": "stl_tree.h (_S_rb_tree_red): Make enum.\n\n\n2002-03-06  Benjamin Kosnik  <bkoz@redhat.com>\n\t    Stephen M. Webb  <stephen.webb@bregmasoft.com>\n\n\t* include/bits/stl_tree.h (_S_rb_tree_red): Make enum.\n\t(_S_rb_tree_black): Make enum.\n\tClean. Format.\n\t* include/bits/stl_bvector.h (__WORD_BIT): To _M_word_bit, enum.\n\t* include/bits/stl_algo.h (__stl_chunk_size): _M_chunk_size, enum.\n\t(__stl_threshold): _M_threshold, enum.\n\t* src/stl-inst.cc: Same.\n\t* config/linker-map.gnu: Remove.\n\n\t* testsuite/23_containers/vector_bool.cc: New.\n\nCo-Authored-By: Stephen M. Webb <stephen.webb@bregmasoft.com>\n\nFrom-SVN: r50393", "tree": {"sha": "428cd7a7ea52f5643e42c3727dd8fc84af7f1761", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/428cd7a7ea52f5643e42c3727dd8fc84af7f1761"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3d526aca6ce9d2f04104b038f092e14731fa813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3d526aca6ce9d2f04104b038f092e14731fa813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3d526aca6ce9d2f04104b038f092e14731fa813", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3d526aca6ce9d2f04104b038f092e14731fa813/comments", "author": null, "committer": null, "parents": [{"sha": "76a773f3b9657b2e4209de6c996d8d479ed727e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a773f3b9657b2e4209de6c996d8d479ed727e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a773f3b9657b2e4209de6c996d8d479ed727e7"}], "stats": {"total": 2603, "additions": 1400, "deletions": 1203}, "files": [{"sha": "eaf39bfee43a5e3487837c99856d9e7b2c7b00ab", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d3d526aca6ce9d2f04104b038f092e14731fa813", "patch": "@@ -1,3 +1,17 @@\n+2002-03-06  Benjamin Kosnik  <bkoz@redhat.com>\n+\t    Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+\n+\t* include/bits/stl_tree.h (_S_rb_tree_red): Make enum.\n+\t(_S_rb_tree_black): Make enum.\n+\tClean. Format.\n+\t* include/bits/stl_bvector.h (__WORD_BIT): To _M_word_bit, enum.\n+\t* include/bits/stl_algo.h (__stl_chunk_size): _M_chunk_size, enum.\n+\t(__stl_threshold): _M_threshold, enum.\n+\t* src/stl-inst.cc: Same.\n+\t* config/linker-map.gnu: Remove.\n+\t\n+\t* testsuite/23_containers/vector_bool.cc: New.\n+\t\n 2002-03-06  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* docs/doxygen/user.cfg.in:  Also document deprecated entries."}, {"sha": "27c6f6617dc9293cfc63149d54d5ea973024ce95", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=d3d526aca6ce9d2f04104b038f092e14731fa813", "patch": "@@ -82,18 +82,6 @@ GLIBCPP_3.1 {\n     _ZTv*;\n     _ZTc*;\n \n-    # std::_S_rb_tree_red\n-    _ZSt14_S_rb_tree_red;\n-\n-    # std::_S_rb_tree_black\n-    _ZSt16_S_rb_tree_black;\n-\n-    # std::__stl_threshold\n-    _ZSt15__stl_threshold;\n-\n-    # std::__stl_chunk_size\n-    _ZSt16__stl_chunk_size;\n-\n     # std::__convert_to_v\n     _ZSt14__convert_to_v*;\n "}, {"sha": "a251befd248ef8c407510611660a7c6a1c764b99", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=d3d526aca6ce9d2f04104b038f092e14731fa813", "patch": "@@ -1889,7 +1889,7 @@ __result, __binary_pred, _IterType());\n    *  This controls some aspect of the sort routines.\n    *  @endmaint\n   */\n-  extern const int __stl_threshold;\n+  enum { _M_threshold = 16 };\n \n   /**\n    *  @maint\n@@ -2016,9 +2016,9 @@ __result, __binary_pred, _IterType());\n     void\n     __final_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)\n     {\n-      if (__last - __first > __stl_threshold) {\n-\t__insertion_sort(__first, __first + __stl_threshold);\n-\t__unguarded_insertion_sort(__first + __stl_threshold, __last);\n+      if (__last - __first > _M_threshold) {\n+\t__insertion_sort(__first, __first + _M_threshold);\n+\t__unguarded_insertion_sort(__first + _M_threshold, __last);\n       }\n       else\n \t__insertion_sort(__first, __last);\n@@ -2034,9 +2034,9 @@ __result, __binary_pred, _IterType());\n     __final_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,\n \t\t\t   _Compare __comp)\n     {\n-      if (__last - __first > __stl_threshold) {\n-\t__insertion_sort(__first, __first + __stl_threshold, __comp);\n-\t__unguarded_insertion_sort(__first + __stl_threshold, __last, __comp);\n+      if (__last - __first > _M_threshold) {\n+\t__insertion_sort(__first, __first + _M_threshold, __comp);\n+\t__unguarded_insertion_sort(__first + _M_threshold, __last, __comp);\n       }\n       else\n \t__insertion_sort(__first, __last, __comp);\n@@ -2068,7 +2068,7 @@ __result, __binary_pred, _IterType());\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n \n-      while (__last - __first > __stl_threshold) {\n+      while (__last - __first > _M_threshold) {\n \tif (__depth_limit == 0) {\n \t  partial_sort(__first, __last, __last);\n \t  return;\n@@ -2096,7 +2096,7 @@ __result, __binary_pred, _IterType());\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n \n-      while (__last - __first > __stl_threshold) {\n+      while (__last - __first > _M_threshold) {\n \tif (__depth_limit == 0) {\n \t  partial_sort(__first, __last, __last, __comp);\n \t  return;\n@@ -2253,7 +2253,7 @@ __result, __binary_pred, _IterType());\n \t    __comp);\n     }\n \n-  extern const int __stl_chunk_size;\n+  enum { _M_chunk_size = 7 };\n \n   template<typename _RandomAccessIter, typename _Distance>\n     void\n@@ -2289,7 +2289,7 @@ __result, __binary_pred, _IterType());\n       _Distance __len = __last - __first;\n       _Pointer __buffer_last = __buffer + __len;\n \n-      _Distance __step_size = __stl_chunk_size;\n+      _Distance __step_size = _M_chunk_size;\n       __chunk_insertion_sort(__first, __last, __step_size);\n \n       while (__step_size < __len) {\n@@ -2310,7 +2310,7 @@ __result, __binary_pred, _IterType());\n       _Distance __len = __last - __first;\n       _Pointer __buffer_last = __buffer + __len;\n \n-      _Distance __step_size = __stl_chunk_size;\n+      _Distance __step_size = _M_chunk_size;\n       __chunk_insertion_sort(__first, __last, __step_size, __comp);\n \n       while (__step_size < __len) {"}, {"sha": "0d2348e40680a0dcc42d9368683a9d979daa6291", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=d3d526aca6ce9d2f04104b038f092e14731fa813", "patch": "@@ -63,7 +63,7 @@\n \n namespace std\n { \n-  extern const int __WORD_BIT;\n+  enum { _M_word_bit = int(CHAR_BIT * sizeof(unsigned long)) };\n \n struct _Bit_reference {\n   unsigned int* _M_p;\n@@ -106,24 +106,24 @@ struct _Bit_iterator_base : public iterator<random_access_iterator_tag, bool>\n     : _M_p(__x), _M_offset(__y) {}\n \n   void _M_bump_up() {\n-    if (_M_offset++ == __WORD_BIT - 1) {\n+    if (_M_offset++ == _M_word_bit - 1) {\n       _M_offset = 0;\n       ++_M_p;\n     }\n   }\n   void _M_bump_down() {\n     if (_M_offset-- == 0) {\n-      _M_offset = __WORD_BIT - 1;\n+      _M_offset = _M_word_bit - 1;\n       --_M_p;\n     }\n   }\n \n   void _M_incr(ptrdiff_t __i) {\n     difference_type __n = __i + _M_offset;\n-    _M_p += __n / __WORD_BIT;\n-    __n = __n % __WORD_BIT;\n+    _M_p += __n / _M_word_bit;\n+    __n = __n % _M_word_bit;\n     if (__n < 0) {\n-      _M_offset = (unsigned int) __n + __WORD_BIT;\n+      _M_offset = (unsigned int) __n + _M_word_bit;\n       --_M_p;\n     } else\n       _M_offset = (unsigned int) __n;\n@@ -151,7 +151,7 @@ struct _Bit_iterator_base : public iterator<random_access_iterator_tag, bool>\n \n inline ptrdiff_t\n operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {\n-  return __WORD_BIT * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;\n+  return _M_word_bit * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;\n }\n \n \n@@ -283,7 +283,7 @@ class _Bvector_alloc_base {\n \n protected:\n   unsigned int* _M_bit_alloc(size_t __n) \n-    { return _M_data_allocator.allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }\n+    { return _M_data_allocator.allocate((__n + _M_word_bit - 1)/_M_word_bit); }\n   void _M_deallocate() {\n     if (_M_start._M_p)\n       _M_data_allocator.deallocate(_M_start._M_p, \n@@ -313,7 +313,7 @@ class _Bvector_alloc_base<_Allocator, true> {\n           _Alloc_type;\n           \n   unsigned int* _M_bit_alloc(size_t __n) \n-    { return _Alloc_type::allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }\n+    { return _Alloc_type::allocate((__n + _M_word_bit - 1)/_M_word_bit); }\n   void _M_deallocate() {\n     if (_M_start._M_p)\n       _Alloc_type::deallocate(_M_start._M_p,\n@@ -380,7 +380,7 @@ template <typename _Alloc>\n   protected:\n     void _M_initialize(size_type __n) {\n       unsigned int* __q = _M_bit_alloc(__n);\n-      _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;\n+      _M_end_of_storage = __q + (__n + _M_word_bit - 1)/_M_word_bit;\n       _M_start = iterator(__q, 0);\n       _M_finish = _M_start + difference_type(__n);\n     }\n@@ -391,13 +391,13 @@ template <typename _Alloc>\n         ++_M_finish;\n       }\n       else {\n-        size_type __len = size() ? 2 * size() : __WORD_BIT;\n+        size_type __len = size() ? 2 * size() : _M_word_bit;\n         unsigned int* __q = _M_bit_alloc(__len);\n         iterator __i = copy(begin(), __position, iterator(__q, 0));\n         *__i++ = __x;\n         _M_finish = copy(__position, end(), __i);\n         _M_deallocate();\n-        _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n+        _M_end_of_storage = __q + (__len + _M_word_bit - 1)/_M_word_bit;\n         _M_start = iterator(__q, 0);\n       }\n     }\n@@ -448,7 +448,7 @@ template <typename _Alloc>\n           __i = copy(__first, __last, __i);\n           _M_finish = copy(__position, end(), __i);\n           _M_deallocate();\n-          _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n+          _M_end_of_storage = __q + (__len + _M_word_bit - 1)/_M_word_bit;\n           _M_start = iterator(__q, 0);\n         }\n       }\n@@ -614,7 +614,7 @@ template <typename _Alloc>\n         _M_finish = copy(begin(), end(), iterator(__q, 0));\n         _M_deallocate();\n         _M_start = iterator(__q, 0);\n-        _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;\n+        _M_end_of_storage = __q + (__n + _M_word_bit - 1)/_M_word_bit;\n       }\n     }\n   \n@@ -678,7 +678,7 @@ template <typename _Alloc>\n         fill_n(__i, __n, __x);\n         _M_finish = copy(__position, end(), __i + difference_type(__n));\n         _M_deallocate();\n-        _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n+        _M_end_of_storage = __q + (__len + _M_word_bit - 1)/_M_word_bit;\n         _M_start = iterator(__q, 0);\n       }\n     }"}, {"sha": "d2ae142e9265c7be01e9a43b59506547ddd89197", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 1323, "deletions": 1157, "changes": 2480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=d3d526aca6ce9d2f04104b038f092e14731fa813", "patch": "@@ -90,1207 +90,1373 @@ iterators invalidated are those referring to the deleted node.\n \n namespace std\n { \n-  typedef bool _Rb_tree_Color_type;\n-  extern const _Rb_tree_Color_type _S_rb_tree_red; // false\n-  extern const _Rb_tree_Color_type _S_rb_tree_black; // true\n+  enum _Rb_tree_color { _M_red = false, _M_black = true };\n \n-struct _Rb_tree_node_base\n-{\n-  typedef _Rb_tree_Color_type _Color_type;\n-  typedef _Rb_tree_node_base* _Base_ptr;\n+  struct _Rb_tree_node_base\n+  {\n+    typedef _Rb_tree_node_base* _Base_ptr;\n+    \n+    _Rb_tree_color \t_M_color; \n+    _Base_ptr \t\t_M_parent;\n+    _Base_ptr \t\t_M_left;\n+    _Base_ptr \t\t_M_right;\n+    \n+    static _Base_ptr \n+    _S_minimum(_Base_ptr __x)\n+    {\n+      while (__x->_M_left != 0) __x = __x->_M_left;\n+      return __x;\n+    }\n \n-  _Color_type _M_color; \n-  _Base_ptr _M_parent;\n-  _Base_ptr _M_left;\n-  _Base_ptr _M_right;\n+    static _Base_ptr \n+    _S_maximum(_Base_ptr __x)\n+    {\n+      while (__x->_M_right != 0) __x = __x->_M_right;\n+      return __x;\n+    }\n+  };\n \n-  static _Base_ptr _S_minimum(_Base_ptr __x)\n+  template<typename _Val>\n+    struct _Rb_tree_node : public _Rb_tree_node_base\n+    {\n+      typedef _Rb_tree_node<_Val>* _Link_type;\n+      _Val _M_value_field;\n+    };\n+  \n+  struct _Rb_tree_base_iterator\n   {\n-    while (__x->_M_left != 0) __x = __x->_M_left;\n-    return __x;\n-  }\n+    typedef _Rb_tree_node_base::_Base_ptr \t_Base_ptr;\n+    typedef bidirectional_iterator_tag \t\titerator_category;\n+    typedef ptrdiff_t \t\t\t\tdifference_type;\n+\n+    _Base_ptr _M_node;\n+\n+    void \n+    _M_increment()\n+    {\n+      if (_M_node->_M_right != 0) \n+\t{\n+\t  _M_node = _M_node->_M_right;\n+\t  while (_M_node->_M_left != 0)\n+\t    _M_node = _M_node->_M_left;\n+\t}\n+      else \n+\t{\n+\t  _Base_ptr __y = _M_node->_M_parent;\n+\t  while (_M_node == __y->_M_right) \n+\t    {\n+\t      _M_node = __y;\n+\t      __y = __y->_M_parent;\n+\t    }\n+\t  if (_M_node->_M_right != __y)\n+\t    _M_node = __y;\n+\t}\n+    }\n+\n+    void \n+    _M_decrement()\n+    {\n+      if (_M_node->_M_color == _M_red \n+\t  && _M_node->_M_parent->_M_parent == _M_node)\n+\t_M_node = _M_node->_M_right;\n+      else if (_M_node->_M_left != 0) \n+\t{\n+\t  _Base_ptr __y = _M_node->_M_left;\n+\t  while (__y->_M_right != 0)\n+\t    __y = __y->_M_right;\n+\t  _M_node = __y;\n+\t}\n+      else \n+\t{\n+\t  _Base_ptr __y = _M_node->_M_parent;\n+\t  while (_M_node == __y->_M_left) \n+\t    {\n+\t      _M_node = __y;\n+\t      __y = __y->_M_parent;\n+\t    }\n+\t  _M_node = __y;\n+\t}\n+    }\n+  };\n+\n+  template<typename _Val, typename _Ref, typename _Ptr>\n+    struct _Rb_tree_iterator : public _Rb_tree_base_iterator\n+    {\n+      typedef _Val value_type;\n+      typedef _Ref reference;\n+      typedef _Ptr pointer;\n+      typedef _Rb_tree_iterator<_Val, _Val&, _Val*> iterator;\n+      typedef _Rb_tree_iterator<_Val, const _Val&, const _Val*> \n+      const_iterator;\n+      typedef _Rb_tree_iterator<_Val, _Ref, _Ptr> _Self;\n+      typedef _Rb_tree_node<_Val>* _Link_type;\n+      \n+      _Rb_tree_iterator() {}\n+      _Rb_tree_iterator(_Link_type __x) { _M_node = __x; }\n+      _Rb_tree_iterator(const iterator& __it) { _M_node = __it._M_node; }\n+\n+      reference \n+      operator*() const { return _Link_type(_M_node)->_M_value_field; }\n+\n+      pointer \n+      operator->() const { return &(operator*()); }\n+\n+      _Self& \n+      operator++() \n+      { \n+\t_M_increment(); \n+\treturn *this; \n+      }\n \n-  static _Base_ptr _S_maximum(_Base_ptr __x)\n+      _Self \n+      operator++(int) \n+      {\n+\t_Self __tmp = *this;\n+\t_M_increment();\n+\treturn __tmp;\n+      }\n+    \n+      _Self& \n+      operator--() { _M_decrement(); return *this; }\n+\n+      _Self \n+      operator--(int) \n+      {\n+\t_Self __tmp = *this;\n+\t_M_decrement();\n+\treturn __tmp;\n+      }\n+  };\n+\n+  template<typename _Val, typename _Ref, typename _Ptr>\n+    inline bool \n+    operator==(const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __x,\n+\t       const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __y) \n+    { return __x._M_node == __y._M_node; }\n+\n+  template<typename _Val>\n+    inline bool \n+    operator==(const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __x,\n+\t       const _Rb_tree_iterator<_Val, _Val&, _Val*>& __y) \n+    { return __x._M_node == __y._M_node; }\n+\n+  template<typename _Val>\n+    inline bool \n+    operator==(const _Rb_tree_iterator<_Val, _Val&, _Val*>& __x,\n+\t       const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __y) \n+    { return __x._M_node == __y._M_node; }\n+\n+  template<typename _Val, typename _Ref, typename _Ptr>\n+    inline bool \n+    operator!=(const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __x,\n+\t       const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __y) \n+    { return __x._M_node != __y._M_node; }\n+\n+  template<typename _Val>\n+    inline bool \n+    operator!=(const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __x,\n+\t       const _Rb_tree_iterator<_Val, _Val&, _Val*>& __y) \n+    { return __x._M_node != __y._M_node; }\n+\n+  template<typename _Val>\n+    inline bool \n+    operator!=(const _Rb_tree_iterator<_Val, _Val&, _Val*>& __x,\n+\t       const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __y) \n+    { return __x._M_node != __y._M_node; }\n+\n+  inline void \n+  _Rb_tree_rotate_left(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)\n   {\n-    while (__x->_M_right != 0) __x = __x->_M_right;\n-    return __x;\n+    _Rb_tree_node_base* __y = __x->_M_right;\n+    __x->_M_right = __y->_M_left;\n+    if (__y->_M_left !=0)\n+      __y->_M_left->_M_parent = __x;\n+    __y->_M_parent = __x->_M_parent;\n+    \n+    if (__x == __root)\n+      __root = __y;\n+    else if (__x == __x->_M_parent->_M_left)\n+      __x->_M_parent->_M_left = __y;\n+    else\n+      __x->_M_parent->_M_right = __y;\n+    __y->_M_left = __x;\n+    __x->_M_parent = __y;\n   }\n-};\n-\n-template <class _Value>\n-struct _Rb_tree_node : public _Rb_tree_node_base\n-{\n-  typedef _Rb_tree_node<_Value>* _Link_type;\n-  _Value _M_value_field;\n-};\n \n+  inline void \n+  _Rb_tree_rotate_right(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)\n+  {\n+    _Rb_tree_node_base* __y = __x->_M_left;\n+    __x->_M_left = __y->_M_right;\n+    if (__y->_M_right != 0)\n+      __y->_M_right->_M_parent = __x;\n+    __y->_M_parent = __x->_M_parent;\n \n-struct _Rb_tree_base_iterator\n-{\n-  typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;\n-  typedef bidirectional_iterator_tag iterator_category;\n-  typedef ptrdiff_t difference_type;\n-  _Base_ptr _M_node;\n+    if (__x == __root)\n+      __root = __y;\n+    else if (__x == __x->_M_parent->_M_right)\n+      __x->_M_parent->_M_right = __y;\n+    else\n+      __x->_M_parent->_M_left = __y;\n+    __y->_M_right = __x;\n+    __x->_M_parent = __y;\n+  }\n \n-  void _M_increment()\n+  inline void \n+  _Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)\n   {\n-    if (_M_node->_M_right != 0) {\n-      _M_node = _M_node->_M_right;\n-      while (_M_node->_M_left != 0)\n-        _M_node = _M_node->_M_left;\n-    }\n-    else {\n-      _Base_ptr __y = _M_node->_M_parent;\n-      while (_M_node == __y->_M_right) {\n-        _M_node = __y;\n-        __y = __y->_M_parent;\n+    __x->_M_color = _M_red;\n+    while (__x != __root \n+\t   && __x->_M_parent->_M_color == _M_red) \n+      {\n+\tif (__x->_M_parent == __x->_M_parent->_M_parent->_M_left) \n+\t  {\n+\t    _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_right;\n+\t    if (__y && __y->_M_color == _M_red) \n+\t      {\n+\t\t__x->_M_parent->_M_color = _M_black;\n+\t\t__y->_M_color = _M_black;\n+\t\t__x->_M_parent->_M_parent->_M_color = _M_red;\n+\t\t__x = __x->_M_parent->_M_parent;\n+\t      }\n+\t    else \n+\t      {\n+\t\tif (__x == __x->_M_parent->_M_right) \n+\t\t  {\n+\t\t    __x = __x->_M_parent;\n+\t\t    _Rb_tree_rotate_left(__x, __root);\n+\t\t  }\n+\t\t__x->_M_parent->_M_color = _M_black;\n+\t\t__x->_M_parent->_M_parent->_M_color = _M_red;\n+\t\t_Rb_tree_rotate_right(__x->_M_parent->_M_parent, __root);\n+\t      }\n+\t  }\n+\telse \n+\t  {\n+\t    _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_left;\n+\t    if (__y && __y->_M_color == _M_red) \n+\t      {\n+\t\t__x->_M_parent->_M_color = _M_black;\n+\t\t__y->_M_color = _M_black;\n+\t\t__x->_M_parent->_M_parent->_M_color = _M_red;\n+\t\t__x = __x->_M_parent->_M_parent;\n+\t      }\n+\t    else \n+\t      {\n+\t\tif (__x == __x->_M_parent->_M_left) \n+\t\t  {\n+\t\t    __x = __x->_M_parent;\n+\t\t    _Rb_tree_rotate_right(__x, __root);\n+\t\t  }\n+\t\t__x->_M_parent->_M_color = _M_black;\n+\t\t__x->_M_parent->_M_parent->_M_color = _M_red;\n+\t\t_Rb_tree_rotate_left(__x->_M_parent->_M_parent, __root);\n+\t      }\n+\t  }\n       }\n-      if (_M_node->_M_right != __y)\n-        _M_node = __y;\n-    }\n+    __root->_M_color = _M_black;\n   }\n \n-  void _M_decrement()\n+  inline _Rb_tree_node_base*\n+  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* __z, \n+\t\t\t       _Rb_tree_node_base*& __root,\n+\t\t\t       _Rb_tree_node_base*& __leftmost,\n+\t\t\t       _Rb_tree_node_base*& __rightmost)\n   {\n-    if (_M_node->_M_color == _S_rb_tree_red &&\n-        _M_node->_M_parent->_M_parent == _M_node)\n-      _M_node = _M_node->_M_right;\n-    else if (_M_node->_M_left != 0) {\n-      _Base_ptr __y = _M_node->_M_left;\n-      while (__y->_M_right != 0)\n-        __y = __y->_M_right;\n-      _M_node = __y;\n-    }\n-    else {\n-      _Base_ptr __y = _M_node->_M_parent;\n-      while (_M_node == __y->_M_left) {\n-        _M_node = __y;\n-        __y = __y->_M_parent;\n+    _Rb_tree_node_base* __y = __z;\n+    _Rb_tree_node_base* __x = 0;\n+    _Rb_tree_node_base* __x_parent = 0;\n+    if (__y->_M_left == 0)     // __z has at most one non-null child. y == z.\n+      __x = __y->_M_right;     // __x might be null.\n+    else\n+      if (__y->_M_right == 0)  // __z has exactly one non-null child. y == z.\n+\t__x = __y->_M_left;    // __x is not null.\n+      else \n+\t{\n+\t  // __z has two non-null children.  Set __y to\n+\t  __y = __y->_M_right;   //   __z's successor.  __x might be null.\n+\t  while (__y->_M_left != 0)\n+\t    __y = __y->_M_left;\n+\t  __x = __y->_M_right;\n+\t}\n+    if (__y != __z) \n+      {\n+\t// relink y in place of z.  y is z's successor\n+\t__z->_M_left->_M_parent = __y; \n+\t__y->_M_left = __z->_M_left;\n+\tif (__y != __z->_M_right) \n+\t  {\n+\t    __x_parent = __y->_M_parent;\n+\t    if (__x) __x->_M_parent = __y->_M_parent;\n+\t    __y->_M_parent->_M_left = __x;   // __y must be a child of _M_left\n+\t    __y->_M_right = __z->_M_right;\n+\t    __z->_M_right->_M_parent = __y;\n+\t  }\n+\telse\n+\t  __x_parent = __y;  \n+\tif (__root == __z)\n+\t  __root = __y;\n+\telse if (__z->_M_parent->_M_left == __z)\n+\t  __z->_M_parent->_M_left = __y;\n+\telse \n+\t  __z->_M_parent->_M_right = __y;\n+\t__y->_M_parent = __z->_M_parent;\n+\tstd::swap(__y->_M_color, __z->_M_color);\n+\t__y = __z;\n+\t// __y now points to node to be actually deleted\n       }\n-      _M_node = __y;\n-    }\n-  }\n-};\n-\n-template <class _Value, class _Ref, class _Ptr>\n-struct _Rb_tree_iterator : public _Rb_tree_base_iterator\n-{\n-  typedef _Value value_type;\n-  typedef _Ref reference;\n-  typedef _Ptr pointer;\n-  typedef _Rb_tree_iterator<_Value, _Value&, _Value*>             \n-    iterator;\n-  typedef _Rb_tree_iterator<_Value, const _Value&, const _Value*> \n-    const_iterator;\n-  typedef _Rb_tree_iterator<_Value, _Ref, _Ptr>                   \n-    _Self;\n-  typedef _Rb_tree_node<_Value>* _Link_type;\n-\n-  _Rb_tree_iterator() {}\n-  _Rb_tree_iterator(_Link_type __x) { _M_node = __x; }\n-  _Rb_tree_iterator(const iterator& __it) { _M_node = __it._M_node; }\n-\n-  reference operator*() const { return _Link_type(_M_node)->_M_value_field; }\n-  pointer operator->() const { return &(operator*()); }\n-\n-  _Self& operator++() { _M_increment(); return *this; }\n-  _Self operator++(int) {\n-    _Self __tmp = *this;\n-    _M_increment();\n-    return __tmp;\n-  }\n-    \n-  _Self& operator--() { _M_decrement(); return *this; }\n-  _Self operator--(int) {\n-    _Self __tmp = *this;\n-    _M_decrement();\n-    return __tmp;\n+    else \n+      {                        // __y == __z\n+\t__x_parent = __y->_M_parent;\n+\tif (__x) \n+\t  __x->_M_parent = __y->_M_parent;   \n+\tif (__root == __z)\n+\t  __root = __x;\n+\telse \n+\t  if (__z->_M_parent->_M_left == __z)\n+\t    __z->_M_parent->_M_left = __x;\n+\t  else\n+\t    __z->_M_parent->_M_right = __x;\n+\tif (__leftmost == __z) \n+\t  if (__z->_M_right == 0)        // __z->_M_left must be null also\n+\t    __leftmost = __z->_M_parent;\n+\t// makes __leftmost == _M_header if __z == __root\n+\t  else\n+\t    __leftmost = _Rb_tree_node_base::_S_minimum(__x);\n+\tif (__rightmost == __z)  \n+\t  if (__z->_M_left == 0)         // __z->_M_right must be null also\n+\t    __rightmost = __z->_M_parent;  \n+\t// makes __rightmost == _M_header if __z == __root\n+\t  else                      // __x == __z->_M_left\n+\t    __rightmost = _Rb_tree_node_base::_S_maximum(__x);\n+      }\n+    if (__y->_M_color != _M_red) \n+      { \n+\twhile (__x != __root && (__x == 0 || __x->_M_color == _M_black))\n+\t  if (__x == __x_parent->_M_left) \n+\t    {\n+\t      _Rb_tree_node_base* __w = __x_parent->_M_right;\n+\t      if (__w->_M_color == _M_red) \n+\t\t{\n+\t\t  __w->_M_color = _M_black;\n+\t\t  __x_parent->_M_color = _M_red;\n+\t\t  _Rb_tree_rotate_left(__x_parent, __root);\n+\t\t  __w = __x_parent->_M_right;\n+\t\t}\n+\t      if ((__w->_M_left == 0 || \n+\t\t   __w->_M_left->_M_color == _M_black) &&\n+\t\t  (__w->_M_right == 0 || \n+\t\t   __w->_M_right->_M_color == _M_black)) \n+\t\t{\n+\t\t  __w->_M_color = _M_red;\n+\t\t  __x = __x_parent;\n+\t\t  __x_parent = __x_parent->_M_parent;\n+\t\t} \n+\t      else \n+\t\t{\n+\t\t  if (__w->_M_right == 0 \n+\t\t      || __w->_M_right->_M_color == _M_black) \n+\t\t    {\n+\t\t      if (__w->_M_left) __w->_M_left->_M_color = _M_black;\n+\t\t      __w->_M_color = _M_red;\n+\t\t      _Rb_tree_rotate_right(__w, __root);\n+\t\t      __w = __x_parent->_M_right;\n+\t\t    }\n+\t\t  __w->_M_color = __x_parent->_M_color;\n+\t\t  __x_parent->_M_color = _M_black;\n+\t\t  if (__w->_M_right) \n+\t\t    __w->_M_right->_M_color = _M_black;\n+\t\t  _Rb_tree_rotate_left(__x_parent, __root);\n+\t\t  break;\n+\t\t}\n+\t    } \n+\t  else \n+\t    {   \n+\t      // same as above, with _M_right <-> _M_left.\n+\t      _Rb_tree_node_base* __w = __x_parent->_M_left;\n+\t      if (__w->_M_color == _M_red) \n+\t\t{\n+\t\t  __w->_M_color = _M_black;\n+\t\t  __x_parent->_M_color = _M_red;\n+\t\t  _Rb_tree_rotate_right(__x_parent, __root);\n+\t\t  __w = __x_parent->_M_left;\n+\t\t}\n+\t      if ((__w->_M_right == 0 || \n+\t\t   __w->_M_right->_M_color == _M_black) &&\n+\t\t  (__w->_M_left == 0 || \n+\t\t   __w->_M_left->_M_color == _M_black)) \n+\t\t{\n+\t\t  __w->_M_color = _M_red;\n+\t\t  __x = __x_parent;\n+\t\t  __x_parent = __x_parent->_M_parent;\n+\t\t} \n+\t      else \n+\t\t{\n+\t\t  if (__w->_M_left == 0 || __w->_M_left->_M_color == _M_black) \n+\t\t    {\n+\t\t      if (__w->_M_right) __w->_M_right->_M_color = _M_black;\n+\t\t      __w->_M_color = _M_red;\n+\t\t      _Rb_tree_rotate_left(__w, __root);\n+\t\t      __w = __x_parent->_M_left;\n+\t\t    }\n+\t\t  __w->_M_color = __x_parent->_M_color;\n+\t\t  __x_parent->_M_color = _M_black;\n+\t\t  if (__w->_M_left) \n+\t\t    __w->_M_left->_M_color = _M_black;\n+\t\t  _Rb_tree_rotate_right(__x_parent, __root);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\tif (__x) __x->_M_color = _M_black;\n+      }\n+    return __y;\n   }\n-};\n-\n-template <class _Value, class _Ref, class _Ptr>\n-inline bool operator==(const _Rb_tree_iterator<_Value, _Ref, _Ptr>& __x,\n-\t\t       const _Rb_tree_iterator<_Value, _Ref, _Ptr>& __y) {\n-  return __x._M_node == __y._M_node;\n-}\n-\n-template <class _Value>\n-inline bool operator==(const _Rb_tree_iterator<_Value, const _Value&, const _Value*>& __x,\n-\t\t       const _Rb_tree_iterator<_Value, _Value&, _Value*>& __y) {\n-  return __x._M_node == __y._M_node;\n-}\n-\n-template <class _Value>\n-inline bool operator==(const _Rb_tree_iterator<_Value, _Value&, _Value*>& __x,\n-\t\t       const _Rb_tree_iterator<_Value, const _Value&, const _Value*>& __y) {\n-  return __x._M_node == __y._M_node;\n-}\n-\n-template <class _Value, class _Ref, class _Ptr>\n-inline bool operator!=(const _Rb_tree_iterator<_Value, _Ref, _Ptr>& __x,\n-\t\t       const _Rb_tree_iterator<_Value, _Ref, _Ptr>& __y) {\n-  return __x._M_node != __y._M_node;\n-}\n-\n-template <class _Value>\n-inline bool operator!=(const _Rb_tree_iterator<_Value, const _Value&, const _Value*>& __x,\n-\t\t       const _Rb_tree_iterator<_Value, _Value&, _Value*>& __y) {\n-  return __x._M_node != __y._M_node;\n-}\n-\n-template <class _Value>\n-inline bool operator!=(const _Rb_tree_iterator<_Value, _Value&, _Value*>& __x,\n-\t\t       const _Rb_tree_iterator<_Value, const _Value&, const _Value*>& __y) {\n-  return __x._M_node != __y._M_node;\n-}\n-\n-inline void \n-_Rb_tree_rotate_left(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)\n-{\n-  _Rb_tree_node_base* __y = __x->_M_right;\n-  __x->_M_right = __y->_M_left;\n-  if (__y->_M_left !=0)\n-    __y->_M_left->_M_parent = __x;\n-  __y->_M_parent = __x->_M_parent;\n-\n-  if (__x == __root)\n-    __root = __y;\n-  else if (__x == __x->_M_parent->_M_left)\n-    __x->_M_parent->_M_left = __y;\n-  else\n-    __x->_M_parent->_M_right = __y;\n-  __y->_M_left = __x;\n-  __x->_M_parent = __y;\n-}\n-\n-inline void \n-_Rb_tree_rotate_right(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)\n-{\n-  _Rb_tree_node_base* __y = __x->_M_left;\n-  __x->_M_left = __y->_M_right;\n-  if (__y->_M_right != 0)\n-    __y->_M_right->_M_parent = __x;\n-  __y->_M_parent = __x->_M_parent;\n-\n-  if (__x == __root)\n-    __root = __y;\n-  else if (__x == __x->_M_parent->_M_right)\n-    __x->_M_parent->_M_right = __y;\n-  else\n-    __x->_M_parent->_M_left = __y;\n-  __y->_M_right = __x;\n-  __x->_M_parent = __y;\n-}\n-\n-inline void \n-_Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)\n-{\n-  __x->_M_color = _S_rb_tree_red;\n-  while (__x != __root && __x->_M_parent->_M_color == _S_rb_tree_red) {\n-    if (__x->_M_parent == __x->_M_parent->_M_parent->_M_left) {\n-      _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_right;\n-      if (__y && __y->_M_color == _S_rb_tree_red) {\n-        __x->_M_parent->_M_color = _S_rb_tree_black;\n-        __y->_M_color = _S_rb_tree_black;\n-        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;\n-        __x = __x->_M_parent->_M_parent;\n+\n+  // Base class to encapsulate the differences between old SGI-style\n+  // allocators and standard-conforming allocators.  In order to avoid\n+  // having an empty base class, we arbitrarily move one of rb_tree's\n+  // data members into the base class.\n+\n+  // _Base for general standard-conforming allocators.\n+  template<typename _Tp, typename _Alloc, bool _S_instanceless>\n+    class _Rb_tree_alloc_base \n+    {\n+    public:\n+    typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;\n+\n+      allocator_type \n+      get_allocator() const { return _M_node_allocator; }\n+\n+      _Rb_tree_alloc_base(const allocator_type& __a)\n+      : _M_node_allocator(__a), _M_header(0) {}\n+\n+    protected:\n+      typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::allocator_type\n+      _M_node_allocator;\n+\n+      _Rb_tree_node<_Tp>* _M_header;\n+      \n+      _Rb_tree_node<_Tp>* \n+      _M_get_node()  { return _M_node_allocator.allocate(1); }\n+\n+      void \n+      _M_put_node(_Rb_tree_node<_Tp>* __p) \n+      { _M_node_allocator.deallocate(__p, 1); }\n+    };\n+\n+  // Specialization for instanceless allocators.\n+  template<typename _Tp, typename _Alloc>\n+    class _Rb_tree_alloc_base<_Tp, _Alloc, true> \n+    {\n+    public:\n+    typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;\n+      allocator_type get_allocator() const { return allocator_type(); }\n+\n+      _Rb_tree_alloc_base(const allocator_type&) : _M_header(0) {}\n+\n+    protected:\n+      _Rb_tree_node<_Tp>* _M_header;\n+      \n+      typedef typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::_Alloc_type\n+      _Alloc_type;\n+      \n+      _Rb_tree_node<_Tp>* \n+      _M_get_node() { return _Alloc_type::allocate(1); }\n+\n+      void \n+      _M_put_node(_Rb_tree_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }\n+    };\n+  \n+  template<typename _Tp, typename _Alloc>\n+    struct _Rb_tree_base : public _Rb_tree_alloc_base<_Tp, _Alloc, \n+                                  _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+    {\n+      typedef _Rb_tree_alloc_base<_Tp, \n+\t_Alloc, _Alloc_traits<_Tp, _Alloc>::_S_instanceless> _Base;\n+      typedef typename _Base::allocator_type allocator_type;\n+\n+      _Rb_tree_base(const allocator_type& __a) \n+      : _Base(__a) { _M_header = _M_get_node(); }\n+      ~_Rb_tree_base() { _M_put_node(_M_header); }\n+    };\n+\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc = allocator<_Val> >\n+    class _Rb_tree : protected _Rb_tree_base<_Val, _Alloc> \n+    {\n+      typedef _Rb_tree_base<_Val, _Alloc> _Base;\n+      \n+    protected:\n+      typedef _Rb_tree_node_base* _Base_ptr;\n+      typedef _Rb_tree_node<_Val> _Rb_tree_node;\n+      \n+    public:\n+      typedef _Key key_type;\n+      typedef _Val value_type;\n+      typedef value_type* pointer;\n+      typedef const value_type* const_pointer;\n+      typedef value_type& reference;\n+      typedef const value_type& const_reference;\n+      typedef _Rb_tree_node* _Link_type;\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      \n+      typedef typename _Base::allocator_type allocator_type;\n+      allocator_type get_allocator() const { return _Base::get_allocator(); }\n+      \n+    protected:\n+      using _Base::_M_get_node;\n+      using _Base::_M_put_node;\n+      using _Base::_M_header;\n+      \n+      _Link_type\n+      _M_create_node(const value_type& __x)\n+      {\n+\t_Link_type __tmp = _M_get_node();\n+\ttry \n+\t  { _Construct(&__tmp->_M_value_field, __x); }\n+\tcatch(...)\n+\t  {\n+\t  _M_put_node(__tmp);\n+\t  __throw_exception_again; \n+\t  }\n+\treturn __tmp;\n       }\n-      else {\n-        if (__x == __x->_M_parent->_M_right) {\n-          __x = __x->_M_parent;\n-          _Rb_tree_rotate_left(__x, __root);\n-        }\n-        __x->_M_parent->_M_color = _S_rb_tree_black;\n-        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;\n-        _Rb_tree_rotate_right(__x->_M_parent->_M_parent, __root);\n+      \n+      _Link_type \n+      _M_clone_node(_Link_type __x)\n+      {\n+\t_Link_type __tmp = _M_create_node(__x->_M_value_field);\n+\t__tmp->_M_color = __x->_M_color;\n+\t__tmp->_M_left = 0;\n+\t__tmp->_M_right = 0;\n+\treturn __tmp;\n       }\n-    }\n-    else {\n-      _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_left;\n-      if (__y && __y->_M_color == _S_rb_tree_red) {\n-        __x->_M_parent->_M_color = _S_rb_tree_black;\n-        __y->_M_color = _S_rb_tree_black;\n-        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;\n-        __x = __x->_M_parent->_M_parent;\n+\n+      void\n+      destroy_node(_Link_type __p)\n+      {\n+\t_Destroy(&__p->_M_value_field);\n+\t_M_put_node(__p);\n+      }\n+\n+      size_type _M_node_count; // keeps track of size of tree\n+      _Compare _M_key_compare;\n+\n+      _Link_type& \n+      _M_root() const { return (_Link_type&) _M_header->_M_parent; }\n+\n+      _Link_type& \n+      _M_leftmost() const { return (_Link_type&) _M_header->_M_left; }\n+\n+      _Link_type& \n+      _M_rightmost() const { return (_Link_type&) _M_header->_M_right; }\n+\n+      static _Link_type& \n+      _S_left(_Link_type __x) { return (_Link_type&)(__x->_M_left); }\n+\n+      static _Link_type& \n+      _S_right(_Link_type __x) { return (_Link_type&)(__x->_M_right); }\n+\n+      static _Link_type& \n+      _S_parent(_Link_type __x) { return (_Link_type&)(__x->_M_parent); }\n+\n+      static reference \n+      _S_value(_Link_type __x) { return __x->_M_value_field; }\n+\n+      static const _Key& \n+      _S_key(_Link_type __x) { return _KeyOfValue()(_S_value(__x)); }\n+\n+      static _Rb_tree_color& \n+      _S_color(_Link_type __x) { return __x->_M_color; }\n+\n+      static _Link_type& \n+      _S_left(_Base_ptr __x) { return (_Link_type&)(__x->_M_left); }\n+\n+      static _Link_type& \n+      _S_right(_Base_ptr __x) { return (_Link_type&)(__x->_M_right); }\n+\n+      static _Link_type& \n+      _S_parent(_Base_ptr __x) { return (_Link_type&)(__x->_M_parent); }\n+\n+      static reference \n+      _S_value(_Base_ptr __x) { return ((_Link_type)__x)->_M_value_field; }\n+\n+      static const _Key& \n+      _S_key(_Base_ptr __x) { return _KeyOfValue()(_S_value(_Link_type(__x)));} \n+\n+      static _Rb_tree_color&\n+      _S_color(_Base_ptr __x) { return (_Link_type(__x)->_M_color); }\n+\n+      static _Link_type \n+      _S_minimum(_Link_type __x) \n+      { return (_Link_type)  _Rb_tree_node_base::_S_minimum(__x); }\n+\n+      static _Link_type \n+      _S_maximum(_Link_type __x)\n+      { return (_Link_type) _Rb_tree_node_base::_S_maximum(__x); }\n+\n+    public:\n+      typedef _Rb_tree_iterator<value_type, reference, pointer> iterator;\n+      typedef _Rb_tree_iterator<value_type, const_reference, const_pointer> \n+      const_iterator;\n+\n+      typedef reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef reverse_iterator<iterator> reverse_iterator;\n+\n+    private:\n+      iterator \n+      _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);\n+\n+      _Link_type \n+      _M_copy(_Link_type __x, _Link_type __p);\n+\n+      void \n+      _M_erase(_Link_type __x);\n+\n+    public:\n+      // allocation/deallocation\n+      _Rb_tree()\n+\t: _Base(allocator_type()), _M_node_count(0), _M_key_compare()\n+      { _M_empty_initialize(); }\n+\n+      _Rb_tree(const _Compare& __comp)\n+\t: _Base(allocator_type()), _M_node_count(0), _M_key_compare(__comp) \n+      { _M_empty_initialize(); }\n+\n+      _Rb_tree(const _Compare& __comp, const allocator_type& __a)\n+\t: _Base(__a), _M_node_count(0), _M_key_compare(__comp) \n+      { _M_empty_initialize(); }\n+\n+      _Rb_tree(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x) \n+\t: _Base(__x.get_allocator()), _M_node_count(0), \n+\t\t _M_key_compare(__x._M_key_compare)\n+      { \n+\tif (__x._M_root() == 0)\n+\t  _M_empty_initialize();\n+\telse \n+\t  {\n+\t    _S_color(_M_header) = _M_red;\n+\t    _M_root() = _M_copy(__x._M_root(), _M_header);\n+\t    _M_leftmost() = _S_minimum(_M_root());\n+\t    _M_rightmost() = _S_maximum(_M_root());\n+\t  }\n+\t_M_node_count = __x._M_node_count;\n       }\n-      else {\n-        if (__x == __x->_M_parent->_M_left) {\n-          __x = __x->_M_parent;\n-          _Rb_tree_rotate_right(__x, __root);\n-        }\n-        __x->_M_parent->_M_color = _S_rb_tree_black;\n-        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;\n-        _Rb_tree_rotate_left(__x->_M_parent->_M_parent, __root);\n+\n+      ~_Rb_tree() { clear(); }\n+\n+      _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& \n+      operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x);\n+\n+    private:\n+      void _M_empty_initialize() \n+      {\n+\t_S_color(_M_header) = _M_red; // used to distinguish header from \n+\t// __root, in iterator.operator++\n+\t_M_root() = 0;\n+\t_M_leftmost() = _M_header;\n+\t_M_rightmost() = _M_header;\n+      }\n+\n+    public:    \n+      // Accessors.\n+      _Compare \n+      key_comp() const { return _M_key_compare; }\n+\n+      iterator \n+      begin() { return _M_leftmost(); }\n+\n+      const_iterator \n+      begin() const { return _M_leftmost(); }\n+\n+      iterator \n+      end() { return _M_header; }\n+\n+      const_iterator \n+      end() const { return _M_header; }\n+\n+      reverse_iterator \n+      rbegin() { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator \n+      rbegin() const { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator \n+      rend() { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator \n+      rend() const { return const_reverse_iterator(begin()); }\n+ \n+      bool \n+      empty() const { return _M_node_count == 0; }\n+\n+      size_type \n+      size() const { return _M_node_count; }\n+\n+      size_type \n+      max_size() const { return size_type(-1); }\n+\n+      void \n+      swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t) \n+      {\n+\tstd::swap(_M_header, __t._M_header);\n+\tstd::swap(_M_node_count, __t._M_node_count);\n+\tstd::swap(_M_key_compare, __t._M_key_compare);\n       }\n+    \n+      // Insert/erase.\n+      pair<iterator,bool> \n+      insert_unique(const value_type& __x);\n+\n+      iterator \n+      insert_equal(const value_type& __x);\n+\n+      iterator \n+      insert_unique(iterator __position, const value_type& __x);\n+\n+      iterator \n+      insert_equal(iterator __position, const value_type& __x);\n+\n+      template<typename _InputIterator>\n+      void \n+      insert_unique(_InputIterator __first, _InputIterator __last);\n+\n+      template<typename _InputIterator>\n+      void \n+      insert_equal(_InputIterator __first, _InputIterator __last);\n+\n+      void \n+      erase(iterator __position);\n+\n+      size_type \n+      erase(const key_type& __x);\n+\n+      void \n+      erase(iterator __first, iterator __last);\n+\n+      void \n+      erase(const key_type* __first, const key_type* __last);\n+\n+      void \n+      clear() \n+      {\n+\tif (_M_node_count != 0) \n+\t  {\n+\t    _M_erase(_M_root());\n+\t    _M_leftmost() = _M_header;\n+\t    _M_root() = 0;\n+\t    _M_rightmost() = _M_header;\n+\t    _M_node_count = 0;\n+\t  }\n+      }      \n+\n+      // Set operations.\n+      iterator \n+      find(const key_type& __x);\n+\n+      const_iterator \n+      find(const key_type& __x) const;\n+\n+      size_type \n+      count(const key_type& __x) const;\n+\n+      iterator \n+      lower_bound(const key_type& __x);\n+\n+      const_iterator \n+      lower_bound(const key_type& __x) const;\n+\n+      iterator \n+      upper_bound(const key_type& __x);\n+\n+      const_iterator \n+      upper_bound(const key_type& __x) const;\n+\n+      pair<iterator,iterator> \n+      equal_range(const key_type& __x);\n+\n+      pair<const_iterator, const_iterator> \n+      equal_range(const key_type& __x) const;\n+\n+      // Debugging.\n+      bool \n+      __rb_verify() const;\n+    };\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    inline bool \n+    operator==(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n+\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n+    {\n+      return __x.size() == __y.size() && \n+\tequal(__x.begin(), __x.end(), __y.begin());\n     }\n-  }\n-  __root->_M_color = _S_rb_tree_black;\n-}\n-\n-inline _Rb_tree_node_base*\n-_Rb_tree_rebalance_for_erase(_Rb_tree_node_base* __z,\n-                             _Rb_tree_node_base*& __root,\n-                             _Rb_tree_node_base*& __leftmost,\n-                             _Rb_tree_node_base*& __rightmost)\n-{\n-  _Rb_tree_node_base* __y = __z;\n-  _Rb_tree_node_base* __x = 0;\n-  _Rb_tree_node_base* __x_parent = 0;\n-  if (__y->_M_left == 0)     // __z has at most one non-null child. y == z.\n-    __x = __y->_M_right;     // __x might be null.\n-  else\n-    if (__y->_M_right == 0)  // __z has exactly one non-null child. y == z.\n-      __x = __y->_M_left;    // __x is not null.\n-    else {                   // __z has two non-null children.  Set __y to\n-      __y = __y->_M_right;   //   __z's successor.  __x might be null.\n-      while (__y->_M_left != 0)\n-        __y = __y->_M_left;\n-      __x = __y->_M_right;\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    inline bool \n+    operator<(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n+\t      const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n+    {\n+      return lexicographical_compare(__x.begin(), __x.end(),\n+\t\t\t\t     __y.begin(), __y.end());\n     }\n-  if (__y != __z) {          // relink y in place of z.  y is z's successor\n-    __z->_M_left->_M_parent = __y; \n-    __y->_M_left = __z->_M_left;\n-    if (__y != __z->_M_right) {\n-      __x_parent = __y->_M_parent;\n-      if (__x) __x->_M_parent = __y->_M_parent;\n-      __y->_M_parent->_M_left = __x;      // __y must be a child of _M_left\n-      __y->_M_right = __z->_M_right;\n-      __z->_M_right->_M_parent = __y;\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    inline bool \n+    operator!=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n+\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) \n+    { return !(__x == __y); }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    inline bool \n+    operator>(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n+\t      const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) \n+    { return __y < __x; }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    inline bool \n+    operator<=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n+\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) \n+  { return !(__y < __x); }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    inline bool \n+    operator>=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n+\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) \n+  { return !(__x < __y); }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    inline void \n+    swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n+\t _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x)\n+    {\n+      if (this != &__x) \n+\t{\n+\t  // Note that _Key may be a constant type.\n+\t  clear();\n+\t  _M_node_count = 0;\n+\t  _M_key_compare = __x._M_key_compare;        \n+\t  if (__x._M_root() == 0) \n+\t    {\n+\t      _M_root() = 0;\n+\t      _M_leftmost() = _M_header;\n+\t      _M_rightmost() = _M_header;\n+\t    }\n+\t  else \n+\t    {\n+\t      _M_root() = _M_copy(__x._M_root(), _M_header);\n+\t      _M_leftmost() = _S_minimum(_M_root());\n+\t      _M_rightmost() = _S_maximum(_M_root());\n+\t      _M_node_count = __x._M_node_count;\n+\t    }\n+\t}\n+      return *this;\n     }\n-    else\n-      __x_parent = __y;  \n-    if (__root == __z)\n-      __root = __y;\n-    else if (__z->_M_parent->_M_left == __z)\n-      __z->_M_parent->_M_left = __y;\n-    else \n-      __z->_M_parent->_M_right = __y;\n-    __y->_M_parent = __z->_M_parent;\n-    std::swap(__y->_M_color, __z->_M_color);\n-    __y = __z;\n-    // __y now points to node to be actually deleted\n-  }\n-  else {                        // __y == __z\n-    __x_parent = __y->_M_parent;\n-    if (__x) __x->_M_parent = __y->_M_parent;   \n-    if (__root == __z)\n-      __root = __x;\n-    else \n-      if (__z->_M_parent->_M_left == __z)\n-        __z->_M_parent->_M_left = __x;\n-      else\n-        __z->_M_parent->_M_right = __x;\n-    if (__leftmost == __z) \n-      if (__z->_M_right == 0)        // __z->_M_left must be null also\n-        __leftmost = __z->_M_parent;\n-    // makes __leftmost == _M_header if __z == __root\n-      else\n-        __leftmost = _Rb_tree_node_base::_S_minimum(__x);\n-    if (__rightmost == __z)  \n-      if (__z->_M_left == 0)         // __z->_M_right must be null also\n-        __rightmost = __z->_M_parent;  \n-    // makes __rightmost == _M_header if __z == __root\n-      else                      // __x == __z->_M_left\n-        __rightmost = _Rb_tree_node_base::_S_maximum(__x);\n-  }\n-  if (__y->_M_color != _S_rb_tree_red) { \n-    while (__x != __root && (__x == 0 || __x->_M_color == _S_rb_tree_black))\n-      if (__x == __x_parent->_M_left) {\n-        _Rb_tree_node_base* __w = __x_parent->_M_right;\n-        if (__w->_M_color == _S_rb_tree_red) {\n-          __w->_M_color = _S_rb_tree_black;\n-          __x_parent->_M_color = _S_rb_tree_red;\n-          _Rb_tree_rotate_left(__x_parent, __root);\n-          __w = __x_parent->_M_right;\n-        }\n-        if ((__w->_M_left == 0 || \n-             __w->_M_left->_M_color == _S_rb_tree_black) &&\n-            (__w->_M_right == 0 || \n-             __w->_M_right->_M_color == _S_rb_tree_black)) {\n-          __w->_M_color = _S_rb_tree_red;\n-          __x = __x_parent;\n-          __x_parent = __x_parent->_M_parent;\n-        } else {\n-          if (__w->_M_right == 0 || \n-              __w->_M_right->_M_color == _S_rb_tree_black) {\n-            if (__w->_M_left) __w->_M_left->_M_color = _S_rb_tree_black;\n-            __w->_M_color = _S_rb_tree_red;\n-            _Rb_tree_rotate_right(__w, __root);\n-            __w = __x_parent->_M_right;\n-          }\n-          __w->_M_color = __x_parent->_M_color;\n-          __x_parent->_M_color = _S_rb_tree_black;\n-          if (__w->_M_right) __w->_M_right->_M_color = _S_rb_tree_black;\n-          _Rb_tree_rotate_left(__x_parent, __root);\n-          break;\n-        }\n-      } else {                  // same as above, with _M_right <-> _M_left.\n-        _Rb_tree_node_base* __w = __x_parent->_M_left;\n-        if (__w->_M_color == _S_rb_tree_red) {\n-          __w->_M_color = _S_rb_tree_black;\n-          __x_parent->_M_color = _S_rb_tree_red;\n-          _Rb_tree_rotate_right(__x_parent, __root);\n-          __w = __x_parent->_M_left;\n-        }\n-        if ((__w->_M_right == 0 || \n-             __w->_M_right->_M_color == _S_rb_tree_black) &&\n-            (__w->_M_left == 0 || \n-             __w->_M_left->_M_color == _S_rb_tree_black)) {\n-          __w->_M_color = _S_rb_tree_red;\n-          __x = __x_parent;\n-          __x_parent = __x_parent->_M_parent;\n-        } else {\n-          if (__w->_M_left == 0 || \n-              __w->_M_left->_M_color == _S_rb_tree_black) {\n-            if (__w->_M_right) __w->_M_right->_M_color = _S_rb_tree_black;\n-            __w->_M_color = _S_rb_tree_red;\n-            _Rb_tree_rotate_left(__w, __root);\n-            __w = __x_parent->_M_left;\n-          }\n-          __w->_M_color = __x_parent->_M_color;\n-          __x_parent->_M_color = _S_rb_tree_black;\n-          if (__w->_M_left) __w->_M_left->_M_color = _S_rb_tree_black;\n-          _Rb_tree_rotate_right(__x_parent, __root);\n-          break;\n-        }\n-      }\n-    if (__x) __x->_M_color = _S_rb_tree_black;\n-  }\n-  return __y;\n-}\n-\n-// Base class to encapsulate the differences between old SGI-style\n-// allocators and standard-conforming allocators.  In order to avoid\n-// having an empty base class, we arbitrarily move one of rb_tree's\n-// data members into the base class.\n-\n-// _Base for general standard-conforming allocators.\n-template <class _Tp, class _Alloc, bool _S_instanceless>\n-class _Rb_tree_alloc_base {\n-public:\n-  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return _M_node_allocator; }\n-\n-  _Rb_tree_alloc_base(const allocator_type& __a)\n-    : _M_node_allocator(__a), _M_header(0) {}\n-\n-protected:\n-  typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::allocator_type\n-           _M_node_allocator;\n-  _Rb_tree_node<_Tp>* _M_header;\n-\n-  _Rb_tree_node<_Tp>* _M_get_node() \n-    { return _M_node_allocator.allocate(1); }\n-  void _M_put_node(_Rb_tree_node<_Tp>* __p) \n-    { _M_node_allocator.deallocate(__p, 1); }\n-};\n-\n-// Specialization for instanceless allocators.\n-template <class _Tp, class _Alloc>\n-class _Rb_tree_alloc_base<_Tp, _Alloc, true> {\n-public:\n-  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Rb_tree_alloc_base(const allocator_type&) : _M_header(0) {}\n-\n-protected:\n-  _Rb_tree_node<_Tp>* _M_header;\n-\n-  typedef typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::_Alloc_type\n-          _Alloc_type;\n-\n-  _Rb_tree_node<_Tp>* _M_get_node()\n-    { return _Alloc_type::allocate(1); }\n-  void _M_put_node(_Rb_tree_node<_Tp>* __p)\n-    { _Alloc_type::deallocate(__p, 1); }\n-};\n-\n-template <class _Tp, class _Alloc>\n-struct _Rb_tree_base\n-  : public _Rb_tree_alloc_base<_Tp, _Alloc,\n-                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-{\n-  typedef _Rb_tree_alloc_base<_Tp, _Alloc,\n-                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-          _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n-\n-  _Rb_tree_base(const allocator_type& __a) \n-    : _Base(__a) { _M_header = _M_get_node(); }\n-  ~_Rb_tree_base() { _M_put_node(_M_header); }\n-\n-};\n-\n-\n-template <class _Key, class _Value, class _KeyOfValue, class _Compare,\n-          class _Alloc = allocator<_Value> >\n-class _Rb_tree : protected _Rb_tree_base<_Value, _Alloc> {\n-  typedef _Rb_tree_base<_Value, _Alloc> _Base;\n-protected:\n-  typedef _Rb_tree_node_base* _Base_ptr;\n-  typedef _Rb_tree_node<_Value> _Rb_tree_node;\n-  typedef _Rb_tree_Color_type _Color_type;\n-public:\n-  typedef _Key key_type;\n-  typedef _Value value_type;\n-  typedef value_type* pointer;\n-  typedef const value_type* const_pointer;\n-  typedef value_type& reference;\n-  typedef const value_type& const_reference;\n-  typedef _Rb_tree_node* _Link_type;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type;\n-\n-  typedef typename _Base::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return _Base::get_allocator(); }\n-\n-protected:\n-  using _Base::_M_get_node;\n-  using _Base::_M_put_node;\n-  using _Base::_M_header;\n-\n-protected:\n-\n-  _Link_type\n-  _M_create_node(const value_type& __x)\n-  {\n-    _Link_type __tmp = _M_get_node();\n-    try {\n-      _Construct(&__tmp->_M_value_field, __x);\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    _M_insert(_Base_ptr __x_, _Base_ptr __y_, const _Val& __v)\n+    {\n+      _Link_type __x = (_Link_type) __x_;\n+      _Link_type __y = (_Link_type) __y_;\n+      _Link_type __z;\n+      \n+      if (__y == _M_header || __x != 0 || \n+\t  _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) \n+\t{\n+\t  __z = _M_create_node(__v);\n+\t  _S_left(__y) = __z;               // also makes _M_leftmost() = __z \n+\t  //    when __y == _M_header\n+\t  if (__y == _M_header) \n+\t    {\n+\t      _M_root() = __z;\n+\t      _M_rightmost() = __z;\n+\t    }\n+\t  else if (__y == _M_leftmost())\n+\t    _M_leftmost() = __z; // maintain _M_leftmost() pointing to min node\n+\t}\n+      else \n+\t{\n+\t  __z = _M_create_node(__v);\n+\t  _S_right(__y) = __z;\n+\t  // Maintain _M_rightmost() pointing to max node.\n+\t  if (__y == _M_rightmost())\n+\t    _M_rightmost() = __z; \n+\t}\n+      _S_parent(__z) = __y;\n+      _S_left(__z) = 0;\n+      _S_right(__z) = 0;\n+      _Rb_tree_rebalance(__z, _M_header->_M_parent);\n+      ++_M_node_count;\n+      return iterator(__z);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    insert_equal(const _Val& __v)\n+    {\n+      _Link_type __y = _M_header;\n+      _Link_type __x = _M_root();\n+      while (__x != 0) \n+\t{\n+\t  __y = __x;\n+\t  __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ? \n+\t    _S_left(__x) : _S_right(__x);\n+\t}\n+      return _M_insert(__x, __y, __v);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator, \n+    bool>\n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    insert_unique(const _Val& __v)\n+    {\n+      _Link_type __y = _M_header;\n+      _Link_type __x = _M_root();\n+      bool __comp = true;\n+      while (__x != 0) \n+\t{\n+\t  __y = __x;\n+\t  __comp = _M_key_compare(_KeyOfValue()(__v), _S_key(__x));\n+\t  __x = __comp ? _S_left(__x) : _S_right(__x);\n+\t}\n+      iterator __j = iterator(__y);   \n+      if (__comp)\n+\tif (__j == begin())     \n+\t  return pair<iterator,bool>(_M_insert(__x, __y, __v), true);\n+\telse\n+\t  --__j;\n+      if (_M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))\n+\treturn pair<iterator,bool>(_M_insert(__x, __y, __v), true);\n+      return pair<iterator,bool>(__j, false);\n+    }\n+  \n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator \n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    insert_unique(iterator __position, const _Val& __v)\n+    {\n+      if (__position._M_node == _M_header->_M_left) \n+\t{ \n+\t  // begin()\n+\t  if (size() > 0 && \n+\t      _M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node)))\n+\t    return _M_insert(__position._M_node, __position._M_node, __v);\n+\t  // first argument just needs to be non-null \n+\t  else\n+\t    return insert_unique(__v).first;\n+\t} \n+      else if (__position._M_node == _M_header) \n+\t{ \n+\t  // end()\n+\t  if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))\n+\t    return _M_insert(0, _M_rightmost(), __v);\n+\t  else\n+\t    return insert_unique(__v).first;\n+\t} \n+      else \n+\t{\n+\t  iterator __before = __position;\n+\t  --__before;\n+\t  if (_M_key_compare(_S_key(__before._M_node), _KeyOfValue()(__v)) \n+\t      && _M_key_compare(_KeyOfValue()(__v),_S_key(__position._M_node)))\n+\t    {\n+\t      if (_S_right(__before._M_node) == 0)\n+\t\treturn _M_insert(0, __before._M_node, __v); \n+\t      else\n+\t\treturn _M_insert(__position._M_node, __position._M_node, __v);\n+\t      // first argument just needs to be non-null \n+\t    } \n+\t  else\n+\t    return insert_unique(__v).first;\n+\t}\n     }\n-    catch(...)\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    insert_equal(iterator __position, const _Val& __v)\n+    {\n+      if (__position._M_node == _M_header->_M_left) \n+\t{ \n+\t  // begin()\n+\t  if (size() > 0 && \n+\t      !_M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))\n+\t    return _M_insert(__position._M_node, __position._M_node, __v);\n+\t  // first argument just needs to be non-null \n+\t  else\n+\t    return insert_equal(__v);\n+\t} \n+      else if (__position._M_node == _M_header) \n+\t{\n+\t  // end()\n+\t  if (!_M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))\n+\t    return _M_insert(0, _M_rightmost(), __v);\n+\t  else\n+\t    return insert_equal(__v);\n+\t} \n+      else \n+\t{\n+\t  iterator __before = __position;\n+\t  --__before;\n+\t  if (!_M_key_compare(_KeyOfValue()(__v), _S_key(__before._M_node))\n+\t      && !_M_key_compare(_S_key(__position._M_node),\n+\t\t\t\t _KeyOfValue()(__v))) \n+\t    {\n+\t      if (_S_right(__before._M_node) == 0)\n+\t\treturn _M_insert(0, __before._M_node, __v); \n+\t      else\n+\t\treturn _M_insert(__position._M_node, __position._M_node, __v);\n+\t      // first argument just needs to be non-null \n+\t    } \n+\t  else\n+\t    return insert_equal(__v);\n+\t}\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KoV, \n+           typename _Cmp, typename _Alloc>\n+    template<class _II>\n+      void \n+      _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::\n+      insert_equal(_II __first, _II __last)\n       {\n-\t_M_put_node(__tmp);\n-\t__throw_exception_again; \n+\tfor ( ; __first != __last; ++__first)\n+\t  insert_equal(*__first);\n       }\n-    return __tmp;\n-  }\n \n-  _Link_type _M_clone_node(_Link_type __x)\n-  {\n-    _Link_type __tmp = _M_create_node(__x->_M_value_field);\n-    __tmp->_M_color = __x->_M_color;\n-    __tmp->_M_left = 0;\n-    __tmp->_M_right = 0;\n-    return __tmp;\n-  }\n+  template<typename _Key, typename _Val, typename _KoV, \n+           typename _Cmp, typename _Alloc> \n+    template<class _II>\n+    void \n+    _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::\n+    insert_unique(_II __first, _II __last) \n+    {\n+      for ( ; __first != __last; ++__first)\n+\tinsert_unique(*__first);\n+    }\n \n-  void\n-  destroy_node(_Link_type __p)\n-  {\n-    _Destroy(&__p->_M_value_field);\n-    _M_put_node(__p);\n-  }\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    inline void \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(iterator __position)\n+    {\n+      _Link_type __y = \n+\t(_Link_type) _Rb_tree_rebalance_for_erase(__position._M_node,\n+\t\t\t\t\t\t  _M_header->_M_parent,\n+\t\t\t\t\t\t  _M_header->_M_left,\n+\t\t\t\t\t\t  _M_header->_M_right);\n+      destroy_node(__y);\n+      --_M_node_count;\n+    }\n \n-protected:\n-  size_type _M_node_count; // keeps track of size of tree\n-  _Compare _M_key_compare;\n-\n-  _Link_type& _M_root() const \n-    { return (_Link_type&) _M_header->_M_parent; }\n-  _Link_type& _M_leftmost() const \n-    { return (_Link_type&) _M_header->_M_left; }\n-  _Link_type& _M_rightmost() const \n-    { return (_Link_type&) _M_header->_M_right; }\n-\n-  static _Link_type& _S_left(_Link_type __x)\n-    { return (_Link_type&)(__x->_M_left); }\n-  static _Link_type& _S_right(_Link_type __x)\n-    { return (_Link_type&)(__x->_M_right); }\n-  static _Link_type& _S_parent(_Link_type __x)\n-    { return (_Link_type&)(__x->_M_parent); }\n-  static reference _S_value(_Link_type __x)\n-    { return __x->_M_value_field; }\n-  static const _Key& _S_key(_Link_type __x)\n-    { return _KeyOfValue()(_S_value(__x)); }\n-  static _Color_type& _S_color(_Link_type __x)\n-    { return (_Color_type&)(__x->_M_color); }\n-\n-  static _Link_type& _S_left(_Base_ptr __x)\n-    { return (_Link_type&)(__x->_M_left); }\n-  static _Link_type& _S_right(_Base_ptr __x)\n-    { return (_Link_type&)(__x->_M_right); }\n-  static _Link_type& _S_parent(_Base_ptr __x)\n-    { return (_Link_type&)(__x->_M_parent); }\n-  static reference _S_value(_Base_ptr __x)\n-    { return ((_Link_type)__x)->_M_value_field; }\n-  static const _Key& _S_key(_Base_ptr __x)\n-    { return _KeyOfValue()(_S_value(_Link_type(__x)));} \n-  static _Color_type& _S_color(_Base_ptr __x)\n-    { return (_Color_type&)(_Link_type(__x)->_M_color); }\n-\n-  static _Link_type _S_minimum(_Link_type __x) \n-    { return (_Link_type)  _Rb_tree_node_base::_S_minimum(__x); }\n-\n-  static _Link_type _S_maximum(_Link_type __x)\n-    { return (_Link_type) _Rb_tree_node_base::_S_maximum(__x); }\n-\n-public:\n-  typedef _Rb_tree_iterator<value_type, reference, pointer> iterator;\n-  typedef _Rb_tree_iterator<value_type, const_reference, const_pointer> \n-          const_iterator;\n-\n-  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-  typedef reverse_iterator<iterator> reverse_iterator;\n-\n-private:\n-  iterator _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);\n-  _Link_type _M_copy(_Link_type __x, _Link_type __p);\n-  void _M_erase(_Link_type __x);\n-\n-public:\n-                                // allocation/deallocation\n-  _Rb_tree()\n-    : _Base(allocator_type()), _M_node_count(0), _M_key_compare()\n-    { _M_empty_initialize(); }\n-\n-  _Rb_tree(const _Compare& __comp)\n-    : _Base(allocator_type()), _M_node_count(0), _M_key_compare(__comp) \n-    { _M_empty_initialize(); }\n-\n-  _Rb_tree(const _Compare& __comp, const allocator_type& __a)\n-    : _Base(__a), _M_node_count(0), _M_key_compare(__comp) \n-    { _M_empty_initialize(); }\n-\n-  _Rb_tree(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x) \n-    : _Base(__x.get_allocator()),\n-      _M_node_count(0), _M_key_compare(__x._M_key_compare)\n-  { \n-    if (__x._M_root() == 0)\n-      _M_empty_initialize();\n-    else {\n-      _S_color(_M_header) = _S_rb_tree_red;\n-      _M_root() = _M_copy(__x._M_root(), _M_header);\n-      _M_leftmost() = _S_minimum(_M_root());\n-      _M_rightmost() = _S_maximum(_M_root());\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(const _Key& __x)\n+    {\n+      pair<iterator,iterator> __p = equal_range(__x);\n+      size_type __n = distance(__p.first, __p.second);\n+      erase(__p.first, __p.second);\n+      return __n;\n     }\n-    _M_node_count = __x._M_node_count;\n-  }\n-  ~_Rb_tree() { clear(); }\n-  _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& \n-  operator=(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x);\n-\n-private:\n-  void _M_empty_initialize() {\n-    _S_color(_M_header) = _S_rb_tree_red; // used to distinguish header from \n-                                          // __root, in iterator.operator++\n-    _M_root() = 0;\n-    _M_leftmost() = _M_header;\n-    _M_rightmost() = _M_header;\n-  }\n \n-public:    \n-                                // accessors:\n-  _Compare key_comp() const { return _M_key_compare; }\n-  iterator begin() { return _M_leftmost(); }\n-  const_iterator begin() const { return _M_leftmost(); }\n-  iterator end() { return _M_header; }\n-  const_iterator end() const { return _M_header; }\n-  reverse_iterator rbegin() { return reverse_iterator(end()); }\n-  const_reverse_iterator rbegin() const { \n-    return const_reverse_iterator(end()); \n-  }\n-  reverse_iterator rend() { return reverse_iterator(begin()); }\n-  const_reverse_iterator rend() const { \n-    return const_reverse_iterator(begin());\n-  } \n-  bool empty() const { return _M_node_count == 0; }\n-  size_type size() const { return _M_node_count; }\n-  size_type max_size() const { return size_type(-1); }\n-\n-  void swap(_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __t) {\n-    std::swap(_M_header, __t._M_header);\n-    std::swap(_M_node_count, __t._M_node_count);\n-    std::swap(_M_key_compare, __t._M_key_compare);\n-  }\n-    \n-public:\n-                                // insert/erase\n-  pair<iterator,bool> insert_unique(const value_type& __x);\n-  iterator insert_equal(const value_type& __x);\n-\n-  iterator insert_unique(iterator __position, const value_type& __x);\n-  iterator insert_equal(iterator __position, const value_type& __x);\n-\n-  template <class _InputIterator>\n-  void insert_unique(_InputIterator __first, _InputIterator __last);\n-  template <class _InputIterator>\n-  void insert_equal(_InputIterator __first, _InputIterator __last);\n-\n-  void erase(iterator __position);\n-  size_type erase(const key_type& __x);\n-  void erase(iterator __first, iterator __last);\n-  void erase(const key_type* __first, const key_type* __last);\n-  void clear() {\n-    if (_M_node_count != 0) {\n-      _M_erase(_M_root());\n-      _M_leftmost() = _M_header;\n-      _M_root() = 0;\n-      _M_rightmost() = _M_header;\n-      _M_node_count = 0;\n+  template<typename _Key, typename _Val, typename _KoV, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type \n+    _Rb_tree<_Key,_Val,_KoV,_Compare,_Alloc>::\n+    _M_copy(_Link_type __x, _Link_type __p)\n+    {\n+      // Structural copy.  __x and __p must be non-null.\n+      _Link_type __top = _M_clone_node(__x);\n+      __top->_M_parent = __p;\n+      \n+      try \n+\t{\n+\t  if (__x->_M_right)\n+\t    __top->_M_right = _M_copy(_S_right(__x), __top);\n+\t  __p = __top;\n+\t  __x = _S_left(__x);\n+\t  \n+\t  while (__x != 0) \n+\t    {\n+\t      _Link_type __y = _M_clone_node(__x);\n+\t      __p->_M_left = __y;\n+\t      __y->_M_parent = __p;\n+\t      if (__x->_M_right)\n+\t\t__y->_M_right = _M_copy(_S_right(__x), __y);\n+\t      __p = __y;\n+\t      __x = _S_left(__x);\n+\t    }\n+\t}\n+      catch(...)\n+\t{\n+\t  _M_erase(__top);\n+\t  __throw_exception_again; \n+\t}\n+      return __top;\n     }\n-  }      \n-\n-public:\n-                                // set operations:\n-  iterator find(const key_type& __x);\n-  const_iterator find(const key_type& __x) const;\n-  size_type count(const key_type& __x) const;\n-  iterator lower_bound(const key_type& __x);\n-  const_iterator lower_bound(const key_type& __x) const;\n-  iterator upper_bound(const key_type& __x);\n-  const_iterator upper_bound(const key_type& __x) const;\n-  pair<iterator,iterator> equal_range(const key_type& __x);\n-  pair<const_iterator, const_iterator> equal_range(const key_type& __x) const;\n-\n-public:\n-                                // Debugging.\n-  bool __rb_verify() const;\n-};\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-inline bool \n-operator==(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, \n-           const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y)\n-{\n-  return __x.size() == __y.size() &&\n-         equal(__x.begin(), __x.end(), __y.begin());\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-inline bool \n-operator<(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, \n-          const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y)\n-{\n-  return lexicographical_compare(__x.begin(), __x.end(), \n-                                 __y.begin(), __y.end());\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-inline bool \n-operator!=(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, \n-           const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-inline bool \n-operator>(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, \n-          const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y) {\n-  return __y < __x;\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-inline bool \n-operator<=(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, \n-           const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y) {\n-  return !(__y < __x);\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-inline bool \n-operator>=(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, \n-           const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y) {\n-  return !(__x < __y);\n-}\n-\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-inline void \n-swap(_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, \n-     _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y)\n-{\n-  __x.swap(__y);\n-}\n-\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& \n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::operator=(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x)\n-{\n-  if (this != &__x) {\n-                                // Note that _Key may be a constant type.\n-    clear();\n-    _M_node_count = 0;\n-    _M_key_compare = __x._M_key_compare;        \n-    if (__x._M_root() == 0) {\n-      _M_root() = 0;\n-      _M_leftmost() = _M_header;\n-      _M_rightmost() = _M_header;\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    void \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_M_erase(_Link_type __x)\n+    {\n+      // Erase without rebalancing.\n+      while (__x != 0) \n+\t{\n+\t  _M_erase(_S_right(__x));\n+\t  _Link_type __y = _S_left(__x);\n+\t  destroy_node(__x);\n+\t  __x = __y;\n+\t}\n     }\n-    else {\n-      _M_root() = _M_copy(__x._M_root(), _M_header);\n-      _M_leftmost() = _S_minimum(_M_root());\n-      _M_rightmost() = _S_maximum(_M_root());\n-      _M_node_count = __x._M_node_count;\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    void \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    erase(iterator __first, iterator __last)\n+    {\n+      if (__first == begin() && __last == end())\n+\tclear();\n+      else\n+\twhile (__first != __last) erase(__first++);\n     }\n-  }\n-  return *this;\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator\n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::_M_insert(_Base_ptr __x_, _Base_ptr __y_, const _Value& __v)\n-{\n-  _Link_type __x = (_Link_type) __x_;\n-  _Link_type __y = (_Link_type) __y_;\n-  _Link_type __z;\n-\n-  if (__y == _M_header || __x != 0 || \n-      _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) {\n-    __z = _M_create_node(__v);\n-    _S_left(__y) = __z;               // also makes _M_leftmost() = __z \n-                                      //    when __y == _M_header\n-    if (__y == _M_header) {\n-      _M_root() = __z;\n-      _M_rightmost() = __z;\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    void \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    erase(const _Key* __first, const _Key* __last) \n+    { \n+      while (__first != __last) \n+\terase(*__first++); \n     }\n-    else if (__y == _M_leftmost())\n-      _M_leftmost() = __z;   // maintain _M_leftmost() pointing to min node\n-  }\n-  else {\n-    __z = _M_create_node(__v);\n-    _S_right(__y) = __z;\n-    if (__y == _M_rightmost())\n-      _M_rightmost() = __z;  // maintain _M_rightmost() pointing to max node\n-  }\n-  _S_parent(__z) = __y;\n-  _S_left(__z) = 0;\n-  _S_right(__z) = 0;\n-  _Rb_tree_rebalance(__z, _M_header->_M_parent);\n-  ++_M_node_count;\n-  return iterator(__z);\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator\n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::insert_equal(const _Value& __v)\n-{\n-  _Link_type __y = _M_header;\n-  _Link_type __x = _M_root();\n-  while (__x != 0) {\n-    __y = __x;\n-    __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ? \n-            _S_left(__x) : _S_right(__x);\n-  }\n-  return _M_insert(__x, __y, __v);\n-}\n-\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-pair<typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator, \n-     bool>\n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::insert_unique(const _Value& __v)\n-{\n-  _Link_type __y = _M_header;\n-  _Link_type __x = _M_root();\n-  bool __comp = true;\n-  while (__x != 0) {\n-    __y = __x;\n-    __comp = _M_key_compare(_KeyOfValue()(__v), _S_key(__x));\n-    __x = __comp ? _S_left(__x) : _S_right(__x);\n-  }\n-  iterator __j = iterator(__y);   \n-  if (__comp)\n-    if (__j == begin())     \n-      return pair<iterator,bool>(_M_insert(__x, __y, __v), true);\n-    else\n-      --__j;\n-  if (_M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))\n-    return pair<iterator,bool>(_M_insert(__x, __y, __v), true);\n-  return pair<iterator,bool>(__j, false);\n-}\n-\n-\n-template <class _Key, class _Val, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator \n-_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>\n-  ::insert_unique(iterator __position, const _Val& __v)\n-{\n-  if (__position._M_node == _M_header->_M_left) { // begin()\n-    if (size() > 0 && \n-       _M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node)))\n-      return _M_insert(__position._M_node, __position._M_node, __v);\n-    // first argument just needs to be non-null \n-    else\n-      return insert_unique(__v).first;\n-  } else if (__position._M_node == _M_header) { // end()\n-    if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))\n-      return _M_insert(0, _M_rightmost(), __v);\n-    else\n-      return insert_unique(__v).first;\n-  } else {\n-    iterator __before = __position;\n-    --__before;\n-    if (_M_key_compare(_S_key(__before._M_node), _KeyOfValue()(__v)) \n-        && _M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node))) {\n-      if (_S_right(__before._M_node) == 0)\n-        return _M_insert(0, __before._M_node, __v); \n-      else\n-        return _M_insert(__position._M_node, __position._M_node, __v);\n-    // first argument just needs to be non-null \n-    } else\n-      return insert_unique(__v).first;\n-  }\n-}\n-\n-template <class _Key, class _Val, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n-_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>\n-  ::insert_equal(iterator __position, const _Val& __v)\n-{\n-  if (__position._M_node == _M_header->_M_left) { // begin()\n-    if (size() > 0 && \n-\t!_M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))\n-      return _M_insert(__position._M_node, __position._M_node, __v);\n-    // first argument just needs to be non-null \n-    else\n-      return insert_equal(__v);\n-  } else if (__position._M_node == _M_header) {// end()\n-    if (!_M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))\n-      return _M_insert(0, _M_rightmost(), __v);\n-    else\n-      return insert_equal(__v);\n-  } else {\n-    iterator __before = __position;\n-    --__before;\n-    if (!_M_key_compare(_KeyOfValue()(__v), _S_key(__before._M_node))\n-        && !_M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v))) {\n-      if (_S_right(__before._M_node) == 0)\n-        return _M_insert(0, __before._M_node, __v); \n-      else\n-        return _M_insert(__position._M_node, __position._M_node, __v);\n-    // first argument just needs to be non-null \n-    } else\n-      return insert_equal(__v);\n-  }\n-}\n-\n-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc>\n-  template<class _II>\n-void _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>\n-  ::insert_equal(_II __first, _II __last)\n-{\n-  for ( ; __first != __last; ++__first)\n-    insert_equal(*__first);\n-}\n-\n-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc> \n-  template<class _II>\n-void _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>\n-  ::insert_unique(_II __first, _II __last) {\n-  for ( ; __first != __last; ++__first)\n-    insert_unique(*__first);\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-inline void _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::erase(iterator __position)\n-{\n-  _Link_type __y = \n-    (_Link_type) _Rb_tree_rebalance_for_erase(__position._M_node,\n-                                              _M_header->_M_parent,\n-                                              _M_header->_M_left,\n-                                              _M_header->_M_right);\n-  destroy_node(__y);\n-  --_M_node_count;\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::size_type \n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::erase(const _Key& __x)\n-{\n-  pair<iterator,iterator> __p = equal_range(__x);\n-  size_type __n = distance(__p.first, __p.second);\n-  erase(__p.first, __p.second);\n-  return __n;\n-}\n-\n-template <class _Key, class _Val, class _KoV, class _Compare, class _Alloc>\n-typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type \n-_Rb_tree<_Key,_Val,_KoV,_Compare,_Alloc>\n-  ::_M_copy(_Link_type __x, _Link_type __p)\n-{\n-                        // structural copy.  __x and __p must be non-null.\n-  _Link_type __top = _M_clone_node(__x);\n-  __top->_M_parent = __p;\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k)\n+    {\n+      _Link_type __y = _M_header;  // Last node which is not less than __k. \n+      _Link_type __x = _M_root();  // Current node. \n+      \n+      while (__x != 0) \n+\tif (!_M_key_compare(_S_key(__x), __k))\n+\t  __y = __x, __x = _S_left(__x);\n+\telse\n+\t  __x = _S_right(__x);\n+      \n+      iterator __j = iterator(__y);   \n+      return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ? \n+\tend() : __j;\n+    }\n+  \n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    find(const _Key& __k) const\n+    {\n+      _Link_type __y = _M_header; // Last node which is not less than __k. \n+      _Link_type __x = _M_root(); // Current node. \n  \n-  try {\n-    if (__x->_M_right)\n-      __top->_M_right = _M_copy(_S_right(__x), __top);\n-    __p = __top;\n-    __x = _S_left(__x);\n-\n-    while (__x != 0) {\n-      _Link_type __y = _M_clone_node(__x);\n-      __p->_M_left = __y;\n-      __y->_M_parent = __p;\n-      if (__x->_M_right)\n-        __y->_M_right = _M_copy(_S_right(__x), __y);\n-      __p = __y;\n-      __x = _S_left(__x);\n+     while (__x != 0) \n+       {\n+\t if (!_M_key_compare(_S_key(__x), __k))\n+\t   __y = __x, __x = _S_left(__x);\n+\t else\n+\t   __x = _S_right(__x);\n+       } \n+     const_iterator __j = const_iterator(__y);   \n+     return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ?\n+       end() : __j;\n     }\n-  }\n-  catch(...)\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    count(const _Key& __k) const\n     {\n-      _M_erase(__top);\n-      __throw_exception_again; \n+      pair<const_iterator, const_iterator> __p = equal_range(__k);\n+      size_type __n = distance(__p.first, __p.second);\n+      return __n;\n     }\n-  return __top;\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-void _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::_M_erase(_Link_type __x)\n-{\n-                                // erase without rebalancing\n-  while (__x != 0) {\n-    _M_erase(_S_right(__x));\n-    _Link_type __y = _S_left(__x);\n-    destroy_node(__x);\n-    __x = __y;\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    lower_bound(const _Key& __k)\n+    {\n+      _Link_type __y = _M_header; /* Last node which is not less than __k. */\n+      _Link_type __x = _M_root(); /* Current node. */\n+      \n+      while (__x != 0) \n+\tif (!_M_key_compare(_S_key(__x), __k))\n+\t  __y = __x, __x = _S_left(__x);\n+\telse\n+\t  __x = _S_right(__x);\n+      \n+      return iterator(__y);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    lower_bound(const _Key& __k) const\n+    {\n+      _Link_type __y = _M_header; /* Last node which is not less than __k. */\n+      _Link_type __x = _M_root(); /* Current node. */\n+      \n+      while (__x != 0) \n+\tif (!_M_key_compare(_S_key(__x), __k))\n+\t  __y = __x, __x = _S_left(__x);\n+\telse\n+\t  __x = _S_right(__x);\n+      \n+      return const_iterator(__y);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    upper_bound(const _Key& __k)\n+    {\n+      _Link_type __y = _M_header; /* Last node which is greater than __k. */\n+      _Link_type __x = _M_root(); /* Current node. */\n+      \n+      while (__x != 0) \n+\tif (_M_key_compare(__k, _S_key(__x)))\n+\t  __y = __x, __x = _S_left(__x);\n+\telse\n+\t  __x = _S_right(__x);\n+      \n+      return iterator(__y);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    upper_bound(const _Key& __k) const\n+    {\n+      _Link_type __y = _M_header; /* Last node which is greater than __k. */\n+      _Link_type __x = _M_root(); /* Current node. */\n+      \n+      while (__x != 0) \n+\tif (_M_key_compare(__k, _S_key(__x)))\n+\t  __y = __x, __x = _S_left(__x);\n+\telse\n+\t  __x = _S_right(__x);\n+      \n+      return const_iterator(__y);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    inline \n+    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator,\n+\t\t\t\t\t\t\t\t   typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator>\n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    equal_range(const _Key& __k)\n+    { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }\n+\n+  template<typename _Key, typename _Val, typename _KoV, \n+           typename _Compare, typename _Alloc>\n+  inline \n+  pair<typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator,\n+\t\t\t\t\t\t\t\ttypename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>\n+  _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>\n+  ::equal_range(const _Key& __k) const\n+  {\n+    return pair<const_iterator,const_iterator>(lower_bound(__k),\n+\t\t\t\t\t       upper_bound(__k));\n   }\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-void _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::erase(iterator __first, iterator __last)\n-{\n-  if (__first == begin() && __last == end())\n-    clear();\n-  else\n-    while (__first != __last) erase(__first++);\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-void _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::erase(const _Key* __first, const _Key* __last) \n-{\n-  while (__first != __last) erase(*__first++);\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator \n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k)\n-{\n-  _Link_type __y = _M_header;      // Last node which is not less than __k. \n-  _Link_type __x = _M_root();      // Current node. \n-\n-  while (__x != 0) \n-    if (!_M_key_compare(_S_key(__x), __k))\n-      __y = __x, __x = _S_left(__x);\n-    else\n-      __x = _S_right(__x);\n-\n-  iterator __j = iterator(__y);   \n-  return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ? \n-     end() : __j;\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::const_iterator \n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k) const\n-{\n-  _Link_type __y = _M_header; /* Last node which is not less than __k. */\n-  _Link_type __x = _M_root(); /* Current node. */\n-\n-  while (__x != 0) {\n-    if (!_M_key_compare(_S_key(__x), __k))\n-      __y = __x, __x = _S_left(__x);\n-    else\n-      __x = _S_right(__x);\n+\n+  inline int\n+  __black_count(_Rb_tree_node_base* __node, _Rb_tree_node_base* __root)\n+  {\n+    if (__node == 0)\n+      return 0;\n+    int __sum = 0;\n+    do \n+      {\n+\tif (__node->_M_color == _M_black) \n+\t  ++__sum;\n+\tif (__node == __root) \n+\t  break;\n+\t__node = __node->_M_parent;\n+      } \n+    while (1);\n+    return __sum;\n   }\n-  const_iterator __j = const_iterator(__y);   \n-  return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ?\n-    end() : __j;\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::size_type \n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::count(const _Key& __k) const\n-{\n-  pair<const_iterator, const_iterator> __p = equal_range(__k);\n-  size_type __n = distance(__p.first, __p.second);\n-  return __n;\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator \n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::lower_bound(const _Key& __k)\n-{\n-  _Link_type __y = _M_header; /* Last node which is not less than __k. */\n-  _Link_type __x = _M_root(); /* Current node. */\n-\n-  while (__x != 0) \n-    if (!_M_key_compare(_S_key(__x), __k))\n-      __y = __x, __x = _S_left(__x);\n-    else\n-      __x = _S_right(__x);\n-\n-  return iterator(__y);\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::const_iterator \n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::lower_bound(const _Key& __k) const\n-{\n-  _Link_type __y = _M_header; /* Last node which is not less than __k. */\n-  _Link_type __x = _M_root(); /* Current node. */\n-\n-  while (__x != 0) \n-    if (!_M_key_compare(_S_key(__x), __k))\n-      __y = __x, __x = _S_left(__x);\n-    else\n-      __x = _S_right(__x);\n-\n-  return const_iterator(__y);\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator \n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::upper_bound(const _Key& __k)\n-{\n-  _Link_type __y = _M_header; /* Last node which is greater than __k. */\n-  _Link_type __x = _M_root(); /* Current node. */\n-\n-   while (__x != 0) \n-     if (_M_key_compare(__k, _S_key(__x)))\n-       __y = __x, __x = _S_left(__x);\n-     else\n-       __x = _S_right(__x);\n-\n-   return iterator(__y);\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::const_iterator \n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::upper_bound(const _Key& __k) const\n-{\n-  _Link_type __y = _M_header; /* Last node which is greater than __k. */\n-  _Link_type __x = _M_root(); /* Current node. */\n-\n-   while (__x != 0) \n-     if (_M_key_compare(__k, _S_key(__x)))\n-       __y = __x, __x = _S_left(__x);\n-     else\n-       __x = _S_right(__x);\n-\n-   return const_iterator(__y);\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-inline \n-pair<typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator,\n-     typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator>\n-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n-  ::equal_range(const _Key& __k)\n-{\n-  return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k));\n-}\n-\n-template <class _Key, class _Value, class _KoV, class _Compare, class _Alloc>\n-inline \n-pair<typename _Rb_tree<_Key, _Value, _KoV, _Compare, _Alloc>::const_iterator,\n-     typename _Rb_tree<_Key, _Value, _KoV, _Compare, _Alloc>::const_iterator>\n-_Rb_tree<_Key, _Value, _KoV, _Compare, _Alloc>\n-  ::equal_range(const _Key& __k) const\n-{\n-  return pair<const_iterator,const_iterator>(lower_bound(__k),\n-                                             upper_bound(__k));\n-}\n-\n-inline int\n-__black_count(_Rb_tree_node_base* __node, _Rb_tree_node_base* __root)\n-{\n-  if (__node == 0)\n-    return 0;\n-  int __sum = 0;\n-  do {\n-    if (__node->_M_color == _S_rb_tree_black) \n-      ++__sum;\n-    if (__node == __root) \n-      break;\n-    __node = __node->_M_parent;\n-  } while (1);\n-  return __sum;\n-}\n-\n-template <class _Key, class _Value, class _KeyOfValue, \n-          class _Compare, class _Alloc>\n-bool _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const\n-{\n-  if (_M_node_count == 0 || begin() == end())\n-    return _M_node_count == 0 && begin() == end() &&\n-      _M_header->_M_left == _M_header && _M_header->_M_right == _M_header;\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    bool \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const\n+    {\n+    if (_M_node_count == 0 || begin() == end())\n+      return _M_node_count == 0 && begin() == end() &&\n+\t_M_header->_M_left == _M_header && _M_header->_M_right == _M_header;\n   \n-  int __len = __black_count(_M_leftmost(), _M_root());\n-  for (const_iterator __it = begin(); __it != end(); ++__it) {\n-    _Link_type __x = (_Link_type) __it._M_node;\n-    _Link_type __L = _S_left(__x);\n-    _Link_type __R = _S_right(__x);\n-\n-    if (__x->_M_color == _S_rb_tree_red)\n-      if ((__L && __L->_M_color == _S_rb_tree_red) ||\n-          (__R && __R->_M_color == _S_rb_tree_red))\n-        return false;\n-\n-    if (__L && _M_key_compare(_S_key(__x), _S_key(__L)))\n-      return false;\n-    if (__R && _M_key_compare(_S_key(__R), _S_key(__x)))\n+    int __len = __black_count(_M_leftmost(), _M_root());\n+    for (const_iterator __it = begin(); __it != end(); ++__it) \n+      {\n+\t_Link_type __x = (_Link_type) __it._M_node;\n+\t_Link_type __L = _S_left(__x);\n+\t_Link_type __R = _S_right(__x);\n+\t\n+\tif (__x->_M_color == _M_red)\n+\t  if ((__L && __L->_M_color == _M_red) \n+\t      || (__R && __R->_M_color == _M_red))\n+\t    return false;\n+\t\n+\tif (__L && _M_key_compare(_S_key(__x), _S_key(__L)))\n+\t  return false;\n+\tif (__R && _M_key_compare(_S_key(__R), _S_key(__x)))\n+\t  return false;\n+\n+\tif (!__L && !__R && __black_count(__x, _M_root()) != __len)\n+\t  return false;\n+      }\n+    \n+    if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))\n       return false;\n-\n-    if (!__L && !__R && __black_count(__x, _M_root()) != __len)\n+    if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))\n       return false;\n-  }\n-\n-  if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))\n-    return false;\n-  if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))\n-    return false;\n-\n-  return true;\n-}\n-\n+    return true;\n+    }\n } // namespace std \n \n-#endif /* __GLIBCPP_INTERNAL_TREE_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n+#endif "}, {"sha": "eaf55599f2b52068fdd1a19fea83e6152d4113fa", "filename": "libstdc++-v3/src/stl-inst.cc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc?ref=d3d526aca6ce9d2f04104b038f092e14731fa813", "patch": "@@ -39,12 +39,6 @@\n \n namespace std\n {\n-  const int __stl_threshold = 16;\n-  const int __stl_chunk_size = 7;\n-  const int __WORD_BIT = int(CHAR_BIT*sizeof(unsigned int));\n-  const _Rb_tree_Color_type _S_rb_tree_red = false;\n-  const _Rb_tree_Color_type _S_rb_tree_black = true;\n-\n   template class __malloc_alloc_template<0>;\n \n #ifndef __USE_MALLOC\n@@ -55,5 +49,4 @@ namespace std\n     void\n     vector<unsigned int>::\n     _M_insert_aux(vector<unsigned int>::iterator, unsigned int const &);\n-\n } // namespace std"}, {"sha": "820bbaca54f4a143d2775b1c49c996d0c4d55aa3", "filename": "libstdc++-v3/testsuite/23_containers/vector_bool.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_bool.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d526aca6ce9d2f04104b038f092e14731fa813/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_bool.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_bool.cc?ref=d3d526aca6ce9d2f04104b038f092e14731fa813", "patch": "@@ -0,0 +1,36 @@\n+// 2002-03-05 Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.5  class vector<bool>\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::vector<bool>::iterator i;\n+  ++i;\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}