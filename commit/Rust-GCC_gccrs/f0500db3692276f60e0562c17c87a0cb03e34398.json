{"sha": "f0500db3692276f60e0562c17c87a0cb03e34398", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA1MDBkYjM2OTIyNzZmNjBlMDU2MmMxN2M4N2EwY2IwM2UzNDM5OA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-07-15T19:15:03Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-07-15T19:15:31Z"}, "message": "Detect buffer overflow by aggregate and vector stores [PR97027].\n\nResolves:\nPR middle-end/97027 - missing warning on buffer overflow storing a larger scalar into a smaller array\n\ngcc/ChangeLog:\n\n\tPR middle-end/97027\n\t* tree-ssa-strlen.c (handle_assign): New function.\n\t(maybe_warn_overflow): Add argument.\n\t(nonzero_bytes_for_type): New function.\n\t(count_nonzero_bytes): Handle more tree types.  Call\n\tnonzero_bytes_for_tye.\n\t(count_nonzero_bytes): Handle types.\n\t(handle_store): Handle stores from function calls.\n\t(strlen_check_and_optimize_call): Move code to handle_assign.  Call\n\tit for assignments from function calls.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/97027\n\t* gcc.dg/Wstringop-overflow-15.c: Remove an xfail.\n\t* gcc.dg/Wstringop-overflow-47.c: Adjust xfails.\n\t* gcc.dg/torture/pr69170.c: Avoid valid warnings.\n\t* gcc.dg/torture/pr70025.c: Prune out a false positive.\n\t* gcc.dg/vect/pr97769.c: Initialize a loop control variable.\n\t* gcc.target/i386/pr92658-avx512bw-trunc.c: Increase buffer size\n\tto avoid overflow.\n\t* gcc.target/i386/pr92658-avx512f.c: Same.\n\t* gcc.dg/Wstringop-overflow-68.c: New test.\n\t* gcc.dg/Wstringop-overflow-69.c: New test.\n\t* gcc.dg/Wstringop-overflow-70.c: New test.\n\t* gcc.dg/Wstringop-overflow-71.c: New test.\n\t* gcc.dg/strlenopt-95.c: New test.", "tree": {"sha": "a554e06c15a6fac71835bf2c5da27ad9d4fc91f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a554e06c15a6fac71835bf2c5da27ad9d4fc91f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0500db3692276f60e0562c17c87a0cb03e34398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0500db3692276f60e0562c17c87a0cb03e34398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0500db3692276f60e0562c17c87a0cb03e34398", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0500db3692276f60e0562c17c87a0cb03e34398/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33255ad3ac14e3953750fe0f2d82b901c2852ff6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33255ad3ac14e3953750fe0f2d82b901c2852ff6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33255ad3ac14e3953750fe0f2d82b901c2852ff6"}], "stats": {"total": 670, "additions": 588, "deletions": 82}, "files": [{"sha": "87f8462d431f48e53c7e62b694a7270021009cbb", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-15.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-15.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -30,7 +30,7 @@ void vla_bounded (int n)\n   a[0] = 0;\n   a[1] = 1;\n   a[n] = n;         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" { xfail *-*-* } }\n-  a[69] = n;        // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" { xfail *-*-* } }\n+  a[69] = n;        // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" }\n \n   sink (&a);\n }"}, {"sha": "968f6ee4ad4a1373ad9885bf4f536eece9d4bff0", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-47.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -31,15 +31,15 @@ void nowarn_c32 (char c)\n \n void warn_c32 (char c)\n {\n-  extern char warn_a32[32];   // { dg-message \"at offset 32 into destination object 'warn_a32' of size 32\" \"pr97027\" }\n+  extern char warn_a32[32];   // { dg-message \"at offset (32|1) into destination object 'warn_a32' of size 32\" \"pr97027\" }\n \n   void *p = warn_a32 + 1;\n-  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" }\n+  *(C32*)p = (C32){ c };      // { dg-warning \"writing (1 byte|32 bytes) into a region of size (0|31)\" \"pr97027\" }\n \n   /* Verify a local variable too. */\n   char a32[32];\n   p = a32 + 1;\n-  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" }\n+  *(C32*)p = (C32){ c };      // { dg-warning \"writing (1 byte|32 bytes) into a region of size (0|31)\" \"pr97027\" }\n   sink (p);\n }\n \n@@ -60,15 +60,20 @@ void nowarn_i16_64 (int16_t i)\n \n void warn_i16_64 (int16_t i)\n {\n-  extern char warn_a64[64];   // { dg-message \"at offset 128 to object 'warn_a64' with size 64\" \"pr97027\" { xfail *-*-* } }\n+/* The IL below that's visible to the warning changes from one target to\n+   another.  On some like aarch64 it's a single vector store, on others\n+   like x86_64 it's a series of BIT_FIELD_REFs.  The overflow by\n+   the former is detected but the latter is not yet.  */\n+\n+ extern char warn_a64[64];   // { dg-message \"at offset (1|128) into destination object 'warn_a64' of size (63|64)\" \"pr97027 note\" { xfail { ! aarch64-*-* } } }\n \n   void *p = warn_a64 + 1;\n   I16_64 *q = (I16_64*)p;\n-  *q = (I16_64){ i };         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" { xfail *-*-* } }\n+  *q = (I16_64){ i };         // { dg-warning \"writing (1 byte|64 bytes) into a region of size (0|63)\" \"pr97027\" { xfail { ! aarch64-*-* } } }\n \n   char a64[64];\n   p = a64 + 1;\n   q = (I16_64*)p;\n-  *q = (I16_64){ i };         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" { xfail *-*-* } }\n+  *q = (I16_64){ i };         // { dg-warning \"writing (1 byte|64 bytes) into a region of size (0|63)\" \"pr97027\" { xfail { ! aarch64-*-* } } }\n   sink (p);\n }"}, {"sha": "d2d3ae5f853302d6cadfee6b119b332c8af4608f", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-68.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -0,0 +1,104 @@\n+/* PR tree-optimization/97027 - missing warning on buffer overflow storing\n+   a larger scalar into a smaller array\n+   Verify overflow by aggregate stores.\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+#define A(N) (A ## N)\n+#define Ac1 (AC1){ 0 }\n+#define Ac2 (AC2){ 0, 1 }\n+#define Ac4 (AC4){ 0, 1, 2, 3 }\n+#define Ac8 (AC8){ 0, 1, 2, 3, 4, 5, 6, 7 }\n+#define Ac16 (AC16){ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }\n+\n+typedef struct AC1 { char a[1]; } AC1;\n+typedef struct AC2 { char a[2]; } AC2;\n+typedef struct AC3 { char a[3]; } AC3;\n+typedef struct AC4 { char a[4]; } AC4;\n+typedef struct AC5 { char a[5]; } AC5;\n+typedef struct AC8 { char a[8]; } AC8;\n+typedef struct AC16 { char a[16]; } AC16;\n+\n+extern char a1[1], a2[2], a3[3], a4[4], a5[5], a6[6], a7[7], a8[8], a15[15];\n+\n+extern AC1 ac1;\n+extern AC2 ac2;\n+extern AC4 ac4;\n+extern AC8 ac8;\n+extern AC16 ac16;\n+\n+extern AC1 fac1 (void);\n+extern AC2 fac2 (void);\n+extern AC4 fac4 (void);\n+extern AC8 fac8 (void);\n+extern AC16 fac16 (void);\n+\n+void nowarn (void)\n+{\n+  *(AC1*)a1 = Ac1;\n+  *(AC2*)a2 = Ac2;\n+  *(AC4*)a4 = Ac4;\n+  *(AC4*)a5 = Ac4;\n+  *(AC4*)a6 = Ac4;\n+  *(AC4*)a7 = Ac4;\n+  *(AC8*)a8 = Ac8;\n+  *(AC8*)a15 = Ac8;\n+}\n+\n+void warn_comp_lit_zero (void)\n+{\n+  *(AC2*)a1 = (AC2){ }; // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+  *(AC4*)a2 = (AC4){ }; // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+  *(AC4*)a3 = (AC4){ }; // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+  *(AC8*)a4 = (AC8){ }; // { dg-warning \"writing 8 bytes into a region of size 4\" }\n+  *(AC8*)a7 = (AC8){ }; // { dg-warning \"writing 8 bytes into a region of size 7\" }\n+  *(AC16*)a15 = (AC16){ };// { dg-warning \"writing 16 bytes into a region of size 15\" }\n+}\n+\n+void warn_comp_lit (void)\n+{\n+  *(AC2*)a1 = Ac2;      // { dg-warning \"writing 2 bytes into a region of size 1\" \"pr??????\" { xfail *-*-* } }\n+  *(AC4*)a2 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 2\" \"pr??????\" { xfail *-*-* } }\n+  *(AC4*)a3 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr??????\" { xfail *-*-* } }\n+  *(AC8*)a4 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 4\" \"pr??????\" { xfail *-*-* } }\n+  *(AC8*)a7 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 7\" \"pr??????\" { xfail *-*-* } }\n+  *(AC16*)a15 = Ac16;   // { dg-warning \"writing 16 bytes into a region of size 15\" \"pr??????\" { xfail *-*-* } }\n+}\n+\n+void warn_aggr_decl (void)\n+{\n+  *(AC2*)a1 = ac2;      // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+  *(AC4*)a2 = ac4;      // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+  *(AC4*)a3 = ac4;      // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+  *(AC8*)a4 = ac8;      // { dg-warning \"writing 8 bytes into a region of size 4\" }\n+  *(AC8*)a7 = ac8;      // { dg-warning \"writing 8 bytes into a region of size 7\" }\n+  *(AC16*)a15 = ac16;   // { dg-warning \"writing 16 bytes into a region of size 15\" }\n+}\n+\n+void warn_aggr_parm (AC2 pc2, AC4 pc4, AC8 pc8, AC16 pc16)\n+{\n+  *(AC2*)a1 = pc2;      // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+  *(AC4*)a2 = pc4;      // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+  *(AC4*)a3 = pc4;      // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+  *(AC8*)a4 = pc8;      // { dg-warning \"writing 8 bytes into a region of size 4\" }\n+  *(AC8*)a7 = pc8;      // { dg-warning \"writing 8 bytes into a region of size 7\" }\n+  *(AC16*)a15 = pc16;   // { dg-warning \"writing 16 bytes into a region of size 15\" }\n+}\n+\n+void warn_aggr_func (void)\n+{\n+  *(AC2*)a1 = fac2 ();  // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+  *(AC4*)a2 = fac4 ();  // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+  *(AC4*)a3 = fac4 ();  // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+  *(AC8*)a4 = fac8 ();  // { dg-warning \"writing 8 bytes into a region of size 4\" }\n+  *(AC8*)a7 = fac8 ();  // { dg-warning \"writing 8 bytes into a region of size 7\" }\n+  *(AC16*)a15 = fac16 ();// { dg-warning \"writing 16 bytes into a region of size 15\" }\n+\n+  extern AC2 fac2_x ();\n+\n+  *(AC2*)a1 = fac2_x ();  // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+\n+  extern AC2 fac2_p (char*);\n+\n+  *(AC2*)a1 = fac2_p (0); // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+}"}, {"sha": "754b481d6cdf7dc8ce4b4f9cdac2141a0abbe086", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-69.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-69.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -0,0 +1,84 @@\n+/* PR tree-optimization/97027 - missing warning on buffer overflow storing\n+   a larger scalar into a smaller array\n+   Verify overflow by vector stores.\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+#define V(N) __attribute__ ((vector_size (N)))\n+#define C1 (VC1){ 0 }\n+#define C2 (VC2){ 0, 1 }\n+#define C4 (VC4){ 0, 1, 2, 3 }\n+#define C8 (VC8){ 0, 1, 2, 3, 4, 5, 6, 7 }\n+#define C16 (VC16){ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }\n+\n+typedef V (1) char VC1;\n+typedef V (2) char VC2;\n+typedef V (4) char VC4;\n+typedef V (8) char VC8;\n+typedef V (16) char VC16;\n+\n+extern char a1[1], a2[2], a3[3], a4[4], a5[5], a6[6], a7[7], a8[8], a15[15];\n+\n+extern VC1 c1;\n+extern VC2 c2;\n+extern VC4 c4;\n+extern VC8 c8;\n+extern VC16 c16;\n+\n+extern VC1 fc1 (void);\n+extern VC2 fc2 (void);\n+extern VC4 fc4 (void);\n+extern VC8 fc8 (void);\n+extern VC16 fc16 (void);\n+\n+void nowarn (void)\n+{\n+  *(VC1*)a1 = C1;\n+  *(VC2*)a2 = C2;\n+  *(VC4*)a4 = C4;\n+  *(VC4*)a5 = C4;\n+  *(VC4*)a6 = C4;\n+  *(VC4*)a7 = C4;\n+  *(VC8*)a8 = C8;\n+  *(VC8*)a15 = C8;\n+}\n+\n+void warn_vec_lit (void)\n+{\n+  *(VC2*)a1 = C2;       // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+  *(VC4*)a2 = C4;       // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+  *(VC4*)a3 = C4;       // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+  *(VC8*)a4 = C8;       // { dg-warning \"writing 8 bytes into a region of size 4\" }\n+  *(VC8*)a7 = C8;       // { dg-warning \"writing 8 bytes into a region of size 7\" }\n+  *(VC16*)a15 = C16;    // { dg-warning \"writing 16 bytes into a region of size 15\" }\n+}\n+\n+void warn_vec_decl (void)\n+{\n+  *(VC2*)a1 = c2;       // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+  *(VC4*)a2 = c4;       // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+  *(VC4*)a3 = c4;       // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+  *(VC8*)a4 = c8;       // { dg-warning \"writing 8 bytes into a region of size 4\" }\n+  *(VC8*)a7 = c8;       // { dg-warning \"writing 8 bytes into a region of size 7\" }\n+  *(VC16*)a15 = c16;    // { dg-warning \"writing 16 bytes into a region of size 15\" }\n+}\n+\n+void warn_vec_parm (VC2 pc2, VC4 pc4, VC8 pc8, VC16 pc16)\n+{\n+  *(VC2*)a1 = pc2;      // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+  *(VC4*)a2 = pc4;      // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+  *(VC4*)a3 = pc4;      // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+  *(VC8*)a4 = pc8;      // { dg-warning \"writing 8 bytes into a region of size 4\" }\n+  *(VC8*)a7 = pc8;      // { dg-warning \"writing 8 bytes into a region of size 7\" }\n+  *(VC16*)a15 = pc16;   // { dg-warning \"writing 16 bytes into a region of size 15\" }\n+}\n+\n+void warn_vec_func (void)\n+{\n+  *(VC2*)a1 = fc2 ();   // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+  *(VC4*)a2 = fc4 ();   // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+  *(VC4*)a3 = fc4 ();   // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+  *(VC8*)a4 = fc8 ();   // { dg-warning \"writing 8 bytes into a region of size 4\" }\n+  *(VC8*)a7 = fc8 ();   // { dg-warning \"writing 8 bytes into a region of size 7\" }\n+  *(VC16*)a15 = fc16 ();// { dg-warning \"writing 16 bytes into a region of size 15\" }\n+}"}, {"sha": "5d8bfa9a7041a47c2fedaa384c83895a8f8a1d44", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-70.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-70.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-70.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-70.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -0,0 +1,21 @@\n+/* PR tree-optimization/97027 - missing warning on buffer overflow storing\n+   a larger scalar into a smaller array\n+   Verify overflow by vector stores.\n+   { dg-do compile }\n+   { dg-options \"-O3\" } */\n+\n+void* nowarn_loop (void)\n+{\n+  char *p = __builtin_malloc (16);\n+  for (int i = 0; i != 16; ++i)\n+    p[i] = i;\n+  return p;\n+}\n+\n+void* warn_loop (void)\n+{\n+  char *p = __builtin_malloc (15);\n+  for (int i = 0; i != 16; ++i)\n+    p[i] = i;       // { dg-warning \"writing 16 bytes into a region of size 15\" }\n+  return p;\n+}"}, {"sha": "dccee35cb3d272ac4fa18a495fad3b617c3133b2", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-71.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-71.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-71.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-71.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -0,0 +1,105 @@\n+/* PR tree-optimization/97027 - missing warning on buffer overflow storing\n+   a larger scalar into a smaller array\n+   Verify warnings for overflow by stores of results of built-in functions.\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+typedef __INT16_TYPE__ int16_t;\n+typedef __SIZE_TYPE__  size_t;\n+\n+extern int abs (int);\n+\n+extern void* alloca (size_t);\n+\n+extern double nan (const char *);\n+_Decimal32 nand32 (const char *);\n+\n+extern size_t strlen (const char *);\n+extern char* strcpy (char *, const char *);\n+\n+\n+extern unsigned char ax[], a1[1], a2[2], a8[8];\n+\n+\n+void nowarn_abs (int i)\n+{\n+  *(int *)ax = abs (i);\n+  *(char *)a1 = abs (i);\n+}\n+\n+void warn_abs (int i)\n+{\n+  *(int *)a1 = abs (i);         // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+void nowarn_alloca (size_t n)\n+{\n+  *(void **)ax = alloca (n);\n+}\n+\n+void warn_alloca (size_t n)\n+{\n+  *(void **)a1 = alloca (n);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+void nowarn_complex (double x, double i)\n+{\n+  *(_Complex double *)ax = __builtin_complex (x, i);\n+}\n+\n+void warn_complex (double x, double i)\n+{\n+  _Complex double *p = (_Complex double *)a1;\n+  *p = __builtin_complex (x, i);  // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr101455\" { xfail *-*-* } }\n+}\n+\n+\n+void nowarn_nan (const char *s)\n+{\n+  *(double *)ax = nan (s);\n+}\n+\n+void warn_nan (const char *s)\n+{\n+  *(double *)a1 = nan (s);      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+void nowarn_nand32 (const char *s)\n+{\n+  *(_Decimal32 *)ax = nand32 (s);\n+}\n+\n+void warn_nand32 (const char *s)\n+{\n+  *(_Decimal32 *)a1 = nand32 (s); // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+void nowarn_strlen (const char *s1, const char *s2, const char *s3)\n+{\n+  *(char *)ax = strlen (s1);\n+  *(char *)a1 = strlen (s2);\n+  *(size_t *)a8 = strlen (s3);\n+}\n+\n+void warn_strlen (const char *s1, const char *s2)\n+{\n+  *(int16_t *)a1 = strlen (s1); // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  *(size_t *)a2 = strlen (s2);  // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+void nowarn_strcpy (char *s1, char *s2, const char *s3)\n+{\n+  *(char **)ax = strcpy (s1, s2);\n+  *(char **)a8 = strcpy (s2, s3);\n+}\n+\n+void warn_strcpy (char *s1, char *s2, const char *s3)\n+{\n+  *(char **)a1 = strcpy (s1, s2);   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  *(char **)a2 = strcpy (s2, s3);   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}"}, {"sha": "505bc996a5918e7d5c1522f798794bdce34a4e3e", "filename": "gcc/testsuite/gcc.dg/strlenopt-95.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-95.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-95.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-95.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -0,0 +1,65 @@\n+/* Verify strlen results of vector assignments.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define V(N) __attribute__ ((vector_size (N)))\n+\n+typedef V (1) char VC1;\n+typedef V (2) char VC2;\n+typedef V (4) char VC4;\n+typedef V (8) char VC8;\n+typedef V (16) char VC16;\n+\n+extern char a[];\n+\n+#define A(expr) ((expr) ? (void)0 : abort ())\n+\n+void test_fold (int i)\n+{\n+  *(VC4*)a = (VC4){ };\n+  A (strlen (a) == 0);\n+  A (!a[1] && !a[2] && !a[3]);\n+\n+  *(VC4*)a = (VC4){ 0, 1 };\n+  A (strlen (a) == 0);\n+  A (a[1] == 1 && !a[2] && !a[3]);\n+\n+  *(VC4*)a = (VC4){ 1 };\n+  A (strlen (a) == 1);\n+  A (!a[1] && !a[2] && !a[3]);\n+\n+  *(VC4*)a = (VC4){ 1, 0, 3 };\n+  A (strlen (a) == 1);\n+  A (!a[1] && a[2] == 3 && !a[3]);\n+\n+  *(VC4*)a = (VC4){ 1, 2 };\n+  A (strlen (a) == 2);\n+  A (!a[2] && !a[3]);\n+\n+  *(VC4*)a = (VC4){ 1, 2, 0, 4 };\n+  A (strlen (a) == 2);\n+  A (!a[2] && a[3] == 4);\n+\n+  *(VC4*)a = (VC4){ 1, 2, 3 };\n+  A (strlen (a) == 3);\n+  A (!a[3]);\n+\n+  *(VC8*)a = (VC8){ 1, 2, 3, 0, 5 };\n+  A (strlen (a) == 3);\n+\n+  *(VC8*)a = (VC8){ 1, 2, 3, 0, 5, 6 };\n+  A (strlen (a) == 3);\n+\n+  *(VC8*)a = (VC8){ 1, 2, 3, 0, 5, 6, 7 };\n+  A (strlen (a) == 3);\n+  A (strlen (a + 1) == 2);\n+  A (strlen (a + 2) == 1);\n+  A (strlen (a + 3) == 0);\n+\n+  A (a[4] == 5 && a[5] == 6 && a[6] == 7 && a[7] == 8);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort \\\\(\" \"strlen1\" } }\n+   { dg-final { scan-tree-dump-not \"strlen \\\\(\" \"strlen1\" } } */"}, {"sha": "a39125a69ccf5b86f6543d7481f392714faa58d2", "filename": "gcc/testsuite/gcc.dg/torture/pr69170.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69170.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69170.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69170.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -6,7 +6,7 @@ typedef struct {\n     char buf[];\n } hash_state;\n int a;\n-hash_state b;\n+extern hash_state b;\n void fn1()\n {\n   a = 0;"}, {"sha": "7cf28c452e339282a1c4fe546640257c5b00a258", "filename": "gcc/testsuite/gcc.dg/torture/pr70025.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70025.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70025.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70025.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -80,3 +80,8 @@ main ()\n     __builtin_abort ();\n   return 0;\n }\n+\n+/* At -O3 the loop in bar() is vectorized and results in a (possibly\n+   unreachable) out-of-bounds store to p.d7[8]:\n+     _22(D)->d7[8] = _122;\n+  { dg-prune-output \"-Wstringop-overflow\" } */"}, {"sha": "59e0b46488138b42536d25d45a30747b62c90d9c", "filename": "gcc/testsuite/gcc.dg/vect/pr97769.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97769.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97769.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97769.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -25,7 +25,7 @@ fn2(tmp *p1)\n {\n   char *d = (char *)p1->d1;\n   int *b = p1->h1;\n-  for (int a; a; a++, d += 4)\n+  for (int a = 0; a; a++, d += 4)\n     fn1(d, *b++);\n }\n "}, {"sha": "fa6d36d34927a32dc42232678f1543fa5533538d", "filename": "gcc/testsuite/gcc.target/i386/pr92658-avx512bw-trunc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92658-avx512bw-trunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92658-avx512bw-trunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92658-avx512bw-trunc.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -13,7 +13,7 @@ typedef unsigned short v32hi __attribute__((vector_size (64)));\n void\n truncwb_512 (v32qi * dst, v32hi * __restrict src)\n {\n-  unsigned char tem[8];\n+  unsigned char tem[32];\n   tem[0] = (*src)[0];\n   tem[1] = (*src)[1];\n   tem[2] = (*src)[2];\n@@ -52,7 +52,7 @@ truncwb_512 (v32qi * dst, v32hi * __restrict src)\n void\n truncwb_256 (v16qi * dst, v16hi * __restrict src)\n {\n-  unsigned char tem[8];\n+  unsigned char tem[16];\n   tem[0] = (*src)[0];\n   tem[1] = (*src)[1];\n   tem[2] = (*src)[2];"}, {"sha": "e26b06ecd5aa6176e553aec677933c5f7e6e9263", "filename": "gcc/testsuite/gcc.target/i386/pr92658-avx512f.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92658-avx512f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92658-avx512f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92658-avx512f.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -54,7 +54,7 @@ truncqb (v8qi * dst, v8di * __restrict src)\n void\n truncdw (v16hi * dst, v16si * __restrict src)\n {\n-  unsigned short tem[8];\n+  unsigned short tem[16];\n   tem[0] = (*src)[0];\n   tem[1] = (*src)[1];\n   tem[2] = (*src)[2];\n@@ -78,7 +78,7 @@ truncdw (v16hi * dst, v16si * __restrict src)\n void\n truncdb (v16qi * dst, v16si * __restrict src)\n {\n-  unsigned char tem[8];\n+  unsigned char tem[16];\n   tem[0] = (*src)[0];\n   tem[1] = (*src)[1];\n   tem[2] = (*src)[2];"}, {"sha": "799c21fddde9757307bba3d7b381bbd9784c5399", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 186, "deletions": 69, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0500db3692276f60e0562c17c87a0cb03e34398/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=f0500db3692276f60e0562c17c87a0cb03e34398", "patch": "@@ -192,6 +192,8 @@ struct laststmt_struct\n \n static int get_stridx_plus_constant (strinfo *, unsigned HOST_WIDE_INT, tree);\n static void handle_builtin_stxncpy_strncat (bool, gimple_stmt_iterator *);\n+static bool handle_assign (gimple_stmt_iterator *, tree, bool *,\n+\t\t\t   pointer_query &);\n \n /* Sets MINMAX to either the constant value or the range VAL is in\n    and returns either the constant value or VAL on success or null\n@@ -1929,12 +1931,15 @@ maybe_set_strlen_range (tree lhs, tree src, tree bound)\n /* Diagnose buffer overflow by a STMT writing LEN + PLUS_ONE bytes,\n    either into a region allocated for the object SI when non-null,\n    or into an object designated by the LHS of STMT otherwise.\n+   For a call STMT, when CALL_LHS is set use its left hand side\n+   as the destination, otherwise use argument zero.\n    When nonnull uses RVALS to determine range information.\n    RAWMEM may be set by memcpy and other raw memory functions\n    to allow accesses across subobject boundaries.  */\n \n static void\n-maybe_warn_overflow (gimple *stmt, tree len, pointer_query &ptr_qry,\n+maybe_warn_overflow (gimple *stmt, bool call_lhs, tree len,\n+\t\t     pointer_query &ptr_qry,\n \t\t     strinfo *si = NULL, bool plus_one = false,\n \t\t     bool rawmem = false)\n {\n@@ -1944,14 +1949,23 @@ maybe_warn_overflow (gimple *stmt, tree len, pointer_query &ptr_qry,\n   /* The DECL of the function performing the write if it is done\n      by one.  */\n   tree writefn = NULL_TREE;\n-  /* The destination expression involved in the store STMT.  */\n+  /* The destination expression involved in the store or call STMT.  */\n   tree dest = NULL_TREE;\n \n   if (is_gimple_assign (stmt))\n     dest = gimple_assign_lhs (stmt);\n   else if (is_gimple_call (stmt))\n     {\n-      dest = gimple_call_arg (stmt, 0);\n+      if (call_lhs)\n+\tdest = gimple_call_lhs (stmt);\n+      else\n+\t{\n+\t  gcc_assert (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL));\n+\t  dest = gimple_call_arg (stmt, 0);\n+\t}\n+\n+      if (!dest)\n+\treturn;\n       writefn = gimple_call_fndecl (stmt);\n     }\n   else\n@@ -2108,12 +2122,12 @@ maybe_warn_overflow (gimple *stmt, tree len, pointer_query &ptr_qry,\n /* Convenience wrapper for the above.  */\n \n static inline void\n-maybe_warn_overflow (gimple *stmt, unsigned HOST_WIDE_INT len,\n+maybe_warn_overflow (gimple *stmt, bool call_lhs, unsigned HOST_WIDE_INT len,\n \t\t     pointer_query &ptr_qry, strinfo *si = NULL,\n \t\t     bool plus_one = false, bool rawmem = false)\n {\n-  maybe_warn_overflow (stmt, build_int_cst (size_type_node, len), ptr_qry,\n-\t\t       si, plus_one, rawmem);\n+  tree tlen = build_int_cst (size_type_node, len);\n+  maybe_warn_overflow (stmt, call_lhs, tlen, ptr_qry, si, plus_one, rawmem);\n }\n \n /* Handle a strlen call.  If strlen of the argument is known, replace\n@@ -2443,7 +2457,7 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n   else if (idx < 0)\n     srclen = build_int_cst (size_type_node, ~idx);\n \n-  maybe_warn_overflow (stmt, srclen, ptr_qry, olddsi, true);\n+  maybe_warn_overflow (stmt, false, srclen, ptr_qry, olddsi, true);\n \n   if (olddsi != NULL)\n     adjust_last_stmt (olddsi, stmt, false, ptr_qry);\n@@ -3248,7 +3262,7 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n   if (olddsi != NULL\n       && !integer_zerop (len))\n     {\n-      maybe_warn_overflow (stmt, len, ptr_qry, olddsi, false, true);\n+      maybe_warn_overflow (stmt, false, len, ptr_qry, olddsi, false, true);\n       adjust_last_stmt (olddsi, stmt, false, ptr_qry);\n     }\n \n@@ -3713,7 +3727,8 @@ handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write,\n   tree memset_size = gimple_call_arg (memset_stmt, 2);\n \n   /* Check for overflow.  */\n-  maybe_warn_overflow (memset_stmt, memset_size, ptr_qry, NULL, false, true);\n+  maybe_warn_overflow (memset_stmt, false, memset_size, ptr_qry, NULL,\n+\t\t       false, true);\n \n   /* Bail when there is no statement associated with the destination\n      (the statement may be null even when SI1->ALLOC is not).  */\n@@ -4374,19 +4389,49 @@ handle_pointer_plus (gimple_stmt_iterator *gsi)\n     }\n }\n \n+/* Set LENRANGE to the number of nonzero bytes for a store of TYPE and\n+   clear all flags.  Return true on success and false on failure.  */\n+\n+static bool\n+nonzero_bytes_for_type (tree type, unsigned lenrange[3],\n+\t\t\tbool *nulterm, bool *allnul, bool *allnonnul)\n+{\n+  /* Use the size of the type of the expression as the size of the store,\n+     and set the upper bound of the length range to that of the size.\n+     Nothing is known about the contents so clear all flags.  */\n+  tree typesize = TYPE_SIZE_UNIT (type);\n+  if (!type)\n+    return false;\n+\n+  if (!tree_fits_uhwi_p (typesize))\n+    return false;\n+\n+  unsigned HOST_WIDE_INT sz = tree_to_uhwi (typesize);\n+  if (sz > UINT_MAX)\n+    return false;\n+\n+  lenrange[2] = sz;\n+  lenrange[1] = lenrange[2] ? lenrange[2] - 1 : 0;\n+  lenrange[0] = 0;\n+  *nulterm = false;\n+  *allnul = false;\n+  *allnonnul = false;\n+  return true;\n+}\n+\n static bool\n count_nonzero_bytes_addr (tree, unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n \t\t\t  unsigned [3], bool *, bool *, bool *,\n \t\t\t  range_query *, ssa_name_limit_t &);\n \n-/* Determines the minimum and maximum number of leading non-zero bytes\n-   in the representation of EXP and set LENRANGE[0] and LENRANGE[1]\n+/* Recursively determine the minimum and maximum number of leading nonzero\n+   bytes in the representation of EXP and set LENRANGE[0] and LENRANGE[1]\n    to each.\n    Sets LENRANGE[2] to the total size of the access (which may be less\n    than LENRANGE[1] when what's being referenced by EXP is a pointer\n    rather than an array).\n-   Sets *NULTERM if the representation contains a zero byte, and sets\n-   *ALLNUL if all the bytes are zero.\n+   Sets *NULTERM if the representation contains a zero byte, sets *ALLNUL\n+   if all the bytes are zero, and *ALLNONNUL is all are nonzero.\n    OFFSET and NBYTES are the offset into the representation and\n    the size of the access to it determined from an ADDR_EXPR (i.e.,\n    a pointer) or MEM_REF or zero for other expressions.\n@@ -4422,9 +4467,11 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n       if (gimple_assign_single_p (stmt))\n \t{\n \t  exp = gimple_assign_rhs1 (stmt);\n-\t  if (TREE_CODE (exp) != MEM_REF)\n+\t  if (!DECL_P (exp)\n+\t      && TREE_CODE (exp) != CONSTRUCTOR\n+\t      && TREE_CODE (exp) != MEM_REF)\n \t    return false;\n-\t  /* Handle MEM_REF below.  */\n+\t  /* Handle DECLs, CONSTRUCTOR and MEM_REF below.  */\n \t}\n       else if (gimple_code (stmt) == GIMPLE_PHI)\n \t{\n@@ -4448,6 +4495,25 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \t}\n     }\n \n+  if (TREE_CODE (exp) == CONSTRUCTOR)\n+    {\n+      if (nbytes)\n+\t/* If NBYTES has already been determined by an outer MEM_REF\n+\t   fail rather than overwriting it (this shouldn't happen).  */\n+\treturn false;\n+\n+      tree type = TREE_TYPE (exp);\n+      tree size = TYPE_SIZE_UNIT (type);\n+      if (!size || !tree_fits_uhwi_p (size))\n+\treturn false;\n+\n+      unsigned HOST_WIDE_INT byte_size = tree_to_uhwi (size);\n+      if (byte_size < offset)\n+\treturn false;\n+\n+      nbytes = byte_size - offset;\n+    }\n+\n   if (TREE_CODE (exp) == MEM_REF)\n     {\n       if (nbytes)\n@@ -4483,9 +4549,11 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \n   if (VAR_P (exp) || TREE_CODE (exp) == CONST_DECL)\n     {\n-      exp = ctor_for_folding (exp);\n-      if (!exp)\n-\treturn false;\n+      /* If EXP can be folded into a constant use the result.  Otherwise\n+\t proceed to use EXP to determine a range of the result.  */\n+      if (tree fold_exp = ctor_for_folding (exp))\n+\tif (fold_exp != error_mark_node)\n+\t  exp = fold_exp;\n     }\n \n   const char *prep = NULL;\n@@ -4533,7 +4601,8 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n     }\n \n   if (!nbytes)\n-    return false;\n+    return nonzero_bytes_for_type (TREE_TYPE (exp), lenrange,\n+\t\t\t\t   nulterm, allnul, allnonnul);\n \n   /* Compute the number of leading nonzero bytes in the representation\n      and update the minimum and maximum.  */\n@@ -4696,14 +4765,19 @@ count_nonzero_bytes_addr (tree exp, unsigned HOST_WIDE_INT offset,\n   return true;\n }\n \n-/* Same as above except with an implicit SSA_NAME limit.  RVALS is used\n-   to determine ranges of dynamically computed string lengths (the results\n-   of strlen).  */\n+/* Same as above except with an implicit SSA_NAME limit.  When EXPR_OR_TYPE\n+   is a type rather than an expression use its size to compute the range.\n+   RVALS is used to determine ranges of dynamically computed string lengths\n+   (the results of strlen).  */\n \n static bool\n-count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n+count_nonzero_bytes (tree expr_or_type, unsigned lenrange[3], bool *nulterm,\n \t\t     bool *allnul, bool *allnonnul, range_query *rvals)\n {\n+  if (TYPE_P (expr_or_type))\n+    return nonzero_bytes_for_type (expr_or_type, lenrange,\n+\t\t\t\t   nulterm, allnul, allnonnul);\n+\n   /* Set to optimistic values so the caller doesn't have to worry about\n      initializing these and to what.  On success, the function will clear\n      these if it determines their values are different but being recursive\n@@ -4714,7 +4788,8 @@ count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n   *allnonnul = true;\n \n   ssa_name_limit_t snlim;\n-  return count_nonzero_bytes (exp, 0, 0, lenrange, nulterm, allnul, allnonnul,\n+  tree expr = expr_or_type;\n+  return count_nonzero_bytes (expr, 0, 0, lenrange, nulterm, allnul, allnonnul,\n \t\t\t      rvals, snlim);\n }\n \n@@ -4728,11 +4803,29 @@ static bool\n handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n \t      pointer_query &ptr_qry)\n {\n-  int idx = -1;\n-  strinfo *si = NULL;\n   gimple *stmt = gsi_stmt (*gsi);\n-  tree ssaname = NULL_TREE, lhs = gimple_assign_lhs (stmt);\n-  tree rhs = gimple_assign_rhs1 (stmt);\n+  /* The LHS and RHS of the store.  The RHS is null if STMT is a function\n+     call.  STORETYPE is the type of the store (determined from either\n+     the RHS of the assignment statement or the LHS of a function call.  */\n+  tree lhs, rhs, storetype;\n+  if (is_gimple_assign (stmt))\n+    {\n+      lhs = gimple_assign_lhs (stmt);\n+      rhs = gimple_assign_rhs1 (stmt);\n+      storetype = TREE_TYPE (rhs);\n+    }\n+  else if (is_gimple_call (stmt))\n+    {\n+      lhs = gimple_call_lhs (stmt);\n+      rhs = NULL_TREE;\n+      storetype = TREE_TYPE (lhs);\n+    }\n+  else\n+    return true;\n+\n+  tree ssaname = NULL_TREE;\n+  strinfo *si = NULL;\n+  int idx = -1;\n \n   range_query *const rvals = ptr_qry.rvals;\n \n@@ -4756,13 +4849,13 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n \t    ssaname = TREE_OPERAND (lhs, 0);\n \t  else if (si == NULL || compare_nonzero_chars (si, offset, rvals) < 0)\n \t    {\n-\t      *zero_write = initializer_zerop (rhs);\n+\t      *zero_write = rhs ? initializer_zerop (rhs) : false;\n \n \t      bool dummy;\n \t      unsigned lenrange[] = { UINT_MAX, 0, 0 };\n-\t      if (count_nonzero_bytes (rhs, lenrange, &dummy, &dummy, &dummy,\n-\t\t\t\t       rvals))\n-\t\tmaybe_warn_overflow (stmt, lenrange[2], ptr_qry);\n+\t      if (count_nonzero_bytes (rhs ? rhs : storetype, lenrange,\n+\t\t\t\t       &dummy, &dummy, &dummy, rvals))\n+\t\tmaybe_warn_overflow (stmt, true, lenrange[2], ptr_qry);\n \n \t      return true;\n \t    }\n@@ -4793,16 +4886,17 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n   bool full_string_p;\n \n   const bool ranges_valid\n-    = count_nonzero_bytes (rhs, lenrange, &full_string_p,\n+    = count_nonzero_bytes (rhs ? rhs : storetype, lenrange, &full_string_p,\n \t\t\t   &storing_all_zeros_p, &storing_all_nonzero_p,\n \t\t\t   rvals);\n+\n   if (ranges_valid)\n     {\n       rhs_minlen = lenrange[0];\n       storing_nonzero_p = lenrange[1] > 0;\n       *zero_write = storing_all_zeros_p;\n \n-      maybe_warn_overflow (stmt, lenrange[2], ptr_qry);\n+      maybe_warn_overflow (stmt, true, lenrange[2], ptr_qry);\n     }\n   else\n     {\n@@ -4864,7 +4958,7 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n \t  && storing_nonzero_p\n \t  && lenrange[0] == lenrange[1]\n \t  && lenrange[0] == lenrange[2]\n-\t  && TREE_CODE (TREE_TYPE (rhs)) == INTEGER_TYPE)\n+\t  && TREE_CODE (storetype) == INTEGER_TYPE)\n \t{\n \t  /* Handle a store of one or more non-nul characters that ends\n \t     before the terminating nul of the destination and so does\n@@ -5145,8 +5239,19 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n   if (!gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n     {\n       tree fntype = gimple_call_fntype (stmt);\n-      if (fntype && lookup_attribute (\"alloc_size\", TYPE_ATTRIBUTES (fntype)))\n-\thandle_alloc_call (BUILT_IN_NONE, gsi);\n+      if (!fntype)\n+\treturn true;\n+\n+      if (lookup_attribute (\"alloc_size\", TYPE_ATTRIBUTES (fntype)))\n+\t{\n+\t  handle_alloc_call (BUILT_IN_NONE, gsi);\n+\t  return true;\n+\t}\n+\n+      if (tree lhs = gimple_call_lhs (stmt))\n+\thandle_assign (gsi, lhs, zero_write, ptr_qry);\n+\n+      /* Proceed to handle user-defined formatting functions.  */\n     }\n \n   /* When not optimizing we must be checking printf calls which\n@@ -5362,6 +5467,48 @@ handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n     }\n }\n \n+/* Handle assignment statement at *GSI to LHS.  Set *ZERO_WRITE if\n+   the assignent stores all zero bytes..  */\n+\n+static bool\n+handle_assign (gimple_stmt_iterator *gsi, tree lhs, bool *zero_write,\n+\t       pointer_query &ptr_qry)\n+{\n+  tree type = TREE_TYPE (lhs);\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  bool is_char_store = is_char_type (type);\n+  if (!is_char_store && TREE_CODE (lhs) == MEM_REF)\n+    {\n+      /* To consider stores into char objects via integer types other\n+\t than char but not those to non-character objects, determine\n+\t the type of the destination rather than just the type of\n+\t the access.  */\n+      for (int i = 0; i != 2; ++i)\n+\t{\n+\t  tree ref = TREE_OPERAND (lhs, i);\n+\t  type = TREE_TYPE (ref);\n+\t  if (TREE_CODE (type) == POINTER_TYPE)\n+\t    type = TREE_TYPE (type);\n+\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t    type = TREE_TYPE (type);\n+\t  if (is_char_type (type))\n+\t    {\n+\t      is_char_store = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  /* Handle a single or multibyte assignment.  */\n+  if (is_char_store && !handle_store (gsi, zero_write, ptr_qry))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n /* Attempt to check for validity of the performed access a single statement\n    at *GSI using string length knowledge, and to optimize it.\n    If the given basic block needs clean-up of EH, CLEANUP_EH is set to\n@@ -5407,38 +5554,8 @@ check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t/* Handle assignment to a character.  */\n \thandle_integral_assign (gsi, cleanup_eh, ptr_qry.rvals);\n       else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n-\t{\n-\t  tree type = TREE_TYPE (lhs);\n-\t  if (TREE_CODE (type) == ARRAY_TYPE)\n-\t    type = TREE_TYPE (type);\n-\n-\tbool is_char_store = is_char_type (type);\n-\tif (!is_char_store && TREE_CODE (lhs) == MEM_REF)\n-\t  {\n-\t    /* To consider stores into char objects via integer types\n-\t       other than char but not those to non-character objects,\n-\t       determine the type of the destination rather than just\n-\t       the type of the access.  */\n-\t    for (int i = 0; i != 2; ++i)\n-\t      {\n-\t\ttree ref = TREE_OPERAND (lhs, i);\n-\t\ttype = TREE_TYPE (ref);\n-\t\tif (TREE_CODE (type) == POINTER_TYPE)\n-\t\t  type = TREE_TYPE (type);\n-\t\tif (TREE_CODE (type) == ARRAY_TYPE)\n-\t\t  type = TREE_TYPE (type);\n-\t\tif (is_char_type (type))\n-\t\t  {\n-\t\t    is_char_store = true;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\t  /* Handle a single or multibyte assignment.  */\n-\t  if (is_char_store && !handle_store (gsi, &zero_write, ptr_qry))\n-\t    return false;\n-\t}\n+\tif (!handle_assign (gsi, lhs, &zero_write, ptr_qry))\n+\t  return false;\n     }\n   else if (gcond *cond = dyn_cast<gcond *> (stmt))\n     {"}]}