{"sha": "33005162262a89f7dfd60e3e402c57d23330edfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMwMDUxNjIyNjJhODlmN2RmZDYwZTNlNDAyYzU3ZDIzMzMwZWRmZA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2002-06-06T01:25:16Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2002-06-06T01:25:16Z"}, "message": "toplev.c: Remove half-pic.\n\n2002-06-05  Eric Christopher  <echristo@redhat.com>\n\n\t* toplev.c: Remove half-pic.\n\t* config/mips/mips.c: Ditto.\n\t* config/mips/mips.h: Ditto. Remove unused defines.\n\t* config/mips/openbsd.h: Update comment to reflect above.\n\t* config/mips/mips.md: Remove half-pic constraints.\n\t* halfpic.h: Delete.\n\t* halfpic.c: Ditto.\n\nFrom-SVN: r54296", "tree": {"sha": "a7fa60e79e389c8dd2c787bac815437aa9e4d1b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7fa60e79e389c8dd2c787bac815437aa9e4d1b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33005162262a89f7dfd60e3e402c57d23330edfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33005162262a89f7dfd60e3e402c57d23330edfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33005162262a89f7dfd60e3e402c57d23330edfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33005162262a89f7dfd60e3e402c57d23330edfd/comments", "author": null, "committer": null, "parents": [{"sha": "5d3dfc3ac1c7fcb4d7a9582d20c21baa8b17b605", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d3dfc3ac1c7fcb4d7a9582d20c21baa8b17b605", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d3dfc3ac1c7fcb4d7a9582d20c21baa8b17b605"}], "stats": {"total": 720, "additions": 58, "deletions": 662}, "files": [{"sha": "042a369d7df3ef6f36e35e1bec2f646af2a1c265", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33005162262a89f7dfd60e3e402c57d23330edfd", "patch": "@@ -1,8 +1,18 @@\n+2002-06-05  Eric Christopher  <echristo@redhat.com>\n+\n+\t* toplev.c: Remove half-pic.\n+\t* config/mips/mips.c: Ditto.\n+\t* config/mips/mips.h: Ditto. Remove unused defines.\n+\t* config/mips/openbsd.h: Update comment to reflect above.\n+\t* config/mips/mips.md: Remove half-pic constraints.\n+\t* halfpic.h: Delete.\n+\t* halfpic.c: Ditto.\n+\n 2002-06-05  Jeffrey Law  <law@redhat.com>\n \n         * pa.h (EXTRA_CONSTRAINT, T case): Further refine so that it\n         rejects (mem (lo_sum (reg) (unspec))), but will allow\n-        (mem (lo_sum (reg) (symbol_ref)) for PA2.0. \n+        (mem (lo_sum (reg) (symbol_ref)) for PA2.0.\n \n 2002-06-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n@@ -52,7 +62,7 @@ Wed Jun  5 20:42:31 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n \t(diagnostic_set_info): Declare.\n \n \t* diagnostic.c (report_problematic_module): Rename to\n-\tdiagnostic_repor_current_module. \n+\tdiagnostic_repor_current_module.\n \t(set_diagnostic_context): Remove.\n \t(count_error): Rename to diagnostic_error_count.\n \t(error_function_changed): Remove.\n@@ -215,7 +225,7 @@ Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n 2002-06-03  Geoffrey Keating  <geoffk@redhat.com>\n \n \tMerge from pch-branch:\n-\t\n+\n \t* gengtype.h (UNION_OR_STRUCT_P): New macro.\n \t* gengtype.c (write_gc_structure_fields): Use it.\n \t(write_gc_root): Use it here too.\n@@ -362,7 +372,7 @@ Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \toutside ifdefs.\n \t(incomplete_types): Likewise.\n \t(decl_scope_table): Likewise.\n-\t(dwarf2out_init): Don't call ggc_add_tree_varray_root.\t\n+\t(dwarf2out_init): Don't call ggc_add_tree_varray_root.\n \t* cfglayout.c (scope_to_insns_finalize): Don't use VARRAY_FREE.\n \t* c-tree.h (struct lang_type): Update for change to length specifier.\n \t* c-parse.in (yylexstring): Don't use VARRAY_FREE.\n@@ -436,7 +446,7 @@ Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \tto list of includes.\n \n \t* gengtype.c (write_gc_marker_routine_for_structure): Name\n-\tthe routines 'gt_ggc_mx_*' instead of 'gt_ggc_m_*'.  \n+\tthe routines 'gt_ggc_mx_*' instead of 'gt_ggc_m_*'.\n \t(write_gc_types): Arrange for the tests with NULL to be inlined.\n \t(write_gc_roots): Update uses of procedure pointers.\n \t* ggc-common.c (gt_ggc_mx_rtx_def): Rename from gt_ggc_m_rtx_def.\n@@ -579,7 +589,7 @@ Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \t* c-tree.h (struct lang_identifier): Use gengtype.\n \t(union lang_tree_node): New.\n \t(c_mark_tree): Delete prototype.\n-\t* dwarf2out.c [!DWARF2_DEBUGGING_INFO]: Define dummy \n+\t* dwarf2out.c [!DWARF2_DEBUGGING_INFO]: Define dummy\n \tdwarf2_debug_hooks.\n \t* gengtype-lex.l (IWORD): Allow 'bool'.\n \t(ptr_alias): Match.\n@@ -664,7 +674,7 @@ Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \t* config/d30v/d30v.c (d30v_init_expanders): Likewise.\n \t* config/arm/arm.c (arm_init_expanders): Likewise.\n \t* config/alpha/alpha.c (override_options): Likewise.\n-\t* gengtype.h (enum gc_used_enum): Add GC_MAYBE_POINTED_TO. \n+\t* gengtype.h (enum gc_used_enum): Add GC_MAYBE_POINTED_TO.\n \t* gengtype.c (set_gc_used_type): Handle 'maybe_null' option.\n \t(write_gc_structure_fields): Don't handle 'really' option.\n \tHandle 'maybe_null' option.\n@@ -985,7 +995,7 @@ Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \t* tree.c: Use gengtype for roots.\n \t* tree.h: Use gengtype for roots.\n \t* varasm.c: Use gengtype for roots.\n-\t\n+\n \t* Makefile.in (GTFILES): Add @all_gtfiles@.\n \t* configure: Regenerate.\n \t* configure.in: Construct all_gtfiles from the gtfiles definitions\n@@ -1031,10 +1041,10 @@ Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \t* config/arm/arm.c (arm_mark_machine_status): Delete.\n \t(arm_init_machine_status): Update calling sequence.\n \t(arm_init_expanders): Use canonical name for arm_mark_machine_status.\n-\t* config/cris/cris.c (cris_init_machine_status): Update \n+\t* config/cris/cris.c (cris_init_machine_status): Update\n \tcalling sequence.\n \t* config/d30v/d30v.h (struct machine_function): Use gengtype.\n-\t* config/d30v/d30v.c (d30v_init_machine_status): Update \n+\t* config/d30v/d30v.c (d30v_init_machine_status): Update\n \tcalling sequence.\n \t(d30v_mark_machine_status): Delete.\n \t* config/i386/i386.c: Include gt-i386.h.\n@@ -1043,12 +1053,12 @@ Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \t(ix86_mark_machine_status): Delete.\n \t(override_options): Use canonical namke for ix86_mark_machine_status.\n \t* config/ia64/ia64.h (struct machine_function): Use gengtype.\n-\t* config/ia64/ia64.c (ia64_init_machine_status): Update calling \n+\t* config/ia64/ia64.c (ia64_init_machine_status): Update calling\n \tsequence.\n \t(ia64_mark_machine_status): Delete.\n-\t(ia64_override_options): Use canonical name for \n+\t(ia64_override_options): Use canonical name for\n \tia64_mark_machine_status.\n-\t* config/mmix/mmix.c (mmix_init_machine_status): Update calling \n+\t* config/mmix/mmix.c (mmix_init_machine_status): Update calling\n \tsequence.\n \t* config/rs6000/rs6000.c (rs6000_init_machine_status): Likewise.\n \t* config/xtensa/xtensa.c (xtensa_init_machine_status): Likewise.\n@@ -1191,7 +1201,7 @@ Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \tDocument that the machine_function structures must be allocated\n \tusing GC.  Update mark_machine_status documentation.\n \t* function.h: Don't declare free_machine_status.\n-\t* function.c (free_machine_status): Don't define. \n+\t* function.c (free_machine_status): Don't define.\n \t(free_after_compilation): Don't call free_machine_status.\n \t(ggc_mark_struct_function): Mark f->machine.  Call\n \tmark_machine_status only on non-NULL pointers.\n@@ -1388,7 +1398,7 @@ Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n 2002-06-03  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n-\t* diagnostic.h (diagnostic_count): Move from output_buffer to \n+\t* diagnostic.h (diagnostic_count): Move from output_buffer to\n \tdiagnostic_context.\n \t(diagnostic_kind_count): Adjust definition.\n \n@@ -1555,7 +1565,7 @@ config/h8300:\n 2002-06-02  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* diagnostic.h (struct diagnostic_context):  Add new member\n-\tinternal_error. \n+\tinternal_error.\n \t(internal_error_function): Remove declaration.\n \t* diagnostic.c (internal_error_function): Remove definition..\n \t(internal_error): Adjust use.\n@@ -1641,7 +1651,7 @@ Sat Jun  1 23:29:51 CEST 2002  Jan Hubicka  <jh@suse.cz>\n 2002-06-01  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-inline.c (expand_call_inline): Make the statement\n-\texpression we generate have a COMPOUND_STMT.\t\n+\texpression we generate have a COMPOUND_STMT.\n \n 2002-06-01  Roger Sayle  <roger@eyesopen.com>\n "}, {"sha": "fb9bda58e12e60abd992bc822598b44f9f2206f0", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 4, "deletions": 76, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=33005162262a89f7dfd60e3e402c57d23330edfd", "patch": "@@ -54,10 +54,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n \n-#ifdef HALF_PIC_DEBUG\n-#include \"halfpic.h\"\n-#endif\n-\n #ifdef __GNU_STAB__\n #define STAB_CODE_TYPE enum __stab_debug_code\n #else\n@@ -272,10 +268,6 @@ rtx branch_cmp[2];\n /* what type of branch to use */\n enum cmp_type branch_type;\n \n-/* Number of previously seen half-pic pointers and references.  */\n-static int prev_half_pic_ptrs = 0;\n-static int prev_half_pic_refs = 0;\n-\n /* The target cpu for code generation.  */\n enum processor_type mips_arch;\n \n@@ -2277,46 +2269,10 @@ mips_move_1word (operands, insn, unsignedp)\n \n       else if (code1 == SYMBOL_REF || code1 == CONST)\n \t{\n-\t  if (HALF_PIC_P () && CONSTANT_P (op1) && HALF_PIC_ADDRESS_P (op1))\n-\t    {\n-\t      rtx offset = const0_rtx;\n-\n-\t      if (GET_CODE (op1) == CONST)\n-\t\top1 = eliminate_constant_term (XEXP (op1, 0), &offset);\n-\n-\t      if (GET_CODE (op1) == SYMBOL_REF)\n-\t\t{\n-\t\t  operands[2] = HALF_PIC_PTR (op1);\n-\n-\t\t  if (TARGET_STATS)\n-\t\t    mips_count_memory_refs (operands[2], 1);\n-\n-\t\t  if (INTVAL (offset) == 0)\n-\t\t    {\n-\t\t      delay = DELAY_LOAD;\n-\t\t      ret = (unsignedp && TARGET_64BIT\n-\t\t\t     ? \"lwu\\t%0,%2\"\n-\t\t\t     : \"lw\\t%0,%2\");\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      dslots_load_total++;\n-\t\t      operands[3] = offset;\n-\t\t      if (unsignedp && TARGET_64BIT)\n-\t\t\tret = (SMALL_INT (offset)\n-\t\t\t       ? \"lwu\\t%0,%2%#\\n\\tadd\\t%0,%0,%3\"\n-\t\t\t       : \"lwu\\t%0,%2%#\\n\\t%[li\\t%@,%3\\n\\tadd\\t%0,%0,%@%]\");\n-\t\t      else\n-\t\t\tret = (SMALL_INT (offset)\n-\t\t\t       ? \"lw\\t%0,%2%#\\n\\tadd\\t%0,%0,%3\"\n-\t\t\t       : \"lw\\t%0,%2%#\\n\\t%[li\\t%@,%3\\n\\tadd\\t%0,%0,%@%]\");\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else if (TARGET_MIPS16\n-\t\t   && code1 == CONST\n-\t\t   && GET_CODE (XEXP (op1, 0)) == REG\n-\t\t   && REGNO (XEXP (op1, 0)) == GP_REG_FIRST + 28)\n+\t  if (TARGET_MIPS16\n+\t      && code1 == CONST\n+\t      && GET_CODE (XEXP (op1, 0)) == REG\n+\t      && REGNO (XEXP (op1, 0)) == GP_REG_FIRST + 28)\n \t    {\n \t      /* This case arises on the mips16; see\n                  mips16_gp_pseudo_reg.  */\n@@ -5203,10 +5159,6 @@ override_options ()\n   if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n     flag_pcc_struct_return = 0;\n \n-  /* Tell halfpic.c that we have half-pic code if we do.  */\n-  if (TARGET_HALF_PIC)\n-    HALF_PIC_INIT ();\n-\n   /* -fpic (-KPIC) is the default when TARGET_ABICALLS is defined.  We need\n      to set flag_pic so that the LEGITIMATE_PIC_OPERAND_P macro will work.  */\n   /* ??? -non_shared turns off pic code generation, but this is not\n@@ -6369,11 +6321,6 @@ mips_asm_file_end (file)\n   tree name_tree;\n   struct extern_list *p;\n \n-  if (HALF_PIC_P ())\n-    {\n-      HALF_PIC_FINISH (file);\n-    }\n-\n   if (extern_head)\n     {\n       fputs (\"\\n\", file);\n@@ -7614,20 +7561,6 @@ mips_output_function_epilogue (file, size)\n \t       dslots_jump_total, dslots_jump_filled,\n \t       num_refs[0], num_refs[1], num_refs[2]);\n \n-      if (HALF_PIC_NUMBER_PTRS > prev_half_pic_ptrs)\n-\t{\n-\t  fprintf (stderr,\n-\t\t   \" half-pic=%3d\", HALF_PIC_NUMBER_PTRS - prev_half_pic_ptrs);\n-\t  prev_half_pic_ptrs = HALF_PIC_NUMBER_PTRS;\n-\t}\n-\n-      if (HALF_PIC_NUMBER_REFS > prev_half_pic_refs)\n-\t{\n-\t  fprintf (stderr,\n-\t\t   \" pic-ref=%3d\", HALF_PIC_NUMBER_REFS - prev_half_pic_refs);\n-\t  prev_half_pic_refs = HALF_PIC_NUMBER_REFS;\n-\t}\n-\n       fputc ('\\n', stderr);\n     }\n \n@@ -8085,11 +8018,6 @@ mips_encode_section_info (decl, first)\n \tSYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n     }\n \n-  else if (HALF_PIC_P ())\n-    {\n-      if (first)\n-\tHALF_PIC_ENCODE (decl);\n-    }\n }\n \f\n /* Return register to use for a function return value with VALTYPE for"}, {"sha": "5f71b54ebd27e25a3d5528c4bd31e9f47b0ef30d", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 8, "deletions": 79, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=33005162262a89f7dfd60e3e402c57d23330edfd", "patch": "@@ -172,20 +172,6 @@ extern int mips_string_length;\t\t/* length of strings for mips16 */\n extern void\t\tsdata_section PARAMS ((void));\n extern void\t\tsbss_section PARAMS ((void));\n \n-/* Stubs for half-pic support if not OSF/1 reference platform.  */\n-\n-#ifndef HALF_PIC_P\n-#define HALF_PIC_P() 0\n-#define HALF_PIC_NUMBER_PTRS 0\n-#define HALF_PIC_NUMBER_REFS 0\n-#define HALF_PIC_ENCODE(DECL)\n-#define HALF_PIC_DECLARE(NAME)\n-#define HALF_PIC_INIT()\terror (\"half-pic init called on systems that don't support it\")\n-#define HALF_PIC_ADDRESS_P(X) 0\n-#define HALF_PIC_PTR(X) X\n-#define HALF_PIC_FINISH(STREAM)\n-#endif\n-\n /* Macros to silence warnings about numbers being signed in traditional\n    C and unsigned in ISO C when compiled on 32-bit hosts.  */\n \n@@ -210,7 +196,7 @@ extern void\t\tsbss_section PARAMS ((void));\n #define MASK_SOFT_FLOAT\t   0x00000100\t/* software floating point */\n #define MASK_FLOAT64\t   0x00000200\t/* fp registers are 64 bits */\n #define MASK_ABICALLS\t   0x00000400\t/* emit .abicalls/.cprestore/.cpload */\n-#define MASK_HALF_PIC\t   0x00000800\t/* Emit OSF-style pic refs to externs*/\n+#define MASK_UNUSED1\t   0x00000800\t/* Unused Mask.  */\n #define MASK_LONG_CALLS\t   0x00001000\t/* Always call through a register */\n #define MASK_64BIT\t   0x00002000\t/* Use 64 bit GP registers and insns */\n #define MASK_EMBEDDED_PIC  0x00004000\t/* Generate embedded PIC code */\n@@ -285,9 +271,6 @@ extern void\t\tsbss_section PARAMS ((void));\n \t\t\t\t\t/* .abicalls, etc from Pyramid V.4 */\n #define TARGET_ABICALLS\t\t(target_flags & MASK_ABICALLS)\n \n-\t\t\t\t\t/* OSF pic references to externs */\n-#define TARGET_HALF_PIC\t\t(target_flags & MASK_HALF_PIC)\n-\n \t\t\t\t\t/* software floating point */\n #define TARGET_SOFT_FLOAT\t(target_flags & MASK_SOFT_FLOAT)\n #define TARGET_HARD_FLOAT\t(! TARGET_SOFT_FLOAT)\n@@ -417,10 +400,6 @@ extern void\t\tsbss_section PARAMS ((void));\n      N_(\"Use Irix PIC\")},\t\t\t\t\t\t\\\n   {\"no-abicalls\",\t -MASK_ABICALLS,\t\t\t\t\\\n      N_(\"Don't use Irix PIC\")},\t\t\t\t\t\t\\\n-  {\"half-pic\",\t\t  MASK_HALF_PIC,\t\t\t\t\\\n-     N_(\"Use OSF PIC\")},\t\t\t\t\t\t\\\n-  {\"no-half-pic\",\t -MASK_HALF_PIC,\t\t\t\t\\\n-     N_(\"Don't use OSF PIC\")},\t\t\t\t\t\t\\\n   {\"long-calls\",\t  MASK_LONG_CALLS,\t\t\t\t\\\n      N_(\"Use indirect calls\")},\t\t\t\t\t\t\\\n   {\"no-long-calls\",\t -MASK_LONG_CALLS,\t\t\t\t\\\n@@ -506,11 +485,7 @@ extern void\t\tsbss_section PARAMS ((void));\n #endif\n \n #ifndef TARGET_ENDIAN_DEFAULT\n-#ifndef DECSTATION\n #define TARGET_ENDIAN_DEFAULT MASK_BIG_ENDIAN\n-#else\n-#define TARGET_ENDIAN_DEFAULT 0\n-#endif\n #endif\n \n #ifndef MIPS_ISA_DEFAULT\n@@ -780,35 +755,6 @@ while (0)\n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n \f\n-/* Complain about missing specs and predefines that should be defined in each\n-   of the target tm files to override the defaults.  This is mostly a place-\n-   holder until I can get each of the files updated [mm].  */\n-\n-#if defined(OSF_OS) \\\n-    || defined(DECSTATION) \\\n-    || defined(SGI_TARGET) \\\n-    || defined(MIPS_NEWS) \\\n-    || defined(MIPS_SYSV) \\\n-    || defined(MIPS_SVR4) \\\n-    || defined(MIPS_BSD43)\n-\n-#ifndef CPP_PREDEFINES\n-\t#error \"Define CPP_PREDEFINES in the appropriate tm.h file\"\n-#endif\n-\n-#ifndef LIB_SPEC\n-\t#error \"Define LIB_SPEC in the appropriate tm.h file\"\n-#endif\n-\n-#ifndef STARTFILE_SPEC\n-\t#error \"Define STARTFILE_SPEC in the appropriate tm.h file\"\n-#endif\n-\n-#ifndef MACHINE_TYPE\n-\t#error \"Define MACHINE_TYPE in the appropriate tm.h file\"\n-#endif\n-#endif\n-\n /* Tell collect what flags to pass to nm.  */\n #ifndef NM_FLAGS\n #define NM_FLAGS \"-Bn\"\n@@ -1001,10 +947,6 @@ extern int mips_abi;\n %{mint64|mlong64|mlong32:-mexplicit-type-size }\\\n %{mgp32: %{mfp64:%emay not use both -mgp32 and -mfp64} %{!mfp32: -mfp32}} \\\n %{G*} %{EB:-meb} %{EL:-mel} %{EB:%{EL:%emay not use both -EB and -EL}} \\\n-%{pic-none:   -mno-half-pic} \\\n-%{pic-lib:    -mhalf-pic} \\\n-%{pic-extern: -mhalf-pic} \\\n-%{pic-calls:  -mhalf-pic} \\\n %{save-temps: } \\\n %(subtarget_cc1_spec) \\\n %(cc1_cpu_spec)\"\n@@ -2234,7 +2176,6 @@ extern enum reg_class mips_char_to_class[256];\n \n    `Q'\tis for mips16 GP relative constants\n    `R'\tis for memory references which take 1 word for the instruction.\n-   `S'\tis for references to extern items which are PIC for OSF/rose.\n    `T'\tis for memory addresses that can be used to load two words.  */\n \n #define EXTRA_CONSTRAINT(OP,CODE)\t\t\t\t\t\\\n@@ -2243,8 +2184,6 @@ extern enum reg_class mips_char_to_class[256];\n \t\t\t     && mips16_gp_offset_p (OP))\t\t\\\n    : (GET_CODE (OP) != MEM) ? FALSE\t\t\t\t\t\\\n    : ((CODE) == 'R')\t  ? simple_memory_operand (OP, GET_MODE (OP))\t\\\n-   : ((CODE) == 'S')\t  ? (HALF_PIC_P () && CONSTANT_P (OP)\t\t\\\n-\t\t\t     && HALF_PIC_ADDRESS_P (OP))\t\t\\\n    : FALSE)\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -3092,14 +3031,13 @@ typedef struct mips_args {\n    `la $5,s;sw $4,70000($5)' via LEGITIMIZE_ADDRESS.  */\n /* ??? SGI Irix 6 assembler fails for CONST address, so reject them.  */\n #define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n-  ((GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n     || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH\t\t\\\n     || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n \t&& ! (flag_pic && pic_address_needs_scratch (X))\t\t\\\n \t&& (mips_abi == ABI_32\t\t\t\t\t\t\\\n \t    || mips_abi == ABI_O64\t\t\t\t\t\\\n-\t    || mips_abi == ABI_EABI)))\t\t\t\t\t\\\n-   && (!HALF_PIC_P () || !HALF_PIC_ADDRESS_P (X)))\n+\t    || mips_abi == ABI_EABI)))\n \n /* Define this, so that when PIC, reload won't try to reload invalid\n    addresses which require two reload registers.  */\n@@ -3354,13 +3292,6 @@ typedef struct mips_args {\n \n #define FUNCTION_MODE (Pmode == DImode ? DImode : SImode)\n \n-/* Define TARGET_MEM_FUNCTIONS if we want to use calls to memcpy and\n-   memset, instead of the BSD functions bcopy and bzero.  */\n-\n-#if defined(MIPS_SYSV) || defined(OSF_OS)\n-#define TARGET_MEM_FUNCTIONS\n-#endif\n-\n \f\n /* A part of a C `switch' statement that describes the relative\n    costs of constant RTL expressions.  It must contain `case'\n@@ -4161,7 +4092,7 @@ typedef struct mips_args {\n   ALL_COP_ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n }\n \n-/* This is meant to be redefined in the host dependent files.  It is a \n+/* This is meant to be redefined in the host dependent files.  It is a\n    set of alternative names and regnums for mips coprocessors.  */\n \n #define ALL_COP_ADDITIONAL_REGISTER_NAMES\n@@ -4282,8 +4213,7 @@ while (0)\n \tLM[0-9]+\tSilicon Graphics/ECOFF stabs label before each stmt.\n \t$Lb[0-9]+\tBegin blocks for MIPS debug support\n \t$Lc[0-9]+\tLabel for use in s<xx> operation.\n-\t$Le[0-9]+\tEnd blocks for MIPS debug support\n-\t$Lp\\..+\t\tHalf-pic labels.  */\n+\t$Le[0-9]+\tEnd blocks for MIPS debug support  */\n \n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.\n@@ -4316,7 +4246,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n  {\t\t\t\t\t\t\t\t\t\\\n    mips_declare_object (STREAM, NAME, \"\", \":\\n\", 0);\t\t\t\\\n-   HALF_PIC_DECLARE (NAME);\t\t\t\t\t\t\\\n  }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n@@ -4393,10 +4322,10 @@ do {\t\t\t\t\t\t\t\\\n    emitting the label is moved to function_prologue, so that we can\n    get the line number correctly emitted before the .ent directive,\n    and after any .file directives.  */\n-\n+/*\n #undef ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL)\t\\\n-  HALF_PIC_DECLARE (NAME)\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL)\n+*/\n \n /* This is how to output an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.  */"}, {"sha": "83ae30eb0b9148cb8eac997ca06e3afcdc93332e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=33005162262a89f7dfd60e3e402c57d23330edfd", "patch": "@@ -4938,7 +4938,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n   if ((INTVAL (offset) & 7) == 0\n       && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))\n-    return \\\"sd\\\\t%1,%0\\\";\n+    return \\\"sd\\\\t%z1,%0\\\";\n \n   return \\\"usd\\\\t%z1,%0\\\";\n }\"\n@@ -5131,17 +5131,17 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\")\n \n (define_insn \"movdi_internal2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*x,*d,*x,*a,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n-\t(match_operand:DI 1 \"movdi_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,J,*x,*d,*J,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m,*x,*d,*x,*a,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n+\t(match_operand:DI 1 \"movdi_operand\" \"d,IKL,Mnis,R,m,dJ,dJ,J,*x,*d,*J,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n   \"TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || se_register_operand (operands[1], DImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n        || operands[1] == CONST0_RTX (DImode))\"\n   \"* return mips_move_2words (operands, insn); \"\n-  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n+  [(set_attr \"type\"\t\"move,arith,arith,load,load,store,store,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4,8,4,8,4,8,4,8,4,4,4,8,8,8,8,8,8,8\")])\n+   (set_attr \"length\"\t\"4,4,8,4,8,4,8,4,4,4,8,8,8,8,8,8,8\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,R,m,*d\")\n@@ -5517,7 +5517,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr_alternative\n     \"length\"\n-    [(if_then_else \n+    [(if_then_else\n       (lt (symbol_ref \"(unsigned HOST_WIDE_INT) INTVAL (operands[0])\")\n \t  (const_int 1024))\n       (const_int 4)\n@@ -5527,28 +5527,28 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n (define_insn \"movsi_internal1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*f*z,*f,*f,*f,*R,*m,*x,*x,*d,*d,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*f*z,*d,*f,*R,*m,*f,*f,J,*d,*x,*a,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m,*d,*f*z,*f,*f,*f,*R,*m,*x,*x,*d,*d,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,IKL,Mnis,R,m,dJ,dJ,*f*z,*d,*f,*R,*m,*f,*f,J,*d,*x,*a,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n   \"TARGET_DEBUG_H_MODE && !TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n   \"* return mips_move_1word (operands, insn, FALSE);\"\n-  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,move,load,load,store,store,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n+  [(set_attr \"type\"\t\"move,arith,arith,load,load,store,store,xfer,xfer,move,load,load,store,store,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,8,4,8,4,8,4,8,4,4,4,4,8,4,8,4,4,4,4,4,4,8,4,4,8\")])\n+   (set_attr \"length\"\t\"4,4,8,4,8,4,8,4,4,4,4,8,4,8,4,4,4,4,4,4,8,4,4,8\")])\n \n (define_insn \"movsi_internal2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*z,*x,*d,*x,*d,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*z,*d,J,*x,*d,*a,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m,*d,*z,*x,*d,*x,*d,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,IKL,Mnis,R,m,dJ,dJ,*z,*d,J,*x,*d,*a,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n   \"!TARGET_DEBUG_H_MODE && !TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n   \"* return mips_move_1word (operands, insn, FALSE);\"\n-  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n+  [(set_attr \"type\"\t\"move,arith,arith,load,load,store,store,xfer,xfer,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,8,4,8,4,8,4,8,4,4,4,4,4,4,4,4,8,4,4,8\")])\n+   (set_attr \"length\"\t\"4,4,8,4,8,4,8,4,4,4,4,4,4,4,4,8,4,4,8\")])\n \n ;; This is the mips16 movsi instruction.  We accept a small integer as\n ;; the source if the destination is a GP memory reference.  This is\n@@ -5559,8 +5559,8 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; into a register.\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,d,R,m,*d,*d\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,d,y,S,K,N,s,R,m,d,d,*x,*a\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,R,m,*d,*d\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,d,y,K,N,s,R,m,d,d,*x,*a\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n@@ -5572,13 +5572,12 @@ move\\\\t%0,%z4\\\\n\\\\\n \t   && (SMALL_INT (operands[1])\n \t       || SMALL_INT_UNSIGNED (operands[1]))))\"\n   \"* return mips_move_1word (operands, insn, FALSE);\"\n-  [(set_attr \"type\"\t\"move,move,move,load,arith,arith,arith,load,load,store,store,hilo,hilo\")\n+  [(set_attr \"type\"\t\"move,move,move,arith,arith,arith,load,load,store,store,hilo,hilo\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n \t\t (const_int 4)\n \t\t (const_int 4)\n-\t\t (const_int 8)\n \t\t (if_then_else (match_operand:VOID 1 \"m16_uimm8_1\" \"\")\n \t\t\t       (const_int 4)\n \t\t\t       (const_int 8))"}, {"sha": "6ed34403e9e6034742491943b0b7b973adeb705c", "filename": "gcc/config/mips/openbsd.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2Fconfig%2Fmips%2Fopenbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2Fconfig%2Fmips%2Fopenbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fopenbsd.h?ref=33005162262a89f7dfd60e3e402c57d23330edfd", "patch": "@@ -35,7 +35,7 @@ Boston, MA 02111-1307, USA.  */\n #define LIB_SPEC OBSD_LIB_SPEC\n \n /* By default, OpenBSD mips is little endian.  This is important to set\n-   here as mips/mips.h defaults to big endian unless DECSTATION.  */\n+   here as mips/mips.h defaults to big endian.  */\n #ifndef TARGET_ENDIAN_DEFAULT\n #define TARGET_ENDIAN_DEFAULT 0\n #endif\n@@ -81,7 +81,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Controlling the compilation driver.  */\n \n-/* LINK_SPEC appropriate for OpenBSD:  support for GCC options \n+/* LINK_SPEC appropriate for OpenBSD:  support for GCC options\n    -static, -assert, and -nostdlib. Dynamic loader control.  */\n #undef LINK_SPEC\n #define LINK_SPEC \\"}, {"sha": "f491314f99f412b500bf45d83c725f4865689849", "filename": "gcc/halfpic.c", "status": "removed", "additions": 0, "deletions": 399, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3dfc3ac1c7fcb4d7a9582d20c21baa8b17b605/gcc%2Fhalfpic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3dfc3ac1c7fcb4d7a9582d20c21baa8b17b605/gcc%2Fhalfpic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.c?ref=5d3dfc3ac1c7fcb4d7a9582d20c21baa8b17b605", "patch": "@@ -1,399 +0,0 @@\n-/* OSF/rose half-pic support functions.\n-   Copyright (C) 1992, 1997, 1998, 1999 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-/* The OSF/rose half-pic model assumes that the non-library code does\n-   not need to have full PIC (position independent code), but rather,\n-   that pointers to external references are put into the data section\n-   and dereferenced as normal pointers.  References to static data does\n-   not need to be PIC-ized.\n-\n-   Another optimization is to have the compiler know what symbols are\n-   in the shared libraries, and to only lay down the pointers to\n-   things which in the library proper.  */\n-\n-#include \"config.h\"\n-\n-#ifdef HALF_PIC_INIT\n-\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"expr.h\"\n-#include \"output.h\"\n-#include \"obstack.h\"\n-#include \"halfpic.h\"\n-\n-#define obstack_chunk_alloc xmalloc\n-#define obstack_chunk_free free\n-\n-int flag_half_pic\t\t= 0;\t/* Global half-pic flag.  */\n-int half_pic_number_ptrs\t= 0;\t/* # distinct pointers found */\n-int half_pic_number_refs\t= 0;\t/* # half-pic references */\n-int (*ptr_half_pic_address_p) PARAMS ((rtx)) = half_pic_address_p;\n-\n-/* Obstack to hold generated pic names.  */\n-static struct obstack half_pic_obstack;\n-\n-/* List of pointers created to pic references.  */\n-\n-struct all_refs {\n-  struct all_refs *hash_next;\t/* next name in hash chain */\n-  struct all_refs *next;\t/* next name created */\n-  int\t\t   external_p;\t/* name is an external reference */\n-  int\t\t   pointer_p;\t/* pointer created.  */\n-  const char\t  *ref_name;\t/* reference name to ptr to real_name */\n-  int\t\t   ref_len;\t/* reference name length */\n-  const char\t  *real_name;\t/* real function/data name */\n-  int\t\t   real_len;\t/* strlen (real_name) */\n-};\n-\n-static struct all_refs *half_pic_names;\n-\n-static const char *half_pic_prefix;\n-static int   half_pic_prefix_len;\n-\n-\f\n-/* Return the hash bucket of a name or NULL.  The hash chain is\n-   organized as a self reorganizing circularly linked chain.  It is\n-   assumed that any name passed to use will never be reallocated.  For\n-   names in SYMBOL_REF's this is true, because the names are allocated\n-   on the permanent obstack.  */\n-\n-#ifndef MAX_HASH_TABLE\n-#define MAX_HASH_TABLE 1009\n-#endif\n-\n-#define HASHBITS 30\n-\n-static struct all_refs *half_pic_hash PARAMS ((const char *, int, int));\n-\n-static struct all_refs *\n-half_pic_hash (name, len, create_p)\n-     const char *name;\t\t/* name to hash */\n-     int len;\t\t\t/* length of the name (or 0 to call strlen) */\n-     int create_p;\t\t/* != 0 to create new hash bucket if new */\n-{\n-  static struct all_refs *hash_table[MAX_HASH_TABLE];\n-  static struct all_refs  zero_all_refs;\n-\n-  const unsigned char *uname;\n-  int hash;\n-  int i;\n-  int ch;\n-  struct all_refs *first;\n-  struct all_refs *ptr;\n-\n-  if (len == 0)\n-    len = strlen (name);\n-\n-  /* Compute hash code */\n-  uname = (const unsigned char *)name;\n-  ch = uname[0];\n-  hash = len * 613 + ch;\n-  for (i = 1; i < len; i += 2)\n-    hash = (hash * 613) + uname[i];\n-\n-  hash &= (1 << HASHBITS) - 1;\n-  hash %= MAX_HASH_TABLE;\n-\n-  /* See if the name is in the hash table.  */\n-  ptr = first = hash_table[hash];\n-  if (ptr)\n-    {\n-      do\n-\t{\n-\t  if (len == ptr->real_len\n-\t      && ch == *(ptr->real_name)\n-\t      && !strcmp (name, ptr->real_name))\n-\t    {\n-\t      hash_table[hash] = ptr;\n-\t      return ptr;\n-\t    }\n-\n-\t  ptr = ptr->hash_next;\n-\t}\n-      while (ptr != first);\n-    }\n-\n-  /* name not in hash table.  */\n-  if (!create_p)\n-    return (struct all_refs *) 0;\n-\n-  ptr = (struct all_refs *) obstack_alloc (&half_pic_obstack, sizeof (struct all_refs));\n-  *ptr = zero_all_refs;\n-\n-  ptr->real_name = name;\n-  ptr->real_len  = len;\n-\n-  /* Update circular links.  */\n-  if (first == (struct all_refs *) 0)\n-    ptr->hash_next = ptr;\n-\n-  else\n-    {\n-      ptr->hash_next = first->hash_next;\n-      first->hash_next = ptr;\n-    }\n-\n-  hash_table[hash] = ptr;\n-  return ptr;\n-}\n-\n-\f\n-/* Do any half-pic initializations.  */\n-\n-void\n-half_pic_init ()\n-{\n-  flag_half_pic = TRUE;\n-  half_pic_prefix = HALF_PIC_PREFIX;\n-  half_pic_prefix_len = strlen (half_pic_prefix);\n-  obstack_init (&half_pic_obstack);\n-}\n-\n-\f\n-/* Write out all pointers to pic references.  */\n-\n-void\n-half_pic_finish (stream)\n-     FILE *stream;\n-{\n-  struct all_refs *p = half_pic_names;\n-\n-  if (!p)\n-    return;\n-\n-  data_section ();\n-  for (; p != 0; p = p->next)\n-    {\n-      /* Emit the pointer if used.  */\n-      if (p->pointer_p)\n-\t{\n-\t  ASM_OUTPUT_LABEL (stream, p->ref_name);\n-\t  assemble_aligned_integer (POINTER_SIZE / BITS_PER_UNIT,\n-\t\t\t\t    gen_rtx_SYMBOL_REF (Pmode, p->real_name));\n-\t}\n-    }\n-}\n-\n-\f\n-/* Encode in a declaration whether or not it is half-pic.  */\n-\n-void\n-half_pic_encode (decl)\n-     tree decl;\n-{\n-  enum tree_code code = TREE_CODE (decl);\n-  tree asm_name;\n-  struct all_refs *ptr;\n-\n-  if (!flag_half_pic)\n-    return;\n-\n-  if (code != VAR_DECL && code != FUNCTION_DECL)\n-    return;\n-\n-  asm_name = DECL_ASSEMBLER_NAME (decl);\n-\n-  if (!asm_name)\n-    return;\n-\n-#ifdef HALF_PIC_DEBUG\n-  if (HALF_PIC_DEBUG)\n-    {\n-      fprintf (stderr, \"\\n========== Half_pic_encode %.*s\\n\",\n-\t       IDENTIFIER_LENGTH (asm_name),\n-\t       IDENTIFIER_POINTER (asm_name));\n-      debug_tree (decl);\n-    }\n-#endif\n-\n-  /* If this is not an external reference, it can't be half-pic.  */\n-  if (!DECL_EXTERNAL (decl) && (code != VAR_DECL || !TREE_PUBLIC (decl)))\n-    return;\n-\n-  ptr = half_pic_hash (IDENTIFIER_POINTER (asm_name),\n-\t\t       IDENTIFIER_LENGTH (asm_name),\n-\t\t       TRUE);\n-\n-  ptr->external_p = TRUE;\n-\n-#ifdef HALF_PIC_DEBUG\n-  if (HALF_PIC_DEBUG)\n-    fprintf (stderr, \"\\n%.*s is half-pic\\n\",\n-\t     IDENTIFIER_LENGTH (asm_name),\n-\t     IDENTIFIER_POINTER (asm_name));\n-#endif\n-}\n-\n-\f\n-/* Mark that an object is now local, and no longer needs half-pic.  */\n-\n-void\n-half_pic_declare (name)\n-     const char *name;\n-{\n-  struct all_refs *ptr;\n-\n-  if (!flag_half_pic)\n-    return;\n-\n-  ptr = half_pic_hash (name, 0, FALSE);\n-  if (!ptr)\n-    return;\n-\n-  ptr->external_p = FALSE;\n-\n-#ifdef HALF_PIC_DEBUG\n-  if (HALF_PIC_DEBUG)\n-    fprintf (stderr, \"\\n========== Half_pic_declare %s\\n\", name);\n-#endif\n-}\n-\n-\f\n-/* Mark that an object is explicitly external.  */\n-\n-void\n-half_pic_external (name)\n-     const char *name;\n-{\n-  struct all_refs *ptr;\n-\n-  if (!flag_half_pic)\n-    return;\n-\n-  ptr = half_pic_hash (name, 0, TRUE);\n-  if (!ptr)\n-    return;\n-\n-  ptr->external_p = TRUE;\n-\n-#ifdef HALF_PIC_DEBUG\n-  if (HALF_PIC_DEBUG)\n-    fprintf (stderr, \"\\n========== Half_pic_external %s\\n\", name);\n-#endif\n-}\n-\n-\f\n-/* Return whether an address is half-pic.  */\n-\n-int\n-half_pic_address_p (addr)\n-     rtx addr;\n-{\n-  const char *name;\n-  int len;\n-  struct all_refs *ptr;\n-\n-  if (!flag_half_pic)\n-    return FALSE;\n-\n-  switch (GET_CODE (addr))\n-    {\n-    default:\n-      break;\n-\n-    case CONST:\n-      {\n-\trtx offset = const0_rtx;\n-\taddr = eliminate_constant_term (XEXP (addr, 0), &offset);\n-\tif (GET_CODE (addr) != SYMBOL_REF)\n-\t  return FALSE;\n-      }\n-      /* fall through */\n-\n-    case SYMBOL_REF:\n-      name = XSTR (addr, 0);\n-\n-#ifdef HALF_PIC_DEBUG\n-      if (HALF_PIC_DEBUG)\n-\tfprintf (stderr, \"\\n========== Half_pic_address_p %s\\n\", name);\n-#endif\n-\n-      /* If this is a label, it will have a '*' in front of it.  */\n-      if (name[0] == '*')\n-\treturn FALSE;\n-\n-      /* If this is a reference to the actual half-pic pointer, it\n-\t is obviously not half-pic.  */\n-\n-      len = strlen (name);\n-      if (len > half_pic_prefix_len\n-\t  && half_pic_prefix[0] == name[0]\n-\t  && !strncmp (name, half_pic_prefix, half_pic_prefix_len))\n-\treturn FALSE;\n-\n-      ptr = half_pic_hash (name, len, FALSE);\n-      if (ptr == (struct all_refs *) 0)\n-\treturn FALSE;\n-\n-      if (ptr->external_p)\n-\t{\n-#ifdef HALF_PIC_DEBUG\n-\t  if (HALF_PIC_DEBUG)\n-\t    fprintf (stderr, \"%s is half-pic\\n\", name);\n-#endif\n-\t  return TRUE;\n-\t}\n-    }\n-\n-  return FALSE;\n-}\n-\n-\f\n-/* Return the name of the pointer to the PIC function, allocating\n-   it if need be.  */\n-\n-struct rtx_def *\n-half_pic_ptr (operand)\n-     rtx operand;\n-{\n-  const char *name;\n-  struct all_refs *p;\n-  int len;\n-\n-  if (GET_CODE (operand) != SYMBOL_REF)\n-    return operand;\n-\n-  name = XSTR (operand, 0);\n-  len = strlen (name);\n-  p = half_pic_hash (name, len, FALSE);\n-  if (p == (struct all_refs *) 0 || !p->external_p)\n-    return operand;\n-\n-  if (!p->pointer_p)\n-    {\t\t\t\t/* first time, create pointer */\n-      obstack_grow (&half_pic_obstack, half_pic_prefix, half_pic_prefix_len);\n-      obstack_grow (&half_pic_obstack, name, len+1);\n-\n-      p->next      = half_pic_names;\n-      p->ref_name  = (char *) obstack_finish (&half_pic_obstack);\n-      p->ref_len   = len + half_pic_prefix_len;\n-      p->pointer_p = TRUE;\n-\n-      half_pic_names = p;\n-      half_pic_number_ptrs++;\n-    }\n-\n-  half_pic_number_refs++;\n-  return gen_rtx_SYMBOL_REF (Pmode, p->ref_name);\n-}\n-\n-#endif /* HALF_PIC_INIT */"}, {"sha": "37bc49962b6a5757db1ce3e8346774bd4a3f640d", "filename": "gcc/halfpic.h", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3dfc3ac1c7fcb4d7a9582d20c21baa8b17b605/gcc%2Fhalfpic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3dfc3ac1c7fcb4d7a9582d20c21baa8b17b605/gcc%2Fhalfpic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.h?ref=5d3dfc3ac1c7fcb4d7a9582d20c21baa8b17b605", "patch": "@@ -1,67 +0,0 @@\n-/* OSF/rose half-pic support definitions.\n-   Copyright (C) 1992, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-#ifndef NO_HALF_PIC\n-\n-/* Declare the variable flag_half_pic as 'int' instead of 'extern\n-   int', so that BSS variables are created (even though this is not\n-   strict ANSI).  This is because rtl.c now refers to the\n-   CONSTANT_ADDRESS_P macro, which in turn refers to flag_half_pic,\n-   and wants to call half_pic_address_p, whose address we also store\n-   in a BSS variable.  This way, the gen* programs won't get\n-   unknown symbol errors when being linked (flag_half_pic will never\n-   be true in the gen* programs).  */\n-\n-int flag_half_pic;\t\t\t/* Global half-pic flag.  */\n-int (*ptr_half_pic_address_p) PARAMS ((struct rtx_def *)); /* ptr to half_pic_address_p () */\n-\n-extern int  half_pic_number_ptrs;\t\t\t\t/* # distinct pointers found */\n-extern int  half_pic_number_refs;\t\t\t\t/* # half-pic references */\n-extern void half_pic_encode PARAMS ((union tree_node *));\t/* encode whether half-pic */\n-extern void half_pic_declare PARAMS ((const char *));\t\t/* declare object local */\n-extern void half_pic_external PARAMS ((const char *));\t\t/* declare object external */\n-extern void half_pic_init PARAMS ((void));\t\t\t/* half_pic initialization */\n-extern int  half_pic_address_p PARAMS ((struct rtx_def *));\t/* true if an address is half-pic */\n-extern struct rtx_def *half_pic_ptr PARAMS ((struct rtx_def *));\t/* return RTX for half-pic pointer */\n-#ifdef BUFSIZ\n-extern void half_pic_finish PARAMS ((FILE *));\t/* half_pic termination */\n-#endif\n-\n-/* Macros to provide access to the half-pic stuff (so they can easily\n-   be stubbed out.  */\n-\n-#define HALF_PIC_P()\t\t(flag_half_pic)\n-#define HALF_PIC_NUMBER_PTRS\t(half_pic_number_ptrs)\n-#define HALF_PIC_NUMBER_REFS\t(half_pic_number_refs)\n-\n-#define HALF_PIC_ENCODE(DECL)\thalf_pic_encode (DECL)\n-#define HALF_PIC_DECLARE(NAME)\thalf_pic_declare (NAME)\n-#define HALF_PIC_EXTERNAL(NAME)\thalf_pic_external (NAME)\n-#define HALF_PIC_INIT()\t\thalf_pic_init ()\n-#define HALF_PIC_FINISH(STREAM)\thalf_pic_finish (STREAM)\n-#define HALF_PIC_ADDRESS_P(X)\t((*ptr_half_pic_address_p) (X))\n-#define HALF_PIC_PTR(X)\t\thalf_pic_ptr (X)\n-\n-/* Prefix for half-pic names */\n-#ifndef HALF_PIC_PREFIX\n-#define\tHALF_PIC_PREFIX\t\"__pic_\"\n-#endif\n-\n-#endif /* NO_HALF_PIC */"}, {"sha": "7ac28c0fddd21af649acfbe8be42c5f2bd738573", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33005162262a89f7dfd60e3e402c57d23330edfd/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=33005162262a89f7dfd60e3e402c57d23330edfd", "patch": "@@ -88,10 +88,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"xcoffout.h\"\t\t/* Needed for external data\n \t\t\t\t   declarations for e.g. AIX 4.x.  */\n #endif\n-\n-#ifdef HALF_PIC_DEBUG\n-#include \"halfpic.h\"\n-#endif\n \f\n /* Carry information from ASM_DECLARE_OBJECT_NAME\n    to ASM_FINISH_DECLARE_OBJECT.  */"}]}