{"sha": "c4c8962b49da1e2f98eba05f45211ad4b03eabd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRjODk2MmI0OWRhMWUyZjk4ZWJhMDVmNDUyMTFhZDRiMDNlYWJkOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2011-01-30T22:25:31Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2011-01-30T22:25:31Z"}, "message": "extend.texi: Follow spelling conventions.\n\n\t* doc/extend.texi: Follow spelling conventions.\n\t* doc/invoke.texi: Fix a typo.\n\nFrom-SVN: r169420", "tree": {"sha": "73163426036594569d308de4f8d3022cb7cfcda0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73163426036594569d308de4f8d3022cb7cfcda0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4c8962b49da1e2f98eba05f45211ad4b03eabd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4c8962b49da1e2f98eba05f45211ad4b03eabd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4c8962b49da1e2f98eba05f45211ad4b03eabd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4c8962b49da1e2f98eba05f45211ad4b03eabd8/comments", "author": null, "committer": null, "parents": [{"sha": "e543b94c18e8dd85b3ab05f6b07bae777abb7643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e543b94c18e8dd85b3ab05f6b07bae777abb7643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e543b94c18e8dd85b3ab05f6b07bae777abb7643"}], "stats": {"total": 13, "additions": 9, "deletions": 4}, "files": [{"sha": "33f73a8ae9500e82eced6fb97128b0a0aa12f717", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4c8962b49da1e2f98eba05f45211ad4b03eabd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4c8962b49da1e2f98eba05f45211ad4b03eabd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4c8962b49da1e2f98eba05f45211ad4b03eabd8", "patch": "@@ -1,3 +1,8 @@\n+2011-01-30  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* doc/extend.texi: Follow spelling conventions.\n+\t* doc/invoke.texi: Fix a typo.\n+\n 2011-01-30  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/hpux11.opt: New."}, {"sha": "cf025bdf05e454363f1fc7a233f684e07cf8da65", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4c8962b49da1e2f98eba05f45211ad4b03eabd8/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4c8962b49da1e2f98eba05f45211ad4b03eabd8/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=c4c8962b49da1e2f98eba05f45211ad4b03eabd8", "patch": "@@ -13649,9 +13649,9 @@ The C++ standard differs from the C standard in its treatment of\n volatile objects.  It fails to specify what constitutes a volatile\n access, except to say that C++ should behave in a similar manner to C\n with respect to volatiles, where possible.  However, the different\n-lvalueness of expressions between C and C++ complicate the behaviour.\n+lvalueness of expressions between C and C++ complicate the behavior.\n G++ behaves the same as GCC for volatile access, @xref{C\n-Extensions,,Volatiles}, for a description of GCC's behaviour.\n+Extensions,,Volatiles}, for a description of GCC's behavior.\n \n The C and C++ language specifications differ when an object is\n accessed in a void context:\n@@ -13681,7 +13681,7 @@ possible to ignore the return value from functions returning volatile\n references.  Again, if you wish to force a read, cast the reference to\n an rvalue.\n \n-G++ implements the same behaviour as GCC does when assigning to a\n+G++ implements the same behavior as GCC does when assigning to a\n volatile object -- there is no reread of the assigned-to object, the\n assigned rvalue is reused.  Note that in C++ assignment expressions\n are lvalues, and if used as an lvalue, the volatile object will be"}, {"sha": "93e01f87d6338906b6acebf053b2fa50d4011666", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4c8962b49da1e2f98eba05f45211ad4b03eabd8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4c8962b49da1e2f98eba05f45211ad4b03eabd8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c4c8962b49da1e2f98eba05f45211ad4b03eabd8", "patch": "@@ -7690,7 +7690,7 @@ This option enables the extraction of object files with GIMPLE bytecode out of\n library archives. This improves the quality of optimization by exposing more\n code the the link time optimizer.  This information specify what symbols \n can be accessed externally (by non-LTO object or during dynamic linking).\n-Resulting code quality improvements on binaries (and shared libaries that do\n+Resulting code quality improvements on binaries (and shared libraries that do\n use hidden visibility) is similar to @code{-fwhole-program}.  See\n @option{-flto} for a description on the effect of this flag and how to use it.\n "}]}