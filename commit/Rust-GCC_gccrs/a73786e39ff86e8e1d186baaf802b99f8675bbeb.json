{"sha": "a73786e39ff86e8e1d186baaf802b99f8675bbeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTczNzg2ZTM5ZmY4NmU4ZTFkMTg2YmFhZjgwMmI5OWY4Njc1YmJlYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-06-13T20:55:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-06-13T20:55:59Z"}, "message": "re PR tree-optimization/71403 (wrong code (segfault) at -O3 on x86_64-linux-gnu)\n\n\tPR tree-optimization/71403\n\t* tree-ssa-threadbackward.c\n\t(convert_and_register_jump_thread_path): No longer accept reference\n\tto path.  Do not pop items off the path anymore.\n\t(fsm_find_control_statement_thread_paths): Do not allow threading\n\tto a deeper loop nest.  Pop the last item off the path here rather\n\tthan in convert_and_register_jump_thread_path.\n\n\tPR tree-optimization/71403\n\t* c-c++-common/ubsan/pr71403-1.c: New test.\n\t* c-c++-common/ubsan/pr71403-2.c: New test.\n\t* c-c++-common/ubsan/pr71403-3.c: New test.\n\nFrom-SVN: r237403", "tree": {"sha": "6a2c8bbaf60c75e44945f7c6c198e3a2a1e8fa1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a2c8bbaf60c75e44945f7c6c198e3a2a1e8fa1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a73786e39ff86e8e1d186baaf802b99f8675bbeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a73786e39ff86e8e1d186baaf802b99f8675bbeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a73786e39ff86e8e1d186baaf802b99f8675bbeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a73786e39ff86e8e1d186baaf802b99f8675bbeb/comments", "author": null, "committer": null, "parents": [{"sha": "79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79a2bc2dc96fb0c6efd4db45d6d8d333f676e8a5"}], "stats": {"total": 124, "additions": 117, "deletions": 7}, "files": [{"sha": "91befb5cc249ecaf121f68799f7105f170de4505", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a73786e39ff86e8e1d186baaf802b99f8675bbeb", "patch": "@@ -1,3 +1,13 @@\n+2016-06-13  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/71403\n+\t* tree-ssa-threadbackward.c\n+\t(convert_and_register_jump_thread_path): No longer accept reference\n+\tto path.  Do not pop items off the path anymore.\n+\t(fsm_find_control_statement_thread_paths): Do not allow threading\n+\tto a deeper loop nest.  Pop the last item off the path here rather\n+\tthan in convert_and_register_jump_thread_path.\n+\n 2016-06-13  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \t* config/rs6000/rs6000.h (RS6000_BTM_COMMON): Add the"}, {"sha": "6ba9050d1666ea3588aff27b0c64d883c8f74d9e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a73786e39ff86e8e1d186baaf802b99f8675bbeb", "patch": "@@ -1,3 +1,10 @@\n+2016-06-13  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/71403\n+\t* c-c++-common/ubsan/pr71403-1.c: New test.\n+\t* c-c++-common/ubsan/pr71403-2.c: New test.\n+\t* c-c++-common/ubsan/pr71403-3.c: New test.\n+\n 2016-06-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/71478"}, {"sha": "f8f48675bb15f97eb6b6e88eb20d96431426cfae", "filename": "gcc/testsuite/c-c++-common/ubsan/pr71403-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr71403-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr71403-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr71403-1.c?ref=a73786e39ff86e8e1d186baaf802b99f8675bbeb", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fsanitize=unreachable\" } */\n+\n+char a = -97;\n+int b, c, d, e;\n+\n+int\n+main ()\n+{\n+  int g = d, h = 0, i = 1; \n+  for (; h < 3; h++)\n+    {\n+      if (g > -1)\n+        {\n+          int j;\n+          g = j = 0;\n+          for (; j < 5; j++)\n+          L1:\n+            if (!i)\n+              goto L1;\n+          a = e;\n+        }\n+      else\n+        i = 0;\n+    }\n+  b = c / ~(a | 114);\n+  __builtin_exit (0);\n+}"}, {"sha": "03b6e8399811170cb709d10b4cc91723c2a12aba", "filename": "gcc/testsuite/c-c++-common/ubsan/pr71403-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr71403-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr71403-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr71403-2.c?ref=a73786e39ff86e8e1d186baaf802b99f8675bbeb", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fsanitize=unreachable\" } */\n+\n+char a, c;\n+short b;\n+\n+int\n+main ()\n+{\n+  unsigned d = 0;\n+  int e = 1;\n+  for (a = 0; a < 2; a++)\n+    {\n+      if (e)\n+        c--;\n+      for (; d < 2; d++)\n+        for (b = 0; b; b++)\n+          ;\n+      e = 0;\n+    }\n+  __builtin_exit (0);\n+}"}, {"sha": "1ab7736690820e3c2befaf36bb37fc7391911bb4", "filename": "gcc/testsuite/c-c++-common/ubsan/pr71403-3.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr71403-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr71403-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr71403-3.c?ref=a73786e39ff86e8e1d186baaf802b99f8675bbeb", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fsanitize=unreachable\" } */\n+\n+\n+int a, b, c, d;\n+\n+void\n+fn1 ()\n+{\n+  for (c = 0; c < 2; c++)\n+    {\n+      int e, f = 1;\n+      for (e = 0; e < 2; e++)\n+\t{\n+\t  if (!f)\n+\t    return;\n+\t  for (d = 0; d; d++)\n+\t    f = b;\n+\t}\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  for (; a < 1; a++)\n+    {\n+      fn1 ();\n+    }\n+  __builtin_exit (0);\n+}"}, {"sha": "9dd37adf51c395b38d8f8431e1937f26d94ae62f", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73786e39ff86e8e1d186baaf802b99f8675bbeb/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=a73786e39ff86e8e1d186baaf802b99f8675bbeb", "patch": "@@ -378,7 +378,7 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n    register the path.   */\n \n static void\n-convert_and_register_jump_thread_path (vec<basic_block, va_gc> *&path,\n+convert_and_register_jump_thread_path (vec<basic_block, va_gc> *path,\n \t\t\t\t       edge taken_edge)\n {\n   vec<jump_thread_edge *> *jump_thread_path = new vec<jump_thread_edge *> ();\n@@ -402,9 +402,6 @@ convert_and_register_jump_thread_path (vec<basic_block, va_gc> *&path,\n \n   register_jump_thread (jump_thread_path);\n   --max_threaded_paths;\n-\n-  /* Remove BBI from the path.  */\n-  path->pop ();\n }\n \n /* We trace the value of the SSA_NAME NAME back through any phi nodes looking\n@@ -459,6 +456,9 @@ fsm_find_control_statement_thread_paths (tree name,\n       seen_loop_phi = true;\n     }\n \n+  if (bb_loop_depth (last_bb_in_path) > bb_loop_depth (var_bb))\n+    return;\n+\n   /* Following the chain of SSA_NAME definitions, we jumped from a definition in\n      LAST_BB_IN_PATH to a definition in VAR_BB.  When these basic blocks are\n      different, append to PATH the blocks from LAST_BB_IN_PATH to VAR_BB.  */\n@@ -505,7 +505,9 @@ fsm_find_control_statement_thread_paths (tree name,\n \t NEXT_PATH.  Don't add them here to avoid pollution.  */\n       for (unsigned int i = 0; i < next_path->length () - 1; i++)\n \t{\n-\t  if (visited_bbs->contains ((*next_path)[i]))\n+\t  if (visited_bbs->contains ((*next_path)[i])\n+\t      || (bb_loop_depth (last_bb_in_path)\n+\t\t  > bb_loop_depth ((*next_path)[i])))\n \t    {\n \t      vec_free (next_path);\n \t      return;\n@@ -557,7 +559,12 @@ fsm_find_control_statement_thread_paths (tree name,\n \t     into the canonical form and register it.  */\n \t  edge taken_edge = profitable_jump_thread_path (path, bbi, name, arg);\n \t  if (taken_edge)\n-\t    convert_and_register_jump_thread_path (path, taken_edge);\n+\t    {\n+\t      if (bb_loop_depth (taken_edge->src)\n+\t\t  >= bb_loop_depth (taken_edge->dest))\n+\t\tconvert_and_register_jump_thread_path (path, taken_edge);\n+\t      path->pop ();\n+\t    }\n \t}\n     }\n   else if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n@@ -578,7 +585,12 @@ fsm_find_control_statement_thread_paths (tree name,\n \t  edge taken_edge = profitable_jump_thread_path (path, var_bb,\n \t\t\t\t\t\t     name, arg);\n \t  if (taken_edge)\n-\t    convert_and_register_jump_thread_path (path, taken_edge);\n+\t    {\n+\t      if (bb_loop_depth (taken_edge->src)\n+\t\t  >= bb_loop_depth (taken_edge->dest))\n+\t\tconvert_and_register_jump_thread_path (path, taken_edge);\n+\t      path->pop ();\n+\t    }\n \n \t  /* And put the current block back onto the path so that the\n \t     state of the stack is unchanged when we leave.  */"}]}