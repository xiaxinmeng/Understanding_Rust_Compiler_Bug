{"sha": "2801f23fb82a5ef51c8b460a500786797943e1e9", "node_id": "C_kwDOANBUbNoAKDI4MDFmMjNmYjgyYTVlZjUxYzhiNDYwYTUwMDc4Njc5Nzk0M2UxZTk", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-15T11:11:31Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-15T11:12:16Z"}, "message": "fold, simplify-rtx: Punt on non-representable floating point constants [PR104522]\n\nFor IBM double double I've added in PR95450 and PR99648 verification that\nwhen we at the tree/GIMPLE or RTL level interpret target bytes as a REAL_CST\nor CONST_DOUBLE constant, we try to encode it back to target bytes and\nverify it is the same.\nThis is because our real.c support isn't able to represent all valid values\nof IBM double double which has variable precision.\nIn PR104522, it has been noted that we have similar problem with the\nIntel/Motorola extended XFmode formats, our internal representation isn't\nable to record pseudo denormals, pseudo infinities, pseudo NaNs and unnormal\nvalues.\nSo, the following patch is an attempt to extend that verification to all\nfloats.\nUnfortunately, it wasn't that straightforward, because the\n__builtin_clear_padding code exactly for the XFmode long doubles needs to\ndiscover what bits are padding and does that by interpreting memory of\nall 1s.  That is actually a valid supported value, a qNaN with negative\nsign with all mantissa bits set, but the verification includes also the\npadding bits (exactly what __builtin_clear_padding wants to figure out)\nand so fails the comparison check and so we ICE.\nThe patch fixes that case by moving that verification from\nnative_interpret_real to its caller, so that clear_padding_type can\ncall native_interpret_real and avoid that extra check.\n\nWith this, the only thing that regresses in the testsuite is\n+FAIL: gcc.target/i386/auto-init-4.c scan-assembler-times long\\\\t-16843010 5\nbecause it decides to use a pattern that has non-zero bits in the padding\nbits of the long double, so the simplify-rtx.cc change prevents folding\na SUBREG into a constant.  We emit (the testcase is -O0 but we emit worse\ncode at all opt levels) something like:\n        movabsq $-72340172838076674, %rax\n        movabsq $-72340172838076674, %rdx\n        movq    %rax, -48(%rbp)\n        movq    %rdx, -40(%rbp)\n        fldt    -48(%rbp)\n        fstpt   -32(%rbp)\ninstead of\n        fldt    .LC2(%rip)\n        fstpt   -32(%rbp)\n...\n.LC2:\n        .long   -16843010\n        .long   -16843010\n        .long   65278\n        .long   0\nNote, neither of those sequences actually stores the padding bits, fstpt\nsimply doesn't touch them.\nFor vars with clear_padding_real_needs_padding_p types that are allocated\nto memory at expansion time, I'd say much better would be to do the stores\nusing integral modes rather than XFmode, so do that:\n        movabsq $-72340172838076674, %rax\n        movq    %rax, -32(%rbp)\n        movq    %rax, -24(%rbp)\ndirectly.  That is the only way to ensure the padding bits are initialized\n(or expand __builtin_clear_padding, but then you initialize separately the\nvalue bits and padding bits).\n\n2022-02-15  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/104522\n\t* fold-const.h (native_interpret_real): Declare.\n\t* fold-const.cc (native_interpret_real): No longer static.  Don't\n\tperform MODE_COMPOSITE_P verification here.\n\t(native_interpret_expr) <case REAL_TYPE>: But perform it here instead\n\tfor all modes.\n\t* gimple-fold.cc (clear_padding_type): Call native_interpret_real\n\tinstead of native_interpret_expr.\n\t* simplify-rtx.cc (simplify_immed_subreg): Perform the native_encode_rtx\n\tand comparison verification for all FLOAT_MODE_P modes, not just\n\tMODE_COMPOSITE_P.\n\n\t* gcc.dg/pr104522.c: New test.", "tree": {"sha": "be43207d42fbf3f64420978ef92934c6bd1e8f3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be43207d42fbf3f64420978ef92934c6bd1e8f3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2801f23fb82a5ef51c8b460a500786797943e1e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2801f23fb82a5ef51c8b460a500786797943e1e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2801f23fb82a5ef51c8b460a500786797943e1e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2801f23fb82a5ef51c8b460a500786797943e1e9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8b6da8dd15240849e00d46f3aef40cb8eeb1dc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8b6da8dd15240849e00d46f3aef40cb8eeb1dc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8b6da8dd15240849e00d46f3aef40cb8eeb1dc5"}], "stats": {"total": 55, "additions": 37, "deletions": 18}, "files": [{"sha": "7b21240ba7660adea7a08666ccf383416f47420e", "filename": "gcc/fold-const.cc", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2801f23fb82a5ef51c8b460a500786797943e1e9/gcc%2Ffold-const.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2801f23fb82a5ef51c8b460a500786797943e1e9/gcc%2Ffold-const.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.cc?ref=2801f23fb82a5ef51c8b460a500786797943e1e9", "patch": "@@ -8643,7 +8643,7 @@ native_interpret_fixed (tree type, const unsigned char *ptr, int len)\n    the buffer PTR of length LEN as a REAL_CST of type TYPE.\n    If the buffer cannot be interpreted, return NULL_TREE.  */\n \n-static tree\n+tree\n native_interpret_real (tree type, const unsigned char *ptr, int len)\n {\n   scalar_float_mode mode = SCALAR_FLOAT_TYPE_MODE (type);\n@@ -8694,19 +8694,7 @@ native_interpret_real (tree type, const unsigned char *ptr, int len)\n     }\n \n   real_from_target (&r, tmp, mode);\n-  tree ret = build_real (type, r);\n-  if (MODE_COMPOSITE_P (mode))\n-    {\n-      /* For floating point values in composite modes, punt if this folding\n-\t doesn't preserve bit representation.  As the mode doesn't have fixed\n-\t precision while GCC pretends it does, there could be valid values that\n-\t GCC can't really represent accurately.  See PR95450.  */\n-      unsigned char buf[24];\n-      if (native_encode_expr (ret, buf, total_bytes, 0) != total_bytes\n-\t  || memcmp (ptr, buf, total_bytes) != 0)\n-\tret = NULL_TREE;\n-    }\n-  return ret;\n+  return build_real (type, r);\n }\n \n \n@@ -8824,7 +8812,23 @@ native_interpret_expr (tree type, const unsigned char *ptr, int len)\n       return native_interpret_int (type, ptr, len);\n \n     case REAL_TYPE:\n-      return native_interpret_real (type, ptr, len);\n+      if (tree ret = native_interpret_real (type, ptr, len))\n+\t{\n+\t  /* For floating point values in composite modes, punt if this\n+\t     folding doesn't preserve bit representation.  As the mode doesn't\n+\t     have fixed precision while GCC pretends it does, there could be\n+\t     valid values that GCC can't really represent accurately.\n+\t     See PR95450.  Even for other modes, e.g. x86 XFmode can have some\n+\t     bit combinationations which GCC doesn't preserve.  */\n+\t  unsigned char buf[24];\n+\t  scalar_float_mode mode = SCALAR_FLOAT_TYPE_MODE (type);\n+\t  int total_bytes = GET_MODE_SIZE (mode);\n+\t  if (native_encode_expr (ret, buf, total_bytes, 0) != total_bytes\n+\t      || memcmp (ptr, buf, total_bytes) != 0)\n+\t    return NULL_TREE;\n+\t  return ret;\n+\t}\n+      return NULL_TREE;\n \n     case FIXED_POINT_TYPE:\n       return native_interpret_fixed (type, ptr, len);"}, {"sha": "926c775e69642b7896ac6a4463b4adfdcb244008", "filename": "gcc/fold-const.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2801f23fb82a5ef51c8b460a500786797943e1e9/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2801f23fb82a5ef51c8b460a500786797943e1e9/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=2801f23fb82a5ef51c8b460a500786797943e1e9", "patch": "@@ -36,6 +36,7 @@ extern int native_encode_expr (const_tree, unsigned char *, int, int off = -1);\n extern int native_encode_initializer (tree, unsigned char *, int,\n \t\t\t\t      int off = -1, unsigned char * = nullptr);\n extern tree native_interpret_expr (tree, const unsigned char *, int);\n+extern tree native_interpret_real (tree, const unsigned char *, int);\n extern bool can_native_interpret_type_p (tree);\n extern tree native_interpret_aggregate (tree, const unsigned char *, int, int);\n extern tree find_bitfield_repr_type (int, int);"}, {"sha": "16f02c2d098dcd9751287e390d557449cd960a76", "filename": "gcc/gimple-fold.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2801f23fb82a5ef51c8b460a500786797943e1e9/gcc%2Fgimple-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2801f23fb82a5ef51c8b460a500786797943e1e9/gcc%2Fgimple-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.cc?ref=2801f23fb82a5ef51c8b460a500786797943e1e9", "patch": "@@ -4807,10 +4807,10 @@ clear_padding_type (clear_padding_struct *buf, tree type,\n \tclear_padding_flush (buf, false);\n       if (clear_padding_real_needs_padding_p (type))\n \t{\n-\t  /* Use native_interpret_expr + native_encode_expr to figure out\n+\t  /* Use native_interpret_real + native_encode_expr to figure out\n \t     which bits are padding.  */\n \t  memset (buf->buf + buf->size, ~0, sz);\n-\t  tree cst = native_interpret_expr (type, buf->buf + buf->size, sz);\n+\t  tree cst = native_interpret_real (type, buf->buf + buf->size, sz);\n \t  gcc_assert (cst && TREE_CODE (cst) == REAL_CST);\n \t  int len = native_encode_expr (cst, buf->buf + buf->size, sz);\n \t  gcc_assert (len > 0 && (size_t) len == (size_t) sz);"}, {"sha": "85ad9904143d40c282ce3ae256d267fe37556cf4", "filename": "gcc/simplify-rtx.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2801f23fb82a5ef51c8b460a500786797943e1e9/gcc%2Fsimplify-rtx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2801f23fb82a5ef51c8b460a500786797943e1e9/gcc%2Fsimplify-rtx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.cc?ref=2801f23fb82a5ef51c8b460a500786797943e1e9", "patch": "@@ -7302,7 +7302,7 @@ simplify_immed_subreg (fixed_size_mode outermode, rtx x,\n   else if (!native_encode_rtx (innermode, x, buffer, first_byte, inner_bytes))\n     return NULL_RTX;\n   rtx ret = native_decode_rtx (outermode, buffer, 0);\n-  if (ret && MODE_COMPOSITE_P (outermode))\n+  if (ret && FLOAT_MODE_P (outermode))\n     {\n       auto_vec<target_unit, 128> buffer2 (buffer_bytes);\n       if (!native_encode_rtx (outermode, ret, buffer2, 0, buffer_bytes))"}, {"sha": "4d1d6309ca3553609fb1b1631f34c0b888eb71f1", "filename": "gcc/testsuite/gcc.dg/pr104522.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2801f23fb82a5ef51c8b460a500786797943e1e9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104522.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2801f23fb82a5ef51c8b460a500786797943e1e9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104522.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104522.c?ref=2801f23fb82a5ef51c8b460a500786797943e1e9", "patch": "@@ -0,0 +1,14 @@\n+/* PR middle-end/104522 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fcompare-debug -dP\" } */\n+\n+typedef short __attribute__((__vector_size__(16))) V;\n+long double x;\n+\n+void\n+foo (void)\n+{\n+  V t = { 512, 0, 0, 0, 16384 };\n+  long double u = *(long double *) &t;\n+  x /= u;\n+}"}]}