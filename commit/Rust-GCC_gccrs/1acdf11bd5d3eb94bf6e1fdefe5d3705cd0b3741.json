{"sha": "1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFjZGYxMWJkNWQzZWI5NGJmNmUxZmRlZmU1ZDM3MDVjZDBiMzc0MQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-05-27T02:46:01Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-05-27T02:46:01Z"}, "message": "re PR tree-optimization/9814 (gcc fails to optimise if (l&2) l|=2 away)\n\n\n\tPR tree-optimization/9814\n\t* ifcvt.c (noce_emit_move_insn): If we fail to recognize the move\n\tinstruction, add the necessary clobbers by re-expanding the RTL\n\tfor arithmetic operations via optab.c's expand_unop/expand_binop.\n\t(noce_try_bitop): New function to optimize bit manipulation idioms\n\tof the form \"if (x & C) x = x op C\" and \"if (!(x & C) x = x op C\".\n\t(noce_process_if_block): Call noce_try_bitop.\n\n\t* gcc.dg/pr9814-1.c: New test case.\n\nFrom-SVN: r100240", "tree": {"sha": "9cf44213b16d28aaf90e2b46a6d444069dfde78e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cf44213b16d28aaf90e2b46a6d444069dfde78e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741/comments", "author": null, "committer": null, "parents": [{"sha": "2c9ed0af7e94a0ab37fbbb95bb61e7b324187b69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9ed0af7e94a0ab37fbbb95bb61e7b324187b69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c9ed0af7e94a0ab37fbbb95bb61e7b324187b69"}], "stats": {"total": 275, "additions": 274, "deletions": 1}, "files": [{"sha": "190a25ad6ce87e99b1d5741bf05ed18bb362758d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741", "patch": "@@ -1,3 +1,13 @@\n+2005-05-26  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR tree-optimization/9814\n+\t* ifcvt.c (noce_emit_move_insn): If we fail to recognize the move\n+\tinstruction, add the necessary clobbers by re-expanding the RTL\n+\tfor arithmetic operations via optab.c's expand_unop/expand_binop.\n+\t(noce_try_bitop): New function to optimize bit manipulation idioms\n+\tof the form \"if (x & C) x = x op C\" and \"if (!(x & C) x = x op C\".\n+\t(noce_process_if_block): Call noce_try_bitop.\n+\n 2005-05-26  Roger Sayle  <roger@eyesopen.com>\n \n \t* reg-stack.c (convert_regs_entry, convert_regs_exit,"}, {"sha": "9575e62b2f1c2bd8a07ebb33b378852a9d28dbdc", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 152, "deletions": 1, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741", "patch": "@@ -687,7 +687,57 @@ noce_emit_move_insn (rtx x, rtx y)\n \n   if (GET_CODE (x) != STRICT_LOW_PART)\n     {\n-      emit_move_insn (x, y);\n+      rtx seq, insn, target;\n+      optab ot;\n+\n+      start_sequence ();\n+      insn = emit_move_insn (x, y);\n+      seq = get_insns ();\n+      end_sequence();\n+\n+      if (recog_memoized (insn) <= 0)\n+\tswitch (GET_RTX_CLASS (GET_CODE (y)))\n+\t  {\n+\t  case RTX_UNARY:\n+\t    ot = code_to_optab[GET_CODE (y)];\n+\t    if (ot)\n+\t      {\n+\t\tstart_sequence ();\n+\t\ttarget = expand_unop (GET_MODE (y), ot, XEXP (y, 0), x, 0);\n+\t\tif (target != NULL_RTX)\n+\t\t  {\n+\t\t    if (target != x)\n+\t\t      emit_move_insn (x, target);\n+\t\t    seq = get_insns ();\n+\t\t  }\n+\t\tend_sequence ();\n+\t      }\n+\t    break;\n+\n+\t  case RTX_BIN_ARITH:\n+\t  case RTX_COMM_ARITH:\n+\t    ot = code_to_optab[GET_CODE (y)];\n+\t    if (ot)\n+\t      {\n+\t\tstart_sequence ();\n+\t\ttarget = expand_binop (GET_MODE (y), ot,\n+\t\t\t\t       XEXP (y, 0), XEXP (y, 1),\n+\t\t\t\t       x, 0, OPTAB_DIRECT);\n+\t\tif (target != NULL_RTX)\n+\t\t  {\n+\t\t    if (target != x)\n+\t\t      emit_move_insn (x, target);\n+\t\t    seq = get_insns ();\n+\t\t  }\n+\t\tend_sequence ();\n+\t      }\n+\t    break;\n+\n+\t  default:\n+\t    break;\n+\t  }\n+\n+      emit_insn (seq);\n       return;\n     }\n \n@@ -1815,6 +1865,105 @@ noce_try_sign_mask (struct noce_if_info *if_info)\n }\n \n \n+/* Optimize away \"if (x & C) x |= C\" and similar bit manipulation\n+   transformations.  */\n+\n+static int\n+noce_try_bitop (struct noce_if_info *if_info)\n+{\n+  rtx cond, x, a, result, seq;\n+  enum machine_mode mode;\n+  enum rtx_code code;\n+  int bitnum;\n+\n+  x = if_info->x;\n+  cond = if_info->cond;\n+  code = GET_CODE (cond);\n+\n+  /* Check for no else condition.  */\n+  if (! rtx_equal_p (x, if_info->b))\n+    return FALSE;\n+\n+  /* Check for a suitable condition.  */\n+  if (code != NE && code != EQ)\n+    return FALSE;\n+  if (XEXP (cond, 1) != const0_rtx)\n+    return FALSE;\n+  cond = XEXP (cond, 0);\n+\n+  /* ??? We could also handle AND here.  */\n+  if (GET_CODE (cond) == ZERO_EXTRACT)\n+    {\n+      if (XEXP (cond, 1) != const1_rtx\n+\t  || GET_CODE (XEXP (cond, 2)) != CONST_INT\n+\t  || ! rtx_equal_p (x, XEXP (cond, 0)))\n+\treturn FALSE;\n+      bitnum = INTVAL (XEXP (cond, 2));\n+      mode = GET_MODE (x);\n+      if (bitnum >= HOST_BITS_PER_WIDE_INT)\n+\treturn FALSE;\n+    }\n+  else\n+    return FALSE;\n+\n+  a = if_info->a;\n+  if (GET_CODE (a) == IOR || GET_CODE (a) == XOR)\n+    {\n+      /* Check for \"if (X & C) x = x op C\".  */\n+      if (! rtx_equal_p (x, XEXP (a, 0))\n+          || GET_CODE (XEXP (a, 1)) != CONST_INT\n+\t  || (INTVAL (XEXP (a, 1)) & GET_MODE_MASK (mode))\n+\t     != (unsigned HOST_WIDE_INT) 1 << bitnum)\n+        return FALSE;\n+\n+      /* if ((x & C) == 0) x |= C; is transformed to x |= C.   */\n+      /* if ((x & C) != 0) x |= C; is transformed to nothing.  */\n+      if (GET_CODE (a) == IOR)\n+\tresult = (code == NE) ? a : NULL_RTX;\n+      else if (code == NE)\n+\t{\n+\t  /* if ((x & C) == 0) x ^= C; is transformed to x |= C.   */\n+\t  result = gen_int_mode ((HOST_WIDE_INT) 1 << bitnum, mode);\n+\t  result = simplify_gen_binary (IOR, mode, x, result);\n+\t}\n+      else\n+\t{\n+\t  /* if ((x & C) != 0) x ^= C; is transformed to x &= ~C.  */\n+\t  result = gen_int_mode (~((HOST_WIDE_INT) 1 << bitnum), mode);\n+\t  result = simplify_gen_binary (AND, mode, x, result);\n+\t}\n+    }\n+  else if (GET_CODE (a) == AND)\n+    {\n+      /* Check for \"if (X & C) x &= ~C\".  */\n+      if (! rtx_equal_p (x, XEXP (a, 0))\n+\t  || GET_CODE (XEXP (a, 1)) != CONST_INT\n+\t  || (INTVAL (XEXP (a, 1)) & GET_MODE_MASK (mode))\n+\t     != (~((HOST_WIDE_INT) 1 << bitnum) & GET_MODE_MASK (mode)))\n+        return FALSE;\n+\n+      /* if ((x & C) == 0) x &= ~C; is transformed to nothing.  */\n+      /* if ((x & C) != 0) x &= ~C; is transformed to x &= ~C.  */\n+      result = (code == EQ) ? a : NULL_RTX;\n+    }\n+  else\n+    return FALSE;\n+\n+  if (result)\n+    {\n+      start_sequence ();\n+      noce_emit_move_insn (x, result);\n+      seq = end_ifcvt_sequence (if_info);\n+      if (!seq)\n+\treturn FALSE;\n+\n+      emit_insn_before_setloc (seq, if_info->jump,\n+\t\t\t       INSN_LOCATOR (if_info->insn_a));\n+    }\n+  return TRUE;\n+}\n+\n+\n /* Similar to get_condition, only the resulting condition must be\n    valid at JUMP, instead of at EARLIEST.  */\n \n@@ -2078,6 +2227,8 @@ noce_process_if_block (struct ce_if_block * ce_info)\n     goto success;\n   if (noce_try_store_flag (&if_info))\n     goto success;\n+  if (noce_try_bitop (&if_info))\n+    goto success;\n   if (noce_try_minmax (&if_info))\n     goto success;\n   if (noce_try_abs (&if_info))"}, {"sha": "00185e8011a985476ce99bdef4b6185f4d596d67", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741", "patch": "@@ -1,3 +1,8 @@\n+2005-05-26  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR tree-optimization/9814\n+\t* gcc.dg/pr9814-1.c: New test case.\n+\n 2005-05-26  Ziemowit Laski  <zlaski@apple.com>\n \n \t* objc.dg/comp-types-8.m, objc.dg/encode-6.m,"}, {"sha": "51b79f7839b5735220a545733020773191f3e821", "filename": "gcc/testsuite/gcc.dg/pr9814-1.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741/gcc%2Ftestsuite%2Fgcc.dg%2Fpr9814-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741/gcc%2Ftestsuite%2Fgcc.dg%2Fpr9814-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr9814-1.c?ref=1acdf11bd5d3eb94bf6e1fdefe5d3705cd0b3741", "patch": "@@ -0,0 +1,107 @@\n+/* PR tree-optimization/9814  */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void abort(void);\n+\n+int test1(int x)\n+{\n+  if (x & 2)\n+    x |= 2;\n+  return x;\n+}\n+\n+int test2(int x)\n+{\n+  if (!(x & 2))\n+    x |= 2;\n+  return x;\n+}\n+\n+int test3(int x)\n+{\n+  if (x & 2)\n+    x ^= 2;\n+  return x;\n+}\n+\n+int test4(int x)\n+{\n+  if (!(x & 2))\n+    x ^= 2;\n+  return x;\n+}\n+\n+int test5(int x)\n+{\n+  if (x & 2)\n+    x &= ~2;\n+  return x;\n+}\n+\n+int test6(int x)\n+{\n+  if (!(x & 2))\n+    x &= ~2;\n+  return x;\n+}\n+\n+int main()\n+{\n+  if (test1(0) != 0)\n+    abort();\n+  if (test1(2) != 2)\n+    abort();\n+  if (test1(5) != 5)\n+    abort();\n+  if (test1(7) != 7)\n+    abort();\n+\n+  if (test2(0) != 2)\n+    abort();\n+  if (test2(2) != 2)\n+    abort();\n+  if (test2(5) != 7)\n+    abort();\n+  if (test2(7) != 7)\n+    abort();\n+\n+  if (test3(0) != 0)\n+    abort();\n+  if (test3(2) != 0)\n+    abort();\n+  if (test3(5) != 5)\n+    abort();\n+  if (test3(7) != 5)\n+    abort();\n+\n+  if (test4(0) != 2)\n+    abort();\n+  if (test4(2) != 2)\n+    abort();\n+  if (test4(5) != 7)\n+    abort();\n+  if (test4(7) != 7)\n+    abort();\n+\n+  if (test5(0) != 0)\n+    abort();\n+  if (test5(2) != 0)\n+    abort();\n+  if (test5(5) != 5)\n+    abort();\n+  if (test5(7) != 5)\n+    abort();\n+\n+  if (test6(0) != 0)\n+    abort();\n+  if (test6(2) != 2)\n+    abort();\n+  if (test6(5) != 5)\n+    abort();\n+  if (test6(7) != 7)\n+    abort();\n+\n+  return 0;\n+}\n+"}]}