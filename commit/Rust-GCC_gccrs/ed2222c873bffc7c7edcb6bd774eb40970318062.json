{"sha": "ed2222c873bffc7c7edcb6bd774eb40970318062", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQyMjIyYzg3M2JmZmM3YzdlZGNiNmJkNzc0ZWI0MDk3MDMxODA2Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-09-09T13:56:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-09-09T13:56:49Z"}, "message": "collect2.c (maybe_run_lto_and_relink): Rewrite code producing ld command line to allow more partitions than input files.\n\n\t* collect2.c (maybe_run_lto_and_relink): Rewrite code producing ld\n\tcommand line to allow more partitions than input files.\n\nFrom-SVN: r164106", "tree": {"sha": "34e95c120d70baca27b4ea27470a727259f17104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34e95c120d70baca27b4ea27470a727259f17104"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed2222c873bffc7c7edcb6bd774eb40970318062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed2222c873bffc7c7edcb6bd774eb40970318062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed2222c873bffc7c7edcb6bd774eb40970318062", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed2222c873bffc7c7edcb6bd774eb40970318062/comments", "author": null, "committer": null, "parents": [{"sha": "aa0df10b370929981d5e6bfafd5824516b96386b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa0df10b370929981d5e6bfafd5824516b96386b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa0df10b370929981d5e6bfafd5824516b96386b"}], "stats": {"total": 90, "additions": 49, "deletions": 41}, "files": [{"sha": "1aca240d980f79d40ad606f53c0c17d071ab0bdd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2222c873bffc7c7edcb6bd774eb40970318062/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2222c873bffc7c7edcb6bd774eb40970318062/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed2222c873bffc7c7edcb6bd774eb40970318062", "patch": "@@ -1,3 +1,8 @@\n+2010-09-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* collect2.c (maybe_run_lto_and_relink): Rewrite code producing ld\n+\tcommand line to allow more partitions than input files.\n+\n 2010-09-09  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR middle-end/44554"}, {"sha": "a8cd232c5504aa9a6610469ab7a5f54397bf57d3", "filename": "gcc/collect2.c", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2222c873bffc7c7edcb6bd774eb40970318062/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2222c873bffc7c7edcb6bd774eb40970318062/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=ed2222c873bffc7c7edcb6bd774eb40970318062", "patch": "@@ -942,20 +942,28 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n     {\n       char **lto_c_argv;\n       const char **lto_c_ptr;\n-      const char **p, **q, **r;\n-      const char **lto_o_ptr;\n+      char **p;\n+      char **lto_o_ptr;\n       struct lto_object *list;\n       char *lto_wrapper = getenv (\"COLLECT_LTO_WRAPPER\");\n       struct pex_obj *pex;\n       const char *prog = \"lto-wrapper\";\n+      int lto_ld_argv_size = 0;\n+      char **out_lto_ld_argv;\n+      int out_lto_ld_argv_size;\n+      size_t num_files;\n \n       if (!lto_wrapper)\n \tfatal (\"COLLECT_LTO_WRAPPER must be set.\");\n \n       num_lto_c_args++;\n \n       /* There is at least one object file containing LTO info,\n-         so we need to run the LTO back end and relink.  */\n+         so we need to run the LTO back end and relink.\n+\n+\t To do so we build updated ld arguments with first\n+\t LTO object replaced by all partitions and other LTO\n+\t objects removed.  */\n \n       lto_c_argv = (char **) xcalloc (sizeof (char *), num_lto_c_args);\n       lto_c_ptr = CONST_CAST2 (const char **, char **, lto_c_argv);\n@@ -973,7 +981,7 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n       {\n \tint c;\n \tFILE *stream;\n-\tsize_t i, num_files;\n+\tsize_t i;\n \tchar *start, *end;\n \n \tstream = pex_read_output (pex, 0);\n@@ -1007,55 +1015,50 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n       do_wait (prog, pex);\n       pex = NULL;\n \n+      /* Compute memory needed for new LD arguments.  At most number of original arguemtns\n+\t plus number of partitions.  */\n+      for (lto_ld_argv_size = 0; lto_ld_argv[lto_ld_argv_size]; lto_ld_argv_size++)\n+\t;\n+      out_lto_ld_argv = XCNEWVEC(char *, num_files + lto_ld_argv_size + 1);\n+      out_lto_ld_argv_size = 0;\n+\n       /* After running the LTO back end, we will relink, substituting\n \t the LTO output for the object files that we submitted to the\n \t LTO. Here, we modify the linker command line for the relink.  */\n-      p = CONST_CAST2 (const char **, char **, lto_ld_argv);\n-      lto_o_ptr = CONST_CAST2 (const char **, char **, lto_o_files);\n \n+      /* Copy all arguments until we find first LTO file.  */\n+      p = lto_ld_argv;\n       while (*p != NULL)\n         {\n           for (list = lto_objects.first; list; list = list->next)\n-            {\n-              if (*p == list->name) /* Note test for pointer equality!  */\n-                {\n-                  /* Excise argument from linker command line.  */\n-                  if (*lto_o_ptr)\n-                    {\n-                      /* Replace first argument with LTO output file.  */\n-                      *p++ = *lto_o_ptr++;\n-                    }\n-                  else\n-                    {\n-                      /* Move following arguments one position earlier,\n-                         overwriting the current argument.  */\n-                      q = p;\n-                      r = p + 1;\n-                      while (*r != NULL)\n-                        *q++ = *r++;\n-                      *q = NULL;\n-                    }\n-\n-                  /* No need to continue searching the LTO object list.  */\n-                  break;\n-                }\n-            }\n-\n-          /* If we didn't find a match, move on to the next argument.\n-             Otherwise, P has been set to the correct argument position\n-             at which to continue.  */\n-          if (!list) ++p;\n+            if (*p == list->name) /* Note test for pointer equality!  */\n+\t      break;\n+\t  if (list)\n+\t    break;\n+\t  out_lto_ld_argv[out_lto_ld_argv_size++] = *p++;\n         }\n \n-      /* The code above assumes we will never have more lto output files than\n-\t input files.  Otherwise, we need to resize lto_ld_argv.  Check this\n-\t assumption.  */\n-      if (*lto_o_ptr)\n-\tfatal (\"too many lto output files\");\n+      /* Now insert all LTO partitions.  */\n+      lto_o_ptr = lto_o_files;\n+      while (*lto_o_ptr)\n+\tout_lto_ld_argv[out_lto_ld_argv_size++] = *lto_o_ptr++;\n+\n+      /* ... and copy the rest.  */\n+      while (*p != NULL)\n+        {\n+          for (list = lto_objects.first; list; list = list->next)\n+            if (*p == list->name) /* Note test for pointer equality!  */\n+\t      break;\n+\t  if (!list)\n+\t    out_lto_ld_argv[out_lto_ld_argv_size++] = *p;\n+\t  p++;\n+        }\n+      out_lto_ld_argv[out_lto_ld_argv_size++] = 0;\n \n       /* Run the linker again, this time replacing the object files\n          optimized by the LTO with the temporary file generated by the LTO.  */\n-      fork_execute (\"ld\", lto_ld_argv);\n+      fork_execute (\"ld\", out_lto_ld_argv);\n+      free (lto_ld_argv);\n \n       maybe_unlink_list (lto_o_files);\n     }"}]}