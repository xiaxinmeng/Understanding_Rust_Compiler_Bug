{"sha": "dfdb644f4ff71f04c78e307035d81c3fac0a18b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZkYjY0NGY0ZmY3MWYwNGM3OGUzMDcwMzVkODFjM2ZhYzBhMThiNg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-09-20T13:58:33Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-09-20T13:58:33Z"}, "message": "gcse.c (invalid_nonnull_info): New function.\n\n        * gcse.c (invalid_nonnull_info): New function.\n        (delete_null_pointer_checks): Likewise.\n        * rtl.h (delete_null_pointer_checks): Declare.\n        * toplev.c (rest_of_compilation): Call delete_null_pointer_checks.\n\nFrom-SVN: r29521", "tree": {"sha": "b885b6669dd819babbce7f0652db442dc385332e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b885b6669dd819babbce7f0652db442dc385332e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfdb644f4ff71f04c78e307035d81c3fac0a18b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfdb644f4ff71f04c78e307035d81c3fac0a18b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfdb644f4ff71f04c78e307035d81c3fac0a18b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfdb644f4ff71f04c78e307035d81c3fac0a18b6/comments", "author": null, "committer": null, "parents": [{"sha": "39dd8003d3b7040d282bd7afe3ddfb49fcb09902", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39dd8003d3b7040d282bd7afe3ddfb49fcb09902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39dd8003d3b7040d282bd7afe3ddfb49fcb09902"}], "stats": {"total": 261, "additions": 261, "deletions": 0}, "files": [{"sha": "c3c18a7cff7ed51b0ae8d20bc75c5a9b0daaff93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdb644f4ff71f04c78e307035d81c3fac0a18b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdb644f4ff71f04c78e307035d81c3fac0a18b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfdb644f4ff71f04c78e307035d81c3fac0a18b6", "patch": "@@ -20,6 +20,11 @@ Mon Sep 20 14:43:37 1999  Nick Clifton  <nickc@cygnus.com>\n \n Mon Sep 20 05:41:36 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* gcse.c (invalid_nonnull_info): New function.\n+\t(delete_null_pointer_checks): Likewise.\n+\t* rtl.h (delete_null_pointer_checks): Declare.\n+\t* toplev.c (rest_of_compilation): Call delete_null_pointer_checks.\n+\n \t* flow.c (merge_blocks_move_predecessor_nojumps): New function.\n \t(merge-blocks_move_successor_nojumps): Likewise.\n \t(merge_blocks): Allow merging of some blocks, even if it requires"}, {"sha": "a02320ec5beabacf3454612387e5bb0ba7b5284b", "filename": "gcc/gcse.c", "status": "modified", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdb644f4ff71f04c78e307035d81c3fac0a18b6/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdb644f4ff71f04c78e307035d81c3fac0a18b6/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=dfdb644f4ff71f04c78e307035d81c3fac0a18b6", "patch": "@@ -620,6 +620,8 @@ static int handle_avail_expr\t  PROTO ((rtx, struct expr *));\n static int classic_gcse\t       PROTO ((void));\n static int one_classic_gcse_pass      PROTO ((int));\n \n+static void invalidate_nonnull_info\tPROTO ((rtx, rtx));\n+\n \f\n /* Entry point for global common subexpression elimination.\n    F is the first instruction in the function.  */\n@@ -4798,3 +4800,247 @@ compute_transpout ()\n \t}\n     }\n }\n+\n+/* Removal of useless null pointer checks */\n+\n+/* These need to be file static for communication between \n+   invalidate_nonnull_info and delete_null_pointer_checks.  */\n+static int current_block;\n+static sbitmap *nonnull_local;\n+static sbitmap *nonnull_killed;\n+\n+/* Called via note_stores.  X is set by SETTER.  If X is a register we must\n+   invalidate nonnull_local and set nonnull_killed.\n+\n+   We ignore hard registers.  */\n+static void\n+invalidate_nonnull_info (x, setter)\n+     rtx x;\n+     rtx setter ATTRIBUTE_UNUSED;\n+{\n+  int offset, regno;\n+\n+  offset = 0;\n+  while (GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+\n+  /* Ignore anything that is not a register or is a hard register.  */\n+  if (GET_CODE (x) != REG\n+      || REGNO (x) < FIRST_PSEUDO_REGISTER)\n+    return;\n+\n+  regno = REGNO (x);\n+\n+  RESET_BIT (nonnull_local[current_block], regno);\n+  SET_BIT (nonnull_killed[current_block], regno);\n+  \n+}\n+\n+/* Find EQ/NE comparisons against zero which can be (indirectly) evaluated\n+   at compile time.\n+\n+   This is conceptually similar to global constant/copy propagation and\n+   classic global CSE (it even uses the same dataflow equations as cprop).\n+\n+   If a register is used as memory address with the form (mem (reg)), then we\n+   know that REG can not be zero at that point in the program.  Any instruction\n+   which sets REG \"kills\" this property.\n+\n+   So, if every path leading to a conditional branch has an available memory\n+   reference of that form, then we know the register can not have the value\n+   zero at the conditional branch.  \n+\n+   So we merely need to compute the local properies and propagate that data\n+   around the cfg, then optimize where possible.\n+\n+   We run this pass two times.  Once before CSE, then again after CSE.  This\n+   has proven to be the most profitable approach.  It is rare for new\n+   optimization opportunities of this nature to appear after the first CSE\n+   pass.\n+\n+   This could probably be integrated with global cprop with a little work.  */\n+\n+void\n+delete_null_pointer_checks (f)\n+     rtx f;\n+{\n+  int_list_ptr *s_preds, *s_succs;\n+  int *num_preds, *num_succs;\n+  int changed, bb;\n+  sbitmap *nonnull_avin, *nonnull_avout;\n+  \n+  /* First break the program into basic blocks.  */\n+  find_basic_blocks (f, max_reg_num (), NULL, 1);\n+\n+  /* If we have only a single block, then there's nothing to do.  */\n+  if (n_basic_blocks <= 1)\n+    {\n+      /* Free storage allocated by find_basic_blocks.  */\n+      free_basic_block_vars (0);\n+      return;\n+    }\n+\n+  /* We need predecessor/successor lists as well as pred/succ counts for\n+     each basic block.  */\n+  s_preds = (int_list_ptr *) alloca (n_basic_blocks * sizeof (int_list_ptr));\n+  s_succs = (int_list_ptr *) alloca (n_basic_blocks * sizeof (int_list_ptr));\n+  num_preds = (int *) alloca (n_basic_blocks * sizeof (int));\n+  num_succs = (int *) alloca (n_basic_blocks * sizeof (int));\n+  compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n+\n+  /* Allocate bitmaps to hold local and global properties.  */\n+  nonnull_local = sbitmap_vector_alloc (n_basic_blocks, max_reg_num ());\n+  nonnull_killed = sbitmap_vector_alloc (n_basic_blocks, max_reg_num ());\n+  nonnull_avin = sbitmap_vector_alloc (n_basic_blocks, max_reg_num ());\n+  nonnull_avout = sbitmap_vector_alloc (n_basic_blocks, max_reg_num ());\n+\n+  /* Compute local properties, nonnull and killed.  A register will have\n+     the nonnull property if at the end of the current block its value is\n+     known to be nonnull.  The killed property indicates that somewhere in\n+     the block any information we had about the register is killed.\n+\n+     Note that a register can have both properties in a single block.  That\n+     indicates that it's killed, then later in the block a new value is\n+     computed.  */\n+  sbitmap_vector_zero (nonnull_local, n_basic_blocks);\n+  sbitmap_vector_zero (nonnull_killed, n_basic_blocks);\n+  for (current_block = 0; current_block < n_basic_blocks; current_block++)\n+    {\n+      rtx insn, stop_insn;\n+\n+      /* Scan each insn in the basic block looking for memory references and\n+\t register sets.  */\n+      stop_insn = NEXT_INSN (BLOCK_END (current_block));\n+      for (insn = BLOCK_HEAD (current_block);\n+\t   insn != stop_insn;\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  rtx set;\n+\n+\t  /* Ignore anything that is not a normal insn.  */\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\t    continue;\n+\n+\t  /* Basically ignore anything that is not a simple SET.  We do have\n+\t     to make sure to invalidate nonnull_local and set nonnull_killed\n+\t     for such insns though.  */\n+\t  set = single_set (insn);\n+\t  if (!set)\n+\t    {\n+\t      note_stores (PATTERN (insn), invalidate_nonnull_info);\n+\t      continue;\n+\t    }\n+\n+\t  /* See if we've got a useable memory load.  We handle it first\n+\t     in case it uses its address register as a dest (which kills\n+\t     the nonnull property).  */\n+\t  if (GET_CODE (SET_SRC (set)) == MEM\n+\t      && GET_CODE (XEXP (SET_SRC (set), 0)) == REG\n+\t      && REGNO (XEXP (SET_SRC (set), 0)) >= FIRST_PSEUDO_REGISTER)\n+\t    SET_BIT (nonnull_local[current_block],\n+\t\t     REGNO (XEXP (SET_SRC (set), 0)));\n+\n+\t  /* Now invalidate stuff clobbered by this insn.  */\n+\t  note_stores (PATTERN (insn), invalidate_nonnull_info);\n+\n+\t  /* And handle stores, we do these last since any sets in INSN can\n+\t     not kill the nonnull property if it is derived from a MEM\n+\t     appearing in a SET_DEST.  */\n+\t  if (GET_CODE (SET_DEST (set)) == MEM\n+\t      && GET_CODE (XEXP (SET_DEST (set), 0)) == REG)\n+\t    SET_BIT (nonnull_local[current_block],\n+\t\t     REGNO (XEXP (SET_DEST (set), 0)));\n+\t}\n+    }\n+\n+  /* Now compute global properties based on the local properties.   This\n+     is a classic global availablity algorithm.  */\n+  sbitmap_zero (nonnull_avin[0]);\n+  sbitmap_vector_ones (nonnull_avout, n_basic_blocks);\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+\n+      for (bb = 0; bb < n_basic_blocks; bb++)\n+\t{\n+\t  if (bb != 0)\n+\t    sbitmap_intersect_of_predecessors (nonnull_avin[bb],\n+\t\t\t\t\t       nonnull_avout, bb, s_preds);\n+\n+\t  changed |= sbitmap_union_of_diff (nonnull_avout[bb],\n+\t\t\t\t\t    nonnull_local[bb],\n+\t\t\t\t\t    nonnull_avin[bb],\n+\t\t\t\t\t    nonnull_killed[bb]);\n+\t}\n+    }\n+\n+  /* Now look at each bb and see if it ends with a compare of a value\n+     against zero.  */\n+  for (bb = 0; bb < n_basic_blocks; bb++)\n+    {\n+      rtx last_insn = BLOCK_END (bb);\n+      rtx condition, earliest, reg;\n+      int compare_and_branch;\n+\n+      /* We only want conditional branches.  */\n+      if (GET_CODE (last_insn) != JUMP_INSN\n+\t  || !condjump_p (last_insn)\n+\t  || simplejump_p (last_insn))\n+\tcontinue;\n+\n+      /* LAST_INSN is a conditional jump.  Get its condition.  */\n+      condition = get_condition (last_insn, &earliest);\n+\n+      /* If we were unable to get the condition, or it is not a equality\n+\t comparison against zero then there's nothing we can do.  */\n+      if (!condition\n+\t  || (GET_CODE (condition) != NE && GET_CODE (condition) != EQ)\n+\t  || GET_CODE (XEXP (condition, 1)) != CONST_INT\n+\t  || XEXP (condition, 1) != CONST0_RTX (GET_MODE (XEXP (condition, 0))))\n+\tcontinue;\n+\n+      /* We must be checking a register against zero.  */\n+      reg = XEXP (condition, 0);\n+      if (GET_CODE (reg) != REG)\n+\tcontinue;\n+\n+      /* Is the register known to have a nonzero value?  */\n+      if (!TEST_BIT (nonnull_avout[bb], REGNO (reg)))\n+\tcontinue;\n+\n+      /* Try to compute whether the compare/branch at the loop end is one or\n+\t two instructions.  */\n+      if (earliest == last_insn)\n+\tcompare_and_branch = 1;\n+      else if (earliest == prev_nonnote_insn (last_insn))\n+\tcompare_and_branch = 2;\n+      else\n+\tcontinue;\n+\n+      /* We know the register in this comparison is nonnull at exit from\n+\t this block.  We can optimize this comparison.  */\n+      if (GET_CODE (condition) == NE)\n+\t{\n+\t  rtx new_jump;\n+\n+\t  new_jump = emit_jump_insn_before (gen_jump (JUMP_LABEL (last_insn)),\n+\t\t\t\t\t    last_insn);\n+\t  JUMP_LABEL (new_jump) = JUMP_LABEL (last_insn);\n+\t  LABEL_NUSES (JUMP_LABEL (new_jump))++;\n+\t  emit_barrier_after (new_jump);\n+\t}\n+      delete_insn (last_insn);\n+      if (compare_and_branch == 2)\n+\tdelete_insn (earliest);\n+    }\n+\n+  /* Free storage allocated by find_basic_blocks.  */\n+  free_basic_block_vars (0);\n+\n+  /* Free bitmaps.  */\n+  free (nonnull_local);\n+  free (nonnull_killed);\n+  free (nonnull_avin);\n+  free (nonnull_avout);\n+}"}, {"sha": "cf65d5fb118a16b908bee21b4e3a71f4b2a19a35", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdb644f4ff71f04c78e307035d81c3fac0a18b6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdb644f4ff71f04c78e307035d81c3fac0a18b6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=dfdb644f4ff71f04c78e307035d81c3fac0a18b6", "patch": "@@ -1697,4 +1697,6 @@ extern rtx addr_side_effect_eval\tPROTO ((rtx, int, int));\n extern int stack_regs_mentioned\t\tPROTO((rtx insn));\n #endif\n \n+\n+extern void delete_null_pointer_checks\tPROTO ((rtx));\n #endif /* _RTL_H */"}, {"sha": "ea7f6d123673f56209a157d132d87a3b33e8de9f", "filename": "gcc/toplev.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdb644f4ff71f04c78e307035d81c3fac0a18b6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdb644f4ff71f04c78e307035d81c3fac0a18b6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=dfdb644f4ff71f04c78e307035d81c3fac0a18b6", "patch": "@@ -3707,6 +3707,10 @@ rest_of_compilation (decl)\n   if (rtl_dump_and_exit || flag_syntax_only || DECL_DEFER_OUTPUT (decl))\n     goto exit_rest_of_compilation;\n \n+  /* Try to identify useless null pointer tests and delete them.  */\n+  if (optimize > 1)\n+    TIMEVAR (jump_time, delete_null_pointer_checks (get_insns ()));\n+\n   /* Dump rtl code after jump, if we are doing that.  */\n   if (jump_opt_dump)\n     dump_rtl (\".jump\", decl, print_rtl, insns);\n@@ -3741,6 +3745,10 @@ rest_of_compilation (decl)\n \tTIMEVAR (jump_time, jump_optimize (insns, !JUMP_CROSS_JUMP,\n \t\t\t\t\t   !JUMP_NOOP_MOVES,\n \t\t\t\t\t   !JUMP_AFTER_REGSCAN));\n+ \n+      /* Try to identify useless null pointer tests and delete them.  */\n+      if (optimize > 1)\n+\tTIMEVAR (jump_time, delete_null_pointer_checks (get_insns ()));\n \n       /* Dump rtl code after cse, if we are doing that.  */\n "}]}