{"sha": "1fdf73384d0ac48ba735153438ce53e6e8234822", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZkZjczMzg0ZDBhYzQ4YmE3MzUxNTM0MzhjZTUzZTZlODIzNDgyMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-28T12:43:44Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-28T12:43:44Z"}, "message": "(movdi matchers): Support odd numbered regs.\n\nFrom-SVN: r10177", "tree": {"sha": "f7b233b1c6d6a8664f3ef62a35fd5d2451af0191", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7b233b1c6d6a8664f3ef62a35fd5d2451af0191"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fdf73384d0ac48ba735153438ce53e6e8234822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fdf73384d0ac48ba735153438ce53e6e8234822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fdf73384d0ac48ba735153438ce53e6e8234822", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fdf73384d0ac48ba735153438ce53e6e8234822/comments", "author": null, "committer": null, "parents": [{"sha": "280fc31e5d1653a576aac4b0145729bf470c6c4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280fc31e5d1653a576aac4b0145729bf470c6c4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/280fc31e5d1653a576aac4b0145729bf470c6c4c"}], "stats": {"total": 82, "additions": 69, "deletions": 13}, "files": [{"sha": "a86fb67ce68f4ac88276cd83ca9233e1d2eb13b4", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 69, "deletions": 13, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fdf73384d0ac48ba735153438ce53e6e8234822/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fdf73384d0ac48ba735153438ce53e6e8234822/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=1fdf73384d0ac48ba735153438ce53e6e8234822", "patch": "@@ -807,8 +807,8 @@\n \n ;; The store case can not be separate.  See comment above.\n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,m,o\")\n-\t(match_operand:DI 1 \"general_operand\" \"dI,i,m,d,J\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,d,m,o\")\n+\t(match_operand:DI 1 \"general_operand\" \"d,I,i,m,d,J\"))]\n   \"(current_function_args_size == 0\n     && current_function_varargs == 0\n     && current_function_stdarg == 0\n@@ -821,24 +821,52 @@\n   switch (which_alternative)\n     {\n     case 0:\n-      return \\\"movl\t%1,%0\\\";\n+      if ((REGNO (operands[0]) & 1)\n+\t  || (REGNO (operands[1]) & 1))\n+\t{\n+\t  /* We normally copy the low-numbered register first.  However, if\n+\t     the second register operand 0 is the same as the first register\n+\t     of operand 1, we must copy in the opposite order.  */\n+\t  if (REGNO (operands[0]) + 1 == REGNO (operands[1]))\n+\t    return \\\"mov\t%D0,%D1\\;mov\t%0,%1\\\";\n+\t  else\n+\t    return \\\"mov\t%0,%1\\;mov\t%D0,%D1\\\";\n+\t}\n+      else\n+\treturn \\\"movl\t%1,%0\\\";\n     case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n+      if (REGNO (operands[0]) & 1)\n+\treturn \\\"mov\t%1,%0\\;mov\t0,%D0\\\";\n+      else\n+\treturn \\\"movl\t%1,%0\\\";\n     case 2:\n-      return \\\"ldl\t%1,%0\\\";\n+      return i960_output_ldconst (operands[0], operands[1]);\n     case 3:\n-      return \\\"stl\t%1,%0\\\";\n+      if (REGNO (operands[0]) & 1)\n+\t{\n+\t  /* One can optimize a few cases here, but you have to be\n+\t     careful of clobbering registers used in the address and\n+\t     edge conditions.  */\n+\t  operands[2] = gen_rtx (REG, Pmode, REGNO (operands[0]) + 1);\n+\t  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n+\t  operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n+\t  return \\\"lda\t%1,%2\\;ld\t%3,%0\\;ld\t%4,%D0\\\";\n+\t}\n+      else\n+\treturn \\\"ldl\t%1,%0\\\";\n     case 4:\n+      return \\\"stl\t%1,%0\\\";\n+    case 5:\n       operands[1] = adj_offsettable_operand (operands[0], 4);\n       return \\\"st\tg14,%0\\;st\tg14,%1\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"move,load,load,store,store\")])\n+  [(set_attr \"type\" \"move,move,load,load,store,store\")])\n \n ;; The store case can not be separate.  See comment above.\n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:DI 1 \"general_operand\" \"dI,i,m,d\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,d,m\")\n+\t(match_operand:DI 1 \"general_operand\" \"d,I,i,m,d\"))]\n   \"(current_function_args_size != 0\n     || current_function_varargs != 0\n     || current_function_stdarg != 0\n@@ -850,16 +878,44 @@\n   switch (which_alternative)\n     {\n     case 0:\n-      return \\\"movl\t%1,%0\\\";\n+      if ((REGNO (operands[0]) & 1)\n+\t  || (REGNO (operands[1]) & 1))\n+\t{\n+\t  /* We normally copy the low-numbered register first.  However, if\n+\t     the second register operand 0 is the same as the first register\n+\t     of operand 1, we must copy in the opposite order.  */\n+\t  if (REGNO (operands[0]) + 1 == REGNO (operands[1]))\n+\t    return \\\"mov\t%D0,%D1\\;mov\t%0,%1\\\";\n+\t  else\n+\t    return \\\"mov\t%0,%1\\;mov\t%D0,%D1\\\";\n+\t}\n+      else\n+\treturn \\\"movl\t%1,%0\\\";\n     case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n+      if (REGNO (operands[0]) & 1)\n+\treturn \\\"mov\t%1,%0\\;mov\t0,%D0\\\";\n+      else\n+\treturn \\\"movl\t%1,%0\\\";\n     case 2:\n-      return \\\"ldl\t%1,%0\\\";\n+      return i960_output_ldconst (operands[0], operands[1]);\n     case 3:\n+      if (REGNO (operands[0]) & 1)\n+\t{\n+\t  /* One can optimize a few cases here, but you have to be\n+\t     careful of clobbering registers used in the address and\n+\t     edge conditions.  */\n+\t  operands[2] = gen_rtx (REG, Pmode, REGNO (operands[0]) + 1);\n+\t  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n+\t  operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n+\t  return \\\"lda\t%1,%2\\;ld\t%3,%0\\;ld\t%4,%D0\\\";\n+\t}\n+      else\n+\treturn \\\"ldl\t%1,%0\\\";\n+    case 4:\n       return \\\"stl\t%1,%0\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"move,load,load,store\")])\n+  [(set_attr \"type\" \"move,move,load,load,store\")])\n \n (define_expand \"movti\"\n   [(set (match_operand:TI 0 \"general_operand\" \"\")"}]}