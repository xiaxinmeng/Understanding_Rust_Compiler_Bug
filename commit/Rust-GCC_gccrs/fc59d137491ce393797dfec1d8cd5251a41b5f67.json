{"sha": "fc59d137491ce393797dfec1d8cd5251a41b5f67", "node_id": "C_kwDOANBUbNoAKGZjNTlkMTM3NDkxY2UzOTM3OTdkZmVjMWQ4Y2Q1MjUxYTQxYjVmNjc", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-11-03T14:02:37Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-11-30T08:47:11Z"}, "message": "builtins: Cleanup initialization of builtins\n\nThis commit performs builtin initialization in a more \"GCC-y\" way, similarly to what the D frontend is doing. This way, we no longer have to worry about invalid attributes or types when initializing them by hand.", "tree": {"sha": "9a35ea6e0ddfde2c200577e605412ac8b66ee1c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a35ea6e0ddfde2c200577e605412ac8b66ee1c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc59d137491ce393797dfec1d8cd5251a41b5f67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc59d137491ce393797dfec1d8cd5251a41b5f67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc59d137491ce393797dfec1d8cd5251a41b5f67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc59d137491ce393797dfec1d8cd5251a41b5f67/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71b8beb150d96548a2ebfb8ef964d14225e300f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71b8beb150d96548a2ebfb8ef964d14225e300f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71b8beb150d96548a2ebfb8ef964d14225e300f0"}], "stats": {"total": 527, "additions": 389, "deletions": 138}, "files": [{"sha": "ee3e42e6b5348aab1c3d1c03091f579e4dd4f6f5", "filename": "gcc/rust/backend/rust-builtins.cc", "status": "modified", "additions": 238, "deletions": 112, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Frust%2Fbackend%2Frust-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Frust%2Fbackend%2Frust-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.cc?ref=fc59d137491ce393797dfec1d8cd5251a41b5f67", "patch": "@@ -14,8 +14,13 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+#include \"rust-diagnostics.h\"\n+#include \"rust-system.h\"\n #include \"rust-builtins.h\"\n \n+#include \"target.h\"\n+#include \"stringpool.h\"\n+\n namespace Rust {\n namespace Compile {\n \n@@ -33,154 +38,275 @@ BuiltinsContext::get ()\n bool\n BuiltinsContext::lookup_simple_builtin (const std::string &name, tree *builtin)\n {\n+  auto *to_search = &name;\n+\n   auto it = rust_intrinsic_to_gcc_builtin.find (name);\n-  if (it == rust_intrinsic_to_gcc_builtin.end ())\n-    return false;\n+  if (it != rust_intrinsic_to_gcc_builtin.end ())\n+    to_search = &it->second;\n \n-  return lookup_gcc_builtin (it->second, builtin);\n+  return lookup_gcc_builtin (*to_search, builtin);\n }\n \n BuiltinsContext::BuiltinsContext () { setup (); }\n \n+/**\n+ * Define a function type according to `builtin-types.def`\n+ *\n+ * *Heavily* inspired by the D frontend's `def_fn_type` function\n+ */\n void\n-BuiltinsContext::setup_overflow_fns ()\n+BuiltinsContext::define_function_type (Type def_idx, Type ret_idx,\n+\t\t\t\t       bool is_variadic, size_t n, ...)\n {\n-  tree overflow_type\n-    = build_varargs_function_type_list (boolean_type_node, NULL_TREE);\n-\n-  define_builtin (\"add_overflow\", BUILT_IN_ADD_OVERFLOW,\n-\t\t  \"__builtin_add_overflow\", \"add_overflow\", overflow_type, 0);\n-  define_builtin (\"sub_overflow\", BUILT_IN_SUB_OVERFLOW,\n-\t\t  \"__builtin_sub_overflow\", \"sub_overflow\", overflow_type, 0);\n-  define_builtin (\"mul_overflow\", BUILT_IN_MUL_OVERFLOW,\n-\t\t  \"__builtin_mul_overflow\", \"mul_overflow\", overflow_type, 0);\n+  va_list list;\n+  va_start (list, n);\n+\n+  auto args = std::vector<tree> ();\n+\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      auto arg_idx = va_arg (list, size_t);\n+      auto arg_type = builtin_types[arg_idx];\n+\n+      args.emplace_back (arg_type);\n+    }\n+\n+  auto return_type = builtin_types[ret_idx];\n+  if (return_type == error_mark_node)\n+    {\n+      va_end (list);\n+      return;\n+    }\n+\n+  auto fn_type = NULL_TREE;\n+  if (is_variadic)\n+    fn_type = build_varargs_function_type_array (return_type, n, args.data ());\n+  else\n+    fn_type = build_function_type_array (return_type, n, args.data ());\n+\n+  builtin_types[def_idx] = fn_type;\n+  va_end (list);\n }\n \n-void\n-BuiltinsContext::setup_math_fns ()\n+// Taken directly from the D frontend\n+static void\n+build_c_type_nodes (void)\n {\n-  tree math_function_type_f32\n-    = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n+  string_type_node = build_pointer_type (char_type_node);\n+  const_string_type_node = build_pointer_type (\n+    build_qualified_type (char_type_node, TYPE_QUAL_CONST));\n+\n+  if (strcmp (UINTMAX_TYPE, \"unsigned int\") == 0)\n+    {\n+      intmax_type_node = integer_type_node;\n+      uintmax_type_node = unsigned_type_node;\n+    }\n+  else if (strcmp (UINTMAX_TYPE, \"long unsigned int\") == 0)\n+    {\n+      intmax_type_node = long_integer_type_node;\n+      uintmax_type_node = long_unsigned_type_node;\n+    }\n+  else if (strcmp (UINTMAX_TYPE, \"long long unsigned int\") == 0)\n+    {\n+      intmax_type_node = long_long_integer_type_node;\n+      uintmax_type_node = long_long_unsigned_type_node;\n+    }\n+  else\n+    gcc_unreachable ();\n \n-  define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n-\t\t  math_function_type_f32, builtin_const);\n-  define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n-\t\t  math_function_type_f32, builtin_const);\n+  signed_size_type_node = signed_type_for (size_type_node);\n+  wint_type_node = unsigned_type_node;\n+  pid_type_node = integer_type_node;\n }\n \n+/**\n+ * Define all builtin types in the `builtin_types` array\n+ */\n void\n-BuiltinsContext::setup_atomic_fns ()\n+BuiltinsContext::define_builtin_types ()\n {\n-  auto atomic_store_type\n-    = build_varargs_function_type_list (void_type_node, NULL_TREE);\n-  auto atomic_load_type = [] (tree ret_type_node) {\n-    return build_function_type_list (ret_type_node,\n-\t\t\t\t     ptr_type_node, // const_ptr_type_node?\n-\t\t\t\t     integer_type_node, NULL_TREE);\n+  // This is taken directly from the D frontend's handling of builtins\n+  auto va_list_ref_type_node = build_reference_type (va_list_type_node);\n+  auto va_list_arg_type_node = va_list_type_node;\n+\n+  build_c_type_nodes ();\n+\n+  auto builtin_type_for_size = [] (int size, bool unsignedp) {\n+    tree type = lang_hooks.types.type_for_size (size, unsignedp);\n+    return type ? type : error_mark_node;\n   };\n \n-  // FIXME: These should be the definition for the generic version of the\n-  // atomic_store builtins, but I cannot get them to work properly. Revisit\n-  // later. define_builtin (\"atomic_store\", BUILT_IN_ATOMIC_STORE,\n-  // \"__atomic_store\", NULL,\n-  //   atomic_store_type, 0);\n-  // define_builtin (\"atomic_store_n\", BUILT_IN_ATOMIC_STORE_N,\n-  // \"__atomic_store_n\",\n-  //   NULL, atomic_store_type, 0);\n-\n-  define_builtin (\"atomic_store_1\", BUILT_IN_ATOMIC_STORE_1, \"__atomic_store_1\",\n-\t\t  NULL, atomic_store_type, 0);\n-  define_builtin (\"atomic_store_2\", BUILT_IN_ATOMIC_STORE_2, \"__atomic_store_2\",\n-\t\t  NULL, atomic_store_type, 0);\n-  define_builtin (\"atomic_store_4\", BUILT_IN_ATOMIC_STORE_4, \"__atomic_store_4\",\n-\t\t  NULL, atomic_store_type, 0);\n-  define_builtin (\"atomic_store_8\", BUILT_IN_ATOMIC_STORE_8, \"__atomic_store_8\",\n-\t\t  NULL, atomic_store_type, 0);\n-  define_builtin (\"atomic_store_16\", BUILT_IN_ATOMIC_STORE_16,\n-\t\t  \"__atomic_store_16\", NULL, atomic_store_type, 0);\n-\n-  define_builtin (\"atomic_load_1\", BUILT_IN_ATOMIC_LOAD_1, \"__atomic_load_1\",\n-\t\t  NULL, atomic_load_type (integer_type_node), 0);\n-  define_builtin (\"atomic_load_2\", BUILT_IN_ATOMIC_LOAD_2, \"__atomic_load_2\",\n-\t\t  NULL, atomic_load_type (integer_type_node), 0);\n-  define_builtin (\"atomic_load_4\", BUILT_IN_ATOMIC_LOAD_4, \"__atomic_load_4\",\n-\t\t  NULL, atomic_load_type (integer_type_node), 0);\n-  define_builtin (\"atomic_load_8\", BUILT_IN_ATOMIC_LOAD_8, \"__atomic_load_8\",\n-\t\t  NULL, atomic_load_type (integer_type_node), 0);\n+#define DEF_PRIMITIVE_TYPE(ENUM, VALUE) builtin_types[ENUM] = VALUE;\n+#define DEF_FUNCTION_TYPE_0(ENUM, RETURN)                                      \\\n+  define_function_type (ENUM, RETURN, 0, 0);\n+#define DEF_FUNCTION_TYPE_1(ENUM, RETURN, A1)                                  \\\n+  define_function_type (ENUM, RETURN, 0, 1, A1);\n+#define DEF_FUNCTION_TYPE_2(ENUM, RETURN, A1, A2)                              \\\n+  define_function_type (ENUM, RETURN, 0, 2, A1, A2);\n+#define DEF_FUNCTION_TYPE_3(ENUM, RETURN, A1, A2, A3)                          \\\n+  define_function_type (ENUM, RETURN, 0, 3, A1, A2, A3);\n+#define DEF_FUNCTION_TYPE_4(ENUM, RETURN, A1, A2, A3, A4)                      \\\n+  define_function_type (ENUM, RETURN, 0, 4, A1, A2, A3, A4);\n+#define DEF_FUNCTION_TYPE_5(ENUM, RETURN, A1, A2, A3, A4, A5)                  \\\n+  define_function_type (ENUM, RETURN, 0, 5, A1, A2, A3, A4, A5);\n+#define DEF_FUNCTION_TYPE_6(ENUM, RETURN, A1, A2, A3, A4, A5, A6)              \\\n+  define_function_type (ENUM, RETURN, 0, 6, A1, A2, A3, A4, A5, A6);\n+#define DEF_FUNCTION_TYPE_7(ENUM, RETURN, A1, A2, A3, A4, A5, A6, A7)          \\\n+  define_function_type (ENUM, RETURN, 0, 7, A1, A2, A3, A4, A5, A6, A7);\n+#define DEF_FUNCTION_TYPE_8(ENUM, RETURN, A1, A2, A3, A4, A5, A6, A7, A8)      \\\n+  define_function_type (ENUM, RETURN, 0, 8, A1, A2, A3, A4, A5, A6, A7, A8);\n+#define DEF_FUNCTION_TYPE_9(ENUM, RETURN, A1, A2, A3, A4, A5, A6, A7, A8, A9)  \\\n+  define_function_type (ENUM, RETURN, 0, 9, A1, A2, A3, A4, A5, A6, A7, A8, A9);\n+#define DEF_FUNCTION_TYPE_10(ENUM, RETURN, A1, A2, A3, A4, A5, A6, A7, A8, A9, \\\n+\t\t\t     A10)                                              \\\n+  define_function_type (ENUM, RETURN, 0, 10, A1, A2, A3, A4, A5, A6, A7, A8,   \\\n+\t\t\tA9, A10);\n+#define DEF_FUNCTION_TYPE_11(ENUM, RETURN, A1, A2, A3, A4, A5, A6, A7, A8, A9, \\\n+\t\t\t     A10, A11)                                         \\\n+  define_function_type (ENUM, RETURN, 0, 11, A1, A2, A3, A4, A5, A6, A7, A8,   \\\n+\t\t\tA9, A10, A11);\n+#define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN)                                  \\\n+  define_function_type (ENUM, RETURN, 1, 0);\n+#define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, A1)                              \\\n+  define_function_type (ENUM, RETURN, 1, 1, A1);\n+#define DEF_FUNCTION_TYPE_VAR_2(ENUM, RETURN, A1, A2)                          \\\n+  define_function_type (ENUM, RETURN, 1, 2, A1, A2);\n+#define DEF_FUNCTION_TYPE_VAR_3(ENUM, RETURN, A1, A2, A3)                      \\\n+  define_function_type (ENUM, RETURN, 1, 3, A1, A2, A3);\n+#define DEF_FUNCTION_TYPE_VAR_4(ENUM, RETURN, A1, A2, A3, A4)                  \\\n+  define_function_type (ENUM, RETURN, 1, 4, A1, A2, A3, A4);\n+#define DEF_FUNCTION_TYPE_VAR_5(ENUM, RETURN, A1, A2, A3, A4, A5)              \\\n+  define_function_type (ENUM, RETURN, 1, 5, A1, A2, A3, A4, A5);\n+#define DEF_FUNCTION_TYPE_VAR_6(ENUM, RETURN, A1, A2, A3, A4, A5, A6)          \\\n+  define_function_type (ENUM, RETURN, 1, 6, A1, A2, A3, A4, A5, A6);\n+#define DEF_FUNCTION_TYPE_VAR_7(ENUM, RETURN, A1, A2, A3, A4, A5, A6, A7)      \\\n+  define_function_type (ENUM, RETURN, 1, 7, A1, A2, A3, A4, A5, A6, A7);\n+#define DEF_FUNCTION_TYPE_VAR_11(ENUM, RETURN, A1, A2, A3, A4, A5, A6, A7, A8, \\\n+\t\t\t\t A9, A10, A11)                                 \\\n+  define_function_type (ENUM, RETURN, 1, 11, A1, A2, A3, A4, A5, A6, A7, A8,   \\\n+\t\t\tA9, A10, A11);\n+#define DEF_POINTER_TYPE(ENUM, TYPE)                                           \\\n+  builtin_types[ENUM] = build_pointer_type (builtin_types[TYPE]);\n+\n+#include \"builtin-types.def\"\n+\n+#undef DEF_PRIMITIVE_TYPE\n+#undef DEF_FUNCTION_TYPE_1\n+#undef DEF_FUNCTION_TYPE_2\n+#undef DEF_FUNCTION_TYPE_3\n+#undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n+#undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n+#undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_1\n+#undef DEF_FUNCTION_TYPE_VAR_2\n+#undef DEF_FUNCTION_TYPE_VAR_3\n+#undef DEF_FUNCTION_TYPE_VAR_4\n+#undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_FUNCTION_TYPE_VAR_6\n+#undef DEF_FUNCTION_TYPE_VAR_7\n+#undef DEF_FUNCTION_TYPE_VAR_11\n+#undef DEF_POINTER_TYPE\n+\n+  builtin_types[Type::BT_LAST] = NULL_TREE;\n }\n \n+/**\n+ * Define all builtin attributes in the `builtin_types` array\n+ */\n void\n-BuiltinsContext::setup ()\n+BuiltinsContext::define_builtin_attributes ()\n+\n {\n-  setup_math_fns ();\n-  setup_overflow_fns ();\n-  setup_atomic_fns ();\n-\n-  define_builtin (\"unreachable\", BUILT_IN_UNREACHABLE, \"__builtin_unreachable\",\n-\t\t  NULL, build_function_type (void_type_node, void_list_node),\n-\t\t  builtin_const | builtin_noreturn);\n-\n-  define_builtin (\"abort\", BUILT_IN_ABORT, \"__builtin_abort\", \"abort\",\n-\t\t  build_function_type (void_type_node, void_list_node),\n-\t\t  builtin_const | builtin_noreturn);\n-\n-  define_builtin (\"breakpoint\", BUILT_IN_TRAP, \"__builtin_trap\", \"breakpoint\",\n-\t\t  build_function_type (void_type_node, void_list_node),\n-\t\t  builtin_const | builtin_noreturn);\n-\n-  define_builtin (\"memcpy\", BUILT_IN_MEMCPY, \"__builtin_memcpy\", \"memcpy\",\n-\t\t  build_function_type_list (build_pointer_type (void_type_node),\n-\t\t\t\t\t    build_pointer_type (void_type_node),\n-\t\t\t\t\t    build_pointer_type (void_type_node),\n-\t\t\t\t\t    size_type_node, NULL_TREE),\n-\t\t  0);\n-\n-  define_builtin (\"prefetch\", BUILT_IN_PREFETCH, \"__builtin_prefetch\",\n-\t\t  \"prefetch\",\n-\t\t  build_varargs_function_type_list (\n-\t\t    build_pointer_type (const_ptr_type_node), NULL_TREE),\n-\t\t  builtin_const);\n+  auto *built_in_attributes = builtin_attributes;\n+\n+#define DEF_ATTR_NULL_TREE(ENUM) built_in_attributes[(int) ENUM] = NULL_TREE;\n+#define DEF_ATTR_INT(ENUM, VALUE)                                              \\\n+  built_in_attributes[ENUM] = build_int_cst (NULL_TREE, VALUE);\n+#define DEF_ATTR_STRING(ENUM, VALUE)                                           \\\n+  built_in_attributes[ENUM] = build_string (strlen (VALUE), VALUE);\n+#define DEF_ATTR_IDENT(ENUM, STRING)                                           \\\n+  built_in_attributes[ENUM] = get_identifier (STRING);\n+#define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN)                        \\\n+  built_in_attributes[ENUM]                                                    \\\n+    = tree_cons (built_in_attributes[PURPOSE], built_in_attributes[VALUE],     \\\n+\t\t built_in_attributes[CHAIN]);\n+#include \"builtin-attrs.def\"\n+#undef DEF_ATTR_NULL_TREE\n+#undef DEF_ATTR_INT\n+#undef DEF_ATTR_STRING\n+#undef DEF_ATTR_IDENT\n+#undef DEF_ATTR_TREE_LIST\n }\n \n-static void\n-handle_flags (tree decl, int flags)\n+/**\n+ * Define all builtin functions during the first initialization of the\n+ * `BuiltinsContext`.\n+ */\n+void\n+BuiltinsContext::define_builtins ()\n {\n-  if (flags & builtin_const)\n-    TREE_READONLY (decl) = 1;\n-  if (flags & builtin_noreturn)\n-    TREE_READONLY (decl) = 1;\n-  if (flags & builtin_novops)\n-    DECL_IS_NOVOPS (decl) = 1;\n+  auto *built_in_attributes = builtin_attributes;\n+  auto build_builtin = [this] (built_in_function fn_code, const char *fn_name,\n+\t\t\t       built_in_class fn_class, tree fn_type, bool both,\n+\t\t\t       bool fallback, tree attributes, bool implicit) {\n+    if (fn_type == error_mark_node)\n+      return;\n+\n+    static auto to_skip = strlen (\"__builtin_\");\n+\n+    auto libname = fn_name + to_skip;\n+    auto decl = add_builtin_function (fn_name, fn_type, fn_code, fn_class,\n+\t\t\t\t      fallback ? libname : NULL, attributes);\n+\n+    set_builtin_decl (fn_code, decl, implicit);\n+\n+    builtin_functions.insert ({std::string (fn_name), decl});\n+  };\n+\n+#define DEF_BUILTIN(ENUM, NAME, CLASS, TYPE, LIBTYPE, BOTH_P, FALLBACK_P,      \\\n+\t\t    NONANSI_P, ATTRS, IMPLICIT, COND)                          \\\n+  if (NAME && COND)                                                            \\\n+    build_builtin (ENUM, NAME, CLASS, builtin_types[TYPE], BOTH_P, FALLBACK_P, \\\n+\t\t   built_in_attributes[ATTRS], IMPLICIT);\n+#include \"builtins.def\"\n+#undef DEF_BUILTIN\n }\n \n+/**\n+ * Register direct mappings between Rust functions and GCC builtins\n+ */\n void\n-BuiltinsContext::define_builtin (const std::string rust_name,\n-\t\t\t\t built_in_function bcode, const char *name,\n-\t\t\t\t const char *libname, tree fntype, int flags)\n+BuiltinsContext::register_rust_mappings ()\n {\n-  tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t    libname, NULL_TREE);\n-  handle_flags (decl, flags);\n-  set_builtin_decl (bcode, decl, true);\n-\n-  this->builtin_functions_[name] = decl;\n-  if (libname != NULL)\n-    {\n-      decl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t   NULL, NULL_TREE);\n-      handle_flags (decl, flags);\n+  rust_intrinsic_to_gcc_builtin = {\n+    {\"sinf32\", \"__builtin_sinf\"},\n+    {\"sqrtf32\", \"__builtin_sqrtf\"},\n+    {\"unreachable\", \"__builtin_unreachable\"},\n+    {\"abort\", \"__builtin_abort\"},\n+  };\n+}\n \n-      this->builtin_functions_[libname] = decl;\n-    }\n+void\n+BuiltinsContext::setup ()\n+{\n+  define_builtin_types ();\n+  define_builtin_attributes ();\n+  define_builtins ();\n \n-  rust_intrinsic_to_gcc_builtin[rust_name] = name;\n+  register_rust_mappings ();\n }\n \n bool\n BuiltinsContext::lookup_gcc_builtin (const std::string &name, tree *builtin)\n {\n-  auto it = builtin_functions_.find (name);\n-  if (it == builtin_functions_.end ())\n+  auto it = builtin_functions.find (name);\n+  if (it == builtin_functions.end ())\n     return false;\n \n   *builtin = it->second;"}, {"sha": "5052edad51e90b27f2e6443f82ce1c894a64d381", "filename": "gcc/rust/backend/rust-builtins.h", "status": "modified", "additions": 107, "deletions": 11, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Frust%2Fbackend%2Frust-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Frust%2Fbackend%2Frust-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.h?ref=fc59d137491ce393797dfec1d8cd5251a41b5f67", "patch": "@@ -21,6 +21,7 @@\n #include \"rust-tree.h\"\n #include \"langhooks.h\"\n #include \"tree.h\"\n+#include \"selftest.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -75,6 +76,7 @@ namespace Compile {\n //     _ => return None,\n // };\n // Some(cx.get_intrinsic(&llvm_name))\n+\n class BuiltinsContext\n {\n public:\n@@ -83,6 +85,110 @@ class BuiltinsContext\n   bool lookup_simple_builtin (const std::string &name, tree *builtin);\n \n private:\n+  enum Type\n+  {\n+#define DEF_PRIMITIVE_TYPE(NAME, V) NAME,\n+#define DEF_FUNCTION_TYPE_0(NAME, R) NAME,\n+#define DEF_FUNCTION_TYPE_1(NAME, R, A1) NAME,\n+#define DEF_FUNCTION_TYPE_2(NAME, R, A1, A2) NAME,\n+#define DEF_FUNCTION_TYPE_3(NAME, R, A1, A2, A3) NAME,\n+#define DEF_FUNCTION_TYPE_4(NAME, R, A1, A2, A3, A4) NAME,\n+#define DEF_FUNCTION_TYPE_5(NAME, R, A1, A2, A3, A4, A5) NAME,\n+#define DEF_FUNCTION_TYPE_6(NAME, R, A1, A2, A3, A4, A5, A6) NAME,\n+#define DEF_FUNCTION_TYPE_7(NAME, R, A1, A2, A3, A4, A5, A6, A7) NAME,\n+#define DEF_FUNCTION_TYPE_8(NAME, R, A1, A2, A3, A4, A5, A6, A7, A8) NAME,\n+#define DEF_FUNCTION_TYPE_9(NAME, R, A1, A2, A3, A4, A5, A6, A7, A8, A9) NAME,\n+#define DEF_FUNCTION_TYPE_10(NAME, R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) \\\n+  NAME,\n+#define DEF_FUNCTION_TYPE_11(NAME, R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, \\\n+\t\t\t     A11)                                              \\\n+  NAME,\n+#define DEF_FUNCTION_TYPE_VAR_0(NAME, R) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_1(NAME, R, A1) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_2(NAME, R, A1, A2) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_3(NAME, R, A1, A2, A3) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_4(NAME, R, A1, A2, A3, A4) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_5(NAME, R, A1, A2, A3, A4, A5) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_6(NAME, R, A1, A2, A3, A4, A5, A6) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_7(NAME, R, A1, A2, A3, A4, A5, A6, A7) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_11(NAME, R, A1, A2, A3, A4, A5, A6, A7, A8, A9,  \\\n+\t\t\t\t A10, A11)                                     \\\n+  NAME,\n+#define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n+\n+#include \"builtin-types.def\"\n+\n+#undef DEF_PRIMITIVE_TYPE\n+#undef DEF_FUNCTION_TYPE_0\n+#undef DEF_FUNCTION_TYPE_1\n+#undef DEF_FUNCTION_TYPE_2\n+#undef DEF_FUNCTION_TYPE_3\n+#undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n+#undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n+#undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_1\n+#undef DEF_FUNCTION_TYPE_VAR_2\n+#undef DEF_FUNCTION_TYPE_VAR_3\n+#undef DEF_FUNCTION_TYPE_VAR_4\n+#undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_FUNCTION_TYPE_VAR_6\n+#undef DEF_FUNCTION_TYPE_VAR_7\n+#undef DEF_FUNCTION_TYPE_VAR_11\n+#undef DEF_POINTER_TYPE\n+\n+    BT_LAST,\n+  };\n+\n+  enum Attr\n+  {\n+#define DEF_ATTR_NULL_TREE(ENUM) ENUM,\n+#define DEF_ATTR_INT(ENUM, VALUE) ENUM,\n+#define DEF_ATTR_STRING(ENUM, VALUE) ENUM,\n+#define DEF_ATTR_IDENT(ENUM, STRING) ENUM,\n+#define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN) ENUM,\n+\n+#include \"builtin-attrs.def\"\n+\n+#undef DEF_ATTR_NULL_TREE\n+#undef DEF_ATTR_INT\n+#undef DEF_ATTR_STRING\n+#undef DEF_ATTR_IDENT\n+#undef DEF_ATTR_TREE_LIST\n+\n+    ATTR_LAST,\n+  };\n+\n+  /**\n+   * All builtin types, as defined in `builtin-types.def`\n+   *\n+   * This array is filled by the `define_builtin_types` method, during the first\n+   * initialization of the `BuiltinsContext`\n+   */\n+  tree builtin_types[Type::BT_LAST + 1];\n+\n+  /**\n+   * Similarly, this array contains all builtin attributes, as defined in\n+   * `builtin-attr.def`\n+   *\n+   * This array is filled by the `define_builtin_attributes` method, during the\n+   * first initialization of the `BuiltinsContext`\n+   */\n+  tree builtin_attributes[Attr::ATTR_LAST + 1];\n+\n+  void define_function_type (Type def, Type ret, bool is_variadic, size_t n,\n+\t\t\t     ...);\n+  void define_builtin_types ();\n+  void define_builtin_attributes ();\n+  void define_builtins ();\n+\n+  void register_rust_mappings ();\n+\n   BuiltinsContext ();\n \n   void setup_overflow_fns ();\n@@ -91,20 +197,10 @@ class BuiltinsContext\n \n   void setup ();\n \n-  // Define a builtin function.  BCODE is the builtin function code\n-  // defined by builtins.def.  NAME is the name of the builtin function.\n-  // LIBNAME is the name of the corresponding library function, and is\n-  // NULL if there isn't one.  FNTYPE is the type of the function.\n-  // CONST_P is true if the function has the const attribute.\n-  // NORETURN_P is true if the function has the noreturn attribute.\n-  void define_builtin (const std::string rust_name, built_in_function bcode,\n-\t\t       const char *name, const char *libname, tree fntype,\n-\t\t       int flags);\n-\n   bool lookup_gcc_builtin (const std::string &name, tree *builtin);\n \n   // A mapping of the GCC built-ins exposed to GCC Rust.\n-  std::map<std::string, tree> builtin_functions_;\n+  std::map<std::string, tree> builtin_functions;\n   std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n };\n "}, {"sha": "78eee530569cd08d4703f632a8defd465b07f9e9", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=fc59d137491ce393797dfec1d8cd5251a41b5f67", "patch": "@@ -28,6 +28,8 @@\n #include \"print-tree.h\"\n #include \"fold-const.h\"\n #include \"langhooks.h\"\n+#include \"rust-gcc.h\"\n+#include \"rust-constexpr.h\"\n \n #include \"print-tree.h\"\n \n@@ -199,6 +201,7 @@ Intrinsics::compile (TyTy::FnType *fntype)\n \n   tree builtin = error_mark_node;\n   BuiltinsContext &builtin_ctx = BuiltinsContext::get ();\n+\n   if (builtin_ctx.lookup_simple_builtin (fntype->get_identifier (), &builtin))\n     return builtin;\n \n@@ -604,7 +607,8 @@ copy_nonoverlapping_handler (Context *ctx, TyTy::FnType *fntype)\n     = build2 (MULT_EXPR, size_type_node, TYPE_SIZE_UNIT (param_type), count);\n \n   tree memcpy_raw = nullptr;\n-  BuiltinsContext::get ().lookup_simple_builtin (\"memcpy\", &memcpy_raw);\n+  BuiltinsContext::get ().lookup_simple_builtin (\"__builtin_memcpy\",\n+\t\t\t\t\t\t &memcpy_raw);\n   rust_assert (memcpy_raw);\n   auto memcpy\n     = build_fold_addr_expr_loc (Location ().gcc_location (), memcpy_raw);\n@@ -656,18 +660,35 @@ prefetch_data_handler (Context *ctx, TyTy::FnType *fntype, Prefetch kind)\n   enter_intrinsic_block (ctx, fndecl);\n \n   auto addr = ctx->get_backend ()->var_expression (args[0], Location ());\n-  auto locality = ctx->get_backend ()->var_expression (args[1], Location ());\n+\n+  // The core library technically allows you to pass any i32 value as a\n+  // locality, but LLVM will then complain if the value cannot be constant\n+  // evaluated. For now, we ignore the locality argument and instead always\n+  // pass `3` (the most restrictive value). This allows us to still have\n+  // prefetch behavior, just not as granular as expected. In future Rust\n+  // versions, we hope that prefetch intrinsics will be split up according to\n+  // locality, similarly to atomic intrinsics.\n+  // The solution is to try and perform constant folding for the locality\n+  // argument, or instead of creating a new function definition, modify the call\n+  // site directly This has the bad side-effect of creating warnings about\n+  // `unused name - locality`, which we hack away here:\n+  // TODO: Take care of handling locality properly\n+  ctx->get_backend ()->var_expression (args[1], Location ());\n+\n   auto rw_flag = make_unsigned_long_tree (ctx, kind == Prefetch::Write ? 1 : 0);\n \n   auto prefetch_raw = NULL_TREE;\n-  auto ok\n-    = BuiltinsContext::get ().lookup_simple_builtin (\"prefetch\", &prefetch_raw);\n+  auto ok = BuiltinsContext::get ().lookup_simple_builtin (\"__builtin_prefetch\",\n+\t\t\t\t\t\t\t   &prefetch_raw);\n   rust_assert (ok);\n   auto prefetch\n     = build_fold_addr_expr_loc (Location ().gcc_location (), prefetch_raw);\n \n   auto prefetch_call\n-    = ctx->get_backend ()->call_expression (prefetch, {addr, rw_flag, locality},\n+    = ctx->get_backend ()->call_expression (prefetch,\n+\t\t\t\t\t    {addr, rw_flag,\n+\t\t\t\t\t     // locality arg\n+\t\t\t\t\t     make_unsigned_long_tree (ctx, 3)},\n \t\t\t\t\t    nullptr, Location ());\n \n   TREE_READONLY (prefetch_call) = 0;\n@@ -693,7 +714,7 @@ build_atomic_builtin_name (const std::string &prefix, Location locus,\n   // TODO: Can we maybe get the generic version (atomic_store_n) to work... This\n   // would be so much better\n \n-  std::string result = prefix;\n+  std::string result = \"__\" + prefix; //  + \"n\";\n \n   auto type_name = operand_type->get_name ();\n   if (type_name == \"usize\" || type_name == \"isize\")\n@@ -703,6 +724,13 @@ build_atomic_builtin_name (const std::string &prefix, Location locus,\n       return \"\";\n     }\n \n+  if (type_name.at (0) == 'i')\n+    {\n+      rust_sorry_at (locus, \"atomics are not yet supported for signed \"\n+\t\t\t    \"integer types (i8, i16, i32, i64, i128)\");\n+      return \"\";\n+    }\n+\n   auto type_size_str = allowed_types.find (type_name);\n \n   if (!check_for_basic_integer_type (\"atomic\", locus, operand_type))\n@@ -832,6 +860,7 @@ atomic_load_handler_inner (Context *ctx, TyTy::FnType *fntype, int ordering)\n   TREE_SIDE_EFFECTS (load_call) = 1;\n \n   ctx->add_statement (return_statement);\n+\n   finalize_intrinsic_block (ctx, fndecl);\n \n   return fndecl;"}, {"sha": "c7253590b5982aa3fa68f39af53cd47594845c65", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=fc59d137491ce393797dfec1d8cd5251a41b5f67", "patch": "@@ -1456,20 +1456,20 @@ fetch_overflow_builtins (ArithmeticOrLogicalOperator op)\n   switch (op)\n     {\n     case ArithmeticOrLogicalOperator::ADD:\n-      builtin_ctx.lookup_simple_builtin (\"add_overflow\", &builtin);\n+      builtin_ctx.lookup_simple_builtin (\"__builtin_add_overflow\", &builtin);\n       break;\n     case ArithmeticOrLogicalOperator::SUBTRACT:\n-      builtin_ctx.lookup_simple_builtin (\"sub_overflow\", &builtin);\n+      builtin_ctx.lookup_simple_builtin (\"__builtin_sub_overflow\", &builtin);\n       break;\n     case ArithmeticOrLogicalOperator::MULTIPLY:\n-      builtin_ctx.lookup_simple_builtin (\"mul_overflow\", &builtin);\n+      builtin_ctx.lookup_simple_builtin (\"__builtin_mul_overflow\", &builtin);\n       break;\n     default:\n       gcc_unreachable ();\n       break;\n     };\n \n-  builtin_ctx.lookup_simple_builtin (\"abort\", &abort);\n+  builtin_ctx.lookup_simple_builtin (\"__builtin_abort\", &abort);\n \n   rust_assert (abort);\n   rust_assert (builtin);"}, {"sha": "a42c51714638b8506b31f7e6882c7c1daa8fea22", "filename": "gcc/testsuite/rust/compile/torture/intrinsics-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs?ref=fc59d137491ce393797dfec1d8cd5251a41b5f67", "patch": "@@ -8,7 +8,7 @@ extern \"rust-intrinsic\" {\n }\n \n fn main() {\n-    let mut dst = 15;\n+    let mut dst = 15u32;\n     let new_value = 14;\n \n     unsafe {"}, {"sha": "612548be90c6b2560783ebf216cc0183b33e7351", "filename": "gcc/testsuite/rust/execute/torture/atomic_load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_load.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_load.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_load.rs?ref=fc59d137491ce393797dfec1d8cd5251a41b5f67", "patch": "@@ -7,14 +7,14 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n }\n \n-fn main() -> i32 {\n+fn main() -> u32 {\n     let one;\n     let two;\n     let three;\n     let four;\n \n     unsafe {\n-        let mut src = 1;\n+        let mut src = 1u32;\n         one = atomic_load_seqcst(&src);\n \n         src = 2;"}, {"sha": "88f8a53a317b783c330fe35b679a780df805686e", "filename": "gcc/testsuite/rust/execute/torture/atomic_store.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc59d137491ce393797dfec1d8cd5251a41b5f67/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs?ref=fc59d137491ce393797dfec1d8cd5251a41b5f67", "patch": "@@ -7,8 +7,8 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n }\n \n-fn main() -> i32 {\n-    let mut dst = 15;\n+fn main() -> u32 {\n+    let mut dst = 15u32;\n     let one;\n     let two;\n     let three;"}]}