{"sha": "9f82c8a919ca1be57db10fd02dbf510474d219e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY4MmM4YTkxOWNhMWJlNTdkYjEwZmQwMmRiZjUxMDQ3NGQyMTllOA==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-08-03T14:07:38Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:20Z"}, "message": "Improved and tidied up ARM target hook", "tree": {"sha": "ad20acbe2b033914b2756146e147b5cd1508efc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad20acbe2b033914b2756146e147b5cd1508efc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f82c8a919ca1be57db10fd02dbf510474d219e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f82c8a919ca1be57db10fd02dbf510474d219e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f82c8a919ca1be57db10fd02dbf510474d219e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f82c8a919ca1be57db10fd02dbf510474d219e8/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "610c1678de5d0fe091679dd35152bb171daff7e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610c1678de5d0fe091679dd35152bb171daff7e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610c1678de5d0fe091679dd35152bb171daff7e7"}], "stats": {"total": 344, "additions": 153, "deletions": 191}, "files": [{"sha": "a71db689f83960e9b16574d111613a673b8d4556", "filename": "gcc/config/arm/arm-rust.c", "status": "modified", "additions": 153, "deletions": 191, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f82c8a919ca1be57db10fd02dbf510474d219e8/gcc%2Fconfig%2Farm%2Farm-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f82c8a919ca1be57db10fd02dbf510474d219e8/gcc%2Fconfig%2Farm%2Farm-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-rust.c?ref=9f82c8a919ca1be57db10fd02dbf510474d219e8", "patch": "@@ -28,114 +28,143 @@ along with GCC; see the file COPYING3.  If not see\n void arm_rust_target_cpu_info(void) {\n     rust_add_target_info(\"target_arch\", \"arm\");\n \n-    /* TODO: further research support for CLREX, acquire-release (lda/ldaex), slow-fp-brcc (slow FP\n-     * compare and branch), perfmon, trustzone, fpao, fuse-aes, fuse-literals, read-tp-hard, zcz,\n-     * prof-unpr, slow-vgetlni32, slow-vdup32, prefer-vmovsr, prefer-ishst, muxed-units, slow-odd-reg,\n-     * slow-load-D-subreg, wide-stride-vfp, dont-widen-vmovs, splat-vfp-neon, expand-fp-mlx,\n-     * vmlx-hazards, neon-fpmovs, neonfp (as in using neon for scalar fp), vldn-align,\n-     * nonpipelined-vfp, slowfpvmlx, slowfpvfmx, vmlx-forwarding, 32bit (prefer 32-bit Thumb),\n-     * loop-align, mve1beat, mve2beat, mve4beat, avoid-partial-cpsr, cheap-predictable-cpsr,\n-     * avoid-movs-shop, ret-addr-stack, no-branch-predictor, virtualization, nacl-trap, execute-only,\n-     * reserve-r9, no-movt, no-neg-immediates, use-misched, disable-postra-scheduler, lob (Low\n-     * Overhead Branch), noarm, cde - can't find them. */\n-    /* TODO: figure out if gcc has an equivalent to \"fpregs\" (floating-point registers even if only\n-     * used for integer - shared between VFP and MVE).  */\n-    if (TARGET_VFPD32)\n-        rust_add_target_info(\"target_feature\", \"d32\");\n-    bool hasFeatureVFP2 = bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv2) && TARGET_VFP_DOUBLE;\n-    if (hasFeatureVFP2) {\n-        rust_add_target_info(\"target_feature\", \"vfp2\");\n-\n-        // also added implied features that aren't separately supported in gcc\n-        rust_add_target_info(\"target_feature\", \"vfp2sp\");\n+    // features stabilised in rustc:\n+    switch (TARGET_ARM_ARCH_PROFILE) {\n+        case 'A':\n+            rust_add_target_info(\"target_feature\", \"aclass\");\n+            break;\n+        case 'R':\n+            rust_add_target_info(\"target_feature\", \"rclass\");\n+            break;\n+        case 'M':\n+            rust_add_target_info(\"target_feature\", \"mclass\");\n+            break;\n+        default:\n+            fprintf(stderr, \"Screwed up profile selection in arm-rust.c - unknown profile '%c'\",\n+              TARGET_ARM_ARCH_PROFILE);\n+            break;\n     }\n-    // minimal VFPv3 support - support for instruction set, not necessarily full\n-    bool minVFP3 = TARGET_VFP3 && bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv2);\n-    if (minVFP3) {\n-        rust_add_target_info(\"target_feature\", \"vfp3d16sp\");\n-\n+    if (TARGET_DSP_MULTIPLY)\n+        rust_add_target_info(\"target_feature\", \"dsp\");\n+    if (TARGET_NEON)\n+        rust_add_target_info(\"target_feature\", \"neon\");\n+    if (TARGET_CRC32)\n+        rust_add_target_info(\"target_feature\", \"crc\");\n+    /* TODO: note that sha2 is an option for aarch64 in gcc but not for arm, so no feature here\n+     * possible. The same goes for aes. However, as llvm has them as prerequisites for crypto, they\n+     * are enabled with it. */\n+    if (TARGET_CRYPTO) {\n+        rust_add_target_info(\"target_feature\", \"crypto\");\n+        rust_add_target_info(\"target_feature\", \"sha2\");\n+        rust_add_target_info(\"target_feature\", \"aes\");\n+    }\n+    if (arm_arch5te)\n+        rust_add_target_info(\"target_feature\", \"v5te\");\n+    if (arm_arch6)\n+        rust_add_target_info(\"target_feature\", \"v6\");\n+    if (arm_arch6k)\n+        rust_add_target_info(\"target_feature\", \"v6k\");\n+    // as gcc does not appear to consider \"v6t2\" a proper arch, it is defined when prequisites are met\n+    bool hasV6T2 = arm_arch6k && arm_arch_thumb2; // TODO: also \"v8m baseline\" stuff too\n+    if (hasV6T2)\n+        rust_add_target_info(\"target_feature\", \"v6t2\");\n+    if (arm_arch7)\n+        rust_add_target_info(\"target_feature\", \"v7\");\n+    if (arm_arch8)\n+        rust_add_target_info(\"target_feature\", \"v8\");\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv2) && TARGET_VFP_DOUBLE)\n+        rust_add_target_info(\"target_feature\", \"vfp2\");\n+    if (TARGET_VFP3 && TARGET_VFP_DOUBLE && TARGET_VFPD32)\n+        rust_add_target_info(\"target_feature\", \"vfp3\");\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv4)\n+        && bitmap_bit_p(arm_active_target.isa, isa_bit_fp16conv) && TARGET_VFP_DOUBLE\n+        && TARGET_VFPD32)\n+        rust_add_target_info(\"target_feature\", \"vfp4\");\n+\n+    // llvm features:\n+    // should be correct option (i.e. thumb mode rather than just thumb-aware) as TARGET_ARM is\n+    // inverse\n+    if (TARGET_THUMB)\n+        rust_add_target_info(\"target_feature\", \"thumb-mode\");\n+    if (TARGET_SOFT_FLOAT) {\n+        rust_add_target_info(\"target_feature\", \"soft-float\");\n+    } else {\n+        // only have fp features if hard float\n+        if (bitmap_bit_p(arm_active_target.isa, isa_bit_vfp_base))\n+            rust_add_target_info(\"target_feature\", \"fpregs\");\n+        if (TARGET_VFP_DOUBLE) {\n+            rust_add_target_info(\"target_feature\", \"fp64\");\n+            rust_add_target_info(\"target_feature\", \"fpregs64\");\n+        }\n         if (TARGET_VFPD32)\n-            rust_add_target_info(\"target_feature\", \"vfp3sp\");\n+            rust_add_target_info(\"target_feature\", \"d32\");\n+        if (bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv2)) {\n+            rust_add_target_info(\"target_feature\", \"vfp2sp\");\n \n-        if (TARGET_VFP_DOUBLE) {\n-            rust_add_target_info(\"target_feature\", \"vfp3d16\");\n+            if (TARGET_VFP_DOUBLE)\n+                rust_add_target_info(\"target_feature\", \"vfp2\");\n+        }\n+        if (TARGET_VFP3) {\n+            rust_add_target_info(\"target_feature\", \"vfp3d16sp\");\n+\n+            if (TARGET_VFPD32)\n+                rust_add_target_info(\"target_feature\", \"vfp3sp\");\n \n-            if (TARGET_VFPD32) {\n-                rust_add_target_info(\"target_feature\", \"vfp3\");\n+            if (TARGET_VFP_DOUBLE) {\n+                rust_add_target_info(\"target_feature\", \"vfp3d16\");\n \n-                if (bitmap_bit_p(arm_active_target.isa, isa_bit_neon))\n-                    rust_add_target_info(\"target_feature\", \"neon\");\n+                if (TARGET_VFPD32)\n+                    rust_add_target_info(\"target_feature\", \"vfp3\");\n             }\n         }\n-    }\n-    bool hasFeatureVFP3 = minVFP3 && TARGET_VFP_DOUBLE && TARGET_VFPD32;\n-    bool hasFeatureFP16 = bitmap_bit_p(arm_active_target.isa, isa_bit_fp16conv);\n-    if (hasFeatureFP16)\n-        rust_add_target_info(\"target_info\", \"fp16\");\n-    bool minVFP4 = minVFP3 && bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv4) && hasFeatureFP16;\n-    if (minVFP4) {\n-        rust_add_target_info(\"target_feature\", \"vfp4d16sp\");\n+        if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16conv))\n+            rust_add_target_info(\"target_info\", \"fp16\");\n+        if (bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv4)) {\n+            // should implicitly enable fp16conv as well\n+            rust_add_target_info(\"target_feature\", \"vfp4d16sp\");\n \n-        if (TARGET_VFPD32)\n-            rust_add_target_info(\"target_feature\", \"vfp4sp\");\n+            if (TARGET_VFPD32)\n+                rust_add_target_info(\"target_feature\", \"vfp4sp\");\n \n-        if (TARGET_VFP_DOUBLE) {\n-            rust_add_target_info(\"target_feature\", \"vfp4d16\");\n+            if (TARGET_VFP_DOUBLE) {\n+                rust_add_target_info(\"target_feature\", \"vfp4d16\");\n \n-            if (TARGET_VFPD32) {\n-                rust_add_target_info(\"target_feature\", \"vfp4\");\n+                if (TARGET_VFPD32)\n+                    rust_add_target_info(\"target_feature\", \"vfp4\");\n             }\n         }\n-    }\n-    // NOTE: supposedly \"fp-armv8\" features in llvm are the same as \"fpv5\", so creating them based on\n-    // that\n-    bool minFP_ARMv8 = minVFP4 && TARGET_VFP5;\n-    if (minFP_ARMv8) {\n-        rust_add_target_info(\"target_feature\", \"fp-armv8d16sp\");\n+        // assuming that fp-armv8 is the same as fpv5\n+        if (TARGET_VFP5) {\n+            rust_add_target_info(\"target_feature\", \"fp-armv8d16sp\");\n \n-        if (TARGET_VFPD32)\n-            rust_add_target_info(\"target_feature\", \"fp-armv8sp\");\n+            if (TARGET_VFPD32)\n+                rust_add_target_info(\"target_feature\", \"fp-armv8sp\");\n \n-        if (TARGET_VFP_DOUBLE) {\n-            rust_add_target_info(\"target_feature\", \"fp-armv8d16\");\n+            if (TARGET_VFP_DOUBLE) {\n+                rust_add_target_info(\"target_feature\", \"fp-armv8d16\");\n \n-            if (TARGET_VFPD32) {\n-                rust_add_target_info(\"target_feature\", \"fp-armv8\");\n+                if (TARGET_VFPD32)\n+                    rust_add_target_info(\"target_feature\", \"fp-armv8\");\n             }\n         }\n-\n-        if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16)) {\n+        if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16))\n             rust_add_target_info(\"target_feature\", \"fullfp16\");\n-\n-            if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16fml))\n-                rust_add_target_info(\"target_feature\", \"fp16fml\");\n-        }\n+        if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16fml))\n+            rust_add_target_info(\"target_feature\", \"fp16fml\");\n+        if (arm_arch_thumb_hwdiv)\n+            rust_add_target_info(\"target_feature\", \"hwdiv\");\n+        if (arm_arch_arm_hwdiv)\n+            rust_add_target_info(\"target_feature\", \"hwdiv-arm\");\n     }\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_tdiv))\n-        rust_add_target_info(\"target_feature\", \"hwdiv\");\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_adiv))\n-        rust_add_target_info(\"target_feature\", \"hwdiv-arm\");\n     // TODO: I'm not sure if there's an exact correlation here (data barrier), so maybe research\n-    // There's also the question of whether this also means \"full data barrier\" (\"fdb\" in llvm)\n+    // There's also the question of whether this also means \"full data barrier\" (\"dfb\" in llvm)\n     if (TARGET_HAVE_MEMORY_BARRIER)\n         rust_add_target_info(\"target_feature\", \"db\");\n     if (bitmap_bit_p(arm_active_target.isa, isa_bit_cmse))\n         rust_add_target_info(\"target_feature\", \"8msecext\");\n-    /* TODO: note that sha2 is an option for aarch64 in gcc but not for arm, so no feature here\n-     * possible. The same goes for aes. However, as llvm has them as prerequisites for crypto, they\n-     * are enabled with it. */\n-    if (TARGET_CRYPTO) {\n-        rust_add_target_info(\"target_feature\", \"crypto\");\n-        rust_add_target_info(\"target_feature\", \"sha2\");\n-        rust_add_target_info(\"target_feature\", \"aes\");\n-    }\n-    if (TARGET_CRC32)\n-        rust_add_target_info(\"target_feature\", \"crc\");\n     if (TARGET_DOTPROD)\n         rust_add_target_info(\"target_feature\", \"dotprod\");\n     // TODO: supposedly gcc supports RAS, but I couldn't find the option, so leaving out \"ras\" for now\n-    if (TARGET_DSP_MULTIPLY)\n-        rust_add_target_info(\"target_feature\", \"dsp\");\n     if (bitmap_bit_p(arm_active_target.isa, isa_bit_mp))\n         rust_add_target_info(\"target_feature\", \"mp\");\n     // TODO: figure out the exact strict-align feature, which I'm pretty sure GCC has\n@@ -146,118 +175,44 @@ void arm_rust_target_cpu_info(void) {\n         rust_add_target_info(\"target_feature\", \"bf16\");\n     if (bitmap_bit_p(arm_active_target.isa, isa_bit_i8mm))\n         rust_add_target_info(\"target_feature\", \"i8mm\");\n-    switch (TARGET_ARM_ARCH_PROFILE) {\n-        case 'A':\n-            rust_add_target_info(\"target_feature\", \"aclass\");\n-            break;\n-        case 'R':\n-            rust_add_target_info(\"target_feature\", \"rclass\");\n-            break;\n-        case 'M':\n-            rust_add_target_info(\"target_feature\", \"mclass\");\n-            break;\n-        default:\n-            fprintf(stderr, \"Screwed up profile selection in arm-rust.c - unknown profile '%c'\",\n-              TARGET_ARM_ARCH_PROFILE);\n-            break;\n-    }\n     if (bitmap_bit_p(arm_active_target.isa, isa_bit_thumb2))\n         rust_add_target_info(\"target_feature\", \"thumb2\");\n-    if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv4)\n-        && bitmap_bit_p(arm_active_target.isa, isa_bit_notm)\n-        && bitmap_bit_p(arm_active_target.isa, isa_bit_thumb)) {\n+    if (arm_arch4t)\n         rust_add_target_info(\"target_feature\", \"v4t\");\n-\n-        if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv5t)) {\n-            rust_add_target_info(\"target_feature\", \"v5t\");\n-\n-            if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv5te)) {\n-                rust_add_target_info(\"target_feature\", \"v5te\");\n-\n-                if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv6)\n-                    && bitmap_bit_p(arm_active_target.isa, isa_bit_be8)) {\n-                    rust_add_target_info(\"target_feature\", \"v6\");\n-\n-                    // note: this definition of \"ARMv6m\" listed as \"suspect\" in arm-cpus.in\n-                    rust_add_target_info(\"target_feature\", \"v6m\");\n-\n-                    bool hasV8BaselineOps = bitmap_bit_p(arm_active_target.isa, isa_bit_armv8)\n-                                            && bitmap_bit_p(arm_active_target.isa, isa_bit_cmse)\n-                                            && bitmap_bit_p(arm_active_target.isa, isa_bit_tdiv);\n-                    if (hasV8BaselineOps)\n-                        rust_add_target_info(\"target_feature\", \"v8m\");\n-\n-                    bool hasV6kOps = bitmap_bit_p(arm_active_target.isa, isa_bit_armv6k);\n-                    if (hasV6kOps) {\n-                        rust_add_target_info(\"target_feature\", \"v6k\");\n-                    }\n-\n-                    if (bitmap_bit_p(arm_active_target.isa, isa_bit_thumb2) && hasV8BaselineOps\n-                        && hasV6kOps) {\n-                        rust_add_target_info(\"target_feature\", \"v6t2\");\n-\n-                        // note that arm-cpus.in refers to this (ARMv7) as suspect\n-                        if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv7)) {\n-                            rust_add_target_info(\"target_feature\", \"v7\");\n-\n-                            rust_add_target_info(\"target_feature\", \"v8m.main\");\n-\n-                            if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv8_1m_main))\n-                                rust_add_target_info(\"target_feature\", \"v8.1m.main\");\n-\n-                            // dummy: can't find feature acquire-release, so dummy true variable\n-                            bool hasAcquireRelease = true;\n-                            if (hasAcquireRelease && bitmap_bit_p(arm_active_target.isa, isa_bit_adiv)\n-                                && bitmap_bit_p(arm_active_target.isa, isa_bit_lpae)\n-                                && bitmap_bit_p(arm_active_target.isa, isa_bit_mp)\n-                                && bitmap_bit_p(arm_active_target.isa, isa_bit_sec)) {\n-                                rust_add_target_info(\"target_feature\", \"v8\");\n-\n-                                if (TARGET_CRC32\n-                                    && bitmap_bit_p(arm_active_target.isa, isa_bit_armv8_1)) {\n-                                    rust_add_target_info(\"target_feature\", \"v8.1a\");\n-\n-                                    if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv8_2)) {\n-                                        rust_add_target_info(\"target_feature\", \"v8.2a\");\n-\n-                                        if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv8_3)) {\n-                                            rust_add_target_info(\"target_feature\", \"v8.3a\");\n-\n-                                            if (bitmap_bit_p(\n-                                                  arm_active_target.isa, isa_bit_armv8_4)) {\n-                                                rust_add_target_info(\"target_feature\", \"v8.4a\");\n-                                                // note: llvm, but not gcc, also wants dotprod for\n-                                                // v8.4\n-\n-                                                if (bitmap_bit_p(arm_active_target.isa, isa_bit_sb)\n-                                                    && bitmap_bit_p(\n-                                                      arm_active_target.isa, isa_bit_predres)\n-                                                    && bitmap_bit_p(\n-                                                      arm_active_target.isa, isa_bit_armv8_5)) {\n-                                                    rust_add_target_info(\"target_feature\", \"v8.5a\");\n-\n-                                                    if (bitmap_bit_p(\n-                                                          arm_active_target.isa, isa_bit_armv8_6))\n-                                                        rust_add_target_info(\n-                                                          \"target_feature\", \"v8.6a\");\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n+    if (arm_arch5t)\n+        rust_add_target_info(\"target_feature\", \"v5t\");\n+    if (arm_arch5te)\n+        rust_add_target_info(\"target_feature\", \"v5te\");\n+    if (arm_arch6m)\n+        rust_add_target_info(\"target_feature\", \"v6m\");\n+    bool hasBaseline8MPreReqs = bitmap_bit_p(arm_active_target.isa, isa_bit_be8)\n+                                && arm_arch_thumb_hwdiv && arm_arch5t && arm_arch4 && arm_arch6\n+                                && arm_arch8 && bitmap_bit_p(arm_active_target.isa, isa_bit_armv5te)\n+                                && arm_arch_cmse && arm_arch_thumb1;\n+    if (hasBaseline8MPreReqs)\n+        rust_add_target_info(\"target_feature\", \"v8m\");\n+    if (hasBaseLine8MPreReqs && arm_arch_thumb2 && arm_arch7)\n+        rust_add_target_info(\"target_feature\", \"v8m.main\");\n+    if (arm_arch8_1)\n+        rust_add_target_info(\"target_feature\", \"v8.1a\");\n+    if (arm_arch8_2)\n+        rust_add_target_info(\"target_feature\", \"v8.2a\");\n+    if (arm_arch8_3)\n+        rust_add_target_info(\"target_feature\", \"v8.3a\");\n+    if (arm_arch8_4)\n+        rust_add_target_info(\"target_feature\", \"v8.4a\");\n+    if (arm_arch8_5)\n+        rust_add_target_info(\"target_feature\", \"v8.5a\");\n+    if (arm_arch8_6)\n+        rust_add_target_info(\"target_feature\", \"v8.6a\");\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv8_1m_main))\n+        rust_add_target_info(\"target_feature\", \"v8.1m.main\");\n     if (bitmap_bit_p(arm_active_target.isa, isa_bit_mve)\n         && bitmap_bit_p(arm_active_target.isa, isa_bit_vfp_base)\n         && bitmap_bit_p(arm_active_target.isa, isa_bit_armv7em)) {\n         rust_add_target_info(\"target_feature\", \"mve\");\n \n-        if (minFP_ARMv8 && bitmap_bit_p(arm_active_target.isa, isa_bit_fp16)\n+        if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16)\n             && bitmap_bit_p(arm_active_target.isa, isa_bit_mve_float))\n             rust_add_target_info(\"target_feature\", \"mve.fp\");\n     }\n@@ -294,11 +249,18 @@ void arm_rust_target_cpu_info(void) {\n         rust_add_target_info(\"target_feature\", \"cdecp7\");\n         rust_add_target_info(\"target_feature\", \"cde\");\n     }\n-    if (TARGET_SOFT_FLOAT)\n-        rust_add_target_info(\"target_feature\", \"soft-float\");\n-    // should be correct option (i.e. thumb mode rather than just thumb-aware) as TARGET_ARM is\n-    // inverse\n-    if (TARGET_THUMB)\n-        rust_add_target_info(\"target_feature\", \"thumb-mode\");\n     // TODO: consider doing the processors as target features, but honestly they don't seem to fit\n+\n+    /* TODO: further research support for CLREX (v7clrex), acquire-release (lda/ldaex), slow-fp-brcc\n+     * (slow FP compare and branch), perfmon, trustzone, fpao, fuse-aes, fuse-literals, read-tp-hard,\n+     * zcz, prof-unpr, slow-vgetlni32, slow-vdup32, prefer-vmovsr, prefer-ishst, muxed-units,\n+     * slow-odd-reg, slow-load-D-subreg, wide-stride-vfp, dont-widen-vmovs, splat-vfp-neon,\n+     * expand-fp-mlx, vmlx-hazards, neon-fpmovs, neonfp (as in using neon for scalar fp), vldn-align,\n+     * nonpipelined-vfp, slowfpvmlx, slowfpvfmx, vmlx-forwarding, 32bit (prefer 32-bit Thumb),\n+     * loop-align, mve1beat, mve2beat, mve4beat, avoid-partial-cpsr, cheap-predictable-cpsr,\n+     * avoid-movs-shop, ret-addr-stack, no-branch-predictor, virtualization, nacl-trap, execute-only,\n+     * reserve-r9, no-movt, no-neg-immediates, use-misched, disable-postra-scheduler, lob (Low\n+     * Overhead Branch), noarm - can't find them. */\n+    // note that apparently v7clrex and perfmon are prerequisites for v7 ops, so could maybe enable\n+    // them like that\n }"}]}