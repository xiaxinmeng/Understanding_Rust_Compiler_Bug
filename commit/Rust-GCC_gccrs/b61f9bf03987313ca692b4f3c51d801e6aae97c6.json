{"sha": "b61f9bf03987313ca692b4f3c51d801e6aae97c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYxZjliZjAzOTg3MzEzY2E2OTJiNGYzYzUxZDgwMWU2YWFlOTdjNg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2004-01-07T05:59:19Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-01-07T05:59:19Z"}, "message": "check_performance: Use -pthread.\n\n\n2004-01-06  Benjamin Kosnik  <bkoz@redhat.com>\n            Stefan Olsson  <stefan@snon.net>\n\n\t* scripts/check_performance: Use -pthread.\n\t* testsuite/performance/allocator.cc: Tweaks, add list.\n\t* testsuite/performance/allocator_thread.cc: New.\n\nCo-Authored-By: Stefan Olsson <stefan@snon.net>\n\nFrom-SVN: r75499", "tree": {"sha": "c605d639de8ec555b54c8e512c073f770fccb57e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c605d639de8ec555b54c8e512c073f770fccb57e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b61f9bf03987313ca692b4f3c51d801e6aae97c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61f9bf03987313ca692b4f3c51d801e6aae97c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b61f9bf03987313ca692b4f3c51d801e6aae97c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61f9bf03987313ca692b4f3c51d801e6aae97c6/comments", "author": null, "committer": null, "parents": [{"sha": "9a01c9b061ea6ac729730ac9d4999e4d60c4df3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d"}], "stats": {"total": 402, "additions": 244, "deletions": 158}, "files": [{"sha": "8a78a5a20674be703e53c8b7fb3a1a3321f95054", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61f9bf03987313ca692b4f3c51d801e6aae97c6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61f9bf03987313ca692b4f3c51d801e6aae97c6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b61f9bf03987313ca692b4f3c51d801e6aae97c6", "patch": "@@ -1,3 +1,10 @@\n+2004-01-06  Benjamin Kosnik  <bkoz@redhat.com>\n+            Stefan Olsson  <stefan@snon.net>\n+\n+\t* scripts/check_performance: Use -pthread.\n+\t* testsuite/performance/allocator.cc: Tweaks, add list.\n+\t* testsuite/performance/allocator_thread.cc: New.\n+\n 2003-01-06  Jerry Quinn  <jlquinn@optonline.net>\n \n \t* include/bits/locale_facets.h: Document public classes and"}, {"sha": "5865114d1eb4f9837265fbb612eaa44a6fd9217d", "filename": "libstdc++-v3/scripts/check_performance", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61f9bf03987313ca692b4f3c51d801e6aae97c6/libstdc%2B%2B-v3%2Fscripts%2Fcheck_performance", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61f9bf03987313ca692b4f3c51d801e6aae97c6/libstdc%2B%2B-v3%2Fscripts%2Fcheck_performance", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fscripts%2Fcheck_performance?ref=b61f9bf03987313ca692b4f3c51d801e6aae97c6", "patch": "@@ -25,12 +25,13 @@ esac\n flags_script=$BUILD_DIR/scripts/testsuite_flags\n INCLUDES=`$flags_script --build-includes`\n FLAGS=`$flags_script --cxxflags`\n+THREAD_FLAG='-pthread'\n COMPILER=`$flags_script --build-cxx`\n SH_FLAG=\"-Wl,--rpath -Wl,$BUILD_DIR/../../gcc \\\n          -Wl,--rpath -Wl,$BUILD_DIR/src/.libs\"\n ST_FLAG=\"-static\"\n LINK=$SH_FLAG\n-CXX=\"$COMPILER $INCLUDES $FLAGS $LINK\"\n+CXX=\"$COMPILER $INCLUDES $FLAGS $THREAD_FLAG $LINK\"\n \n \n TESTS_FILE=\"testsuite_files_performance\""}, {"sha": "53058edb39548b392e236775a9250f643295d34f", "filename": "libstdc++-v3/testsuite/performance/allocator.cc", "status": "modified", "additions": 81, "deletions": 157, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61f9bf03987313ca692b4f3c51d801e6aae97c6/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61f9bf03987313ca692b4f3c51d801e6aae97c6/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator.cc?ref=b61f9bf03987313ca692b4f3c51d801e6aae97c6", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -26,36 +26,17 @@\n // the GNU General Public License.\n \n /*\n- * \n- *\n  * The goal with this application is to compare the performance\n- * between different STL allocators relative to the default\n- * __pool_alloc.\n- *\n- * The container used for the tests is vector, which as stated by\n- * SGI \"Vector is the simplest of the STL container classes, and in \n- * many cases the most efficient.\".\n- *\n- * NOTE! The vector<> container does some \"caching\" of it's own and\n- * therefore we redeclare the variable in each iteration (forcing the\n- * const/destr to be called and thus free memory).\n- *\n- * NOTE! The usage of gettimeofday is unwanted since it's not POSIX,\n- * however I have not found a more generic system call to use - \n- * ideas are greatly appriciated!\n- *\n- * NOTE! This version only does operations on vector<int>. More/other\n- * data types should maybe also be tested - ideas are always welcome!\n- *\n- * I assume that glibc/underlying malloc() implementation has been\n- * compiled with -O2 thus should this application also be compiled\n- * with -O2 in order to get relevant results.\n+ * between different std::allocator implementations. The results are\n+ * influenced by the underlying allocator in the \"C\" library, malloc.\n  */\n \n // 2003-02-05 Stefan Olsson <stefan@snon.net>\n \n #include <vector>\n-#include <sys/time.h>\n+#include <list>\n+#include <typeinfo>\n+#include <sstream>\n #include <ext/mt_allocator.h>\n #include <ext/malloc_allocator.h>\n #include <testsuite_performance.h>\n@@ -64,154 +45,97 @@ using namespace std;\n using __gnu_cxx::malloc_allocator;\n using __gnu_cxx::__mt_alloc;\n \n-/*\n- * In order to avoid that the time it takes for the application to \n- * startup/shutdown affect the end result, we define a target \n- * duration (in seconds) for which all tests should run.\n- * Each test is responsible for \"calibrating\" their # of iterations \n- * to come as close as possible to this target based on the time\n- * it takes to complete the test using the default __pool_alloc.\n- */\n-int target_run_time = 10;\n+typedef int test_type;\n \n-/*\n- * The number of iterations to be performed in order to figure out\n- * the \"speed\" of this computer and adjust the number of iterations\n- * needed to come close to target_run_time.\n- */\n-int calibrate_iterations = 100000;\n+// The number of iterations to be performed.\n+int iterations;\n \n-/*\n- * The number of values to insert in the vector, 32 will cause \n- * 5 (re)allocations to be performed (sizes 4, 8, 16, 32 and 64)\n- * This means that all allocations are within _MAX_BYTES = 128\n- * as defined in stl_alloc.h for __pool_alloc.\n- * Whether or not this value is relevant in \"the real world\" \n- * or not I don't know and should probably be investigated in \n- * more detail.\n- */\n-int insert_values = 32;\n+// The number of values to insert in the container, 32 will cause 5\n+// (re)allocations to be performed (sizes 4, 8, 16, 32 and 64)\n+// This means that all allocations are within _MAX_BYTES = 128 as\n+// defined in stl_alloc.h for __pool_alloc.  Whether or not this\n+// value is relevant in \"the real world\" or not I don't know and\n+// should probably be investigated in more detail.\n+int insert_values = 128;\n \n-static struct timeval _tstart, _tend;\n-static struct timezone tz;\n-\n-void\n-tstart(void)\n-{\n-  gettimeofday(&_tstart, &tz);\n-}\n-\n-void\n-tend(void)\n-{\n-  gettimeofday(&_tend, &tz);\n-}\n-\n-double\n-tval()\n-{\n-  double t1, t2;\n-\n-  t1 =(double)_tstart.tv_sec +(double)_tstart.tv_usec/(1000*1000);\n-  t2 =(double)_tend.tv_sec +(double)_tend.tv_usec/(1000*1000);\n-  return t2 - t1;\n-}\n-\n-int\n-calibrate_test_ints(void)\n-{\n-  tstart();\n-  for (int i = 0; i < calibrate_iterations; i++)\n+template<typename Container>\n+  int\n+  do_loop()\n   {\n-    vector<int> v1;\n-\n-    for(int j = 0; j < insert_values; j++)\n-      v1.push_back(1);\n+    int test_iterations = 0;\n+    try\n+      {\n+\tContainer obj;\n+\twhile (test_iterations < iterations)\n+\t  {\n+\t    for (int j = 0; j < insert_values; ++j)\n+\t      obj.push_back(test_iterations);\n+\t    ++test_iterations;\n+\t  }\n+      }\n+    catch(...)\n+      {\n+\t// No point allocating all available memory, repeatedly.\t\n+      }\n+    return test_iterations;\n   }\n-  tend();\n-\n-  return(int)((double)target_run_time / tval()) * calibrate_iterations;\n-}\n \n-double\n-test_ints_pool_alloc(int iterations)\n-{\n-  tstart();\n-  for(int i = 0; i < iterations; i++)\n-  {\n-    vector<int> v1;\n-\n-    for(int j = 0; j < insert_values; j++)\n-      v1.push_back(1);\n-  }\n-  tend();\n-\n-  return tval();\n-}\n-\n-double\n-test_ints_malloc_alloc(int iterations)\n-{\n-  tstart();\n-  for(int i = 0; i < iterations; i++)\n+template<typename Container>\n+  void\n+  calibrate_iterations()\n   {\n-    vector<int, malloc_allocator<int> > v1;\n-\n-    for(int j = 0; j < insert_values; j++)\n-    {\n-      v1.push_back(1);\n-    }\n+    int try_iterations = iterations = 100000;\n+    int test_iterations;\n+\n+    __gnu_test::time_counter timer;\n+    timer.start();\n+    test_iterations = do_loop<Container>();\n+    timer.stop();\n+\n+    if (try_iterations > test_iterations && test_iterations > iterations)\n+      iterations = test_iterations - 100;\n+    else\n+      {\n+\tdouble tics = timer.real_time();\n+\tdouble iterpc = test_iterations / tics; //iterations per clock\n+\tdouble xtics = 200; // works for linux 2gig x86\n+\titerations = static_cast<int>(xtics * iterpc);\n+      }\n   }\n-  tend();\n-\n-  return tval();\n-}\n \n-double\n-test_ints_mt_alloc(int iterations)\n-{\n-  tstart();\n-  for(int i = 0; i < iterations; i++)\n+template<typename Container>\n+  void\n+  test_container(Container obj)\n   {\n-    vector<int, __mt_alloc<int> > v1;\n-\n-    for(int j = 0; j < insert_values; j++)\n-    {\n-      v1.push_back(1);\n-    }\n+    using namespace __gnu_test;\n+\n+    time_counter time;\n+    resource_counter resource;\n+    clear_counters(time, resource);\n+    start_counters(time, resource);\n+    int test_iterations = do_loop<Container>();\n+    stop_counters(time, resource);\n+ \n+    std::ostringstream comment;\n+    comment << \"iterations: \" << test_iterations << '\\t';\n+    comment << \"type: \" << typeid(obj).name();\n+    report_header(__FILE__, comment.str());\n+    report_performance(__FILE__, string(), time, resource);\n   }\n-  tend();\n-\n-  return tval();\n-}\n \n // http://gcc.gnu.org/ml/libstdc++/2001-05/msg00105.html\n // http://gcc.gnu.org/ml/libstdc++/2003-05/msg00231.html\n int main(void)\n {\n-  using namespace __gnu_test;\n-\n-  time_counter time;\n-  resource_counter resource;\n-\n-  int iterations = calibrate_test_ints();\n-\n-  start_counters(time, resource);\n-  test_ints_pool_alloc(iterations);\n-  stop_counters(time, resource);\n-  report_performance(__FILE__, \"default\", time, resource);\n-  clear_counters(time, resource);\n-\n-  start_counters(time, resource);\n-  test_ints_malloc_alloc(iterations);\n-  stop_counters(time, resource);\n-  report_performance(__FILE__, \"malloc\", time, resource);\n-  clear_counters(time, resource);\n-\n-  start_counters(time, resource);\n-  test_ints_mt_alloc(iterations);\n-  stop_counters(time, resource);\n-  report_performance(__FILE__, \"mt\", time, resource);\n+  calibrate_iterations<vector<test_type> >();\n+  test_container(vector<test_type>());\n+  test_container(vector<test_type, malloc_allocator<test_type> >());\n+  //test_container(vector<test_type, __mt_alloc<test_type> >());\n+\n+  calibrate_iterations<list<test_type> >();\n+  test_container(list<test_type>());\n+  test_container(list<test_type, malloc_allocator<test_type> >());\n+  //test_container(list<test_type, __mt_alloc<test_type> >());\n \n   return 0;\n }"}, {"sha": "016f45a5d3033893f5cfbf5a8138db5e25283c15", "filename": "libstdc++-v3/testsuite/performance/allocator_thread.cc", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61f9bf03987313ca692b4f3c51d801e6aae97c6/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61f9bf03987313ca692b4f3c51d801e6aae97c6/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator_thread.cc?ref=b61f9bf03987313ca692b4f3c51d801e6aae97c6", "patch": "@@ -0,0 +1,154 @@\n+// Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ * The goal with this application is to compare the performance\n+ * between different std::allocator implementations. The results are\n+ * influenced by the underlying allocator in the \"C\" library, malloc.\n+ */\n+\n+// 2003-02-05 Stefan Olsson <stefan@snon.net>\n+\n+#include <vector>\n+#include <list>\n+#include <typeinfo>\n+#include <sstream>\n+#include <pthread.h>\n+#include <ext/mt_allocator.h>\n+#include <ext/malloc_allocator.h>\n+#include <testsuite_performance.h>\n+\n+using namespace std;\n+using __gnu_cxx::malloc_allocator;\n+using __gnu_cxx::__mt_alloc;\n+\n+typedef int test_type;\n+\n+// The number of iterations to be performed.\n+int iterations;\n+\n+// The number of values to insert in the container, 32 will cause 5\n+// (re)allocations to be performed (sizes 4, 8, 16, 32 and 64)\n+// This means that all allocations are within _MAX_BYTES = 128 as\n+// defined in stl_alloc.h for __pool_alloc.  Whether or not this\n+// value is relevant in \"the real world\" or not I don't know and\n+// should probably be investigated in more detail.\n+int insert_values = 128;\n+\n+template<typename Container>\n+  void*\n+  do_loop(void* p = NULL)\n+  {\n+    Container obj;    \n+    try\n+      {\n+\tint test_iterations = 0;\n+\twhile (test_iterations < iterations)\n+\t  {\n+\t    for (int j = 0; j < insert_values; ++j)\n+\t      obj.push_back(test_iterations);\n+\t    ++test_iterations;\n+\t  }\n+\tobj.clear();\n+\ttest_iterations = 0;\n+\twhile (test_iterations < iterations)\n+\t  {\n+\t    for (int j = 0; j < insert_values; ++j)\n+\t      obj.push_back(test_iterations);\n+\t    ++test_iterations;\n+\t  }\n+      }\n+    catch(...)\n+      {\n+\t// No point allocating all available memory, repeatedly.\t\n+      }\n+  }\n+\n+template<typename Container>\n+  void\n+  calibrate_iterations()\n+  {\n+    int try_iterations = iterations = 100000;\n+\n+    __gnu_test::time_counter timer;\n+    timer.start();\n+    do_loop<Container>();\n+    timer.stop();\n+\n+    double tics = timer.real_time();\n+    double iterpc = iterations / tics; //iterations per clock\n+    double xtics = 100; // works for linux 2gig x86\n+    iterations = static_cast<int>(xtics * iterpc);\n+  }\n+\n+template<typename Container>\n+  void\n+  test_container(Container obj)\n+  {\n+    using namespace __gnu_test;\n+    time_counter time;\n+    resource_counter resource;\n+\n+    clear_counters(time, resource);\n+    start_counters(time, resource);\n+    \n+    pthread_t  t1, t2, t3, t4;\n+    pthread_create(&t1, 0, &do_loop<Container>, 0);\n+    pthread_create(&t2, 0, &do_loop<Container>, 0);\n+    pthread_create(&t3, 0, &do_loop<Container>, 0);\n+    pthread_create(&t4, 0, &do_loop<Container>, 0);\n+\n+    pthread_join(t1, NULL);\n+    pthread_join(t2, NULL);\n+    pthread_join(t3, NULL);\n+    pthread_join(t4, NULL);\n+\n+    stop_counters(time, resource);\n+ \n+    std::ostringstream comment;\n+    comment << \"iterations: \" << iterations << '\\t';\n+    comment << \"type: \" << typeid(obj).name();\n+    report_header(__FILE__, comment.str());\n+    report_performance(__FILE__, string(), time, resource);\n+  }\n+\n+// http://gcc.gnu.org/ml/libstdc++/2001-05/msg00105.html\n+// http://gcc.gnu.org/ml/libstdc++/2003-05/msg00231.html\n+int main(void)\n+{\n+  calibrate_iterations<vector<test_type> >();\n+  test_container(vector<test_type>());\n+  test_container(vector<test_type, malloc_allocator<test_type> >());\n+  //test_container(vector<test_type, __mt_alloc<test_type> >());\n+\n+  calibrate_iterations<list<test_type> >();\n+  test_container(list<test_type>());\n+  test_container(list<test_type, malloc_allocator<test_type> >());\n+  //test_container(list<test_type, __mt_alloc<test_type> >());\n+\n+  return 0;\n+}"}]}