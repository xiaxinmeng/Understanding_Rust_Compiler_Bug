{"sha": "74853971933adc9c021b596d1e574f6851a7165c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ4NTM5NzE5MzNhZGM5YzAyMWI1OTZkMWU1NzRmNjg1MWE3MTY1Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T06:59:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T06:59:47Z"}, "message": "[multiple changes]\n\n2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Mark_Coextensions): If the expression in the allocator\n\tfor a coextension in an object declaration is a concatenation, treat\n\tcoextension as dynamic.\n\n2010-06-23  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (Add_Internal_Interface_Entities): Ensure that the\n\tinternal entities are added to the scope of the tagged type.\n\t(Derive_Subprograms): Do not stop derivation when we find the first\n\tinternal entity that has attribute Interface_Alias. After the change\n\tdone to Override_Dispatching_Operations it is no longer true that\n\tthese primirives are always located at the end of the list of\n\tprimitives.\n\t* einfo.ads (Primitive_Operations): Add documentation.\n\t* exp_disp.adb (Write_DT): Improve output adding to the name of the\n\tprimitive a prefix indicating its corresponding tagged type.\n\t* sem_disp.adb (Override_Dispatching_Operations): If the overridden\n\tentity covers the primitive of an interface that is not an ancestor of\n\tthis tagged type then the new primitive is added at the end of the list\n\tof primitives.  Required to fulfill the C++ ABI.\n\nFrom-SVN: r161253", "tree": {"sha": "7ca867f80e6d89c254fab730b81c4a7fd03ef4e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ca867f80e6d89c254fab730b81c4a7fd03ef4e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74853971933adc9c021b596d1e574f6851a7165c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74853971933adc9c021b596d1e574f6851a7165c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74853971933adc9c021b596d1e574f6851a7165c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74853971933adc9c021b596d1e574f6851a7165c/comments", "author": null, "committer": null, "parents": [{"sha": "e771c08509c5bc959cd8a59aaa15965cfc04a48c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e771c08509c5bc959cd8a59aaa15965cfc04a48c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e771c08509c5bc959cd8a59aaa15965cfc04a48c"}], "stats": {"total": 169, "additions": 132, "deletions": 37}, "files": [{"sha": "5ea2f6fe3ec116c1bc1b74fc840107695fc45056", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=74853971933adc9c021b596d1e574f6851a7165c", "patch": "@@ -1,3 +1,26 @@\n+2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Mark_Coextensions): If the expression in the allocator\n+\tfor a coextension in an object declaration is a concatenation, treat\n+\tcoextension as dynamic.\n+\n+2010-06-23  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch3.adb (Add_Internal_Interface_Entities): Ensure that the\n+\tinternal entities are added to the scope of the tagged type.\n+\t(Derive_Subprograms): Do not stop derivation when we find the first\n+\tinternal entity that has attribute Interface_Alias. After the change\n+\tdone to Override_Dispatching_Operations it is no longer true that\n+\tthese primirives are always located at the end of the list of\n+\tprimitives.\n+\t* einfo.ads (Primitive_Operations): Add documentation.\n+\t* exp_disp.adb (Write_DT): Improve output adding to the name of the\n+\tprimitive a prefix indicating its corresponding tagged type.\n+\t* sem_disp.adb (Override_Dispatching_Operations): If the overridden\n+\tentity covers the primitive of an interface that is not an ancestor of\n+\tthis tagged type then the new primitive is added at the end of the list\n+\tof primitives.  Required to fulfill the C++ ABI.\n+\n 2010-06-23  Javier Miranda  <miranda@adacore.com>\n \n \t* atree.ads (Set_Reporting_Proc): New subprogram."}, {"sha": "a3bff056113be84b4c12205321de3d8c6b2b5130", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=74853971933adc9c021b596d1e574f6851a7165c", "patch": "@@ -3152,7 +3152,9 @@ package Einfo is\n --       types. Points to an element list of entities for primitive operations\n --       for the tagged type. Not present (and not set) in untagged types (it\n --       is an error to reference the primitive operations field of a type\n---       that is not tagged).\n+--       that is not tagged). In order to fulfill the C++ ABI, entities of\n+--       primitives that come from source must be stored in this list following\n+--       their order of occurrence in the sources.\n \n --    Prival (Node17)\n --       Present in private components of protected types. Refers to the entity"}, {"sha": "fbc6ddbb38d75158a6a94920d2928efc9eaa418e", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=74853971933adc9c021b596d1e574f6851a7165c", "patch": "@@ -7127,7 +7127,7 @@ package body Exp_Disp is\n             Next_Elmt (Prim_Elmt);\n          end loop;\n \n-         --  Third stage: Fix the position of all the new primitives\n+         --  Third stage: Fix the position of all the new primitives.\n          --  Entries associated with primitives covering interfaces\n          --  are handled in a latter round.\n \n@@ -7515,6 +7515,17 @@ package body Exp_Disp is\n             Write_Str (\"(predefined) \");\n          end if;\n \n+         --  Prefix the name of the primitive with its corresponding tagged\n+         --  type to facilitate seeing inherited primitives.\n+\n+         if Present (Alias (Prim)) then\n+            Write_Name\n+              (Chars (Find_Dispatching_Type (Ultimate_Alias (Prim))));\n+         else\n+            Write_Name (Chars (Typ));\n+         end if;\n+\n+         Write_Str (\".\");\n          Write_Name (Chars (Prim));\n \n          --  Indicate if this primitive has an aliased primitive"}, {"sha": "d5b39f99f9d00a77367e2f57d0c03460aa77e183", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 61, "deletions": 33, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=74853971933adc9c021b596d1e574f6851a7165c", "patch": "@@ -1517,13 +1517,14 @@ package body Sem_Ch3 is\n    -------------------------------------\n \n    procedure Add_Internal_Interface_Entities (Tagged_Type : Entity_Id) is\n-      Elmt        : Elmt_Id;\n-      Iface       : Entity_Id;\n-      Iface_Elmt  : Elmt_Id;\n-      Iface_Prim  : Entity_Id;\n-      Ifaces_List : Elist_Id;\n-      New_Subp    : Entity_Id := Empty;\n-      Prim        : Entity_Id;\n+      Elmt          : Elmt_Id;\n+      Iface         : Entity_Id;\n+      Iface_Elmt    : Elmt_Id;\n+      Iface_Prim    : Entity_Id;\n+      Ifaces_List   : Elist_Id;\n+      New_Subp      : Entity_Id := Empty;\n+      Prim          : Entity_Id;\n+      Restore_Scope : Boolean := False;\n \n    begin\n       pragma Assert (Ada_Version >= Ada_05\n@@ -1532,6 +1533,13 @@ package body Sem_Ch3 is\n         and then Has_Interfaces (Tagged_Type)\n         and then not Is_Interface (Tagged_Type));\n \n+      --  Ensure that the internal entities are added to the scope of the type\n+\n+      if Scope (Tagged_Type) /= Current_Scope then\n+         Push_Scope (Scope (Tagged_Type));\n+         Restore_Scope := True;\n+      end if;\n+\n       Collect_Interfaces (Tagged_Type, Ifaces_List);\n \n       Iface_Elmt := First_Elmt (Ifaces_List);\n@@ -1556,32 +1564,47 @@ package body Sem_Ch3 is\n                    (Tagged_Type => Tagged_Type,\n                     Iface_Prim  => Iface_Prim);\n \n+               --  Handle cases where the type has no primitive covering this\n+               --  interface primitive.\n+\n                if No (Prim) then\n \n-                  --  In some rare cases, a name conflict may have kept the\n-                  --  operation completely hidden. Look for it in the list\n-                  --  of primitive operations of the type.\n+                  --  if the tagged type is defined at library level then we\n+                  --  invoke Check_Abstract_Overriding to report the error\n+                  --  and thus avoid generating the dispatch tables.\n \n-                  declare\n-                     El : Elmt_Id;\n+                  if Is_Library_Level_Tagged_Type (Tagged_Type) then\n+                     Check_Abstract_Overriding (Tagged_Type);\n+                     pragma Assert (Serious_Errors_Detected > 0);\n+                     return;\n \n-                  begin\n-                     El := First_Elmt (Primitive_Operations (Tagged_Type));\n-                     while Present (El) loop\n-                        Prim := Node (El);\n-                        exit when Is_Subprogram (Prim)\n-                          and then Alias (Prim) = Iface_Prim;\n-                        Next_Elmt (El);\n-                     end loop;\n+                  --  For tagged types defined in nested scopes it is still\n+                  --  possible to cover this interface primitive by means of\n+                  --  late overriding (see Override_Dispatching_Operation).\n \n-                     --  If the operation was not explicitly overridden, it\n-                     --  should have been inherited as an abstract operation\n-                     --  so Prim can not be Empty at this stage.\n+                  --  Search in the list of primitives of the type for the\n+                  --  entity that will be overridden in such case to reference\n+                  --  it in the internal entity that we build here. If the\n+                  --  primitive is not overridden then the error will be\n+                  --  reported later as part of the analysis of entities\n+                  --  defined in the enclosing scope.\n \n-                     if No (El) then\n-                        raise Program_Error;\n-                     end if;\n-                  end;\n+                  else\n+                     declare\n+                        El : Elmt_Id;\n+\n+                     begin\n+                        El := First_Elmt (Primitive_Operations (Tagged_Type));\n+                        while Present (El)\n+                          and then Alias (Node (El)) /= Iface_Prim\n+                        loop\n+                           Next_Elmt (El);\n+                        end loop;\n+\n+                        pragma Assert (Present (El));\n+                        Prim := Node (El);\n+                     end;\n+                  end if;\n                end if;\n \n                Derive_Subprogram\n@@ -1627,6 +1650,10 @@ package body Sem_Ch3 is\n \n          Next_Elmt (Iface_Elmt);\n       end loop;\n+\n+      if Restore_Scope then\n+         Pop_Scope;\n+      end if;\n    end Add_Internal_Interface_Entities;\n \n    -----------------------------------\n@@ -12827,13 +12854,13 @@ package body Sem_Ch3 is\n             Subp       := Node (Elmt);\n             Alias_Subp := Ultimate_Alias (Subp);\n \n-            --  At this early stage Derived_Type has no entities with attribute\n-            --  Interface_Alias. In addition, such primitives are always\n-            --  located at the end of the list of primitives of Parent_Type.\n-            --  Therefore, if found we can safely stop processing pending\n-            --  entities.\n+            --  Do not derive internal entities of the parent that link\n+            --  interface primitives and its covering primitive. These\n+            --  entities will be added to this type when frozen.\n \n-            exit when Present (Interface_Alias (Subp));\n+            if Present (Interface_Alias (Subp)) then\n+               goto Continue;\n+            end if;\n \n             --  If the generic actual is present find the corresponding\n             --  operation in the generic actual. If the parent type is a\n@@ -13008,6 +13035,7 @@ package body Sem_Ch3 is\n                Act_Subp := Node (Act_Elmt);\n             end if;\n \n+            <<Continue>>\n             Next_Elmt (Elmt);\n          end loop;\n "}, {"sha": "a21337bb600c8ba225dee4b54e44738a927d0e94", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=74853971933adc9c021b596d1e574f6851a7165c", "patch": "@@ -784,7 +784,7 @@ package body Sem_Disp is\n         and then not Comes_From_Source (Subp)\n         and then not Has_Dispatching_Parent\n       then\n-         --  Complete decoration if internally built subprograms that override\n+         --  Complete decoration of internally built subprograms that override\n          --  a dispatching primitive. These entities correspond with the\n          --  following cases:\n \n@@ -1709,7 +1709,28 @@ package body Sem_Disp is\n          return;\n       end if;\n \n-      Replace_Elmt (Elmt, New_Op);\n+      --  The location of entities that come from source in the list of\n+      --  primitives of the tagged type must follow their order of occurrence\n+      --  in the sources to fulfill the C++ ABI. If the overriden entity is a\n+      --  primitive of an interface that is not an ancestor of this tagged\n+      --  type (that is, it is an entity added to the list of primitives by\n+      --  Derive_Interface_Progenitors), then we must append the new entity\n+      --  at the end of the list of primitives.\n+\n+      if Present (Alias (Prev_Op))\n+        and then Is_Interface (Find_Dispatching_Type (Alias (Prev_Op)))\n+        and then not Is_Ancestor (Find_Dispatching_Type (Alias (Prev_Op)),\n+                                  Tagged_Type)\n+      then\n+         Remove_Elmt (Primitive_Operations (Tagged_Type), Elmt);\n+         Append_Elmt (New_Op, Primitive_Operations (Tagged_Type));\n+\n+      --  The new primitive replaces the overriden entity. Required to ensure\n+      --  that overriding primitive is assigned the same dispatch table slot.\n+\n+      else\n+         Replace_Elmt (Elmt, New_Op);\n+      end if;\n \n       if Ada_Version >= Ada_05\n         and then Has_Interfaces (Tagged_Type)"}, {"sha": "b141ca41fe63d7684b21863d7c5c5be23191aeb5", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74853971933adc9c021b596d1e574f6851a7165c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=74853971933adc9c021b596d1e574f6851a7165c", "patch": "@@ -7948,6 +7948,16 @@ package body Sem_Util is\n             if Is_Dynamic then\n                Set_Is_Dynamic_Coextension (N);\n \n+            --  If the allocator expression is potentially dynamic, it may\n+            --  be expanded out of order and require dynamic allocation\n+            --  anyway, so we treat the coextension itself as dynamic.\n+            --  Potential optimization ???\n+\n+            elsif Nkind (Expression (N)) = N_Qualified_Expression\n+              and then Nkind (Expression (Expression (N))) = N_Op_Concat\n+            then\n+               Set_Is_Dynamic_Coextension (N);\n+\n             else\n                Set_Is_Static_Coextension (N);\n             end if;"}]}