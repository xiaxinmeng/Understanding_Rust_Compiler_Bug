{"sha": "4a53743eda72f3cf49c3aadb2ac8fd5b3f105c37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE1Mzc0M2VkYTcyZjNjZjQ5YzNhYWRiMmFjOGZkNWIzZjEwNWMzNw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2013-03-25T16:50:02Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2013-03-25T16:50:02Z"}, "message": "ipa-prop.c (ipa_write_jump_function): Stream simple and aritmetic pass-through jump functions differently.\n\n2013-03-25  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.c (ipa_write_jump_function): Stream simple and aritmetic\n\tpass-through jump functions differently.\n\t(ipa_read_jump_function): Likewise.  Also use setter functions to set\n\tup jump functions.\n\nFrom-SVN: r197055", "tree": {"sha": "ef3f69bbb435d1727ee564541659378079458405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef3f69bbb435d1727ee564541659378079458405"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a53743eda72f3cf49c3aadb2ac8fd5b3f105c37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a53743eda72f3cf49c3aadb2ac8fd5b3f105c37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a53743eda72f3cf49c3aadb2ac8fd5b3f105c37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a53743eda72f3cf49c3aadb2ac8fd5b3f105c37/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "162712de00d6e234083e63c00b7a0570aa13a5e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162712de00d6e234083e63c00b7a0570aa13a5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/162712de00d6e234083e63c00b7a0570aa13a5e3"}], "stats": {"total": 86, "additions": 59, "deletions": 27}, "files": [{"sha": "044b5f6ff99d0a2a263d9b6b88e3de5a6c214adb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a53743eda72f3cf49c3aadb2ac8fd5b3f105c37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a53743eda72f3cf49c3aadb2ac8fd5b3f105c37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a53743eda72f3cf49c3aadb2ac8fd5b3f105c37", "patch": "@@ -1,3 +1,10 @@\n+2013-03-25  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.c (ipa_write_jump_function): Stream simple and aritmetic\n+\tpass-through jump functions differently.\n+\t(ipa_read_jump_function): Likewise.  Also use setter functions to set\n+\tup jump functions.\n+\n 2013-03-25  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-cp.c (ipa_get_indirect_edge_target): Renamed to"}, {"sha": "645bf5b243c86c68ece02e721c2d625dc36ba0e2", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a53743eda72f3cf49c3aadb2ac8fd5b3f105c37/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a53743eda72f3cf49c3aadb2ac8fd5b3f105c37/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=4a53743eda72f3cf49c3aadb2ac8fd5b3f105c37", "patch": "@@ -3277,12 +3277,19 @@ ipa_write_jump_function (struct output_block *ob,\n       stream_write_tree (ob, jump_func->value.constant, true);\n       break;\n     case IPA_JF_PASS_THROUGH:\n-      stream_write_tree (ob, jump_func->value.pass_through.operand, true);\n-      streamer_write_uhwi (ob, jump_func->value.pass_through.formal_id);\n       streamer_write_uhwi (ob, jump_func->value.pass_through.operation);\n-      bp = bitpack_create (ob->main_stream);\n-      bp_pack_value (&bp, jump_func->value.pass_through.agg_preserved, 1);\n-      streamer_write_bitpack (&bp);\n+      if (jump_func->value.pass_through.operation == NOP_EXPR)\n+\t{\n+\t  streamer_write_uhwi (ob, jump_func->value.pass_through.formal_id);\n+\t  bp = bitpack_create (ob->main_stream);\n+\t  bp_pack_value (&bp, jump_func->value.pass_through.agg_preserved, 1);\n+\t  streamer_write_bitpack (&bp);\n+\t}\n+      else\n+\t{\n+\t  stream_write_tree (ob, jump_func->value.pass_through.operand, true);\n+\t  streamer_write_uhwi (ob, jump_func->value.pass_through.formal_id);\n+\t}\n       break;\n     case IPA_JF_ANCESTOR:\n       streamer_write_uhwi (ob, jump_func->value.ancestor.offset);\n@@ -3317,45 +3324,63 @@ ipa_read_jump_function (struct lto_input_block *ib,\n \t\t\tstruct ipa_jump_func *jump_func,\n \t\t\tstruct data_in *data_in)\n {\n-  struct bitpack_d bp;\n+  enum jump_func_type jftype;\n+  enum tree_code operation;\n   int i, count;\n \n-  jump_func->type = (enum jump_func_type) streamer_read_uhwi (ib);\n-  switch (jump_func->type)\n+  jftype = (enum jump_func_type) streamer_read_uhwi (ib);\n+  switch (jftype)\n     {\n     case IPA_JF_UNKNOWN:\n+      jump_func->type = IPA_JF_UNKNOWN;\n       break;\n     case IPA_JF_KNOWN_TYPE:\n-      jump_func->value.known_type.offset = streamer_read_uhwi (ib);\n-      jump_func->value.known_type.base_type = stream_read_tree (ib, data_in);\n-      jump_func->value.known_type.component_type = stream_read_tree (ib,\n-\t\t\t\t\t\t\t\t     data_in);\n-      break;\n+      {\n+\tHOST_WIDE_INT offset = streamer_read_uhwi (ib);\n+\ttree base_type = stream_read_tree (ib, data_in);\n+\ttree component_type = stream_read_tree (ib, data_in);\n+\n+\tipa_set_jf_known_type (jump_func, offset, base_type, component_type);\n+\tbreak;\n+      }\n     case IPA_JF_CONST:\n-      jump_func->value.constant = stream_read_tree (ib, data_in);\n+      ipa_set_jf_constant (jump_func, stream_read_tree (ib, data_in));\n       break;\n     case IPA_JF_PASS_THROUGH:\n-      jump_func->value.pass_through.operand = stream_read_tree (ib, data_in);\n-      jump_func->value.pass_through.formal_id = streamer_read_uhwi (ib);\n-      jump_func->value.pass_through.operation\n-\t= (enum tree_code) streamer_read_uhwi (ib);\n-      bp = streamer_read_bitpack (ib);\n-      jump_func->value.pass_through.agg_preserved = bp_unpack_value (&bp, 1);\n+      operation = (enum tree_code) streamer_read_uhwi (ib);\n+      if (operation == NOP_EXPR)\n+\t{\n+\t  int formal_id =  streamer_read_uhwi (ib);\n+\t  struct bitpack_d bp = streamer_read_bitpack (ib);\n+\t  bool agg_preserved = bp_unpack_value (&bp, 1);\n+\t  ipa_set_jf_simple_pass_through (jump_func, formal_id, agg_preserved);\n+\t}\n+      else\n+\t{\n+\t  tree operand = stream_read_tree (ib, data_in);\n+\t  int formal_id =  streamer_read_uhwi (ib);\n+\t  ipa_set_jf_arith_pass_through (jump_func, formal_id, operand,\n+\t\t\t\t\t operation);\n+\t}\n       break;\n     case IPA_JF_ANCESTOR:\n-      jump_func->value.ancestor.offset = streamer_read_uhwi (ib);\n-      jump_func->value.ancestor.type = stream_read_tree (ib, data_in);\n-      jump_func->value.ancestor.formal_id = streamer_read_uhwi (ib);\n-      bp = streamer_read_bitpack (ib);\n-      jump_func->value.ancestor.agg_preserved = bp_unpack_value (&bp, 1);\n-      break;\n+      {\n+\tHOST_WIDE_INT offset = streamer_read_uhwi (ib);\n+\ttree type = stream_read_tree (ib, data_in);\n+\tint formal_id = streamer_read_uhwi (ib);\n+\tstruct bitpack_d bp = streamer_read_bitpack (ib);\n+\tbool agg_preserved = bp_unpack_value (&bp, 1);\n+\n+\tipa_set_ancestor_jf (jump_func, offset, type, formal_id, agg_preserved);\n+\tbreak;\n+      }\n     }\n \n   count = streamer_read_uhwi (ib);\n   vec_alloc (jump_func->agg.items, count);\n   if (count)\n     {\n-      bp = streamer_read_bitpack (ib);\n+      struct bitpack_d bp = streamer_read_bitpack (ib);\n       jump_func->agg.by_ref = bp_unpack_value (&bp, 1);\n     }\n   for (i = 0; i < count; i++)"}]}