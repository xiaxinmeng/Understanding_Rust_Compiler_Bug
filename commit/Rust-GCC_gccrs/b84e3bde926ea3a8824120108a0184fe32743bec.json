{"sha": "b84e3bde926ea3a8824120108a0184fe32743bec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg0ZTNiZGU5MjZlYTNhODgyNDEyMDEwOGEwMTg0ZmUzMjc0M2JlYw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-07-31T19:22:48Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-07-31T19:22:48Z"}, "message": "dumpfile.c: eliminate special-casing of dump_file/alt_dump_file\n\nWith the addition of optinfo, the various dump_* calls had three parts:\n- optionally print to dump_file\n- optionally print to alt_dump_file\n- optionally make an optinfo_item and add it to the pending optinfo,\n  creating it for dump_*_loc calls.\n\nHowever, this split makes it difficult to implement the formatted dumps\nlater in patch kit, so as enabling work towards that, this patch removes\nthe above split, so that all dumping within the dump_* API goes through\noptinfo_item.\n\nIn order to ensure that the dumps to dump_file and alt_dump_file are\nprocessed immediately (rather than being buffered within the pending\noptinfo for consolidation), this patch introduces the idea of \"immediate\"\noptinfo_item destinations vs \"non-immediate\" destinations.\n\nThe patch also adds selftest coverage of what's printed, and of scopes.\n\nThis adds two allocations per dump_* call when dumping is enabled.\nI'm assuming that this isn't a problem, as dump_enabled_p is normally\nfalse.  There are ways of optimizing it if it is an issue (by making\noptinfo_item instances become temporaries that borrow the underlying\nbuffer), but they require nontrivial changes, so I'd prefer to leave\nthat for another patch kit, if it becomes necessary.\n\ngcc/ChangeLog:\n\t* dump-context.h: Include \"pretty-print.h\".\n\t(dump_context::refresh_dumps_are_enabled): New decl.\n\t(dump_context::emit_item): New decl.\n\t(class dump_context): Add fields \"m_test_pp\" and\n\t\"m_test_pp_flags\".\n\t(temp_dump_context::temp_dump_context): Add param \"test_pp_flags\".\n\t(temp_dump_context::get_dumped_text): New decl.\n\t(class temp_dump_context): Add field \"m_pp\".\n\t* dumpfile.c (refresh_dumps_are_enabled): Convert to...\n\t(dump_context::refresh_dumps_are_enabled): ...and add a test for\n\tm_test_pp.\n\t(set_dump_file): Update for above change.\n\t(set_alt_dump_file): Likewise.\n\t(dump_loc): New overload, taking a pretty_printer *.\n\t(dump_context::dump_loc): Call end_any_optinfo.  Dump the location\n\tto any test pretty-printer.\n\t(make_item_for_dump_gimple_stmt): New function, adapted from\n\toptinfo::add_gimple_stmt.\n\t(dump_context::dump_gimple_stmt): Call it, and use the result,\n\teliminating the direct usage of dump_file and alt_dump_file in\n\tfavor of indirectly using them via emit_item.\n\t(make_item_for_dump_gimple_expr): New function, adapted from\n\toptinfo::add_gimple_expr.\n\t(dump_context::dump_gimple_expr): Call it, and use the result,\n\teliminating the direct usage of dump_file and alt_dump_file in\n\tfavor of indirectly using them via emit_item.\n\t(make_item_for_dump_generic_expr): New function, adapted from\n\toptinfo::add_tree.\n\t(dump_context::dump_generic_expr): Call it, and use the result,\n\teliminating the direct usage of dump_file and alt_dump_file in\n\tfavor of indirectly using them via emit_item.\n\t(make_item_for_dump_printf_va): New function, adapted from\n\toptinfo::add_printf_va.\n\t(make_item_for_dump_printf): New function.\n\t(dump_context::dump_printf_va): Call make_item_for_dump_printf_va,\n\tand use the result, eliminating the direct usage of dump_file and\n\talt_dump_file in favor of indirectly using them via emit_item.\n\t(make_item_for_dump_dec): New function.\n\t(dump_context::dump_dec): Call it, and use the result,\n\teliminating the direct usage of dump_file and alt_dump_file in\n\tfavor of indirectly using them via emit_item.\n\t(make_item_for_dump_symtab_node): New function, adapted from\n\toptinfo::add_symtab_node.\n\t(dump_context::dump_symtab_node): Call it, and use the result,\n\teliminating the direct usage of dump_file and alt_dump_file in\n\tfavor of indirectly using them via emit_item.\n\t(dump_context::begin_scope): Reimplement, avoiding direct usage\n\tof dump_file and alt_dump_file in favor of indirectly using them\n\tvia emit_item.\n\t(dump_context::emit_item): New member function.\n\t(temp_dump_context::temp_dump_context): Add param \"test_pp_flags\".\n\tSet up test pretty-printer on the underlying context.  Call\n\trefresh_dumps_are_enabled.\n\t(temp_dump_context::~temp_dump_context): Call\n\trefresh_dumps_are_enabled.\n\t(temp_dump_context::get_dumped_text): New member function.\n\t(selftest::verify_dumped_text): New function.\n\t(ASSERT_DUMPED_TEXT_EQ): New macro.\n\t(selftest::test_capture_of_dump_calls): Run all tests twice, with\n\tand then without optinfo enabled.  Add uses of\n\tASSERT_DUMPED_TEXT_EQ to all tests.  Add test of nested scopes.\n\t* dumpfile.h: Update comment for the dump_* API.\n\t* optinfo-emit-json.cc\n\t(selftest::test_building_json_from_dump_calls): Update for new\n\tparam for temp_dump_context ctor.\n\t* optinfo.cc (optinfo_item::optinfo_item): Remove \"owned\" param\n\tand \"m_owned\" field.\n\t(optinfo_item::~optinfo_item): Likewise.\n\t(optinfo::add_item): New member function.\n\t(optinfo::emit): Update comment.\n\t(optinfo::add_string): Delete.\n\t(optinfo::add_printf): Delete.\n\t(optinfo::add_printf_va): Delete.\n\t(optinfo::add_gimple_stmt): Delete.\n\t(optinfo::add_gimple_expr): Delete.\n\t(optinfo::add_tree): Delete.\n\t(optinfo::add_symtab_node): Delete.\n\t(optinfo::add_dec): Delete.\n\t* optinfo.h (class dump_context): New forward decl.\n\t(optinfo::add_item): New decl.\n\t(optinfo::add_string): Delete.\n\t(optinfo::add_printf): Delete.\n\t(optinfo::add_printf_va): Delete.\n\t(optinfo::add_gimple_stmt): Delete.\n\t(optinfo::add_gimple_expr): Delete.\n\t(optinfo::add_tree): Delete.\n\t(optinfo::add_symtab_node): Delete.\n\t(optinfo::add_dec): Delete.\n\t(optinfo::add_poly_int): Delete.\n\t(optinfo_item::optinfo_item): Remove \"owned\" param.\n\t(class optinfo_item): Remove field \"m_owned\".\n\nFrom-SVN: r263178", "tree": {"sha": "6480c9f6b8d02e58bb2b18fc96cb22b71bcaad64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6480c9f6b8d02e58bb2b18fc96cb22b71bcaad64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b84e3bde926ea3a8824120108a0184fe32743bec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b84e3bde926ea3a8824120108a0184fe32743bec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b84e3bde926ea3a8824120108a0184fe32743bec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b84e3bde926ea3a8824120108a0184fe32743bec/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b06e1dcec5e7e29d12988dc8d2a6d4183f6c91df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b06e1dcec5e7e29d12988dc8d2a6d4183f6c91df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b06e1dcec5e7e29d12988dc8d2a6d4183f6c91df"}], "stats": {"total": 939, "additions": 599, "deletions": 340}, "files": [{"sha": "b5536323af06e2ccb2b81164ae4a684c034d4c91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b84e3bde926ea3a8824120108a0184fe32743bec", "patch": "@@ -1,3 +1,97 @@\n+2018-07-31  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* dump-context.h: Include \"pretty-print.h\".\n+\t(dump_context::refresh_dumps_are_enabled): New decl.\n+\t(dump_context::emit_item): New decl.\n+\t(class dump_context): Add fields \"m_test_pp\" and\n+\t\"m_test_pp_flags\".\n+\t(temp_dump_context::temp_dump_context): Add param \"test_pp_flags\".\n+\t(temp_dump_context::get_dumped_text): New decl.\n+\t(class temp_dump_context): Add field \"m_pp\".\n+\t* dumpfile.c (refresh_dumps_are_enabled): Convert to...\n+\t(dump_context::refresh_dumps_are_enabled): ...and add a test for\n+\tm_test_pp.\n+\t(set_dump_file): Update for above change.\n+\t(set_alt_dump_file): Likewise.\n+\t(dump_loc): New overload, taking a pretty_printer *.\n+\t(dump_context::dump_loc): Call end_any_optinfo.  Dump the location\n+\tto any test pretty-printer.\n+\t(make_item_for_dump_gimple_stmt): New function, adapted from\n+\toptinfo::add_gimple_stmt.\n+\t(dump_context::dump_gimple_stmt): Call it, and use the result,\n+\teliminating the direct usage of dump_file and alt_dump_file in\n+\tfavor of indirectly using them via emit_item.\n+\t(make_item_for_dump_gimple_expr): New function, adapted from\n+\toptinfo::add_gimple_expr.\n+\t(dump_context::dump_gimple_expr): Call it, and use the result,\n+\teliminating the direct usage of dump_file and alt_dump_file in\n+\tfavor of indirectly using them via emit_item.\n+\t(make_item_for_dump_generic_expr): New function, adapted from\n+\toptinfo::add_tree.\n+\t(dump_context::dump_generic_expr): Call it, and use the result,\n+\teliminating the direct usage of dump_file and alt_dump_file in\n+\tfavor of indirectly using them via emit_item.\n+\t(make_item_for_dump_printf_va): New function, adapted from\n+\toptinfo::add_printf_va.\n+\t(make_item_for_dump_printf): New function.\n+\t(dump_context::dump_printf_va): Call make_item_for_dump_printf_va,\n+\tand use the result, eliminating the direct usage of dump_file and\n+\talt_dump_file in favor of indirectly using them via emit_item.\n+\t(make_item_for_dump_dec): New function.\n+\t(dump_context::dump_dec): Call it, and use the result,\n+\teliminating the direct usage of dump_file and alt_dump_file in\n+\tfavor of indirectly using them via emit_item.\n+\t(make_item_for_dump_symtab_node): New function, adapted from\n+\toptinfo::add_symtab_node.\n+\t(dump_context::dump_symtab_node): Call it, and use the result,\n+\teliminating the direct usage of dump_file and alt_dump_file in\n+\tfavor of indirectly using them via emit_item.\n+\t(dump_context::begin_scope): Reimplement, avoiding direct usage\n+\tof dump_file and alt_dump_file in favor of indirectly using them\n+\tvia emit_item.\n+\t(dump_context::emit_item): New member function.\n+\t(temp_dump_context::temp_dump_context): Add param \"test_pp_flags\".\n+\tSet up test pretty-printer on the underlying context.  Call\n+\trefresh_dumps_are_enabled.\n+\t(temp_dump_context::~temp_dump_context): Call\n+\trefresh_dumps_are_enabled.\n+\t(temp_dump_context::get_dumped_text): New member function.\n+\t(selftest::verify_dumped_text): New function.\n+\t(ASSERT_DUMPED_TEXT_EQ): New macro.\n+\t(selftest::test_capture_of_dump_calls): Run all tests twice, with\n+\tand then without optinfo enabled.  Add uses of\n+\tASSERT_DUMPED_TEXT_EQ to all tests.  Add test of nested scopes.\n+\t* dumpfile.h: Update comment for the dump_* API.\n+\t* optinfo-emit-json.cc\n+\t(selftest::test_building_json_from_dump_calls): Update for new\n+\tparam for temp_dump_context ctor.\n+\t* optinfo.cc (optinfo_item::optinfo_item): Remove \"owned\" param\n+\tand \"m_owned\" field.\n+\t(optinfo_item::~optinfo_item): Likewise.\n+\t(optinfo::add_item): New member function.\n+\t(optinfo::emit): Update comment.\n+\t(optinfo::add_string): Delete.\n+\t(optinfo::add_printf): Delete.\n+\t(optinfo::add_printf_va): Delete.\n+\t(optinfo::add_gimple_stmt): Delete.\n+\t(optinfo::add_gimple_expr): Delete.\n+\t(optinfo::add_tree): Delete.\n+\t(optinfo::add_symtab_node): Delete.\n+\t(optinfo::add_dec): Delete.\n+\t* optinfo.h (class dump_context): New forward decl.\n+\t(optinfo::add_item): New decl.\n+\t(optinfo::add_string): Delete.\n+\t(optinfo::add_printf): Delete.\n+\t(optinfo::add_printf_va): Delete.\n+\t(optinfo::add_gimple_stmt): Delete.\n+\t(optinfo::add_gimple_expr): Delete.\n+\t(optinfo::add_tree): Delete.\n+\t(optinfo::add_symtab_node): Delete.\n+\t(optinfo::add_dec): Delete.\n+\t(optinfo::add_poly_int): Delete.\n+\t(optinfo_item::optinfo_item): Remove \"owned\" param.\n+\t(class optinfo_item): Remove field \"m_owned\".\n+\n 2018-07-31  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \tPR middle-end/86705"}, {"sha": "f40ea14d2dccedbb69ade1b0a689a0fff315fe6f", "filename": "gcc/dump-context.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Fdump-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Fdump-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdump-context.h?ref=b84e3bde926ea3a8824120108a0184fe32743bec", "patch": "@@ -22,6 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_DUMP_CONTEXT_H\n #define GCC_DUMP_CONTEXT_H 1\n \n+#include \"pretty-print.h\"\n+\n /* A class for handling the various dump_* calls.\n \n    In particular, this class has responsibility for consolidating\n@@ -39,6 +41,8 @@ class dump_context\n \n   ~dump_context ();\n \n+  void refresh_dumps_are_enabled ();\n+\n   void dump_loc (dump_flags_t dump_kind, const dump_location_t &loc);\n \n   void dump_gimple_stmt (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n@@ -93,6 +97,8 @@ class dump_context\n \n   void end_any_optinfo ();\n \n+  void emit_item (optinfo_item *item, dump_flags_t dump_kind);\n+\n  private:\n   optinfo &ensure_pending_optinfo ();\n   optinfo &begin_next_optinfo (const dump_location_t &loc);\n@@ -108,6 +114,11 @@ class dump_context\n      if any.  */\n   optinfo *m_pending;\n \n+  /* For use in selftests: if non-NULL, then items are to be printed\n+     to this, using the given flags.  */\n+  pretty_printer *m_test_pp;\n+  dump_flags_t m_test_pp_flags;\n+\n   /* The currently active dump_context, for use by the dump_* API calls.  */\n   static dump_context *s_current;\n \n@@ -123,13 +134,16 @@ class dump_context\n class temp_dump_context\n {\n  public:\n-  temp_dump_context (bool forcibly_enable_optinfo);\n+  temp_dump_context (bool forcibly_enable_optinfo,\n+\t\t     dump_flags_t test_pp_flags);\n   ~temp_dump_context ();\n \n   /* Support for selftests.  */\n   optinfo *get_pending_optinfo () const { return m_context.m_pending; }\n+  const char *get_dumped_text ();\n \n  private:\n+  pretty_printer m_pp;\n   dump_context m_context;\n   dump_context *m_saved;\n   bool m_saved_flag_remarks;"}, {"sha": "10e9cabc6fa5793c91cce68735f7988149bbb74f", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 447, "deletions": 173, "changes": 620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=b84e3bde926ea3a8824120108a0184fe32743bec", "patch": "@@ -63,15 +63,6 @@ dump_flags_t dump_flags;\n bool dumps_are_enabled = false;\n \n \n-/* Update the \"dumps_are_enabled\" global; to be called whenever dump_file\n-   or alt_dump_file change.  */\n-\n-static void\n-refresh_dumps_are_enabled ()\n-{\n-  dumps_are_enabled = (dump_file || alt_dump_file || optinfo_enabled_p ());\n-}\n-\n /* Set global \"dump_file\" to NEW_DUMP_FILE, refreshing the \"dumps_are_enabled\"\n    global.  */\n \n@@ -80,7 +71,7 @@ set_dump_file (FILE *new_dump_file)\n {\n   dumpfile_ensure_any_optinfo_are_flushed ();\n   dump_file = new_dump_file;\n-  refresh_dumps_are_enabled ();\n+  dump_context::get ().refresh_dumps_are_enabled ();\n }\n \n /* Set \"alt_dump_file\" to NEW_ALT_DUMP_FILE, refreshing the \"dumps_are_enabled\"\n@@ -91,7 +82,7 @@ set_alt_dump_file (FILE *new_alt_dump_file)\n {\n   dumpfile_ensure_any_optinfo_are_flushed ();\n   alt_dump_file = new_alt_dump_file;\n-  refresh_dumps_are_enabled ();\n+  dump_context::get ().refresh_dumps_are_enabled ();\n }\n \n #define DUMP_FILE_INFO(suffix, swtch, dkind, num) \\\n@@ -465,6 +456,27 @@ dump_loc (dump_flags_t dump_kind, FILE *dfile, source_location loc)\n     }\n }\n \n+/* Print source location to PP if enabled.  */\n+\n+static void\n+dump_loc (dump_flags_t dump_kind, pretty_printer *pp, source_location loc)\n+{\n+  if (dump_kind)\n+    {\n+      if (LOCATION_LOCUS (loc) > BUILTINS_LOCATION)\n+\tpp_printf (pp, \"%s:%d:%d: note: \", LOCATION_FILE (loc),\n+\t\t   LOCATION_LINE (loc), LOCATION_COLUMN (loc));\n+      else if (current_function_decl)\n+\tpp_printf (pp, \"%s:%d:%d: note: \",\n+\t\t   DECL_SOURCE_FILE (current_function_decl),\n+\t\t   DECL_SOURCE_LINE (current_function_decl),\n+\t\t   DECL_SOURCE_COLUMN (current_function_decl));\n+      /* Indentation based on scope depth.  */\n+      for (unsigned i = 0; i < get_dump_scope_depth (); i++)\n+\tpp_character (pp, ' ');\n+    }\n+}\n+\n /* Implementation of dump_context member functions.  */\n \n /* dump_context's dtor.  */\n@@ -474,12 +486,24 @@ dump_context::~dump_context ()\n   delete m_pending;\n }\n \n+/* Update the \"dumps_are_enabled\" global; to be called whenever dump_file\n+   or alt_dump_file change, or when changing dump_context in selftests.  */\n+\n+void\n+dump_context::refresh_dumps_are_enabled ()\n+{\n+  dumps_are_enabled = (dump_file || alt_dump_file || optinfo_enabled_p ()\n+\t\t       || m_test_pp);\n+}\n+\n /* Print LOC to the appropriate dump destinations, given DUMP_KIND.\n    If optinfos are enabled, begin a new optinfo.  */\n \n void\n dump_context::dump_loc (dump_flags_t dump_kind, const dump_location_t &loc)\n {\n+  end_any_optinfo ();\n+\n   location_t srcloc = loc.get_location_t ();\n \n   if (dump_file && (dump_kind & pflags))\n@@ -488,13 +512,33 @@ dump_context::dump_loc (dump_flags_t dump_kind, const dump_location_t &loc)\n   if (alt_dump_file && (dump_kind & alt_flags))\n     ::dump_loc (dump_kind, alt_dump_file, srcloc);\n \n+  /* Support for temp_dump_context in selftests.  */\n+  if (m_test_pp && (dump_kind & m_test_pp_flags))\n+    ::dump_loc (dump_kind, m_test_pp, srcloc);\n+\n   if (optinfo_enabled_p ())\n     {\n       optinfo &info = begin_next_optinfo (loc);\n       info.handle_dump_file_kind (dump_kind);\n     }\n }\n \n+/* Make an item for the given dump call, equivalent to print_gimple_stmt.  */\n+\n+static optinfo_item *\n+make_item_for_dump_gimple_stmt (gimple *stmt, int spc, dump_flags_t dump_flags)\n+{\n+  pretty_printer pp;\n+  pp_needs_newline (&pp) = true;\n+  pp_gimple_stmt_1 (&pp, stmt, spc, dump_flags);\n+  pp_newline (&pp);\n+\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_GIMPLE, gimple_location (stmt),\n+\t\t\txstrdup (pp_formatted_text (&pp)));\n+  return item;\n+}\n+\n /* Dump gimple statement GS with SPC indentation spaces and\n    EXTRA_DUMP_FLAGS on the dump streams if DUMP_KIND is enabled.  */\n \n@@ -503,18 +547,18 @@ dump_context::dump_gimple_stmt (dump_flags_t dump_kind,\n \t\t\t\tdump_flags_t extra_dump_flags,\n \t\t\t\tgimple *gs, int spc)\n {\n-  if (dump_file && (dump_kind & pflags))\n-    print_gimple_stmt (dump_file, gs, spc, dump_flags | extra_dump_flags);\n-\n-  if (alt_dump_file && (dump_kind & alt_flags))\n-    print_gimple_stmt (alt_dump_file, gs, spc, dump_flags | extra_dump_flags);\n+  optinfo_item *item\n+    = make_item_for_dump_gimple_stmt (gs, spc, dump_flags | extra_dump_flags);\n+  emit_item (item, dump_kind);\n \n   if (optinfo_enabled_p ())\n     {\n       optinfo &info = ensure_pending_optinfo ();\n       info.handle_dump_file_kind (dump_kind);\n-      info.add_gimple_stmt (gs, spc, dump_flags | extra_dump_flags);\n+      info.add_item (item);\n     }\n+  else\n+    delete item;\n }\n \n /* Similar to dump_gimple_stmt, except additionally print source location.  */\n@@ -529,6 +573,22 @@ dump_context::dump_gimple_stmt_loc (dump_flags_t dump_kind,\n   dump_gimple_stmt (dump_kind, extra_dump_flags, gs, spc);\n }\n \n+/* Make an item for the given dump call, equivalent to print_gimple_expr.  */\n+\n+static optinfo_item *\n+make_item_for_dump_gimple_expr (gimple *stmt, int spc, dump_flags_t dump_flags)\n+{\n+  dump_flags |= TDF_RHS_ONLY;\n+  pretty_printer pp;\n+  pp_needs_newline (&pp) = true;\n+  pp_gimple_stmt_1 (&pp, stmt, spc, dump_flags);\n+\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_GIMPLE, gimple_location (stmt),\n+\t\t\txstrdup (pp_formatted_text (&pp)));\n+  return item;\n+}\n+\n /* Dump gimple statement GS with SPC indentation spaces and\n    EXTRA_DUMP_FLAGS on the dump streams if DUMP_KIND is enabled.\n    Do not terminate with a newline or semicolon.  */\n@@ -538,18 +598,18 @@ dump_context::dump_gimple_expr (dump_flags_t dump_kind,\n \t\t\t\tdump_flags_t extra_dump_flags,\n \t\t\t\tgimple *gs, int spc)\n {\n-  if (dump_file && (dump_kind & pflags))\n-    print_gimple_expr (dump_file, gs, spc, dump_flags | extra_dump_flags);\n-\n-  if (alt_dump_file && (dump_kind & alt_flags))\n-    print_gimple_expr (alt_dump_file, gs, spc, dump_flags | extra_dump_flags);\n+  optinfo_item *item\n+    = make_item_for_dump_gimple_expr (gs, spc, dump_flags | extra_dump_flags);\n+  emit_item (item, dump_kind);\n \n   if (optinfo_enabled_p ())\n     {\n       optinfo &info = ensure_pending_optinfo ();\n       info.handle_dump_file_kind (dump_kind);\n-      info.add_gimple_expr (gs, spc, dump_flags | extra_dump_flags);\n+      info.add_item (item);\n     }\n+  else\n+    delete item;\n }\n \n /* Similar to dump_gimple_expr, except additionally print source location.  */\n@@ -565,6 +625,25 @@ dump_context::dump_gimple_expr_loc (dump_flags_t dump_kind,\n   dump_gimple_expr (dump_kind, extra_dump_flags, gs, spc);\n }\n \n+/* Make an item for the given dump call, equivalent to print_generic_expr.  */\n+\n+static optinfo_item *\n+make_item_for_dump_generic_expr (tree node, dump_flags_t dump_flags)\n+{\n+  pretty_printer pp;\n+  pp_needs_newline (&pp) = true;\n+  pp_translate_identifiers (&pp) = false;\n+  dump_generic_node (&pp, node, 0, dump_flags, false);\n+\n+  location_t loc = UNKNOWN_LOCATION;\n+  if (EXPR_HAS_LOCATION (node))\n+    loc = EXPR_LOCATION (node);\n+\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_TREE, loc,\n+\t\t\txstrdup (pp_formatted_text (&pp)));\n+  return item;\n+}\n \n /* Dump expression tree T using EXTRA_DUMP_FLAGS on dump streams if\n    DUMP_KIND is enabled.  */\n@@ -574,18 +653,18 @@ dump_context::dump_generic_expr (dump_flags_t dump_kind,\n \t\t\t\t dump_flags_t extra_dump_flags,\n \t\t\t\t tree t)\n {\n-  if (dump_file && (dump_kind & pflags))\n-      print_generic_expr (dump_file, t, dump_flags | extra_dump_flags);\n-\n-  if (alt_dump_file && (dump_kind & alt_flags))\n-      print_generic_expr (alt_dump_file, t, dump_flags | extra_dump_flags);\n+  optinfo_item *item\n+    = make_item_for_dump_generic_expr (t, dump_flags | extra_dump_flags);\n+  emit_item (item, dump_kind);\n \n   if (optinfo_enabled_p ())\n     {\n       optinfo &info = ensure_pending_optinfo ();\n       info.handle_dump_file_kind (dump_kind);\n-      info.add_tree (t, dump_flags | extra_dump_flags);\n+      info.add_item (item);\n     }\n+  else\n+    delete item;\n }\n \n \n@@ -602,36 +681,56 @@ dump_context::dump_generic_expr_loc (dump_flags_t dump_kind,\n   dump_generic_expr (dump_kind, extra_dump_flags, t);\n }\n \n+/* Make an item for the given dump call.  */\n+\n+static optinfo_item *\n+make_item_for_dump_printf_va (const char *format, va_list ap)\n+  ATTRIBUTE_PRINTF (1, 0);\n+\n+static optinfo_item *\n+make_item_for_dump_printf_va (const char *format, va_list ap)\n+{\n+  char *formatted_text = xvasprintf (format, ap);\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_TEXT, UNKNOWN_LOCATION,\n+\t\t\tformatted_text);\n+  return item;\n+}\n+\n+/* Make an item for the given dump call.  */\n+\n+static optinfo_item *\n+make_item_for_dump_printf (const char *format, ...)\n+  ATTRIBUTE_PRINTF (1, 2);\n+\n+static optinfo_item *\n+make_item_for_dump_printf (const char *format, ...)\n+{\n+  va_list ap;\n+  va_start (ap, format);\n+  optinfo_item *item\n+    = make_item_for_dump_printf_va (format, ap);\n+  va_end (ap);\n+  return item;\n+}\n+\n /* Output a formatted message using FORMAT on appropriate dump streams.  */\n \n void\n dump_context::dump_printf_va (dump_flags_t dump_kind, const char *format,\n \t\t\t      va_list ap)\n {\n-  if (dump_file && (dump_kind & pflags))\n-    {\n-      va_list aq;\n-      va_copy (aq, ap);\n-      vfprintf (dump_file, format, aq);\n-      va_end (aq);\n-    }\n-\n-  if (alt_dump_file && (dump_kind & alt_flags))\n-    {\n-      va_list aq;\n-      va_copy (aq, ap);\n-      vfprintf (alt_dump_file, format, aq);\n-      va_end (aq);\n-    }\n+  optinfo_item *item = make_item_for_dump_printf_va (format, ap);\n+  emit_item (item, dump_kind);\n \n   if (optinfo_enabled_p ())\n     {\n       optinfo &info = ensure_pending_optinfo ();\n-      va_list aq;\n-      va_copy (aq, ap);\n-      info.add_printf_va (format, aq);\n-      va_end (aq);\n+      info.handle_dump_file_kind (dump_kind);\n+      info.add_item (item);\n     }\n+  else\n+    delete item;\n }\n \n /* Similar to dump_printf, except source location is also printed, and\n@@ -646,45 +745,82 @@ dump_context::dump_printf_loc_va (dump_flags_t dump_kind,\n   dump_printf_va (dump_kind, format, ap);\n }\n \n-/* Output VALUE in decimal to appropriate dump streams.  */\n+/* Make an item for the given dump call, equivalent to print_dec.  */\n \n template<unsigned int N, typename C>\n-void\n-dump_context::dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value)\n+static optinfo_item *\n+make_item_for_dump_dec (const poly_int<N, C> &value)\n {\n   STATIC_ASSERT (poly_coeff_traits<C>::signedness >= 0);\n   signop sgn = poly_coeff_traits<C>::signedness ? SIGNED : UNSIGNED;\n-  if (dump_file && (dump_kind & pflags))\n-    print_dec (value, dump_file, sgn);\n \n-  if (alt_dump_file && (dump_kind & alt_flags))\n-    print_dec (value, alt_dump_file, sgn);\n+  pretty_printer pp;\n+\n+  if (value.is_constant ())\n+    pp_wide_int (&pp, value.coeffs[0], sgn);\n+  else\n+    {\n+      pp_character (&pp, '[');\n+      for (unsigned int i = 0; i < N; ++i)\n+\t{\n+\t  pp_wide_int (&pp, value.coeffs[i], sgn);\n+\t  pp_character (&pp, i == N - 1 ? ']' : ',');\n+\t}\n+    }\n+\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_TEXT, UNKNOWN_LOCATION,\n+\t\t\txstrdup (pp_formatted_text (&pp)));\n+  return item;\n+}\n+\n+/* Output VALUE in decimal to appropriate dump streams.  */\n+\n+template<unsigned int N, typename C>\n+void\n+dump_context::dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value)\n+{\n+  optinfo_item *item = make_item_for_dump_dec (value);\n+  emit_item (item, dump_kind);\n \n   if (optinfo_enabled_p ())\n     {\n       optinfo &info = ensure_pending_optinfo ();\n       info.handle_dump_file_kind (dump_kind);\n-      info.add_poly_int<N,C> (value);\n+      info.add_item (item);\n     }\n+  else\n+    delete item;\n+}\n+\n+/* Make an item for the given dump call.  */\n+\n+static optinfo_item *\n+make_item_for_dump_symtab_node (symtab_node *node)\n+{\n+  location_t loc = DECL_SOURCE_LOCATION (node->decl);\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_SYMTAB_NODE, loc,\n+\t\t\txstrdup (node->dump_name ()));\n+  return item;\n }\n \n /* Output the name of NODE on appropriate dump streams.  */\n \n void\n dump_context::dump_symtab_node (dump_flags_t dump_kind, symtab_node *node)\n {\n-  if (dump_file && (dump_kind & pflags))\n-    fprintf (dump_file, \"%s\", node->dump_name ());\n-\n-  if (alt_dump_file && (dump_kind & alt_flags))\n-    fprintf (alt_dump_file, \"%s\", node->dump_name ());\n+  optinfo_item *item = make_item_for_dump_symtab_node (node);\n+  emit_item (item, dump_kind);\n \n   if (optinfo_enabled_p ())\n     {\n       optinfo &info = ensure_pending_optinfo ();\n       info.handle_dump_file_kind (dump_kind);\n-      info.add_symtab_node (node);\n+      info.add_item (item);\n     }\n+  else\n+    delete item;\n }\n \n /* Get the current dump scope-nesting depth.\n@@ -705,28 +841,28 @@ dump_context::get_scope_depth () const\n void\n dump_context::begin_scope (const char *name, const dump_location_t &loc)\n {\n-  /* Specialcase, to avoid going through dump_printf_loc,\n-     so that we can create a optinfo of kind OPTINFO_KIND_SCOPE.  */\n-\n   if (dump_file)\n-    {\n-      ::dump_loc (MSG_NOTE, dump_file, loc.get_location_t ());\n-      fprintf (dump_file, \"=== %s ===\\n\", name);\n-    }\n+    ::dump_loc (MSG_NOTE, dump_file, loc.get_location_t ());\n \n   if (alt_dump_file)\n-    {\n-      ::dump_loc (MSG_NOTE, alt_dump_file, loc.get_location_t ());\n-      fprintf (alt_dump_file, \"=== %s ===\\n\", name);\n-    }\n+    ::dump_loc (MSG_NOTE, alt_dump_file, loc.get_location_t ());\n+\n+  /* Support for temp_dump_context in selftests.  */\n+  if (m_test_pp)\n+    ::dump_loc (MSG_NOTE, m_test_pp, loc.get_location_t ());\n+\n+  optinfo_item *item = make_item_for_dump_printf (\"=== %s ===\\n\", name);\n+  emit_item (item, MSG_NOTE);\n \n   if (optinfo_enabled_p ())\n     {\n+      optinfo &info = begin_next_optinfo (loc);\n+      info.m_kind = OPTINFO_KIND_SCOPE;\n+      info.add_item (item);\n       end_any_optinfo ();\n-      optinfo info (loc, OPTINFO_KIND_SCOPE, current_pass);\n-      info.add_printf (\"=== %s ===\", name);\n-      info.emit ();\n     }\n+  else\n+    delete item;\n \n   m_scope_depth++;\n }\n@@ -776,6 +912,23 @@ dump_context::end_any_optinfo ()\n   m_pending = NULL;\n }\n \n+/* Emit ITEM to all item destinations (those that don't require\n+   consolidation into optinfo instances).  */\n+\n+void\n+dump_context::emit_item (optinfo_item *item, dump_flags_t dump_kind)\n+{\n+  if (dump_file && (dump_kind & pflags))\n+    fprintf (dump_file, \"%s\", item->get_text ());\n+\n+  if (alt_dump_file && (dump_kind & alt_flags))\n+    fprintf (alt_dump_file, \"%s\", item->get_text ());\n+\n+  /* Support for temp_dump_context in selftests.  */\n+  if (m_test_pp && (dump_kind & m_test_pp_flags))\n+    pp_string (m_test_pp, item->get_text ());\n+}\n+\n /* The current singleton dump_context, and its default.  */\n \n dump_context *dump_context::s_current = &dump_context::s_default;\n@@ -1510,19 +1663,35 @@ enable_rtl_dump_file (void)\n /* temp_dump_context's ctor.  Temporarily override the dump_context\n    (to forcibly enable optinfo-generation).  */\n \n-temp_dump_context::temp_dump_context (bool forcibly_enable_optinfo)\n+temp_dump_context::temp_dump_context (bool forcibly_enable_optinfo,\n+\t\t\t\t      dump_flags_t test_pp_flags)\n+\n : m_context (),\n   m_saved (&dump_context ().get ())\n {\n   dump_context::s_current = &m_context;\n   m_context.m_forcibly_enable_optinfo = forcibly_enable_optinfo;\n+  m_context.m_test_pp = &m_pp;\n+  m_context.m_test_pp_flags = test_pp_flags;\n+\n+  dump_context::get ().refresh_dumps_are_enabled ();\n }\n \n /* temp_dump_context's dtor.  Restore the saved dump_context.  */\n \n temp_dump_context::~temp_dump_context ()\n {\n   dump_context::s_current = m_saved;\n+\n+  dump_context::get ().refresh_dumps_are_enabled ();\n+}\n+\n+/* 0-terminate the text dumped so far, and return it.  */\n+\n+const char *\n+temp_dump_context::get_dumped_text ()\n+{\n+  return pp_formatted_text (&m_pp);\n }\n \n namespace selftest {\n@@ -1561,6 +1730,29 @@ test_impl_location ()\n #endif\n }\n \n+/* Verify that the text dumped so far in CONTEXT equals\n+   EXPECTED_TEXT, using LOC for the location of any failure.\n+   As a side-effect, the internal buffer is 0-terminated.  */\n+\n+static void\n+verify_dumped_text (const location &loc,\n+\t\t    temp_dump_context *context,\n+\t\t    const char *expected_text)\n+{\n+  gcc_assert (context);\n+  ASSERT_STREQ_AT (loc, context->get_dumped_text (),\n+\t\t   expected_text);\n+}\n+\n+/* Verify that the text dumped so far in CONTEXT equals\n+   EXPECTED_TEXT.\n+   As a side-effect, the internal buffer is 0-terminated.  */\n+\n+#define ASSERT_DUMPED_TEXT_EQ(CONTEXT, EXPECTED_TEXT)\t\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    verify_dumped_text (SELFTEST_LOCATION, &(CONTEXT), (EXPECTED_TEXT)); \\\n+  SELFTEST_END_STMT\n+\n /* Verify that ITEM has the expected values.  */\n \n static void\n@@ -1611,124 +1803,206 @@ test_capture_of_dump_calls (const line_table_case &case_)\n   linemap_line_start (line_table, 5, 100);\n   linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n   location_t where = linemap_position_for_column (line_table, 10);\n+  if (where > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n \n   dump_location_t loc = dump_location_t::from_location_t (where);\n \n-  /* Test of dump_printf.  */\n-  {\n-    temp_dump_context tmp (true);\n-    dump_printf (MSG_NOTE, \"int: %i str: %s\", 42, \"foo\");\n-\n-    optinfo *info = tmp.get_pending_optinfo ();\n-    ASSERT_TRUE (info != NULL);\n-    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n-    ASSERT_EQ (info->num_items (), 1);\n-    ASSERT_IS_TEXT (info->get_item (0), \"int: 42 str: foo\");\n-  }\n-\n-  /* Tree, via dump_generic_expr.  */\n-  {\n-    temp_dump_context tmp (true);\n-    dump_printf_loc (MSG_NOTE, loc, \"test of tree: \");\n-    dump_generic_expr (MSG_NOTE, TDF_SLIM, integer_zero_node);\n-\n-    optinfo *info = tmp.get_pending_optinfo ();\n-    ASSERT_TRUE (info != NULL);\n-    ASSERT_EQ (info->get_location_t (), where);\n-    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n-    ASSERT_EQ (info->num_items (), 2);\n-    ASSERT_IS_TEXT (info->get_item (0), \"test of tree: \");\n-    ASSERT_IS_TREE (info->get_item (1), UNKNOWN_LOCATION, \"0\");\n-  }\n-\n-  /* Tree, via dump_generic_expr_loc.  */\n-  {\n-    temp_dump_context tmp (true);\n-    dump_generic_expr_loc (MSG_NOTE, loc, TDF_SLIM, integer_one_node);\n-\n-    optinfo *info = tmp.get_pending_optinfo ();\n-    ASSERT_TRUE (info != NULL);\n-    ASSERT_EQ (info->get_location_t (), where);\n-    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n-    ASSERT_EQ (info->num_items (), 1);\n-    ASSERT_IS_TREE (info->get_item (0), UNKNOWN_LOCATION, \"1\");\n-  }\n-\n-  /* Gimple.  */\n-  {\n-    greturn *stmt = gimple_build_return (NULL);\n-    gimple_set_location (stmt, where);\n-\n-    /* dump_gimple_stmt_loc.  */\n-    {\n-      temp_dump_context tmp (true);\n-      dump_gimple_stmt_loc (MSG_NOTE, loc, TDF_SLIM, stmt, 2);\n-\n-      optinfo *info = tmp.get_pending_optinfo ();\n-      ASSERT_TRUE (info != NULL);\n-      ASSERT_EQ (info->num_items (), 1);\n-      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\\n\");\n-    }\n-\n-    /* dump_gimple_stmt.  */\n-    {\n-      temp_dump_context tmp (true);\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 2);\n+  greturn *stmt = gimple_build_return (NULL);\n+  gimple_set_location (stmt, where);\n \n-      optinfo *info = tmp.get_pending_optinfo ();\n-      ASSERT_TRUE (info != NULL);\n-      ASSERT_EQ (info->num_items (), 1);\n-      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\\n\");\n-    }\n-\n-    /* dump_gimple_expr_loc.  */\n+  /* Run all tests twice, with and then without optinfo enabled, to ensure\n+     that immediate destinations vs optinfo-based destinations both\n+     work, independently of each other, with no leaks.  */\n+  for (int i = 0 ; i < 2; i++)\n     {\n-      temp_dump_context tmp (true);\n-      dump_gimple_expr_loc (MSG_NOTE, loc, TDF_SLIM, stmt, 2);\n+      bool with_optinfo = (i == 0);\n+\n+      /* Test of dump_printf.  */\n+      {\n+\ttemp_dump_context tmp (with_optinfo, MSG_ALL);\n+\tdump_printf (MSG_NOTE, \"int: %i str: %s\", 42, \"foo\");\n+\n+\tASSERT_DUMPED_TEXT_EQ (tmp, \"int: 42 str: foo\");\n+\tif (with_optinfo)\n+\t  {\n+\t    optinfo *info = tmp.get_pending_optinfo ();\n+\t    ASSERT_TRUE (info != NULL);\n+\t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+\t    ASSERT_EQ (info->num_items (), 1);\n+\t    ASSERT_IS_TEXT (info->get_item (0), \"int: 42 str: foo\");\n+\t  }\n+      }\n+\n+      /* Tree, via dump_generic_expr.  */\n+      {\n+\ttemp_dump_context tmp (with_optinfo, MSG_ALL);\n+\tdump_printf_loc (MSG_NOTE, loc, \"test of tree: \");\n+\tdump_generic_expr (MSG_NOTE, TDF_SLIM, integer_zero_node);\n+\n+\tASSERT_DUMPED_TEXT_EQ (tmp, \"test.txt:5:10: note: test of tree: 0\");\n+\tif (with_optinfo)\n+\t  {\n+\t    optinfo *info = tmp.get_pending_optinfo ();\n+\t    ASSERT_TRUE (info != NULL);\n+\t    ASSERT_EQ (info->get_location_t (), where);\n+\t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+\t    ASSERT_EQ (info->num_items (), 2);\n+\t    ASSERT_IS_TEXT (info->get_item (0), \"test of tree: \");\n+\t    ASSERT_IS_TREE (info->get_item (1), UNKNOWN_LOCATION, \"0\");\n+\t  }\n+      }\n+\n+      /* Tree, via dump_generic_expr_loc.  */\n+      {\n+\ttemp_dump_context tmp (with_optinfo, MSG_ALL);\n+\tdump_generic_expr_loc (MSG_NOTE, loc, TDF_SLIM, integer_one_node);\n+\n+\tASSERT_DUMPED_TEXT_EQ (tmp, \"test.txt:5:10: note: 1\");\n+\tif (with_optinfo)\n+\t  {\n+\t    optinfo *info = tmp.get_pending_optinfo ();\n+\t    ASSERT_TRUE (info != NULL);\n+\t    ASSERT_EQ (info->get_location_t (), where);\n+\t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+\t    ASSERT_EQ (info->num_items (), 1);\n+\t    ASSERT_IS_TREE (info->get_item (0), UNKNOWN_LOCATION, \"1\");\n+\t  }\n+      }\n+\n+      /* Gimple.  */\n+      {\n+\t/* dump_gimple_stmt_loc.  */\n+\t{\n+\t  temp_dump_context tmp (with_optinfo, MSG_ALL);\n+\t  dump_gimple_stmt_loc (MSG_NOTE, loc, TDF_SLIM, stmt, 2);\n+\n+\t  ASSERT_DUMPED_TEXT_EQ (tmp, \"test.txt:5:10: note: return;\\n\");\n+\t  if (with_optinfo)\n+\t    {\n+\t      optinfo *info = tmp.get_pending_optinfo ();\n+\t      ASSERT_TRUE (info != NULL);\n+\t      ASSERT_EQ (info->num_items (), 1);\n+\t      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\\n\");\n+\t    }\n+\t}\n \n-      optinfo *info = tmp.get_pending_optinfo ();\n-      ASSERT_TRUE (info != NULL);\n-      ASSERT_EQ (info->num_items (), 1);\n-      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\");\n-    }\n+\t/* dump_gimple_stmt.  */\n+\t{\n+\t  temp_dump_context tmp (with_optinfo, MSG_ALL);\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 2);\n+\n+\t  ASSERT_DUMPED_TEXT_EQ (tmp, \"return;\\n\");\n+\t  if (with_optinfo)\n+\t    {\n+\t      optinfo *info = tmp.get_pending_optinfo ();\n+\t      ASSERT_TRUE (info != NULL);\n+\t      ASSERT_EQ (info->num_items (), 1);\n+\t      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\\n\");\n+\t    }\n+\t}\n \n-    /* dump_gimple_expr.  */\n-    {\n-      temp_dump_context tmp (true);\n-      dump_gimple_expr (MSG_NOTE, TDF_SLIM, stmt, 2);\n+\t/* dump_gimple_expr_loc.  */\n+\t{\n+\t  temp_dump_context tmp (with_optinfo, MSG_ALL);\n+\t  dump_gimple_expr_loc (MSG_NOTE, loc, TDF_SLIM, stmt, 2);\n+\n+\t  ASSERT_DUMPED_TEXT_EQ (tmp, \"test.txt:5:10: note: return;\");\n+\t  if (with_optinfo)\n+\t    {\n+\t      optinfo *info = tmp.get_pending_optinfo ();\n+\t      ASSERT_TRUE (info != NULL);\n+\t      ASSERT_EQ (info->num_items (), 1);\n+\t      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\");\n+\t    }\n+\t}\n \n-      optinfo *info = tmp.get_pending_optinfo ();\n-      ASSERT_TRUE (info != NULL);\n-      ASSERT_EQ (info->num_items (), 1);\n-      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\");\n+\t/* dump_gimple_expr.  */\n+\t{\n+\t  temp_dump_context tmp (with_optinfo, MSG_ALL);\n+\t  dump_gimple_expr (MSG_NOTE, TDF_SLIM, stmt, 2);\n+\n+\t  ASSERT_DUMPED_TEXT_EQ (tmp, \"return;\");\n+\t  if (with_optinfo)\n+\t    {\n+\t      optinfo *info = tmp.get_pending_optinfo ();\n+\t      ASSERT_TRUE (info != NULL);\n+\t      ASSERT_EQ (info->num_items (), 1);\n+\t      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\");\n+\t    }\n+\t}\n+      }\n+\n+      /* poly_int.  */\n+      {\n+\ttemp_dump_context tmp (with_optinfo, MSG_ALL);\n+\tdump_dec (MSG_NOTE, poly_int64 (42));\n+\n+\tASSERT_DUMPED_TEXT_EQ (tmp, \"42\");\n+\tif (with_optinfo)\n+\t  {\n+\t    optinfo *info = tmp.get_pending_optinfo ();\n+\t    ASSERT_TRUE (info != NULL);\n+\t    ASSERT_EQ (info->num_items (), 1);\n+\t    ASSERT_IS_TEXT (info->get_item (0), \"42\");\n+\t  }\n+      }\n+\n+      /* scopes.  */\n+      {\n+\ttemp_dump_context tmp (with_optinfo, MSG_ALL);\n+\tdump_printf_loc (MSG_NOTE, stmt, \"msg 1\\n\");\n+\t{\n+\t  AUTO_DUMP_SCOPE (\"outer scope\", stmt);\n+\t  dump_printf_loc (MSG_NOTE, stmt, \"msg 2\\n\");\n+\t  {\n+\t    AUTO_DUMP_SCOPE (\"middle scope\", stmt);\n+\t    dump_printf_loc (MSG_NOTE, stmt, \"msg 3\\n\");\n+\t    {\n+\t      AUTO_DUMP_SCOPE (\"inner scope\", stmt);\n+\t      dump_printf_loc (MSG_NOTE, stmt, \"msg 4\\n\");\n+\t    }\n+\t    dump_printf_loc (MSG_NOTE, stmt, \"msg 5\\n\");\n+\t  }\n+\t  dump_printf_loc (MSG_NOTE, stmt, \"msg 6\\n\");\n+\t}\n+\tdump_printf_loc (MSG_NOTE, stmt, \"msg 7\\n\");\n+\n+\tASSERT_DUMPED_TEXT_EQ (tmp,\n+\t\t\t       \"test.txt:5:10: note: msg 1\\n\"\n+\t\t\t       \"test.txt:5:10: note: === outer scope ===\\n\"\n+\t\t\t       \"test.txt:5:10: note:  msg 2\\n\"\n+\t\t\t       \"test.txt:5:10: note:  === middle scope ===\\n\"\n+\t\t\t       \"test.txt:5:10: note:   msg 3\\n\"\n+\t\t\t       \"test.txt:5:10: note:   === inner scope ===\\n\"\n+\t\t\t       \"test.txt:5:10: note:    msg 4\\n\"\n+\t\t\t       \"test.txt:5:10: note:   msg 5\\n\"\n+\t\t\t       \"test.txt:5:10: note:  msg 6\\n\"\n+\t\t\t       \"test.txt:5:10: note: msg 7\\n\");\n+\tif (with_optinfo)\n+\t  {\n+\t    optinfo *info = tmp.get_pending_optinfo ();\n+\t    ASSERT_TRUE (info != NULL);\n+\t    ASSERT_EQ (info->num_items (), 1);\n+\t    ASSERT_IS_TEXT (info->get_item (0), \"msg 7\\n\");\n+\t  }\n+      }\n     }\n-  }\n-\n-  /* poly_int.  */\n-  {\n-    temp_dump_context tmp (true);\n-    dump_dec (MSG_NOTE, poly_int64 (42));\n-\n-    optinfo *info = tmp.get_pending_optinfo ();\n-    ASSERT_TRUE (info != NULL);\n-    ASSERT_EQ (info->num_items (), 1);\n-    ASSERT_IS_TEXT (info->get_item (0), \"42\");\n-  }\n \n   /* Verify that MSG_* affects optinfo->get_kind (); we tested MSG_NOTE\n      above.  */\n   {\n     /* MSG_OPTIMIZED_LOCATIONS.  */\n     {\n-      temp_dump_context tmp (true);\n+      temp_dump_context tmp (true, MSG_ALL);\n       dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc, \"test\");\n       ASSERT_EQ (tmp.get_pending_optinfo ()->get_kind (),\n \t\t OPTINFO_KIND_SUCCESS);\n     }\n \n     /* MSG_MISSED_OPTIMIZATION.  */\n     {\n-      temp_dump_context tmp (true);\n+      temp_dump_context tmp (true, MSG_ALL);\n       dump_printf_loc (MSG_MISSED_OPTIMIZATION, loc, \"test\");\n       ASSERT_EQ (tmp.get_pending_optinfo ()->get_kind (),\n \t\t OPTINFO_KIND_FAILURE);"}, {"sha": "2b174e5ea0f19370ff2bae3c5e190f3b5e6e5cb7", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=b84e3bde926ea3a8824120108a0184fe32743bec", "patch": "@@ -442,19 +442,27 @@ dump_enabled_p (void)\n }\n \n /* The following API calls (which *don't* take a \"FILE *\")\n-   write the output to zero or more locations:\n-   (a) the active dump_file, if any\n-   (b) the -fopt-info destination, if any\n-   (c) to the \"optinfo\" destinations, if any:\n-       (c.1) as optimization records\n-\n-   dump_* (MSG_*) --> dumpfile.c --+--> (a) dump_file\n-                                   |\n-                                   +--> (b) alt_dump_file\n-                                   |\n-                                   `--> (c) optinfo\n-                                            `---> optinfo destinations\n-                                                  (c.1) optimization records\n+   write the output to zero or more locations.\n+\n+   Some destinations are written to immediately as dump_* calls\n+   are made; for others, the output is consolidated into an \"optinfo\"\n+   instance (with its own metadata), and only emitted once the optinfo\n+   is complete.\n+\n+   The destinations are:\n+\n+   (a) the \"immediate\" destinations:\n+       (a.1) the active dump_file, if any\n+       (a.2) the -fopt-info destination, if any\n+   (b) the \"optinfo\" destinations, if any:\n+       (b.1) as optimization records\n+\n+   dump_* (MSG_*) --> dumpfile.c --> items --> (a.1) dump_file\n+                                       |   `-> (a.2) alt_dump_file\n+                                       |\n+                                       `--> (b) optinfo\n+                                                `---> optinfo destinations\n+                                                      (b.1) optimization records\n \n    For optinfos, the dump_*_loc mark the beginning of an optinfo\n    instance: all subsequent dump_* calls are consolidated into"}, {"sha": "992960ec8d200a5b2cccd2edab46e89ec40e3cf4", "filename": "gcc/optinfo-emit-json.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Foptinfo-emit-json.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Foptinfo-emit-json.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo-emit-json.cc?ref=b84e3bde926ea3a8824120108a0184fe32743bec", "patch": "@@ -537,7 +537,7 @@ namespace selftest {\n static void\n test_building_json_from_dump_calls ()\n {\n-  temp_dump_context tmp (true);\n+  temp_dump_context tmp (true, MSG_NOTE);\n   dump_location_t loc;\n   dump_printf_loc (MSG_NOTE, loc, \"test of tree: \");\n   dump_generic_expr (MSG_NOTE, TDF_SLIM, integer_zero_node);"}, {"sha": "b858c3ca08a1c0fe1e11894c4d4561e200061981", "filename": "gcc/optinfo.cc", "status": "modified", "additions": 15, "deletions": 120, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Foptinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Foptinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.cc?ref=b84e3bde926ea3a8824120108a0184fe32743bec", "patch": "@@ -34,20 +34,19 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"selftest.h\"\n \n-/* optinfo_item's ctor.  */\n+/* optinfo_item's ctor.  Takes ownership of TEXT.  */\n \n optinfo_item::optinfo_item (enum optinfo_item_kind kind, location_t location,\n-\t\t\t    char *text, bool owned)\n-: m_kind (kind), m_location (location), m_text (text), m_owned (owned)\n+\t\t\t    char *text)\n+: m_kind (kind), m_location (location), m_text (text)\n {\n }\n \n /* optinfo_item's dtor.  */\n \n optinfo_item::~optinfo_item ()\n {\n-  if (m_owned)\n-    free (m_text);\n+  free (m_text);\n }\n \n /* Get a string from KIND.  */\n@@ -81,7 +80,17 @@ optinfo::~optinfo ()\n     delete item;\n }\n \n-/* Emit the optinfo to all of the active destinations.  */\n+/* Add ITEM to this optinfo.  */\n+\n+void\n+optinfo::add_item (optinfo_item *item)\n+{\n+  gcc_assert (item);\n+  m_items.safe_push (item);\n+}\n+\n+/* Emit the optinfo to all of the \"non-immediate\" destinations\n+   (emission to \"immediate\" destinations is done by emit_item).  */\n \n void\n optinfo::emit ()\n@@ -103,120 +112,6 @@ optinfo::handle_dump_file_kind (dump_flags_t dump_kind)\n     m_kind = OPTINFO_KIND_NOTE;\n }\n \n-/* Append a string literal to this optinfo.  */\n-\n-void\n-optinfo::add_string (const char *str)\n-{\n-  optinfo_item *item\n-    = new optinfo_item (OPTINFO_ITEM_KIND_TEXT, UNKNOWN_LOCATION,\n-\t\t\tconst_cast <char *> (str), false);\n-  m_items.safe_push (item);\n-}\n-\n-/* Append printf-formatted text to this optinfo.  */\n-\n-void\n-optinfo::add_printf (const char *format, ...)\n-{\n-  va_list ap;\n-  va_start (ap, format);\n-  add_printf_va (format, ap);\n-  va_end (ap);\n-}\n-\n-/* Append printf-formatted text to this optinfo.  */\n-\n-void\n-optinfo::add_printf_va (const char *format, va_list ap)\n-{\n-  char *formatted_text = xvasprintf (format, ap);\n-  optinfo_item *item\n-    = new optinfo_item (OPTINFO_ITEM_KIND_TEXT, UNKNOWN_LOCATION,\n-\t\t\tformatted_text, true);\n-  m_items.safe_push (item);\n-}\n-\n-/* Append a gimple statement to this optinfo, equivalent to\n-   print_gimple_stmt.  */\n-\n-void\n-optinfo::add_gimple_stmt (gimple *stmt, int spc, dump_flags_t dump_flags)\n-{\n-  pretty_printer pp;\n-  pp_needs_newline (&pp) = true;\n-  pp_gimple_stmt_1 (&pp, stmt, spc, dump_flags);\n-  pp_newline (&pp);\n-\n-  optinfo_item *item\n-    = new optinfo_item (OPTINFO_ITEM_KIND_GIMPLE, gimple_location (stmt),\n-\t\t\txstrdup (pp_formatted_text (&pp)), true);\n-  m_items.safe_push (item);\n-}\n-\n-/* Append a gimple statement to this optinfo, equivalent to\n-   print_gimple_expr.  */\n-\n-void\n-optinfo::add_gimple_expr (gimple *stmt, int spc, dump_flags_t dump_flags)\n-{\n-  dump_flags |= TDF_RHS_ONLY;\n-  pretty_printer pp;\n-  pp_needs_newline (&pp) = true;\n-  pp_gimple_stmt_1 (&pp, stmt, spc, dump_flags);\n-\n-  optinfo_item *item\n-    = new optinfo_item (OPTINFO_ITEM_KIND_GIMPLE, gimple_location (stmt),\n-\t\t\txstrdup (pp_formatted_text (&pp)), true);\n-  m_items.safe_push (item);\n-}\n-\n-/* Append a tree node to this optinfo, equivalent to print_generic_expr.  */\n-\n-void\n-optinfo::add_tree (tree node, dump_flags_t dump_flags)\n-{\n-  pretty_printer pp;\n-  pp_needs_newline (&pp) = true;\n-  pp_translate_identifiers (&pp) = false;\n-  dump_generic_node (&pp, node, 0, dump_flags, false);\n-\n-  location_t loc = UNKNOWN_LOCATION;\n-  if (EXPR_HAS_LOCATION (node))\n-    loc = EXPR_LOCATION (node);\n-\n-  optinfo_item *item\n-    = new optinfo_item (OPTINFO_ITEM_KIND_TREE, loc,\n-\t\t\txstrdup (pp_formatted_text (&pp)), true);\n-  m_items.safe_push (item);\n-}\n-\n-/* Append a symbol table node to this optinfo.  */\n-\n-void\n-optinfo::add_symtab_node (symtab_node *node)\n-{\n-  location_t loc = DECL_SOURCE_LOCATION (node->decl);\n-  optinfo_item *item\n-    = new optinfo_item (OPTINFO_ITEM_KIND_SYMTAB_NODE, loc,\n-\t\t\txstrdup (node->dump_name ()), true);\n-  m_items.safe_push (item);\n-}\n-\n-/* Append the decimal represenation of a wide_int_ref to this\n-   optinfo.  */\n-\n-void\n-optinfo::add_dec (const wide_int_ref &wi, signop sgn)\n-{\n-  char buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-  print_dec (wi, buf, sgn);\n-  optinfo_item *item\n-    = new optinfo_item (OPTINFO_ITEM_KIND_TEXT, UNKNOWN_LOCATION,\n-\t\t\txstrdup (buf), true);\n-  m_items.safe_push (item);\n-}\n-\n /* Should optinfo instances be created?\n    All creation of optinfos should be guarded by this predicate.\n    Return true if any optinfo destinations are active.  */"}, {"sha": "8ac961c9e9246cfe7012c8927cd4208bfa768355", "filename": "gcc/optinfo.h", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Foptinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84e3bde926ea3a8824120108a0184fe32743bec/gcc%2Foptinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.h?ref=b84e3bde926ea3a8824120108a0184fe32743bec", "patch": "@@ -92,6 +92,8 @@ enum optinfo_kind\n \n extern const char *optinfo_kind_to_string (enum optinfo_kind kind);\n \n+class dump_context;\n+\n /* A bundle of information describing part of an optimization.  */\n \n class optinfo\n@@ -120,41 +122,14 @@ class optinfo\n   location_t get_location_t () const { return m_loc.get_location_t (); }\n   profile_count get_count () const { return m_loc.get_count (); }\n \n+  void add_item (optinfo_item *item);\n+\n  private:\n   void emit ();\n \n   /* Pre-canned ways of manipulating the optinfo, for use by friend class\n      dump_context.  */\n   void handle_dump_file_kind (dump_flags_t);\n-  void add_string (const char *str);\n-  void add_printf (const char *format, ...) ATTRIBUTE_PRINTF_2;\n-  void add_printf_va (const char *format, va_list ap) ATTRIBUTE_PRINTF (2, 0);\n-  void add_gimple_stmt (gimple *stmt, int spc, dump_flags_t dump_flags);\n-  void add_gimple_expr (gimple *stmt, int spc, dump_flags_t dump_flags);\n-  void add_tree (tree node, dump_flags_t dump_flags);\n-  void add_symtab_node (symtab_node *node);\n-  void add_dec (const wide_int_ref &wi, signop sgn);\n-\n-  template<unsigned int N, typename C>\n-  void add_poly_int (const poly_int<N, C> &value)\n-  {\n-    /* Compare with dump_dec (MSG_NOTE, ).  */\n-\n-    STATIC_ASSERT (poly_coeff_traits<C>::signedness >= 0);\n-    signop sgn = poly_coeff_traits<C>::signedness ? SIGNED : UNSIGNED;\n-\n-    if (value.is_constant ())\n-      add_dec (value.coeffs[0], sgn);\n-    else\n-      {\n-\tadd_string (\"[\");\n-\tfor (unsigned int i = 0; i < N; ++i)\n-\t  {\n-\t    add_dec (value.coeffs[i], sgn);\n-\t    add_string (i == N - 1 ? \"]\" : \",\");\n-\t  }\n-      }\n-  }\n \n  private:\n   dump_location_t m_loc;\n@@ -179,7 +154,7 @@ class optinfo_item\n {\n  public:\n   optinfo_item (enum optinfo_item_kind kind, location_t location,\n-\t\tchar *text, bool owned);\n+\t\tchar *text);\n   ~optinfo_item ();\n \n   enum optinfo_item_kind get_kind () const { return m_kind; }\n@@ -191,9 +166,8 @@ class optinfo_item\n   enum optinfo_item_kind m_kind;\n   location_t m_location;\n \n-  /* The textual form of the item.  */\n+  /* The textual form of the item, owned by the item.  */\n   char *m_text;\n-  bool m_owned;\n };\n \n #endif /* #ifndef GCC_OPTINFO_H */"}]}