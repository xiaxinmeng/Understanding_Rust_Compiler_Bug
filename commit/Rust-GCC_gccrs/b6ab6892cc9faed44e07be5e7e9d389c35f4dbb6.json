{"sha": "b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZhYjY4OTJjYzlmYWVkNDRlMDdiZTVlN2U5ZDM4OWMzNWY0ZGJiNg==", "commit": {"author": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-11-04T13:07:35Z"}, "committer": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-11-04T13:07:35Z"}, "message": "DR 49, 100\n\n\tDR 49, 100\n\t* cp-tree.h (TYPE_REF_OBJ_P): New macro.\n\t(TYPE_PTR_P, TYPE_PTROB_P, TYPE_PTROBV_P, TYPE_PTRFN_P,\n\tTYPE_REFFN_P): Document.\n\t(fold_decl_constant_value): New prototype.\n\t* pt.c (convert_nontype_argument_function): Rewrite and extract\n\tparts into...\n\t(fold_decl_constant_value, convert_nontype_argument_function): New.\n\t(lookup_template_class): Add comment about useless double call.\n\t* mangle.c (write_expression): Strip conversions before lowering\n\tpointer to members.\n\t* cvt.c (ocp_convert): Check LOOKUP_COMPLAIN for a pedwarn. Disallow\n\tenum to enum conversion.\n\n\t* g++.dg/template/nontype7.C: New test.\n\t* g++.dg/template/nontype8.C: Likewise.\n\t* g++.dg/template/nontype9.C: Likewise.\n\t* g++.dg/template/nontype10.C: Likewise.\n\t* g++.dg/tc1/dr49.C: Likewise.\n\t* g++.dg/template/ptrmem8.C: Relax dg-error checks.\n\t* g++.old-deja/g++.other/null1.C: Remove a buggy error check\n\nFrom-SVN: r90059", "tree": {"sha": "83598a1d6f066b2be9579ffd9e08efb5b5b8c2fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83598a1d6f066b2be9579ffd9e08efb5b5b8c2fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/comments", "author": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eba7452ba8a7c3d088531c0a9dca639b6d708883", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eba7452ba8a7c3d088531c0a9dca639b6d708883", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eba7452ba8a7c3d088531c0a9dca639b6d708883"}], "stats": {"total": 799, "additions": 454, "deletions": 345}, "files": [{"sha": "a531bf00c3503fba286672ffbbcf2e942091e0d2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -1,3 +1,19 @@\n+2004-11-04  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\tDR 49, 100\n+\t* cp-tree.h (TYPE_REF_OBJ_P): New macro.\n+\t(TYPE_PTR_P, TYPE_PTROB_P, TYPE_PTROBV_P, TYPE_PTRFN_P,\n+\tTYPE_REFFN_P): Document.\n+\t(fold_decl_constant_value): New prototype.\n+\t* pt.c (convert_nontype_argument_function): Rewrite and extract\n+\tparts into...\n+\t(fold_decl_constant_value, convert_nontype_argument_function): New.\n+\t(lookup_template_class): Add comment about useless double call.\n+\t* mangle.c (write_expression): Strip conversions before lowering\n+\tpointer to members.\n+\t* cvt.c (ocp_convert): Check LOOKUP_COMPLAIN for a pedwarn. Disallow\n+\tenum to enum conversion.\n+\n 2004-11-02  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/18124"}, {"sha": "6a69eb78709b5d6d3ebc53c22326a769984f2bed", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -2398,18 +2398,29 @@ struct lang_decl GTY(())\n /* Returns true if NODE is a pointer-to-data-member.  */\n #define TYPE_PTRMEM_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == OFFSET_TYPE)\n+/* Returns true if NODE is a pointer.  */\n #define TYPE_PTR_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == POINTER_TYPE)\n+/* Returns true if NODE is a pointer to an object.  */\n #define TYPE_PTROB_P(NODE)\t\t\t\t\\\n   (TYPE_PTR_P (NODE) \t\t\t\t\t\\\n    && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE\t\\\n    && TREE_CODE (TREE_TYPE (NODE)) != METHOD_TYPE\t\\\n    && TREE_CODE (TREE_TYPE (NODE)) != VOID_TYPE)\n+/* Returns true if NODE is a reference to an object.  */\n+#define TYPE_REF_OBJ_P(NODE)\t\t\t\t\\\n+  (TREE_CODE (NODE) == REFERENCE_TYPE\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) != METHOD_TYPE\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) != VOID_TYPE)\n+/* Returns true if NODE is a pointer to an object, or a pointer to void.  */\n #define TYPE_PTROBV_P(NODE)\t\t\t\t\t\t\\\n   (TYPE_PTR_P (NODE) && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE)\n+/* Returns true if NODE is a pointer to function.  */\n #define TYPE_PTRFN_P(NODE)\t\t\t\t\\\n   (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n    && TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE)\n+/* Returns true if NODE is a reference to function.  */\n #define TYPE_REFFN_P(NODE)\t\t\t\t\\\n   (TREE_CODE (NODE) == REFERENCE_TYPE\t\t\t\\\n    && TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE)\n@@ -3976,6 +3987,7 @@ extern tree build_non_dependent_expr            (tree);\n extern tree build_non_dependent_args            (tree);\n extern bool reregister_specialization           (tree, tree, tree);\n extern tree fold_non_dependent_expr             (tree);\n+extern tree fold_decl_constant_value            (tree);\n \n /* in repo.c */\n extern void init_repo (void);"}, {"sha": "f1968fd3a905df30e29fc46f4c83e156db1d5e2e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -662,10 +662,13 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       /* enum = enum, enum = int, enum = float, (enum)pointer are all\n          errors.  */\n       if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t  && ((ARITHMETIC_TYPE_P (intype) && ! (convtype & CONV_STATIC))\n-\t      || (TREE_CODE (intype) == POINTER_TYPE)))\n+\t  && (((INTEGRAL_OR_ENUMERATION_TYPE_P (intype)\n+\t        || TREE_CODE (intype) == REAL_TYPE)\n+\t       && ! (convtype & CONV_STATIC))\n+\t      || TREE_CODE (intype) == POINTER_TYPE))\n \t{\n-\t  pedwarn (\"conversion from %q#T to %q#T\", intype, type);\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    pedwarn (\"conversion from %q#T to %q#T\", intype, type);\n \n \t  if (flag_pedantic_errors)\n \t    return error_mark_node;"}, {"sha": "1aeb3beb401fdf18abff85e5f369650fae011011", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -1969,6 +1969,16 @@ write_expression (tree expr)\n \n   code = TREE_CODE (expr);\n \n+  /* Skip NOP_EXPRs.  They can occur when (say) a pointer argument\n+     is converted (via qualification conversions) to another\n+     type.  */\n+  while (TREE_CODE (expr) == NOP_EXPR\n+\t || TREE_CODE (expr) == NON_LVALUE_EXPR)\n+    {\n+      expr = TREE_OPERAND (expr, 0);\n+      code = TREE_CODE (expr);\n+    }\n+\n   /* Handle pointers-to-members by making them look like expression\n      nodes.  */\n   if (code == PTRMEM_CST)\n@@ -1980,16 +1990,6 @@ write_expression (tree expr)\n       code = TREE_CODE (expr);\n     }\n \n-  /* Skip NOP_EXPRs.  They can occur when (say) a pointer argument\n-     is converted (via qualification conversions) to another\n-     type.  */\n-  while (TREE_CODE (expr) == NOP_EXPR\n-\t || TREE_CODE (expr) == NON_LVALUE_EXPR)\n-    {\n-      expr = TREE_OPERAND (expr, 0);\n-      code = TREE_CODE (expr);\n-    }\n-\n   /* Handle template parameters.  */\n   if (code == TEMPLATE_TYPE_PARM \n       || code == TEMPLATE_TEMPLATE_PARM"}, {"sha": "961488443b613c742b010f3421261a8f3edc3c1c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 322, "deletions": 329, "changes": 651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -110,6 +110,7 @@ static int maybe_adjust_types_for_deduction (unification_kind_t, tree*, tree*);\n static int  type_unification_real (tree, tree, tree, tree,\n \t\t\t\t   int, unification_kind_t, int, int);\n static void note_template_header (int);\n+static tree convert_nontype_argument_function (tree, tree);\n static tree convert_nontype_argument (tree, tree);\n static tree convert_template_argument (tree, tree, tree,\n \t\t\t\t       tsubst_flags_t, int, tree);\n@@ -3302,20 +3303,117 @@ fold_non_dependent_expr (tree expr)\n   return expr;\n }\n \n+/* EXPR is an expression which is used in a constant-expression context.\n+   For instance, it could be a VAR_DECL with a constant initializer.\n+   Extract the innest constant expression.\n+   \n+   This is basically a more powerful version of decl_constant_value, which\n+   can be used also in templates where initializers can maintain a\n+   syntactic rather than semantic form (even if they are non-dependent, for\n+   access-checking purposes).  */\n+\n+tree\n+fold_decl_constant_value (tree expr)\n+{\n+  while (true)\n+    {\n+      tree const_expr = decl_constant_value (expr);\n+      /* In a template, the initializer for a VAR_DECL may not be\n+\t marked as TREE_CONSTANT, in which case decl_constant_value\n+\t will not return the initializer.  Handle that special case\n+\t here.  */\n+      if (expr == const_expr\n+\t  && TREE_CODE (expr) == VAR_DECL\n+\t  && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (expr)\n+\t  && CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (expr))\n+\t  /* DECL_INITIAL can be NULL if we are processing a\n+\t     variable initialized to an expression involving itself.\n+\t     We know it is initialized to a constant -- but not what\n+\t     constant, yet.  */\n+\t  && DECL_INITIAL (expr))\n+\tconst_expr = DECL_INITIAL (expr);\n+      if (expr == const_expr)\n+\tbreak;\n+      expr = fold_non_dependent_expr (const_expr);\n+    }\n+\n+    return expr;\n+}\n+\n+/* Subroutine of convert_nontype_argument. Converts EXPR to TYPE, which\n+   must be a function or a pointer-to-function type, as specified\n+   in [temp.arg.nontype]: disambiguate EXPR if it is an overload set,\n+   and check that the resulting function has external linkage.  */\n+\n+static tree\n+convert_nontype_argument_function (tree type, tree expr)\n+{\n+  tree fns = expr;\n+  tree fn, fn_no_ptr;\n+\n+  fn = instantiate_type (type, fns, tf_none);\n+  if (fn == error_mark_node)\n+    return error_mark_node;\n+\n+  fn_no_ptr = fn;\n+  if (TREE_CODE (fn_no_ptr) == ADDR_EXPR)\n+    fn_no_ptr = TREE_OPERAND (fn_no_ptr, 0);\n+\n+  /* [temp.arg.nontype]/1\n+\n+     A template-argument for a non-type, non-template template-parameter\n+     shall be one of:\n+     [...]\n+     -- the address of an object or function with external linkage.  */\n+  if (!DECL_EXTERNAL_LINKAGE_P (fn_no_ptr))\n+    {\n+      error (\"%qE is not a valid template argument for type %qT \"\n+\t     \"because function %qD has not external linkage\",\n+\t     expr, type, fn_no_ptr);\n+      return NULL_TREE;\n+    }\n+\n+  return fn;\n+}\n+\n /* Attempt to convert the non-type template parameter EXPR to the\n    indicated TYPE.  If the conversion is successful, return the\n    converted value.  If the conversion is unsuccessful, return\n    NULL_TREE if we issued an error message, or error_mark_node if we\n    did not.  We issue error messages for out-and-out bad template\n    parameters, but not simply because the conversion failed, since we\n    might be just trying to do argument deduction.  Both TYPE and EXPR\n-   must be non-dependent.  */\n+   must be non-dependent.\n+\n+   The conversion follows the special rules described in\n+   [temp.arg.nontype], and it is much more strict than an implicit\n+   conversion.\n+\n+   This function is called twice for each template argument (see\n+   lookup_template_class for a more accurate description of this\n+   problem). This means that we need to handle expressions which\n+   are not valid in a C++ source, but can be created from the\n+   first call (for instance, casts to perform conversions). These\n+   hacks can go away after we fix the double coercion problem.  */\n \n static tree\n convert_nontype_argument (tree type, tree expr)\n {\n   tree expr_type;\n \n+  /* Detect immediately string literals as invalid non-type argument.\n+     This special-case is not needed for correctness (we would easily\n+     catch this later), but only to provide better diagnostic for this\n+     common user mistake. As suggested by DR 100, we do not mention\n+     linkage issues in the diagnostic as this is not the point.  */\n+  if (TREE_CODE (expr) == STRING_CST)\n+    {\n+      error (\"%qE is not a valid template argument for type %qT \"\n+\t     \"because string literals can never be used in this context\",\n+\t     expr, type);\n+      return NULL_TREE;\n+    }\n+\n   /* If we are in a template, EXPR may be non-dependent, but still\n      have a syntactic, rather than semantic, form.  For example, EXPR\n      might be a SCOPE_REF, rather than the VAR_DECL to which the\n@@ -3326,374 +3424,262 @@ convert_nontype_argument (tree type, tree expr)\n   expr = fold_non_dependent_expr (expr);\n   expr_type = TREE_TYPE (expr);\n \n-  /* A template-argument for a non-type, non-template\n-     template-parameter shall be one of:\n-\n-     --an integral constant-expression of integral or enumeration\n-     type; or\n-     \n-     --the name of a non-type template-parameter; or\n-     \n-     --the name of an object or function with external linkage,\n-     including function templates and function template-ids but\n-     excluding non-static class members, expressed as id-expression;\n-     or\n-     \n-     --the address of an object or function with external linkage,\n-     including function templates and function template-ids but\n-     excluding non-static class members, expressed as & id-expression\n-     where the & is optional if the name refers to a function or\n-     array; or\n-     \n-     --a pointer to member expressed as described in _expr.unary.op_.  */\n-\n-  /* An integral constant-expression can include const variables or\n-.     enumerators.  Simplify things by folding them to their values,\n-     unless we're about to bind the declaration to a reference\n-     parameter.  */\n-  if (INTEGRAL_TYPE_P (expr_type) && TREE_CODE (type) != REFERENCE_TYPE)\n-    while (true) \n-      {\n-\ttree const_expr = decl_constant_value (expr);\n-\t/* In a template, the initializer for a VAR_DECL may not be\n-\t   marked as TREE_CONSTANT, in which case decl_constant_value\n-\t   will not return the initializer.  Handle that special case\n-\t   here.  */\n-\tif (expr == const_expr\n-\t    && DECL_INTEGRAL_CONSTANT_VAR_P (expr)\n-\t    /* DECL_INITIAL can be NULL if we are processing a\n-\t       variable initialized to an expression involving itself.\n-\t       We know it is initialized to a constant -- but not what\n-\t       constant, yet.  */\n-\t    && DECL_INITIAL (expr))\n-\t  const_expr = DECL_INITIAL (expr);\n-\tif (expr == const_expr)\n-\t  break;\n-\texpr = fold_non_dependent_expr (const_expr);\n-      }\n-\n-  if (is_overloaded_fn (expr))\n-    /* OK for now.  We'll check that it has external linkage later.\n-       Check this first since if expr_type is the unknown_type_node\n-       we would otherwise complain below.  */\n-    ;\n-  else if (TYPE_PTR_TO_MEMBER_P (expr_type))\n-    {\n-      if (TREE_CODE (expr) != PTRMEM_CST)\n-\tgoto bad_argument;\n-    }\n-  else if (TYPE_PTR_P (expr_type)\n-\t   || TREE_CODE (expr_type) == ARRAY_TYPE\n-\t   || TREE_CODE (type) == REFERENCE_TYPE\n-\t   /* If expr is the address of an overloaded function, we\n-\t      will get the unknown_type_node at this point.  */\n-\t   || expr_type == unknown_type_node)\n-    {\n-      tree referent;\n-      tree e = expr;\n-      STRIP_NOPS (e);\n-\n-      if (TREE_CODE (expr_type) == ARRAY_TYPE\n-\t  || (TREE_CODE (type) == REFERENCE_TYPE\n-\t      && TREE_CODE (e) != ADDR_EXPR))\n-\treferent = e;\n-      else\n-\t{\n-\t  if (TREE_CODE (e) != ADDR_EXPR)\n-\t    {\n-\t    bad_argument:\n-\t      error (\"%qE is not a valid template argument\", expr);\n-\t      if (TYPE_PTR_P (expr_type))\n-\t\t{\n-\t\t  if (TREE_CODE (TREE_TYPE (expr_type)) == FUNCTION_TYPE)\n-\t\t    error (\"it must be the address of a function with external linkage\");\n-\t\t  else\n-\t\t    error (\"it must be the address of an object with external linkage\");\n-\t\t}\n-\t      else if (TYPE_PTR_TO_MEMBER_P (expr_type))\n-\t\terror (\"it must be a pointer-to-member of the form %<&X::Y%>\");\n-\n-\t      return NULL_TREE;\n-\t    }\n-\n-\t  referent = TREE_OPERAND (e, 0);\n-\t  STRIP_NOPS (referent);\n-\t}\n-\n-      if (TREE_CODE (referent) == STRING_CST)\n+  /* HACK: Due to double coercion, we can get a\n+     NOP_EXPR<REFERENCE_TYPE>(ADDR_EXPR<POINTER_TYPE> (arg)) here,\n+     which is the tree that we built on the first call (see\n+     below when coercing to reference to object or to reference to\n+     function). We just strip everything and get to the arg.\n+     See g++.old-deja/g++.oliva/template4.C and g++.dg/template/nontype9.C\n+     for examples.  */\n+  if (TREE_CODE (expr) == NOP_EXPR)\n+    {\n+      if (TYPE_REF_OBJ_P (type) || TYPE_REFFN_P (type))\n \t{\n-\t  error (\"string literal %qE is not a valid template argument \"\n-                 \"because it is the address of an object with static linkage\", \n-                 referent);\n-\t  return NULL_TREE;\n+\t  /* ??? Maybe we could use convert_from_reference here, but we\n+\t     would need to relax its constraints because the NOP_EXPR\n+\t     could actually change the type to something more cv-qualified,\n+\t     and this is not folded by convert_from_reference.  */\n+\t  tree addr = TREE_OPERAND (expr, 0);\n+\t  gcc_assert (TREE_CODE (expr_type) == REFERENCE_TYPE);\n+\t  gcc_assert (TREE_CODE (addr) == ADDR_EXPR);\n+\t  gcc_assert (TREE_CODE (TREE_TYPE (addr)) == POINTER_TYPE);\n+\t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t      (TREE_TYPE (expr_type),\n+\t\t       TREE_TYPE (TREE_TYPE (addr))));\n+\n+\t  expr = TREE_OPERAND (addr, 0);\n+\t  expr_type = TREE_TYPE (expr);\n \t}\n \n-      if (TREE_CODE (referent) == SCOPE_REF)\n-\treferent = TREE_OPERAND (referent, 1);\n-\n-      if (is_overloaded_fn (referent))\n-\t/* We'll check that it has external linkage later.  */\n-\t;\n-      else if (TREE_CODE (referent) != VAR_DECL)\n-\tgoto bad_argument;\n-      else if (!DECL_EXTERNAL_LINKAGE_P (referent))\n+      /* We could also generate a NOP_EXPR(ADDR_EXPR()) when the\n+\t parameter is a pointer to object, through decay and\n+\t qualification conversion. Let's strip everything.  */\n+      else if (TYPE_PTROBV_P (type))\n \t{\n-\t  error (\"address of non-extern %qE cannot be used as \"\n-                 \"template argument\", referent); \n-\t  return error_mark_node;\n-\t}\n-    }\n-  else if (INTEGRAL_TYPE_P (expr_type) || TYPE_PTR_TO_MEMBER_P (expr_type))\n-    {\n-      if (! TREE_CONSTANT (expr))\n-\t{\n-\tnon_constant:\n-\t  error (\"non-constant %qE cannot be used as template argument\", expr);\n-\t  return NULL_TREE;\n+\t  STRIP_NOPS (expr);\n+\t  gcc_assert (TREE_CODE (expr) == ADDR_EXPR);\n+\t  gcc_assert (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE);\n+\t  /* Skip the ADDR_EXPR only if it is part of the decay for\n+\t     an array. Otherwise, it is part of the original argument\n+\t     in the source code.  */\n+\t  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == ARRAY_TYPE)\n+\t    expr = TREE_OPERAND (expr, 0);\n+\t  expr_type = TREE_TYPE (expr);\n \t}\n     }\n-  else \n-    {\n-      if (TYPE_P (expr))\n-         error (\"type %qT cannot be used as a value for a non-type \"\n-               \"template-parameter\", expr);\n-      else if (DECL_P (expr))\n-        error (\"invalid use of %qD as a non-type template-argument\", expr);\n-      else\n-        error (\"invalid use of %qE as a non-type template-argument\", expr);\n \n-      return NULL_TREE;\n-    }\n+  /* [temp.arg.nontype]/5, bullet 1\n \n-  switch (TREE_CODE (type))\n+     For a non-type template-parameter of integral or enumeration type,\n+     integral promotions (_conv.prom_) and integral conversions\n+     (_conv.integral_) are applied.  */\n+  if (INTEGRAL_TYPE_P (type))\n     {\n-      HOST_WIDE_INT saved_processing_template_decl;\n-\n-    case INTEGER_TYPE:\n-    case BOOLEAN_TYPE:\n-    case ENUMERAL_TYPE:\n-      /* For a non-type template-parameter of integral or enumeration\n-         type, integral promotions (_conv.prom_) and integral\n-         conversions (_conv.integral_) are applied.  */\n       if (!INTEGRAL_TYPE_P (expr_type))\n \treturn error_mark_node;\n \n-      /* [conv.integral] does not allow conversions between two different\n-\t enumeration types.  */\n-      if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t  && TREE_CODE (expr_type) == ENUMERAL_TYPE\n-\t  && !same_type_ignoring_top_level_qualifiers_p (type, expr_type))\n-\t  return error_mark_node;\n-\n-      /* It's safe to call digest_init in this case; we know we're\n-\t just converting one integral constant expression to another.\n-\t */\n-      saved_processing_template_decl = processing_template_decl;\n-      processing_template_decl = 0;\n-      expr = digest_init (type, expr, (tree*) 0);\n-      processing_template_decl = saved_processing_template_decl;\n-\n+      expr = fold_decl_constant_value (expr);\n+      /* Notice that there are constant expressions like '4 % 0' which\n+\t do not fold into integer constants.  */\n       if (TREE_CODE (expr) != INTEGER_CST)\n-\t/* Curiously, some TREE_CONSTANT integral expressions do not\n-\t   simplify to integer constants.  For example, `3 % 0',\n-\t   remains a TRUNC_MOD_EXPR.  */\n-\tgoto non_constant;\n-      \n-      return expr;\n-\n-    case OFFSET_TYPE:\n-      {\n-\ttree e;\n-\n-\t/* For a non-type template-parameter of type pointer to data\n-\t   member, qualification conversions (_conv.qual_) are\n-\t   applied.  */\n-\te = perform_qualification_conversions (type, expr);\n-\tif (TREE_CODE (e) == NOP_EXPR)\n-\t  /* The call to perform_qualification_conversions will\n-\t     insert a NOP_EXPR over EXPR to do express conversion,\n-\t     if necessary.  But, that will confuse us if we use\n-\t     this (converted) template parameter to instantiate\n-\t     another template; then the thing will not look like a\n-\t     valid template argument.  So, just make a new\n-\t     constant, of the appropriate type.  */\n-\t  e = make_ptrmem_cst (type, PTRMEM_CST_MEMBER (expr));\n-\treturn e;\n-      }\n-\n-    case POINTER_TYPE:\n-      {\n-\ttree type_pointed_to = TREE_TYPE (type);\n- \n-\tif (TREE_CODE (type_pointed_to) == FUNCTION_TYPE)\n-\t  { \n-\t    /* For a non-type template-parameter of type pointer to\n-\t       function, only the function-to-pointer conversion\n-\t       (_conv.func_) is applied.  If the template-argument\n-\t       represents a set of overloaded functions (or a pointer to\n-\t       such), the matching function is selected from the set\n-\t       (_over.over_).  */\n-\t    tree fns;\n-\t    tree fn;\n-\n-\t    if (TREE_CODE (expr) == ADDR_EXPR)\n-\t      fns = TREE_OPERAND (expr, 0);\n-\t    else\n-\t      fns = expr;\n+\t{\n+\t  error (\"%qE is not a valid template argument for type %qT \"\n+\t\t \"because it is a non-constant expression\", expr, type);\n+\t  return NULL_TREE;\n+\t}\n \n-\t    fn = instantiate_type (type_pointed_to, fns, tf_none);\n+      /* At this point, an implicit conversion does what we want,\n+\t because we already know that the expression is of integral\n+\t type.  */\n+      expr = ocp_convert (type, expr, CONV_IMPLICIT, LOOKUP_PROTECT);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n \n-\t    if (fn == error_mark_node)\n-\t      return error_mark_node;\n+      /* Conversion was allowed: fold it to a bare integer constant.  */\n+      expr = fold (expr);\n+    }\n+  /* [temp.arg.nontype]/5, bullet 2\n \n-\t    if (!DECL_EXTERNAL_LINKAGE_P (fn))\n-\t      {\n-\t\tif (really_overloaded_fn (fns))\n-\t\t  return error_mark_node;\n-\t\telse\n-\t\t  goto bad_argument;\n-\t      }\n+     For a non-type template-parameter of type pointer to object,\n+     qualification conversions (_conv.qual_) and the array-to-pointer\n+     conversion (_conv.array_) are applied.  */\n+  else if (TYPE_PTROBV_P (type))\n+    {\n+      /* [temp.arg.nontype]/1  (TC1 version, DR 49):\n \n-\t    expr = build_unary_op (ADDR_EXPR, fn, 0);\n+\t A template-argument for a non-type, non-template template-parameter\n+\t shall be one of: [...]\n \n-\t    gcc_assert (same_type_p (type, TREE_TYPE (expr)));\n-\t    return expr;\n-\t  }\n-\telse \n-\t  {\n-\t    /* For a non-type template-parameter of type pointer to\n-\t       object, qualification conversions (_conv.qual_) and the\n-\t       array-to-pointer conversion (_conv.array_) are applied.\n-\t       [Note: In particular, neither the null pointer conversion\n-\t       (_conv.ptr_) nor the derived-to-base conversion\n-\t       (_conv.ptr_) are applied.  Although 0 is a valid\n-\t       template-argument for a non-type template-parameter of\n-\t       integral type, it is not a valid template-argument for a\n-\t       non-type template-parameter of pointer type.]  \n+\t -- the name of a non-type template-parameter;\n+\t -- the address of an object or function with external linkage, [...]\n+\t    expressed as \"& id-expression\" where the & is optional if the name\n+\t    refers to a function or array, or if the corresponding\n+\t    template-parameter is a reference.\n \t    \n-\t       The call to decay_conversion performs the\n-\t       array-to-pointer conversion, if appropriate.  */\n-\t    expr = decay_conversion (expr);\n+\tHere, we do not care about functions, as they are invalid anyway\n+\tfor a parameter of type pointer-to-object.  */\n+      bool constant_address_p =\n+\t(TREE_CODE (expr) == ADDR_EXPR\n+\t || TREE_CODE (expr_type) == ARRAY_TYPE\n+\t || (DECL_P (expr) && DECL_TEMPLATE_PARM_P (expr)));\n+\n+      expr = decay_conversion (expr);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n \n-\t    if (expr == error_mark_node)\n-\t      return error_mark_node;\n-\t    else\n-\t      return perform_qualification_conversions (type, expr);\n-\t  }\n-      }\n-      break;\n+      expr = perform_qualification_conversions (type, expr);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n \n-    case REFERENCE_TYPE:\n-      {\n-\ttree type_referred_to = TREE_TYPE (type);\n+      if (!constant_address_p)\n+\t{\n+\t    error (\"%qE is not a valid template argument for type %qT \"\n+\t\t  \"because it is not a constant pointer\", expr, type);\n+\t    return NULL_TREE;\n+\t}\n+    }\n+  /* [temp.arg.nontype]/5, bullet 3\n \n-\t/* If this expression already has reference type, get the\n-\t   underlying object.  */\n-\tif (TREE_CODE (expr_type) == REFERENCE_TYPE) \n-\t  {\n-\t    if (TREE_CODE (expr) == NOP_EXPR\n-\t\t&& TREE_CODE (TREE_OPERAND (expr, 0)) == ADDR_EXPR)\n-\t      STRIP_NOPS (expr);\n-\t    gcc_assert (TREE_CODE (expr) == ADDR_EXPR);\n-\t    expr = TREE_OPERAND (expr, 0);\n-\t    expr_type = TREE_TYPE (expr);\n-\t  }\n+     For a non-type template-parameter of type reference to object, no\n+     conversions apply. The type referred to by the reference may be more\n+     cv-qualified than the (otherwise identical) type of the\n+     template-argument. The template-parameter is bound directly to the\n+     template-argument, which must be an lvalue.  */\n+  else if (TYPE_REF_OBJ_P (type))\n+    {\n+      if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (type),\n+\t\t\t\t\t\t      expr_type))\n+\treturn error_mark_node;\n \n-\tif (TREE_CODE (type_referred_to) == FUNCTION_TYPE)\n-\t  {\n-\t    /* For a non-type template-parameter of type reference to\n-\t       function, no conversions apply.  If the\n-\t       template-argument represents a set of overloaded\n-\t       functions, the matching function is selected from the\n-\t       set (_over.over_).  */\n-\t    tree fn;\n+      if (!at_least_as_qualified_p (TREE_TYPE (type), expr_type))\n+\t{\n+\t  error (\"%qE is not a valid template argument for type %qT \"\n+\t\t \"because of conflicts in cv-qualification\", expr, type);\n+\t  return NULL_TREE;\n+\t}\n+\t\n+      if (!real_lvalue_p (expr))\n+\t{\n+\t  error (\"%qE is not a valid template argument for type %qT \"\n+\t         \"because it is not a lvalue\", expr, type);\n+\t  return NULL_TREE;\n+\t}\n \n-\t    fn = instantiate_type (type_referred_to, expr, tf_none);\n+      /* [temp.arg.nontype]/1\n \n-\t    if (fn == error_mark_node)\n-\t      return error_mark_node;\n+\t A template-argument for a non-type, non-template template-parameter\n+\t shall be one of: [...]\n \n-\t    if (!DECL_EXTERNAL_LINKAGE_P (fn))\n-\t      {\n-\t\tif (really_overloaded_fn (expr))\n-\t\t  /* Don't issue an error here; we might get a different\n-\t\t     function if the overloading had worked out\n-\t\t     differently.  */\n-\t\t  return error_mark_node;\n-\t\telse\n-\t\t  goto bad_argument;\n-\t      }\n+\t -- the address of an object or function with external linkage.   */\n+      if (!DECL_EXTERNAL_LINKAGE_P (expr))\n+\t{\n+\t  error (\"%qE is not a valid template argument for type %qT \"\n+\t\t \"because object %qD has not external linkage\",\n+\t\t expr, type, expr);\n+\t  return NULL_TREE;\n+\t}\n \n-\t    gcc_assert (same_type_p (type_referred_to, TREE_TYPE (fn)));\n-\t    expr = fn;\n-\t  }\n-\telse\n-\t  {\n-\t    /* For a non-type template-parameter of type reference to\n-\t       object, no conversions apply.  The type referred to by the\n-\t       reference may be more cv-qualified than the (otherwise\n-\t       identical) type of the template-argument.  The\n-\t       template-parameter is bound directly to the\n-\t       template-argument, which must be an lvalue.  */\n-\t    if (!same_type_p (TYPE_MAIN_VARIANT (expr_type),\n-\t\t\t      TYPE_MAIN_VARIANT (type_referred_to))\n-\t\t|| !at_least_as_qualified_p (type_referred_to,\n-\t\t\t\t\t     expr_type)\n-\t\t|| !real_lvalue_p (expr))\n-\t      return error_mark_node;\n-\t  }\n+      expr = build_nop (type, build_address (expr));\n+    }\n+  /* [temp.arg.nontype]/5, bullet 4\n \n-\tcxx_mark_addressable (expr);\n-\treturn build_nop (type, build_address (expr));\n-      }\n-      break;\n+     For a non-type template-parameter of type pointer to function, only\n+     the function-to-pointer conversion (_conv.func_) is applied. If the\n+     template-argument represents a set of overloaded functions (or a\n+     pointer to such), the matching function is selected from the set\n+     (_over.over_).  */\n+  else if (TYPE_PTRFN_P (type))\n+    {\n+      /* If the argument is a template-id, we might not have enough\n+         context information to decay the pointer.\n+\t ??? Why static5.C requires decay and subst1.C works fine\n+\t even without it?  */\n+      if (!type_unknown_p (expr_type))\n+\t{\n+\t  expr = decay_conversion (expr);\n+\t  if (expr == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n \n-    case RECORD_TYPE:\n-      {\n-\tgcc_assert (TYPE_PTRMEMFUNC_P (type));\n+      expr = convert_nontype_argument_function (type, expr);\n+      if (!expr || expr == error_mark_node)\n+\treturn expr;\n+    }\n+  /* [temp.arg.nontype]/5, bullet 5\n \n-\t/* For a non-type template-parameter of type pointer to member\n-\t   function, no conversions apply.  If the template-argument\n-\t   represents a set of overloaded member functions, the\n-\t   matching member function is selected from the set\n-\t   (_over.over_).  */\n+     For a non-type template-parameter of type reference to function, no\n+     conversions apply. If the template-argument represents a set of\n+     overloaded functions, the matching function is selected from the set\n+     (_over.over_).  */\n+  else if (TYPE_REFFN_P (type))\n+    {\n+      if (TREE_CODE (expr) == ADDR_EXPR)\n+\t{\n+\t  error (\"%qE is not a valid template argument for type %qT \"\n+\t\t \"because it is a pointer\", expr, type);\n+\t  inform (\"try using %qE instead\", TREE_OPERAND (expr, 0));\n+\t  return NULL_TREE;\n+\t}\n \n-\tif (!TYPE_PTRMEMFUNC_P (expr_type) && \n-\t    expr_type != unknown_type_node)\n-\t  return error_mark_node;\n+      expr = convert_nontype_argument_function (TREE_TYPE (type), expr);\n+      if (!expr || expr == error_mark_node)\n+\treturn expr;\n \n-\tif (TREE_CODE (expr) == PTRMEM_CST)\n-\t  {\n-\t    /* A ptr-to-member constant.  */\n-\t    if (!same_type_p (type, expr_type))\n-\t      return error_mark_node;\n-\t    else \n-\t      return expr;\n-\t  }\n+      expr = build_nop(type, build_address (expr));\n+    }\n+  /* [temp.arg.nontype]/5, bullet 6\n \n-\tif (TREE_CODE (expr) != ADDR_EXPR)\n-\t  return error_mark_node;\n+     For a non-type template-parameter of type pointer to member function,\n+     no conversions apply. If the template-argument represents a set of\n+     overloaded member functions, the matching member function is selected\n+     from the set (_over.over_).  */\n+  else if (TYPE_PTRMEMFUNC_P (type))\n+    {\n+      expr = instantiate_type (type, expr, tf_none);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n \n-\texpr = instantiate_type (type, expr, tf_none);\n-\t\n-\tif (expr == error_mark_node)\n-\t  return error_mark_node;\n+      /* There is no way to disable standard conversions in\n+\t resolve_address_of_overloaded_function (called by\n+\t instantiate_type). It is possible that the call succeeded by\n+\t converting &B::I to &D::I (where B is a base of D), so we need\n+\t to reject this conversion here.\n \n-\tif (!same_type_p (type, TREE_TYPE (expr)))\n-\t  return error_mark_node;\n+\t Actually, even if there was a way to disable standard conversions,\n+\t it would still be better to reject them here so that we can\n+\t provide a superior diagnostic.  */\n+      if (!same_type_p (TREE_TYPE (expr), type))\n+\t{\n+\t  /* Make sure we are just one standard conversion off.  */\n+\t  gcc_assert (can_convert (type, TREE_TYPE (expr)));\n+\t  error (\"%qE is not a valid template argument for type %qT \"\n+\t\t \"because it is of type %qT\", expr, type,\n+\t\t TREE_TYPE (expr));\n+\t  inform (\"standard conversions are not allowed in this context\");\n+\t  return NULL_TREE;\n+\t}\n+    }\n+  /* [temp.arg.nontype]/5, bullet 7\n \n+     For a non-type template-parameter of type pointer to data member,\n+     qualification conversions (_conv.qual_) are applied.  */\n+  else if (TYPE_PTRMEM_P (type))\n+    {\n+      expr = perform_qualification_conversions (type, expr);\n+      if (expr == error_mark_node)\n \treturn expr;\n-      }\n-      break;\n-\n-    default:\n-      /* All non-type parameters must have one of these types.  */\n-      gcc_unreachable ();\n     }\n+  /* A template non-type parameter must be one of the above.  */\n+  else\n+    gcc_unreachable ();\n \n-  return error_mark_node;\n+  /* Sanity check: did we actually convert the argument to the\n+     right type?  */\n+  gcc_assert (same_type_p (type, TREE_TYPE (expr)));\n+  return expr;\n }\n \n+\n /* Return 1 if PARM_PARMS and ARG_PARMS matches using rule for \n    template template parameters.  Both PARM_PARMS and ARG_PARMS are \n    vectors of TREE_LIST nodes containing TYPE_DECL, TEMPLATE_DECL \n@@ -4300,7 +4286,14 @@ maybe_get_template_decl_from_type_decl (tree decl)\n \n    If the template class is really a local class in a template\n    function, then the FUNCTION_CONTEXT is the function in which it is\n-   being instantiated.  */\n+   being instantiated.  \n+\n+   ??? Note that this function is currently called *twice* for each\n+   template-id: the first time from the parser, while creating the\n+   incomplete type (finish_template_type), and the second type during the\n+   real instantiation (instantiate_template_class). This is surely something\n+   that we want to avoid. It also causes some problems with argument\n+   coercion (see convert_nontype_argument for more information on this).  */\n \n tree\n lookup_template_class (tree d1, "}, {"sha": "770171aac035dab3bdb357f6d1e9b43ba147c3e8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -1,3 +1,13 @@\n+2004-11-04  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\t* g++.dg/template/nontype7.C: New test.\n+\t* g++.dg/template/nontype8.C: Likewise.\n+\t* g++.dg/template/nontype9.C: Likewise.\n+\t* g++.dg/template/nontype10.C: Likewise.\n+\t* g++.dg/tc1/dr49.C: Likewise.\n+\t* g++.dg/template/ptrmem8.C: Relax dg-error checks.\n+\t* g++.old-deja/g++.other/null1.C: Remove a buggy error check\n+\n 2004-11-04  Ben Elliston  <bje@au.ibm.com>\n \n \t* g++.dg/rtti/tinfo1.C: Remove xfails."}, {"sha": "f880e2ac36ac6c164a288e4a449c8d8276ee6662", "filename": "gcc/testsuite/g++.dg/tc1/dr49.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftc1%2Fdr49.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftc1%2Fdr49.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftc1%2Fdr49.C?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+// Contributed by: Giovanni Bajo <giovannibajo at gcc dot gnu dot org>\n+// DR 49: Non-constant pointers are invalid template arguments.\n+\n+template<int *a> struct R { /* ... */ };\n+template<int b[5]> struct S { /* ... */ };\n+\n+int p;\n+template struct R<&p>; // OK\n+template struct S<&p>; // OK due to parameter adjustment\n+\n+int *ptr;\n+template struct R<ptr>; // { dg-error \"constant\" }\n+template struct S<ptr>; // { dg-error \"constant\" }\n+\n+int v[5];\n+template struct R<v>; // OK due to implicit argument conversion\n+template struct S<v>; // OK due to both adjustment and conversion\n+"}, {"sha": "cd3a3aabd7f8ae173c13c94407ef275a0c291f9c", "filename": "gcc/testsuite/g++.dg/template/nontype10.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype10.C?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile }\n+// Contributed by: Giovanni Bajo <giovannibajo at gcc dot gnu dot org>\n+#include <cstddef>\n+\n+template <int  T> struct A {};\n+template <void* T> struct B {};\n+\n+A<NULL> a;\n+B<NULL> b;  // { dg-error \"\" }\n+"}, {"sha": "5eac558e4517084a917bd3d67accdb6309687e3a", "filename": "gcc/testsuite/g++.dg/template/nontype7.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype7.C?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+// Origin: C++ standard, [temp.arg.nontype]/2\n+\n+template<class T, char* p> struct X {\n+  X();\n+  X(const char* q) { /* ... */ }\n+};\n+\n+char p[] = \"Vivisectionist\";\n+\n+X<int,\"Studebaker\"> x1;    // { dg-error \"string literal\" }\n+X<int, p> x2;\n+\n+// { dg-bogus \"\" \"additional errors\" { xfail *-*-* } 11 }\n+"}, {"sha": "d2976dfc04756bfd898aa38b3319ef518f901471", "filename": "gcc/testsuite/g++.dg/template/nontype8.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype8.C?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile }\n+// Origin: C++ standard, [temp.arg.nontype]/3\n+\n+template<int* p> class X { };\n+\n+int a[10];\n+struct S { int m; static int s; } s;\n+\n+X<&a[2]> x3;                    // { dg-error \"\" } address of array element\n+X<&s.m> x4;                     // { dg-error \"\" } address of non-static member\n+X<&s.s> x5;                     // { dg-error \"\" } &S::s must be used\n+X<&S::s> x6;                    // OK: address of static member\n+"}, {"sha": "f381240e30108ddfe046c19384a90818458b276c", "filename": "gcc/testsuite/g++.dg/template/nontype9.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype9.C?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile  }\n+// Contributed by: Giovanni Bajo <giovannibajo at gcc dot gnu dot org>\n+int i;\n+\n+template <void (&FN)()>\n+struct g {\n+  void foo(void) {\n+    FN ();\n+  }\n+};\n+\n+void h ()\n+{\n+  i = 7;\n+}\n+\n+template struct g<h>;\n+"}, {"sha": "588ac1fc50a2fc5caea7d9b194e188870787a3a3", "filename": "gcc/testsuite/g++.dg/template/ptrmem8.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem8.C?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -15,6 +15,6 @@ template <int (D::*fun)() const> int Get();\n \n int main () \n {\n-  Get<&B::I>();   // { dg-error \"no matching function\" }\n-  Get<&D::I>();   // { dg-error \"no matching function\" }\n+  Get<&B::I>();   // { dg-error \"\" }\n+  Get<&D::I>();   // { dg-error \"\" }\n }"}, {"sha": "f4e97b9abcc24caa8ad414307770f7b5d8470e1a", "filename": "gcc/testsuite/g++.old-deja/g++.other/null1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnull1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnull1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnull1.C?ref=b6ab6892cc9faed44e07be5e7e9d389c35f4dbb6", "patch": "@@ -38,7 +38,7 @@ int main()\n   z = NULL;  // { dg-warning \"\" } converting NULL to non-pointer type\n   k(NULL);   // { dg-warning \"\" } converting NULL to int\n   g(NULL);   // { dg-warning \"\" } converting NULL to int\n-  h<NULL>(); // { dg-warning \"\" } NULL bound to integer template parameter\n+  h<NULL>(); // No warning: NULL bound to integer template parameter\n   l(NULL);   // { dg-warning \"\" } converting NULL to int\n   NULL && NULL; // No warning: converting NULL to bool is OK\n }"}]}