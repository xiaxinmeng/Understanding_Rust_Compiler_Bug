{"sha": "8f3e7a26bde8797649fff46419ac6c6b71c95f78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYzZTdhMjZiZGU4Nzk3NjQ5ZmZmNDY0MTlhYzZjNmI3MWM5NWY3OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T21:43:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T21:43:38Z"}, "message": "(reg_used_between_p): Check usage exprs on CALL_INSNs.\n\n(reg_referenced_between_p, reg_set_p, dead_or_set_regno_p): Likewise.\n(find_reg{,no}_fusage): New functions.\n\nFrom-SVN: r7235", "tree": {"sha": "8519ea9678cbfc1a38a3dba35811138854615389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8519ea9678cbfc1a38a3dba35811138854615389"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f3e7a26bde8797649fff46419ac6c6b71c95f78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f3e7a26bde8797649fff46419ac6c6b71c95f78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f3e7a26bde8797649fff46419ac6c6b71c95f78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f3e7a26bde8797649fff46419ac6c6b71c95f78/comments", "author": null, "committer": null, "parents": [{"sha": "e51c6661ff575384cb5e180eacf0b14e6f6d079e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e51c6661ff575384cb5e180eacf0b14e6f6d079e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e51c6661ff575384cb5e180eacf0b14e6f6d079e"}], "stats": {"total": 105, "additions": 101, "deletions": 4}, "files": [{"sha": "980226f2b645f12ad830c63ce6505365ed13cb0f", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 101, "deletions": 4, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3e7a26bde8797649fff46419ac6c6b71c95f78/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3e7a26bde8797649fff46419ac6c6b71c95f78/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=8f3e7a26bde8797649fff46419ac6c6b71c95f78", "patch": "@@ -315,7 +315,10 @@ reg_used_between_p (reg, from_insn, to_insn)\n \n   for (insn = NEXT_INSN (from_insn); insn != to_insn; insn = NEXT_INSN (insn))\n     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t&& reg_overlap_mentioned_p (reg, PATTERN (insn)))\n+\t&& (reg_overlap_mentioned_p (reg, PATTERN (insn))\n+\t   || (GET_CODE (insn) == CALL_INSN\n+\t      && (find_reg_fusage (insn, USE, reg)\n+\t\t  || find_reg_fusage (insn, CLOBBER, reg)))))\n       return 1;\n   return 0;\n }\n@@ -393,7 +396,9 @@ reg_referenced_between_p (reg, from_insn, to_insn)\n \n   for (insn = NEXT_INSN (from_insn); insn != to_insn; insn = NEXT_INSN (insn))\n     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t&& reg_referenced_p (reg, PATTERN (insn)))\n+\t&& (reg_referenced_p (reg, PATTERN (insn))\n+\t   || (GET_CODE (insn) == CALL_INSN\n+\t      && find_reg_fusage (insn, USE, reg))))\n       return 1;\n   return 0;\n }\n@@ -448,10 +453,14 @@ reg_set_p (reg, insn)\n \t  || (GET_CODE (insn) == CALL_INSN\n \t      /* We'd like to test call_used_regs here, but rtlanal.c can't\n \t\t reference that variable due to its use in genattrtab.  So\n-\t\t we'll just be more conservative.  */\n+\t\t we'll just be more conservative.\n+\n+\t\t ??? Unless we could ensure that the CALL_INSN_FUNCTION_USAGE\n+\t\t information holds all clobbered registers.  */\n \t      && ((GET_CODE (reg) == REG\n \t\t   && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n-\t\t  || GET_CODE (reg) == MEM)))\n+\t\t  || GET_CODE (reg) == MEM\n+\t\t  || find_reg_fusage (insn, CLOBBER, reg))))\n \treturn 1;\n \n       body = PATTERN (insn);\n@@ -1130,6 +1139,10 @@ dead_or_set_regno_p (insn, test_regno)\n \treturn 1;\n     }\n \n+  if (GET_CODE (insn) == CALL_INSN\n+      && find_regno_fusage (insn, CLOBBER, test_regno))\n+    return 1;\n+\n   if (GET_CODE (PATTERN (insn)) == SET)\n     {\n       rtx dest = SET_DEST (PATTERN (insn));\n@@ -1233,6 +1246,90 @@ find_regno_note (insn, kind, regno)\n       return link;\n   return 0;\n }\n+\n+/* Return true if DATUM, or any overlap of DATUM, of kind CODE is found\n+   in the CALL_INSN_FUNCTION_USAGE information of INSN.  */\n+\n+int\n+find_reg_fusage (insn, code, datum)\n+     rtx insn;\n+     enum rtx_code code;\n+     rtx datum;\n+{\n+  /* If it's not a CALL_INSN, it can't possibly have a\n+     CALL_INSN_FUNCTION_USAGE field, so don't bother checking.  */\n+  if (GET_CODE (insn) != CALL_INSN)\n+    return 0;\n+\n+  if (! datum)\n+    abort();\n+\n+  if (GET_CODE (datum) != REG)\n+    {\n+      register rtx link;\n+\n+      for (link = CALL_INSN_FUNCTION_USAGE (insn);\n+           link;\n+\t   link = XEXP (link, 1))\n+        if (GET_CODE (XEXP (link, 0)) == code\n+\t    && rtx_equal_p (datum, SET_DEST (XEXP (link, 0))))\n+          return 1;\n+    }\n+  else\n+    {\n+      register int regno = REGNO (datum);\n+\n+      /* CALL_INSN_FUNCTION_USAGE information cannot contain references\n+\t to pseudo registers, so don't bother checking.  */\n+\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+        {\n+\t  int end_regno = regno + HARD_REGNO_NREGS (regno, GET_MODE (datum));\n+\t  int i;\n+\n+\t  for (i = regno; i < end_regno; i++)\n+\t    if (find_regno_fusage (insn, code, i))\n+\t      return 1;\n+        }\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return true if REGNO, or any overlap of REGNO, of kind CODE is found\n+   in the CALL_INSN_FUNCTION_USAGE information of INSN.  */\n+\n+int\n+find_regno_fusage (insn, code, regno)\n+     rtx insn;\n+     enum rtx_code code;\n+     int regno;\n+{\n+  register rtx link;\n+\n+  /* CALL_INSN_FUNCTION_USAGE information cannot contain references\n+     to pseudo registers, so don't bother checking.  */\n+\n+  if (regno >= FIRST_PSEUDO_REGISTER\n+      || GET_CODE (insn) != CALL_INSN )\n+    return 0;\n+\n+  for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n+   {\n+    register int regnote;\n+    register rtx op;\n+\n+    if (GET_CODE (op = XEXP (link, 0)) == code\n+\t&& GET_CODE (SET_DEST (op)) == REG\n+\t&& (regnote = REGNO (SET_DEST (op))) <= regno\n+\t&& regnote\n+\t\t+ HARD_REGNO_NREGS (regnote, GET_MODE (SET_DEST (op)))\n+\t    > regno)\n+      return 1;\n+   }\n+\n+  return 0;\n+}\n \f\n /* Remove register note NOTE from the REG_NOTES of INSN.  */\n "}]}