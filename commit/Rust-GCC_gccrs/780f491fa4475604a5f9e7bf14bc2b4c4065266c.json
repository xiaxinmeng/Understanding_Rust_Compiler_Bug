{"sha": "780f491fa4475604a5f9e7bf14bc2b4c4065266c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgwZjQ5MWZhNDQ3NTYwNGE1ZjllN2JmMTRiYzJiNGM0MDY1MjY2Yw==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-03-02T19:21:27Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-03-02T19:21:27Z"}, "message": "(pa_adjust_cost): New procudure.\n\nFrom-SVN: r3597", "tree": {"sha": "8c27952cc350b1cfae4447fb3b80729502ccfeb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c27952cc350b1cfae4447fb3b80729502ccfeb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/780f491fa4475604a5f9e7bf14bc2b4c4065266c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780f491fa4475604a5f9e7bf14bc2b4c4065266c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/780f491fa4475604a5f9e7bf14bc2b4c4065266c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780f491fa4475604a5f9e7bf14bc2b4c4065266c/comments", "author": null, "committer": null, "parents": [{"sha": "1150aa7087ef10eaceb12009c4177c4056997e8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1150aa7087ef10eaceb12009c4177c4056997e8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1150aa7087ef10eaceb12009c4177c4056997e8b"}], "stats": {"total": 96, "additions": 96, "deletions": 0}, "files": [{"sha": "1b3d5ddeaf426640a919998d5cef00ecbd4c15a1", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780f491fa4475604a5f9e7bf14bc2b4c4065266c/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780f491fa4475604a5f9e7bf14bc2b4c4065266c/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=780f491fa4475604a5f9e7bf14bc2b4c4065266c", "patch": "@@ -2061,6 +2061,102 @@ gen_cmp_fp (code, operand0, operand1)\n \t\t  gen_rtx (code, CCFPmode, operand0, operand1));\n }\n \n+/* Adjust the cost of a scheduling dependency.  Return the new cost of\n+   a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n+\n+int\n+pa_adjust_cost (insn, link, dep_insn, cost)\n+     rtx insn;\n+     rtx link;\n+     rtx dep_insn;\n+     int cost;\n+{\n+  /* If the dependence is an anti-dependence, there is no cost.  For an\n+     output dependence, there is sometimes a cost, but it doesn't seem\n+     worth handling those few cases.  */\n+\n+  if (REG_NOTE_KIND (link) == 0)\n+    {\n+      /* Data dependency; DEP_INSN writes a register that INSN reads some\n+\t cycles later.  */\n+\n+      if (get_attr_type (insn) == TYPE_FPSTORE)\n+\t{\n+\t  if (GET_CODE (PATTERN (insn)) != SET\n+\t      || GET_CODE (PATTERN (dep_insn)) != SET)\n+\t    /* If this happens, we have to extend this to schedule\n+\t       optimally.  */\n+\t    abort();\n+\n+\t  if (rtx_equal_p (SET_DEST (PATTERN (dep_insn)), SET_SRC (PATTERN (insn))))\n+\t    {\n+\t      /* INSN is a fp store and DEP_INSN is writing to the register\n+\t\t being stored.  */\n+\t      switch (get_attr_type (dep_insn))\n+\t\t{\n+\t\tcase TYPE_FPLOAD:\n+\t\t  /* This cost 3 cycles, not 2 as the md says.  */\n+\t\t  return cost + 1;\n+\n+\t\tcase TYPE_FPALU:\n+\t\tcase TYPE_FPMUL:\n+\t\tcase TYPE_FPDIVSGL:\n+\t\tcase TYPE_FPDIVDBL:\n+\t\tcase TYPE_FPSQRTSGL:\n+\t\tcase TYPE_FPSQRTDBL:\n+\t\t  /* In these important cases, we save one cycle compared to\n+\t\t     when flop instruction feed each other.  */\n+\t\t  return cost - 1;\n+\n+\t\tdefault:\n+\t\t  return cost;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* For other data dependencies, the default cost specified in the\n+\t md is correct.  */\n+      return cost;\n+    }\n+  else if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n+    {\n+      /* Anti dependency; DEP_INSN reads a register that INSN writes some\n+\t cycles later.  */\n+\n+      if (get_attr_type (insn) == TYPE_FPLOAD)\n+\t{\n+\t  if (GET_CODE (PATTERN (insn)) != SET\n+\t      || GET_CODE (PATTERN (dep_insn)) != SET)\n+\t    /* If this happens, we have to extend this to schedule\n+\t       optimally.  */\n+\t    abort();\n+\n+\t  if (rtx_equal_p (SET_SRC (PATTERN (dep_insn)), SET_DEST (PATTERN (insn))))\n+\t    {\n+\t      switch (get_attr_type (dep_insn))\n+\t\t{\n+\t\tcase TYPE_FPALU:\n+\t\tcase TYPE_FPMUL:\n+\t\tcase TYPE_FPDIVSGL:\n+\t\tcase TYPE_FPDIVDBL:\n+\t\tcase TYPE_FPSQRTSGL:\n+\t\tcase TYPE_FPSQRTDBL:\n+\t\t  return cost - 1;\n+\n+\t\tdefault:\n+\t\t  return 0;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* For other anti dependencies, the cost is 0.  */\n+      return 0;\n+    }\n+\n+  /* For all other cases of anti dependency and all cases of output\n+     dependence the md is correct enough for the PA7000.  */\n+  return cost;\n+}\n \n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified."}]}