{"sha": "9f8e62437fbd291bf0f947608a97b910b8f60f37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY4ZTYyNDM3ZmJkMjkxYmYwZjk0NzYwOGE5N2I5MTBiOGY2MGYzNw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1998-05-28T07:32:33Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1998-05-28T07:32:33Z"}, "message": "Flow now removes exception regions when their handlers are all removed.\n\nFrom-SVN: r20115", "tree": {"sha": "1ae90a1f7e7acf9282967693b1700bd18248222e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ae90a1f7e7acf9282967693b1700bd18248222e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f8e62437fbd291bf0f947608a97b910b8f60f37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f8e62437fbd291bf0f947608a97b910b8f60f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f8e62437fbd291bf0f947608a97b910b8f60f37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f8e62437fbd291bf0f947608a97b910b8f60f37/comments", "author": null, "committer": null, "parents": [{"sha": "d05a5492a531fbee813b2f365fa68127ff445af3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05a5492a531fbee813b2f365fa68127ff445af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d05a5492a531fbee813b2f365fa68127ff445af3"}], "stats": {"total": 87, "additions": 65, "deletions": 22}, "files": [{"sha": "1bb223c463db5c40d774e0907cd4507b6c1f2eed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f8e62437fbd291bf0f947608a97b910b8f60f37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f8e62437fbd291bf0f947608a97b910b8f60f37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f8e62437fbd291bf0f947608a97b910b8f60f37", "patch": "@@ -1,3 +1,11 @@\n+Thu May 28 10:22:22 EDT 1998  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* except.h (remove_handler): Add new prototype.\n+\t* except.c (remove_handler): New function to remove handlers\n+\tfrom an exception region.\n+\t* flow.c (find_basic_blocks_1): Remove handlers from regions when\n+\thandler label is deleted; remove exception regions with no handlers.\n+\n Thu May 28 09:36:39 1998  Michael Meissner  <meissner@cygnus.com>\n \n \t* except.h (rtx): Define rtx type correctly if needed."}, {"sha": "5881e223d6477bbe243ef059021a2117400e8fde", "filename": "gcc/except.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f8e62437fbd291bf0f947608a97b910b8f60f37/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f8e62437fbd291bf0f947608a97b910b8f60f37/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=9f8e62437fbd291bf0f947608a97b910b8f60f37", "patch": "@@ -754,6 +754,34 @@ add_new_handler (region, newhandler)\n     }\n }\n \n+/* Remove a handler label. The handler label is being deleted, so all\n+   regions which reference this handler should have it removed from their\n+   list of possible handlers. Any region which has the final handler\n+   removed can be deleted. */\n+\n+void remove_handler (removing_label)\n+     rtx removing_label;\n+{\n+  struct handler_info *handler, *last;\n+  int x;\n+  for (x = 0 ; x < current_func_eh_entry; ++x)\n+    {\n+      last = NULL;\n+      handler = function_eh_regions[x].handlers;\n+      for ( ; handler; last = handler, handler = handler->next)\n+        if (handler->handler_label == removing_label)\n+          {\n+            if (last)\n+              {\n+                last->next = handler->next;\n+                handler = last;\n+              }\n+            else\n+              function_eh_regions[x].handlers = handler->next;\n+          }\n+    }\n+}\n+\n /* Create a new handler structure initialized with the handler label and\n    typeinfo fields passed in. */\n "}, {"sha": "d2523cb2a81b9fc002ca4b16342bf62c0cbf3f46", "filename": "gcc/except.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f8e62437fbd291bf0f947608a97b910b8f60f37/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f8e62437fbd291bf0f947608a97b910b8f60f37/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=9f8e62437fbd291bf0f947608a97b910b8f60f37", "patch": "@@ -191,6 +191,13 @@ int new_eh_region_entry                         PROTO((int));\n \n void add_new_handler                       PROTO((int, struct handler_info *));\n \n+/* Remove a handler label. The handler label is being deleted, so all\n+   regions which reference this handler should have it removed from their\n+   list of possible handlers. Any region which has the final handler\n+   removed can be deleted. */\n+\n+void remove_handler                        PROTO((rtx));\n+\n /* Create a new handler structure initialized with the handler label and\n    typeinfo fields passed in. */\n "}, {"sha": "8021b4e2c89432e637641a08d6bfda7ea592a0a4", "filename": "gcc/flow.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f8e62437fbd291bf0f947608a97b910b8f60f37/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f8e62437fbd291bf0f947608a97b910b8f60f37/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=9f8e62437fbd291bf0f947608a97b910b8f60f37", "patch": "@@ -404,6 +404,7 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n   enum rtx_code prev_code, code;\n   int depth, pass;\n   int in_libcall_block = 0;\n+  int deleted_handler = 0;\n \n   pass = 1;\n   active_eh_region = (int *) alloca ((max_uid_for_flow + 1) * sizeof (int));\n@@ -770,28 +771,9 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t\t\t    XEXP (x, 1) = NULL_RTX;\n \t\t\t    XEXP (x, 0) = NULL_RTX;\n \n-\t\t\t    /* Now we have to find the EH_BEG and EH_END notes\n-\t\t\t       associated with this label and remove them.  */\n-\n-#if 0\n-/* Handlers and labels no longer needs to have the same values.\n-   If there are no references, scan_region will remove any region\n-   labels which are of no use. */\n-\t\t\t    for (x = get_insns (); x; x = NEXT_INSN (x))\n-\t\t\t      {\n-\t\t\t\tif (GET_CODE (x) == NOTE\n-\t\t\t\t    && ((NOTE_LINE_NUMBER (x)\n-\t\t\t\t\t == NOTE_INSN_EH_REGION_BEG)\n-\t\t\t\t\t|| (NOTE_LINE_NUMBER (x)\n-\t\t\t\t\t    == NOTE_INSN_EH_REGION_END))\n-\t\t\t\t    && (NOTE_BLOCK_NUMBER (x)\n-\t\t\t\t\t== CODE_LABEL_NUMBER (insn)))\n-\t\t\t\t  {\n-\t\t\t\t    NOTE_LINE_NUMBER (x) = NOTE_INSN_DELETED;\n-\t\t\t\t    NOTE_SOURCE_FILE (x) = 0;\n-\t\t\t\t  }\n-\t\t\t      }\n-#endif\n+                            /* Remove the handler from all regions */\n+                            remove_handler (insn);\n+                            deleted_handler = 1;\n \t\t\t    break;\n \t\t\t  }\n \t\t\tprev = &XEXP (x, 1);\n@@ -861,6 +843,24 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t\t    }\n \t      }\n \t  }\n+      /* If we deleted an exception handler, we may have EH region\n+         begin/end blocks to remove as well. */\n+      if (deleted_handler)\n+        for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+          if (GET_CODE (insn) == NOTE)\n+            {\n+              if ((NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG) ||\n+                  (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)) \n+                {\n+                  int num = CODE_LABEL_NUMBER (insn);\n+                  /* A NULL handler indicates a region is no longer needed */\n+                  if (get_first_handler (num) == NULL)\n+                    {\n+                      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+                      NOTE_SOURCE_FILE (insn) = 0;\n+                    }\n+                }\n+            }\n \n       /* There are pathological cases where one function calling hundreds of\n \t nested inline functions can generate lots and lots of unreachable"}]}