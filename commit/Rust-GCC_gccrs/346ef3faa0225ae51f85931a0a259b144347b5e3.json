{"sha": "346ef3faa0225ae51f85931a0a259b144347b5e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ2ZWYzZmFhMDIyNWFlNTFmODU5MzFhMGEyNTliMTQ0MzQ3YjVlMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-04-16T13:22:03Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-04-16T13:22:03Z"}, "message": "gimple.h (walk_stmt_load_store_addr_ops): Declare.\n\n2009-04-16  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.h (walk_stmt_load_store_addr_ops): Declare.\n\t(walk_stmt_load_store_ops): Likewise.\n\t* gimple.c (get_base_loadstore): New function.\n\t(walk_stmt_load_store_addr_ops): Likewise.\n\t(walk_stmt_load_store_ops): Likewise.\n\t* ipa-pure-const.c (check_op): Simplify.\n\t(check_load, check_store): New functions.\n\t(check_stmt): Use walk_stmt_load_store_ops.\n\t* ipa-reference.c (mark_load): Adjust signature.\n\t(mark_store): Likewise.\n\t(scan_stmt_for_static_refs): Use walk_stmt_load_store_addr_ops.\n\nFrom-SVN: r146190", "tree": {"sha": "23dd4190a75ec3d4a003945074976a4b867c0cdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23dd4190a75ec3d4a003945074976a4b867c0cdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/346ef3faa0225ae51f85931a0a259b144347b5e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/346ef3faa0225ae51f85931a0a259b144347b5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/346ef3faa0225ae51f85931a0a259b144347b5e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/346ef3faa0225ae51f85931a0a259b144347b5e3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9fbb3ae64a8d1c6103f4d4a91e60f1ee8312b3f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fbb3ae64a8d1c6103f4d4a91e60f1ee8312b3f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fbb3ae64a8d1c6103f4d4a91e60f1ee8312b3f3"}], "stats": {"total": 403, "additions": 278, "deletions": 125}, "files": [{"sha": "7bcff75da26a8ec1ec397ee9a6c2010750721832", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/346ef3faa0225ae51f85931a0a259b144347b5e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/346ef3faa0225ae51f85931a0a259b144347b5e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=346ef3faa0225ae51f85931a0a259b144347b5e3", "patch": "@@ -1,3 +1,17 @@\n+2009-04-16  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.h (walk_stmt_load_store_addr_ops): Declare.\n+\t(walk_stmt_load_store_ops): Likewise.\n+\t* gimple.c (get_base_loadstore): New function.\n+\t(walk_stmt_load_store_addr_ops): Likewise.\n+\t(walk_stmt_load_store_ops): Likewise.\n+\t* ipa-pure-const.c (check_op): Simplify.\n+\t(check_load, check_store): New functions.\n+\t(check_stmt): Use walk_stmt_load_store_ops.\n+\t* ipa-reference.c (mark_load): Adjust signature.\n+\t(mark_store): Likewise.\n+\t(scan_stmt_for_static_refs): Use walk_stmt_load_store_addr_ops.\n+\n 2009-04-16  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* gcc-plugin.h (plugin_event): Add PLUGIN_INFO."}, {"sha": "29692782aed894ca26d708a11f10d0b3db2705b8", "filename": "gcc/gimple.c", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/346ef3faa0225ae51f85931a0a259b144347b5e3/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/346ef3faa0225ae51f85931a0a259b144347b5e3/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=346ef3faa0225ae51f85931a0a259b144347b5e3", "patch": "@@ -3194,4 +3194,202 @@ count_uses_and_derefs (tree ptr, gimple stmt, unsigned *num_uses_p,\n   gcc_assert (*num_uses_p >= *num_loads_p + *num_stores_p);\n }\n \n+/* From a tree operand OP return the base of a load or store operation\n+   or NULL_TREE if OP is not a load or a store.  */\n+\n+static tree\n+get_base_loadstore (tree op)\n+{\n+  while (handled_component_p (op))\n+    op = TREE_OPERAND (op, 0);\n+  if (DECL_P (op)\n+      || INDIRECT_REF_P (op)\n+      || TREE_CODE (op) == TARGET_MEM_REF)\n+    return op;\n+  return NULL_TREE;\n+}\n+\n+/* For the statement STMT call the callbacks VISIT_LOAD, VISIT_STORE and\n+   VISIT_ADDR if non-NULL on loads, store and address-taken operands\n+   passing the STMT, the base of the operand and DATA to it.  The base\n+   will be either a decl, an indirect reference (including TARGET_MEM_REF)\n+   or the argument of an address expression.\n+   Returns the results of these callbacks or'ed.  */\n+\n+bool\n+walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n+\t\t\t       bool (*visit_load)(gimple, tree, void *),\n+\t\t\t       bool (*visit_store)(gimple, tree, void *),\n+\t\t\t       bool (*visit_addr)(gimple, tree, void *))\n+{\n+  bool ret = false;\n+  unsigned i;\n+  if (gimple_assign_single_p (stmt))\n+    {\n+      tree lhs, rhs;\n+      if (visit_store)\n+\t{\n+\t  lhs = get_base_loadstore (gimple_assign_lhs (stmt));\n+\t  if (lhs)\n+\t    ret |= visit_store (stmt, lhs, data);\n+\t}\n+      rhs = gimple_assign_rhs1 (stmt);\n+      if (visit_addr)\n+\t{\n+\t  if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t    ret |= visit_addr (stmt, TREE_OPERAND (rhs, 0), data);\n+\t  else if (TREE_CODE (rhs) == TARGET_MEM_REF\n+\t\t   && TREE_CODE (TMR_BASE (rhs)) == ADDR_EXPR)\n+\t    ret |= visit_addr (stmt, TREE_OPERAND (TMR_BASE (rhs), 0), data);\n+\t  else if (TREE_CODE (rhs) == OBJ_TYPE_REF\n+\t\t   && TREE_CODE (OBJ_TYPE_REF_OBJECT (rhs)) == ADDR_EXPR)\n+\t    ret |= visit_addr (stmt, TREE_OPERAND (OBJ_TYPE_REF_OBJECT (rhs),\n+\t\t\t\t\t\t   0), data);\n+\t}\n+      if (visit_load)\n+\t{\n+\t  rhs = get_base_loadstore (rhs);\n+\t  if (rhs)\n+\t    ret |= visit_load (stmt, rhs, data);\n+\t}\n+    }\n+  else if (visit_addr\n+\t   && (is_gimple_assign (stmt)\n+\t       || gimple_code (stmt) == GIMPLE_COND\n+\t       || gimple_code (stmt) == GIMPLE_CHANGE_DYNAMIC_TYPE))\n+    {\n+      for (i = 0; i < gimple_num_ops (stmt); ++i)\n+\tif (gimple_op (stmt, i)\n+\t    && TREE_CODE (gimple_op (stmt, i)) == ADDR_EXPR)\n+\t  ret |= visit_addr (stmt, TREE_OPERAND (gimple_op (stmt, i), 0), data);\n+    }\n+  else if (is_gimple_call (stmt))\n+    {\n+      if (visit_store)\n+\t{\n+\t  tree lhs = gimple_call_lhs (stmt);\n+\t  if (lhs)\n+\t    {\n+\t      lhs = get_base_loadstore (lhs);\n+\t      if (lhs)\n+\t\tret |= visit_store (stmt, lhs, data);\n+\t    }\n+\t}\n+      if (visit_load || visit_addr)\n+\tfor (i = 0; i < gimple_call_num_args (stmt); ++i)\n+\t  {\n+\t    tree rhs = gimple_call_arg (stmt, i);\n+\t    if (visit_addr\n+\t\t&& TREE_CODE (rhs) == ADDR_EXPR)\n+\t      ret |= visit_addr (stmt, TREE_OPERAND (rhs, 0), data);\n+\t    else if (visit_load)\n+\t      {\n+\t\trhs = get_base_loadstore (rhs);\n+\t\tif (rhs)\n+\t\t  ret |= visit_load (stmt, rhs, data);\n+\t      }\n+\t  }\n+      if (visit_addr\n+\t  && gimple_call_chain (stmt)\n+\t  && TREE_CODE (gimple_call_chain (stmt)) == ADDR_EXPR)\n+\tret |= visit_addr (stmt, TREE_OPERAND (gimple_call_chain (stmt), 0),\n+\t\t\t   data);\n+    }\n+  else if (gimple_code (stmt) == GIMPLE_ASM)\n+    {\n+      unsigned noutputs;\n+      const char *constraint;\n+      const char **oconstraints;\n+      bool allows_mem, allows_reg, is_inout;\n+      noutputs = gimple_asm_noutputs (stmt);\n+      oconstraints = XALLOCAVEC (const char *, noutputs);\n+      if (visit_store || visit_addr)\n+\tfor (i = 0; i < gimple_asm_noutputs (stmt); ++i)\n+\t  {\n+\t    tree link = gimple_asm_output_op (stmt, i);\n+\t    tree op = get_base_loadstore (TREE_VALUE (link));\n+\t    if (op && visit_store)\n+\t      ret |= visit_store (stmt, op, data);\n+\t    if (visit_addr)\n+\t      {\n+\t\tconstraint = TREE_STRING_POINTER\n+\t\t    (TREE_VALUE (TREE_PURPOSE (link)));\n+\t\toconstraints[i] = constraint;\n+\t\tparse_output_constraint (&constraint, i, 0, 0, &allows_mem,\n+\t\t\t\t\t &allows_reg, &is_inout);\n+\t\tif (op && !allows_reg && allows_mem)\n+\t\t  ret |= visit_addr (stmt, op, data);\n+\t      }\n+\t  }\n+      if (visit_load || visit_addr)\n+\tfor (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n+\t  {\n+\t    tree link = gimple_asm_input_op (stmt, i);\n+\t    tree op = TREE_VALUE (link);\n+\t    if (visit_addr\n+\t\t&& TREE_CODE (op) == ADDR_EXPR)\n+\t      ret |= visit_addr (stmt, TREE_OPERAND (op, 0), data);\n+\t    else if (visit_load || visit_addr)\n+\t      {\n+\t\top = get_base_loadstore (op);\n+\t\tif (op)\n+\t\t  {\n+\t\t    if (visit_load)\n+\t\t      ret |= visit_load (stmt, op, data);\n+\t\t    if (visit_addr)\n+\t\t      {\n+\t\t\tconstraint = TREE_STRING_POINTER\n+\t\t\t    (TREE_VALUE (TREE_PURPOSE (link)));\n+\t\t\tparse_input_constraint (&constraint, 0, 0, noutputs,\n+\t\t\t\t\t\t0, oconstraints,\n+\t\t\t\t\t\t&allows_mem, &allows_reg);\n+\t\t\tif (!allows_reg && allows_mem)\n+\t\t\t  ret |= visit_addr (stmt, op, data);\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  }\n+    }\n+  else if (gimple_code (stmt) == GIMPLE_RETURN)\n+    {\n+      tree op = gimple_return_retval (stmt);\n+      if (op)\n+\t{\n+\t  if (visit_addr\n+\t      && TREE_CODE (op) == ADDR_EXPR)\n+\t    ret |= visit_addr (stmt, TREE_OPERAND (op, 0), data);\n+\t  else if (visit_load)\n+\t    {\n+\t      op = get_base_loadstore (op);\n+\t      if (op)\n+\t\tret |= visit_load (stmt, op, data);\n+\t    }\n+\t}\n+    }\n+  else if (visit_addr\n+\t   && gimple_code (stmt) == GIMPLE_PHI)\n+    {\n+      for (i = 0; i < gimple_phi_num_args (stmt); ++i)\n+\t{\n+\t  tree op = PHI_ARG_DEF (stmt, i);\n+\t  if (TREE_CODE (op) == ADDR_EXPR)\n+\t    ret |= visit_addr (stmt, TREE_OPERAND (op, 0), data);\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n+/* Like walk_stmt_load_store_addr_ops but with NULL visit_addr.  IPA-CP\n+   should make a faster clone for this case.  */\n+\n+bool\n+walk_stmt_load_store_ops (gimple stmt, void *data,\n+\t\t\t  bool (*visit_load)(gimple, tree, void *),\n+\t\t\t  bool (*visit_store)(gimple, tree, void *))\n+{\n+  return walk_stmt_load_store_addr_ops (stmt, data,\n+\t\t\t\t\tvisit_load, visit_store, NULL);\n+}\n+\n #include \"gt-gimple.h\""}, {"sha": "bf09039a5e97905f9ea7b2a4701ef698af5bab88", "filename": "gcc/gimple.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/346ef3faa0225ae51f85931a0a259b144347b5e3/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/346ef3faa0225ae51f85931a0a259b144347b5e3/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=346ef3faa0225ae51f85931a0a259b144347b5e3", "patch": "@@ -909,6 +909,13 @@ extern tree get_call_expr_in (tree t);\n extern void recalculate_side_effects (tree);\n extern void count_uses_and_derefs (tree, gimple, unsigned *, unsigned *,\n \t\t\t\t   unsigned *);\n+extern bool walk_stmt_load_store_addr_ops (gimple, void *,\n+\t\t\t\t\t   bool (*)(gimple, tree, void *),\n+\t\t\t\t\t   bool (*)(gimple, tree, void *),\n+\t\t\t\t\t   bool (*)(gimple, tree, void *));\n+extern bool walk_stmt_load_store_ops (gimple, void *,\n+\t\t\t\t      bool (*)(gimple, tree, void *),\n+\t\t\t\t      bool (*)(gimple, tree, void *));\n \n /* In gimplify.c  */\n extern tree create_tmp_var_raw (tree, const char *);"}, {"sha": "ca4da1c6a6cf097ed8477f720e1785febb738c24", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 46, "deletions": 80, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/346ef3faa0225ae51f85931a0a259b144347b5e3/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/346ef3faa0225ae51f85931a0a259b144347b5e3/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=346ef3faa0225ae51f85931a0a259b144347b5e3", "patch": "@@ -209,36 +209,28 @@ check_decl (funct_state local,\n    variable T is legal in a function that is either pure or const.  */\n \n static inline void \n-check_op (funct_state local, \n-\t    tree t, bool checking_write)\n+check_op (funct_state local, tree t, bool checking_write)\n {\n-  while (t && handled_component_p (t))\n-    t = TREE_OPERAND (t, 0);\n-  if (!t)\n-    return;\n-  if (INDIRECT_REF_P (t) || TREE_CODE (t) == TARGET_MEM_REF)\n+  if (TREE_THIS_VOLATILE (t))\n     {\n-      if (TREE_THIS_VOLATILE (t)) \n-\t{ \n-\t  local->pure_const_state = IPA_NEITHER;\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"    Volatile indirect ref is not const/pure\\n\");\n-\t  return;\n-\t}\n-      else if (checking_write)\n-\t{ \n-\t  local->pure_const_state = IPA_NEITHER;\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"    Indirect ref write is not const/pure\\n\");\n-\t  return;\n-\t}\n-       else\n-        {\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"    Indirect ref read is not const\\n\");\n-          if (local->pure_const_state == IPA_CONST)\n-\t    local->pure_const_state = IPA_PURE;\n-\t}\n+      local->pure_const_state = IPA_NEITHER;\n+      if (dump_file)\n+\tfprintf (dump_file, \"    Volatile indirect ref is not const/pure\\n\");\n+      return;\n+    }\n+  else if (checking_write)\n+    {\n+      local->pure_const_state = IPA_NEITHER;\n+      if (dump_file)\n+\tfprintf (dump_file, \"    Indirect ref write is not const/pure\\n\");\n+      return;\n+    }\n+  else\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"    Indirect ref read is not const\\n\");\n+      if (local->pure_const_state == IPA_CONST)\n+\tlocal->pure_const_state = IPA_PURE;\n     }\n }\n \n@@ -375,6 +367,30 @@ check_call (funct_state local, gimple call, bool ipa)\n   /* Direct functions calls are handled by IPA propagation.  */\n }\n \n+/* Wrapper around check_decl for loads.  */\n+\n+static bool\n+check_load (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+{\n+  if (DECL_P (op))\n+    check_decl ((funct_state)data, op, false);\n+  else\n+    check_op ((funct_state)data, op, false);\n+  return false;\n+}\n+\n+/* Wrapper around check_decl for stores.  */\n+\n+static bool\n+check_store (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+{\n+  if (DECL_P (op))\n+    check_decl ((funct_state)data, op, true);\n+  else\n+    check_op ((funct_state)data, op, true);\n+  return false;\n+}\n+\n /* Look into pointer pointed to by GSIP and figure out what interesting side\n    effects it has.  */\n static void\n@@ -389,45 +405,8 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n       print_gimple_stmt (dump_file, stmt, 0, 0);\n     }\n \n-  /* Look for direct loads and stores.  */\n-  if (gimple_has_lhs (stmt))\n-    {\n-      tree lhs = get_base_address (gimple_get_lhs (stmt));\n-      if (lhs && DECL_P (lhs))\n-\tcheck_decl (local, lhs, true);\n-    }\n-  if (gimple_assign_single_p (stmt))\n-    {\n-      tree rhs = get_base_address (gimple_assign_rhs1 (stmt));\n-      if (rhs && DECL_P (rhs))\n-\tcheck_decl (local, rhs, false);\n-    }\n-  else if (is_gimple_call (stmt))\n-    {\n-      for (i = 0; i < gimple_call_num_args (stmt); ++i)\n-\t{\n-\t  tree rhs = get_base_address (gimple_call_arg (stmt, i));\n-\t  if (rhs && DECL_P (rhs))\n-\t    check_decl (local, rhs, false);\n-\t}\n-    }\n-  else if (gimple_code (stmt) == GIMPLE_ASM)\n-    {\n-      for (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n-\t{\n-\t  tree op = TREE_VALUE (gimple_asm_input_op (stmt, i));\n-\t  op = get_base_address (op);\n-\t  if (op && DECL_P (op))\n-\t    check_decl (local, op, false);\n-\t}\n-      for (i = 0; i < gimple_asm_noutputs (stmt); ++i)\n-\t{\n-\t  tree op = TREE_VALUE (gimple_asm_output_op (stmt, i));\n-\t  op = get_base_address (op);\n-\t  if (op && DECL_P (op))\n-\t    check_decl (local, op, true);\n-\t}\n-    }\n+  /* Look for loads and stores.  */\n+  walk_stmt_load_store_ops (stmt, local, check_load, check_store);\n \n   if (gimple_code (stmt) != GIMPLE_CALL\n       && stmt_could_throw_p (stmt))\n@@ -447,13 +426,7 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n     }\n   switch (gimple_code (stmt))\n     {\n-    case GIMPLE_ASSIGN:\n-      check_op (local, gimple_assign_lhs (stmt), true);\n-      i = 1;\n-      break;\n     case GIMPLE_CALL:\n-      check_op (local, gimple_call_lhs (stmt), true);\n-      i = 1;\n       check_call (local, stmt, ipa);\n       break;\n     case GIMPLE_LABEL:\n@@ -466,10 +439,6 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n \t}\n       break;\n     case GIMPLE_ASM:\n-      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n-         check_op (local, TREE_VALUE (gimple_asm_output_op (stmt, i)), true);\n-      for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n-         check_op (local, TREE_VALUE (gimple_asm_input_op (stmt, i)), false);\n       for (i = 0; i < gimple_asm_nclobbers (stmt); i++)\n \t{\n \t  tree op = gimple_asm_clobber_op (stmt, i);\n@@ -493,9 +462,6 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n     default:\n       break;\n     }\n-\n-  for (; i < gimple_num_ops (stmt); i++)\n-    check_op (local, gimple_op (stmt, i), false);\n }\n \n "}, {"sha": "d2c20c08d16f32e34e42a26a418fc71f964884c9", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 13, "deletions": 45, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/346ef3faa0225ae51f85931a0a259b144347b5e3/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/346ef3faa0225ae51f85931a0a259b144347b5e3/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=346ef3faa0225ae51f85931a0a259b144347b5e3", "patch": "@@ -336,21 +336,22 @@ mark_address_taken (tree x)\n \n /* Mark load of T.  */\n \n-static void\n-mark_load (ipa_reference_local_vars_info_t local, \n-\t   tree t)\n+static bool\n+mark_load (gimple stmt ATTRIBUTE_UNUSED, tree t, void *data)\n {\n+  ipa_reference_local_vars_info_t local = (ipa_reference_local_vars_info_t)data;\n   if (TREE_CODE (t) == VAR_DECL\n       && has_proper_scope_for_analysis (t))\n     bitmap_set_bit (local->statics_read, DECL_UID (t));\n+  return false;\n }\n \n /* Mark store of T.  */\n \n-static void\n-mark_store (ipa_reference_local_vars_info_t local, \n-\t   tree t)\n+static bool\n+mark_store (gimple stmt ATTRIBUTE_UNUSED, tree t, void *data)\n {\n+  ipa_reference_local_vars_info_t local = (ipa_reference_local_vars_info_t)data;\n   if (TREE_CODE (t) == VAR_DECL\n       && has_proper_scope_for_analysis (t))\n     {\n@@ -361,6 +362,7 @@ mark_store (ipa_reference_local_vars_info_t local,\n       if (module_statics_written)\n \tbitmap_set_bit (module_statics_written, DECL_UID (t));\n     }\n+  return false;\n }\n \n /* Look for memory clobber and set read_all/write_all if present.  */\n@@ -434,46 +436,12 @@ scan_stmt_for_static_refs (gimple_stmt_iterator *gsip,\n     local = get_reference_vars_info (fn)->local;\n \n   /* Look for direct loads and stores.  */\n-  if (gimple_has_lhs (stmt))\n-    {\n-      tree lhs = get_base_address (gimple_get_lhs (stmt));\n-      if (lhs && DECL_P (lhs))\n-        mark_store (local, lhs);\n-    }\n-  if (gimple_assign_single_p (stmt))\n-    {\n-      tree rhs = get_base_address (gimple_assign_rhs1 (stmt));\n-      if (rhs && DECL_P (rhs))\n-\tmark_load (local, rhs);\n-    }\n-  else if (is_gimple_call (stmt))\n-    {\n-      for (i = 0; i < gimple_call_num_args (stmt); ++i)\n-\t{\n-\t  tree rhs = get_base_address (gimple_call_arg (stmt, i));\n-\t  if (rhs && DECL_P (rhs))\n-\t    mark_load (local, rhs);\n-\t}\n-      check_call (local, stmt);\n-    }\n+  walk_stmt_load_store_addr_ops (stmt, local, mark_load, mark_store, NULL);\n+\n+  if (is_gimple_call (stmt))\n+    check_call (local, stmt);\n   else if (gimple_code (stmt) == GIMPLE_ASM)\n-    {\n-      for (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n-\t{\n-\t  tree op = TREE_VALUE (gimple_asm_input_op (stmt, i));\n-\t  op = get_base_address (op);\n-\t  if (op && DECL_P (op))\n-\t    mark_load (local, op);\n-\t}\n-      for (i = 0; i < gimple_asm_noutputs (stmt); ++i)\n-\t{\n-\t  tree op = TREE_VALUE (gimple_asm_output_op (stmt, i));\n-\t  op = get_base_address (op);\n-\t  if (op && DECL_P (op))\n-\t    mark_store (local, op);\n-\t}\n-      check_asm_memory_clobber (local, stmt);\n-    }\n+    check_asm_memory_clobber (local, stmt);\n \n   if (gimple_addresses_taken (stmt))\n     EXECUTE_IF_SET_IN_BITMAP (gimple_addresses_taken (stmt), 0, i, bi)"}]}