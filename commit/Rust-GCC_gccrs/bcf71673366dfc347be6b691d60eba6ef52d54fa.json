{"sha": "bcf71673366dfc347be6b691d60eba6ef52d54fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNmNzE2NzMzNjZkZmMzNDdiZTZiNjkxZDYwZWJhNmVmNTJkNTRmYQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-09-04T10:21:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-09-04T10:21:07Z"}, "message": "re PR bootstrap/45519 (Failed to bootstrap)\n\n2010-09-04  Richard Guenther  <rguenther@suse.de>\n\n\tPR bootstrap/45519\n\t* tree-flow.h (force_gimple_operand_1): Declare.\n\t(force_gimple_operand_gsi_1): Likewise.\n\t* gimplify.c (force_gimple_operand_1): New worker taking a\n\tgimple predicate for ...\n\t(force_gimple_operand): ... which now wraps it.\n\t(force_gimple_operand_gsi_1, force_gimple_operand_gsi): Likewise.\n\t* tree-ssa-loop-ivopts.c (find_interesting_uses_address): Revert\n\tlast change.\n\t* tree-ssa-address.c (gimplify_mem_ref_parts): Use\n\tforce_gimple_operand_gsi_1 with is_gimple_mem_ref_addr.\n\t(create_mem_ref): Likewise.\n\nFrom-SVN: r163858", "tree": {"sha": "acb1b826af7559a70b5c2f6988aadf6a62d1db93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acb1b826af7559a70b5c2f6988aadf6a62d1db93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcf71673366dfc347be6b691d60eba6ef52d54fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf71673366dfc347be6b691d60eba6ef52d54fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcf71673366dfc347be6b691d60eba6ef52d54fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf71673366dfc347be6b691d60eba6ef52d54fa/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "770b37b9e49d8c338a290a076f4281964fecc817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770b37b9e49d8c338a290a076f4281964fecc817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/770b37b9e49d8c338a290a076f4281964fecc817"}], "stats": {"total": 109, "additions": 77, "deletions": 32}, "files": [{"sha": "d0ac706f01685bdaa235e13d5fb763040943c5d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf71673366dfc347be6b691d60eba6ef52d54fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf71673366dfc347be6b691d60eba6ef52d54fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcf71673366dfc347be6b691d60eba6ef52d54fa", "patch": "@@ -1,3 +1,18 @@\n+2010-09-04  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR bootstrap/45519\n+\t* tree-flow.h (force_gimple_operand_1): Declare.\n+\t(force_gimple_operand_gsi_1): Likewise.\n+\t* gimplify.c (force_gimple_operand_1): New worker taking a\n+\tgimple predicate for ...\n+\t(force_gimple_operand): ... which now wraps it.\n+\t(force_gimple_operand_gsi_1, force_gimple_operand_gsi): Likewise.\n+\t* tree-ssa-loop-ivopts.c (find_interesting_uses_address): Revert\n+\tlast change.\n+\t* tree-ssa-address.c (gimplify_mem_ref_parts): Use\n+\tforce_gimple_operand_gsi_1 with is_gimple_mem_ref_addr.\n+\t(create_mem_ref): Likewise.\n+\n 2010-09-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/predicates.md (sse_reg_operand): New predicate."}, {"sha": "be9e22d650c596986ccb5c86bd24199d5c219cc5", "filename": "gcc/gimplify.c", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf71673366dfc347be6b691d60eba6ef52d54fa/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf71673366dfc347be6b691d60eba6ef52d54fa/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=bcf71673366dfc347be6b691d60eba6ef52d54fa", "patch": "@@ -8008,26 +8008,23 @@ gimple_regimplify_operands (gimple stmt, gimple_stmt_iterator *gsi_p)\n }\n \n \n-/* Expands EXPR to list of gimple statements STMTS.  If SIMPLE is true,\n-   force the result to be either ssa_name or an invariant, otherwise\n-   just force it to be a rhs expression.  If VAR is not NULL, make the\n+/* Expands EXPR to list of gimple statements STMTS.  GIMPLE_TEST_F specifies\n+   the predicate that will hold for the result.  If VAR is not NULL, make the\n    base variable of the final destination be VAR if suitable.  */\n \n tree\n-force_gimple_operand (tree expr, gimple_seq *stmts, bool simple, tree var)\n+force_gimple_operand_1 (tree expr, gimple_seq *stmts,\n+\t\t\tgimple_predicate gimple_test_f, tree var)\n {\n   tree t;\n   enum gimplify_status ret;\n-  gimple_predicate gimple_test_f;\n   struct gimplify_ctx gctx;\n \n   *stmts = NULL;\n \n   if (is_gimple_val (expr))\n     return expr;\n \n-  gimple_test_f = simple ? is_gimple_val : is_gimple_reg_rhs;\n-\n   push_gimplify_context (&gctx);\n   gimplify_ctxp->into_ssa = gimple_in_ssa_p (cfun);\n   gimplify_ctxp->allow_rhs_cond_expr = true;\n@@ -8056,20 +8053,34 @@ force_gimple_operand (tree expr, gimple_seq *stmts, bool simple, tree var)\n   return expr;\n }\n \n-/* Invokes force_gimple_operand for EXPR with parameters SIMPLE_P and VAR.  If\n-   some statements are produced, emits them at GSI.  If BEFORE is true.\n-   the statements are appended before GSI, otherwise they are appended after\n-   it.  M specifies the way GSI moves after insertion (GSI_SAME_STMT or\n-   GSI_CONTINUE_LINKING are the usual values).  */\n+/* Expands EXPR to list of gimple statements STMTS.  If SIMPLE is true,\n+   force the result to be either ssa_name or an invariant, otherwise\n+   just force it to be a rhs expression.  If VAR is not NULL, make the\n+   base variable of the final destination be VAR if suitable.  */\n \n tree\n-force_gimple_operand_gsi (gimple_stmt_iterator *gsi, tree expr,\n-\t\t\t  bool simple_p, tree var, bool before,\n-\t\t\t  enum gsi_iterator_update m)\n+force_gimple_operand (tree expr, gimple_seq *stmts, bool simple, tree var)\n+{\n+  return force_gimple_operand_1 (expr, stmts,\n+\t\t\t\t simple ? is_gimple_val : is_gimple_reg_rhs,\n+\t\t\t\t var);\n+}\n+\n+/* Invokes force_gimple_operand_1 for EXPR with parameters GIMPLE_TEST_F\n+   and VAR.  If some statements are produced, emits them at GSI.\n+   If BEFORE is true.  the statements are appended before GSI, otherwise\n+   they are appended after it.  M specifies the way GSI moves after\n+   insertion (GSI_SAME_STMT or GSI_CONTINUE_LINKING are the usual values).  */\n+\n+tree\n+force_gimple_operand_gsi_1 (gimple_stmt_iterator *gsi, tree expr,\n+\t\t\t    gimple_predicate gimple_test_f,\n+\t\t\t    tree var, bool before,\n+\t\t\t    enum gsi_iterator_update m)\n {\n   gimple_seq stmts;\n \n-  expr = force_gimple_operand (expr, &stmts, simple_p, var);\n+  expr = force_gimple_operand_1 (expr, &stmts, gimple_test_f, var);\n \n   if (!gimple_seq_empty_p (stmts))\n     {\n@@ -8090,4 +8101,24 @@ force_gimple_operand_gsi (gimple_stmt_iterator *gsi, tree expr,\n   return expr;\n }\n \n+/* Invokes force_gimple_operand_1 for EXPR with parameter VAR.\n+   If SIMPLE is true, force the result to be either ssa_name or an invariant,\n+   otherwise just force it to be a rhs expression.  If some statements are\n+   produced, emits them at GSI.  If BEFORE is true, the statements are\n+   appended before GSI, otherwise they are appended after it.  M specifies\n+   the way GSI moves after insertion (GSI_SAME_STMT or GSI_CONTINUE_LINKING\n+   are the usual values).  */\n+\n+tree\n+force_gimple_operand_gsi (gimple_stmt_iterator *gsi, tree expr,\n+\t\t\t  bool simple_p, tree var, bool before,\n+\t\t\t  enum gsi_iterator_update m)\n+{\n+  return force_gimple_operand_gsi_1 (gsi, expr,\n+\t\t\t\t     simple_p\n+\t\t\t\t     ? is_gimple_val : is_gimple_reg_rhs,\n+\t\t\t\t     var, before, m);\n+}\n+\n+\n #include \"gt-gimplify.h\""}, {"sha": "da23516fd2b59b4c96612a01c7cf1c7413ee159e", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf71673366dfc347be6b691d60eba6ef52d54fa/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf71673366dfc347be6b691d60eba6ef52d54fa/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=bcf71673366dfc347be6b691d60eba6ef52d54fa", "patch": "@@ -824,7 +824,11 @@ extern bool thread_through_all_blocks (bool);\n extern void register_jump_thread (edge, edge);\n \n /* In gimplify.c  */\n+tree force_gimple_operand_1 (tree, gimple_seq *, gimple_predicate, tree);\n tree force_gimple_operand (tree, gimple_seq *, bool, tree);\n+tree force_gimple_operand_gsi_1 (gimple_stmt_iterator *, tree,\n+\t\t\t\t gimple_predicate, tree,\n+\t\t\t\t bool, enum gsi_iterator_update);\n tree force_gimple_operand_gsi (gimple_stmt_iterator *, tree, bool, tree,\n \t\t\t       bool, enum gsi_iterator_update);\n tree gimple_fold_indirect_ref (tree);"}, {"sha": "18c0e556220df7949059bcdec4c45486d15f56e4", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf71673366dfc347be6b691d60eba6ef52d54fa/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf71673366dfc347be6b691d60eba6ef52d54fa/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=bcf71673366dfc347be6b691d60eba6ef52d54fa", "patch": "@@ -664,8 +664,8 @@ static void\n gimplify_mem_ref_parts (gimple_stmt_iterator *gsi, struct mem_address *parts)\n {\n   if (parts->base)\n-    parts->base = force_gimple_operand_gsi (gsi, parts->base,\n-\t\t\t\t\t    true, NULL_TREE,\n+    parts->base = force_gimple_operand_gsi_1 (gsi, parts->base,\n+\t\t\t\t\t    is_gimple_mem_ref_addr, NULL_TREE,\n \t\t\t\t\t    true, GSI_SAME_STMT);\n   if (parts->index)\n     parts->index = force_gimple_operand_gsi (gsi, parts->index,\n@@ -724,11 +724,11 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \t  if (parts.index)\n \t    {\n \t      atype = TREE_TYPE (tmp);\n-\t      parts.base = force_gimple_operand_gsi (gsi,\n+\t      parts.base = force_gimple_operand_gsi_1 (gsi,\n \t\t\tfold_build2 (POINTER_PLUS_EXPR, atype,\n \t\t\t\t     tmp,\n \t\t\t\t     fold_convert (sizetype, parts.base)),\n-\t\t\ttrue, NULL_TREE, true, GSI_SAME_STMT);\n+\t\t\tis_gimple_mem_ref_addr, NULL_TREE, true, GSI_SAME_STMT);\n \t    }\n \t  else\n \t    {\n@@ -751,11 +751,11 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n       if (parts.base)\n \t{\n \t  atype = TREE_TYPE (parts.base);\n-\t  parts.base = force_gimple_operand_gsi (gsi,\n+\t  parts.base = force_gimple_operand_gsi_1 (gsi,\n \t\t\tfold_build2 (POINTER_PLUS_EXPR, atype,\n \t\t\t\t     parts.base,\n \t\t\t    \t     parts.index),\n-\t\t\ttrue, NULL_TREE, true, GSI_SAME_STMT);\n+\t\t\tis_gimple_mem_ref_addr, NULL_TREE, true, GSI_SAME_STMT);\n \t}\n       else\n \tparts.base = parts.index;\n@@ -772,11 +772,11 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n       if (parts.base)\n \t{\n \t  atype = TREE_TYPE (parts.base);\n-\t  parts.base = force_gimple_operand_gsi (gsi,\n+\t  parts.base = force_gimple_operand_gsi_1 (gsi,\n \t\t\tfold_build2 (POINTER_PLUS_EXPR, atype,\n \t\t\t\t     parts.base,\n \t\t\t\t     fold_convert (sizetype, parts.offset)),\n-\t\t\ttrue, NULL_TREE, true, GSI_SAME_STMT);\n+\t\t\tis_gimple_mem_ref_addr, NULL_TREE, true, GSI_SAME_STMT);\n \t}\n       else\n \tparts.base = parts.offset;"}, {"sha": "9f79615edfcc346406cf0397cdff73af795a8f3b", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf71673366dfc347be6b691d60eba6ef52d54fa/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf71673366dfc347be6b691d60eba6ef52d54fa/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=bcf71673366dfc347be6b691d60eba6ef52d54fa", "patch": "@@ -1788,14 +1788,9 @@ find_interesting_uses_address (struct ivopts_data *data, gimple stmt, tree *op_p\n \t    ref = &TREE_OPERAND (*ref, 0);\n \t  if (TREE_CODE (*ref) == MEM_REF)\n \t    {\n-\t      tree tem = TREE_OPERAND (*ref, 0);\n-\t      STRIP_NOPS (tem);\n-\t      if (tem != TREE_OPERAND (*ref, 0))\n-\t\ttem = fold_build2 (MEM_REF, TREE_TYPE (*ref),\n-\t\t\t\t   tem, TREE_OPERAND (*ref, 1));\n-\t      else\n-\t\ttem = fold_binary (MEM_REF, TREE_TYPE (*ref),\n-\t\t\t\t   tem, TREE_OPERAND (*ref, 1));\n+\t      tree tem = fold_binary (MEM_REF, TREE_TYPE (*ref),\n+\t\t\t\t      TREE_OPERAND (*ref, 0),\n+\t\t\t\t      TREE_OPERAND (*ref, 1));\n \t      if (tem)\n \t\t*ref = tem;\n \t    }"}]}