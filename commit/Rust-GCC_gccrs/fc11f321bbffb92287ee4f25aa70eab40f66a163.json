{"sha": "fc11f321bbffb92287ee4f25aa70eab40f66a163", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMxMWYzMjFiYmZmYjkyMjg3ZWU0ZjI1YWE3MGVhYjQwZjY2YTE2Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-09-06T10:13:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-09-06T10:13:37Z"}, "message": "re PR middle-end/58094 (IPA devirt testsuite errors)\n\n\tPR middle-end/58094\n\t* cgraph.h (symtab_semantically_equivalent_p): Declare.\n\t* tree-tailcall.c: Include ipa-utils.h.\n\t(find_tail_calls): Use it.\n\t* ipa-pure-const.c (check_call): Likewise.\n\t* ipa-utils.c (recursive_call_p): New function.\n\t* ipa-utils.h (recursive_call_p): Dclare.\n\t* symtab.c (symtab_nonoverwritable_alias): Fix formatting.\n\t(symtab_semantically_equivalent_p): New function.\n\t* Makefile.in (tree-tailcall.o): Update dependencies.\n\nFrom-SVN: r202316", "tree": {"sha": "e167b438c335f3bc2a8367366839e99f406f78e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e167b438c335f3bc2a8367366839e99f406f78e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc11f321bbffb92287ee4f25aa70eab40f66a163", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc11f321bbffb92287ee4f25aa70eab40f66a163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc11f321bbffb92287ee4f25aa70eab40f66a163", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc11f321bbffb92287ee4f25aa70eab40f66a163/comments", "author": null, "committer": null, "parents": [{"sha": "9a6af4504b8bc9b03020b1e96a3bad56d9929916", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a6af4504b8bc9b03020b1e96a3bad56d9929916", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a6af4504b8bc9b03020b1e96a3bad56d9929916"}], "stats": {"total": 80, "additions": 73, "deletions": 7}, "files": [{"sha": "a2a68229650fe0a86351daa731fa47fbb905ef98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc11f321bbffb92287ee4f25aa70eab40f66a163", "patch": "@@ -1,3 +1,16 @@\n+2013-09-06  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/58094\n+\t* cgraph.h (symtab_semantically_equivalent_p): Declare.\n+\t* tree-tailcall.c: Include ipa-utils.h.\n+\t(find_tail_calls): Use it.\n+\t* ipa-pure-const.c (check_call): Likewise.\n+\t* ipa-utils.c (recursive_call_p): New function.\n+\t* ipa-utils.h (recursive_call_p): Dclare.\n+\t* symtab.c (symtab_nonoverwritable_alias): Fix formatting.\n+\t(symtab_semantically_equivalent_p): New function.\n+\t* Makefile.in (tree-tailcall.o): Update dependencies.\n+\n 2013-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* ipa-split.c (split_function): Set DECL_NO_INLINE_WARNING_P on the"}, {"sha": "8430300239ee978df4c6d9f0f1d6bee794db46a5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fc11f321bbffb92287ee4f25aa70eab40f66a163", "patch": "@@ -2432,7 +2432,7 @@ tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TM_P_H) $(FUNCTION_H) $(TM_H) coretypes.h \\\n    $(EXCEPT_H) $(TREE_PASS_H) $(FLAGS_H) langhooks.h \\\n    $(BASIC_BLOCK_H) $(DBGCNT_H) $(GIMPLE_PRETTY_PRINT_H) $(TARGET_H) \\\n-   $(COMMON_TARGET_H) $(CFGLOOP_H)\n+   $(COMMON_TARGET_H) $(CFGLOOP_H) ipa-utils.h\n tree-ssa-sink.o : tree-ssa-sink.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) \\\n    $(TM_H) coretypes.h $(TREE_PASS_H) $(FLAGS_H) alloc-pool.h \\"}, {"sha": "5a7a949061f5420b51bd393739335ff5d53dd9c6", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=fc11f321bbffb92287ee4f25aa70eab40f66a163", "patch": "@@ -627,6 +627,7 @@ bool symtab_for_node_and_aliases (symtab_node,\n \t\t\t\t  bool);\n symtab_node symtab_nonoverwritable_alias (symtab_node);\n enum availability symtab_node_availability (symtab_node);\n+bool symtab_semantically_equivalent_p (symtab_node, symtab_node);\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);"}, {"sha": "ed4deae64fec2d1ca5a51851218f0018a6066cf3", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=fc11f321bbffb92287ee4f25aa70eab40f66a163", "patch": "@@ -541,7 +541,8 @@ check_call (funct_state local, gimple call, bool ipa)\n     }\n \n   /* When not in IPA mode, we can still handle self recursion.  */\n-  if (!ipa && callee_t == current_function_decl)\n+  if (!ipa && callee_t\n+      && recursive_call_p (current_function_decl, callee_t))\n     {\n       if (dump_file)\n         fprintf (dump_file, \"    Recursive call can loop.\\n\");\n@@ -1079,8 +1080,9 @@ ignore_edge (struct cgraph_edge *e)\n }\n \n /* Return true if NODE is self recursive function.\n-   ??? self recursive and indirectly recursive funcions should\n-   be the same, so this function seems unnecessary.  */\n+   Indirectly recursive functions appears as non-trivial strongly\n+   connected components, so we need to care about self recursion\n+   only.  */\n \n static bool\n self_recursive_p (struct cgraph_node *node)"}, {"sha": "e2e169043bc14e77326eef4e465e44d67064d357", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=fc11f321bbffb92287ee4f25aa70eab40f66a163", "patch": "@@ -791,3 +791,14 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   src->symbol.decl = oldsrcdecl;\n }\n \n+/* Return true if call to DEST is known to be self-recusive call withing FUNC.   */\n+\n+bool\n+recursive_call_p (tree func, tree dest)\n+{\n+  struct cgraph_node *dest_node = cgraph_get_create_node (dest);\n+  struct cgraph_node *cnode = cgraph_get_create_node (func);\n+\n+  return symtab_semantically_equivalent_p ((symtab_node)dest_node,\n+\t\t\t\t\t   (symtab_node)cnode);\n+}"}, {"sha": "d6f390daf15b26946f654a1867ae3644bc22e15b", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=fc11f321bbffb92287ee4f25aa70eab40f66a163", "patch": "@@ -46,6 +46,7 @@ int ipa_reverse_postorder (struct cgraph_node **);\n tree get_base_var (tree);\n void ipa_merge_profiles (struct cgraph_node *dst,\n \t\t\t struct cgraph_node *src);\n+bool recursive_call_p (tree, tree);\n \n /* In ipa-profile.c  */\n bool ipa_propagate_frequency (struct cgraph_node *node);"}, {"sha": "8dc61d0c7af98bad8e234552b088d93b1fabc271", "filename": "gcc/symtab.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=fc11f321bbffb92287ee4f25aa70eab40f66a163", "patch": "@@ -1106,11 +1106,48 @@ symtab_nonoverwritable_alias (symtab_node node)\n     {\n       DECL_STATIC_CONSTRUCTOR (new_decl) = 0;\n       DECL_STATIC_DESTRUCTOR (new_decl) = 0;\n-      new_node = (symtab_node) cgraph_create_function_alias (new_decl, node->symbol.decl);\n+      new_node = (symtab_node) cgraph_create_function_alias\n+\t\t\t\t (new_decl, node->symbol.decl);\n     }\n   else\n-    new_node = (symtab_node) varpool_create_variable_alias (new_decl, node->symbol.decl);\n+    new_node = (symtab_node) varpool_create_variable_alias (new_decl,\n+\t\t\t\t\t\t\t    node->symbol.decl);\n   symtab_resolve_alias (new_node, node);  \n+  gcc_assert (decl_binds_to_current_def_p (new_decl));\n   return new_node;\n }\n+\n+/* Return true if A and B represents semantically equivalent symbols.  */\n+\n+bool\n+symtab_semantically_equivalent_p (symtab_node a,\n+\t\t\t\t  symtab_node b)\n+{\n+  enum availability avail;\n+  symtab_node ba, bb;\n+\n+  /* Equivalent functions are equivalent.  */\n+  if (a->symbol.decl == b->symbol.decl)\n+    return true;\n+\n+  /* If symbol is not overwritable by different implementation,\n+     walk to the base object it defines.  */\n+  ba = symtab_alias_ultimate_target (a, &avail);\n+  if (avail >= AVAIL_AVAILABLE)\n+    {\n+      if (ba == b)\n+\treturn true;\n+    }\n+  else\n+    ba = a;\n+  bb = symtab_alias_ultimate_target (b, &avail);\n+  if (avail >= AVAIL_AVAILABLE)\n+    {\n+      if (a == bb)\n+\treturn true;\n+    }\n+  else\n+    bb = b;\n+  return bb == ba;\n+}\n #include \"gt-symtab.h\""}, {"sha": "289b75a09bc474b0c94d587c7e06091345710fc9", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc11f321bbffb92287ee4f25aa70eab40f66a163/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=fc11f321bbffb92287ee4f25aa70eab40f66a163", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"cfgloop.h\"\n #include \"common/common-target.h\"\n+#include \"ipa-utils.h\"\n \n /* The file implements the tail recursion elimination.  It is also used to\n    analyze the tail calls in general, passing the results to the rtl level\n@@ -445,7 +446,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n   /* We found the call, check whether it is suitable.  */\n   tail_recursion = false;\n   func = gimple_call_fndecl (call);\n-  if (func == current_function_decl)\n+  if (func && recursive_call_p (current_function_decl, func))\n     {\n       tree arg;\n "}]}