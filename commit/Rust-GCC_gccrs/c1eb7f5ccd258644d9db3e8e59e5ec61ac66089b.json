{"sha": "c1eb7f5ccd258644d9db3e8e59e5ec61ac66089b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFlYjdmNWNjZDI1ODY0NGQ5ZGIzZThlNTllNWVjNjFhYzY2MDg5Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-12-11T15:35:37Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-12-11T15:35:37Z"}, "message": "mangle.c (conv_type_names): Holds IDENTIFIER_NODEs only.\n\n\t* mangle.c (conv_type_names): Holds IDENTIFIER_NODEs only.\n\t(hash_type): Use TYPE_UID of the identifier's type.\n\t(compare_type): Adjust.\n\t(mangle_conv_op_name_for_type): Store identifier nodes only, use\n\tTYPE_UID has hash value.\n\nFrom-SVN: r74538", "tree": {"sha": "4e70fa01b2e7d5612debfa644326b44e9545a9b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e70fa01b2e7d5612debfa644326b44e9545a9b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1eb7f5ccd258644d9db3e8e59e5ec61ac66089b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1eb7f5ccd258644d9db3e8e59e5ec61ac66089b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1eb7f5ccd258644d9db3e8e59e5ec61ac66089b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1eb7f5ccd258644d9db3e8e59e5ec61ac66089b/comments", "author": null, "committer": null, "parents": [{"sha": "c1fb3625aebaa9ccacc16eb185f04a93e4ed459f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1fb3625aebaa9ccacc16eb185f04a93e4ed459f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1fb3625aebaa9ccacc16eb185f04a93e4ed459f"}], "stats": {"total": 63, "additions": 37, "deletions": 26}, "files": [{"sha": "5cad5c00949733daa10183803a197bee0b07e093", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1eb7f5ccd258644d9db3e8e59e5ec61ac66089b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1eb7f5ccd258644d9db3e8e59e5ec61ac66089b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c1eb7f5ccd258644d9db3e8e59e5ec61ac66089b", "patch": "@@ -1,3 +1,11 @@\n+2003-12-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* mangle.c (conv_type_names): Holds IDENTIFIER_NODEs only.\n+\t(hash_type): Use TYPE_UID of the identifier's type.\n+\t(compare_type): Adjust.\n+\t(mangle_conv_op_name_for_type): Store identifier nodes only, use\n+\tTYPE_UID has hash value.\n+\n 2003-12-10  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (DECL_CONV_FN_P): Check that DECL_NAME is non-NULL.\n@@ -7,11 +15,11 @@\n \tPR c/13134\n \t* decl.c (duplicate_decls): Copy visibility flag when appropriate.\n \t\n-2003-12-09  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\r\n-\r\n-\t* init.c (build_new_1): Deal with an OVERLOAD set when\r\n-\tlooking up for _Jv_AllocObject.\r\n-\t* except.c (build_throw): Likewise for _Jv_Throw.\r\n+2003-12-09  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\t* init.c (build_new_1): Deal with an OVERLOAD set when\n+\tlooking up for _Jv_AllocObject.\n+\t* except.c (build_throw): Likewise for _Jv_Throw.\n \n 2003-12-08  Jason Merrill  <jason@redhat.com>\n "}, {"sha": "351a7e2c49483fc74925ff87844fc52c4064117e", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1eb7f5ccd258644d9db3e8e59e5ec61ac66089b/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1eb7f5ccd258644d9db3e8e59e5ec61ac66089b/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=c1eb7f5ccd258644d9db3e8e59e5ec61ac66089b", "patch": "@@ -2602,8 +2602,8 @@ mangle_thunk (tree fn_decl, const int this_adjusting, tree fixed_offset,\n }\n \n /* This hash table maps TYPEs to the IDENTIFIER for a conversion\n-   operator to TYPE.  The nodes are TREE_LISTs whose TREE_PURPOSE is\n-   the TYPE and whose TREE_VALUE is the IDENTIFIER.  */\n+   operator to TYPE.  The nodes are IDENTIFIERs whose TREE_TYPE is the\n+   TYPE.  */\n \n static GTY ((param_is (union tree_node))) htab_t conv_type_names;\n \n@@ -2612,15 +2612,15 @@ static GTY ((param_is (union tree_node))) htab_t conv_type_names;\n static hashval_t\n hash_type (const void *val)\n {\n-  return htab_hash_pointer (TREE_PURPOSE ((tree) val));\n+  return (hashval_t) TYPE_UID (TREE_TYPE ((tree) val));\n }\n \n /* Compare VAL1 (a node in the table) with VAL2 (a TYPE).  */\n \n static int\n compare_type (const void *val1, const void *val2)\n {\n-  return TREE_PURPOSE ((tree) val1) == (tree) val2;\n+  return TREE_TYPE ((tree) val1) == (tree) val2;\n }\n \n /* Return an identifier for the mangled unqualified name for a\n@@ -2632,29 +2632,32 @@ mangle_conv_op_name_for_type (const tree type)\n {\n   void **slot;\n   tree identifier;\n-  char buffer[64];\n \n   if (conv_type_names == NULL) \n     conv_type_names = htab_create_ggc (31, &hash_type, &compare_type, NULL);\n \n   slot = htab_find_slot_with_hash (conv_type_names, type, \n-\t\t\t\t   htab_hash_pointer (type), INSERT);\n-  if (*slot)\n-    return TREE_VALUE ((tree) *slot);\n-\n-  /* Create a unique name corresponding to TYPE.  */\n-  sprintf (buffer, \"operator %lu\", \n-\t   (unsigned long) htab_elements (conv_type_names));\n-  identifier = get_identifier (buffer);\n-  *slot = build_tree_list (type, identifier);\n+\t\t\t\t   (hashval_t) TYPE_UID (type), INSERT);\n+  identifier = (tree)*slot;\n+  if (!identifier)\n+    {\n+      char buffer[64];\n+      \n+       /* Create a unique name corresponding to TYPE.  */\n+      sprintf (buffer, \"operator %lu\",\n+\t       (unsigned long) htab_elements (conv_type_names));\n+      identifier = get_identifier (buffer);\n+      *slot = identifier;\n+\n+      /* Hang TYPE off the identifier so it can be found easily later\n+\t when performing conversions.  */\n+      TREE_TYPE (identifier) = type;\n+\n+      /* Set bits on the identifier so we know later it's a conversion.  */\n+      IDENTIFIER_OPNAME_P (identifier) = 1;\n+      IDENTIFIER_TYPENAME_P (identifier) = 1;\n+    }\n   \n-  /* Set bits on the identifier so we know later it's a conversion.  */\n-  IDENTIFIER_OPNAME_P (identifier) = 1;\n-  IDENTIFIER_TYPENAME_P (identifier) = 1;\n-  /* Hang TYPE off the identifier so it can be found easily later when\n-     performing conversions.  */\n-  TREE_TYPE (identifier) = type;\n-\n   return identifier;\n }\n "}]}