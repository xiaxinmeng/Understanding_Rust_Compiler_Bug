{"sha": "34895b6606561a36ffded81efee2904feb9c1bfd", "node_id": "C_kwDOANBUbNoAKDM0ODk1YjY2MDY1NjFhMzZmZmRlZDgxZWZlZTI5MDRmZWI5YzFiZmQ", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-06-24T13:17:08Z"}, "committer": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-08-29T09:15:09Z"}, "message": "s390: Recognize reverse/element swap permute patterns.\n\nThis adds functions to recognize reverse/element swap permute patterns\nfor vler, vster as well as vpdi and rotate.\n\ngcc/ChangeLog:\n\n\t* config/s390/s390.cc (expand_perm_with_vpdi): Recognize swap pattern.\n\t(is_reverse_perm_mask): New function.\n\t(expand_perm_with_rot): Recognize reverse pattern.\n\t(expand_perm_with_vstbrq): New function.\n\t(expand_perm_with_vster): Use vler/vster for element reversal on z15.\n\t(vectorize_vec_perm_const_1): Use.\n\t(s390_vectorize_vec_perm_const): Add expand functions.\n\t* config/s390/vx-builtins.md: Prefer vster over vler.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/s390/vector/vperm-rev-z14.c: New test.\n\t* gcc.target/s390/vector/vperm-rev-z15.c: New test.\n\t* gcc.target/s390/zvector/vec-reve-store-byte.c: Adjust test\n\texpectation.", "tree": {"sha": "7a3c3d80822a0e9938628817d971b3432fbd31e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a3c3d80822a0e9938628817d971b3432fbd31e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34895b6606561a36ffded81efee2904feb9c1bfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34895b6606561a36ffded81efee2904feb9c1bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34895b6606561a36ffded81efee2904feb9c1bfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34895b6606561a36ffded81efee2904feb9c1bfd/comments", "author": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bde28df1933b972e080613a00b6819413aefa2e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde28df1933b972e080613a00b6819413aefa2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bde28df1933b972e080613a00b6819413aefa2e6"}], "stats": {"total": 351, "additions": 345, "deletions": 6}, "files": [{"sha": "a10e9a7b9578139f26f8408221c81699f1bb4d1a", "filename": "gcc/config/s390/s390.cc", "status": "modified", "additions": 117, "deletions": 2, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34895b6606561a36ffded81efee2904feb9c1bfd/gcc%2Fconfig%2Fs390%2Fs390.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34895b6606561a36ffded81efee2904feb9c1bfd/gcc%2Fconfig%2Fs390%2Fs390.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.cc?ref=34895b6606561a36ffded81efee2904feb9c1bfd", "patch": "@@ -17124,6 +17124,8 @@ struct expand_vec_perm_d\n   machine_mode vmode;\n   unsigned char nelt;\n   bool testing_p;\n+  bool only_op0;\n+  bool only_op1;\n };\n \n /* Try to expand the vector permute operation described by D using the\n@@ -17191,7 +17193,9 @@ expand_perm_with_vpdi (const struct expand_vec_perm_d &d)\n   if (d.perm[0] == 0 && d.perm[1] == 3)\n     vpdi1_p = true;\n \n-  if (d.perm[0] == 1 && d.perm[1] == 2)\n+  if ((d.perm[0] == 1 && d.perm[1] == 2)\n+      || (d.perm[0] == 1 && d.perm[1] == 0)\n+      || (d.perm[0] == 3 && d.perm[1] == 2))\n     vpdi4_p = true;\n \n   if (!vpdi1_p && !vpdi4_p)\n@@ -17203,15 +17207,107 @@ expand_perm_with_vpdi (const struct expand_vec_perm_d &d)\n   op0_reg = force_reg (GET_MODE (d.op0), d.op0);\n   op1_reg = force_reg (GET_MODE (d.op1), d.op1);\n \n+  /* If we only reference either of the operands in\n+     the permute mask, just use one of them.  */\n+  if (d.only_op0)\n+    op1_reg = op0_reg;\n+  else if (d.only_op1)\n+    op0_reg = op1_reg;\n+\n   if (vpdi1_p)\n     emit_insn (gen_vpdi1 (d.vmode, d.target, op0_reg, op1_reg));\n-\n   if (vpdi4_p)\n     emit_insn (gen_vpdi4 (d.vmode, d.target, op0_reg, op1_reg));\n \n   return true;\n }\n \n+/* Helper that checks if a vector permutation mask D\n+   represents a reversal of the vector's elements.  */\n+static inline bool\n+is_reverse_perm_mask (const struct expand_vec_perm_d &d)\n+{\n+  for (int i = 0; i < d.nelt; i++)\n+    if (d.perm[i] != d.nelt - i - 1)\n+      return false;\n+  return true;\n+}\n+\n+/* The case of reversing a four-element vector [0, 1, 2, 3]\n+   can be handled by first permuting the doublewords\n+   [2, 3, 0, 1] and subsequently rotating them by 32 bits.  */\n+static bool\n+expand_perm_with_rot (const struct expand_vec_perm_d &d)\n+{\n+  if (d.nelt != 4)\n+    return false;\n+\n+  if (d.op0 == d.op1 && is_reverse_perm_mask (d))\n+    {\n+      if (d.testing_p)\n+\treturn true;\n+\n+      rtx tmp = gen_reg_rtx (d.vmode);\n+      rtx op0_reg = force_reg (GET_MODE (d.op0), d.op0);\n+\n+      emit_insn (gen_vpdi4_2 (d.vmode, tmp, op0_reg, op0_reg));\n+      if (d.vmode == V4SImode)\n+\temit_insn (gen_rotlv4si3_di (d.target, tmp));\n+      else if (d.vmode == V4SFmode)\n+\temit_insn (gen_rotlv4sf3_di (d.target, tmp));\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* If we just reverse the elements, emit an eltswap if we have\n+   vler/vster.  */\n+static bool\n+expand_perm_with_vster (const struct expand_vec_perm_d &d)\n+{\n+  if (TARGET_VXE2 && d.op0 == d.op1 && is_reverse_perm_mask (d)\n+      && (d.vmode == V2DImode || d.vmode == V2DFmode\n+\t  || d.vmode == V4SImode || d.vmode == V4SFmode\n+\t  || d.vmode == V8HImode))\n+    {\n+      if (d.testing_p)\n+\treturn true;\n+\n+      if (d.vmode == V2DImode)\n+\temit_insn (gen_eltswapv2di (d.target, d.op0));\n+      else if (d.vmode == V2DFmode)\n+\temit_insn (gen_eltswapv2df (d.target, d.op0));\n+      else if (d.vmode == V4SImode)\n+\temit_insn (gen_eltswapv4si (d.target, d.op0));\n+      else if (d.vmode == V4SFmode)\n+\temit_insn (gen_eltswapv4sf (d.target, d.op0));\n+      else if (d.vmode == V8HImode)\n+\temit_insn (gen_eltswapv8hi (d.target, d.op0));\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* If we reverse a byte-vector this is the same as\n+   byte reversing it which can be done with vstbrq.  */\n+static bool\n+expand_perm_with_vstbrq (const struct expand_vec_perm_d &d)\n+{\n+  if (TARGET_VXE2 && d.op0 == d.op1 && is_reverse_perm_mask (d)\n+      && d.vmode == V16QImode)\n+    {\n+      if (d.testing_p)\n+\treturn true;\n+\n+      emit_insn (gen_eltswapv16qi (d.target, d.op0));\n+      return true;\n+    }\n+  return false;\n+}\n+\n+\n /* Try to find the best sequence for the vector permute operation\n    described by D.  Return true if the operation could be\n    expanded.  */\n@@ -17221,9 +17317,18 @@ vectorize_vec_perm_const_1 (const struct expand_vec_perm_d &d)\n   if (expand_perm_with_merge (d))\n     return true;\n \n+  if (expand_perm_with_vster (d))\n+    return true;\n+\n+  if (expand_perm_with_vstbrq (d))\n+    return true;\n+\n   if (expand_perm_with_vpdi (d))\n     return true;\n \n+  if (expand_perm_with_rot (d))\n+    return true;\n+\n   return false;\n }\n \n@@ -17253,17 +17358,27 @@ s390_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n   gcc_assert (VECTOR_MODE_P (d.vmode));\n   d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n   d.testing_p = target == NULL_RTX;\n+  d.only_op0 = false;\n+  d.only_op1 = false;\n \n   gcc_assert (target == NULL_RTX || REG_P (target));\n   gcc_assert (sel.length () == nelt);\n \n+  unsigned int highest = 0, lowest = 2 * nelt - 1;\n   for (i = 0; i < nelt; i++)\n     {\n       unsigned char e = sel[i];\n+      lowest = MIN (lowest, e);\n+      highest = MAX (highest, e);\n       gcc_assert (e < 2 * nelt);\n       d.perm[i] = e;\n     }\n \n+  if (lowest < nelt && highest < nelt)\n+    d.only_op0 = true;\n+  else if (lowest >= nelt && highest >= nelt)\n+    d.only_op1 = true;\n+\n   return vectorize_vec_perm_const_1 (d);\n }\n "}, {"sha": "e4bb514556cb74061c50ec182a0c3947ad635b46", "filename": "gcc/config/s390/vx-builtins.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34895b6606561a36ffded81efee2904feb9c1bfd/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34895b6606561a36ffded81efee2904feb9c1bfd/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvx-builtins.md?ref=34895b6606561a36ffded81efee2904feb9c1bfd", "patch": "@@ -2186,6 +2186,27 @@\n    vster<bhfgq>\\t%v1,%v0\"\n   [(set_attr \"op_type\" \"*,VRX,VRX\")])\n \n+; The emulation pattern below will also accept\n+;  vst (eltswap (vl))\n+; i.e. both operands in memory, which reload needs to fix.\n+; Split into\n+;  vl\n+;  vster (=vst (eltswap))\n+; since we prefer vster over vler as long as the latter\n+; does not support alignment hints.\n+(define_split\n+  [(set (match_operand:VEC_HW                 0 \"memory_operand\" \"\")\n+\t(unspec:VEC_HW [(match_operand:VEC_HW 1 \"memory_operand\" \"\")]\n+\t\t       UNSPEC_VEC_ELTSWAP))]\n+  \"TARGET_VXE2 && can_create_pseudo_p ()\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0)\n+\t(unspec:VEC_HW [(match_dup 2)] UNSPEC_VEC_ELTSWAP))]\n+{\n+  operands[2] = gen_reg_rtx (<MODE>mode);\n+})\n+\n+\n ; Swapping v2df/v2di can be done via vpdi on z13 and z14.\n (define_split\n   [(set (match_operand:V_HW_2                 0 \"register_operand\" \"\")"}, {"sha": "5c64fac4646c8cd78fe203db3ec70143d48dbfc1", "filename": "gcc/testsuite/gcc.target/s390/vector/vperm-rev-z14.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34895b6606561a36ffded81efee2904feb9c1bfd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvperm-rev-z14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34895b6606561a36ffded81efee2904feb9c1bfd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvperm-rev-z14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvperm-rev-z14.c?ref=34895b6606561a36ffded81efee2904feb9c1bfd", "patch": "@@ -0,0 +1,87 @@\n+/* Make sure that the reverse permute patterns are optimized\n+   correctly.  */\n+/* { dg-do run { target { s390*-*-* } } } */\n+/* { dg-options \"-O2 -march=z14 -mzarch -fno-unroll-loops\" } */\n+\n+/* { dg-final { scan-assembler-times \"vpdi\\t\" 4 } } */\n+/* { dg-final { scan-assembler-times \"verllg\\t\" 2 } } */\n+\n+#include <assert.h>\n+\n+__attribute__((noipa))\n+void reversel (long long *restrict a, long long *restrict b, int n)\n+{\n+  for (int i = 0; i < n; i += 2)\n+    {\n+      a[i + 1] = b[i + 0];\n+      a[i + 0] = b[i + 1];\n+    }\n+}\n+\n+__attribute__((noipa))\n+void reversed (double *restrict a, double *restrict b, int n)\n+{\n+  for (int i = 0; i < n; i += 2)\n+    {\n+      a[i + 1] = b[i + 0];\n+      a[i + 0] = b[i + 1];\n+    }\n+}\n+\n+__attribute__((noipa))\n+void reversei (unsigned int *restrict a, unsigned int *restrict b, int n)\n+{\n+  for (int i = 0; i < n; i += 4)\n+    {\n+      a[i + 3] = b[i + 0];\n+      a[i + 2] = b[i + 1];\n+      a[i + 1] = b[i + 2];\n+      a[i + 0] = b[i + 3];\n+    }\n+}\n+\n+__attribute__((noipa))\n+void reversef (float *restrict a, float *restrict b, int n)\n+{\n+  for (int i = 0; i < n; i += 4)\n+    {\n+      a[i + 3] = b[i + 0];\n+      a[i + 2] = b[i + 1];\n+      a[i + 1] = b[i + 2];\n+      a[i + 0] = b[i + 3];\n+    }\n+}\n+\n+int main()\n+{\n+  const int n = 1024;\n+  unsigned int u[n], u2[n];\n+  long long l[n], l2[n];\n+  double d[n], d2[n];\n+  float f[n], f2[n];\n+\n+  for (int i = 0; i < n; i++)\n+    {\n+      u[i] = i;\n+      l[i] = i;\n+      d[i] = i;\n+      f[i] = i;\n+      u2[i] = i;\n+      l2[i] = i;\n+      d2[i] = i;\n+      f2[i] = i;\n+    }\n+\n+  reversei (u2, u, n);\n+  reversel (l2, l, n);\n+  reversed (d2, d, n);\n+  reversef (f2, f, n);\n+\n+  for (int i = 0; i < n - 16; i++)\n+    {\n+      assert (u[i] == u2[i / (16 / sizeof (u[0])) * (16 / sizeof (u[0])) + 16 / sizeof (u[0]) - 1 - i % (16 / sizeof (u[0]))]);\n+      assert (l[i] == l2[i / (16 / sizeof (l[0])) * (16 / sizeof (l[0])) + 16 / sizeof (l[0]) - 1 - i % (16 / sizeof (l[0]))]);\n+      assert (d[i] == d2[i / (16 / sizeof (d[0])) * (16 / sizeof (d[0])) + 16 / sizeof (d[0]) - 1 - i % (16 / sizeof (d[0]))]);\n+      assert (f[i] == f2[i / (16 / sizeof (f[0])) * (16 / sizeof (f[0])) + 16 / sizeof (f[0]) - 1 - i % (16 / sizeof (f[0]))]);\n+    }\n+}"}, {"sha": "bff52406fa9b022486e37b53e23543c5b61cdf96", "filename": "gcc/testsuite/gcc.target/s390/vector/vperm-rev-z15.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34895b6606561a36ffded81efee2904feb9c1bfd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvperm-rev-z15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34895b6606561a36ffded81efee2904feb9c1bfd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvperm-rev-z15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvperm-rev-z15.c?ref=34895b6606561a36ffded81efee2904feb9c1bfd", "patch": "@@ -0,0 +1,118 @@\n+/* Make sure that the reverse permute patterns are optimized\n+   correctly.  */\n+/* { dg-do run { target { s390*-*-* } } } */\n+/* { dg-options \"-O2 -march=z15 -mzarch -fno-unroll-loops\" } */\n+\n+/* { dg-final { scan-assembler-times \"vsterg\\t\" 2 } } */\n+/* { dg-final { scan-assembler-times \"vsterf\" 2 } } */\n+/* { dg-final { scan-assembler-times \"vstbrq\\t\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vperm\" 0 } } */\n+\n+#include <assert.h>\n+\n+__attribute__((noipa))\n+void reversec (char *restrict a, char *restrict b, int n)\n+{\n+  for (int i = 0; i < n; i += 16)\n+    {\n+      a[i + 0] = b[i + 15];\n+      a[i + 1] = b[i + 14];\n+      a[i + 2] = b[i + 13];\n+      a[i + 3] = b[i + 12];\n+      a[i + 4] = b[i + 11];\n+      a[i + 5] = b[i + 10];\n+      a[i + 6] = b[i + 9];\n+      a[i + 7] = b[i + 8];\n+      a[i + 8] = b[i + 7];\n+      a[i + 9] = b[i + 6];\n+      a[i + 10] = b[i + 5];\n+      a[i + 11] = b[i + 4];\n+      a[i + 12] = b[i + 3];\n+      a[i + 13] = b[i + 2];\n+      a[i + 14] = b[i + 1];\n+      a[i + 15] = b[i + 0];\n+    }\n+}\n+\n+__attribute__((noipa))\n+void reversel (long long *restrict a, long long *restrict b, int n)\n+{\n+  for (int i = 0; i < n; i += 2)\n+    {\n+      a[i + 1] = b[i + 0];\n+      a[i + 0] = b[i + 1];\n+    }\n+}\n+\n+__attribute__((noipa))\n+void reversed (double *restrict a, double *restrict b, int n)\n+{\n+  for (int i = 0; i < n; i += 2)\n+    {\n+      a[i + 1] = b[i + 0];\n+      a[i + 0] = b[i + 1];\n+    }\n+}\n+\n+__attribute__((noipa))\n+void reversei (unsigned int *restrict a, unsigned int *restrict b, int n)\n+{\n+  for (int i = 0; i < n; i += 4)\n+    {\n+      a[i + 3] = b[i + 0];\n+      a[i + 2] = b[i + 1];\n+      a[i + 1] = b[i + 2];\n+      a[i + 0] = b[i + 3];\n+    }\n+}\n+\n+__attribute__((noipa))\n+void reversef (float *restrict a, float *restrict b, int n)\n+{\n+  for (int i = 0; i < n; i += 4)\n+    {\n+      a[i + 3] = b[i + 0];\n+      a[i + 2] = b[i + 1];\n+      a[i + 1] = b[i + 2];\n+      a[i + 0] = b[i + 3];\n+    }\n+}\n+\n+int main()\n+{\n+  const int n = 1024;\n+  char c[n], c2[n];\n+  unsigned int u[n], u2[n];\n+  long long l[n], l2[n];\n+  double d[n], d2[n];\n+  float f[n], f2[n];\n+\n+  for (int i = 0; i < n; i++)\n+    {\n+      c[i] = i;\n+      u[i] = i;\n+      l[i] = i;\n+      d[i] = i;\n+      f[i] = i;\n+      c2[i] = i;\n+      u2[i] = i;\n+      l2[i] = i;\n+      d2[i] = i;\n+      f2[i] = i;\n+    }\n+\n+  reversec (c2, c, n);\n+  reversei (u2, u, n);\n+  reversel (l2, l, n);\n+  reversed (d2, d, n);\n+  reversef (f2, f, n);\n+\n+  for (int i = 0; i < n - 16; i++)\n+    {\n+      assert (c[i] == c2[i / (16 / sizeof (c[0])) * (16 / sizeof (c[0])) + 16 / sizeof (c[0]) - 1 - i % (16 / sizeof (c[0]))]);\n+      assert (u[i] == u2[i / (16 / sizeof (u[0])) * (16 / sizeof (u[0])) + 16 / sizeof (u[0]) - 1 - i % (16 / sizeof (u[0]))]);\n+      assert (l[i] == l2[i / (16 / sizeof (l[0])) * (16 / sizeof (l[0])) + 16 / sizeof (l[0]) - 1 - i % (16 / sizeof (l[0]))]);\n+      assert (d[i] == d2[i / (16 / sizeof (d[0])) * (16 / sizeof (d[0])) + 16 / sizeof (d[0]) - 1 - i % (16 / sizeof (d[0]))]);\n+      assert (f[i] == f2[i / (16 / sizeof (f[0])) * (16 / sizeof (f[0])) + 16 / sizeof (f[0]) - 1 - i % (16 / sizeof (f[0]))]);\n+    }\n+}"}, {"sha": "6c061c69fea020d47ea754daacbe67cc8c1bcb01", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-reve-store-byte.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34895b6606561a36ffded81efee2904feb9c1bfd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-reve-store-byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34895b6606561a36ffded81efee2904feb9c1bfd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-reve-store-byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-reve-store-byte.c?ref=34895b6606561a36ffded81efee2904feb9c1bfd", "patch": "@@ -16,13 +16,11 @@ bar (signed char *target, vector signed char x)\n   vec_xst (vec_reve (x), 0, target);\n }\n \n-/* { dg-final { scan-assembler-times \"vstbrq\\t\" 2 } } */\n-\n-/* mem -> mem: This becomes vlbrq + vst */\n+/* mem -> mem: This becomes vl + vstbrq */\n void\n baz (vector signed char *target, vector signed char *x)\n {\n   *target = vec_reve (*x);\n }\n \n-/* { dg-final { scan-assembler-times \"vlbrq\\t\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vstbrq\\t\" 3 } } */"}]}