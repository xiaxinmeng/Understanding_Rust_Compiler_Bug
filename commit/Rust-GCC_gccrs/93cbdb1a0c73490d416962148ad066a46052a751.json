{"sha": "93cbdb1a0c73490d416962148ad066a46052a751", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNjYmRiMWEwYzczNDkwZDQxNjk2MjE0OGFkMDY2YTQ2MDUyYTc1MQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2003-12-16T22:44:19Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-12-16T22:44:19Z"}, "message": "container_benchmark.cc: New...\n\n2003-12-16  Paolo Carlini  <pcarlini@suse.de>\n\n\t* testsuite/performance/container_benchmark.cc: New, a\n\tbenchmark developed by Bjarne Stroustrup and Alexander\n\tStepanov and made available with no restrictions.\n\n\t* testsuite/testsuite_performance.h (report_header): New,\n\tuseful to produce header lines in the reports.\n\nFrom-SVN: r74713", "tree": {"sha": "abbddeab1c0c68cea911026e3b99e3ac33866199", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abbddeab1c0c68cea911026e3b99e3ac33866199"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93cbdb1a0c73490d416962148ad066a46052a751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93cbdb1a0c73490d416962148ad066a46052a751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93cbdb1a0c73490d416962148ad066a46052a751", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93cbdb1a0c73490d416962148ad066a46052a751/comments", "author": null, "committer": null, "parents": [{"sha": "6d43c524dd8eb5db820457d828749406c66d1f0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d43c524dd8eb5db820457d828749406c66d1f0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d43c524dd8eb5db820457d828749406c66d1f0a"}], "stats": {"total": 184, "additions": 184, "deletions": 0}, "files": [{"sha": "3b0ca7147289410e86c5bf27f0bd2846e81267c9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cbdb1a0c73490d416962148ad066a46052a751/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cbdb1a0c73490d416962148ad066a46052a751/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=93cbdb1a0c73490d416962148ad066a46052a751", "patch": "@@ -1,3 +1,12 @@\n+2003-12-16  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* testsuite/performance/container_benchmark.cc: New, a\n+\tbenchmark developed by Bjarne Stroustrup and Alexander\n+\tStepanov and made available with no restrictions.\n+\n+\t* testsuite/testsuite_performance.h (report_header): New,\n+\tuseful to produce header lines in the reports.\n+\n 2003-12-16  Jonathan Wakely  <redi@gcc.gnu.org>\n \n \t* docs/html/21_strings/howto.html: Document shrink-to-fit reserve()."}, {"sha": "b20376eac7d8a3994640d717d548b52c991dceb9", "filename": "libstdc++-v3/testsuite/performance/container_benchmark.cc", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cbdb1a0c73490d416962148ad066a46052a751/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fcontainer_benchmark.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cbdb1a0c73490d416962148ad066a46052a751/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fcontainer_benchmark.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fcontainer_benchmark.cc?ref=93cbdb1a0c73490d416962148ad066a46052a751", "patch": "@@ -0,0 +1,175 @@\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cmath>\n+#include <cstdlib>\n+\n+#include <vector>\n+#include <algorithm>\n+#include <list>\n+#include <deque>\n+#include <set>\n+\n+#include <sstream>\n+#include <testsuite_performance.h>\n+\n+using namespace std;\n+\n+typedef double element_t;\n+typedef void(*test)(element_t*, element_t*);\n+\n+void array_test(element_t* first, element_t* last)\n+{\n+  element_t* array = new element_t[last - first];\n+  copy(first, last, array);\n+  sort(array, array + (last - first));\n+  unique(array, array + (last - first));\n+  delete [] array;\t  \n+}\n+\n+void vector_pointer_test(element_t* first, element_t* last)\n+{ \n+  vector<element_t> container(first, last);\n+  sort(&*container.begin(), &*container.end());\n+  unique(&*container.begin(), &*container.end());\n+}\n+\n+void vector_iterator_test(element_t* first, element_t* last)\n+{\n+  vector<element_t> container(first, last);\n+  sort(container.begin(), container.end());\n+  unique(container.begin(), container.end());\n+}\n+\n+void deque_test(element_t* first, element_t* last)\n+{  \n+  deque<element_t> container(first, last);\n+  copy(first, last, container.begin()); \n+  sort(container.begin(), container.end());\n+  unique(container.begin(), container.end());\n+}\n+    \n+void list_test(element_t* first, element_t* last)\n+{ \n+  list<element_t> container(first, last);\n+  container.sort();\n+  container.unique();\n+}\n+ \n+void set_test(element_t* first, element_t* last)\n+{ set<element_t> container(first, last); }\n+\n+void multiset_test(element_t* first, element_t* last)\n+{\n+  multiset<element_t> container(first, last);\n+  typedef multiset<element_t>::iterator iterator;\n+  {\n+    iterator first = container.begin();\n+    iterator last = container.end();\n+    \n+    while (first != last)\n+      {\n+\titerator next = first;\n+\tif (++next == last) break;\n+\tif (*first == *next)\n+\t  container.erase(next);\n+\telse\n+\t  ++first;\n+      }\n+  }\n+}\n+\n+double logtwo(double x)\n+{ return log(x)/log(2.0); }\n+\n+int number_of_tests(int size)\n+{\n+  const double n = size;\n+  const double largest_n = 1000000;\n+  return int(floor((largest_n * logtwo(largest_n))\n+\t\t   / (n * logtwo(n))));\n+}\n+\n+void initialize(element_t* first, element_t* last)\n+{\n+  element_t value = 0.0;\n+  while (first != last)\n+    {\n+      *first++ = value;\n+      value += 1.;\n+    }\n+}\n+\n+void run_tests(int size, const test* tests, const char** names,\n+\t       int ntests)\n+{\n+  using namespace __gnu_test;\n+  time_counter time;\n+  resource_counter resource;\n+\n+  const int n = number_of_tests(size);\n+  const size_t length = 2 * size;\n+\n+  // make a random test set of the chosen size:\n+  vector<element_t> buf(length);\n+  element_t* buffer = &buf[0];\n+  element_t* buffer_end = &buf[length];\n+  initialize(buffer, buffer + size);\t // elements\n+  initialize(buffer + size, buffer_end); // duplicate elements\n+  random_shuffle(buffer, buffer_end);\n+\n+  // test the containers:\n+  ostringstream oss;\n+  oss << \"size = \" << size;\n+  report_header(__FILE__, oss.str());\n+  for (int i = 0; i < ntests; ++i)\n+    {\n+      start_counters(time, resource);\n+      for (int j = 0; j < n; ++j)\n+\ttests[i](buffer, buffer_end);\n+      stop_counters(time, resource);\n+      report_performance(__FILE__, names[i], time, resource);\n+      clear_counters(time, resource);\n+    }\n+}\n+\n+int main()\n+{\n+  const test tests[] = { &array_test, &vector_pointer_test,\n+\t\t\t &vector_iterator_test, &deque_test,\n+\t\t\t &list_test, &set_test, &multiset_test };\n+  const int ntests = sizeof(tests) / sizeof(test);\n+  const char* names[ntests] = { \"array\", \"vector (ptr)\",\n+\t\t\t\t\"vector (iter)\", \"deque\",\n+\t\t\t\t\"list\", \"set\", \"multiset\" };\n+\n+  const int sizes[] = {100, 1000, 10000, 100000};\n+  for (int i = 0; i < sizeof(sizes) / sizeof(int); ++i)\n+    run_tests(sizes[i], tests, names, ntests);\n+\n+  return 0;\n+}"}]}