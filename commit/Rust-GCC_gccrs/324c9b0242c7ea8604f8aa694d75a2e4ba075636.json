{"sha": "324c9b0242c7ea8604f8aa694d75a2e4ba075636", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI0YzliMDI0MmM3ZWE4NjA0ZjhhYTY5NGQ3NWEyZTRiYTA3NTYzNg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2009-06-01T14:42:56Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2009-06-01T14:42:56Z"}, "message": "tree.h (CONSTRUCTOR_BITFIELD_P): True if NODE...\n\n\t* tree.h (CONSTRUCTOR_BITFIELD_P): True if NODE, a FIELD_DECL, is\n\tto be processed as a bitfield for constructor output purposes.\n\t* output.h (initializer_constant_valid_for_bitfield_p): Declare\n\tnew function.\n\t* varasm.c (oc_local_state): New type, output_constructor\n\tlocal state to support communication with helpers.\n\t(oc_outer_state): New type, output_constructor outer state of\n\trelevance in recursive calls.\n\t(output_constructor_array_range): New output_constructor helper,\n\textracted code for an array range element.\n\t(output_constructor_regular_field): New output_constructor helper,\n\textracted code for an element that is not a bitfield.\n\t(output_constructor_bitfield): New output_constructor helper,\n\textracted code for a bitfield element.  Accept an OUTER state\n\targument for recursive processing.  Recurse on record or array\n\tCONSTRUCTOR values, possibly past noop conversions.\n\t(initializer_constant_valid_for_bitfield_p): New predicate. Whether\n\tVALUE is a valid constant-valued expression for use in a static\n\tbit-field initializer.\n\t(output_constructor): Rework to use helpers. Accept and honor an\n\tOUTER state argument for recursive calls. Return total size. Be\n\tprepared for nested constructors initializing bitfields.\n\t(output_constant): Feed OUTER in calls to output_constructor.\n\n\tada/\n\t* gcc-interface/utils2.c (gnat_build_constructor): Factor\n\tout code. Use initializer_constant_valid_for_bitfield_p and\n\tCONSTRUCTOR_BITFIELD_P for bit-fields.\n\n\ttestsuite/\n\t* gnat.dg/oconst[1-6].ad[bs]: New tests. Also support for ...\n\t* gnat.dg/test_oconst.adb: New test.\n\n\nCo-Authored-By: Eric Botcazou <ebotcazou@adacore.com>\n\nFrom-SVN: r148045", "tree": {"sha": "2fb071a57ee2fbe016eadc8f563a7c7f8a70a306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fb071a57ee2fbe016eadc8f563a7c7f8a70a306"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/324c9b0242c7ea8604f8aa694d75a2e4ba075636", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/324c9b0242c7ea8604f8aa694d75a2e4ba075636", "html_url": "https://github.com/Rust-GCC/gccrs/commit/324c9b0242c7ea8604f8aa694d75a2e4ba075636", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/324c9b0242c7ea8604f8aa694d75a2e4ba075636/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0980d7fe0b2f311dfc8e8d644d07a0a04f3cdf0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0980d7fe0b2f311dfc8e8d644d07a0a04f3cdf0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0980d7fe0b2f311dfc8e8d644d07a0a04f3cdf0c"}], "stats": {"total": 1100, "additions": 815, "deletions": 285}, "files": [{"sha": "eee6e8447fdd9c2c92df169d5735a7d3e4f8c03d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -1,3 +1,30 @@\n+2009-06-01  Olivier Hainque  <hainque@adacore.com>\n+            Eric Botcazou  <botcazou@adacore.com>\n+\n+\t* tree.h (CONSTRUCTOR_BITFIELD_P): True if NODE, a FIELD_DECL, is\n+\tto be processed as a bitfield for constructor output purposes.\n+\t* output.h (initializer_constant_valid_for_bitfield_p): Declare\n+\tnew function.\n+\t* varasm.c (oc_local_state): New type, output_constructor\n+\tlocal state to support communication with helpers.\n+\t(oc_outer_state): New type, output_constructor outer state of\n+\trelevance in recursive calls.\n+\t(output_constructor_array_range): New output_constructor helper,\n+\textracted code for an array range element.\n+\t(output_constructor_regular_field): New output_constructor helper,\n+\textracted code for an element that is not a bitfield.\n+\t(output_constructor_bitfield): New output_constructor helper,\n+\textracted code for a bitfield element.  Accept an OUTER state\n+\targument for recursive processing.  Recurse on record or array\n+\tCONSTRUCTOR values, possibly past noop conversions.\n+\t(initializer_constant_valid_for_bitfield_p): New predicate. Whether\n+\tVALUE is a valid constant-valued expression for use in a static\n+\tbit-field initializer.\n+\t(output_constructor): Rework to use helpers. Accept and honor an\n+\tOUTER state argument for recursive calls. Return total size. Be\n+\tprepared for nested constructors initializing bitfields.\n+\t(output_constant): Feed OUTER in calls to output_constructor.\n+\n 2009-06-01  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* calls.c (emit_library_call_value_1): Don't force_operand for move"}, {"sha": "51be8bf3a227cfcf6a0f3abe42aece3e9e18c88a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -1,3 +1,10 @@\n+2009-06-01  Olivier Hainque  <hainque@adacore.com>\n+            Eric Botcazou  <botcazou@adacore.com>\n+\t\n+\t* gcc-interface/utils2.c (gnat_build_constructor): Factor\n+\tout code. Use initializer_constant_valid_for_bitfield_p and\n+\tCONSTRUCTOR_BITFIELD_P for bit-fields.\n+\n 2009-05-26  Ian Lance Taylor  <iant@google.com>\n \n \t* gcc-interface/Makefile.in (COMPILER): Define."}, {"sha": "ec72a27ebbc1434c8168e6857556d512ef39b0ac", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -1623,34 +1623,35 @@ compare_elmt_bitpos (const PTR rt1, const PTR rt2)\n tree\n gnat_build_constructor (tree type, tree list)\n {\n-  tree elmt;\n-  int n_elmts;\n   bool allconstant = (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST);\n   bool side_effects = false;\n-  tree result;\n+  tree elmt, result;\n+  int n_elmts;\n \n   /* Scan the elements to see if they are all constant or if any has side\n      effects, to let us set global flags on the resulting constructor.  Count\n      the elements along the way for possible sorting purposes below.  */\n   for (n_elmts = 0, elmt = list; elmt; elmt = TREE_CHAIN (elmt), n_elmts ++)\n     {\n-      if (!TREE_CONSTANT (TREE_VALUE (elmt))\n+      tree obj = TREE_PURPOSE (elmt);\n+      tree val = TREE_VALUE (elmt);\n+\n+      /* The predicate must be in keeping with output_constructor.  */\n+      if (!TREE_CONSTANT (val)\n \t  || (TREE_CODE (type) == RECORD_TYPE\n-\t      && DECL_BIT_FIELD (TREE_PURPOSE (elmt))\n-\t      && TREE_CODE (TREE_VALUE (elmt)) != INTEGER_CST)\n-\t  || !initializer_constant_valid_p (TREE_VALUE (elmt),\n-\t\t\t\t\t    TREE_TYPE (TREE_VALUE (elmt))))\n+\t      && CONSTRUCTOR_BITFIELD_P (obj)\n+\t      && !initializer_constant_valid_for_bitfield_p (val))\n+\t  || !initializer_constant_valid_p (val, TREE_TYPE (val)))\n \tallconstant = false;\n \n-      if (TREE_SIDE_EFFECTS (TREE_VALUE (elmt)))\n+      if (TREE_SIDE_EFFECTS (val))\n \tside_effects = true;\n \n       /* Propagate an NULL_EXPR from the size of the type.  We won't ever\n \t be executing the code we generate here in that case, but handle it\n \t specially to avoid the compiler blowing up.  */\n       if (TREE_CODE (type) == RECORD_TYPE\n-\t  && (0 != (result\n-\t\t    = contains_null_expr (DECL_SIZE (TREE_PURPOSE (elmt))))))\n+\t  && (result = contains_null_expr (DECL_SIZE (obj))) != NULL_TREE)\n \treturn build1 (NULL_EXPR, type, TREE_OPERAND (result, 0));\n     }\n "}, {"sha": "9e2b704920a22a3bd78edc144f017fd90d2f2d5a", "filename": "gcc/output.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -303,6 +303,11 @@ extern bool constructor_static_from_elts_p (const_tree);\n    arithmetic-combinations of integers.  */\n extern tree initializer_constant_valid_p (tree, tree);\n \n+/* Return true if VALUE is a valid constant-valued expression\n+   for use in initializing a static bit-field; one that can be\n+   an element of a \"constant\" initializer.  */\n+extern bool initializer_constant_valid_for_bitfield_p (tree);\n+\n /* Output assembler code for constant EXP to FILE, with no label.\n    This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n    Assumes output_addressed_constants has been done on EXP already."}, {"sha": "f82565b5b37205281fb9c88336d1c954bedd1f3c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -1,3 +1,8 @@\n+2009-06-01  Olivier Hainque  <hainque@adacore.com>\n+            Eric Botcazou  <botcazou@adacore.com>\n+\n+\t* gnat.dg/oconst[1-6].ad[bs]: New tests. Also support for ...\n+\t* gnat.dg/test_oconst.adb: New test.\n \n 2009-05-31  Basile Starynkevitch  <basile@starynkevitch.net>\n "}, {"sha": "1e97ad8f2eb8a7d86b9c0700f14f38ed5d9b47da", "filename": "gcc/testsuite/gnat.dg/oconst1.adb", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foconst1.adb?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,18 @@\n+-- { dg-do compile }\n+-- { dg-final { scan-assembler-not \"elabs\" } }\n+\n+package body OCONST1 is\n+\n+  procedure check (arg : R) is\n+  begin\n+    if arg.u /= 1\n+       or else arg.b.i1 /= 2\n+       or else arg.b.i2 /= 3\n+       or else arg.b.i3 /= 4\n+    then\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+end;\n+"}, {"sha": "93b35f79bae622f8e41dd83add161e1eaa854219", "filename": "gcc/testsuite/gnat.dg/oconst1.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foconst1.ads?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,25 @@\n+package OCONST1 is\n+\n+  type u8 is mod 2**8;\n+\n+  type Base is record\n+    i1 : Integer;\n+    i2 : Integer;\n+    i3 : Integer;\n+  end Record;\n+\n+  type R is record\n+    u : u8;\n+    b : Base;\n+  end record;\n+\n+  for R use record\n+    u at 0 range 0 .. 7;\n+    b at 1 range 0 .. 95;  -- BLKmode bitfield\n+  end record;\n+\n+  My_R : constant R := (u=>1, b=>(2, 3, 4));\n+\n+  procedure check (arg : R);\n+\n+end;"}, {"sha": "d4f45ad5d040546f6160ff11a67dae572829f3b9", "filename": "gcc/testsuite/gnat.dg/oconst2.adb", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foconst2.adb?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,15 @@\n+-- { dg-do compile }\n+-- { dg-final { scan-assembler-not \"elabs\" } }\n+\n+package body OCONST2 is\n+\n+  procedure check (arg : R) is\n+  begin\n+    if arg.u /= 1\n+       or else arg.b.i1 /= 2\n+    then\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+end;"}, {"sha": "23e57a74cc2ea00ffdc428b06e56c96bd95ff7d3", "filename": "gcc/testsuite/gnat.dg/oconst2.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foconst2.ads?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,23 @@\n+package OCONST2 is\n+\n+  type u8 is mod 2**8;\n+\n+  type Base is record\n+    i1 : Integer;\n+  end Record;\n+\n+  type R is record\n+    u : u8;\n+    b : Base;\n+  end record;\n+\n+  for R use record\n+    u at 0 range 0 .. 7;\n+    b at 1 range 0 .. 31;  -- aligned SImode bitfield\n+  end record;\n+\n+  My_R : constant R := (u=>1, b=>(i1=>2));\n+\n+  procedure check (arg : R);\n+\n+end;"}, {"sha": "c9a94d4f491f63a709feccaa1037a60ed66708ff", "filename": "gcc/testsuite/gnat.dg/oconst3.adb", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foconst3.adb?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,16 @@\n+-- { dg-do compile }\n+-- { dg-final { scan-assembler-not \"elabs\" } }\n+\n+package body OCONST3 is\n+\n+  procedure check (arg : R) is\n+  begin\n+    if arg.u /= 1\n+       or else arg.f /= one\n+       or else arg.b.i1 /= 3\n+    then\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+end;"}, {"sha": "6a0094b57e97e4c349772272933f3e296a03f227", "filename": "gcc/testsuite/gnat.dg/oconst3.ads", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foconst3.ads?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,26 @@\n+package OCONST3 is\n+\n+  type bit is (zero, one);\n+  type u8 is mod 2**8;\n+\n+  type Base is record\n+    i1 : Integer;\n+  end Record;\n+\n+  type R is record\n+    u : u8;\n+    f : bit;\n+    b : Base;\n+  end record;\n+\n+  for R use record\n+    u at 0 range 0 .. 7;\n+    f at 1 range 0 .. 0;\n+    b at 1 range 1 .. 32;  -- unaligned SImode bitfield\n+  end record;\n+\n+  My_R : constant R := (u=>1, f=>one, b=>(i1=>3));\n+\n+  procedure check (arg : R);\n+\n+end;"}, {"sha": "f97f217b3da4bf651cc6c72f9b022e7d3ec5a50b", "filename": "gcc/testsuite/gnat.dg/oconst4.adb", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foconst4.adb?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,24 @@\n+-- { dg-do compile }\n+-- { dg-final { scan-assembler-not \"elabs\" } }\n+\n+package body OCONST4 is\n+\n+  procedure check (arg : R) is\n+  begin\n+    if arg.u /= 1\n+       or else arg.d.f1 /= 17\n+       or else arg.d.b.f1 /= one\n+       or else arg.d.b.f2 /= 2\n+       or else arg.d.b.f3 /= 17\n+       or else arg.d.b.f4 /= 42\n+       or else arg.d.f2 /= one\n+       or else arg.d.f3 /= 1\n+       or else arg.d.f4 /= 111\n+       or else arg.d.i1 /= 2\n+       or else arg.d.i2 /= 3\n+    then\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+end;"}, {"sha": "cde0935fe8dbc536e2ad6f99aae42efe2755fcd1", "filename": "gcc/testsuite/gnat.dg/oconst4.ads", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foconst4.ads?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,66 @@\n+package OCONST4 is\n+\n+  type bit is (zero, one);\n+  type u2 is mod 2**2;\n+  type u5 is mod 2**5;\n+  type u8 is mod 2**8;\n+\n+  type Base is record\n+    f1 : bit;\n+    f2 : u2;\n+    f3 : u5;\n+    f4 : u8;\n+  end record;\n+\n+  for Base use record\n+    f1 at 0 range  0 .. 0;\n+    f2 at 0 range  1 .. 2;\n+    f3 at 0 range  3 .. 7;\n+    f4 at 1 range  0 .. 7;\n+  end record;\n+\n+  type Derived is record\n+    f1 : u5;\n+    b  : Base;\n+    f2 : bit;\n+    f3 : u2;\n+    f4 : u8;\n+    i1 : Integer;\n+    i2 : Integer;\n+  end record;\n+\n+  for Derived use record\n+    f1 at 0 range  0 ..  4;\n+    b  at 0 range  5 .. 20;  -- unaligned HImode bitfield\n+    f2 at 0 range 21 .. 21;\n+    f3 at 0 range 22 .. 23;\n+    f4 at 0 range 24 .. 31;\n+    i1 at 4 range  0 .. 31;\n+    i2 at 8 range  0 .. 31;\n+  end record;\n+\n+  type R is record\n+    u : u8;\n+    d : Derived;\n+  end record;\n+\n+  for R use record\n+    u at 0 range 0 .. 7;\n+    d at 1 range 0 .. 95;  -- BLKmode bitfield\n+  end record;\n+\n+  My_R : constant R := (u=>1,\n+                        d=>(f1=>17,\n+                            b=>(f1=>one,\n+                                f2=>2,\n+                                f3=>17,\n+                                f4=>42),\n+                            f2=>one,\n+                            f3=>1,\n+                            f4=>111,\n+                            i1=>2,\n+                            i2=>3));\n+\n+  procedure check (arg : R);\n+\n+end;"}, {"sha": "4d4896aea585a0b8bb99cfa4e239f3be0462d5e2", "filename": "gcc/testsuite/gnat.dg/oconst5.adb", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foconst5.adb?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,15 @@\n+-- { dg-do compile }\n+-- { dg-final { scan-assembler-not \"elabs\" } }\n+\n+package body OCONST5 is\n+\n+   procedure Check (Arg : R; Bit : U1) is\n+   begin\n+      if Arg.Bit /= Bit\n+        or else Arg.Agg.A /= 3\n+        or else Arg.Agg.B /= 7\n+      then\n+         raise Program_Error;\n+      end if;\n+   end;\n+end;"}, {"sha": "f12a265d0d3c5eaccb00e2301340ed36bf5729fd", "filename": "gcc/testsuite/gnat.dg/oconst5.ads", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foconst5.ads?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,27 @@\n+package OCONST5 is\n+\n+  type u1 is mod 2**1;\n+  type u8 is mod 2**8;\n+\n+  type HI_Record is record\n+    A, B : U8;\n+  end record;\n+  pragma Suppress_Initialization (HI_Record);\n+\n+  type R is record\n+     Bit : U1;\n+     Agg : HI_Record;\n+  end record;\n+  pragma Suppress_Initialization (R);\n+\n+  for R use record\n+     Bit at 0 range  0 .. 0;\n+     Agg at 0 range  1 .. 16;\n+  end record;\n+\n+  My_R0 : R := (Bit => 0, Agg => (A => 3, B => 7));\n+  My_R1 : R := (Bit => 1, Agg => (A => 3, B => 7));\n+\n+  procedure Check (Arg : R; Bit : U1);\n+\n+end;"}, {"sha": "e4c3c50eb0dfa2a0771e3aaa8c162a79f0d8ca10", "filename": "gcc/testsuite/gnat.dg/oconst6.ads", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Foconst6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foconst6.ads?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,18 @@\n+-- { dg-do compile }\n+-- { dg-final { scan-assembler-not \"elabs\" } }\n+\n+package OCONST6 is\n+\n+   type Sequence is array (1 .. 1) of Natural;\n+\n+   type Message is record\n+      Data : Sequence;\n+   end record;\n+\n+   for Message'Alignment use 1;\n+   pragma PACK (Message);\n+\n+   ACK : Message := (Data => (others => 1));\n+\n+end;\n+"}, {"sha": "23e5a97d53734909ccce848da8e4a7cb982b8f33", "filename": "gcc/testsuite/gnat.dg/test_oconst.adb", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Ftest_oconst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftestsuite%2Fgnat.dg%2Ftest_oconst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Ftest_oconst.adb?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -0,0 +1,13 @@\n+--  { dg-do run }\n+\n+with OCONST1, OCONST2, OCONST3, OCONST4, OCONST5;\n+\n+procedure Test_Oconst is\n+begin\n+  OCONST1.check (OCONST1.My_R);\n+  OCONST2.check (OCONST2.My_R);\n+  OCONST3.check (OCONST3.My_R);\n+  OCONST4.check (OCONST4.My_R);\n+  OCONST5.check (OCONST5.My_R0, 0);\n+  OCONST5.check (OCONST5.My_R1, 1);\n+end;"}, {"sha": "5853d762afd79bccbe88dff1a13e6deec29c049c", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -1502,6 +1502,11 @@ struct GTY(()) tree_vec {\n     _ce___->value = VALUE; \\\n   } while (0)\n \n+/* True if NODE, a FIELD_DECL, is to be processed as a bitfield for\n+   constructor output purposes.  */\n+#define CONSTRUCTOR_BITFIELD_P(NODE) \\\n+  (DECL_BIT_FIELD (FIELD_DECL_CHECK (NODE)) && DECL_MODE (NODE) != BLKmode)\n+\n /* A single element of a CONSTRUCTOR. VALUE holds the actual value of the\n    element. INDEX can optionally design the position of VALUE: in arrays,\n    it is the index where VALUE has to be placed; in structures, it is the"}, {"sha": "c5de9ae7a730ea3a2f0de96da4b2ea4381b91b1b", "filename": "gcc/varasm.c", "status": "modified", "additions": 468, "deletions": 274, "changes": 742, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324c9b0242c7ea8604f8aa694d75a2e4ba075636/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=324c9b0242c7ea8604f8aa694d75a2e4ba075636", "patch": "@@ -114,7 +114,6 @@ static void output_constant_def_contents (rtx);\n static void output_addressed_constants (tree);\n static unsigned HOST_WIDE_INT array_size_for_constructor (tree);\n static unsigned min_align (unsigned, unsigned);\n-static void output_constructor (tree, unsigned HOST_WIDE_INT, unsigned int);\n static void globalize_decl (tree);\n #ifdef BSS_SECTION_ASM_OP\n #ifdef ASM_OUTPUT_BSS\n@@ -4366,6 +4365,55 @@ initializer_constant_valid_p (tree value, tree endtype)\n   return 0;\n }\n \f\n+/* Return true if VALUE is a valid constant-valued expression\n+   for use in initializing a static bit-field; one that can be\n+   an element of a \"constant\" initializer.  */\n+\n+bool\n+initializer_constant_valid_for_bitfield_p (tree value)\n+{\n+  /* For bitfields we support integer constants or possibly nested aggregates\n+     of such.  */\n+  switch (TREE_CODE (value))\n+    {\n+    case CONSTRUCTOR:\n+      {\n+\tunsigned HOST_WIDE_INT idx;\n+\ttree elt;\n+\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (value), idx, elt)\n+\t  if (!initializer_constant_valid_for_bitfield_p (elt))\n+\t    return false;\n+\treturn true;\n+      }\n+\n+    case INTEGER_CST:\n+      return true;\n+\n+    case VIEW_CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n+      return\n+\tinitializer_constant_valid_for_bitfield_p (TREE_OPERAND (value, 0));\n+\n+    default:\n+      break;\n+    }\n+\n+  return false;\n+}\n+\n+/* output_constructor outer state of relevance in recursive calls, typically\n+   for nested aggregate bitfields.  */\n+\n+typedef struct {\n+  unsigned int bit_offset;  /* current position in ...  */\n+  int byte;                 /* ... the outer byte buffer.  */\n+} oc_outer_state;\n+\n+static unsigned HOST_WIDE_INT\n+  output_constructor (tree, unsigned HOST_WIDE_INT, unsigned int,\n+\t\t      oc_outer_state *);\n+\n /* Output assembler code for constant EXP to FILE, with no label.\n    This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n    Assumes output_addressed_constants has been done on EXP already.\n@@ -4504,7 +4552,7 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n       switch (TREE_CODE (exp))\n \t{\n \tcase CONSTRUCTOR:\n-\t  output_constructor (exp, size, align);\n+\t    output_constructor (exp, size, align, NULL);\n \t  return;\n \tcase STRING_CST:\n \t  thissize = MIN ((unsigned HOST_WIDE_INT)TREE_STRING_LENGTH (exp),\n@@ -4542,7 +4590,7 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n       gcc_assert (TREE_CODE (exp) == CONSTRUCTOR);\n-      output_constructor (exp, size, align);\n+      output_constructor (exp, size, align, NULL);\n       return;\n \n     case ERROR_MARK:\n@@ -4598,316 +4646,462 @@ array_size_for_constructor (tree val)\n   return tree_low_cst (i, 1);\n }\n \n-/* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).\n-   Generate at least SIZE bytes, padding if necessary.  */\n+/* Other datastructures + helpers for output_constructor.  */\n \n-static void\n-output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n-\t\t    unsigned int align)\n-{\n-  tree type = TREE_TYPE (exp);\n-  tree field = 0;\n-  tree min_index = 0;\n-  /* Number of bytes output or skipped so far.\n-     In other words, current position within the constructor.  */\n-  HOST_WIDE_INT total_bytes = 0;\n-  /* Nonzero means BYTE contains part of a byte, to be output.  */\n-  int byte_buffer_in_use = 0;\n-  int byte = 0;\n-  unsigned HOST_WIDE_INT cnt;\n-  constructor_elt *ce;\n+/* output_constructor local state to support interaction with helpers.  */\n \n-  gcc_assert (HOST_BITS_PER_WIDE_INT >= BITS_PER_UNIT);\n+typedef struct {\n \n-  if (TREE_CODE (type) == RECORD_TYPE)\n-    field = TYPE_FIELDS (type);\n+  /* Received arguments.  */\n+  tree exp;                     /* Constructor expression.  */\n+  unsigned HOST_WIDE_INT size;  /* # bytes to output - pad if necessary.  */\n+  unsigned int align;           /* Known initial alignment.  */\n \n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_DOMAIN (type) != 0)\n-    min_index = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n+  /* Constructor expression data.  */\n+  tree type;       /* Expression type.  */\n+  tree field;      /* Current field decl in a record.  */\n+  tree min_index;  /* Lower bound if specified for an array.  */\n \n-  /* As LINK goes through the elements of the constant,\n-     FIELD goes through the structure fields, if the constant is a structure.\n-     if the constant is a union, then we override this,\n-     by getting the field from the TREE_LIST element.\n-     But the constant could also be an array.  Then FIELD is zero.\n+  /* Output processing state.  */\n+  HOST_WIDE_INT total_bytes;  /* # bytes output so far / current position.  */\n+  bool byte_buffer_in_use;    /* Whether byte ...  */\n+  int byte;                   /* ... contains part of a bitfield byte yet to\n+\t\t\t         be output.  */\n \n-     There is always a maximum of one element in the chain LINK for unions\n-     (even if the initializer in a source program incorrectly contains\n-     more one).  */\n-  for (cnt = 0;\n-       VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (exp), cnt, ce);\n-       cnt++, field = field ? TREE_CHAIN (field) : 0)\n+  int last_relative_index;    /* Implicit or explicit index of the last\n+\t\t\t\t array element output within a bitfield.  */\n+  /* Current element.  */\n+  tree val;    /* Current element value.  */\n+  tree index;  /* Current element index.  */\n+\n+} oc_local_state;\n+\n+/* Helper for output_constructor.  From the current LOCAL state, output a\n+   RANGE_EXPR element.  */\n+\n+static void\n+output_constructor_array_range (oc_local_state *local)\n+{\n+  unsigned HOST_WIDE_INT fieldsize\n+    = int_size_in_bytes (TREE_TYPE (local->type));\n+\n+  HOST_WIDE_INT lo_index\n+    = tree_low_cst (TREE_OPERAND (local->index, 0), 0);\n+  HOST_WIDE_INT hi_index\n+    = tree_low_cst (TREE_OPERAND (local->index, 1), 0);\n+  HOST_WIDE_INT index;\n+\n+  unsigned int align2\n+    = min_align (local->align, fieldsize * BITS_PER_UNIT);\n+  \n+  for (index = lo_index; index <= hi_index; index++)\n     {\n-      tree val = ce->value;\n-      tree index = 0;\n+      /* Output the element's initial value.  */\n+      if (local->val == NULL_TREE)\n+\tassemble_zeros (fieldsize);\n+      else\n+\toutput_constant (local->val, fieldsize, align2);\n+      \n+      /* Count its size.  */\n+      local->total_bytes += fieldsize;\n+    }\n+}\n \n-      /* The element in a union constructor specifies the proper field\n-\t or index.  */\n-      if ((TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE\n-\t   || TREE_CODE (type) == QUAL_UNION_TYPE)\n-\t  && ce->index != 0)\n-\tfield = ce->index;\n+/* Helper for output_constructor.  From the current LOCAL state, output a\n+   field element that is not true bitfield or part of an outer one.  */\n \n-      else if (TREE_CODE (type) == ARRAY_TYPE)\n-\tindex = ce->index;\n+static void\n+output_constructor_regular_field (oc_local_state *local)\n+{\n+  /* Field size and position.  Since this structure is static, we know the\n+     positions are constant.  */\n+  unsigned HOST_WIDE_INT fieldsize;\n+  HOST_WIDE_INT fieldpos;\n \n-#ifdef ASM_COMMENT_START\n-      if (field && flag_verbose_asm)\n-\tfprintf (asm_out_file, \"%s %s:\\n\",\n-\t\t ASM_COMMENT_START,\n-\t\t DECL_NAME (field)\n-\t\t ? IDENTIFIER_POINTER (DECL_NAME (field))\n-\t\t : \"<anonymous>\");\n-#endif\n+  unsigned int align2;\n \n-      /* Eliminate the marker that makes a cast not be an lvalue.  */\n-      if (val != 0)\n-\tSTRIP_NOPS (val);\n+  if (local->index != NULL_TREE)\n+    fieldpos = (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (local->val)), 1)\n+\t\t* ((tree_low_cst (local->index, 0) \n+\t\t    - tree_low_cst (local->min_index, 0))));\n+  else if (local->field != NULL_TREE) \n+    fieldpos = int_byte_position (local->field);\n+  else\n+    fieldpos = 0; \n+\n+  /* Output any buffered-up bit-fields preceding this element.  */\n+  if (local->byte_buffer_in_use)\n+    {\n+      assemble_integer (GEN_INT (local->byte), 1, BITS_PER_UNIT, 1);\n+      local->total_bytes++;\n+      local->byte_buffer_in_use = false;\n+    }\n+  \n+  /* Advance to offset of this element.\n+     Note no alignment needed in an array, since that is guaranteed\n+     if each element has the proper size.  */\n+  if ((local->field != NULL_TREE || local->index != NULL_TREE)\n+      && fieldpos != local->total_bytes)\n+    {\n+      gcc_assert (fieldpos >= local->total_bytes);\n+      assemble_zeros (fieldpos - local->total_bytes);\n+      local->total_bytes = fieldpos;\n+    }\n+  \n+  /* Find the alignment of this element.  */\n+  align2 = min_align (local->align, BITS_PER_UNIT * fieldpos);\n \n-      if (index && TREE_CODE (index) == RANGE_EXPR)\n+  /* Determine size this element should occupy.  */\n+  if (local->field)\n+    {\n+      fieldsize = 0;\n+      \n+      /* If this is an array with an unspecified upper bound,\n+\t the initializer determines the size.  */\n+      /* ??? This ought to only checked if DECL_SIZE_UNIT is NULL,\n+\t but we cannot do this until the deprecated support for\n+\t initializing zero-length array members is removed.  */\n+      if (TREE_CODE (TREE_TYPE (local->field)) == ARRAY_TYPE\n+\t  && TYPE_DOMAIN (TREE_TYPE (local->field))\n+\t  && ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (local->field))))\n \t{\n-\t  unsigned HOST_WIDE_INT fieldsize\n-\t    = int_size_in_bytes (TREE_TYPE (type));\n-\t  HOST_WIDE_INT lo_index = tree_low_cst (TREE_OPERAND (index, 0), 0);\n-\t  HOST_WIDE_INT hi_index = tree_low_cst (TREE_OPERAND (index, 1), 0);\n-\t  HOST_WIDE_INT index;\n-\t  unsigned int align2 = min_align (align, fieldsize * BITS_PER_UNIT);\n-\n-\t  for (index = lo_index; index <= hi_index; index++)\n-\t    {\n-\t      /* Output the element's initial value.  */\n-\t      if (val == 0)\n-\t\tassemble_zeros (fieldsize);\n-\t      else\n-\t\toutput_constant (val, fieldsize, align2);\n-\n-\t      /* Count its size.  */\n-\t      total_bytes += fieldsize;\n-\t    }\n+\t  fieldsize = array_size_for_constructor (local->val);\n+\t  /* Given a non-empty initialization, this field had\n+\t     better be last.  */\n+\t  gcc_assert (!fieldsize || !TREE_CHAIN (local->field));\n \t}\n-      else if (field == 0 || !DECL_BIT_FIELD (field))\n+      else if (DECL_SIZE_UNIT (local->field))\n \t{\n-\t  /* An element that is not a bit-field.  */\n+\t  /* ??? This can't be right.  If the decl size overflows\n+\t     a host integer we will silently emit no data.  */\n+\t  if (host_integerp (DECL_SIZE_UNIT (local->field), 1))\n+\t    fieldsize = tree_low_cst (DECL_SIZE_UNIT (local->field), 1);\n+\t}\n+    }\n+  else\n+    fieldsize = int_size_in_bytes (TREE_TYPE (local->type));\n+  \n+  /* Output the element's initial value.  */\n+  if (local->val == NULL_TREE)\n+    assemble_zeros (fieldsize);\n+  else\n+    output_constant (local->val, fieldsize, align2);\n \n-\t  unsigned HOST_WIDE_INT fieldsize;\n-\t  /* Since this structure is static,\n-\t     we know the positions are constant.  */\n-\t  HOST_WIDE_INT pos = field ? int_byte_position (field) : 0;\n-\t  unsigned int align2;\n+  /* Count its size.  */\n+  local->total_bytes += fieldsize;\n+}\n \n-\t  if (index != 0)\n-\t    pos = (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (val)), 1)\n-\t\t   * (tree_low_cst (index, 0) - tree_low_cst (min_index, 0)));\n+/* Helper for output_constructor.  From the current LOCAL and OUTER states,\n+   output an element that is a true bitfield or part of an outer one.  */\n \n-\t  /* Output any buffered-up bit-fields preceding this element.  */\n-\t  if (byte_buffer_in_use)\n-\t    {\n-\t      assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);\n-\t      total_bytes++;\n-\t      byte_buffer_in_use = 0;\n-\t    }\n-\n-\t  /* Advance to offset of this element.\n-\t     Note no alignment needed in an array, since that is guaranteed\n-\t     if each element has the proper size.  */\n-\t  if ((field != 0 || index != 0) && pos != total_bytes)\n-\t    {\n-\t      gcc_assert (pos >= total_bytes);\n-\t      assemble_zeros (pos - total_bytes);\n-\t      total_bytes = pos;\n-\t    }\n+static void\n+output_constructor_bitfield (oc_local_state *local, oc_outer_state *outer)\n+{\n+  /* Bit size of this element.  */\n+  HOST_WIDE_INT ebitsize\n+    = (local->field\n+       ? tree_low_cst (DECL_SIZE (local->field), 1)\n+       : tree_low_cst (TYPE_SIZE (TREE_TYPE (local->type)), 1));\n+\n+  /* Relative index of this element if this is an array component.  */\n+  HOST_WIDE_INT relative_index\n+    = (!local->field\n+       ? (local->index\n+\t  ? (tree_low_cst (local->index, 0) \n+\t     - tree_low_cst (local->min_index, 0))\n+\t  : local->last_relative_index + 1)\n+       : 0);\n+  \n+  /* Bit position of this element from the start of the containing\n+     constructor.  */\n+  HOST_WIDE_INT constructor_relative_ebitpos\n+      = (local->field\n+\t ? int_bit_position (local->field) \n+\t : ebitsize * relative_index);\n+  \n+  /* Bit position of this element from the start of a possibly ongoing\n+     outer byte buffer.  */\n+  HOST_WIDE_INT byte_relative_ebitpos\n+      = ((outer ? outer->bit_offset : 0) + constructor_relative_ebitpos);\n+\n+  /* From the start of a possibly ongoing outer byte buffer, offsets to \n+     the first bit of this element and to the first bit past the end of\n+     this element.  */\n+  HOST_WIDE_INT next_offset = byte_relative_ebitpos;\n+  HOST_WIDE_INT end_offset = byte_relative_ebitpos + ebitsize;\n+  \n+  local->last_relative_index = relative_index;\n+  \n+  if (local->val == NULL_TREE)\n+    local->val = integer_zero_node;\n+  \n+  while (TREE_CODE (local->val) == VIEW_CONVERT_EXPR\n+\t || TREE_CODE (local->val) == NON_LVALUE_EXPR)\n+    local->val = TREE_OPERAND (local->val, 0);\n+    \n+  if (TREE_CODE (local->val) != INTEGER_CST\n+      && TREE_CODE (local->val) != CONSTRUCTOR)\n+    {\n+      error (\"invalid initial value for member %qE\", DECL_NAME (local->field));\n+      return;\n+    }\n \n-\t  /* Find the alignment of this element.  */\n-\t  align2 = min_align (align, BITS_PER_UNIT * pos);\n+  /* If this field does not start in this (or, next) byte,\n+     skip some bytes.  */\n+  if (next_offset / BITS_PER_UNIT != local->total_bytes)\n+    {\n+      /* Output remnant of any bit field in previous bytes.  */\n+      if (local->byte_buffer_in_use)\n+\t{\n+\t  assemble_integer (GEN_INT (local->byte), 1, BITS_PER_UNIT, 1);\n+\t  local->total_bytes++;\n+\t  local->byte_buffer_in_use = false;\n+\t}\n+      \n+      /* If still not at proper byte, advance to there.  */\n+      if (next_offset / BITS_PER_UNIT != local->total_bytes)\n+\t{\n+\t  gcc_assert (next_offset / BITS_PER_UNIT >= local->total_bytes);\n+\t  assemble_zeros (next_offset / BITS_PER_UNIT - local->total_bytes);\n+\t  local->total_bytes = next_offset / BITS_PER_UNIT;\n+\t}\n+    }\n+  \n+  /* Set up the buffer if necessary.  */\n+  if (!local->byte_buffer_in_use)\n+    {\n+      local->byte = 0;\n+      if (ebitsize > 0)\n+\tlocal->byte_buffer_in_use = true;\n+    }\n+  \n+  /* If this is nested constructor, recurse passing the bit offset and the\n+     pending data, then retrieve the new pending data afterwards.  */\n+  if (TREE_CODE (local->val) == CONSTRUCTOR)\n+    {\n+      oc_outer_state output_state;\n \n-\t  /* Determine size this element should occupy.  */\n-\t  if (field)\n+      output_state.bit_offset = next_offset % BITS_PER_UNIT;\n+      output_state.byte = local->byte;\n+      local->total_bytes\n+\t  += output_constructor (local->val, 0, 0, &output_state);\n+      local->byte = output_state.byte;\n+      return;\n+    }\n+  \n+  /* Otherwise, we must split the element into pieces that fall within\n+     separate bytes, and combine each byte with previous or following\n+     bit-fields.  */  \n+  while (next_offset < end_offset)\n+    {\n+      int this_time;\n+      int shift;\n+      HOST_WIDE_INT value;\n+      HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;\n+      HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;\n+      \n+      /* Advance from byte to byte\n+\t within this element when necessary.  */\n+      while (next_byte != local->total_bytes)\n+\t{\n+\t  assemble_integer (GEN_INT (local->byte), 1, BITS_PER_UNIT, 1);\n+\t  local->total_bytes++;\n+\t  local->byte = 0;\n+\t}\n+      \n+      /* Number of bits we can process at once\n+\t (all part of the same byte).  */\n+      this_time = MIN (end_offset - next_offset,\n+\t\t       BITS_PER_UNIT - next_bit);\n+      if (BYTES_BIG_ENDIAN)\n+\t{\n+\t  /* On big-endian machine, take the most significant bits\n+\t     first (of the bits that are significant)\n+\t     and put them into bytes from the most significant end.  */\n+\t  shift = end_offset - next_offset - this_time;\n+\t  \n+\t  /* Don't try to take a bunch of bits that cross\n+\t     the word boundary in the INTEGER_CST. We can\n+\t     only select bits from the LOW or HIGH part\n+\t     not from both.  */\n+\t  if (shift < HOST_BITS_PER_WIDE_INT\n+\t      && shift + this_time > HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      fieldsize = 0;\n-\n-\t      /* If this is an array with an unspecified upper bound,\n-\t\t the initializer determines the size.  */\n-\t      /* ??? This ought to only checked if DECL_SIZE_UNIT is NULL,\n-\t\t but we cannot do this until the deprecated support for\n-\t\t initializing zero-length array members is removed.  */\n-\t      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n-\t\t  && TYPE_DOMAIN (TREE_TYPE (field))\n-\t\t  && ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (field))))\n-\t\t{\n-\t\t  fieldsize = array_size_for_constructor (val);\n-\t\t  /* Given a non-empty initialization, this field had\n-\t\t     better be last.  */\n-\t\t  gcc_assert (!fieldsize || !TREE_CHAIN (field));\n-\t\t}\n-\t      else if (DECL_SIZE_UNIT (field))\n-\t\t{\n-\t\t  /* ??? This can't be right.  If the decl size overflows\n-\t\t     a host integer we will silently emit no data.  */\n-\t\t  if (host_integerp (DECL_SIZE_UNIT (field), 1))\n-\t\t    fieldsize = tree_low_cst (DECL_SIZE_UNIT (field), 1);\n-\t\t}\n+\t      this_time = shift + this_time - HOST_BITS_PER_WIDE_INT;\n+\t      shift = HOST_BITS_PER_WIDE_INT;\n \t    }\n+\t  \n+\t  /* Now get the bits from the appropriate constant word.  */\n+\t  if (shift < HOST_BITS_PER_WIDE_INT)\n+\t    value = TREE_INT_CST_LOW (local->val);\n \t  else\n-\t    fieldsize = int_size_in_bytes (TREE_TYPE (type));\n-\n-\t  /* Output the element's initial value.  */\n-\t  if (val == 0)\n-\t    assemble_zeros (fieldsize);\n-\t  else\n-\t    output_constant (val, fieldsize, align2);\n-\n-\t  /* Count its size.  */\n-\t  total_bytes += fieldsize;\n+\t    {\n+\t      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);\n+\t      value = TREE_INT_CST_HIGH (local->val);\n+\t      shift -= HOST_BITS_PER_WIDE_INT;\n+\t    }\n+\t  \n+\t  /* Get the result. This works only when:\n+\t     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */\n+\t  local->byte |= (((value >> shift)\n+\t\t\t   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))\n+\t\t\t  << (BITS_PER_UNIT - this_time - next_bit));\n \t}\n-      else if (val != 0 && TREE_CODE (val) != INTEGER_CST)\n-\terror (\"invalid initial value for member %qE\",\n-\t       DECL_NAME (field));\n       else\n \t{\n-\t  /* Element that is a bit-field.  */\n+\t  /* On little-endian machines,\n+\t     take first the least significant bits of the value\n+\t     and pack them starting at the least significant\n+\t     bits of the bytes.  */\n+\t  shift = next_offset - byte_relative_ebitpos;\n+\t  \n+\t  /* Don't try to take a bunch of bits that cross\n+\t     the word boundary in the INTEGER_CST. We can\n+\t     only select bits from the LOW or HIGH part\n+\t     not from both.  */\n+\t  if (shift < HOST_BITS_PER_WIDE_INT\n+\t      && shift + this_time > HOST_BITS_PER_WIDE_INT)\n+\t    this_time = (HOST_BITS_PER_WIDE_INT - shift);\n+\t  \n+\t  /* Now get the bits from the appropriate constant word.  */\n+\t  if (shift < HOST_BITS_PER_WIDE_INT)\n+\t    value = TREE_INT_CST_LOW (local->val);\n+\t  else\n+\t    {\n+\t      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);\n+\t      value = TREE_INT_CST_HIGH (local->val);\n+\t      shift -= HOST_BITS_PER_WIDE_INT;\n+\t    }\n+\t  \n+\t  /* Get the result. This works only when:\n+\t     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */\n+\t  local->byte |= (((value >> shift)\n+\t\t\t   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))\n+\t\t\t  << next_bit);\n+\t}\n+      \n+      next_offset += this_time;\n+      local->byte_buffer_in_use = true;\n+    }\n+}\n \n-\t  HOST_WIDE_INT next_offset = int_bit_position (field);\n-\t  HOST_WIDE_INT end_offset\n-\t    = (next_offset + tree_low_cst (DECL_SIZE (field), 1));\n+/* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).\n+   Generate at least SIZE bytes, padding if necessary.  OUTER designates the\n+   caller output state of relevance in recursive invocations.  */\n \n-\t  if (val == 0)\n-\t    val = integer_zero_node;\n+static unsigned HOST_WIDE_INT\n+output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n+\t\t    unsigned int align, oc_outer_state * outer)\n+{\n+  unsigned HOST_WIDE_INT cnt;\n+  constructor_elt *ce;\n \n-\t  /* If this field does not start in this (or, next) byte,\n-\t     skip some bytes.  */\n-\t  if (next_offset / BITS_PER_UNIT != total_bytes)\n-\t    {\n-\t      /* Output remnant of any bit field in previous bytes.  */\n-\t      if (byte_buffer_in_use)\n-\t\t{\n-\t\t  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);\n-\t\t  total_bytes++;\n-\t\t  byte_buffer_in_use = 0;\n-\t\t}\n+  oc_local_state local;\n \n-\t      /* If still not at proper byte, advance to there.  */\n-\t      if (next_offset / BITS_PER_UNIT != total_bytes)\n-\t\t{\n-\t\t  gcc_assert (next_offset / BITS_PER_UNIT >= total_bytes);\n-\t\t  assemble_zeros (next_offset / BITS_PER_UNIT - total_bytes);\n-\t\t  total_bytes = next_offset / BITS_PER_UNIT;\n-\t\t}\n-\t    }\n+  /* Setup our local state to communicate with helpers.  */\n+  local.exp = exp;\n+  local.size = size;\n+  local.align = align;\n \n-\t  if (! byte_buffer_in_use)\n-\t    byte = 0;\n+  local.total_bytes = 0;\n+  local.byte_buffer_in_use = outer != NULL;\n+  local.byte = outer ? outer->byte : 0;\n \n-\t  /* We must split the element into pieces that fall within\n-\t     separate bytes, and combine each byte with previous or\n-\t     following bit-fields.  */\n+  local.type = TREE_TYPE (exp);\n \n-\t  /* next_offset is the offset n fbits from the beginning of\n-\t     the structure to the next bit of this element to be processed.\n-\t     end_offset is the offset of the first bit past the end of\n-\t     this element.  */\n-\t  while (next_offset < end_offset)\n-\t    {\n-\t      int this_time;\n-\t      int shift;\n-\t      HOST_WIDE_INT value;\n-\t      HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;\n-\t      HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;\n-\n-\t      /* Advance from byte to byte\n-\t\t within this element when necessary.  */\n-\t      while (next_byte != total_bytes)\n-\t\t{\n-\t\t  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);\n-\t\t  total_bytes++;\n-\t\t  byte = 0;\n-\t\t}\n+  local.last_relative_index = -1;\n \n-\t      /* Number of bits we can process at once\n-\t\t (all part of the same byte).  */\n-\t      this_time = MIN (end_offset - next_offset,\n-\t\t\t       BITS_PER_UNIT - next_bit);\n-\t      if (BYTES_BIG_ENDIAN)\n-\t\t{\n-\t\t  /* On big-endian machine, take the most significant bits\n-\t\t     first (of the bits that are significant)\n-\t\t     and put them into bytes from the most significant end.  */\n-\t\t  shift = end_offset - next_offset - this_time;\n-\n-\t\t  /* Don't try to take a bunch of bits that cross\n-\t\t     the word boundary in the INTEGER_CST. We can\n-\t\t     only select bits from the LOW or HIGH part\n-\t\t     not from both.  */\n-\t\t  if (shift < HOST_BITS_PER_WIDE_INT\n-\t\t      && shift + this_time > HOST_BITS_PER_WIDE_INT)\n-\t\t    {\n-\t\t      this_time = shift + this_time - HOST_BITS_PER_WIDE_INT;\n-\t\t      shift = HOST_BITS_PER_WIDE_INT;\n-\t\t    }\n-\n-\t\t  /* Now get the bits from the appropriate constant word.  */\n-\t\t  if (shift < HOST_BITS_PER_WIDE_INT)\n-\t\t    value = TREE_INT_CST_LOW (val);\n-\t\t  else\n-\t\t    {\n-\t\t      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);\n-\t\t      value = TREE_INT_CST_HIGH (val);\n-\t\t      shift -= HOST_BITS_PER_WIDE_INT;\n-\t\t    }\n-\n-\t\t  /* Get the result. This works only when:\n-\t\t     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */\n-\t\t  byte |= (((value >> shift)\n-\t\t\t    & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))\n-\t\t\t   << (BITS_PER_UNIT - this_time - next_bit));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* On little-endian machines,\n-\t\t     take first the least significant bits of the value\n-\t\t     and pack them starting at the least significant\n-\t\t     bits of the bytes.  */\n-\t\t  shift = next_offset - int_bit_position (field);\n-\n-\t\t  /* Don't try to take a bunch of bits that cross\n-\t\t     the word boundary in the INTEGER_CST. We can\n-\t\t     only select bits from the LOW or HIGH part\n-\t\t     not from both.  */\n-\t\t  if (shift < HOST_BITS_PER_WIDE_INT\n-\t\t      && shift + this_time > HOST_BITS_PER_WIDE_INT)\n-\t\t    this_time = (HOST_BITS_PER_WIDE_INT - shift);\n-\n-\t\t  /* Now get the bits from the appropriate constant word.  */\n-\t\t  if (shift < HOST_BITS_PER_WIDE_INT)\n-\t\t    value = TREE_INT_CST_LOW (val);\n-\t\t  else\n-\t\t    {\n-\t\t      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);\n-\t\t      value = TREE_INT_CST_HIGH (val);\n-\t\t      shift -= HOST_BITS_PER_WIDE_INT;\n-\t\t    }\n-\n-\t\t  /* Get the result. This works only when:\n-\t\t     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */\n-\t\t  byte |= (((value >> shift)\n-\t\t\t    & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))\n-\t\t\t   << next_bit);\n-\t\t}\n+  local.min_index = NULL_TREE;\n+  if (TREE_CODE (local.type) == ARRAY_TYPE\n+      && TYPE_DOMAIN (local.type) != NULL_TREE)\n+    local.min_index = TYPE_MIN_VALUE (TYPE_DOMAIN (local.type));\n+  \n+  gcc_assert (HOST_BITS_PER_WIDE_INT >= BITS_PER_UNIT);\n \n-\t      next_offset += this_time;\n-\t      byte_buffer_in_use = 1;\n-\t    }\n-\t}\n-    }\n+  /* As CE goes through the elements of the constant, FIELD goes through the\n+     structure fields if the constant is a structure.  If the constant is a\n+     union, we override this by getting the field from the TREE_LIST element.\n+     But the constant could also be an array.  Then FIELD is zero.\n \n-  if (byte_buffer_in_use)\n+     There is always a maximum of one element in the chain LINK for unions\n+     (even if the initializer in a source program incorrectly contains\n+     more one).  */\n+\n+  local.field = NULL_TREE;\n+  if (TREE_CODE (local.type) == RECORD_TYPE)\n+    local.field = TYPE_FIELDS (local.type);\n+\n+  for (cnt = 0;\n+       VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (exp), cnt, ce);\n+       cnt++, local.field = local.field ? TREE_CHAIN (local.field) : 0)\n     {\n-      assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);\n-      total_bytes++;\n+      local.val = ce->value;\n+      local.index = NULL_TREE;\n+\n+      /* The element in a union constructor specifies the proper field\n+\t or index.  */\n+      if ((TREE_CODE (local.type) == RECORD_TYPE\n+\t   || TREE_CODE (local.type) == UNION_TYPE\n+\t   || TREE_CODE (local.type) == QUAL_UNION_TYPE)\n+\t  && ce->index != NULL_TREE)\n+\tlocal.field = ce->index;\n+\n+      else if (TREE_CODE (local.type) == ARRAY_TYPE)\n+\tlocal.index = ce->index;\n+\n+#ifdef ASM_COMMENT_START\n+      if (local.field && flag_verbose_asm)\n+\tfprintf (asm_out_file, \"%s %s:\\n\",\n+\t\t ASM_COMMENT_START,\n+\t\t DECL_NAME (local.field)\n+\t\t ? IDENTIFIER_POINTER (DECL_NAME (local.field))\n+\t\t : \"<anonymous>\");\n+#endif\n+\n+      /* Eliminate the marker that makes a cast not be an lvalue.  */\n+      if (local.val != NULL_TREE)\n+\tSTRIP_NOPS (local.val);\n+\n+      /* Output the current element, using the appropriate helper ...  */\n+\n+      /* For an array slice not part of an outer bitfield.  */\n+      if (!outer\n+\t  && local.index != NULL_TREE\n+\t  && TREE_CODE (local.index) == RANGE_EXPR)\n+\toutput_constructor_array_range (&local);\n+\n+      /* For a field that is neither a true bitfield nor part of an outer one,\n+\t known to be at least byte aligned and multiple-of-bytes long.  */\n+      else if (!outer\n+\t       && (local.field == NULL_TREE\n+\t\t   || !CONSTRUCTOR_BITFIELD_P (local.field)))\n+\toutput_constructor_regular_field (&local);\n+      \n+      /* For a true bitfield or part of an outer one.  */\n+      else\n+\toutput_constructor_bitfield (&local, outer);\n     }\n \n-  if ((unsigned HOST_WIDE_INT)total_bytes < size)\n-    assemble_zeros (size - total_bytes);\n+  /* If we are not at toplevel, save the pending data for our caller.\n+     Otherwise output the pending data and padding zeros as needed. */\n+  if (outer)\n+    outer->byte = local.byte;\n+  else\n+    {\n+      if (local.byte_buffer_in_use)\n+\t{\n+\t  assemble_integer (GEN_INT (local.byte), 1, BITS_PER_UNIT, 1);\n+\t  local.total_bytes++;\n+\t}\n+\n+      if ((unsigned HOST_WIDE_INT)local.total_bytes < local.size)\n+\t{\n+\t  assemble_zeros (local.size - local.total_bytes);\n+\t  local.total_bytes = local.size;\n+\t}\n+    }\n+      \n+  return local.total_bytes;\n }\n \n /* Mark DECL as weak.  */"}]}