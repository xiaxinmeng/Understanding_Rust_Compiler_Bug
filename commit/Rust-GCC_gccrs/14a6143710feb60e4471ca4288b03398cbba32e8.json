{"sha": "14a6143710feb60e4471ca4288b03398cbba32e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRhNjE0MzcxMGZlYjYwZTQ0NzFjYTQyODhiMDMzOThjYmJhMzJlOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-05-28T13:29:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-05-28T13:29:41Z"}, "message": "tree-vect-loop.c (vect_fixup_reduc_chain): New function.\n\n2015-05-28  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (vect_fixup_reduc_chain): New function.\n\t(vect_fixup_scalar_cycles_with_patterns): Likewise.\n\t(vect_analyze_loop_2): Call vect_fixup_scalar_cycles_with_patterns\n\tafter pattern recog.\n\t(vect_create_epilog_for_reduction): Properly handle reductions\n\twith patterns.\n\t(vectorizable_reduction): Likewise.\n\t* tree-vect-slp.c (vect_analyze_slp_instance): Properly mark\n\treduction chains.\n\t(vect_get_constant_vectors): Create the correct number of\n\tinitial values for reductions.\n\t(vect_schedule_slp_instance): Handle reduction chains that are\n\ttype changing properly.\n\t* tree-vect-stmts.c (vect_analyze_stmt): Adjust.\n\n\t* gcc.dg/vect/slp-reduc-sad.c: New testcase.\n\nFrom-SVN: r223818", "tree": {"sha": "e58d06abd6645dd0965c136f0078b9ac6a74f784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e58d06abd6645dd0965c136f0078b9ac6a74f784"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14a6143710feb60e4471ca4288b03398cbba32e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14a6143710feb60e4471ca4288b03398cbba32e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14a6143710feb60e4471ca4288b03398cbba32e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14a6143710feb60e4471ca4288b03398cbba32e8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "228722248f2f6a9e32d8f761e6579c2f56cdec4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/228722248f2f6a9e32d8f761e6579c2f56cdec4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/228722248f2f6a9e32d8f761e6579c2f56cdec4f"}], "stats": {"total": 205, "additions": 173, "deletions": 32}, "files": [{"sha": "2a2829dad3418f7cb629ba9b104b1e655d57e648", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14a6143710feb60e4471ca4288b03398cbba32e8", "patch": "@@ -1,3 +1,20 @@\n+2015-05-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (vect_fixup_reduc_chain): New function.\n+\t(vect_fixup_scalar_cycles_with_patterns): Likewise.\n+\t(vect_analyze_loop_2): Call vect_fixup_scalar_cycles_with_patterns\n+\tafter pattern recog.\n+\t(vect_create_epilog_for_reduction): Properly handle reductions\n+\twith patterns.\n+\t(vectorizable_reduction): Likewise.\n+\t* tree-vect-slp.c (vect_analyze_slp_instance): Properly mark\n+\treduction chains.\n+\t(vect_get_constant_vectors): Create the correct number of\n+\tinitial values for reductions.\n+\t(vect_schedule_slp_instance): Handle reduction chains that are\n+\ttype changing properly.\n+\t* tree-vect-stmts.c (vect_analyze_stmt): Adjust.\n+\n 2015-05-28  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/66142"}, {"sha": "1a2b185eff0d21507c9a3d7120462b31124b37d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=14a6143710feb60e4471ca4288b03398cbba32e8", "patch": "@@ -1,3 +1,7 @@\n+2015-05-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/slp-reduc-sad.c: New testcase.\n+\n 2015-05-28  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/66142"}, {"sha": "472544f4fb2f6157447797b8fdb0296e41af1c32", "filename": "gcc/testsuite/gcc.dg/vect/slp-reduc-sad.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-sad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-sad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-sad.c?ref=14a6143710feb60e4471ca4288b03398cbba32e8", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-require-effective-target vect_usad_char } */\n+\n+#include \"tree-vect.h\"\n+\n+typedef unsigned int uint32_t;\n+typedef unsigned short uint16_t;\n+typedef unsigned char uint8_t;\n+\n+extern int abs (int);\n+extern void abort (void);\n+\n+int __attribute__((noinline,noclone))\n+foo (uint8_t *pix1, uint8_t *pix2, int i_stride_pix2)\n+{\n+  int i_sum = 0;\n+  for( int y = 0; y < 16; y++ )\n+    {\n+      i_sum += abs ( pix1[0] - pix2[0] );\n+      i_sum += abs ( pix1[1] - pix2[1] );\n+      i_sum += abs ( pix1[2] - pix2[2] );\n+      i_sum += abs ( pix1[3] - pix2[3] );\n+      i_sum += abs ( pix1[4] - pix2[4] );\n+      i_sum += abs ( pix1[5] - pix2[5] );\n+      i_sum += abs ( pix1[6] - pix2[6] );\n+      i_sum += abs ( pix1[7] - pix2[7] );\n+      i_sum += abs ( pix1[8] - pix2[8] );\n+      i_sum += abs ( pix1[9] - pix2[9] );\n+      i_sum += abs ( pix1[10] - pix2[10] );\n+      i_sum += abs ( pix1[11] - pix2[11] );\n+      i_sum += abs ( pix1[12] - pix2[12] );\n+      i_sum += abs ( pix1[13] - pix2[13] );\n+      i_sum += abs ( pix1[14] - pix2[14] );\n+      i_sum += abs ( pix1[15] - pix2[15] );\n+      pix1 += 16;\n+      pix2 += i_stride_pix2;\n+    }\n+  return i_sum; \n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+\n+  uint8_t X[16*16];\n+  uint8_t Y[16*16];\n+\n+  for (int i = 0; i < 16*16; ++i)\n+    {\n+      X[i] = i;\n+      Y[i] = 16*16 - i;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  if (foo (X, Y, 16) != 32512)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_sad_pattern: detected\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "71df11c0f6f7069ac4e7f2efc2085bbb21847839", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 69, "deletions": 26, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=14a6143710feb60e4471ca4288b03398cbba32e8", "patch": "@@ -828,6 +828,45 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n     vect_analyze_scalar_cycles_1 (loop_vinfo, loop->inner);\n }\n \n+/* Transfer group and reduction information from STMT to its pattern stmt.  */\n+\n+static void\n+vect_fixup_reduc_chain (gimple stmt)\n+{\n+  gimple firstp = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n+  gimple stmtp;\n+  gcc_assert (!GROUP_FIRST_ELEMENT (vinfo_for_stmt (firstp))\n+\t      && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)));\n+  GROUP_SIZE (vinfo_for_stmt (firstp)) = GROUP_SIZE (vinfo_for_stmt (stmt));\n+  do\n+    {\n+      stmtp = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n+      GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmtp)) = firstp;\n+      stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n+      if (stmt)\n+\tGROUP_NEXT_ELEMENT (vinfo_for_stmt (stmtp))\n+\t  = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n+    }\n+  while (stmt);\n+  STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmtp)) = vect_reduction_def;\n+}\n+\n+/* Fixup scalar cycles that now have their stmts detected as patterns.  */\n+\n+static void\n+vect_fixup_scalar_cycles_with_patterns (loop_vec_info loop_vinfo)\n+{\n+  gimple first;\n+  unsigned i;\n+\n+  FOR_EACH_VEC_ELT (LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo), i, first)\n+    if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (first)))\n+      {\n+\tvect_fixup_reduc_chain (first);\n+\tLOOP_VINFO_REDUCTION_CHAINS (loop_vinfo)[i]\n+\t  = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (first));\n+      }\n+}\n \n /* Function vect_get_loop_niters.\n \n@@ -1708,6 +1747,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n \n   vect_pattern_recog (loop_vinfo, NULL);\n \n+  vect_fixup_scalar_cycles_with_patterns (loop_vinfo);\n+\n   /* Analyze the access patterns of the data-refs in the loop (consecutive,\n      complex, etc.). FORNOW: Only handle consecutive access pattern.  */\n \n@@ -4573,8 +4614,12 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n      exit phi node.  */\n   if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n-      scalar_dest = gimple_assign_lhs (\n-\t\t\tSLP_TREE_SCALAR_STMTS (slp_node)[group_size - 1]);\n+      gimple dest_stmt = SLP_TREE_SCALAR_STMTS (slp_node)[group_size - 1];\n+      /* Handle reduction patterns.  */\n+      if (STMT_VINFO_RELATED_STMT (vinfo_for_stmt (dest_stmt)))\n+\tdest_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (dest_stmt));\n+\n+      scalar_dest = gimple_assign_lhs (dest_stmt);\n       group_size = 1;\n     }\n \n@@ -4875,12 +4920,17 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   auto_vec<gimple> phis;\n   int vec_num;\n   tree def0, def1, tem, op0, op1 = NULL_TREE;\n+  bool first_p = true;\n \n   /* In case of reduction chain we switch to the first stmt in the chain, but\n      we don't update STMT_INFO, since only the last stmt is marked as reduction\n      and has reduction properties.  */\n-  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n-    stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+  if (GROUP_FIRST_ELEMENT (stmt_info)\n+      && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n+    {\n+      stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      first_p = false;\n+    }\n \n   if (nested_in_vect_loop_p (loop, stmt))\n     {\n@@ -4903,8 +4953,8 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Make sure it was already recognized as a reduction computation.  */\n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def\n-      && STMT_VINFO_DEF_TYPE (stmt_info) != vect_nested_cycle)\n+  if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != vect_reduction_def\n+      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != vect_nested_cycle)\n     return false;\n \n   /* 2. Has this been recognized as a reduction pattern?\n@@ -4914,7 +4964,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n      the STMT_VINFO_RELATED_STMT field records the last stmt in\n      the original sequence that constitutes the pattern.  */\n \n-  orig_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+  orig_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n   if (orig_stmt)\n     {\n       orig_stmt_info = vinfo_for_stmt (orig_stmt);\n@@ -5040,20 +5090,16 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n+  gimple tmp = vect_is_simple_reduction (loop_vinfo, reduc_def_stmt,\n+\t\t\t\t\t !nested_cycle, &dummy);\n   if (orig_stmt)\n-    gcc_assert (orig_stmt == vect_is_simple_reduction (loop_vinfo,\n-                                                       reduc_def_stmt,\n-                                                       !nested_cycle,\n-                                                       &dummy));\n+    gcc_assert (tmp == orig_stmt\n+\t\t|| GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp)) == orig_stmt);\n   else\n-    {\n-      gimple tmp = vect_is_simple_reduction (loop_vinfo, reduc_def_stmt,\n-                                             !nested_cycle, &dummy);\n-      /* We changed STMT to be the first stmt in reduction chain, hence we\n-         check that in this case the first element in the chain is STMT.  */\n-      gcc_assert (stmt == tmp\n-                  || GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp)) == stmt);\n-    }\n+    /* We changed STMT to be the first stmt in reduction chain, hence we\n+       check that in this case the first element in the chain is STMT.  */\n+    gcc_assert (stmt == tmp\n+\t\t|| GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp)) == stmt);\n \n   if (STMT_VINFO_LIVE_P (vinfo_for_stmt (reduc_def_stmt)))\n     return false;\n@@ -5267,8 +5313,9 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n-      if (!vect_model_reduction_cost (stmt_info, epilog_reduc_code, ncopies,\n-\t\t\t\t      reduc_index))\n+      if (first_p\n+\t  && !vect_model_reduction_cost (stmt_info, epilog_reduc_code, ncopies,\n+\t\t\t\t\t reduc_index))\n         return false;\n       STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n       return true;\n@@ -5324,11 +5371,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   prev_stmt_info = NULL;\n   prev_phi_info = NULL;\n   if (slp_node)\n-    {\n-      vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-      gcc_assert (TYPE_VECTOR_SUBPARTS (vectype_out) \n-                  == TYPE_VECTOR_SUBPARTS (vectype_in));\n-    }\n+    vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n   else\n     {\n       vec_num = 1;"}, {"sha": "f38191d9884565aa7c19ce6644ae16c6261c50f9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=14a6143710feb60e4471ca4288b03398cbba32e8", "patch": "@@ -1793,6 +1793,11 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n             scalar_stmts.safe_push (next);\n           next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n         }\n+      /* Mark the first element of the reduction chain as reduction to properly\n+\t transform the node.  In the reduction analysis phase only the last\n+\t element of the chain is marked as reduction.  */\n+      if (!STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt)))\n+\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = vect_reduction_def;\n     }\n   else\n     {\n@@ -2738,7 +2743,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n      (s1, s2, ..., s8).  We will create two vectors {s1, s2, s3, s4} and\n      {s5, s6, s7, s8}.  */\n \n-  number_of_copies = least_common_multiple (nunits, group_size) / group_size;\n+  number_of_copies = nunits * number_of_vectors / group_size;\n \n   number_of_places_left_in_vector = nunits;\n   elts = XALLOCAVEC (tree, nunits);\n@@ -3383,8 +3388,14 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n      for the scalar stmts in each node of the SLP tree.  Number of vector\n      elements in one vector iteration is the number of scalar elements in\n      one scalar iteration (GROUP_SIZE) multiplied by VF divided by vector\n-     size.  */\n-  vec_stmts_size = (vectorization_factor * group_size) / nunits;\n+     size.\n+     Unless this is a SLP reduction in which case the number of vector\n+     stmts is equal to the number of vector stmts of the children.  */\n+  if (GROUP_FIRST_ELEMENT (stmt_info)\n+      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+    vec_stmts_size = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_CHILDREN (node)[0]);\n+  else\n+    vec_stmts_size = (vectorization_factor * group_size) / nunits;\n \n   if (!SLP_TREE_VEC_STMTS (node).exists ())\n     {"}, {"sha": "6b018e53aadef6d7e68746a1f6196ad3489bfdae", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14a6143710feb60e4471ca4288b03398cbba32e8/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=14a6143710feb60e4471ca4288b03398cbba32e8", "patch": "@@ -7310,9 +7310,11 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n \n       case vect_reduction_def:\n       case vect_nested_cycle:\n-         gcc_assert (!bb_vinfo && (relevance == vect_used_in_outer\n-                     || relevance == vect_used_in_outer_by_reduction\n-                     || relevance == vect_unused_in_scope));\n+         gcc_assert (!bb_vinfo\n+\t\t     && (relevance == vect_used_in_outer\n+\t\t\t || relevance == vect_used_in_outer_by_reduction\n+\t\t\t || relevance == vect_used_by_reduction\n+\t\t\t || relevance == vect_unused_in_scope));\n          break;\n \n       case vect_induction_def:"}]}