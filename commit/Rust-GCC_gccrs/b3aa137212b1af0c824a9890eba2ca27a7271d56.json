{"sha": "b3aa137212b1af0c824a9890eba2ca27a7271d56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNhYTEzNzIxMmIxYWYwYzgyNGE5ODkwZWJhMmNhMjdhNzI3MWQ1Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-06T13:47:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-06T13:47:25Z"}, "message": "reassoc: Improve maybe_optimize_range_tests [PR96480]\n\nOn the following testcase, if the IL before reassoc would be:\n...\n  <bb 4> [local count: 354334800]:\n  if (x_3(D) == 2)\n    goto <bb 7>; [34.00%]\n  else\n    goto <bb 5>; [66.00%]\n\n  <bb 5> [local count: 233860967]:\n  if (x_3(D) == 3)\n    goto <bb 7>; [34.00%]\n  else\n    goto <bb 6>; [66.00%]\n\n  <bb 6> [local count: 79512730]:\n\n  <bb 7> [local count: 1073741824]:\n  # prephitmp_7 = PHI <1(3), 1(4), 1(5), 1(2), 0(6)>\nthen we'd optimize it properly, but as bb 5-7 is instead:\n  <bb 5> [local count: 233860967]:\n  if (x_3(D) == 3)\n    goto <bb 6>; [34.00%]\n  else\n    goto <bb 7>; [66.00%]\n\n  <bb 6> [local count: 79512730]:\n\n  <bb 7> [local count: 1073741824]:\n  # prephitmp_7 = PHI <1(3), 1(4), 0(5), 1(2), 1(6)>\n(i.e. the true/false edges on the last bb with condition swapped\nand ditto for the phi args), we don't recognize it.  If bb 6\nis empty, there should be no functional difference between the two IL\nrepresentations.\n\nThis patch handles those special cases.\n\n2020-08-06  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/96480\n\t* tree-ssa-reassoc.c (suitable_cond_bb): Add TEST_SWAPPED_P argument.\n\tIf TEST_BB ends in cond and has one edge to *OTHER_BB and another\n\tthrough an empty bb to that block too, if PHI args don't match, retry\n\tthem through the other path from TEST_BB.\n\t(maybe_optimize_range_tests): Adjust callers.  Handle such LAST_BB\n\tthrough inversion of the condition.\n\n\t* gcc.dg/tree-ssa/pr96480.c: New test.", "tree": {"sha": "882174cfdd4295b46dfe6127e4f57126122a806a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/882174cfdd4295b46dfe6127e4f57126122a806a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3aa137212b1af0c824a9890eba2ca27a7271d56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3aa137212b1af0c824a9890eba2ca27a7271d56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3aa137212b1af0c824a9890eba2ca27a7271d56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3aa137212b1af0c824a9890eba2ca27a7271d56/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af30b83b50953fbbe671d93d44ea6ac2f7a50ce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af30b83b50953fbbe671d93d44ea6ac2f7a50ce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af30b83b50953fbbe671d93d44ea6ac2f7a50ce9"}], "stats": {"total": 111, "additions": 101, "deletions": 10}, "files": [{"sha": "f2a91ef9909de7ea6a5c565a83c1b914bdd02fa1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr96480.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3aa137212b1af0c824a9890eba2ca27a7271d56/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96480.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3aa137212b1af0c824a9890eba2ca27a7271d56/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96480.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96480.c?ref=b3aa137212b1af0c824a9890eba2ca27a7271d56", "patch": "@@ -0,0 +1,23 @@\n+/* PR tree-optimization/96480 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump \" = _\\[0-9]* <= 3;\" \"optimized\" } } */\n+\n+int v[4];\n+\n+int\n+foo (int x)\n+{\n+  int *p;\n+  if (x == 0)\n+    p = &v[0];\n+  else if (x == 1)\n+    p = &v[1];\n+  else if (x == 2)\n+    p = &v[2];\n+  else if (x == 3)\n+    p = &v[3];\n+  else\n+    p = &v[4];\n+  return p != &v[4];\n+}"}, {"sha": "fed463b0350df09828cdf0a6262572f153c6b70e", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3aa137212b1af0c824a9890eba2ca27a7271d56/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3aa137212b1af0c824a9890eba2ca27a7271d56/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=b3aa137212b1af0c824a9890eba2ca27a7271d56", "patch": "@@ -4127,11 +4127,14 @@ final_range_test_p (gimple *stmt)\n    of TEST_BB, and *OTHER_BB is either NULL and filled by the routine,\n    or compared with to find a common basic block to which all conditions\n    branch to if true resp. false.  If BACKWARD is false, TEST_BB should\n-   be the only predecessor of BB.  */\n+   be the only predecessor of BB.  *TEST_SWAPPED_P is set to true if\n+   TEST_BB is a bb ending in condition where the edge to non-*OTHER_BB\n+   block points to an empty block that falls through into *OTHER_BB and\n+   the phi args match that path.  */\n \n static bool\n suitable_cond_bb (basic_block bb, basic_block test_bb, basic_block *other_bb,\n-\t\t  bool backward)\n+\t\t  bool *test_swapped_p, bool backward)\n {\n   edge_iterator ei, ei2;\n   edge e, e2;\n@@ -4196,6 +4199,7 @@ suitable_cond_bb (basic_block bb, basic_block test_bb, basic_block *other_bb,\n   /* Now check all PHIs of *OTHER_BB.  */\n   e = find_edge (bb, *other_bb);\n   e2 = find_edge (test_bb, *other_bb);\n+ retry:;\n   for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gphi *phi = gsi.phi ();\n@@ -4221,11 +4225,52 @@ suitable_cond_bb (basic_block bb, basic_block test_bb, basic_block *other_bb,\n \t  else\n \t    {\n \t      gimple *test_last = last_stmt (test_bb);\n-\t      if (gimple_code (test_last) != GIMPLE_COND\n-\t\t  && gimple_phi_arg_def (phi, e2->dest_idx)\n-\t\t     == gimple_assign_lhs (test_last)\n-\t\t  && (integer_zerop (gimple_phi_arg_def (phi, e->dest_idx))\n-\t\t      || integer_onep (gimple_phi_arg_def (phi, e->dest_idx))))\n+\t      if (gimple_code (test_last) == GIMPLE_COND)\n+\t\t{\n+\t\t  if (backward ? e2->src != test_bb : e->src != bb)\n+\t\t    return false;\n+\n+\t\t  /* For last_bb, handle also:\n+\t\t     if (x_3(D) == 3)\n+\t\t       goto <bb 6>; [34.00%]\n+\t\t     else\n+\t\t       goto <bb 7>; [66.00%]\n+\n+\t\t     <bb 6> [local count: 79512730]:\n+\n+\t\t     <bb 7> [local count: 1073741824]:\n+\t\t     # prephitmp_7 = PHI <1(3), 1(4), 0(5), 1(2), 1(6)>\n+\t\t     where bb 7 is *OTHER_BB, but the PHI values from the\n+\t\t     earlier bbs match the path through the empty bb\n+\t\t     in between.  */\n+\t\t  edge e3;\n+\t\t  if (backward)\n+\t\t    e3 = EDGE_SUCC (test_bb,\n+\t\t\t\t    e2 == EDGE_SUCC (test_bb, 0) ? 1 : 0);\n+\t\t  else\n+\t\t    e3 = EDGE_SUCC (bb,\n+\t\t\t\t    e == EDGE_SUCC (bb, 0) ? 1 : 0);\n+\t\t  if (empty_block_p (e3->dest)\n+\t\t      && single_succ_p (e3->dest)\n+\t\t      && single_succ (e3->dest) == *other_bb\n+\t\t      && single_pred_p (e3->dest)\n+\t\t      && single_succ_edge (e3->dest)->flags == EDGE_FALLTHRU)\n+\t\t    {\n+\t\t      if (backward)\n+\t\t\te2 = single_succ_edge (e3->dest);\n+\t\t      else\n+\t\t\te = single_succ_edge (e3->dest);\n+\t\t      if (test_swapped_p)\n+\t\t\t*test_swapped_p = true;\n+\t\t      goto retry;\n+\t\t    }\n+\t\t}\n+\t      else if (gimple_phi_arg_def (phi, e2->dest_idx)\n+\t\t       == gimple_assign_lhs (test_last)\n+\t\t       && (integer_zerop (gimple_phi_arg_def (phi,\n+\t\t\t\t\t\t\t      e->dest_idx))\n+\t\t\t   || integer_onep (gimple_phi_arg_def (phi,\n+\t\t\t\t\t\t\t\te->dest_idx))))\n \t\tcontinue;\n \t    }\n \n@@ -4414,7 +4459,7 @@ maybe_optimize_range_tests (gimple *stmt)\n   while (single_pred_p (first_bb))\n     {\n       basic_block pred_bb = single_pred (first_bb);\n-      if (!suitable_cond_bb (pred_bb, first_bb, &other_bb, true))\n+      if (!suitable_cond_bb (pred_bb, first_bb, &other_bb, NULL, true))\n \tbreak;\n       if (!no_side_effect_bb (first_bb))\n \tbreak;\n@@ -4444,7 +4489,8 @@ maybe_optimize_range_tests (gimple *stmt)\n \t\t&& gimple_code (stmt) == GIMPLE_COND\n \t\t&& EDGE_COUNT (e->dest->succs) == 2)\n \t      {\n-\t\tif (suitable_cond_bb (first_bb, e->dest, &other_bb, true))\n+\t\tif (suitable_cond_bb (first_bb, e->dest, &other_bb,\n+\t\t\t\t      NULL, true))\n \t\t  break;\n \t\telse\n \t\t  other_bb = NULL;\n@@ -4472,7 +4518,7 @@ maybe_optimize_range_tests (gimple *stmt)\n \tbreak;\n       if (!single_pred_p (e->dest))\n \tbreak;\n-      if (!suitable_cond_bb (e->dest, last_bb, &other_bb, false))\n+      if (!suitable_cond_bb (e->dest, last_bb, &other_bb, NULL, false))\n \tbreak;\n       if (!no_side_effect_bb (e->dest))\n \tbreak;\n@@ -4583,6 +4629,28 @@ maybe_optimize_range_tests (gimple *stmt)\n \t  bbinfo.safe_push (bb_ent);\n \t  continue;\n \t}\n+      else if (bb == last_bb)\n+\t{\n+\t  /* For last_bb, handle also:\n+\t     if (x_3(D) == 3)\n+\t       goto <bb 6>; [34.00%]\n+\t     else\n+\t       goto <bb 7>; [66.00%]\n+\n+\t     <bb 6> [local count: 79512730]:\n+\n+\t     <bb 7> [local count: 1073741824]:\n+\t     # prephitmp_7 = PHI <1(3), 1(4), 0(5), 1(2), 1(6)>\n+\t     where bb 7 is OTHER_BB, but the PHI values from the\n+\t     earlier bbs match the path through the empty bb\n+\t     in between.  */\n+\t  bool test_swapped_p = false;\n+\t  bool ok = suitable_cond_bb (single_pred (last_bb), last_bb,\n+\t\t\t\t      &other_bb, &test_swapped_p, true);\n+\t  gcc_assert (ok);\n+\t  if (test_swapped_p)\n+\t    e = EDGE_SUCC (bb, e == EDGE_SUCC (bb, 0) ? 1 : 0);\n+\t}\n       /* Otherwise stmt is GIMPLE_COND.  */\n       code = gimple_cond_code (stmt);\n       lhs = gimple_cond_lhs (stmt);"}]}