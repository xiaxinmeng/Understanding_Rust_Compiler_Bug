{"sha": "9e21be9dfc4f91607f13dcda03d6f2c977ce3d0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUyMWJlOWRmYzRmOTE2MDdmMTNkY2RhMDNkNmYyYzk3N2NlM2QwYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-17T22:42:49Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-17T22:42:49Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r768", "tree": {"sha": "2516da4b887ca63cd8692699a957cce24e25878e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2516da4b887ca63cd8692699a957cce24e25878e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e21be9dfc4f91607f13dcda03d6f2c977ce3d0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e21be9dfc4f91607f13dcda03d6f2c977ce3d0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e21be9dfc4f91607f13dcda03d6f2c977ce3d0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e21be9dfc4f91607f13dcda03d6f2c977ce3d0a/comments", "author": null, "committer": null, "parents": [{"sha": "c8470713623c22b28edb6249520cdf78df504433", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8470713623c22b28edb6249520cdf78df504433", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8470713623c22b28edb6249520cdf78df504433"}], "stats": {"total": 61, "additions": 53, "deletions": 8}, "files": [{"sha": "b986811693a0ffc1688734fbee3a46ea001f072a", "filename": "gcc/recog.c", "status": "modified", "additions": 53, "deletions": 8, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e21be9dfc4f91607f13dcda03d6f2c977ce3d0a/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e21be9dfc4f91607f13dcda03d6f2c977ce3d0a/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=9e21be9dfc4f91607f13dcda03d6f2c977ce3d0a", "patch": "@@ -1599,6 +1599,9 @@ constrain_operands (insn_code_num, strict)\n      int strict;\n {\n   char *constraints[MAX_RECOG_OPERANDS];\n+  int matching_operands[MAX_RECOG_OPERANDS];\n+  enum op_type {OP_IN, OP_OUT, OP_INOUT} op_types[MAX_RECOG_OPERANDS];\n+  int earlyclobber[MAX_RECOG_OPERANDS];\n   register int c;\n   int noperands = insn_n_operands[insn_code_num];\n \n@@ -1610,7 +1613,11 @@ constrain_operands (insn_code_num, strict)\n     return 1;\n \n   for (c = 0; c < noperands; c++)\n-    constraints[c] = insn_operand_constraint[insn_code_num][c];\n+    {\n+      constraints[c] = insn_operand_constraint[insn_code_num][c];\n+      matching_operands[c] = -1;\n+      op_types[c] = OP_IN;\n+    }\n \n   which_alternative = 0;\n \n@@ -1629,6 +1636,8 @@ constrain_operands (insn_code_num, strict)\n \t  int win = 0;\n \t  int val;\n \n+\t  earlyclobber[opno] = 0;\n+\n \t  if (GET_CODE (op) == SUBREG)\n \t    {\n \t      if (GET_CODE (SUBREG_REG (op)) == REG\n@@ -1645,16 +1654,25 @@ constrain_operands (insn_code_num, strict)\n \t  while (*p && (c = *p++) != ',')\n \t    switch (c)\n \t      {\n-\t      case '=':\n-\t      case '+':\n \t      case '?':\n \t      case '#':\n-\t      case '&':\n \t      case '!':\n \t      case '*':\n \t      case '%':\n \t\tbreak;\n \n+\t      case '=':\n+\t\top_types[opno] = OP_OUT;\n+\t\tbreak;\n+\n+\t      case '+':\n+\t\top_types[opno] = OP_INOUT;\n+\t\tbreak;\n+\n+\t      case '&':\n+\t\tearlyclobber[opno] = 1;\n+\t\tbreak;\n+\n \t      case '0':\n \t      case '1':\n \t      case '2':\n@@ -1674,6 +1692,9 @@ constrain_operands (insn_code_num, strict)\n \t\t  val = operands_match_p (recog_operand[c - '0'],\n \t\t\t\t\t  recog_operand[opno]);\n \n+\t\tmatching_operands[opno] = c - '0';\n+\t\tmatching_operands[c - '0'] = opno;\n+\n \t\tif (val != 0)\n \t\t  win = 1;\n \t\t/* If output is *x and input is *--x,\n@@ -1850,12 +1871,36 @@ constrain_operands (insn_code_num, strict)\n \t Change whichever operands this alternative says to change.  */\n       if (! lose)\n \t{\n-\t  while (--funny_match_index >= 0)\n+\t  int opno, eopno;\n+\n+\t  /* See if any earlyclobber operand conflicts with some other\n+\t     operand.  */\n+\n+\t  if (strict > 0)\n+\t    for (eopno = 0; eopno < noperands; eopno++)\n+\t      if (earlyclobber[eopno])\n+\t\tfor (opno = 0; opno < noperands; opno++)\n+\t\t  if ((GET_CODE (recog_operand[opno]) == MEM\n+\t\t       || op_types[opno] != OP_OUT)\n+\t\t      && opno != eopno\n+\t\t      && constraints[opno] != 0\n+\t\t      && ! (matching_operands[opno] == eopno\n+\t\t\t    && rtx_equal_p (recog_operand[opno],\n+\t\t\t\t\t    recog_operand[eopno]))\n+\t\t      && ! safe_from_earlyclobber (recog_operand[opno],\n+\t\t\t\t\t\t   recog_operand[eopno]))\n+\t\t    lose = 1;\n+\n+\t  if (! lose)\n \t    {\n-\t      recog_operand[funny_match[funny_match_index].other]\n-\t\t= recog_operand[funny_match[funny_match_index].this];\n+\t      while (--funny_match_index >= 0)\n+\t\t{\n+\t\t  recog_operand[funny_match[funny_match_index].other]\n+\t\t    = recog_operand[funny_match[funny_match_index].this];\n+\t\t}\n+\n+\t      return 1;\n \t    }\n-\t  return 1;\n \t}\n \n       which_alternative++;"}]}