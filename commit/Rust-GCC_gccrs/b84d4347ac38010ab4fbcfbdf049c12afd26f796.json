{"sha": "b84d4347ac38010ab4fbcfbdf049c12afd26f796", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg0ZDQzNDdhYzM4MDEwYWI0ZmJjZmJkZjA0OWMxMmFmZDI2Zjc5Ng==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-10-16T10:47:55Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-10-16T10:47:55Z"}, "message": "IPA ICF pass, part 3/5\n\n\t* Makefile.in: New object files included.\n\t* cgraph.c (cgraph_node::dump): New cgraph_node flag icf_merged\n\tis printed.\n\t(verify_edge_corresponds_to_fndecl): More sensitive verification\n\tof nodes that are merged by IPA ICF.\n\t* cgraph.h (cgraph_node::num_references): New function.\n\t* cgraphunit.c (cgraph_node::expand_thunk): White space fixed.\n\t* common.opt: New options ipa-icf, ipa-icf-functions and\n\tipa-icf-variables introduced.\n\t* doc/invoke.texi: Documentation of new options introduced.\n\t* ipa-icf-gimple.c: New file.\n\t* ipa-icf-gimple.h: New file.\n\t* ipa-icf.c: New file.\n\t* ipa-icf.h: New file.\n\t* lto-cgraph.c (lto_output_node): Streaming of icf_merged flag added.\n\t(input_overwrite_node): Likewise.\n\t* lto-section-in.c: New icf section added.\n\t* lto-streamer.h (enum lto_section_type): Likewise.\n\t* opts.c (common_handle_option): New option added.\n\t* passes.def: New pass included.\n\t* timevar.def: Time variable for IPA ICF added.\n\t* tree-pass.h: New IPA ICF pass entry point added.\n\n\nCo-Authored-By: Jan Hubicka <hubicka@ucw.cz>\n\nFrom-SVN: r216305", "tree": {"sha": "a924d04dfecfeecfc3dbb2cd245d5482ed23f090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a924d04dfecfeecfc3dbb2cd245d5482ed23f090"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b84d4347ac38010ab4fbcfbdf049c12afd26f796", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b84d4347ac38010ab4fbcfbdf049c12afd26f796", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b84d4347ac38010ab4fbcfbdf049c12afd26f796", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b84d4347ac38010ab4fbcfbdf049c12afd26f796/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "93a95abe925edc98131056a6b716e7a9e15f72cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93a95abe925edc98131056a6b716e7a9e15f72cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93a95abe925edc98131056a6b716e7a9e15f72cc"}], "stats": {"total": 4169, "additions": 4166, "deletions": 3}, "files": [{"sha": "ed426f56d27757867957857444eef7ec83c95812", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -1,3 +1,29 @@\n+2014-10-16  Martin Liska  <mliska@suse.cz>\n+\t    Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* Makefile.in: New object files included.\n+\t* cgraph.c (cgraph_node::dump): New cgraph_node flag icf_merged\n+\tis printed.\n+\t(verify_edge_corresponds_to_fndecl): More sensitive verification\n+\tof nodes that are merged by IPA ICF.\n+\t* cgraph.h (cgraph_node::num_references): New function.\n+\t* cgraphunit.c (cgraph_node::expand_thunk): White space fixed.\n+\t* common.opt: New options ipa-icf, ipa-icf-functions and\n+\tipa-icf-variables introduced.\n+\t* doc/invoke.texi: Documentation of new options introduced.\n+\t* ipa-icf-gimple.c: New file.\n+\t* ipa-icf-gimple.h: New file.\n+\t* ipa-icf.c: New file.\n+\t* ipa-icf.h: New file.\n+\t* lto-cgraph.c (lto_output_node): Streaming of icf_merged flag added.\n+\t(input_overwrite_node): Likewise.\n+\t* lto-section-in.c: New icf section added.\n+\t* lto-streamer.h (enum lto_section_type): Likewise.\n+\t* opts.c (common_handle_option): New option added.\n+\t* passes.def: New pass included.\n+\t* timevar.def: Time variable for IPA ICF added.\n+\t* tree-pass.h: New IPA ICF pass entry point added.\n+\n 2014-10-16  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/63168"}, {"sha": "de2adc761e4634db50e269a09369fc173c3a0100", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -1269,6 +1269,8 @@ OBJS = \\\n \tipa-profile.o \\\n \tipa-prop.o \\\n \tipa-pure-const.o \\\n+\tipa-icf.o \\\n+\tipa-icf-gimple.o \\\n \tipa-reference.o \\\n \tipa-ref.o \\\n \tipa-utils.o \\"}, {"sha": "f472ec531592cbd7de1063de227204612ea13f14", "filename": "gcc/cgraph.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -1910,6 +1910,8 @@ cgraph_node::dump (FILE *f)\n     fprintf (f, \" only_called_at_exit\");\n   if (tm_clone)\n     fprintf (f, \" tm_clone\");\n+  if (icf_merged)\n+    fprintf (f, \" icf_merged\");\n   if (DECL_STATIC_CONSTRUCTOR (decl))\n     fprintf (f,\" static_constructor (priority:%i)\", get_init_priority ());\n   if (DECL_STATIC_DESTRUCTOR (decl))\n@@ -2560,6 +2562,7 @@ verify_edge_corresponds_to_fndecl (cgraph_edge *e, tree decl)\n   if (!node\n       || node->body_removed\n       || node->in_other_partition\n+      || node->icf_merged\n       || e->callee->in_other_partition)\n     return false;\n "}, {"sha": "69b5d0a8481a7ae8e55b6e34919592ca4d876b15", "filename": "gcc/cgraph.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -180,6 +180,12 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Dump referring in list to FILE.  */\n   void dump_referring (FILE *);\n \n+  /* Get number of references for this node.  */\n+  inline unsigned num_references (void)\n+  {\n+    return ref_list.references ? ref_list.references->length () : 0;\n+  }\n+\n   /* Iterates I-th reference in the list, REF is also set.  */\n   ipa_ref *iterate_reference (unsigned i, ipa_ref *&ref);\n \n@@ -1249,6 +1255,8 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   /* True if this decl calls a COMDAT-local function.  This is set up in\n      compute_inline_parameters and inline_call.  */\n   unsigned calls_comdat_local : 1;\n+  /* True if node has been created by merge operation in IPA-ICF.  */\n+  unsigned icf_merged: 1;\n };\n \n /* A cgraph node set is a collection of cgraph nodes.  A cgraph node"}, {"sha": "321674a08e8255d6086fa5152e48501654b1e2b3", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -1501,7 +1501,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n       if (in_lto_p)\n \tget_body ();\n       a = DECL_ARGUMENTS (thunk_fndecl);\n-      \n+\n       current_function_decl = thunk_fndecl;\n \n       /* Ensure thunks are emitted in their correct sections.  */"}, {"sha": "5db5e1ee6ada823e8d61df066b84a1e257f2a7cd", "filename": "gcc/common.opt", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -1443,6 +1443,18 @@ fipa-pure-const\n Common Report Var(flag_ipa_pure_const) Init(0) Optimization\n Discover pure and const functions\n \n+fipa-icf\n+Common Report Var(flag_ipa_icf) Optimization\n+Perform Identical Code Folding for functions and read-only variables\n+\n+fipa-icf-functions\n+Common Report Var(flag_ipa_icf_functions) Optimization\n+Perform Identical Code Folding for functions\n+\n+fipa-icf-variables\n+Common Report Var(flag_ipa_icf_variables) Optimization\n+Perform Identical Code Folding for variables\n+\n fipa-reference\n Common Report Var(flag_ipa_reference) Init(0) Optimization\n Discover readonly and non addressable static variables"}, {"sha": "6bc09d6c812f8054d8f406ef4d58e3e9eecfb487", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -382,7 +382,7 @@ Objective-C and Objective-C++ Dialects}.\n -fif-conversion2 -findirect-inlining @gol\n -finline-functions -finline-functions-called-once -finline-limit=@var{n} @gol\n -finline-small-functions -fipa-cp -fipa-cp-clone @gol\n--fipa-pta -fipa-profile -fipa-pure-const -fipa-reference @gol\n+-fipa-pta -fipa-profile -fipa-pure-const -fipa-reference -fipa-icf @gol\n -fira-algorithm=@var{algorithm} @gol\n -fira-region=@var{region} -fira-hoist-pressure @gol\n -fira-loop-pressure -fno-ira-share-save-slots @gol\n@@ -7142,6 +7142,7 @@ also turns on the following optimization flags:\n -findirect-inlining @gol\n -fipa-cp @gol\n -fipa-sra @gol\n+-fipa-icf @gol\n -fisolate-erroneous-paths-dereference @gol\n -foptimize-sibling-calls @gol\n -foptimize-strlen @gol\n@@ -8087,6 +8088,19 @@ it may significantly increase code size\n (see @option{--param ipcp-unit-growth=@var{value}}).\n This flag is enabled by default at @option{-O3}.\n \n+@item -fipa-icf\n+@opindex fipa-icf\n+Perform Identical Code Folding for functions and read-only variables.\n+The optimization reduces code size and may disturb unwind stacks by replacing\n+a function by equivalent one with a different name. The optimization works\n+more effectively with link time optimization enabled.\n+\n+Nevertheless the behavior is similar to Gold Linker ICF optimization, GCC ICF\n+works on different levels and thus the optimizations are not same - there are\n+equivalences that are found only by GCC and equivalences found only by Gold.\n+\n+This flag is enabled by default at @option{-O2} and @option{-Os}.\n+\n @item -fisolate-erroneous-paths-dereference\n Detect paths which trigger erroneous or undefined behaviour due to\n dereferencing a NULL pointer.  Isolate those paths from the main control"}, {"sha": "792a3e402bf010faa128c94a11a235d88e59187b", "filename": "gcc/ipa-icf-gimple.c", "status": "added", "additions": 897, "deletions": 0, "changes": 897, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -0,0 +1,897 @@\n+/* Interprocedural Identical Code Folding pass\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   Contributed by Jan Hubicka <hubicka@ucw.cz> and Martin Liska <mliska@suse.cz>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"expr.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-ssa.h\"\n+#include \"tree-cfg.h\"\n+#include \"stringpool.h\"\n+#include \"tree-dfa.h\"\n+#include \"tree-pass.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"cfgloop.h\"\n+#include \"except.h\"\n+#include \"data-streamer.h\"\n+#include \"ipa-utils.h\"\n+#include <list>\n+#include \"tree-ssanames.h\"\n+#include \"tree-eh.h\"\n+\n+#include \"ipa-icf-gimple.h\"\n+#include \"ipa-icf.h\"\n+\n+namespace ipa_icf_gimple {\n+\n+/* Initialize internal structures for a given SOURCE_FUNC_DECL and\n+   TARGET_FUNC_DECL. Strict polymorphic comparison is processed if\n+   an option COMPARE_POLYMORPHIC is true. For special cases, one can\n+   set IGNORE_LABELS to skip label comparison.\n+   Similarly, IGNORE_SOURCE_DECLS and IGNORE_TARGET_DECLS are sets\n+   of declarations that can be skipped.  */\n+\n+func_checker::func_checker (tree source_func_decl, tree target_func_decl,\n+\t\t\t    bool compare_polymorphic,\n+\t\t\t    bool ignore_labels,\n+\t\t\t    hash_set<symtab_node *> *ignored_source_nodes,\n+\t\t\t    hash_set<symtab_node *> *ignored_target_nodes)\n+  : m_source_func_decl (source_func_decl), m_target_func_decl (target_func_decl),\n+    m_ignored_source_nodes (ignored_source_nodes),\n+    m_ignored_target_nodes (ignored_target_nodes),\n+    m_compare_polymorphic (compare_polymorphic),\n+    m_ignore_labels (ignore_labels)\n+{\n+  function *source_func = DECL_STRUCT_FUNCTION (source_func_decl);\n+  function *target_func = DECL_STRUCT_FUNCTION (target_func_decl);\n+\n+  unsigned ssa_source = SSANAMES (source_func)->length ();\n+  unsigned ssa_target = SSANAMES (target_func)->length ();\n+\n+  m_source_ssa_names.create (ssa_source);\n+  m_target_ssa_names.create (ssa_target);\n+\n+  for (unsigned i = 0; i < ssa_source; i++)\n+    m_source_ssa_names.safe_push (-1);\n+\n+  for (unsigned i = 0; i < ssa_target; i++)\n+    m_target_ssa_names.safe_push (-1);\n+}\n+\n+/* Memory release routine.  */\n+\n+func_checker::~func_checker ()\n+{\n+  m_source_ssa_names.release();\n+  m_target_ssa_names.release();\n+}\n+\n+/* Verifies that trees T1 and T2 are equivalent from perspective of ICF.  */\n+\n+bool\n+func_checker::compare_ssa_name (tree t1, tree t2)\n+{\n+  unsigned i1 = SSA_NAME_VERSION (t1);\n+  unsigned i2 = SSA_NAME_VERSION (t2);\n+\n+  if (m_source_ssa_names[i1] == -1)\n+    m_source_ssa_names[i1] = i2;\n+  else if (m_source_ssa_names[i1] != (int) i2)\n+    return false;\n+\n+  if(m_target_ssa_names[i2] == -1)\n+    m_target_ssa_names[i2] = i1;\n+  else if (m_target_ssa_names[i2] != (int) i1)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Verification function for edges E1 and E2.  */\n+\n+bool\n+func_checker::compare_edge (edge e1, edge e2)\n+{\n+  if (e1->flags != e2->flags)\n+    return false;\n+\n+  bool existed_p;\n+\n+  edge &slot = m_edge_map.get_or_insert (e1, &existed_p);\n+  if (existed_p)\n+    return return_with_debug (slot == e2);\n+  else\n+    slot = e2;\n+\n+  /* TODO: filter edge probabilities for profile feedback match.  */\n+\n+  return true;\n+}\n+\n+/* Verification function for declaration trees T1 and T2 that\n+   come from functions FUNC1 and FUNC2.  */\n+\n+bool\n+func_checker::compare_decl (tree t1, tree t2)\n+{\n+  if (!auto_var_in_fn_p (t1, m_source_func_decl)\n+      || !auto_var_in_fn_p (t2, m_target_func_decl))\n+    return return_with_debug (t1 == t2);\n+\n+  tree_code t = TREE_CODE (t1);\n+  if ((t == VAR_DECL || t == PARM_DECL || t == RESULT_DECL)\n+      && DECL_BY_REFERENCE (t1) != DECL_BY_REFERENCE (t2))\n+    return return_false_with_msg (\"DECL_BY_REFERENCE flags are different\");\n+\n+  if (!compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t   m_compare_polymorphic))\n+    return return_false ();\n+\n+  bool existed_p;\n+\n+  tree &slot = m_decl_map.get_or_insert (t1, &existed_p);\n+  if (existed_p)\n+    return return_with_debug (slot == t2);\n+  else\n+    slot = t2;\n+\n+  return true;\n+}\n+\n+/* Return true if types are compatible from perspective of ICF.  */\n+bool func_checker::compatible_types_p (tree t1, tree t2,\n+\t\t\t\t       bool compare_polymorphic,\n+\t\t\t\t       bool first_argument)\n+{\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return return_false_with_msg (\"different tree types\");\n+\n+  if (!types_compatible_p (t1, t2))\n+    return return_false_with_msg (\"types are not compatible\");\n+\n+  if (get_alias_set (t1) != get_alias_set (t2))\n+    return return_false_with_msg (\"alias sets are different\");\n+\n+  /* We call contains_polymorphic_type_p with this pointer type.  */\n+  if (first_argument && TREE_CODE (t1) == POINTER_TYPE)\n+    {\n+      t1 = TREE_TYPE (t1);\n+      t2 = TREE_TYPE (t2);\n+    }\n+\n+  if (compare_polymorphic)\n+    if (contains_polymorphic_type_p (t1) || contains_polymorphic_type_p (t2))\n+      {\n+\tif (!contains_polymorphic_type_p (t1) || !contains_polymorphic_type_p (t2))\n+\t  return return_false_with_msg (\"one type is not polymorphic\");\n+\n+\tif (!types_must_be_same_for_odr (t1, t2))\n+\t  return return_false_with_msg (\"types are not same for ODR\");\n+      }\n+\n+  return true;\n+}\n+\n+/* Function responsible for comparison of handled components T1 and T2.\n+   If these components, from functions FUNC1 and FUNC2, are equal, true\n+   is returned.  */\n+\n+bool\n+func_checker::compare_operand (tree t1, tree t2)\n+{\n+  tree base1, base2, x1, x2, y1, y2, z1, z2;\n+  HOST_WIDE_INT offset1 = 0, offset2 = 0;\n+  bool ret;\n+\n+  if (!t1 && !t2)\n+    return true;\n+  else if (!t1 || !t2)\n+    return false;\n+\n+  tree tt1 = TREE_TYPE (t1);\n+  tree tt2 = TREE_TYPE (t2);\n+\n+  if (!func_checker::compatible_types_p (tt1, tt2))\n+    return false;\n+\n+  base1 = get_addr_base_and_unit_offset (t1, &offset1);\n+  base2 = get_addr_base_and_unit_offset (t2, &offset2);\n+\n+  if (base1 && base2)\n+    {\n+      if (offset1 != offset2)\n+\treturn return_false_with_msg (\"base offsets are different\");\n+\n+      t1 = base1;\n+      t2 = base2;\n+    }\n+\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return return_false ();\n+\n+  switch (TREE_CODE (t1))\n+    {\n+    case CONSTRUCTOR:\n+      {\n+\tunsigned length1 = vec_safe_length (CONSTRUCTOR_ELTS (t1));\n+\tunsigned length2 = vec_safe_length (CONSTRUCTOR_ELTS (t2));\n+\n+\tif (length1 != length2)\n+\t  return return_false ();\n+\n+\tfor (unsigned i = 0; i < length1; i++)\n+\t  if (!compare_operand (CONSTRUCTOR_ELT (t1, i)->value,\n+\t\t\t\tCONSTRUCTOR_ELT (t2, i)->value))\n+\t    return return_false();\n+\n+\treturn true;\n+      }\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      x1 = TREE_OPERAND (t1, 0);\n+      x2 = TREE_OPERAND (t2, 0);\n+      y1 = TREE_OPERAND (t1, 1);\n+      y2 = TREE_OPERAND (t2, 1);\n+\n+      if (!compare_operand (array_ref_low_bound (t1),\n+\t\t\t    array_ref_low_bound (t2)))\n+\treturn return_false_with_msg (\"\");\n+      if (!compare_operand (array_ref_element_size (t1),\n+\t\t\t    array_ref_element_size (t2)))\n+\treturn return_false_with_msg (\"\");\n+      if (!compare_operand (x1, x2))\n+\treturn return_false_with_msg (\"\");\n+      return compare_operand (y1, y2);\n+    case MEM_REF:\n+      {\n+\tx1 = TREE_OPERAND (t1, 0);\n+\tx2 = TREE_OPERAND (t2, 0);\n+\ty1 = TREE_OPERAND (t1, 1);\n+\ty2 = TREE_OPERAND (t2, 1);\n+\n+\t/* See if operand is an memory access (the test originate from\n+\t gimple_load_p).\n+\n+\tIn this case the alias set of the function being replaced must\n+\tbe subset of the alias set of the other function.  At the moment\n+\twe seek for equivalency classes, so simply require inclussion in\n+\tboth directions.  */\n+\n+\tif (!func_checker::compatible_types_p (TREE_TYPE (x1), TREE_TYPE (x2)))\n+\t  return return_false ();\n+\n+\tif (!compare_operand (x1, x2))\n+\t  return return_false_with_msg (\"\");\n+\n+\tif (get_alias_set (TREE_TYPE (y1)) != get_alias_set (TREE_TYPE (y2)))\n+\t  return return_false_with_msg (\"alias set for MEM_REF offsets are different\");\n+\n+\tao_ref r1, r2;\n+\tao_ref_init (&r1, t1);\n+\tao_ref_init (&r2, t2);\n+\tif (ao_ref_alias_set (&r1) != ao_ref_alias_set (&r2)\n+\t    || ao_ref_base_alias_set (&r1) != ao_ref_base_alias_set (&r2))\n+\t  return return_false_with_msg (\"ao alias sets are different\");\n+\n+\t/* Type of the offset on MEM_REF does not matter.  */\n+\treturn wi::to_offset  (y1) == wi::to_offset  (y2);\n+      }\n+    case COMPONENT_REF:\n+      {\n+\tx1 = TREE_OPERAND (t1, 0);\n+\tx2 = TREE_OPERAND (t2, 0);\n+\ty1 = TREE_OPERAND (t1, 1);\n+\ty2 = TREE_OPERAND (t2, 1);\n+\n+\tret = compare_operand (x1, x2)\n+\t      && compare_operand (y1, y2);\n+\n+\treturn return_with_debug (ret);\n+      }\n+    /* Virtual table call.  */\n+    case OBJ_TYPE_REF:\n+      {\n+\tx1 = TREE_OPERAND (t1, 0);\n+\tx2 = TREE_OPERAND (t2, 0);\n+\ty1 = TREE_OPERAND (t1, 1);\n+\ty2 = TREE_OPERAND (t2, 1);\n+\tz1 = TREE_OPERAND (t1, 2);\n+\tz2 = TREE_OPERAND (t2, 2);\n+\n+\tret = compare_operand (x1, x2)\n+\t      && compare_operand (y1, y2)\n+\t      && compare_operand (z1, z2);\n+\n+\treturn return_with_debug (ret);\n+      }\n+    case ADDR_EXPR:\n+      {\n+\tx1 = TREE_OPERAND (t1, 0);\n+\tx2 = TREE_OPERAND (t2, 0);\n+\n+\tret = compare_operand (x1, x2);\n+\treturn return_with_debug (ret);\n+      }\n+    case SSA_NAME:\n+      {\n+\tret = compare_ssa_name (t1, t2);\n+\n+\tif (!ret)\n+\t  return return_with_debug (ret);\n+\n+\tif (SSA_NAME_IS_DEFAULT_DEF (t1))\n+\t  {\n+\t    tree b1 = SSA_NAME_VAR (t1);\n+\t    tree b2 = SSA_NAME_VAR (t2);\n+\n+\t    if (b1 == NULL && b2 == NULL)\n+\t      return true;\n+\n+\t    if (b1 == NULL || b2 == NULL || TREE_CODE (b1) != TREE_CODE (b2))\n+\t      return return_false ();\n+\n+\t    switch (TREE_CODE (b1))\n+\t      {\n+\t      case VAR_DECL:\n+\t\treturn return_with_debug (compare_variable_decl (t1, t2));\n+\t      case PARM_DECL:\n+\t      case RESULT_DECL:\n+\t\tret = compare_decl (b1, b2);\n+\t\treturn return_with_debug (ret);\n+\t      default:\n+\t\treturn return_false_with_msg (\"Unknown TREE code reached\");\n+\t      }\n+\t  }\n+\telse\n+\t  return true;\n+      }\n+    case INTEGER_CST:\n+      {\n+\tret = compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t      && wi::to_offset  (t1) == wi::to_offset  (t2);\n+\n+\treturn return_with_debug (ret);\n+      }\n+    case COMPLEX_CST:\n+    case VECTOR_CST:\n+    case STRING_CST:\n+    case REAL_CST:\n+      {\n+\tret = operand_equal_p (t1, t2, OEP_ONLY_CONST);\n+\treturn return_with_debug (ret);\n+      }\n+    case FUNCTION_DECL:\n+      {\n+\tret = compare_function_decl (t1, t2);\n+\treturn return_with_debug (ret);\n+      }\n+    case VAR_DECL:\n+      return return_with_debug (compare_variable_decl (t1, t2));\n+    case FIELD_DECL:\n+      {\n+\ttree offset1 = DECL_FIELD_OFFSET (t1);\n+\ttree offset2 = DECL_FIELD_OFFSET (t2);\n+\n+\ttree bit_offset1 = DECL_FIELD_BIT_OFFSET (t1);\n+\ttree bit_offset2 = DECL_FIELD_BIT_OFFSET (t2);\n+\n+\tret = compare_operand (offset1, offset2)\n+\t      && compare_operand (bit_offset1, bit_offset2);\n+\n+\treturn return_with_debug (ret);\n+      }\n+    case LABEL_DECL:\n+      {\n+\tint *bb1 = m_label_bb_map.get (t1);\n+\tint *bb2 = m_label_bb_map.get (t2);\n+\n+\treturn return_with_debug (*bb1 == *bb2);\n+      }\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case CONST_DECL:\n+    case BIT_FIELD_REF:\n+      {\n+\tret = compare_decl (t1, t2);\n+\treturn return_with_debug (ret);\n+      }\n+    default:\n+      return return_false_with_msg (\"Unknown TREE code reached\");\n+    }\n+}\n+\n+/* Compares two tree list operands T1 and T2 and returns true if these\n+   two trees are semantically equivalent.  */\n+\n+bool\n+func_checker::compare_tree_list_operand (tree t1, tree t2)\n+{\n+  gcc_assert (TREE_CODE (t1) == TREE_LIST);\n+  gcc_assert (TREE_CODE (t2) == TREE_LIST);\n+\n+  for (; t1; t1 = TREE_CHAIN (t1))\n+    {\n+      if (!t2)\n+\treturn false;\n+\n+      if (!compare_operand (TREE_VALUE (t1), TREE_VALUE (t2)))\n+\treturn return_false ();\n+\n+      t2 = TREE_CHAIN (t2);\n+    }\n+\n+  if (t2)\n+    return return_false ();\n+\n+  return true;\n+}\n+\n+/* Verifies that trees T1 and T2, representing function declarations\n+   are equivalent from perspective of ICF.  */\n+\n+bool\n+func_checker::compare_function_decl (tree t1, tree t2)\n+{\n+  bool ret = false;\n+\n+  if (t1 == t2)\n+    return true;\n+\n+  symtab_node *n1 = symtab_node::get (t1);\n+  symtab_node *n2 = symtab_node::get (t2);\n+\n+  if (m_ignored_source_nodes != NULL && m_ignored_target_nodes != NULL)\n+    {\n+      ret = m_ignored_source_nodes->contains (n1)\n+\t    && m_ignored_target_nodes->contains (n2);\n+\n+      if (ret)\n+\treturn true;\n+    }\n+\n+  /* If function decl is WEAKREF, we compare targets.  */\n+  cgraph_node *f1 = cgraph_node::get (t1);\n+  cgraph_node *f2 = cgraph_node::get (t2);\n+\n+  if(f1 && f2 && f1->weakref && f2->weakref)\n+    ret = f1->alias_target == f2->alias_target;\n+\n+  return ret;\n+}\n+\n+/* Verifies that trees T1 and T2 do correspond.  */\n+\n+bool\n+func_checker::compare_variable_decl (tree t1, tree t2)\n+{\n+  bool ret = false;\n+\n+  if (t1 == t2)\n+    return true;\n+\n+  if (TREE_CODE (t1) == VAR_DECL && (DECL_EXTERNAL (t1) || TREE_STATIC (t1)))\n+    {\n+      symtab_node *n1 = symtab_node::get (t1);\n+      symtab_node *n2 = symtab_node::get (t2);\n+\n+      if (m_ignored_source_nodes != NULL && m_ignored_target_nodes != NULL)\n+\t{\n+\t  ret = m_ignored_source_nodes->contains (n1)\n+\t\t&& m_ignored_target_nodes->contains (n2);\n+\n+\t  if (ret)\n+\t    return true;\n+\t}\n+    }\n+  ret = compare_decl (t1, t2);\n+\n+  return return_with_debug (ret);\n+}\n+\n+void\n+func_checker::parse_labels (sem_bb *bb)\n+{\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb->bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+\n+      if (gimple_code (stmt) == GIMPLE_LABEL)\n+\t{\n+\t  tree t = gimple_label_label (stmt);\n+\t  gcc_assert (TREE_CODE (t) == LABEL_DECL);\n+\n+\t  m_label_bb_map.put (t, bb->bb->index);\n+\t}\n+    }\n+}\n+\n+/* Basic block equivalence comparison function that returns true if\n+   basic blocks BB1 and BB2 (from functions FUNC1 and FUNC2) correspond.\n+\n+   In general, a collection of equivalence dictionaries is built for types\n+   like SSA names, declarations (VAR_DECL, PARM_DECL, ..). This infrastructure\n+   is utilized by every statement-by-stament comparison function.  */\n+\n+bool\n+func_checker::compare_bb (sem_bb *bb1, sem_bb *bb2)\n+{\n+  unsigned i;\n+  gimple_stmt_iterator gsi1, gsi2;\n+  gimple s1, s2;\n+\n+  if (bb1->nondbg_stmt_count != bb2->nondbg_stmt_count\n+      || bb1->edge_count != bb2->edge_count)\n+    return return_false ();\n+\n+  gsi1 = gsi_start_bb (bb1->bb);\n+  gsi2 = gsi_start_bb (bb2->bb);\n+\n+  for (i = 0; i < bb1->nondbg_stmt_count; i++)\n+    {\n+      if (is_gimple_debug (gsi_stmt (gsi1)))\n+\tgsi_next_nondebug (&gsi1);\n+\n+      if (is_gimple_debug (gsi_stmt (gsi2)))\n+\tgsi_next_nondebug (&gsi2);\n+\n+      s1 = gsi_stmt (gsi1);\n+      s2 = gsi_stmt (gsi2);\n+\n+      int eh1 = lookup_stmt_eh_lp_fn\n+\t\t(DECL_STRUCT_FUNCTION (m_source_func_decl), s1);\n+      int eh2 = lookup_stmt_eh_lp_fn\n+\t\t(DECL_STRUCT_FUNCTION (m_target_func_decl), s2);\n+\n+      if (eh1 != eh2)\n+\treturn return_false_with_msg (\"EH regions are different\");\n+\n+      if (gimple_code (s1) != gimple_code (s2))\n+\treturn return_false_with_msg (\"gimple codes are different\");\n+\n+      switch (gimple_code (s1))\n+\t{\n+\tcase GIMPLE_CALL:\n+\t  if (!compare_gimple_call (s1, s2))\n+\t    return return_different_stmts (s1, s2, \"GIMPLE_CALL\");\n+\t  break;\n+\tcase GIMPLE_ASSIGN:\n+\t  if (!compare_gimple_assign (s1, s2))\n+\t    return return_different_stmts (s1, s2, \"GIMPLE_ASSIGN\");\n+\t  break;\n+\tcase GIMPLE_COND:\n+\t  if (!compare_gimple_cond (s1, s2))\n+\t    return return_different_stmts (s1, s2, \"GIMPLE_COND\");\n+\t  break;\n+\tcase GIMPLE_SWITCH:\n+\t  if (!compare_gimple_switch (s1, s2))\n+\t    return return_different_stmts (s1, s2, \"GIMPLE_SWITCH\");\n+\t  break;\n+\tcase GIMPLE_DEBUG:\n+\tcase GIMPLE_EH_DISPATCH:\n+\t  break;\n+\tcase GIMPLE_RESX:\n+\t  if (!compare_gimple_resx (s1, s2))\n+\t    return return_different_stmts (s1, s2, \"GIMPLE_RESX\");\n+\t  break;\n+\tcase GIMPLE_LABEL:\n+\t  if (!compare_gimple_label (s1, s2))\n+\t    return return_different_stmts (s1, s2, \"GIMPLE_LABEL\");\n+\t  break;\n+\tcase GIMPLE_RETURN:\n+\t  if (!compare_gimple_return (s1, s2))\n+\t    return return_different_stmts (s1, s2, \"GIMPLE_RETURN\");\n+\t  break;\n+\tcase GIMPLE_GOTO:\n+\t  if (!compare_gimple_goto (s1, s2))\n+\t    return return_different_stmts (s1, s2, \"GIMPLE_GOTO\");\n+\t  break;\n+\tcase GIMPLE_ASM:\n+\t  if (!compare_gimple_asm (s1, s2))\n+\t    return return_different_stmts (s1, s2, \"GIMPLE_ASM\");\n+\t  break;\n+\tcase GIMPLE_PREDICT:\n+\tcase GIMPLE_NOP:\n+\t  return true;\n+\tdefault:\n+\t  return return_false_with_msg (\"Unknown GIMPLE code reached\");\n+\t}\n+\n+      gsi_next (&gsi1);\n+      gsi_next (&gsi2);\n+    }\n+\n+  return true;\n+}\n+\n+/* Verifies for given GIMPLEs S1 and S2 that\n+   call statements are semantically equivalent.  */\n+\n+bool\n+func_checker::compare_gimple_call (gimple s1, gimple s2)\n+{\n+  unsigned i;\n+  tree t1, t2;\n+\n+  if (gimple_call_num_args (s1) != gimple_call_num_args (s2))\n+    return false;\n+\n+  t1 = gimple_call_fndecl (s1);\n+  t2 = gimple_call_fndecl (s2);\n+\n+  /* Function pointer variables are not supported yet.  */\n+  if (!compare_operand (t1, t2))\n+    return return_false();\n+\n+  /* Checking of argument.  */\n+  for (i = 0; i < gimple_call_num_args (s1); ++i)\n+    {\n+      t1 = gimple_call_arg (s1, i);\n+      t2 = gimple_call_arg (s2, i);\n+\n+      if (!compare_operand (t1, t2))\n+\treturn false;\n+    }\n+\n+  /* Return value checking.  */\n+  t1 = gimple_get_lhs (s1);\n+  t2 = gimple_get_lhs (s2);\n+\n+  return compare_operand (t1, t2);\n+}\n+\n+\n+/* Verifies for given GIMPLEs S1 and S2 that\n+   assignment statements are semantically equivalent.  */\n+\n+bool\n+func_checker::compare_gimple_assign (gimple s1, gimple s2)\n+{\n+  tree arg1, arg2;\n+  tree_code code1, code2;\n+  unsigned i;\n+\n+  code1 = gimple_expr_code (s1);\n+  code2 = gimple_expr_code (s2);\n+\n+  if (code1 != code2)\n+    return false;\n+\n+  code1 = gimple_assign_rhs_code (s1);\n+  code2 = gimple_assign_rhs_code (s2);\n+\n+  if (code1 != code2)\n+    return false;\n+\n+  for (i = 0; i < gimple_num_ops (s1); i++)\n+    {\n+      arg1 = gimple_op (s1, i);\n+      arg2 = gimple_op (s2, i);\n+\n+      if (!compare_operand (arg1, arg2))\n+\treturn false;\n+    }\n+\n+\n+  return true;\n+}\n+\n+/* Verifies for given GIMPLEs S1 and S2 that\n+   condition statements are semantically equivalent.  */\n+\n+bool\n+func_checker::compare_gimple_cond (gimple s1, gimple s2)\n+{\n+  tree t1, t2;\n+  tree_code code1, code2;\n+\n+  code1 = gimple_expr_code (s1);\n+  code2 = gimple_expr_code (s2);\n+\n+  if (code1 != code2)\n+    return false;\n+\n+  t1 = gimple_cond_lhs (s1);\n+  t2 = gimple_cond_lhs (s2);\n+\n+  if (!compare_operand (t1, t2))\n+    return false;\n+\n+  t1 = gimple_cond_rhs (s1);\n+  t2 = gimple_cond_rhs (s2);\n+\n+  return compare_operand (t1, t2);\n+}\n+\n+/* Verifies that tree labels T1 and T2 correspond in FUNC1 and FUNC2.  */\n+\n+bool\n+func_checker::compare_tree_ssa_label (tree t1, tree t2)\n+{\n+  return compare_operand (t1, t2);\n+}\n+\n+/* Verifies for given GIMPLEs S1 and S2 that\n+   label statements are semantically equivalent.  */\n+\n+bool\n+func_checker::compare_gimple_label (gimple g1, gimple g2)\n+{\n+  if (m_ignore_labels)\n+    return true;\n+\n+  tree t1 = gimple_label_label (g1);\n+  tree t2 = gimple_label_label (g2);\n+\n+  if (FORCED_LABEL (t1) || FORCED_LABEL (t2))\n+    return return_false_with_msg (\"FORCED_LABEL\");\n+\n+  return compare_tree_ssa_label (t1, t2);\n+}\n+\n+/* Verifies for given GIMPLEs S1 and S2 that\n+   switch statements are semantically equivalent.  */\n+\n+bool\n+func_checker::compare_gimple_switch (gimple g1, gimple g2)\n+{\n+  unsigned lsize1, lsize2, i;\n+\n+  lsize1 = gimple_switch_num_labels (g1);\n+  lsize2 = gimple_switch_num_labels (g2);\n+\n+  if (lsize1 != lsize2)\n+    return false;\n+\n+  tree t1 = gimple_switch_index (g1);\n+  tree t2 = gimple_switch_index (g2);\n+\n+  if (!compare_operand (t1, t2))\n+    return false;\n+\n+  for (i = 0; i < lsize1; i++)\n+    {\n+      tree label1 = gimple_switch_label (g1, i);\n+      tree label2 = gimple_switch_label (g2, i);\n+\n+      if (TREE_CODE (label1) == CASE_LABEL_EXPR\n+\t  && TREE_CODE (label2) == CASE_LABEL_EXPR)\n+\t{\n+\t  label1 = CASE_LABEL (label1);\n+\t  label2 = CASE_LABEL (label2);\n+\n+\t  if (!compare_operand (label1, label2))\n+\t    return return_false_with_msg (\"switch label_exprs are different\");\n+\t}\n+      else if (!tree_int_cst_equal (label1, label2))\n+\treturn return_false_with_msg (\"switch labels are different\");\n+    }\n+\n+  return true;\n+}\n+\n+/* Verifies for given GIMPLEs S1 and S2 that\n+   return statements are semantically equivalent.  */\n+\n+bool\n+func_checker::compare_gimple_return (gimple g1, gimple g2)\n+{\n+  tree t1, t2;\n+\n+  t1 = gimple_return_retval (g1);\n+  t2 = gimple_return_retval (g2);\n+\n+  /* Void return type.  */\n+  if (t1 == NULL && t2 == NULL)\n+    return true;\n+  else\n+    return compare_operand (t1, t2);\n+}\n+\n+/* Verifies for given GIMPLEs S1 and S2 that\n+   goto statements are semantically equivalent.  */\n+\n+bool\n+func_checker::compare_gimple_goto (gimple g1, gimple g2)\n+{\n+  tree dest1, dest2;\n+\n+  dest1 = gimple_goto_dest (g1);\n+  dest2 = gimple_goto_dest (g2);\n+\n+  if (TREE_CODE (dest1) != TREE_CODE (dest2) || TREE_CODE (dest1) != SSA_NAME)\n+    return false;\n+\n+  return compare_operand (dest1, dest2);\n+}\n+\n+/* Verifies for given GIMPLEs S1 and S2 that\n+   resx statements are semantically equivalent.  */\n+\n+bool\n+func_checker::compare_gimple_resx (gimple g1, gimple g2)\n+{\n+  return gimple_resx_region (g1) == gimple_resx_region (g2);\n+}\n+\n+/* Verifies for given GIMPLEs S1 and S2 that ASM statements are equivalent.\n+   For the beginning, the pass only supports equality for\n+   '__asm__ __volatile__ (\"\", \"\", \"\", \"memory\")'.  */\n+\n+bool\n+func_checker::compare_gimple_asm (gimple g1, gimple g2)\n+{\n+  if (gimple_asm_volatile_p (g1) != gimple_asm_volatile_p (g2))\n+    return false;\n+\n+  if (gimple_asm_ninputs (g1) != gimple_asm_ninputs (g2))\n+    return false;\n+\n+  if (gimple_asm_noutputs (g1) != gimple_asm_noutputs (g2))\n+    return false;\n+\n+  /* We do not suppport goto ASM statement comparison.  */\n+  if (gimple_asm_nlabels (g1) || gimple_asm_nlabels (g2))\n+    return false;\n+\n+  if (gimple_asm_nclobbers (g1) != gimple_asm_nclobbers (g2))\n+    return false;\n+\n+  for (unsigned i = 0; i < gimple_asm_ninputs (g1); i++)\n+    {\n+      tree input1 = gimple_asm_input_op (g1, i);\n+      tree input2 = gimple_asm_input_op (g2, i);\n+\n+      if (!compare_tree_list_operand (input1, input2))\n+\treturn return_false_with_msg (\"ASM input is different\");\n+    }\n+\n+  for (unsigned i = 0; i < gimple_asm_noutputs (g1); i++)\n+    {\n+      tree output1 = gimple_asm_output_op (g1, i);\n+      tree output2 = gimple_asm_output_op (g2, i);\n+\n+      if (!compare_tree_list_operand (output1, output2))\n+\treturn return_false_with_msg (\"ASM output is different\");\n+    }\n+\n+  for (unsigned i = 0; i < gimple_asm_nclobbers (g1); i++)\n+    {\n+      tree clobber1 = gimple_asm_clobber_op (g1, i);\n+      tree clobber2 = gimple_asm_clobber_op (g2, i);\n+\n+      if (!operand_equal_p (TREE_VALUE (clobber1), TREE_VALUE (clobber2),\n+\t\t\t    OEP_ONLY_CONST))\n+\treturn return_false_with_msg (\"ASM clobber is different\");\n+    }\n+\n+  return true;\n+}\n+\n+} // ipa_icf_gimple namespace"}, {"sha": "8487a2ad745e4b1a3866f53844e87ae1c73cef0b", "filename": "gcc/ipa-icf-gimple.h", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -0,0 +1,264 @@\n+/* Interprocedural semantic function equality pass\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   Contributed by Jan Hubicka <hubicka@ucw.cz> and Martin Liska <mliska@suse.cz>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Gimple identical code folding (class func_checker) is an infastructure\n+   capable of comparing two given functions. The class compares every\n+   gimple statement and uses many dictionaries to map source and target\n+   SSA_NAMEs, declarations and other components.\n+\n+   To use the infrastructure, create an instanse of func_checker and call\n+   a comparsion function based on type of gimple statement.  */\n+\n+/* Prints string STRING to a FILE with a given number of SPACE_COUNT.  */\n+#define FPUTS_SPACES(file, space_count, string) \\\n+  fprintf (file, \"%*s\" string, space_count, \" \");\n+\n+/* fprintf function wrapper that transforms given FORMAT to follow given\n+   number for SPACE_COUNT and call fprintf for a FILE.  */\n+#define FPRINTF_SPACES(file, space_count, format, ...) \\\n+  fprintf (file, \"%*s\" format, space_count, \" \", ##__VA_ARGS__);\n+\n+/* Prints a MESSAGE to dump_file if exists. FUNC is name of function and\n+   LINE is location in the source file.  */\n+\n+static inline void\n+dump_message_1 (const char *message, const char *func, unsigned int line)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"  debug message: %s (%s:%u)\\n\", message, func, line);\n+}\n+\n+/* Prints a MESSAGE to dump_file if exists.  */\n+#define dump_message(message) dump_message_1 (message, __func__, __LINE__)\n+\n+/* Logs a MESSAGE to dump_file if exists and returns false. FUNC is name\n+   of function and LINE is location in the source file.  */\n+\n+static inline bool\n+return_false_with_message_1 (const char *message, const char *func,\n+\t\t\t     unsigned int line)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"  false returned: '%s' (%s:%u)\\n\", message, func, line);\n+  return false;\n+}\n+\n+/* Logs a MESSAGE to dump_file if exists and returns false.  */\n+#define return_false_with_msg(message) \\\n+  return_false_with_message_1 (message, __func__, __LINE__)\n+\n+/* Return false and log that false value is returned.  */\n+#define return_false() return_false_with_msg (\"\")\n+\n+/* Logs return value if RESULT is false. FUNC is name of function and LINE\n+   is location in the source file.  */\n+\n+static inline bool\n+return_with_result (bool result, const char *func, unsigned int line)\n+{\n+  if (!result && dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"  false returned (%s:%u)\\n\", func, line);\n+\n+  return result;\n+}\n+\n+/* Logs return value if RESULT is false.  */\n+#define return_with_debug(result) return_with_result (result, __func__, __LINE__)\n+\n+/* Verbose logging function logging statements S1 and S2 of a CODE.\n+   FUNC is name of function and LINE is location in the source file.  */\n+\n+static inline bool\n+return_different_stmts_1 (gimple s1, gimple s2, const char *code,\n+\t\t\t  const char *func, unsigned int line)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  different statement for code: %s (%s:%u):\\n\",\n+\t       code, func, line);\n+\n+      print_gimple_stmt (dump_file, s1, 3, TDF_DETAILS);\n+      print_gimple_stmt (dump_file, s2, 3, TDF_DETAILS);\n+    }\n+\n+  return false;\n+}\n+\n+/* Verbose logging function logging statements S1 and S2 of a CODE.  */\n+#define return_different_stmts(s1, s2, code) \\\n+  return_different_stmts_1 (s1, s2, code, __func__, __LINE__)\n+\n+namespace ipa_icf_gimple {\n+\n+/* Basic block struct for semantic equality pass.  */\n+class sem_bb\n+{\n+public:\n+  sem_bb (basic_block bb_, unsigned nondbg_stmt_count_, unsigned edge_count_):\n+    bb (bb_), nondbg_stmt_count (nondbg_stmt_count_), edge_count (edge_count_) {}\n+\n+  /* Basic block the structure belongs to.  */\n+  basic_block bb;\n+\n+  /* Number of non-debug statements in the basic block.  */\n+  unsigned nondbg_stmt_count;\n+\n+  /* Number of edges connected to the block.  */\n+  unsigned edge_count;\n+};\n+\n+/* A class aggregating all connections and semantic equivalents\n+   for a given pair of semantic function candidates.  */\n+class func_checker\n+{\n+public:\n+  /* Initialize internal structures for a given SOURCE_FUNC_DECL and\n+     TARGET_FUNC_DECL. Strict polymorphic comparison is processed if\n+     an option COMPARE_POLYMORPHIC is true. For special cases, one can\n+     set IGNORE_LABELS to skip label comparison.\n+     Similarly, IGNORE_SOURCE_DECLS and IGNORE_TARGET_DECLS are sets\n+     of declarations that can be skipped.  */\n+  func_checker (tree source_func_decl, tree target_func_decl,\n+\t\tbool compare_polymorphic,\n+\t\tbool ignore_labels = false,\n+\t\thash_set<symtab_node *> *ignored_source_nodes = NULL,\n+\t\thash_set<symtab_node *> *ignored_target_nodes = NULL);\n+\n+  /* Memory release routine.  */\n+  ~func_checker();\n+\n+  void parse_labels (sem_bb *bb);\n+\n+  /* Basic block equivalence comparison function that returns true if\n+     basic blocks BB1 and BB2 correspond.  */\n+  bool compare_bb (sem_bb *bb1, sem_bb *bb2);\n+\n+  /* Verifies that trees T1 and T2 are equivalent from perspective of ICF.  */\n+  bool compare_ssa_name (tree t1, tree t2);\n+\n+  /* Verification function for edges E1 and E2.  */\n+  bool compare_edge (edge e1, edge e2);\n+\n+  /* Verifies for given GIMPLEs S1 and S2 that\n+     call statements are semantically equivalent.  */\n+  bool compare_gimple_call (gimple s1, gimple s2);\n+\n+  /* Verifies for given GIMPLEs S1 and S2 that\n+     assignment statements are semantically equivalent.  */\n+  bool compare_gimple_assign (gimple s1, gimple s2);\n+\n+  /* Verifies for given GIMPLEs S1 and S2 that\n+     condition statements are semantically equivalent.  */\n+  bool compare_gimple_cond (gimple s1, gimple s2);\n+\n+  /* Verifies for given GIMPLEs S1 and S2 that\n+     label statements are semantically equivalent.  */\n+  bool compare_gimple_label (gimple s1, gimple s2);\n+\n+  /* Verifies for given GIMPLEs S1 and S2 that\n+     switch statements are semantically equivalent.  */\n+  bool compare_gimple_switch (gimple s1, gimple s2);\n+\n+  /* Verifies for given GIMPLEs S1 and S2 that\n+     return statements are semantically equivalent.  */\n+  bool compare_gimple_return (gimple s1, gimple s2);\n+\n+  /* Verifies for given GIMPLEs S1 and S2 that\n+     goto statements are semantically equivalent.  */\n+  bool compare_gimple_goto (gimple s1, gimple s2);\n+\n+  /* Verifies for given GIMPLEs S1 and S2 that\n+     resx statements are semantically equivalent.  */\n+  bool compare_gimple_resx (gimple s1, gimple s2);\n+\n+  /* Verifies for given GIMPLEs S1 and S2 that ASM statements are equivalent.\n+     For the beginning, the pass only supports equality for\n+     '__asm__ __volatile__ (\"\", \"\", \"\", \"memory\")'.  */\n+  bool compare_gimple_asm (gimple s1, gimple s2);\n+\n+  /* Verification function for declaration trees T1 and T2.  */\n+  bool compare_decl (tree t1, tree t2);\n+\n+  /* Verifies that tree labels T1 and T2 correspond.  */\n+  bool compare_tree_ssa_label (tree t1, tree t2);\n+\n+  /* Function responsible for comparison of handled components T1 and T2.\n+     If these components, from functions FUNC1 and FUNC2, are equal, true\n+     is returned.  */\n+  bool compare_operand (tree t1, tree t2);\n+\n+  /* Compares two tree list operands T1 and T2 and returns true if these\n+     two trees are semantically equivalent.  */\n+  bool compare_tree_list_operand (tree t1, tree t2);\n+\n+  /* Verifies that trees T1 and T2, representing function declarations\n+     are equivalent from perspective of ICF.  */\n+  bool compare_function_decl (tree t1, tree t2);\n+\n+  /* Verifies that trees T1 and T2 do correspond.  */\n+  bool compare_variable_decl (tree t1, tree t2);\n+\n+  /* Return true if types are compatible from perspective of ICF.\n+     FIRST_ARGUMENT indicates if the comparison is called for\n+     first parameter of a function.  */\n+  static bool compatible_types_p (tree t1, tree t2,\n+\t\t\t\t  bool compare_polymorphic = true,\n+\t\t\t\t  bool first_argument = false);\n+\n+\n+private:\n+  /* Vector mapping source SSA names to target ones.  */\n+  vec <int> m_source_ssa_names;\n+\n+  /* Vector mapping target SSA names to source ones.  */\n+  vec <int> m_target_ssa_names;\n+\n+  /* Source TREE function declaration.  */\n+  tree m_source_func_decl;\n+\n+  /* Target TREE function declaration.  */\n+  tree m_target_func_decl;\n+\n+  /* Source symbol nodes that should be skipped by\n+     declaration comparison.  */\n+  hash_set<symtab_node *> *m_ignored_source_nodes;\n+\n+  /* Target symbol nodes that should be skipped by\n+     declaration comparison.  */\n+  hash_set<symtab_node *> *m_ignored_target_nodes;\n+\n+  /* Source to target edge map.  */\n+  hash_map <edge, edge> m_edge_map;\n+\n+  /* Source to target declaration map.  */\n+  hash_map <tree, tree> m_decl_map;\n+\n+  /* Label to basic block index mapping.  */\n+  hash_map <tree, int> m_label_bb_map;\n+\n+  /* Flag if polymorphic comparison should be executed.  */\n+  bool m_compare_polymorphic;\n+\n+  /* Flag if ignore labels in comparison.  */\n+  bool m_ignore_labels;\n+};\n+\n+} // ipa_icf_gimple namespace"}, {"sha": "4e73849f1b01a43f8fca5ac6091ac53fd3783949", "filename": "gcc/ipa-icf.c", "status": "added", "additions": 2371, "deletions": 0, "changes": 2371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -0,0 +1,2371 @@\n+/* Interprocedural Identical Code Folding pass\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   Contributed by Jan Hubicka <hubicka@ucw.cz> and Martin Liska <mliska@suse.cz>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Interprocedural Identical Code Folding for functions and\n+   read-only variables.\n+\n+   The goal of this transformation is to discover functions and read-only\n+   variables which do have exactly the same semantics.\n+\n+   In case of functions,\n+   we could either create a virtual clone or do a simple function wrapper\n+   that will call equivalent function. If the function is just locally visible,\n+   all function calls can be redirected. For read-only variables, we create\n+   aliases if possible.\n+\n+   Optimization pass arranges as follows:\n+   1) All functions and read-only variables are visited and internal\n+      data structure, either sem_function or sem_variables is created.\n+   2) For every symbol from the previous step, VAR_DECL and FUNCTION_DECL are\n+      saved and matched to corresponding sem_items.\n+   3) These declaration are ignored for equality check and are solved\n+      by Value Numbering algorithm published by Alpert, Zadeck in 1992.\n+   4) We compute hash value for each symbol.\n+   5) Congruence classes are created based on hash value. If hash value are\n+      equal, equals function is called and symbols are deeply compared.\n+      We must prove that all SSA names, declarations and other items\n+      correspond.\n+   6) Value Numbering is executed for these classes. At the end of the process\n+      all symbol members in remaining classes can be merged.\n+   7) Merge operation creates alias in case of read-only variables. For\n+      callgraph node, we must decide if we can redirect local calls,\n+      create an alias or a thunk.\n+\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"expr.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-ssa.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-phinodes.h\"\n+#include \"stringpool.h\"\n+#include \"tree-ssanames.h\"\n+#include \"tree-dfa.h\"\n+#include \"tree-pass.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"ipa-inline.h\"\n+#include \"cfgloop.h\"\n+#include \"except.h\"\n+#include \"hash-table.h\"\n+#include \"coverage.h\"\n+#include \"attribs.h\"\n+#include \"print-tree.h\"\n+#include \"lto-streamer.h\"\n+#include \"data-streamer.h\"\n+#include \"ipa-utils.h\"\n+#include <list>\n+#include \"ipa-icf-gimple.h\"\n+#include \"ipa-icf.h\"\n+\n+using namespace ipa_icf_gimple;\n+\n+namespace ipa_icf {\n+/* Constructor for key value pair, where _ITEM is key and _INDEX is a target.  */\n+\n+sem_usage_pair::sem_usage_pair (sem_item *_item, unsigned int _index):\n+  item (_item), index (_index)\n+{\n+}\n+\n+/* Semantic item constructor for a node of _TYPE, where STACK is used\n+   for bitmap memory allocation.  */\n+\n+sem_item::sem_item (sem_item_type _type,\n+\t\t    bitmap_obstack *stack): type(_type), hash(0)\n+{\n+  setup (stack);\n+}\n+\n+/* Semantic item constructor for a node of _TYPE, where STACK is used\n+   for bitmap memory allocation. The item is based on symtab node _NODE\n+   with computed _HASH.  */\n+\n+sem_item::sem_item (sem_item_type _type, symtab_node *_node,\n+\t\t    hashval_t _hash, bitmap_obstack *stack): type(_type),\n+  node (_node), hash (_hash)\n+{\n+  decl = node->decl;\n+  setup (stack);\n+}\n+\n+/* Add reference to a semantic TARGET.  */\n+\n+void\n+sem_item::add_reference (sem_item *target)\n+{\n+  refs.safe_push (target);\n+  unsigned index = refs.length ();\n+  target->usages.safe_push (new sem_usage_pair(this, index));\n+  bitmap_set_bit (target->usage_index_bitmap, index);\n+  refs_set.add (target->node);\n+}\n+\n+/* Initialize internal data structures. Bitmap STACK is used for\n+   bitmap memory allocation process.  */\n+\n+void\n+sem_item::setup (bitmap_obstack *stack)\n+{\n+  gcc_checking_assert (node);\n+\n+  refs.create (0);\n+  tree_refs.create (0);\n+  usages.create (0);\n+  usage_index_bitmap = BITMAP_ALLOC (stack);\n+}\n+\n+sem_item::~sem_item ()\n+{\n+  for (unsigned i = 0; i < usages.length (); i++)\n+    delete usages[i];\n+\n+  refs.release ();\n+  tree_refs.release ();\n+  usages.release ();\n+\n+  BITMAP_FREE (usage_index_bitmap);\n+}\n+\n+/* Dump function for debugging purpose.  */\n+\n+DEBUG_FUNCTION void\n+sem_item::dump (void)\n+{\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"[%s] %s (%u) (tree:%p)\\n\", type == FUNC ? \"func\" : \"var\",\n+\t       name(), node->order, (void *) node->decl);\n+      fprintf (dump_file, \"  hash: %u\\n\", get_hash ());\n+      fprintf (dump_file, \"  references: \");\n+\n+      for (unsigned i = 0; i < refs.length (); i++)\n+\tfprintf (dump_file, \"%s%s \", refs[i]->name (),\n+\t\t i < refs.length() - 1 ? \",\" : \"\");\n+\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n+/* Semantic function constructor that uses STACK as bitmap memory stack.  */\n+\n+sem_function::sem_function (bitmap_obstack *stack): sem_item (FUNC, stack),\n+  m_checker (NULL), m_compared_func (NULL)\n+{\n+  arg_types.create (0);\n+  bb_sizes.create (0);\n+  bb_sorted.create (0);\n+}\n+\n+/*  Constructor based on callgraph node _NODE with computed hash _HASH.\n+    Bitmap STACK is used for memory allocation.  */\n+sem_function::sem_function (cgraph_node *node, hashval_t hash,\n+\t\t\t    bitmap_obstack *stack):\n+  sem_item (FUNC, node, hash, stack),\n+  m_checker (NULL), m_compared_func (NULL)\n+{\n+  arg_types.create (0);\n+  bb_sizes.create (0);\n+  bb_sorted.create (0);\n+}\n+\n+sem_function::~sem_function ()\n+{\n+  for (unsigned i = 0; i < bb_sorted.length (); i++)\n+    free (bb_sorted[i]);\n+\n+  arg_types.release ();\n+  bb_sizes.release ();\n+  bb_sorted.release ();\n+}\n+\n+/* Calculates hash value based on a BASIC_BLOCK.  */\n+\n+hashval_t\n+sem_function::get_bb_hash (const sem_bb *basic_block)\n+{\n+  inchash::hash hstate;\n+\n+  hstate.add_int (basic_block->nondbg_stmt_count);\n+  hstate.add_int (basic_block->edge_count);\n+\n+  return hstate.end ();\n+}\n+\n+/* References independent hash function.  */\n+\n+hashval_t\n+sem_function::get_hash (void)\n+{\n+  if(!hash)\n+    {\n+      inchash::hash hstate;\n+      hstate.add_int (177454); /* Random number for function type.  */\n+\n+      hstate.add_int (arg_count);\n+      hstate.add_int (cfg_checksum);\n+      hstate.add_int (gcode_hash);\n+\n+      for (unsigned i = 0; i < bb_sorted.length (); i++)\n+\thstate.merge_hash (get_bb_hash (bb_sorted[i]));\n+\n+      for (unsigned i = 0; i < bb_sizes.length (); i++)\n+\thstate.add_int (bb_sizes[i]);\n+\n+      hash = hstate.end ();\n+    }\n+\n+  return hash;\n+}\n+\n+/* For a given symbol table nodes N1 and N2, we check that FUNCTION_DECLs\n+   point to a same function. Comparison can be skipped if IGNORED_NODES\n+   contains these nodes.  */\n+\n+bool\n+sem_function::compare_cgraph_references (hash_map <symtab_node *, sem_item *>\n+    &ignored_nodes,\n+    symtab_node *n1, symtab_node *n2)\n+{\n+  if (n1 == n2 || (ignored_nodes.get (n1) && ignored_nodes.get (n2)))\n+    return true;\n+\n+  /* TODO: add more precise comparison for weakrefs, etc.  */\n+\n+  return return_false_with_msg (\"different references\");\n+}\n+\n+/* If cgraph edges E1 and E2 are indirect calls, verify that\n+   ECF flags are the same.  */\n+\n+bool sem_function::compare_edge_flags (cgraph_edge *e1, cgraph_edge *e2)\n+{\n+  if (e1->indirect_info && e2->indirect_info)\n+    {\n+      int e1_flags = e1->indirect_info->ecf_flags;\n+      int e2_flags = e2->indirect_info->ecf_flags;\n+\n+      if (e1_flags != e2_flags)\n+\treturn return_false_with_msg (\"ICF flags are different\");\n+    }\n+  else if (e1->indirect_info || e2->indirect_info)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Fast equality function based on knowledge known in WPA.  */\n+\n+bool\n+sem_function::equals_wpa (sem_item *item,\n+\t\t\t  hash_map <symtab_node *, sem_item *> &ignored_nodes)\n+{\n+  gcc_assert (item->type == FUNC);\n+\n+  m_compared_func = static_cast<sem_function *> (item);\n+\n+  if (arg_types.length () != m_compared_func->arg_types.length ())\n+    return return_false_with_msg (\"different number of arguments\");\n+\n+  /* Checking types of arguments.  */\n+  for (unsigned i = 0; i < arg_types.length (); i++)\n+    {\n+      /* This guard is here for function pointer with attributes (pr59927.c).  */\n+      if (!arg_types[i] || !m_compared_func->arg_types[i])\n+\treturn return_false_with_msg (\"NULL argument type\");\n+\n+      /* Polymorphic comparison is executed just for non-leaf functions.  */\n+      bool is_not_leaf = get_node ()->callees != NULL;\n+\n+      if (!func_checker::compatible_types_p (arg_types[i],\n+\t\t\t\t\t     m_compared_func->arg_types[i],\n+\t\t\t\t\t     is_not_leaf, i == 0))\n+\treturn return_false_with_msg (\"argument type is different\");\n+    }\n+\n+  /* Result type checking.  */\n+  if (!func_checker::compatible_types_p (result_type,\n+\t\t\t\t\t m_compared_func->result_type))\n+    return return_false_with_msg (\"result types are different\");\n+\n+  if (node->num_references () != item->node->num_references ())\n+    return return_false_with_msg (\"different number of references\");\n+\n+  ipa_ref *ref = NULL, *ref2 = NULL;\n+  for (unsigned i = 0; node->iterate_reference (i, ref); i++)\n+    {\n+      item->node->iterate_reference (i, ref2);\n+\n+      if (!compare_cgraph_references (ignored_nodes, ref->referred, ref2->referred))\n+\treturn false;\n+    }\n+\n+  cgraph_edge *e1 = dyn_cast <cgraph_node *> (node)->callees;\n+  cgraph_edge *e2 = dyn_cast <cgraph_node *> (item->node)->callees;\n+\n+  while (e1 && e2)\n+    {\n+      if (!compare_cgraph_references (ignored_nodes, e1->callee, e2->callee))\n+\treturn false;\n+\n+      e1 = e1->next_callee;\n+      e2 = e2->next_callee;\n+    }\n+\n+  if (e1 || e2)\n+    return return_false_with_msg (\"different number of edges\");\n+\n+  return true;\n+}\n+\n+/* Returns true if the item equals to ITEM given as argument.  */\n+\n+bool\n+sem_function::equals (sem_item *item,\n+\t\t      hash_map <symtab_node *, sem_item *> &ignored_nodes)\n+{\n+  gcc_assert (item->type == FUNC);\n+  bool eq = equals_private (item, ignored_nodes);\n+\n+  if (m_checker != NULL)\n+    {\n+      delete m_checker;\n+      m_checker = NULL;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file,\n+\t     \"Equals called for:%s:%s (%u:%u) (%s:%s) with result: %s\\n\\n\",\n+\t     name(), item->name (), node->order, item->node->order, asm_name (),\n+\t     item->asm_name (), eq ? \"true\" : \"false\");\n+\n+  return eq;\n+}\n+\n+/* Processes function equality comparison.  */\n+\n+bool\n+sem_function::equals_private (sem_item *item,\n+\t\t\t      hash_map <symtab_node *, sem_item *> &ignored_nodes)\n+{\n+  if (item->type != FUNC)\n+    return false;\n+\n+  basic_block bb1, bb2;\n+  edge e1, e2;\n+  edge_iterator ei1, ei2;\n+  int *bb_dict = NULL;\n+  bool result = true;\n+  tree arg1, arg2;\n+\n+  m_compared_func = static_cast<sem_function *> (item);\n+\n+  gcc_assert (decl != item->decl);\n+\n+  if (bb_sorted.length () != m_compared_func->bb_sorted.length ()\n+      || edge_count != m_compared_func->edge_count\n+      || cfg_checksum != m_compared_func->cfg_checksum)\n+    return return_false ();\n+\n+  if (!equals_wpa (item, ignored_nodes))\n+    return false;\n+\n+  /* Checking function arguments.  */\n+  tree decl1 = DECL_ATTRIBUTES (decl);\n+  tree decl2 = DECL_ATTRIBUTES (m_compared_func->decl);\n+\n+  m_checker = new func_checker (decl, m_compared_func->decl,\n+\t\t\t\tcompare_polymorphic_p (),\n+\t\t\t\tfalse,\n+\t\t\t\t&refs_set,\n+\t\t\t\t&m_compared_func->refs_set);\n+  while (decl1)\n+    {\n+      if (decl2 == NULL)\n+\treturn return_false ();\n+\n+      if (get_attribute_name (decl1) != get_attribute_name (decl2))\n+\treturn return_false ();\n+\n+      tree attr_value1 = TREE_VALUE (decl1);\n+      tree attr_value2 = TREE_VALUE (decl2);\n+\n+      if (attr_value1 && attr_value2)\n+\t{\n+\t  bool ret = m_checker->compare_operand (TREE_VALUE (attr_value1),\n+\t\t\t\t\t\t TREE_VALUE (attr_value2));\n+\t  if (!ret)\n+\t    return return_false_with_msg (\"attribute values are different\");\n+\t}\n+      else if (!attr_value1 && !attr_value2)\n+\t{}\n+      else\n+\treturn return_false ();\n+\n+      decl1 = TREE_CHAIN (decl1);\n+      decl2 = TREE_CHAIN (decl2);\n+    }\n+\n+  if (decl1 != decl2)\n+    return return_false();\n+\n+\n+  for (arg1 = DECL_ARGUMENTS (decl),\n+       arg2 = DECL_ARGUMENTS (m_compared_func->decl);\n+       arg1; arg1 = DECL_CHAIN (arg1), arg2 = DECL_CHAIN (arg2))\n+    if (!m_checker->compare_decl (arg1, arg2))\n+      return return_false ();\n+\n+  /* Fill-up label dictionary.  */\n+  for (unsigned i = 0; i < bb_sorted.length (); ++i)\n+    {\n+      m_checker->parse_labels (bb_sorted[i]);\n+      m_checker->parse_labels (m_compared_func->bb_sorted[i]);\n+    }\n+\n+  /* Checking all basic blocks.  */\n+  for (unsigned i = 0; i < bb_sorted.length (); ++i)\n+    if(!m_checker->compare_bb (bb_sorted[i], m_compared_func->bb_sorted[i]))\n+      return return_false();\n+\n+  dump_message (\"All BBs are equal\\n\");\n+\n+  /* Basic block edges check.  */\n+  for (unsigned i = 0; i < bb_sorted.length (); ++i)\n+    {\n+      bb_dict = XNEWVEC (int, bb_sorted.length () + 2);\n+      memset (bb_dict, -1, (bb_sorted.length () + 2) * sizeof (int));\n+\n+      bb1 = bb_sorted[i]->bb;\n+      bb2 = m_compared_func->bb_sorted[i]->bb;\n+\n+      ei2 = ei_start (bb2->preds);\n+\n+      for (ei1 = ei_start (bb1->preds); ei_cond (ei1, &e1); ei_next (&ei1))\n+\t{\n+\t  ei_cond (ei2, &e2);\n+\n+\t  if (e1->flags != e2->flags)\n+\t    return return_false_with_msg (\"flags comparison returns false\");\n+\n+\t  if (!bb_dict_test (bb_dict, e1->src->index, e2->src->index))\n+\t    return return_false_with_msg (\"edge comparison returns false\");\n+\n+\t  if (!bb_dict_test (bb_dict, e1->dest->index, e2->dest->index))\n+\t    return return_false_with_msg (\"BB comparison returns false\");\n+\n+\t  if (!m_checker->compare_edge (e1, e2))\n+\t    return return_false_with_msg (\"edge comparison returns false\");\n+\n+\t  ei_next (&ei2);\n+\t}\n+    }\n+\n+  /* Basic block PHI nodes comparison.  */\n+  for (unsigned i = 0; i < bb_sorted.length (); i++)\n+    if (!compare_phi_node (bb_sorted[i]->bb, m_compared_func->bb_sorted[i]->bb))\n+      return return_false_with_msg (\"PHI node comparison returns false\");\n+\n+  return result;\n+}\n+\n+/* Merges instance with an ALIAS_ITEM, where alias, thunk or redirection can\n+   be applied.  */\n+bool\n+sem_function::merge (sem_item *alias_item)\n+{\n+  gcc_assert (alias_item->type == FUNC);\n+\n+  sem_function *alias_func = static_cast<sem_function *> (alias_item);\n+\n+  cgraph_node *original = get_node ();\n+  cgraph_node *local_original = original;\n+  cgraph_node *alias = alias_func->get_node ();\n+  bool original_address_matters;\n+  bool alias_address_matters;\n+\n+  bool create_thunk = false;\n+  bool create_alias = false;\n+  bool redirect_callers = false;\n+  bool original_discardable = false;\n+\n+  /* Do not attempt to mix functions from different user sections;\n+     we do not know what user intends with those.  */\n+  if (((DECL_SECTION_NAME (original->decl) && !original->implicit_section)\n+       || (DECL_SECTION_NAME (alias->decl) && !alias->implicit_section))\n+      && DECL_SECTION_NAME (original->decl) != DECL_SECTION_NAME (alias->decl))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Not unifying; original and alias are in different sections.\\n\\n\");\n+      return false;\n+    }\n+\n+  /* See if original is in a section that can be discarded if the main\n+     symbol is not used.  */\n+  if (DECL_EXTERNAL (original->decl))\n+    original_discardable = true;\n+  if (original->resolution == LDPR_PREEMPTED_REG\n+      || original->resolution == LDPR_PREEMPTED_IR)\n+    original_discardable = true;\n+  if (original->can_be_discarded_p ())\n+    original_discardable = true;\n+\n+  /* See if original and/or alias address can be compared for equality.  */\n+  original_address_matters\n+    = (!DECL_VIRTUAL_P (original->decl)\n+       && (original->externally_visible\n+\t   || original->address_taken_from_non_vtable_p ()));\n+  alias_address_matters\n+    = (!DECL_VIRTUAL_P (alias->decl)\n+       && (alias->externally_visible\n+\t   || alias->address_taken_from_non_vtable_p ()));\n+\n+  /* If alias and original can be compared for address equality, we need\n+     to create a thunk.  Also we can not create extra aliases into discardable\n+     section (or we risk link failures when section is discarded).  */\n+  if ((original_address_matters\n+       && alias_address_matters)\n+      || original_discardable)\n+    {\n+      create_thunk = !stdarg_p (TREE_TYPE (alias->decl));\n+      create_alias = false;\n+      /* When both alias and original are not overwritable, we can save\n+         the extra thunk wrapper for direct calls.  */\n+      redirect_callers\n+\t= (!original_discardable\n+\t   && alias->get_availability () > AVAIL_INTERPOSABLE\n+\t   && original->get_availability () > AVAIL_INTERPOSABLE);\n+    }\n+  else\n+    {\n+      create_alias = true;\n+      create_thunk = false;\n+      redirect_callers = false;\n+    }\n+\n+  if (create_alias && DECL_COMDAT_GROUP (alias->decl))\n+    {\n+      create_alias = false;\n+      create_thunk = true;\n+    }\n+\n+  /* We want thunk to always jump to the local function body\n+     unless the body is comdat and may be optimized out.  */\n+  if ((create_thunk || redirect_callers)\n+      && (!original_discardable\n+\t  || (DECL_COMDAT_GROUP (original->decl)\n+\t      && (DECL_COMDAT_GROUP (original->decl)\n+\t\t  == DECL_COMDAT_GROUP (alias->decl)))))\n+    local_original\n+      = dyn_cast <cgraph_node *> (original->noninterposable_alias ());\n+\n+  if (redirect_callers)\n+    {\n+      /* If alias is non-overwritable then\n+         all direct calls are safe to be redirected to the original.  */\n+      bool redirected = false;\n+      while (alias->callers)\n+\t{\n+\t  cgraph_edge *e = alias->callers;\n+\t  e->redirect_callee (local_original);\n+\t  push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n+\n+\t  if (e->call_stmt)\n+\t    e->redirect_call_stmt_to_callee ();\n+\n+\t  pop_cfun ();\n+\t  redirected = true;\n+\t}\n+\n+      alias->icf_merged = true;\n+\n+      /* The alias function is removed if symbol address\n+         does not matter.  */\n+      if (!alias_address_matters)\n+\talias->remove ();\n+\n+      if (dump_file && redirected)\n+\tfprintf (dump_file, \"Callgraph local calls have been redirected.\\n\\n\");\n+    }\n+  /* If the condtion above is not met, we are lucky and can turn the\n+     function into real alias.  */\n+  else if (create_alias)\n+    {\n+      alias->icf_merged = true;\n+\n+      /* Remove the function's body.  */\n+      ipa_merge_profiles (original, alias);\n+      alias->release_body (true);\n+      alias->reset ();\n+\n+      /* Create the alias.  */\n+      cgraph_node::create_alias (alias_func->decl, decl);\n+      alias->resolve_alias (original);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"Callgraph alias has been created.\\n\\n\");\n+    }\n+  else if (create_thunk)\n+    {\n+      if (DECL_COMDAT_GROUP (alias->decl))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Callgraph thunk cannot be created because of COMDAT\\n\");\n+\n+\t  return 0;\n+\t}\n+\n+      alias->icf_merged = true;\n+      ipa_merge_profiles (local_original, alias);\n+      alias->create_wrapper (local_original);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"Callgraph thunk has been created.\\n\\n\");\n+    }\n+  else if (dump_file)\n+    fprintf (dump_file, \"Callgraph merge operation cannot be performed.\\n\\n\");\n+\n+  return true;\n+}\n+\n+/* Semantic item initialization function.  */\n+\n+void\n+sem_function::init (void)\n+{\n+  if (in_lto_p)\n+    get_node ()->get_body ();\n+\n+  tree fndecl = node->decl;\n+  function *func = DECL_STRUCT_FUNCTION (fndecl);\n+\n+  gcc_assert (func);\n+  gcc_assert (SSANAMES (func));\n+\n+  ssa_names_size = SSANAMES (func)->length ();\n+  node = node;\n+\n+  decl = fndecl;\n+  region_tree = func->eh->region_tree;\n+\n+  /* iterating all function arguments.  */\n+  arg_count = count_formal_params (fndecl);\n+\n+  edge_count = n_edges_for_fn (func);\n+  cfg_checksum = coverage_compute_cfg_checksum (func);\n+\n+  inchash::hash hstate;\n+\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, func)\n+  {\n+    unsigned nondbg_stmt_count = 0;\n+\n+    edge e;\n+    for (edge_iterator ei = ei_start (bb->preds); ei_cond (ei, &e); ei_next (&ei))\n+      cfg_checksum = iterative_hash_host_wide_int (e->flags,\n+\t\t     cfg_checksum);\n+\n+    for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t gsi_next (&gsi))\n+      {\n+\tgimple stmt = gsi_stmt (gsi);\n+\n+\tif (gimple_code (stmt) != GIMPLE_DEBUG)\n+\t  {\n+\t    hash_stmt (&hstate, stmt);\n+\t    nondbg_stmt_count++;\n+\t  }\n+      }\n+\n+    gcode_hash = hstate.end ();\n+    bb_sizes.safe_push (nondbg_stmt_count);\n+\n+    /* Inserting basic block to hash table.  */\n+    sem_bb *semantic_bb = new sem_bb (bb, nondbg_stmt_count,\n+\t\t\t\t      EDGE_COUNT (bb->preds) + EDGE_COUNT (bb->succs));\n+\n+    bb_sorted.safe_push (semantic_bb);\n+  }\n+\n+  parse_tree_args ();\n+}\n+\n+/* Improve accumulated hash for HSTATE based on a gimple statement STMT.  */\n+\n+void\n+sem_function::hash_stmt (inchash::hash *hstate, gimple stmt)\n+{\n+  enum gimple_code code = gimple_code (stmt);\n+\n+  hstate->add_int (code);\n+\n+  if (code == GIMPLE_CALL)\n+    {\n+      /* Checking of argument.  */\n+      for (unsigned i = 0; i < gimple_call_num_args (stmt); ++i)\n+\t{\n+\t  tree argument = gimple_call_arg (stmt, i);\n+\n+\t  switch (TREE_CODE (argument))\n+\t    {\n+\t    case INTEGER_CST:\n+\t      if (tree_fits_shwi_p (argument))\n+\t\thstate->add_wide_int (tree_to_shwi (argument));\n+\t      else if (tree_fits_uhwi_p (argument))\n+\t\thstate->add_wide_int (tree_to_uhwi (argument));\n+\t      break;\n+\t    case REAL_CST:\n+\t      REAL_VALUE_TYPE c;\n+\t      HOST_WIDE_INT n;\n+\n+\t      c = TREE_REAL_CST (argument);\n+\t      n = real_to_integer (&c);\n+\n+\t      hstate->add_wide_int (n);\n+\t      break;\n+\t    case ADDR_EXPR:\n+\t      {\n+\t\ttree addr_operand = TREE_OPERAND (argument, 0);\n+\n+\t\tif (TREE_CODE (addr_operand) == STRING_CST)\n+\t\t  hstate->add (TREE_STRING_POINTER (addr_operand),\n+\t\t\t       TREE_STRING_LENGTH (addr_operand));\n+\t\tbreak;\n+\t      }\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Return true if polymorphic comparison must be processed.  */\n+\n+bool\n+sem_function::compare_polymorphic_p (void)\n+{\n+  return get_node ()->callees != NULL\n+\t || m_compared_func->get_node ()->callees != NULL;\n+}\n+\n+/* For a given call graph NODE, the function constructs new\n+   semantic function item.  */\n+\n+sem_function *\n+sem_function::parse (cgraph_node *node, bitmap_obstack *stack)\n+{\n+  tree fndecl = node->decl;\n+  function *func = DECL_STRUCT_FUNCTION (fndecl);\n+\n+  /* TODO: add support for thunks and aliases.  */\n+\n+  if (!func || !node->has_gimple_body_p ())\n+    return NULL;\n+\n+  if (lookup_attribute_by_prefix (\"omp \", DECL_ATTRIBUTES (node->decl)) != NULL)\n+    return NULL;\n+\n+  sem_function *f = new sem_function (node, 0, stack);\n+\n+  f->init ();\n+\n+  return f;\n+}\n+\n+/* Parses function arguments and result type.  */\n+\n+void\n+sem_function::parse_tree_args (void)\n+{\n+  tree result;\n+\n+  if (arg_types.exists ())\n+    arg_types.release ();\n+\n+  arg_types.create (4);\n+  tree fnargs = DECL_ARGUMENTS (decl);\n+\n+  for (tree parm = fnargs; parm; parm = DECL_CHAIN (parm))\n+    arg_types.safe_push (DECL_ARG_TYPE (parm));\n+\n+  /* Function result type.  */\n+  result = DECL_RESULT (decl);\n+  result_type = result ? TREE_TYPE (result) : NULL;\n+\n+  /* During WPA, we can get arguments by following method.  */\n+  if (!fnargs)\n+    {\n+      tree type = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+      for (tree parm = type; parm; parm = TREE_CHAIN (parm))\n+\targ_types.safe_push (TYPE_CANONICAL (TREE_VALUE (parm)));\n+\n+      result_type = TREE_TYPE (TREE_TYPE (decl));\n+    }\n+}\n+\n+/* For given basic blocks BB1 and BB2 (from functions FUNC1 and FUNC),\n+   return true if phi nodes are semantically equivalent in these blocks .  */\n+\n+bool\n+sem_function::compare_phi_node (basic_block bb1, basic_block bb2)\n+{\n+  gimple_stmt_iterator si1, si2;\n+  gimple phi1, phi2;\n+  unsigned size1, size2, i;\n+  tree t1, t2;\n+  edge e1, e2;\n+\n+  gcc_assert (bb1 != NULL);\n+  gcc_assert (bb2 != NULL);\n+\n+  si2 = gsi_start_phis (bb2);\n+  for (si1 = gsi_start_phis (bb1); !gsi_end_p (si1);\n+       gsi_next (&si1))\n+    {\n+      gsi_next_nonvirtual_phi (&si1);\n+      gsi_next_nonvirtual_phi (&si2);\n+\n+      if (gsi_end_p (si1) && gsi_end_p (si2))\n+\tbreak;\n+\n+      if (gsi_end_p (si1) || gsi_end_p (si2))\n+\treturn return_false();\n+\n+      phi1 = gsi_stmt (si1);\n+      phi2 = gsi_stmt (si2);\n+\n+      size1 = gimple_phi_num_args (phi1);\n+      size2 = gimple_phi_num_args (phi2);\n+\n+      if (size1 != size2)\n+\treturn return_false ();\n+\n+      for (i = 0; i < size1; ++i)\n+\t{\n+\t  t1 = gimple_phi_arg (phi1, i)->def;\n+\t  t2 = gimple_phi_arg (phi2, i)->def;\n+\n+\t  if (!m_checker->compare_operand (t1, t2))\n+\t    return return_false ();\n+\n+\t  e1 = gimple_phi_arg_edge (phi1, i);\n+\t  e2 = gimple_phi_arg_edge (phi2, i);\n+\n+\t  if (!m_checker->compare_edge (e1, e2))\n+\t    return return_false ();\n+\t}\n+\n+      gsi_next (&si2);\n+    }\n+\n+  return true;\n+}\n+\n+/* Returns true if tree T can be compared as a handled component.  */\n+\n+bool\n+sem_function::icf_handled_component_p (tree t)\n+{\n+  tree_code tc = TREE_CODE (t);\n+\n+  return ((handled_component_p (t))\n+\t  || tc == ADDR_EXPR || tc == MEM_REF || tc == REALPART_EXPR\n+\t  || tc == IMAGPART_EXPR || tc == OBJ_TYPE_REF);\n+}\n+\n+/* Basic blocks dictionary BB_DICT returns true if SOURCE index BB\n+   corresponds to TARGET.  */\n+\n+bool\n+sem_function::bb_dict_test (int* bb_dict, int source, int target)\n+{\n+  if (bb_dict[source] == -1)\n+    {\n+      bb_dict[source] = target;\n+      return true;\n+    }\n+  else\n+    return bb_dict[source] == target;\n+}\n+\n+/* Iterates all tree types in T1 and T2 and returns true if all types\n+   are compatible. If COMPARE_POLYMORPHIC is set to true,\n+   more strict comparison is executed.  */\n+\n+bool\n+sem_function::compare_type_list (tree t1, tree t2, bool compare_polymorphic)\n+{\n+  tree tv1, tv2;\n+  tree_code tc1, tc2;\n+\n+  if (!t1 && !t2)\n+    return true;\n+\n+  while (t1 != NULL && t2 != NULL)\n+    {\n+      tv1 = TREE_VALUE (t1);\n+      tv2 = TREE_VALUE (t2);\n+\n+      tc1 = TREE_CODE (tv1);\n+      tc2 = TREE_CODE (tv2);\n+\n+      if (tc1 == NOP_EXPR && tc2 == NOP_EXPR)\n+\t{}\n+      else if (tc1 == NOP_EXPR || tc2 == NOP_EXPR)\n+\treturn false;\n+      else if (!func_checker::compatible_types_p (tv1, tv2, compare_polymorphic))\n+\treturn false;\n+\n+      t1 = TREE_CHAIN (t1);\n+      t2 = TREE_CHAIN (t2);\n+    }\n+\n+  return !(t1 || t2);\n+}\n+\n+\n+/* Semantic variable constructor that uses STACK as bitmap memory stack.  */\n+\n+sem_variable::sem_variable (bitmap_obstack *stack): sem_item (VAR, stack)\n+{\n+}\n+\n+/*  Constructor based on varpool node _NODE with computed hash _HASH.\n+    Bitmap STACK is used for memory allocation.  */\n+\n+sem_variable::sem_variable (varpool_node *node, hashval_t _hash,\n+\t\t\t    bitmap_obstack *stack): sem_item(VAR,\n+\t\t\t\t  node, _hash, stack)\n+{\n+  gcc_checking_assert (node);\n+  gcc_checking_assert (get_node ());\n+}\n+\n+/* Returns true if the item equals to ITEM given as argument.  */\n+\n+bool\n+sem_variable::equals (sem_item *item,\n+\t\t      hash_map <symtab_node *, sem_item *> & ARG_UNUSED (ignored_nodes))\n+{\n+  gcc_assert (item->type == VAR);\n+\n+  sem_variable *v = static_cast<sem_variable *>(item);\n+\n+  if (!ctor || !v->ctor)\n+    return return_false_with_msg (\"ctor is missing for semantic variable\");\n+\n+  return sem_variable::equals (ctor, v->ctor);\n+}\n+\n+/* Compares trees T1 and T2 for semantic equality.  */\n+\n+bool\n+sem_variable::equals (tree t1, tree t2)\n+{\n+  tree_code tc1 = TREE_CODE (t1);\n+  tree_code tc2 = TREE_CODE (t2);\n+\n+  if (tc1 != tc2)\n+    return false;\n+\n+  switch (tc1)\n+    {\n+    case CONSTRUCTOR:\n+      {\n+\tunsigned len1 = vec_safe_length (CONSTRUCTOR_ELTS (t1));\n+\tunsigned len2 = vec_safe_length (CONSTRUCTOR_ELTS (t2));\n+\n+\tif (len1 != len2)\n+\t  return false;\n+\n+\tfor (unsigned i = 0; i < len1; i++)\n+\t  if (!sem_variable::equals (CONSTRUCTOR_ELT (t1, i)->value,\n+\t\t\t\t     CONSTRUCTOR_ELT (t2, i)->value)\n+\t      || CONSTRUCTOR_ELT (t1, i)->index != CONSTRUCTOR_ELT (t2, i)->index)\n+\t    return false;\n+\n+\treturn true;\n+      }\n+    case MEM_REF:\n+      {\n+\ttree x1 = TREE_OPERAND (t1, 0);\n+\ttree x2 = TREE_OPERAND (t2, 0);\n+\ttree y1 = TREE_OPERAND (t1, 1);\n+\ttree y2 = TREE_OPERAND (t2, 1);\n+\n+\tif (!func_checker::compatible_types_p (TREE_TYPE (x1), TREE_TYPE (x2),\n+\t\t\t\t\t       true))\n+\t  return return_false ();\n+\n+\t/* Type of the offset on MEM_REF does not matter.  */\n+\treturn sem_variable::equals (x1, x2)\n+\t       && wi::to_offset  (y1) == wi::to_offset  (y2);\n+      }\n+    case NOP_EXPR:\n+    case ADDR_EXPR:\n+      {\n+\ttree op1 = TREE_OPERAND (t1, 0);\n+\ttree op2 = TREE_OPERAND (t2, 0);\n+\treturn sem_variable::equals (op1, op2);\n+      }\n+    case FUNCTION_DECL:\n+    case VAR_DECL:\n+    case FIELD_DECL:\n+    case LABEL_DECL:\n+      return t1 == t2;\n+    case INTEGER_CST:\n+      return func_checker::compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t     true)\n+\t     && wi::to_offset (t1) == wi::to_offset (t2);\n+    case STRING_CST:\n+    case REAL_CST:\n+    case COMPLEX_CST:\n+      return operand_equal_p (t1, t2, OEP_ONLY_CONST);\n+    case COMPONENT_REF:\n+    case ARRAY_REF:\n+    case POINTER_PLUS_EXPR:\n+      {\n+\ttree x1 = TREE_OPERAND (t1, 0);\n+\ttree x2 = TREE_OPERAND (t2, 0);\n+\ttree y1 = TREE_OPERAND (t1, 1);\n+\ttree y2 = TREE_OPERAND (t2, 1);\n+\n+\treturn sem_variable::equals (x1, x2) && sem_variable::equals (y1, y2);\n+      }\n+    case ERROR_MARK:\n+      return return_false_with_msg (\"ERROR_MARK\");\n+    default:\n+      return return_false_with_msg (\"Unknown TREE code reached\");\n+    }\n+}\n+\n+/* Parser function that visits a varpool NODE.  */\n+\n+sem_variable *\n+sem_variable::parse (varpool_node *node, bitmap_obstack *stack)\n+{\n+  tree decl = node->decl;\n+\n+  bool readonly = TYPE_P (decl) ? TYPE_READONLY (decl) : TREE_READONLY (decl);\n+  bool can_handle = readonly && (DECL_VIRTUAL_P (decl)\n+\t\t\t\t || !TREE_ADDRESSABLE (decl));\n+\n+  if (!can_handle)\n+    return NULL;\n+\n+  tree ctor = ctor_for_folding (decl);\n+  if (!ctor)\n+    return NULL;\n+\n+  sem_variable *v = new sem_variable (node, 0, stack);\n+\n+  v->init ();\n+\n+  return v;\n+}\n+\n+/* References independent hash function.  */\n+\n+hashval_t\n+sem_variable::get_hash (void)\n+{\n+  if (hash)\n+    return hash;\n+\n+  inchash::hash hstate;\n+\n+  hstate.add_int (456346417);\n+  hstate.add_int (TREE_CODE (ctor));\n+\n+  if (TREE_CODE (ctor) == CONSTRUCTOR)\n+    {\n+      unsigned length = vec_safe_length (CONSTRUCTOR_ELTS (ctor));\n+      hstate.add_int (length);\n+    }\n+\n+  hash = hstate.end ();\n+\n+  return hash;\n+}\n+\n+/* Merges instance with an ALIAS_ITEM, where alias, thunk or redirection can\n+   be applied.  */\n+\n+bool\n+sem_variable::merge (sem_item *alias_item)\n+{\n+  gcc_assert (alias_item->type == VAR);\n+\n+  sem_variable *alias_var = static_cast<sem_variable *> (alias_item);\n+\n+  varpool_node *original = get_node ();\n+  varpool_node *alias = alias_var->get_node ();\n+  bool original_discardable = false;\n+\n+  /* See if original is in a section that can be discarded if the main\n+     symbol is not used.  */\n+  if (DECL_EXTERNAL (original->decl))\n+    original_discardable = true;\n+  if (original->resolution == LDPR_PREEMPTED_REG\n+      || original->resolution == LDPR_PREEMPTED_IR)\n+    original_discardable = true;\n+  if (original->can_be_discarded_p ())\n+    original_discardable = true;\n+\n+  gcc_assert (!TREE_ASM_WRITTEN (alias->decl));\n+\n+  if (original_discardable || DECL_EXTERNAL (alias_var->decl) ||\n+      !compare_sections (alias_var))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Varpool alias cannot be created\\n\\n\");\n+\n+      return false;\n+    }\n+  else\n+    {\n+      // alias cycle creation check\n+      varpool_node *n = original;\n+\n+      while (n->alias)\n+\t{\n+\t  n = n->get_alias_target ();\n+\t  if (n == alias)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Varpool alias cannot be created (alias cycle).\\n\\n\");\n+\n+\t      return false;\n+\t    }\n+\t}\n+\n+      alias->analyzed = false;\n+\n+      DECL_INITIAL (alias->decl) = NULL;\n+      alias->remove_all_references ();\n+\n+      varpool_node::create_alias (alias_var->decl, decl);\n+      alias->resolve_alias (original);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"Varpool alias has been created.\\n\\n\");\n+\n+      return true;\n+    }\n+}\n+\n+bool\n+sem_variable::compare_sections (sem_variable *alias)\n+{\n+  const char *source = node->get_section ();\n+  const char *target = alias->node->get_section();\n+\n+  if (source == NULL && target == NULL)\n+    return true;\n+  else if(!source || !target)\n+    return false;\n+  else\n+    return strcmp (source, target) == 0;\n+}\n+\n+/* Dump symbol to FILE.  */\n+\n+void\n+sem_variable::dump_to_file (FILE *file)\n+{\n+  gcc_assert (file);\n+\n+  print_node (file, \"\", decl, 0);\n+  fprintf (file, \"\\n\\n\");\n+}\n+\n+/* Iterates though a constructor and identifies tree references\n+   we are interested in semantic function equality.  */\n+\n+void\n+sem_variable::parse_tree_refs (tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case CONSTRUCTOR:\n+      {\n+\tunsigned length = vec_safe_length (CONSTRUCTOR_ELTS (t));\n+\n+\tfor (unsigned i = 0; i < length; i++)\n+\t  parse_tree_refs(CONSTRUCTOR_ELT (t, i)->value);\n+\n+\tbreak;\n+      }\n+    case NOP_EXPR:\n+    case ADDR_EXPR:\n+      {\n+\ttree op = TREE_OPERAND (t, 0);\n+\tparse_tree_refs (op);\n+\tbreak;\n+      }\n+    case FUNCTION_DECL:\n+      {\n+\ttree_refs.safe_push (t);\n+\tbreak;\n+      }\n+    default:\n+      break;\n+    }\n+}\n+\n+unsigned int sem_item_optimizer::class_id = 0;\n+\n+sem_item_optimizer::sem_item_optimizer (): worklist (0), m_classes (0),\n+  m_classes_count (0), m_cgraph_node_hooks (NULL), m_varpool_node_hooks (NULL)\n+{\n+  m_items.create (0);\n+  bitmap_obstack_initialize (&m_bmstack);\n+}\n+\n+sem_item_optimizer::~sem_item_optimizer ()\n+{\n+  for (unsigned int i = 0; i < m_items.length (); i++)\n+    delete m_items[i];\n+\n+  for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+    {\n+      for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n+\tdelete (*it)->classes[i];\n+\n+      (*it)->classes.release ();\n+    }\n+\n+  m_items.release ();\n+\n+  bitmap_obstack_release (&m_bmstack);\n+}\n+\n+/* Write IPA ICF summary for symbols.  */\n+\n+void\n+sem_item_optimizer::write_summary (void)\n+{\n+  unsigned int count = 0;\n+\n+  output_block *ob = create_output_block (LTO_section_ipa_icf);\n+  lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n+  ob->symbol = NULL;\n+\n+  /* Calculate number of symbols to be serialized.  */\n+  for (lto_symtab_encoder_iterator lsei = lsei_start_in_partition (encoder);\n+       !lsei_end_p (lsei);\n+       lsei_next_in_partition (&lsei))\n+    {\n+      symtab_node *node = lsei_node (lsei);\n+\n+      if (m_symtab_node_map.get (node))\n+\tcount++;\n+    }\n+\n+  streamer_write_uhwi (ob, count);\n+\n+  /* Process all of the symbols.  */\n+  for (lto_symtab_encoder_iterator lsei = lsei_start_in_partition (encoder);\n+       !lsei_end_p (lsei);\n+       lsei_next_in_partition (&lsei))\n+    {\n+      symtab_node *node = lsei_node (lsei);\n+\n+      sem_item **item = m_symtab_node_map.get (node);\n+\n+      if (item && *item)\n+\t{\n+\t  int node_ref = lto_symtab_encoder_encode (encoder, node);\n+\t  streamer_write_uhwi_stream (ob->main_stream, node_ref);\n+\n+\t  streamer_write_uhwi (ob, (*item)->get_hash ());\n+\t}\n+    }\n+\n+  streamer_write_char_stream (ob->main_stream, 0);\n+  produce_asm (ob, NULL);\n+  destroy_output_block (ob);\n+}\n+\n+/* Reads a section from LTO stream file FILE_DATA. Input block for DATA\n+   contains LEN bytes.  */\n+\n+void\n+sem_item_optimizer::read_section (lto_file_decl_data *file_data,\n+\t\t\t\t  const char *data, size_t len)\n+{\n+  const lto_function_header *header =\n+    (const lto_function_header *) data;\n+  const int cfg_offset = sizeof (lto_function_header);\n+  const int main_offset = cfg_offset + header->cfg_size;\n+  const int string_offset = main_offset + header->main_size;\n+  data_in *data_in;\n+  unsigned int i;\n+  unsigned int count;\n+\n+  lto_input_block ib_main ((const char *) data + main_offset, 0,\n+\t\t\t   header->main_size);\n+\n+  data_in =\n+    lto_data_in_create (file_data, (const char *) data + string_offset,\n+\t\t\theader->string_size, vNULL);\n+\n+  count = streamer_read_uhwi (&ib_main);\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      unsigned int index;\n+      symtab_node *node;\n+      lto_symtab_encoder_t encoder;\n+\n+      index = streamer_read_uhwi (&ib_main);\n+      encoder = file_data->symtab_node_encoder;\n+      node = lto_symtab_encoder_deref (encoder, index);\n+\n+      hashval_t hash = streamer_read_uhwi (&ib_main);\n+\n+      gcc_assert (node->definition);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"Symbol added:%s (tree: %p, uid:%u)\\n\", node->asm_name (),\n+\t\t (void *) node->decl, node->order);\n+\n+      if (is_a<cgraph_node *> (node))\n+\t{\n+\t  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n+\n+\t  m_items.safe_push (new sem_function (cnode, hash, &m_bmstack));\n+\t}\n+      else\n+\t{\n+\t  varpool_node *vnode = dyn_cast <varpool_node *> (node);\n+\n+\t  m_items.safe_push (new sem_variable (vnode, hash, &m_bmstack));\n+\t}\n+    }\n+\n+  lto_free_section_data (file_data, LTO_section_ipa_icf, NULL, data,\n+\t\t\t len);\n+  lto_data_in_delete (data_in);\n+}\n+\n+/* Read IPA IPA ICF summary for symbols.  */\n+\n+void\n+sem_item_optimizer::read_summary (void)\n+{\n+  lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n+  lto_file_decl_data *file_data;\n+  unsigned int j = 0;\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      size_t len;\n+      const char *data = lto_get_section_data (file_data,\n+\t\t\t LTO_section_ipa_icf, NULL, &len);\n+\n+      if (data)\n+\tread_section (file_data, data, len);\n+    }\n+}\n+\n+/* Register callgraph and varpool hooks.  */\n+\n+void\n+sem_item_optimizer::register_hooks (void)\n+{\n+  m_cgraph_node_hooks = symtab->add_cgraph_removal_hook\n+\t\t\t(&sem_item_optimizer::cgraph_removal_hook, this);\n+\n+  m_varpool_node_hooks = symtab->add_varpool_removal_hook\n+\t\t\t (&sem_item_optimizer::varpool_removal_hook, this);\n+}\n+\n+/* Unregister callgraph and varpool hooks.  */\n+\n+void\n+sem_item_optimizer::unregister_hooks (void)\n+{\n+  if (m_cgraph_node_hooks)\n+    symtab->remove_cgraph_removal_hook (m_cgraph_node_hooks);\n+\n+  if (m_varpool_node_hooks)\n+    symtab->remove_varpool_removal_hook (m_varpool_node_hooks);\n+}\n+\n+/* Adds a CLS to hashtable associated by hash value.  */\n+\n+void\n+sem_item_optimizer::add_class (congruence_class *cls)\n+{\n+  gcc_assert (cls->members.length ());\n+\n+  congruence_class_group *group = get_group_by_hash (\n+\t\t\t\t    cls->members[0]->get_hash (),\n+\t\t\t\t    cls->members[0]->type);\n+  group->classes.safe_push (cls);\n+}\n+\n+/* Gets a congruence class group based on given HASH value and TYPE.  */\n+\n+congruence_class_group *\n+sem_item_optimizer::get_group_by_hash (hashval_t hash, sem_item_type type)\n+{\n+  congruence_class_group *item = XNEW (congruence_class_group);\n+  item->hash = hash;\n+  item->type = type;\n+\n+  congruence_class_group **slot = m_classes.find_slot (item, INSERT);\n+\n+  if (*slot)\n+    free (item);\n+  else\n+    {\n+      item->classes.create (1);\n+      *slot = item;\n+    }\n+\n+  return *slot;\n+}\n+\n+/* Callgraph removal hook called for a NODE with a custom DATA.  */\n+\n+void\n+sem_item_optimizer::cgraph_removal_hook (cgraph_node *node, void *data)\n+{\n+  sem_item_optimizer *optimizer = (sem_item_optimizer *) data;\n+  optimizer->remove_symtab_node (node);\n+}\n+\n+/* Varpool removal hook called for a NODE with a custom DATA.  */\n+\n+void\n+sem_item_optimizer::varpool_removal_hook (varpool_node *node, void *data)\n+{\n+  sem_item_optimizer *optimizer = (sem_item_optimizer *) data;\n+  optimizer->remove_symtab_node (node);\n+}\n+\n+/* Remove symtab NODE triggered by symtab removal hooks.  */\n+\n+void\n+sem_item_optimizer::remove_symtab_node (symtab_node *node)\n+{\n+  gcc_assert (!m_classes.elements());\n+\n+  m_removed_items_set.add (node);\n+}\n+\n+void\n+sem_item_optimizer::remove_item (sem_item *item)\n+{\n+  if (m_symtab_node_map.get (item->node))\n+    m_symtab_node_map.remove (item->node);\n+  delete item;\n+}\n+\n+/* Removes all callgraph and varpool nodes that are marked by symtab\n+   as deleted.  */\n+\n+void\n+sem_item_optimizer::filter_removed_items (void)\n+{\n+  auto_vec <sem_item *> filtered;\n+\n+  for (unsigned int i = 0; i < m_items.length(); i++)\n+    {\n+      sem_item *item = m_items[i];\n+\n+      if (!flag_ipa_icf_functions && item->type == FUNC)\n+\t{\n+\t  remove_item (item);\n+\t  continue;\n+\t}\n+\n+      if (!flag_ipa_icf_variables && item->type == VAR)\n+\t{\n+\t  remove_item (item);\n+\t  continue;\n+\t}\n+\n+      bool no_body_function = false;\n+\n+      if (item->type == FUNC)\n+\t{\n+\t  cgraph_node *cnode = static_cast <sem_function *>(item)->get_node ();\n+\n+\t  no_body_function = in_lto_p && (cnode->alias || cnode->body_removed);\n+\t}\n+\n+      if(!m_removed_items_set.contains (m_items[i]->node)\n+\t  && !no_body_function)\n+\t{\n+\t  if (item->type == VAR || (!DECL_CXX_CONSTRUCTOR_P (item->decl)\n+\t\t\t\t    && !DECL_CXX_DESTRUCTOR_P (item->decl)))\n+\t    {\n+\t      filtered.safe_push (m_items[i]);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      remove_item (item);\n+    }\n+\n+  /* Clean-up of released semantic items.  */\n+\n+  m_items.release ();\n+  for (unsigned int i = 0; i < filtered.length(); i++)\n+    m_items.safe_push (filtered[i]);\n+}\n+\n+/* Optimizer entry point.  */\n+\n+void\n+sem_item_optimizer::execute (void)\n+{\n+  filter_removed_items ();\n+  build_hash_based_classes ();\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Dump after hash based groups\\n\");\n+  dump_cong_classes ();\n+\n+  for (unsigned int i = 0; i < m_items.length(); i++)\n+    m_items[i]->init_wpa ();\n+\n+  build_graph ();\n+\n+  subdivide_classes_by_equality (true);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Dump after WPA based types groups\\n\");\n+\n+  dump_cong_classes ();\n+\n+  process_cong_reduction ();\n+  verify_classes ();\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Dump after callgraph-based congruence reduction\\n\");\n+\n+  dump_cong_classes ();\n+\n+  parse_nonsingleton_classes ();\n+  subdivide_classes_by_equality ();\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Dump after full equality comparison of groups\\n\");\n+\n+  dump_cong_classes ();\n+\n+  unsigned int prev_class_count = m_classes_count;\n+\n+  process_cong_reduction ();\n+  dump_cong_classes ();\n+  verify_classes ();\n+  merge_classes (prev_class_count);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    symtab_node::dump_table (dump_file);\n+}\n+\n+/* Function responsible for visiting all potential functions and\n+   read-only variables that can be merged.  */\n+\n+void\n+sem_item_optimizer::parse_funcs_and_vars (void)\n+{\n+  cgraph_node *cnode;\n+\n+  if (flag_ipa_icf_functions)\n+    FOR_EACH_DEFINED_FUNCTION (cnode)\n+    {\n+      sem_function *f = sem_function::parse (cnode, &m_bmstack);\n+      if (f)\n+\t{\n+\t  m_items.safe_push (f);\n+\t  m_symtab_node_map.put (cnode, f);\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Parsed function:%s\\n\", f->asm_name ());\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    f->dump_to_file (dump_file);\n+\t}\n+      else if (dump_file)\n+\tfprintf (dump_file, \"Not parsed function:%s\\n\", cnode->asm_name ());\n+    }\n+\n+  varpool_node *vnode;\n+\n+  if (flag_ipa_icf_variables)\n+    FOR_EACH_DEFINED_VARIABLE (vnode)\n+    {\n+      sem_variable *v = sem_variable::parse (vnode, &m_bmstack);\n+\n+      if (v)\n+\t{\n+\t  m_items.safe_push (v);\n+\t  m_symtab_node_map.put (vnode, v);\n+\t}\n+    }\n+}\n+\n+/* Makes pairing between a congruence class CLS and semantic ITEM.  */\n+\n+void\n+sem_item_optimizer::add_item_to_class (congruence_class *cls, sem_item *item)\n+{\n+  item->index_in_class = cls->members.length ();\n+  cls->members.safe_push (item);\n+  item->cls = cls;\n+}\n+\n+/* Congruence classes are built by hash value.  */\n+\n+void\n+sem_item_optimizer::build_hash_based_classes (void)\n+{\n+  for (unsigned i = 0; i < m_items.length (); i++)\n+    {\n+      sem_item *item = m_items[i];\n+\n+      congruence_class_group *group = get_group_by_hash (item->get_hash (),\n+\t\t\t\t      item->type);\n+\n+      if (!group->classes.length ())\n+\t{\n+\t  m_classes_count++;\n+\t  group->classes.safe_push (new congruence_class (class_id++));\n+\t}\n+\n+      add_item_to_class (group->classes[0], item);\n+    }\n+}\n+\n+/* Build references according to call graph.  */\n+\n+void\n+sem_item_optimizer::build_graph (void)\n+{\n+  for (unsigned i = 0; i < m_items.length (); i++)\n+    {\n+      sem_item *item = m_items[i];\n+      m_symtab_node_map.put (item->node, item);\n+    }\n+\n+  for (unsigned i = 0; i < m_items.length (); i++)\n+    {\n+      sem_item *item = m_items[i];\n+\n+      if (item->type == FUNC)\n+\t{\n+\t  cgraph_node *cnode = dyn_cast <cgraph_node *> (item->node);\n+\n+\t  cgraph_edge *e = cnode->callees;\n+\t  while (e)\n+\t    {\n+\t      sem_item **slot = m_symtab_node_map.get (e->callee);\n+\t      if (slot)\n+\t\titem->add_reference (*slot);\n+\n+\t      e = e->next_callee;\n+\t    }\n+\t}\n+\n+      ipa_ref *ref = NULL;\n+      for (unsigned i = 0; item->node->iterate_reference (i, ref); i++)\n+\t{\n+\t  sem_item **slot = m_symtab_node_map.get (ref->referred);\n+\t  if (slot)\n+\t    item->add_reference (*slot);\n+\t}\n+    }\n+}\n+\n+/* Semantic items in classes having more than one element and initialized.\n+   In case of WPA, we load function body.  */\n+\n+void\n+sem_item_optimizer::parse_nonsingleton_classes (void)\n+{\n+  unsigned int init_called_count = 0;\n+\n+  for (unsigned i = 0; i < m_items.length (); i++)\n+    if (m_items[i]->cls->members.length () > 1)\n+      {\n+\tm_items[i]->init ();\n+\tinit_called_count++;\n+      }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Init called for %u items (%.2f%%).\\n\", init_called_count,\n+\t     100.0f * init_called_count / m_items.length ());\n+}\n+\n+/* Equality function for semantic items is used to subdivide existing\n+   classes. If IN_WPA, fast equality function is invoked.  */\n+\n+void\n+sem_item_optimizer::subdivide_classes_by_equality (bool in_wpa)\n+{\n+  for (hash_table <congruence_class_group_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+    {\n+      unsigned int class_count = (*it)->classes.length ();\n+\n+      for (unsigned i = 0; i < class_count; i++)\n+\t{\n+\t  congruence_class *c = (*it)->classes [i];\n+\n+\t  if (c->members.length() > 1)\n+\t    {\n+\t      auto_vec <sem_item *> new_vector;\n+\n+\t      sem_item *first = c->members[0];\n+\t      new_vector.safe_push (first);\n+\n+\t      unsigned class_split_first = (*it)->classes.length ();\n+\n+\t      for (unsigned j = 1; j < c->members.length (); j++)\n+\t\t{\n+\t\t  sem_item *item = c->members[j];\n+\n+\t\t  bool equals = in_wpa ? first->equals_wpa (item,\n+\t\t\t\tm_symtab_node_map) : first->equals (item, m_symtab_node_map);\n+\n+\t\t  if (equals)\n+\t\t    new_vector.safe_push (item);\n+\t\t  else\n+\t\t    {\n+\t\t      bool integrated = false;\n+\n+\t\t      for (unsigned k = class_split_first; k < (*it)->classes.length (); k++)\n+\t\t\t{\n+\t\t\t  sem_item *x = (*it)->classes[k]->members[0];\n+\t\t\t  bool equals = in_wpa ? x->equals_wpa (item,\n+\t\t\t\t\t\t\t\tm_symtab_node_map) : x->equals (item, m_symtab_node_map);\n+\n+\t\t\t  if (equals)\n+\t\t\t    {\n+\t\t\t      integrated = true;\n+\t\t\t      add_item_to_class ((*it)->classes[k], item);\n+\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\n+\t\t      if (!integrated)\n+\t\t\t{\n+\t\t\t  congruence_class *c = new congruence_class (class_id++);\n+\t\t\t  m_classes_count++;\n+\t\t\t  add_item_to_class (c, item);\n+\n+\t\t\t  (*it)->classes.safe_push (c);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      // we replace newly created new_vector for the class we've just splitted\n+\t      c->members.release ();\n+\t      c->members.create (new_vector.length ());\n+\n+\t      for (unsigned int j = 0; j < new_vector.length (); j++)\n+\t\tadd_item_to_class (c, new_vector[j]);\n+\t    }\n+\t}\n+    }\n+\n+  verify_classes ();\n+}\n+\n+/* Verify congruence classes if checking is enabled.  */\n+\n+void\n+sem_item_optimizer::verify_classes (void)\n+{\n+#if ENABLE_CHECKING\n+  for (hash_table <congruence_class_group_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+    {\n+      for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n+\t{\n+\t  congruence_class *cls = (*it)->classes[i];\n+\n+\t  gcc_checking_assert (cls);\n+\t  gcc_checking_assert (cls->members.length () > 0);\n+\n+\t  for (unsigned int j = 0; j < cls->members.length (); j++)\n+\t    {\n+\t      sem_item *item = cls->members[j];\n+\n+\t      gcc_checking_assert (item);\n+\t      gcc_checking_assert (item->cls == cls);\n+\n+\t      for (unsigned k = 0; k < item->usages.length (); k++)\n+\t\t{\n+\t\t  sem_usage_pair *usage = item->usages[k];\n+\t\t  gcc_checking_assert (usage->item->index_in_class <\n+\t\t\t\t       usage->item->cls->members.length ());\n+\t\t}\n+\t    }\n+\t}\n+    }\n+#endif\n+}\n+\n+/* Disposes split map traverse function. CLS_PTR is pointer to congruence\n+   class, BSLOT is bitmap slot we want to release. DATA is mandatory,\n+   but unused argument.  */\n+\n+bool\n+sem_item_optimizer::release_split_map (congruence_class * const &,\n+\t\t\t\t       bitmap const &b, traverse_split_pair *)\n+{\n+  bitmap bmp = b;\n+\n+  BITMAP_FREE (bmp);\n+\n+  return true;\n+}\n+\n+/* Process split operation for a class given as pointer CLS_PTR,\n+   where bitmap B splits congruence class members. DATA is used\n+   as argument of split pair.  */\n+\n+bool\n+sem_item_optimizer::traverse_congruence_split (congruence_class * const &cls,\n+    bitmap const &b, traverse_split_pair *pair)\n+{\n+  sem_item_optimizer *optimizer = pair->optimizer;\n+  const congruence_class *splitter_cls = pair->cls;\n+\n+  /* If counted bits are greater than zero and less than the number of members\n+     a group will be splitted.  */\n+  unsigned popcount = bitmap_count_bits (b);\n+\n+  if (popcount > 0 && popcount < cls->members.length ())\n+    {\n+      congruence_class* newclasses[2] = { new congruence_class (class_id++), new congruence_class (class_id++) };\n+\n+      for (unsigned int i = 0; i < cls->members.length (); i++)\n+\t{\n+\t  int target = bitmap_bit_p (b, i);\n+\t  congruence_class *tc = newclasses[target];\n+\n+\t  add_item_to_class (tc, cls->members[i]);\n+\t}\n+\n+#ifdef ENABLE_CHECKING\n+      for (unsigned int i = 0; i < 2; i++)\n+\tgcc_checking_assert (newclasses[i]->members.length ());\n+#endif\n+\n+      if (splitter_cls == cls)\n+\toptimizer->splitter_class_removed = true;\n+\n+      /* Remove old class from worklist if presented.  */\n+      bool in_worklist = cls->in_worklist;\n+\n+      if (in_worklist)\n+\tcls->in_worklist = false;\n+\n+      congruence_class_group g;\n+      g.hash = cls->members[0]->get_hash ();\n+      g.type = cls->members[0]->type;\n+\n+      congruence_class_group *slot = optimizer->m_classes.find(&g);\n+\n+      for (unsigned int i = 0; i < slot->classes.length (); i++)\n+\tif (slot->classes[i] == cls)\n+\t  {\n+\t    slot->classes.ordered_remove (i);\n+\t    break;\n+\t  }\n+\n+      /* New class will be inserted and integrated to work list.  */\n+      for (unsigned int i = 0; i < 2; i++)\n+\toptimizer->add_class (newclasses[i]);\n+\n+      /* Two classes replace one, so that increment just by one.  */\n+      optimizer->m_classes_count++;\n+\n+      /* If OLD class was presented in the worklist, we remove the class\n+         and replace it will both newly created classes.  */\n+      if (in_worklist)\n+\tfor (unsigned int i = 0; i < 2; i++)\n+\t  optimizer->worklist_push (newclasses[i]);\n+      else /* Just smaller class is inserted.  */\n+\t{\n+\t  unsigned int smaller_index = newclasses[0]->members.length () <\n+\t\t\t\t       newclasses[1]->members.length () ?\n+\t\t\t\t       0 : 1;\n+\t  optimizer->worklist_push (newclasses[smaller_index]);\n+\t}\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"  congruence class splitted:\\n\");\n+\t  cls->dump (dump_file, 4);\n+\n+\t  fprintf (dump_file, \"  newly created groups:\\n\");\n+\t  for (unsigned int i = 0; i < 2; i++)\n+\t    newclasses[i]->dump (dump_file, 4);\n+\t}\n+\n+      /* Release class if not presented in work list.  */\n+      if (!in_worklist)\n+\tdelete cls;\n+    }\n+\n+\n+  return true;\n+}\n+\n+/* Tests if a class CLS used as INDEXth splits any congruence classes.\n+   Bitmap stack BMSTACK is used for bitmap allocation.  */\n+\n+void\n+sem_item_optimizer::do_congruence_step_for_index (congruence_class *cls,\n+    unsigned int index)\n+{\n+  hash_map <congruence_class *, bitmap> split_map;\n+\n+  for (unsigned int i = 0; i < cls->members.length (); i++)\n+    {\n+      sem_item *item = cls->members[i];\n+\n+      /* Iterate all usages that have INDEX as usage of the item.  */\n+      for (unsigned int j = 0; j < item->usages.length (); j++)\n+\t{\n+\t  sem_usage_pair *usage = item->usages[j];\n+\n+\t  if (usage->index != index)\n+\t    continue;\n+\n+\t  bitmap *slot = split_map.get (usage->item->cls);\n+\t  bitmap b;\n+\n+\t  if(!slot)\n+\t    {\n+\t      b = BITMAP_ALLOC (&m_bmstack);\n+\t      split_map.put (usage->item->cls, b);\n+\t    }\n+\t  else\n+\t    b = *slot;\n+\n+#if ENABLE_CHECKING\n+\t  gcc_checking_assert (usage->item->cls);\n+\t  gcc_checking_assert (usage->item->index_in_class <\n+\t\t\t       usage->item->cls->members.length ());\n+#endif\n+\n+\t  bitmap_set_bit (b, usage->item->index_in_class);\n+\t}\n+    }\n+\n+  traverse_split_pair pair;\n+  pair.optimizer = this;\n+  pair.cls = cls;\n+\n+  splitter_class_removed = false;\n+  split_map.traverse\n+  <traverse_split_pair *, sem_item_optimizer::traverse_congruence_split> (&pair);\n+\n+  /* Bitmap clean-up.  */\n+  split_map.traverse\n+  <traverse_split_pair *, sem_item_optimizer::release_split_map> (NULL);\n+}\n+\n+/* Every usage of a congruence class CLS is a candidate that can split the\n+   collection of classes. Bitmap stack BMSTACK is used for bitmap\n+   allocation.  */\n+\n+void\n+sem_item_optimizer::do_congruence_step (congruence_class *cls)\n+{\n+  bitmap_iterator bi;\n+  unsigned int i;\n+\n+  bitmap usage = BITMAP_ALLOC (&m_bmstack);\n+\n+  for (unsigned int i = 0; i < cls->members.length (); i++)\n+    bitmap_ior_into (usage, cls->members[i]->usage_index_bitmap);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (usage, 0, i, bi)\n+  {\n+    if (dump_file && (dump_flags & TDF_DETAILS))\n+      fprintf (dump_file, \"  processing congruece step for class: %u, index: %u\\n\",\n+\t       cls->id, i);\n+\n+    do_congruence_step_for_index (cls, i);\n+\n+    if (splitter_class_removed)\n+      break;\n+  }\n+\n+  BITMAP_FREE (usage);\n+}\n+\n+/* Adds a newly created congruence class CLS to worklist.  */\n+\n+void\n+sem_item_optimizer::worklist_push (congruence_class *cls)\n+{\n+  /* Return if the class CLS is already presented in work list.  */\n+  if (cls->in_worklist)\n+    return;\n+\n+  cls->in_worklist = true;\n+  worklist.push_back (cls);\n+}\n+\n+/* Pops a class from worklist. */\n+\n+congruence_class *\n+sem_item_optimizer::worklist_pop (void)\n+{\n+  congruence_class *cls;\n+\n+  while (!worklist.empty ())\n+    {\n+      cls = worklist.front ();\n+      worklist.pop_front ();\n+      if (cls->in_worklist)\n+\t{\n+\t  cls->in_worklist = false;\n+\n+\t  return cls;\n+\t}\n+      else\n+\t{\n+\t  /* Work list item was already intended to be removed.\n+\t     The only reason for doing it is to split a class.\n+\t     Thus, the class CLS is deleted.  */\n+\t  delete cls;\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Iterative congruence reduction function.  */\n+\n+void\n+sem_item_optimizer::process_cong_reduction (void)\n+{\n+  for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+    for (unsigned i = 0; i < (*it)->classes.length (); i++)\n+      if ((*it)->classes[i]->is_class_used ())\n+\tworklist_push ((*it)->classes[i]);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Worklist has been filled with: %lu\\n\",\n+\t     worklist.size ());\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Congruence class reduction\\n\");\n+\n+  congruence_class *cls;\n+  while ((cls = worklist_pop ()) != NULL)\n+    do_congruence_step (cls);\n+}\n+\n+/* Debug function prints all informations about congruence classes.  */\n+\n+void\n+sem_item_optimizer::dump_cong_classes (void)\n+{\n+  if (!dump_file)\n+    return;\n+\n+  fprintf (dump_file,\n+\t   \"Congruence classes: %u (unique hash values: %lu), with total: %u items\\n\",\n+\t   m_classes_count, m_classes.elements(), m_items.length ());\n+\n+  /* Histogram calculation.  */\n+  unsigned int max_index = 0;\n+  unsigned int* histogram = XCNEWVEC (unsigned int, m_items.length () + 1);\n+\n+  for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+\n+    for (unsigned i = 0; i < (*it)->classes.length (); i++)\n+      {\n+\tunsigned int c = (*it)->classes[i]->members.length ();\n+\thistogram[c]++;\n+\n+\tif (c > max_index)\n+\t  max_index = c;\n+      }\n+\n+  fprintf (dump_file,\n+\t   \"Class size histogram [num of members]: number of classe number of classess\\n\");\n+\n+  for (unsigned int i = 0; i <= max_index; i++)\n+    if (histogram[i])\n+      fprintf (dump_file, \"[%u]: %u classes\\n\", i, histogram[i]);\n+\n+  fprintf (dump_file, \"\\n\\n\");\n+\n+\n+  if (dump_flags & TDF_DETAILS)\n+    for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n+\t it != m_classes.end (); ++it)\n+      {\n+\tfprintf (dump_file, \"  group: with %u classes:\\n\", (*it)->classes.length ());\n+\n+\tfor (unsigned i = 0; i < (*it)->classes.length (); i++)\n+\t  {\n+\t    (*it)->classes[i]->dump (dump_file, 4);\n+\n+\t    if(i < (*it)->classes.length () - 1)\n+\t      fprintf (dump_file, \" \");\n+\t  }\n+      }\n+\n+  free (histogram);\n+}\n+\n+/* After reduction is done, we can declare all items in a group\n+   to be equal. PREV_CLASS_COUNT is start number of classes\n+   before reduction.  */\n+\n+void\n+sem_item_optimizer::merge_classes (unsigned int prev_class_count)\n+{\n+  unsigned int item_count = m_items.length ();\n+  unsigned int class_count = m_classes_count;\n+  unsigned int equal_items = item_count - class_count;\n+\n+  unsigned int non_singular_classes_count = 0;\n+  unsigned int non_singular_classes_sum = 0;\n+\n+  for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+    for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n+      {\n+\tcongruence_class *c = (*it)->classes[i];\n+\tif (c->members.length () > 1)\n+\t  {\n+\t    non_singular_classes_count++;\n+\t    non_singular_classes_sum += c->members.length ();\n+\t  }\n+      }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nItem count: %u\\n\", item_count);\n+      fprintf (dump_file, \"Congruent classes before: %u, after: %u\\n\",\n+\t       prev_class_count, class_count);\n+      fprintf (dump_file, \"Average class size before: %.2f, after: %.2f\\n\",\n+\t       1.0f * item_count / prev_class_count,\n+\t       1.0f * item_count / class_count);\n+      fprintf (dump_file, \"Average non-singular class size: %.2f, count: %u\\n\",\n+\t       1.0f * non_singular_classes_sum / non_singular_classes_count,\n+\t       non_singular_classes_count);\n+      fprintf (dump_file, \"Equal symbols: %u\\n\", equal_items);\n+      fprintf (dump_file, \"Fraction of visited symbols: %.2f%%\\n\\n\",\n+\t       100.0f * equal_items / item_count);\n+    }\n+\n+  for (hash_table<congruence_class_group_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+    for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n+      {\n+\tcongruence_class *c = (*it)->classes[i];\n+\n+\tif (c->members.length () == 1)\n+\t  continue;\n+\n+\tgcc_assert (c->members.length ());\n+\n+\tsem_item *source = c->members[0];\n+\n+\tfor (unsigned int j = 1; j < c->members.length (); j++)\n+\t  {\n+\t    sem_item *alias = c->members[j];\n+\t    source->equals (alias, m_symtab_node_map);\n+\n+\t    if (dump_file)\n+\t      {\n+\t\tfprintf (dump_file, \"Semantic equality hit:%s->%s\\n\",\n+\t\t\t source->name (), alias->name ());\n+\t\tfprintf (dump_file, \"Assembler symbol names:%s->%s\\n\",\n+\t\t\t source->asm_name (), alias->asm_name ());\n+\t      }\n+\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      {\n+\t\tsource->dump_to_file (dump_file);\n+\t\talias->dump_to_file (dump_file);\n+\t      }\n+\n+\t    source->merge (alias);\n+\t  }\n+      }\n+}\n+\n+/* Dump function prints all class members to a FILE with an INDENT.  */\n+\n+void\n+congruence_class::dump (FILE *file, unsigned int indent) const\n+{\n+  FPRINTF_SPACES (file, indent, \"class with id: %u, hash: %u, items: %u\\n\",\n+\t\t  id, members[0]->get_hash (), members.length ());\n+\n+  FPUTS_SPACES (file, indent + 2, \"\");\n+  for (unsigned i = 0; i < members.length (); i++)\n+    fprintf (file, \"%s(%p/%u) \", members[i]->asm_name (), (void *) members[i]->decl,\n+\t     members[i]->node->order);\n+\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* Returns true if there's a member that is used from another group.  */\n+\n+bool\n+congruence_class::is_class_used (void)\n+{\n+  for (unsigned int i = 0; i < members.length (); i++)\n+    if (members[i]->usages.length ())\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Initialization and computation of symtab node hash, there data\n+   are propagated later on.  */\n+\n+static sem_item_optimizer *optimizer = NULL;\n+\n+/* Generate pass summary for IPA ICF pass.  */\n+\n+static void\n+ipa_icf_generate_summary (void)\n+{\n+  if (!optimizer)\n+    optimizer = new sem_item_optimizer ();\n+\n+  optimizer->parse_funcs_and_vars ();\n+}\n+\n+/* Write pass summary for IPA ICF pass.  */\n+\n+static void\n+ipa_icf_write_summary (void)\n+{\n+  gcc_assert (optimizer);\n+\n+  optimizer->write_summary ();\n+}\n+\n+/* Read pass summary for IPA ICF pass.  */\n+\n+static void\n+ipa_icf_read_summary (void)\n+{\n+  if (!optimizer)\n+    optimizer = new sem_item_optimizer ();\n+\n+  optimizer->read_summary ();\n+  optimizer->register_hooks ();\n+}\n+\n+/* Semantic equality exection function.  */\n+\n+static unsigned int\n+ipa_icf_driver (void)\n+{\n+  gcc_assert (optimizer);\n+\n+  optimizer->execute ();\n+  optimizer->unregister_hooks ();\n+\n+  delete optimizer;\n+\n+  return 0;\n+}\n+\n+const pass_data pass_data_ipa_icf =\n+{\n+  IPA_PASS,\t\t    /* type */\n+  \"icf\",\t\t    /* name */\n+  OPTGROUP_IPA,             /* optinfo_flags */\n+  TV_IPA_ICF,\t\t    /* tv_id */\n+  0,                        /* properties_required */\n+  0,                        /* properties_provided */\n+  0,                        /* properties_destroyed */\n+  0,                        /* todo_flags_start */\n+  0,                        /* todo_flags_finish */\n+};\n+\n+class pass_ipa_icf : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_icf (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_icf, ctxt,\n+\t\t      ipa_icf_generate_summary, /* generate_summary */\n+\t\t      ipa_icf_write_summary, /* write_summary */\n+\t\t      ipa_icf_read_summary, /* read_summary */\n+\t\t      NULL, /*\n+\t\t      write_optimization_summary */\n+\t\t      NULL, /*\n+\t\t      read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+  {\n+    return flag_ipa_icf_variables || flag_ipa_icf_functions;\n+  }\n+\n+  virtual unsigned int execute (function *)\n+  {\n+    return ipa_icf_driver();\n+  }\n+}; // class pass_ipa_icf\n+\n+} // ipa_icf namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_icf (gcc::context *ctxt)\n+{\n+  return new ipa_icf::pass_ipa_icf (ctxt);\n+}"}, {"sha": "d8e7b163a166667053fa3a37c148f674d760c708", "filename": "gcc/ipa-icf.h", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -0,0 +1,553 @@\n+/* Interprocedural semantic function equality pass\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   Contributed by Jan Hubicka <hubicka@ucw.cz> and Martin Liska <mliska@suse.cz>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+namespace ipa_icf {\n+class sem_item;\n+\n+/* Congruence class encompasses a collection of either functions or\n+   read-only variables. These items are considered to be equivalent\n+   if not proved the oposite.  */\n+class congruence_class\n+{\n+public:\n+  /* Congruence class constructor for a new class with _ID.  */\n+  congruence_class (unsigned int _id): in_worklist (false), id(_id)\n+  {\n+  }\n+\n+  /* Destructor.  */\n+  ~congruence_class ()\n+  {\n+  }\n+\n+  /* Dump function prints all class members to a FILE with an INDENT.  */\n+  void dump (FILE *file, unsigned int indent = 0) const;\n+\n+  /* Returns true if there's a member that is used from another group.  */\n+  bool is_class_used (void);\n+\n+  /* Flag is used in case we want to remove a class from worklist and\n+     delete operation is quite expensive for\n+     the data structure (linked list).  */\n+  bool in_worklist;\n+\n+  /* Vector of all group members.  */\n+  auto_vec <sem_item *> members;\n+\n+  /* Global unique class identifier.  */\n+  unsigned int id;\n+};\n+\n+/* Semantic item type enum.  */\n+enum sem_item_type\n+{\n+  FUNC,\n+  VAR\n+};\n+\n+/* Semantic item usage pair.  */\n+class sem_usage_pair\n+{\n+public:\n+  /* Constructor for key value pair, where _ITEM is key and _INDEX is a target.  */\n+  sem_usage_pair (sem_item *_item, unsigned int _index);\n+\n+  /* Target semantic item where an item is used.  */\n+  sem_item *item;\n+\n+  /* Index of usage of such an item.  */\n+  unsigned int index;\n+};\n+\n+/* Semantic item is a base class that encapsulates all shared functionality\n+   for both semantic function and variable items.  */\n+class sem_item\n+{\n+public:\n+  /* Semantic item constructor for a node of _TYPE, where STACK is used\n+     for bitmap memory allocation.  */\n+  sem_item (sem_item_type _type, bitmap_obstack *stack);\n+\n+  /* Semantic item constructor for a node of _TYPE, where STACK is used\n+     for bitmap memory allocation. The item is based on symtab node _NODE\n+     with computed _HASH.  */\n+  sem_item (sem_item_type _type, symtab_node *_node, hashval_t _hash,\n+\t    bitmap_obstack *stack);\n+\n+  virtual ~sem_item ();\n+\n+  /* Dump function for debugging purpose.  */\n+  DEBUG_FUNCTION void dump (void);\n+\n+  /* Initialize semantic item by info reachable during LTO WPA phase.  */\n+  virtual void init_wpa (void) = 0;\n+\n+  /* Semantic item initialization function.  */\n+  virtual void init (void) = 0;\n+\n+  /* Add reference to a semantic TARGET.  */\n+  void add_reference (sem_item *target);\n+\n+  /* Gets symbol name of the item.  */\n+  const char *name (void)\n+  {\n+    return node->name ();\n+  }\n+\n+  /* Gets assembler name of the item.  */\n+  const char *asm_name (void)\n+  {\n+    return node->asm_name ();\n+  }\n+\n+  /* Fast equality function based on knowledge known in WPA.  */\n+  virtual bool equals_wpa (sem_item *item,\n+\t\t\t   hash_map <symtab_node *, sem_item *> &ignored_nodes) = 0;\n+\n+  /* Returns true if the item equals to ITEM given as arguemnt.  */\n+  virtual bool equals (sem_item *item,\n+\t\t       hash_map <symtab_node *, sem_item *> &ignored_nodes) = 0;\n+\n+  /* References independent hash function.  */\n+  virtual hashval_t get_hash (void) = 0;\n+\n+  /* Merges instance with an ALIAS_ITEM, where alias, thunk or redirection can\n+     be applied.  */\n+  virtual bool merge (sem_item *alias_item) = 0;\n+\n+  /* Dump symbol to FILE.  */\n+  virtual void dump_to_file (FILE *file) = 0;\n+\n+  /* Return base tree that can be used for compatible_types_p and\n+     contains_polymorphic_type_p comparison.  */\n+\n+  static bool get_base_types (tree *t1, tree *t2);\n+\n+  /* Item type.  */\n+  sem_item_type type;\n+\n+  /* Symtab node.  */\n+  symtab_node *node;\n+\n+  /* Declaration tree node.  */\n+  tree decl;\n+\n+  /* Semantic references used that generate congruence groups.  */\n+  vec <sem_item *> refs;\n+\n+  /* Pointer to a congruence class the item belongs to.  */\n+  congruence_class *cls;\n+\n+  /* Index of the item in a class belonging to.  */\n+  unsigned int index_in_class;\n+\n+  /* List of semantic items where the instance is used.  */\n+  vec <sem_usage_pair *> usages;\n+\n+  /* A bitmap with indices of all classes referencing this item.  */\n+  bitmap usage_index_bitmap;\n+\n+  /* List of tree references (either FUNC_DECL or VAR_DECL).  */\n+  vec <tree> tree_refs;\n+\n+  /* A set with symbol table references.  */\n+  hash_set <symtab_node *> refs_set;\n+\n+protected:\n+  /* Cached, once calculated hash for the item.  */\n+  hashval_t hash;\n+\n+private:\n+  /* Initialize internal data structures. Bitmap STACK is used for\n+     bitmap memory allocation process.  */\n+  void setup (bitmap_obstack *stack);\n+}; // class sem_item\n+\n+class sem_function: public sem_item\n+{\n+public:\n+  /* Semantic function constructor that uses STACK as bitmap memory stack.  */\n+  sem_function (bitmap_obstack *stack);\n+\n+  /*  Constructor based on callgraph node _NODE with computed hash _HASH.\n+      Bitmap STACK is used for memory allocation.  */\n+  sem_function (cgraph_node *_node, hashval_t _hash, bitmap_obstack *stack);\n+\n+  ~sem_function ();\n+\n+  inline virtual void init_wpa (void)\n+  {\n+    parse_tree_args ();\n+  }\n+\n+  virtual void init (void);\n+  virtual bool equals_wpa (sem_item *item,\n+\t\t\t   hash_map <symtab_node *, sem_item *> &ignored_nodes);\n+  virtual hashval_t get_hash (void);\n+  virtual bool equals (sem_item *item,\n+\t\t       hash_map <symtab_node *, sem_item *> &ignored_nodes);\n+  virtual bool merge (sem_item *alias_item);\n+\n+  /* Dump symbol to FILE.  */\n+  virtual void dump_to_file (FILE *file)\n+  {\n+    gcc_assert (file);\n+    dump_function_to_file (decl, file, TDF_DETAILS);\n+  }\n+\n+  /* Parses function arguments and result type.  */\n+  void parse_tree_args (void);\n+\n+  /* Returns cgraph_node.  */\n+  inline cgraph_node *get_node (void)\n+  {\n+    return dyn_cast <cgraph_node *> (node);\n+  }\n+\n+  /* Improve accumulated hash for HSTATE based on a gimple statement STMT.  */\n+  void hash_stmt (inchash::hash *inchash, gimple stmt);\n+\n+  /* Return true if polymorphic comparison must be processed.  */\n+  bool compare_polymorphic_p (void);\n+\n+  /* For a given call graph NODE, the function constructs new\n+     semantic function item.  */\n+  static sem_function *parse (cgraph_node *node, bitmap_obstack *stack);\n+\n+  /* Exception handling region tree.  */\n+  eh_region region_tree;\n+\n+  /* Result type tree node.  */\n+  tree result_type;\n+\n+  /* Array of argument tree types.  */\n+  vec <tree> arg_types;\n+\n+  /* Number of function arguments.  */\n+  unsigned int arg_count;\n+\n+  /* Total amount of edges in the function.  */\n+  unsigned int edge_count;\n+\n+  /* Vector of sizes of all basic blocks.  */\n+  vec <unsigned int> bb_sizes;\n+\n+  /* Control flow graph checksum.  */\n+  hashval_t cfg_checksum;\n+\n+  /* GIMPLE codes hash value.  */\n+  hashval_t gcode_hash;\n+\n+  /* Total number of SSA names used in the function.  */\n+  unsigned ssa_names_size;\n+\n+  /* Array of structures for all basic blocks.  */\n+  vec <ipa_icf_gimple::sem_bb *> bb_sorted;\n+\n+private:\n+  /* Calculates hash value based on a BASIC_BLOCK.  */\n+  hashval_t get_bb_hash (const ipa_icf_gimple::sem_bb *basic_block);\n+\n+  /* For given basic blocks BB1 and BB2 (from functions FUNC1 and FUNC),\n+     true value is returned if phi nodes are semantically\n+     equivalent in these blocks .  */\n+  bool compare_phi_node (basic_block bb1, basic_block bb2);\n+\n+  /* Basic blocks dictionary BB_DICT returns true if SOURCE index BB\n+     corresponds to TARGET.  */\n+  bool bb_dict_test (int* bb_dict, int source, int target);\n+\n+  /* Iterates all tree types in T1 and T2 and returns true if all types\n+     are compatible. If COMPARE_POLYMORPHIC is set to true,\n+     more strict comparison is executed.  */\n+  bool compare_type_list (tree t1, tree t2, bool compare_polymorphic);\n+\n+  /* If cgraph edges E1 and E2 are indirect calls, verify that\n+     ICF flags are the same.  */\n+  bool compare_edge_flags (cgraph_edge *e1, cgraph_edge *e2);\n+\n+  /* For a given symbol table nodes N1 and N2, we check that FUNCTION_DECLs\n+     point to a same function. Comparison can be skipped if IGNORED_NODES\n+     contains these nodes.  */\n+  bool compare_cgraph_references (hash_map <symtab_node *, sem_item *>\n+\t\t\t\t  &ignored_nodes,\n+\t\t\t\t  symtab_node *n1, symtab_node *n2);\n+\n+  /* Processes function equality comparison.  */\n+  bool equals_private (sem_item *item,\n+\t\t       hash_map <symtab_node *, sem_item *> &ignored_nodes);\n+\n+  /* Returns true if tree T can be compared as a handled component.  */\n+  static bool icf_handled_component_p (tree t);\n+\n+  /* Function checker stores binding between functions.   */\n+  ipa_icf_gimple::func_checker *m_checker;\n+\n+  /* COMPARED_FUNC is a function that we compare to.  */\n+  sem_function *m_compared_func;\n+}; // class sem_function\n+\n+class sem_variable: public sem_item\n+{\n+public:\n+  /* Semantic variable constructor that uses STACK as bitmap memory stack.  */\n+  sem_variable (bitmap_obstack *stack);\n+\n+  /*  Constructor based on callgraph node _NODE with computed hash _HASH.\n+      Bitmap STACK is used for memory allocation.  */\n+\n+  sem_variable (varpool_node *_node, hashval_t _hash, bitmap_obstack *stack);\n+\n+  inline virtual void init_wpa (void) {}\n+\n+  /* Semantic variable initialization function.  */\n+  inline virtual void init (void)\n+  {\n+    decl = get_node ()->decl;\n+    ctor = ctor_for_folding (decl);\n+  }\n+\n+  virtual hashval_t get_hash (void);\n+  virtual bool merge (sem_item *alias_item);\n+  virtual void dump_to_file (FILE *file);\n+  virtual bool equals (sem_item *item,\n+\t\t       hash_map <symtab_node *, sem_item *> &ignored_nodes);\n+\n+  /* Fast equality variable based on knowledge known in WPA.  */\n+  inline virtual bool equals_wpa (sem_item *item,\n+\t\t\t\t  hash_map <symtab_node *, sem_item *> & ARG_UNUSED(ignored_nodes))\n+  {\n+    gcc_assert (item->type == VAR);\n+    return true;\n+  }\n+\n+  /* Returns varpool_node.  */\n+  inline varpool_node *get_node (void)\n+  {\n+    return dyn_cast <varpool_node *> (node);\n+  }\n+\n+  /* Parser function that visits a varpool NODE.  */\n+  static sem_variable *parse (varpool_node *node, bitmap_obstack *stack);\n+\n+  /* Variable constructor.  */\n+  tree ctor;\n+\n+private:\n+  /* Iterates though a constructor and identifies tree references\n+     we are interested in semantic function equality.  */\n+  void parse_tree_refs (tree t);\n+\n+  /* Compares trees T1 and T2 for semantic equality.  */\n+  static bool equals (tree t1, tree t2);\n+\n+  /* Compare that symbol sections are either NULL or have same name.  */\n+  bool compare_sections (sem_variable *alias);\n+\n+}; // class sem_variable\n+\n+class sem_item_optimizer;\n+\n+struct congruence_class_group\n+{\n+  hashval_t hash;\n+  sem_item_type type;\n+  vec <congruence_class *> classes;\n+};\n+\n+/* Congruence class set structure.  */\n+struct congruence_class_group_hash: typed_noop_remove <congruence_class_group>\n+{\n+  typedef congruence_class_group value_type;\n+  typedef congruence_class_group compare_type;\n+\n+  static inline hashval_t hash (const value_type *item)\n+  {\n+    return item->hash;\n+  }\n+\n+  static inline int equal (const value_type *item1, const compare_type *item2)\n+  {\n+    return item1->hash == item2->hash && item1->type == item2->type;\n+  }\n+};\n+\n+struct traverse_split_pair\n+{\n+  sem_item_optimizer *optimizer;\n+  class congruence_class *cls;\n+};\n+\n+/* Semantic item optimizer includes all top-level logic\n+   related to semantic equality comparison.  */\n+class sem_item_optimizer\n+{\n+public:\n+  sem_item_optimizer ();\n+  ~sem_item_optimizer ();\n+\n+  /* Function responsible for visiting all potential functions and\n+     read-only variables that can be merged.  */\n+  void parse_funcs_and_vars (void);\n+\n+  /* Optimizer entry point.  */\n+  void execute (void);\n+\n+  /* Dump function. */\n+  void dump (void);\n+\n+  /* Verify congruence classes if checking is enabled.  */\n+  void verify_classes (void);\n+\n+  /* Write IPA ICF summary for symbols.  */\n+  void write_summary (void);\n+\n+  /* Read IPA IPA ICF summary for symbols.  */\n+  void read_summary (void);\n+\n+  /* Callgraph removal hook called for a NODE with a custom DATA.  */\n+  static void cgraph_removal_hook (cgraph_node *node, void *data);\n+\n+  /* Varpool removal hook called for a NODE with a custom DATA.  */\n+  static void varpool_removal_hook (varpool_node *node, void *data);\n+\n+  /* Worklist of congruence classes that can potentially\n+     refine classes of congruence.  */\n+  std::list<congruence_class *> worklist;\n+\n+  /* Remove semantic ITEM and release memory.  */\n+  void remove_item (sem_item *item);\n+\n+  /* Remove symtab NODE triggered by symtab removal hooks.  */\n+  void remove_symtab_node (symtab_node *node);\n+\n+  /* Register callgraph and varpool hooks.  */\n+  void register_hooks (void);\n+\n+  /* Unregister callgraph and varpool hooks.  */\n+  void unregister_hooks (void);\n+\n+  /* Adds a CLS to hashtable associated by hash value.  */\n+  void add_class (congruence_class *cls);\n+\n+  /* Gets a congruence class group based on given HASH value and TYPE.  */\n+  congruence_class_group *get_group_by_hash (hashval_t hash,\n+      sem_item_type type);\n+\n+private:\n+\n+  /* Congruence classes are built by hash value.  */\n+  void build_hash_based_classes (void);\n+\n+  /* Semantic items in classes having more than one element and initialized.\n+     In case of WPA, we load function body.  */\n+  void parse_nonsingleton_classes (void);\n+\n+  /* Equality function for semantic items is used to subdivide existing\n+     classes. If IN_WPA, fast equality function is invoked.  */\n+  void subdivide_classes_by_equality (bool in_wpa = false);\n+\n+  /* Debug function prints all informations about congruence classes.  */\n+  void dump_cong_classes (void);\n+\n+  /* Build references according to call graph.  */\n+  void build_graph (void);\n+\n+  /* Iterative congruence reduction function.  */\n+  void process_cong_reduction (void);\n+\n+  /* After reduction is done, we can declare all items in a group\n+     to be equal. PREV_CLASS_COUNT is start number of classes\n+     before reduction.  */\n+  void merge_classes (unsigned int prev_class_count);\n+\n+  /* Adds a newly created congruence class CLS to worklist.  */\n+  void worklist_push (congruence_class *cls);\n+\n+  /* Pops a class from worklist. */\n+  congruence_class *worklist_pop ();\n+\n+  /* Every usage of a congruence class CLS is a candidate that can split the\n+     collection of classes. Bitmap stack BMSTACK is used for bitmap\n+     allocation.  */\n+  void do_congruence_step (congruence_class *cls);\n+\n+  /* Tests if a class CLS used as INDEXth splits any congruence classes.\n+     Bitmap stack BMSTACK is used for bitmap allocation.  */\n+  void do_congruence_step_for_index (congruence_class *cls, unsigned int index);\n+\n+  /* Makes pairing between a congruence class CLS and semantic ITEM.  */\n+  static void add_item_to_class (congruence_class *cls, sem_item *item);\n+\n+  /* Disposes split map traverse function. CLS is congruence\n+     class, BSLOT is bitmap slot we want to release. DATA is mandatory,\n+     but unused argument.  */\n+  static bool release_split_map (congruence_class * const &cls, bitmap const &b,\n+\t\t\t\t traverse_split_pair *pair);\n+\n+  /* Process split operation for a cognruence class CLS,\n+     where bitmap B splits congruence class members. DATA is used\n+     as argument of split pair.  */\n+  static bool traverse_congruence_split (congruence_class * const &cls,\n+\t\t\t\t\t bitmap const &b,\n+\t\t\t\t\t traverse_split_pair *pair);\n+\n+  /* Reads a section from LTO stream file FILE_DATA. Input block for DATA\n+     contains LEN bytes.  */\n+  void read_section (lto_file_decl_data *file_data, const char *data,\n+\t\t     size_t len);\n+\n+  /* Removes all callgraph and varpool nodes that are marked by symtab\n+     as deleted.  */\n+  void filter_removed_items (void);\n+\n+  /* Vector of semantic items.  */\n+  vec <sem_item *> m_items;\n+\n+  /* A set containing all items removed by hooks.  */\n+  hash_set <symtab_node *> m_removed_items_set;\n+\n+  /* Hashtable of congruence classes */\n+  hash_table <congruence_class_group_hash> m_classes;\n+\n+  /* Count of congruence classes.  */\n+  unsigned int m_classes_count;\n+\n+  /* Map data structure maps symtab nodes to semantic items.  */\n+  hash_map <symtab_node *, sem_item *> m_symtab_node_map;\n+\n+  /* Set to true if a splitter class is removed.  */\n+  bool splitter_class_removed;\n+\n+  /* Global unique class id counter.  */\n+  static unsigned int class_id;\n+\n+  /* Callgraph node removal hook holder.  */\n+  cgraph_node_hook_list *m_cgraph_node_hooks;\n+\n+  /* Varpool node removal hook holder.  */\n+  varpool_node_hook_list *m_varpool_node_hooks;\n+\n+  /* Bitmap stack.  */\n+  bitmap_obstack m_bmstack;\n+}; // class sem_item_optimizer\n+\n+} // ipa_icf namespace"}, {"sha": "136fc86420e02539bec880dd9a0a76ecb86a9d29", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -540,6 +540,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n   bp_pack_value (&bp, node->tm_clone, 1);\n   bp_pack_value (&bp, node->calls_comdat_local, 1);\n+  bp_pack_value (&bp, node->icf_merged, 1);\n   bp_pack_value (&bp, node->thunk.thunk_p && !boundary_p, 1);\n   bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n \t        LDPR_NUM_KNOWN, node->resolution);\n@@ -1080,6 +1081,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->only_called_at_exit = bp_unpack_value (bp, 1);\n   node->tm_clone = bp_unpack_value (bp, 1);\n   node->calls_comdat_local = bp_unpack_value (bp, 1);\n+  node->icf_merged = bp_unpack_value (bp, 1);\n   node->thunk.thunk_p = bp_unpack_value (bp, 1);\n   node->resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n \t\t\t\t     LDPR_NUM_KNOWN);"}, {"sha": "c053545b506ba9f0b1d597c6e6bebfe7789607ba", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -60,7 +60,8 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"opts\",\n   \"cgraphopt\",\n   \"inline\",\n-  \"ipcp_trans\"\n+  \"ipcp_trans\",\n+  \"icf\"\n };\n \n "}, {"sha": "63e4b32d8e53a34d6f69a2a2a54cb8f9873b1fb2", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -247,6 +247,7 @@ enum lto_section_type\n   LTO_section_cgraph_opt_sum,\n   LTO_section_inline_summary,\n   LTO_section_ipcp_transform,\n+  LTO_section_ipa_icf,\n   LTO_N_SECTION_TYPES\t\t/* Must be last.  */\n };\n "}, {"sha": "dc8ddf4cd37c56a0cf30a6fb26f93b77c8c432f0", "filename": "gcc/opts.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -497,6 +497,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_fvect_cost_model_, NULL, VECT_COST_MODEL_CHEAP },\n     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_foptimize_strlen, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fhoist_adjacent_loads, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_fipa_icf, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fisolate_erroneous_paths_dereference, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fuse_caller_save, NULL, 1 },\n \n@@ -1980,6 +1981,11 @@ common_handle_option (struct gcc_options *opts,\n \topts->x_flag_wrapv = 0;\n       break;\n \n+    case OPT_fipa_icf:\n+\topts->x_flag_ipa_icf_functions = value;\n+\topts->x_flag_ipa_icf_variables = value;\n+      break;\n+\n     default:\n       /* If the flag was handled in a standard way, assume the lack of\n \t processing here is intentional.  */"}, {"sha": "57c2c1343b199d04c92e85c14126349d2f750532", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -103,6 +103,7 @@ along with GCC; see the file COPYING3.  If not see\n   INSERT_PASSES_AFTER (all_regular_ipa_passes)\n   NEXT_PASS (pass_ipa_whole_program_visibility);\n   NEXT_PASS (pass_ipa_profile);\n+  NEXT_PASS (pass_ipa_icf);\n   NEXT_PASS (pass_ipa_devirt);\n   NEXT_PASS (pass_ipa_cp);\n   NEXT_PASS (pass_ipa_cdtor_merge);"}, {"sha": "55a230b39c8cdb8bb14738a9a85395580d10738c", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -90,6 +90,7 @@ DEFTIMEVAR (TV_WHOPR_LTRANS          , \"whopr ltrans\")\n DEFTIMEVAR (TV_IPA_REFERENCE         , \"ipa reference\")\n DEFTIMEVAR (TV_IPA_PROFILE           , \"ipa profile\")\n DEFTIMEVAR (TV_IPA_PURE_CONST        , \"ipa pure const\")\n+DEFTIMEVAR (TV_IPA_ICF\t\t     , \"ipa icf\")\n DEFTIMEVAR (TV_IPA_PTA               , \"ipa points-to\")\n DEFTIMEVAR (TV_IPA_SRA               , \"ipa SRA\")\n DEFTIMEVAR (TV_IPA_FREE_LANG_DATA    , \"ipa free lang data\")"}, {"sha": "2ff52cf52437c8189de59050cc6cde46d8eea645", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84d4347ac38010ab4fbcfbdf049c12afd26f796/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=b84d4347ac38010ab4fbcfbdf049c12afd26f796", "patch": "@@ -461,6 +461,7 @@ extern simple_ipa_opt_pass *make_pass_ipa_free_lang_data (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_free_inline_summary (gcc::context\n \t\t\t\t\t\t\t       *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_cp (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_icf (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_devirt (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_reference (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_pure_const (gcc::context *ctxt);"}]}