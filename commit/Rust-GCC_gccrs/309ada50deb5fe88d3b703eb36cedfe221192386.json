{"sha": "309ada50deb5fe88d3b703eb36cedfe221192386", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA5YWRhNTBkZWI1ZmU4OGQzYjcwM2ViMzZjZWRmZTIyMTE5MjM4Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-12-09T23:54:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-12-09T23:54:58Z"}, "message": "i386.md (cpu attribute): Add \"athlon\".\n\n\t* i386.md (cpu attribute): Add \"athlon\".\n\t(athlon_decode): New attribute.\n\t(Athlon scheduling units definitions): New.\n\t(fcmp and shld patterns): Set athlon_decode to \"vector\".\n\t* i386.c (athlon_cost): New.\n\t(m_ATHLON): New.\n\t(x86_use_leave, x86_push_memory, x86_movx, x86_cmove, x86_deep_branch,\n\tx86_use_sahf): Set for Athlon.\n\t(x86_use_fiop): Unset for Athlon.\n\t(override_options): Define Athlon alignments and \"athlon\" name.\n\t(x86_adjust_cost): Penalize AGI and delayed latencies for Athlon.\n\t* i386.h (TARGET_ATHLON): New.\n\t(enum processor_type): Add PROCESSOR_ATHLON.\n\t(TARGET_CPU_DEFAULT_SPEC): Set to \"-D__tune_athlon__\"\n\tfor CPU_DEFAULT==6\n\t(TARGET_CPP_CPU_SPECS): Set -D__tune_athlon__ for Athlon.\n\nFrom-SVN: r30852", "tree": {"sha": "0a257cc5ec6e36ddb570193a11e352fe2c6447c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a257cc5ec6e36ddb570193a11e352fe2c6447c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/309ada50deb5fe88d3b703eb36cedfe221192386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309ada50deb5fe88d3b703eb36cedfe221192386", "html_url": "https://github.com/Rust-GCC/gccrs/commit/309ada50deb5fe88d3b703eb36cedfe221192386", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309ada50deb5fe88d3b703eb36cedfe221192386/comments", "author": null, "committer": null, "parents": [{"sha": "009fef522acfb6d3678d57bf9f5eae8fecfe381d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009fef522acfb6d3678d57bf9f5eae8fecfe381d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/009fef522acfb6d3678d57bf9f5eae8fecfe381d"}], "stats": {"total": 214, "additions": 201, "deletions": 13}, "files": [{"sha": "630761dcdf4cf65b6dd64a308b6ce87ed876f7c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309ada50deb5fe88d3b703eb36cedfe221192386/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309ada50deb5fe88d3b703eb36cedfe221192386/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=309ada50deb5fe88d3b703eb36cedfe221192386", "patch": "@@ -1,3 +1,22 @@\n+Fri Dec 10 00:52:13 MET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* i386.md (cpu attribute): Add \"athlon\".\n+\t(athlon_decode): New attribute.\n+\t(Athlon scheduling units definitions): New.\n+\t(fcmp and shld patterns): Set athlon_decode to \"vector\".\n+\t* i386.c (athlon_cost): New.\n+\t(m_ATHLON): New.\n+\t(x86_use_leave, x86_push_memory, x86_movx, x86_cmove, x86_deep_branch,\n+\tx86_use_sahf): Set for Athlon.\n+\t(x86_use_fiop): Unset for Athlon.\n+\t(override_options): Define Athlon alignments and \"athlon\" name.\n+\t(x86_adjust_cost): Penalize AGI and delayed latencies for Athlon.\n+\t* i386.h (TARGET_ATHLON): New.\n+\t(enum processor_type): Add PROCESSOR_ATHLON.\n+\t(TARGET_CPU_DEFAULT_SPEC): Set to \"-D__tune_athlon__\"\n+\tfor CPU_DEFAULT==5\n+\t(TARGET_CPP_CPU_SPECS): Set -D__tune_athlon__ for Athlon.\n+\n 1999-12-09  Andreas Jaeger  <aj@suse.de>\n \n \t* loop.c (record_biv): Declare parameter as int."}, {"sha": "d2069eede5a443159f5c47688889a672fdd761bb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309ada50deb5fe88d3b703eb36cedfe221192386/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309ada50deb5fe88d3b703eb36cedfe221192386/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=309ada50deb5fe88d3b703eb36cedfe221192386", "patch": "@@ -155,6 +155,26 @@ struct processor_costs k6_cost = {\n   {4, 4, 4}\t\t\t\t/* cost of loading integer registers */\n };\n \n+struct processor_costs athlon_cost = {\n+  1,\t\t\t\t\t/* cost of an add instruction */\n+  1,\t\t\t\t\t/* cost of a lea instruction */\n+  1,\t\t\t\t\t/* variable shift costs */\n+  1,\t\t\t\t\t/* constant shift costs */\n+  5,\t\t\t\t\t/* cost of starting a multiply */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  19,\t\t\t\t\t/* cost of a divide/mod */\n+  8,\t\t\t\t\t/* \"large\" insn */\n+  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2). */\n+  {2, 3, 2},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {6, 6, 6},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {4, 4, 4}\t\t\t\t/* cost of loading integer registers */\n+};\n+\n struct processor_costs *ix86_cost = &pentium_cost;\n \n /* Processor feature/optimization bitmasks.  */\n@@ -163,22 +183,23 @@ struct processor_costs *ix86_cost = &pentium_cost;\n #define m_PENT (1<<PROCESSOR_PENTIUM)\n #define m_PPRO (1<<PROCESSOR_PENTIUMPRO)\n #define m_K6  (1<<PROCESSOR_K6)\n+#define m_ATHLON  (1<<PROCESSOR_ATHLON)\n \n-const int x86_use_leave = m_386 | m_K6;\n-const int x86_push_memory = m_386 | m_K6;\n+const int x86_use_leave = m_386 | m_K6 | m_ATHLON;\n+const int x86_push_memory = m_386 | m_K6 | m_ATHLON;\n const int x86_zero_extend_with_and = m_486 | m_PENT;\n-const int x86_movx = 0 /* m_386 | m_PPRO | m_K6 */;\n+const int x86_movx = m_ATHLON /* m_386 | m_PPRO | m_K6 */;\n const int x86_double_with_add = ~m_386;\n const int x86_use_bit_test = m_386;\n const int x86_unroll_strlen = m_486 | m_PENT;\n const int x86_use_q_reg = m_PENT | m_PPRO | m_K6;\n const int x86_use_any_reg = m_486;\n-const int x86_cmove = m_PPRO;\n-const int x86_deep_branch = m_PPRO | m_K6;\n-const int x86_use_sahf = m_PPRO | m_K6;\n+const int x86_cmove = m_PPRO | m_ATHLON;\n+const int x86_deep_branch = m_PPRO | m_K6 | m_ATHLON;\n+const int x86_use_sahf = m_PPRO | m_K6 | m_ATHLON;\n const int x86_partial_reg_stall = m_PPRO;\n const int x86_use_loop = m_K6;\n-const int x86_use_fiop = ~m_PPRO;\n+const int x86_use_fiop = ~(m_PPRO | m_ATHLON | m_PENT);\n const int x86_use_mov0 = m_K6;\n const int x86_use_cltd = ~(m_PENT | m_K6);\n const int x86_read_modify_write = ~m_PENT;\n@@ -334,7 +355,8 @@ override_options ()\n       {&i486_cost, 0, 0, 4, 4, 4, 1},\n       {&pentium_cost, 0, 0, -4, -4, -4, 1},\n       {&pentiumpro_cost, 0, 0, 4, -4, 4, 1},\n-      {&k6_cost, 0, 0, -5, -5, 4, 1}\n+      {&k6_cost, 0, 0, -5, -5, 4, 1},\n+      {&athlon_cost, 0, 0, 4, -4, 4, 1}\n     };\n \n   static struct pta\n@@ -351,6 +373,7 @@ override_options ()\n       {\"i686\", PROCESSOR_PENTIUMPRO},\n       {\"pentiumpro\", PROCESSOR_PENTIUMPRO},\n       {\"k6\", PROCESSOR_K6},\n+      {\"athlon\", PROCESSOR_ATHLON},\n     };\n \n   int const pta_size = sizeof(processor_alias_table)/sizeof(struct pta);\n@@ -5582,9 +5605,9 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n   rtx set, set2;\n   int dep_insn_code_number;\n \n-  /* We describe no anti or output depenancies.  */\n+  /* Anti and output depenancies have zero cost on all CPUs.  */\n   if (REG_NOTE_KIND (link) != 0)\n-    return cost;\n+    return 0;\n \n   dep_insn_code_number = recog_memoized (dep_insn);\n \n@@ -5660,6 +5683,20 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n \tcost += 5;\n       break;\n \n+    case PROCESSOR_ATHLON:\n+      /* Address Generation Interlock cause problems on the Athlon CPU because\n+         the loads and stores are done in order so once one load or store has\n+\t to wait, others must too, so penalize the AGIs slightly by one cycle.\n+\t We might experiment with this value later.  */\n+      if (ix86_agi_dependant (insn, dep_insn, insn_type))\n+\tcost += 1;\n+\n+      /* Since we can't represent delayed latencies of load+operation, \n+\t increase the cost here for non-imov insns.  */\n+      if (dep_insn_type != TYPE_IMOV\n+\t  && dep_insn_type != TYPE_FMOV\n+\t  && get_attr_memory (dep_insn) == MEMORY_LOAD)\n+\tcost += 2;\n     default:\n       break;\n     }"}, {"sha": "ee7873583041b876677baf9fc1297a0444f44d2e", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309ada50deb5fe88d3b703eb36cedfe221192386/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309ada50deb5fe88d3b703eb36cedfe221192386/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=309ada50deb5fe88d3b703eb36cedfe221192386", "patch": "@@ -151,6 +151,7 @@ extern int target_flags;\n #define TARGET_PENTIUM (ix86_cpu == PROCESSOR_PENTIUM)\n #define TARGET_PENTIUMPRO (ix86_cpu == PROCESSOR_PENTIUMPRO)\n #define TARGET_K6 (ix86_cpu == PROCESSOR_K6)\n+#define TARGET_ATHLON (ix86_cpu == PROCESSOR_ATHLON)\n \n #define CPUMASK (1 << ix86_cpu)\n extern const int x86_use_leave, x86_push_memory, x86_zero_extend_with_and;\n@@ -245,6 +246,7 @@ enum processor_type\n   PROCESSOR_PENTIUM,\n   PROCESSOR_PENTIUMPRO,\n   PROCESSOR_K6,\n+  PROCESSOR_ATHLON,\n   PROCESSOR_max\n };\n \n@@ -326,6 +328,9 @@ extern int ix86_arch;\n #if TARGET_CPU_DEFAULT == 4\n #define CPP_CPU_DEFAULT_SPEC \"-D__tune_k6__\"\n #endif\n+#if TARGET_CPU_DEFAULT == 5\n+#define CPP_CPU_DEFAULT_SPEC \"-D__tune_athlon__\"\n+#endif\n #ifndef CPP_CPU_DEFAULT_SPEC\n #define CPP_CPU_DEFAULT_SPEC \"-D__tune_i386__\"\n #endif\n@@ -342,11 +347,13 @@ extern int ix86_arch;\n %{march=pentiumpro|march=i686:-D__pentiumpro -D__pentiumpro__ \\\n   %{!mcpu*:-D__tune_pentiumpro__ }}\\\n %{march=k6:-D__k6 -D__k6__ %{!mcpu*:-D__tune_k6__ }}\\\n+%{march=athlon:-D__athlon -D__athlon__ %{!mcpu*:-D__tune_athlon__ }}\\\n %{m386|mcpu=i386:-D__tune_i386__ }\\\n %{m486|mcpu=i486:-D__tune_i486__ }\\\n %{mpentium|mcpu=pentium|mcpu=i586:-D__tune_pentium__ }\\\n %{mpentiumpro|mcpu=pentiumpro|mcpu=i686:-D__tune_pentiumpro__ }\\\n %{mcpu=k6:-D__tune_k6__ }\\\n+%{mcpu=athlon:-D__tune_athlon__ }\\\n %{!march*:%{!mcpu*:%{!m386:%{!m486:%{!mpentium*:%(cpp_cpu_default)}}}}}\"\n #endif\n "}, {"sha": "cb0ed327bcbeb8de83e81e77364af8d50d13f0e6", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 128, "deletions": 3, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309ada50deb5fe88d3b703eb36cedfe221192386/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309ada50deb5fe88d3b703eb36cedfe221192386/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=309ada50deb5fe88d3b703eb36cedfe221192386", "patch": "@@ -77,7 +77,7 @@\n \f\n ;; Processor type.  This attribute must exactly match the processor_type\n ;; enumeration in i386.h.\n-(define_attr \"cpu\" \"i386,i486,pentium,pentiumpro,k6\"\n+(define_attr \"cpu\" \"i386,i486,pentium,pentiumpro,k6,athlon\"\n   (const (symbol_ref \"ix86_cpu\")))\n \n ;; A basic instruction type.  Refinements due to arguments to be\n@@ -693,6 +693,128 @@\n        (eq_attr \"type\" \"idiv\"))\n   17 17)\n \f\n+;; AMD Athlon Scheduling\n+;;\n+;; The Athlon does contain three pipelined FP units, three integer units and\n+;; three address generation units. \n+;;\n+;; The predecode logic is determining boundaries of instructions in the 64\n+;; byte cache line. So the cache line straddling problem of K6 might be issue\n+;; here as well, but it is not noted in the documentation.\n+;;\n+;; Three DirectPath instructions decoders and only one VectorPath decoder\n+;; is available. They can decode three DirectPath instructions or one VectorPath\n+;; instruction per cycle.\n+;; Decoded macro instructions are then passed to 72 entry instruction control\n+;; unit, that passes\n+;; it to the specialized integer (18 entry) and fp (36 entry) schedulers.\n+;;\n+;; The load/store queue unit is not attached to the schedulers but\n+;; communicates with all the execution units seperately instead.\n+\n+(define_attr \"athlon_decode\" \"direct,vector\"\n+  (cond [(eq_attr \"type\" \"call,imul,idiv,other,multi,fcmov,fpspc\")\n+\t   (const_string \"vector\")\n+         (and (eq_attr \"type\" \"push\")\n+              (match_operand 1 \"memory_operand\" \"\"))\n+\t   (const_string \"vector\")\n+         (and (eq_attr \"type\" \"fmov\")\n+              (ior (match_operand:XF 0 \"memory_operand\" \"\")\n+                   (match_operand:XF 1 \"memory_operand\" \"\")))\n+\t   (const_string \"vector\")]\n+\t(const_string \"direct\")))\n+\n+(define_function_unit \"athlon_vectordec\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_decode\" \"vector\"))\n+  1 1)\n+\n+(define_function_unit \"athlon_directdec\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_decode\" \"direct\"))\n+  1 1)\n+\n+(define_function_unit \"athlon_vectordec\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_decode\" \"direct\"))\n+  1 1 [(eq_attr \"athlon_decode\" \"vector\")])\n+\n+(define_function_unit \"athlon_ieu\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"alu1,negnot,alu,icmp,imov,imovx,lea,incdec,ishift,imul,idiv,ibr,setcc,push,pop,call,callv,icmov\"))\n+  1 1)\n+\n+(define_function_unit \"athlon_ieu\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"imul\"))\n+  4 0)\n+\n+(define_function_unit \"athlon_ieu\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"idiv\"))\n+  27 0)\n+\n+(define_function_unit \"athlon_muldiv\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"imul\"))\n+  5 0)\n+\n+(define_function_unit \"athlon_muldiv\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"idiv\"))\n+  27 27)\n+\n+(define_attr \"athlon_fpunits\" \"none,store,mul,add,muladd,all\"\n+  (cond [(eq_attr \"type\" \"fop,fop1,fcmp\")\n+\t   (const_string \"add\")\n+         (eq_attr \"type\" \"fmul,fdiv,fpspc,fsgn\")\n+\t   (const_string \"mul\")\n+\t (and (eq_attr \"type\" \"fmov\") (eq_attr \"memory\" \"!none\"))\n+\t   (const_string \"store\")\n+         (and (eq_attr \"type\" \"fmov\")\n+              (ior (match_operand:SI 1 \"register_operand\" \"\")\n+                   (match_operand 1 \"immediate_operand\" \"\")))\n+\t   (const_string \"store\")\n+         (eq_attr \"type\" \"fmov\")\n+\t   (const_string \"muladd\")\n+         (eq_attr \"type\" \"fcmov\")\n+\t   (const_string \"all\")]\n+\t(const_string \"none\")))\n+\n+(define_function_unit \"athlon_fp_mul\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_fpunits\" \"mul,all\"))\n+  4 1)\n+\n+(define_function_unit \"athlon_fp_add\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_fpunits\" \"add,all\"))\n+  4 1)\n+\n+(define_function_unit \"athlon_fp_muladd\" 2 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (and (eq_attr \"type\" \"fmov\")\n+            (eq_attr \"athlon_fpunits\" \"muladd,mul,add,all\")))\n+  2 1)\n+\n+(define_function_unit \"athlon_fp_muladd\" 2 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (and (eq_attr \"type\" \"!fmov\")\n+            (eq_attr \"athlon_fpunits\" \"muladd,mul,add,all\")))\n+  4 1)\n+\n+(define_function_unit \"athlon_fp_store\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_fpunits\" \"store,all\"))\n+  1 1)\n+\n+(define_function_unit \"athlon_agu\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (and (eq_attr \"memory\" \"!none\")\n+            (eq_attr \"athlon_fpunits\" \"none\")))\n+  1 1)\n+\n+\f\n ;; Compare instructions.\n \n ;; All compare insns have expanders that save the operands away without\n@@ -1095,7 +1217,8 @@\n    && FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[0])\"\n   \"* return output_fp_compare (insn, operands, 1, 0);\"\n-  [(set_attr \"type\" \"fcmp\")])\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"athlon_decode\" \"vector\")])\n \n (define_insn \"*cmpfp_iu\"\n   [(set (reg:CCFPU 17)\n@@ -1105,7 +1228,8 @@\n    && FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n   \"* return output_fp_compare (insn, operands, 1, 1);\"\n-  [(set_attr \"type\" \"fcmp\")])\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"athlon_decode\" \"vector\")])\n \f\n ;; Move instructions.\n \n@@ -5440,6 +5564,7 @@\n   [(set_attr \"type\" \"ishift\")\n    (set_attr \"length_opcode\" \"3\")\n    (set_attr \"pent_pair\" \"np\")\n+   (set_attr \"athlon_decode\" \"vector\")\n    (set_attr \"ppro_uops\" \"few\")])\n \n (define_expand \"x86_shift_adj_1\""}]}