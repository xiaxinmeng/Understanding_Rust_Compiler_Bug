{"sha": "f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc5MzcxMTFlOGM4Y2ZhZjVlYTc5ZDk3YzY1ZDZiNmRjMjliMjYxZg==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2020-11-02T06:21:09Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-11-30T14:16:20Z"}, "message": "[Ada] Implement inheritance for Default_Initial_Condition and address other gaps\n\ngcc/ada/\n\n\t* einfo.ads (Is_Partial_DIC_Procedure): New function.\n\t(Partial_DIC_Procedure): New procedure.\n\t* einfo.adb (Is_Partial_DIC_Procedure): New function to return\n\twhether a subprogram is a partial Default_Initial_Condition\n\tprocedure by checking the name (to avoid adding a new field).\n\t(DIC_Procedure): Add a test that excludes partial DIC procedures\n\tfrom being returned.\n\t(Partial_DIC_Procedure): New procedure to return the partial DIC\n\tprocedure of a type, if it has one (otherwise returns Empty).\n\t(Set_DIC_Procedure): Remove check for duplicate DIC procedures.\n\t* exp_aggr.adb (Gen_Assign): Generate a call to the type's DIC\n\tprocedure in the case where an array component is default\n\tinitialized (due to an association with a box).\n\t(Build_Record_Aggr_Code): For an extension aggregate, generate a\n\tcall to the ancestor type's DIC procedure (if any) when the\n\tancestor part is a subtype mark. For a record component\n\tassociation that was specified with a box (tested for by\n\tchecking the new flag Was_Default_Init_Box_Association),\n\tgenerate a call to the component type's DIC procedure (if it has\n\tone).\n\t* exp_ch4.adb (Expand_N_Allocator): When the allocated object is\n\tdefault initialized and the designated type has a DIC aspect,\n\tgenerate a call to the DIC procedure.\n\t* exp_util.ads (Build_DIC_Call): Change the formal Obj_Id to\n\tname Obj_Name, and change its type from Entity_Id to Node_Id\n\t(and update comment).\n\t(Build_DIC_Procedure_Body): Add formal Partial_DIC, remove\n\tformal For_Freeze, and update comment accordingly.\n\t(Build_DIC_Procedure_Declaration): Add formal Partial_DIC and\n\tupdate comment.\n\t* exp_util.adb\n\t(Build_DIC_Call): Revised to use its Obj_Name (formerly Obj_Id)\n\tformal directly rather than calling New_Occurrence_Of on it, to\n\tallow arbitrary names to be passed rather than being limited to\n\tEntity_Ids.\n\t(Build_DIC_Procedure_Body): Call Add_Parent_DICs to generate\n\tchecks for DICs associated with any parent types, implementing\n\tthe required \"additive\" semantics for DICs. When building a DIC\n\tprocedure body for a partial view (when Partial_DIC is True),\n\tcall Add_Own_DIC when the type has its own DIC.  In the case of\n\t\"full\" DIC procedures, a call is generated to any partial DIC\n\tprocedure of the type (unless the procedure has a null body),\n\talong with checks for any DICs inherited by the full view.\n\t(Build_DIC_Procedure_Declaration): Add handling for partial DIC\n\tprocedures.  For the suffix of a regular DIC procedure's name,\n\tuse \"DIC\" (instead of \"Default_Initial_Condition\"), and for the\n\tsuffix of a partial DIC procedure's name, use \"Partial_DIC\".\n\t(Add_DIC_Check): Add the DIC pragma to the list of seen pragmas\n\t(Pragmas_Seen).\n\t(Add_Inherited_Tagged_DIC): Remove the formals Par_Typ,\n\tDeriv_Typ, and Obj_Id, and add formal Expr, which denotes DIC's\n\texpression. Remove the call to Replace_References (which is now\n\tdone in Add_Inherited_DICs).\n\t(Add_Inherited_DICs): New procedure to locate a DIC pragma\n\tassociated with a parent type, replace its references\n\tappropriately (such as any current instance references), and add\n\ta check for the DIC.\n\t(Add_Own_DIC): Add an Obj_Id formal to allow caller to pass the\n\t_init formal of the generated DIC procedure.\n\t(Add_Parent_DICs): New procedure to traverse a type's parents,\n\tlooking for DICs associated with those and calling\n\tAdd_Inherited_DICs to apply the appropriate DIC checks.\n\t(Is_Verifiable_DIC_Pragma): Treat pragmas that have an Empty\n\tfirst argument the same as a pragma without any arguments\n\t(returning False for that case).\n\t* exp_ch3.adb (Init_One_Dimension): Generate calls to the\n\tcomponent's DIC procedure when needed.\n\t(Possible_DIC_Call): New function nested in Init_One_Dimension\n\tto build a call to the array component type's DIC-checking\n\tfunction when appropriate.\n\t(Build_Array_Init_Proc): The presence of a DIC on the component\n\ttype is an additional condition for generating an init proc for\n\tan array type.\n\t(Build_Init_Statements): When the record component's type has a\n\tDIC, and the component declaration does not have an\n\tinitialization expression, generate a call to the component\n\ttype's DIC procedure.\n\t(Expand_N_Object_Declaration): Modify the call to Build_DIC_Call\n\tto pass a new occurrence of the object's defining id rather than\n\tthe id itself.\n\t(Freeze_Type): Only build a type's DIC procedure (if it has one)\n\tfor types that are not interfaces.\n\t* exp_spark.adb (Expand_SPARK_N_Freeze_Type): Remove From_Freeze\n\tactual and add a ??? comment.\n\t(Expand_SPARK_N_Object_Declaration): Modify call to\n\tBuild_DIC_Call to pass a new occurrence of the object id rather\n\tthan the object id itself.\n\t* sem_aggr.adb (Resolve_Record_Aggregate): Declare local flag\n\tIs_Box_Init_By_Default and set it in cases where the component\n\tassociation has a box and the component is being initialized by\n\tdefault (as opposed to initialized by an initialization\n\texpression associated with the component's declaration).\n\t(Add_Association): If the association has a box for a component\n\tinitialized by default, the flag\n\tWas_Default_Init_Box_Association is set on the new component\n\tassociation (for later testing during expansion).\n\t(Get_Value): Reset Is_Box_Init_By_Default to False.\n\t* sem_ch3.adb (Build_Assertion_Bodies_For_Type): Rearrange code\n\tto build DIC procedure bodies for a (noninterface) type that\n\tHas_Own_DIC (for partial type views) or Has_DIC (for full type\n\tviews) as appropriate.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications,\n\tAspect_Default_Initial_Condition): Add an extra argument to the\n\tDIC pragma to denote the type associated with the pragma (for\n\tuse in Build_DIC_Procedure_Body).\n\t* sem_prag.adb (Analyze_Pragma): Allow two arguments for pragma\n\tDefault_Initial_Condition.  If not already present, add an extra\n\targument denoting the type that the pragma is associated with.\n\t* sem_util.adb (Propagate_DIC_Attributes): Retrieve any partial\n\tDIC procedure associated with the type and add it to the type's\n\tlist of subprograms (Subprograms_For_Type).\n\t* sinfo.ads (Was_Default_Init_Box_Association): New flag on\n\tN_Component_Association nodes.  Add subprograms to get and set\n\tflag, as well as updating the documentation.\n\t* sinfo.adb (Was_Default_Init_Box_Association): New function to\n\tretrieve the corresponding flag (Flag14).\n\t(Set_Was_Default_Init_Box_Association): New procedure to set the\n\tcorresponding flag (Flag14).", "tree": {"sha": "182d42682901bcac2a64c20a6a27edc3d9825af9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/182d42682901bcac2a64c20a6a27edc3d9825af9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b76fe3dcf8067d6f24240841c1cd33fcd5e829b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b76fe3dcf8067d6f24240841c1cd33fcd5e829b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b76fe3dcf8067d6f24240841c1cd33fcd5e829b"}], "stats": {"total": 1168, "additions": 900, "deletions": 268}, "files": [{"sha": "8949703f8d7a5bfaccd8924dfdd05f68025c3c52", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 68, "deletions": 15, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -2543,6 +2543,29 @@ package body Einfo is\n       return Flag215 (Base_Type (Id));\n    end Is_Param_Block_Component_Type;\n \n+   function Is_Partial_DIC_Procedure (Id : E) return B is\n+      Partial_DIC_Suffix : constant String := \"Partial_DIC\";\n+      DIC_Nam            : constant String := Get_Name_String (Chars (Id));\n+\n+   begin\n+      pragma Assert (Ekind (Id) in E_Function | E_Procedure);\n+\n+      --  Instead of adding a new Entity_Id flag (which are in short supply),\n+      --  we test the form of the subprogram name. When the node field and flag\n+      --  situation is eased, this should be replaced with a flag. ???\n+\n+      if DIC_Nam'Length > Partial_DIC_Suffix'Length\n+        and then\n+          DIC_Nam\n+            (DIC_Nam'Last - Partial_DIC_Suffix'Length + 1 .. DIC_Nam'Last) =\n+               Partial_DIC_Suffix\n+      then\n+         return True;\n+      else\n+         return False;\n+      end if;\n+   end Is_Partial_DIC_Procedure;\n+\n    function Is_Partial_Invariant_Procedure (Id : E) return B is\n    begin\n       pragma Assert (Ekind (Id) in E_Function | E_Procedure);\n@@ -7401,7 +7424,13 @@ package body Einfo is\n          while Present (Subp_Elmt) loop\n             Subp_Id := Node (Subp_Elmt);\n \n-            if Is_DIC_Procedure (Subp_Id) then\n+            --  Currently the flag Is_DIC_Procedure is set for both normal DIC\n+            --  check procedures as well as for partial DIC check procedures,\n+            --  and we don't have a flag for the partial procedures.\n+\n+            if Is_DIC_Procedure (Subp_Id)\n+              and then not Is_Partial_DIC_Procedure (Subp_Id)\n+            then\n                return Subp_Id;\n             end if;\n \n@@ -8792,6 +8821,36 @@ package body Einfo is\n       return Ekind (Id);\n    end Parameter_Mode;\n \n+   ---------------------------\n+   -- Partial_DIC_Procedure --\n+   ---------------------------\n+\n+   function Partial_DIC_Procedure (Id : E) return E is\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n+\n+   begin\n+      pragma Assert (Is_Type (Id));\n+\n+      Subps := Subprograms_For_Type (Base_Type (Id));\n+\n+      if Present (Subps) then\n+         Subp_Elmt := First_Elmt (Subps);\n+         while Present (Subp_Elmt) loop\n+            Subp_Id := Node (Subp_Elmt);\n+\n+            if Is_Partial_DIC_Procedure (Subp_Id) then\n+               return Subp_Id;\n+            end if;\n+\n+            Next_Elmt (Subp_Elmt);\n+         end loop;\n+      end if;\n+\n+      return Empty;\n+   end Partial_DIC_Procedure;\n+\n    ---------------------------------\n    -- Partial_Invariant_Procedure --\n    ---------------------------------\n@@ -9271,8 +9330,6 @@ package body Einfo is\n \n    procedure Set_DIC_Procedure (Id : E; V : E) is\n       Base_Typ  : Entity_Id;\n-      Subp_Elmt : Elmt_Id;\n-      Subp_Id   : Entity_Id;\n       Subps     : Elist_Id;\n \n    begin\n@@ -9286,21 +9343,17 @@ package body Einfo is\n          Set_Subprograms_For_Type (Base_Typ, Subps);\n       end if;\n \n-      Subp_Elmt := First_Elmt (Subps);\n       Prepend_Elmt (V, Subps);\n+   end Set_DIC_Procedure;\n \n-      --  Check for a duplicate default initial condition procedure\n-\n-      while Present (Subp_Elmt) loop\n-         Subp_Id := Node (Subp_Elmt);\n-\n-         if Is_DIC_Procedure (Subp_Id) then\n-            raise Program_Error;\n-         end if;\n+   -------------------------------------\n+   -- Set_Partial_Invariant_Procedure --\n+   -------------------------------------\n \n-         Next_Elmt (Subp_Elmt);\n-      end loop;\n-   end Set_DIC_Procedure;\n+   procedure Set_Partial_DIC_Procedure (Id : E; V : E) is\n+   begin\n+      Set_DIC_Procedure (Id, V);\n+   end Set_Partial_DIC_Procedure;\n \n    -----------------------------\n    -- Set_Invariant_Procedure --"}, {"sha": "360ce7ce85588cd11be3ce0c46248434c661ae6d", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -3932,6 +3932,20 @@ package Einfo is\n --       of a single protected/task type, the references are examined as they\n --       must appear only within the type defintion and the corresponding body.\n \n+--    Partial_DIC_Procedure (synthesized)\n+--       Defined in type entities. Set for a private type and its full view\n+--       when the type is subject to pragma Default_Initial_Condition (DIC), or\n+--       when the type inherits a DIC pragma from a parent type. Points to the\n+--       entity of a procedure that takes a single argument of the given type\n+--       and verifies the assertion expression of the DIC pragma at run time.\n+--       When present, the Partial_DIC_Procedure of a type only checks DICs\n+--       associated with the partial (private) view of the type, and is invoked\n+--       by the full DIC_Procedure (which may check additional DICs associated\n+--       with the full view).\n+\n+--       Note: the reason this is marked as a synthesized attribute is that the\n+--       way this is stored is as an element of the Subprograms_For_Type field.\n+\n --    Partial_Invariant_Procedure (synthesized)\n --       Defined in types and subtypes. Set for private types when one or more\n --       [class-wide] type invariants apply to them. Points to the entity for a\n@@ -5821,6 +5835,7 @@ package Einfo is\n    --    Is_Full_Access                      (synth)\n    --    Is_Controlled                       (synth)\n    --    Object_Size_Clause                  (synth)\n+   --    Partial_DIC_Procedure               (synth)\n    --    Partial_Invariant_Procedure         (synth)\n    --    Predicate_Function                  (synth)\n    --    Predicate_Function_M                (synth)\n@@ -6586,6 +6601,7 @@ package Einfo is\n    --    Is_Invariant_Procedure              (Flag257)  (non-generic case only)\n    --    Is_Machine_Code_Subprogram          (Flag137)  (non-generic case only)\n    --    Is_Null_Init_Proc                   (Flag178)\n+   --    Is_Partial_DIC_Procedure            (synth)    (non-generic case only)\n    --    Is_Partial_Invariant_Procedure      (Flag292)  (non-generic case only)\n    --    Is_Predicate_Function               (Flag255)  (non-generic case only)\n    --    Is_Predicate_Function_M             (Flag256)  (non-generic case only)\n@@ -7405,6 +7421,7 @@ package Einfo is\n    function Is_Packed_Array_Impl_Type           (Id : E) return B;\n    function Is_Potentially_Use_Visible          (Id : E) return B;\n    function Is_Param_Block_Component_Type       (Id : E) return B;\n+   function Is_Partial_DIC_Procedure            (Id : E) return B;\n    function Is_Partial_Invariant_Procedure      (Id : E) return B;\n    function Is_Predicate_Function               (Id : E) return B;\n    function Is_Predicate_Function_M             (Id : E) return B;\n@@ -8309,12 +8326,14 @@ package Einfo is\n    ---------------------------------------------------\n \n    function DIC_Procedure                        (Id : E) return E;\n+   function Partial_DIC_Procedure                (Id : E) return E;\n    function Invariant_Procedure                  (Id : E) return E;\n    function Partial_Invariant_Procedure          (Id : E) return E;\n    function Predicate_Function                   (Id : E) return E;\n    function Predicate_Function_M                 (Id : E) return E;\n \n    procedure Set_DIC_Procedure                   (Id : E; V : E);\n+   procedure Set_Partial_DIC_Procedure           (Id : E; V : E);\n    procedure Set_Invariant_Procedure             (Id : E; V : E);\n    procedure Set_Partial_Invariant_Procedure     (Id : E; V : E);\n    procedure Set_Predicate_Function              (Id : E; V : E);"}, {"sha": "30f6dd95e7cb2bc1c0b8e8cd7aaa5170d825ac83", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -1865,6 +1865,21 @@ package body Exp_Aggr is\n                    Typ               => Ctype,\n                    With_Default_Init => True));\n \n+               --  If Default_Initial_Condition applies to the component type,\n+               --  add a DIC check after the component is default-initialized.\n+               --  It will be analyzed and resolved before the code for\n+               --  initialization of other components.\n+\n+               --  Theoretically this might also be needed for cases where\n+               --  the component type doesn't have an init proc (such as for\n+               --  Default_Value cases), but those should be uncommon, and for\n+               --  now we only support the init proc case. ???\n+\n+               if Has_DIC (Ctype) and then Present (DIC_Procedure (Ctype)) then\n+                  Append_To (Stmts,\n+                    Build_DIC_Call (Loc, New_Copy_Tree (Indexed_Comp), Ctype));\n+               end if;\n+\n                --  If the component type has invariants, add an invariant\n                --  check after the component is default-initialized. It will\n                --  be analyzed and resolved before the code for initialization\n@@ -3504,6 +3519,18 @@ package body Exp_Aggr is\n                   then\n                      Check_Ancestor_Discriminants (Entity (Ancestor));\n                   end if;\n+\n+                  --  If ancestor type has Default_Initialization_Condition,\n+                  --  add a DIC check after the ancestor object is initialized\n+                  --  by default.\n+\n+                  if Has_DIC (Entity (Ancestor))\n+                    and then Present (DIC_Procedure (Entity (Ancestor)))\n+                  then\n+                     Append_To (L,\n+                       Build_DIC_Call\n+                         (Loc, New_Copy_Tree (Ref), Entity (Ancestor)));\n+                  end if;\n                end if;\n \n             --  Handle calls to C++ constructors\n@@ -4109,6 +4136,22 @@ package body Exp_Aggr is\n             end;\n          end if;\n \n+         --  If the component association was specified with a box and the\n+         --  component type has a Default_Initial_Condition, then generate\n+         --  a call to the DIC procedure.\n+\n+         if Has_DIC (Etype (Selector))\n+           and then Was_Default_Init_Box_Association (Comp)\n+           and then Present (DIC_Procedure (Etype (Selector)))\n+         then\n+            Append_To (L,\n+              Build_DIC_Call (Loc,\n+                Make_Selected_Component (Loc,\n+                  Prefix        => New_Copy_Tree (Target),\n+                  Selector_Name => New_Occurrence_Of (Selector, Loc)),\n+                Etype (Selector)));\n+         end if;\n+\n          Next (Comp);\n       end loop;\n "}, {"sha": "3fa0641d3651597bb43cf552395b6575504dbe44", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 121, "deletions": 21, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -671,24 +671,85 @@ package body Exp_Ch3 is\n       ------------------------\n \n       function Init_One_Dimension (N : Int) return List_Id is\n-         Index : Entity_Id;\n+         Index       : Entity_Id;\n+         DIC_Call    : Node_Id;\n+         Result_List : List_Id;\n+\n+         function Possible_DIC_Call return Node_Id;\n+         --  If the component type has Default_Initial_Conditions and a DIC\n+         --  procedure that is not an empty body, then builds a call to the\n+         --  DIC procedure and returns it.\n+\n+         -----------------------\n+         -- Possible_DIC_Call --\n+         -----------------------\n+\n+         function Possible_DIC_Call return Node_Id is\n+         begin\n+            --  When the component's type has a Default_Initial_Condition, then\n+            --  create a call for the DIC check.\n+\n+            if Has_DIC (Comp_Type)\n+              --  In GNATprove mode, the component DICs are checked by other\n+              --  means. They should not be added to the record type DIC\n+              --  procedure, so that the procedure can be used to check the\n+              --  record type invariants or DICs if any.\n+\n+              and then not GNATprove_Mode\n+\n+              and then Present (DIC_Procedure (Comp_Type))\n+\n+              and then not Has_Null_Body (DIC_Procedure (Comp_Type))\n+            then\n+               return\n+                 Build_DIC_Call (Loc,\n+                   Make_Indexed_Component (Loc,\n+                     Prefix      => Make_Identifier (Loc, Name_uInit),\n+                     Expressions => Index_List),\n+                   Comp_Type);\n+            else\n+               return Empty;\n+            end if;\n+         end Possible_DIC_Call;\n+\n+      --  Start of processing for Init_One_Dimension\n \n       begin\n          --  If the component does not need initializing, then there is nothing\n          --  to do here, so we return a null body. This occurs when generating\n          --  the dummy Init_Proc needed for Initialize_Scalars processing.\n+         --  An exception is if component type has a Default_Initial_Condition,\n+         --  in which case we generate a call to the type's DIC procedure.\n \n          if not Has_Non_Null_Base_Init_Proc (Comp_Type)\n            and then not Comp_Simple_Init\n            and then not Has_Task (Comp_Type)\n            and then not Has_Default_Aspect (A_Type)\n+           and then (not Has_DIC (Comp_Type)\n+                      or else N > Number_Dimensions (A_Type))\n          then\n-            return New_List (Make_Null_Statement (Loc));\n+            DIC_Call := Possible_DIC_Call;\n+\n+            if Present (DIC_Call) then\n+               return New_List (DIC_Call);\n+            else\n+               return New_List (Make_Null_Statement (Loc));\n+            end if;\n \n          --  If all dimensions dealt with, we simply initialize the component\n+         --  and append a call to component type's DIC procedure when needed.\n \n          elsif N > Number_Dimensions (A_Type) then\n-            return Init_Component;\n+            DIC_Call := Possible_DIC_Call;\n+\n+            if Present (DIC_Call) then\n+               Result_List := Init_Component;\n+               Append (DIC_Call, Result_List);\n+               return Result_List;\n+\n+            else\n+               return Init_Component;\n+            end if;\n \n          --  Here we generate the required loop\n \n@@ -753,6 +814,7 @@ package body Exp_Ch3 is\n       --    3. Tasks are present\n       --    4. The type is marked as a public entity\n       --    5. The array type has a Default_Component_Value aspect\n+      --    6. The array component type has a Default_Initialization_Condition\n \n       --  The reason for the public entity test is to deal properly with the\n       --  Initialize_Scalars pragma. This pragma can be set in the client and\n@@ -771,7 +833,8 @@ package body Exp_Ch3 is\n       Has_Default_Init := Has_Non_Null_Base_Init_Proc (Comp_Type)\n                             or else Comp_Simple_Init\n                             or else Has_Task (Comp_Type)\n-                            or else Has_Default_Aspect (A_Type);\n+                            or else Has_Default_Aspect (A_Type)\n+                            or else Has_DIC (Comp_Type);\n \n       if Has_Default_Init\n         or else (not Restriction_Active (No_Initialize_Scalars)\n@@ -3438,6 +3501,38 @@ package body Exp_Ch3 is\n                   Actions := No_List;\n                end if;\n \n+               --  When the component's type has a Default_Initial_Condition,\n+               --  and the component is default initialized, then check the\n+               --  DIC here.\n+\n+               if Has_DIC (Typ)\n+                 and then not Present (Expression (Decl))\n+                 and then Present (DIC_Procedure (Typ))\n+                 and then not Has_Null_Body (DIC_Procedure (Typ))\n+\n+                 --  The DICs of ancestors are checked as part of the type's\n+                 --  DIC procedure.\n+\n+                 and then Chars (Id) /= Name_uParent\n+\n+                 --  In GNATprove mode, the component DICs are checked by other\n+                 --  means. They should not be added to the record type DIC\n+                 --  procedure, so that the procedure can be used to check the\n+                 --  record type invariants or DICs if any.\n+\n+                 and then not GNATprove_Mode\n+               then\n+                  Append_New_To (Actions,\n+                     Build_DIC_Call\n+                       (Comp_Loc,\n+                        Make_Selected_Component (Comp_Loc,\n+                          Prefix        =>\n+                            Make_Identifier (Comp_Loc, Name_uInit),\n+                          Selector_Name =>\n+                            New_Occurrence_Of (Id, Comp_Loc)),\n+                        Typ));\n+               end if;\n+\n                if Present (Checks) then\n                   if Chars (Id) = Name_uParent then\n                      Append_List_To (Parent_Stmts, Checks);\n@@ -7552,12 +7647,14 @@ package body Exp_Ch3 is\n       if Comes_From_Source (Def_Id)\n         and then Has_DIC (Typ)\n         and then Present (DIC_Procedure (Typ))\n+        and then not Has_Null_Body (DIC_Procedure (Typ))\n         and then not Has_Init_Expression (N)\n         and then not Is_Imported (Def_Id)\n       then\n          declare\n-            DIC_Call : constant Node_Id := Build_DIC_Call (Loc, Def_Id, Typ);\n-\n+            DIC_Call : constant Node_Id :=\n+                         Build_DIC_Call\n+                           (Loc, New_Occurrence_Of (Def_Id, Loc), Typ);\n          begin\n             if Present (Next_N) then\n                Insert_Before_And_Analyze (Next_N, DIC_Call);\n@@ -8331,13 +8428,6 @@ package body Exp_Ch3 is\n       Process_Pending_Access_Types (Def_Id);\n       Freeze_Stream_Operations (N, Def_Id);\n \n-      --  Generate the [spec and] body of the procedure tasked with the runtime\n-      --  verification of pragma Default_Initial_Condition's expression.\n-\n-      if Has_DIC (Def_Id) then\n-         Build_DIC_Procedure_Body (Def_Id, For_Freeze => True);\n-      end if;\n-\n       --  Generate the [spec and] body of the invariant procedure tasked with\n       --  the runtime verification of all invariants that pertain to the type.\n       --  This includes invariants on the partial and full view, inherited\n@@ -8363,14 +8453,24 @@ package body Exp_Ch3 is\n       --  subprograms, which may involve local declarations of local\n       --  subtypes to which these checks do not apply.\n \n-      elsif Has_Invariants (Def_Id) then\n-         if not Predicate_Check_In_Scope (Def_Id)\n-           or else (Ekind (Current_Scope) = E_Function\n-                     and then Is_Predicate_Function (Current_Scope))\n-         then\n-            null;\n-         else\n-            Build_Invariant_Procedure_Body (Def_Id);\n+      else\n+         if Has_Invariants (Def_Id) then\n+            if not Predicate_Check_In_Scope (Def_Id)\n+              or else (Ekind (Current_Scope) = E_Function\n+                        and then Is_Predicate_Function (Current_Scope))\n+            then\n+               null;\n+            else\n+               Build_Invariant_Procedure_Body (Def_Id);\n+            end if;\n+         end if;\n+\n+         --  Generate the [spec and] body of the procedure tasked with the\n+         --  run-time verification of pragma Default_Initial_Condition's\n+         --  expression.\n+\n+         if Has_DIC (Def_Id) then\n+            Build_DIC_Procedure_Body (Def_Id);\n          end if;\n       end if;\n "}, {"sha": "ecaeeb27ff67950627fcc8180dc903215073a868", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -5388,6 +5388,24 @@ package body Exp_Ch4 is\n \n                Rewrite (N, New_Occurrence_Of (Temp, Loc));\n                Analyze_And_Resolve (N, PtrT);\n+\n+               --  When designated type has Default_Initial_Condition aspects,\n+               --  make a call to the type's DIC procedure to perform the\n+               --  checks. Theoretically this might also be needed for cases\n+               --  where the type doesn't have an init proc, but those should\n+               --  be very uncommon, and for now we only support the init proc\n+               --  case. ???\n+\n+               if Has_DIC (Dtyp)\n+                 and then Present (DIC_Procedure (Dtyp))\n+                 and then not Has_Null_Body (DIC_Procedure (Dtyp))\n+               then\n+                  Insert_Action (N,\n+                                 Build_DIC_Call (Loc,\n+                                   Make_Explicit_Dereference (Loc,\n+                                     Prefix => New_Occurrence_Of (Temp, Loc)),\n+                                 Dtyp));\n+               end if;\n             end if;\n          end if;\n       end;"}, {"sha": "d65136be09d292eceb394400aa3111b92697f23f", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -357,7 +357,10 @@ package body Exp_SPARK is\n       --  procedure for it as done during regular expansion for compilation.\n \n       if Has_DIC (E) and then Is_Tagged_Type (E) then\n-         Build_DIC_Procedure_Body (E, For_Freeze => True);\n+         --  Why is this needed for DIC, but not for other aspects (such as\n+         --  Type_Invariant)???\n+\n+         Build_DIC_Procedure_Body (E);\n       end if;\n    end Expand_SPARK_N_Freeze_Type;\n \n@@ -530,7 +533,7 @@ package body Exp_SPARK is\n         and then Present (DIC_Procedure (Typ))\n         and then not Has_Init_Expression (N)\n       then\n-         Call := Build_DIC_Call (Loc, Obj_Id, Typ);\n+         Call := Build_DIC_Call (Loc, New_Occurrence_Of (Obj_Id, Loc), Typ);\n \n          --  Partially insert the call into the tree by setting its parent\n          --  pointer."}, {"sha": "9e08e9c0f28d58236e434072cffe435b2b82d068", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 461, "deletions": 179, "changes": 640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -1446,21 +1446,27 @@ package body Exp_Util is\n    --------------------\n \n    function Build_DIC_Call\n-     (Loc    : Source_Ptr;\n-      Obj_Id : Entity_Id;\n-      Typ    : Entity_Id) return Node_Id\n+     (Loc      : Source_Ptr;\n+      Obj_Name : Node_Id;\n+      Typ      : Entity_Id) return Node_Id\n    is\n       Proc_Id    : constant Entity_Id := DIC_Procedure (Typ);\n       Formal_Typ : constant Entity_Id := Etype (First_Formal (Proc_Id));\n \n    begin\n+      --  The DIC procedure has a null body if assertions are disabled or\n+      --  Assertion_Policy Ignore is in effect. In that case, it would be\n+      --  nice to generate a null statement instead of a call to the DIC\n+      --  procedure, but doing that seems to interfere with the determination\n+      --  of ECRs (early call regions) in SPARK. ???\n+\n       return\n         Make_Procedure_Call_Statement (Loc,\n           Name                   => New_Occurrence_Of (Proc_Id, Loc),\n           Parameter_Associations => New_List (\n             Make_Unchecked_Type_Conversion (Loc,\n               Subtype_Mark => New_Occurrence_Of (Formal_Typ, Loc),\n-              Expression   => New_Occurrence_Of (Obj_Id, Loc))));\n+              Expression   => Obj_Name)));\n    end Build_DIC_Call;\n \n    ------------------------------\n@@ -1472,9 +1478,13 @@ package body Exp_Util is\n    --  Ghost mode.\n \n    procedure Build_DIC_Procedure_Body\n-     (Typ        : Entity_Id;\n-      For_Freeze : Boolean := False)\n+     (Typ         : Entity_Id;\n+      Partial_DIC : Boolean := False)\n    is\n+      Pragmas_Seen : Elist_Id := No_Elist;\n+      --  This list contains all DIC pragmas processed so far. The list is used\n+      --  to avoid redundant Default_Initial_Condition checks.\n+\n       procedure Add_DIC_Check\n         (DIC_Prag : Node_Id;\n          DIC_Expr : Node_Id;\n@@ -1494,24 +1504,46 @@ package body Exp_Util is\n       --  pragma. All generated code is added to list Stmts.\n \n       procedure Add_Inherited_Tagged_DIC\n-        (DIC_Prag  : Node_Id;\n-         Par_Typ   : Entity_Id;\n-         Deriv_Typ : Entity_Id;\n-         Stmts     : in out List_Id);\n+        (DIC_Prag : Node_Id;\n+         Expr     : Node_Id;\n+         Stmts    : in out List_Id);\n       --  Add a runtime check to verify assertion expression DIC_Expr of\n-      --  inherited pragma DIC_Prag. This routine applies class-wide pre- and\n-      --  postcondition-like runtime semantics to the check. Par_Typ is the\n-      --  parent type whose DIC pragma is being inherited. Deriv_Typ is the\n-      --  derived type inheriting the DIC pragma. All generated code is added\n-      --  to list Stmts.\n+      --  inherited pragma DIC_Prag. This routine applies class-wide pre-\n+      --  and postcondition-like runtime semantics to the check. Expr is\n+      --  the assertion expression after substitition has been performed\n+      --  (via Replace_References). All generated code is added to list Stmts.\n+\n+      procedure Add_Inherited_DICs\n+        (T         : Entity_Id;\n+         Priv_Typ  : Entity_Id;\n+         Full_Typ  : Entity_Id;\n+         Obj_Id    : Entity_Id;\n+         Checks    : in out List_Id);\n+      --  Generate a DIC check for each inherited Default_Initial_Condition\n+      --  coming from all parent types of type T. Priv_Typ and Full_Typ denote\n+      --  the partial and full view of the parent type. Obj_Id denotes the\n+      --  entity of the _object formal parameter of the DIC procedure. All\n+      --  created checks are added to list Checks.\n \n       procedure Add_Own_DIC\n         (DIC_Prag : Node_Id;\n          DIC_Typ  : Entity_Id;\n+         Obj_Id   : Entity_Id;\n          Stmts    : in out List_Id);\n       --  Add a runtime check to verify the assertion expression of pragma\n-      --  DIC_Prag. DIC_Typ is the owner of the DIC pragma. All generated code\n-      --  is added to list Stmts.\n+      --  DIC_Prag. DIC_Typ is the owner of the DIC pragma. Obj_Id is the\n+      --  object to substitute in the assertion expression for any references\n+      --  to the current instance of the type All generated code is added to\n+      --  list Stmts.\n+\n+      procedure Add_Parent_DICs\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id);\n+      --  Generate a Default_Initial_Condition check for each inherited DIC\n+      --  aspect coming from all parent types of type T. Obj_Id denotes the\n+      --  entity of the _object formal parameter of the DIC procedure. All\n+      --  created checks are added to list Checks.\n \n       -------------------\n       -- Add_DIC_Check --\n@@ -1549,6 +1581,10 @@ package body Exp_Util is\n                   Make_Pragma_Argument_Association (Loc,\n                     Expression => DIC_Expr))));\n          end if;\n+\n+         --  Add the pragma to the list of processed pragmas\n+\n+         Append_New_Elmt (DIC_Prag, Pragmas_Seen);\n       end Add_DIC_Check;\n \n       -----------------------\n@@ -1590,65 +1626,172 @@ package body Exp_Util is\n       ------------------------------\n \n       procedure Add_Inherited_Tagged_DIC\n-        (DIC_Prag  : Node_Id;\n-         Par_Typ   : Entity_Id;\n-         Deriv_Typ : Entity_Id;\n-         Stmts     : in out List_Id)\n+        (DIC_Prag : Node_Id;\n+         Expr     : Node_Id;\n+         Stmts    : in out List_Id)\n       is\n-         Deriv_Proc : constant Entity_Id := DIC_Procedure (Deriv_Typ);\n-         DIC_Args   : constant List_Id   :=\n-                        Pragma_Argument_Associations (DIC_Prag);\n-         DIC_Arg    : constant Node_Id   := First (DIC_Args);\n-         DIC_Expr   : constant Node_Id   := Expression_Copy (DIC_Arg);\n-         Par_Proc   : constant Entity_Id := DIC_Procedure (Par_Typ);\n+      begin\n+         --  Once the DIC assertion expression is fully processed, add a check\n+         --  to the statements of the DIC procedure.\n \n-         Expr : Node_Id;\n+         Add_DIC_Check\n+           (DIC_Prag => DIC_Prag,\n+            DIC_Expr => Expr,\n+            Stmts    => Stmts);\n+      end Add_Inherited_Tagged_DIC;\n+\n+      ------------------------\n+      -- Add_Inherited_DICs --\n+      ------------------------\n+\n+      procedure Add_Inherited_DICs\n+        (T         : Entity_Id;\n+         Priv_Typ  : Entity_Id;\n+         Full_Typ  : Entity_Id;\n+         Obj_Id    : Entity_Id;\n+         Checks    : in out List_Id)\n+      is\n+         Deriv_Typ     : Entity_Id;\n+         Expr          : Node_Id;\n+         Prag          : Node_Id;\n+         Prag_Expr     : Node_Id;\n+         Prag_Expr_Arg : Node_Id;\n+         Prag_Typ      : Node_Id;\n+         Prag_Typ_Arg  : Node_Id;\n+\n+         Par_Proc : Entity_Id;\n+         --  The \"partial\" invariant procedure of Par_Typ\n+\n+         Par_Typ : Entity_Id;\n+         --  The suitable view of the parent type used in the substitution of\n+         --  type attributes.\n \n       begin\n-         --  The processing of an inherited DIC assertion expression starts off\n-         --  with a copy of the original parent expression where all references\n-         --  to the parent type have already been replaced with references to\n-         --  the _object formal parameter of the parent type's DIC procedure.\n+         if not Present (Priv_Typ) and then not Present (Full_Typ) then\n+            return;\n+         end if;\n \n-         pragma Assert (Present (DIC_Expr));\n-         Expr := New_Copy_Tree (DIC_Expr);\n+         --  When the type inheriting the class-wide invariant is a concurrent\n+         --  type, use the corresponding record type because it contains all\n+         --  primitive operations of the concurrent type and allows for proper\n+         --  substitution.\n \n-         --  Perform the following substitutions:\n+         if Is_Concurrent_Type (T) then\n+            Deriv_Typ := Corresponding_Record_Type (T);\n+         else\n+            Deriv_Typ := T;\n+         end if;\n \n-         --    * Replace a reference to the _object parameter of the parent\n-         --      type's DIC procedure with a reference to the _object parameter\n-         --      of the derived types' DIC procedure.\n+         pragma Assert (Present (Deriv_Typ));\n \n-         --    * Replace a reference to a discriminant of the parent type with\n-         --      a suitable value from the point of view of the derived type.\n+         --  Determine which rep item chain to use. Precedence is given to that\n+         --  of the parent type's partial view since it usually carries all the\n+         --  class-wide invariants.\n \n-         --    * Replace a call to an overridden parent primitive with a call\n-         --      to the overriding derived type primitive.\n+         if Present (Priv_Typ) then\n+            Prag := First_Rep_Item (Priv_Typ);\n+         else\n+            Prag := First_Rep_Item (Full_Typ);\n+         end if;\n \n-         --    * Replace a call to an inherited parent primitive with a call to\n-         --      the internally-generated inherited derived type primitive.\n+         while Present (Prag) loop\n+            if Nkind (Prag) = N_Pragma\n+              and then Pragma_Name (Prag) = Name_Default_Initial_Condition\n+            then\n+               --  Nothing to do if the pragma was already processed\n \n-         --  Note that primitives defined in the private part are automatically\n-         --  handled by the overriding/inheritance mechanism and do not require\n-         --  an extra replacement pass.\n+               if Contains (Pragmas_Seen, Prag) then\n+                  return;\n+               end if;\n \n-         pragma Assert (Present (Deriv_Proc) and then Present (Par_Proc));\n+               --  Extract arguments of the Default_Initial_Condition pragma\n \n-         Replace_References\n-           (Expr      => Expr,\n-            Par_Typ   => Par_Typ,\n-            Deriv_Typ => Deriv_Typ,\n-            Par_Obj   => First_Formal (Par_Proc),\n-            Deriv_Obj => First_Formal (Deriv_Proc));\n+               Prag_Expr_Arg := First (Pragma_Argument_Associations (Prag));\n+               Prag_Expr     := Expression_Copy (Prag_Expr_Arg);\n \n-         --  Once the DIC assertion expression is fully processed, add a check\n-         --  to the statements of the DIC procedure.\n+               --  Pick up the implicit second argument of the pragma, which\n+               --  indicates the type that the pragma applies to.\n \n-         Add_DIC_Check\n-           (DIC_Prag => DIC_Prag,\n-            DIC_Expr => Expr,\n-            Stmts    => Stmts);\n-      end Add_Inherited_Tagged_DIC;\n+               Prag_Typ_Arg  := Next (Prag_Expr_Arg);\n+               if Present (Prag_Typ_Arg) then\n+                  Prag_Typ := Get_Pragma_Arg (Prag_Typ_Arg);\n+               else\n+                  Prag_Typ := Empty;\n+               end if;\n+\n+               --  The pragma applies to the partial view of the parent type\n+\n+               if Present (Priv_Typ)\n+                 and then Present (Prag_Typ)\n+                 and then Entity (Prag_Typ) = Priv_Typ\n+               then\n+                  Par_Typ := Priv_Typ;\n+\n+               --  The pragma applies to the full view of the parent type\n+\n+               elsif Present (Full_Typ)\n+                 and then Present (Prag_Typ)\n+                 and then Entity (Prag_Typ) = Full_Typ\n+               then\n+                  Par_Typ := Full_Typ;\n+\n+               --  Otherwise the pragma does not belong to the parent type and\n+               --  should not be considered.\n+\n+               else\n+                  return;\n+               end if;\n+\n+               --  Substitute references in the DIC expression that are related\n+               --  to the partial type with corresponding references related to\n+               --  the derived type (call to Replace_References below).\n+\n+               Expr := New_Copy_Tree (Prag_Expr);\n+\n+               Par_Proc := Partial_DIC_Procedure (Par_Typ);\n+\n+               --  If there's not a partial DIC procedure (such as when a\n+               --  full type doesn't have its own DIC, but is inherited from\n+               --  a type with DIC), get the full DIC procedure.\n+\n+               if not Present (Par_Proc) then\n+                  Par_Proc := DIC_Procedure (Par_Typ);\n+               end if;\n+\n+               Replace_References\n+                 (Expr      => Expr,\n+                  Par_Typ   => Par_Typ,\n+                  Deriv_Typ => Deriv_Typ,\n+                  Par_Obj   => First_Formal (Par_Proc),\n+                  Deriv_Obj => Obj_Id);\n+\n+               --  Why are there different actions depending on whether T is\n+               --  tagged? Can these be unified? ???\n+\n+               if Is_Tagged_Type (T) then\n+                  Add_Inherited_Tagged_DIC\n+                    (DIC_Prag  => Prag,\n+                     Expr      => Expr,\n+                     Stmts     => Checks);\n+\n+               else\n+                  Add_Inherited_DIC\n+                    (DIC_Prag  => Prag,\n+                     Par_Typ   => Par_Typ,\n+                     Deriv_Typ => Deriv_Typ,\n+                     Stmts     => Checks);\n+               end if;\n+\n+               --  Leave as soon as we get a DIC pragma, since we'll visit\n+               --  the pragmas of the parents, so will get to any \"inherited\"\n+               --  pragmas that way.\n+\n+               return;\n+            end if;\n+\n+            Next_Rep_Item (Prag);\n+         end loop;\n+      end Add_Inherited_DICs;\n \n       -----------------\n       -- Add_Own_DIC --\n@@ -1657,15 +1800,14 @@ package body Exp_Util is\n       procedure Add_Own_DIC\n         (DIC_Prag : Node_Id;\n          DIC_Typ  : Entity_Id;\n+         Obj_Id   : Entity_Id;\n          Stmts    : in out List_Id)\n       is\n          DIC_Args : constant List_Id   :=\n                       Pragma_Argument_Associations (DIC_Prag);\n          DIC_Arg  : constant Node_Id   := First (DIC_Args);\n          DIC_Asp  : constant Node_Id   := Corresponding_Aspect (DIC_Prag);\n          DIC_Expr : constant Node_Id   := Get_Pragma_Arg (DIC_Arg);\n-         DIC_Proc : constant Entity_Id := DIC_Procedure (DIC_Typ);\n-         Obj_Id   : constant Entity_Id := First_Formal (DIC_Proc);\n \n          --  Local variables\n \n@@ -1722,6 +1864,66 @@ package body Exp_Util is\n             Stmts    => Stmts);\n       end Add_Own_DIC;\n \n+      ---------------------\n+      -- Add_Parent_DICs --\n+      ---------------------\n+\n+      procedure Add_Parent_DICs\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id)\n+      is\n+         Dummy_1 : Entity_Id;\n+         Dummy_2 : Entity_Id;\n+\n+         Curr_Typ : Entity_Id;\n+         --  The entity of the current type being examined\n+\n+         Full_Typ : Entity_Id;\n+         --  The full view of Par_Typ\n+\n+         Par_Typ : Entity_Id;\n+         --  The entity of the parent type\n+\n+         Priv_Typ : Entity_Id;\n+         --  The partial view of Par_Typ\n+\n+      begin\n+         --  Climb the parent type chain\n+\n+         Curr_Typ := T;\n+         loop\n+            --  Do not consider subtypes, as they inherit the DICs from their\n+            --  base types.\n+\n+            Par_Typ := Base_Type (Etype (Base_Type (Curr_Typ)));\n+\n+            --  Stop the climb once the root of the parent chain is\n+            --  reached.\n+\n+            exit when Curr_Typ = Par_Typ;\n+\n+            --  Process the DICs of the parent type\n+\n+            Get_Views (Par_Typ, Priv_Typ, Full_Typ, Dummy_1, Dummy_2);\n+\n+            --  Only try to inherit a DIC pragma from the parent type Par_Typ\n+            --  if it Has_Own_DIC pragma. The loop will proceed up the parent\n+            --  chain to find all types that have their own DIC.\n+\n+            if Has_Own_DIC (Par_Typ) then\n+               Add_Inherited_DICs\n+                 (T         => T,\n+                  Priv_Typ  => Priv_Typ,\n+                  Full_Typ  => Full_Typ,\n+                  Obj_Id    => Obj_Id,\n+                  Checks    => Checks);\n+            end if;\n+\n+            Curr_Typ := Par_Typ;\n+         end loop;\n+      end Add_Parent_DICs;\n+\n       --  Local variables\n \n       Loc : constant Source_Ptr := Sloc (Typ);\n@@ -1740,8 +1942,20 @@ package body Exp_Util is\n       Proc_Id      : Entity_Id;\n       Stmts        : List_Id := No_List;\n \n-      Build_Body : Boolean := False;\n-      --  Flag set when the type requires a DIC procedure body to be built\n+      CRec_Typ : Entity_Id := Empty;\n+      --  The corresponding record type of Full_Typ\n+\n+      Full_Typ : Entity_Id := Empty;\n+      --  The full view of the working type\n+\n+      Obj_Id : Entity_Id := Empty;\n+      --  The _object formal parameter of the invariant procedure\n+\n+      Part_Proc : Entity_Id := Empty;\n+      --  The entity of the \"partial\" invariant procedure\n+\n+      Priv_Typ : Entity_Id := Empty;\n+      --  The partial view of the working type\n \n       Work_Typ : Entity_Id;\n       --  The working type\n@@ -1805,25 +2019,41 @@ package body Exp_Util is\n          goto Leave;\n       end if;\n \n-      --  The working type may lack a DIC procedure declaration. This may be\n-      --  due to several reasons:\n+      --  Obtain both views of the type\n+\n+      Get_Views (Work_Typ, Priv_Typ, Full_Typ, Dummy_1, CRec_Typ);\n \n-      --    * The working type's own DIC pragma does not contain a verifiable\n-      --      assertion expression. In this case there is no need to build a\n-      --      DIC procedure because there is nothing to check.\n+      --  The caller requests a body for the partial DIC procedure\n \n-      --    * The working type derives from a parent type. In this case a DIC\n-      --      procedure should be built only when the inherited DIC pragma has\n-      --      a verifiable assertion expression.\n+      if Partial_DIC then\n+         Proc_Id   := Partial_DIC_Procedure (Work_Typ);\n \n-      Proc_Id := DIC_Procedure (Work_Typ);\n+         --  The \"full\" DIC procedure body was already created\n \n-      --  Build a DIC procedure declaration when the working type derives from\n-      --  a parent type.\n+         --  Create a declaration for the \"partial\" DIC procedure if it\n+         --  is not available.\n+\n+         if No (Proc_Id) then\n+            Build_DIC_Procedure_Declaration\n+              (Typ         => Work_Typ,\n+               Partial_DIC => True);\n \n-      if No (Proc_Id) then\n-         Build_DIC_Procedure_Declaration (Work_Typ);\n-         Proc_Id := DIC_Procedure (Work_Typ);\n+            Proc_Id := Partial_DIC_Procedure (Work_Typ);\n+         end if;\n+\n+      --  The caller requests a body for the \"full\" DIC procedure\n+\n+      else\n+         Proc_Id   := DIC_Procedure (Work_Typ);\n+         Part_Proc := Partial_DIC_Procedure (Work_Typ);\n+\n+         --  Create a declaration for the \"full\" DIC procedure if it is\n+         --  not available.\n+\n+         if No (Proc_Id) then\n+            Build_DIC_Procedure_Declaration (Work_Typ);\n+            Proc_Id := DIC_Procedure (Work_Typ);\n+         end if;\n       end if;\n \n       --  At this point there should be a DIC procedure declaration\n@@ -1843,123 +2073,146 @@ package body Exp_Util is\n       Push_Scope (Proc_Id);\n       Install_Formals (Proc_Id);\n \n-      --  The working type defines its own DIC pragma. Replace the current\n-      --  instance of the working type with the formal of the DIC procedure.\n-      --  Note that there is no need to consider inherited DIC pragmas from\n-      --  parent types because the working type's DIC pragma \"hides\" all\n-      --  inherited DIC pragmas.\n+      Obj_Id := First_Formal (Proc_Id);\n+      pragma Assert (Present (Obj_Id));\n \n-      if Has_Own_DIC (Work_Typ) then\n-         pragma Assert (DIC_Typ = Work_Typ);\n+      --  The \"partial\" DIC procedure verifies the DICs of the partial view\n+      --  only.\n \n-         Add_Own_DIC\n-           (DIC_Prag => DIC_Prag,\n-            DIC_Typ  => DIC_Typ,\n-            Stmts    => Stmts);\n+      if Partial_DIC then\n+         pragma Assert (Present (Priv_Typ));\n+\n+         if Has_Own_DIC (Work_Typ) then  -- If we're testing this then maybe\n+            Add_Own_DIC        -- we shouldn't be calling Find_DIC_Typ above???\n+              (DIC_Prag => DIC_Prag,\n+               DIC_Typ  => DIC_Typ,  -- Should this just be Work_Typ???\n+               Obj_Id   => Obj_Id,\n+               Stmts    => Stmts);\n+         end if;\n \n-         Build_Body := True;\n+      --  Otherwise the \"full\" DIC procedure verifies the DICs of the full\n+      --  view, well as DICs inherited from parent types. In addition, it\n+      --  indirectly verifies the DICs of the partial view by calling the\n+      --  \"partial\" DIC procedure.\n \n-      --  Otherwise the working type inherits a DIC pragma from a parent type.\n-      --  This processing is carried out when the type is frozen because the\n-      --  state of all parent discriminants is known at that point. Note that\n-      --  it is semantically sound to delay the creation of the DIC procedure\n-      --  body till the freeze point. If the type has a DIC pragma of its own,\n-      --  then the DIC procedure body would have already been constructed at\n-      --  the end of the visible declarations and all parent DIC pragmas are\n-      --  effectively \"hidden\" and irrelevant.\n+      else\n+         pragma Assert (Present (Full_Typ));\n \n-      elsif For_Freeze then\n-         pragma Assert (Has_Inherited_DIC (Work_Typ));\n-         pragma Assert (DIC_Typ /= Work_Typ);\n+         --  Check the DIC of the partial view by calling the \"partial\" DIC\n+         --  procedure, unless the partial DIC body is empty. Generate:\n \n-         --  The working type is tagged. The verification of the assertion\n-         --  expression is subject to the same semantics as class-wide pre-\n-         --  and postconditions.\n+         --    <Work_Typ>Partial_DIC (_object);\n+\n+         if Present (Part_Proc) and then not Has_Null_Body (Part_Proc) then\n+            Append_New_To (Stmts,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name                   => New_Occurrence_Of (Part_Proc, Loc),\n+                Parameter_Associations => New_List (\n+                  New_Occurrence_Of (Obj_Id, Loc))));\n+         end if;\n \n-         if Is_Tagged_Type (Work_Typ) then\n-            Add_Inherited_Tagged_DIC\n-              (DIC_Prag  => DIC_Prag,\n-               Par_Typ   => DIC_Typ,\n-               Deriv_Typ => Work_Typ,\n-               Stmts     => Stmts);\n+         --  Derived subtypes do not have a partial view\n \n-         --  Otherwise the working type is not tagged. Verify the assertion\n-         --  expression of the inherited DIC pragma by directly calling the\n-         --  DIC procedure of the parent type.\n+         if Present (Priv_Typ) then\n \n-         else\n-            Add_Inherited_DIC\n-              (DIC_Prag  => DIC_Prag,\n-               Par_Typ   => DIC_Typ,\n-               Deriv_Typ => Work_Typ,\n-               Stmts     => Stmts);\n+            --  The processing of the \"full\" DIC procedure intentionally\n+            --  skips the partial view because a) this may result in changes of\n+            --  visibility and b) lead to duplicate checks. However, when the\n+            --  full view is the underlying full view of an untagged derived\n+            --  type whose parent type is private, partial DICs appear on\n+            --  the rep item chain of the partial view only.\n+\n+            --    package Pack_1 is\n+            --       type Root ... is private;\n+            --    private\n+            --       <full view of Root>\n+            --    end Pack_1;\n+\n+            --    with Pack_1;\n+            --    package Pack_2 is\n+            --       type Child is new Pack_1.Root with Type_DIC => ...;\n+            --       <underlying full view of Child>\n+            --    end Pack_2;\n+\n+            --  As a result, the processing of the full view must also consider\n+            --  all DICs of the partial view.\n+\n+            if Is_Untagged_Private_Derivation (Priv_Typ, Full_Typ) then\n+               null;\n+\n+            --  Otherwise the DICs of the partial view are ignored\n+\n+            else\n+               --  Ignore the DICs of the partial view by eliminating the view\n+\n+               Priv_Typ := Empty;\n+            end if;\n          end if;\n \n-         Build_Body := True;\n+         --  Process inherited Default_Initial_Conditions for all parent types\n+\n+         Add_Parent_DICs (Work_Typ, Obj_Id, Stmts);\n       end if;\n \n       End_Scope;\n \n-      if Build_Body then\n+      --  Produce an empty completing body in the following cases:\n+      --    * Assertions are disabled\n+      --    * The DIC Assertion_Policy is Ignore\n \n-         --  Produce an empty completing body in the following cases:\n-         --    * Assertions are disabled\n-         --    * The DIC Assertion_Policy is Ignore\n+      if No (Stmts) then\n+         Stmts := New_List (Make_Null_Statement (Loc));\n+      end if;\n \n-         if No (Stmts) then\n-            Stmts := New_List (Make_Null_Statement (Loc));\n-         end if;\n+      --  Generate:\n+      --    procedure <Work_Typ>DIC (_object : <Work_Typ>) is\n+      --    begin\n+      --       <Stmts>\n+      --    end <Work_Typ>DIC;\n \n-         --  Generate:\n-         --    procedure <Work_Typ>DIC (_object : <Work_Typ>) is\n-         --    begin\n-         --       <Stmts>\n-         --    end <Work_Typ>DIC;\n-\n-         Proc_Body :=\n-           Make_Subprogram_Body (Loc,\n-             Specification                =>\n-               Copy_Subprogram_Spec (Parent (Proc_Id)),\n-             Declarations                 => Empty_List,\n-               Handled_Statement_Sequence =>\n-                 Make_Handled_Sequence_Of_Statements (Loc,\n-                   Statements => Stmts));\n-         Proc_Body_Id := Defining_Entity (Proc_Body);\n-\n-         --  Perform minor decoration in case the body is not analyzed\n-\n-         Set_Ekind        (Proc_Body_Id, E_Subprogram_Body);\n-         Set_Etype        (Proc_Body_Id, Standard_Void_Type);\n-         Set_Scope        (Proc_Body_Id, Current_Scope);\n-         Set_SPARK_Pragma (Proc_Body_Id, SPARK_Pragma (Proc_Id));\n-         Set_SPARK_Pragma_Inherited\n-                          (Proc_Body_Id, SPARK_Pragma_Inherited (Proc_Id));\n-\n-         --  Link both spec and body to avoid generating duplicates\n-\n-         Set_Corresponding_Body (Proc_Decl, Proc_Body_Id);\n-         Set_Corresponding_Spec (Proc_Body, Proc_Id);\n-\n-         --  The body should not be inserted into the tree when the context\n-         --  is a generic unit because it is not part of the template.\n-         --  Note that the body must still be generated in order to resolve the\n-         --  DIC assertion expression.\n-\n-         if Inside_A_Generic then\n-            null;\n+      Proc_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification                =>\n+            Copy_Subprogram_Spec (Parent (Proc_Id)),\n+          Declarations                 => Empty_List,\n+            Handled_Statement_Sequence =>\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => Stmts));\n+      Proc_Body_Id := Defining_Entity (Proc_Body);\n \n-         --  Semi-insert the body into the tree for GNATprove by setting its\n-         --  Parent field. This allows for proper upstream tree traversals.\n+      --  Perform minor decoration in case the body is not analyzed\n \n-         elsif GNATprove_Mode then\n-            Set_Parent (Proc_Body, Parent (Declaration_Node (Work_Typ)));\n+      Set_Ekind        (Proc_Body_Id, E_Subprogram_Body);\n+      Set_Etype        (Proc_Body_Id, Standard_Void_Type);\n+      Set_Scope        (Proc_Body_Id, Current_Scope);\n+      Set_SPARK_Pragma (Proc_Body_Id, SPARK_Pragma (Proc_Id));\n+      Set_SPARK_Pragma_Inherited\n+                       (Proc_Body_Id, SPARK_Pragma_Inherited (Proc_Id));\n \n-         --  Otherwise the body is part of the freezing actions of the working\n-         --  type.\n+      --  Link both spec and body to avoid generating duplicates\n \n-         else\n-            Append_Freeze_Action (Work_Typ, Proc_Body);\n-         end if;\n+      Set_Corresponding_Body (Proc_Decl, Proc_Body_Id);\n+      Set_Corresponding_Spec (Proc_Body, Proc_Id);\n+\n+      --  The body should not be inserted into the tree when the context\n+      --  is a generic unit because it is not part of the template.\n+      --  Note that the body must still be generated in order to resolve the\n+      --  DIC assertion expression.\n+\n+      if Inside_A_Generic then\n+         null;\n+\n+      --  Semi-insert the body into the tree for GNATprove by setting its\n+      --  Parent field. This allows for proper upstream tree traversals.\n+\n+      elsif GNATprove_Mode then\n+         Set_Parent (Proc_Body, Parent (Declaration_Node (Work_Typ)));\n+\n+      --  Otherwise the body is part of the freezing actions of the working\n+      --  type.\n+\n+      else\n+         Append_Freeze_Action (Work_Typ, Proc_Body);\n       end if;\n \n    <<Leave>>\n@@ -1974,7 +2227,10 @@ package body Exp_Util is\n    --  replaced by gotos which jump to the end of the routine and restore the\n    --  Ghost mode.\n \n-   procedure Build_DIC_Procedure_Declaration (Typ : Entity_Id) is\n+   procedure Build_DIC_Procedure_Declaration\n+     (Typ         : Entity_Id;\n+      Partial_DIC : Boolean := False)\n+   is\n       Loc : constant Source_Ptr := Sloc (Typ);\n \n       Saved_GM  : constant Ghost_Mode_Type := Ghost_Mode;\n@@ -1985,6 +2241,7 @@ package body Exp_Util is\n       DIC_Typ   : Entity_Id;\n       Proc_Decl : Node_Id;\n       Proc_Id   : Entity_Id;\n+      Proc_Nam  : Name_Id;\n       Typ_Decl  : Node_Id;\n \n       CRec_Typ : Entity_Id;\n@@ -2060,17 +2317,35 @@ package body Exp_Util is\n \n       if not Is_Verifiable_DIC_Pragma (DIC_Prag) then\n          goto Leave;\n+      end if;\n+\n+      --  Nothing to do if the type already has a \"partial\" DIC procedure\n+\n+      if Partial_DIC then\n+         if Present (Partial_DIC_Procedure (Work_Typ)) then\n+            goto Leave;\n+         end if;\n \n-      --  Nothing to do if the type already has a DIC procedure\n+      --  Nothing to do if the type already has a \"full\" DIC procedure\n \n       elsif Present (DIC_Procedure (Work_Typ)) then\n          goto Leave;\n       end if;\n \n+      --  The caller requests the declaration of the \"partial\" DIC procedure\n+\n+      if Partial_DIC then\n+         Proc_Nam := New_External_Name (Chars (Work_Typ), \"Partial_DIC\");\n+\n+      --  Otherwise the caller requests the declaration of the \"full\" DIC\n+      --  procedure.\n+\n+      else\n+         Proc_Nam := New_External_Name (Chars (Work_Typ), \"DIC\");\n+      end if;\n+\n       Proc_Id :=\n-        Make_Defining_Identifier (Loc,\n-          Chars =>\n-            New_External_Name (Chars (Work_Typ), \"Default_Initial_Condition\"));\n+        Make_Defining_Identifier (Loc, Chars => Proc_Nam);\n \n       --  Perform minor decoration in case the declaration is not analyzed\n \n@@ -8908,6 +9183,13 @@ package body Exp_Util is\n \n       return\n         Present (Args)\n+\n+          --  If there are args, but the first arg is Empty, then treat the\n+          --  pragma the same as having no args (there may be a second arg that\n+          --  is an implicitly added type arg, and Empty is a placeholder).\n+\n+          and then Present (Get_Pragma_Arg (First (Args)))\n+\n           and then Nkind (Get_Pragma_Arg (First (Args))) /= N_Null;\n    end Is_Verifiable_DIC_Pragma;\n "}, {"sha": "202ac3c954c0a050c9117ada3f56de68aa5537bb", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -293,23 +293,29 @@ package Exp_Util is\n    --  type is frozen.\n \n    function Build_DIC_Call\n-     (Loc    : Source_Ptr;\n-      Obj_Id : Entity_Id;\n-      Typ    : Entity_Id) return Node_Id;\n-   --  Build a call to the DIC procedure of type Typ with Obj_Id as the actual\n+     (Loc      : Source_Ptr;\n+      Obj_Name : Node_Id;\n+      Typ      : Entity_Id) return Node_Id;\n+   --  Build a call to the DIC procedure for Typ with Obj_Name as the actual\n    --  parameter.\n \n    procedure Build_DIC_Procedure_Body\n-     (Typ        : Entity_Id;\n-      For_Freeze : Boolean := False);\n+     (Typ         : Entity_Id;\n+      Partial_DIC : Boolean := False);\n    --  Create the body of the procedure which verifies the assertion expression\n-   --  of pragma Default_Initial_Condition at run time. Flag For_Freeze should\n-   --  be set when the body is constructed as part of the freezing actions for\n-   --  Typ.\n-\n-   procedure Build_DIC_Procedure_Declaration (Typ : Entity_Id);\n+   --  of pragma Default_Initial_Condition at run time. Partial_DIC indicates\n+   --  that a partial DIC-checking procedure body should be built, for checking\n+   --  a DIC associated with the type's partial view, and which will be called\n+   --  by the main DIC procedure.\n+\n+   procedure Build_DIC_Procedure_Declaration\n+     (Typ         : Entity_Id;\n+      Partial_DIC : Boolean := False);\n    --  Create the declaration of the procedure which verifies the assertion\n-   --  expression of pragma Default_Initial_Condition at run time.\n+   --  expression of pragma Default_Initial_Condition at run time. Partial_DIC\n+   --  indicates that a partial DIC-checking procedure should be declared,\n+   --  for checking a DIC associated with the type's partial view, and which\n+   --  will be called by the main DIC procedure.\n \n    procedure Build_Invariant_Procedure_Body\n      (Typ               : Entity_Id;"}, {"sha": "3caa84f0cb0fcaa1ff06d7919f4aa92413270d19", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -3715,9 +3715,10 @@ package body Sem_Aggr is\n       --\n       --  This variable is updated as a side effect of function Get_Value.\n \n-      Box_Node       : Node_Id := Empty;\n-      Is_Box_Present : Boolean := False;\n-      Others_Box     : Natural := 0;\n+      Box_Node               : Node_Id := Empty;\n+      Is_Box_Present         : Boolean := False;\n+      Is_Box_Init_By_Default : Boolean := False;\n+      Others_Box             : Natural := 0;\n       --  Ada 2005 (AI-287): Variables used in case of default initialization\n       --  to provide a functionality similar to Others_Etype. Box_Present\n       --  indicates that the component takes its default initialization;\n@@ -3842,6 +3843,17 @@ package body Sem_Aggr is\n              Choices     => Choice_List,\n              Expression  => Expr,\n              Box_Present => Is_Box_Present));\n+\n+         --  If this association has a box for a component that is initialized\n+         --  by default, then set flag on the new association to indicate that\n+         --  the original association was for such a box-initialized component.\n+\n+         if Resolve_Record_Aggregate.Is_Box_Present\n+           and then not Is_Box_Present\n+           and then Is_Box_Init_By_Default  -- ???\n+         then\n+            Set_Was_Default_Init_Box_Association (Last (Assoc_List));\n+         end if;\n       end Add_Association;\n \n       -----------------------------\n@@ -4059,6 +4071,7 @@ package body Sem_Aggr is\n \n       begin\n          Is_Box_Present := False;\n+         Is_Box_Init_By_Default := False;\n \n          if No (From) then\n             return Empty;\n@@ -5054,6 +5067,11 @@ package body Sem_Aggr is\n                Ctyp : constant Entity_Id := Etype (Component);\n \n             begin\n+               --  Initially assume that the box is for a default-initialized\n+               --  component and reset to False in cases where that's not true.\n+\n+               Is_Box_Init_By_Default := True;\n+\n                --  If there is a default expression for the aggregate, copy\n                --  it into a new association. This copy must modify the scopes\n                --  of internal types that may be attached to the expression\n@@ -5077,6 +5095,11 @@ package body Sem_Aggr is\n                  and then Nkind (Parent (Component)) = N_Component_Declaration\n                  and then Present (Expression (Parent (Component)))\n                then\n+                  --  If component declaration has an initialization expression\n+                  --  then this is not a case of default initialization.\n+\n+                  Is_Box_Init_By_Default := False;\n+\n                   Expr :=\n                     New_Copy_Tree_And_Copy_Dimensions\n                       (Expression (Parent (Component)),"}, {"sha": "b48aeb47739f608fa12d875ffd8f2606ba60e723", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -3606,11 +3606,17 @@ package body Sem_Ch13 is\n                --  wrapped inside of a procedure at the freeze point of the\n                --  private type's full view.\n \n+               --  A type entity argument is appended to facilitate inheriting\n+               --  the aspect from parent types (see Build_DIC_Procedure_Body),\n+               --  though that extra argument isn't documented for the pragma.\n+\n                when Aspect_Default_Initial_Condition =>\n                   Aitem := Make_Aitem_Pragma\n                     (Pragma_Argument_Associations => New_List (\n                        Make_Pragma_Argument_Association (Loc,\n-                         Expression => Relocate_Node (Expr))),\n+                         Expression => Relocate_Node (Expr)),\n+                       Make_Pragma_Argument_Association (Sloc (Ent),\n+                         Expression => Ent)),\n                      Pragma_Name                  =>\n                        Name_Default_Initial_Condition);\n "}, {"sha": "00834cea113da62f4d04a5b11a86f0006b67530f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -2312,13 +2312,6 @@ package body Sem_Ch3 is\n \n          procedure Build_Assertion_Bodies_For_Type (Typ : Entity_Id) is\n          begin\n-            --  Preanalyze and resolve the Default_Initial_Condition assertion\n-            --  expression at the end of the declarations to catch any errors.\n-\n-            if Has_DIC (Typ) then\n-               Build_DIC_Procedure_Body (Typ);\n-            end if;\n-\n             if Nkind (Context) = N_Package_Specification then\n \n                --  Preanalyze and resolve the class-wide invariants of an\n@@ -2341,32 +2334,57 @@ package body Sem_Ch3 is\n                         Partial_Invariant => True);\n                   end if;\n \n-               --  Preanalyze and resolve the invariants of a private type\n-               --  at the end of the visible declarations to catch potential\n-               --  errors. Inherited class-wide invariants are not included\n-               --  because they have already been resolved.\n+               elsif Decls = Visible_Declarations (Context) then\n+                  --  Preanalyze and resolve the invariants of a private type\n+                  --  at the end of the visible declarations to catch potential\n+                  --  errors. Inherited class-wide invariants are not included\n+                  --  because they have already been resolved.\n \n-               elsif Decls = Visible_Declarations (Context)\n-                 and then Ekind (Typ) in E_Limited_Private_Type\n-                                       | E_Private_Type\n-                                       | E_Record_Type_With_Private\n-                 and then Has_Own_Invariants (Typ)\n-               then\n-                  Build_Invariant_Procedure_Body\n-                    (Typ               => Typ,\n-                     Partial_Invariant => True);\n-\n-               --  Preanalyze and resolve the invariants of a private type's\n-               --  full view at the end of the private declarations to catch\n-               --  potential errors.\n-\n-               elsif Decls = Private_Declarations (Context)\n-                 and then (not Is_Private_Type (Typ)\n-                            or else Present (Underlying_Full_View (Typ)))\n-                 and then Has_Private_Declaration (Typ)\n-                 and then Has_Invariants (Typ)\n-               then\n-                  Build_Invariant_Procedure_Body (Typ);\n+                  if Ekind (Typ) in E_Limited_Private_Type\n+                                  | E_Private_Type\n+                                  | E_Record_Type_With_Private\n+                    and then Has_Own_Invariants (Typ)\n+                  then\n+                     Build_Invariant_Procedure_Body\n+                       (Typ               => Typ,\n+                        Partial_Invariant => True);\n+                  end if;\n+\n+                  --  Preanalyze and resolve the Default_Initial_Condition\n+                  --  assertion expression at the end of the declarations to\n+                  --  catch any errors.\n+\n+                  if Ekind (Typ) in E_Limited_Private_Type\n+                                  | E_Private_Type\n+                                  | E_Record_Type_With_Private\n+                     and then Has_Own_DIC (Typ)\n+                  then\n+                     Build_DIC_Procedure_Body\n+                       (Typ         => Typ,\n+                        Partial_DIC => True);\n+                  end if;\n+\n+               elsif Decls = Private_Declarations (Context) then\n+\n+                  --  Preanalyze and resolve the invariants of a private type's\n+                  --  full view at the end of the private declarations to catch\n+                  --  potential errors.\n+\n+                  if (not Is_Private_Type (Typ)\n+                       or else Present (Underlying_Full_View (Typ)))\n+                    and then Has_Private_Declaration (Typ)\n+                    and then Has_Invariants (Typ)\n+                  then\n+                     Build_Invariant_Procedure_Body (Typ);\n+                  end if;\n+\n+                  if (not Is_Private_Type (Typ)\n+                       or else Present (Underlying_Full_View (Typ)))\n+                    and then Has_Private_Declaration (Typ)\n+                    and then Has_DIC (Typ)\n+                  then\n+                     Build_DIC_Procedure_Body (Typ);\n+                  end if;\n                end if;\n             end if;\n          end Build_Assertion_Bodies_For_Type;"}, {"sha": "1bcbb25d5f9038c1b19a495ee5c14919e1bd50e6", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -15111,7 +15111,7 @@ package body Sem_Prag is\n          begin\n             GNAT_Pragma;\n             Check_No_Identifiers;\n-            Check_At_Most_N_Arguments (1);\n+            Check_At_Most_N_Arguments (2);  -- Accounts for implicit type arg\n \n             Typ  := Empty;\n             Stmt := Prev (N);\n@@ -15174,6 +15174,27 @@ package body Sem_Prag is\n \n             Set_Has_Own_DIC (Typ);\n \n+            --  A type entity argument is appended to facilitate inheriting the\n+            --  aspect/pragma from parent types (see Build_DIC_Procedure_Body),\n+            --  though that extra argument isn't documented for the pragma.\n+\n+            if not Present (Arg2) then\n+               --  When the pragma has no arguments, create an argument with\n+               --  the value Empty, so the type name argument can be appended\n+               --  following it (since it's expected as the second argument).\n+\n+               if not Present (Arg1) then\n+                  Set_Pragma_Argument_Associations (N, New_List (\n+                    Make_Pragma_Argument_Association (Sloc (Typ),\n+                      Expression => Empty)));\n+               end if;\n+\n+               Append_To\n+                 (Pragma_Argument_Associations (N),\n+                  Make_Pragma_Argument_Association (Sloc (Typ),\n+                    Expression => New_Occurrence_Of (Typ, Sloc (Typ))));\n+            end if;\n+\n             --  Chain the pragma on the rep item chain for further processing\n \n             Discard := Rep_Item_Too_Late (Typ, N, FOnly => True);"}, {"sha": "72dbc6868af522094387e3140a6efeb70d0a4bd2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -26184,7 +26184,8 @@ package body Sem_Util is\n      (Typ      : Entity_Id;\n       From_Typ : Entity_Id)\n    is\n-      DIC_Proc : Entity_Id;\n+      DIC_Proc         : Entity_Id;\n+      Partial_DIC_Proc : Entity_Id;\n \n    begin\n       if Present (Typ) and then Present (From_Typ) then\n@@ -26205,6 +26206,7 @@ package body Sem_Util is\n          end if;\n \n          DIC_Proc := DIC_Procedure (From_Typ);\n+         Partial_DIC_Proc := Partial_DIC_Procedure (From_Typ);\n \n          --  The setting of the attributes is intentionally conservative. This\n          --  prevents accidental clobbering of enabled attributes.\n@@ -26220,6 +26222,12 @@ package body Sem_Util is\n          if Present (DIC_Proc) and then No (DIC_Procedure (Typ)) then\n             Set_DIC_Procedure (Typ, DIC_Proc);\n          end if;\n+\n+         if Present (Partial_DIC_Proc)\n+           and then No (Partial_DIC_Procedure (Typ))\n+         then\n+            Set_Partial_DIC_Procedure (Typ, Partial_DIC_Proc);\n+         end if;\n       end if;\n    end Propagate_DIC_Attributes;\n "}, {"sha": "2d0a9572f2cb20171cd5d0c6d3da8de6f014eaf5", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -3535,6 +3535,14 @@ package body Sinfo is\n       return Flag2 (N);\n    end Was_Attribute_Reference;\n \n+   function Was_Default_Init_Box_Association\n+     (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Component_Association);\n+      return Flag14 (N);\n+   end Was_Default_Init_Box_Association;\n+\n    function Was_Expression_Function\n       (N : Node_Id) return Boolean is\n    begin\n@@ -7036,6 +7044,14 @@ package body Sinfo is\n       Set_Flag2 (N, Val);\n    end Set_Was_Attribute_Reference;\n \n+   procedure Set_Was_Default_Init_Box_Association\n+     (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Component_Association);\n+      Set_Flag14 (N, Val);\n+   end Set_Was_Default_Init_Box_Association;\n+\n    procedure Set_Was_Expression_Function\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "f9b0667f8af6feec49a0142e689ecc6bb13cc4aa", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=f7937111e8c8cfaf5ea79d97c65d6b6dc29b261f", "patch": "@@ -2412,6 +2412,11 @@ package Sinfo is\n    --    instantiation prologue renames these attributes, and expansion later\n    --    converts them into subprogram bodies.\n \n+   --  Was_Default_Init_Box_Association (Flag14-Sem)\n+   --    Present in N_Component_Association. Set to True if the original source\n+   --    is an aggregate component association with a box (<>) for a component\n+   --    that is initialized by default.\n+\n    --  Was_Expression_Function (Flag18-Sem)\n    --    Present in N_Subprogram_Body. True if the original source had an\n    --    N_Expression_Function, which was converted to the N_Subprogram_Body\n@@ -4120,6 +4125,7 @@ package Sinfo is\n       --  Expression (Node3) (empty if Box_Present)\n       --  Loop_Actions (List5-Sem)\n       --  Box_Present (Flag15)\n+      --  Was_Default_Init_Box_Association (Flag14)\n       --  Inherited_Discriminant (Flag13)\n \n       --  Note: this structure is used for both record component associations\n@@ -4128,7 +4134,9 @@ package Sinfo is\n       --  list of selector names in the record aggregate case, or a list of\n       --  discrete choices in the array aggregate case or an N_Others_Choice\n       --  node (which appears as a singleton list). Box_Present gives support\n-      --  to Ada 2005 (AI-287).\n+      --  to Ada 2005 (AI-287). Was_Default_Init_Box_Association is used for\n+      --  determining the need for Default_Initial_Condition check on component\n+      --  associations with a box.\n \n       ----------------------------------\n       -- 4.3.1  Component Choice List --\n@@ -10254,6 +10262,9 @@ package Sinfo is\n    function Was_Attribute_Reference\n      (N : Node_Id) return Boolean;    -- Flag2\n \n+   function Was_Default_Init_Box_Association\n+     (N : Node_Id) return Boolean;    -- Flag14\n+\n    function Was_Expression_Function\n      (N : Node_Id) return Boolean;    -- Flag18\n \n@@ -11366,6 +11377,9 @@ package Sinfo is\n    procedure Set_Was_Attribute_Reference\n      (N : Node_Id; Val : Boolean := True);    -- Flag2\n \n+   procedure Set_Was_Default_Init_Box_Association\n+     (N : Node_Id; Val : Boolean := True);    -- Flag14\n+\n    procedure Set_Was_Expression_Function\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n@@ -13477,6 +13491,7 @@ package Sinfo is\n    pragma Inline (Visible_Declarations);\n    pragma Inline (Used_Operations);\n    pragma Inline (Was_Attribute_Reference);\n+   pragma Inline (Was_Default_Init_Box_Association);\n    pragma Inline (Was_Expression_Function);\n    pragma Inline (Was_Originally_Stub);\n \n@@ -13842,6 +13857,7 @@ package Sinfo is\n    pragma Inline (Set_Variants);\n    pragma Inline (Set_Visible_Declarations);\n    pragma Inline (Set_Was_Attribute_Reference);\n+   pragma Inline (Set_Was_Default_Init_Box_Association);\n    pragma Inline (Set_Was_Expression_Function);\n    pragma Inline (Set_Was_Originally_Stub);\n "}]}