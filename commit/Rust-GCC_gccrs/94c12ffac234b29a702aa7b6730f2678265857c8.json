{"sha": "94c12ffac234b29a702aa7b6730f2678265857c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRjMTJmZmFjMjM0YjI5YTcwMmFhN2I2NzMwZjI2NzgyNjU4NTdjOA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-09-17T21:39:13Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-09-17T21:39:13Z"}, "message": "Factor predidacte analysis out of tree-ssa-uninit.c into its own module.\n\ngcc/ChangeLog:\n\n\t* Makefile.in (OBJS): Add gimple-predicate-analysis.o.\n\t* tree-ssa-uninit.c (max_phi_args): Move to gimple-predicate-analysis.\n\t(MASK_SET_BIT, MASK_TEST_BIT, MASK_EMPTY): Same.\n\t(check_defs): Add comment.\n\t(can_skip_redundant_opnd): Update comment.\n\t(compute_uninit_opnds_pos): Adjust to namespace change.\n\t(find_pdom): Move to gimple-predicate-analysis.cc.\n\t(find_dom): Same.\n\t(struct uninit_undef_val_t): New.\n\t(is_non_loop_exit_postdominating): Move to gimple-predicate-analysis.cc.\n\t(find_control_equiv_block): Same.\n\t(MAX_NUM_CHAINS, MAX_CHAIN_LEN, MAX_POSTDOM_CHECK): Same.\n\t(MAX_SWITCH_CASES): Same.\n\t(compute_control_dep_chain): Same.\n\t(find_uninit_use): Use predicate analyzer.\n\t(struct pred_info): Move to gimple-predicate-analysis.\n\t(convert_control_dep_chain_into_preds): Same.\n\t(find_predicates): Same.\n\t(collect_phi_def_edges): Same.\n\t(warn_uninitialized_phi): Use predicate analyzer.\n\t(find_def_preds): Move to gimple-predicate-analysis.\n\t(dump_pred_info): Same.\n\t(dump_pred_chain): Same.\n\t(dump_predicates): Same.\n\t(destroy_predicate_vecs): Remove.\n\t(execute_late_warn_uninitialized): New.\n\t(get_cmp_code): Move to gimple-predicate-analysis.\n\t(is_value_included_in): Same.\n\t(value_sat_pred_p): Same.\n\t(find_matching_predicate_in_rest_chains): Same.\n\t(is_use_properly_guarded): Same.\n\t(prune_uninit_phi_opnds): Same.\n\t(find_var_cmp_const): Same.\n\t(use_pred_not_overlap_with_undef_path_pred): Same.\n\t(pred_equal_p): Same.\n\t(is_neq_relop_p): Same.\n\t(is_neq_zero_form_p): Same.\n\t(pred_expr_equal_p): Same.\n\t(is_pred_expr_subset_of): Same.\n\t(is_pred_chain_subset_of): Same.\n\t(is_included_in): Same.\n\t(is_superset_of): Same.\n\t(pred_neg_p): Same.\n\t(simplify_pred): Same.\n\t(simplify_preds_2): Same.\n\t(simplify_preds_3): Same.\n\t(simplify_preds_4): Same.\n\t(simplify_preds): Same.\n\t(push_pred): Same.\n\t(push_to_worklist): Same.\n\t(get_pred_info_from_cmp): Same.\n\t(is_degenerated_phi): Same.\n\t(normalize_one_pred_1): Same.\n\t(normalize_one_pred): Same.\n\t(normalize_one_pred_chain): Same.\n\t(normalize_preds): Same.\n\t(can_one_predicate_be_invalidated_p): Same.\n\t(can_chain_union_be_invalidated_p): Same.\n\t(uninit_uses_cannot_happen): Same.\n\t(pass_late_warn_uninitialized::execute): Define.\n\t* gimple-predicate-analysis.cc: New file.\n\t* gimple-predicate-analysis.h: New file.", "tree": {"sha": "39a583cbfb2147f987db443568b89e135afa029e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39a583cbfb2147f987db443568b89e135afa029e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94c12ffac234b29a702aa7b6730f2678265857c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94c12ffac234b29a702aa7b6730f2678265857c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94c12ffac234b29a702aa7b6730f2678265857c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94c12ffac234b29a702aa7b6730f2678265857c8/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51166eb2c534692c3c7779def24f83c8c3811b98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51166eb2c534692c3c7779def24f83c8c3811b98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51166eb2c534692c3c7779def24f83c8c3811b98"}], "stats": {"total": 4990, "additions": 2741, "deletions": 2249}, "files": [{"sha": "f36ffa4740b787549f463d8450f77d529c8eb99d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94c12ffac234b29a702aa7b6730f2678265857c8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94c12ffac234b29a702aa7b6730f2678265857c8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=94c12ffac234b29a702aa7b6730f2678265857c8", "patch": "@@ -1394,6 +1394,7 @@ OBJS = \\\n \tgimple-loop-jam.o \\\n \tgimple-loop-versioning.o \\\n \tgimple-low.o \\\n+\tgimple-predicate-analysis.o \\\n \tgimple-pretty-print.o \\\n \tgimple-range.o \\\n \tgimple-range-cache.o \\"}, {"sha": "3404f2d630acb9bf0fbd9221b0fa180cb5f80313", "filename": "gcc/gimple-predicate-analysis.cc", "status": "added", "additions": 2400, "deletions": 0, "changes": 2400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94c12ffac234b29a702aa7b6730f2678265857c8/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94c12ffac234b29a702aa7b6730f2678265857c8/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=94c12ffac234b29a702aa7b6730f2678265857c8", "patch": "@@ -0,0 +1,2400 @@\n+/* Support for simple predicate analysis.\n+\n+   Copyright (C) 2001-2021 Free Software Foundation, Inc.\n+   Contributed by Xinliang David Li <davidxl@google.com>\n+   Generalized by Martin Sebor <msebor@redhat.com>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define INCLUDE_STRING\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"diagnostic-core.h\"\n+#include \"fold-const.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-ssa.h\"\n+#include \"tree-cfg.h\"\n+#include \"cfghooks.h\"\n+#include \"attribs.h\"\n+#include \"builtins.h\"\n+#include \"calls.h\"\n+#include \"value-query.h\"\n+\n+#include \"gimple-predicate-analysis.h\"\n+\n+#define DEBUG_PREDICATE_ANALYZER 1\n+\n+/* Find the immediate postdominator of the specified basic block BB.  */\n+\n+static inline basic_block\n+find_pdom (basic_block bb)\n+{\n+  basic_block exit_bb = EXIT_BLOCK_PTR_FOR_FN (cfun);\n+  if (bb == exit_bb)\n+    return exit_bb;\n+\n+  if (basic_block pdom = get_immediate_dominator (CDI_POST_DOMINATORS, bb))\n+    return pdom;\n+\n+  return exit_bb;\n+}\n+\n+/* Find the immediate dominator of the specified basic block BB.  */\n+\n+static inline basic_block\n+find_dom (basic_block bb)\n+{\n+  basic_block entry_bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  if (bb == entry_bb)\n+    return entry_bb;\n+\n+  if (basic_block dom = get_immediate_dominator (CDI_DOMINATORS, bb))\n+    return dom;\n+\n+  return entry_bb;\n+}\n+\n+/* Return true if BB1 is postdominating BB2 and BB1 is not a loop exit\n+   bb.  The loop exit bb check is simple and does not cover all cases.  */\n+\n+static bool\n+is_non_loop_exit_postdominating (basic_block bb1, basic_block bb2)\n+{\n+  if (!dominated_by_p (CDI_POST_DOMINATORS, bb2, bb1))\n+    return false;\n+\n+  if (single_pred_p (bb1) && !single_succ_p (bb2))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Find BB's closest postdominator that is its control equivalent (i.e.,\n+   that's controlled by the same predicate).  */\n+\n+static inline basic_block\n+find_control_equiv_block (basic_block bb)\n+{\n+  basic_block pdom = find_pdom (bb);\n+\n+  /* Skip the postdominating bb that is also a loop exit.  */\n+  if (!is_non_loop_exit_postdominating (pdom, bb))\n+    return NULL;\n+\n+  /* If the postdominator is dominated by BB, return it.  */\n+  if (dominated_by_p (CDI_DOMINATORS, pdom, bb))\n+    return pdom;\n+\n+  return NULL;\n+}\n+\n+/* Return true if X1 is the negation of X2.  */\n+\n+static inline bool\n+pred_neg_p (const pred_info &x1, const pred_info &x2)\n+{\n+  if (!operand_equal_p (x1.pred_lhs, x2.pred_lhs, 0)\n+      || !operand_equal_p (x1.pred_rhs, x2.pred_rhs, 0))\n+    return false;\n+\n+  tree_code c1 = x1.cond_code, c2;\n+  if (x1.invert == x2.invert)\n+    c2 = invert_tree_comparison (x2.cond_code, false);\n+  else\n+    c2 = x2.cond_code;\n+\n+  return c1 == c2;\n+}\n+\n+/* Return whether the condition (VAL CMPC BOUNDARY) is true.  */\n+\n+static bool\n+is_value_included_in (tree val, tree boundary, tree_code cmpc)\n+{\n+  /* Only handle integer constant here.  */\n+  if (TREE_CODE (val) != INTEGER_CST || TREE_CODE (boundary) != INTEGER_CST)\n+    return true;\n+\n+  bool inverted = false;\n+  if (cmpc == GE_EXPR || cmpc == GT_EXPR || cmpc == NE_EXPR)\n+    {\n+      cmpc = invert_tree_comparison (cmpc, false);\n+      inverted = true;\n+    }\n+\n+  bool result;\n+  if (cmpc == EQ_EXPR)\n+    result = tree_int_cst_equal (val, boundary);\n+  else if (cmpc == LT_EXPR)\n+    result = tree_int_cst_lt (val, boundary);\n+  else\n+    {\n+      gcc_assert (cmpc == LE_EXPR);\n+      result = tree_int_cst_le (val, boundary);\n+    }\n+\n+  if (inverted)\n+    result ^= 1;\n+\n+  return result;\n+}\n+\n+/* Format the vector of edges EV as a string.  */\n+\n+static std::string\n+format_edge_vec (const vec<edge> &ev)\n+{\n+  std::string str;\n+\n+  unsigned n = ev.length ();\n+  for (unsigned i = 0; i < n; ++i)\n+    {\n+      char es[32];\n+      const_edge e = ev[i];\n+      sprintf (es, \"%u\", e->src->index);\n+      str += es;\n+      if (i + 1 < n)\n+\tstr += \" -> \";\n+    }\n+  return str;\n+}\n+\n+/* Format the first N elements of the array of vector of edges EVA as\n+   a string.  */\n+\n+static std::string\n+format_edge_vecs (const vec<edge> eva[], unsigned n)\n+{\n+  std::string str;\n+\n+  for (unsigned i = 0; i != n; ++i)\n+    {\n+      str += '{';\n+      str += format_edge_vec (eva[i]);\n+      str += '}';\n+      if (i + 1 < n)\n+\tstr += \", \";\n+    }\n+  return str;\n+}\n+\n+/* Dump a single pred_info to DUMP_FILE.  */\n+\n+static void\n+dump_pred_info (const pred_info &pred)\n+{\n+  if (pred.invert)\n+    fprintf (dump_file, \"NOT (\");\n+  print_generic_expr (dump_file, pred.pred_lhs);\n+  fprintf (dump_file, \" %s \", op_symbol_code (pred.cond_code));\n+  print_generic_expr (dump_file, pred.pred_rhs);\n+  if (pred.invert)\n+    fputc (')', dump_file);\n+}\n+\n+/* Dump a pred_chain to DUMP_FILE.  */\n+\n+static void\n+dump_pred_chain (const pred_chain &chain)\n+{\n+  unsigned np = chain.length ();\n+  if (np > 1)\n+    fprintf (dump_file, \"AND (\");\n+\n+  for (unsigned j = 0; j < np; j++)\n+    {\n+      dump_pred_info (chain[j]);\n+      if (j < np - 1)\n+\tfprintf (dump_file, \", \");\n+      else if (j > 0)\n+\tfputc (')', dump_file);\n+    }\n+}\n+\n+/* Dump the predicate chain PREDS for STMT, prefixed by MSG.  */\n+\n+static void\n+dump_predicates (gimple *stmt, const pred_chain_union &preds, const char *msg)\n+{\n+  fprintf (dump_file, \"%s\", msg);\n+  if (stmt)\n+    {\n+      print_gimple_stmt (dump_file, stmt, 0);\n+      fprintf (dump_file, \"is guarded by:\\n\");\n+    }\n+\n+  unsigned np = preds.length ();\n+  if (np > 1)\n+    fprintf (dump_file, \"OR (\");\n+  for (unsigned i = 0; i < np; i++)\n+    {\n+      dump_pred_chain (preds[i]);\n+      if (i < np - 1)\n+\tfprintf (dump_file, \", \");\n+      else if (i > 0)\n+\tfputc (')', dump_file);\n+    }\n+  fputc ('\\n', dump_file);\n+}\n+\n+/* Dump the first NCHAINS elements of the DEP_CHAINS array into DUMP_FILE.  */\n+\n+static void\n+dump_dep_chains (const auto_vec<edge> dep_chains[], unsigned nchains)\n+{\n+  if (!dump_file)\n+    return;\n+\n+  for (unsigned i = 0; i != nchains; ++i)\n+    {\n+      const auto_vec<edge> &v = dep_chains[i];\n+      unsigned n = v.length ();\n+      for (unsigned j = 0; j != n; ++j)\n+\t{\n+\t  fprintf (dump_file, \"%u\", v[j]->src->index);\n+\t  if (j + 1 < n)\n+\t    fprintf (dump_file, \" -> \");\n+\t}\n+      fputc ('\\n', dump_file);\n+    }\n+}\n+\n+/* Return the 'normalized' conditional code with operand swapping\n+   and condition inversion controlled by SWAP_COND and INVERT.  */\n+\n+static tree_code\n+get_cmp_code (tree_code orig_cmp_code, bool swap_cond, bool invert)\n+{\n+  tree_code tc = orig_cmp_code;\n+\n+  if (swap_cond)\n+    tc = swap_tree_comparison (orig_cmp_code);\n+  if (invert)\n+    tc = invert_tree_comparison (tc, false);\n+\n+  switch (tc)\n+    {\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      break;\n+    default:\n+      return ERROR_MARK;\n+    }\n+  return tc;\n+}\n+\n+/* Return true if PRED is common among all predicate chains in PREDS\n+   (and therefore can be factored out).  */\n+\n+static bool\n+find_matching_predicate_in_rest_chains (const pred_info &pred,\n+\t\t\t\t\tconst pred_chain_union &preds)\n+{\n+  /* Trival case.  */\n+  if (preds.length () == 1)\n+    return true;\n+\n+  for (unsigned i = 1; i < preds.length (); i++)\n+    {\n+      bool found = false;\n+      const pred_chain &chain = preds[i];\n+      unsigned n = chain.length ();\n+      for (unsigned j = 0; j < n; j++)\n+\t{\n+\t  const pred_info &pred2 = chain[j];\n+\t  /* Can relax the condition comparison to not use address\n+\t     comparison.  However, the most common case is that\n+\t     multiple control dependent paths share a common path\n+\t     prefix, so address comparison should be ok.  */\n+\t  if (operand_equal_p (pred2.pred_lhs, pred.pred_lhs, 0)\n+\t      && operand_equal_p (pred2.pred_rhs, pred.pred_rhs, 0)\n+\t      && pred2.invert == pred.invert)\n+\t    {\n+\t      found = true;\n+\t      break;\n+\t    }\n+\t}\n+      if (!found)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Find a predicate to examine against paths of interest.  If there\n+   is no predicate of the \"FLAG_VAR CMP CONST\" form, try to find one\n+   of that's the form \"FLAG_VAR CMP FLAG_VAR\" with value range info.\n+   PHI is the phi node whose incoming (interesting) paths need to be\n+   examined.  On success, return the comparison code, set defintion\n+   gimple of FLAG_DEF and BOUNDARY_CST.  Otherwise return ERROR_MARK.  */\n+\n+static tree_code\n+find_var_cmp_const (pred_chain_union preds, gphi *phi, gimple **flag_def,\n+\t\t    tree *boundary_cst)\n+{\n+  tree_code vrinfo_code = ERROR_MARK;\n+  gimple *vrinfo_def = NULL;\n+  tree vrinfo_cst = NULL;\n+\n+  gcc_assert (preds.length () > 0);\n+  pred_chain chain = preds[0];\n+  for (unsigned i = 0; i < chain.length (); i++)\n+    {\n+      bool use_vrinfo_p = false;\n+      const pred_info &pred = chain[i];\n+      tree cond_lhs = pred.pred_lhs;\n+      tree cond_rhs = pred.pred_rhs;\n+      if (cond_lhs == NULL_TREE || cond_rhs == NULL_TREE)\n+\tcontinue;\n+\n+      tree_code code = get_cmp_code (pred.cond_code, false, pred.invert);\n+      if (code == ERROR_MARK)\n+\tcontinue;\n+\n+      /* Convert to the canonical form SSA_NAME CMP CONSTANT.  */\n+      if (TREE_CODE (cond_lhs) == SSA_NAME\n+\t  && is_gimple_constant (cond_rhs))\n+\t;\n+      else if (TREE_CODE (cond_rhs) == SSA_NAME\n+\t       && is_gimple_constant (cond_lhs))\n+\t{\n+\t  std::swap (cond_lhs, cond_rhs);\n+\t  if ((code = get_cmp_code (code, true, false)) == ERROR_MARK)\n+\t    continue;\n+\t}\n+      /* Check if we can take advantage of FLAG_VAR COMP FLAG_VAR predicate\n+\t with value range info.  Note only first of such case is handled.  */\n+      else if (vrinfo_code == ERROR_MARK\n+\t       && TREE_CODE (cond_lhs) == SSA_NAME\n+\t       && TREE_CODE (cond_rhs) == SSA_NAME)\n+\t{\n+\t  gimple* lhs_def = SSA_NAME_DEF_STMT (cond_lhs);\n+\t  if (!lhs_def || gimple_code (lhs_def) != GIMPLE_PHI\n+\t      || gimple_bb (lhs_def) != gimple_bb (phi))\n+\t    {\n+\t      std::swap (cond_lhs, cond_rhs);\n+\t      if ((code = get_cmp_code (code, true, false)) == ERROR_MARK)\n+\t\tcontinue;\n+\t    }\n+\n+\t  /* Check value range info of rhs, do following transforms:\n+\t       flag_var < [min, max]  ->  flag_var < max\n+\t       flag_var > [min, max]  ->  flag_var > min\n+\n+\t     We can also transform LE_EXPR/GE_EXPR to LT_EXPR/GT_EXPR:\n+\t       flag_var <= [min, max] ->  flag_var < [min, max+1]\n+\t       flag_var >= [min, max] ->  flag_var > [min-1, max]\n+\t     if no overflow/wrap.  */\n+\t  tree type = TREE_TYPE (cond_lhs);\n+\t  value_range r;\n+\t  if (!INTEGRAL_TYPE_P (type)\n+\t      || !get_range_query (cfun)->range_of_expr (r, cond_rhs)\n+\t      || r.kind () != VR_RANGE)\n+\t    continue;\n+\n+\t  wide_int min = r.lower_bound ();\n+\t  wide_int max = r.upper_bound ();\n+\t  if (code == LE_EXPR\n+\t      && max != wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type)))\n+\t    {\n+\t      code = LT_EXPR;\n+\t      max = max + 1;\n+\t    }\n+\t  if (code == GE_EXPR\n+\t      && min != wi::min_value (TYPE_PRECISION (type), TYPE_SIGN (type)))\n+\t    {\n+\t      code = GT_EXPR;\n+\t      min = min - 1;\n+\t    }\n+\t  if (code == LT_EXPR)\n+\t    cond_rhs = wide_int_to_tree (type, max);\n+\t  else if (code == GT_EXPR)\n+\t    cond_rhs = wide_int_to_tree (type, min);\n+\t  else\n+\t    continue;\n+\n+\t  use_vrinfo_p = true;\n+\t}\n+      else\n+\tcontinue;\n+\n+      if ((*flag_def = SSA_NAME_DEF_STMT (cond_lhs)) == NULL)\n+\tcontinue;\n+\n+      if (gimple_code (*flag_def) != GIMPLE_PHI\n+\t  || gimple_bb (*flag_def) != gimple_bb (phi)\n+\t  || !find_matching_predicate_in_rest_chains (pred, preds))\n+\tcontinue;\n+\n+      /* Return if any \"flag_var comp const\" predicate is found.  */\n+      if (!use_vrinfo_p)\n+\t{\n+\t  *boundary_cst = cond_rhs;\n+\t  return code;\n+\t}\n+      /* Record if any \"flag_var comp flag_var[vinfo]\" predicate is found.  */\n+      else if (vrinfo_code == ERROR_MARK)\n+\t{\n+\t  vrinfo_code = code;\n+\t  vrinfo_def = *flag_def;\n+\t  vrinfo_cst = cond_rhs;\n+\t}\n+    }\n+  /* Return the \"flag_var cmp flag_var[vinfo]\" predicate we found.  */\n+  if (vrinfo_code != ERROR_MARK)\n+    {\n+      *flag_def = vrinfo_def;\n+      *boundary_cst = vrinfo_cst;\n+    }\n+  return vrinfo_code;\n+}\n+\n+/* Return true if all interesting opnds are pruned, false otherwise.\n+   PHI is the phi node with interesting operands, OPNDS is the bitmap\n+   of the interesting operand positions, FLAG_DEF is the statement\n+   defining the flag guarding the use of the PHI output, BOUNDARY_CST\n+   is the const value used in the predicate associated with the flag,\n+   CMP_CODE is the comparison code used in the predicate, VISITED_PHIS\n+   is the pointer set of phis visited, and VISITED_FLAG_PHIS is\n+   the pointer to the pointer set of flag definitions that are also\n+   phis.\n+\n+   Example scenario:\n+\n+   BB1:\n+     flag_1 = phi <0, 1>\t\t\t// (1)\n+     var_1  = phi <undef, some_val>\n+\n+\n+   BB2:\n+     flag_2 = phi <0,   flag_1, flag_1>\t\t// (2)\n+     var_2  = phi <undef, var_1, var_1>\n+     if (flag_2 == 1)\n+       goto BB3;\n+\n+   BB3:\n+     use of var_2\t\t\t\t// (3)\n+\n+   Because some flag arg in (1) is not constant, if we do not look into\n+   the flag phis recursively, it is conservatively treated as unknown and\n+   var_1 is thought to flow into use at (3).  Since var_1 is potentially\n+   uninitialized a false warning will be emitted.\n+   Checking recursively into (1), the compiler can find out that only\n+   some_val (which is defined) can flow into (3) which is OK.  */\n+\n+static bool\n+prune_phi_opnds (gphi *phi, unsigned opnds, gphi *flag_def,\n+\t\t tree boundary_cst, tree_code cmp_code,\n+\t\t predicate::func_t &eval,\n+\t\t hash_set<gphi *> *visited_phis,\n+\t\t bitmap *visited_flag_phis)\n+{\n+  /* The Boolean predicate guarding the PHI definition.  Initialized\n+     lazily from PHI in the first call to is_use_guarded() and cached\n+     for subsequent iterations.  */\n+  predicate def_preds (eval);\n+\n+  unsigned n = MIN (eval.max_phi_args, gimple_phi_num_args (flag_def));\n+  for (unsigned i = 0; i < n; i++)\n+    {\n+      if (!MASK_TEST_BIT (opnds, i))\n+\tcontinue;\n+\n+      tree flag_arg = gimple_phi_arg_def (flag_def, i);\n+      if (!is_gimple_constant (flag_arg))\n+\t{\n+\t  if (TREE_CODE (flag_arg) != SSA_NAME)\n+\t    return false;\n+\n+\t  gphi *flag_arg_def = dyn_cast<gphi *> (SSA_NAME_DEF_STMT (flag_arg));\n+\t  if (!flag_arg_def)\n+\t    return false;\n+\n+\t  tree phi_arg = gimple_phi_arg_def (phi, i);\n+\t  if (TREE_CODE (phi_arg) != SSA_NAME)\n+\t    return false;\n+\n+\t  gphi *phi_arg_def = dyn_cast<gphi *> (SSA_NAME_DEF_STMT (phi_arg));\n+\t  if (!phi_arg_def)\n+\t    return false;\n+\n+\t  if (gimple_bb (phi_arg_def) != gimple_bb (flag_arg_def))\n+\t    return false;\n+\n+\t  if (!*visited_flag_phis)\n+\t    *visited_flag_phis = BITMAP_ALLOC (NULL);\n+\n+\t  tree phi_result = gimple_phi_result (flag_arg_def);\n+\t  if (bitmap_bit_p (*visited_flag_phis, SSA_NAME_VERSION (phi_result)))\n+\t    return false;\n+\n+\t  bitmap_set_bit (*visited_flag_phis, SSA_NAME_VERSION (phi_result));\n+\n+\t  /* Now recursively try to prune the interesting phi args.  */\n+\t  unsigned opnds_arg_phi = eval.phi_arg_set (phi_arg_def);\n+\t  if (!prune_phi_opnds (phi_arg_def, opnds_arg_phi, flag_arg_def,\n+\t\t\t\tboundary_cst, cmp_code, eval, visited_phis,\n+\t\t\t\tvisited_flag_phis))\n+\t    return false;\n+\n+\t  bitmap_clear_bit (*visited_flag_phis, SSA_NAME_VERSION (phi_result));\n+\t  continue;\n+\t}\n+\n+      /* Now check if the constant is in the guarded range.  */\n+      if (is_value_included_in (flag_arg, boundary_cst, cmp_code))\n+\t{\n+\t  /* Now that we know that this undefined edge is not pruned.\n+\t     If the operand is defined by another phi, we can further\n+\t     prune the incoming edges of that phi by checking\n+\t     the predicates of this operands.  */\n+\n+\t  tree opnd = gimple_phi_arg_def (phi, i);\n+\t  gimple *opnd_def = SSA_NAME_DEF_STMT (opnd);\n+\t  if (gphi *opnd_def_phi = dyn_cast <gphi *> (opnd_def))\n+\t    {\n+\t      unsigned opnds2 = eval.phi_arg_set (opnd_def_phi);\n+\t      if (!MASK_EMPTY (opnds2))\n+\t\t{\n+\t\t  edge opnd_edge = gimple_phi_arg_edge (phi, i);\n+\t\t  if (def_preds.is_use_guarded (phi, opnd_edge->src,\n+\t\t\t\t\t\topnd_def_phi, opnds2,\n+\t\t\t\t\t\tvisited_phis))\n+\t\t    return false;\n+\t\t}\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Recursively compute the set PHI's incoming edges with \"uninteresting\"\n+   operands of a phi chain, i.e., those for which EVAL returns false.\n+   CD_ROOT is the control dependence root from which edges are collected\n+   up the CFG nodes that it's dominated by.  *EDGES holds the result, and\n+   VISITED is used for detecting cycles.  */\n+\n+static void\n+collect_phi_def_edges (gphi *phi, basic_block cd_root, auto_vec<edge> *edges,\n+\t\t       predicate::func_t &eval, hash_set<gimple *> *visited)\n+{\n+  if (visited->elements () == 0\n+      && DEBUG_PREDICATE_ANALYZER\n+      && dump_file)\n+    {\n+      fprintf (dump_file, \"%s for cd_root %u and \",\n+\t       __func__, cd_root->index);\n+      print_gimple_stmt (dump_file, phi, 0);\n+\n+    }\n+\n+  if (visited->add (phi))\n+    return;\n+\n+  unsigned n = gimple_phi_num_args (phi);\n+  for (unsigned i = 0; i < n; i++)\n+    {\n+      edge opnd_edge = gimple_phi_arg_edge (phi, i);\n+      tree opnd = gimple_phi_arg_def (phi, i);\n+\n+      if (TREE_CODE (opnd) == SSA_NAME)\n+\t{\n+\t  gimple *def = SSA_NAME_DEF_STMT (opnd);\n+\n+\t  if (gimple_code (def) == GIMPLE_PHI\n+\t      && dominated_by_p (CDI_DOMINATORS, gimple_bb (def), cd_root))\n+\t    collect_phi_def_edges (as_a<gphi *> (def), cd_root, edges, eval,\n+\t\t\t\t   visited);\n+\t  else if (!eval (opnd))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"\\tFound def edge %i -> %i for cd_root %i \"\n+\t\t\t   \"and operand %u of: \",\n+\t\t\t   opnd_edge->src->index, opnd_edge->dest->index,\n+\t\t\t   cd_root->index, i);\n+\t\t  print_gimple_stmt (dump_file, phi, 0);\n+\t\t}\n+\t      edges->safe_push (opnd_edge);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"\\tFound def edge %i -> %i for cd_root %i \"\n+\t\t       \"and operand %u of: \",\n+\t\t       opnd_edge->src->index, opnd_edge->dest->index,\n+\t\t       cd_root->index, i);\n+\t      print_gimple_stmt (dump_file, phi, 0);\n+\t    }\n+\n+\t  if (!eval (opnd))\n+\t    edges->safe_push (opnd_edge);\n+\t}\n+    }\n+}\n+\n+/* Return an expression corresponding to the predicate PRED.  */\n+\n+static tree\n+build_pred_expr (const pred_info &pred)\n+{\n+  tree_code cond_code = pred.cond_code;\n+  tree lhs = pred.pred_lhs;\n+  tree rhs = pred.pred_rhs;\n+\n+  if (pred.invert)\n+    cond_code = invert_tree_comparison (cond_code, false);\n+\n+  return build2 (cond_code, TREE_TYPE (lhs), lhs, rhs);\n+}\n+\n+/* Return an expression corresponding to PREDS.  */\n+\n+static tree\n+build_pred_expr (const pred_chain_union &preds, bool invert = false)\n+{\n+  tree_code code = invert ? TRUTH_AND_EXPR : TRUTH_OR_EXPR;\n+  tree_code subcode = invert ? TRUTH_OR_EXPR : TRUTH_AND_EXPR;\n+\n+  tree expr = NULL_TREE;\n+  for (unsigned i = 0; i != preds.length (); ++i)\n+    {\n+      tree subexpr = NULL_TREE;\n+      for (unsigned j = 0; j != preds[i].length (); ++j)\n+       {\n+         const pred_info &pi = preds[i][j];\n+         tree cond = build_pred_expr (pi);\n+\t if (invert)\n+\t   cond = invert_truthvalue (cond);\n+         subexpr = subexpr ? build2 (subcode, boolean_type_node,\n+                                     subexpr, cond) : cond;\n+       }\n+      if (expr)\n+       expr = build2 (code, boolean_type_node, expr, subexpr);\n+      else\n+       expr = subexpr;\n+    }\n+\n+  return expr;\n+}\n+\n+/* Return a bitset of all PHI arguments or zero if there are too many.  */\n+\n+unsigned\n+predicate::func_t::phi_arg_set (gphi *phi)\n+{\n+  unsigned n = gimple_phi_num_args (phi);\n+\n+  if (max_phi_args < n)\n+    return 0;\n+\n+  /* Set the least significant N bits.  */\n+  return (1U << n) - 1;\n+}\n+\n+/* Determine if the predicate set of the use does not overlap with that\n+   of the interesting paths.  The most common senario of guarded use is\n+   in Example 1:\n+     Example 1:\n+\t   if (some_cond)\n+\t   {\n+\t      x = ...;   // set x to valid\n+\t      flag = true;\n+\t   }\n+\n+\t    ... some code ...\n+\n+\t   if (flag)\n+\t      use (x);   // use when x is valid\n+\n+     The real world examples are usually more complicated, but similar\n+     and usually result from inlining:\n+\n+\t bool init_func (int * x)\n+\t {\n+\t     if (some_cond)\n+\t\treturn false;\n+\t     *x  =  ...;   // set *x to valid\n+\t     return true;\n+\t }\n+\n+\t void foo (..)\n+\t {\n+\t     int x;\n+\n+\t     if (!init_func (&x))\n+\t\treturn;\n+\n+\t     .. some_code ...\n+\t     use (x);      // use when x is valid\n+\t }\n+\n+     Another possible use scenario is in the following trivial example:\n+\n+     Example 2:\n+\t  if (n > 0)\n+\t     x = 1;\n+\t  ...\n+\t  if (n > 0)\n+\t    {\n+\t      if (m < 2)\n+\t\t ... = x;\n+\t    }\n+\n+     Predicate analysis needs to compute the composite predicate:\n+\n+       1) 'x' use predicate: (n > 0) .AND. (m < 2)\n+       2) 'x' default value  (non-def) predicate: .NOT. (n > 0)\n+       (the predicate chain for phi operand defs can be computed\n+       starting from a bb that is control equivalent to the phi's\n+       bb and is dominating the operand def.)\n+\n+       and check overlapping:\n+\t  (n > 0) .AND. (m < 2) .AND. (.NOT. (n > 0))\n+\t<==> false\n+\n+     This implementation provides a framework that can handle different\n+     scenarios.  (Note that many simple cases are handled properly without\n+     the predicate analysis if jump threading eliminates the merge point\n+     thus makes path-sensitive analysis unnecessary.)\n+\n+     PHI is the phi node whose incoming (undefined) paths need to be\n+     pruned, and OPNDS is the bitmap holding interesting operand\n+     positions.  VISITED is the pointer set of phi stmts being\n+     checked.  */\n+\n+bool\n+predicate::overlap (gphi *phi, unsigned opnds, hash_set<gphi *> *visited)\n+{\n+  gimple *flag_def = NULL;\n+  tree boundary_cst = NULL_TREE;\n+  bitmap visited_flag_phis = NULL;\n+\n+  /* Find within the common prefix of multiple predicate chains\n+     a predicate that is a comparison of a flag variable against\n+     a constant.  */\n+  tree_code cmp_code = find_var_cmp_const (m_preds, phi, &flag_def,\n+\t\t\t\t\t   &boundary_cst);\n+  if (cmp_code == ERROR_MARK)\n+    return true;\n+\n+  /* Now check all the uninit incoming edges have a constant flag\n+     value that is in conflict with the use guard/predicate.  */\n+  gphi *phi_def = as_a<gphi *> (flag_def);\n+  bool all_pruned = prune_phi_opnds (phi, opnds, phi_def, boundary_cst,\n+\t\t\t\t     cmp_code, m_eval, visited,\n+\t\t\t\t     &visited_flag_phis);\n+\n+  if (visited_flag_phis)\n+    BITMAP_FREE (visited_flag_phis);\n+\n+  return !all_pruned;\n+}\n+\n+/* Return true if two predicates PRED1 and X2 are equivalent.  Assume\n+   the expressions have already properly re-associated.  */\n+\n+static inline bool\n+pred_equal_p (const pred_info &pred1, const pred_info &pred2)\n+{\n+  if (!operand_equal_p (pred1.pred_lhs, pred2.pred_lhs, 0)\n+      || !operand_equal_p (pred1.pred_rhs, pred2.pred_rhs, 0))\n+    return false;\n+\n+  tree_code c1 = pred1.cond_code, c2;\n+  if (pred1.invert != pred2.invert\n+      && TREE_CODE_CLASS (pred2.cond_code) == tcc_comparison)\n+    c2 = invert_tree_comparison (pred2.cond_code, false);\n+  else\n+    c2 = pred2.cond_code;\n+\n+  return c1 == c2;\n+}\n+\n+/* Return true if PRED tests inequality (i.e., X != Y).  */\n+\n+static inline bool\n+is_neq_relop_p (const pred_info &pred)\n+{\n+\n+  return ((pred.cond_code == NE_EXPR && !pred.invert)\n+\t  || (pred.cond_code == EQ_EXPR && pred.invert));\n+}\n+\n+/* Returns true if PRED is of the form X != 0.  */\n+\n+static inline bool\n+is_neq_zero_form_p (const pred_info &pred)\n+{\n+  if (!is_neq_relop_p (pred) || !integer_zerop (pred.pred_rhs)\n+      || TREE_CODE (pred.pred_lhs) != SSA_NAME)\n+    return false;\n+  return true;\n+}\n+\n+/* Return true if PRED is equivalent to X != 0.  */\n+\n+static inline bool\n+pred_expr_equal_p (const pred_info &pred, tree expr)\n+{\n+  if (!is_neq_zero_form_p (pred))\n+    return false;\n+\n+  return operand_equal_p (pred.pred_lhs, expr, 0);\n+}\n+\n+/* Return true if VAL satisfies (x CMPC BOUNDARY) predicate.  CMPC can\n+   be either one of the range comparison codes ({GE,LT,EQ,NE}_EXPR and\n+   the like), or BIT_AND_EXPR.  EXACT_P is only meaningful for the latter.\n+   Modify the question from VAL & BOUNDARY != 0 to VAL & BOUNDARY == VAL.\n+   For other values of CMPC, EXACT_P is ignored.  */\n+\n+static bool\n+value_sat_pred_p (tree val, tree boundary, tree_code cmpc,\n+\t\t  bool exact_p = false)\n+{\n+  if (cmpc != BIT_AND_EXPR)\n+    return is_value_included_in (val, boundary, cmpc);\n+\n+  wide_int andw = wi::to_wide (val) & wi::to_wide (boundary);\n+  if (exact_p)\n+    return andw == wi::to_wide (val);\n+\n+  return andw.to_uhwi ();\n+}\n+\n+/* Return true if the domain of single predicate expression PRED1\n+   is a subset of that of PRED2, and false if it cannot be proved.  */\n+\n+static bool\n+subset_of (const pred_info &pred1, const pred_info &pred2)\n+{\n+  if (pred_equal_p (pred1, pred2))\n+    return true;\n+\n+  if ((TREE_CODE (pred1.pred_rhs) != INTEGER_CST)\n+      || (TREE_CODE (pred2.pred_rhs) != INTEGER_CST))\n+    return false;\n+\n+  if (!operand_equal_p (pred1.pred_lhs, pred2.pred_lhs, 0))\n+    return false;\n+\n+  tree_code code1 = pred1.cond_code;\n+  if (pred1.invert)\n+    code1 = invert_tree_comparison (code1, false);\n+  tree_code code2 = pred2.cond_code;\n+  if (pred2.invert)\n+    code2 = invert_tree_comparison (code2, false);\n+\n+  if (code2 == NE_EXPR && code1 == NE_EXPR)\n+    return false;\n+\n+  if (code2 == NE_EXPR)\n+    return !value_sat_pred_p (pred2.pred_rhs, pred1.pred_rhs, code1);\n+\n+  if (code1 == EQ_EXPR)\n+    return value_sat_pred_p (pred1.pred_rhs, pred2.pred_rhs, code2);\n+\n+  if (code1 == code2)\n+    return value_sat_pred_p (pred1.pred_rhs, pred2.pred_rhs, code2,\n+\t\t\t     code1 == BIT_AND_EXPR);\n+\n+  return false;\n+}\n+\n+/* Return true if the domain of CHAIN1 is a subset of that of CHAIN2.\n+   Return false if it cannot be proven so.  */\n+\n+static bool\n+subset_of (const pred_chain &chain1, const pred_chain &chain2)\n+{\n+  unsigned np1 = chain1.length ();\n+  unsigned np2 = chain2.length ();\n+  for (unsigned i2 = 0; i2 < np2; i2++)\n+    {\n+      bool found = false;\n+      const pred_info &info2 = chain2[i2];\n+      for (unsigned i1 = 0; i1 < np1; i1++)\n+\t{\n+\t  const pred_info &info1 = chain1[i1];\n+\t  if (subset_of (info1, info2))\n+\t    {\n+\t      found = true;\n+\t      break;\n+\t    }\n+\t}\n+      if (!found)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Return true if the domain defined by the predicate chain PREDS is\n+   a subset of the domain of *THIS.  Return false if PREDS's domain\n+   is not a subset of any of the sub-domains of *THIS (corresponding\n+   to each individual chains in it), even though it may be still be\n+   a subset of whole domain of *THIS which is the union (ORed) of all\n+   its subdomains.  In other words, the result is conservative.  */\n+\n+bool\n+predicate::includes (const pred_chain &chain) const\n+{\n+  for (unsigned i = 0; i < m_preds.length (); i++)\n+    if (subset_of (chain, m_preds[i]))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Return true if the domain defined by *THIS is a superset of PREDS's\n+   domain.\n+   Avoid building generic trees (and rely on the folding capability\n+   of the compiler), and instead perform brute force comparison of\n+   individual predicate chains (this won't be a computationally costly\n+   since the chains are pretty short).  Returning false does not\n+   necessarily mean *THIS is not a superset of *PREDS, only that\n+   it need not be since the analysis cannot prove it.  */\n+\n+bool\n+predicate::superset_of (const predicate &preds) const\n+{\n+  for (unsigned i = 0; i < preds.m_preds.length (); i++)\n+    if (!includes (preds.m_preds[i]))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Create a predicate of the form OP != 0 and push it the work list CHAIN.  */\n+\n+static void\n+push_to_worklist (tree op, pred_chain *chain, hash_set<tree> *mark_set)\n+{\n+  if (mark_set->contains (op))\n+    return;\n+  mark_set->add (op);\n+\n+  pred_info arg_pred;\n+  arg_pred.pred_lhs = op;\n+  arg_pred.pred_rhs = integer_zero_node;\n+  arg_pred.cond_code = NE_EXPR;\n+  arg_pred.invert = false;\n+  chain->safe_push (arg_pred);\n+}\n+\n+/* Return a pred_info for a gimple assignment CMP_ASSIGN with comparison\n+   rhs.  */\n+\n+static pred_info\n+get_pred_info_from_cmp (const gimple *cmp_assign)\n+{\n+  pred_info pred;\n+  pred.pred_lhs = gimple_assign_rhs1 (cmp_assign);\n+  pred.pred_rhs = gimple_assign_rhs2 (cmp_assign);\n+  pred.cond_code = gimple_assign_rhs_code (cmp_assign);\n+  pred.invert = false;\n+  return pred;\n+}\n+\n+/* If PHI is a degenerate phi with all operands having the same value (relop)\n+   update *PRED to that value and return true.  Otherwise return false.  */\n+\n+static bool\n+is_degenerate_phi (gimple *phi, pred_info *pred)\n+{\n+  tree op0 = gimple_phi_arg_def (phi, 0);\n+\n+  if (TREE_CODE (op0) != SSA_NAME)\n+    return false;\n+\n+  gimple *def0 = SSA_NAME_DEF_STMT (op0);\n+  if (gimple_code (def0) != GIMPLE_ASSIGN)\n+    return false;\n+\n+  if (TREE_CODE_CLASS (gimple_assign_rhs_code (def0)) != tcc_comparison)\n+    return false;\n+\n+  pred_info pred0 = get_pred_info_from_cmp (def0);\n+\n+  unsigned n = gimple_phi_num_args (phi);\n+  for (unsigned i = 1; i < n; ++i)\n+    {\n+      tree op = gimple_phi_arg_def (phi, i);\n+      if (TREE_CODE (op) != SSA_NAME)\n+\treturn false;\n+\n+      gimple *def = SSA_NAME_DEF_STMT (op);\n+      if (gimple_code (def) != GIMPLE_ASSIGN)\n+\treturn false;\n+\n+      if (TREE_CODE_CLASS (gimple_assign_rhs_code (def)) != tcc_comparison)\n+\treturn false;\n+\n+      pred_info pred = get_pred_info_from_cmp (def);\n+      if (!pred_equal_p (pred, pred0))\n+\treturn false;\n+    }\n+\n+  *pred = pred0;\n+  return true;\n+}\n+\n+/* Recursively compute the control dependence chains (paths of edges)\n+   from the dependent basic block, DEP_BB, up to the dominating basic\n+   block, DOM_BB (the head node of a chain should be dominated by it),\n+   storing them in the CD_CHAINS array.\n+   CUR_CD_CHAIN is the current chain being computed.\n+   *NUM_CHAINS is total number of chains in the CD_CHAINS array.\n+   *NUM_CALLS is the number of recursive calls to control unbounded\n+   recursion.\n+   Return true if the information is successfully computed, false if\n+   there is no control dependence or not computed.  */\n+\n+static bool\n+compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n+\t\t\t   vec<edge> cd_chains[], unsigned *num_chains,\n+\t\t\t   vec<edge> &cur_cd_chain, unsigned *num_calls,\n+\t\t\t   unsigned depth = 0)\n+{\n+  if (*num_calls > (unsigned)param_uninit_control_dep_attempts)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"param_uninit_control_dep_attempts exceeded: %u\\n\",\n+\t\t *num_calls);\n+      return false;\n+    }\n+  ++*num_calls;\n+\n+  /* FIXME: Use a set instead.  */\n+  unsigned cur_chain_len = cur_cd_chain.length ();\n+  if (cur_chain_len > MAX_CHAIN_LEN)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"MAX_CHAIN_LEN exceeded: %u\\n\", cur_chain_len);\n+\n+      return false;\n+    }\n+\n+  if (cur_chain_len > 5)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"chain length exceeds 5: %u\\n\", cur_chain_len);\n+    }\n+\n+  for (unsigned i = 0; i < cur_chain_len; i++)\n+    {\n+      edge e = cur_cd_chain[i];\n+      /* Cycle detected.  */\n+      if (e->src == dom_bb)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"cycle detected\\n\");\n+\t  return false;\n+\t}\n+    }\n+\n+  if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+    fprintf (dump_file,\n+\t     \"%*s%s (dom_bb = %u, dep_bb = %u, cd_chains = { %s }, ...)\\n\",\n+\t     depth, \"\", __func__, dom_bb->index, dep_bb->index,\n+\t     format_edge_vecs (cd_chains, *num_chains).c_str ());\n+\n+  bool found_cd_chain = false;\n+\n+  /* Iterate over DOM_BB's successors.  */\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, dom_bb->succs)\n+    {\n+      int post_dom_check = 0;\n+      if (e->flags & (EDGE_FAKE | EDGE_ABNORMAL))\n+\tcontinue;\n+\n+      basic_block cd_bb = e->dest;\n+      cur_cd_chain.safe_push (e);\n+      while (!is_non_loop_exit_postdominating (cd_bb, dom_bb))\n+\t{\n+\t  if (cd_bb == dep_bb)\n+\t    {\n+\t      /* Found a direct control dependence.  */\n+\t      if (*num_chains < MAX_NUM_CHAINS)\n+\t\t{\n+\t\t  cd_chains[*num_chains] = cur_cd_chain.copy ();\n+\t\t  (*num_chains)++;\n+\t\t}\n+\t      found_cd_chain = true;\n+\t      /* Check path from next edge.  */\n+\t      break;\n+\t    }\n+\n+\t  /* Check if DEP_BB is indirectly control-dependent on DOM_BB.  */\n+\t  if (compute_control_dep_chain (cd_bb, dep_bb, cd_chains,\n+\t\t\t\t\t num_chains, cur_cd_chain,\n+\t\t\t\t\t num_calls, depth + 1))\n+\t    {\n+\t      found_cd_chain = true;\n+\t      break;\n+\t    }\n+\n+\t  cd_bb = find_pdom (cd_bb);\n+\t  post_dom_check++;\n+\t  if (cd_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t      || post_dom_check > MAX_POSTDOM_CHECK)\n+\t    break;\n+\t}\n+      cur_cd_chain.pop ();\n+      gcc_assert (cur_cd_chain.length () == cur_chain_len);\n+    }\n+\n+  gcc_assert (cur_cd_chain.length () == cur_chain_len);\n+  return found_cd_chain;\n+}\n+\n+/* Return true if PRED can be invalidated by any predicate in GUARD.  */\n+\n+static bool\n+can_be_invalidated_p (const pred_info &pred, const pred_chain &guard)\n+{\n+  if (dump_file && dump_flags & TDF_DETAILS)\n+    {\n+      fprintf (dump_file, \"Testing if predicate: \");\n+      dump_pred_info (pred);\n+      fprintf (dump_file, \"\\n...can be invalidated by a USE guard of: \");\n+      dump_pred_chain (guard);\n+      fputc ('\\n', dump_file);\n+    }\n+\n+  unsigned n = guard.length ();\n+  for (unsigned i = 0; i < n; ++i)\n+    {\n+      if (pred_neg_p (pred, guard[i]))\n+\t{\n+\t  if (dump_file && dump_flags & TDF_DETAILS)\n+\t    {\n+\t      fprintf (dump_file, \"  Predicate invalidated by: \");\n+\t      dump_pred_info (guard[i]);\n+\t      fputc ('\\n', dump_file);\n+\t    }\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if all predicates in PREDS are invalidated by GUARD being\n+   true.  */\n+\n+static bool\n+can_be_invalidated_p (const pred_chain_union &preds, const pred_chain &guard)\n+{\n+  if (preds.is_empty ())\n+    return false;\n+\n+  if (dump_file && dump_flags & TDF_DETAILS)\n+    dump_predicates (NULL, preds,\n+\t\t     \"Testing if anything here can be invalidated: \");\n+\n+  for (unsigned i = 0; i < preds.length (); ++i)\n+    {\n+      const pred_chain &chain = preds[i];\n+      for (unsigned j = 0; j < chain.length (); ++j)\n+\tif (can_be_invalidated_p (chain[j], guard))\n+\t  return true;\n+\n+      /* If we were unable to invalidate any predicate in C, then there\n+\t is a viable path from entry to the PHI where the PHI takes\n+\t an interesting value and continues to a use of the PHI.  */\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Return true if none of the PHI arguments in OPNDS is used given\n+   the use guards in *THIS that guard the PHI's use.  */\n+\n+bool\n+predicate::use_cannot_happen (gphi *phi, unsigned opnds)\n+{\n+  if (!m_eval.phi_arg_set (phi))\n+    return false;\n+\n+  /* PHI_USE_GUARDS are OR'ed together.  If we have more than one\n+     possible guard, there's no way of knowing which guard was true.\n+     Since we need to be absolutely sure that the uninitialized\n+     operands will be invalidated, bail.  */\n+  const pred_chain_union &phi_use_guards = m_preds;\n+  if (phi_use_guards.length () != 1)\n+    return false;\n+\n+  const pred_chain &use_guard = phi_use_guards[0];\n+\n+  /* Look for the control dependencies of all the interesting operands\n+     and build guard predicates describing them.  */\n+  unsigned n = gimple_phi_num_args (phi);\n+  for (unsigned i = 0; i < n; ++i)\n+    {\n+      if (!MASK_TEST_BIT (opnds, i))\n+\tcontinue;\n+\n+      edge e = gimple_phi_arg_edge (phi, i);\n+      auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n+      auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n+      unsigned num_chains = 0;\n+      unsigned num_calls = 0;\n+\n+      /* Build the control dependency chain for the PHI argument...  */\n+      if (!compute_control_dep_chain (ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t\t\t      e->src, dep_chains, &num_chains,\n+\t\t\t\t      cur_chain, &num_calls))\n+\treturn false;\n+\n+      if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+\t{\n+\t  fprintf (dump_file, \"predicate::use_cannot_happen (...) \"\n+\t\t   \"dep_chains for arg %u:\\n\\t\", i);\n+\t  dump_dep_chains (dep_chains, num_chains);\n+\t}\n+\n+      /* ...and convert it into a set of predicates guarding its\n+\t definition.  */\n+      predicate def_preds (m_eval);\n+      def_preds.init_from_control_deps (dep_chains, num_chains);\n+      if (def_preds.is_empty ())\n+\t/* If there's no predicate there's no basis to rule the use out.  */\n+\treturn false;\n+\n+      def_preds.simplify ();\n+      def_preds.normalize ();\n+\n+      /* Can the guard for this PHI argument be negated by the one\n+\t guarding the PHI use?  */\n+      if (!can_be_invalidated_p (def_preds.chain (), use_guard))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Implemented simplifications:\n+\n+   1) ((x IOR y) != 0) AND (x != 0) is equivalent to (x != 0);\n+   2) (X AND Y) OR (!X AND Y) is equivalent to Y;\n+   3) X OR (!X AND Y) is equivalent to (X OR Y);\n+   4) ((x IAND y) != 0) || (x != 0 AND y != 0)) is equivalent to\n+      (x != 0 AND y != 0)\n+   5) (X AND Y) OR (!X AND Z) OR (!Y AND Z) is equivalent to\n+      (X AND Y) OR Z\n+\n+   PREDS is the predicate chains, and N is the number of chains.  */\n+\n+/* Implement rule 1 above.  PREDS is the AND predicate to simplify\n+   in place.  */\n+\n+static void\n+simplify_1 (pred_chain &chain)\n+{\n+  bool simplified = false;\n+  pred_chain s_chain = vNULL;\n+\n+  unsigned n = chain.length ();\n+  for (unsigned i = 0; i < n; i++)\n+    {\n+      pred_info &a_pred = chain[i];\n+\n+      if (!a_pred.pred_lhs\n+\t  || !is_neq_zero_form_p (a_pred))\n+\tcontinue;\n+\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (a_pred.pred_lhs);\n+      if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n+\tcontinue;\n+\n+      if (gimple_assign_rhs_code (def_stmt) != BIT_IOR_EXPR)\n+\tcontinue;\n+\n+      for (unsigned j = 0; j < n; j++)\n+\t{\n+\t  const pred_info &b_pred = chain[j];\n+\n+\t  if (!b_pred.pred_lhs\n+\t      || !is_neq_zero_form_p (b_pred))\n+\t    continue;\n+\n+\t  if (pred_expr_equal_p (b_pred, gimple_assign_rhs1 (def_stmt))\n+\t      || pred_expr_equal_p (b_pred, gimple_assign_rhs2 (def_stmt)))\n+\t    {\n+\t      /* Mark A_PRED for removal from PREDS.  */\n+\t      a_pred.pred_lhs = NULL;\n+\t      a_pred.pred_rhs = NULL;\n+\t      simplified = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (!simplified)\n+    return;\n+\n+  /* Remove predicates marked above.  */\n+  for (unsigned i = 0; i < n; i++)\n+    {\n+      pred_info &a_pred = chain[i];\n+      if (!a_pred.pred_lhs)\n+\tcontinue;\n+      s_chain.safe_push (a_pred);\n+    }\n+\n+  chain.release ();\n+  chain = s_chain;\n+}\n+\n+/* Implements rule 2 for the OR predicate PREDS:\n+\n+   2) (X AND Y) OR (!X AND Y) is equivalent to Y.  */\n+\n+bool\n+predicate::simplify_2 ()\n+{\n+  bool simplified = false;\n+\n+  /* (X AND Y) OR (!X AND Y) is equivalent to Y.\n+     (X AND Y) OR (X AND !Y) is equivalent to X.  */\n+\n+  unsigned n = m_preds.length ();\n+  for (unsigned i = 0; i < n; i++)\n+    {\n+      pred_chain &a_chain = m_preds[i];\n+      if (a_chain.length () != 2)\n+\tcontinue;\n+\n+      /* Create copies since the chain may be released below before\n+\t the copy is added to the other chain.  */\n+      const pred_info x = a_chain[0];\n+      const pred_info y = a_chain[1];\n+\n+      for (unsigned j = 0; j < n; j++)\n+\t{\n+\t  if (j == i)\n+\t    continue;\n+\n+\t  pred_chain &b_chain = m_preds[j];\n+\t  if (b_chain.length () != 2)\n+\t    continue;\n+\n+\t  const pred_info &x2 = b_chain[0];\n+\t  const pred_info &y2 = b_chain[1];\n+\n+\t  if (pred_equal_p (x, x2) && pred_neg_p (y, y2))\n+\t    {\n+\t      /* Kill a_chain.  */\n+\t      b_chain.release ();\n+\t      a_chain.release ();\n+\t      b_chain.safe_push (x);\n+\t      simplified = true;\n+\t      break;\n+\t    }\n+\t  if (pred_neg_p (x, x2) && pred_equal_p (y, y2))\n+\t    {\n+\t      /* Kill a_chain.  */\n+\t      a_chain.release ();\n+\t      b_chain.release ();\n+\t      b_chain.safe_push (y);\n+\t      simplified = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  /* Now clean up the chain.  */\n+  if (simplified)\n+    {\n+      pred_chain_union s_preds = vNULL;\n+      for (unsigned i = 0; i < n; i++)\n+\t{\n+\t  if (m_preds[i].is_empty ())\n+\t    continue;\n+\t  s_preds.safe_push (m_preds[i]);\n+\t}\n+      m_preds.release ();\n+      m_preds = s_preds;\n+      s_preds = vNULL;\n+    }\n+\n+  return simplified;\n+}\n+\n+/* Implement rule 3 for the OR predicate PREDS:\n+\n+   3) x OR (!x AND y) is equivalent to x OR y.  */\n+\n+bool\n+predicate::simplify_3 ()\n+{\n+  /* Now iteratively simplify X OR (!X AND Z ..)\n+       into X OR (Z ...).  */\n+\n+  unsigned n = m_preds.length ();\n+  if (n < 2)\n+    return false;\n+\n+  bool simplified = false;\n+  for (unsigned i = 0; i < n; i++)\n+    {\n+      const pred_chain &a_chain = m_preds[i];\n+\n+      if (a_chain.length () != 1)\n+\tcontinue;\n+\n+      const pred_info &x = a_chain[0];\n+      for (unsigned j = 0; j < n; j++)\n+\t{\n+\t  if (j == i)\n+\t    continue;\n+\n+\t  pred_chain b_chain = m_preds[j];\n+\t  if (b_chain.length () < 2)\n+\t    continue;\n+\n+\t  for (unsigned k = 0; k < b_chain.length (); k++)\n+\t    {\n+\t      const pred_info &x2 = b_chain[k];\n+\t      if (pred_neg_p (x, x2))\n+\t\t{\n+\t\t  b_chain.unordered_remove (k);\n+\t\t  simplified = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return simplified;\n+}\n+\n+/* Implement rule 4 for the OR predicate PREDS:\n+\n+   2) ((x AND y) != 0) OR (x != 0 AND y != 0) is equivalent to\n+       (x != 0 ANd y != 0).   */\n+\n+bool\n+predicate::simplify_4 ()\n+{\n+  bool simplified = false;\n+  pred_chain_union s_preds = vNULL;\n+\n+  unsigned n = m_preds.length ();\n+  for (unsigned i = 0; i < n; i++)\n+    {\n+      pred_chain a_chain = m_preds[i];\n+      if (a_chain.length () != 1)\n+\tcontinue;\n+\n+      const pred_info &z = a_chain[0];\n+      if (!is_neq_zero_form_p (z))\n+\tcontinue;\n+\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (z.pred_lhs);\n+      if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n+\tcontinue;\n+\n+      if (gimple_assign_rhs_code (def_stmt) != BIT_AND_EXPR)\n+\tcontinue;\n+\n+      for (unsigned j = 0; j < n; j++)\n+\t{\n+\t  if (j == i)\n+\t    continue;\n+\n+\t  pred_chain b_chain = m_preds[j];\n+\t  if (b_chain.length () != 2)\n+\t    continue;\n+\n+\t  const pred_info &x2 = b_chain[0];\n+\t  const pred_info &y2 = b_chain[1];\n+\t  if (!is_neq_zero_form_p (x2) || !is_neq_zero_form_p (y2))\n+\t    continue;\n+\n+\t  if ((pred_expr_equal_p (x2, gimple_assign_rhs1 (def_stmt))\n+\t       && pred_expr_equal_p (y2, gimple_assign_rhs2 (def_stmt)))\n+\t      || (pred_expr_equal_p (x2, gimple_assign_rhs2 (def_stmt))\n+\t\t  && pred_expr_equal_p (y2, gimple_assign_rhs1 (def_stmt))))\n+\t    {\n+\t      /* Kill a_chain.  */\n+\t      a_chain.release ();\n+\t      simplified = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  /* Now clean up the chain.  */\n+  if (simplified)\n+    {\n+      for (unsigned i = 0; i < n; i++)\n+\t{\n+\t  if (m_preds[i].is_empty ())\n+\t    continue;\n+\t  s_preds.safe_push (m_preds[i]);\n+\t}\n+\n+      m_preds.release ();\n+      m_preds = s_preds;\n+      s_preds = vNULL;\n+    }\n+\n+  return simplified;\n+}\n+\n+/* Simplify predicates in *THIS.  */\n+\n+void\n+predicate::simplify (gimple *use_or_def, bool is_use)\n+{\n+  if (dump_file && dump_flags & TDF_DETAILS)\n+    {\n+      fprintf (dump_file, \"Before simplication \");\n+      dump (use_or_def, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n+    }\n+\n+  unsigned n = m_preds.length ();\n+  for (unsigned i = 0; i < n; i++)\n+    ::simplify_1 (m_preds[i]);\n+\n+  if (n < 2)\n+    return;\n+\n+  bool changed;\n+  do\n+    {\n+      changed = false;\n+      if (simplify_2 ())\n+\tchanged = true;\n+\n+      if (simplify_3 ())\n+\tchanged = true;\n+\n+      if (simplify_4 ())\n+\tchanged = true;\n+    }\n+  while (changed);\n+}\n+\n+/* Attempt to normalize predicate chains by following UD chains by\n+   building up a big tree of either IOR operations or AND operations,\n+   and converting the IOR tree into a pred_chain_union or the BIT_AND\n+   tree into a pred_chain.\n+   Example:\n+\n+  _3 = _2 RELOP1 _1;\n+  _6 = _5 RELOP2 _4;\n+  _9 = _8 RELOP3 _7;\n+  _10 = _3 | _6;\n+  _12 = _9 | _0;\n+  _t = _10 | _12;\n+\n+  then _t != 0 will be normalized into a pred_chain_union\n+\n+   (_2 RELOP1 _1) OR (_5 RELOP2 _4) OR (_8 RELOP3 _7) OR (_0 != 0)\n+\n+   Similarly given:\n+\n+  _3 = _2 RELOP1 _1;\n+  _6 = _5 RELOP2 _4;\n+  _9 = _8 RELOP3 _7;\n+  _10 = _3 & _6;\n+  _12 = _9 & _0;\n+\n+  then _t != 0 will be normalized into a pred_chain:\n+  (_2 RELOP1 _1) AND (_5 RELOP2 _4) AND (_8 RELOP3 _7) AND (_0 != 0)\n+  */\n+\n+/* Store a PRED in *THIS.  */\n+\n+void\n+predicate::push_pred (const pred_info &pred)\n+{\n+  pred_chain chain = vNULL;\n+  chain.safe_push (pred);\n+  m_preds.safe_push (chain);\n+}\n+\n+/* Dump predicates in *THIS for STMT prepended by MSG.  */\n+\n+void\n+predicate::dump (gimple *stmt, const char *msg) const\n+{\n+  fprintf (dump_file, \"%s\", msg);\n+  if (stmt)\n+    {\n+      fputc ('\\t', dump_file);\n+      print_gimple_stmt (dump_file, stmt, 0);\n+      fprintf (dump_file, \"  is conditional on:\\n\");\n+    }\n+\n+  unsigned np = m_preds.length ();\n+  if (np == 0)\n+    {\n+      fprintf (dump_file, \"\\t(empty)\\n\");\n+      return;\n+    }\n+\n+  {\n+    tree expr = build_pred_expr (m_preds);\n+    char *str = print_generic_expr_to_str (expr);\n+    fprintf (dump_file, \"\\t%s (expanded)\\n\", str);\n+    free (str);\n+  }\n+\n+  if (np > 1)\n+    fprintf (dump_file, \"\\tOR (\");\n+  else\n+    fputc ('\\t', dump_file);\n+  for (unsigned i = 0; i < np; i++)\n+    {\n+      dump_pred_chain (m_preds[i]);\n+      if (i < np - 1)\n+\tfprintf (dump_file, \", \");\n+      else if (i > 0)\n+\tfputc (')', dump_file);\n+    }\n+  fputc ('\\n', dump_file);\n+}\n+\n+/* Initialize *THIS with the predicates of the control dependence chains\n+   between the basic block DEF_BB that defines a variable of interst and\n+   USE_BB that uses the variable, respectively.  */\n+\n+predicate::predicate (basic_block def_bb, basic_block use_bb, func_t &eval)\n+  : m_preds (vNULL), m_eval (eval)\n+{\n+  /* Set CD_ROOT to the basic block closest to USE_BB that is the control\n+     equivalent of (is guarded by the same predicate as) DEF_BB that also\n+     dominates USE_BB.  */\n+  basic_block cd_root = def_bb;\n+  while (dominated_by_p (CDI_DOMINATORS, use_bb, cd_root))\n+    {\n+      /* Find CD_ROOT's closest postdominator that's its control\n+\t equivalent.  */\n+      if (basic_block bb = find_control_equiv_block (cd_root))\n+\tif (dominated_by_p (CDI_DOMINATORS, use_bb, bb))\n+\t  {\n+\t    cd_root = bb;\n+\t    continue;\n+\t  }\n+\n+      break;\n+    }\n+\n+  /* Set DEP_CHAINS to the set of edges between CD_ROOT and USE_BB.\n+     Each DEP_CHAINS element is a series of edges whose conditions\n+     are logical conjunctions.  Together, the DEP_CHAINS vector is\n+     used below to initialize an OR expression of the conjunctions.  */\n+  unsigned num_calls = 0;\n+  unsigned num_chains = 0;\n+  auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n+  auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n+\n+  compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains,\n+\t\t\t     cur_chain, &num_calls);\n+\n+  if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+    {\n+      fprintf (dump_file, \"predicate::predicate (def_bb = %u, use_bb = %u, func_t) \"\n+\t       \"initialized from %u dep_chains:\\n\\t\",\n+\t       def_bb->index, use_bb->index, num_chains);\n+      dump_dep_chains (dep_chains, num_chains);\n+    }\n+\n+  /* From the set of edges computed above initialize *THIS as the OR\n+     condition under which the definition in DEF_BB is used in USE_BB.\n+     Each OR subexpression is represented by one element of DEP_CHAINS,\n+     where each element consists of a series of AND subexpressions.  */\n+  init_from_control_deps (dep_chains, num_chains);\n+}\n+\n+/* Release resources in *THIS.  */\n+\n+predicate::~predicate ()\n+{\n+  unsigned n = m_preds.length ();\n+  for (unsigned i = 0; i != n; ++i)\n+    m_preds[i].release ();\n+  m_preds.release ();\n+}\n+\n+/* Copy-assign RHS to *THIS.  */\n+\n+predicate&\n+predicate::operator= (const predicate &rhs)\n+{\n+  if (this == &rhs)\n+    return *this;\n+\n+  /* FIXME: Make this a compile-time constraint?  */\n+  gcc_assert (&m_eval == &rhs.m_eval);\n+\n+  unsigned n = m_preds.length ();\n+  for (unsigned i = 0; i != n; ++i)\n+    m_preds[i].release ();\n+  m_preds.release ();\n+\n+  n = rhs.m_preds.length ();\n+  for (unsigned i = 0; i != n; ++i)\n+    {\n+      const pred_chain &chain = rhs.m_preds[i];\n+      m_preds.safe_push (chain.copy ());\n+    }\n+\n+  return *this;\n+}\n+\n+/* For each use edge of PHI, compute all control dependence chains\n+   and convert those to the composite predicates in M_PREDS.\n+   Return true if a nonempty predicate has been obtained.  */\n+\n+bool\n+predicate::init_from_phi_def (gphi *phi)\n+{\n+  gcc_assert (is_empty ());\n+\n+  basic_block phi_bb = gimple_bb (phi);\n+  /* Find the closest dominating bb to be the control dependence root.  */\n+  basic_block cd_root = find_dom (phi_bb);\n+  if (!cd_root)\n+    return false;\n+\n+  /* Set DEF_EDGES to the edges to the PHI from the bb's that provide\n+     definitions of each of the PHI operands for which M_EVAL is false.  */\n+  auto_vec<edge> def_edges;\n+  hash_set<gimple *> visited_phis;\n+  collect_phi_def_edges (phi, cd_root, &def_edges, m_eval, &visited_phis);\n+\n+  unsigned nedges = def_edges.length ();\n+  if (nedges == 0)\n+    return false;\n+\n+  unsigned num_chains = 0;\n+  auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n+  auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n+  for (unsigned i = 0; i < nedges; i++)\n+    {\n+      edge e = def_edges[i];\n+      unsigned num_calls = 0;\n+      unsigned prev_nc = num_chains;\n+      compute_control_dep_chain (cd_root, e->src, dep_chains,\n+\t\t\t\t &num_chains, cur_chain, &num_calls);\n+\n+      /* Update the newly added chains with the phi operand edge.  */\n+      if (EDGE_COUNT (e->src->succs) > 1)\n+\t{\n+\t  if (prev_nc == num_chains && num_chains < MAX_NUM_CHAINS)\n+\t    dep_chains[num_chains++] = vNULL;\n+\t  for (unsigned j = prev_nc; j < num_chains; j++)\n+\t    dep_chains[j].safe_push (e);\n+\t}\n+    }\n+\n+  /* Convert control dependence chains to the predicate in *THIS under\n+     which the PHI operands are defined to values for which M_EVAL is\n+     false.  */\n+  init_from_control_deps (dep_chains, num_chains);\n+  return !is_empty ();\n+}\n+\n+/* Compute the predicates that guard the use USE_STMT and check if\n+   the incoming paths that have an empty (or possibly empty) definition\n+   can be pruned.  Return true if it can be determined that the use of\n+   PHI's def in USE_STMT is guarded by a predicate set that does not\n+   overlap with the predicate sets of all runtime paths that do not\n+   have a definition.\n+\n+   Return false if the use is not guarded or if it cannot be determined.\n+   USE_BB is the bb of the use (for phi operand use, the bb is not the bb\n+   of the phi stmt, but the source bb of the operand edge).\n+\n+   OPNDS is a bitmap with a bit set for each PHI operand of interest.\n+\n+   THIS->M_PREDS contains the (memoized) defining predicate chains of\n+   a PHI.  If THIS->M_PREDS is empty, the PHI's defining predicate\n+   chains are computed and stored into THIS->M_PREDS as needed.\n+\n+   VISITED_PHIS is a pointer set of phis being visited.  */\n+\n+bool\n+predicate::is_use_guarded (gimple *use_stmt, basic_block use_bb,\n+\t\t\t   gphi *phi, unsigned opnds,\n+\t\t\t   hash_set<gphi *> *visited)\n+{\n+  if (visited->add (phi))\n+    return false;\n+\n+  /* The basic block where the PHI is defined.  */\n+  basic_block def_bb = gimple_bb (phi);\n+\n+  /* Try to build the predicate expression under which the PHI flows\n+     into its use.  This will be empty if the PHI is defined and used\n+     in the same bb.  */\n+  predicate use_preds (def_bb, use_bb, m_eval);\n+\n+  if (is_non_loop_exit_postdominating (use_bb, def_bb))\n+    {\n+      if (is_empty ())\n+\t{\n+\t  /* Lazily initialize *THIS from the PHI and build its use\n+\t     expression.  */\n+\t  init_from_phi_def (phi);\n+\t  m_use_expr = build_pred_expr (use_preds.m_preds);\n+\t}\n+\n+      /* The use is not guarded.  */\n+      return false;\n+    }\n+\n+  if (use_preds.is_empty ())\n+    return false;\n+\n+  /* Try to prune the dead incoming phi edges.  */\n+  if (!use_preds.overlap (phi, opnds, visited))\n+    {\n+      if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+\tfputs (\"found predicate overlap\\n\", dump_file);\n+\n+      return true;\n+    }\n+\n+  /* We might be able to prove that if the control dependencies for OPNDS\n+     are true, the control dependencies for USE_STMT can never be true.  */\n+  if (use_preds.use_cannot_happen (phi, opnds))\n+    return true;\n+\n+  if (is_empty ())\n+    {\n+      /* Lazily initialize *THIS from PHI.  */\n+      if (!init_from_phi_def (phi))\n+\t{\n+\t  m_use_expr = build_pred_expr (use_preds.m_preds);\n+\t  return false;\n+\t}\n+\n+      simplify (phi);\n+      normalize (phi);\n+    }\n+\n+  use_preds.simplify (use_stmt, /*is_use=*/true);\n+  use_preds.normalize (use_stmt, /*is_use=*/true);\n+\n+  /* Return true if the predicate guarding the valid definition (i.e.,\n+     *THIS) is a superset of the predicate guarding the use (i.e.,\n+     USE_PREDS).  */\n+  if (superset_of (use_preds))\n+    return true;\n+\n+  m_use_expr = build_pred_expr (use_preds.m_preds);\n+\n+  return false;\n+}\n+\n+/* Public interface to the above. */\n+\n+bool\n+predicate::is_use_guarded (gimple *stmt, basic_block use_bb, gphi *phi,\n+\t\t\t   unsigned opnds)\n+{\n+  hash_set<gphi *> visited;\n+  return is_use_guarded (stmt, use_bb, phi, opnds, &visited);\n+}\n+\n+/* Normalize predicate PRED:\n+   1) if PRED can no longer be normalized, append it to *THIS.\n+   2) otherwise if PRED is of the form x != 0, follow x's definition\n+      and put normalized predicates into WORK_LIST.  */\n+\n+void\n+predicate::normalize (pred_chain *norm_chain,\n+\t\t      pred_info pred,\n+\t\t      tree_code and_or_code,\n+\t\t      pred_chain *work_list,\n+\t\t      hash_set<tree> *mark_set)\n+{\n+  if (!is_neq_zero_form_p (pred))\n+    {\n+      if (and_or_code == BIT_IOR_EXPR)\n+\tpush_pred (pred);\n+      else\n+\tnorm_chain->safe_push (pred);\n+      return;\n+    }\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n+\n+  if (gimple_code (def_stmt) == GIMPLE_PHI\n+      && is_degenerate_phi (def_stmt, &pred))\n+    /* PRED has been modified above.  */\n+    work_list->safe_push (pred);\n+  else if (gimple_code (def_stmt) == GIMPLE_PHI && and_or_code == BIT_IOR_EXPR)\n+    {\n+      unsigned n = gimple_phi_num_args (def_stmt);\n+\n+      /* Punt for a nonzero constant.  The predicate should be one guarding\n+\t the phi edge.  */\n+      for (unsigned i = 0; i < n; ++i)\n+\t{\n+\t  tree op = gimple_phi_arg_def (def_stmt, i);\n+\t  if (TREE_CODE (op) == INTEGER_CST && !integer_zerop (op))\n+\t    {\n+\t      push_pred (pred);\n+\t      return;\n+\t    }\n+\t}\n+\n+      for (unsigned i = 0; i < n; ++i)\n+\t{\n+\t  tree op = gimple_phi_arg_def (def_stmt, i);\n+\t  if (integer_zerop (op))\n+\t    continue;\n+\n+\t  push_to_worklist (op, work_list, mark_set);\n+\t}\n+    }\n+  else if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n+    {\n+      if (and_or_code == BIT_IOR_EXPR)\n+\tpush_pred (pred);\n+      else\n+\tnorm_chain->safe_push (pred);\n+    }\n+  else if (gimple_assign_rhs_code (def_stmt) == and_or_code)\n+    {\n+      /* Avoid splitting up bit manipulations like x & 3 or y | 1.  */\n+      if (is_gimple_min_invariant (gimple_assign_rhs2 (def_stmt)))\n+\t{\n+\t  /* But treat x & 3 as a condition.  */\n+\t  if (and_or_code == BIT_AND_EXPR)\n+\t    {\n+\t      pred_info n_pred;\n+\t      n_pred.pred_lhs = gimple_assign_rhs1 (def_stmt);\n+\t      n_pred.pred_rhs = gimple_assign_rhs2 (def_stmt);\n+\t      n_pred.cond_code = and_or_code;\n+\t      n_pred.invert = false;\n+\t      norm_chain->safe_push (n_pred);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  push_to_worklist (gimple_assign_rhs1 (def_stmt), work_list, mark_set);\n+\t  push_to_worklist (gimple_assign_rhs2 (def_stmt), work_list, mark_set);\n+\t}\n+    }\n+  else if (TREE_CODE_CLASS (gimple_assign_rhs_code (def_stmt))\n+\t   == tcc_comparison)\n+    {\n+      pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n+      if (and_or_code == BIT_IOR_EXPR)\n+\tpush_pred (n_pred);\n+      else\n+\tnorm_chain->safe_push (n_pred);\n+    }\n+  else\n+    {\n+      if (and_or_code == BIT_IOR_EXPR)\n+\tpush_pred (pred);\n+      else\n+\tnorm_chain->safe_push (pred);\n+    }\n+}\n+\n+/* Normalize PRED and store the normalized predicates in THIS->M_PREDS.  */\n+\n+void\n+predicate::normalize (const pred_info &pred)\n+{\n+  if (!is_neq_zero_form_p (pred))\n+    {\n+      push_pred (pred);\n+      return;\n+    }\n+\n+  tree_code and_or_code = ERROR_MARK;\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n+  if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n+    and_or_code = gimple_assign_rhs_code (def_stmt);\n+  if (and_or_code != BIT_IOR_EXPR && and_or_code != BIT_AND_EXPR)\n+    {\n+      if (TREE_CODE_CLASS (and_or_code) == tcc_comparison)\n+\t{\n+\t  pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n+\t  push_pred (n_pred);\n+\t}\n+      else\n+\tpush_pred (pred);\n+      return;\n+    }\n+\n+\n+  pred_chain norm_chain = vNULL;\n+  pred_chain work_list = vNULL;\n+  work_list.safe_push (pred);\n+  hash_set<tree> mark_set;\n+\n+  while (!work_list.is_empty ())\n+    {\n+      pred_info a_pred = work_list.pop ();\n+      normalize (&norm_chain, a_pred, and_or_code, &work_list, &mark_set);\n+    }\n+\n+  if (and_or_code == BIT_AND_EXPR)\n+    m_preds.safe_push (norm_chain);\n+\n+  work_list.release ();\n+}\n+\n+/* Normalize a single predicate PRED_CHAIN and append it to *THIS.  */\n+\n+void\n+predicate::normalize (const pred_chain &chain)\n+{\n+  pred_chain work_list = vNULL;\n+  hash_set<tree> mark_set;\n+  for (unsigned i = 0; i < chain.length (); i++)\n+    {\n+      work_list.safe_push (chain[i]);\n+      mark_set.add (chain[i].pred_lhs);\n+    }\n+\n+  /* Normalized chain of predicates built up below.  */\n+  pred_chain norm_chain = vNULL;\n+  while (!work_list.is_empty ())\n+    {\n+      pred_info pi = work_list.pop ();\n+      predicate pred (m_eval);\n+      /* The predicate object is not modified here, only NORM_CHAIN and\n+\t WORK_LIST are appended to.  */\n+      pred.normalize (&norm_chain, pi, BIT_AND_EXPR, &work_list, &mark_set);\n+    }\n+\n+  m_preds.safe_push (norm_chain);\n+  work_list.release ();\n+}\n+\n+/* Normalize predicate chains in THIS.  */\n+\n+void\n+predicate::normalize (gimple *use_or_def, bool is_use)\n+{\n+  if (dump_file && dump_flags & TDF_DETAILS)\n+    {\n+      fprintf (dump_file, \"Before normalization \");\n+      dump (use_or_def, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n+    }\n+\n+  predicate norm_preds (m_eval);\n+  for (unsigned i = 0; i < m_preds.length (); i++)\n+    {\n+      if (m_preds[i].length () != 1)\n+\tnorm_preds.normalize (m_preds[i]);\n+      else\n+\tnorm_preds.normalize (m_preds[i][0]);\n+    }\n+\n+  *this = norm_preds;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"After normalization \");\n+      dump (use_or_def, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n+    }\n+}\n+\n+/* Add a predicate for the condition or logical assignment STMT to CHAIN.\n+   Expand SSA_NAME into constituent subexpressions.  Invert the result\n+   if INVERT is true.  Return true if the predicate has been added.  */\n+\n+static bool\n+add_pred (pred_chain *chain, gimple *stmt, bool invert)\n+{\n+  if (gimple_code (stmt) == GIMPLE_COND)\n+    {\n+      tree lhs = gimple_cond_lhs (stmt);\n+      if (TREE_CODE (lhs) == SSA_NAME)\n+\t{\n+\t  gimple *def = SSA_NAME_DEF_STMT (lhs);\n+\t  if (is_gimple_assign (def)\n+\t      && add_pred (chain, def, invert))\n+\t    return true;\n+\t}\n+\n+      pred_info pred;\n+      pred.pred_lhs = lhs;\n+      pred.pred_rhs = gimple_cond_rhs (stmt);\n+      pred.cond_code = gimple_cond_code (stmt);\n+      pred.invert = invert;\n+      chain->safe_push (pred);\n+      return true;\n+    }\n+\n+  if (!is_gimple_assign (stmt))\n+    return false;\n+\n+  if (gimple_assign_single_p (stmt))\n+    // FIXME: handle this?\n+    return false;\n+\n+  if (TREE_TYPE (gimple_assign_lhs (stmt)) != boolean_type_node)\n+    return false;\n+\n+  tree rhs1 = gimple_assign_rhs1 (stmt);\n+  tree rhs2 = gimple_assign_rhs2 (stmt);\n+  tree_code code = gimple_assign_rhs_code (stmt);\n+  if (code == BIT_AND_EXPR)\n+    {\n+      if (TREE_CODE (rhs1) == SSA_NAME\n+\t  && add_pred (chain, SSA_NAME_DEF_STMT (rhs1), invert)\n+\t  && TREE_CODE (rhs2) == SSA_NAME\n+\t  /* FIXME: Need to handle failure below! */\n+\t  && add_pred (chain, SSA_NAME_DEF_STMT (rhs2), invert))\n+\treturn true;\n+    }\n+  else if (TREE_CODE_CLASS (code) != tcc_comparison)\n+    return false;\n+\n+  pred_info pred;\n+  pred.pred_lhs = rhs1;\n+  pred.pred_rhs = rhs2;\n+  pred.cond_code = code;\n+  pred.invert = invert;\n+  chain->safe_push (pred);\n+  return true;\n+}\n+\n+/* Convert the chains of control dependence edges into a set of predicates.\n+   A control dependence chain is represented by a vector edges.  DEP_CHAINS\n+   points to an array of NUM_CHAINS dependence chains. One edge in\n+   a dependence chain is mapped to predicate expression represented by\n+   pred_info type.  One dependence chain is converted to a composite\n+   predicate that is the result of AND operation of pred_info mapped to\n+   each edge.  A composite predicate is represented by a vector of\n+   pred_info.  Sets M_PREDS to the resulting composite predicates.  */\n+\n+void\n+predicate::init_from_control_deps (const vec<edge> *dep_chains,\n+\t\t\t\t   unsigned num_chains)\n+{\n+  gcc_assert (is_empty ());\n+\n+  bool has_valid_pred = false;\n+  if (num_chains == 0)\n+    return;\n+\n+  if (num_chains >= MAX_NUM_CHAINS)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"MAX_NUM_CHAINS exceeded: %u\\n\", num_chains);\n+      return;\n+    }\n+\n+  /* Convert the control dependency chain into a set of predicates.  */\n+  m_preds.reserve (num_chains);\n+\n+  for (unsigned i = 0; i < num_chains; i++)\n+    {\n+      /* One path through the CFG represents a logical conjunction\n+\t of the predicates.  */\n+      const vec<edge> &path = dep_chains[i];\n+\n+      has_valid_pred = false;\n+      /* The chain of predicates guarding the definition along this path.  */\n+      pred_chain t_chain{ };\n+      for (unsigned j = 0; j < path.length (); j++)\n+\t{\n+\t  edge e = path[j];\n+\t  basic_block guard_bb = e->src;\n+\t  /* Ignore empty forwarder blocks.  */\n+\t  if (empty_block_p (guard_bb) && single_succ_p (guard_bb))\n+\t    continue;\n+\n+\t  /* An empty basic block here is likely a PHI, and is not one\n+\t     of the cases we handle below.  */\n+\t  gimple_stmt_iterator gsi = gsi_last_bb (guard_bb);\n+\t  if (gsi_end_p (gsi))\n+\t    {\n+\t      has_valid_pred = false;\n+\t      break;\n+\t    }\n+\t  /* Get the conditional controlling the bb exit edge.  */\n+\t  gimple *cond_stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_call (cond_stmt) && EDGE_COUNT (e->src->succs) >= 2)\n+\t    /* Ignore EH edge.  Can add assertion on the other edge's flag.  */\n+\t    continue;\n+\t  /* Skip if there is essentially one succesor.  */\n+\t  if (EDGE_COUNT (e->src->succs) == 2)\n+\t    {\n+\t      edge e1;\n+\t      edge_iterator ei1;\n+\t      bool skip = false;\n+\n+\t      FOR_EACH_EDGE (e1, ei1, e->src->succs)\n+\t\t{\n+\t\t  if (EDGE_COUNT (e1->dest->succs) == 0)\n+\t\t    {\n+\t\t      skip = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (skip)\n+\t\tcontinue;\n+\t    }\n+\t  if (gimple_code (cond_stmt) == GIMPLE_COND)\n+\t    {\n+\t      /* The true edge corresponds to the uninteresting condition.\n+\t\t Add the negated predicate(s) for the edge to record\n+\t\t the interesting condition.  */\n+\t      pred_info one_pred;\n+\t      one_pred.pred_lhs = gimple_cond_lhs (cond_stmt);\n+\t      one_pred.pred_rhs = gimple_cond_rhs (cond_stmt);\n+\t      one_pred.cond_code = gimple_cond_code (cond_stmt);\n+\t      one_pred.invert = !!(e->flags & EDGE_FALSE_VALUE);\n+\n+\t      t_chain.safe_push (one_pred);\n+\n+\t      if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"one_pred = \");\n+\t\t  dump_pred_info (one_pred);\n+\t\t  fputc ('\\n', dump_file);\n+\t\t}\n+\n+\t      has_valid_pred = true;\n+\t    }\n+\t  else if (gswitch *gs = dyn_cast<gswitch *> (cond_stmt))\n+\t    {\n+\t      /* Avoid quadratic behavior.  */\n+\t      if (gimple_switch_num_labels (gs) > MAX_SWITCH_CASES)\n+\t\t{\n+\t\t  has_valid_pred = false;\n+\t\t  break;\n+\t\t}\n+\t      /* Find the case label.  */\n+\t      tree l = NULL_TREE;\n+\t      unsigned idx;\n+\t      for (idx = 0; idx < gimple_switch_num_labels (gs); ++idx)\n+\t\t{\n+\t\t  tree tl = gimple_switch_label (gs, idx);\n+\t\t  if (e->dest == label_to_block (cfun, CASE_LABEL (tl)))\n+\t\t    {\n+\t\t      if (!l)\n+\t\t\tl = tl;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  l = NULL_TREE;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      /* If more than one label reaches this block or the case\n+\t\t label doesn't have a single value (like the default one)\n+\t\t fail.  */\n+\t      if (!l\n+\t\t  || !CASE_LOW (l)\n+\t\t  || (CASE_HIGH (l)\n+\t\t      && !operand_equal_p (CASE_LOW (l), CASE_HIGH (l), 0)))\n+\t\t{\n+\t\t  has_valid_pred = false;\n+\t\t  break;\n+\t\t}\n+\n+\t      pred_info one_pred;\n+\t      one_pred.pred_lhs = gimple_switch_index (gs);\n+\t      one_pred.pred_rhs = CASE_LOW (l);\n+\t      one_pred.cond_code = EQ_EXPR;\n+\t      one_pred.invert = false;\n+\t      t_chain.safe_push (one_pred);\n+\t      has_valid_pred = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Disabled.  See PR 90994.\n+\t\t has_valid_pred = false;  */\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (!has_valid_pred)\n+\tbreak;\n+      else\n+\tm_preds.safe_push (t_chain);\n+    }\n+\n+  if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+    {\n+      fprintf (dump_file, \"init_from_control_deps {%s}:\\n\",\n+\t       format_edge_vecs (dep_chains, num_chains).c_str ());\n+      dump (NULL, \"\");\n+    }\n+\n+  gcc_assert (has_valid_pred == (m_preds.length () > 0));\n+}\n+\n+/* Return the predicate expression guarding the definition of\n+   the interesting variable.  When INVERT is set, return the logical\n+   NOT of the predicate.  */\n+\n+tree\n+predicate::def_expr (bool invert /* = false */) const\n+{\n+  /* The predicate is stored in an inverted form.  */\n+  return build_pred_expr (m_preds, !invert);\n+}\n+\n+/* Return the predicate expression guarding the use of the interesting\n+   variable or null if the use predicate hasn't been determined yet.  */\n+\n+tree\n+predicate::use_expr () const\n+{\n+  return m_use_expr;\n+}\n+\n+/* Return a logical AND expression with the (optionally inverted) predicate\n+   expression guarding the definition of the interesting variable and one\n+   guarding its use.  Return null if the use predicate hasn't yet been\n+   determined.  */\n+\n+tree\n+predicate::expr (bool invert /* = false */) const\n+{\n+  if (!m_use_expr)\n+    return NULL_TREE;\n+\n+  tree expr = build_pred_expr (m_preds, !invert);\n+  return build2 (TRUTH_AND_EXPR, boolean_type_node, expr, m_use_expr);\n+}"}, {"sha": "fbf6f8e5aea54fa8e3756570ae311d9dbcdaf032", "filename": "gcc/gimple-predicate-analysis.h", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94c12ffac234b29a702aa7b6730f2678265857c8/gcc%2Fgimple-predicate-analysis.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94c12ffac234b29a702aa7b6730f2678265857c8/gcc%2Fgimple-predicate-analysis.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.h?ref=94c12ffac234b29a702aa7b6730f2678265857c8", "patch": "@@ -0,0 +1,158 @@\n+/* Support for simple predicate analysis.\n+\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by Martin Sebor <msebor@redhat.com>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GIMPLE_PREDICATE_ANALYSIS_H_INCLUDED\n+#define GIMPLE_PREDICATE_ANALYSIS_H_INCLUDED\n+\n+#define MAX_NUM_CHAINS 8\n+#define MAX_CHAIN_LEN 5\n+#define MAX_POSTDOM_CHECK 8\n+#define MAX_SWITCH_CASES 40\n+\n+/* Represents a simple Boolean predicate.  */\n+struct pred_info\n+{\n+  tree pred_lhs;\n+  tree pred_rhs;\n+  enum tree_code cond_code;\n+  bool invert;\n+};\n+\n+/* The type to represent a sequence of predicates grouped\n+   with .AND. operation.  */\n+typedef vec<pred_info, va_heap, vl_ptr> pred_chain;\n+\n+/* The type to represent a sequence of pred_chains grouped\n+   with .OR. operation.  */\n+typedef vec<pred_chain, va_heap, vl_ptr> pred_chain_union;\n+\n+/* Represents a complex Boolean predicate expression.  */\n+class predicate\n+{\n+ public:\n+  /* Base function object type used to determine whether an expression\n+     is of interest.  */\n+  struct func_t\n+  {\n+    typedef unsigned phi_arg_set_t;\n+\n+    /* Return true if the argument is an expression of interest.  */\n+    virtual bool operator()(tree) = 0;\n+    /* Return a bitset of PHI arguments of interest.  By default returns\n+       bitset with a bit set for each argument.  Should be called in\n+       the overriden function first and, if nonzero, the result then\n+       refined as appropriate.  */\n+    virtual phi_arg_set_t phi_arg_set (gphi *);\n+\n+    /* Maximum number of PHI arguments supported by phi_arg_set().  */\n+    static constexpr unsigned max_phi_args =\n+      sizeof (phi_arg_set_t) * CHAR_BIT;\n+  };\n+\n+  /* Construct with the specified EVAL object.  */\n+  predicate (func_t &eval)\n+    : m_preds (vNULL), m_eval (eval), m_use_expr () { }\n+\n+  /* Copy.  */\n+  predicate (const predicate &rhs)\n+    : m_preds (vNULL), m_eval (rhs.m_eval), m_use_expr ()\n+    {\n+      *this = rhs;\n+    }\n+\n+  predicate (basic_block, basic_block, func_t &);\n+\n+  ~predicate ();\n+\n+  /* Assign.  */\n+  predicate& operator= (const predicate &);\n+\n+  bool is_empty () const\n+  {\n+    return m_preds.is_empty ();\n+  }\n+\n+  const pred_chain_union chain () const\n+  {\n+    return m_preds;\n+  }\n+\n+  /* Return true if the use by a statement in the basic block of\n+     a PHI operand is ruled out (i.e., guarded) by *THIS.  */\n+  bool is_use_guarded (gimple *, basic_block, gphi *, unsigned);\n+\n+  void init_from_control_deps (const vec<edge> *, unsigned);\n+\n+  void dump (gimple *, const char *) const;\n+\n+  void normalize (gimple * = NULL, bool = false);\n+  void simplify (gimple * = NULL, bool = false);\n+\n+  bool is_use_guarded (gimple *, basic_block, gphi *, unsigned,\n+\t\t       hash_set<gphi *> *);\n+\n+  /* Return the predicate expression guarding the definition of\n+     the interesting variable, optionally inverted.  */\n+  tree def_expr (bool = false) const;\n+  /* Return the predicate expression guarding the use of the interesting\n+     variable.  */\n+  tree use_expr () const;\n+\n+  tree expr (bool = false) const;\n+\n+private:\n+  bool includes (const pred_chain &) const;\n+  bool superset_of (const predicate &) const;\n+  bool overlap (gphi *, unsigned, hash_set<gphi *> *);\n+  bool use_cannot_happen (gphi *, unsigned);\n+\n+  bool init_from_phi_def (gphi *);\n+\n+  void push_pred (const pred_info &);\n+\n+  /* Normalization functions.  */\n+  void normalize (pred_chain *, pred_info, tree_code, pred_chain *,\n+\t\t  hash_set<tree> *);\n+\n+  void normalize (const pred_info &);\n+  void normalize (const pred_chain &);\n+\n+  /* Simplification functions.  */\n+  bool simplify_2 ();\n+  bool simplify_3 ();\n+  bool simplify_4 ();\n+\n+private:\n+  /* Representation of the predicate expression(s).  */\n+  pred_chain_union m_preds;\n+  /* Callback to evaluate an operand.  Return true if it's interesting.  */\n+  func_t &m_eval;\n+  /* The predicate expression guarding the use of the interesting\n+     variable.  */\n+  tree m_use_expr;\n+};\n+\n+/* Bit mask handling macros.  */\n+#define MASK_SET_BIT(mask, pos) mask |= (1 << pos)\n+#define MASK_TEST_BIT(mask, pos) (mask & (1 << pos))\n+#define MASK_EMPTY(mask) (mask == 0)\n+\n+#endif // GIMPLE_PREDICATE_ANALYSIS_H_INCLUDED"}, {"sha": "d67534f22a87162cc1a95fb646df9a2a31f5b8d5", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 182, "deletions": 2249, "changes": 2431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94c12ffac234b29a702aa7b6730f2678265857c8/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94c12ffac234b29a702aa7b6730f2678265857c8/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=94c12ffac234b29a702aa7b6730f2678265857c8", "patch": "@@ -39,6 +39,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"calls.h\"\n #include \"gimple-range.h\"\n \n+#include \"gimple-predicate-analysis.h\"\n+\n /* This implements the pass that does predicate aware warning on uses of\n    possibly uninitialized variables.  The pass first collects the set of\n    possibly uninitialized SSA names.  For each such name, it walks through\n@@ -49,19 +51,11 @@ along with GCC; see the file COPYING3.  If not see\n    default definitions or by checking if the predicate set that guards the\n    defining paths is a superset of the use predicate.  */\n \n-/* Max PHI args we can handle in pass.  */\n-const unsigned max_phi_args = 32;\n-\n /* Pointer set of potentially undefined ssa names, i.e.,\n    ssa names that are defined by phi with operands that\n    are not defined or potentially undefined.  */\n static hash_set<tree> *possibly_undefined_names = 0;\n \n-/* Bit mask handling macros.  */\n-#define MASK_SET_BIT(mask, pos) mask |= (1 << pos)\n-#define MASK_TEST_BIT(mask, pos) (mask & (1 << pos))\n-#define MASK_EMPTY(mask) (mask == 0)\n-\n /* Returns the first bit position (starting from LSB)\n    in mask that is non zero.  Returns -1 if the mask is empty.  */\n static int\n@@ -389,23 +383,24 @@ check_defs (ao_ref *ref, tree vdef, void *data_)\n   /* The ASAN_MARK intrinsic doesn't modify the variable.  */\n   if (is_gimple_call (def_stmt))\n     {\n+      /* The ASAN_MARK intrinsic doesn't modify the variable.  */\n       if (gimple_call_internal_p (def_stmt)\n \t  && gimple_call_internal_fn (def_stmt) == IFN_ASAN_MARK)\n-       return false;\n+\treturn false;\n \n       if (tree fndecl = gimple_call_fndecl (def_stmt))\n-       {\n-\t /* Some sanitizer calls pass integer arguments to built-ins\n-\t    that expect pointers.  Avoid using gimple_call_builtin_p()\n-\t    which fails for such calls.  */\n-\t if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n-\t   {\n-\t     built_in_function fncode = DECL_FUNCTION_CODE (fndecl);\n-\t     if (fncode > BEGIN_SANITIZER_BUILTINS\n-\t\t && fncode < END_SANITIZER_BUILTINS)\n-\t       return false;\n-\t   }\n-       }\n+\t{\n+\t  /* Some sanitizer calls pass integer arguments to built-ins\n+\t     that expect pointets. Avoid using gimple_call_builtin_p()\n+\t     which fails for such calls.  */\n+\t  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+\t    {\n+\t      built_in_function fncode = DECL_FUNCTION_CODE (fndecl);\n+\t      if (fncode > BEGIN_SANITIZER_BUILTINS\n+\t\t  && fncode < END_SANITIZER_BUILTINS)\n+\t\treturn false;\n+\t    }\n+\t}\n     }\n \n   /* End of VLA scope is not a kill.  */\n@@ -998,8 +993,8 @@ can_skip_redundant_opnd (tree opnd, gimple *phi)\n   return true;\n }\n \n-/* Returns a bit mask holding the positions of arguments in PHI\n-   that have empty (or possibly empty) definitions.  */\n+/* Return a bitset holding the positions of arguments in PHI with empty\n+   (or possibly empty) definitions.  */\n \n static unsigned\n compute_uninit_opnds_pos (gphi *phi)\n@@ -1008,7 +1003,7 @@ compute_uninit_opnds_pos (gphi *phi)\n \n   unsigned n = gimple_phi_num_args (phi);\n   /* Bail out for phi with too many args.  */\n-  if (n > max_phi_args)\n+  if (n > predicate::func_t::max_phi_args)\n     return 0;\n \n   for (unsigned i = 0; i < n; ++i)\n@@ -1031,2300 +1026,231 @@ compute_uninit_opnds_pos (gphi *phi)\n   return uninit_opnds;\n }\n \n-/* Find the immediate postdominator of the specified basic block BLOCK.  */\n-\n-static inline basic_block\n-find_pdom (basic_block block)\n-{\n-  if (block == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-    return EXIT_BLOCK_PTR_FOR_FN (cfun);\n-  else\n-    {\n-      basic_block bb = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n-      if (!bb)\n-\treturn EXIT_BLOCK_PTR_FOR_FN (cfun);\n-      return bb;\n-    }\n-}\n-\n-/* Find the immediate dominator of the specified basic block BLOCK.  */\n+/* Function object type used to determine whether an expression\n+   is of interest to the predicate analyzer.  */\n \n-static inline basic_block\n-find_dom (basic_block block)\n+struct uninit_undef_val_t: public predicate::func_t\n {\n-  if (block == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-    return ENTRY_BLOCK_PTR_FOR_FN (cfun);\n-  else\n-    {\n-      basic_block bb = get_immediate_dominator (CDI_DOMINATORS, block);\n-      if (!bb)\n-\treturn ENTRY_BLOCK_PTR_FOR_FN (cfun);\n-      return bb;\n-    }\n-}\n+  virtual bool operator()(tree) override;\n+  virtual unsigned phi_arg_set (gphi *) override;\n+};\n \n-/* Returns true if BB1 is postdominating BB2 and BB1 is\n-   not a loop exit bb.  The loop exit bb check is simple and does\n-   not cover all cases.  */\n+/* Return true if the argument is an expression of interest.  */\n \n-static bool\n-is_non_loop_exit_postdominating (basic_block bb1, basic_block bb2)\n+bool\n+uninit_undef_val_t::operator()(tree val)\n {\n-  if (!dominated_by_p (CDI_POST_DOMINATORS, bb2, bb1))\n-    return false;\n-\n-  if (single_pred_p (bb1) && !single_succ_p (bb2))\n-    return false;\n+  if (TREE_CODE (val) == SSA_NAME)\n+    return uninit_undefined_value_p (val);\n \n-  return true;\n+  return false;\n }\n \n-/* Find the closest postdominator of a specified BB, which is control\n-   equivalent to BB.  */\n+/* Return a bitset of PHI arguments of interest.  */\n \n-static inline basic_block\n-find_control_equiv_block (basic_block bb)\n+unsigned\n+uninit_undef_val_t::phi_arg_set (gphi *phi)\n {\n-  basic_block pdom = find_pdom (bb);\n-\n-  /* Skip the postdominating bb that is also loop exit.  */\n-  if (!is_non_loop_exit_postdominating (pdom, bb))\n-    return NULL;\n-\n-  if (dominated_by_p (CDI_DOMINATORS, pdom, bb))\n-    return pdom;\n-\n-  return NULL;\n+  return compute_uninit_opnds_pos (phi);\n }\n \n-#define MAX_NUM_CHAINS 8\n-#define MAX_CHAIN_LEN 5\n-#define MAX_POSTDOM_CHECK 8\n-#define MAX_SWITCH_CASES 40\n-\n-/* Computes the control dependence chains (paths of edges)\n-   for DEP_BB up to the dominating basic block BB (the head node of a\n-   chain should be dominated by it).  CD_CHAINS is pointer to an\n-   array holding the result chains.  CUR_CD_CHAIN is the current\n-   chain being computed.  *NUM_CHAINS is total number of chains.  The\n-   function returns true if the information is successfully computed,\n-   return false if there is no control dependence or not computed.  */\n+/* Searches through all uses of a potentially\n+   uninitialized variable defined by PHI and returns a use\n+   statement if the use is not properly guarded.  It returns\n+   NULL if all uses are guarded.  UNINIT_OPNDS is a bitvector\n+   holding the position(s) of uninit PHI operands.  WORKLIST\n+   is the vector of candidate phis that may be updated by this\n+   function.  ADDED_TO_WORKLIST is the pointer set tracking\n+   if the new phi is already in the worklist.  */\n \n-static bool\n-compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n-\t\t\t   vec<edge> *cd_chains,\n-\t\t\t   size_t *num_chains,\n-\t\t\t   vec<edge> *cur_cd_chain,\n-\t\t\t   int *num_calls)\n+static gimple *\n+find_uninit_use (gphi *phi, unsigned uninit_opnds,\n+\t\t vec<gphi *> *worklist, hash_set<gphi *> *added_to_worklist)\n {\n-  edge_iterator ei;\n-  edge e;\n-  size_t i;\n-  bool found_cd_chain = false;\n-  size_t cur_chain_len = 0;\n-\n-  if (*num_calls > param_uninit_control_dep_attempts)\n-    return false;\n-  ++*num_calls;\n-\n-  /* Could use a set instead.  */\n-  cur_chain_len = cur_cd_chain->length ();\n-  if (cur_chain_len > MAX_CHAIN_LEN)\n-    return false;\n+  /* The Boolean predicate guarding the PHI definition.  Initialized\n+     lazily from PHI in the first call to is_use_guarded() and cached\n+     for subsequent iterations.  */\n+  uninit_undef_val_t eval;\n+  predicate def_preds (eval);\n \n-  for (i = 0; i < cur_chain_len; i++)\n-    {\n-      edge e = (*cur_cd_chain)[i];\n-      /* Cycle detected.  */\n-      if (e->src == bb)\n-\treturn false;\n-    }\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n+  use_operand_p use_p;\n+  imm_use_iterator iter;\n+  tree phi_result = gimple_phi_result (phi);\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, phi_result)\n     {\n-      basic_block cd_bb;\n-      int post_dom_check = 0;\n-      if (e->flags & (EDGE_FAKE | EDGE_ABNORMAL))\n+      gimple *use_stmt = USE_STMT (use_p);\n+      if (is_gimple_debug (use_stmt))\n \tcontinue;\n \n-      cd_bb = e->dest;\n-      cur_cd_chain->safe_push (e);\n-      while (!is_non_loop_exit_postdominating (cd_bb, bb))\n-\t{\n-\t  if (cd_bb == dep_bb)\n-\t    {\n-\t      /* Found a direct control dependence.  */\n-\t      if (*num_chains < MAX_NUM_CHAINS)\n-\t\t{\n-\t\t  cd_chains[*num_chains] = cur_cd_chain->copy ();\n-\t\t  (*num_chains)++;\n-\t\t}\n-\t      found_cd_chain = true;\n-\t      /* Check path from next edge.  */\n-\t      break;\n-\t    }\n+      basic_block use_bb;\n+      if (gphi *use_phi = dyn_cast<gphi *> (use_stmt))\n+\tuse_bb = gimple_phi_arg_edge (use_phi,\n+\t\t\t\t      PHI_ARG_INDEX_FROM_USE (use_p))->src;\n+      else\n+\tuse_bb = gimple_bb (use_stmt);\n \n-\t  /* Now check if DEP_BB is indirectly control dependent on BB.  */\n-\t  if (compute_control_dep_chain (cd_bb, dep_bb, cd_chains, num_chains,\n-\t\t\t\t\t cur_cd_chain, num_calls))\n-\t    {\n-\t      found_cd_chain = true;\n-\t      break;\n-\t    }\n+      if (def_preds.is_use_guarded (use_stmt, use_bb, phi, uninit_opnds))\n+\tcontinue;\n \n-\t  cd_bb = find_pdom (cd_bb);\n-\t  post_dom_check++;\n-\t  if (cd_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n-\t      || post_dom_check > MAX_POSTDOM_CHECK)\n-\t    break;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Found unguarded use in bb %u: \",\n+\t\t   use_bb->index);\n+\t  print_gimple_stmt (dump_file, use_stmt, 0);\n \t}\n-      cur_cd_chain->pop ();\n-      gcc_assert (cur_cd_chain->length () == cur_chain_len);\n-    }\n-  gcc_assert (cur_cd_chain->length () == cur_chain_len);\n-\n-  return found_cd_chain;\n-}\n-\n-/* The type to represent a simple predicate.  */\n-\n-struct pred_info\n-{\n-  tree pred_lhs;\n-  tree pred_rhs;\n-  enum tree_code cond_code;\n-  bool invert;\n-};\n-\n-/* The type to represent a sequence of predicates grouped\n-  with .AND. operation.  */\n-\n-typedef vec<pred_info, va_heap, vl_ptr> pred_chain;\n-\n-/* The type to represent a sequence of pred_chains grouped\n-  with .OR. operation.  */\n-\n-typedef vec<pred_chain, va_heap, vl_ptr> pred_chain_union;\n-\n-/* Converts the chains of control dependence edges into a set of\n-   predicates.  A control dependence chain is represented by a vector\n-   edges.  DEP_CHAINS points to an array of dependence chains.\n-   NUM_CHAINS is the size of the chain array.  One edge in a dependence\n-   chain is mapped to predicate expression represented by pred_info\n-   type.  One dependence chain is converted to a composite predicate that\n-   is the result of AND operation of pred_info mapped to each edge.\n-   A composite predicate is presented by a vector of pred_info.  On\n-   return, *PREDS points to the resulting array of composite predicates.\n-   *NUM_PREDS is the number of composite predictes.  */\n-\n-static bool\n-convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n-\t\t\t\t      size_t num_chains,\n-\t\t\t\t      pred_chain_union *preds)\n-{\n-  bool has_valid_pred = false;\n-  size_t i, j;\n-  if (num_chains == 0 || num_chains >= MAX_NUM_CHAINS)\n-    return false;\n-\n-  /* Now convert the control dep chain into a set\n-     of predicates.  */\n-  preds->reserve (num_chains);\n-\n-  for (i = 0; i < num_chains; i++)\n-    {\n-      vec<edge> one_cd_chain = dep_chains[i];\n+      /* Found one real use, return.  */\n+      if (gimple_code (use_stmt) != GIMPLE_PHI)\n+\treturn use_stmt;\n \n-      has_valid_pred = false;\n-      pred_chain t_chain = vNULL;\n-      for (j = 0; j < one_cd_chain.length (); j++)\n+      /* Found a phi use that is not guarded,\n+\t add the phi to the worklist.  */\n+      if (!added_to_worklist->add (as_a<gphi *> (use_stmt)))\n \t{\n-\t  gimple *cond_stmt;\n-\t  gimple_stmt_iterator gsi;\n-\t  basic_block guard_bb;\n-\t  pred_info one_pred;\n-\t  edge e;\n-\n-\t  e = one_cd_chain[j];\n-\t  guard_bb = e->src;\n-\t  gsi = gsi_last_bb (guard_bb);\n-\t  /* Ignore empty forwarder blocks.  */\n-\t  if (empty_block_p (guard_bb) && single_succ_p (guard_bb))\n-\t    continue;\n-\t  /* An empty basic block here is likely a PHI, and is not one\n-\t     of the cases we handle below.  */\n-\t  if (gsi_end_p (gsi))\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      has_valid_pred = false;\n-\t      break;\n+\t      fprintf (dump_file, \"[WORKLIST]: Update worklist with phi: \");\n+\t      print_gimple_stmt (dump_file, use_stmt, 0);\n \t    }\n-\t  cond_stmt = gsi_stmt (gsi);\n-\t  if (is_gimple_call (cond_stmt) && EDGE_COUNT (e->src->succs) >= 2)\n-\t    /* Ignore EH edge.  Can add assertion on the other edge's flag.  */\n-\t    continue;\n-\t  /* Skip if there is essentially one succesor.  */\n-\t  if (EDGE_COUNT (e->src->succs) == 2)\n-\t    {\n-\t      edge e1;\n-\t      edge_iterator ei1;\n-\t      bool skip = false;\n \n-\t      FOR_EACH_EDGE (e1, ei1, e->src->succs)\n-\t\t{\n-\t\t  if (EDGE_COUNT (e1->dest->succs) == 0)\n-\t\t    {\n-\t\t      skip = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      if (skip)\n-\t\tcontinue;\n-\t    }\n-\t  if (gimple_code (cond_stmt) == GIMPLE_COND)\n-\t    {\n-\t      one_pred.pred_lhs = gimple_cond_lhs (cond_stmt);\n-\t      one_pred.pred_rhs = gimple_cond_rhs (cond_stmt);\n-\t      one_pred.cond_code = gimple_cond_code (cond_stmt);\n-\t      one_pred.invert = !!(e->flags & EDGE_FALSE_VALUE);\n-\t      t_chain.safe_push (one_pred);\n-\t      has_valid_pred = true;\n-\t    }\n-\t  else if (gswitch *gs = dyn_cast<gswitch *> (cond_stmt))\n-\t    {\n-\t      /* Avoid quadratic behavior.  */\n-\t      if (gimple_switch_num_labels (gs) > MAX_SWITCH_CASES)\n-\t\t{\n-\t\t  has_valid_pred = false;\n-\t\t  break;\n-\t\t}\n-\t      /* Find the case label.  */\n-\t      tree l = NULL_TREE;\n-\t      unsigned idx;\n-\t      for (idx = 0; idx < gimple_switch_num_labels (gs); ++idx)\n-\t\t{\n-\t\t  tree tl = gimple_switch_label (gs, idx);\n-\t\t  if (e->dest == label_to_block (cfun, CASE_LABEL (tl)))\n-\t\t    {\n-\t\t      if (!l)\n-\t\t\tl = tl;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  l = NULL_TREE;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      /* If more than one label reaches this block or the case\n-\t\t label doesn't have a single value (like the default one)\n-\t\t fail.  */\n-\t      if (!l\n-\t\t  || !CASE_LOW (l)\n-\t\t  || (CASE_HIGH (l)\n-\t\t      && !operand_equal_p (CASE_LOW (l), CASE_HIGH (l), 0)))\n-\t\t{\n-\t\t  has_valid_pred = false;\n-\t\t  break;\n-\t\t}\n-\t      one_pred.pred_lhs = gimple_switch_index (gs);\n-\t      one_pred.pred_rhs = CASE_LOW (l);\n-\t      one_pred.cond_code = EQ_EXPR;\n-\t      one_pred.invert = false;\n-\t      t_chain.safe_push (one_pred);\n-\t      has_valid_pred = true;\n-\t    }\n-\t  else\n-\t    {\n-\t      has_valid_pred = false;\n-\t      break;\n-\t    }\n+\t  worklist->safe_push (as_a<gphi *> (use_stmt));\n+\t  possibly_undefined_names->add (phi_result);\n \t}\n-\n-      if (!has_valid_pred)\n-\tbreak;\n-      else\n-\tpreds->safe_push (t_chain);\n-    }\n-  return has_valid_pred;\n-}\n-\n-/* Computes all control dependence chains for USE_BB.  The control\n-   dependence chains are then converted to an array of composite\n-   predicates pointed to by PREDS.  PHI_BB is the basic block of\n-   the phi whose result is used in USE_BB.  */\n-\n-static bool\n-find_predicates (pred_chain_union *preds,\n-\t\t basic_block phi_bb,\n-\t\t basic_block use_bb)\n-{\n-  size_t num_chains = 0, i;\n-  int num_calls = 0;\n-  vec<edge> dep_chains[MAX_NUM_CHAINS];\n-  auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n-  bool has_valid_pred = false;\n-  basic_block cd_root = 0;\n-\n-  /* First find the closest bb that is control equivalent to PHI_BB\n-     that also dominates USE_BB.  */\n-  cd_root = phi_bb;\n-  while (dominated_by_p (CDI_DOMINATORS, use_bb, cd_root))\n-    {\n-      basic_block ctrl_eq_bb = find_control_equiv_block (cd_root);\n-      if (ctrl_eq_bb && dominated_by_p (CDI_DOMINATORS, use_bb, ctrl_eq_bb))\n-\tcd_root = ctrl_eq_bb;\n-      else\n-\tbreak;\n     }\n \n-  compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains,\n-\t\t\t     &cur_chain, &num_calls);\n-\n-  has_valid_pred\n-    = convert_control_dep_chain_into_preds (dep_chains, num_chains, preds);\n-  for (i = 0; i < num_chains; i++)\n-    dep_chains[i].release ();\n-  return has_valid_pred;\n+  return NULL;\n }\n \n-/* Computes the set of incoming edges of PHI that have non empty\n-   definitions of a phi chain.  The collection will be done\n-   recursively on operands that are defined by phis.  CD_ROOT\n-   is the control dependence root.  *EDGES holds the result, and\n-   VISITED_PHIS is a pointer set for detecting cycles.  */\n+/* Look for inputs to PHI that are SSA_NAMEs that have empty definitions\n+   and gives warning if there exists a runtime path from the entry to a\n+   use of the PHI def that does not contain a definition.  In other words,\n+   the warning is on the real use.  The more dead paths that can be pruned\n+   by the compiler, the fewer false positives the warning is.  WORKLIST\n+   is a vector of candidate phis to be examined.  ADDED_TO_WORKLIST is\n+   a pointer set tracking if the new phi is added to the worklist or not.  */\n \n static void\n-collect_phi_def_edges (gphi *phi, basic_block cd_root,\n-\t\t       auto_vec<edge> *edges,\n-\t\t       hash_set<gimple *> *visited_phis)\n+warn_uninitialized_phi (gphi *phi, vec<gphi *> *worklist,\n+\t\t\thash_set<gphi *> *added_to_worklist)\n {\n-  size_t i, n;\n-  edge opnd_edge;\n-  tree opnd;\n+  /* Don't look at virtual operands.  */\n+  if (virtual_operand_p (gimple_phi_result (phi)))\n+    return;\n \n-  if (visited_phis->add (phi))\n+  unsigned uninit_opnds = compute_uninit_opnds_pos (phi);\n+  if (MASK_EMPTY (uninit_opnds))\n     return;\n \n-  n = gimple_phi_num_args (phi);\n-  for (i = 0; i < n; i++)\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      opnd_edge = gimple_phi_arg_edge (phi, i);\n-      opnd = gimple_phi_arg_def (phi, i);\n-\n-      if (TREE_CODE (opnd) != SSA_NAME)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"\\n[CHECK] Found def edge %d in \", (int) i);\n-\t      print_gimple_stmt (dump_file, phi, 0);\n-\t    }\n-\t  edges->safe_push (opnd_edge);\n-\t}\n-      else\n-\t{\n-\t  gimple *def = SSA_NAME_DEF_STMT (opnd);\n-\n-\t  if (gimple_code (def) == GIMPLE_PHI\n-\t      && dominated_by_p (CDI_DOMINATORS, gimple_bb (def), cd_root))\n-\t    collect_phi_def_edges (as_a<gphi *> (def), cd_root, edges,\n-\t\t\t\t   visited_phis);\n-\t  else if (!uninit_undefined_value_p (opnd))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"\\n[CHECK] Found def edge %d in \",\n-\t\t\t   (int) i);\n-\t\t  print_gimple_stmt (dump_file, phi, 0);\n-\t\t}\n-\t      edges->safe_push (opnd_edge);\n-\t    }\n-\t}\n+      fprintf (dump_file, \"Examining phi: \");\n+      print_gimple_stmt (dump_file, phi, 0);\n     }\n-}\n \n-/* For each use edge of PHI, computes all control dependence chains.\n-   The control dependence chains are then converted to an array of\n-   composite predicates pointed to by PREDS.  */\n-\n-static bool\n-find_def_preds (pred_chain_union *preds, gphi *phi)\n-{\n-  size_t num_chains = 0, i, n;\n-  vec<edge> dep_chains[MAX_NUM_CHAINS];\n-  auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n-  auto_vec<edge> def_edges;\n-  bool has_valid_pred = false;\n-  basic_block phi_bb, cd_root = 0;\n-\n-  phi_bb = gimple_bb (phi);\n-  /* First find the closest dominating bb to be\n-     the control dependence root.  */\n-  cd_root = find_dom (phi_bb);\n-  if (!cd_root)\n-    return false;\n+  gimple *uninit_use_stmt = find_uninit_use (phi, uninit_opnds,\n+\t\t\t\t\t     worklist, added_to_worklist);\n \n-  hash_set<gimple *> visited_phis;\n-  collect_phi_def_edges (phi, cd_root, &def_edges, &visited_phis);\n+  /* All uses are properly guarded but a new PHI may have been added\n+     to WORKLIST.  */\n+  if (!uninit_use_stmt)\n+    return;\n \n-  n = def_edges.length ();\n-  if (n == 0)\n-    return false;\n+  unsigned phiarg_index = MASK_FIRST_SET_BIT (uninit_opnds);\n+  tree uninit_op = gimple_phi_arg_def (phi, phiarg_index);\n+  if (SSA_NAME_VAR (uninit_op) == NULL_TREE)\n+    return;\n \n-  for (i = 0; i < n; i++)\n+  location_t loc = UNKNOWN_LOCATION;\n+  if (gimple_phi_arg_has_location (phi, phiarg_index))\n+    loc = gimple_phi_arg_location (phi, phiarg_index);\n+  else\n     {\n-      size_t prev_nc, j;\n-      int num_calls = 0;\n-      edge opnd_edge;\n-\n-      opnd_edge = def_edges[i];\n-      prev_nc = num_chains;\n-      compute_control_dep_chain (cd_root, opnd_edge->src, dep_chains,\n-\t\t\t\t &num_chains, &cur_chain, &num_calls);\n-\n-      /* Now update the newly added chains with\n-\t the phi operand edge:  */\n-      if (EDGE_COUNT (opnd_edge->src->succs) > 1)\n+      tree arg_def = gimple_phi_arg_def (phi, phiarg_index);\n+      if (TREE_CODE (arg_def) == SSA_NAME)\n \t{\n-\t  if (prev_nc == num_chains && num_chains < MAX_NUM_CHAINS)\n-\t    dep_chains[num_chains++] = vNULL;\n-\t  for (j = prev_nc; j < num_chains; j++)\n-\t    dep_chains[j].safe_push (opnd_edge);\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (arg_def);\n+\t  if (gphi *arg_phi = dyn_cast<gphi *> (def_stmt))\n+\t    {\n+\t      unsigned uop = compute_uninit_opnds_pos (arg_phi);\n+\t      unsigned idx = MASK_FIRST_SET_BIT (uop);\n+\t      if (idx < gimple_phi_num_args (arg_phi)\n+\t\t  && gimple_phi_arg_has_location (arg_phi, idx))\n+\t\tloc = gimple_phi_arg_location (arg_phi, idx);\n+\t    }\n \t}\n     }\n \n-  has_valid_pred\n-    = convert_control_dep_chain_into_preds (dep_chains, num_chains, preds);\n-  for (i = 0; i < num_chains; i++)\n-    dep_chains[i].release ();\n-  return has_valid_pred;\n+  warn_uninit (OPT_Wmaybe_uninitialized, uninit_op,\n+\t       SSA_NAME_VAR (uninit_op),\n+\t       \"%qD may be used uninitialized in this function\",\n+\t       uninit_use_stmt, loc);\n }\n \n-/* Dump a pred_info.  */\n-\n-static void\n-dump_pred_info (pred_info one_pred)\n+static bool\n+gate_warn_uninitialized (void)\n {\n-  if (one_pred.invert)\n-    fprintf (dump_file, \" (.NOT.) \");\n-  print_generic_expr (dump_file, one_pred.pred_lhs);\n-  fprintf (dump_file, \" %s \", op_symbol_code (one_pred.cond_code));\n-  print_generic_expr (dump_file, one_pred.pred_rhs);\n+  return warn_uninitialized || warn_maybe_uninitialized;\n }\n \n-/* Dump a pred_chain.  */\n+namespace {\n \n-static void\n-dump_pred_chain (pred_chain one_pred_chain)\n+const pass_data pass_data_late_warn_uninitialized =\n {\n-  size_t np = one_pred_chain.length ();\n-  for (size_t j = 0; j < np; j++)\n-    {\n-      dump_pred_info (one_pred_chain[j]);\n-      if (j < np - 1)\n-\tfprintf (dump_file, \" (.AND.) \");\n-      else\n-\tfprintf (dump_file, \"\\n\");\n-    }\n-}\n-\n-/* Dumps the predicates (PREDS) for USESTMT.  */\n+  GIMPLE_PASS, /* type */\n+  \"uninit\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n \n-static void\n-dump_predicates (gimple *usestmt, pred_chain_union preds, const char *msg)\n+class pass_late_warn_uninitialized : public gimple_opt_pass\n {\n-  fprintf (dump_file, \"%s\", msg);\n-  if (usestmt)\n-    {\n-      print_gimple_stmt (dump_file, usestmt, 0);\n-      fprintf (dump_file, \"is guarded by :\\n\\n\");\n-    }\n-  size_t num_preds = preds.length ();\n-  for (size_t i = 0; i < num_preds; i++)\n-    {\n-      dump_pred_chain (preds[i]);\n-      if (i < num_preds - 1)\n-\tfprintf (dump_file, \"(.OR.)\\n\");\n-      else\n-\tfprintf (dump_file, \"\\n\\n\");\n-    }\n-}\n+public:\n+  pass_late_warn_uninitialized (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_late_warn_uninitialized, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass *clone () { return new pass_late_warn_uninitialized (m_ctxt); }\n+  virtual bool gate (function *) { return gate_warn_uninitialized (); }\n+  virtual unsigned int execute (function *);\n \n-/* Destroys the predicate set *PREDS.  */\n+}; // class pass_late_warn_uninitialized\n \n static void\n-destroy_predicate_vecs (pred_chain_union *preds)\n+execute_late_warn_uninitialized (function *fun)\n {\n-  size_t i;\n-\n-  size_t n = preds->length ();\n-  for (i = 0; i < n; i++)\n-    (*preds)[i].release ();\n-  preds->release ();\n-}\n-\n-/* Computes the 'normalized' conditional code with operand\n-   swapping and condition inversion.  */\n+  basic_block bb;\n+  gphi_iterator gsi;\n+  vec<gphi *> worklist = vNULL;\n \n-static enum tree_code\n-get_cmp_code (enum tree_code orig_cmp_code, bool swap_cond, bool invert)\n-{\n-  enum tree_code tc = orig_cmp_code;\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  /* Re-do the plain uninitialized variable check, as optimization may have\n+     straightened control flow.  Do this first so that we don't accidentally\n+     get a \"may be\" warning when we'd have seen an \"is\" warning later.  */\n+  warn_uninitialized_vars (/*warn_maybe_uninitialized=*/1);\n \n-  if (swap_cond)\n-    tc = swap_tree_comparison (orig_cmp_code);\n-  if (invert)\n-    tc = invert_tree_comparison (tc, false);\n+  timevar_push (TV_TREE_UNINIT);\n \n-  switch (tc)\n-    {\n-    case LT_EXPR:\n-    case LE_EXPR:\n-    case GT_EXPR:\n-    case GE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-      break;\n-    default:\n-      return ERROR_MARK;\n-    }\n-  return tc;\n-}\n+  possibly_undefined_names = new hash_set<tree>;\n+  hash_set<gphi *> added_to_worklist;\n \n-/* Returns whether VAL CMPC BOUNDARY is true.  */\n-\n-static bool\n-is_value_included_in (tree val, tree boundary, enum tree_code cmpc)\n-{\n-  bool inverted = false;\n-  bool result;\n-\n-  /* Only handle integer constant here.  */\n-  if (TREE_CODE (val) != INTEGER_CST || TREE_CODE (boundary) != INTEGER_CST)\n-    return true;\n-\n-  if (cmpc == GE_EXPR || cmpc == GT_EXPR || cmpc == NE_EXPR)\n-    {\n-      cmpc = invert_tree_comparison (cmpc, false);\n-      inverted = true;\n-    }\n-\n-  if (cmpc == EQ_EXPR)\n-    result = tree_int_cst_equal (val, boundary);\n-  else if (cmpc == LT_EXPR)\n-    result = tree_int_cst_lt (val, boundary);\n-  else\n-    {\n-      gcc_assert (cmpc == LE_EXPR);\n-      result = tree_int_cst_le (val, boundary);\n-    }\n-\n-  if (inverted)\n-    result ^= 1;\n-\n-  return result;\n-}\n-\n-/* Returns whether VAL satisfies (x CMPC BOUNDARY) predicate.  CMPC can be\n-   either one of the range comparison codes ({GE,LT,EQ,NE}_EXPR and the like),\n-   or BIT_AND_EXPR.  EXACT_P is only meaningful for the latter.  It modifies the\n-   question from whether VAL & BOUNDARY != 0 to whether VAL & BOUNDARY == VAL.\n-   For other values of CMPC, EXACT_P is ignored.  */\n-\n-static bool\n-value_sat_pred_p (tree val, tree boundary, enum tree_code cmpc,\n-\t\t  bool exact_p = false)\n-{\n-  if (cmpc != BIT_AND_EXPR)\n-    return is_value_included_in (val, boundary, cmpc);\n-\n-  wide_int andw = wi::to_wide (val) & wi::to_wide (boundary);\n-  if (exact_p)\n-    return andw == wi::to_wide (val);\n-  else\n-    return andw.to_uhwi ();\n-}\n-\n-/* Returns true if PRED is common among all the predicate\n-   chains (PREDS) (and therefore can be factored out).  */\n-\n-static bool\n-find_matching_predicate_in_rest_chains (pred_info pred, pred_chain_union preds)\n-{\n-  size_t i, j, n;\n-\n-  /* Trival case.  */\n-  if (preds.length () == 1)\n-    return true;\n-\n-  for (i = 1; i < preds.length (); i++)\n-    {\n-      bool found = false;\n-      pred_chain one_chain = preds[i];\n-      n = one_chain.length ();\n-      for (j = 0; j < n; j++)\n-\t{\n-\t  pred_info pred2 = one_chain[j];\n-\t  /* Can relax the condition comparison to not\n-\t     use address comparison.  However, the most common\n-\t     case is that multiple control dependent paths share\n-\t     a common path prefix, so address comparison should\n-\t     be ok.  */\n-\n-\t  if (operand_equal_p (pred2.pred_lhs, pred.pred_lhs, 0)\n-\t      && operand_equal_p (pred2.pred_rhs, pred.pred_rhs, 0)\n-\t      && pred2.invert == pred.invert)\n-\t    {\n-\t      found = true;\n-\t      break;\n-\t    }\n-\t}\n-      if (!found)\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n-/* Forward declaration.  */\n-static bool is_use_properly_guarded (gimple *use_stmt,\n-\t\t\t\t     basic_block use_bb,\n-\t\t\t\t     gphi *phi,\n-\t\t\t\t     unsigned uninit_opnds,\n-\t\t\t\t     pred_chain_union *def_preds,\n-\t\t\t\t     hash_set<gphi *> *visited_phis);\n-\n-/* Returns true if all uninitialized opnds are pruned.  Returns false\n-   otherwise.  PHI is the phi node with uninitialized operands,\n-   UNINIT_OPNDS is the bitmap of the uninitialize operand positions,\n-   FLAG_DEF is the statement defining the flag guarding the use of the\n-   PHI output, BOUNDARY_CST is the const value used in the predicate\n-   associated with the flag, CMP_CODE is the comparison code used in\n-   the predicate, VISITED_PHIS is the pointer set of phis visited, and\n-   VISITED_FLAG_PHIS is the pointer to the pointer set of flag definitions\n-   that are also phis.\n-\n-   Example scenario:\n-\n-   BB1:\n-   flag_1 = phi <0, 1>\t\t\t// (1)\n-   var_1  = phi <undef, some_val>\n-\n-\n-   BB2:\n-   flag_2 = phi <0,   flag_1, flag_1>   // (2)\n-   var_2  = phi <undef, var_1, var_1>\n-   if (flag_2 == 1)\n-      goto BB3;\n-\n-   BB3:\n-   use of var_2\t\t\t\t// (3)\n-\n-   Because some flag arg in (1) is not constant, if we do not look into the\n-   flag phis recursively, it is conservatively treated as unknown and var_1\n-   is thought to be flowed into use at (3).  Since var_1 is potentially\n-   uninitialized a false warning will be emitted.\n-   Checking recursively into (1), the compiler can find out that only some_val\n-   (which is defined) can flow into (3) which is OK.  */\n-\n-static bool\n-prune_uninit_phi_opnds (gphi *phi, unsigned uninit_opnds, gphi *flag_def,\n-\t\t\ttree boundary_cst, enum tree_code cmp_code,\n-\t\t\thash_set<gphi *> *visited_phis,\n-\t\t\tbitmap *visited_flag_phis)\n-{\n-  unsigned i;\n-\n-  for (i = 0; i < MIN (max_phi_args, gimple_phi_num_args (flag_def)); i++)\n-    {\n-      tree flag_arg;\n-\n-      if (!MASK_TEST_BIT (uninit_opnds, i))\n-\tcontinue;\n-\n-      flag_arg = gimple_phi_arg_def (flag_def, i);\n-      if (!is_gimple_constant (flag_arg))\n-\t{\n-\t  gphi *flag_arg_def, *phi_arg_def;\n-\t  tree phi_arg;\n-\t  unsigned uninit_opnds_arg_phi;\n-\n-\t  if (TREE_CODE (flag_arg) != SSA_NAME)\n-\t    return false;\n-\t  flag_arg_def = dyn_cast<gphi *> (SSA_NAME_DEF_STMT (flag_arg));\n-\t  if (!flag_arg_def)\n-\t    return false;\n-\n-\t  phi_arg = gimple_phi_arg_def (phi, i);\n-\t  if (TREE_CODE (phi_arg) != SSA_NAME)\n-\t    return false;\n-\n-\t  phi_arg_def = dyn_cast<gphi *> (SSA_NAME_DEF_STMT (phi_arg));\n-\t  if (!phi_arg_def)\n-\t    return false;\n-\n-\t  if (gimple_bb (phi_arg_def) != gimple_bb (flag_arg_def))\n-\t    return false;\n-\n-\t  if (!*visited_flag_phis)\n-\t    *visited_flag_phis = BITMAP_ALLOC (NULL);\n-\n-\t  tree phi_result = gimple_phi_result (flag_arg_def);\n-\t  if (bitmap_bit_p (*visited_flag_phis, SSA_NAME_VERSION (phi_result)))\n-\t    return false;\n-\n-\t  bitmap_set_bit (*visited_flag_phis,\n-\t\t\t  SSA_NAME_VERSION (gimple_phi_result (flag_arg_def)));\n-\n-\t  /* Now recursively prune the uninitialized phi args.  */\n-\t  uninit_opnds_arg_phi = compute_uninit_opnds_pos (phi_arg_def);\n-\t  if (!prune_uninit_phi_opnds\n-\t      (phi_arg_def, uninit_opnds_arg_phi, flag_arg_def, boundary_cst,\n-\t       cmp_code, visited_phis, visited_flag_phis))\n-\t    return false;\n-\n-\t  phi_result = gimple_phi_result (flag_arg_def);\n-\t  bitmap_clear_bit (*visited_flag_phis, SSA_NAME_VERSION (phi_result));\n-\t  continue;\n-\t}\n-\n-      /* Now check if the constant is in the guarded range.  */\n-      if (is_value_included_in (flag_arg, boundary_cst, cmp_code))\n-\t{\n-\t  tree opnd;\n-\t  gimple *opnd_def;\n-\n-\t  /* Now that we know that this undefined edge is not\n-\t     pruned.  If the operand is defined by another phi,\n-\t     we can further prune the incoming edges of that\n-\t     phi by checking the predicates of this operands.  */\n-\n-\t  opnd = gimple_phi_arg_def (phi, i);\n-\t  opnd_def = SSA_NAME_DEF_STMT (opnd);\n-\t  if (gphi *opnd_def_phi = dyn_cast <gphi *> (opnd_def))\n-\t    {\n-\t      edge opnd_edge;\n-\t      unsigned uninit_opnds2 = compute_uninit_opnds_pos (opnd_def_phi);\n-\t      if (!MASK_EMPTY (uninit_opnds2))\n-\t\t{\n-\t\t  pred_chain_union def_preds = vNULL;\n-\t\t  bool ok;\n-\t\t  opnd_edge = gimple_phi_arg_edge (phi, i);\n-\t\t  ok = is_use_properly_guarded (phi,\n-\t\t\t\t\t\topnd_edge->src,\n-\t\t\t\t\t\topnd_def_phi,\n-\t\t\t\t\t\tuninit_opnds2,\n-\t\t\t\t\t\t&def_preds,\n-\t\t\t\t\t\tvisited_phis);\n-\t\t  destroy_predicate_vecs (&def_preds);\n-\t\t  if (!ok)\n-\t\t    return false;\n-\t\t}\n-\t    }\n-\t  else\n-\t    return false;\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n-/* A helper function finds predicate which will be examined against uninit\n-   paths.  If there is no \"flag_var cmp const\" form predicate, the function\n-   tries to find predicate of form like \"flag_var cmp flag_var\" with value\n-   range info.  PHI is the phi node whose incoming (undefined) paths need to\n-   be examined.  On success, the function returns the comparsion code, sets\n-   defintion gimple of the flag_var to FLAG_DEF, sets boundary_cst to\n-   BOUNDARY_CST.  On fail, the function returns ERROR_MARK.  */\n-\n-static enum tree_code\n-find_var_cmp_const (pred_chain_union preds, gphi *phi, gimple **flag_def,\n-\t\t    tree *boundary_cst)\n-{\n-  enum tree_code vrinfo_code = ERROR_MARK, code;\n-  gimple *vrinfo_def = NULL;\n-  tree vrinfo_cst = NULL, cond_lhs, cond_rhs;\n-\n-  gcc_assert (preds.length () > 0);\n-  pred_chain the_pred_chain = preds[0];\n-  for (unsigned i = 0; i < the_pred_chain.length (); i++)\n-    {\n-      bool use_vrinfo_p = false;\n-      pred_info the_pred = the_pred_chain[i];\n-      cond_lhs = the_pred.pred_lhs;\n-      cond_rhs = the_pred.pred_rhs;\n-      if (cond_lhs == NULL_TREE || cond_rhs == NULL_TREE)\n-\tcontinue;\n-\n-      code = get_cmp_code (the_pred.cond_code, false, the_pred.invert);\n-      if (code == ERROR_MARK)\n-\tcontinue;\n-\n-      if (TREE_CODE (cond_lhs) == SSA_NAME && is_gimple_constant (cond_rhs))\n-\t;\n-      else if (TREE_CODE (cond_rhs) == SSA_NAME\n-\t       && is_gimple_constant (cond_lhs))\n-\t{\n-\t  std::swap (cond_lhs, cond_rhs);\n-\t  if ((code = get_cmp_code (code, true, false)) == ERROR_MARK)\n-\t    continue;\n-\t}\n-      /* Check if we can take advantage of \"flag_var comp flag_var\" predicate\n-\t with value range info.  Note only first of such case is handled.  */\n-      else if (vrinfo_code == ERROR_MARK\n-\t       && TREE_CODE (cond_lhs) == SSA_NAME\n-\t       && TREE_CODE (cond_rhs) == SSA_NAME)\n-\t{\n-\t  gimple* lhs_def = SSA_NAME_DEF_STMT (cond_lhs);\n-\t  if (!lhs_def || gimple_code (lhs_def) != GIMPLE_PHI\n-\t      || gimple_bb (lhs_def) != gimple_bb (phi))\n-\t    {\n-\t      std::swap (cond_lhs, cond_rhs);\n-\t      if ((code = get_cmp_code (code, true, false)) == ERROR_MARK)\n-\t\tcontinue;\n-\t    }\n-\n-\t  /* Check value range info of rhs, do following transforms:\n-\t       flag_var < [min, max]  ->  flag_var < max\n-\t       flag_var > [min, max]  ->  flag_var > min\n-\n-\t     We can also transform LE_EXPR/GE_EXPR to LT_EXPR/GT_EXPR:\n-\t       flag_var <= [min, max] ->  flag_var < [min, max+1]\n-\t       flag_var >= [min, max] ->  flag_var > [min-1, max]\n-\t     if no overflow/wrap.  */\n-\t  tree type = TREE_TYPE (cond_lhs);\n-\t  value_range r;\n-\t  if (!INTEGRAL_TYPE_P (type)\n-\t      || !get_range_query (cfun)->range_of_expr (r, cond_rhs)\n-\t      || r.kind () != VR_RANGE)\n-\t    continue;\n-\t  wide_int min = r.lower_bound ();\n-\t  wide_int max = r.upper_bound ();\n-\t  if (code == LE_EXPR\n-\t      && max != wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type)))\n-\t    {\n-\t      code = LT_EXPR;\n-\t      max = max + 1;\n-\t    }\n-\t  if (code == GE_EXPR\n-\t      && min != wi::min_value (TYPE_PRECISION (type), TYPE_SIGN (type)))\n-\t    {\n-\t      code = GT_EXPR;\n-\t      min = min - 1;\n-\t    }\n-\t  if (code == LT_EXPR)\n-\t    cond_rhs = wide_int_to_tree (type, max);\n-\t  else if (code == GT_EXPR)\n-\t    cond_rhs = wide_int_to_tree (type, min);\n-\t  else\n-\t    continue;\n-\n-\t  use_vrinfo_p = true;\n-\t}\n-      else\n-\tcontinue;\n-\n-      if ((*flag_def = SSA_NAME_DEF_STMT (cond_lhs)) == NULL)\n-\tcontinue;\n-\n-      if (gimple_code (*flag_def) != GIMPLE_PHI\n-\t  || gimple_bb (*flag_def) != gimple_bb (phi)\n-\t  || !find_matching_predicate_in_rest_chains (the_pred, preds))\n-\tcontinue;\n-\n-      /* Return if any \"flag_var comp const\" predicate is found.  */\n-      if (!use_vrinfo_p)\n-\t{\n-\t  *boundary_cst = cond_rhs;\n-\t  return code;\n-\t}\n-      /* Record if any \"flag_var comp flag_var[vinfo]\" predicate is found.  */\n-      else if (vrinfo_code == ERROR_MARK)\n-\t{\n-\t  vrinfo_code = code;\n-\t  vrinfo_def = *flag_def;\n-\t  vrinfo_cst = cond_rhs;\n-\t}\n-    }\n-  /* Return the \"flag_var cmp flag_var[vinfo]\" predicate we found.  */\n-  if (vrinfo_code != ERROR_MARK)\n-    {\n-      *flag_def = vrinfo_def;\n-      *boundary_cst = vrinfo_cst;\n-    }\n-  return vrinfo_code;\n-}\n-\n-/* A helper function that determines if the predicate set\n-   of the use is not overlapping with that of the uninit paths.\n-   The most common senario of guarded use is in Example 1:\n-     Example 1:\n-\t   if (some_cond)\n-\t   {\n-\t      x = ...;\n-\t      flag = true;\n-\t   }\n-\n-\t    ... some code ...\n-\n-\t   if (flag)\n-\t      use (x);\n-\n-     The real world examples are usually more complicated, but similar\n-     and usually result from inlining:\n-\n-\t bool init_func (int * x)\n-\t {\n-\t     if (some_cond)\n-\t\treturn false;\n-\t     *x  =  ..\n-\t     return true;\n-\t }\n-\n-\t void foo (..)\n-\t {\n-\t     int x;\n-\n-\t     if (!init_func (&x))\n-\t\treturn;\n-\n-\t     .. some_code ...\n-\t     use (x);\n-\t }\n-\n-     Another possible use scenario is in the following trivial example:\n-\n-     Example 2:\n-\t  if (n > 0)\n-\t     x = 1;\n-\t  ...\n-\t  if (n > 0)\n-\t    {\n-\t      if (m < 2)\n-\t\t .. = x;\n-\t    }\n-\n-     Predicate analysis needs to compute the composite predicate:\n-\n-       1) 'x' use predicate: (n > 0) .AND. (m < 2)\n-       2) 'x' default value  (non-def) predicate: .NOT. (n > 0)\n-       (the predicate chain for phi operand defs can be computed\n-       starting from a bb that is control equivalent to the phi's\n-       bb and is dominating the operand def.)\n-\n-       and check overlapping:\n-\t  (n > 0) .AND. (m < 2) .AND. (.NOT. (n > 0))\n-\t<==> false\n-\n-     This implementation provides framework that can handle\n-     scenarios.  (Note that many simple cases are handled properly\n-     without the predicate analysis -- this is due to jump threading\n-     transformation which eliminates the merge point thus makes\n-     path sensitive analysis unnecessary.)\n-\n-     PHI is the phi node whose incoming (undefined) paths need to be\n-     pruned, and UNINIT_OPNDS is the bitmap holding uninit operand\n-     positions.  VISITED_PHIS is the pointer set of phi stmts being\n-     checked.  */\n-\n-static bool\n-use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n-\t\t\t\t\t   gphi *phi, unsigned uninit_opnds,\n-\t\t\t\t\t   hash_set<gphi *> *visited_phis)\n-{\n-  gimple *flag_def = 0;\n-  tree boundary_cst = 0;\n-  enum tree_code cmp_code;\n-  bitmap visited_flag_phis = NULL;\n-  bool all_pruned = false;\n-\n-  /* Find within the common prefix of multiple predicate chains\n-     a predicate that is a comparison of a flag variable against\n-     a constant.  */\n-  cmp_code = find_var_cmp_const (preds, phi, &flag_def, &boundary_cst);\n-  if (cmp_code == ERROR_MARK)\n-    return false;\n-\n-  /* Now check all the uninit incoming edge has a constant flag value\n-     that is in conflict with the use guard/predicate.  */\n-  all_pruned = prune_uninit_phi_opnds\n-    (phi, uninit_opnds, as_a<gphi *> (flag_def), boundary_cst, cmp_code,\n-     visited_phis, &visited_flag_phis);\n-\n-  if (visited_flag_phis)\n-    BITMAP_FREE (visited_flag_phis);\n-\n-  return all_pruned;\n-}\n-\n-/* The helper function returns true if two predicates X1 and X2\n-   are equivalent.  It assumes the expressions have already\n-   properly re-associated.  */\n-\n-static inline bool\n-pred_equal_p (pred_info x1, pred_info x2)\n-{\n-  enum tree_code c1, c2;\n-  if (!operand_equal_p (x1.pred_lhs, x2.pred_lhs, 0)\n-      || !operand_equal_p (x1.pred_rhs, x2.pred_rhs, 0))\n-    return false;\n-\n-  c1 = x1.cond_code;\n-  if (x1.invert != x2.invert\n-      && TREE_CODE_CLASS (x2.cond_code) == tcc_comparison)\n-    c2 = invert_tree_comparison (x2.cond_code, false);\n-  else\n-    c2 = x2.cond_code;\n-\n-  return c1 == c2;\n-}\n-\n-/* Returns true if the predication is testing !=.  */\n-\n-static inline bool\n-is_neq_relop_p (pred_info pred)\n-{\n-\n-  return ((pred.cond_code == NE_EXPR && !pred.invert)\n-\t  || (pred.cond_code == EQ_EXPR && pred.invert));\n-}\n-\n-/* Returns true if pred is of the form X != 0.  */\n-\n-static inline bool\n-is_neq_zero_form_p (pred_info pred)\n-{\n-  if (!is_neq_relop_p (pred) || !integer_zerop (pred.pred_rhs)\n-      || TREE_CODE (pred.pred_lhs) != SSA_NAME)\n-    return false;\n-  return true;\n-}\n-\n-/* The helper function returns true if two predicates X1\n-   is equivalent to X2 != 0.  */\n-\n-static inline bool\n-pred_expr_equal_p (pred_info x1, tree x2)\n-{\n-  if (!is_neq_zero_form_p (x1))\n-    return false;\n-\n-  return operand_equal_p (x1.pred_lhs, x2, 0);\n-}\n-\n-/* Returns true of the domain of single predicate expression\n-   EXPR1 is a subset of that of EXPR2.  Returns false if it\n-   cannot be proved.  */\n-\n-static bool\n-is_pred_expr_subset_of (pred_info expr1, pred_info expr2)\n-{\n-  enum tree_code code1, code2;\n-\n-  if (pred_equal_p (expr1, expr2))\n-    return true;\n-\n-  if ((TREE_CODE (expr1.pred_rhs) != INTEGER_CST)\n-      || (TREE_CODE (expr2.pred_rhs) != INTEGER_CST))\n-    return false;\n-\n-  if (!operand_equal_p (expr1.pred_lhs, expr2.pred_lhs, 0))\n-    return false;\n-\n-  code1 = expr1.cond_code;\n-  if (expr1.invert)\n-    code1 = invert_tree_comparison (code1, false);\n-  code2 = expr2.cond_code;\n-  if (expr2.invert)\n-    code2 = invert_tree_comparison (code2, false);\n-\n-  if (code2 == NE_EXPR && code1 == NE_EXPR)\n-    return false;\n-\n-  if (code2 == NE_EXPR)\n-    return !value_sat_pred_p (expr2.pred_rhs, expr1.pred_rhs, code1);\n-\n-  if (code1 == EQ_EXPR)\n-    return value_sat_pred_p (expr1.pred_rhs, expr2.pred_rhs, code2);\n-\n-  if (code1 == code2)\n-    return value_sat_pred_p (expr1.pred_rhs, expr2.pred_rhs, code2,\n-\t\t\t     code1 == BIT_AND_EXPR);\n-\n-  return false;\n-}\n-\n-/* Returns true if the domain of PRED1 is a subset\n-   of that of PRED2.  Returns false if it cannot be proved so.  */\n-\n-static bool\n-is_pred_chain_subset_of (pred_chain pred1, pred_chain pred2)\n-{\n-  size_t np1, np2, i1, i2;\n-\n-  np1 = pred1.length ();\n-  np2 = pred2.length ();\n-\n-  for (i2 = 0; i2 < np2; i2++)\n-    {\n-      bool found = false;\n-      pred_info info2 = pred2[i2];\n-      for (i1 = 0; i1 < np1; i1++)\n-\t{\n-\t  pred_info info1 = pred1[i1];\n-\t  if (is_pred_expr_subset_of (info1, info2))\n-\t    {\n-\t      found = true;\n-\t      break;\n-\t    }\n-\t}\n-      if (!found)\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n-/* Returns true if the domain defined by\n-   one pred chain ONE_PRED is a subset of the domain\n-   of *PREDS.  It returns false if ONE_PRED's domain is\n-   not a subset of any of the sub-domains of PREDS\n-   (corresponding to each individual chains in it), even\n-   though it may be still be a subset of whole domain\n-   of PREDS which is the union (ORed) of all its subdomains.\n-   In other words, the result is conservative.  */\n-\n-static bool\n-is_included_in (pred_chain one_pred, pred_chain_union preds)\n-{\n-  size_t i;\n-  size_t n = preds.length ();\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      if (is_pred_chain_subset_of (one_pred, preds[i]))\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Compares two predicate sets PREDS1 and PREDS2 and returns\n-   true if the domain defined by PREDS1 is a superset\n-   of PREDS2's domain.  N1 and N2 are array sizes of PREDS1 and\n-   PREDS2 respectively.  The implementation chooses not to build\n-   generic trees (and relying on the folding capability of the\n-   compiler), but instead performs brute force comparison of\n-   individual predicate chains (won't be a compile time problem\n-   as the chains are pretty short).  When the function returns\n-   false, it does not necessarily mean *PREDS1 is not a superset\n-   of *PREDS2, but mean it may not be so since the analysis cannot\n-   prove it.  In such cases, false warnings may still be\n-   emitted.  */\n-\n-static bool\n-is_superset_of (pred_chain_union preds1, pred_chain_union preds2)\n-{\n-  size_t i, n2;\n-  pred_chain one_pred_chain = vNULL;\n-\n-  n2 = preds2.length ();\n-\n-  for (i = 0; i < n2; i++)\n-    {\n-      one_pred_chain = preds2[i];\n-      if (!is_included_in (one_pred_chain, preds1))\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n-/* Returns true if X1 is the negate of X2.  */\n-\n-static inline bool\n-pred_neg_p (pred_info x1, pred_info x2)\n-{\n-  enum tree_code c1, c2;\n-  if (!operand_equal_p (x1.pred_lhs, x2.pred_lhs, 0)\n-      || !operand_equal_p (x1.pred_rhs, x2.pred_rhs, 0))\n-    return false;\n-\n-  c1 = x1.cond_code;\n-  if (x1.invert == x2.invert)\n-    c2 = invert_tree_comparison (x2.cond_code, false);\n-  else\n-    c2 = x2.cond_code;\n-\n-  return c1 == c2;\n-}\n-\n-/* 1) ((x IOR y) != 0) AND (x != 0) is equivalent to (x != 0);\n-   2) (X AND Y) OR (!X AND Y) is equivalent to Y;\n-   3) X OR (!X AND Y) is equivalent to (X OR Y);\n-   4) ((x IAND y) != 0) || (x != 0 AND y != 0)) is equivalent to\n-      (x != 0 AND y != 0)\n-   5) (X AND Y) OR (!X AND Z) OR (!Y AND Z) is equivalent to\n-      (X AND Y) OR Z\n-\n-   PREDS is the predicate chains, and N is the number of chains.  */\n-\n-/* Helper function to implement rule 1 above.  ONE_CHAIN is\n-   the AND predication to be simplified.  */\n-\n-static void\n-simplify_pred (pred_chain *one_chain)\n-{\n-  size_t i, j, n;\n-  bool simplified = false;\n-  pred_chain s_chain = vNULL;\n-\n-  n = one_chain->length ();\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      pred_info *a_pred = &(*one_chain)[i];\n-\n-      if (!a_pred->pred_lhs)\n-\tcontinue;\n-      if (!is_neq_zero_form_p (*a_pred))\n-\tcontinue;\n-\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (a_pred->pred_lhs);\n-      if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n-\tcontinue;\n-      if (gimple_assign_rhs_code (def_stmt) == BIT_IOR_EXPR)\n-\t{\n-\t  for (j = 0; j < n; j++)\n-\t    {\n-\t      pred_info *b_pred = &(*one_chain)[j];\n-\n-\t      if (!b_pred->pred_lhs)\n-\t\tcontinue;\n-\t      if (!is_neq_zero_form_p (*b_pred))\n-\t\tcontinue;\n-\n-\t      if (pred_expr_equal_p (*b_pred, gimple_assign_rhs1 (def_stmt))\n-\t\t  || pred_expr_equal_p (*b_pred, gimple_assign_rhs2 (def_stmt)))\n-\t\t{\n-\t\t  /* Mark a_pred for removal.  */\n-\t\t  a_pred->pred_lhs = NULL;\n-\t\t  a_pred->pred_rhs = NULL;\n-\t\t  simplified = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  if (!simplified)\n-    return;\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      pred_info *a_pred = &(*one_chain)[i];\n-      if (!a_pred->pred_lhs)\n-\tcontinue;\n-      s_chain.safe_push (*a_pred);\n-    }\n-\n-  one_chain->release ();\n-  *one_chain = s_chain;\n-}\n-\n-/* The helper function implements the rule 2 for the\n-   OR predicate PREDS.\n-\n-   2) (X AND Y) OR (!X AND Y) is equivalent to Y.  */\n-\n-static bool\n-simplify_preds_2 (pred_chain_union *preds)\n-{\n-  size_t i, j, n;\n-  bool simplified = false;\n-  pred_chain_union s_preds = vNULL;\n-\n-  /* (X AND Y) OR (!X AND Y) is equivalent to Y.\n-     (X AND Y) OR (X AND !Y) is equivalent to X.  */\n-\n-  n = preds->length ();\n-  for (i = 0; i < n; i++)\n-    {\n-      pred_info x, y;\n-      pred_chain *a_chain = &(*preds)[i];\n-\n-      if (a_chain->length () != 2)\n-\tcontinue;\n-\n-      x = (*a_chain)[0];\n-      y = (*a_chain)[1];\n-\n-      for (j = 0; j < n; j++)\n-\t{\n-\t  pred_chain *b_chain;\n-\t  pred_info x2, y2;\n-\n-\t  if (j == i)\n-\t    continue;\n-\n-\t  b_chain = &(*preds)[j];\n-\t  if (b_chain->length () != 2)\n-\t    continue;\n-\n-\t  x2 = (*b_chain)[0];\n-\t  y2 = (*b_chain)[1];\n-\n-\t  if (pred_equal_p (x, x2) && pred_neg_p (y, y2))\n-\t    {\n-\t      /* Kill a_chain.  */\n-\t      a_chain->release ();\n-\t      b_chain->release ();\n-\t      b_chain->safe_push (x);\n-\t      simplified = true;\n-\t      break;\n-\t    }\n-\t  if (pred_neg_p (x, x2) && pred_equal_p (y, y2))\n-\t    {\n-\t      /* Kill a_chain.  */\n-\t      a_chain->release ();\n-\t      b_chain->release ();\n-\t      b_chain->safe_push (y);\n-\t      simplified = true;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  /* Now clean up the chain.  */\n-  if (simplified)\n-    {\n-      for (i = 0; i < n; i++)\n-\t{\n-\t  if ((*preds)[i].is_empty ())\n-\t    continue;\n-\t  s_preds.safe_push ((*preds)[i]);\n-\t}\n-      preds->release ();\n-      (*preds) = s_preds;\n-      s_preds = vNULL;\n-    }\n-\n-  return simplified;\n-}\n-\n-/* The helper function implements the rule 2 for the\n-   OR predicate PREDS.\n-\n-   3) x OR (!x AND y) is equivalent to x OR y.  */\n-\n-static bool\n-simplify_preds_3 (pred_chain_union *preds)\n-{\n-  size_t i, j, n;\n-  bool simplified = false;\n-\n-  /* Now iteratively simplify X OR (!X AND Z ..)\n-       into X OR (Z ...).  */\n-\n-  n = preds->length ();\n-  if (n < 2)\n-    return false;\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      pred_info x;\n-      pred_chain *a_chain = &(*preds)[i];\n-\n-      if (a_chain->length () != 1)\n-\tcontinue;\n-\n-      x = (*a_chain)[0];\n-\n-      for (j = 0; j < n; j++)\n-\t{\n-\t  pred_chain *b_chain;\n-\t  pred_info x2;\n-\t  size_t k;\n-\n-\t  if (j == i)\n-\t    continue;\n-\n-\t  b_chain = &(*preds)[j];\n-\t  if (b_chain->length () < 2)\n-\t    continue;\n-\n-\t  for (k = 0; k < b_chain->length (); k++)\n-\t    {\n-\t      x2 = (*b_chain)[k];\n-\t      if (pred_neg_p (x, x2))\n-\t\t{\n-\t\t  b_chain->unordered_remove (k);\n-\t\t  simplified = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  return simplified;\n-}\n-\n-/* The helper function implements the rule 4 for the\n-   OR predicate PREDS.\n-\n-   2) ((x AND y) != 0) OR (x != 0 AND y != 0) is equivalent to\n-       (x != 0 ANd y != 0).   */\n-\n-static bool\n-simplify_preds_4 (pred_chain_union *preds)\n-{\n-  size_t i, j, n;\n-  bool simplified = false;\n-  pred_chain_union s_preds = vNULL;\n-  gimple *def_stmt;\n-\n-  n = preds->length ();\n-  for (i = 0; i < n; i++)\n-    {\n-      pred_info z;\n-      pred_chain *a_chain = &(*preds)[i];\n-\n-      if (a_chain->length () != 1)\n-\tcontinue;\n-\n-      z = (*a_chain)[0];\n-\n-      if (!is_neq_zero_form_p (z))\n-\tcontinue;\n-\n-      def_stmt = SSA_NAME_DEF_STMT (z.pred_lhs);\n-      if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n-\tcontinue;\n-\n-      if (gimple_assign_rhs_code (def_stmt) != BIT_AND_EXPR)\n-\tcontinue;\n-\n-      for (j = 0; j < n; j++)\n-\t{\n-\t  pred_chain *b_chain;\n-\t  pred_info x2, y2;\n-\n-\t  if (j == i)\n-\t    continue;\n-\n-\t  b_chain = &(*preds)[j];\n-\t  if (b_chain->length () != 2)\n-\t    continue;\n-\n-\t  x2 = (*b_chain)[0];\n-\t  y2 = (*b_chain)[1];\n-\t  if (!is_neq_zero_form_p (x2) || !is_neq_zero_form_p (y2))\n-\t    continue;\n-\n-\t  if ((pred_expr_equal_p (x2, gimple_assign_rhs1 (def_stmt))\n-\t       && pred_expr_equal_p (y2, gimple_assign_rhs2 (def_stmt)))\n-\t      || (pred_expr_equal_p (x2, gimple_assign_rhs2 (def_stmt))\n-\t\t  && pred_expr_equal_p (y2, gimple_assign_rhs1 (def_stmt))))\n-\t    {\n-\t      /* Kill a_chain.  */\n-\t      a_chain->release ();\n-\t      simplified = true;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  /* Now clean up the chain.  */\n-  if (simplified)\n-    {\n-      for (i = 0; i < n; i++)\n-\t{\n-\t  if ((*preds)[i].is_empty ())\n-\t    continue;\n-\t  s_preds.safe_push ((*preds)[i]);\n-\t}\n-\n-      preds->release ();\n-      (*preds) = s_preds;\n-      s_preds = vNULL;\n-    }\n-\n-  return simplified;\n-}\n-\n-/* This function simplifies predicates in PREDS.  */\n-\n-static void\n-simplify_preds (pred_chain_union *preds, gimple *use_or_def, bool is_use)\n-{\n-  size_t i, n;\n-  bool changed = false;\n-\n-  if (dump_file && dump_flags & TDF_DETAILS)\n-    {\n-      fprintf (dump_file, \"[BEFORE SIMPLICATION -- \");\n-      dump_predicates (use_or_def, *preds, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n-    }\n-\n-  for (i = 0; i < preds->length (); i++)\n-    simplify_pred (&(*preds)[i]);\n-\n-  n = preds->length ();\n-  if (n < 2)\n-    return;\n-\n-  do\n-    {\n-      changed = false;\n-      if (simplify_preds_2 (preds))\n-\tchanged = true;\n-\n-      /* Now iteratively simplify X OR (!X AND Z ..)\n-       into X OR (Z ...).  */\n-      if (simplify_preds_3 (preds))\n-\tchanged = true;\n-\n-      if (simplify_preds_4 (preds))\n-\tchanged = true;\n-    }\n-  while (changed);\n-\n-  return;\n-}\n-\n-/* This is a helper function which attempts to normalize predicate chains\n-  by following UD chains.  It basically builds up a big tree of either IOR\n-  operations or AND operations, and convert the IOR tree into a\n-  pred_chain_union or BIT_AND tree into a pred_chain.\n-  Example:\n-\n-  _3 = _2 RELOP1 _1;\n-  _6 = _5 RELOP2 _4;\n-  _9 = _8 RELOP3 _7;\n-  _10 = _3 | _6;\n-  _12 = _9 | _0;\n-  _t = _10 | _12;\n-\n- then _t != 0 will be normalized into a pred_chain_union\n-\n-   (_2 RELOP1 _1) OR (_5 RELOP2 _4) OR (_8 RELOP3 _7) OR (_0 != 0)\n-\n- Similarly given,\n-\n-  _3 = _2 RELOP1 _1;\n-  _6 = _5 RELOP2 _4;\n-  _9 = _8 RELOP3 _7;\n-  _10 = _3 & _6;\n-  _12 = _9 & _0;\n-\n- then _t != 0 will be normalized into a pred_chain:\n-   (_2 RELOP1 _1) AND (_5 RELOP2 _4) AND (_8 RELOP3 _7) AND (_0 != 0)\n-\n-  */\n-\n-/* This is a helper function that stores a PRED into NORM_PREDS.  */\n-\n-inline static void\n-push_pred (pred_chain_union *norm_preds, pred_info pred)\n-{\n-  pred_chain pred_chain = vNULL;\n-  pred_chain.safe_push (pred);\n-  norm_preds->safe_push (pred_chain);\n-}\n-\n-/* A helper function that creates a predicate of the form\n-   OP != 0 and push it WORK_LIST.  */\n-\n-inline static void\n-push_to_worklist (tree op, vec<pred_info, va_heap, vl_ptr> *work_list,\n-\t\t  hash_set<tree> *mark_set)\n-{\n-  if (mark_set->contains (op))\n-    return;\n-  mark_set->add (op);\n-\n-  pred_info arg_pred;\n-  arg_pred.pred_lhs = op;\n-  arg_pred.pred_rhs = integer_zero_node;\n-  arg_pred.cond_code = NE_EXPR;\n-  arg_pred.invert = false;\n-  work_list->safe_push (arg_pred);\n-}\n-\n-/* A helper that generates a pred_info from a gimple assignment\n-   CMP_ASSIGN with comparison rhs.  */\n-\n-static pred_info\n-get_pred_info_from_cmp (gimple *cmp_assign)\n-{\n-  pred_info n_pred;\n-  n_pred.pred_lhs = gimple_assign_rhs1 (cmp_assign);\n-  n_pred.pred_rhs = gimple_assign_rhs2 (cmp_assign);\n-  n_pred.cond_code = gimple_assign_rhs_code (cmp_assign);\n-  n_pred.invert = false;\n-  return n_pred;\n-}\n-\n-/* Returns true if the PHI is a degenerated phi with\n-   all args with the same value (relop).  In that case, *PRED\n-   will be updated to that value.  */\n-\n-static bool\n-is_degenerated_phi (gimple *phi, pred_info *pred_p)\n-{\n-  int i, n;\n-  tree op0;\n-  gimple *def0;\n-  pred_info pred0;\n-\n-  n = gimple_phi_num_args (phi);\n-  op0 = gimple_phi_arg_def (phi, 0);\n-\n-  if (TREE_CODE (op0) != SSA_NAME)\n-    return false;\n-\n-  def0 = SSA_NAME_DEF_STMT (op0);\n-  if (gimple_code (def0) != GIMPLE_ASSIGN)\n-    return false;\n-  if (TREE_CODE_CLASS (gimple_assign_rhs_code (def0)) != tcc_comparison)\n-    return false;\n-  pred0 = get_pred_info_from_cmp (def0);\n-\n-  for (i = 1; i < n; ++i)\n-    {\n-      gimple *def;\n-      pred_info pred;\n-      tree op = gimple_phi_arg_def (phi, i);\n-\n-      if (TREE_CODE (op) != SSA_NAME)\n-\treturn false;\n-\n-      def = SSA_NAME_DEF_STMT (op);\n-      if (gimple_code (def) != GIMPLE_ASSIGN)\n-\treturn false;\n-      if (TREE_CODE_CLASS (gimple_assign_rhs_code (def)) != tcc_comparison)\n-\treturn false;\n-      pred = get_pred_info_from_cmp (def);\n-      if (!pred_equal_p (pred, pred0))\n-\treturn false;\n-    }\n-\n-  *pred_p = pred0;\n-  return true;\n-}\n-\n-/* Normalize one predicate PRED\n-   1) if PRED can no longer be normlized, put it into NORM_PREDS.\n-   2) otherwise if PRED is of the form x != 0, follow x's definition\n-      and put normalized predicates into WORK_LIST.  */\n-\n-static void\n-normalize_one_pred_1 (pred_chain_union *norm_preds,\n-\t\t      pred_chain *norm_chain,\n-\t\t      pred_info pred,\n-\t\t      enum tree_code and_or_code,\n-\t\t      vec<pred_info, va_heap, vl_ptr> *work_list,\n-\t\t      hash_set<tree> *mark_set)\n-{\n-  if (!is_neq_zero_form_p (pred))\n-    {\n-      if (and_or_code == BIT_IOR_EXPR)\n-\tpush_pred (norm_preds, pred);\n-      else\n-\tnorm_chain->safe_push (pred);\n-      return;\n-    }\n-\n-  gimple *def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n-\n-  if (gimple_code (def_stmt) == GIMPLE_PHI\n-      && is_degenerated_phi (def_stmt, &pred))\n-    work_list->safe_push (pred);\n-  else if (gimple_code (def_stmt) == GIMPLE_PHI && and_or_code == BIT_IOR_EXPR)\n-    {\n-      int i, n;\n-      n = gimple_phi_num_args (def_stmt);\n-\n-      /* If we see non zero constant, we should punt.  The predicate\n-       * should be one guarding the phi edge.  */\n-      for (i = 0; i < n; ++i)\n-\t{\n-\t  tree op = gimple_phi_arg_def (def_stmt, i);\n-\t  if (TREE_CODE (op) == INTEGER_CST && !integer_zerop (op))\n-\t    {\n-\t      push_pred (norm_preds, pred);\n-\t      return;\n-\t    }\n-\t}\n-\n-      for (i = 0; i < n; ++i)\n-\t{\n-\t  tree op = gimple_phi_arg_def (def_stmt, i);\n-\t  if (integer_zerop (op))\n-\t    continue;\n-\n-\t  push_to_worklist (op, work_list, mark_set);\n-\t}\n-    }\n-  else if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n-    {\n-      if (and_or_code == BIT_IOR_EXPR)\n-\tpush_pred (norm_preds, pred);\n-      else\n-\tnorm_chain->safe_push (pred);\n-    }\n-  else if (gimple_assign_rhs_code (def_stmt) == and_or_code)\n-    {\n-      /* Avoid splitting up bit manipulations like x & 3 or y | 1.  */\n-      if (is_gimple_min_invariant (gimple_assign_rhs2 (def_stmt)))\n-\t{\n-\t  /* But treat x & 3 as condition.  */\n-\t  if (and_or_code == BIT_AND_EXPR)\n-\t    {\n-\t      pred_info n_pred;\n-\t      n_pred.pred_lhs = gimple_assign_rhs1 (def_stmt);\n-\t      n_pred.pred_rhs = gimple_assign_rhs2 (def_stmt);\n-\t      n_pred.cond_code = and_or_code;\n-\t      n_pred.invert = false;\n-\t      norm_chain->safe_push (n_pred);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  push_to_worklist (gimple_assign_rhs1 (def_stmt), work_list, mark_set);\n-\t  push_to_worklist (gimple_assign_rhs2 (def_stmt), work_list, mark_set);\n-\t}\n-    }\n-  else if (TREE_CODE_CLASS (gimple_assign_rhs_code (def_stmt))\n-\t   == tcc_comparison)\n-    {\n-      pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n-      if (and_or_code == BIT_IOR_EXPR)\n-\tpush_pred (norm_preds, n_pred);\n-      else\n-\tnorm_chain->safe_push (n_pred);\n-    }\n-  else\n-    {\n-      if (and_or_code == BIT_IOR_EXPR)\n-\tpush_pred (norm_preds, pred);\n-      else\n-\tnorm_chain->safe_push (pred);\n-    }\n-}\n-\n-/* Normalize PRED and store the normalized predicates into NORM_PREDS.  */\n-\n-static void\n-normalize_one_pred (pred_chain_union *norm_preds, pred_info pred)\n-{\n-  vec<pred_info, va_heap, vl_ptr> work_list = vNULL;\n-  enum tree_code and_or_code = ERROR_MARK;\n-  pred_chain norm_chain = vNULL;\n-\n-  if (!is_neq_zero_form_p (pred))\n-    {\n-      push_pred (norm_preds, pred);\n-      return;\n-    }\n-\n-  gimple *def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n-  if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n-    and_or_code = gimple_assign_rhs_code (def_stmt);\n-  if (and_or_code != BIT_IOR_EXPR && and_or_code != BIT_AND_EXPR)\n-    {\n-      if (TREE_CODE_CLASS (and_or_code) == tcc_comparison)\n-\t{\n-\t  pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n-\t  push_pred (norm_preds, n_pred);\n-\t}\n-      else\n-\tpush_pred (norm_preds, pred);\n-      return;\n-    }\n-\n-  work_list.safe_push (pred);\n-  hash_set<tree> mark_set;\n-\n-  while (!work_list.is_empty ())\n-    {\n-      pred_info a_pred = work_list.pop ();\n-      normalize_one_pred_1 (norm_preds, &norm_chain, a_pred, and_or_code,\n-\t\t\t    &work_list, &mark_set);\n-    }\n-  if (and_or_code == BIT_AND_EXPR)\n-    norm_preds->safe_push (norm_chain);\n-\n-  work_list.release ();\n-}\n-\n-static void\n-normalize_one_pred_chain (pred_chain_union *norm_preds, pred_chain one_chain)\n-{\n-  vec<pred_info, va_heap, vl_ptr> work_list = vNULL;\n-  hash_set<tree> mark_set;\n-  pred_chain norm_chain = vNULL;\n-  size_t i;\n-\n-  for (i = 0; i < one_chain.length (); i++)\n-    {\n-      work_list.safe_push (one_chain[i]);\n-      mark_set.add (one_chain[i].pred_lhs);\n-    }\n-\n-  while (!work_list.is_empty ())\n-    {\n-      pred_info a_pred = work_list.pop ();\n-      normalize_one_pred_1 (0, &norm_chain, a_pred, BIT_AND_EXPR, &work_list,\n-\t\t\t    &mark_set);\n-    }\n-\n-  norm_preds->safe_push (norm_chain);\n-  work_list.release ();\n-}\n-\n-/* Normalize predicate chains PREDS and returns the normalized one.  */\n-\n-static pred_chain_union\n-normalize_preds (pred_chain_union preds, gimple *use_or_def, bool is_use)\n-{\n-  pred_chain_union norm_preds = vNULL;\n-  size_t n = preds.length ();\n-  size_t i;\n-\n-  if (dump_file && dump_flags & TDF_DETAILS)\n-    {\n-      fprintf (dump_file, \"[BEFORE NORMALIZATION --\");\n-      dump_predicates (use_or_def, preds, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n-    }\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      if (preds[i].length () != 1)\n-\tnormalize_one_pred_chain (&norm_preds, preds[i]);\n-      else\n-\t{\n-\t  normalize_one_pred (&norm_preds, preds[i][0]);\n-\t  preds[i].release ();\n-\t}\n-    }\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"[AFTER NORMALIZATION -- \");\n-      dump_predicates (use_or_def, norm_preds,\n-\t\t       is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n-    }\n-\n-  destroy_predicate_vecs (&preds);\n-  return norm_preds;\n-}\n-\n-/* Return TRUE if PREDICATE can be invalidated by any individual\n-   predicate in USE_GUARD.  */\n-\n-static bool\n-can_one_predicate_be_invalidated_p (pred_info predicate,\n-\t\t\t\t    pred_chain use_guard)\n-{\n-  if (dump_file && dump_flags & TDF_DETAILS)\n-    {\n-      fprintf (dump_file, \"Testing if this predicate: \");\n-      dump_pred_info (predicate);\n-      fprintf (dump_file, \"\\n...can be invalidated by a USE guard of: \");\n-      dump_pred_chain (use_guard);\n-    }\n-  for (size_t i = 0; i < use_guard.length (); ++i)\n-    {\n-      /* NOTE: This is a very simple check, and only understands an\n-\t exact opposite.  So, [i == 0] is currently only invalidated\n-\t by [.NOT. i == 0] or [i != 0].  Ideally we should also\n-\t invalidate with say [i > 5] or [i == 8].  There is certainly\n-\t room for improvement here.  */\n-      if (pred_neg_p (predicate, use_guard[i]))\n-\t{\n-\t  if (dump_file && dump_flags & TDF_DETAILS)\n-\t    {\n-\t      fprintf (dump_file, \"  Predicate was invalidated by: \");\n-\t      dump_pred_info (use_guard[i]);\n-\t      fputc ('\\n', dump_file);\n-\t    }\n-\t  return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* Return TRUE if all predicates in UNINIT_PRED are invalidated by\n-   USE_GUARD being true.  */\n-\n-static bool\n-can_chain_union_be_invalidated_p (pred_chain_union uninit_pred,\n-\t\t\t\t  pred_chain use_guard)\n-{\n-  if (uninit_pred.is_empty ())\n-    return false;\n-  if (dump_file && dump_flags & TDF_DETAILS)\n-    dump_predicates (NULL, uninit_pred,\n-\t\t     \"Testing if anything here can be invalidated: \");\n-  for (size_t i = 0; i < uninit_pred.length (); ++i)\n-    {\n-      pred_chain c = uninit_pred[i];\n-      size_t j;\n-      for (j = 0; j < c.length (); ++j)\n-\tif (can_one_predicate_be_invalidated_p (c[j], use_guard))\n-\t  break;\n-\n-      /* If we were unable to invalidate any predicate in C, then there\n-\t is a viable path from entry to the PHI where the PHI takes\n-\t an uninitialized value and continues to a use of the PHI.  */\n-      if (j == c.length ())\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n-/* Return TRUE if none of the uninitialized operands in UNINT_OPNDS\n-   can actually happen if we arrived at a use for PHI.\n-\n-   PHI_USE_GUARDS are the guard conditions for the use of the PHI.  */\n-\n-static bool\n-uninit_uses_cannot_happen (gphi *phi, unsigned uninit_opnds,\n-\t\t\t   pred_chain_union phi_use_guards)\n-{\n-  unsigned phi_args = gimple_phi_num_args (phi);\n-  if (phi_args > max_phi_args)\n-    return false;\n-\n-  /* PHI_USE_GUARDS are OR'ed together.  If we have more than one\n-     possible guard, there's no way of knowing which guard was true.\n-     Since we need to be absolutely sure that the uninitialized\n-     operands will be invalidated, bail.  */\n-  if (phi_use_guards.length () != 1)\n-    return false;\n-\n-  /* Look for the control dependencies of all the uninitialized\n-     operands and build guard predicates describing them.  */\n-  pred_chain_union uninit_preds;\n-  bool ret = true;\n-  for (unsigned i = 0; i < phi_args; ++i)\n-    {\n-      if (!MASK_TEST_BIT (uninit_opnds, i))\n-\tcontinue;\n-\n-      edge e = gimple_phi_arg_edge (phi, i);\n-      vec<edge> dep_chains[MAX_NUM_CHAINS];\n-      auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n-      size_t num_chains = 0;\n-      int num_calls = 0;\n-\n-      /* Build the control dependency chain for uninit operand `i'...  */\n-      uninit_preds = vNULL;\n-      if (!compute_control_dep_chain (ENTRY_BLOCK_PTR_FOR_FN (cfun),\n-\t\t\t\t      e->src, dep_chains, &num_chains,\n-\t\t\t\t      &cur_chain, &num_calls))\n-\t{\n-\t  ret = false;\n-\t  break;\n-\t}\n-      /* ...and convert it into a set of predicates.  */\n-      bool has_valid_preds\n-\t= convert_control_dep_chain_into_preds (dep_chains, num_chains,\n-\t\t\t\t\t\t&uninit_preds);\n-      for (size_t j = 0; j < num_chains; ++j)\n-\tdep_chains[j].release ();\n-      if (!has_valid_preds)\n-\t{\n-\t  ret = false;\n-\t  break;\n-\t}\n-      simplify_preds (&uninit_preds, NULL, false);\n-      uninit_preds = normalize_preds (uninit_preds, NULL, false);\n-\n-      /* Can the guard for this uninitialized operand be invalidated\n-\t by the PHI use?  */\n-      if (!can_chain_union_be_invalidated_p (uninit_preds, phi_use_guards[0]))\n-\t{\n-\t  ret = false;\n-\t  break;\n-\t}\n-    }\n-  destroy_predicate_vecs (&uninit_preds);\n-  return ret;\n-}\n-\n-/* Computes the predicates that guard the use and checks\n-   if the incoming paths that have empty (or possibly\n-   empty) definition can be pruned/filtered.  The function returns\n-   true if it can be determined that the use of PHI's def in\n-   USE_STMT is guarded with a predicate set not overlapping with\n-   predicate sets of all runtime paths that do not have a definition.\n-\n-   Returns false if it is not or it cannot be determined.  USE_BB is\n-   the bb of the use (for phi operand use, the bb is not the bb of\n-   the phi stmt, but the src bb of the operand edge).\n-\n-   UNINIT_OPNDS is a bit vector.  If an operand of PHI is uninitialized, the\n-   corresponding bit in the vector is 1.  VISITED_PHIS is a pointer\n-   set of phis being visited.\n-\n-   *DEF_PREDS contains the (memoized) defining predicate chains of PHI.\n-   If *DEF_PREDS is the empty vector, the defining predicate chains of\n-   PHI will be computed and stored into *DEF_PREDS as needed.\n-\n-   VISITED_PHIS is a pointer set of phis being visited.  */\n-\n-static bool\n-is_use_properly_guarded (gimple *use_stmt,\n-\t\t\t basic_block use_bb,\n-\t\t\t gphi *phi,\n-\t\t\t unsigned uninit_opnds,\n-\t\t\t pred_chain_union *def_preds,\n-\t\t\t hash_set<gphi *> *visited_phis)\n-{\n-  basic_block phi_bb;\n-  pred_chain_union preds = vNULL;\n-  bool has_valid_preds = false;\n-  bool is_properly_guarded = false;\n-\n-  if (visited_phis->add (phi))\n-    return false;\n-\n-  phi_bb = gimple_bb (phi);\n-\n-  if (is_non_loop_exit_postdominating (use_bb, phi_bb))\n-    return false;\n-\n-  has_valid_preds = find_predicates (&preds, phi_bb, use_bb);\n-\n-  if (!has_valid_preds)\n-    {\n-      destroy_predicate_vecs (&preds);\n-      return false;\n-    }\n-\n-  /* Try to prune the dead incoming phi edges.  */\n-  is_properly_guarded\n-    = use_pred_not_overlap_with_undef_path_pred (preds, phi, uninit_opnds,\n-\t\t\t\t\t\t visited_phis);\n-\n-  /* We might be able to prove that if the control dependencies\n-     for UNINIT_OPNDS are true, that the control dependencies for\n-     USE_STMT can never be true.  */\n-  if (!is_properly_guarded)\n-    is_properly_guarded |= uninit_uses_cannot_happen (phi, uninit_opnds,\n-\t\t\t\t\t\t      preds);\n-\n-  if (is_properly_guarded)\n-    {\n-      destroy_predicate_vecs (&preds);\n-      return true;\n-    }\n-\n-  if (def_preds->is_empty ())\n-    {\n-      has_valid_preds = find_def_preds (def_preds, phi);\n-\n-      if (!has_valid_preds)\n-\t{\n-\t  destroy_predicate_vecs (&preds);\n-\t  return false;\n-\t}\n-\n-      simplify_preds (def_preds, phi, false);\n-      *def_preds = normalize_preds (*def_preds, phi, false);\n-    }\n-\n-  simplify_preds (&preds, use_stmt, true);\n-  preds = normalize_preds (preds, use_stmt, true);\n-\n-  is_properly_guarded = is_superset_of (*def_preds, preds);\n-\n-  destroy_predicate_vecs (&preds);\n-  return is_properly_guarded;\n-}\n-\n-/* Searches through all uses of a potentially\n-   uninitialized variable defined by PHI and returns a use\n-   statement if the use is not properly guarded.  It returns\n-   NULL if all uses are guarded.  UNINIT_OPNDS is a bitvector\n-   holding the position(s) of uninit PHI operands.  WORKLIST\n-   is the vector of candidate phis that may be updated by this\n-   function.  ADDED_TO_WORKLIST is the pointer set tracking\n-   if the new phi is already in the worklist.  */\n-\n-static gimple *\n-find_uninit_use (gphi *phi, unsigned uninit_opnds,\n-\t\t vec<gphi *> *worklist,\n-\t\t hash_set<gphi *> *added_to_worklist)\n-{\n-  tree phi_result;\n-  use_operand_p use_p;\n-  gimple *use_stmt;\n-  imm_use_iterator iter;\n-  pred_chain_union def_preds = vNULL;\n-  gimple *ret = NULL;\n-\n-  phi_result = gimple_phi_result (phi);\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, iter, phi_result)\n-    {\n-      basic_block use_bb;\n-\n-      use_stmt = USE_STMT (use_p);\n-      if (is_gimple_debug (use_stmt))\n-\tcontinue;\n-\n-      if (gphi *use_phi = dyn_cast<gphi *> (use_stmt))\n-\tuse_bb = gimple_phi_arg_edge (use_phi,\n-\t\t\t\t      PHI_ARG_INDEX_FROM_USE (use_p))->src;\n-      else\n-\tuse_bb = gimple_bb (use_stmt);\n-\n-      hash_set<gphi *> visited_phis;\n-      if (is_use_properly_guarded (use_stmt, use_bb, phi, uninit_opnds,\n-\t\t\t\t   &def_preds, &visited_phis))\n-\tcontinue;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"[CHECK]: Found unguarded use: \");\n-\t  print_gimple_stmt (dump_file, use_stmt, 0);\n-\t}\n-      /* Found one real use, return.  */\n-      if (gimple_code (use_stmt) != GIMPLE_PHI)\n-\t{\n-\t  ret = use_stmt;\n-\t  break;\n-\t}\n-\n-      /* Found a phi use that is not guarded,\n-\t add the phi to the worklist.  */\n-      if (!added_to_worklist->add (as_a<gphi *> (use_stmt)))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"[WORKLIST]: Update worklist with phi: \");\n-\t      print_gimple_stmt (dump_file, use_stmt, 0);\n-\t    }\n-\n-\t  worklist->safe_push (as_a<gphi *> (use_stmt));\n-\t  possibly_undefined_names->add (phi_result);\n-\t}\n-    }\n-\n-  destroy_predicate_vecs (&def_preds);\n-  return ret;\n-}\n-\n-/* Look for inputs to PHI that are SSA_NAMEs that have empty definitions\n-   and gives warning if there exists a runtime path from the entry to a\n-   use of the PHI def that does not contain a definition.  In other words,\n-   the warning is on the real use.  The more dead paths that can be pruned\n-   by the compiler, the fewer false positives the warning is.  WORKLIST\n-   is a vector of candidate phis to be examined.  ADDED_TO_WORKLIST is\n-   a pointer set tracking if the new phi is added to the worklist or not.  */\n-\n-static void\n-warn_uninitialized_phi (gphi *phi, vec<gphi *> *worklist,\n-\t\t\thash_set<gphi *> *added_to_worklist)\n-{\n-  /* Don't look at virtual operands.  */\n-  if (virtual_operand_p (gimple_phi_result (phi)))\n-    return;\n-\n-  unsigned uninit_opnds = compute_uninit_opnds_pos (phi);\n-  if (MASK_EMPTY (uninit_opnds))\n-    return;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"[CHECK]: examining phi: \");\n-      print_gimple_stmt (dump_file, phi, 0);\n-    }\n-\n-  /* Now check if we have any use of the value without proper guard.  */\n-  gimple *uninit_use_stmt = find_uninit_use (phi, uninit_opnds,\n-\t\t\t\t\t     worklist, added_to_worklist);\n-\n-  /* All uses are properly guarded.  */\n-  if (!uninit_use_stmt)\n-    return;\n-\n-  int phiarg_index = MASK_FIRST_SET_BIT (uninit_opnds);\n-  tree uninit_op = gimple_phi_arg_def (phi, phiarg_index);\n-  if (SSA_NAME_VAR (uninit_op) == NULL_TREE)\n-    return;\n-\n-  location_t phi_arg_loc = gimple_phi_arg_location (phi, phiarg_index);\n-  warn_uninit (OPT_Wmaybe_uninitialized, uninit_op,\n-\t       SSA_NAME_VAR (uninit_op),\n-\t       \"%qD may be used uninitialized in this function\",\n-\t       uninit_use_stmt, phi_arg_loc);\n-}\n-\n-static bool\n-gate_warn_uninitialized (void)\n-{\n-  return warn_uninitialized || warn_maybe_uninitialized;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_late_warn_uninitialized =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"uninit\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_NONE, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_late_warn_uninitialized : public gimple_opt_pass\n-{\n-public:\n-  pass_late_warn_uninitialized (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_late_warn_uninitialized, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass *clone () { return new pass_late_warn_uninitialized (m_ctxt); }\n-  virtual bool gate (function *) { return gate_warn_uninitialized (); }\n-  virtual unsigned int execute (function *);\n-\n-}; // class pass_late_warn_uninitialized\n-\n-unsigned int\n-pass_late_warn_uninitialized::execute (function *fun)\n-{\n-  basic_block bb;\n-  gphi_iterator gsi;\n-  vec<gphi *> worklist = vNULL;\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  calculate_dominance_info (CDI_POST_DOMINATORS);\n-  /* Re-do the plain uninitialized variable check, as optimization may have\n-     straightened control flow.  Do this first so that we don't accidentally\n-     get a \"may be\" warning when we'd have seen an \"is\" warning later.  */\n-  warn_uninitialized_vars (/*warn_maybe_uninitialized=*/1);\n-\n-  timevar_push (TV_TREE_UNINIT);\n-\n-  possibly_undefined_names = new hash_set<tree>;\n-  hash_set<gphi *> added_to_worklist;\n-\n-  /* Initialize worklist  */\n-  FOR_EACH_BB_FN (bb, fun)\n-    for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-      {\n-\tgphi *phi = gsi.phi ();\n-\tsize_t n, i;\n-\n-\tn = gimple_phi_num_args (phi);\n+  /* Initialize worklist  */\n+  FOR_EACH_BB_FN (bb, fun)\n+    for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgphi *phi = gsi.phi ();\n \n \t/* Don't look at virtual operands.  */\n \tif (virtual_operand_p (gimple_phi_result (phi)))\n \t  continue;\n \n-\tfor (i = 0; i < n; ++i)\n+\tunsigned n = gimple_phi_num_args (phi);\n+\tfor (unsigned i = 0; i < n; ++i)\n \t  {\n \t    tree op = gimple_phi_arg_def (phi, i);\n \t    if (TREE_CODE (op) == SSA_NAME && uninit_undefined_value_p (op))\n@@ -3333,7 +1259,8 @@ pass_late_warn_uninitialized::execute (function *fun)\n \t\tadded_to_worklist.add (phi);\n \t\tif (dump_file && (dump_flags & TDF_DETAILS))\n \t\t  {\n-\t\t    fprintf (dump_file, \"[WORKLIST]: add to initial list: \");\n+\t\t    fprintf (dump_file, \"[WORKLIST]: add to initial list \"\n+\t\t\t     \"for operand %u of: \", i);\n \t\t    print_gimple_stmt (dump_file, phi, 0);\n \t\t  }\n \t\tbreak;\n@@ -3353,6 +1280,12 @@ pass_late_warn_uninitialized::execute (function *fun)\n   possibly_undefined_names = NULL;\n   free_dominance_info (CDI_POST_DOMINATORS);\n   timevar_pop (TV_TREE_UNINIT);\n+}\n+\n+unsigned int\n+pass_late_warn_uninitialized::execute (function *fun)\n+{\n+  execute_late_warn_uninitialized (fun);\n   return 0;\n }\n "}]}