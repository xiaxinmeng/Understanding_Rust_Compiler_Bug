{"sha": "749ced524c4a4bcb7e8374854cc380e33e69a1d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ5Y2VkNTI0YzRhNGJjYjdlODM3NDg1NGNjMzgwZTMzZTY5YTFkOA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-09-24T00:27:33Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-09-24T00:27:33Z"}, "message": "top level:\n\n\t* errors.h (warning, error, fatal, internal_error): Don't mark\n\twith ATTRIBUTE_PRINTF_n.\n\t* toplev.h (internal_error, fatal_io_error, warning, error,\n\tpedwarn, pedwarn_with_file_and_line, warning_with_file_and_line,\n\terror_with_file_and_line, sorry, error_for_asm, warning_for_asm):\n\tLikewise.\ncp:\n\t* Make-lang.in (CXX_OBJS): Take out cp/errfn.o.\n\t(cp/errfn.o): Delete rule.\n\t(cp/error.o): Depend on flags.h.\n\t* errfn.c: Delete file.\n\t* cp-tree.h: Declare warn_deprecated.  Remove definitions of\n\tTFF_NAMESPACE_SCOPE, TFF_CLASS_SCOPE, TFF_CHASE_NAMESPACE_ALIAS,\n\tand TFF_TEMPLATE_DEFAULT_ARGUMENTS. #define cp_error, cp_warning,\n\tcp_pedwarn, and cp_compiler_error to error, warning, pedwarn, and\n\tinternal_error respectively.  Make cp_deprecated into a macro.\n\tDon't define cp_printer typedef or declare cp_printers.\n\t* error.c: Include flags.h.\n\tDelete: struct tree_formatting_info, print_function_argument_list,\n\tprint_declaration, print_expression, print_function_declaration,\n\tprint_function_parameter, print_type_id, print_cv_qualifier_seq,\n\tprint_type_specifier_seq, print_simple_type_specifier,\n\tprint_elaborated_type_specifier, print_rest_of_abstract_declarator,\n\tprint_parameter_declaration_clause, print_exception_specification,\n\tprint_nested_name_specifier, and definition of cp_printers.\n\t(locate_error): New function.\n\t(cp_error_at, cp_warning_at, cp_pedwarn_at): Moved here and\n\trewritten in terms of locate_error and diagnostic.c.\n\t(cp_tree_printer): Rename cp_printer; wire up to *_to_string\n\tinstead of deleted print_* routines.  Handle %C, %L, %O, %Q also.\n\t(init_error): Adjust to match.\npo:\n\t* POTFILES.in: Remove cp/errfn.c.\n\nFrom-SVN: r45765", "tree": {"sha": "1f1e9f3af7240cf9b105d13f1eb384eafd666ecf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f1e9f3af7240cf9b105d13f1eb384eafd666ecf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/749ced524c4a4bcb7e8374854cc380e33e69a1d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749ced524c4a4bcb7e8374854cc380e33e69a1d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/749ced524c4a4bcb7e8374854cc380e33e69a1d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749ced524c4a4bcb7e8374854cc380e33e69a1d8/comments", "author": null, "committer": null, "parents": [{"sha": "7a80cf9a2f287793e0361af57606031a17e636d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a80cf9a2f287793e0361af57606031a17e636d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a80cf9a2f287793e0361af57606031a17e636d4"}], "stats": {"total": 1367, "additions": 254, "deletions": 1113}, "files": [{"sha": "3badef73bb15dc12b587a13c887bcc61aeb12762", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=749ced524c4a4bcb7e8374854cc380e33e69a1d8", "patch": "@@ -1,3 +1,12 @@\n+2001-09-23  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* errors.h (warning, error, fatal, internal_error): Don't mark\n+\twith ATTRIBUTE_PRINTF_n.\n+\t* toplev.h (internal_error, fatal_io_error, warning, error,\n+\tpedwarn, pedwarn_with_file_and_line, warning_with_file_and_line,\n+\terror_with_file_and_line, sorry, error_for_asm, warning_for_asm):\n+\tLikewise.\n+\n Sun Sep 23 18:19:48 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* function.c (pop_function_context_from): var_refs_queue\n@@ -573,7 +582,7 @@ Thu Sep 20 12:19:36 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n 2001-09-18  Ulrich Weigand  <uweigand@de.ibm.com>:\n \n-        * config.gcc (s390-*-linux-*, s390x-*-linux*): Switch to\n+\t* config.gcc (s390-*-linux-*, s390x-*-linux*): Switch to\n \tnew-style tm_file specification.  Specify correct tm_p_file,\n \tmd_file, and out_file for s390x.\n \n@@ -586,12 +595,12 @@ Thu Sep 20 12:19:36 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n Tue Sep 18 09:51:11 2001  Eric Christopher  <ecechristo@redhat.com>\n \n-        * config/mips/mips.c (mips_asm_file_start): Conditionalize Elf\n-        code generation only for Gnu assembler.\n+\t* config/mips/mips.c (mips_asm_file_start): Conditionalize Elf\n+\tcode generation only for Gnu assembler.\n \n 2001-09-18  Catherine Moore  <clm@redhat.com>\n \n-        * config/stormy16 (LIB_SPEC): Remove -lnosys.\n+\t* config/stormy16 (LIB_SPEC): Remove -lnosys.\n \n 2001-09-18  Richard Sandiford  <rsandifo@redhat.com>\n "}, {"sha": "a5dc225cbac6479bec872dba00942f8aeec9aaca", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=749ced524c4a4bcb7e8374854cc380e33e69a1d8", "patch": "@@ -1,3 +1,30 @@\n+2001-09-23  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* Make-lang.in (CXX_OBJS): Take out cp/errfn.o.\n+\t(cp/errfn.o): Delete rule.\n+\t(cp/error.o): Depend on flags.h.\n+\t* errfn.c: Delete file.\n+\t* cp-tree.h: Declare warn_deprecated.  Remove definitions of\n+\tTFF_NAMESPACE_SCOPE, TFF_CLASS_SCOPE, TFF_CHASE_NAMESPACE_ALIAS,\n+\tand TFF_TEMPLATE_DEFAULT_ARGUMENTS. #define cp_error, cp_warning,\n+\tcp_pedwarn, and cp_compiler_error to error, warning, pedwarn, and\n+\tinternal_error respectively.  Make cp_deprecated into a macro.\n+\tDon't define cp_printer typedef or declare cp_printers.\n+\t* error.c: Include flags.h.\n+\tDelete: struct tree_formatting_info, print_function_argument_list,\n+\tprint_declaration, print_expression, print_function_declaration,\n+\tprint_function_parameter, print_type_id, print_cv_qualifier_seq,\n+\tprint_type_specifier_seq, print_simple_type_specifier,\n+\tprint_elaborated_type_specifier, print_rest_of_abstract_declarator,\n+\tprint_parameter_declaration_clause, print_exception_specification,\n+\tprint_nested_name_specifier, and definition of cp_printers.\n+\t(locate_error): New function.\n+\t(cp_error_at, cp_warning_at, cp_pedwarn_at): Moved here and\n+\trewritten in terms of locate_error and diagnostic.c.\n+\t(cp_tree_printer): Rename cp_printer; wire up to *_to_string\n+\tinstead of deleted print_* routines.  Handle %C, %L, %O, %Q also.\n+\t(init_error): Adjust to match.\n+\n Sat Sep 22 09:15:31 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* Make-lang.in (CXX_C_OBJS): Add attribs.o.\n@@ -58,8 +85,8 @@ Fri Sep 21 08:16:19 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n 2001-09-15  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n \n-\t        * Make-lang.in (cp/error.o): Depend on real.h\n-\t        * error.c: #include \"real.h\"\n+\t\t* Make-lang.in (cp/error.o): Depend on real.h\n+\t\t* error.c: #include \"real.h\"\n \n 2001-09-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n@@ -125,10 +152,10 @@ Fri Sep 21 08:16:19 2001  J\"orn Rennecke <amylaar@redhat.com>\n \t(dump_decl): Fix formatting.\n \n 2001-08-30  Kurt Garloff  <garloff@suse.de>\n- \n+\n \t* optimize.c (inlinable_function_p): Allow only smaller single\n \tfunctions. Halve inline limit after reaching recursive limit.\n- \n+\n 2001-08-30  Joern Rennecke <amylaar@redhat.com>\n \t    Jason Merrill  <jason_merrill@redhat.com>\n \n@@ -335,7 +362,7 @@ Fri Sep 21 08:16:19 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n 2001-07-30  Andreas Jaeger  <aj@suse.de>\n \n-        * decl2.c: Remove unused var global_temp_name_counter.\n+\t* decl2.c: Remove unused var global_temp_name_counter.\n \n 2001-07-28  Richard Henderson  <rth@redhat.com>\n \n@@ -385,7 +412,7 @@ Fri Sep 21 08:16:19 2001  J\"orn Rennecke <amylaar@redhat.com>\n \tdeclaring a function, and create last_function_parms correctly.\n \n 2001-07-25  Jason Merrill  <jason_merrill@redhat.com>\n-\t\n+\n \t* call.c (joust): Only prefer a non-builtin candidate to a builtin\n \tone if they have the same signature.\n \n@@ -573,7 +600,7 @@ Fri Sep 21 08:16:19 2001  J\"orn Rennecke <amylaar@redhat.com>\n \t* NEWS: Document ABI changes from GCC 3.0.\n \n 2001-07-18  Xavier Delacour <xavier@fmaudio.net>,\n-            Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n+\t    Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* NEWS (Changes in GCC 3.0): Fix typo.\n \n@@ -1093,7 +1120,7 @@ Fri Sep 21 08:16:19 2001  J\"orn Rennecke <amylaar@redhat.com>\n 2001-05-14  Nick Clifton  <nickc@cambridge.redhat.com>\n \n \t* decl.c (duplicate_decls): Suppress warning about duplicate\n-        decls if the first decl is a friend.\n+\tdecls if the first decl is a friend.\n \n 2001-05-12  Zack Weinberg  <zackw@stanford.edu>\n \n@@ -1218,7 +1245,7 @@ Fri Sep 21 08:16:19 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n 2001-04-30  Richard Henderson  <rth@redhat.com>\n \n-        * cvt.c: Downcase C_PROMOTING_INTEGER_TYPE_P invocations.\n+\t* cvt.c: Downcase C_PROMOTING_INTEGER_TYPE_P invocations.\n \t* decl.c: Likewise.\n \n 2001-04-30  Mark Mitchell  <mark@codesourcery.com>"}, {"sha": "4fe7e8752b47ebc96f8481ac0f100cc475947d0d", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=749ced524c4a4bcb7e8374854cc380e33e69a1d8", "patch": "@@ -97,7 +97,7 @@ CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n  c-dump.o $(CXX_TARGET_OBJS)\n \n # Language-specific object files.\n-CXX_OBJS = cp/call.o cp/decl.o cp/errfn.o cp/expr.o cp/pt.o cp/typeck2.o \\\n+CXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n  cp/class.o cp/decl2.o cp/error.o cp/lex.o cp/parse.o cp/ptree.o cp/rtti.o \\\n  cp/spew.o cp/typeck.o cp/cvt.o cp/except.o cp/friend.o cp/init.o cp/method.o \\\n  cp/search.o cp/semantics.o cp/tree.o cp/xref.o cp/repo.o cp/dump.o \\\n@@ -271,8 +271,7 @@ cp/expr.o: cp/expr.c $(CXX_TREE_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\\n cp/xref.o: cp/xref.c $(CXX_TREE_H) input.h toplev.h\n cp/pt.o: cp/pt.c $(CXX_TREE_H) cp/decl.h cp/parse.h cp/lex.h toplev.h \\\n   $(GGC_H) $(RTL_H) except.h\n-cp/error.o: cp/error.c $(CXX_TREE_H) toplev.h diagnostic.h real.h\n-cp/errfn.o: cp/errfn.c $(CXX_TREE_H) toplev.h\n+cp/error.o: cp/error.c $(CXX_TREE_H) toplev.h diagnostic.h flags.h real.h\n cp/repo.o: cp/repo.c $(CXX_TREE_H) toplev.h $(GGC_H) diagnostic.h\n cp/semantics.o: cp/semantics.c $(CXX_TREE_H) cp/lex.h except.h toplev.h \\\n   flags.h $(GGC_H) debug.h output.h $(RTL_H) $(TIMEVAR_H) $(EXPR_H)"}, {"sha": "de58ee4b890f81711e5fdf89bebae8022ae75c6c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=749ced524c4a4bcb7e8374854cc380e33e69a1d8", "patch": "@@ -997,6 +997,10 @@ extern int warn_old_style_cast;\n \n extern int warn_reorder;\n \n+/* Non-zero means warn about deprecated features.  */\n+\n+extern int warn_deprecated;\n+\n /* Nonzero means to treat bitfields as unsigned unless they say `signed'.  */\n \n extern int flag_signed_bitfields;\n@@ -3433,11 +3437,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n /* These constants can used as bit flags in the process of tree formatting.\n \n    TFF_PLAIN_IDENTIFIER: unqualified part of a name.\n-   TFF_NAMESPACE_SCOPE: the complete qualified-id form of a name.\n-   TFF_CLASS_SCOPE: if possible, include the class-name part of a\n-        qualified-id.  This flag may be implied in some circumstances by\n-        TFF_NAMESPACE_SCOPE.\n-   TFF_SCOPE: the combination of the two above.\n+   TFF_SCOPE: include the class and namespace scope of the name.\n    TFF_CHASE_TYPEDEF: print the original type-id instead of the typedef-name.\n    TFF_DECL_SPECIFIERS: print decl-specifiers.\n    TFF_CLASS_KEY_OR_ENUM: precede a class-type name (resp. enum name) with\n@@ -3447,25 +3447,20 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n    TFF_EXCEPTION_SPECIFICATION: show function exception specification.\n    TFF_TEMPLATE_HEADER: show the template<...> header in a\n        template-declaration.\n-   TFF_TEMPLATE_DEFAULT_ARGUMENTS: show template parameter default values.\n    TFF_TEMPLATE_NAME: show only template-name.\n    TFF_EXPR_IN_PARENS: Parenthesize expressions.  */\n \n #define TFF_PLAIN_IDENTIFIER               (0)\n-#define TFF_NAMESPACE_SCOPE                (1)\n-#define TFF_CLASS_SCOPE                    (1 << 1)\n-#define TFF_CHASE_NAMESPACE_ALIAS          (1 << 2)\n-#define TFF_CHASE_TYPEDEF                  (1 << 3)\n-#define TFF_DECL_SPECIFIERS                (1 << 4)\n-#define TFF_CLASS_KEY_OR_ENUM              (1 << 5)\n-#define TFF_RETURN_TYPE                    (1 << 6)\n-#define TFF_FUNCTION_DEFAULT_ARGUMENTS     (1 << 7)\n-#define TFF_EXCEPTION_SPECIFICATION        (1 << 8)\n-#define TFF_TEMPLATE_HEADER                (1 << 9)\n-#define TFF_TEMPLATE_DEFAULT_ARGUMENTS     (1 << 10)\n-#define TFF_TEMPLATE_NAME                  (1 << 11)\n-#define TFF_EXPR_IN_PARENS                 (1 << 12)\n-#define TFF_SCOPE (TFF_NAMESPACE_SCOPE | TFF_CLASS_SCOPE)\n+#define TFF_SCOPE                \t   (1)\n+#define TFF_CHASE_TYPEDEF                  (1 << 1)\n+#define TFF_DECL_SPECIFIERS                (1 << 2)\n+#define TFF_CLASS_KEY_OR_ENUM              (1 << 3)\n+#define TFF_RETURN_TYPE                    (1 << 4)\n+#define TFF_FUNCTION_DEFAULT_ARGUMENTS     (1 << 5)\n+#define TFF_EXCEPTION_SPECIFICATION        (1 << 6)\n+#define TFF_TEMPLATE_HEADER                (1 << 7)\n+#define TFF_TEMPLATE_NAME                  (1 << 8)\n+#define TFF_EXPR_IN_PARENS                 (1 << 9)\n \n /* Returns the TEMPLATE_DECL associated to a TEMPLATE_TEMPLATE_PARM\n    node.  */\n@@ -3779,17 +3774,24 @@ extern tree set_guard                           PARAMS ((tree));\n /* in parse.y */\n extern void cp_parse_init\t\t\tPARAMS ((void));\n \n-/* in errfn.c */\n-/* The cp_* functions aren't suitable for ATTRIBUTE_PRINTF. */\n-extern void cp_error\t\t\t\tPARAMS ((const char *, ...));\n-extern void cp_error_at\t\t\t\tPARAMS ((const char *, ...));\n-extern void cp_warning\t\t\t\tPARAMS ((const char *, ...));\n-extern void cp_warning_at\t\t\tPARAMS ((const char *, ...));\n-extern void cp_pedwarn\t\t\t\tPARAMS ((const char *, ...));\n-extern void cp_pedwarn_at\t\t\tPARAMS ((const char *, ...));\n-extern void cp_compiler_error\t\t\tPARAMS ((const char *, ...));\n-extern void cp_sprintf\t\t\t\tPARAMS ((const char *, ...));\n-extern void cp_deprecated                       PARAMS ((const char*));\n+/* Obsolete names, formerly found in errfn.c, which no longer exists.\n+   These are all variadic functions and therefore cannot be defined\n+   as function-like macros.  */\n+#define cp_error\t\terror\n+#define cp_warning\t\twarning\n+#define cp_pedwarn\t\tpedwarn\n+#define cp_compiler_error\tinternal_error\n+\n+extern void cp_error_at\t\tPARAMS ((const char *msgid, ...));\n+extern void cp_warning_at\tPARAMS ((const char *msgid, ...));\n+extern void cp_pedwarn_at\tPARAMS ((const char *msgid, ...));\n+\n+/* XXX Not i18n clean.  */\n+#define cp_deprecated(str) \\\n+ do { if (warn_deprecated) \\\n+      cp_warning(\"%s is deprecated, please see the documentation for details\", \\\n+\t\t str); \\\n+ } while (0)\n \n /* in error.c */\n extern void init_error\t\t\t\tPARAMS ((void));\n@@ -3802,13 +3804,6 @@ extern const char *cp_file_of\t\t\tPARAMS ((tree));\n extern int cp_line_of\t\t\t\tPARAMS ((tree));\n extern const char *language_to_string           PARAMS ((enum languages, int));\n extern void print_instantiation_context         PARAMS ((void));\n-/* cp_printer is the type of a function which converts an argument into\n-   a string for digestion by printf.  The cp_printer function should deal\n-   with all memory management; the functions in errfn will not free\n-   the char*s returned.  See error.c for an example use of this code.  */\n-typedef const char *cp_printer\t\t\tPARAMS ((tree, int));\n-extern cp_printer *cp_printers[256];\n-\n \n /* in except.c */\n extern void init_exception_processing\t\tPARAMS ((void));"}, {"sha": "84ad1f5e20f3f3210dced845140b02e49be5219e", "filename": "gcc/cp/errfn.c", "status": "removed", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a80cf9a2f287793e0361af57606031a17e636d4/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a80cf9a2f287793e0361af57606031a17e636d4/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=7a80cf9a2f287793e0361af57606031a17e636d4", "patch": "@@ -1,280 +0,0 @@\n-/* Provide a call-back mechanism for handling error output.\n-   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n-   Free Software Foundation, Inc.\n-   Contributed by Jason Merrill (jason@cygnus.com)\n-\n-   This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"cp-tree.h\"\n-#include \"toplev.h\"\n-\n-/* Whether or not we should try to be quiet for errors and warnings; this is\n-   used to avoid being too talkative about problems with tentative choices\n-   when we're computing the conversion costs for a method call.  */\n-int cp_silent = 0;\n-\n-typedef void errorfn ();\t/* deliberately vague */\n-\n-static void cp_thing PARAMS ((errorfn *, int, const char *, va_list));\n-\n-#define STRDUP(f) (ap = (char *) alloca (strlen (f) +1), strcpy (ap, (f)), ap)\n-\n-/* This function supports only `%s', `%d', `%%', and the C++ print\n-   codes.  */\n-\n-static void\n-cp_thing (errfn, atarg1, format, ap)\n-     errorfn *errfn;\n-     int atarg1;\n-     const char *format;\n-     va_list ap;\n-{\n-  static char *buf;\n-  static long buflen;\n-  int nargs = 0;\n-  long len;\n-  long offset;\n-  const char *f;\n-  tree atarg = 0;\n-\n-  len = strlen (format) + 1;\n-  if (len > buflen)\n-    {\n-      buflen = len;\n-      buf = xrealloc (buf, buflen);\n-    }\n-  offset = 0;\n-\n-  for (f = format; *f; ++f)\n-    {\n-      cp_printer * function;\n-      int alternate;\n-      int maybe_here;\n-\n-      /* ignore text */\n-      if (*f != '%')\n-\t{\n-\t  buf[offset++] = *f;\n-\t  continue;\n-\t}\n-\n-      ++f;\n-\n-      alternate = 0;\n-      maybe_here = 0;\n-\n-      /* Check for '+' and '#' (in that order). */\n-      if (*f == '+')\n-\t{\n-\t  maybe_here = 1;\n-\t  ++f;\n-\t}\n-      if (*f == '#')\n-\t{\n-\t  alternate = 1;\n-\t  ++f;\n-\t}\n-\n-      /* no field width or precision */\n-\n-      function = cp_printers[(int)*f];\n-\n-      if (function || *f == 's')\n-\t{\n-\t  const char *p;\n-\t  int plen;\n-\n-\t  if (*f == 's')\n-\t    {\n-\t      p = va_arg (ap, char *);\n-\t      nargs++;\n-\t    }\n-\t  else\n-\t    {\n-\t      tree t = va_arg (ap, tree);\n-\t      nargs++;\n-\n-\t      /* This indicates that ATARG comes from a different\n-\t\t location than normal.  */\n-\t      if (maybe_here && atarg1)\n-\t\tatarg = t;\n-\n-\t      /* If atarg1 is set and this is the first argument, then\n-\t\t set ATARG appropriately.  */\n-\t      if (atarg1 && nargs == 1)\n-\t\tatarg = t;\n-\n-\t      p = (*function) (t, alternate);\n-\t    }\n-\n-\t  plen = strlen (p);\n-\t  len += plen;\n-\t  if (len > buflen)\n-\t    {\n-\t      buflen = len;\n-\t      buf = xrealloc (buf, len);\n-\t    }\n-\t  strcpy (buf + offset, p);\n-\t  offset += plen;\n-\t}\n-      else if (*f == '%')\n-\t{\n-\t  /* A `%%' has occurred in the input string. Replace it with\n-\t     a `%' in the formatted message buf. */\n-\n-\t  if (++len > buflen)\n-\t    {\n-\t      buflen = len;\n-\t      buf = xrealloc (buf, len);\n-\t    }\n-\t  buf[offset++] = '%';\n-\t}\n-      else\n-\t{\n-\t  if (*f != 'd')\n-\t    abort ();\n-\t  len += HOST_BITS_PER_INT / 2;\n-\t  if (len > buflen)\n-\t    {\n-\t      buflen = len;\n-\t      buf = xrealloc (buf, len);\n-\t    }\n-\t  sprintf (buf + offset, \"%d\", va_arg (ap, int));\n-\t  nargs++;\n-\t  offset += strlen (buf + offset);\n-\t  /* With an ANSI C library one could write\n-\t     out += sprintf (...); */\n-\t}\n-    }\n-  buf[offset] = '\\0';\n-\n-  /* If ATARG1 is set, but we haven't extracted any arguments, then\n-     extract one tree argument for ATARG.  */\n-  if (nargs == 0 && atarg1)\n-    atarg = va_arg (ap, tree);\n-\n-  if (atarg)\n-    {\n-      const char *file = cp_file_of (atarg);\n-      int   line = cp_line_of (atarg);\n-      (*errfn) (file, line, \"%s\", buf);\n-    }\n-  else\n-    (*errfn) (\"%s\", buf);\n-\n-}\n-\n-void\n-cp_error VPARAMS ((const char *format, ...))\n-{\n-  VA_OPEN (ap, format);\n-  VA_FIXEDARG (ap, const char *, format);\n-\n-  if (! cp_silent)\n-    cp_thing ((errorfn *) error, 0, format, ap);\n-  VA_CLOSE (ap);\n-}\n-\n-void\n-cp_warning VPARAMS ((const char *format, ...))\n-{\n-  VA_OPEN (ap, format);\n-  VA_FIXEDARG (ap, const char *, format);\n-\n-  if (! cp_silent)\n-    cp_thing ((errorfn *) warning, 0, format, ap);\n-  VA_CLOSE (ap);\n-}\n-\n-void\n-cp_pedwarn VPARAMS ((const char *format, ...))\n-{\n-  VA_OPEN (ap, format);\n-  VA_FIXEDARG (ap, const char *, format);\n-\n-  if (! cp_silent)\n-    cp_thing ((errorfn *) pedwarn, 0, format, ap);\n-  VA_CLOSE (ap);\n-}\n-\n-void\n-cp_compiler_error VPARAMS ((const char *format, ...))\n-{\n-  VA_OPEN (ap, format);\n-  VA_FIXEDARG (ap, const char *, format);\n-\n-  if (! cp_silent)\n-    cp_thing ((errorfn *) compiler_error, 0, format, ap);\n-  VA_CLOSE (ap);\n-}\n-\n-void\n-cp_deprecated (msg)\n-  const char *msg;\n-{\n-  extern int warn_deprecated;\n-  if (!warn_deprecated)\n-    return;\n-  cp_warning (\"%s is deprecated, please see the documentation for details\", msg);\n-}\n-\n-void\n-cp_sprintf VPARAMS ((const char *format, ...))\n-{\n-  VA_OPEN (ap, format);\n-  VA_FIXEDARG (ap, const char *, format);\n-\n-  cp_thing ((errorfn *) sprintf, 0, format, ap);\n-  VA_CLOSE (ap);\n-}\n-\n-void\n-cp_error_at VPARAMS ((const char *format, ...))\n-{\n-  VA_OPEN (ap, format);\n-  VA_FIXEDARG (ap, const char *, format);\n-\n-  if (! cp_silent)\n-    cp_thing ((errorfn *) error_with_file_and_line, 1, format, ap);\n-  VA_CLOSE (ap);\n-}\n-\n-void\n-cp_warning_at VPARAMS ((const char *format, ...))\n-{\n-  VA_OPEN (ap, format);\n-  VA_FIXEDARG (ap, const char *, format);\n-\n-  if (! cp_silent)\n-    cp_thing ((errorfn *) warning_with_file_and_line, 1, format, ap);\n-  VA_CLOSE (ap);\n-}\n-\n-void\n-cp_pedwarn_at VPARAMS ((const char *format, ...))\n-{\n-  VA_OPEN (ap, format);\n-  VA_FIXEDARG (ap, const char *, format);\n-\n-  if (! cp_silent)\n-    cp_thing ((errorfn *) pedwarn_with_file_and_line, 1, format, ap);\n-  VA_CLOSE (ap);\n-}"}, {"sha": "2e7118465751c65eb0fcc71df2bb3c9e65fc2a90", "filename": "gcc/cp/error.c", "status": "modified", "additions": 137, "deletions": 743, "changes": 880, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=749ced524c4a4bcb7e8374854cc380e33e69a1d8", "patch": "@@ -26,23 +26,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n+#include \"flags.h\"\n #include \"diagnostic.h\"\n \n enum pad { none, before, after };\n \n-/* This data structure bundles altogether, all the information necessary\n-   for pretty-printing a C++ source-level entity represented by a tree.  */\n-typedef struct\n-{\n-  tree decl;\n-  int flags;\n-  enum pad pad;\n-} tree_formatting_info, *tfi_t;\n-\n-#define tree_being_formatted(TFI) (TFI)->decl\n-#define tree_formatting_flags(TFI) (TFI)->flags\n-#define put_whitespace(TFI) (TFI)->pad\n-\n #define sorry_for_unsupported_tree(T)                                      \\\n    sorry (\"`%s' not supported by %s\", tree_code_name[(int) TREE_CODE (T)], \\\n              __FUNCTION__)\n@@ -130,74 +118,19 @@ static void cp_diagnostic_finalizer PARAMS ((output_buffer *,\n static void cp_print_error_function PARAMS ((output_buffer *,\n                                              diagnostic_context *));\n \n-static int cp_tree_printer PARAMS ((output_buffer *));\n-static void print_function_argument_list PARAMS ((output_buffer *, tfi_t));\n-static void print_declaration PARAMS ((output_buffer *, tfi_t));\n-static void print_expression PARAMS ((output_buffer *, tfi_t));\n-static void print_integer PARAMS ((output_buffer *, HOST_WIDE_INT));\n-static void print_function_declaration PARAMS ((output_buffer *, tfi_t));\n-static void print_function_parameter PARAMS ((output_buffer *, int));\n-static void print_type_id PARAMS ((output_buffer *, tfi_t));\n-static void print_cv_qualifier_seq PARAMS ((output_buffer *, tfi_t));\n-static void print_type_specifier_seq PARAMS ((output_buffer *, tfi_t));\n-static void print_simple_type_specifier PARAMS ((output_buffer *, tfi_t));\n-static void print_elaborated_type_specifier PARAMS ((output_buffer *, tfi_t));\n-static void print_rest_of_abstract_declarator PARAMS ((output_buffer *,\n-                                                       tfi_t));\n-static void print_parameter_declaration_clause PARAMS ((output_buffer *,\n-                                                        tfi_t));\n-static void print_exception_specification PARAMS ((output_buffer *, tfi_t));\n-static void print_nested_name_specifier PARAMS ((output_buffer *, tfi_t));\n-static void print_template_id PARAMS ((output_buffer *, tfi_t));\n-static tree typedef_original_name PARAMS ((tree));\n+static int cp_printer PARAMS ((output_buffer *));\n static void print_non_consecutive_character PARAMS ((output_buffer *, int));\n-\n-#define A args_to_string\n-#define C code_to_string\n-#define D decl_to_string\n-#define E expr_to_string\n-#define F fndecl_to_string\n-#define L language_to_string\n-#define O op_to_string\n-#define P parm_to_string\n-#define Q assop_to_string\n-#define T type_to_string\n-#define V cv_to_string\n-\n-#define o (cp_printer *) 0\n-cp_printer * cp_printers[256] =\n-{\n-/*0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x00 */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x10 */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x20 */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x30 */\n-  o, A, o, C, D, E, F, o, o, o, o, o, L, o, o, O, /* 0x40 */\n-  P, Q, o, o, T, o, V, o, o, o, o, o, o, o, o, o, /* 0x50 */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x60 */\n-  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x70 */\n-};\n-#undef A\n-#undef C\n-#undef D\n-#undef E\n-#undef F\n-#undef L\n-#undef O\n-#undef P\n-#undef Q\n-#undef T\n-#undef V\n-#undef o\n+static void print_integer PARAMS ((output_buffer *, HOST_WIDE_INT));\n+static tree locate_error PARAMS ((const char *, va_list));\n \n void\n init_error ()\n {\n   print_error_function = lang_print_error_function;\n   diagnostic_starter (global_dc) = cp_diagnostic_starter;\n   diagnostic_finalizer (global_dc) = cp_diagnostic_finalizer;\n-  diagnostic_format_decoder (global_dc) = cp_tree_printer;\n-  \n+  diagnostic_format_decoder (global_dc) = cp_printer;\n+\n   init_output_buffer (scratch_buffer, /* prefix */NULL, /* line-width */0);\n }\n \n@@ -2634,121 +2567,59 @@ print_instantiation_context ()\n /* Called from output_format -- during diagnostic message processing --\n    to handle C++ specific format specifier with the following meanings:\n    %A   function argument-list.\n+   %C\ttree code.\n    %D   declaration.\n    %E   expression.\n    %F   function declaration.\n+   %L\tlanguage as used in extern \"lang\".\n+   %O\tbinary operator.\n    %P   function parameter whose position is indicated by an integer.\n+   %Q\tassignment operator.\n    %T   type.\n    %V   cv-qualifier.  */\n static int\n-cp_tree_printer (buffer)\n+cp_printer (buffer)\n      output_buffer *buffer;\n {\n-  int be_verbose = 0;\n-  tree_formatting_info tfi;\n-\n-  memset (&tfi, 0, sizeof (tree_formatting_info));\n+  int verbose = 0;\n+  const char *result;\n+#define next_tree    va_arg (output_buffer_format_args (buffer), tree)\n+#define next_tcode   va_arg (output_buffer_format_args (buffer), enum tree_code)\n+#define next_lang    va_arg (output_buffer_format_args (buffer), enum languages)\n+#define next_int     va_arg (output_buffer_format_args (buffer), int)\n \n   if (*output_buffer_text_cursor (buffer) == '+')\n     ++output_buffer_text_cursor (buffer);\n   if (*output_buffer_text_cursor (buffer) == '#')\n     {\n-      be_verbose = 1;\n+      verbose = 1;\n       ++output_buffer_text_cursor (buffer);\n     }\n \n   switch (*output_buffer_text_cursor (buffer))\n     {\n-    case 'A':\n-      tree_being_formatted (&tfi) =\n-        va_arg (output_buffer_format_args (buffer), tree);\n-      if (be_verbose)\n-        tree_formatting_flags (&tfi) = TFF_SCOPE\n-          | TFF_FUNCTION_DEFAULT_ARGUMENTS;\n-      print_function_argument_list (buffer, &tfi);\n-      break;\n-\n-    case 'D':\n-      tree_being_formatted (&tfi) =\n-        va_arg (output_buffer_format_args (buffer), tree);\n-      if (be_verbose)\n-        tree_formatting_flags (&tfi) = TFF_SCOPE | TFF_DECL_SPECIFIERS\n-          | TFF_CLASS_KEY_OR_ENUM | TFF_RETURN_TYPE\n-          | TFF_FUNCTION_DEFAULT_ARGUMENTS | TFF_TEMPLATE_DEFAULT_ARGUMENTS\n-          | TFF_EXCEPTION_SPECIFICATION | TFF_CHASE_NAMESPACE_ALIAS;\n-      print_declaration (buffer, &tfi);\n-      break;\n-\n-    case 'E':\n-      tree_being_formatted (&tfi) =\n-        va_arg (output_buffer_format_args (buffer), tree);\n-      if (be_verbose)\n-        tree_formatting_flags (&tfi) = TFF_SCOPE;\n-      print_expression (buffer, &tfi);\n-      break;\n-\n-    case 'F':\n-      tree_being_formatted (&tfi) =\n-        va_arg (output_buffer_format_args (buffer), tree);\n-      if (be_verbose)\n-        tree_formatting_flags (&tfi) = TFF_SCOPE | TFF_DECL_SPECIFIERS\n-          | TFF_RETURN_TYPE | TFF_FUNCTION_DEFAULT_ARGUMENTS\n-          | TFF_EXCEPTION_SPECIFICATION;\n-      print_function_declaration (buffer, &tfi);\n-      break;\n-\n-    case 'P':\n-      print_function_parameter\n-        (buffer, va_arg (output_buffer_format_args (buffer), int));\n-      break;\n-\n-    case 'T':\n-      tree_being_formatted (&tfi) =\n-        va_arg (output_buffer_format_args (buffer), tree);\n-      if (be_verbose)\n-        tree_formatting_flags (&tfi) = TFF_SCOPE | TFF_CLASS_KEY_OR_ENUM\n-          | TFF_RETURN_TYPE | TFF_EXCEPTION_SPECIFICATION;\n-      print_type_id (buffer, &tfi);\n-      break;\n-\n-    case 'V':\n-      tree_being_formatted (&tfi) =\n-        va_arg (output_buffer_format_args (buffer), tree);\n-      print_cv_qualifier_seq (buffer, &tfi);\n-      break;\n-\n+    case 'A': result = args_to_string (next_tree, verbose);\tbreak;\n+    case 'C': result = code_to_string (next_tcode, verbose);\tbreak;\n+    case 'D': result = decl_to_string (next_tree, verbose);\tbreak;\n+    case 'E': result = expr_to_string (next_tree, verbose);\tbreak;\n+    case 'F': result = fndecl_to_string (next_tree, verbose);\tbreak;\n+    case 'L': result = language_to_string (next_lang, verbose); break;\n+    case 'O': result = op_to_string (next_tcode, verbose);\tbreak;\n+    case 'P': result = parm_to_string (next_int, verbose);\tbreak;\n+    case 'Q': result = assop_to_string (next_tcode, verbose);\tbreak;\n+    case 'T': result = type_to_string (next_tree, verbose);\tbreak;\n+    case 'V': result = cv_to_string (next_tree, verbose);\tbreak;\n+ \n     default:\n       return 0;\n     }\n \n+  output_add_string (buffer, result);\n   return 1;\n-}\n-\n-/* Print a function argument-list represented by tree_being_formatted (TFI)\n-   onto BUFFER.  */\n-static void\n-print_function_argument_list (buffer, tfi)\n-     output_buffer *buffer __attribute__ ((__unused__));\n-     tfi_t tfi __attribute__  ((__unused__));\n-{\n-}\n-\n-/* Print a declaration represented by tree_being_formatted (TFI)\n-   onto buffer.  */\n-static void\n-print_declaration (buffer, tfi)\n-     output_buffer *buffer __attribute__ ((__unused__));\n-     tfi_t tfi __attribute__ ((__unused__));\n-{\n-}\n-\n-/* Print an expression represented by tree_being_formatted (TFI)\n-   onto BUFFER.  */\n-static void\n-print_expression (buffer, tfi)\n-     output_buffer *buffer __attribute__ ((__unused__));\n-     tfi_t tfi __attribute__ ((__unused__));\n-{\n+#undef next_tree\n+#undef next_tcode\n+#undef next_lang\n+#undef next_int\n }\n \n static void\n@@ -2760,617 +2631,140 @@ print_integer (buffer, i)\n   output_add_string (buffer, digit_buffer);\n }\n \n-/* Print a function declaration represented by tree_being_formatted (TFI)\n-   onto BUFFER.  */\n-static void\n-print_function_declaration (buffer, tfi)\n-     output_buffer *buffer __attribute__ ((__unused__));\n-     tfi_t tfi __attribute__ ((__unused__));\n-{\n-}\n-\n-/* Print the N'th function parameter onto BUFFER.  A negative value of N\n-   means the implicit \"this\" parameter of a member function.  */\n static void\n-print_function_parameter (buffer, n)\n-     output_buffer *buffer;\n-     int n;\n-{\n-  if (n < 0)\n-    print_identifier (buffer, \"this\");\n-  else\n-    output_decimal (buffer, n + 1);\n-}\n-\f\n-/* Print a type represented by tree_being_formatted (TFI) onto BUFFER.  */\n-static void\n-print_type_id (buffer, tfi)\n+print_non_consecutive_character (buffer, c)\n      output_buffer *buffer;\n-     tfi_t tfi;\n+     int c;\n {\n-  tree t = tree_being_formatted (tfi);\n-  int flags = tree_formatting_flags (tfi);\n-  if (t == NULL_TREE)\n-    return;\n-\n-  if (flags & TFF_CHASE_TYPEDEF)\n-    tree_being_formatted (tfi) =\n-      typedef_original_name (tree_being_formatted (tfi));\n-\n-  /* A type-id is of the form:\n-     type-id:\n-        type-specifier-seq abstract-declarator(opt)  */\n-  print_type_specifier_seq (buffer, tfi);\n-\n-  if (TYPE_PTRMEMFUNC_P (t))\n-    goto ptr_mem_fun;\n-\n-  /* For types with abstract-declarator, print_type_specifier_seq prints\n-     the start of the abstract-declarator.  Fiinish the job.  */\n-  switch (TREE_CODE (t))\n-    {\n-    case ARRAY_TYPE:\n-    case POINTER_TYPE:\n-    case REFERENCE_TYPE:\n-    case OFFSET_TYPE:\n-    case METHOD_TYPE:\n-    case FUNCTION_TYPE:\n-    ptr_mem_fun:\n-      print_rest_of_abstract_declarator (buffer, tfi);\n-\n-    default:\n-      break;\n-    }\n+  const char *p = output_last_position (buffer);\n \n-  tree_being_formatted (tfi) = t;\n+  if (p != NULL && *p == c)\n+    output_add_space (buffer);\n+  output_add_character (buffer, c);\n }\n \n-/* Print the type-specifier-seq part of a type-id.  If appropriate, print\n- also the prefix of the abstract-declarator.  */\n-static void\n-print_type_specifier_seq (buffer, tfi)\n-     output_buffer *buffer;\n-     tfi_t tfi;\n-{\n-  int flags = tree_formatting_flags (tfi);\n-  tree t = tree_being_formatted (tfi);\n-  enum tree_code code = TREE_CODE (t);\n-\n-  /* A type-speficier-seq is:\n-         type-specifier type-specifier-seq(opt)\n-     where\n-         type-specifier:\n-             simple-type-specifier\n-             class-specifier\n-             enum-specifier\n-             elaborated-type-specifier\n-             cv-qualifier\n-\n-     We do not, however, pretty-print class-specifier nor enum-specifier.  */\n-\n-  switch (code)\n-    {\n-    case UNKNOWN_TYPE:\n-    case IDENTIFIER_NODE:\n-    case VOID_TYPE:\n-    case INTEGER_TYPE:\n-    case REAL_TYPE:\n-    case COMPLEX_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-    case UNION_TYPE:\n-    case TYPE_DECL:\n-    case TEMPLATE_DECL:\n-    case TEMPLATE_TYPE_PARM:\n-    case TYPEOF_TYPE:\n-    case TEMPLATE_TEMPLATE_PARM:\n-    case TYPENAME_TYPE:\n-    class_type:\n-      print_cv_qualifier_seq (buffer, tfi);\n-      if ((flags & TFF_DECL_SPECIFIERS)\n-          && (code ==  TYPENAME_TYPE || IS_AGGR_TYPE (t)))\n-        print_elaborated_type_specifier (buffer, tfi);\n-      else\n-        print_simple_type_specifier (buffer, tfi);\n-      break;\n-\n-      /* Because the abstract-declarator can modify the type-specifier-seq\n-         in a highly non linear manner, we pretty-print its prefix here.\n-         The suffix part is handled by print_rest_of_abstract_declarator.  */\n-\n-      /* A RECORD_TYPE is also used to represent a pointer to member\n-         function.  */\n-    case RECORD_TYPE:\n-      if (TYPE_PTRMEMFUNC_P (t))\n-        {\n-          /* Print the return type.  */\n-          tree_being_formatted (tfi) =\n-            TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (t));\n-          print_type_id (buffer, tfi);\n-          print_whitespace (buffer, tfi);\n-\n-          /* Then the beginning of the abstract-declarator part.  */\n-          tree_being_formatted (tfi) =\n-            TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (t));\n-          print_left_paren (buffer);\n-          print_nested_name_specifier (buffer, tfi);\n-        }\n-      else\n-        goto class_type;\n-      break;\n-\n-    case POINTER_TYPE:\n-      if (TYPE_PTRMEM_P (t))\n-        goto ptr_data_member;\n-      else\n-        goto non_ptr_data_member;\n-      break;\n-\n-    case ARRAY_TYPE:\n-    case REFERENCE_TYPE:\n-    case FUNCTION_TYPE:\n-    case METHOD_TYPE:\n-    non_ptr_data_member:\n-      tree_being_formatted (tfi) = TREE_TYPE (t);\n-      print_type_specifier_seq (buffer, tfi);\n-      if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n-        {\n-          if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n-            print_left_paren (buffer);\n-        }\n-      else if (code == FUNCTION_TYPE || code == METHOD_TYPE)\n-        {\n-          print_whitespace (buffer, tfi);\n-          print_left_paren (buffer);\n-          if (code == METHOD_TYPE)\n-            {\n-              tree_being_formatted (tfi) = TYPE_METHOD_BASETYPE (t);\n-              print_nested_name_specifier (buffer, tfi);\n-              tree_being_formatted (tfi) = t;\n-            }\n-        }\n-      tree_being_formatted (tfi) = t;\n-      break;\n-\n-    ptr_data_member:\n-    case OFFSET_TYPE:\n-      /* Firstly, the type of the member.  */\n-      tree_being_formatted (tfi) = TREE_TYPE (t);\n-      print_type_id (buffer, tfi);\n-      print_whitespace (buffer, tfi);\n-\n-      /* Then, the containing class.  */\n-      tree_being_formatted (tfi) = TYPE_OFFSET_BASETYPE (t);\n-      print_nested_name_specifier (buffer, tfi);\n-      tree_being_formatted (tfi) = t;\n-      break;\n-\n-    default:\n-      sorry_for_unsupported_tree (t);\n-      /* fall throught  */\n+/* These are temporary wrapper functions which handle the historic\n+   behavior of cp_*_at.  */\n \n-    case ERROR_MARK:\n-      print_identifier (buffer, \"{type-specifier-seq error}\");\n-      break;\n-    }\n-\n-  tree_being_formatted (tfi) = t;\n-}\n-\n-/* Print the simpe-type-specifier component of a type-specifier.  */\n-static void\n-print_simple_type_specifier (buffer, tfi)\n-     output_buffer *buffer;\n-     tfi_t tfi;\n+static tree\n+locate_error (msgid, ap)\n+     const char *msgid;\n+     va_list ap;\n {\n-  int flags = tree_formatting_flags (tfi);\n-  tree t = tree_being_formatted (tfi);\n-  enum tree_code code = TREE_CODE (t);\n+  tree here = 0, t;\n+  int plus = 0;\n+  const char *f;\n \n-  switch (code)\n+  for (f = msgid; *f; f++)\n     {\n-    case UNKNOWN_TYPE:\n-      print_identifier (buffer, \"{unknown type}\");\n-      break;\n-\n-    case IDENTIFIER_NODE:\n-      print_tree_identifier (buffer, t);\n-      break;\n-\n-    case COMPLEX_TYPE:\n-      print_identifier (buffer, \"__complex__ \");\n-      tree_being_formatted (tfi) = TREE_TYPE (t);\n-      print_type_id (buffer, tfi);\n-      break;\n-\n-    case TYPENAME_TYPE:\n-      tree_being_formatted (tfi) = TYPE_CONTEXT (t);\n-      print_nested_name_specifier (buffer, tfi);\n-      tree_being_formatted (tfi) = TYPENAME_TYPE_FULLNAME (t);\n-      tree_formatting_flags (tfi) |= ~TFF_CHASE_TYPEDEF;\n-      print_type_id (buffer, tfi);\n-      break;\n-\n-    case TYPEOF_TYPE:\n-      print_identifier (buffer, \"__typeof__\");\n-      tree_being_formatted (tfi) = TYPE_FIELDS (t);\n-      print_left_paren (buffer);\n-      print_expression (buffer, tfi);\n-      print_right_paren (buffer);\n-      break;\n-\n-    case INTEGER_TYPE:\n-      if (TREE_UNSIGNED (t))\n-        {\n-          if (TYPE_MAIN_VARIANT (t) == integer_type_node)\n-            /* We don't want pedantry like `unsigned int'.  */;\n-          else if (!TREE_UNSIGNED (TYPE_MAIN_VARIANT (t)))\n-            {\n-              print_identifier (buffer, \"unsigned\");\n-              print_whitespace (buffer, tfi);\n-            }\n-        }\n-      else if (TYPE_MAIN_VARIANT (t) == char_type_node)\n-        {\n-          print_identifier (buffer, \"signed\");\n-          print_whitespace (buffer, tfi);\n-        }\n-    case REAL_TYPE:\n-    case BOOLEAN_TYPE:\n-    case VOID_TYPE:\n-      {\n-        tree s = (flags & TFF_CHASE_TYPEDEF) ? TYPE_MAIN_VARIANT (t) : t;\n-\n-        if (TYPE_NAME (s) && TYPE_IDENTIFIER (s))\n-          print_tree_identifier (buffer, TYPE_IDENTIFIER (s));\n-        else\n-\t  /* Types like intQI_type_node and friends have no names.\n-\t     These don't come up in user error messages, but it's nice\n-\t     to be able to print them from the debugger.  */\n-          print_identifier (buffer, \"{anonymous}\");\n-      }\n-      break;\n-\n-    case TEMPLATE_TEMPLATE_PARM:\n-      if (TYPE_IDENTIFIER (t))\n-        print_tree_identifier (buffer, TYPE_IDENTIFIER (t));\n-      else\n-        print_identifier (buffer, \"{anonymous template template parameter}\");\n-      break;\n-\n-    case TYPE_DECL:\n-      if (flags & TFF_CHASE_TYPEDEF)\n-        print_type_id (buffer, tfi);\n-      else\n-        print_tree_identifier (buffer, DECL_NAME (t));\n-      break;\n-\n-    case BOUND_TEMPLATE_TEMPLATE_PARM:\n-    case TEMPLATE_DECL:\n-      print_template_id (buffer, tfi);\n-      break;\n+      plus = 0;\n+      if (*f == '%')\n+\t{\n+\t  f++;\n+\t  if (*f == '+')\n+\t    f++, plus = 1;\n+\t  if (*f == '#')\n+\t    f++;\n \n-    case TEMPLATE_TYPE_PARM:\n-      if (TYPE_IDENTIFIER (t))\n-        print_tree_identifier (buffer, TYPE_IDENTIFIER (t));\n-      else\n-        print_identifier (buffer, \"{anonymous template type parameter}\");\n-      break;\n+\t  switch (*f)\n+\t    {\n+\t      /* Just ignore these possibilities.  */\n+\t    case '%':\t\t\t\t\t\tbreak;\n+\t    case 'd':\t(void) va_arg (ap, int);\t\tbreak;\n+\t    case 's':\t(void) va_arg (ap, char *);\t\tbreak;\n+\t    case 'L':\t(void) va_arg (ap, enum languages);\tbreak;\n+\t    case 'C':\n+\t    case 'O':\n+\t    case 'Q':\t(void) va_arg (ap, enum tree_code);\tbreak;\n+\n+\t      /* These take a tree, which may be where the error is\n+\t\t located.  */\n+\t    case 'A':\n+\t    case 'D':\n+\t    case 'E':\n+\t    case 'F':\n+\t    case 'P':\n+\t    case 'T':\n+\t    case 'V':\n+\t      t = va_arg (ap, tree);\n+\t      if (!here || plus)\n+\t\there = t;\n+\t      break;\n \n-    default:\n-      break;\n+\t    default:\n+\t      errorcount = 0;  /* damn ICE suppression */\n+\t      internal_error (\"unexpected letter `%c' in locate_error\\n\", *f);\n+\t    }\n+\t}\n     }\n \n-  tree_being_formatted (tfi) = t;\n-  tree_formatting_flags (tfi) = flags;\n-}\n-\n-/* Print the elaborated-type-specifier form of a type-specifier.  */\n-static void\n-print_elaborated_type_specifier (buffer, tfi)\n-     output_buffer *buffer;\n-     tfi_t tfi;\n-{\n-  int flags = tree_formatting_flags (tfi);\n-  tree t = tree_being_formatted (tfi);\n-\n-  switch (TREE_CODE (t))\n-    {\n-    case TYPENAME_TYPE:\n-      print_identifier (buffer, \"typename\");\n-      print_whitespace (buffer, tfi);\n-      tree_formatting_flags (tfi) |= ~TFF_DECL_SPECIFIERS;\n-      print_simple_type_specifier (buffer, tfi);\n-      break;\n-\n-    case UNION_TYPE:\n-    case RECORD_TYPE:\n-      {\n-        tree name = NULL_TREE;\n-\n-        if (flags & TFF_CHASE_TYPEDEF)\n-          tree_being_formatted (tfi) = typedef_original_name (t);\n-\n-        print_identifier\n-          (buffer, class_key_or_enum (tree_being_formatted (tfi)));\n-        print_whitespace (buffer, tfi);\n+  if (here == 0)\n+    here = va_arg (ap, tree);\n \n-        name = TYPE_NAME (tree_being_formatted (tfi));\n-        if (name)\n-          {\n-            if (flags & TFF_SCOPE)\n-              {\n-                tree_being_formatted (tfi) = CP_DECL_CONTEXT (name);\n-                print_nested_name_specifier (buffer, tfi);\n-              }\n-            print_tree_identifier (buffer, DECL_NAME (name));\n-          }\n-        else\n-          print_identifier (buffer, \"{anonymous}\");\n-      }\n-      break;\n-\n-    default:\n-      sorry_for_unsupported_tree (t);\n-      break;\n-    }\n-\n-  tree_being_formatted (tfi) = t;\n-  tree_formatting_flags (tfi) = flags;\n+  return here;\n }\n \n-/* Finish the job of printing the abstract-declarator part of a\n-   type-id.  */\n-static void\n-print_rest_of_abstract_declarator (buffer, tfi)\n-     output_buffer *buffer;\n-     tfi_t tfi;\n-{\n-  tree t = tree_being_formatted (tfi);\n-  enum tree_code code = TREE_CODE (t);\n-\n-  /* An abstract-declarator has the form:\n-\n-     abstract-declarator:\n-          ptr-operator abstract-declarator(opt)\n-          direct-abstract-declarator\n-\n-     direct-abstract-declarator:\n-          direct-abstract-declarator(opt)\n-              ( parameter-declaration-clause ) cv-qualifier-seq(opt)\n-                    exception-specification(opt)\n-          direct-abstract-declarator(opt) [ constant-expression(opt) ]\n-          ( direct-abstract-declarator )   */\n-\n-  switch (code)\n-    {\n-    case ARRAY_TYPE:\n-      print_left_bracket (buffer);\n-      if (TYPE_DOMAIN (t))\n-\t{\n-          tree s = TYPE_DOMAIN (t);\n-\n-\t  if (host_integerp (TYPE_MAX_VALUE (s), 0))\n-\t    output_decimal (buffer, tree_low_cst (TYPE_MAX_VALUE (s), 0) + 1);\n-\t  else if (TREE_CODE (TYPE_MAX_VALUE (s)) == MINUS_EXPR)\n-            {\n-              tree_being_formatted (tfi) =\n-                TREE_OPERAND (TYPE_MAX_VALUE (s), 0);\n-              print_expression (buffer, tfi);\n-              tree_being_formatted (tfi) = t;\n-            }\n-\t  else\n-            {\n-              tree_being_formatted (tfi) = fold\n-                (cp_build_binary_op (PLUS_EXPR, TYPE_MAX_VALUE (s),\n-                                     integer_one_node));\n-              print_expression (buffer, tfi);\n-              tree_being_formatted (tfi) = t;\n-            }\n-\t}\n-      print_right_bracket (buffer);\n-      put_whitespace (tfi) = none;\n-      tree_being_formatted (tfi) = TREE_TYPE (t);\n-      print_rest_of_abstract_declarator (buffer, tfi);\n-      tree_being_formatted (tfi) = t;\n-      break;\n-\n-    case POINTER_TYPE:\n-    case REFERENCE_TYPE:\n-    case OFFSET_TYPE:\n-      if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n-        {\n-          output_add_character (buffer, \"&*\"[code == POINTER_TYPE]);\n-          if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n-            print_right_paren (buffer);\n-        }\n-      put_whitespace (tfi) = before;\n-      print_cv_qualifier_seq (buffer, tfi);\n-      tree_being_formatted (tfi) = TREE_TYPE (t);\n-      print_rest_of_abstract_declarator (buffer, tfi);\n-      tree_being_formatted (tfi) = t;\n-      break;\n \n-    case FUNCTION_TYPE:\n-    case METHOD_TYPE:\n-      print_right_paren (buffer);\n-      print_whitespace (buffer, tfi);\n-\n-      /* Skip the `this' implicit parameter if present.  */\n-      tree_being_formatted (tfi) = TYPE_ARG_TYPES (t);\n-      if (code == METHOD_TYPE)\n-        tree_being_formatted (tfi) = TREE_CHAIN (tree_being_formatted (tfi));\n-\n-      /* Print the parameter-list.  */\n-      print_left_paren (buffer);\n-      print_parameter_declaration_clause (buffer, tfi);\n-      print_right_paren (buffer);\n-\n-      print_whitespace (buffer, tfi);\n-\n-      if (code == METHOD_TYPE)\n-        {\n-          tree_being_formatted (tfi) =\n-            TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t)));\n-          print_cv_qualifier_seq (buffer, tfi);\n-        }\n-\n-      /* Finish the abstract-declarator.  */\n-      tree_being_formatted (tfi) = TREE_TYPE (t);\n-      print_rest_of_abstract_declarator (buffer, tfi);\n-\n-      /* Print the exception-specification for documentaion purpose.  */\n-      tree_being_formatted (tfi) = TYPE_RAISES_EXCEPTIONS (t);\n-      print_exception_specification (buffer, tfi);\n-      tree_being_formatted (tfi) = t;\n-      break;\n-\n-      /* These types don't have abstract-declarator.  */\n-    case UNKNOWN_TYPE:\n-    case IDENTIFIER_NODE:\n-    case VOID_TYPE:\n-    case INTEGER_TYPE:\n-    case REAL_TYPE:\n-    case COMPLEX_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-    case UNION_TYPE:\n-    case TYPE_DECL:\n-    case TEMPLATE_DECL:\n-    case TEMPLATE_TYPE_PARM:\n-    case TYPEOF_TYPE:\n-    case TEMPLATE_TEMPLATE_PARM:\n-    case TYPENAME_TYPE:\n-      break;\n-\n-    default:\n-      sorry_for_unsupported_tree (t);\n-      /* fall throught.  */\n-    case ERROR_MARK:\n-      break;\n-    }\n-}\n-\n-/* Print the cv-quafilers of tree_being_formatted (TFI) onto BUFFER.  */\n-static void\n-print_cv_qualifier_seq (buffer, tfi)\n-     output_buffer *buffer;\n-     tree_formatting_info *tfi;\n+void\n+cp_error_at VPARAMS ((const char *msgid, ...))\n {\n-  int cv = TYPE_QUALS (tree_being_formatted (tfi));\n-  int pad_after = after == put_whitespace (tfi);\n-  static const int mask[]\n-    = {TYPE_QUAL_CONST, TYPE_QUAL_VOLATILE, TYPE_QUAL_RESTRICT};\n-  static const char *const qualifier[]\n-    = { \"const\", \"volatile\", \"__restrict__\" };\n-\n-  if (cv != 0)\n-    {\n-      int i;\n-      for (i = 0; i != 3; ++i)\n-        if (mask[i] & cv)\n-          {\n-            if (put_whitespace (tfi) == before)\n-              output_add_space (buffer);\n-            print_identifier (buffer, qualifier[i]);\n-            put_whitespace (tfi) = before;\n-          }\n+  tree here;\n+  diagnostic_context dc;\n \n-      if (pad_after)\n-        {\n-          output_add_space (buffer);\n-          put_whitespace (tfi) = none;\n-        }\n-    }\n-}\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, const char *, msgid);\n+  here = locate_error (msgid, ap);\n+  VA_CLOSE (ap);\n \n-static void\n-print_parameter_declaration_clause (buffer, tfi)\n-     output_buffer *buffer __attribute__ ((__unused__));\n-     tfi_t tfi __attribute__ ((__unused__));\n-{\n-}\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n-static void\n-print_exception_specification (buffer, tfi)\n-     output_buffer *buffer __attribute__ ((__unused__));\n-     tfi_t tfi __attribute__ ((__unused__));\n-{\n+  set_diagnostic_context (&dc, msgid, &ap,\n+\t\t\t  cp_file_of (here),\n+\t\t\t  cp_line_of (here), /* warning = */ 0);\n+  report_diagnostic (&dc);\n+  VA_CLOSE (ap);\n }\n \n-static void\n-print_nested_name_specifier (buffer, tfi)\n-     output_buffer *buffer;\n-     tfi_t tfi;\n+void\n+cp_warning_at VPARAMS ((const char *msgid, ...))\n {\n-  int flags = tree_formatting_flags (tfi);\n-  tree t = tree_being_formatted (tfi);\n-  /* A nested-name-specifier is:\n-        class-or-namespace-name :: nested-name-specifier(opt)\n-        class-or-namespace-name :: template nested-name-specifier\n-\n-     The latter form being the correct syntax for a name  designating\n-     a template member, where the preceding class-or-namespace-name part\n-     is name-dependent.  For the time being, we do not do such a\n-     sophisticated pretty-printing.\n-\n-     class-or-namespace-name:\n-        class-name\n-        namespace-name  */\n-\n-  if (t == NULL_TREE || t == global_namespace)\n-    return;\n+  tree here;\n+  diagnostic_context dc;\n \n-  if (CLASS_TYPE_P (t) && !(flags & TFF_CLASS_SCOPE))\n-    return;\n-\n-  if (TREE_CODE (t) == NAMESPACE_DECL && !(flags & TFF_NAMESPACE_SCOPE))\n-    return;\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, const char *, msgid);\n+  here = locate_error (msgid, ap);\n+  VA_CLOSE (ap);\n \n-  tree_being_formatted (tfi) = DECL_CONTEXT (t);\n-  print_nested_name_specifier (buffer, tfi);\n-  print_scope_operator (buffer);\n-  if (TREE_CODE (t) == NAMESPACE_DECL)\n-    print_tree_identifier (buffer, DECL_NAME (t));\n-  else if (CLASS_TYPE_P (t))\n-    {\n-      if (!DECL_USE_TEMPLATE (t))\n-        print_tree_identifier (buffer, TYPE_IDENTIFIER (t));\n-      else\n-        {\n-          tree_being_formatted (tfi) = t;\n-          print_template_id (buffer, tfi);\n-        }\n-    }\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n-  tree_being_formatted (tfi) = t;\n+  set_diagnostic_context (&dc, msgid, &ap,\n+\t\t\t  cp_file_of (here),\n+\t\t\t  cp_line_of (here), /* warning = */ 1);\n+  report_diagnostic (&dc);\n+  VA_CLOSE (ap);\n }\n \n-static void\n-print_template_id (buffer, tfi)\n-     output_buffer *buffer;\n-     tfi_t tfi __attribute__ ((__unused__));\n+void\n+cp_pedwarn_at VPARAMS ((const char *msgid, ...))\n {\n-  print_template_argument_list_start (buffer);\n-  /* ... */\n-  print_template_argument_list_end (buffer);\n-}\n+  tree here;\n+  diagnostic_context dc;\n \n-static tree\n-typedef_original_name (t)\n-     tree t;\n-{\n-  return DECL_ORIGINAL_TYPE (t) ? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t);\n-}\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, const char *, msgid);\n+  here = locate_error (msgid, ap);\n+  VA_CLOSE (ap);\n \n-static void\n-print_non_consecutive_character (buffer, c)\n-     output_buffer *buffer;\n-     int c;\n-{\n-  const char *p = output_last_position (buffer);\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n-  if (p != NULL && *p == c)\n-    output_add_space (buffer);\n-  output_add_character (buffer, c);\n+  set_diagnostic_context (&dc, msgid, &ap,\n+\t\t\t  cp_file_of (here),\n+\t\t\t  cp_line_of (here),\n+\t\t\t  /* warning = */ !flag_pedantic_errors);\n+  report_diagnostic (&dc);\n+  VA_CLOSE (ap);\n }"}, {"sha": "5306c2eb9625f5188bfc51df2eeb718cb90bfc59", "filename": "gcc/errors.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Ferrors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Ferrors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ferrors.h?ref=749ced524c4a4bcb7e8374854cc380e33e69a1d8", "patch": "@@ -20,17 +20,19 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* warning, error, and fatal.  These definitions are suitable for use\n    in the generator programs; eventually we would like to use them in\n-   cc1 too, but that's a longer term project.  */\n+   cc1 too, but that's a longer term project.\n+\n+   N.B. We cannot presently use ATTRIBUTE_PRINTF with these functions,\n+   because they can be extended with additional format specifiers which\n+   GCC does not know about.  */\n \n #ifndef GCC_ERRORS_H\n #define GCC_ERRORS_H\n \n-extern void warning PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-extern void error   PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-extern void fatal   PARAMS ((const char *, ...))\n-    ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-extern void internal_error   PARAMS ((const char *, ...))\n-    ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+extern void warning PARAMS ((const char *, ...));\n+extern void error   PARAMS ((const char *, ...));\n+extern void fatal   PARAMS ((const char *, ...)) ATTRIBUTE_NORETURN;\n+extern void internal_error   PARAMS ((const char *, ...)) ATTRIBUTE_NORETURN;\n extern const char *trim_filename   PARAMS ((const char *));\n extern void fancy_abort PARAMS ((const char *, int, const char *))\n     ATTRIBUTE_NORETURN;"}, {"sha": "c2bfc03ac7f89aeee3e77ff19604119d7c27616e", "filename": "gcc/po/ChangeLog", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fpo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fpo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FChangeLog?ref=749ced524c4a4bcb7e8374854cc380e33e69a1d8", "patch": "@@ -1,11 +1,15 @@\n+2001-09-23  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* POTFILES.in: Remove cp/errfn.c.\n+\n 2001-08-01  Nick Clifton  <nickc@cambridge.redhat.com>\n \n \t* POTFILES.in: Remove chorus.h files from i386, rs6000 and sparc\n \tconfig directories.  Add config/chorus.h instead.\n \n Mon Jul  9 13:27:15 2001  Jeffrey A Law  (law@cygnus.com)\n \n-        * POTFILES.in: Add ssa-ccp.c\n+\t* POTFILES.in: Add ssa-ccp.c\n \n Thu Jun 28 16:11:30 2001  Jeffrey A Law  (law@cygnus.com)\n \n@@ -32,8 +36,8 @@ Tue Jun 19 08:03:43 2001  Jeffrey A Law  (law@cygnus.com)\n \n 2001-06-11  Zack Weinberg  <zackw@stanford.edu>\n \n-\t* Makefile.in.in: Take --defines switch off of xgettext   \n-\tcommand line.                                           \n+\t* Makefile.in.in: Take --defines switch off of xgettext\n+\tcommand line.\n \t* POTFILES.in: Massive update, removing all dead files and\n \tadding approximately 300 files which had been left out.\n \tClarify comments on what should and should not appear here.\n@@ -120,7 +124,7 @@ Thu Nov 30 01:28:08 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* POTFILES.in: Remove the files from the nuked\n \tdead ports.\n-\t* ChangeLog: Correct David's entry. \n+\t* ChangeLog: Correct David's entry.\n \n 2000-09-28  David O'Brien  <obrien@FreeBSD.org>\n \n@@ -131,7 +135,7 @@ Thu Nov 30 01:28:08 2000  Jeffrey A Law  (law@cygnus.com)\n 2000-09-26  Philipp Thomas  <pthomas@suse.de>\n \n \t* Makefile.in.in: Remove stamp-check-pot from list\n-\tof default targets as checks are only possible in a \n+\tof default targets as checks are only possible in a\n \tcomplete source tree and all languages configured.\n \n 2000-09-13  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>"}, {"sha": "d2c1c1c1a15a6fe7c2a1093f4bf4de24fb02e618", "filename": "gcc/po/POTFILES.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fpo%2FPOTFILES.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Fpo%2FPOTFILES.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FPOTFILES.in?ref=749ced524c4a4bcb7e8374854cc380e33e69a1d8", "patch": "@@ -665,7 +665,6 @@ cp/decl.c\n cp/decl.h\n cp/decl2.c\n cp/dump.c\n-cp/errfn.c\n cp/error.c\n cp/except.c\n cp/expr.c"}, {"sha": "860d49bd9d7f6384cab4af53102986c825db22e3", "filename": "gcc/toplev.h", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749ced524c4a4bcb7e8374854cc380e33e69a1d8/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=749ced524c4a4bcb7e8374854cc380e33e69a1d8", "patch": "@@ -39,10 +39,8 @@ extern void strip_off_ending\t\tPARAMS ((char *, int));\n extern void print_time\t\t\tPARAMS ((const char *, long));\n extern const char *trim_filename\tPARAMS ((const char *));\n extern void internal_error\t\tPARAMS ((const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_1\n \t\t\t\t\t       ATTRIBUTE_NORETURN;\n extern void fatal_io_error\t\tPARAMS ((const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_1\n \t\t\t\t\t       ATTRIBUTE_NORETURN;\n extern void _fatal_insn_not_found\tPARAMS ((struct rtx_def *,\n \t\t\t\t\t\tconst char *, int,\n@@ -59,34 +57,28 @@ extern void _fatal_insn\t\t\tPARAMS ((const char *,\n #define fatal_insn_not_found(insn) \\\n \t_fatal_insn_not_found (insn, __FILE__, __LINE__, __FUNCTION__)\n \n-extern void warning\t\t\tPARAMS ((const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_1;\n-extern void error\t\t\tPARAMS ((const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_1;\n+/* None of these functions are suitable for ATTRIBUTE_PRINTF, because\n+   each language front end can extend them with its own set of format\n+   specifiers.  */\n+extern void warning\t\t\tPARAMS ((const char *, ...));\n+extern void error\t\t\tPARAMS ((const char *, ...));\n extern void fatal_error\t\t\tPARAMS ((const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_NORETURN\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_1;\n-extern void pedwarn\t\t\tPARAMS ((const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_1;\n+\t\t\t\t\t       ATTRIBUTE_NORETURN;\n+extern void pedwarn\t\t\tPARAMS ((const char *, ...));\n extern void pedwarn_with_file_and_line\tPARAMS ((const char *, int,\n-\t\t\t\t\t\t const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_3;\n+\t\t\t\t\t\t const char *, ...));\n extern void warning_with_file_and_line\tPARAMS ((const char *, int,\n-\t\t\t\t\t\t const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_3;\n+\t\t\t\t\t\t const char *, ...));\n extern void error_with_file_and_line\tPARAMS ((const char *, int,\n-\t\t\t\t\t\t const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_3;\n-extern void sorry\t\t\tPARAMS ((const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_1;\n+\t\t\t\t\t\t const char *, ...));\n+extern void sorry\t\t\tPARAMS ((const char *, ...));\n extern void report_error_function\tPARAMS ((const char *));\n \n extern void rest_of_decl_compilation\tPARAMS ((union tree_node *,\n \t\t\t\t\t\tconst char *, int, int));\n extern void rest_of_type_compilation\tPARAMS ((union tree_node *, int));\n extern void rest_of_compilation\t\tPARAMS ((union tree_node *));\n \n-/* The *_with_decl functions aren't suitable for ATTRIBUTE_PRINTF. */\n extern void pedwarn_with_decl\t\tPARAMS ((union tree_node *,\n \t\t\t\t\t\t const char *, ...));\n extern void warning_with_decl\t\tPARAMS ((union tree_node *,\n@@ -97,11 +89,9 @@ extern void error_with_decl\t\tPARAMS ((union tree_node *,\n extern void announce_function\t\tPARAMS ((union tree_node *));\n \n extern void error_for_asm\t\tPARAMS ((struct rtx_def *,\n-\t\t\t\t\t\t const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_2;\n+\t\t\t\t\t\t const char *, ...));\n extern void warning_for_asm\t\tPARAMS ((struct rtx_def *,\n-\t\t\t\t\t\t const char *, ...))\n-\t\t\t\t\t       ATTRIBUTE_PRINTF_2;\n+\t\t\t\t\t\t const char *, ...));\n extern int do_float_handler PARAMS ((void (*) (PTR), PTR));\n \n #ifdef BUFSIZ\n@@ -113,6 +103,8 @@ extern void botch\t\t\tPARAMS ((const char *))\n   ATTRIBUTE_NORETURN;\n \n #ifdef BUFSIZ\n+  /* N.B. Unlike all the others, fnotice is just gettext+fprintf, and\n+     therefore it can have ATTRIBUTE_PRINTF.  */\n extern void fnotice\t\t\tPARAMS ((FILE *, const char *, ...))\n \t\t\t\t\t       ATTRIBUTE_PRINTF_2;\n #endif"}]}