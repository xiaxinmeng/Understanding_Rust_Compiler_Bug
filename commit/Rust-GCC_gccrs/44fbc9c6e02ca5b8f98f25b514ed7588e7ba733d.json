{"sha": "44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRmYmM5YzZlMDJjYTViOGY5OGYyNWI1MTRlZDc1ODhlN2JhNzMzZA==", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2020-10-30T19:05:22Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2020-10-30T19:08:23Z"}, "message": "Take insn scratch RA requirements into account in IRA.\n\n  The patch changes insn scratches which require registers for all\ninsn alternatives (in other words w/o X constraint in scratch\nconstraint string).  This is done before IRA staring its work.  LRA\nstill continue to change the rest scratches (with X constraint and in\ninsn created during IRA) into pseudos.  As before the patch at the end\nof LRA work, spilled scratch pseudos (for which X constraint was\nchosen) changed into scratches back.\n\ngcc/ChangeLog:\n\n\t* lra.c (get_scratch_reg): New function.\n\t(remove_scratches_1): Rename remove_insn_scratches.  Use\n\tira_remove_insn_scratches and get_scratch_reg.\n\t(remove_scratches): Do not\n\tinitialize scratches, scratch_bitmap, and scratch_operand_bitmap.\n\t(lra): Call ira_restore_scratches instead of restore_scratches.\n\t(struct sloc, sloc_t, scratches, scratch_bitmap)\n\t(scratch_operand_bitmap, lra_former_scratch_p)\n\t(lra_former_scratch_operand_p, lra_register_new_scratch_op)\n\t(restore_scratches): Move them to ...\n\t* ira.c: ... here.\n\t(former_scratch_p, former_scratch_operand_p): Rename to\n\tira_former_scratch_p and ira_former_scratch_operand_p.\n\t(contains_X_constraint_p): New function.\n\t(register_new_scratch_op): Rename to ira_register_new_scratch_op.\n\tChange it to work for IRA and LRA.\n\t(restore_scratches): Rename to ira_restore_scratches.\n\t(get_scratch_reg, ira_remove_insn_scratches): New functions.\n\t(ira): Call ira_remove_scratches if we use LRA.\n\t* ira.h (ira_former_scratch_p, ira_former_scratch_operand_p): New\n\tprototypes.\n\t(ira_register_new_scratch_op, ira_restore_scratches): New prototypes.\n\t(ira_remove_insn_scratches): New prototype.\n\t* lra-int.h (lra_former_scratch_p, lra_former_scratch_operand_p):\n\tRemove prototypes.\n\t(lra_register_new_scratch_op): Ditto.\n\t* lra-constraints.c: Rename lra_former_scratch_p and\n\tlra_former_scratch_p to ira_former_scratch_p and to\n\tira_former_scratch_p.\n\t* lra-remat.c: Ditto.\n\t* lra-spills.c: Rename lra_former_scratch_p to ira_former_scratch_p.", "tree": {"sha": "cb3a5a5e1fbd03203fd0a2842a6ffca63195bc51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb3a5a5e1fbd03203fd0a2842a6ffca63195bc51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdf6524bc0bfa0908a7a7c52e799dbecbebaefe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdf6524bc0bfa0908a7a7c52e799dbecbebaefe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdf6524bc0bfa0908a7a7c52e799dbecbebaefe8"}], "stats": {"total": 414, "additions": 236, "deletions": 178}, "files": [{"sha": "682d092c2f5cdbc13bbb95ddfe0e2cdd3202d4b2", "filename": "gcc/ira.c", "status": "modified", "additions": 203, "deletions": 14, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "patch": "@@ -5133,7 +5133,191 @@ move_unallocated_pseudos (void)\n \n   first_moveable_pseudo = last_moveable_pseudo = 0;\n }\n+\n+\f\n+\n+/* Code dealing with scratches (changing them onto\n+   pseudos and restoring them from the pseudos).\n+\n+   We change scratches into pseudos at the beginning of IRA to\n+   simplify dealing with them (conflicts, hard register assignments).\n+\n+   If the pseudo denoting scratch was spilled it means that we do not\n+   need a hard register for it.  Such pseudos are transformed back to\n+   scratches at the end of LRA.  */\n+\n+/* Description of location of a former scratch operand.\t */\n+struct sloc\n+{\n+  rtx_insn *insn; /* Insn where the scratch was.  */\n+  int nop;  /* Number of the operand which was a scratch.  */\n+  unsigned regno; /* regno gnerated instead of scratch */\n+  int icode;  /* Original icode from which scratch was removed.  */\n+};\n+\n+typedef struct sloc *sloc_t;\n+\n+/* Locations of the former scratches.  */\n+static vec<sloc_t> scratches;\n+\n+/* Bitmap of scratch regnos.  */\n+static bitmap_head scratch_bitmap;\n+\n+/* Bitmap of scratch operands.\t*/\n+static bitmap_head scratch_operand_bitmap;\n+\n+/* Return true if pseudo REGNO is made of SCRATCH.  */\n+bool\n+ira_former_scratch_p (int regno)\n+{\n+  return bitmap_bit_p (&scratch_bitmap, regno);\n+}\n+\n+/* Return true if the operand NOP of INSN is a former scratch.\t*/\n+bool\n+ira_former_scratch_operand_p (rtx_insn *insn, int nop)\n+{\n+  return bitmap_bit_p (&scratch_operand_bitmap,\n+\t\t       INSN_UID (insn) * MAX_RECOG_OPERANDS + nop) != 0;\n+}\n+\n+/* Register operand NOP in INSN as a former scratch.  It will be\n+   changed to scratch back, if it is necessary, at the LRA end.  */\n+void\n+ira_register_new_scratch_op (rtx_insn *insn, int nop, int icode)\n+{\n+  rtx op = *recog_data.operand_loc[nop];\n+  sloc_t loc = XNEW (struct sloc);\n+  ira_assert (REG_P (op));\n+  loc->insn = insn;\n+  loc->nop = nop;\n+  loc->regno = REGNO (op);\n+  loc->icode = icode;\n+  scratches.safe_push (loc);\n+  bitmap_set_bit (&scratch_bitmap, REGNO (op));\n+  bitmap_set_bit (&scratch_operand_bitmap,\n+\t\t  INSN_UID (insn) * MAX_RECOG_OPERANDS + nop);\n+  add_reg_note (insn, REG_UNUSED, op);\n+}\n+\n+/* Return true if string STR contains constraint 'X'.  */\n+static bool\n+contains_X_constraint_p (const char *str)\n+{\n+  int c;\n+  \n+  while ((c = *str))\n+    {\n+      str += CONSTRAINT_LEN (c, str);\n+      if (c == 'X') return true;\n+    }\n+  return false;\n+}\n+  \n+/* Change INSN's scratches into pseudos and save their location.  */\n+bool\n+ira_remove_insn_scratches (rtx_insn *insn, bool all_p, FILE *dump_file,\n+\t\t\t   rtx (*get_reg) (rtx original))\n+{\n+  int i;\n+  bool insn_changed_p;\n+  rtx reg, *loc;\n+   \n+  extract_insn (insn);\n+  insn_changed_p = false;\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      loc = recog_data.operand_loc[i];\n+      if (GET_CODE (*loc) == SCRATCH && GET_MODE (*loc) != VOIDmode)\n+\t{\n+\t  if (! all_p && contains_X_constraint_p (recog_data.constraints[i]))\n+\t    continue;\n+\t  insn_changed_p = true;\n+\t  *loc = reg = get_reg (*loc);\n+\t  ira_register_new_scratch_op (insn, i, INSN_CODE (insn));\n+\t  if (ira_dump_file != NULL)\n+\t    fprintf (dump_file,\n+\t\t     \"Removing SCRATCH to p%u in insn #%u (nop %d)\\n\",\n+\t\t     REGNO (reg), INSN_UID (insn), i);\n+\t}\n+    }\n+  return insn_changed_p;\n+}\n+\n+/* Return new register of the same mode as ORIGINAL.  Used in\n+   ira_remove_scratches.  */\n+static rtx\n+get_scratch_reg (rtx original)\n+{\n+  return gen_reg_rtx (GET_MODE (original));\n+}\n+\n+/* Change scratches into pseudos and save their location.  */\n+void\n+ira_remove_scratches (void)\n+{\n+  basic_block bb;\n+  rtx_insn *insn;\n+\n+  scratches.create (get_max_uid ());\n+  bitmap_initialize (&scratch_bitmap, &reg_obstack);\n+  bitmap_initialize (&scratch_operand_bitmap, &reg_obstack);\n+  FOR_EACH_BB_FN (bb, cfun)\n+    FOR_BB_INSNS (bb, insn)\n+    if (INSN_P (insn)\n+\t&& ira_remove_insn_scratches (insn, false, ira_dump_file, get_scratch_reg))\n+      /* Because we might use DF, we need to keep DF info up to date.  */\n+      df_insn_rescan (insn);\n+}\n+\n+/* Changes pseudos created by function remove_scratches onto scratches.\t */\n+void\n+ira_restore_scratches (FILE *dump_file)\n+{\n+  int regno, n;\n+  unsigned i;\n+  rtx *op_loc;\n+  sloc_t loc;\n+\n+  for (i = 0; scratches.iterate (i, &loc); i++)\n+    {\n+      /* Ignore already deleted insns.  */\n+      if (NOTE_P (loc->insn)\n+\t  && NOTE_KIND (loc->insn) == NOTE_INSN_DELETED)\n+\tcontinue;\n+      extract_insn (loc->insn);\n+      if (loc->icode != INSN_CODE (loc->insn))\n+\t{\n+\t  /* The icode doesn't match, which means the insn has been modified\n+\t     (e.g. register elimination).  The scratch cannot be restored.  */\n+\t  continue;\n+\t}\n+      op_loc = recog_data.operand_loc[loc->nop];\n+      if (REG_P (*op_loc)\n+\t  && ((regno = REGNO (*op_loc)) >= FIRST_PSEUDO_REGISTER)\n+\t  && reg_renumber[regno] < 0)\n+\t{\n+\t  /* It should be only case when scratch register with chosen\n+\t     constraint 'X' did not get memory or hard register.  */\n+\t  ira_assert (ira_former_scratch_p (regno));\n+\t  *op_loc = gen_rtx_SCRATCH (GET_MODE (*op_loc));\n+\t  for (n = 0; n < recog_data.n_dups; n++)\n+\t    *recog_data.dup_loc[n]\n+\t      = *recog_data.operand_loc[(int) recog_data.dup_num[n]];\n+\t  if (dump_file != NULL)\n+\t    fprintf (dump_file, \"Restoring SCRATCH in insn #%u(nop %d)\\n\",\n+\t\t     INSN_UID (loc->insn), loc->nop);\n+\t}\n+    }\n+  for (i = 0; scratches.iterate (i, &loc); i++)\n+    free (loc);\n+  scratches.release ();\n+  bitmap_clear (&scratch_bitmap);\n+  bitmap_clear (&scratch_operand_bitmap);\n+}\n+\n \f\n+\n /* If the backend knows where to allocate pseudos for hard\n    register initial values, register these allocations now.  */\n static void\n@@ -5182,8 +5366,10 @@ allocate_initial_values (void)\n \t\t\t\t\t\t  &hreg, &preg));\n     }\n }\n+\n \f\n \n+\n /* True when we use LRA instead of reload pass for the current\n    function.  */\n bool ira_use_lra_p;\n@@ -5204,6 +5390,17 @@ ira (FILE *f)\n   bool saved_flag_caller_saves = flag_caller_saves;\n   enum ira_region saved_flag_ira_region = flag_ira_region;\n \n+  if (flag_ira_verbose < 10)\n+    {\n+      internal_flag_ira_verbose = flag_ira_verbose;\n+      ira_dump_file = f;\n+    }\n+  else\n+    {\n+      internal_flag_ira_verbose = flag_ira_verbose - 10;\n+      ira_dump_file = stderr;\n+    }\n+\n   clear_bb_flags ();\n \n   /* Determine if the current function is a leaf before running IRA\n@@ -5250,17 +5447,6 @@ ira (FILE *f)\n   if (flag_caller_saves && !ira_use_lra_p)\n     init_caller_save ();\n \n-  if (flag_ira_verbose < 10)\n-    {\n-      internal_flag_ira_verbose = flag_ira_verbose;\n-      ira_dump_file = f;\n-    }\n-  else\n-    {\n-      internal_flag_ira_verbose = flag_ira_verbose - 10;\n-      ira_dump_file = stderr;\n-    }\n-\n   setup_prohibited_mode_move_regs ();\n   decrease_live_ranges_number ();\n   df_note_add_problem ();\n@@ -5305,9 +5491,6 @@ ira (FILE *f)\n   if (warn_clobbered)\n     generate_setjmp_warnings ();\n \n-  if (resize_reg_info () && flag_ira_loop_pressure)\n-    ira_set_pseudo_classes (true, ira_dump_file);\n-\n   init_alias_analysis ();\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n   reg_equiv = XCNEWVEC (struct equivalence, max_reg_num ());\n@@ -5331,6 +5514,12 @@ ira (FILE *f)\n   end_alias_analysis ();\n   free (reg_equiv);\n \n+  if (ira_use_lra_p)\n+    ira_remove_scratches ();\n+\n+  if (resize_reg_info () && flag_ira_loop_pressure)\n+    ira_set_pseudo_classes (true, ira_dump_file);\n+\n   setup_reg_equiv ();\n   grow_reg_equivs ();\n   setup_reg_equiv_init ();"}, {"sha": "c30f36aeccaee86f7a7bf0a6e724ab93c2d26a92", "filename": "gcc/ira.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "patch": "@@ -207,6 +207,13 @@ extern bool ira_bad_reload_regno (int, rtx, rtx);\n \n extern void ira_adjust_equiv_reg_cost (unsigned, int);\n \n+extern bool ira_former_scratch_p (int regno);\n+extern bool ira_former_scratch_operand_p (rtx_insn *insn, int nop);\n+extern void ira_register_new_scratch_op (rtx_insn *insn, int nop, int icode);\n+extern bool ira_remove_insn_scratches (rtx_insn *insn, bool all_p, FILE *dump_file,\n+\t\t\t\t       rtx (*get_reg) (rtx original));\n+extern void ira_restore_scratches (FILE *dump_file);\n+\n /* ira-costs.c */\n extern void ira_costs_c_finalize (void);\n "}, {"sha": "fea1ef5d144bd8a2deeee759f5798eabdb534686", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "patch": "@@ -2505,7 +2505,7 @@ process_alt_operands (int only_alternative)\n \t  while ((p += len), c);\n \n \t  scratch_p = (operand_reg[nop] != NULL_RTX\n-\t\t       && lra_former_scratch_p (REGNO (operand_reg[nop])));\n+\t\t       && ira_former_scratch_p (REGNO (operand_reg[nop])));\n \t  /* Record which operands fit this alternative.  */\n \t  if (win)\n \t    {\n@@ -4354,8 +4354,8 @@ curr_insn_transform (bool check_only_p)\n \t\t assigment pass and the scratch pseudo will be\n \t\t spilled.  Spilled scratch pseudos are transformed\n \t\t back to scratches at the LRA end.  */\n-\t      && lra_former_scratch_operand_p (curr_insn, i)\n-\t      && lra_former_scratch_p (REGNO (op)))\n+\t      && ira_former_scratch_operand_p (curr_insn, i)\n+\t      && ira_former_scratch_p (REGNO (op)))\n \t    {\n \t      int regno = REGNO (op);\n \t      lra_change_class (regno, NO_REGS, \"      Change to\", true);\n@@ -4376,7 +4376,7 @@ curr_insn_transform (bool check_only_p)\n \t      && goal_alt[i] != NO_REGS && REG_P (op)\n \t      && (regno = REGNO (op)) >= FIRST_PSEUDO_REGISTER\n \t      && regno < new_regno_start\n-\t      && ! lra_former_scratch_p (regno)\n+\t      && ! ira_former_scratch_p (regno)\n \t      && reg_renumber[regno] < 0\n \t      /* Check that the optional reload pseudo will be able to\n \t\t hold given mode value.  */"}, {"sha": "f9e99a28baac0e3d6b2f1348670c9b33ecbc4ed1", "filename": "gcc/lra-int.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "patch": "@@ -319,9 +319,6 @@ extern struct lra_insn_reg *lra_get_insn_regs (int);\n extern void lra_free_copies (void);\n extern void lra_create_copy (int, int, int);\n extern lra_copy_t lra_get_copy (int);\n-extern bool lra_former_scratch_p (int);\n-extern bool lra_former_scratch_operand_p (rtx_insn *, int);\n-extern void lra_register_new_scratch_op (rtx_insn *, int, int);\n \n extern int lra_new_regno_start;\n extern int lra_constraint_new_regno_start;"}, {"sha": "7a62c8f63e703e4f1de24cf5beae9d6bbaf1ddb0", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "patch": "@@ -1031,12 +1031,12 @@ update_scratch_ops (rtx_insn *remat_insn)\n       if (! REG_P (*loc))\n \tcontinue;\n       int regno = REGNO (*loc);\n-      if (! lra_former_scratch_p (regno))\n+      if (! ira_former_scratch_p (regno))\n \tcontinue;\n       *loc = lra_create_new_reg (GET_MODE (*loc), *loc,\n \t\t\t\t lra_get_allocno_class (regno),\n \t\t\t\t \"scratch pseudo copy\");\n-      lra_register_new_scratch_op (remat_insn, i, id->icode);\n+      ira_register_new_scratch_op (remat_insn, i, id->icode);\n     }\n   \n }"}, {"sha": "8082a5b489f7abd575ac6cbcba632717207631fd", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "patch": "@@ -446,7 +446,7 @@ remove_pseudos (rtx *loc, rtx_insn *insn)\n \t it might result in an address reload for some targets.\t In\n \t any case we transform such pseudos not getting hard registers\n \t into scratches back.  */\n-      && ! lra_former_scratch_p (i))\n+      && ! ira_former_scratch_p (i))\n     {\n       if (lra_reg_info[i].nrefs == 0\n \t  && pseudo_slots[i].mem == NULL && spill_hard_reg[i] == NULL)\n@@ -494,7 +494,7 @@ spill_pseudos (void)\n   for (i = FIRST_PSEUDO_REGISTER; i < regs_num; i++)\n     {\n       if (lra_reg_info[i].nrefs != 0 && lra_get_regno_hard_regno (i) < 0\n-\t  && ! lra_former_scratch_p (i))\n+\t  && ! ira_former_scratch_p (i))\n \t{\n \t  bitmap_set_bit (spilled_pseudos, i);\n \t  bitmap_ior_into (changed_insns, &lra_reg_info[i].insn_bitmap);\n@@ -578,7 +578,7 @@ lra_need_for_scratch_reg_p (void)\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (lra_reg_info[i].nrefs != 0 && lra_get_regno_hard_regno (i) < 0\n-\t&& lra_former_scratch_p (i))\n+\t&& ira_former_scratch_p (i))\n       return true;\n   return false;\n }\n@@ -591,7 +591,7 @@ lra_need_for_spills_p (void)\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (lra_reg_info[i].nrefs != 0 && lra_get_regno_hard_regno (i) < 0\n-\t&& ! lra_former_scratch_p (i))\n+\t&& ! ira_former_scratch_p (i))\n       return true;\n   return false;\n }\n@@ -612,7 +612,7 @@ lra_spill (void)\n   for (n = 0, i = FIRST_PSEUDO_REGISTER; i < regs_num; i++)\n     if (lra_reg_info[i].nrefs != 0 && lra_get_regno_hard_regno (i) < 0\n \t/* We do not want to assign memory for former scratches.  */\n-\t&& ! lra_former_scratch_p (i))\n+\t&& ! ira_former_scratch_p (i))\n       pseudo_regnos[n++] = i;\n   lra_assert (n > 0);\n   pseudo_slots = XNEWVEC (struct pseudo_slot, regs_num);"}, {"sha": "664f1b5e5daf759aee803aa5b837515b35133bbd", "filename": "gcc/lra.c", "status": "modified", "additions": 15, "deletions": 150, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "patch": "@@ -160,8 +160,6 @@ static void invalidate_insn_recog_data (int);\n static int get_insn_freq (rtx_insn *);\n static void invalidate_insn_data_regno_info (lra_insn_recog_data_t,\n \t\t\t\t\t     rtx_insn *, int);\n-static void remove_scratches_1 (rtx_insn *);\n-\n /* Expand all regno related info needed for LRA.  */\n static void\n expand_reg_data (int old)\n@@ -482,6 +480,8 @@ lra_emit_add (rtx x, rtx y, rtx z)\n /* The number of emitted reload insns so far.  */\n int lra_curr_reload_num;\n \n+static void remove_insn_scratches (rtx_insn *insn);\n+\n /* Emit x := y, processing special case when y = u + v or y = u + v *\n    scale + w through emit_add (Y can be an address which is base +\n    index reg * scale + displacement in general case).  X may be used\n@@ -503,7 +503,7 @@ lra_emit_move (rtx x, rtx y)\n       /* The move pattern may require scratch registers, so convert them\n \t into real registers now.  */\n       if (insn != NULL_RTX)\n-\tremove_scratches_1 (insn);\n+\tremove_insn_scratches (insn);\n       if (REG_P (x))\n \tlra_reg_info[ORIGINAL_REGNO (x)].last_reload = ++lra_curr_reload_num;\n       /* Function emit_move can create pseudos -- so expand the pseudo\n@@ -1988,170 +1988,35 @@ lra_substitute_pseudo_within_insn (rtx_insn *insn, int old_regno,\n \n \f\n \n-/* This page contains code dealing with scratches (changing them onto\n-   pseudos and restoring them from the pseudos).\n-\n-   We change scratches into pseudos at the beginning of LRA to\n-   simplify dealing with them (conflicts, hard register assignments).\n-\n-   If the pseudo denoting scratch was spilled it means that we do need\n-   a hard register for it.  Such pseudos are transformed back to\n-   scratches at the end of LRA.\t */\n-\n-/* Description of location of a former scratch operand.\t */\n-struct sloc\n+/* Return new register of the same mode as ORIGINAL of class ALL_REGS.\n+   Used in ira_remove_scratches.  */\n+static rtx\n+get_scratch_reg (rtx original)\n {\n-  rtx_insn *insn; /* Insn where the scratch was.  */\n-  int nop;  /* Number of the operand which was a scratch.  */\n-  int icode;  /* Original icode from which scratch was removed.  */\n-};\n-\n-typedef struct sloc *sloc_t;\n-\n-/* Locations of the former scratches.  */\n-static vec<sloc_t> scratches;\n-\n-/* Bitmap of scratch regnos.  */\n-static bitmap_head scratch_bitmap;\n-\n-/* Bitmap of scratch operands.\t*/\n-static bitmap_head scratch_operand_bitmap;\n-\n-/* Return true if pseudo REGNO is made of SCRATCH.  */\n-bool\n-lra_former_scratch_p (int regno)\n-{\n-  return bitmap_bit_p (&scratch_bitmap, regno);\n+  return lra_create_new_reg (GET_MODE (original), original, ALL_REGS, NULL);\n }\n \n-/* Return true if the operand NOP of INSN is a former scratch.\t*/\n-bool\n-lra_former_scratch_operand_p (rtx_insn *insn, int nop)\n-{\n-  return bitmap_bit_p (&scratch_operand_bitmap,\n-\t\t       INSN_UID (insn) * MAX_RECOG_OPERANDS + nop) != 0;\n-}\n-\n-/* Register operand NOP in INSN as a former scratch.  It will be\n-   changed to scratch back, if it is necessary, at the LRA end.  */\n-void\n-lra_register_new_scratch_op (rtx_insn *insn, int nop, int icode)\n-{\n-  lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n-  rtx op = *id->operand_loc[nop];\n-  sloc_t loc = XNEW (struct sloc);\n-  lra_assert (REG_P (op));\n-  loc->insn = insn;\n-  loc->nop = nop;\n-  loc->icode = icode;\n-  scratches.safe_push (loc);\n-  bitmap_set_bit (&scratch_bitmap, REGNO (op));\n-  bitmap_set_bit (&scratch_operand_bitmap,\n-\t\t  INSN_UID (insn) * MAX_RECOG_OPERANDS + nop);\n-  add_reg_note (insn, REG_UNUSED, op);\n-}\n-\n-/* Change INSN's scratches into pseudos and save their location.  */\n+/* Remove all insn scratches in INSN.  */\n static void\n-remove_scratches_1 (rtx_insn *insn)\n+remove_insn_scratches (rtx_insn *insn)\n {\n-  int i;\n-  bool insn_changed_p;\n-  rtx reg;\n-  lra_insn_recog_data_t id;\n-  struct lra_static_insn_data *static_id;\n-\n-  id = lra_get_insn_recog_data (insn);\n-  static_id = id->insn_static_data;\n-  insn_changed_p = false;\n-  for (i = 0; i < static_id->n_operands; i++)\n-    if (GET_CODE (*id->operand_loc[i]) == SCRATCH\n-\t&& GET_MODE (*id->operand_loc[i]) != VOIDmode)\n-      {\n-\tinsn_changed_p = true;\n-\t*id->operand_loc[i] = reg\n-\t  = lra_create_new_reg (static_id->operand[i].mode,\n-\t\t\t\t*id->operand_loc[i], ALL_REGS, NULL);\n-\tlra_register_new_scratch_op (insn, i, id->icode);\n-\tif (lra_dump_file != NULL)\n-\t  fprintf (lra_dump_file,\n-\t\t   \"Removing SCRATCH in insn #%u (nop %d)\\n\",\n-\t\t   INSN_UID (insn), i);\n-      }\n-  if (insn_changed_p)\n-    /* Because we might use DF right after caller-saves sub-pass\n-       we need to keep DF info up to date.  */\n+  if (ira_remove_insn_scratches (insn, true, lra_dump_file, get_scratch_reg))\n     df_insn_rescan (insn);\n }\n \n-/* Change scratches into pseudos and save their location.  */\n+/* Remove all insn scratches in the current function.  */\n static void\n remove_scratches (void)\n {\n   basic_block bb;\n   rtx_insn *insn;\n \n-  scratches.create (get_max_uid ());\n-  bitmap_initialize (&scratch_bitmap, &reg_obstack);\n-  bitmap_initialize (&scratch_operand_bitmap, &reg_obstack);\n   FOR_EACH_BB_FN (bb, cfun)\n     FOR_BB_INSNS (bb, insn)\n-    if (INSN_P (insn))\n-      remove_scratches_1 (insn);\n-}\n-\n-/* Changes pseudos created by function remove_scratches onto scratches.\t */\n-static void\n-restore_scratches (void)\n-{\n-  int regno;\n-  unsigned i;\n-  sloc_t loc;\n-  rtx_insn *last = NULL;\n-  lra_insn_recog_data_t id = NULL;\n-\n-  for (i = 0; scratches.iterate (i, &loc); i++)\n-    {\n-      /* Ignore already deleted insns.  */\n-      if (NOTE_P (loc->insn)\n-\t  && NOTE_KIND (loc->insn) == NOTE_INSN_DELETED)\n-\tcontinue;\n-      if (last != loc->insn)\n-\t{\n-\t  last = loc->insn;\n-\t  id = lra_get_insn_recog_data (last);\n-\t}\n-      if (loc->icode != id->icode)\n-\t{\n-\t  /* The icode doesn't match, which means the insn has been modified\n-\t     (e.g. register elimination).  The scratch cannot be restored.  */\n-\t  continue;\n-\t}\n-      if (REG_P (*id->operand_loc[loc->nop])\n-\t  && ((regno = REGNO (*id->operand_loc[loc->nop]))\n-\t      >= FIRST_PSEUDO_REGISTER)\n-\t  && lra_get_regno_hard_regno (regno) < 0)\n-\t{\n-\t  /* It should be only case when scratch register with chosen\n-\t     constraint 'X' did not get memory or hard register.  */\n-\t  lra_assert (lra_former_scratch_p (regno));\n-\t  *id->operand_loc[loc->nop]\n-\t    = gen_rtx_SCRATCH (GET_MODE (*id->operand_loc[loc->nop]));\n-\t  lra_update_dup (id, loc->nop);\n-\t  if (lra_dump_file != NULL)\n-\t    fprintf (lra_dump_file, \"Restoring SCRATCH in insn #%u(nop %d)\\n\",\n-\t\t     INSN_UID (loc->insn), loc->nop);\n-\t}\n-    }\n-  for (i = 0; scratches.iterate (i, &loc); i++)\n-    free (loc);\n-  scratches.release ();\n-  bitmap_clear (&scratch_bitmap);\n-  bitmap_clear (&scratch_operand_bitmap);\n+      if (INSN_P (insn))\n+        remove_insn_scratches (insn);\n }\n \n-\f\n-\n /* Function checks RTL for correctness.\t If FINAL_P is true, it is\n    done at the end of LRA and the check is more rigorous.  */\n static void\n@@ -2543,7 +2408,7 @@ lra (FILE *f)\n \tlra_bad_spill_regno_start = lra_constraint_new_regno_start;\n       lra_assignment_iter_after_spill = 0;\n     }\n-  restore_scratches ();\n+  ira_restore_scratches (lra_dump_file);\n   lra_eliminate (true, false);\n   lra_final_code_change ();\n   lra_in_progress = 0;"}]}