{"sha": "7432f255b70811dafaf325d94036ac580891de69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQzMmYyNTViNzA4MTFkYWZhZjMyNWQ5NDAzNmFjNTgwODkxZGU2OQ==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2020-11-16T14:58:19Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-01-15T10:37:38Z"}, "message": "arm: Auto-vectorization for MVE: vshl\n\nThis patch enables MVE vshlq instructions for auto-vectorization.\n\nThe existing mve_vshlq_n_<supf><mode> is kept, as it takes a single\nimmediate as second operand, and is used by arm_mve.h.\n\nWe move the vashl<mode>3 insn from neon.md to an expander in\nvec-common.md, and the mve_vshlq_<supf><mode> insn from mve.md to\nvec-common.md, adding the second alternative fron neon.md.\n\nmve_vshlq_<supf><mode> will be used by a later patch enabling\nvectorization for vshr, as a unified version of\nashl3<mode3>_[signed|unsigned] from neon.md. Keeping the use of unspec\nVSHLQ enables to generate both 's' and 'u' variants.\n\nIt is not clear whether the neon_shift_[reg|imm]<q> attribute is still\nsuitable, since this insn is also used for MVE.\n\nI kept the mve_vshlq_<supf><mode> naming instead of renaming it to\nashl3_<supf>_<mode> as discussed because the reference in\narm_mve_builtins.def automatically inserts the \"mve_\" prefix and I\ndidn't want to make a special case for this.\n\nI haven't yet found why the v16qi and v8hi tests are not vectorized.\nWith dest[i] = a[i] << b[i] and:\n  {\n    int i;\n    unsigned int i.24_1;\n    unsigned int _2;\n    int16_t * _3;\n    short int _4;\n    int _5;\n    int16_t * _6;\n    short int _7;\n    int _8;\n    int _9;\n    int16_t * _10;\n    short int _11;\n    unsigned int ivtmp_42;\n    unsigned int ivtmp_43;\n\n    <bb 2> [local count: 119292720]:\n\n    <bb 3> [local count: 954449105]:\n    i.24_1 = (unsigned int) i_23;\n    _2 = i.24_1 * 2;\n    _3 = a_15(D) + _2;\n    _4 = *_3;\n    _5 = (int) _4;\n    _6 = b_16(D) + _2;\n    _7 = *_6;\n    _8 = (int) _7;\n    _9 = _5 << _8;\n    _10 = dest_17(D) + _2;\n    _11 = (short int) _9;\n    *_10 = _11;\n    i_19 = i_23 + 1;\n    ivtmp_42 = ivtmp_43 - 1;\n    if (ivtmp_42 != 0)\n      goto <bb 5>; [87.50%]\n    else\n      goto <bb 4>; [12.50%]\n\n    <bb 5> [local count: 835156386]:\n    goto <bb 3>; [100.00%]\n\n    <bb 4> [local count: 119292720]:\n    return;\n\n  }\nthe vectorizer says:\nmve-vshl.c:37:96: note:   ==> examining statement: _5 = (int) _4;\nmve-vshl.c:37:96: note:   vect_is_simple_use: operand *_3, type of def: internal\nmve-vshl.c:37:96: note:   vect_is_simple_use: vectype vector(8) short int\nmve-vshl.c:37:96: missed:   conversion not supported by target.\nmve-vshl.c:37:96: note:   vect_is_simple_use: operand *_3, type of def: internal\nmve-vshl.c:37:96: note:   vect_is_simple_use: vectype vector(8) short int\nmve-vshl.c:37:96: note:   vect_is_simple_use: operand *_3, type of def: internal\nmve-vshl.c:37:96: note:   vect_is_simple_use: vectype vector(8) short int\nmve-vshl.c:37:117: missed:   not vectorized: relevant stmt not supported: _5 = (int) _4;\nmve-vshl.c:37:96: missed:  bad operation or unsupported loop bound.\nmve-vshl.c:37:96: note:  ***** Analysis failed with vector mode V8HI\n\n2020-12-03  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/\n\t* config/arm/mve.md (mve_vshlq_<supf><mode>): Move to\n\tvec-commond.md.\n\t* config/arm/neon.md (vashl<mode>3): Delete.\n\t* config/arm/vec-common.md (mve_vshlq_<supf><mode>): New.\n\t(vasl<mode>3): New expander.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/simd/mve-vshl.c: Add tests for vshl.", "tree": {"sha": "ec23a6271665f5e3c94b8da00c2e393742e34e8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec23a6271665f5e3c94b8da00c2e393742e34e8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7432f255b70811dafaf325d94036ac580891de69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7432f255b70811dafaf325d94036ac580891de69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7432f255b70811dafaf325d94036ac580891de69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7432f255b70811dafaf325d94036ac580891de69/comments", "author": null, "committer": null, "parents": [{"sha": "2ea6f4a377e51ed4d55cd8277f8c201ad66685f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ea6f4a377e51ed4d55cd8277f8c201ad66685f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ea6f4a377e51ed4d55cd8277f8c201ad66685f6"}], "stats": {"total": 116, "additions": 85, "deletions": 31}, "files": [{"sha": "89ee172471d879fd2bc21c542078971f75e78d7e", "filename": "gcc/config/arm/mve.md", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7432f255b70811dafaf325d94036ac580891de69/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7432f255b70811dafaf325d94036ac580891de69/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=7432f255b70811dafaf325d94036ac580891de69", "patch": "@@ -822,18 +822,7 @@\n \n ;;\n ;; [vshlq_s, vshlq_u])\n-;;\n-(define_insn \"mve_vshlq_<supf><mode>\"\n-  [\n-   (set (match_operand:MVE_2 0 \"s_register_operand\" \"=w\")\n-\t(unspec:MVE_2 [(match_operand:MVE_2 1 \"s_register_operand\" \"w\")\n-\t\t       (match_operand:MVE_2 2 \"s_register_operand\" \"w\")]\n-\t VSHLQ))\n-  ]\n-  \"TARGET_HAVE_MVE\"\n-  \"vshl.<supf>%#<V_sz_elem>\\t%q0, %q1, %q2\"\n-  [(set_attr \"type\" \"mve_move\")\n-])\n+;; See vec-common.md\n \n ;;\n ;; [vabdq_s, vabdq_u])"}, {"sha": "b229834b30fba5c56279866125dc91e93b126709", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7432f255b70811dafaf325d94036ac580891de69/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7432f255b70811dafaf325d94036ac580891de69/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=7432f255b70811dafaf325d94036ac580891de69", "patch": "@@ -845,25 +845,6 @@\n ; generic vectorizer code.  It ends up creating a V2DI constructor with\n ; SImode elements.\n \n-(define_insn \"vashl<mode>3\"\n-  [(set (match_operand:VDQIW 0 \"s_register_operand\" \"=w,w\")\n-\t(ashift:VDQIW (match_operand:VDQIW 1 \"s_register_operand\" \"w,w\")\n-\t\t      (match_operand:VDQIW 2 \"imm_lshift_or_reg_neon\" \"w,Dm\")))]\n-  \"TARGET_NEON\"\n-  {\n-    switch (which_alternative)\n-      {\n-        case 0: return \"vshl.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\";\n-        case 1: return neon_output_shift_immediate (\"vshl\", 'i', &operands[2],\n-                         \t\t\t    <MODE>mode,\n-\t\t\t\t\t\t    VALID_NEON_QREG_MODE (<MODE>mode),\n-\t\t\t\t\t\t    true);\n-        default: gcc_unreachable ();\n-      }\n-  }\n-  [(set_attr \"type\" \"neon_shift_reg<q>, neon_shift_imm<q>\")]\n-)\n-\n (define_insn \"vashr<mode>3_imm\"\n   [(set (match_operand:VDQIW 0 \"s_register_operand\" \"=w\")\n \t(ashiftrt:VDQIW (match_operand:VDQIW 1 \"s_register_operand\" \"w\")"}, {"sha": "5dfdf99be2dabec83342920376552c16acb1795e", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7432f255b70811dafaf325d94036ac580891de69/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7432f255b70811dafaf325d94036ac580891de69/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=7432f255b70811dafaf325d94036ac580891de69", "patch": "@@ -238,3 +238,25 @@\n  if (!neon_vector_mem_operand (adjust_mem, 2, true))\n    XEXP (adjust_mem, 0) = force_reg (Pmode, XEXP (adjust_mem, 0));\n })\n+\n+(define_insn \"mve_vshlq_<supf><mode>\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\" \"=w,w\")\n+\t(unspec:VDQIW [(match_operand:VDQIW 1 \"s_register_operand\" \"w,w\")\n+\t\t       (match_operand:VDQIW 2 \"imm_lshift_or_reg_neon\" \"w,Dm\")]\n+\t VSHLQ))]\n+  \"ARM_HAVE_<MODE>_ARITH\"\n+  \"@\n+   vshl.<supf>%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\n+   * return neon_output_shift_immediate (\\\"vshl\\\", 'i', &operands[2], <MODE>mode, VALID_NEON_QREG_MODE (<MODE>mode), true);\"\n+  [(set_attr \"type\" \"neon_shift_reg<q>, neon_shift_imm<q>\")]\n+)\n+\n+(define_expand \"vashl<mode>3\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\" \"\")\n+\t(ashift:VDQIW (match_operand:VDQIW 1 \"s_register_operand\" \"\")\n+\t\t      (match_operand:VDQIW 2 \"imm_lshift_or_reg_neon\" \"\")))]\n+  \"ARM_HAVE_<MODE>_ARITH\"\n+{\n+  emit_insn (gen_mve_vshlq_u<mode> (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n\\ No newline at end of file"}, {"sha": "7a0644997c8bdcf6ee97bc843c3da05ed8af43ff", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vshl.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7432f255b70811dafaf325d94036ac580891de69/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vshl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7432f255b70811dafaf325d94036ac580891de69/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vshl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vshl.c?ref=7432f255b70811dafaf325d94036ac580891de69", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <stdint.h>\n+\n+#define FUNC(SIGN, TYPE, BITS, NB, OP, NAME)\t\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS ## x ## NB (TYPE##BITS##_t * __restrict__ dest, TYPE##BITS##_t *a, TYPE##BITS##_t *b) { \\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i<NB; i++) {\t\t\t\t\t\t\\\n+      dest[i] = a[i] OP b[i];\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define FUNC_IMM(SIGN, TYPE, BITS, NB, OP, NAME)\t\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS ## x ## NB (TYPE##BITS##_t * __restrict__ dest, TYPE##BITS##_t *a) { \\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i<NB; i++) {\t\t\t\t\t\t\\\n+      dest[i] = a[i] OP 5;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* 64-bit vectors.  */\n+FUNC(s, int, 32, 2, <<, vshl)\n+FUNC(u, uint, 32, 2, <<, vshl)\n+FUNC(s, int, 16, 4, <<, vshl)\n+FUNC(u, uint, 16, 4, <<, vshl)\n+FUNC(s, int, 8, 8, <<, vshl)\n+FUNC(u, uint, 8, 8, <<, vshl)\n+\n+/* 128-bit vectors.  */\n+FUNC(s, int, 32, 4, <<, vshl)\n+FUNC(u, uint, 32, 4, <<, vshl)\n+FUNC(s, int, 16, 8, <<, vshl)  /* FIXME: not vectorized */\n+FUNC(u, uint, 16, 8, <<, vshl) /* FIXME: not vectorized */\n+FUNC(s, int, 8, 16, <<, vshl)  /* FIXME: not vectorized */\n+FUNC(u, uint, 8, 16, <<, vshl) /* FIXME: not vectorized */\n+\n+/* 64-bit vectors.  */\n+FUNC_IMM(s, int, 32, 2, <<, vshlimm)\n+FUNC_IMM(u, uint, 32, 2, <<, vshlimm)\n+FUNC_IMM(s, int, 16, 4, <<, vshlimm)\n+FUNC_IMM(u, uint, 16, 4, <<, vshlimm)\n+FUNC_IMM(s, int, 8, 8, <<, vshlimm)\n+FUNC_IMM(u, uint, 8, 8, <<, vshlimm)\n+\n+/* 128-bit vectors.  */\n+FUNC_IMM(s, int, 32, 4, <<, vshlimm)\n+FUNC_IMM(u, uint, 32, 4, <<, vshlimm)\n+FUNC_IMM(s, int, 16, 8, <<, vshlimm)\n+FUNC_IMM(u, uint, 16, 8, <<, vshlimm)\n+FUNC_IMM(s, int, 8, 16, <<, vshlimm)\n+FUNC_IMM(u, uint, 8, 16, <<, vshlimm)\n+\n+/* MVE has only 128-bit vectors, so we can vectorize only half of the\n+   functions above.  */\n+/* We only emit vshl.u, which is equivalent to vshl.s anyway.  */\n+/* { dg-final { scan-assembler-times {vshl.u[0-9]+\\tq[0-9]+, q[0-9]+} 2 } } */\n+\n+/* We emit vshl.i when the shift amount is an immediate.  */\n+/* { dg-final { scan-assembler-times {vshl.i[0-9]+\\tq[0-9]+, q[0-9]+} 6 } } */"}]}