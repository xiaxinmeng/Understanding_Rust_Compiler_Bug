{"sha": "4fb4e4b8be6e8c27eb777469727555fc1db3ca01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZiNGU0YjhiZTZlOGMyN2ViNzc3NDY5NzI3NTU1ZmMxZGIzY2EwMQ==", "commit": {"author": {"name": "Doug Evans", "email": "devans@gcc.gnu.org", "date": "1997-10-17T20:39:37Z"}, "committer": {"name": "Doug Evans", "email": "devans@gcc.gnu.org", "date": "1997-10-17T20:39:37Z"}, "message": "sp64-elf.h (TARGET_DEFAULT): Delete MASK_STACK_BIAS.\n\n\t* sparc/sp64-elf.h (TARGET_DEFAULT): Delete MASK_STACK_BIAS.\n\t* sparc/sparc.h (PROMOTE_MODE): Promote small ints if arch64.\n\t(PROMOTE_FUNCTION_ARGS,PROMOTE_FUNCTION_RETURN): Define.\n\t(SPARC_FIRST_FP_REG, SPARC_FP_REG_P): New macros.\n\t(SPARC_{OUTGOING,INCOMING}_INT_ARG_FIRST): New macros.\n\t(SPARC_FP_ARG_FIRST): New macro.\n\t(CONDITIONAL_REGISTER_USAGE): All v9 fp regs are volatile now.\n\t(REG_ALLOC_ORDER,REG_LEAF_ALLOC_ORDER): Reorganize fp regs.\n\t(NPARM_REGS): There are 32 fp argument registers now.\n\t(FUNCTION_ARG_REGNO_P): Likewise.\n\t(FIRST_PARM_OFFSET): Update to new v9 abi.\n\t(REG_PARM_STACK_SPACE): Define for arch64.\n\t(enum sparc_arg_class): Delete.\n\t(sparc_arg_count,sparc_n_named_args): Delete.\n\t(struct sparc_args): Redefine and use for arch32 as well as arch64.\n\t(GET_SPARC_ARG_CLASS,ROUND_REG,ROUND_ADVANCE): Delete.\n\t(FUNCTION_ARG_ADVANCE): Rewrite.\n\t(FUNCTION_ARG,FUNCTION_INCOMING_ARG): Rewrite.\n\t(FUNCTION_ARG_{PARTIAL_NREGS,PASS_BY_REFERENCE}): Rewrite.\n\t(FUNCTION_ARG_CALLEE_COPIES): Delete.\n\t(FUNCTION_ARG_{PADDING,BOUNDARY}): Define.\n\t(STRICT_ARGUMENT_NAMING): Define.\n\t(doublemove_string): Declare.\n\t* sparc/sparc.c (sparc_arg_count,sparc_n_named_args): Delete.\n\t(single_move_string): Use GEN_INT, and HOST_WIDE_INT.\n\t(doublemove_string): New function.\n\t(output_move_quad): Clean up some of the arch64 support.\n\t(compute_frame_size): Add REG_PARM_STACK_SPACE if arch64.\n\tDon't add 8 bytes of reserved space if arch64.\n\t(sparc_builtin_saveregs): Combine arch32/arch64 versions.\n\t(init_cumulative_args): New function.\n\t(function_arg_slotno): New static function.\n\t(function_arg,function_arg_partial_nregs): New functions.\n\t(function_arg_{pass_by_reference,advance}): New functions.\n\t(function_arg_padding): New function.\nFirst pass at updating to current v9 abi.\n\nFrom-SVN: r15968", "tree": {"sha": "a66dd17c6cdd2d0fdbd52a6cbac07913b75ddbba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a66dd17c6cdd2d0fdbd52a6cbac07913b75ddbba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fb4e4b8be6e8c27eb777469727555fc1db3ca01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb4e4b8be6e8c27eb777469727555fc1db3ca01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb4e4b8be6e8c27eb777469727555fc1db3ca01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb4e4b8be6e8c27eb777469727555fc1db3ca01/comments", "author": null, "committer": null, "parents": [{"sha": "941b1165c2536a4709341cb3c33e7b7c375f0d95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/941b1165c2536a4709341cb3c33e7b7c375f0d95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/941b1165c2536a4709341cb3c33e7b7c375f0d95"}], "stats": {"total": 1367, "additions": 987, "deletions": 380}, "files": [{"sha": "8ff9650f9106d0c33900ead5be45aaec20da6781", "filename": "gcc/config/sparc/sp64-elf.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb4e4b8be6e8c27eb777469727555fc1db3ca01/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb4e4b8be6e8c27eb777469727555fc1db3ca01/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h?ref=4fb4e4b8be6e8c27eb777469727555fc1db3ca01", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for SPARC64, ELF.\n-   Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Doug Evans, dje@cygnus.com.\n \n This file is part of GNU CC.\n@@ -19,7 +19,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* This is a v9 only compiler.  -mv8 is not expected to work.  If you want\n+/* This is a v9 only compiler.  -mcpu=v8 is not expected to work.  If you want\n    a v8/v9 compiler, this isn't the place to do it.  */\n \n #define SPARC_V9 1\t/* See sparc.h.  */\n@@ -35,13 +35,15 @@ Boston, MA 02111-1307, USA.  */\n #undef TARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (sparc64-elf)\")\n \n-/* A v9 compiler with stack-bias, 32 bit integers and 64 bit pointers,\n-   in a Medium/Anywhere code model environment.  */\n+/* A v9 compiler without stack-bias, lp64 sizes,\n+   in a Medium/Anywhere code model environment.\n+   There is no stack bias as this configuration is intended for\n+   embedded systems.  */\n \n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT \\\n-  (MASK_V9 + MASK_ARCH64 + MASK_PTR64 + MASK_HARD_QUAD \\\n-   + MASK_STACK_BIAS + MASK_MEDANY + MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU)\n+  (MASK_V9 + MASK_ARCH64 + MASK_PTR64 + MASK_LONG64 + MASK_HARD_QUAD \\\n+   MASK_MEDANY + MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU)\n \n /* __svr4__ is used by the C library */\n /* ??? __arch64__ is subject to change.  */\n@@ -120,6 +122,7 @@ crtbegin.o%s \\\n /* The medium/anywhere code model practically requires us to put jump tables\n    in the text section as gcc is unable to distinguish LABEL_REF's of jump\n    tables from other label refs (when we need to).  */\n+/* ??? Revisit this.  */\n #undef JUMP_TABLES_IN_TEXT_SECTION\n #define JUMP_TABLES_IN_TEXT_SECTION\n "}, {"sha": "de4ee75c82511b90f3eb2c11589ae8b6450974d8", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 827, "deletions": 171, "changes": 998, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb4e4b8be6e8c27eb777469727555fc1db3ca01/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb4e4b8be6e8c27eb777469727555fc1db3ca01/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=4fb4e4b8be6e8c27eb777469727555fc1db3ca01", "patch": "@@ -64,17 +64,6 @@ static int actual_fsize;\n \n rtx sparc_compare_op0, sparc_compare_op1;\n \n-/* Count of named arguments (v9 only).\n-   ??? INIT_CUMULATIVE_ARGS initializes these, and FUNCTION_ARG_ADVANCE\n-   increments SPARC_ARG_COUNT. They are then used by\n-   FUNCTION_ARG_CALLEE_COPIES to determine if the argument is really a named\n-   argument or not.  This hack is necessary because the NAMED argument to the\n-   FUNCTION_ARG_XXX macros is not what it says it is: it does not include the\n-   last named argument.  */\n-\n-int sparc_arg_count;\n-int sparc_n_named_args;\n-\n /* We may need an epilogue if we spill too many registers.\n    If this is non-zero, then we branch here for the epilogue.  */\n static rtx leaf_label;\n@@ -1647,7 +1636,12 @@ emit_move_sequence (operands, mode)\n }\n \f\n /* Return the best assembler insn template\n-   for moving operands[1] into operands[0] as a fullword.  */\n+   for moving operands[1] into operands[0] as a 4 byte quantity.\n+\n+   This isn't intended to be very smart.  It is up to the caller to\n+   choose the best way to do things.\n+\n+   Note that OPERANDS may be modified to suit the returned string.  */\n \n char *\n singlemove_string (operands)\n@@ -1673,7 +1667,7 @@ singlemove_string (operands)\n \n       REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n       REAL_VALUE_TO_TARGET_SINGLE (r, i);\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode, i);\n+      operands[1] = GEN_INT (i);\n \n       if (CONST_OK_FOR_LETTER_P (i, 'I'))\n \treturn \"mov %1,%0\";\n@@ -1685,10 +1679,11 @@ singlemove_string (operands)\n   else if (GET_CODE (operands[1]) == CONST_INT\n \t   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n     {\n-      int i = INTVAL (operands[1]);\n+      HOST_WIDE_INT i = INTVAL (operands[1]);\n \n       /* If all low order 10 bits are clear, then we only need a single\n \t sethi insn to load the constant.  */\n+      /* FIXME: Use SETHI_P.  */\n       if ((i & 0x000003FF) != 0)\n \treturn \"sethi %%hi(%a1),%0\\n\\tor %0,%%lo(%a1),%0\";\n       else\n@@ -1697,7 +1692,59 @@ singlemove_string (operands)\n   /* Operand 1 must be a register, or a 'I' type CONST_INT.  */\n   return \"mov %1,%0\";\n }\n-\f\n+\n+/* Return the best assembler insn template\n+   for moving operands[1] into operands[0] as an 8 byte quantity.\n+\n+   This isn't intended to be very smart.  It is up to the caller to\n+   choose the best way to do things.\n+\n+   Note that OPERANDS may be modified to suit the returned string.  */\n+\n+char *\n+doublemove_string (operands)\n+     rtx *operands;\n+{\n+  rtx op0 = operands[0], op1 = operands[1];\n+\n+  if (GET_CODE (op0) == MEM)\n+    {\n+      if (GET_CODE (op1) == REG)\n+\t{\n+\t  if (FP_REG_P (op1))\n+\t    return \"std %1,%0\";\n+\t  return TARGET_ARCH64 ? \"stx %1,%0\" : \"std %1,%0\";\n+\t}\n+      if (TARGET_ARCH64\n+\t  && (op1 == const0_rtx\n+\t      || (GET_MODE (op1) != VOIDmode\n+\t\t  && op1 == CONST0_RTX (GET_MODE (op1)))))\n+\treturn \"stx %r1,%0\";\n+      abort ();\n+    }\n+  else if (GET_CODE (op1) == MEM)\n+    {\n+      if (GET_CODE (op0) != REG)\n+\tabort ();\n+      if (FP_REG_P (op0))\n+\treturn \"ldd %1,%0\";\n+      return TARGET_ARCH64 ? \"ldx %1,%0\" : \"ldd %1,%0\";\n+    }\n+  else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    {\n+      /* ??? Unfinished, and maybe not needed.  */\n+      abort ();\n+    }\n+  else if (GET_CODE (operands[1]) == CONST_INT\n+\t   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n+    {\n+      /* ??? Unfinished, and maybe not needed.  */\n+      abort ();\n+    }\n+  /* Operand 1 must be a register, or a 'I' type CONST_INT.  */\n+  return \"mov %1,%0\";\n+}\n+\n /* Return non-zero if it is OK to assume that the given memory operand is\n    aligned at least to a 8-byte boundary.  This should only be called\n    for memory accesses whose size is 8 bytes or larger.  */\n@@ -2038,17 +2085,25 @@ output_move_quad (operands)\n \n   if (optype0 == REGOP)\n     {\n-      wordpart[0][0] = gen_rtx (REG, SImode, REGNO (op0) + 0);\n-      wordpart[1][0] = gen_rtx (REG, SImode, REGNO (op0) + 1);\n-      wordpart[2][0] = gen_rtx (REG, SImode, REGNO (op0) + 2);\n-      wordpart[3][0] = gen_rtx (REG, SImode, REGNO (op0) + 3);\n+      wordpart[0][0] = gen_rtx (REG, word_mode, REGNO (op0) + 0);\n+      wordpart[1][0] = gen_rtx (REG, word_mode, REGNO (op0) + 1);\n+      if (TARGET_ARCH32)\n+\t{\n+\t  wordpart[2][0] = gen_rtx (REG, word_mode, REGNO (op0) + 2);\n+\t  wordpart[3][0] = gen_rtx (REG, word_mode, REGNO (op0) + 3);\n+\t}\n     }\n   else if (optype0 == OFFSOP)\n     {\n       wordpart[0][0] = adj_offsettable_operand (op0, 0);\n-      wordpart[1][0] = adj_offsettable_operand (op0, 4);\n-      wordpart[2][0] = adj_offsettable_operand (op0, 8);\n-      wordpart[3][0] = adj_offsettable_operand (op0, 12);\n+      if (TARGET_ARCH32)\n+\t{\n+\t  wordpart[1][0] = adj_offsettable_operand (op0, 4);\n+\t  wordpart[2][0] = adj_offsettable_operand (op0, 8);\n+\t  wordpart[3][0] = adj_offsettable_operand (op0, 12);\n+\t}\n+      else\n+\twordpart[1][0] = adj_offsettable_operand (op0, 8);\n     }\n   else\n     {\n@@ -2060,17 +2115,25 @@ output_move_quad (operands)\n \n   if (optype1 == REGOP)\n     {\n-      wordpart[0][1] = gen_rtx (REG, SImode, REGNO (op1) + 0);\n-      wordpart[1][1] = gen_rtx (REG, SImode, REGNO (op1) + 1);\n-      wordpart[2][1] = gen_rtx (REG, SImode, REGNO (op1) + 2);\n-      wordpart[3][1] = gen_rtx (REG, SImode, REGNO (op1) + 3);\n+      wordpart[0][1] = gen_rtx (REG, word_mode, REGNO (op1) + 0);\n+      wordpart[1][1] = gen_rtx (REG, word_mode, REGNO (op1) + 1);\n+      if (TARGET_ARCH32)\n+\t{\n+\t  wordpart[2][1] = gen_rtx (REG, word_mode, REGNO (op1) + 2);\n+\t  wordpart[3][1] = gen_rtx (REG, word_mode, REGNO (op1) + 3);\n+\t}\n     }\n   else if (optype1 == OFFSOP)\n     {\n       wordpart[0][1] = adj_offsettable_operand (op1, 0);\n-      wordpart[1][1] = adj_offsettable_operand (op1, 4);\n-      wordpart[2][1] = adj_offsettable_operand (op1, 8);\n-      wordpart[3][1] = adj_offsettable_operand (op1, 12);\n+      if (TARGET_ARCH32)\n+\t{\n+\t  wordpart[1][1] = adj_offsettable_operand (op1, 4);\n+\t  wordpart[2][1] = adj_offsettable_operand (op1, 8);\n+\t  wordpart[3][1] = adj_offsettable_operand (op1, 12);\n+\t}\n+      else\n+\twordpart[1][1] = adj_offsettable_operand (op1, 8);\n     }\n   else if (optype1 == CNSTOP)\n     {\n@@ -2117,12 +2180,13 @@ output_move_quad (operands)\n \t  /* If this is a floating point register higher than %f31,\n \t     then we *must* use an aligned load, since `ld' will not accept\n \t     the register number.  */\n-\t  || (TARGET_V9 && REGNO (reg) >= 64))\n+\t  || (TARGET_V9 && REGNO (reg) >= SPARC_FIRST_V9_FP_REG))\n \t{\n \t  if (TARGET_V9 && FP_REG_P (reg) && TARGET_HARD_QUAD)\n \t    {\n \t      if ((REGNO (reg) & 3) != 0)\n \t\tabort ();\n+\t      /* ??? Can `mem' have an inappropriate alignment here?  */\n \t      return (mem == op1 ? \"ldq %1,%0\" : \"stq %1,%0\");\n \t    }\n \t  operands[2] = adj_offsettable_operand (mem, 8);\n@@ -2137,21 +2201,36 @@ output_move_quad (operands)\n   /* If the first move would clobber the source of the second one,\n      do them in the other order.  */\n \n-  /* Overlapping registers.  */\n-  if (optype0 == REGOP && optype1 == REGOP\n-      && (REGNO (op0) == REGNO (wordpart[1][3])\n-\t  || REGNO (op0) == REGNO (wordpart[1][2])\n-\t  || REGNO (op0) == REGNO (wordpart[1][1])))\n+  /* Overlapping registers?  */\n+  if (TARGET_ARCH32)\n     {\n-      /* Do fourth word.  */\n-      output_asm_insn (singlemove_string (wordpart[3]), wordpart[3]);\n-      /* Do the third word.  */\n-      output_asm_insn (singlemove_string (wordpart[2]), wordpart[2]);\n-      /* Do the second word.  */\n-      output_asm_insn (singlemove_string (wordpart[1]), wordpart[1]);\n-      /* Do lowest-numbered word.  */\n-      return singlemove_string (wordpart[0]);\n+      if (optype0 == REGOP && optype1 == REGOP\n+\t  && (REGNO (op0) == REGNO (wordpart[1][3])\n+\t      || REGNO (op0) == REGNO (wordpart[1][2])\n+\t      || REGNO (op0) == REGNO (wordpart[1][1])))\n+\t{\n+\t  /* Do fourth word.  */\n+\t  output_asm_insn (singlemove_string (wordpart[3]), wordpart[3]);\n+\t  /* Do the third word.  */\n+\t  output_asm_insn (singlemove_string (wordpart[2]), wordpart[2]);\n+\t  /* Do the second word.  */\n+\t  output_asm_insn (singlemove_string (wordpart[1]), wordpart[1]);\n+\t  /* Do lowest-numbered word.  */\n+\t  output_asm_insn (singlemove_string (wordpart[0]), wordpart[0]);\n+\t  return \"\";\n+\t}\n+    }\n+  else /* TARGET_ARCH64 */\n+    {\n+      if (optype0 == REGOP && optype1 == REGOP\n+\t  && REGNO (op0) == REGNO (wordpart[1][1]))\n+\t{\n+\t  output_asm_insn (\"mov %1,%0\", wordpart[1]);\n+\t  output_asm_insn (\"mov %1,%0\", wordpart[0]);\n+\t  return \"\";\n+\t}\n     }\n+\n   /* Loading into a register which overlaps a register used in the address.  */\n   if (optype0 == REGOP && optype1 != REGOP\n       && reg_overlap_mentioned_p (op0, op1))\n@@ -2164,42 +2243,64 @@ output_move_quad (operands)\n       abort ();\n     }\n \n-  /* Normal case: move the four words in lowest to highest address order.  */\n+  /* Normal case: move the words in lowest to highest address order.  */\n \n-  output_asm_insn (singlemove_string (wordpart[0]), wordpart[0]);\n+  if (TARGET_ARCH32)\n+    {\n+      output_asm_insn (singlemove_string (wordpart[0]), wordpart[0]);\n \n-  /* Make any unoffsettable addresses point at the second word.  */\n-  if (addreg0)\n-    output_asm_insn (\"add %0,0x4,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"add %0,0x4,%0\", &addreg1);\n+      /* Make any unoffsettable addresses point at the second word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add %0,0x4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add %0,0x4,%0\", &addreg1);\n+\n+      /* Do the second word.  */\n+      output_asm_insn (singlemove_string (wordpart[1]), wordpart[1]);\n \n-  /* Do the second word.  */\n-  output_asm_insn (singlemove_string (wordpart[1]), wordpart[1]);\n+      /* Make any unoffsettable addresses point at the third word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add %0,0x4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add %0,0x4,%0\", &addreg1);\n \n-  /* Make any unoffsettable addresses point at the third word.  */\n-  if (addreg0)\n-    output_asm_insn (\"add %0,0x4,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"add %0,0x4,%0\", &addreg1);\n+      /* Do the third word.  */\n+      output_asm_insn (singlemove_string (wordpart[2]), wordpart[2]);\n \n-  /* Do the third word.  */\n-  output_asm_insn (singlemove_string (wordpart[2]), wordpart[2]);\n+      /* Make any unoffsettable addresses point at the fourth word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add %0,0x4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add %0,0x4,%0\", &addreg1);\n \n-  /* Make any unoffsettable addresses point at the fourth word.  */\n-  if (addreg0)\n-    output_asm_insn (\"add %0,0x4,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"add %0,0x4,%0\", &addreg1);\n+      /* Do the fourth word.  */\n+      output_asm_insn (singlemove_string (wordpart[3]), wordpart[3]);\n \n-  /* Do the fourth word.  */\n-  output_asm_insn (singlemove_string (wordpart[3]), wordpart[3]);\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add %0,-0xc,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add %0,-0xc,%0\", &addreg1);\n+    }\n+  else /* TARGET_ARCH64 */\n+    {\n+      output_asm_insn (doublemove_string (wordpart[0]), wordpart[0]);\n \n-  /* Undo the adds we just did.  */\n-  if (addreg0)\n-    output_asm_insn (\"add %0,-0xc,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"add %0,-0xc,%0\", &addreg1);\n+      /* Make any unoffsettable addresses point at the second word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add %0,0x8,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add %0,0x8,%0\", &addreg1);\n+\n+      /* Do the second word.  */\n+      output_asm_insn (doublemove_string (wordpart[1]), wordpart[1]);\n+\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add %0,-0x8,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add %0,-0x8,%0\", &addreg1);\n+    }\n \n   return \"\";\n }\n@@ -2324,7 +2425,7 @@ output_sized_memop (opname, mode, signedp)\n \n   fprintf (asm_out_file, \"\\t%s%s\", opname, modename);\n }\n-\f\n+\n void\n output_move_with_extension (operands)\n      rtx *operands;\n@@ -3056,10 +3157,7 @@ compute_frame_size (size, leaf_function)\n {\n   int n_regs = 0, i;\n   int outgoing_args_size = (current_function_outgoing_args_size\n-#if ! SPARC_ARCH64\n-\t\t\t    + REG_PARM_STACK_SPACE (current_function_decl)\n-#endif\n-\t\t\t    );\n+\t\t\t    + REG_PARM_STACK_SPACE (current_function_decl));\n \n   if (TARGET_EPILOGUE)\n     {\n@@ -3106,10 +3204,9 @@ compute_frame_size (size, leaf_function)\n   /* Make sure nothing can clobber our register windows.\n      If a SAVE must be done, or there is a stack-local variable,\n      the register window area must be allocated.\n-     ??? For v9 we need an additional 8 bytes of reserved space, apparently\n-     it's needed by v8 as well.  */\n+     ??? For v8 we apparently need an additional 8 bytes of reserved space.  */\n   if (leaf_function == 0 || size > 0)\n-    actual_fsize += (16 * UNITS_PER_WORD) + 8;\n+    actual_fsize += (16 * UNITS_PER_WORD) + (TARGET_ARCH64 ? 0 : 8);\n \n   return SPARC_STACK_ALIGN (actual_fsize);\n }\n@@ -3405,105 +3502,671 @@ output_function_epilogue (file, size, leaf_function)\n       target_flags |= old_target_epilogue;\n     }\n }\n+\f\n+/* Functions for handling argument passing.\n+\n+   For v8 the first six args are normally in registers and the rest are\n+   pushed.  Any arg that starts within the first 6 words is at least\n+   partially passed in a register unless its data type forbids.\n+\n+   For v9, the argument registers are laid out as an array of 16 elements\n+   and arguments are added sequentially.  The first 6 int args and up to the\n+   first 16 fp args (depending on size) are passed in regs.\n+\n+   Slot    Stack   Integral   Float   Float in structure   Double   Long Double\n+   ----    -----   --------   -----   ------------------   ------   -----------\n+    15   [SP+248]              %f31       %f30,%f31         %d30\n+    14   [SP+240]              %f29       %f28,%f29         %d28       %q28\n+    13   [SP+232]              %f27       %f26,%f27         %d26\n+    12   [SP+224]              %f25       %f24,%f25         %d24       %q24\n+    11   [SP+216]              %f23       %f22,%f23         %d22\n+    10   [SP+208]              %f21       %f20,%f21         %d20       %q20\n+     9   [SP+200]              %f19       %f18,%f19         %d18\n+     8   [SP+192]              %f17       %f16,%f17         %d16       %q16\n+     7   [SP+184]              %f15       %f14,%f15         %d14\n+     6   [SP+176]              %f13       %f12,%f13         %d12       %q12\n+     5   [SP+168]     %o5      %f11       %f10,%f11         %d10\n+     4   [SP+160]     %o4       %f9        %f8,%f9           %d8        %q8\n+     3   [SP+152]     %o3       %f7        %f6,%f7           %d6\n+     2   [SP+144]     %o2       %f5        %f4,%f5           %d4        %q4\n+     1   [SP+136]     %o1       %f3        %f2,%f3           %d2\n+     0   [SP+128]     %o0       %f1        %f0,%f1           %d0        %q0\n+\n+   Here SP = %sp if -mno-stack-bias or %sp+stack_bias otherwise.\n+\n+   Integral arguments are always passed as 64 bit quantities appropriately\n+   extended.\n+\n+   Passing of floating point values is handled as follows.\n+   If a prototype is in scope:\n+     If the value is in a named argument (i.e. not a stdarg function or a\n+     value not part of the `...') then the value is passed in the appropriate\n+     fp reg.\n+     If the value is part of the `...' and is passed in one of the first 6\n+     slots then the value is passed in the appropriate int reg.\n+     If the value is part of the `...' and is not passed in one of the first 6\n+     slots then the value is passed in memory.\n+   If a prototype is not in scope:\n+     If the value is one of the first 6 arguments the value is passed in the\n+     appropriate integer reg and the appropriate fp reg.\n+     If the value is not one of the first 6 arguments the value is passed in\n+     the appropriate fp reg and in memory.\n+   */\n+\n+/* Maximum number of int regs for args.  */\n+#define SPARC_INT_ARG_MAX 6\n+/* Maximum number of fp regs for args.  */\n+#define SPARC_FP_ARG_MAX 16\n+\n+#define ROUND_ADVANCE(SIZE) (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Handle the INIT_CUMULATIVE_ARGS macro.\n+   Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n \n-/* Do what is necessary for `va_start'.  The argument is ignored.\n-   !v9: We look at the current function to determine if stdarg or varargs\n-   is used and return the address of the first unnamed parameter.\n-   v9: We save the argument integer and floating point regs in a buffer, and\n-   return the address of this buffer.  The rest is handled in va-sparc.h.  */\n-/* ??? This is currently conditioned on SPARC_ARCH64 because\n-   current_function_args_info is different in each compiler.  */\n+void\n+init_cumulative_args (cum, fntype, libname, indirect)\n+     CUMULATIVE_ARGS *cum;\n+     tree fntype, libname;\n+     int indirect;\n+{\n+  cum->words = 0;\n+  cum->prototype_p = fntype && TYPE_ARG_TYPES (fntype);\n+  cum->libcall_p = fntype == 0;\n+}\n \n-#if SPARC_ARCH64\n+/* Compute the slot number to pass an argument in.\n+   Returns the slot number or -1 if passing on the stack.\n+\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+   INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.\n+   *PREGNO records the register number to use if scalar type.\n+   *PPADDING records the amount of padding needed in words.  */\n+\n+static int\n+function_arg_slotno (cum, mode, type, named, incoming_p, pregno, ppadding)\n+     const CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+     int incoming_p;\n+     int *pregno;\n+     int *ppadding;\n+{\n+  int regbase = (incoming_p\n+\t\t ? SPARC_INCOMING_INT_ARG_FIRST\n+\t\t : SPARC_OUTGOING_INT_ARG_FIRST);\n+  int slotno = cum->words;\n+  int regno;\n+\n+  *ppadding = 0;\n+\n+  if (type != 0 && TREE_ADDRESSABLE (type))\n+    return -1;\n+  if (TARGET_ARCH32\n+      && type != 0 && mode == BLKmode\n+      && TYPE_ALIGN (type) % PARM_BOUNDARY != 0)\n+    return -1;\n+\n+  switch (mode)\n+    {\n+    case VOIDmode :\n+      /* MODE is VOIDmode when generating the actual call.\n+\t See emit_call_1.  */\n+      return -1;\n+\n+    case QImode : case CQImode :\n+    case HImode : case CHImode :\n+    case SImode : case CSImode :\n+    case DImode : case CDImode :\n+      if (slotno >= SPARC_INT_ARG_MAX)\n+\treturn -1;\n+      regno = regbase + slotno;\n+      break;\n+\n+    case SFmode : case SCmode :\n+    case DFmode : case DCmode :\n+    case TFmode : case TCmode :\n+      if (TARGET_ARCH32)\n+\t{\n+\t  if (slotno >= SPARC_INT_ARG_MAX)\n+\t    return -1;\n+\t  regno = regbase + slotno;\n+\t}\n+      else\n+\t{\n+\t  if ((mode == TFmode || mode == TCmode)\n+\t      && (slotno & 1) != 0)\n+\t    slotno++, *ppadding = 1;\n+\t  if (TARGET_FPU && named)\n+\t    {\n+\t      if (slotno >= SPARC_FP_ARG_MAX)\n+\t\treturn 0;\n+\t      regno = SPARC_FP_ARG_FIRST + slotno * 2;\n+\t      if (mode == SFmode)\n+\t\tregno++;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (slotno >= SPARC_INT_ARG_MAX)\n+\t\treturn -1;\n+\t      regno = regbase + slotno;\n+\t    }\n+\t}\n+      break;\n+\n+    case BLKmode :\n+      /* For sparc64, objects requiring 16 byte alignment get it.  */\n+      if (TARGET_ARCH64)\n+\t{\n+\t  if (type && TYPE_ALIGN (type) == 128 && (slotno & 1) != 0)\n+\t    slotno++, *ppadding = 1;\n+\t}\n+\n+      if (TARGET_ARCH32\n+\t  || type && TREE_CODE (type) == UNION_TYPE)\n+\t{\n+\t  if (slotno >= SPARC_INT_ARG_MAX)\n+\t    return -1;\n+\t  regno = regbase + slotno;\n+\t}\n+      else\n+\t{\n+\t  tree field;\n+\t  int intregs_p = 0, fpregs_p = 0;\n+\t  /* The ABI obviously doesn't specify how packed\n+\t     structures are passed.  These are defined to be passed\n+\t     in int regs if possible, otherwise memory.  */\n+\t  int packed_p = 0;\n+\n+\t  /* First see what kinds of registers we need.  */\n+\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t    {\n+\t      if (TREE_CODE (field) == FIELD_DECL)\n+\t\t{\n+\t\t  if (TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n+\t\t      && TARGET_FPU)\n+\t\t    fpregs_p = 1;\n+\t\t  else\n+\t\t    intregs_p = 1;\n+\t\t  if (DECL_PACKED (field))\n+\t\t    packed_p = 1;\n+\t\t}\n+\t    }\n+\t  if (packed_p || !named)\n+\t    fpregs_p = 0, intregs_p = 1;\n+\n+\t  /* If all arg slots are filled, then must pass on stack.  */\n+\t  if (fpregs_p && slotno >= SPARC_FP_ARG_MAX)\n+\t    return -1;\n+\t  /* If there are only int args and all int arg slots are filled,\n+\t     then must pass on stack.  */\n+\t  if (!fpregs_p && intregs_p && slotno >= SPARC_INT_ARG_MAX)\n+\t    return -1;\n+\t  /* Note that even if all int arg slots are filled, fp members may\n+\t     still be passed in regs if such regs are available.\n+\t     *PREGNO isn't set because there may be more than one, it's up\n+\t     to the caller to compute them.  */\n+\t  return slotno;\n+\t}\n+      break;\n+\n+    default :\n+      abort ();\n+    }\n+\n+  *pregno = regno;\n+  return slotno;\n+}\n+\n+/* Handle the FUNCTION_ARG macro.\n+   Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+   INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.  */\n \n rtx\n-sparc_builtin_saveregs (arglist)\n-     tree arglist;\n+function_arg (cum, mode, type, named, incoming_p)\n+     const CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+     int incoming_p;\n {\n-  tree fntype = TREE_TYPE (current_function_decl);\n-  /* First unnamed integer register.  */\n-  int first_intreg = current_function_args_info.arg_count[(int) SPARC_ARG_INT];\n-  /* Number of integer registers we need to save.  */\n-  int n_intregs = MAX (0, NPARM_REGS (SImode) - first_intreg);\n-  /* First unnamed SFmode float reg (no, you can't pass SFmode floats as\n-     unnamed arguments, we just number them that way).  We must round up to\n-     the next double word float reg - that is the first one to save.  */\n-  int first_floatreg = current_function_args_info.arg_count[(int) SPARC_ARG_FLOAT] + 1 & ~1;\n-  /* Number of SFmode float regs to save.  */\n-  int n_floatregs = MAX (0, NPARM_REGS (SFmode) - first_floatreg);\n-  int ptrsize = GET_MODE_SIZE (Pmode);\n-  rtx valist, regbuf, fpregs;\n-  int bufsize, adjust, regno;\n-\n-  /* Allocate block of memory for the regs.\n-     We only allocate as much as we need, but we must ensure quadword float\n-     regs are stored with the appropriate alignment.  */\n-  /* ??? If n_intregs + n_floatregs == 0, should we allocate at least 1 byte?\n-     Or can assign_stack_local accept a 0 SIZE argument?  */\n-\n-  bufsize = (n_intregs * UNITS_PER_WORD) + \n-  \t    (TARGET_FPU ? (n_floatregs * (UNITS_PER_WORD / 2)) : 0);\n-  /* Add space in front of the int regs to ensure proper alignment of quadword\n-     fp regs.  We must add the space in front because va_start assumes this.  */\n-  if (TARGET_FPU && n_floatregs >= 4)\n-    adjust = ((n_intregs + first_floatreg / 2) % 2) * UNITS_PER_WORD;\n+  int regbase = (incoming_p\n+\t\t ? SPARC_INCOMING_INT_ARG_FIRST\n+\t\t : SPARC_OUTGOING_INT_ARG_FIRST);\n+  int slotno, regno, padding;\n+  rtx reg;\n+\n+  slotno = function_arg_slotno (cum, mode, type, named, incoming_p,\n+\t\t\t\t&regno, &padding);\n+\n+  if (slotno == -1)\n+    return 0;\n+\n+  if (TARGET_ARCH32)\n+    {\n+      reg = gen_rtx (REG, mode, regno);\n+      return reg;\n+    }\n+\n+  /* v9 fp args in reg slots beyond the int reg slots get passed in regs\n+     but also have the slot allocated for them.\n+     If no prototype is in scope fp values in register slots get passed\n+     in two places, either fp regs and int regs or fp regs and memory.  */\n+  if ((GET_MODE_CLASS (mode) == MODE_FLOAT\n+       || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+      && SPARC_FP_REG_P (regno))\n+    {\n+      reg = gen_rtx (REG, mode, regno);\n+      if (cum->prototype_p || cum->libcall_p)\n+\t{\n+\t  /* \"* 2\" because fp reg numbers are recorded in 4 byte\n+\t     quantities.  */\n+\t  /* ??? This will cause the value to be passed in the fp reg and\n+\t     in the stack.  When a prototype exists we want to pass the\n+\t     value in the reg but reserve space on the stack.  That's an\n+\t     optimization, and is defered [for a bit].  */\n+\t  if ((regno - SPARC_FP_ARG_FIRST) >= SPARC_INT_ARG_MAX * 2)\n+\t    return gen_rtx (PARALLEL, mode,\n+\t\t\t    gen_rtvec (2,\n+\t\t\t\t       gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t\t\t\tNULL_RTX, const0_rtx),\n+\t\t\t\t       gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t\t\t\treg, const0_rtx)));\n+\t  else\n+\t    return reg;\n+\t}\n+      else\n+\t{\n+\t  if ((regno - SPARC_FP_ARG_FIRST) < SPARC_INT_ARG_MAX * 2)\n+\t    {\n+\t      int regbase = (incoming_p\n+\t\t\t     ? SPARC_INCOMING_INT_ARG_FIRST\n+\t\t\t     : SPARC_OUTGOING_INT_ARG_FIRST);\n+\t      int intreg = regbase + (regno - SPARC_FP_ARG_FIRST) / 2;\n+\t      return gen_rtx (PARALLEL, mode,\n+\t\t\t      gen_rtvec (2,\n+\t\t\t\t\t gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t\t\t\t  gen_rtx (REG, mode, intreg),\n+\t\t\t\t\t\t  const0_rtx),\n+\t\t\t\t\t gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t\t\t\t  reg, const0_rtx)));\n+\t    }\n+\t  else\n+\t    return gen_rtx (PARALLEL, mode,\n+\t\t\t    gen_rtvec (2,\n+\t\t\t\t       gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t\t\t\tNULL_RTX, const0_rtx),\n+\t\t\t\t       gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t\t\t\treg, const0_rtx)));\n+\t}\n+    }\n+  else if (type && TREE_CODE (type) == RECORD_TYPE)\n+    {\n+      /* Structures up to 16 bytes in size are passed in arg slots on the\n+\t stack and are promoted to registers where possible.  */\n+      tree field;\n+      rtx ret;\n+      int i;\n+      int nregs;\n+      /* Starting bit position of a sequence of integer fields, counted from\n+\t msb of left most byte, -1 if last field wasn't an int.  */\n+      /* ??? This isn't entirely necessary, some simplification\n+\t may be possible.  */\n+      int start_int_bitpos;\n+      /* Current bitpos in struct, counted from msb of left most byte.  */\n+      int bitpos, this_slotno;\n+      /* The ABI obviously doesn't specify how packed\n+\t structures are passed.  These are defined to be passed\n+\t in int regs if possible, otherwise memory.  */\n+      int packed_p = 0;\n+\n+      if (int_size_in_bytes (type) > 16)\n+\tabort (); /* shouldn't get here */\n+\n+      /* We need to compute how many registers are needed so we can allocate\n+\t the PARALLEL but before we can do that we need to know whether there\n+\t are any packed fields.  If there are, int regs are used regardless of\n+\t whether there are fp values present.  */\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t{\n+\t  if (TREE_CODE (field) == FIELD_DECL\n+\t      && DECL_PACKED (field))\n+\t    {\n+\t      packed_p = 1;\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* Compute how many registers we need.  */\n+      nregs = 0;\n+      start_int_bitpos = -1;\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t{\n+\t  bitpos = TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n+\t  this_slotno = slotno + bitpos / BITS_PER_WORD;\n+\t  if (TREE_CODE (field) == FIELD_DECL)\n+\t    {\n+\t      if (TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n+\t\t  && TARGET_FPU\n+\t\t  && ! packed_p\n+\t\t  && named)\n+\t\t{\n+\t\t  /* There's no need to check this_slotno < SPARC_FP_ARG MAX.\n+\t\t     If it wasn't true we wouldn't be here.  */\n+\t\t  nregs++;\n+\t\t  start_int_bitpos = -1;\n+\t\t}\n+\t      else if (this_slotno < SPARC_INT_ARG_MAX)\n+\t\t{\n+\t\t  if (start_int_bitpos == -1)\n+\t\t    {\n+\t\t      nregs++;\n+\t\t      start_int_bitpos = bitpos;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (bitpos % BITS_PER_WORD == 0)\n+\t\t\tnregs++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      if (nregs == 0)\n+\tabort ();\n+\n+      ret = gen_rtx (PARALLEL, BLKmode, rtvec_alloc (nregs + 1));\n+\n+      /* ??? This causes the entire struct to be passed in memory.\n+\t This isn't necessary, but is left for later.  */\n+      XVECEXP (ret, 0, 0) = gen_rtx (EXPR_LIST, VOIDmode, NULL_RTX,\n+\t\t\t\t     const0_rtx);\n+\n+      /* Fill in the entries.  */\n+      start_int_bitpos = -1;\n+      for (i = 1, field = TYPE_FIELDS (type);\n+\t   field;\n+\t   field = TREE_CHAIN (field))\n+\t{\n+\t  bitpos = TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n+\t  this_slotno = slotno + bitpos / BITS_PER_WORD;\n+\t  if (TREE_CODE (field) == FIELD_DECL)\n+\t    {\n+\t      if (TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n+\t\t  && TARGET_FPU\n+\t\t  && ! packed_p\n+\t\t  && named)\n+\t\t{\n+\t\t  reg = gen_rtx (REG, DECL_MODE (field),\n+\t\t\t\t (SPARC_FP_ARG_FIRST + this_slotno * 2\n+\t\t\t\t  + (DECL_MODE (field) == SFmode\n+\t\t\t\t     && (bitpos & 32) != 0)));\n+\t\t  XVECEXP (ret, 0, i) = gen_rtx (EXPR_LIST, VOIDmode, reg,\n+\t\t\t\t\t\t GEN_INT (bitpos / BITS_PER_UNIT));\n+\t\t  i++;\n+\t\t  start_int_bitpos = -1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (this_slotno < SPARC_INT_ARG_MAX\n+\t\t      && (start_int_bitpos == -1\n+\t\t\t  || bitpos % BITS_PER_WORD == 0))\n+\t\t    {\n+\t\t      enum machine_mode mode;\n+\n+\t\t      /* If this is the trailing part of a word, only load\n+\t\t\t that much into the register.  Otherwise load the\n+\t\t\t whole register.  Note that in the latter case we may\n+\t\t\t pick up unwanted bits.  It's not a problem at the\n+\t\t\t moment but may wish to revisit.  */\n+\t\t      if (bitpos % BITS_PER_WORD != 0)\n+\t\t\tmode = mode_for_size (BITS_PER_WORD - bitpos % BITS_PER_WORD,\n+\t\t\t\t\t      MODE_INT, 0);\n+\t\t      else\n+\t\t\tmode = word_mode;\n+\n+\t\t      regno = regbase + this_slotno;\n+\t\t      reg = gen_rtx (REG, mode, regno);\n+\t\t      XVECEXP (ret, 0, i) = gen_rtx (EXPR_LIST, VOIDmode, reg,\n+\t\t\t\t\t\t     GEN_INT (bitpos / BITS_PER_UNIT));\n+\t\t      i++;\n+\t\t      if (start_int_bitpos == -1)\n+\t\t\tstart_int_bitpos = bitpos;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      if (i != nregs + 1)\n+\tabort ();\n+\n+      return ret;\n+    }\n+  else if (type && TREE_CODE (type) == UNION_TYPE)\n+    {\n+      enum machine_mode mode;\n+      int bytes = int_size_in_bytes (type);\n+\n+      if (bytes > 16)\n+\tabort ();\n+\n+      mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 0);\n+      reg = gen_rtx (REG, mode, regno);\n+    }\n   else\n-    adjust = 0;\n+    {\n+      /* Scalar or complex int.  */\n+      reg = gen_rtx (REG, mode, regno);\n+    }\n+\n+  return reg;\n+}\n \n-  regbuf = assign_stack_local (BLKmode, bufsize + adjust,\n-\t\t\t       GET_MODE_BITSIZE (TFmode));\n-  regbuf = gen_rtx (MEM, BLKmode, plus_constant (XEXP (regbuf, 0), adjust));\n-  MEM_IN_STRUCT_P (regbuf) = 1;\n+/* Handle the FUNCTION_ARG_PARTIAL_NREGS macro.\n+   For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.\n+\n+   Any arg that starts in the first 6 regs but won't entirely fit in them\n+   needs partial registers on v8.  On v9, structures with integer\n+   values in arg slots 5,6 will be passed in %o5 and SP+176, and complex fp\n+   values that begin in the last fp reg [where \"last fp reg\" varies with the\n+   mode] will be split between that reg and memory.  */\n+\n+int\n+function_arg_partial_nregs (cum, mode, type, named)\n+     const CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  int slotno, regno, padding;\n \n-  /* Save int args.\n-     This is optimized to only save the regs that are necessary.  Explicitly\n-     named args need not be saved.  */\n+  /* We pass 0 for incoming_p here, it doesn't matter.  */\n+  slotno = function_arg_slotno (cum, mode, type, named, 0, &regno, &padding);\n \n-  if (n_intregs > 0)\n-    move_block_from_reg (BASE_INCOMING_ARG_REG (SImode) + first_intreg,\n-\t\t\t regbuf, n_intregs, n_intregs * UNITS_PER_WORD);\n+  if (slotno == -1)\n+    return 0;\n \n-  if (TARGET_FPU) \n+  if (TARGET_ARCH32)\n     {\n-      /* Save float args.\n-         This is optimized to only save the regs that are necessary.\n-\t Explicitly named args need not be saved.\n-         We explicitly build a pointer to the buffer because it halves the insn\n-         count when not optimizing (otherwise the pointer is built for each reg\n-         saved).  */\n+      if ((slotno + (mode == BLKmode\n+\t\t     ? ROUND_ADVANCE (int_size_in_bytes (type))\n+\t\t     : ROUND_ADVANCE (GET_MODE_SIZE (mode))))\n+\t  > NPARM_REGS (SImode))\n+\treturn NPARM_REGS (SImode) - slotno;\n+      return 0;\n+    }\n+  else\n+    {\n+      if (type && AGGREGATE_TYPE_P (type))\n+\t{\n+\t  int size = int_size_in_bytes (type);\n+\t  int align = TYPE_ALIGN (type);\n \n-      fpregs = gen_reg_rtx (Pmode);\n-      emit_move_insn (fpregs, plus_constant (XEXP (regbuf, 0),\n-  \t\t\t\t\t     n_intregs * UNITS_PER_WORD));\n-      for (regno = first_floatreg; regno < NPARM_REGS (SFmode); regno += 2)\n-        emit_move_insn (gen_rtx (MEM, DFmode,\n-\t\t\t         plus_constant (fpregs,\n-\t\t\t\t\t        GET_MODE_SIZE (SFmode)\n-\t\t\t\t\t        * (regno - first_floatreg))),\n-\t\t        gen_rtx (REG, DFmode,\n-\t\t\t         BASE_INCOMING_ARG_REG (DFmode) + regno));\n+\t  if (align == 16)\n+\t    slotno += slotno & 1;\n+\t  if (size > 8 && size <= 16\n+\t      && slotno == SPARC_INT_ARG_MAX - 1)\n+\t    return 1;\n+\t}\n+      else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n+\t       || (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+\t\t   && ! TARGET_FPU))\n+\t{\n+\t  if (GET_MODE_ALIGNMENT (mode) == 128)\n+\t    {\n+\t      slotno += slotno & 1;\n+\t      if (slotno == SPARC_INT_ARG_MAX - 2)\n+\t\treturn 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (slotno == SPARC_INT_ARG_MAX - 1)\n+\t\treturn 1;\n+\t    }\n+\t}\n+      else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+\t{\n+\t  if (GET_MODE_ALIGNMENT (mode) == 128)\n+\t    slotno += slotno & 1;\n+\t  if ((slotno + GET_MODE_SIZE (mode) / UNITS_PER_WORD)\n+\t      > SPARC_FP_ARG_MAX)\n+\t    return 1;\n+\t}\n+      return 0;\n     }\n+}\n+\n+/* Handle the FUNCTION_ARG_PASS_BY_REFERENCE macro.\n+   !v9: The SPARC ABI stipulates passing struct arguments (of any size) and\n+   quad-precision floats by invisible reference.\n+   v9: aggregates greater than 16 bytes are passed by reference.\n+   For Pascal, also pass arrays by reference.  */\n \n-  if (flag_check_memory_usage)\n+int\n+function_arg_pass_by_reference (cum, mode, type, named)\n+     const CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  if (TARGET_ARCH32)\n+    {\n+      return (type && AGGREGATE_TYPE_P (type)\n+\t      || mode == TFmode || mode == TCmode);\n+    }\n+  else\n     {\n-      emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3, regbuf,\n-\t\t ptr_mode, GEN_INT (n_intregs * UNITS_PER_WORD),\n-\t\t\t TYPE_MODE (sizetype), GEN_INT (MEMORY_USE_RW), QImode);\n+      return ((type && TREE_CODE (type) == ARRAY_TYPE)\n+\t      || (type && AGGREGATE_TYPE_P (type)\n+\t\t  && int_size_in_bytes (type) > 16));\n+    }\n+}\n+\n+/* Handle the FUNCTION_ARG_ADVANCE macro.\n+   Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   TYPE is null for libcalls where that information may not be available.  */\n+\n+void\n+function_arg_advance (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  int slotno, regno, padding;\n \n-      emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n-\t\t\t fpregs, ptr_mode,\n-\t\t\t GEN_INT (UNITS_PER_WORD \n-\t\t\t \t  * GET_MODE_SIZE (SFmode)\n-\t\t\t\t  * (NPARM_REGS (SFmode) - first_floatreg)),\n-\t\t\t TYPE_MODE (sizetype), GEN_INT (MEMORY_USE_RW), QImode);\n+  /* We pass 0 for incoming_p here, it doesn't matter.  */\n+  slotno = function_arg_slotno (cum, mode, type, named, 0, &regno, &padding);\n+\n+  /* If register required leading padding, add it.  */\n+  if (slotno != -1)\n+    cum->words += padding;\n+\n+  if (TARGET_ARCH32)\n+    {\n+      cum->words += (mode != BLKmode\n+\t\t     ? ROUND_ADVANCE (GET_MODE_SIZE (mode))\n+\t\t     : ROUND_ADVANCE (int_size_in_bytes (type)));\n     }\n+  else\n+    {\n+      if (type && AGGREGATE_TYPE_P (type))\n+\t{\n+\t  int size = int_size_in_bytes (type);\n+\n+\t  if (size <= 8)\n+\t    ++cum->words;\n+\t  else if (size <= 16)\n+\t    cum->words += 2;\n+\t  else /* passed by reference */\n+\t    ++cum->words;\n+\t}\n+      else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT)\n+\t{\n+\t  cum->words += 2;\n+\t}\n+      else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+\t{\n+\t  cum->words += GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n+\t}\n+      else\n+\t{\n+\t  cum->words += (mode != BLKmode\n+\t\t\t ? ROUND_ADVANCE (GET_MODE_SIZE (mode))\n+\t\t\t : ROUND_ADVANCE (int_size_in_bytes (type)));\n+\t}\n+    }\n+}\n \n-  /* Return the address of the regbuf.  */\n+/* Handle the FUNCTION_ARG_PADDING macro.\n+   For the 64 bit ABI structs are always stored left shifted in their\n+   argument slot.  */\n \n-  return XEXP (regbuf, 0);\n+enum direction\n+function_arg_padding (mode, type)\n+     enum machine_mode mode;\n+     tree type;\n+{\n+  if (TARGET_ARCH64 && type && TREE_CODE (type) == RECORD_TYPE)\n+    {\n+      return upward;\n+    }\n+\n+  /* This is the default definition.  */\n+  return (! BYTES_BIG_ENDIAN\n+\t  ? upward\n+\t  : ((mode == BLKmode\n+\t      ? (type && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t\t && int_size_in_bytes (type) < (PARM_BOUNDARY / BITS_PER_UNIT))\n+\t      : GET_MODE_BITSIZE (mode) < PARM_BOUNDARY)\n+\t     ? downward : upward));\n }\n+\f\n+/* Do what is necessary for `va_start'.  The argument is ignored.\n \n-#else /* ! SPARC_ARCH64 */\n+   We look at the current function to determine if stdarg or varargs\n+   is used and return the address of the first unnamed parameter.  */\n \n rtx\n sparc_builtin_saveregs (arglist)\n@@ -3513,41 +4176,34 @@ sparc_builtin_saveregs (arglist)\n   int stdarg = (TYPE_ARG_TYPES (fntype) != 0\n \t\t&& (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n \t\t    != void_type_node));\n-  int first_reg = current_function_args_info;\n+  int first_reg = current_function_args_info.words;\n   rtx address;\n   int regno;\n \n-#if 0 /* This code seemed to have no effect except to make\n-\t varargs not work right when va_list wasn't the first arg.  */\n-  if (! stdarg)\n-    first_reg = 0;\n-#endif\n-\n-  for (regno = first_reg; regno < NPARM_REGS (SImode); regno++)\n+  for (regno = first_reg; regno < NPARM_REGS (word_mode); regno++)\n     emit_move_insn (gen_rtx (MEM, word_mode,\n \t\t\t     gen_rtx (PLUS, Pmode,\n \t\t\t\t      frame_pointer_rtx,\n \t\t\t\t      GEN_INT (STACK_POINTER_OFFSET\n \t\t\t\t\t       + UNITS_PER_WORD * regno))),\n-\t\t    gen_rtx (REG, word_mode, BASE_INCOMING_ARG_REG (word_mode)\n-\t\t\t     + regno));\n+\t\t    gen_rtx (REG, word_mode,\n+\t\t\t     BASE_INCOMING_ARG_REG (word_mode) + regno));\n \n   address = gen_rtx (PLUS, Pmode,\n \t\t     frame_pointer_rtx,\n \t\t     GEN_INT (STACK_POINTER_OFFSET\n \t\t\t      + UNITS_PER_WORD * first_reg));\n \n-  if (flag_check_memory_usage)\n+  if (flag_check_memory_usage\n+      && first_reg < NPARM_REGS (word_mode))\n     emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t       address, ptr_mode,\n \t\t       GEN_INT (UNITS_PER_WORD \n-\t\t\t \t* (NPARM_REGS (SImode) - first_reg)),\n+\t\t\t \t* (NPARM_REGS (word_mode) - first_reg)),\n \t\t       TYPE_MODE (sizetype), GEN_INT (MEMORY_USE_RW), QImode);\n \n   return address;\n }\n-\n-#endif /* ! SPARC_ARCH64 */\n \f\n /* Return the string to output a conditional branch to LABEL, which is\n    the operand number of the label.  OP is the conditional expression."}, {"sha": "205f59b8782f13de451ca487db34f765064907c7", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 151, "deletions": 203, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb4e4b8be6e8c27eb777469727555fc1db3ca01/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb4e4b8be6e8c27eb777469727555fc1db3ca01/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=4fb4e4b8be6e8c27eb777469727555fc1db3ca01", "patch": "@@ -612,6 +612,34 @@ extern int sparc_align_funcs;\n    See also the macro `Pmode' defined below.  */\n #define POINTER_SIZE (TARGET_PTR64 ? 64 : 32)\n \n+/* A macro to update MODE and UNSIGNEDP when an object whose type\n+   is TYPE and which has the specified mode and signedness is to be\n+   stored in a register.  This macro is only called when TYPE is a\n+   scalar type.  */\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE) \\\n+if (TARGET_ARCH64\t\t\t\t\\\n+    && GET_MODE_CLASS (MODE) == MODE_INT\t\\\n+    && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\\\n+{\t\t\t\t\t\t\\\n+  (MODE) = DImode;\t\t\t\t\\\n+}\n+\n+/* Define this macro if the promotion described by PROMOTE_MODE\n+   should also be done for outgoing function arguments.  */\n+/* This is only needed for TARGET_ARCH64, but since PROMOTE_MODE is a no-op\n+   for TARGET_ARCH32 this is ok.  Otherwise we'd need to add a runtime test\n+   for this value.  */\n+#define PROMOTE_FUNCTION_ARGS\n+\n+/* Define this macro if the promotion described by PROMOTE_MODE\n+   should also be done for the return value of functions.\n+   If this macro is defined, FUNCTION_VALUE must perform the same\n+   promotions done by PROMOTE_MODE.  */\n+/* This is only needed for TARGET_ARCH64, but since PROMOTE_MODE is a no-op\n+   for TARGET_ARCH32 this is ok.  Otherwise we'd need to add a runtime test\n+   for this value.  */\n+#define PROMOTE_FUNCTION_RETURN\n+\n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY (TARGET_ARCH64 ? 64 : 32)\n \n@@ -732,9 +760,10 @@ extern int sparc_align_funcs;\n \n #define FIRST_PSEUDO_REGISTER 101\n \n+#define SPARC_FIRST_FP_REG     32\n /* Additional V9 fp regs.  */\n-#define SPARC_FIRST_V9_FP_REG 64\n-#define SPARC_LAST_V9_FP_REG  95\n+#define SPARC_FIRST_V9_FP_REG  64\n+#define SPARC_LAST_V9_FP_REG   95\n /* V9 %fcc[0123].  V8 uses (figuratively) %fcc0.  */\n #define SPARC_FIRST_V9_FCC_REG 96\n #define SPARC_LAST_V9_FCC_REG  99\n@@ -743,16 +772,28 @@ extern int sparc_align_funcs;\n /* Integer CC reg.  We don't distinguish %icc from %xcc.  */\n #define SPARC_ICC_REG 100\n \n+/* Nonzero if REGNO is an fp reg.  */\n+#define SPARC_FP_REG_P(REGNO) \\\n+((REGNO) >= SPARC_FIRST_FP_REG && (REGNO) <= SPARC_LAST_V9_FP_REG)\n+\n+/* Argument passing regs.  */\n+#define SPARC_OUTGOING_INT_ARG_FIRST 8\n+#define SPARC_INCOMING_INT_ARG_FIRST 24\n+#define SPARC_FP_ARG_FIRST           32\n+\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n+\n    On non-v9 systems:\n    g1 is free to use as temporary.\n    g2-g4 are reserved for applications.  Gcc normally uses them as\n    temporaries, but this can be disabled via the -mno-app-regs option.\n    g5 through g7 are reserved for the operating system.\n+\n    On v9 systems:\n-   g1 and g5 are free to use as temporaries.\n-   g2-g4 are reserved for applications.  Gcc normally uses them as\n+   g1,g4,g5 are free to use as temporaries.\n+   g1,g5 are free to use between calls if call is to external function via PLT.\n+   g2-g3 are reserved for applications.  Gcc normally uses them as\n    temporaries, but this can be disabled via the -mno-app-regs option.\n    g6-g7 are reserved for the operating system.\n    ??? Register 1 is used as a temporary by the 64 bit sethi pattern, so must\n@@ -819,11 +860,7 @@ do\t\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n     if (SPARC_ARCH64)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n-\tint regno;\t\t\t\t\t\t\\\n \tfixed_regs[1] = 1;\t\t\t\t\t\\\n-\t/* ??? We need to scan argv for -fcall-used-.  */\t\\\n-\tfor (regno = 48; regno < 80; regno++)\t\t\t\\\n-\t  call_used_regs[regno] = 0;\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n     if (! TARGET_V9)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n@@ -916,11 +953,12 @@ extern int sparc_mode_class[];\n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM 14\n \n-/* Actual top-of-stack address is 92/136 greater than the contents of the\n+/* Actual top-of-stack address is 92/176 greater than the contents of the\n    stack pointer register for !v9/v9.  That is:\n    - !v9: 64 bytes for the in and local registers, 4 bytes for structure return\n-     address, and 24 bytes for the 6 register parameters.\n-   - v9: 128 bytes for the in and local registers + 8 bytes reserved.  */\n+     address, and 6*4 bytes for the 6 register parameters.\n+   - v9: 128 bytes for the in and local registers + 6*8 bytes for the integer\n+     parameter regs.  */\n #define STACK_POINTER_OFFSET FIRST_PARM_OFFSET(0)\n \n /* The stack bias (amount by which the hardware register is offset by).  */\n@@ -978,11 +1016,16 @@ extern int sparc_mode_class[];\n \n /* Sparc ABI says that quad-precision floats and all structures are returned\n    in memory.\n-   For v9, all aggregates are returned in memory.  */\n+   For v9: unions <= 32 bytes in size are returned in int regs,\n+   structures up to 32 bytes are returned in int and fp regs.\n+   FIXME: wip */\n+\n #define RETURN_IN_MEMORY(TYPE)\t\t\t\t\\\n-  (TYPE_MODE (TYPE) == BLKmode\t\t\t\t\\\n-   || (! TARGET_ARCH64 && (TYPE_MODE (TYPE) == TFmode\t\\\n-\t\t\t    || TYPE_MODE (TYPE) == TCmode)))\n+(TARGET_ARCH32\t\t\t\t\t\t\\\n+ ? (TYPE_MODE (TYPE) == BLKmode\t\t\t\t\\\n+    || TYPE_MODE (TYPE) == TFmode\t\t\t\\\n+    || TYPE_MODE (TYPE) == TCmode)\t\t\t\\\n+ : TYPE_MODE (TYPE) == BLKmode)\n \n /* Functions which return large structures get the address\n    to place the wanted value at offset 64 from the frame.\n@@ -1025,7 +1068,9 @@ extern int sparc_mode_class[];\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n \n-/* The SPARC has two kinds of registers, general and floating point.\n+/* The SPARC has various kinds of registers: general, floating point,\n+   and condition codes [well, it has others as well, but none that we\n+   care directly about].\n \n    For v9 we must distinguish between the upper and lower floating point\n    registers because the upper ones can't hold SFmode values.\n@@ -1092,45 +1137,40 @@ extern enum reg_class sparc_regno_reg_class[];\n    We put %f0/%f1 last among the float registers, so as to make it more\n    likely that a pseudo-register which dies in the float return register\n    will get allocated to the float return register, thus saving a move\n-   instruction at the end of the function.\n-\n-   The float registers are ordered a little \"funny\" because in the 64 bit\n-   architecture, some of them (%f16-%f47) are call-preserved.  */\n+   instruction at the end of the function.  */\n \n #define REG_ALLOC_ORDER \\\n { 8, 9, 10, 11, 12, 13, 2, 3,\t\t\\\n   15, 16, 17, 18, 19, 20, 21, 22,\t\\\n   23, 24, 25, 26, 27, 28, 29, 31,\t\\\n   34, 35, 36, 37, 38, 39,\t\t/* %f2-%f7 */   \\\n   40, 41, 42, 43, 44, 45, 46, 47,\t/* %f8-%f15 */  \\\n-  80, 81, 82, 83, 84, 85, 86, 87,\t/* %f48-%f55 */ \\\n-  88, 89, 90, 91, 92, 93, 94, 95,\t/* %f56-%f63 */ \\\n   48, 49, 50, 51, 52, 53, 54, 55,\t/* %f16-%f23 */ \\\n   56, 57, 58, 59, 60, 61, 62, 63,\t/* %f24-%f31 */ \\\n   64, 65, 66, 67, 68, 69, 70, 71,\t/* %f32-%f39 */ \\\n   72, 73, 74, 75, 76, 77, 78, 79,\t/* %f40-%f47 */ \\\n+  80, 81, 82, 83, 84, 85, 86, 87,\t/* %f48-%f55 */ \\\n+  88, 89, 90, 91, 92, 93, 94, 95,\t/* %f56-%f63 */ \\\n   32, 33,\t\t\t\t/* %f0,%f1 */   \\\n   96, 97, 98, 99, 100,\t\t\t/* %fcc0-3, %icc */ \\\n   1, 4, 5, 6, 7, 0, 14, 30}\n \n /* This is the order in which to allocate registers for\n    leaf functions.  If all registers can fit in the \"i\" registers,\n-   then we have the possibility of having a leaf function.\n-   The floating point registers are ordered a little \"funny\" because in the\n-   64 bit architecture some of them (%f16-%f47) are call-preserved.   */\n+   then we have the possibility of having a leaf function.  */\n \n #define REG_LEAF_ALLOC_ORDER \\\n { 2, 3, 24, 25, 26, 27, 28, 29,\t\t\\\n   15, 8, 9, 10, 11, 12, 13,\t\t\\\n   16, 17, 18, 19, 20, 21, 22, 23,\t\\\n   34, 35, 36, 37, 38, 39,\t\t\\\n   40, 41, 42, 43, 44, 45, 46, 47,\t\\\n-  80, 81, 82, 83, 84, 85, 86, 87,\t\\\n-  88, 89, 90, 91, 92, 93, 94, 95,\t\\\n   48, 49, 50, 51, 52, 53, 54, 55,\t\\\n   56, 57, 58, 59, 60, 61, 62, 63,\t\\\n   64, 65, 66, 67, 68, 69, 70, 71,\t\\\n   72, 73, 74, 75, 76, 77, 78, 79,\t\\\n+  80, 81, 82, 83, 84, 85, 86, 87,\t\\\n+  88, 89, 90, 91, 92, 93, 94, 95,\t\\\n   32, 33,\t\t\t\t\\\n   96, 97, 98, 99, 100,\t\t\t\\\n   1, 4, 5, 6, 7, 0, 14, 30, 31}\n@@ -1293,13 +1333,15 @@ extern char leaf_reg_remap[];\n /* Stack layout; function entry, exit and calling.  */\n \n /* Define the number of register that can hold parameters.\n-   These two macros are used only in other macro definitions below.\n+   This macro is only used in other macro definitions below and in sparc.c.\n    MODE is the mode of the argument.\n    !v9: All args are passed in %o0-%o5.\n-   v9: Non-float args are passed in %o0-5 and float args are passed in\n-   %f0-%f15.  */\n+   v9: %o0-%o5 and %f0-%f31 are cumulatively used to pass values.\n+   See the description in sparc.c.  */\n #define NPARM_REGS(MODE) \\\n-  (TARGET_ARCH64 ? (GET_MODE_CLASS (MODE) == MODE_FLOAT ? 16 : 6) : 6)\n+(TARGET_ARCH64 \\\n+ ? (GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 6) \\\n+ : 6)\n \n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n@@ -1328,16 +1370,16 @@ extern char leaf_reg_remap[];\n /* Offset of first parameter from the argument pointer register value.\n    !v9: This is 64 for the ins and locals, plus 4 for the struct-return reg\n    even if this function isn't going to use it.\n-   v9: This is 128 for the ins and locals, plus a reserved space of 8.  */\n+   v9: This is 128 for the ins and locals.  */\n #define FIRST_PARM_OFFSET(FNDECL) \\\n-  (TARGET_ARCH64 ? (SPARC_STACK_BIAS + 136) \\\n+  (TARGET_ARCH64 ? (SPARC_STACK_BIAS + 16 * UNITS_PER_WORD) \\\n    : (STRUCT_VALUE_OFFSET + UNITS_PER_WORD))\n \n /* When a parameter is passed in a register, stack space is still\n    allocated for it.  */\n-#if ! SPARC_ARCH64\n-#define REG_PARM_STACK_SPACE(DECL) (NPARM_REGS (SImode) * UNITS_PER_WORD)\n-#endif\n+/* This only takes into account the int regs.\n+   fp regs are handled elsewhere.  */\n+#define REG_PARM_STACK_SPACE(DECL) (6 * UNITS_PER_WORD)\n \n /* Keep the stack pointer constant throughout the function.\n    This is both an optimization and a necessity: longjmp\n@@ -1427,11 +1469,12 @@ extern char leaf_reg_remap[];\n #define APPLY_RESULT_SIZE 16\n \n /* 1 if N is a possible register number for function argument passing.\n-   On SPARC, these are the \"output\" registers.  v9 also uses %f0-%f15.  */\n+   On SPARC, these are the \"output\" registers.  v9 also uses %f0-%f31.  */\n \n #define FUNCTION_ARG_REGNO_P(N) \\\n-  (TARGET_ARCH64 ? (((N) < 14 && (N) > 7) || (N) > 31 && (N) < 48) \\\n-   : ((N) < 14 && (N) > 7))\n+(TARGET_ARCH64 \\\n+ ? (((N) >= 8 && (N) <= 13) || ((N) >= 32 && (N) <= 63)) \\\n+ : ((N) >= 8 && (N) <= 13))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -1444,129 +1487,30 @@ extern char leaf_reg_remap[];\n    if any, which holds the structure-value-address).\n    Thus 7 or more means all following args should go on the stack.\n \n-   For v9, we record how many of each type has been passed.  Different\n-   types get passed differently.\n-\n-\t- Float args are passed in %f0-15, after which they go to the stack\n-\t  where floats and doubles are passed 8 byte aligned and long doubles\n-\t  are passed 16 byte aligned.\n-\t- All aggregates are passed by reference.  The callee copies\n-\t  the structure if necessary, except if stdarg/varargs and the struct\n-\t  matches the ellipse in which case the caller makes a copy.\n-\t- Any non-float argument might be split between memory and reg %o5.\n-\t  ??? I don't think this can ever happen now that structs are no\n-\t  longer passed in regs.\n-\n-   For v9 return values:\n-\n-\t- For all aggregates, the caller allocates space for the return value,\n-          and passes the pointer as an implicit first argument, which is\n-          allocated like all other arguments.\n-\t- The unimp instruction stuff for structure returns is gone.  */\n+   For v9, we also need to know whether a prototype is present.  */\n \n-#if SPARC_ARCH64\n-enum sparc_arg_class { SPARC_ARG_INT = 0, SPARC_ARG_FLOAT = 1 };\n struct sparc_args {\n-    int arg_count[2];\t/* must be int! (for __builtin_args_info) */\n+  int words;       /* number of words passed so far */\n+  int prototype_p; /* non-zero if a prototype is present */\n+  int libcall_p;   /* non-zero if a library call */\n };\n #define CUMULATIVE_ARGS struct sparc_args\n \n-/* Return index into CUMULATIVE_ARGS.  */\n-\n-#define GET_SPARC_ARG_CLASS(MODE) \\\n-  (GET_MODE_CLASS (MODE) == MODE_FLOAT ? SPARC_ARG_FLOAT : SPARC_ARG_INT)\n-\n-/* Round a register number up to a proper boundary for an arg of mode MODE.\n-   This macro is only used in this file.\n-\n-   The \"& (0x10000 - ...)\" is used to round up to the next appropriate reg.  */\n-\n-#define ROUND_REG(CUM, MODE)\t\t\t\t\\\n-  (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\\\n-   ? (CUM).arg_count[(int) GET_SPARC_ARG_CLASS (MODE)]\t\\\n-   : ((CUM).arg_count[(int) GET_SPARC_ARG_CLASS (MODE)]\t\\\n-      + GET_MODE_UNIT_SIZE (MODE) / 4 - 1)\t\t\\\n-     & (0x10000 - GET_MODE_UNIT_SIZE (MODE) / 4))\n-\n-#define ROUND_ADVANCE(SIZE)\t\\\n-  (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-#else /* ! SPARC_ARCH64 */\n-\n-#define CUMULATIVE_ARGS int\n-\n-#define ROUND_REG(CUM, MODE) (CUM)\n-\n-#define ROUND_ADVANCE(SIZE)\t\\\n-  ((SIZE + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-#endif /* ! SPARC_ARCH64 */\n-\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On SPARC, the offset always starts at 0: the first parm reg is always\n-   the same reg.  */\n+   For a library call, FNTYPE is 0.  */\n \n-#if SPARC_ARCH64\n-extern int sparc_arg_count,sparc_n_named_args;\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    (CUM).arg_count[(int) SPARC_ARG_INT] = 0;\t\t\t\\\n-    (CUM).arg_count[(int) SPARC_ARG_FLOAT] = 0;\t\t\t\\\n-    sparc_arg_count = 0;\t\t\t\t\t\\\n-    sparc_n_named_args =\t\t\t\t\t\\\n-      ((FNTYPE) && TYPE_ARG_TYPES (FNTYPE)\t\t\t\\\n-       ? (list_length (TYPE_ARG_TYPES (FNTYPE))\t\t\t\\\n-\t  + (TREE_CODE (TREE_TYPE (FNTYPE)) == RECORD_TYPE\t\\\n-\t     || TREE_CODE (TREE_TYPE (FNTYPE)) == QUAL_UNION_TYPE\\\n-\t     || TREE_CODE (TREE_TYPE (FNTYPE)) == SET_TYPE\t\\\n-\t     || TREE_CODE (TREE_TYPE (FNTYPE)) == UNION_TYPE))\t\\\n-       /* Can't tell, treat 'em all as named.  */\t\t\\\n-       : 10000);\t\t\t\t\t\t\\\n-  } while (0)\n-#else\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT) ((CUM) = 0)\n-#endif\n+extern void init_cumulative_args ();\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT) \\\n+init_cumulative_args (& (CUM), (FNTYPE), (LIBNAME), (INDIRECT));\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#if SPARC_ARCH64\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    (CUM).arg_count[(int) GET_SPARC_ARG_CLASS (MODE)] =\t\t\\\n-      ROUND_REG ((CUM), (MODE))\t\t\t\t\t\\\n-\t+ (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n-\t   ? GET_MODE_SIZE (MODE) / 4\t\t\t\t\\\n-\t   : ROUND_ADVANCE ((MODE) == BLKmode\t\t\t\\\n-\t\t\t    ? GET_MODE_SIZE (Pmode)\t\t\\\n-\t\t\t    : GET_MODE_SIZE (MODE)));\t\t\\\n-    sparc_arg_count++;\t\t\t\t\t\t\\\n-  } while (0)\n-#else\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-  ((CUM) += ((MODE) != BLKmode\t\t\t\t\\\n-\t     ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\\\n-\t     : ROUND_ADVANCE (int_size_in_bytes (TYPE))))\n-#endif\n+   TYPE is null for libcalls where that information may not be available.  */\n \n-/* Return boolean indicating arg of mode MODE will be passed in a reg.\n-   This macro is only used in this file.  */\n-\n-#if SPARC_ARCH64\n-#define PASS_IN_REG_P(CUM, MODE, TYPE)\t\t\t\t\\\n-  (ROUND_REG ((CUM), (MODE)) < NPARM_REGS (MODE)\t\t\\\n-   && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\\\n-   && ((TYPE)==0 || (MODE) != BLKmode))\n-#else\n-#define PASS_IN_REG_P(CUM, MODE, TYPE)\t\t\t\t\\\n-  ((CUM) < NPARM_REGS (SImode)\t\t\t\t\t\\\n-   && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\\\n-   && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\\\n-       || (TYPE_ALIGN (TYPE) % PARM_BOUNDARY == 0)))\n-#endif\n+extern void function_arg_advance ();\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n+function_arg_advance (& (CUM), (MODE), (TYPE), (NAMED))\n \n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n@@ -1581,64 +1525,52 @@ extern int sparc_arg_count,sparc_n_named_args;\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-/* On SPARC the first six args are normally in registers\n-   and the rest are pushed.  Any arg that starts within the first 6 words\n-   is at least partially passed in a register unless its data type forbids.\n-   For v9, the first 6 int args are passed in regs and the first N\n-   float args are passed in regs (where N is such that %f0-15 are filled).\n-   The rest are pushed.  Any arg that starts within the first 6 words\n-   is at least partially passed in a register unless its data type forbids.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t\\\n-  (PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n-   ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n-\t      (BASE_PASSING_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))))\\\n-   : 0)\n+extern struct rtx_def *function_arg ();\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+function_arg (& (CUM), (MODE), (TYPE), (NAMED), 0)\n \n /* Define where a function finds its arguments.\n    This is different from FUNCTION_ARG because of register windows.  */\n \n-#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-  (PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n-   ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n-\t      (BASE_INCOMING_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))))\\\n-   : 0)\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n+function_arg (& (CUM), (MODE), (TYPE), (NAMED), 1)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.\n-   Any arg that starts in the first 6 regs but won't entirely fit in them\n-   needs partial registers on the Sparc (!v9).  On v9, there are no arguments\n-   that are passed partially in registers (??? complex values?).  */\n-\n-#if ! SPARC_ARCH64\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \t\t\\\n-  (PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n-   && ((CUM) + ((MODE) == BLKmode\t\t\t\t\t\\\n-\t\t? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\t\\\n-\t\t: ROUND_ADVANCE (GET_MODE_SIZE (MODE))) - NPARM_REGS (SImode) > 0)\\\n-   ? (NPARM_REGS (SImode) - (CUM))\t\t\t\t\t\\\n-   : 0)\n-#endif\n-\n-/* The SPARC ABI stipulates passing struct arguments (of any size) and\n-   (!v9) quad-precision floats by invisible reference.\n-   For Pascal, also pass arrays by reference.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n-  ((TYPE && AGGREGATE_TYPE_P (TYPE))\t\t\t\t\\\n-   || (!TARGET_ARCH64 && MODE == TFmode))\n-\n-/* A C expression that indicates when it is the called function's\n-   responsibility to make copies of arguments passed by reference.\n-   If the callee can determine that the argument won't be modified, it can\n-   avoid the copy.  */\n-/* ??? We'd love to be able to use NAMED here.  Unfortunately, it doesn't\n-   include the last named argument so we keep track of the args ourselves.  */\n-\n-#if SPARC_ARCH64\n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n-  (sparc_arg_count < sparc_n_named_args)\n-#endif\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+extern int function_arg_partial_nregs ();\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+function_arg_partial_nregs (& (CUM), (MODE), (TYPE), (NAMED))\n+\n+/* A C expression that indicates when an argument must be passed by reference.\n+   If nonzero for an argument, a copy of that argument is made in memory and a\n+   pointer to the argument is passed instead of the argument itself.\n+   The pointer is passed in whatever way is appropriate for passing a pointer\n+   to that type.  */\n+\n+extern int function_arg_pass_by_reference ();\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n+function_arg_pass_by_reference (& (CUM), (MODE), (TYPE), (NAMED))\n+\n+/* If defined, a C expression which determines whether, and in which direction,\n+   to pad out an argument with extra space.  The value should be of type\n+   `enum direction': either `upward' to pad above the argument,\n+   `downward' to pad below, or `none' to inhibit padding.  */\n+extern enum direction function_arg_padding ();\n+#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n+function_arg_padding ((MODE), (TYPE))\n+\n+/* If defined, a C expression that gives the alignment boundary, in bits,\n+   of an argument with the specified mode and type.  If it is not defined,\n+   PARM_BOUNDARY is used for all arguments.\n+   For sparc64, objects requiring 16 byte alignment are passed that way.  */\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n+((TARGET_ARCH64\t\t\t\t\t\\\n+  && (GET_MODE_ALIGNMENT (MODE) == 128\t\t\\\n+      || ((TYPE) && TYPE_ALIGN (TYPE) == 128)))\t\\\n+ ? 128 : PARM_BOUNDARY)\n \f\n /* Initialize data used by insn expanders.  This is called from\n    init_emit, once for each function, before code is generated.\n@@ -2133,6 +2065,7 @@ extern union tree_node *current_function_decl;\n      nop\n      .xword context\n      .xword function  */\n+/* ??? Stack is execute-protected in v9.  */\n \n #define TRAMPOLINE_TEMPLATE(FILE) \\\n do {\t\t\t\t\t\t\t\t\t\\\n@@ -2177,9 +2110,24 @@ void sparc64_initialize_trampoline ();\n \f\n /* Generate necessary RTL for __builtin_saveregs().\n    ARGLIST is the argument list; see expr.c.  */\n+\n extern struct rtx_def *sparc_builtin_saveregs ();\n #define EXPAND_BUILTIN_SAVEREGS(ARGLIST) sparc_builtin_saveregs (ARGLIST)\n \n+/* Define this macro if the location where a function argument is passed\n+   depends on whether or not it is a named argument.\n+\n+   This macro controls how the NAMED argument to FUNCTION_ARG\n+   is set for varargs and stdarg functions.  With this macro defined,\n+   the NAMED argument is always true for named arguments, and false for\n+   unnamed arguments.  If this is not defined, but SETUP_INCOMING_VARARGS\n+   is defined, then all arguments are treated as named.  Otherwise, all named\n+   arguments except the last are treated as named.\n+   For the v9 we want NAMED to mean what it says it means.  */\n+/* ??? This needn't be set for v8, but I don't want to make this runtime\n+   selectable if I don't have to.  */\n+#define STRICT_ARGUMENT_NAMING\n+\n /* Generate RTL to flush the register windows so as to make arbitrary frames\n    available.  */\n #define SETUP_FRAME_ADDRESSES()\t\t\\\n@@ -2717,8 +2665,7 @@ extern struct rtx_def *legitimize_pic_address ();\n     return 8;\n \n /* Compute the cost of an address.  For the sparc, all valid addresses are\n-   the same cost.\n-   ??? Is this true for v9?  */\n+   the same cost.  */\n \n #define ADDRESS_COST(RTX)  1\n \n@@ -3186,6 +3133,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Declare functions defined in sparc.c and used in templates.  */\n \n extern char *singlemove_string ();\n+extern char *doublemove_string ();\n extern char *output_move_double ();\n extern char *output_move_quad ();\n extern char *output_fp_move_double ();"}]}