{"sha": "80dddedcaf316e1a1f3346c9cbda719b40fd28a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBkZGRlZGNhZjMxNmUxYTFmMzM0NmM5Y2JkYTcxOWI0MGZkMjhhNQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-06-22T10:06:39Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-06-22T10:06:39Z"}, "message": "std_istream.h (ignore(streamsize __n = 1, int_type __delim = traits_type::eof())): Split into...\n\n2004-06-22  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/std/std_istream.h (ignore(streamsize __n = 1,\n\tint_type __delim = traits_type::eof())): Split into...\n\t(ignore(), ignore(streamsize __n), ignore(streamsize __n,\n\tint_type __delim)): The first two can be much more simpler\n\tand efficient than the fully general case; also, the last\n\ttwo can take advantage of the same mechanism already used\n\tfor getline.\n\t* include/bits/istream.tcc (ignore(streamsize __n = 1,\n\tint_type __delim = traits_type::eof()): Remove.\n\t(ignore(), ignore(streamsize __n), ignore(streamsize __n,\n\tint_type __delim)): New.\n\nFrom-SVN: r83486", "tree": {"sha": "5f2d938ba07c066da1ee25f22e88ae358b32679f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f2d938ba07c066da1ee25f22e88ae358b32679f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80dddedcaf316e1a1f3346c9cbda719b40fd28a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80dddedcaf316e1a1f3346c9cbda719b40fd28a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80dddedcaf316e1a1f3346c9cbda719b40fd28a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80dddedcaf316e1a1f3346c9cbda719b40fd28a5/comments", "author": null, "committer": null, "parents": [{"sha": "39bc18760f4b039c6fc89f98a132183b8371a751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39bc18760f4b039c6fc89f98a132183b8371a751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39bc18760f4b039c6fc89f98a132183b8371a751"}], "stats": {"total": 152, "additions": 144, "deletions": 8}, "files": [{"sha": "7e0b5e7c1bf37a71e30033c13b55463b8c40bf4c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80dddedcaf316e1a1f3346c9cbda719b40fd28a5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80dddedcaf316e1a1f3346c9cbda719b40fd28a5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=80dddedcaf316e1a1f3346c9cbda719b40fd28a5", "patch": "@@ -1,3 +1,17 @@\n+2004-06-22  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/std/std_istream.h (ignore(streamsize __n = 1,\n+\tint_type __delim = traits_type::eof())): Split into...\n+\t(ignore(), ignore(streamsize __n), ignore(streamsize __n,\n+\tint_type __delim)): The first two can be much more simpler\n+\tand efficient than the fully general case; also, the last\n+\ttwo can take advantage of the same mechanism already used\n+\tfor getline.\n+\t* include/bits/istream.tcc (ignore(streamsize __n = 1,\n+\tint_type __delim = traits_type::eof()): Remove.\n+\t(ignore(), ignore(streamsize __n), ignore(streamsize __n,\n+\tint_type __delim)): New.\n+\n 2004-06-21  Loren J. Rittle  <ljrittle@acm.org>\n \n \t* config/linker-map.gnu: Use wildcards for"}, {"sha": "59a44de10ddc226e75934cd3fdca2d0e5e07ceed", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 117, "deletions": 6, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80dddedcaf316e1a1f3346c9cbda719b40fd28a5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80dddedcaf316e1a1f3346c9cbda719b40fd28a5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=80dddedcaf316e1a1f3346c9cbda719b40fd28a5", "patch": "@@ -641,33 +641,144 @@ namespace std\n       return *this;\n     }\n \n+  // We provide three overloads, since the first two are much simpler\n+  // than the general case. Also, the latter two can thus adopt the\n+  // same \"batchy\" strategy used by getline above.\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    ignore(void)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb)\n+\t{\n+\t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n+\t  try\n+\t    {\n+\t      const int_type __eof = traits_type::eof();\n+\t      __streambuf_type* __sb = this->rdbuf();\n+\n+\t      if (traits_type::eq_int_type(__sb->sbumpc(), __eof))\n+\t\t__err |= ios_base::eofbit;\n+\t      else\n+\t\t_M_gcount = 1;\n+\t    }\n+\t  catch(...)\n+\t    { this->_M_setstate(ios_base::badbit); }\n+\t  if (__err)\n+\t    this->setstate(__err);\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    ignore(streamsize __n)\n+    {\n+      if (__n == 1)\n+\treturn ignore();\n+      \n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb && __n > 0)\n+\t{\n+\t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n+\t  try\n+\t    {\n+\t      const int_type __eof = traits_type::eof();\n+\t      __streambuf_type* __sb = this->rdbuf();\n+\t      int_type __c = __sb->sgetc();\n+\t      \n+\t      const bool __bound = __n != numeric_limits<streamsize>::max();\n+\t      if (__bound)\n+\t\t--__n;\n+\t      while (_M_gcount <= __n\n+\t\t     && !traits_type::eq_int_type(__c, __eof))\n+\t\t{\n+\t\t  streamsize __size = __sb->egptr() - __sb->gptr();\n+\t\t  if (__bound)\n+\t\t    __size = std::min(__size, streamsize(__n - _M_gcount + 1));\n+\n+\t\t  if (__size > 1)\n+\t\t    {\n+\t\t      __sb->gbump(__size);\n+\t\t      _M_gcount += __size;\n+\t\t      __c = __sb->sgetc();\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      ++_M_gcount;\n+\t\t      __c = __sb->snextc();\n+\t\t    }\t\t  \n+\t\t}\n+\t      if (traits_type::eq_int_type(__c, __eof))\n+\t\t__err |= ios_base::eofbit;\n+\t    }\n+\t  catch(...)\n+\t    { this->_M_setstate(ios_base::badbit); }\n+\t  if (__err)\n+\t    this->setstate(__err);\n+\t}\n+      return *this;\n+    }\n+\n   template<typename _CharT, typename _Traits>\n     basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     ignore(streamsize __n, int_type __delim)\n     {\n+      if (traits_type::eq_int_type(__delim, traits_type::eof()))\n+\treturn ignore(__n);\n+\n       _M_gcount = 0;\n       sentry __cerb(*this, true);\n       if (__cerb && __n > 0)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n \t  try\n \t    {\n+\t      const char_type __cdelim = traits_type::to_char_type(__delim);\t      \n \t      const int_type __eof = traits_type::eof();\n \t      __streambuf_type* __sb = this->rdbuf();\n-\t      int_type __c = __eof;\n+\t      int_type __c = __sb->sgetc();\n \n-\t      if (__n != numeric_limits<streamsize>::max())\n+\t      const bool __bound = __n != numeric_limits<streamsize>::max();\n+\t      if (__bound)\n \t\t--__n;\n \t      while (_M_gcount <= __n\n-\t\t     && !traits_type::eq_int_type(__c = __sb->sbumpc(), __eof))\n+\t\t     && !traits_type::eq_int_type(__c, __eof)\n+\t\t     && !traits_type::eq_int_type(__c, __delim))\n \t\t{\n-\t\t  ++_M_gcount;\n-\t\t  if (traits_type::eq_int_type(__c, __delim))\n-\t\t    break;\n+\t\t  streamsize __size = __sb->egptr() - __sb->gptr();\n+\t\t  if (__bound)\n+\t\t    __size = std::min(__size, streamsize(__n - _M_gcount + 1));\n+\n+\t\t  if (__size > 1)\n+\t\t    {\n+\t\t      const char_type* __p = traits_type::find(__sb->gptr(),\n+\t\t\t\t\t\t\t       __size,\n+\t\t\t\t\t\t\t       __cdelim);\n+\t\t      if (__p)\n+\t\t\t__size = __p - __sb->gptr();\n+\t\t      __sb->gbump(__size);\n+\t\t      _M_gcount += __size;\n+\t\t      __c = __sb->sgetc();\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      ++_M_gcount;\n+\t\t      __c = __sb->snextc();\n+\t\t    }\t\t  \n \t\t}\n \t      if (traits_type::eq_int_type(__c, __eof))\n \t\t__err |= ios_base::eofbit;\n+\t      else if (traits_type::eq_int_type(__c, __delim))\n+\t\t{\n+\t\t  ++_M_gcount;\n+\t\t  __sb->sbumpc();\n+\t\t}\n \t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }"}, {"sha": "65f9e6c30345466f51083456e02e892f3952344b", "filename": "libstdc++-v3/include/std/std_istream.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80dddedcaf316e1a1f3346c9cbda719b40fd28a5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_istream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80dddedcaf316e1a1f3346c9cbda719b40fd28a5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_istream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_istream.h?ref=80dddedcaf316e1a1f3346c9cbda719b40fd28a5", "patch": "@@ -1,6 +1,6 @@\n // Input streams -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003\n+// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2004\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -412,9 +412,20 @@ namespace std\n        *  - the next character equals @a delim (in this case, the character\n        *    is extracted); note that this condition will never occur if\n        *    @a delim equals @c traits::eof().\n+       *\n+       *  NB: Provide three overloads, instead of the single function\n+       *  (with defaults) mandated by the Standard: this leads to a\n+       *  better performing implementation, while still conforming to\n+       *  the Standard.\n       */\n       __istream_type& \n-      ignore(streamsize __n = 1, int_type __delim = traits_type::eof());\n+      ignore();\n+\n+      __istream_type& \n+      ignore(streamsize __n);\n+\n+      __istream_type& \n+      ignore(streamsize __n, int_type __delim);\n       \n       /**\n        *  @brief  Looking ahead in the stream"}]}