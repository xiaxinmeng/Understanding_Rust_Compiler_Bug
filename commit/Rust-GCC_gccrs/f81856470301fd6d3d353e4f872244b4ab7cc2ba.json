{"sha": "f81856470301fd6d3d353e4f872244b4ab7cc2ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgxODU2NDcwMzAxZmQ2ZDNkMzUzZTRmODcyMjQ0YjRhYjdjYzJiYQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2005-09-05T07:58:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T07:58:52Z"}, "message": "sem_ch10.adb (In_Chain): Moved from the scope of a subprogram to become local to the whole package.\n\n2005-09-01  Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch10.adb (In_Chain): Moved from the scope of a subprogram to\n\tbecome local to the whole package.\n\t(Install_Limited_Withed_Unit): Instead of unchaining real entities if\n\tthe package was already analyzed the new algorithm \"replaces\" the\n\treal entities by the shadow ones. This is required to ensure that\n\tthe order of these entities in the homonym chains does not change;\n\totherwise we can have undefined references at linking time because\n\tin case of conflicts the external name of the entities will have\n\ta suffix that depends on the order of the entities in the chain.\n\t(Remove_Limited_With_Clause): Complementary code that completes the\n\tnew algorithm and replaces the shadow entities by the real ones.\n\t(Install_Limited_Withed_Unit): When unchaining entities before the\n\tinstallation of the shadow entities, only regular entities of the\n\tpublic part must be taken into account. This is required to\n\tkeep this routine in synch with the work done by Remove_Limited_\n\tWith_Clause\n\t(Install_Limited_With_Clause): Introduce implicit limited_with_clause\n\teven if unit is analyzed, because the analysis of the unit is\n\tidempotent in any case, and the limited view of the unit may have to\n\tbe installed for proper visibility.\n\t(Expand_Limited_With_Clause): Even if the unit in the implicit\n\twith_clause has been analyzed already, a limited view of the package\n\tmust be built for the current context, if it does not exist yet.\n\nFrom-SVN: r103878", "tree": {"sha": "ea05b1ec4808816d48656a0904fecb317ef753c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea05b1ec4808816d48656a0904fecb317ef753c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f81856470301fd6d3d353e4f872244b4ab7cc2ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f81856470301fd6d3d353e4f872244b4ab7cc2ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f81856470301fd6d3d353e4f872244b4ab7cc2ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f81856470301fd6d3d353e4f872244b4ab7cc2ba/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0835f1d7fa977a52e01042f657ed3c988933f61f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0835f1d7fa977a52e01042f657ed3c988933f61f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0835f1d7fa977a52e01042f657ed3c988933f61f"}], "stats": {"total": 564, "additions": 316, "deletions": 248}, "files": [{"sha": "b752eb495aa38c643d05248a0404cf2fcafa5449", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 316, "deletions": 248, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f81856470301fd6d3d353e4f872244b4ab7cc2ba/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f81856470301fd6d3d353e4f872244b4ab7cc2ba/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=f81856470301fd6d3d353e4f872244b4ab7cc2ba", "patch": "@@ -115,6 +115,10 @@ package body Sem_Ch10 is\n    --  If the main unit is a child unit, implicit withs are also added for\n    --  all its ancestors.\n \n+   function In_Chain (E : Entity_Id) return Boolean;\n+   --  Check that the shadow entity is not already in the homonym chain, for\n+   --  example through a limited_with clause in a parent unit.\n+\n    procedure Install_Context_Clauses (N : Node_Id);\n    --  Subsidiary to Install_Context and Install_Parents. Process only with_\n    --  and use_clauses for current unit and its library unit if any.\n@@ -811,7 +815,6 @@ package body Sem_Ch10 is\n          if Nkind (Item) = N_With_Clause\n            and then not Limited_Present (Item)\n          then\n-\n             --  Skip analyzing with clause if no unit, nothing to do (this\n             --  happens for a with that references a non-existant unit)\n \n@@ -853,14 +856,11 @@ package body Sem_Ch10 is\n \n                if Ukind /= N_Package_Declaration\n                  and then Ukind /= N_Subprogram_Declaration\n-                 and then Ukind /= N_Subprogram_Renaming_Declaration\n-                 and then Ukind /= N_Generic_Package_Declaration\n-                 and then Ukind /= N_Generic_Package_Renaming_Declaration\n-                 and then Ukind /= N_Generic_Subprogram_Declaration\n-                 and then Ukind /= N_Generic_Procedure_Renaming_Declaration\n-                 and then Ukind /= N_Package_Instantiation\n                  and then Ukind /= N_Package_Renaming_Declaration\n-                 and then Ukind /= N_Procedure_Instantiation\n+                 and then Ukind /= N_Subprogram_Renaming_Declaration\n+                 and then Ukind not in N_Generic_Declaration\n+                 and then Ukind not in N_Generic_Renaming_Declaration\n+                 and then Ukind not in N_Generic_Instantiation\n                then\n                   Error_Msg_N (\"limited with_clause not allowed here\", Item);\n \n@@ -1329,7 +1329,6 @@ package body Sem_Ch10 is\n         or else Nkind (Parent (N)) = N_Subprogram_Body\n       then\n          Decl := First (Declarations (Parent (N)));\n-\n          while Present (Decl)\n            and then Decl /= N\n          loop\n@@ -1417,20 +1416,18 @@ package body Sem_Ch10 is\n \n       begin\n          Analyze_Context (N);\n-         Item := First (Context_Items (N));\n \n-         --  make withed units immediately visible. If child unit, make the\n+         --  Make withed units immediately visible. If child unit, make the\n          --  ultimate parent immediately visible.\n \n+         Item := First (Context_Items (N));\n          while Present (Item) loop\n-\n             if Nkind (Item) = N_With_Clause then\n-               --  Protect the frontend against previous errors\n-               --  in context clauses\n+\n+               --  Protect frontend against previous errors in context clauses\n \n                if Nkind (Name (Item)) /= N_Selected_Component then\n                   Unit_Name := Entity (Name (Item));\n-\n                   while Is_Child_Unit (Unit_Name) loop\n                      Set_Is_Visible_Child_Unit (Unit_Name);\n                      Unit_Name := Scope (Unit_Name);\n@@ -1444,15 +1441,13 @@ package body Sem_Ch10 is\n \n             elsif Nkind (Item) = N_Use_Package_Clause then\n                Nam := First (Names (Item));\n-\n                while Present (Nam) loop\n                   Analyze (Nam);\n                   Next (Nam);\n                end loop;\n \n             elsif Nkind (Item) = N_Use_Type_Clause then\n                Nam := First (Subtype_Marks (Item));\n-\n                while Present (Nam) loop\n                   Analyze (Nam);\n                   Next (Nam);\n@@ -1462,22 +1457,18 @@ package body Sem_Ch10 is\n             Next (Item);\n          end loop;\n \n-         Item := First (Context_Items (N));\n-\n-         --  reset visibility of withed units. They will be made visible\n+         --  Reset visibility of withed units. They will be made visible\n          --  again when we install the subunit context.\n \n+         Item := First (Context_Items (N));\n          while Present (Item) loop\n-\n             if Nkind (Item) = N_With_Clause\n \n-               --  Protect the frontend against previous errors in context\n-               --  clauses\n+               --  Protect frontend against previous errors in context clauses\n \n               and then Nkind (Name (Item)) /= N_Selected_Component\n             then\n                Unit_Name := Entity (Name (Item));\n-\n                while Is_Child_Unit (Unit_Name) loop\n                   Set_Is_Visible_Child_Unit (Unit_Name, False);\n                   Unit_Name := Scope (Unit_Name);\n@@ -1491,7 +1482,6 @@ package body Sem_Ch10 is\n \n             Next (Item);\n          end loop;\n-\n       end Analyze_Subunit_Context;\n \n       ------------------------\n@@ -1521,11 +1511,10 @@ package body Sem_Ch10 is\n             Set_Is_Immediately_Visible (Scop);\n          end if;\n \n-         E := First_Entity (Current_Scope);\n-\n          --  Make entities in scope visible again. For child units, restore\n          --  visibility only if they are actually in context.\n \n+         E := First_Entity (Current_Scope);\n          while Present (E) loop\n             if not Is_Child_Unit (E)\n               or else Is_Visible_Child_Unit (E)\n@@ -1552,7 +1541,6 @@ package body Sem_Ch10 is\n \n       procedure Re_Install_Use_Clauses is\n          U  : Node_Id;\n-\n       begin\n          for J in reverse 1 .. Num_Scopes loop\n             U := Use_Clauses (J);\n@@ -1571,9 +1559,9 @@ package body Sem_Ch10 is\n       begin\n          Num_Scopes := Num_Scopes + 1;\n          Use_Clauses (Num_Scopes) :=\n-               Scope_Stack.Table (Scope_Stack.Last).First_Use_Clause;\n-         E := First_Entity (Current_Scope);\n+           Scope_Stack.Table (Scope_Stack.Last).First_Use_Clause;\n \n+         E := First_Entity (Current_Scope);\n          while Present (E) loop\n             Set_Is_Immediately_Visible (E, False);\n             Next_Entity (E);\n@@ -1741,6 +1729,7 @@ package body Sem_Ch10 is\n \n    begin\n       if Limited_Present (N) then\n+\n          --  Ada 2005 (AI-50217): Build visibility structures but do not\n          --  analyze unit\n \n@@ -1862,7 +1851,6 @@ package body Sem_Ch10 is\n          --  Instance is declared in the visible part of the wrapper package.\n \n          E_Name := First_Entity (Defining_Entity (U));\n-\n          while Present (E_Name) loop\n             exit when Is_Subprogram (E_Name)\n               and then Is_Generic_Instance (E_Name);\n@@ -1899,27 +1887,26 @@ package body Sem_Ch10 is\n       Style_Check := Save_Style_Check;\n       Cunit_Boolean_Restrictions_Restore (Save_C_Restrict);\n \n-      --  Record the reference, but do NOT set the unit as referenced, we\n-      --  want to consider the unit as unreferenced if this is the only\n-      --  reference that occurs.\n+      --  Record the reference, but do NOT set the unit as referenced, we want\n+      --  to consider the unit as unreferenced if this is the only reference\n+      --  that occurs.\n \n       Set_Entity_With_Style_Check (Name (N), E_Name);\n       Generate_Reference (E_Name, Name (N), 'w', Set_Ref => False);\n \n       if Is_Child_Unit (E_Name) then\n          Pref     := Prefix (Name (N));\n          Par_Name := Scope (E_Name);\n-\n          while Nkind (Pref) = N_Selected_Component loop\n             Change_Selected_Component_To_Expanded_Name (Pref);\n             Set_Entity_With_Style_Check (Pref, Par_Name);\n \n             Generate_Reference (Par_Name, Pref);\n             Pref := Prefix (Pref);\n \n-            --  If E_Name is the dummy entity for a nonexistent unit,\n-            --  its scope is set to Standard_Standard, and no attempt\n-            --  should be made to further unwind scopes.\n+            --  If E_Name is the dummy entity for a nonexistent unit, its scope\n+            --  is set to Standard_Standard, and no attempt should be made to\n+            --  further unwind scopes.\n \n             if Par_Name /= Standard_Standard then\n                Par_Name := Scope (Par_Name);\n@@ -1929,12 +1916,12 @@ package body Sem_Ch10 is\n          if Present (Entity (Pref))\n            and then not Analyzed (Parent (Parent (Entity (Pref))))\n          then\n-            --  If the entity is set without its unit being compiled,\n-            --  the original parent is a renaming, and Par_Name is the\n-            --  renamed entity. For visibility purposes, we need the\n-            --  original entity, which must be analyzed now, because\n-            --  Load_Unit retrieves directly the renamed unit, and the\n-            --  renaming declaration itself has not been analyzed.\n+            --  If the entity is set without its unit being compiled, the\n+            --  original parent is a renaming, and Par_Name is the renamed\n+            --  entity. For visibility purposes, we need the original entity,\n+            --  which must be analyzed now because Load_Unit directly retrieves\n+            --  the renamed unit, and the renaming declaration itself has not\n+            --  been analyzed.\n \n             Analyze (Parent (Parent (Entity (Pref))));\n             pragma Assert (Renamed_Object (Entity (Pref)) = Par_Name);\n@@ -1946,8 +1933,8 @@ package body Sem_Ch10 is\n       end if;\n \n       --  If the withed unit is System, and a system extension pragma is\n-      --  present, compile the extension now, rather than waiting for\n-      --  a visibility check on a specific entity.\n+      --  present, compile the extension now, rather than waiting for a\n+      --  visibility check on a specific entity.\n \n       if Chars (E_Name) = Name_System\n         and then Scope (E_Name) = Standard_Standard\n@@ -2033,11 +2020,11 @@ package body Sem_Ch10 is\n       --------------\n \n       function In_Chain (E : Entity_Id) return Boolean is\n-         H : Entity_Id := Current_Entity (E);\n+         H : Entity_Id;\n \n       begin\n+         H := Current_Entity (E);\n          while Present (H) loop\n-\n             if H = E then\n                return True;\n             else\n@@ -2176,9 +2163,7 @@ package body Sem_Ch10 is\n \n          Decl :=\n            First (Visible_Declarations (Specification (Unit (Cunit (Unum)))));\n-\n          while Present (Decl) loop\n-\n             if Nkind (Decl) = N_Full_Type_Declaration\n               and then Chars (Defining_Identifier (Decl)) = Chars (Sel)\n             then\n@@ -2475,9 +2460,8 @@ package body Sem_Ch10 is\n            or else Kind = N_Subprogram_Body\n            or else Kind = N_Task_Body\n            or else Kind = N_Protected_Body)\n-\n         and then (Nkind (Parent (Par)) = N_Compilation_Unit\n-                   or else Nkind (Parent (Par)) = N_Subunit)\n+                    or else Nkind (Parent (Par)) = N_Subunit)\n       then\n          null;\n \n@@ -2504,6 +2488,10 @@ package body Sem_Ch10 is\n \n       function Build_Unit_Name (Nam : Node_Id) return Node_Id;\n \n+      ---------------------\n+      -- Build_Unit_Name --\n+      ---------------------\n+\n       function Build_Unit_Name (Nam : Node_Id) return Node_Id is\n          Result : Node_Id;\n \n@@ -2522,6 +2510,8 @@ package body Sem_Ch10 is\n          end if;\n       end Build_Unit_Name;\n \n+   --  Start of processing for Expand_With_Clause\n+\n    begin\n       New_Nodes_OK := New_Nodes_OK + 1;\n       Withn :=\n@@ -2672,6 +2662,26 @@ package body Sem_Ch10 is\n       New_Nodes_OK := New_Nodes_OK - 1;\n    end Implicit_With_On_Parent;\n \n+   --------------\n+   -- In_Chain --\n+   --------------\n+\n+   function In_Chain (E : Entity_Id) return Boolean is\n+      H : Entity_Id;\n+\n+   begin\n+      H := Current_Entity (E);\n+      while Present (H) loop\n+         if H = E then\n+            return True;\n+         else\n+            H := Homonym (H);\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end In_Chain;\n+\n    ---------------------\n    -- Install_Context --\n    ---------------------\n@@ -2869,7 +2879,7 @@ package body Sem_Ch10 is\n \n       if Nkind (Lib_Unit) = N_Package_Body\n         or else (Nkind (Lib_Unit) = N_Subprogram_Body\n-                  and then not Acts_As_Spec (N))\n+                   and then not Acts_As_Spec (N))\n       then\n          Install_Context (Library_Unit (N));\n \n@@ -2884,11 +2894,12 @@ package body Sem_Ch10 is\n             --  context clause of the body are directly visible.\n \n             declare\n-               Lib_Spec : Node_Id := Unit (Library_Unit (N));\n+               Lib_Spec : Node_Id;\n                P        : Node_Id;\n                P_Name   : Entity_Id;\n \n             begin\n+               Lib_Spec := Unit (Library_Unit (N));\n                while Is_Child_Spec (Lib_Spec) loop\n                   P := Unit (Parent_Spec (Lib_Spec));\n \n@@ -3000,18 +3011,16 @@ package body Sem_Ch10 is\n                --  Traverse the list of packages\n \n                Nam := First (Names (Item));\n-\n                while Present (Nam) loop\n                   E := Entity (Nam);\n \n                   pragma Assert (Present (Parent (E)));\n \n-                  if Nkind (Parent (E))\n-                    = N_Package_Renaming_Declaration\n+                  if Nkind (Parent (E)) = N_Package_Renaming_Declaration\n                     and then Renamed_Entity (E) = WEnt\n                   then\n-                     Error_Msg_N (\"unlimited view visible through \"\n-                                  & \"use_clause + renamings\", W);\n+                     Error_Msg_N (\"unlimited view visible through \" &\n+                                  \"use clause and renamings\", W);\n                      return;\n \n                   elsif Nkind (Parent (E)) = N_Package_Specification then\n@@ -3026,8 +3035,8 @@ package body Sem_Ch10 is\n                      end loop;\n \n                      if E2 = WEnt then\n-                        Error_Msg_N (\"unlimited view visible through \"\n-                                     & \"use_clause \", W);\n+                        Error_Msg_N\n+                          (\"unlimited view visible through use clause \", W);\n                         return;\n                      end if;\n \n@@ -3139,13 +3148,16 @@ package body Sem_Ch10 is\n          New_Nodes_OK := New_Nodes_OK + 1;\n \n          if Nkind (Nam) = N_Identifier then\n-            Withn := Make_With_Clause (Loc, Nam);\n+            Withn :=\n+              Make_With_Clause (Loc,\n+                Name => Nam);\n \n          else pragma Assert (Nkind (Nam) = N_Selected_Component);\n-            Withn := Make_With_Clause (Loc,\n-                       Make_Selected_Component (Loc,\n-                          Prefix        => Prefix (Nam),\n-                          Selector_Name => Selector_Name (Nam)));\n+            Withn :=\n+              Make_With_Clause (Loc,\n+                Name => Make_Selected_Component (Loc,\n+                  Prefix        => Prefix (Nam),\n+                  Selector_Name => Selector_Name (Nam)));\n             Set_Parent (Withn, Parent (N));\n          end if;\n \n@@ -3160,31 +3172,32 @@ package body Sem_Ch10 is\n               Subunit    => False,\n               Error_Node => Nam);\n \n-         if not Analyzed (Cunit (Unum)) then\n-            --  Do not generate a limited_with_clause on the current unit.\n-            --  This path is taken when a unit has a limited_with clause on\n-            --  one of its child units.\n+         --  Do not generate a limited_with_clause on the current unit.\n+         --  This path is taken when a unit has a limited_with clause on\n+         --  one of its child units.\n \n-            if Unum = Current_Sem_Unit then\n-               return;\n-            end if;\n+         if Unum = Current_Sem_Unit then\n+            return;\n+         end if;\n \n-            Set_Library_Unit (Withn, Cunit (Unum));\n-            Set_Corresponding_Spec\n-              (Withn, Specification (Unit (Cunit (Unum))));\n+         Set_Library_Unit (Withn, Cunit (Unum));\n+         Set_Corresponding_Spec\n+           (Withn, Specification (Unit (Cunit (Unum))));\n \n-            if not Previous_Withed_Unit (Withn) then\n-               Prepend (Withn, Context_Items (Parent (N)));\n-               Mark_Rewrite_Insertion (Withn);\n+         if not Previous_Withed_Unit (Withn) then\n+            Prepend (Withn, Context_Items (Parent (N)));\n+            Mark_Rewrite_Insertion (Withn);\n \n-               --  Add implicit limited_with_clauses for parents of child units\n-               --  mentioned in limited_with clauses\n+            --  Add implicit limited_with_clauses for parents of child units\n+            --  mentioned in limited_with clauses.\n \n-               if Nkind (Nam) = N_Selected_Component then\n-                  Expand_Limited_With_Clause (Comp_Unit, Prefix (Nam), N);\n-               end if;\n+            if Nkind (Nam) = N_Selected_Component then\n+               Expand_Limited_With_Clause (Comp_Unit, Prefix (Nam), N);\n+            end if;\n \n-               Analyze (Withn);\n+            Analyze (Withn);\n+\n+            if not Limited_View_Installed (Withn) then\n                Install_Limited_Withed_Unit (Withn);\n             end if;\n          end if;\n@@ -3220,7 +3233,9 @@ package body Sem_Ch10 is\n             --  case it is already being compiled and it makes no sense\n             --  to install its limited view.\n \n-            if Library_Unit (Item) /= Cunit (Current_Sem_Unit) then\n+            if Library_Unit (Item) /= Cunit (Current_Sem_Unit)\n+              and then not Limited_View_Installed (Item)\n+            then\n                Install_Limited_Withed_Unit (Item);\n             end if;\n          end if;\n@@ -3277,7 +3292,7 @@ package body Sem_Ch10 is\n            or else Nkind (Original_Node (Lib_Unit)) in N_Generic_Instantiation\n            or else\n              (Nkind (Lib_Unit) = N_Package_Declaration\n-               and then Present (Generic_Parent (Specification (Lib_Unit))))\n+                and then Present (Generic_Parent (Specification (Lib_Unit))))\n          then\n             null;\n          else\n@@ -3362,13 +3377,14 @@ package body Sem_Ch10 is\n \n       if Nkind (Parent (Decl)) = N_Compilation_Unit then\n          Item := First (Context_Items (Parent (Decl)));\n-\n          while Present (Item) loop\n             if Nkind (Item) = N_With_Clause\n               and then Private_Present (Item)\n             then\n                if Limited_Present (Item) then\n-                  Install_Limited_Withed_Unit (Item);\n+                  if not Limited_View_Installed (Item) then\n+                     Install_Limited_Withed_Unit (Item);\n+                  end if;\n                else\n                   Install_Withed_Unit (Item, Private_With_OK => True);\n                end if;\n@@ -3392,18 +3408,18 @@ package body Sem_Ch10 is\n       --  scope of each entity is an ancestor of the current unit.\n \n       Item := First (Context_Items (N));\n+      while Present (Item) loop\n \n-      --  Do not install private_with_clauses if the unit is a package\n-      --  declaration, unless it is itself a private child unit.\n+         --  Do not install private_with_clauses if the unit is a package\n+         --  declaration, unless it is itself a private child unit.\n \n-      while Present (Item) loop\n          if Nkind (Item) = N_With_Clause\n            and then not Implicit_With (Item)\n            and then not Limited_Present (Item)\n            and then\n               (not Private_Present (Item)\n-                or else Nkind (Unit (N)) /= N_Package_Declaration\n-                or else Private_Present (N))\n+                 or else Nkind (Unit (N)) /= N_Package_Declaration\n+                 or else Private_Present (N))\n          then\n             Id := Entity (Name (Item));\n \n@@ -3426,7 +3442,6 @@ package body Sem_Ch10 is\n \n                   begin\n                      Clause := First (Context_Items (N));\n-\n                      while Present (Clause) loop\n                         if Nkind (Clause) = N_With_Clause\n                           and then Entity (Name (Clause)) = Prev\n@@ -3462,48 +3477,24 @@ package body Sem_Ch10 is\n    -------------------------------\n \n    procedure Install_Limited_Withed_Unit (N : Node_Id) is\n-      Unum             : constant Unit_Number_Type :=\n-                           Get_Source_Unit (Library_Unit (N));\n       P_Unit           : constant Entity_Id := Unit (Library_Unit (N));\n       P                : Entity_Id;\n       Is_Child_Package : Boolean := False;\n \n-      Lim_Header       : Entity_Id;\n-      Lim_Typ          : Entity_Id;\n-\n-      function In_Chain (E : Entity_Id) return Boolean;\n-      --  Check that the shadow entity is not already in the homonym\n-      --  chain, for example through a limited_with clause in a parent unit.\n+      Lim_Header : Entity_Id;\n+      Lim_Typ    : Entity_Id;\n \n       function Is_Visible_Through_Renamings (P : Entity_Id) return Boolean;\n       --  Check if some package installed though normal with-clauses has a\n       --  renaming declaration of package P. AARM 10.1.2(21/2).\n \n-      --------------\n-      -- In_Chain --\n-      --------------\n-\n-      function In_Chain (E : Entity_Id) return Boolean is\n-         H : Entity_Id := Current_Entity (E);\n-\n-      begin\n-         while Present (H) loop\n-            if H = E then\n-               return True;\n-            else\n-               H := Homonym (H);\n-            end if;\n-         end loop;\n-\n-         return False;\n-      end In_Chain;\n-\n       ----------------------------------\n       -- Is_Visible_Through_Renamings --\n       ----------------------------------\n \n       function Is_Visible_Through_Renamings (P : Entity_Id) return Boolean is\n-         Kind : constant Node_Kind := Nkind (Unit (Cunit (Current_Sem_Unit)));\n+         Kind     : constant Node_Kind :=\n+                      Nkind (Unit (Cunit (Current_Sem_Unit)));\n          Aux_Unit : Node_Id;\n          Item     : Node_Id;\n          Decl     : Entity_Id;\n@@ -3589,6 +3580,8 @@ package body Sem_Ch10 is\n    --  Start of processing for Install_Limited_Withed_Unit\n \n    begin\n+      pragma Assert (not Limited_View_Installed (N));\n+\n       --  In case of limited with_clause on subprograms, generics, instances,\n       --  or renamings, the corresponding error was previously posted and we\n       --  have nothing to do here.\n@@ -3599,16 +3592,15 @@ package body Sem_Ch10 is\n \n       P := Defining_Unit_Name (Specification (P_Unit));\n \n-      if Nkind (P) = N_Defining_Program_Unit_Name then\n-\n-         --  Retrieve entity of child package\n+      --  Handle child packages\n \n+      if Nkind (P) = N_Defining_Program_Unit_Name then\n          Is_Child_Package := True;\n          P := Defining_Identifier (P);\n       end if;\n \n       --  Do not install the limited-view if the full-view is already visible\n-      --  through some renaming declaration\n+      --  through renaming declarations.\n \n       if Is_Visible_Through_Renamings (P) then\n          return;\n@@ -3624,19 +3616,17 @@ package body Sem_Ch10 is\n       --       with X;          -- [2]\n       --       package body A is ...\n \n-      --  The compilation of A's body installs the entities of its\n-      --  withed packages (the context clauses found at [2]) and\n-      --  then the context clauses of its specification (found at [1]).\n-\n-      --  As a consequence, at point [1] the specification of X has been\n-      --  analyzed and it is immediately visible. According to the semantics\n-      --  of the limited-with context clauses we don't install the limited\n-      --  view because the full view of X supersedes its limited view.\n+      --  The compilation of A's body installs the context clauses found at [2]\n+      --  and then the context clauses of its specification (found at [1]). As\n+      --  a consequence, at [1] the specification of X has been analyzed and it\n+      --  is immediately visible. According to the semantics of limited-with\n+      --  context clauses we don't install the limited view because the full\n+      --  view of X supersedes its limited view.\n \n-      if Analyzed (Cunit (Unum))\n+      if Analyzed (P_Unit)\n         and then (Is_Immediately_Visible (P)\n-                   or else (Is_Child_Package\n-                             and then Is_Visible_Child_Unit (P)))\n+                    or else (Is_Child_Package\n+                               and then Is_Visible_Child_Unit (P)))\n       then\n          --  Ada 2005 (AI-262): Install the private declarations of P\n \n@@ -3645,9 +3635,9 @@ package body Sem_Ch10 is\n          then\n             declare\n                Id : Entity_Id;\n+\n             begin\n                Id := First_Private_Entity (P);\n-\n                while Present (Id) loop\n                   if not Is_Internal (Id)\n                     and then not Is_Child_Unit (Id)\n@@ -3676,14 +3666,26 @@ package body Sem_Ch10 is\n          Write_Eol;\n       end if;\n \n-      if not Analyzed (Cunit (Unum)) then\n-         Set_Ekind (P, E_Package);\n-         Set_Etype (P, Standard_Void_Type);\n-         Set_Scope (P, Standard_Standard);\n+      --  If the unit has not been analyzed and the limited view has not been\n+      --  already installed then we install it.\n+\n+      if not Analyzed (P_Unit) then\n+         if not In_Chain (P) then\n \n-         --  Place entity on visibility structure\n+            --  Minimum decoration\n+\n+            Set_Ekind (P, E_Package);\n+            Set_Etype (P, Standard_Void_Type);\n+            Set_Scope (P, Standard_Standard);\n+\n+            if Is_Child_Package then\n+               Set_Is_Child_Unit (P);\n+               Set_Is_Visible_Child_Unit (P);\n+               Set_Scope (P, Defining_Entity (Unit (Parent_Spec (P_Unit))));\n+            end if;\n+\n+            --  Place entity on visibility structure\n \n-         if Current_Entity (P) /= P then\n             Set_Homonym (P, Current_Entity (P));\n             Set_Current_Entity (P);\n \n@@ -3693,75 +3695,111 @@ package body Sem_Ch10 is\n                Write_Eol;\n             end if;\n \n-         end if;\n+            --  Install the incomplete view. The first element of the limited\n+            --  view is a header (an E_Package entity) used to reference the\n+            --  first shadow entity in the private part of the package.\n \n-         if Is_Child_Package then\n-            Set_Is_Child_Unit (P);\n-            Set_Is_Visible_Child_Unit (P);\n+            Lim_Header := Limited_View (P);\n+            Lim_Typ    := First_Entity (Lim_Header);\n \n-            declare\n-               Parent_Comp : Node_Id;\n-               Parent_Id   : Entity_Id;\n+            while Present (Lim_Typ)\n+              and then Lim_Typ /= First_Private_Entity (Lim_Header)\n+            loop\n+               Set_Homonym (Lim_Typ, Current_Entity (Lim_Typ));\n+               Set_Current_Entity (Lim_Typ);\n \n-            begin\n-               Parent_Comp := Parent_Spec (Unit (Cunit (Unum)));\n-               Parent_Id   := Defining_Entity (Unit (Parent_Comp));\n+               if Debug_Flag_I then\n+                  Write_Str (\"   (homonym) chain \");\n+                  Write_Name (Chars (Lim_Typ));\n+                  Write_Eol;\n+               end if;\n \n-               Set_Scope (P, Parent_Id);\n-            end;\n+               Next_Entity (Lim_Typ);\n+            end loop;\n          end if;\n-      else\n \n-         --  If the unit appears in a previous regular with_clause, the\n-         --  regular entities must be unchained before the shadow ones\n-         --  are made accessible.\n+      --  If the unit appears in a previous regular with_clause, the regular\n+      --  entities of the public part of the withed package must be replaced\n+      --  by the shadow ones.\n+\n+      --  This code must be kept synchronized with the code that replaces the\n+      --  the shadow entities by the real entities (see body of Remove_Limited\n+      --  With_Clause); otherwise the contents of the homonym chains are not\n+      --  consistent.\n+\n+      else\n+         --  Hide all the type entities of the public part of the package to\n+         --  avoid its usage. This is needed to cover all the subtype decla-\n+         --  rations because we do not remove them from the homonym chain.\n \n          declare\n-            Ent : Entity_Id;\n+            E : Entity_Id;\n+\n          begin\n-            Ent := First_Entity (P);\n+            E := First_Entity (P);\n+            while Present (E) and then E /= First_Private_Entity (P) loop\n+               if Is_Type (E) then\n+                  Set_Was_Hidden (E, Is_Hidden (E));\n+                  Set_Is_Hidden (E);\n+               end if;\n \n-            while Present (Ent) loop\n-               Unchain (Ent);\n-               Next_Entity (Ent);\n+               Next_Entity (E);\n             end loop;\n          end;\n-      end if;\n \n-      --  The package must be visible while the limited-with clause is active,\n-      --  because references to the type P.T must resolve in the usual way.\n+         --  Replace the real entities by the shadow entities of the limited\n+         --  view. The first element of the limited view is a header that is\n+         --  used to reference the first shadow entity in the private part\n+         --  of the package.\n \n-      Set_Is_Immediately_Visible (P);\n+         Lim_Header := Limited_View (P);\n \n-      --  Install each incomplete view. The first element of the limited view\n-      --  is a header (an E_Package entity) that is used to reference the first\n-      --  shadow entity in the private part of the package\n+         Lim_Typ := First_Entity (Lim_Header);\n+         while Present (Lim_Typ)\n+           and then Lim_Typ /= First_Private_Entity (Lim_Header)\n+         loop\n+            pragma Assert (not In_Chain (Lim_Typ));\n \n-      Lim_Header := Limited_View (P);\n-      Lim_Typ    := First_Entity (Lim_Header);\n+            --  Do not unchain child units\n \n-      while Present (Lim_Typ) loop\n+            if not Is_Child_Unit (Lim_Typ) then\n+               declare\n+                  Prev : Entity_Id;\n \n-         exit when not Private_Present (N)\n-                        and then Lim_Typ = First_Private_Entity (Lim_Header);\n+               begin\n+                  Set_Homonym (Lim_Typ, Homonym (Non_Limited_View (Lim_Typ)));\n+                  Prev := Current_Entity (Lim_Typ);\n \n-         if not In_Chain (Lim_Typ) then\n-            Set_Homonym (Lim_Typ, Current_Entity (Lim_Typ));\n-            Set_Current_Entity (Lim_Typ);\n+                  if Prev = Non_Limited_View (Lim_Typ) then\n+                     Set_Current_Entity (Lim_Typ);\n+                  else\n+                     while Present (Prev)\n+                       and then Homonym (Prev) /= Non_Limited_View (Lim_Typ)\n+                     loop\n+                        Prev := Homonym (Prev);\n+                     end loop;\n \n-            if Debug_Flag_I then\n-               Write_Str (\"   (homonym) chain \");\n-               Write_Name (Chars (Lim_Typ));\n-               Write_Eol;\n+                     Set_Homonym (Prev, Lim_Typ);\n+                  end if;\n+               end;\n+\n+               if Debug_Flag_I then\n+                  Write_Str (\"   (homonym) chain \");\n+                  Write_Name (Chars (Lim_Typ));\n+                  Write_Eol;\n+               end if;\n             end if;\n-         end if;\n \n-         Next_Entity (Lim_Typ);\n-      end loop;\n+            Next_Entity (Lim_Typ);\n+         end loop;\n+      end if;\n \n-      --  The context clause has installed a limited-view, mark it\n-      --  accordingly, to uninstall it when the context is removed.\n+      --  The package must be visible while the limited-with clause is active\n+      --  because references to the type P.T must resolve in the usual way.\n+      --  In addition, we remember that the limited-view has been installed to\n+      --  uninstall it at the point of context removal.\n \n+      Set_Is_Immediately_Visible (P);\n       Set_Limited_View_Installed (N);\n       Set_From_With_Type (P);\n    end Install_Limited_Withed_Unit;\n@@ -3815,10 +3853,10 @@ package body Sem_Ch10 is\n \n       if P /= Standard_Standard then\n \n-         --  If the unit is not analyzed after analysis of the with clause,\n-         --  and it is an instantiation, then it awaits a body and is the main\n-         --  unit. Its appearance in the context of some other unit indicates\n-         --  a circular dependency (DEC suite perversity).\n+         --  If the unit is not analyzed after analysis of the with clause and\n+         --  it is an instantiation then it awaits a body and is the main unit.\n+         --  Its appearance in the context of some other unit indicates a\n+         --  circular dependency (DEC suite perversity).\n \n          if not Analyzed (Uname)\n            and then Nkind (Parent (Uname)) = N_Package_Instantiation\n@@ -3829,8 +3867,8 @@ package body Sem_Ch10 is\n          elsif not Is_Visible_Child_Unit (Uname) then\n             Set_Is_Visible_Child_Unit (Uname);\n \n-            --  If the child unit appears in the context of its parent, it\n-            --  is immediately visible.\n+            --  If the child unit appears in the context of its parent, it is\n+            --  immediately visible.\n \n             if In_Open_Scopes (Scope (Uname)) then\n                Set_Is_Immediately_Visible (Uname);\n@@ -3847,8 +3885,8 @@ package body Sem_Ch10 is\n                    (Defining_Entity (Unit (Library_Unit (With_Clause)))));\n             end if;\n \n-            --  The parent unit may have been installed already, and\n-            --  may have appeared in a use clause.\n+            --  The parent unit may have been installed already, and may have\n+            --  appeared in a use clause.\n \n             if In_Use (Scope (Uname)) then\n                Set_Is_Potentially_Use_Visible (Uname);\n@@ -4175,7 +4213,6 @@ package body Sem_Ch10 is\n \n       begin\n          Decl := First_Decl;\n-\n          while Present (Decl) loop\n \n             --  For each library_package_declaration in the environment, there\n@@ -4195,7 +4232,7 @@ package body Sem_Ch10 is\n             if Nkind (Decl) = N_Full_Type_Declaration then\n                Is_Tagged :=\n                   Nkind (Type_Definition (Decl)) = N_Record_Definition\n-                  and then Tagged_Present (Type_Definition (Decl));\n+                    and then Tagged_Present (Type_Definition (Decl));\n \n                Comp_Typ := Defining_Identifier (Decl);\n \n@@ -4458,7 +4495,6 @@ package body Sem_Ch10 is\n            and then Present (Corresponding_Body (Unit_Declaration_Node (E)))\n          then\n             Ent := First_Entity (E);\n-\n             while Present (Ent) loop\n                if Entity_Needs_Body (Ent) then\n                   return True;\n@@ -4607,14 +4643,27 @@ package body Sem_Ch10 is\n \n    procedure Remove_Limited_With_Clause (N : Node_Id) is\n       P_Unit     : constant Entity_Id := Unit (Library_Unit (N));\n-      P          : Entity_Id := Defining_Unit_Name (Specification (P_Unit));\n+      P          : Entity_Id;\n+      Lim_Header : Entity_Id;\n       Lim_Typ    : Entity_Id;\n+      Prev       : Entity_Id;\n \n    begin\n-      if Nkind (P) = N_Defining_Program_Unit_Name then\n+      pragma Assert (Limited_View_Installed (N));\n \n-         --  Retrieve entity of Child package\n+      --  In case of limited with_clause on subprograms, generics, instances,\n+      --  or renamings, the corresponding error was previously posted and we\n+      --  have nothing to do here.\n+\n+      if Nkind (P_Unit) /= N_Package_Declaration then\n+         return;\n+      end if;\n+\n+      P := Defining_Unit_Name (Specification (P_Unit));\n \n+      --  Handle child packages\n+\n+      if Nkind (P) = N_Defining_Program_Unit_Name then\n          P := Defining_Identifier (P);\n       end if;\n \n@@ -4625,66 +4674,88 @@ package body Sem_Ch10 is\n          Write_Eol;\n       end if;\n \n-      --  Remove all shadow entities from visibility. The first element of the\n-      --  limited view is a header (an E_Package entity) that is used to\n-      --  reference the first shadow entity in the private part of the package\n-\n-      Lim_Typ    := First_Entity (Limited_View (P));\n+      --  Prepare the removal of the shadow entities from visibility. The\n+      --  first element of the limited view is a header (an E_Package\n+      --  entity) that is used to reference the first shadow entity in the\n+      --  private part of the package\n \n-      while Present (Lim_Typ) loop\n-         Unchain (Lim_Typ);\n-         Next_Entity (Lim_Typ);\n-      end loop;\n-\n-      --  Indicate that the limited view of the package is not installed\n-\n-      Set_From_With_Type (P, False);\n-      Set_Limited_View_Installed (N, False);\n+      Lim_Header := Limited_View (P);\n+      Lim_Typ    := First_Entity (Lim_Header);\n \n-      --  If the exporting package has previously been analyzed, it\n-      --  has appeared in the closure already and should be left alone.\n-      --  Otherwise, remove package itself from visibility.\n+      --  Remove package and shadow entities from visibility if it has not\n+      --  been analyzed\n \n       if not Analyzed (P_Unit) then\n          Unchain (P);\n-         Set_First_Entity (P, Empty);\n-         Set_Last_Entity (P, Empty);\n-         Set_Ekind (P, E_Void);\n-         Set_Scope (P, Empty);\n          Set_Is_Immediately_Visible (P, False);\n \n-      else\n+         while Present (Lim_Typ) loop\n+            Unchain (Lim_Typ);\n+            Next_Entity (Lim_Typ);\n+         end loop;\n+\n+      --  Otherwise this package has already appeared in the closure and its\n+      --  shadow entities must be replaced by its real entities. This code\n+      --  must be kept synchronized with the complementary code in Install\n+      --  Limited_Withed_Unit.\n \n-         --  Reinstall visible entities (entities removed from visibility in\n-         --  Install_Limited_Withed to install the shadow entities).\n+      else\n+         --  Real entities that are type or subtype declarations were hidden\n+         --  from visibility at the point of installation of the limited-view.\n+         --  Now we recover the previous value of the hidden attribute.\n \n          declare\n-            Ent : Entity_Id;\n+            E : Entity_Id;\n \n          begin\n-            Ent := First_Entity (P);\n-            while Present (Ent) and then Ent /= First_Private_Entity (P) loop\n+            E := First_Entity (P);\n+            while Present (E) and then E /= First_Private_Entity (P) loop\n+               if Is_Type (E) then\n+                  Set_Is_Hidden (E, Was_Hidden (E));\n+               end if;\n+\n+               Next_Entity (E);\n+            end loop;\n+         end;\n \n-               --  Shadow entities have not been added to the list of\n-               --  entities associated to the package spec. Therefore we\n-               --  just have to re-chain all its visible entities.\n+         while Present (Lim_Typ)\n+           and then Lim_Typ /= First_Private_Entity (Lim_Header)\n+         loop\n+            pragma Assert (not In_Chain (Non_Limited_View (Lim_Typ)));\n \n-               if not Is_Class_Wide_Type (Ent) then\n+            --  Child units have not been unchained\n \n-                  Set_Homonym (Ent, Current_Entity (Ent));\n-                  Set_Current_Entity (Ent);\n+            if not Is_Child_Unit (Non_Limited_View (Lim_Typ)) then\n+               Prev := Current_Entity (Lim_Typ);\n \n-                  if Debug_Flag_I then\n-                     Write_Str (\"   (homonym) chain \");\n-                     Write_Name (Chars (Ent));\n-                     Write_Eol;\n-                  end if;\n+               if Prev = Lim_Typ then\n+                  Set_Current_Entity (Non_Limited_View (Lim_Typ));\n+               else\n+                  while Present (Prev)\n+                    and then Homonym (Prev) /= Lim_Typ\n+                  loop\n+                     Prev := Homonym (Prev);\n+                  end loop;\n+\n+                  pragma Assert (Present (Prev));\n+                  Set_Homonym (Prev, Non_Limited_View (Lim_Typ));\n                end if;\n \n-               Next_Entity (Ent);\n-            end loop;\n-         end;\n+               --  We must also set the next homonym entity of the real entity\n+               --  to handle the case in which the next homonym was a shadow\n+               --  entity.\n+\n+               Set_Homonym (Non_Limited_View (Lim_Typ), Homonym (Lim_Typ));\n+            end if;\n+\n+            Next_Entity (Lim_Typ);\n+         end loop;\n       end if;\n+\n+      --  Indicate that the limited view of the package is not installed\n+\n+      Set_From_With_Type         (P, False);\n+      Set_Limited_View_Installed (N, False);\n    end Remove_Limited_With_Clause;\n \n    --------------------\n@@ -4721,9 +4792,7 @@ package body Sem_Ch10 is\n          --  visible while the parent is in scope.\n \n          E := First_Entity (P_Name);\n-\n          while Present (E) loop\n-\n             if Is_Child_Unit (E) then\n                Set_Is_Immediately_Visible (E, False);\n             end if;\n@@ -4821,7 +4890,6 @@ package body Sem_Ch10 is\n       --  If P is a child unit, remove parents as well\n \n       P := Scope (P);\n-\n       while Present (P)\n         and then P /= Standard_Standard\n       loop"}]}