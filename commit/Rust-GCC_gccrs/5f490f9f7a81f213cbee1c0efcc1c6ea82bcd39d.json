{"sha": "5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY0OTBmOWY3YTgxZjIxM2NiZWUxYzBlZmNjMWM2ZWE4MmJjZDM5ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-04-07T21:32:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-04-07T21:32:05Z"}, "message": "cgraph.h (struct cgraph_simd_clone): Add mask_mode field.\n\n\t* cgraph.h (struct cgraph_simd_clone): Add mask_mode field.\n\t* omp-low.c (simd_clone_init_simd_arrays, simd_clone_adjust): Handle\n\tnode->simdclone->mask_mode != VOIDmode masks.\n\t(simd_clone_adjust_argument_types): Likewise.  Move sc var definition\n\tearlier, use it instead of node->simdclone.\n\t* config/i386/i386.c (ix86_simd_clone_compute_vecsize_and_simdlen):\n\tSet clonei->mask_mode.\n\n\t* c-c++-common/attr-simd.c: Add scan-assembler* directives for AVX512F\n\tclones.\n\t* c-c++-common/attr-simd-2.c: Likewise.\n\t* c-c++-common/attr-simd-4.c: Likewise.\n\t* gcc.dg/gomp/simd-clones-2.c: Likewise.\n\t* gcc.dg/gomp/simd-clones-3.c: Likewise.\n\nFrom-SVN: r234816", "tree": {"sha": "882c57e35ac3ebcd75ffa7a1481754a29a7398c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/882c57e35ac3ebcd75ffa7a1481754a29a7398c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4ebc74d8c82e74c5e6b5f04ed4ac1f97f2a53bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ebc74d8c82e74c5e6b5f04ed4ac1f97f2a53bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4ebc74d8c82e74c5e6b5f04ed4ac1f97f2a53bc"}], "stats": {"total": 206, "additions": 164, "deletions": 42}, "files": [{"sha": "8e36e506a811c0bc987ea6b1c707133047efdf1b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "patch": "@@ -1,3 +1,13 @@\n+2016-04-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cgraph.h (struct cgraph_simd_clone): Add mask_mode field.\n+\t* omp-low.c (simd_clone_init_simd_arrays, simd_clone_adjust): Handle\n+\tnode->simdclone->mask_mode != VOIDmode masks.\n+\t(simd_clone_adjust_argument_types): Likewise.  Move sc var definition\n+\tearlier, use it instead of node->simdclone.\n+\t* config/i386/i386.c (ix86_simd_clone_compute_vecsize_and_simdlen):\n+\tSet clonei->mask_mode.\n+\n 2016-04-06  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR c/70436"}, {"sha": "0d5806b458ebb7bcfad966e342d423053d38d519", "filename": "gcc/cgraph.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "patch": "@@ -766,6 +766,11 @@ struct GTY(()) cgraph_simd_clone {\n   /* Max hardware vector size in bits for floating point vectors.  */\n   unsigned int vecsize_float;\n \n+  /* Machine mode of the mask argument(s), if they are to be passed\n+     as bitmasks in integer argument(s).  VOIDmode if masks are passed\n+     as vectors of characteristic type.  */\n+  machine_mode mask_mode;\n+\n   /* The mangling character for a given vector size.  This is used\n      to determine the ISA mangling bit as specified in the Intel\n      Vector ABI.  */"}, {"sha": "acbecbd24e10670fde3ea66b0c35d002c56cd216", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "patch": "@@ -53747,7 +53747,7 @@ ix86_memmodel_check (unsigned HOST_WIDE_INT val)\n   return val;\n }\n \n-/* Set CLONEI->vecsize_mangle, CLONEI->vecsize_int,\n+/* Set CLONEI->vecsize_mangle, CLONEI->mask_mode, CLONEI->vecsize_int,\n    CLONEI->vecsize_float and if CLONEI->simdlen is 0, also\n    CLONEI->simdlen.  Return 0 if SIMD clones shouldn't be emitted,\n    or number of vecsize_mangle variants that should be emitted.  */\n@@ -53834,6 +53834,7 @@ ix86_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n       clonei->vecsize_mangle = \"bcde\"[num];\n       ret = 4;\n     }\n+  clonei->mask_mode = VOIDmode;\n   switch (clonei->vecsize_mangle)\n     {\n     case 'b':\n@@ -53851,6 +53852,10 @@ ix86_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n     case 'e':\n       clonei->vecsize_int = 512;\n       clonei->vecsize_float = 512;\n+      if (TYPE_MODE (base_type) == QImode)\n+\tclonei->mask_mode = DImode;\n+      else\n+\tclonei->mask_mode = SImode;\n       break;\n     }\n   if (clonei->simdlen == 0)"}, {"sha": "979926d332a743daf341d0eef99eb07ed2bcecf5", "filename": "gcc/omp-low.c", "status": "modified", "additions": 119, "deletions": 41, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "patch": "@@ -18918,18 +18918,20 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n   adjustments.create (args.length ());\n   unsigned i, j, veclen;\n   struct ipa_parm_adjustment adj;\n-  for (i = 0; i < node->simdclone->nargs; ++i)\n+  struct cgraph_simd_clone *sc = node->simdclone;\n+\n+  for (i = 0; i < sc->nargs; ++i)\n     {\n       memset (&adj, 0, sizeof (adj));\n       tree parm = args[i];\n       tree parm_type = node->definition ? TREE_TYPE (parm) : parm;\n       adj.base_index = i;\n       adj.base = parm;\n \n-      node->simdclone->args[i].orig_arg = node->definition ? parm : NULL_TREE;\n-      node->simdclone->args[i].orig_type = parm_type;\n+      sc->args[i].orig_arg = node->definition ? parm : NULL_TREE;\n+      sc->args[i].orig_type = parm_type;\n \n-      switch (node->simdclone->args[i].arg_type)\n+      switch (sc->args[i].arg_type)\n \t{\n \tdefault:\n \t  /* No adjustment necessary for scalar arguments.  */\n@@ -18938,29 +18940,29 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n \tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n \t  if (node->definition)\n-\t    node->simdclone->args[i].simd_array\n+\t    sc->args[i].simd_array\n \t      = create_tmp_simd_array (IDENTIFIER_POINTER (DECL_NAME (parm)),\n \t\t\t\t       TREE_TYPE (parm_type),\n-\t\t\t\t       node->simdclone->simdlen);\n+\t\t\t\t       sc->simdlen);\n \t  adj.op = IPA_PARM_OP_COPY;\n \t  break;\n \tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n \tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n \tcase SIMD_CLONE_ARG_TYPE_VECTOR:\n \t  if (INTEGRAL_TYPE_P (parm_type) || POINTER_TYPE_P (parm_type))\n-\t    veclen = node->simdclone->vecsize_int;\n+\t    veclen = sc->vecsize_int;\n \t  else\n-\t    veclen = node->simdclone->vecsize_float;\n+\t    veclen = sc->vecsize_float;\n \t  veclen /= GET_MODE_BITSIZE (TYPE_MODE (parm_type));\n-\t  if (veclen > node->simdclone->simdlen)\n-\t    veclen = node->simdclone->simdlen;\n+\t  if (veclen > sc->simdlen)\n+\t    veclen = sc->simdlen;\n \t  adj.arg_prefix = \"simd\";\n \t  if (POINTER_TYPE_P (parm_type))\n \t    adj.type = build_vector_type (pointer_sized_int_node, veclen);\n \t  else\n \t    adj.type = build_vector_type (parm_type, veclen);\n-\t  node->simdclone->args[i].vector_type = adj.type;\n-\t  for (j = veclen; j < node->simdclone->simdlen; j += veclen)\n+\t  sc->args[i].vector_type = adj.type;\n+\t  for (j = veclen; j < sc->simdlen; j += veclen)\n \t    {\n \t      adjustments.safe_push (adj);\n \t      if (j == veclen)\n@@ -18969,55 +18971,63 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t\t  adj.op = IPA_PARM_OP_NEW;\n \t\t  adj.arg_prefix = \"simd\";\n \t\t  adj.base_index = i;\n-\t\t  adj.type = node->simdclone->args[i].vector_type;\n+\t\t  adj.type = sc->args[i].vector_type;\n \t\t}\n \t    }\n \n \t  if (node->definition)\n-\t    node->simdclone->args[i].simd_array\n+\t    sc->args[i].simd_array\n \t      = create_tmp_simd_array (IDENTIFIER_POINTER (DECL_NAME (parm)),\n-\t\t\t\t       parm_type, node->simdclone->simdlen);\n+\t\t\t\t       parm_type, sc->simdlen);\n \t}\n       adjustments.safe_push (adj);\n     }\n \n-  if (node->simdclone->inbranch)\n+  if (sc->inbranch)\n     {\n-      tree base_type\n-\t= simd_clone_compute_base_data_type (node->simdclone->origin,\n-\t\t\t\t\t     node->simdclone);\n+      tree base_type = simd_clone_compute_base_data_type (sc->origin, sc);\n \n       memset (&adj, 0, sizeof (adj));\n       adj.op = IPA_PARM_OP_NEW;\n       adj.arg_prefix = \"mask\";\n \n       adj.base_index = i;\n       if (INTEGRAL_TYPE_P (base_type) || POINTER_TYPE_P (base_type))\n-\tveclen = node->simdclone->vecsize_int;\n+\tveclen = sc->vecsize_int;\n       else\n-\tveclen = node->simdclone->vecsize_float;\n+\tveclen = sc->vecsize_float;\n       veclen /= GET_MODE_BITSIZE (TYPE_MODE (base_type));\n-      if (veclen > node->simdclone->simdlen)\n-\tveclen = node->simdclone->simdlen;\n-      if (POINTER_TYPE_P (base_type))\n+      if (veclen > sc->simdlen)\n+\tveclen = sc->simdlen;\n+      if (sc->mask_mode != VOIDmode)\n+\tadj.type\n+\t  = lang_hooks.types.type_for_mode (sc->mask_mode, 1);\n+      else if (POINTER_TYPE_P (base_type))\n \tadj.type = build_vector_type (pointer_sized_int_node, veclen);\n       else\n \tadj.type = build_vector_type (base_type, veclen);\n       adjustments.safe_push (adj);\n \n-      for (j = veclen; j < node->simdclone->simdlen; j += veclen)\n+      for (j = veclen; j < sc->simdlen; j += veclen)\n \tadjustments.safe_push (adj);\n \n       /* We have previously allocated one extra entry for the mask.  Use\n \t it and fill it.  */\n-      struct cgraph_simd_clone *sc = node->simdclone;\n       sc->nargs++;\n+      if (sc->mask_mode != VOIDmode)\n+\tbase_type = boolean_type_node;\n       if (node->definition)\n \t{\n \t  sc->args[i].orig_arg\n \t    = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL, base_type);\n-\t  sc->args[i].simd_array\n-\t    = create_tmp_simd_array (\"mask\", base_type, sc->simdlen);\n+\t  if (sc->mask_mode == VOIDmode)\n+\t    sc->args[i].simd_array\n+\t      = create_tmp_simd_array (\"mask\", base_type, sc->simdlen);\n+\t  else if (veclen < sc->simdlen)\n+\t    sc->args[i].simd_array\n+\t      = create_tmp_simd_array (\"mask\", adj.type, sc->simdlen / veclen);\n+\t  else\n+\t    sc->args[i].simd_array = NULL_TREE;\n \t}\n       sc->args[i].orig_type = base_type;\n       sc->args[i].arg_type = SIMD_CLONE_ARG_TYPE_MASK;\n@@ -19085,6 +19095,27 @@ simd_clone_init_simd_arrays (struct cgraph_node *node,\n       node->simdclone->args[i].vector_arg = arg;\n \n       tree array = node->simdclone->args[i].simd_array;\n+      if (node->simdclone->mask_mode != VOIDmode\n+\t  && node->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_MASK)\n+\t{\n+\t  if (array == NULL_TREE)\n+\t    continue;\n+\t  unsigned int l\n+\t    = tree_to_uhwi (TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (array))));\n+\t  for (k = 0; k <= l; k++)\n+\t    {\n+\t      if (k)\n+\t\t{\n+\t\t  arg = DECL_CHAIN (arg);\n+\t\t  j++;\n+\t\t}\n+\t      tree t = build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (array)),\n+\t\t\t       array, size_int (k), NULL, NULL);\n+\t      t = build2 (MODIFY_EXPR, TREE_TYPE (t), t, arg);\n+\t      gimplify_and_add (t, &seq);\n+\t    }\n+\t  continue;\n+\t}\n       if (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg)) == node->simdclone->simdlen)\n \t{\n \t  tree ptype = build_pointer_type (TREE_TYPE (TREE_TYPE (array)));\n@@ -19455,7 +19486,7 @@ simd_clone_adjust (struct cgraph_node *node)\n   e->probability = REG_BR_PROB_BASE;\n   gsi = gsi_last_bb (incr_bb);\n   gimple *g = gimple_build_assign (iter2, PLUS_EXPR, iter1,\n-\t\t\t\t  build_int_cst (unsigned_type_node, 1));\n+\t\t\t\t   build_int_cst (unsigned_type_node, 1));\n   gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n \n   /* Mostly annotate the loop for the vectorizer (the rest is done below).  */\n@@ -19471,21 +19502,68 @@ simd_clone_adjust (struct cgraph_node *node)\n       gimple_stmt_iterator gsi = gsi_last_bb (loop->header);\n       tree mask_array\n \t= node->simdclone->args[node->simdclone->nargs - 1].simd_array;\n-      tree mask = make_ssa_name (TREE_TYPE (TREE_TYPE (mask_array)));\n-      tree aref = build4 (ARRAY_REF,\n-\t\t\t  TREE_TYPE (TREE_TYPE (mask_array)),\n-\t\t\t  mask_array, iter1,\n-\t\t\t  NULL, NULL);\n-      g = gimple_build_assign (mask, aref);\n-      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-      int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (aref)));\n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (aref)))\n+      tree mask;\n+      if (node->simdclone->mask_mode != VOIDmode)\n \t{\n-\t  aref = build1 (VIEW_CONVERT_EXPR,\n-\t\t\t build_nonstandard_integer_type (bitsize, 0), mask);\n-\t  mask = make_ssa_name (TREE_TYPE (aref));\n+\t  tree shift_cnt;\n+\t  if (mask_array == NULL_TREE)\n+\t    {\n+\t      tree arg = node->simdclone->args[node->simdclone->nargs\n+\t\t\t\t\t       - 1].vector_arg;\n+\t      mask = get_or_create_ssa_default_def (cfun, arg);\n+\t      shift_cnt = iter1;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree maskt = TREE_TYPE (mask_array);\n+\t      int c = tree_to_uhwi (TYPE_MAX_VALUE (TYPE_DOMAIN (maskt)));\n+\t      c = node->simdclone->simdlen / (c + 1);\n+\t      int s = exact_log2 (c);\n+\t      gcc_assert (s > 0);\n+\t      c--;\n+\t      tree idx = make_ssa_name (TREE_TYPE (iter1));\n+\t      g = gimple_build_assign (idx, RSHIFT_EXPR, iter1,\n+\t\t\t\t       build_int_cst (NULL_TREE, s));\n+\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t      mask = make_ssa_name (TREE_TYPE (TREE_TYPE (mask_array)));\n+\t      tree aref = build4 (ARRAY_REF,\n+\t\t\t\t  TREE_TYPE (TREE_TYPE (mask_array)),\n+\t\t\t\t  mask_array, idx, NULL, NULL);\n+\t      g = gimple_build_assign (mask, aref);\n+\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t      shift_cnt = make_ssa_name (TREE_TYPE (iter1));\n+\t      g = gimple_build_assign (shift_cnt, BIT_AND_EXPR, iter1,\n+\t\t\t\t       build_int_cst (TREE_TYPE (iter1), c));\n+\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t    }\n+\t  g = gimple_build_assign (make_ssa_name (TREE_TYPE (mask)),\n+\t\t\t\t   RSHIFT_EXPR, mask, shift_cnt);\n+\t  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t  mask = gimple_assign_lhs (g);\n+\t  g = gimple_build_assign (make_ssa_name (TREE_TYPE (mask)),\n+\t\t\t\t   BIT_AND_EXPR, mask,\n+\t\t\t\t   build_int_cst (TREE_TYPE (mask), 1));\n+\t  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t  mask = gimple_assign_lhs (g);\n+\t}\n+      else\n+\t{\n+\t  mask = make_ssa_name (TREE_TYPE (TREE_TYPE (mask_array)));\n+\t  tree aref = build4 (ARRAY_REF,\n+\t\t\t      TREE_TYPE (TREE_TYPE (mask_array)),\n+\t\t\t      mask_array, iter1, NULL, NULL);\n \t  g = gimple_build_assign (mask, aref);\n \t  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t  int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (aref)));\n+\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (aref)))\n+\t    {\n+\t      aref = build1 (VIEW_CONVERT_EXPR,\n+\t\t\t     build_nonstandard_integer_type (bitsize, 0),\n+\t\t\t\t\t\t\t     mask);\n+\t      mask = make_ssa_name (TREE_TYPE (aref));\n+\t      g = gimple_build_assign (mask, aref);\n+\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t    }\n \t}\n \n       g = gimple_build_cond (EQ_EXPR, mask, build_zero_cst (TREE_TYPE (mask)),"}, {"sha": "409da311de49d507182f5e14c56c27a8aaa72f3e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "patch": "@@ -1,3 +1,12 @@\n+2016-04-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/attr-simd.c: Add scan-assembler* directives for AVX512F\n+\tclones.\n+\t* c-c++-common/attr-simd-2.c: Likewise.\n+\t* c-c++-common/attr-simd-4.c: Likewise.\n+\t* gcc.dg/gomp/simd-clones-2.c: Likewise.\n+\t* gcc.dg/gomp/simd-clones-3.c: Likewise.\n+\n 2016-04-07  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \tPR testsuite/70553"}, {"sha": "d76eba6a47174222ce4d1ec2dd1590362bf3ff26", "filename": "gcc/testsuite/c-c++-common/attr-simd-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd-2.c?ref=5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "patch": "@@ -19,3 +19,5 @@ int simd_attr (void)\n /* { dg-final { scan-assembler-times \"_ZGVcM4_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-times \"_ZGVdN8_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-times \"_ZGVdM8_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVeN16_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVeM16_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */"}, {"sha": "2a58587ce36e276661877c68214ab39af5d7348f", "filename": "gcc/testsuite/c-c++-common/attr-simd-4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd-4.c?ref=5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "patch": "@@ -15,9 +15,11 @@ int simd_attr (void)\n /* { dg-final { scan-assembler-times \"_ZGVbN4_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-times \"_ZGVcN4_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-times \"_ZGVdN8_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVeN16_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-not \"_ZGVbM4_simd_attr:\" { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-not \"_ZGVcM4_simd_attr:\" { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-not \"_ZGVdM8_simd_attr:\" { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-not \"_ZGVeM16_simd_attr:\" { target { i?86-*-* x86_64-*-* } } } } */\n \n extern\n #ifdef __cplusplus\n@@ -33,6 +35,8 @@ int simd_attr2 (void)\n /* { dg-final { scan-assembler-not \"_ZGVbN4_simd_attr2:\" { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-not \"_ZGVcN4_simd_attr2:\" { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-not \"_ZGVdN8_simd_attr2:\" { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-not \"_ZGVeN16_simd_attr2:\" { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-times \"_ZGVbM4_simd_attr2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-times \"_ZGVcM4_simd_attr2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-times \"_ZGVdM8_simd_attr2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVeM16_simd_attr2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */"}, {"sha": "dde2475f9b0403833d55e2ec18ba2470e6581bac", "filename": "gcc/testsuite/c-c++-common/attr-simd.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd.c?ref=5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "patch": "@@ -18,6 +18,8 @@ int simd_attr (void)\n /* { dg-final { scan-assembler-times \"_ZGVcM4_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-times \"_ZGVdN8_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-times \"_ZGVdM8_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVeN16_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVeM16_simd_attr:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n \n extern\n #ifdef __cplusplus\n@@ -36,3 +38,5 @@ int simd_attr2 (void)\n /* { dg-final { scan-assembler-times \"_ZGVcM4_simd_attr2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-times \"_ZGVdN8_simd_attr2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n /* { dg-final { scan-assembler-times \"_ZGVdM8_simd_attr2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVeN16_simd_attr2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"_ZGVeM16_simd_attr2:\" 1 { target { i?86-*-* x86_64-*-* } } } } */"}, {"sha": "df7f63141335dfbd3264a84995214276f142294a", "filename": "gcc/testsuite/gcc.dg/gomp/simd-clones-2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-2.c?ref=5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "patch": "@@ -23,3 +23,6 @@ float setArray(float *a, float x, int k)\n /* { dg-final { scan-tree-dump \"_ZGVdN8ua32vl_setArray\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n /* { dg-final { scan-tree-dump \"_ZGVdN8vvva32_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n /* { dg-final { scan-tree-dump \"_ZGVdM8vl66u_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVeN16ua32vl_setArray\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVeN16vvva32_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVeM16vl66u_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */"}, {"sha": "28570a244cb3c0a8030767a84c8533eb4df4adc9", "filename": "gcc/testsuite/gcc.dg/gomp/simd-clones-3.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-3.c?ref=5f490f9f7a81f213cbee1c0efcc1c6ea82bcd39d", "patch": "@@ -15,3 +15,5 @@ int addit(int a, int b, int c)\n /* { dg-final { scan-tree-dump \"_ZGVcM4vvv_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n /* { dg-final { scan-tree-dump \"_ZGVdN8vvv_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n /* { dg-final { scan-tree-dump \"_ZGVdM8vvv_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVeN16vvv_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVeM16vvv_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */"}]}