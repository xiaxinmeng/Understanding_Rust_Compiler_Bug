{"sha": "2a87fbe84e9cb099440fc173129735044f1aae6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE4N2ZiZTg0ZTljYjA5OTQ0MGZjMTczMTI5NzM1MDQ0ZjFhYWU2Zg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-04-04T21:17:20Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-04T21:17:20Z"}, "message": "cpplex.c (trigraph_map, speccase): Combine into single table, chartab.\n\n\t* cpplex.c (trigraph_map, speccase): Combine into single\n\ttable, chartab.\n\t(NORMAL, NONTRI): New macros.\n\t(_cpp_read_and_prescan): Change to use unified table.  Use\n\tis_hspace to test for whitespace.\n\nFrom-SVN: r32912", "tree": {"sha": "50de542f3dad2224ab018fa9f5a57ac0ea59b36b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50de542f3dad2224ab018fa9f5a57ac0ea59b36b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a87fbe84e9cb099440fc173129735044f1aae6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a87fbe84e9cb099440fc173129735044f1aae6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a87fbe84e9cb099440fc173129735044f1aae6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a87fbe84e9cb099440fc173129735044f1aae6f/comments", "author": null, "committer": null, "parents": [{"sha": "21e62dfa2a67a84aa0bd2ca093046287f13fbcb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21e62dfa2a67a84aa0bd2ca093046287f13fbcb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21e62dfa2a67a84aa0bd2ca093046287f13fbcb5"}], "stats": {"total": 68, "additions": 32, "deletions": 36}, "files": [{"sha": "44c63873b7d93cef7e781b297c27a088fafefcc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a87fbe84e9cb099440fc173129735044f1aae6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a87fbe84e9cb099440fc173129735044f1aae6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a87fbe84e9cb099440fc173129735044f1aae6f", "patch": "@@ -1,3 +1,11 @@\n+2000-04-04  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplex.c (trigraph_map, speccase): Combine into single\n+\ttable, chartab.\n+\t(NORMAL, NONTRI): New macros.\n+\t(_cpp_read_and_prescan): Change to use unified table.  Use\n+\tis_hspace to test for whitespace.\n+\n 2000-04-04  Clinton Popetz  <cpopetz@cygnus.com>\n \n \t* builtins.c (expand_builtin_strlen): Force the source to"}, {"sha": "56f061ba6ebc86a73782e833d1cd99664658e67f", "filename": "gcc/cpplex.c", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a87fbe84e9cb099440fc173129735044f1aae6f/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a87fbe84e9cb099440fc173129735044f1aae6f/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=2a87fbe84e9cb099440fc173129735044f1aae6f", "patch": "@@ -1268,62 +1268,51 @@ find_position (start, limit, linep)\n   return lbase;\n }\n \n-/* These are tables used by _cpp_read_and_prescan.  If we have\n-   designated initializers, they can be constant data; otherwise, they\n-   are set up at runtime by _cpp_init_input_buffer.  */\n+/* The following table is used by _cpp_read_and_prescan.  If we have\n+   designated initializers, it can be constant data; otherwise, it is\n+   set up at runtime by _cpp_init_input_buffer.  */\n \n #ifndef UCHAR_MAX\n #define UCHAR_MAX 255\t/* assume 8-bit bytes */\n #endif\n \n #if (GCC_VERSION >= 2007) || (__STDC_VERSION__ >= 199901L)\n-#define CHARTAB(name) static const unsigned char name[UCHAR_MAX + 1]\n-#define init_speccase()  /* nothing */\n-#define init_trigraph_map() /* nothing */\n-#define SPECCASE CHARTAB(speccase) = {\n-#define TRIGRAPH_MAP CHARTAB(trigraph_map) = {\n+#define init_chartab()  /* nothing */\n+#define CHARTAB static const unsigned char chartab[UCHAR_MAX + 1] = {\n #define END };\n #define s(p, v) [p] = v,\n #else\n-#define CHARTAB(name) static unsigned char name[UCHAR_MAX + 1]\n-#define SPECCASE CHARTAB(speccase) = { 0 }; \\\n- static void init_speccase PARAMS ((void)) { \\\n- unsigned char *x = speccase;\n-#define TRIGRAPH_MAP CHARTAB(trigraph_map) = { 0 }; \\\n- static void init_trigraph_map PARAMS ((void)) { \\\n- unsigned char *x = trigraph_map;\n+#define CHARTAB static unsigned char chartab[UCHAR_MAX + 1] = { 0 }; \\\n+ static void init_chartab PARAMS ((void)) { \\\n+ unsigned char *x = chartab;\n #define END }\n #define s(p, v) x[p] = v;\n #endif\n \n /* Table of characters that can't be handled in the inner loop.\n-   Keep these contiguous to optimize the performance of the code generated\n-   for the switch that uses them.  */\n-#define SPECCASE_EMPTY     0\n+   Also contains the mapping between trigraph third characters and their\n+   replacements.  */\n #define SPECCASE_CR        1\n #define SPECCASE_BACKSLASH 2\n #define SPECCASE_QUESTION  3\n  \n-SPECCASE\n+CHARTAB\n   s('\\r', SPECCASE_CR)\n   s('\\\\', SPECCASE_BACKSLASH)\n   s('?',  SPECCASE_QUESTION)\n-END\n \n-/* Map of trigraph third characters to their replacements.  */\n-  \n-TRIGRAPH_MAP\n   s('=', '#')\ts(')', ']')\ts('!', '|')\n   s('(', '[')\ts('\\'', '^')\ts('>', '}')\n   s('/', '\\\\')\ts('<', '{')\ts('-', '~')\n END\n \n #undef CHARTAB\n-#undef SPECCASE\n-#undef TRIGRAPH_MAP\n #undef END\n #undef s\n \n+#define NORMAL(c) ((chartab[c]) == 0 || (chartab[c]) > SPECCASE_QUESTION)\n+#define NONTRI(c) ((c) <= SPECCASE_QUESTION)\n+\n /* Read the entire contents of file DESC into buffer BUF.  LEN is how\n    much memory to allocate initially; more will be allocated if\n    necessary.  Convert end-of-line markers (\\n, \\r, \\r\\n, \\n\\r) to\n@@ -1438,20 +1427,20 @@ _cpp_read_and_prescan (pfile, fp, desc, len)\n \t  /* Deal with \\-newline, potentially in the middle of a token. */\n \t  if (deferred_newlines)\n \t    {\n-\t      if (op != buf && op[-1] != ' ' && op[-1] != '\\n' && op[-1] != '\\t' && op[-1] != '\\r')\n+\t      if (op != buf && ! is_space (op[-1]) && op[-1] != '\\r')\n \t\t{\n \t\t  /* Previous was not white space.  Skip to white\n \t\t     space, if we can, before outputting the \\r's */\n \t\t  span = 0;\n \t\t  while (ip[span] != ' '\n \t\t\t && ip[span] != '\\t'\n \t\t\t && ip[span] != '\\n'\n-\t\t\t && speccase[ip[span]] == SPECCASE_EMPTY)\n+\t\t\t && NORMAL(ip[span]))\n \t\t    span++;\n \t\t  memcpy (op, ip, span);\n \t\t  op += span;\n \t\t  ip += span;\n-\t\t  if (speccase[ip[0]] != SPECCASE_EMPTY)\n+\t\t  if (! NORMAL(ip[0]))\n \t\t    goto do_speccase;\n \t\t}\n \t      while (deferred_newlines)\n@@ -1460,15 +1449,15 @@ _cpp_read_and_prescan (pfile, fp, desc, len)\n \n \t  /* Copy as much as we can without special treatment. */\n \t  span = 0;\n-\t  while (speccase[ip[span]] == SPECCASE_EMPTY) span++;\n+\t  while (NORMAL (ip[span])) span++;\n \t  memcpy (op, ip, span);\n \t  op += span;\n \t  ip += span;\n \n \tdo_speccase:\n \t  if (ip > near_buff_end) /* Do we have enough chars? */\n \t    break;\n-\t  switch (speccase[*ip++])\n+\t  switch (chartab[*ip++])\n \t    {\n \t    case SPECCASE_CR:  /* \\r */\n \t      if (ip[-2] != '\\n')\n@@ -1505,8 +1494,8 @@ _cpp_read_and_prescan (pfile, fp, desc, len)\n \t\t  break;\n \t\t    \n \t\td = ip[1];\n-\t\tt = trigraph_map[d];\n-\t\tif (t == 0)\n+\t\tt = chartab[d];\n+\t\tif (NONTRI (t))\n \t\t  break;\n \n \t\tif (CPP_OPTION (pfile, warn_trigraphs))\n@@ -1578,17 +1567,16 @@ _cpp_read_and_prescan (pfile, fp, desc, len)\n   return -1;\n }\n \n-/* Allocate pfile->input_buffer, and initialize speccase[] and\n-   trigraph_map[] if it hasn't happened already.  */\n+/* Allocate pfile->input_buffer, and initialize chartab[]\n+   if it hasn't happened already.  */\n  \n void\n _cpp_init_input_buffer (pfile)\n      cpp_reader *pfile;\n {\n   U_CHAR *tmp;\n \n-  init_speccase ();\n-  init_trigraph_map ();\n+  init_chartab ();\n \n   /* Determine the appropriate size for the input buffer.  Normal C\n      source files are smaller than eight K.  */"}]}