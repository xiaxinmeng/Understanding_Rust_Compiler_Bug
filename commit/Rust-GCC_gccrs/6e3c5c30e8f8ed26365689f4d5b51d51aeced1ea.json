{"sha": "6e3c5c30e8f8ed26365689f4d5b51d51aeced1ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUzYzVjMzBlOGY4ZWQyNjM2NTY4OWY0ZDViNTFkNTFhZWNlZDFlYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2008-04-18T15:22:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2008-04-18T15:22:40Z"}, "message": "fold-const.c (pointer_may_wrap_p): New static function.\n\n\t* fold-const.c (pointer_may_wrap_p): New static function.\n\t(fold_comparison): Add another test for pointer overflow.  Use\n\tpointer_may_wrap_p to disable some false positives.\n\nFrom-SVN: r134440", "tree": {"sha": "1445e3ff80f2b0fb59f3e865b2d505a26ecc0254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1445e3ff80f2b0fb59f3e865b2d505a26ecc0254"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e3c5c30e8f8ed26365689f4d5b51d51aeced1ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3c5c30e8f8ed26365689f4d5b51d51aeced1ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e3c5c30e8f8ed26365689f4d5b51d51aeced1ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3c5c30e8f8ed26365689f4d5b51d51aeced1ea/comments", "author": null, "committer": null, "parents": [{"sha": "b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf"}], "stats": {"total": 91, "additions": 87, "deletions": 4}, "files": [{"sha": "270b12e159cb56720d1a88ecfb12a184430d0985", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3c5c30e8f8ed26365689f4d5b51d51aeced1ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3c5c30e8f8ed26365689f4d5b51d51aeced1ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e3c5c30e8f8ed26365689f4d5b51d51aeced1ea", "patch": "@@ -1,3 +1,9 @@\n+2008-04-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* fold-const.c (pointer_may_wrap_p): New static function.\n+\t(fold_comparison): Add another test for pointer overflow.  Use\n+\tpointer_may_wrap_p to disable some false positives.\n+\n 2008-04-18  Kris Van Hees <kris.van.hees@oracle.com>\n \t  \n \t* c-common.c (CHAR16_TYPE, CHAR32_TYPE): New macros."}, {"sha": "f5ec30c17066d5deb2915ec0a8a8d9453fd81bd9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 81, "deletions": 4, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3c5c30e8f8ed26365689f4d5b51d51aeced1ea/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3c5c30e8f8ed26365689f4d5b51d51aeced1ea/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6e3c5c30e8f8ed26365689f4d5b51d51aeced1ea", "patch": "@@ -8394,6 +8394,66 @@ maybe_canonicalize_comparison (enum tree_code code, tree type,\n   return t;\n }\n \n+/* Return whether BASE + OFFSET + BITPOS may wrap around the address\n+   space.  This is used to avoid issuing overflow warnings for\n+   expressions like &p->x which can not wrap.  */\n+\n+static bool\n+pointer_may_wrap_p (tree base, tree offset, HOST_WIDE_INT bitpos)\n+{\n+  tree size;\n+  unsigned HOST_WIDE_INT offset_low, total_low;\n+  HOST_WIDE_INT offset_high, total_high;\n+\n+  if (!POINTER_TYPE_P (TREE_TYPE (base)))\n+    return true;\n+\n+  if (bitpos < 0)\n+    return true;\n+\n+  size = size_in_bytes (TREE_TYPE (TREE_TYPE (base)));\n+  if (size == NULL_TREE || TREE_CODE (size) != INTEGER_CST)\n+    return true;\n+\n+  /* We can do slightly better for SIZE if we have an ADDR_EXPR of an\n+     array.  */\n+  if (TREE_CODE (base) == ADDR_EXPR)\n+    {\n+      tree base_size = size_in_bytes (TREE_TYPE (TREE_OPERAND (base, 0)));\n+      if (base_size != NULL_TREE\n+\t  && TREE_CODE (base_size) == INTEGER_CST\n+\t  && INT_CST_LT_UNSIGNED (size, base_size))\n+\tsize = base_size;\n+    }\n+\n+  if (offset == NULL_TREE)\n+    {\n+      offset_low = 0;\n+      offset_high = 0;\n+    }\n+  else if (TREE_CODE (offset) != INTEGER_CST || TREE_OVERFLOW (offset))\n+    return true;\n+  else\n+    {\n+      offset_low = TREE_INT_CST_LOW (offset);\n+      offset_high = TREE_INT_CST_HIGH (offset);\n+    }\n+\n+  if (add_double_with_sign (offset_low, offset_high,\n+\t\t\t    bitpos / BITS_PER_UNIT, 0,\n+\t\t\t    &total_low, &total_high,\n+\t\t\t    true))\n+    return true;\n+\n+  if ((unsigned HOST_WIDE_INT) total_high\n+      < (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (size))\n+    return false;\n+  if ((unsigned HOST_WIDE_INT) total_high\n+      > (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (size))\n+    return true;\n+  return total_low > TREE_INT_CST_LOW (size);\n+}\n+\n /* Subroutine of fold_binary.  This routine performs all of the\n    transformations that are common to the equality/inequality\n    operators (EQ_EXPR and NE_EXPR) and the ordering operators\n@@ -8544,10 +8604,24 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t{\n \t  /* We can fold this expression to a constant if the non-constant\n \t     offset parts are equal.  */\n-\t  if (offset0 == offset1\n-\t      || (offset0 && offset1\n-\t\t  && operand_equal_p (offset0, offset1, 0)))\n+\t  if ((offset0 == offset1\n+\t       || (offset0 && offset1\n+\t\t   && operand_equal_p (offset0, offset1, 0)))\n+\t      && (code == EQ_EXPR\n+\t\t  || code == NE_EXPR\n+\t\t  || POINTER_TYPE_OVERFLOW_UNDEFINED))\n+\t\t\n \t    {\n+\t      if (code != EQ_EXPR\n+\t\t  && code != NE_EXPR\n+\t\t  && bitpos0 != bitpos1\n+\t\t  && (pointer_may_wrap_p (base0, offset0, bitpos0)\n+\t\t      || pointer_may_wrap_p (base1, offset1, bitpos1)))\n+\t\tfold_overflow_warning ((\"assuming pointer wraparound does not \"\n+\t\t\t\t\t\"occur when comparing P +- C1 with \"\n+\t\t\t\t\t\"P +- C2\"),\n+\t\t\t\t       WARN_STRICT_OVERFLOW_CONDITIONAL);\n+\n \t      switch (code)\n \t\t{\n \t\tcase EQ_EXPR:\n@@ -8593,7 +8667,10 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t      else\n \t\toffset1 = fold_convert (signed_size_type_node, offset1);\n \n-\t      if (code != EQ_EXPR && code != NE_EXPR)\n+\t      if (code != EQ_EXPR\n+\t\t  && code != NE_EXPR\n+\t\t  && (pointer_may_wrap_p (base0, offset0, bitpos0)\n+\t\t      || pointer_may_wrap_p (base1, offset1, bitpos1)))\n \t\tfold_overflow_warning ((\"assuming pointer wraparound does not \"\n \t\t\t\t\t\"occur when comparing P +- C1 with \"\n \t\t\t\t\t\"P +- C2\"),"}]}