{"sha": "e767b5be438a67c59f8f23b6214fcbb7183a8092", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc2N2I1YmU0MzhhNjdjNTlmOGYyM2I2MjE0ZmNiYjcxODNhODA5Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-08-16T11:04:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-08-16T11:04:59Z"}, "message": "i386.c (ix86_fntype_regparm): Rename from ...\n\n\t* i386.c (ix86_fntype_regparm): Rename from ...\n\t(ix86_function_regparm): ... this one; add fastcall and local\n\tfunctions.\n\t(ix86_function_ok_for_sibcall): Update.\n\t(ix86_return_pops_args): Likewise.\n\t(init_cumulative_args): Likewise.\n\t(x86_can_output_mi_thunk): Likewise.\n\t(function_arg): Fix formating.\n\t(x86_this_parameter): Fix fastcall.\n\t(x86_output_mi_thunk): Likewise.\n\n\t* cgraph.c (cgraph_mark_needed_node): Do not mark functions without\n\tbody as reachable; mark nested functions as needed too.\n\t(dump_cgraph): Do not output global.calls.\n\t* cgraph.h (cgraph_global_info): Kill.\n\t* cgraphunit.c (cgraph_finalize_function): Enqueue needed functions.\n\t(record_call_1): Speedup.\n\t(cgraph_analyze_function): Break out from ...; compute inlining\n\tparameters.\n\t(cgraph_finalize_compilation_unit): ... here.\n\t(cgraph_mark_inline): Kill computation of calls.\n\t(cgraph_decide_inlining): Do not compute most of initial values.\n\nFrom-SVN: r70504", "tree": {"sha": "df38d256a957a8ffd8b53d92a0e7ccf9f23354bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df38d256a957a8ffd8b53d92a0e7ccf9f23354bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e767b5be438a67c59f8f23b6214fcbb7183a8092", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e767b5be438a67c59f8f23b6214fcbb7183a8092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e767b5be438a67c59f8f23b6214fcbb7183a8092", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e767b5be438a67c59f8f23b6214fcbb7183a8092/comments", "author": null, "committer": null, "parents": [{"sha": "5ab7486eee0b529d1561533e0b1216c33b652621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab7486eee0b529d1561533e0b1216c33b652621", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ab7486eee0b529d1561533e0b1216c33b652621"}], "stats": {"total": 277, "additions": 156, "deletions": 121}, "files": [{"sha": "a88550421367532caa819342add6d947d756d8b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e767b5be438a67c59f8f23b6214fcbb7183a8092/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e767b5be438a67c59f8f23b6214fcbb7183a8092/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e767b5be438a67c59f8f23b6214fcbb7183a8092", "patch": "@@ -1,3 +1,28 @@\n+2003-08-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_fntype_regparm): Rename from ...\n+\t(ix86_function_regparm): ... this one; add fastcall and local\n+\tfunctions.\n+\t(ix86_function_ok_for_sibcall): Update.\n+\t(ix86_return_pops_args): Likewise.\n+\t(init_cumulative_args): Likewise.\n+\t(x86_can_output_mi_thunk): Likewise.\n+\t(function_arg): Fix formating.\n+\t(x86_this_parameter): Fix fastcall.\n+\t(x86_output_mi_thunk): Likewise.\n+\n+\t* cgraph.c (cgraph_mark_needed_node): Do not mark functions without\n+\tbody as reachable; mark nested functions as needed too.\n+\t(dump_cgraph): Do not output global.calls.\n+\t* cgraph.h (cgraph_global_info): Kill.\n+\t* cgraphunit.c (cgraph_finalize_function): Enqueue needed functions.\n+\t(record_call_1): Speedup.\n+\t(cgraph_analyze_function): Break out from ...; compute inlining\n+\tparameters.\n+\t(cgraph_finalize_compilation_unit): ... here.\n+\t(cgraph_mark_inline): Kill computation of calls.\n+\t(cgraph_decide_inlining): Do not compute most of initial values.\n+\n 2003-08-14  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (negate_expr_p): MULT_EXPRs and RDIV_EXPRs are easy"}, {"sha": "9aa12a6102df81691ed2575e48dec287175a2495", "filename": "gcc/cgraph.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e767b5be438a67c59f8f23b6214fcbb7183a8092/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e767b5be438a67c59f8f23b6214fcbb7183a8092/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e767b5be438a67c59f8f23b6214fcbb7183a8092", "patch": "@@ -240,17 +240,24 @@ void\n cgraph_mark_needed_node (struct cgraph_node *node, int needed)\n {\n   if (needed)\n-    {\n-      node->needed = 1;\n-    }\n-  if (!node->reachable)\n+    node->needed = 1;\n+\n+  if (!node->reachable && DECL_SAVED_TREE (node->decl))\n     {\n       node->reachable = 1;\n-      if (DECL_SAVED_TREE (node->decl))\n+\n+      node->next_needed = cgraph_nodes_queue;\n+      cgraph_nodes_queue = node;\n+\n+      /* At the moment frontend automatically emits all nested functions.  */\n+      if (node->nested)\n \t{\n-\t  node->next_needed = cgraph_nodes_queue;\n-\t  cgraph_nodes_queue = node;\n-        }\n+\t  struct cgraph_node *node2;\n+\n+\t  for (node2 = node->nested; node2; node2 = node2->next_nested)\n+\t    if (!node2->reachable)\n+\t      cgraph_mark_needed_node (node2, 0);\n+\t}\n     }\n }\n \n@@ -361,8 +368,6 @@ dump_cgraph (FILE *f)\n \tfprintf (f, \" %i insns after inlining\", node->global.insns);\n       if (node->global.cloned_times > 1)\n \tfprintf (f, \" cloned %ix\", node->global.cloned_times);\n-      if (node->global.calls)\n-\tfprintf (f, \" %i calls\", node->global.calls);\n \n       fprintf (f, \"\\n  called by :\");\n       for (edge = node->callers; edge; edge = edge->next_caller)"}, {"sha": "f96ac0d0d59ab1483303a1f242a58c3ed6b5b9dd", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e767b5be438a67c59f8f23b6214fcbb7183a8092/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e767b5be438a67c59f8f23b6214fcbb7183a8092/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e767b5be438a67c59f8f23b6214fcbb7183a8092", "patch": "@@ -52,9 +52,6 @@ struct cgraph_global_info GTY(())\n   /* Estimated size of the function after inlining.  */\n   int insns;\n \n-  /* Number of direct calls not inlined into the function body.  */\n-  int calls;\n-\n   /* Number of times given function will be cloned during output.  */\n   int cloned_times;\n "}, {"sha": "faf6850910018376d52992b3582c9d0556020ef6", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 50, "deletions": 54, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e767b5be438a67c59f8f23b6214fcbb7183a8092/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e767b5be438a67c59f8f23b6214fcbb7183a8092/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e767b5be438a67c59f8f23b6214fcbb7183a8092", "patch": "@@ -65,6 +65,10 @@ cgraph_finalize_function (tree decl, tree body ATTRIBUTE_UNUSED)\n   node->decl = decl;\n   node->local.finalized = true;\n \n+  /* Function now has DECL_SAVED_TREE set.  Enqueue it into cgraph_nodes_queue\n+     if needed.  */\n+  if (node->needed)\n+    cgraph_mark_needed_node (node, 0);\n   if (/* Externally visible functions must be output.  The exception are\n \t COMDAT functions that must be output only when they are needed.\n \t Similarly are handled deferred functions and\n@@ -122,6 +126,10 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n \t  *walk_subtrees = 0;\n \t}\n     }\n+  /* Save some cycles by not walking types and declaration as we won't find anything\n+     usefull there anyway.  */\n+  if (DECL_P (*tp) || TYPE_P (*tp))\n+    *walk_subtrees = 0;\n   return NULL;\n }\n \n@@ -135,13 +143,46 @@ cgraph_create_edges (tree decl, tree body)\n   walk_tree_without_duplicates (&body, record_call_1, decl);\n }\n \n+/* Analyze the function scheduled to be output.  */\n+static void\n+cgraph_analyze_function (struct cgraph_node *node)\n+{\n+  tree decl = node->decl;\n+\n+  if (lang_hooks.callgraph.lower_function)\n+    (*lang_hooks.callgraph.lower_function) (decl);\n+\n+  current_function_decl = node->decl;\n+\n+  /* First kill forward declaration so reverse inlining works properly.  */\n+  cgraph_create_edges (decl, DECL_SAVED_TREE (decl));\n+\n+  node->local.inlinable = tree_inlinable_function_p (decl);\n+  if (!DECL_ESTIMATED_INSNS (decl))\n+    DECL_ESTIMATED_INSNS (decl)\n+      = (*lang_hooks.tree_inlining.estimate_num_insns) (decl);\n+  node->local.self_insns = DECL_ESTIMATED_INSNS (decl);\n+  if (node->local.inlinable)\n+    node->local.disregard_inline_limits\n+      = (*lang_hooks.tree_inlining.disregard_inline_limits) (decl);\n+\n+  /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n+  node->global.insns = node->local.self_insns;\n+  if (!DECL_EXTERNAL (node->decl))\n+    {\n+      node->global.cloned_times = 1;\n+      node->global.will_be_output = true;\n+    }\n+\n+  node->lowered = true;\n+}\n+\n /* Analyze the whole compilation unit once it is parsed completely.  */\n \n void\n cgraph_finalize_compilation_unit (void)\n {\n   struct cgraph_node *node;\n-  struct cgraph_edge *edge;\n \n   cgraph_varpool_assemble_pending_decls ();\n   if (!quiet_flag)\n@@ -163,6 +204,7 @@ cgraph_finalize_compilation_unit (void)\n      method table generation for instance).  */\n   while (cgraph_nodes_queue)\n     {\n+      struct cgraph_edge *edge;\n       tree decl = cgraph_nodes_queue->decl;\n \n       node = cgraph_nodes_queue;\n@@ -171,38 +213,12 @@ cgraph_finalize_compilation_unit (void)\n       if (node->lowered || !node->reachable || !DECL_SAVED_TREE (decl))\n \tabort ();\n \n-      if (lang_hooks.callgraph.lower_function)\n-\t(*lang_hooks.callgraph.lower_function) (decl);\n-\n-      current_function_decl = node->decl;\n-\n-      /* At the moment frontend automatically emits all nested functions.  */\n-      if (node->nested)\n-\t{\n-\t  struct cgraph_node *node2;\n-\n-\t  for (node2 = node->nested; node2; node2 = node2->next_nested)\n-\t    if (!node2->reachable)\n-\t      cgraph_mark_needed_node (node2, 0);\n-\t}\n-\n-      /* First kill forward declaration so reverse inlining works properly.  */\n-      cgraph_create_edges (decl, DECL_SAVED_TREE (decl));\n-\n-      node->local.inlinable = tree_inlinable_function_p (decl);\n-      DECL_ESTIMATED_INSNS (decl)\n-        = (*lang_hooks.tree_inlining.estimate_num_insns) (decl);\n-      node->local.self_insns = DECL_ESTIMATED_INSNS (decl);\n-      if (node->local.inlinable)\n-\tnode->local.disregard_inline_limits\n-\t  = (*lang_hooks.tree_inlining.disregard_inline_limits) (decl);\n-\n+      cgraph_analyze_function (node);\n       for (edge = node->callees; edge; edge = edge->next_callee)\n-\t{\n-\t  if (!edge->callee->reachable)\n-            cgraph_mark_needed_node (edge->callee, 0);\n-\t}\n-      node->lowered = true;\n+      {\n+\tif (!edge->callee->reachable)\n+\t    cgraph_mark_needed_node (edge->callee, 0);\n+      }\n       cgraph_varpool_assemble_pending_decls ();\n     }\n   /* Collect entry points to the unit.  */\n@@ -214,6 +230,7 @@ cgraph_finalize_compilation_unit (void)\n \tif (node->needed && DECL_SAVED_TREE (node->decl))\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\");\n+      dump_cgraph (cgraph_dump_file);\n     }\n \n   if (cgraph_dump_file)\n@@ -650,7 +667,6 @@ cgraph_mark_inline (struct cgraph_node *to, struct cgraph_node *what,\n     overall_insns += new_insns - to->global.insns;\n   to->global.insns = new_insns;\n \n-  to->global.calls += (what->global.calls - 1) *times;\n   if (!called && !what->needed && !what->origin\n       && !DECL_EXTERNAL (what->decl))\n     {\n@@ -662,8 +678,6 @@ cgraph_mark_inline (struct cgraph_node *to, struct cgraph_node *what,\n       overall_insns -= what->global.insns;\n     }\n   what->global.cloned_times += clones;\n-  if (to->global.calls < 0)\n-    abort ();\n   for (i = 0; i < ninlined; i++)\n     {\n       new_insns =\n@@ -672,10 +686,6 @@ cgraph_mark_inline (struct cgraph_node *to, struct cgraph_node *what,\n       if (inlined[i]->global.will_be_output)\n \toverall_insns += new_insns - inlined[i]->global.insns;\n       inlined[i]->global.insns = new_insns;\n-      inlined[i]->global.calls +=\n-\t(what->global.calls - 1) *INLINED_TIMES (inlined[i]) * times;\n-      if (inlined[i]->global.calls < 0)\n-\tabort ();\n     }\n   for (i = 0; i < ninlined_callees; i++)\n     {\n@@ -883,21 +893,7 @@ cgraph_decide_inlining (void)\n   int i, y;\n \n   for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      int ncalls = 0;\n-      struct cgraph_edge *e;\n-\n-      node->global.insns = node->local.self_insns;\n-      for (e = node->callees; e; e = e->next_callee)\n-\tncalls++;\n-      node->global.calls = ncalls;\n-      if (!DECL_EXTERNAL (node->decl))\n-\t{\n-\t  node->global.cloned_times = 1;\n-\t  initial_insns += node->local.self_insns;\n-\t  node->global.will_be_output = true;\n-\t}\n-    }\n+    initial_insns += node->local.self_insns;\n   overall_insns = initial_insns;\n \n   nnodes = cgraph_postorder (order);"}, {"sha": "db404f07b10dcfcaa1c13d2107c0eacffce4144d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 66, "deletions": 54, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e767b5be438a67c59f8f23b6214fcbb7183a8092/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e767b5be438a67c59f8f23b6214fcbb7183a8092/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e767b5be438a67c59f8f23b6214fcbb7183a8092", "patch": "@@ -866,7 +866,7 @@ static unsigned int ix86_select_alt_pic_regnum (void);\n static int ix86_save_reg (unsigned int, int);\n static void ix86_compute_frame_layout (struct ix86_frame *);\n static int ix86_comp_type_attributes (tree, tree);\n-static int ix86_fntype_regparm (tree);\n+static int ix86_function_regparm (tree, tree);\n const struct attribute_spec ix86_attribute_table[];\n static bool ix86_function_ok_for_sibcall (tree, tree);\n static tree ix86_handle_cdecl_attribute (tree *, tree, tree, int, bool *);\n@@ -1532,19 +1532,14 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n      such registers are not used for passing parameters.  */\n   if (!decl && !TARGET_64BIT)\n     {\n-      int regparm = ix86_regparm;\n-      tree attr, type;\n+      tree type;\n \n       /* We're looking at the CALL_EXPR, we need the type of the function.  */\n       type = TREE_OPERAND (exp, 0);\t\t/* pointer expression */\n       type = TREE_TYPE (type);\t\t\t/* pointer type */\n       type = TREE_TYPE (type);\t\t\t/* function type */\n \n-      attr = lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (type));\n-      if (attr)\n-        regparm = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr)));\n-\n-      if (regparm >= 3)\n+      if (ix86_function_regparm (type, NULL) >= 3)\n \t{\n \t  /* ??? Need to count the actual number of registers to be used,\n \t     not the possible number of registers.  Fix later.  */\n@@ -1637,9 +1632,9 @@ ix86_handle_regparm_attribute (tree *node, tree name, tree args,\n \t}\n \n       if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (*node)))\n-    {\n-      error (\"fastcall and regparm attributes are not compatible\");\n-    }\n+\t{\n+\t  error (\"fastcall and regparm attributes are not compatible\");\n+\t}\n     }\n \n   return NULL_TREE;\n@@ -1670,18 +1665,49 @@ ix86_comp_type_attributes (tree type1, tree type2)\n   return 1;\n }\n \f\n-/* Return the regparm value for a fuctio with the indicated TYPE.  */\n+/* Return the regparm value for a fuctio with the indicated TYPE and DECL.\n+   DECL may be NULL when calling function indirectly\n+   or considerling a libcall.  */\n \n static int\n-ix86_fntype_regparm (tree type)\n+ix86_function_regparm (tree type, tree decl)\n {\n   tree attr;\n+  int regparm = ix86_regparm;\n+  bool user_convention = false;\n \n-  attr = lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (type));\n-  if (attr)\n-    return TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr)));\n-  else\n-    return ix86_regparm;\n+  if (!TARGET_64BIT)\n+    {\n+      attr = lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (type));\n+      if (attr)\n+\t{\n+\t  regparm = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr)));\n+\t  user_convention = true;\n+\t}\n+\n+      if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (type)))\n+\t{\n+\t  regparm = 2;\n+\t  user_convention = true;\n+\t}\n+\n+      /* Use register calling convention for local functions when possible.  */\n+      if (!TARGET_64BIT && !user_convention && decl\n+\t  && flag_unit_at_a_time)\n+\t{\n+\t  struct cgraph_local_info *i = cgraph_local_info (decl);\n+\t  if (i && i->local)\n+\t    {\n+\t      /* We can't use regparm(3) for nested functions as these use\n+\t\t static chain pointer in third argument.  */\n+\t      if (DECL_CONTEXT (decl) && !DECL_NO_STATIC_CHAIN (decl))\n+\t\tregparm = 2;\n+\t      else\n+\t\tregparm = 3;\n+\t    }\n+\t}\n+    }\n+  return regparm;\n }\n \n /* Value is the number of bytes of arguments automatically\n@@ -1725,7 +1751,7 @@ ix86_return_pops_args (tree fundecl, tree funtype, int size)\n   if (aggregate_value_p (TREE_TYPE (funtype))\n       && !TARGET_64BIT)\n     {\n-      int nregs = ix86_fntype_regparm (funtype);\n+      int nregs = ix86_function_regparm (funtype, fundecl);\n \n       if (!nregs)\n \treturn GET_MODE_SIZE (Pmode);\n@@ -1767,7 +1793,6 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n {\n   static CUMULATIVE_ARGS zero_cum;\n   tree param, next_param;\n-  bool user_convention = false;\n \n   if (TARGET_DEBUG_ARG)\n     {\n@@ -1786,18 +1811,11 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n   *cum = zero_cum;\n \n   /* Set up the number of registers to use for passing arguments.  */\n-  cum->nregs = ix86_regparm;\n+  if (fntype)\n+    cum->nregs = ix86_function_regparm (fntype, fndecl);\n+  else\n+    cum->nregs = ix86_regparm;\n   cum->sse_nregs = SSE_REGPARM_MAX;\n-  if (fntype && !TARGET_64BIT)\n-    {\n-      tree attr = lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (fntype));\n-\n-      if (attr)\n-\t{\n-\t  cum->nregs = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr)));\n-\t  user_convention = true;\n-\t}\n-    }\n   cum->maybe_vaarg = false;\n \n   /* Use ecx and edx registers if function has fastcall attribute */\n@@ -1807,23 +1825,6 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \t{\n \t  cum->nregs = 2;\n \t  cum->fastcall = 1;\n-\t  user_convention = true;\n-\t}\n-    }\n-\n-  /* Use register calling convention for local functions when possible.  */\n-  if (!TARGET_64BIT && !user_convention && fndecl\n-      && flag_unit_at_a_time)\n-    {\n-      struct cgraph_local_info *i = cgraph_local_info (fndecl);\n-      if (i && i->local)\n-\t{\n-\t  /* We can't use regparm(3) for nested functions as these use\n-\t     static chain pointer in third argument.  */\n-\t  if (DECL_CONTEXT (fndecl) && !DECL_NO_STATIC_CHAIN (fndecl))\n-\t    cum->nregs = 2;\n-\t  else\n-\t    cum->nregs = 3;\n \t}\n     }\n \n@@ -2501,7 +2502,7 @@ function_arg (CUMULATIVE_ARGS *cum,\t/* current arg information */\n \n \t        /* ECX not EAX is the first allocated register.  */\n \t        if (regno == 0)\n-\t\t      regno = 2;\n+\t\t  regno = 2;\n \t      }\n \t    ret = gen_rtx_REG (mode, regno);\n \t  }\n@@ -15087,7 +15088,7 @@ x86_this_parameter (tree function)\n       return gen_rtx_REG (DImode, x86_64_int_parameter_registers[n]);\n     }\n \n-  if (ix86_fntype_regparm (type) > 0)\n+  if (ix86_function_regparm (type, function) > 0)\n     {\n       tree parm;\n \n@@ -15097,9 +15098,14 @@ x86_this_parameter (tree function)\n       for (; parm; parm = TREE_CHAIN (parm))\n \tif (TREE_VALUE (parm) == void_type_node)\n \t  break;\n-      /* If not, the this parameter is in %eax.  */\n+      /* If not, the this parameter is in the first argument.  */\n       if (parm)\n-\treturn gen_rtx_REG (SImode, 0);\n+\t{\n+\t  int regno = 0;\n+\t  if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (type)))\n+\t    regno = 2;\n+\t  return gen_rtx_REG (SImode, 0);\n+\t}\n     }\n \n   if (aggregate_value_p (TREE_TYPE (type)))\n@@ -15120,7 +15126,7 @@ x86_can_output_mi_thunk (tree thunk ATTRIBUTE_UNUSED,\n     return true;\n \n   /* For 32-bit, everything's fine if we have one free register.  */\n-  if (ix86_fntype_regparm (TREE_TYPE (function)) < 3)\n+  if (ix86_function_regparm (TREE_TYPE (function), function) < 3)\n     return true;\n \n   /* Need a free register for vcall_offset.  */\n@@ -15191,7 +15197,13 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n       if (TARGET_64BIT)\n \ttmp = gen_rtx_REG (DImode, FIRST_REX_INT_REG + 2 /* R10 */);\n       else\n-\ttmp = gen_rtx_REG (SImode, 2 /* ECX */);\n+\t{\n+\t  int tmp_regno = 2 /* ECX */;\n+\t  if (lookup_attribute (\"fastcall\",\n+\t      TYPE_ATTRIBUTES (TREE_TYPE (function))))\n+\t    tmp_regno = 0 /* EAX */;\n+\t  tmp = gen_rtx_REG (SImode, tmp_regno);\n+\t}\n \n       xops[0] = gen_rtx_MEM (Pmode, this_reg);\n       xops[1] = tmp;"}]}