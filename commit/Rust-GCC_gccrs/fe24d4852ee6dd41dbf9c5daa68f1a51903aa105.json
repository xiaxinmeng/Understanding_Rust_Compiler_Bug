{"sha": "fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUyNGQ0ODUyZWU2ZGQ0MWRiZjljNWRhYTY4ZjFhNTE5MDNhYTEwNQ==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2006-07-18T13:07:28Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2006-07-18T13:07:28Z"}, "message": "tree.h (categorize_ctor_elements): Adjust prototype and add descriptive comment...\n\n\t* tree.h (categorize_ctor_elements): Adjust prototype and add\n\tdescriptive comment, both in accordance with the interface change\n\tdescribed below.\n\t* varasm.c (constructor_static_from_elts_p): New function.\n\tWhether a constructor node is a valid static constant initializer\n\tif all its elements are.\n\t(initializer_constant_valid_p) <CONSTRUCTOR value>: Use it.\n\t* output.h: Declare it.\t\n\t* expr.c (categorize_ctor_elements_1): Return whether the constructor\n\tis a valid constant initializer instead of computing the number of\n\tnon-constant elements.  Use constructor_static_from_elts_p for this\n\tpurpose.  Replace the head comment with an indication that this is a\n\thelper for categorize_ctor_elements.\n\t(categorize_ctor_elements): Same interface change as for the _1\n\thelper.  Former head comment from this helper moved here, adjusted to\n\taccount for the interface changes.\n\t(mostly_zeros_p): Adjust call to categorize_ctor_elements.\n\t(all_zeros_p): Likewise.\t\n\t* gimplify.c (gimplify_init_constructor): Decide whether we can make\n\tstatic versions of the constructor from the categorize_ctor_elements\n\treturn value instead of the formerly computed number of non-constant\n\telements.\n\n\t* gnat.dg/outer_agg_bitfield_constructor.adb: New test.\n\t* gnat.dg/nested_agg_bitfield_constructor.adb: New test.\n\nFrom-SVN: r115553", "tree": {"sha": "4065694fdb2ca6a3a4f7e10356db5f8774473035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4065694fdb2ca6a3a4f7e10356db5f8774473035"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57255173dac51b82ac40d272a3b8dc82fd452413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57255173dac51b82ac40d272a3b8dc82fd452413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57255173dac51b82ac40d272a3b8dc82fd452413"}], "stats": {"total": 239, "additions": 197, "deletions": 42}, "files": [{"sha": "558765d4b530f4d3c7d665906d58a2119bc90c90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "patch": "@@ -1,3 +1,28 @@\n+2006-07-18  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* tree.h (categorize_ctor_elements): Adjust prototype and add\n+\tdescriptive comment, both in accordance with the interface change\n+\tdescribed below.\n+\t* varasm.c (constructor_static_from_elts_p): New function.\n+\tWhether a constructor node is a valid static constant initializer\n+\tif all its elements are.\n+\t(initializer_constant_valid_p) <CONSTRUCTOR value>: Use it.\n+\t* output.h: Declare it.\t\n+\t* expr.c (categorize_ctor_elements_1): Return whether the constructor\n+\tis a valid constant initializer instead of computing the number of\n+\tnon-constant elements.  Use constructor_static_from_elts_p for this\n+\tpurpose.  Replace the head comment with an indication that this is a\n+\thelper for categorize_ctor_elements.\n+\t(categorize_ctor_elements): Same interface change as for the _1\n+\thelper.  Former head comment from this helper moved here, adjusted to\n+\taccount for the interface changes.\n+\t(mostly_zeros_p): Adjust call to categorize_ctor_elements.\n+\t(all_zeros_p): Likewise.\t\n+\t* gimplify.c (gimplify_init_constructor): Decide whether we can make\n+\tstatic versions of the constructor from the categorize_ctor_elements\n+\treturn value instead of the formerly computed number of non-constant\n+\telements.\n+\n 2006-07-18  Paolo Bonzini  <bonzini@gnu.org>\n \n         * configure: Regenerate."}, {"sha": "48ec0ef6f6757fc9e639f4bcbe20754c1919d1fb", "filename": "gcc/expr.c", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "patch": "@@ -4531,28 +4531,24 @@ store_expr (tree exp, rtx target, int call_param_p)\n   return NULL_RTX;\n }\n \f\n-/* Examine CTOR to discover:\n-   * how many scalar fields are set to nonzero values,\n-     and place it in *P_NZ_ELTS;\n-   * how many scalar fields are set to non-constant values,\n-     and place it in  *P_NC_ELTS; and\n-   * how many scalar fields in total are in CTOR,\n-     and place it in *P_ELT_COUNT.\n-   * if a type is a union, and the initializer from the constructor\n-     is not the largest element in the union, then set *p_must_clear.  */\n+/* Helper for categorize_ctor_elements.  Identical interface.  */\n \n-static void\n+static bool\n categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n-\t\t\t    HOST_WIDE_INT *p_nc_elts,\n \t\t\t    HOST_WIDE_INT *p_elt_count,\n \t\t\t    bool *p_must_clear)\n {\n   unsigned HOST_WIDE_INT idx;\n-  HOST_WIDE_INT nz_elts, nc_elts, elt_count;\n+  HOST_WIDE_INT nz_elts, elt_count;\n   tree value, purpose;\n \n+  /* Whether CTOR is a valid constant initializer, in accordance with what\n+     initializer_constant_valid_p does.  If inferred from the constructor\n+     elements, true until proven otherwise.  */\n+  bool const_from_elts_p = constructor_static_from_elts_p (ctor);\n+  bool const_p = const_from_elts_p ? true : TREE_STATIC (ctor);\n+\n   nz_elts = 0;\n-  nc_elts = 0;\n   elt_count = 0;\n \n   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), idx, purpose, value)\n@@ -4574,11 +4570,16 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t{\n \tcase CONSTRUCTOR:\n \t  {\n-\t    HOST_WIDE_INT nz = 0, nc = 0, ic = 0;\n-\t    categorize_ctor_elements_1 (value, &nz, &nc, &ic, p_must_clear);\n+\t    HOST_WIDE_INT nz = 0, ic = 0;\n+\t    \n+\t    bool const_elt_p\n+\t      = categorize_ctor_elements_1 (value, &nz, &ic, p_must_clear);\n+\n \t    nz_elts += mult * nz;\n-\t    nc_elts += mult * nc;\n-\t    elt_count += mult * ic;\n+ \t    elt_count += mult * ic;\n+\n+\t    if (const_from_elts_p && const_p)\n+\t      const_p = const_elt_p;\n \t  }\n \t  break;\n \n@@ -4617,8 +4618,10 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \tdefault:\n \t  nz_elts += mult;\n \t  elt_count += mult;\n-\t  if (!initializer_constant_valid_p (value, TREE_TYPE (value)))\n-\t    nc_elts += mult;\n+\n+\t  if (const_from_elts_p && const_p)\n+\t    const_p = initializer_constant_valid_p (value, TREE_TYPE (value))\n+\t\t      != NULL_TREE;\n \t  break;\n \t}\n     }\n@@ -4660,22 +4663,33 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n     }\n \n   *p_nz_elts += nz_elts;\n-  *p_nc_elts += nc_elts;\n   *p_elt_count += elt_count;\n+\n+  return const_p;\n }\n \n-void\n+/* Examine CTOR to discover:\n+   * how many scalar fields are set to nonzero values,\n+     and place it in *P_NZ_ELTS;\n+   * how many scalar fields in total are in CTOR,\n+     and place it in *P_ELT_COUNT.\n+   * if a type is a union, and the initializer from the constructor\n+     is not the largest element in the union, then set *p_must_clear.\n+\n+   Return whether or not CTOR is a valid static constant initializer, the same\n+   as \"initializer_constant_valid_p (CTOR, TREE_TYPE (CTOR)) != 0\".  */\n+\n+bool\n categorize_ctor_elements (tree ctor, HOST_WIDE_INT *p_nz_elts,\n-\t\t\t  HOST_WIDE_INT *p_nc_elts,\n \t\t\t  HOST_WIDE_INT *p_elt_count,\n \t\t\t  bool *p_must_clear)\n {\n   *p_nz_elts = 0;\n-  *p_nc_elts = 0;\n   *p_elt_count = 0;\n   *p_must_clear = false;\n-  categorize_ctor_elements_1 (ctor, p_nz_elts, p_nc_elts, p_elt_count,\n-\t\t\t      p_must_clear);\n+\n+  return\n+    categorize_ctor_elements_1 (ctor, p_nz_elts, p_elt_count, p_must_clear);\n }\n \n /* Count the number of scalars in TYPE.  Return -1 on overflow or\n@@ -4777,10 +4791,10 @@ mostly_zeros_p (tree exp)\n   if (TREE_CODE (exp) == CONSTRUCTOR)\n \n     {\n-      HOST_WIDE_INT nz_elts, nc_elts, count, elts;\n+      HOST_WIDE_INT nz_elts, count, elts;\n       bool must_clear;\n \n-      categorize_ctor_elements (exp, &nz_elts, &nc_elts, &count, &must_clear);\n+      categorize_ctor_elements (exp, &nz_elts, &count, &must_clear);\n       if (must_clear)\n \treturn 1;\n \n@@ -4800,10 +4814,10 @@ all_zeros_p (tree exp)\n   if (TREE_CODE (exp) == CONSTRUCTOR)\n \n     {\n-      HOST_WIDE_INT nz_elts, nc_elts, count;\n+      HOST_WIDE_INT nz_elts, count;\n       bool must_clear;\n \n-      categorize_ctor_elements (exp, &nz_elts, &nc_elts, &count, &must_clear);\n+      categorize_ctor_elements (exp, &nz_elts, &count, &must_clear);\n       return nz_elts == 0;\n     }\n "}, {"sha": "16e4d3c6e0759e442ad102a5c622d7f07bccb423", "filename": "gcc/gimplify.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "patch": "@@ -2940,22 +2940,25 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n       {\n \tstruct gimplify_init_ctor_preeval_data preeval_data;\n \tHOST_WIDE_INT num_type_elements, num_ctor_elements;\n-\tHOST_WIDE_INT num_nonzero_elements, num_nonconstant_elements;\n-\tbool cleared;\n+\tHOST_WIDE_INT num_nonzero_elements;\n+\tbool cleared, valid_const_initializer;\n \n \t/* Aggregate types must lower constructors to initialization of\n \t   individual elements.  The exception is that a CONSTRUCTOR node\n \t   with no elements indicates zero-initialization of the whole.  */\n \tif (VEC_empty (constructor_elt, elts))\n \t  break;\n \n-\tcategorize_ctor_elements (ctor, &num_nonzero_elements,\n-\t\t\t\t  &num_nonconstant_elements,\n-\t\t\t\t  &num_ctor_elements, &cleared);\n+\t/* Fetch information about the constructor to direct later processing.\n+\t   We might want to make static versions of it in various cases, and\n+\t   can only do so if it known to be a valid constant initializer.  */\n+\tvalid_const_initializer\n+\t  = categorize_ctor_elements (ctor, &num_nonzero_elements,\n+\t\t\t\t      &num_ctor_elements, &cleared);\n \n \t/* If a const aggregate variable is being initialized, then it\n \t   should never be a lose to promote the variable to be static.  */\n-\tif (num_nonconstant_elements == 0\n+\tif (valid_const_initializer\n \t    && num_nonzero_elements > 1\n \t    && TREE_READONLY (object)\n \t    && TREE_CODE (object) == VAR_DECL)\n@@ -3012,7 +3015,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t   for sparse arrays, though, as it's more efficient to follow\n \t   the standard CONSTRUCTOR behavior of memset followed by\n \t   individual element initialization.  */\n-\tif (num_nonconstant_elements == 0 && !cleared)\n+\tif (valid_const_initializer && !cleared)\n \t  {\n \t    HOST_WIDE_INT size = int_size_in_bytes (type);\n \t    unsigned int align;"}, {"sha": "3cfe32c93cfb56bac3c867d464e9296edd07209b", "filename": "gcc/output.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "patch": "@@ -280,6 +280,13 @@ extern void output_shared_constant_pool (void);\n \n extern void output_object_blocks (void);\n \n+/* Whether a constructor CTOR is a valid static constant initializer if all\n+   its elements are.  This used to be internal to initializer_constant_valid_p\n+   and has been exposed to let other functions like categorize_ctor_elements\n+   evaluate the property while walking a constructor for other purposes.  */\n+\n+extern bool constructor_static_from_elts_p (tree);\n+\n /* Return nonzero if VALUE is a valid constant-valued expression\n    for use in initializing a static variable; one that can be an\n    element of a \"constant\" initializer."}, {"sha": "f73f2e6064426ad16f318ae524253afa262aec0c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "patch": "@@ -1,3 +1,8 @@\n+2006-07-18  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* gnat.dg/outer_agg_bitfield_constructor.adb: New test.\n+\t* gnat.dg/nested_agg_bitfield_constructor.adb: New test.\n+\t\n 2006-07-18  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c/28286"}, {"sha": "6015900c5aa2185570b166906ee821f108f9f2bb", "filename": "gcc/testsuite/gnat.dg/nested_agg_bitfield_constructor.adb", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Ftestsuite%2Fgnat.dg%2Fnested_agg_bitfield_constructor.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Ftestsuite%2Fgnat.dg%2Fnested_agg_bitfield_constructor.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fnested_agg_bitfield_constructor.adb?ref=fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "patch": "@@ -0,0 +1,34 @@\n+-- { dg-do compile }\n+-- { dg-options \"-gnatws\" }\n+--              (bits of \"Header\" unused)\n+\n+procedure Nested_Agg_Bitfield_Constructor is\n+\n+    type Uint64 is mod 2 ** 64;\n+    type Uint16 is mod 2 ** 16;\n+\n+    type Time_Stamp is record\n+       Sec  : Uint64;\n+       Year : Uint16;\n+    end record;\n+\n+    type Msg_Header is record\n+       Stamp : Time_Stamp;\n+    end record;\n+    for Msg_Header use record\n+       Stamp at 0 range 0 .. 64+16-1;\n+    end record;\n+    for Msg_Header'Size use 80;\n+\n+    type Msg is record\n+       Header : Msg_Header;\n+    end record;\n+\n+    for Msg use record\n+       Header at 0 range 0 .. 191;\n+    end record;\n+\n+    M : Msg := (Header => (Stamp => (2, 4)));\n+begin\n+   null;\n+end;"}, {"sha": "6658042e9630f03e5856c08e9c5f536fe0b1fb3b", "filename": "gcc/testsuite/gnat.dg/outer_agg_bitfield_constructor.adb", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Ftestsuite%2Fgnat.dg%2Fouter_agg_bitfield_constructor.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Ftestsuite%2Fgnat.dg%2Fouter_agg_bitfield_constructor.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fouter_agg_bitfield_constructor.adb?ref=fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "patch": "@@ -0,0 +1,44 @@\n+-- { dg-do run }\n+\n+procedure Outer_Agg_Bitfield_Constructor is\n+\n+    type Mod_64 is mod 2 ** 64;\n+    for Mod_64'Size use 64;\n+\n+    type Uint_16 is range 0 .. 2 ** 16 - 1;\n+    for Uint_16'Size use 16;\n+\n+    type Values_Type is record\n+       M64 : Mod_64;\n+       U16 : Uint_16;\n+    end record;\n+\n+    for Values_Type use record\n+       M64 at 0 range 0 .. 63;\n+       U16 at 8 range 0 .. 15;\n+    end record;\n+\n+    type Wrapper_Type is record\n+       Values : Values_Type;\n+    end record;\n+\n+    for Wrapper_Type use record\n+       Values at 0 range 0 .. 79;\n+    end record;\n+\n+    M : constant := 2;\n+    U : constant := 4;\n+\n+    W : Wrapper_Type := (Values => (M, U));\n+\n+    procedure Check (O : Wrapper_Type) is\n+    begin\n+       if O.Values.M64 /= M or else O.Values.U16 /= U then\n+          raise Program_Error;\n+       end if;\n+    end;\n+begin\n+   Check (W);\n+end;\n+\n+"}, {"sha": "dfea92adc1d99a17cc7671b8860631958d918a07", "filename": "gcc/tree.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "patch": "@@ -3924,8 +3924,20 @@ extern int fields_length (tree);\n \n extern bool initializer_zerop (tree);\n \n-extern void categorize_ctor_elements (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t      HOST_WIDE_INT *, bool *);\n+/* Examine CTOR to discover:\n+   * how many scalar fields are set to nonzero values,\n+     and place it in *P_NZ_ELTS;\n+   * how many scalar fields in total are in CTOR,\n+     and place it in *P_ELT_COUNT.\n+   * if a type is a union, and the initializer from the constructor\n+     is not the largest element in the union, then set *p_must_clear.\n+\n+   Return whether or not CTOR is a valid static constant initializer, the same\n+   as \"initializer_constant_valid_p (CTOR, TREE_TYPE (CTOR)) != 0\".  */\n+\n+extern bool categorize_ctor_elements (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t      bool *);\n+\n extern HOST_WIDE_INT count_type_elements (tree, bool);\n \n /* integer_zerop (tree x) is nonzero if X is an integer constant of value 0.  */"}, {"sha": "1f5f43a1b4ef61be81f566e14b1fbe14afe7f9b0", "filename": "gcc/varasm.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe24d4852ee6dd41dbf9c5daa68f1a51903aa105/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=fe24d4852ee6dd41dbf9c5daa68f1a51903aa105", "patch": "@@ -3699,6 +3699,20 @@ output_addressed_constants (tree exp)\n     }\n }\n \f\n+/* Whether a constructor CTOR is a valid static constant initializer if all\n+   its elements are.  This used to be internal to initializer_constant_valid_p\n+   and has been exposed to let other functions like categorize_ctor_elements\n+   evaluate the property while walking a constructor for other purposes.  */\n+\n+bool\n+constructor_static_from_elts_p (tree ctor)\n+{\n+  return (TREE_CONSTANT (ctor)\n+\t  && (TREE_CODE (TREE_TYPE (ctor)) == UNION_TYPE\n+\t      || TREE_CODE (TREE_TYPE (ctor)) == RECORD_TYPE)\n+\t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (ctor)));\n+}\n+\n /* Return nonzero if VALUE is a valid constant-valued expression\n    for use in initializing a static variable; one that can be an\n    element of a \"constant\" initializer.\n@@ -3719,10 +3733,7 @@ initializer_constant_valid_p (tree value, tree endtype)\n   switch (TREE_CODE (value))\n     {\n     case CONSTRUCTOR:\n-      if ((TREE_CODE (TREE_TYPE (value)) == UNION_TYPE\n-\t   || TREE_CODE (TREE_TYPE (value)) == RECORD_TYPE)\n-\t  && TREE_CONSTANT (value)\n-\t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (value)))\n+      if (constructor_static_from_elts_p (value))\n \t{\n \t  unsigned HOST_WIDE_INT idx;\n \t  tree elt;"}]}