{"sha": "0caf592d6ae836a99907841fccd31c4c5f180e8d", "node_id": "C_kwDOANBUbNoAKDBjYWY1OTJkNmFlODM2YTk5OTA3ODQxZmNjZDMxYzRjNWYxODBlOGQ", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2021-12-13T14:11:59Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2021-12-13T15:16:22Z"}, "message": "aarch64: Add support for Armv8.8-a memory operations and memcpy expansion\n\nThis patch adds the +mops architecture extension flag from the 2021 Arm Architecture extensions, Armv8.8-a.\nThe +mops extensions introduce instructions to accelerate the memcpy, memset, memmove standard functions.\nThe first patch here uses the instructions in the inline memcpy expansion.\nFurther patches in the series will use similar instructions to inline memmove and memset.\n\nA new param, aarch64-mops-memcpy-size-threshold, is introduced to control the size threshold above which to\nemit the new sequence. Its default setting is 256 bytes, which is the same as the current threshold above\nwhich we'd emit a libcall.\n\nBootstrapped and tested on aarch64-none-linux-gnu.\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64-option-extensions.def (mops): Define.\n\t* config/aarch64/aarch64.c (aarch64_expand_cpymem_mops): Define.\n\t(aarch64_expand_cpymem): Define.\n\t* config/aarch64/aarch64.h (AARCH64_FL_MOPS): Define.\n\t(AARCH64_ISA_MOPS): Define.\n\t(TARGET_MOPS): Define.\n\t(MOVE_RATIO): Adjust for TARGET_MOPS.\n\t* config/aarch64/aarch64.md (\"unspec\"): Add UNSPEC_CPYMEM.\n\t(aarch64_cpymemdi): New pattern.\n\t(cpymemdi): Adjust for TARGET_MOPS.\n\t* config/aarch64/aarch64.opt (aarch64-mops-memcpy-size-threshol):\n\tNew param.\n\t* doc/invoke.texi (AArch64 Options): Document +mops.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/mops_1.c: New test.", "tree": {"sha": "3f2877ba89c1f973560c23862e87309ca7fa6b4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f2877ba89c1f973560c23862e87309ca7fa6b4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0caf592d6ae836a99907841fccd31c4c5f180e8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0caf592d6ae836a99907841fccd31c4c5f180e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0caf592d6ae836a99907841fccd31c4c5f180e8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0caf592d6ae836a99907841fccd31c4c5f180e8d/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9eb8785b3fa3a180bd216cf68b53f1621628efc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb8785b3fa3a180bd216cf68b53f1621628efc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb8785b3fa3a180bd216cf68b53f1621628efc6"}], "stats": {"total": 166, "additions": 149, "deletions": 17}, "files": [{"sha": "3f449fba41557afd66d11f976ec9fbdcddfafb42", "filename": "gcc/config/aarch64/aarch64-option-extensions.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def?ref=0caf592d6ae836a99907841fccd31c4c5f180e8d", "patch": "@@ -235,4 +235,7 @@ AARCH64_OPT_EXTENSION(\"pauth\", AARCH64_FL_PAUTH, 0, 0, false, \"paca pacg\")\n /* Enabling/Disabling \"ls64\" only changes \"ls64\".  */\n AARCH64_OPT_EXTENSION(\"ls64\", AARCH64_FL_LS64, 0, 0, false, \"\")\n \n+/* Enabling/disabling \"mops\" only changes \"mops\".  */\n+AARCH64_OPT_EXTENSION(\"mops\", AARCH64_FL_MOPS, 0, 0, false, \"\")\n+\n #undef AARCH64_OPT_EXTENSION"}, {"sha": "bd754e4e2c2b43e76021d3dd4b10cc03d78d9543", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0caf592d6ae836a99907841fccd31c4c5f180e8d", "patch": "@@ -23568,6 +23568,28 @@ aarch64_copy_one_block_and_progress_pointers (rtx *src, rtx *dst,\n   *dst = aarch64_progress_pointer (*dst);\n }\n \n+/* Expand a cpymem using the MOPS extension.  OPERANDS are taken\n+   from the cpymem pattern.  Return true iff we succeeded.  */\n+static bool\n+aarch64_expand_cpymem_mops (rtx *operands)\n+{\n+  if (!TARGET_MOPS)\n+    return false;\n+  rtx addr_dst = XEXP (operands[0], 0);\n+  rtx addr_src = XEXP (operands[1], 0);\n+  rtx sz_reg = operands[2];\n+\n+  if (!REG_P (sz_reg))\n+    sz_reg = force_reg (DImode, sz_reg);\n+  if (!REG_P (addr_dst))\n+    addr_dst = force_reg (DImode, addr_dst);\n+  if (!REG_P (addr_src))\n+    addr_src = force_reg (DImode, addr_src);\n+  emit_insn (gen_aarch64_cpymemdi (addr_dst, addr_src, sz_reg));\n+\n+  return true;\n+}\n+\n /* Expand cpymem, as if from a __builtin_memcpy.  Return true if\n    we succeed, otherwise return false, indicating that a libcall to\n    memcpy should be emitted.  */\n@@ -23581,19 +23603,25 @@ aarch64_expand_cpymem (rtx *operands)\n   rtx base;\n   machine_mode cur_mode = BLKmode;\n \n-  /* Only expand fixed-size copies.  */\n+  /* Variable-sized memcpy can go through the MOPS expansion if available.  */\n   if (!CONST_INT_P (operands[2]))\n-    return false;\n+    return aarch64_expand_cpymem_mops (operands);\n \n   unsigned HOST_WIDE_INT size = INTVAL (operands[2]);\n \n-  /* Try to inline up to 256 bytes.  */\n-  unsigned HOST_WIDE_INT max_copy_size = 256;\n+  /* Try to inline up to 256 bytes or use the MOPS threshold if available.  */\n+  unsigned HOST_WIDE_INT max_copy_size\n+    = TARGET_MOPS ? aarch64_mops_memcpy_size_threshold : 256;\n \n   bool size_p = optimize_function_for_size_p (cfun);\n \n+  /* Large constant-sized cpymem should go through MOPS when possible.\n+     It should be a win even for size optimization in the general case.\n+     For speed optimization the choice between MOPS and the SIMD sequence\n+     depends on the size of the copy, rather than number of instructions,\n+     alignment etc.  */\n   if (size > max_copy_size)\n-    return false;\n+    return aarch64_expand_cpymem_mops (operands);\n \n   int copy_bits = 256;\n \n@@ -23643,9 +23671,9 @@ aarch64_expand_cpymem (rtx *operands)\n       nops += 2;\n       n -= mode_bits;\n \n-      /* Emit trailing copies using overlapping unaligned accesses - this is\n-\t smaller and faster.  */\n-      if (n > 0 && n < copy_bits / 2)\n+      /* Emit trailing copies using overlapping unaligned accesses\n+\t(when !STRICT_ALIGNMENT) - this is smaller and faster.  */\n+      if (n > 0 && n < copy_bits / 2 && !STRICT_ALIGNMENT)\n \t{\n \t  machine_mode next_mode = smallest_mode_for_size (n, MODE_INT);\n \t  int n_bits = GET_MODE_BITSIZE (next_mode).to_constant ();\n@@ -23657,9 +23685,25 @@ aarch64_expand_cpymem (rtx *operands)\n     }\n   rtx_insn *seq = get_insns ();\n   end_sequence ();\n+  /* MOPS sequence requires 3 instructions for the memory copying + 1 to move\n+     the constant size into a register.  */\n+  unsigned mops_cost = 3 + 1;\n+\n+  /* If MOPS is available at this point we don't consider the libcall as it's\n+     not a win even on code size.  At this point only consider MOPS if\n+     optimizing for size.  For speed optimizations we will have chosen between\n+     the two based on copy size already.  */\n+  if (TARGET_MOPS)\n+    {\n+      if (size_p && mops_cost < nops)\n+\treturn aarch64_expand_cpymem_mops (operands);\n+      emit_insn (seq);\n+      return true;\n+    }\n \n   /* A memcpy libcall in the worst case takes 3 instructions to prepare the\n-     arguments + 1 for the call.  */\n+     arguments + 1 for the call.  When MOPS is not available and we're\n+     optimizing for size a libcall may be preferable.  */\n   unsigned libcall_cost = 4;\n   if (size_p && libcall_cost < nops)\n     return false;"}, {"sha": "79d0bcd357fc75c8b85a252813b2aac0e2b6e5bd", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=0caf592d6ae836a99907841fccd31c4c5f180e8d", "patch": "@@ -231,14 +231,17 @@ extern unsigned aarch64_architecture_version;\n /* Pointer Authentication (PAUTH) extension.  */\n #define AARCH64_FL_PAUTH      (1ULL << 40)\n \n+/* Armv9.0-A.  */\n+#define AARCH64_FL_V9         (1ULL << 41)  /* Armv9.0-A Architecture.  */\n+\n /* 64-byte atomic load/store extensions.  */\n-#define AARCH64_FL_LS64      (1ULL << 41)\n+#define AARCH64_FL_LS64      (1ULL << 42)\n \n /* Armv8.7-a architecture extensions.  */\n-#define AARCH64_FL_V8_7       (1ULL << 42)\n+#define AARCH64_FL_V8_7       (1ULL << 43)\n \n-/* Armv9.0-A.  */\n-#define AARCH64_FL_V9         (1ULL << 43)  /* Armv9.0-A Architecture.  */\n+/* Hardware memory operation instructions.  */\n+#define AARCH64_FL_MOPS       (1ULL << 44)\n \n /* Has FP and SIMD.  */\n #define AARCH64_FL_FPSIMD     (AARCH64_FL_FP | AARCH64_FL_SIMD)\n@@ -310,6 +313,7 @@ extern unsigned aarch64_architecture_version;\n #define AARCH64_ISA_V8_R\t   (aarch64_isa_flags & AARCH64_FL_V8_R)\n #define AARCH64_ISA_PAUTH\t   (aarch64_isa_flags & AARCH64_FL_PAUTH)\n #define AARCH64_ISA_V9\t\t   (aarch64_isa_flags & AARCH64_FL_V9)\n+#define AARCH64_ISA_MOPS\t   (aarch64_isa_flags & AARCH64_FL_MOPS)\n \n /* Crypto is an optional extension to AdvSIMD.  */\n #define TARGET_CRYPTO (TARGET_SIMD && AARCH64_ISA_CRYPTO)\n@@ -401,6 +405,9 @@ extern unsigned aarch64_architecture_version;\n /* PAUTH instructions are enabled through +pauth.  */\n #define TARGET_PAUTH (AARCH64_ISA_PAUTH)\n \n+/* MOPS instructions are enabled through +mops.  */\n+#define TARGET_MOPS (AARCH64_ISA_MOPS)\n+\n /* Make sure this is always defined so we don't have to check for ifdefs\n    but rather use normal ifs.  */\n #ifndef TARGET_FIX_ERR_A53_835769_DEFAULT\n@@ -1046,9 +1053,10 @@ typedef struct\n    7-byte copy is a 4-byte + 2-byte + byte copy.  This proves inefficient\n    for both size and speed of copy, so we will instead use the \"cpymem\"\n    standard name to implement the copy.  This logic does not apply when\n-   targeting -mstrict-align, so keep a sensible default in that case.  */\n+   targeting -mstrict-align or TARGET_MOPS, so keep a sensible default in\n+   that case.  */\n #define MOVE_RATIO(speed) \\\n-  (!STRICT_ALIGNMENT ? 2 : (((speed) ? 15 : AARCH64_CALL_RATIO) / 2))\n+  ((!STRICT_ALIGNMENT || TARGET_MOPS) ? 2 : (((speed) ? 15 : AARCH64_CALL_RATIO) / 2))\n \n /* Like MOVE_RATIO, without -mstrict-align, make decisions in \"setmem\" when\n    we would use more than 3 scalar instructions."}, {"sha": "d623c1b00bf62bf24420813fb7a3a6bf09ff1dc0", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=0caf592d6ae836a99907841fccd31c4c5f180e8d", "patch": "@@ -143,6 +143,7 @@\n     UNSPEC_AUTIBSP\n     UNSPEC_CALLEE_ABI\n     UNSPEC_CASESI\n+    UNSPEC_CPYMEM\n     UNSPEC_CRC32B\n     UNSPEC_CRC32CB\n     UNSPEC_CRC32CH\n@@ -1572,6 +1573,18 @@\n   }\n )\n \n+(define_insn \"aarch64_cpymemdi\"\n+  [(parallel [\n+   (set (match_operand:DI 2 \"register_operand\" \"+&r\") (const_int 0))\n+   (clobber (match_operand:DI 0 \"register_operand\" \"+&r\"))\n+   (clobber (match_operand:DI 1 \"register_operand\" \"+&r\"))\n+   (set (mem:BLK (match_dup 0))\n+        (unspec:BLK [(mem:BLK (match_dup 1)) (match_dup 2)] UNSPEC_CPYMEM))])]\n+ \"TARGET_MOPS\"\n+ \"cpyfp\\t[%x0]!, [%x1]!, %x2!\\;cpyfm\\t[%x0]!, [%x1]!, %x2!\\;cpyfe\\t[%x0]!, [%x1]!, %x2!\"\n+ [(set_attr \"length\" \"12\")]\n+)\n+\n ;; 0 is dst\n ;; 1 is src\n ;; 2 is size of copy in bytes\n@@ -1580,9 +1593,9 @@\n (define_expand \"cpymemdi\"\n   [(match_operand:BLK 0 \"memory_operand\")\n    (match_operand:BLK 1 \"memory_operand\")\n-   (match_operand:DI 2 \"immediate_operand\")\n+   (match_operand:DI 2 \"general_operand\")\n    (match_operand:DI 3 \"immediate_operand\")]\n-   \"!STRICT_ALIGNMENT\"\n+   \"!STRICT_ALIGNMENT || TARGET_MOPS\"\n {\n   if (aarch64_expand_cpymem (operands))\n     DONE;"}, {"sha": "7445ed106cca9cb8a4537414499f6f28476951bf", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=0caf592d6ae836a99907841fccd31c4c5f180e8d", "patch": "@@ -280,3 +280,7 @@ Target Joined UInteger Var(aarch64_autovec_preference) Init(0) IntegerRange(0, 4\n \n -param=aarch64-loop-vect-issue-rate-niters=\n Target Joined UInteger Var(aarch64_loop_vect_issue_rate_niters) Init(6) IntegerRange(0, 65536) Param\n+\n+-param=aarch64-mops-memcpy-size-threshold=\n+Target Joined UInteger Var(aarch64_mops_memcpy_size_threshold) Init(256) Param\n+Constant memcpy size in bytes above which to start using MOPS sequence."}, {"sha": "2424a5bf3e0e2d5e0dd5d446fd3e30228e3e9b25", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0caf592d6ae836a99907841fccd31c4c5f180e8d", "patch": "@@ -19144,6 +19144,9 @@ prior to Armv8.2-A is not supported.\n @item ls64\n Enable the 64-byte atomic load and store instructions for accelerators.\n This option is enabled by default for @option{-march=armv8.7-a}.\n+@item mops\n+Enable the instructions to accelerate memory operations like @code{memcpy},\n+@code{memmove}, @code{memset}.\n @item flagm\n Enable the Flag Manipulation instructions Extension.\n @item pauth"}, {"sha": "661c14192e8a84fd4641a4d818b8db46ab4f1b28", "filename": "gcc/testsuite/gcc.target/aarch64/mops_1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmops_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0caf592d6ae836a99907841fccd31c4c5f180e8d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmops_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmops_1.c?ref=0caf592d6ae836a99907841fccd31c4c5f180e8d", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=armv8.6-a+mops --param=aarch64-mops-memcpy-size-threshold=0\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#include <stdlib.h>\n+\n+/* We want to inline variable-sized memcpy.\n+** do_it_cpy:\n+**\tcpyfp\t\\[x1\\]\\!, \\[x0\\]\\!, x2\\!\n+**\tcpyfm\t\\[x1\\]\\!, \\[x0\\]\\!, x2\\!\n+**\tcpyfe\t\\[x1\\]\\!, \\[x0\\]\\!, x2\\!\n+**\tret\n+*/\n+void do_it_cpy (char * in, char * out, size_t size)\n+{\n+  __builtin_memcpy (out, in, size);\n+}\n+\n+/*\n+** do_it_cpy_large:\n+**\tmov\tx2, 1024\n+**\tcpyfp\t\\[x1\\]\\!, \\[x0\\]!, x2\\!\n+**\tcpyfm\t\\[x1\\]\\!, \\[x0\\]!, x2\\!\n+**\tcpyfe\t\\[x1\\]\\!, \\[x0\\]\\!, x2\\!\n+**\tret\n+*/\n+void do_it_cpy_large (char * in, char * out)\n+{\n+  __builtin_memcpy (out, in, 1024);\n+}\n+\n+/*\n+** do_it_cpy_127:\n+**\tmov\tx2, 127\n+**\tcpyfp\t\\[x1\\]\\!, \\[x0\\]!, x2\\!\n+**\tcpyfm\t\\[x1\\]\\!, \\[x0\\]!, x2\\!\n+**\tcpyfe\t\\[x1\\]\\!, \\[x0\\]\\!, x2\\!\n+**\tret\n+*/\n+void do_it_cpy_127 (char * in, char * out)\n+{\n+  __builtin_memcpy (out, in, 127);\n+}\n+\n+/*\n+** do_it_cpy_128:\n+**\tmov\tx2, 128\n+**\tcpyfp\t\\[x1\\]\\!, \\[x0\\]!, x2\\!\n+**\tcpyfm\t\\[x1\\]\\!, \\[x0\\]!, x2\\!\n+**\tcpyfe\t\\[x1\\]\\!, \\[x0\\]\\!, x2\\!\n+**\tret\n+*/\n+void do_it_cpy_128 (char * in, char * out)\n+{\n+  __builtin_memcpy (out, in, 128);\n+}\n+"}]}