{"sha": "1b6f8e9778b58e190f40a1137eaba618c529110f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI2ZjhlOTc3OGI1OGUxOTBmNDBhMTEzN2VhYmE2MThjNTI5MTEwZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-05-31T10:46:52Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-31T10:46:52Z"}, "message": "[Ada] Fix internal error on allocator with function call\n\n2018-05-31  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/trans.c (Call_to_gnu): If this is a function call and\n\tthere is no target, also create a temporary for the return value for\n\tan allocator if the type is an unconstrained record type with default\n\tdiscriminant.\n\nFrom-SVN: r261007", "tree": {"sha": "304e0a126a9af3e6c8f2caff389caa00785eb4e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/304e0a126a9af3e6c8f2caff389caa00785eb4e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b6f8e9778b58e190f40a1137eaba618c529110f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b6f8e9778b58e190f40a1137eaba618c529110f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b6f8e9778b58e190f40a1137eaba618c529110f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b6f8e9778b58e190f40a1137eaba618c529110f/comments", "author": null, "committer": null, "parents": [{"sha": "3c5d07ab057a1cbe23ca655d172bfb53581be960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c5d07ab057a1cbe23ca655d172bfb53581be960", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c5d07ab057a1cbe23ca655d172bfb53581be960"}], "stats": {"total": 23, "additions": 17, "deletions": 6}, "files": [{"sha": "446d65267f0499d04aa514f46842ec03aaea9f13", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b6f8e9778b58e190f40a1137eaba618c529110f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b6f8e9778b58e190f40a1137eaba618c529110f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1b6f8e9778b58e190f40a1137eaba618c529110f", "patch": "@@ -1,3 +1,10 @@\n+2018-05-31  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (Call_to_gnu): If this is a function call and\n+\tthere is no target, also create a temporary for the return value for\n+\tan allocator if the type is an unconstrained record type with default\n+\tdiscriminant.\n+\n 2018-05-31  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch7.adb (Find_Transient_Context): An iteration scheme is a valid"}, {"sha": "1704db2c317fbd03d33c8ca49e498a6a02688cfa", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b6f8e9778b58e190f40a1137eaba618c529110f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b6f8e9778b58e190f40a1137eaba618c529110f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=1b6f8e9778b58e190f40a1137eaba618c529110f", "patch": "@@ -4355,12 +4355,15 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  because we need to preserve the return value before copying back the\n \t  parameters.\n \n-       2. There is no target and the call is made for neither an object nor a\n+       2. There is no target and the call is made for neither an object, nor a\n \t  renaming declaration, nor a return statement, nor an allocator, and\n \t  the return type has variable size because in this case the gimplifier\n-\t  cannot create the temporary, or more generally is simply an aggregate\n-\t  type, because the gimplifier would then create the temporary in the\n-\t  outermost scope instead of locally.\n+\t  cannot create the temporary, or more generally is an aggregate type,\n+\t  because the gimplifier would create the temporary in the outermost\n+\t  scope instead of locally.  But there is an exception for an allocator\n+\t  of an unconstrained record type with default discriminant because we\n+\t  allocate the actual size in this case, unlike the other 3 cases, so\n+\t  we need a temporary to fetch the discriminant and we create it here.\n \n        3. There is a target and it is a slice or an array with fixed size,\n \t  and the return type has variable size, because the gimplifier\n@@ -4379,8 +4382,9 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      && Nkind (Parent (gnat_node)) != N_Object_Declaration\n \t      && Nkind (Parent (gnat_node)) != N_Object_Renaming_Declaration\n \t      && Nkind (Parent (gnat_node)) != N_Simple_Return_Statement\n-\t      && !(Nkind (Parent (gnat_node)) == N_Qualified_Expression\n-\t\t   && Nkind (Parent (Parent (gnat_node))) == N_Allocator)\n+\t      && (!(Nkind (Parent (gnat_node)) == N_Qualified_Expression\n+\t\t    && Nkind (Parent (Parent (gnat_node))) == N_Allocator)\n+\t\t  || type_is_padding_self_referential (gnu_result_type))\n \t      && AGGREGATE_TYPE_P (gnu_result_type)\n \t      && !TYPE_IS_FAT_POINTER_P (gnu_result_type))\n \t  || (gnu_target"}]}