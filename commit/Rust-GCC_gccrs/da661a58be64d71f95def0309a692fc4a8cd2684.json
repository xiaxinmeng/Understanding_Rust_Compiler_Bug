{"sha": "da661a58be64d71f95def0309a692fc4a8cd2684", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE2NjFhNThiZTY0ZDcxZjk1ZGVmMDMwOWE2OTJmYzRhOGNkMjY4NA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-05-31T20:04:09Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-05-31T20:04:09Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-05-31  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * intrinsic.c (klass): Add CLASS_ATOMIC.\n        (add_subroutines): Add atomic_ref/atomic_define.\n        * intrinsic.texi (ATOMIC_REF, ATOMIC_DEFINE): Document.\n        * intrinsic.h (gfc_check_atomic_def, gfc_check_atomic_ref,\n        gfc_resolve_atomic_def, gfc_resolve_atomic_ref): New prototypes.\n        * gfortran.h (gfc_isym_id): Add GFC_ISYM_ATOMIC_DEF\n        and GFC_ISYM_ATOMIC_REF.\n        (gfc_atomic_int_kind, gfc_atomic_logical_kind): New global vars.\n        * iresolve.c (gfc_resolve_atomic_def, gfc_resolve_atomic_ref):\n        * New\n        functions.\n        * check.c (gfc_check_atomic, gfc_check_atomic_def,\n        gfc_check_atomic_ref): New functions.\n        * iso-fortran-env.def (ISOFORTRANENV_FILE_ATOMIC_INT_KIND,\n        ISOFORTRANENV_FILE_ATOMIC_LOGICAL_KIND): Change kind value.\n        * trans-intrinsic.c (conv_intrinsic_atomic_def,\n        conv_intrinsic_atomic_ref, gfc_conv_intrinsic_subroutine): New\n        functions.\n        (conv_intrinsic_move_alloc) Renamed from\n        gfc_conv_intrinsic_move_alloc - and made static.\n        * trans.h (gfc_conv_intrinsic_move_alloc): Remove.\n        (gfc_conv_intrinsic_subroutine) Add prototype.\n        * trans.c (trans_code): Call gfc_conv_intrinsic_subroutine.\n\nFrom-SVN: r174510", "tree": {"sha": "f09811acccca40393f12028c87bd9199a9ee86cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f09811acccca40393f12028c87bd9199a9ee86cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da661a58be64d71f95def0309a692fc4a8cd2684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da661a58be64d71f95def0309a692fc4a8cd2684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da661a58be64d71f95def0309a692fc4a8cd2684", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da661a58be64d71f95def0309a692fc4a8cd2684/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ead7c399bc1b0c62bacaf845628ab72024838085", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead7c399bc1b0c62bacaf845628ab72024838085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ead7c399bc1b0c62bacaf845628ab72024838085"}], "stats": {"total": 384, "additions": 370, "deletions": 14}, "files": [{"sha": "c24489bd48a12544064c5fe5ea0b8bfbdf3b74e1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -1,3 +1,32 @@\n+2011-05-31  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* intrinsic.c (klass): Add CLASS_ATOMIC.\n+\t(add_subroutines): Add atomic_ref/atomic_define.\n+\t* intrinsic.texi (ATOMIC_REF, ATOMIC_DEFINE): Document.\n+\t* intrinsic.h (gfc_check_atomic_def, gfc_check_atomic_ref,\n+\tgfc_resolve_atomic_def, gfc_resolve_atomic_ref): New prototypes.\n+\t* gfortran.h (gfc_isym_id): Add GFC_ISYM_ATOMIC_DEF\n+\tand GFC_ISYM_ATOMIC_REF.\n+\t(gfc_atomic_int_kind, gfc_atomic_logical_kind): New global vars.\n+\t* iresolve.c (gfc_resolve_atomic_def, gfc_resolve_atomic_ref): New\n+\tfunctions.\n+\t* check.c (gfc_check_atomic, gfc_check_atomic_def,\n+\tgfc_check_atomic_ref): New functions.\n+\t* iso-fortran-env.def (ISOFORTRANENV_FILE_ATOMIC_INT_KIND,\n+\tISOFORTRANENV_FILE_ATOMIC_LOGICAL_KIND): Change kind value.\n+\t* trans-intrinsic.c (conv_intrinsic_atomic_def,\n+\tconv_intrinsic_atomic_ref, gfc_conv_intrinsic_subroutine): New\n+\tfunctions.\n+\t(conv_intrinsic_move_alloc) Renamed from\n+\tgfc_conv_intrinsic_move_alloc - and made static.\n+\t* trans.h (gfc_conv_intrinsic_move_alloc): Remove.\n+\t(gfc_conv_intrinsic_subroutine) Add prototype.\n+\t* trans.c (trans_code): Call gfc_conv_intrinsic_subroutine.\n+\t* trans-types (gfc_atomic_int_kind, gfc_atomic_logical_kind): New\n+\tglobal vars.\n+\t(gfc_init_kinds): Set them.\n+\n 2011-05-31  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "117896731150155107bfec4bc0e57360d49c4ce4", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -973,6 +973,72 @@ gfc_check_atan2 (gfc_expr *y, gfc_expr *x)\n }\n \n \n+static gfc_try\n+gfc_check_atomic (gfc_expr *atom, gfc_expr *value)\n+{\n+  if (!(atom->ts.type == BT_INTEGER && atom->ts.kind == gfc_atomic_int_kind)\n+      && !(atom->ts.type == BT_LOGICAL\n+\t   && atom->ts.kind == gfc_atomic_logical_kind))\n+    {\n+      gfc_error (\"ATOM argument at %L to intrinsic function %s shall be an \"\n+\t\t \"integer of ATOMIC_INT_KIND or a logical of \"\n+\t\t \"ATOMIC_LOGICAL_KIND\", &atom->where, gfc_current_intrinsic);\n+      return FAILURE;\n+    }\n+\n+  if (!gfc_expr_attr (atom).codimension)\n+    {\n+      gfc_error (\"ATOM argument at %L of the %s intrinsic function shall be a \"\n+\t\t \"coarray or coindexed\", &atom->where, gfc_current_intrinsic);\n+      return FAILURE;\n+    }\n+\n+  if (atom->ts.type != value->ts.type)\n+    {\n+      gfc_error (\"ATOM and VALUE argument of the %s intrinsic function shall \"\n+\t\t \"have the same type at %L\", gfc_current_intrinsic,\n+\t\t &value->where);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n+gfc_try\n+gfc_check_atomic_def (gfc_expr *atom, gfc_expr *value)\n+{\n+  if (scalar_check (atom, 0) == FAILURE || scalar_check (value, 1) == FAILURE)\n+    return FAILURE;\n+\n+  if (gfc_check_vardef_context (atom, false, NULL) == FAILURE)\n+    {\n+      gfc_error (\"ATOM argument of the %s intrinsic function at %L shall be \"\n+\t\t \"definable\", gfc_current_intrinsic, &atom->where);\n+      return FAILURE;\n+    }\n+\n+  return gfc_check_atomic (atom, value);\n+}\n+\n+\n+gfc_try\n+gfc_check_atomic_ref (gfc_expr *value, gfc_expr *atom)\n+{\n+  if (scalar_check (value, 0) == FAILURE || scalar_check (atom, 1) == FAILURE)\n+    return FAILURE;\n+\n+  if (gfc_check_vardef_context (value, false, NULL) == FAILURE)\n+    {\n+      gfc_error (\"VALUE argument of the %s intrinsic function at %L shall be \"\n+\t\t \"definable\", gfc_current_intrinsic, &value->where);\n+      return FAILURE;\n+    }\n+\n+  return gfc_check_atomic (atom, value);\n+}\n+\n+\n /* BESJN and BESYN functions.  */\n \n gfc_try"}, {"sha": "ff824244d867d2804e8131834f9b2cfaaa4906d7", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -306,6 +306,8 @@ enum gfc_isym_id\n   GFC_ISYM_ATAN,\n   GFC_ISYM_ATAN2,\n   GFC_ISYM_ATANH,\n+  GFC_ISYM_ATOMIC_DEF,\n+  GFC_ISYM_ATOMIC_REF,\n   GFC_ISYM_BGE,\n   GFC_ISYM_BGT,\n   GFC_ISYM_BIT_SIZE,\n@@ -2464,6 +2466,8 @@ extern int gfc_default_character_kind;\n extern int gfc_default_logical_kind;\n extern int gfc_default_complex_kind;\n extern int gfc_c_int_kind;\n+extern int gfc_atomic_int_kind;\n+extern int gfc_atomic_logical_kind;\n extern int gfc_intio_kind;\n extern int gfc_charlen_int_kind;\n extern int gfc_numeric_storage_size;"}, {"sha": "1cce1447b04b6415f3f516216b3027ae41d8c66d", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -51,7 +51,7 @@ sizing;\n \n enum klass\n { CLASS_IMPURE = 0, CLASS_PURE, CLASS_ELEMENTAL,\n-  CLASS_INQUIRY, CLASS_TRANSFORMATIONAL };\n+  CLASS_INQUIRY, CLASS_TRANSFORMATIONAL, CLASS_ATOMIC };\n \n #define ACTUAL_NO\t0\n #define ACTUAL_YES\t1\n@@ -2880,6 +2880,18 @@ add_subroutines (void)\n \n   make_noreturn();\n \n+  add_sym_2s (\"atomic_define\", GFC_ISYM_ATOMIC_DEF, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008,\n+\t      gfc_check_atomic_def, NULL, gfc_resolve_atomic_def,\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_IN);\n+\n+  add_sym_2s (\"atomic_ref\", GFC_ISYM_ATOMIC_REF, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008,\n+\t      gfc_check_atomic_ref, NULL, gfc_resolve_atomic_ref,\n+\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_IN);\n+\n   add_sym_1s (\"cpu_time\", GFC_ISYM_CPU_TIME, CLASS_IMPURE, BT_UNKNOWN, 0,\n \t      GFC_STD_F95, gfc_check_cpu_time, NULL, gfc_resolve_cpu_time,\n \t      tm, BT_REAL, dr, REQUIRED, INTENT_OUT);"}, {"sha": "e64325b99e7ff6e17252d8daaac061b1a6baf2ee", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -39,6 +39,8 @@ gfc_try gfc_check_allocated (gfc_expr *);\n gfc_try gfc_check_associated (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_atan_2 (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_atan2 (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_atomic_def (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_atomic_ref (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_besn (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_bessel_n2 (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_bge_bgt_ble_blt (gfc_expr *, gfc_expr *);\n@@ -414,6 +416,8 @@ void gfc_resolve_asinh (gfc_expr *, gfc_expr *);\n void gfc_resolve_atan (gfc_expr *, gfc_expr *);\n void gfc_resolve_atanh (gfc_expr *, gfc_expr *);\n void gfc_resolve_atan2 (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_atomic_def (gfc_code *);\n+void gfc_resolve_atomic_ref (gfc_code *);\n void gfc_resolve_besn (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_bessel_n2 (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *a);\n void gfc_resolve_btest (gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "cb46a77e444d8512086d4018513953f274592def", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -61,6 +61,8 @@ Some basic guidelines for editing this document:\n * @code{ATAN}:          ATAN,      Arctangent function\n * @code{ATAN2}:         ATAN2,     Arctangent function\n * @code{ATANH}:         ATANH,     Inverse hyperbolic tangent function\n+* @code{ATOMIC_DEFINE}: ATOMIC_DEFINE, Setting a variable atomically\n+* @code{ATOMIC_REF}:    ATOMIC_REF, Obtaining the value of a variable atomically\n * @code{BESSEL_J0}:     BESSEL_J0, Bessel function of the first kind of order 0\n * @code{BESSEL_J1}:     BESSEL_J1, Bessel function of the first kind of order 1\n * @code{BESSEL_JN}:     BESSEL_JN, Bessel function of the first kind\n@@ -1546,6 +1548,100 @@ Inverse function: @ref{TANH}\n \n \n \n+@node ATOMIC_DEFINE\n+@section @code{ATOMIC_DEFINE} --- Setting a variable atomically\n+@fnindex ATOMIC_DEFINE\n+@cindex Atomic subroutine, define\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATOMIC_DEFINE(ATOM, VALUE)} defines the variable @var{ATOM} with the value\n+@var{VALUE} atomically.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Atomic subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL ATOMIC_DEFINE(ATOM, VALUE)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ATOM}   @tab Scalar coarray or coindexed variable of either integer\n+                        type with @code{ATOMIC_INT_KIND} kind or logical type\n+                        with @code{ATOMIC_LOGICAL_KIND} kind.\n+@item @var{VALURE} @tab Scalar and of the same type as @var{ATOM}. If the kind\n+                        is different, the value is converted to the kind of\n+                        @var{ATOM}.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program atomic\n+  use iso_fortran_env\n+  integer(atomic_int_kind) :: atom[*]\n+  call atomic_define (atom[1], this_image())\n+end program atomic\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{ATOMIC_REF}, @ref{ISO_FORTRAN_ENV}\n+@end table\n+\n+\n+\n+@node ATOMIC_REF\n+@section @code{ATOMIC_REF} --- Obtaining the value of a variable atomically\n+@fnindex ATOMIC_REF\n+@cindex Atomic subroutine, reference\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATOMIC_DEFINE(ATOM, VALUE)} atomically assigns the value of the\n+variable @var{ATOM} to @var{VALUE}.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Atomic subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL ATOMIC_REF(VALUE, ATOM)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{VALURE} @tab Scalar and of the same type as @var{ATOM}. If the kind\n+                        is different, the value is converted to the kind of\n+                        @var{ATOM}.\n+@item @var{ATOM}   @tab Scalar coarray or coindexed variable of either integer\n+                        type with @code{ATOMIC_INT_KIND} kind or logical type\n+                        with @code{ATOMIC_LOGICAL_KIND} kind.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program atomic\n+  use iso_fortran_env\n+  logical(atomic_logical_kind) :: atom[*]\n+  logical :: val\n+  call atomic_ref (atom, .false.)\n+  ! ...\n+  call atomic_ref (atom, val)\n+  if (val) then\n+    print *, \"Obtained\"\n+  end if\n+end program atomic\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{ATOMIC_DEFINE}, @ref{ISO_FORTRAN_ENV}\n+@end table\n+\n+\n+\n @node BESSEL_J0\n @section @code{BESSEL_J0} --- Bessel function of the first kind of order 0\n @fnindex BESSEL_J0"}, {"sha": "9d94e3b91075353ea4629a93ad89f52a2b8c2561", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -2894,6 +2894,22 @@ create_formal_for_intents (gfc_actual_arglist* actual, const sym_intent* ints)\n }\n \n \n+void\n+gfc_resolve_atomic_def (gfc_code *c)\n+{\n+  const char *name = \"atomic_define\";\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n+}\n+\n+\n+void\n+gfc_resolve_atomic_ref (gfc_code *c)\n+{\n+  const char *name = \"atomic_ref\";\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n+}\n+\n+\n void\n gfc_resolve_mvbits (gfc_code *c)\n {"}, {"sha": "8ec70745e58edc726437934745d780c7c8772c51", "filename": "gcc/fortran/iso-fortran-env.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fiso-fortran-env.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Fiso-fortran-env.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-fortran-env.def?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -38,9 +38,9 @@ along with GCC; see the file COPYING3.  If not see\n      -- the standard that supports this type  */ \n \n NAMED_INTCST (ISOFORTRANENV_FILE_ATOMIC_INT_KIND, \"atomic_int_kind\", \\\n-              gfc_default_integer_kind, GFC_STD_F2008)\n+              gfc_atomic_int_kind, GFC_STD_F2008)\n NAMED_INTCST (ISOFORTRANENV_FILE_ATOMIC_LOGICAL_KIND, \"atomic_logical_kind\", \\\n-              gfc_default_logical_kind, GFC_STD_F2008)\n+              gfc_atomic_logical_kind, GFC_STD_F2008)\n NAMED_INTCST (ISOFORTRANENV_CHARACTER_STORAGE_SIZE, \"character_storage_size\", \\\n               gfc_character_storage_size, GFC_STD_F2003)\n NAMED_INTCST (ISOFORTRANENV_ERROR_UNIT, \"error_unit\", GFC_STDERR_UNIT_NUMBER, \\"}, {"sha": "db2bbc147708f7ff1c330a07e08ae4302c5cf7d7", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -6952,8 +6952,44 @@ gfc_walk_intrinsic_function (gfc_ss * ss, gfc_expr * expr,\n }\n \n \n-tree\n-gfc_conv_intrinsic_move_alloc (gfc_code *code)\n+static tree\n+conv_intrinsic_atomic_def (gfc_code *code)\n+{\n+  gfc_se atom, value;\n+  stmtblock_t block;\n+\n+  gfc_init_se (&atom, NULL);\n+  gfc_init_se (&value, NULL);\n+  gfc_conv_expr (&atom, code->ext.actual->expr);\n+  gfc_conv_expr (&value, code->ext.actual->next->expr);\n+\n+  gfc_init_block (&block);\n+  gfc_add_modify (&block, atom.expr,\n+\t\t  fold_convert (TREE_TYPE (atom.expr), value.expr));\n+  return gfc_finish_block (&block);\n+}\n+\n+\n+static tree\n+conv_intrinsic_atomic_ref (gfc_code *code)\n+{\n+  gfc_se atom, value;\n+  stmtblock_t block;\n+\n+  gfc_init_se (&atom, NULL);\n+  gfc_init_se (&value, NULL);\n+  gfc_conv_expr (&value, code->ext.actual->expr);\n+  gfc_conv_expr (&atom, code->ext.actual->next->expr);\n+\n+  gfc_init_block (&block);\n+  gfc_add_modify (&block, value.expr,\n+\t\t  fold_convert (TREE_TYPE (value.expr), atom.expr));\n+  return gfc_finish_block (&block);\n+}\n+\n+\n+static tree\n+conv_intrinsic_move_alloc (gfc_code *code)\n {\n   if (code->ext.actual->expr->rank == 0)\n     {\n@@ -7002,4 +7038,33 @@ gfc_conv_intrinsic_move_alloc (gfc_code *code)\n }\n \n \n+tree\n+gfc_conv_intrinsic_subroutine (gfc_code *code)\n+{\n+  tree res;\n+\n+  gcc_assert (code->resolved_isym);\n+\n+  switch (code->resolved_isym->id)\n+    {\n+    case GFC_ISYM_MOVE_ALLOC:\n+      res = conv_intrinsic_move_alloc (code);\n+      break;\n+\n+    case GFC_ISYM_ATOMIC_DEF:\n+      res = conv_intrinsic_atomic_def (code);\n+      break;\n+\n+    case GFC_ISYM_ATOMIC_REF:\n+      res = conv_intrinsic_atomic_ref (code);\n+      break;\n+\n+    default:\n+      res = NULL_TREE;\n+      break;\n+    }\n+\n+  return res;\n+}\n+\n #include \"gt-fortran-trans-intrinsic.h\""}, {"sha": "6d384bedf16a1ec29b9b823cf201928791db84e5", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -118,6 +118,8 @@ int gfc_default_character_kind;\n int gfc_default_logical_kind;\n int gfc_default_complex_kind;\n int gfc_c_int_kind;\n+int gfc_atomic_int_kind;\n+int gfc_atomic_logical_kind;\n \n /* The kind size used for record offsets. If the target system supports\n    kind=8, this will be set to 8, otherwise it is set to 4.  */\n@@ -578,6 +580,10 @@ gfc_init_kinds (void)\n   /* Pick a kind the same size as the C \"int\" type.  */\n   gfc_c_int_kind = INT_TYPE_SIZE / 8;\n \n+  /* Choose atomic kinds to match C's int.  */\n+  gfc_atomic_int_kind = gfc_c_int_kind;\n+  gfc_atomic_logical_kind = gfc_c_int_kind;\n+\n   /* initialize the C interoperable kinds  */\n   init_c_interop_kinds();\n }"}, {"sha": "f2f13525b39ade4032185842d7bc5efa434f6b74", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -1245,15 +1245,20 @@ trans_code (gfc_code * code, tree cond)\n \t     dependency check, too.  */\n \t  {\n \t    bool is_mvbits = false;\n+\n+\t    if (code->resolved_isym)\n+\t      {\n+\t\tres = gfc_conv_intrinsic_subroutine (code);\n+\t\tif (res != NULL_TREE)\n+\t\t  break;\n+\t      }\n+\n \t    if (code->resolved_isym\n \t\t&& code->resolved_isym->id == GFC_ISYM_MVBITS)\n \t      is_mvbits = true;\n-\t    if (code->resolved_isym\n-\t\t&& code->resolved_isym->id == GFC_ISYM_MOVE_ALLOC)\n-\t      res = gfc_conv_intrinsic_move_alloc (code);\n-\t    else\n-\t      res = gfc_trans_call (code, is_mvbits, NULL_TREE,\n-\t\t\t\t    NULL_TREE, false);\n+\n+\t    res = gfc_trans_call (code, is_mvbits, NULL_TREE,\n+\t\t\t\t  NULL_TREE, false);\n \t  }\n \t  break;\n "}, {"sha": "e14e41f8a25db91d7883ad144e4259904e1f2df9", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -345,7 +345,8 @@ tree gfc_evaluate_now (tree, stmtblock_t *);\n /* Find the appropriate variant of a math intrinsic.  */\n tree gfc_builtin_decl_for_float_kind (enum built_in_function, int);\n \n-/* Intrinsic function handling.  */\n+/* Intrinsic procedure handling.  */\n+tree gfc_conv_intrinsic_subroutine (gfc_code *);\n void gfc_conv_intrinsic_function (gfc_se *, gfc_expr *);\n \n /* Is the intrinsic expanded inline.  */\n@@ -356,8 +357,6 @@ bool gfc_inline_intrinsic_function_p (gfc_expr *);\n    gfc_inline_intrinsic_function_p returns true.  */\n int gfc_is_intrinsic_libcall (gfc_expr *);\n \n-tree gfc_conv_intrinsic_move_alloc (gfc_code *);\n-\n /* Used to call ordinary functions/subroutines\n    and procedure pointer components.  */\n int gfc_conv_procedure_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,"}, {"sha": "f8eea2b32e6968cd542a542a0ce4dc4145d84430", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -1,3 +1,9 @@\n+2011-05-31  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray_atomic_1.f90: New.\n+\t* gfortran.dg/coarray/atomic_1.f90: New.\n+\n 2011-05-31  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/guality/bswaptest.c: New test."}, {"sha": "1cf621287a6dc76f479dc8d92d7253094c0ce4fc", "filename": "gcc/testsuite/gfortran.dg/coarray/atomic_1.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fatomic_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fatomic_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fatomic_1.f90?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+!\n+! PR fortran/18918\n+!\n+! Basic atomic def/ref test\n+!\n+\n+use iso_fortran_env, only: atomic_int_kind, atomic_logical_kind\n+implicit none\n+integer(atomic_int_kind) :: a(1)[*]\n+logical(atomic_logical_kind) :: c[*]\n+intrinsic :: atomic_define\n+intrinsic :: atomic_ref\n+integer(8) :: b\n+logical(1) :: d\n+\n+call atomic_define(a(1), 7_2)\n+call atomic_ref(b, a(1))\n+if (b /= a(1)) call abort()\n+\n+call atomic_define(c, .false.)\n+call atomic_ref(d, c[this_image()])\n+if (d .neqv. .false.) call abort()\n+call atomic_define(c[this_image()], .true.)\n+call atomic_ref(d, c)\n+if (d .neqv. .true.) call abort()\n+end"}, {"sha": "bf94b914cb71193a861fdace078dd7f140318d4c", "filename": "gcc/testsuite/gfortran.dg/coarray_atomic_1.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da661a58be64d71f95def0309a692fc4a8cd2684/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_1.f90?ref=da661a58be64d71f95def0309a692fc4a8cd2684", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single -std=f2008\" }\n+!\n+! PR fortran/18918\n+!\n+! Diagnostic for atomic subroutines\n+!\n+use iso_fortran_env, only: atomic_int_kind, atomic_logical_kind\n+implicit none\n+integer(atomic_int_kind) :: a(1)[*]\n+logical(1) :: c[*]\n+integer(atomic_int_kind) :: b\n+logical(atomic_logical_kind) :: d, e[*]\n+\n+call atomic_define(a, 7_2) ! { dg-error \"must be a scalar\" }\n+call atomic_ref(b, b) ! { dg-error \"shall be a coarray\" }\n+\n+call atomic_define(c, 7) ! { dg-error \"an integer of ATOMIC_INT_KIND or a logical of ATOMIC_LOGICAL_KIND\" }\n+call atomic_ref(d, a(1)) ! { dg-error \"shall have the same type\" }\n+call atomic_ref(.true., e) ! { dg-error \"shall be definable\" }\n+end"}]}