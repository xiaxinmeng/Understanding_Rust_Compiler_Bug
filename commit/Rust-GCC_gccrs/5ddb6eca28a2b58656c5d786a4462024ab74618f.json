{"sha": "5ddb6eca28a2b58656c5d786a4462024ab74618f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRkYjZlY2EyOGEyYjU4NjU2YzVkNzg2YTQ0NjIwMjRhYjc0NjE4Zg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-11-30T19:11:34Z"}, "committer": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-11-30T19:11:34Z"}, "message": "Remove dead cc0 code from H8 port\n\ngcc/\n\t* config/h8300/bitfield.md: Remove \"cc\" attribute on any\n\tinsns where it remained.\n\t* config/h8300/combiner.md: Likewise.\n\t* config/h8300/jumpcall.md: Likewise.\n\t* config/h8300/logical.md: Likewise.\n\t* config/h8300/testcompare.md: Likewise.\n\t* config/h8300/h8300.md (old_cc attr): Renamed from cc attr.\n\t* config/h8300/h8300.c (notice_update_cc): Remove.\n\t(compute_plussi_cc): Change references to CC_* to OLD_CC_.\n\t(compute_logical_op_cc): Likewise.\n\t(shift_one, shift_two): Likewise.\n\t(compute_a_shift_cc): Likewise.\n\t(get_shift_alg): Likewise.\n\t(struct shift_insn): Change type of cc_valid field.\n\t(struct shift_info): Likewise.\n\t* config/h8300/save.md: Remove accidentially created file.", "tree": {"sha": "fbae518150dc4a212feb62c1627f8a2a96c31f7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbae518150dc4a212feb62c1627f8a2a96c31f7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ddb6eca28a2b58656c5d786a4462024ab74618f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ddb6eca28a2b58656c5d786a4462024ab74618f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ddb6eca28a2b58656c5d786a4462024ab74618f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ddb6eca28a2b58656c5d786a4462024ab74618f/comments", "author": null, "committer": null, "parents": [{"sha": "b46314c78061a5156bac44a317c87d32b00d4295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46314c78061a5156bac44a317c87d32b00d4295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b46314c78061a5156bac44a317c87d32b00d4295"}], "stats": {"total": 707, "additions": 100, "deletions": 607}, "files": [{"sha": "722c147fe4fe34a060f9b60ea87966426900c08a", "filename": "gcc/config/h8300/bitfield.md", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Fbitfield.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Fbitfield.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fbitfield.md?ref=5ddb6eca28a2b58656c5d786a4462024ab74618f", "patch": "@@ -69,8 +69,7 @@\n {\n   return output_simode_bld (0, operands);\n }\n-  [(set_attr \"cc\" \"set_znv,set_znv\")\n-   (set_attr \"length\" \"8,6\")])\n+  [(set_attr \"length\" \"8,6\")])\n \n ;;\n ;; Inverted loads with a 32bit destination.\n@@ -104,8 +103,7 @@\n {\n   return output_simode_bld (1, operands);\n }\n-  [(set_attr \"cc\" \"set_znv,set_znv\")\n-   (set_attr \"length\" \"8,6\")])\n+  [(set_attr \"length\" \"8,6\")])\n \n (define_expand \"insv\"\n   [(set (zero_extract:HI (match_operand:HI 0 \"general_operand\" \"\")\n@@ -312,8 +310,7 @@\n \t\t\t - (1 << INTVAL (operands[3])));\n   return \"bfld\t%2,%1,%R0\";\n }\n-  [(set_attr \"cc\" \"none_0hit\")\n-   (set_attr \"length_table\" \"bitfield\")])\n+  [(set_attr \"length_table\" \"bitfield\")])\n \n (define_insn_and_split \"bfst\"\n   [(set (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"+WU\")\n@@ -339,8 +336,7 @@\n \t\t\t - (1 << INTVAL (operands[3])));\n   return \"bfst\t%R1,%2,%0\";\n }\n-  [(set_attr \"cc\" \"none_0hit\")\n-   (set_attr \"length_table\" \"bitfield\")])\n+  [(set_attr \"length_table\" \"bitfield\")])\n \n ;;(define_expand \"cstore<mode>4\"\n ;;  [(use (match_operator 1 \"eqne_operator\"\n@@ -357,8 +353,7 @@\n ;;  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n ;;\t(match_operator:HI 1 \"eqne_operator\" [(cc0) (const_int 0)]))]\n ;;  \"TARGET_H8300SX\"\n-;;  \"mulu.w\t#0,%T0\\;b%k1\t.Lh8BR%=\\;inc.w\t#1,%T0\\\\n.Lh8BR%=:\"\n-;;  [(set_attr \"cc\" \"clobber\")])\n+;;  \"mulu.w\t#0,%T0\\;b%k1\t.Lh8BR%=\\;inc.w\t#1,%T0\\\\n.Lh8BR%=:\")\n \n ;;(define_insn_and_split \"*cmpstz\"\n ;;  [(set (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"+WU,WU\")\n@@ -379,8 +374,7 @@\n ;;\t(match_op_dup:QI 2 [(cc0) (const_int 0)]))]\n ;;  {\n ;;    operands[5] = gen_rtx_COMPARE (VOIDmode, operands[3], operands[4]);\n-;;  }\n-;;  [(set_attr \"cc\" \"set_znv,compare\")])\n+;;  })\n \n ;;(define_insn \"*bstz\"\n ;;  [(set (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"+WU\")\n@@ -389,8 +383,7 @@\n ;;\t(eq:QI (cc0) (const_int 0)))]\n ;;  \"TARGET_H8300SX && reload_completed\"\n ;;  \"bstz\t%1,%0\"\n-;;  [(set_attr \"cc\" \"none_0hit\")\n-;;   (set_attr \"length_table\" \"unary\")])\n+;;  [(set_attr \"length_table\" \"unary\")])\n \n ;;(define_insn \"*bistz\"\n ;;  [(set (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"+WU\")\n@@ -399,8 +392,7 @@\n ;;\t(ne:QI (cc0) (const_int 0)))]\n ;;  \"TARGET_H8300SX && reload_completed\"\n ;;  \"bistz\t%1,%0\"\n-;;  [(set_attr \"cc\" \"none_0hit\")\n-;;   (set_attr \"length_table\" \"unary\")])\n+;;  [(set_attr \"length_table\" \"unary\")])\n \n ;;(define_insn_and_split \"*cmpcondbset\"\n ;;  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n@@ -420,8 +412,7 @@\n ;;\t\t\t (match_dup 4)))]\n ;;  {\n ;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n-;;  }\n-;; [(set_attr \"cc\" \"set_znv,compare\")])\n+;;  })\n \n ;;(define_insn \"*condbset\"\n ;;  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n@@ -432,8 +423,7 @@\n ;;\t\t\t (match_dup 3)))]\n ;;  \"TARGET_H8300SX && reload_completed\"\n ;;  \"bset/%j2\\t%V1,%0\"\n-;;  [(set_attr \"cc\" \"none_0hit\")\n-;;   (set_attr \"length_table\" \"logicb\")])\n+;;  [(set_attr \"length_table\" \"logicb\")])\n \n ;;(define_insn_and_split \"*cmpcondbclr\"\n ;;  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n@@ -453,8 +443,7 @@\n ;;\t\t\t (match_dup 4)))]\n ;;  {\n ;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n-;;  }\n-;;  [(set_attr \"cc\" \"set_znv,compare\")])\n+;;  })\n \n ;;(define_insn \"*condbclr\"\n ;;  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n@@ -465,8 +454,7 @@\n ;;\t\t\t (match_dup 3)))]\n ;;  \"TARGET_H8300SX && reload_completed\"\n ;;  \"bclr/%j2\\t%W1,%0\"\n-;;  [(set_attr \"cc\" \"none_0hit\")\n-;;   (set_attr \"length_table\" \"logicb\")])\n+;;  [(set_attr \"length_table\" \"logicb\")])\n \n ;;(define_insn_and_split \"*cmpcondbsetreg\"\n ;;  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n@@ -489,8 +477,7 @@\n ;;\t\t\t (match_dup 4)))]\n ;;  {\n ;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n-;;  }\n-;;  [(set_attr \"cc\" \"set_znv,compare\")])\n+;;  })\n \n ;;(define_insn \"*condbsetreg\"\n ;;  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n@@ -502,8 +489,7 @@\n ;;\t\t\t (match_dup 3)))]\n ;;  \"TARGET_H8300SX && reload_completed\"\n ;;  \"bset/%j2\\t%R1,%0\"\n-;;  [(set_attr \"cc\" \"none_0hit\")\n-;;   (set_attr \"length_table\" \"logicb\")])\n+;;  [(set_attr \"length_table\" \"logicb\")])\n \n ;;(define_insn_and_split \"*cmpcondbclrreg\"\n ;;  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=WU,WU\")\n@@ -526,8 +512,7 @@\n ;;\t\t\t (match_dup 4)))]\n ;;  {\n ;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n-;;  }\n-;;  [(set_attr \"cc\" \"set_znv,compare\")])\n+;;  })\n \n ;;(define_insn \"*condbclrreg\"\n ;;  [(set (match_operand:QI 0 \"bit_memory_operand\" \"=WU\")\n@@ -539,6 +524,5 @@\n ;;\t\t\t (match_dup 3)))]\n ;;  \"TARGET_H8300SX && reload_completed\"\n ;;  \"bclr/%j2\\t%R1,%0\"\n-;;  [(set_attr \"cc\" \"none_0hit\")\n-;;   (set_attr \"length_table\" \"logicb\")])\n+;;  [(set_attr \"length_table\" \"logicb\")])\n "}, {"sha": "20e19da04199441cd1c31c71d6e4edcce21b3067", "filename": "gcc/config/h8300/combiner.md", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Fcombiner.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Fcombiner.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fcombiner.md?ref=5ddb6eca28a2b58656c5d786a4462024ab74618f", "patch": "@@ -144,8 +144,7 @@\n   \"@\n    mov.b\\\\t%x1,%w0\\;extu.w\\\\t%f0\\;extu.l\\\\t%S0\n    sub.l\\\\t%S0,%S0\\;mov.b\\\\t%x1,%w0\"\n-  [(set_attr \"cc\" \"set_znv,clobber\")\n-   (set_attr \"length\" \"6,4\")])\n+  [(set_attr \"length\" \"6,4\")])\n \n (define_insn_and_split \"*extzv_8_16\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -167,8 +166,7 @@\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"mov.w\\\\t%e1,%f0\\;extu.w\\\\t%f0\\;extu.l\\\\t%S0\"\n-  [(set_attr \"cc\" \"set_znv\")\n-   (set_attr \"length\" \"6\")])\n+  [(set_attr \"length\" \"6\")])\n \n (define_insn_and_split \"*extzv_16_8\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -192,8 +190,7 @@\n    (clobber (reg:CC CC_REG))]\n   \"TARGET_H8300H\"\n   \"mov.w\\\\t%e1,%f2\\;mov.b\\\\t%x1,%w0\\;mov.b\\\\t%w2,%x0\\;extu.l\\\\t%S0\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"cc\" \"set_znv\")])\n+  [(set_attr \"length\" \"8\")])\n \n ;; Extract the exponent of a float.\n \n@@ -775,8 +772,7 @@\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"rotxl.l\\\\t%S0\\;bor\\\\t#0,%w1\\;rotxr.l\\\\t%S0\"\n-  [(set_attr \"length\" \"6\")\n-   (set_attr \"cc\" \"set_znv\")])\n+  [(set_attr \"length\" \"6\")])\n \n (define_insn_and_split \"*iorsi3_and_ashift\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1163,8 +1159,7 @@\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"mov.b\\\\t%t1,%R0\"\n-  [(set_attr \"cc\" \"set_znv\")\n-   (set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8\")])\n \n ;; Storing a part of SImode to QImode.\n \n@@ -1186,8 +1181,7 @@\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"mov.b\\\\t%x1,%R0\"\n-  [(set_attr \"cc\" \"set_znv\")\n-   (set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8\")])\n \n (define_insn_and_split \"\"\n   [(set (match_operand:QI 0 \"general_operand_dst\" \"=rm<\")\n@@ -1210,8 +1204,7 @@\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"mov.w\\\\t%e1,%f2\\;mov.b\\\\t%w2,%R0\"\n-  [(set_attr \"cc\" \"set_znv\")\n-   (set_attr \"length\" \"10\")])\n+  [(set_attr \"length\" \"10\")])\n \n (define_insn_and_split \"\"\n   [(set (match_operand:QI 0 \"general_operand_dst\" \"=rm<\")\n@@ -1234,8 +1227,7 @@\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"mov.w\\\\t%e1,%f2\\;mov.b\\\\t%x2,%R0\"\n-  [(set_attr \"cc\" \"set_znv\")\n-   (set_attr \"length\" \"10\")])\n+  [(set_attr \"length\" \"10\")])\n \n ;;(define_insn_and_split \"\"\n ;;  [(set (pc)"}, {"sha": "31e23b238cc6e9c63fc0050b38d685d2af0030c6", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 63, "deletions": 131, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=5ddb6eca28a2b58656c5d786a4462024ab74618f", "patch": "@@ -1956,74 +1956,6 @@ h8300_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1)\n   return CCmode;\n }\n \n-#if 0\n-/* Update the condition code from the insn.  */\n-\n-void\n-notice_update_cc (rtx body, rtx_insn *insn)\n-{\n-  rtx set;\n-\n-  switch (get_attr_cc (insn))\n-    {\n-    case CC_NONE:\n-      /* Insn does not affect CC at all.  */\n-      break;\n-\n-    case CC_NONE_0HIT:\n-      /* Insn does not change CC, but the 0'th operand has been changed.  */\n-      if (cc_status.value1 != 0\n-\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))\n-\tcc_status.value1 = 0;\n-      if (cc_status.value2 != 0\n-\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value2))\n-\tcc_status.value2 = 0;\n-      break;\n-\n-    case CC_SET_ZN:\n-      /* Insn sets the Z,N flags of CC to recog_data.operand[0].\n-\t The V flag is unusable.  The C flag may or may not be known but\n-\t that's ok because alter_cond will change tests to use EQ/NE.  */\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_OVERFLOW_UNUSABLE | CC_NO_CARRY;\n-      set = single_set (insn);\n-      cc_status.value1 = SET_SRC (set);\n-      if (SET_DEST (set) != cc0_rtx)\n-\tcc_status.value2 = SET_DEST (set);\n-      break;\n-\n-    case CC_SET_ZNV:\n-      /* Insn sets the Z,N,V flags of CC to recog_data.operand[0].\n-\t The C flag may or may not be known but that's ok because\n-\t alter_cond will change tests to use EQ/NE.  */\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_NO_CARRY;\n-      set = single_set (insn);\n-      cc_status.value1 = SET_SRC (set);\n-      if (SET_DEST (set) != cc0_rtx)\n-\t{\n-\t  /* If the destination is STRICT_LOW_PART, strip off\n-\t     STRICT_LOW_PART.  */\n-\t  if (GET_CODE (SET_DEST (set)) == STRICT_LOW_PART)\n-\t    cc_status.value2 = XEXP (SET_DEST (set), 0);\n-\t  else\n-\t    cc_status.value2 = SET_DEST (set);\n-\t}\n-      break;\n-\n-    case CC_COMPARE:\n-      /* The insn is a compare instruction.  */\n-      CC_STATUS_INIT;\n-      cc_status.value1 = SET_SRC (body);\n-      break;\n-\n-    case CC_CLOBBER:\n-      /* Insn doesn't leave CC in a usable state.  */\n-      CC_STATUS_INIT;\n-      break;\n-    }\n-}\n-#endif\n \f\n /* Given that X occurs in an address of the form (plus X constant),\n    return the part of X that is expected to be a register.  There are\n@@ -2882,7 +2814,7 @@ compute_plussi_length (rtx *operands, bool need_flags)\n \n /* Compute which flag bits are valid after an addition insn.  */\n \n-enum attr_cc\n+enum attr_old_cc\n compute_plussi_cc (rtx *operands)\n {\n   machine_mode mode = GET_MODE (operands[0]);\n@@ -2895,9 +2827,9 @@ compute_plussi_cc (rtx *operands)\n       HOST_WIDE_INT intval = INTVAL (operands[2]);\n \n       if (TARGET_H8300SX && (intval >= 1 && intval <= 7))\n-\treturn CC_SET_ZN;\n+\treturn OLD_CC_SET_ZN;\n       if (TARGET_H8300SX && (intval >= -7 && intval <= -1))\n-\treturn CC_SET_ZN;\n+\treturn OLD_CC_SET_ZN;\n \n       /* See if we can finish with 2 bytes.  */\n \n@@ -2906,28 +2838,28 @@ compute_plussi_cc (rtx *operands)\n \tcase 0x00000001:\n \tcase 0x00000002:\n \tcase 0x00000004:\n-\t  return CC_NONE_0HIT;\n+\t  return OLD_CC_NONE_0HIT;\n \n \tcase 0xffffffff:\n \tcase 0xfffffffe:\n \tcase 0xfffffffc:\n-\t  return CC_NONE_0HIT;\n+\t  return OLD_CC_NONE_0HIT;\n \n \tcase 0x00010000:\n \tcase 0x00020000:\n-\t  return CC_CLOBBER;\n+\t  return OLD_CC_CLOBBER;\n \n \tcase 0xffff0000:\n \tcase 0xfffe0000:\n-\t  return CC_CLOBBER;\n+\t  return OLD_CC_CLOBBER;\n \t}\n \n       /* See if we can finish with 4 bytes.  */\n       if ((intval & 0xffff) == 0)\n-\treturn CC_CLOBBER;\n+\treturn OLD_CC_CLOBBER;\n     }\n \n-  return CC_SET_ZN;\n+  return OLD_CC_SET_ZN;\n }\n \f\n /* Output a logical insn.  */\n@@ -3234,15 +3166,15 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)\n   int lower_half_easy_p = 0;\n   int upper_half_easy_p = 0;\n   /* Condition code.  */\n-  enum attr_cc cc = CC_CLOBBER;\n+  enum attr_old_cc cc = OLD_CC_CLOBBER;\n \n   switch (mode)\n     {\n     case E_HImode:\n       /* First, see if we can finish with one insn.  */\n       if (b0 != 0 && b1 != 0)\n \t{\n-\t  cc = CC_SET_ZNV;\n+\t  cc = OLD_CC_SET_ZNV;\n \t}\n       break;\n     case E_SImode:\n@@ -3264,15 +3196,15 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)\n \t  && !(code == IOR && w1 == 0xffff\n \t       && (w0 & 0x8000) != 0 && lower_half_easy_p))\n \t{\n-\t  cc = CC_SET_ZNV;\n+\t  cc = OLD_CC_SET_ZNV;\n \t}\n       else\n \t{\n \t  if (code == IOR\n \t      && w1 == 0xffff\n \t      && (w0 & 0x8000) != 0)\n \t    {\n-\t      cc = CC_SET_ZNV;\n+\t      cc = OLD_CC_SET_ZNV;\n \t    }\n \t}\n       break;\n@@ -3500,13 +3432,13 @@ enum shift_mode\n };\n \n /* For single bit shift insns, record assembler and what bits of the\n-   condition code are valid afterwards (represented as various CC_FOO\n+   condition code are valid afterwards (represented as various OLD_CC_FOO\n    bits, 0 means CC isn't left in a usable state).  */\n \n struct shift_insn\n {\n   const char *const assembler;\n-  const enum attr_cc cc_valid;\n+  const enum attr_old_cc cc_valid;\n };\n \n /* Assembler instruction shift table.\n@@ -3520,42 +3452,42 @@ static const struct shift_insn shift_one[2][3][3] =\n   {\n /* SHIFT_ASHIFT */\n     {\n-      { \"shll\\t%X0\", CC_SET_ZNV },\n-      { \"add.w\\t%T0,%T0\", CC_SET_ZN },\n-      { \"add.w\\t%f0,%f0\\n\\taddx\\t%y0,%y0\\n\\taddx\\t%z0,%z0\", CC_CLOBBER }\n+      { \"shll\\t%X0\", OLD_CC_SET_ZNV },\n+      { \"add.w\\t%T0,%T0\", OLD_CC_SET_ZN },\n+      { \"add.w\\t%f0,%f0\\n\\taddx\\t%y0,%y0\\n\\taddx\\t%z0,%z0\", OLD_CC_CLOBBER }\n     },\n /* SHIFT_LSHIFTRT */\n     {\n-      { \"shlr\\t%X0\", CC_SET_ZNV },\n-      { \"shlr\\t%t0\\n\\trotxr\\t%s0\", CC_CLOBBER },\n-      { \"shlr\\t%z0\\n\\trotxr\\t%y0\\n\\trotxr\\t%x0\\n\\trotxr\\t%w0\", CC_CLOBBER }\n+      { \"shlr\\t%X0\", OLD_CC_SET_ZNV },\n+      { \"shlr\\t%t0\\n\\trotxr\\t%s0\", OLD_CC_CLOBBER },\n+      { \"shlr\\t%z0\\n\\trotxr\\t%y0\\n\\trotxr\\t%x0\\n\\trotxr\\t%w0\", OLD_CC_CLOBBER }\n     },\n /* SHIFT_ASHIFTRT */\n     {\n-      { \"shar\\t%X0\", CC_SET_ZNV },\n-      { \"shar\\t%t0\\n\\trotxr\\t%s0\", CC_CLOBBER },\n-      { \"shar\\t%z0\\n\\trotxr\\t%y0\\n\\trotxr\\t%x0\\n\\trotxr\\t%w0\", CC_CLOBBER }\n+      { \"shar\\t%X0\", OLD_CC_SET_ZNV },\n+      { \"shar\\t%t0\\n\\trotxr\\t%s0\", OLD_CC_CLOBBER },\n+      { \"shar\\t%z0\\n\\trotxr\\t%y0\\n\\trotxr\\t%x0\\n\\trotxr\\t%w0\", OLD_CC_CLOBBER }\n     }\n   },\n /* H8/300H */\n   {\n /* SHIFT_ASHIFT */\n     {\n-      { \"shll.b\\t%X0\", CC_SET_ZNV },\n-      { \"shll.w\\t%T0\", CC_SET_ZNV },\n-      { \"shll.l\\t%S0\", CC_SET_ZNV }\n+      { \"shll.b\\t%X0\", OLD_CC_SET_ZNV },\n+      { \"shll.w\\t%T0\", OLD_CC_SET_ZNV },\n+      { \"shll.l\\t%S0\", OLD_CC_SET_ZNV }\n     },\n /* SHIFT_LSHIFTRT */\n     {\n-      { \"shlr.b\\t%X0\", CC_SET_ZNV },\n-      { \"shlr.w\\t%T0\", CC_SET_ZNV },\n-      { \"shlr.l\\t%S0\", CC_SET_ZNV }\n+      { \"shlr.b\\t%X0\", OLD_CC_SET_ZNV },\n+      { \"shlr.w\\t%T0\", OLD_CC_SET_ZNV },\n+      { \"shlr.l\\t%S0\", OLD_CC_SET_ZNV }\n     },\n /* SHIFT_ASHIFTRT */\n     {\n-      { \"shar.b\\t%X0\", CC_SET_ZNV },\n-      { \"shar.w\\t%T0\", CC_SET_ZNV },\n-      { \"shar.l\\t%S0\", CC_SET_ZNV }\n+      { \"shar.b\\t%X0\", OLD_CC_SET_ZNV },\n+      { \"shar.w\\t%T0\", OLD_CC_SET_ZNV },\n+      { \"shar.l\\t%S0\", OLD_CC_SET_ZNV }\n     }\n   }\n };\n@@ -3564,21 +3496,21 @@ static const struct shift_insn shift_two[3][3] =\n {\n /* SHIFT_ASHIFT */\n     {\n-      { \"shll.b\\t#2,%X0\", CC_SET_ZNV },\n-      { \"shll.w\\t#2,%T0\", CC_SET_ZNV },\n-      { \"shll.l\\t#2,%S0\", CC_SET_ZNV }\n+      { \"shll.b\\t#2,%X0\", OLD_CC_SET_ZNV },\n+      { \"shll.w\\t#2,%T0\", OLD_CC_SET_ZNV },\n+      { \"shll.l\\t#2,%S0\", OLD_CC_SET_ZNV }\n     },\n /* SHIFT_LSHIFTRT */\n     {\n-      { \"shlr.b\\t#2,%X0\", CC_SET_ZNV },\n-      { \"shlr.w\\t#2,%T0\", CC_SET_ZNV },\n-      { \"shlr.l\\t#2,%S0\", CC_SET_ZNV }\n+      { \"shlr.b\\t#2,%X0\", OLD_CC_SET_ZNV },\n+      { \"shlr.w\\t#2,%T0\", OLD_CC_SET_ZNV },\n+      { \"shlr.l\\t#2,%S0\", OLD_CC_SET_ZNV }\n     },\n /* SHIFT_ASHIFTRT */\n     {\n-      { \"shar.b\\t#2,%X0\", CC_SET_ZNV },\n-      { \"shar.w\\t#2,%T0\", CC_SET_ZNV },\n-      { \"shar.l\\t#2,%S0\", CC_SET_ZNV }\n+      { \"shar.b\\t#2,%X0\", OLD_CC_SET_ZNV },\n+      { \"shar.w\\t#2,%T0\", OLD_CC_SET_ZNV },\n+      { \"shar.l\\t#2,%S0\", OLD_CC_SET_ZNV }\n     }\n };\n \n@@ -3674,10 +3606,10 @@ struct shift_info {\n   const char *shift2;\n \n   /* CC status for SHIFT_INLINE.  */\n-  enum attr_cc cc_inline;\n+  enum attr_old_cc cc_inline;\n \n   /* CC status  for SHIFT_SPECIAL.  */\n-  enum attr_cc cc_special;\n+  enum attr_old_cc cc_special;\n };\n \n static void get_shift_alg (enum shift_type,\n@@ -3746,7 +3678,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n     case SHIFT_ROT_AND:\n       info->shift1 = rotate_one[cpu_type][shift_type][shift_mode];\n       info->shift2 = rotate_two[shift_type][shift_mode];\n-      info->cc_inline = CC_CLOBBER;\n+      info->cc_inline = OLD_CC_CLOBBER;\n       goto end;\n \n     case SHIFT_SPECIAL:\n@@ -3755,7 +3687,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n       info->shift1 = shift_one[cpu_type][shift_type][shift_mode].assembler;\n       info->shift2 = shift_two[shift_type][shift_mode].assembler;\n       info->cc_inline = shift_one[cpu_type][shift_type][shift_mode].cc_valid;\n-      info->cc_special = CC_CLOBBER;\n+      info->cc_special = OLD_CC_CLOBBER;\n       break;\n     }\n \n@@ -3797,11 +3729,11 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      goto end;\n \t    case SHIFT_LSHIFTRT:\n \t      info->special = \"mov.b\\t%t0,%s0\\n\\textu.w\\t%T0\";\n-\t      info->cc_special = CC_SET_ZNV;\n+\t      info->cc_special = OLD_CC_SET_ZNV;\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n \t      info->special = \"mov.b\\t%t0,%s0\\n\\texts.w\\t%T0\";\n-\t      info->cc_special = CC_SET_ZNV;\n+\t      info->cc_special = OLD_CC_SET_ZNV;\n \t      goto end;\n \t    }\n \t}\n@@ -3817,7 +3749,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      if (TARGET_H8300H)\n \t\t{\n \t\t  info->special = \"shll.b\\t%t0\\n\\tsubx.b\\t%s0,%s0\\n\\tshll.b\\t%t0\\n\\trotxl.b\\t%s0\\n\\texts.w\\t%T0\";\n-\t\t  info->cc_special = CC_SET_ZNV;\n+\t\t  info->cc_special = OLD_CC_SET_ZNV;\n \t\t}\n \t      else /* TARGET_H8300S */\n \t\tgcc_unreachable ();\n@@ -3863,11 +3795,11 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t    {\n \t    case SHIFT_ASHIFT:\n \t      info->special = \"shlr.w\\t%e0\\n\\tmov.w\\t%f0,%e0\\n\\txor.w\\t%f0,%f0\\n\\trotxr.l\\t%S0\";\n-\t      info->cc_special = CC_SET_ZNV;\n+\t      info->cc_special = OLD_CC_SET_ZNV;\n \t      goto end;\n \t    case SHIFT_LSHIFTRT:\n \t      info->special = \"shll.w\\t%f0\\n\\tmov.w\\t%e0,%f0\\n\\txor.w\\t%e0,%e0\\n\\trotxl.l\\t%S0\";\n-\t      info->cc_special = CC_SET_ZNV;\n+\t      info->cc_special = OLD_CC_SET_ZNV;\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n \t      gcc_unreachable ();\n@@ -3885,11 +3817,11 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      goto end;\n \t    case SHIFT_LSHIFTRT:\n \t      info->special = \"mov.w\\t%e0,%f0\\n\\textu.l\\t%S0\";\n-\t      info->cc_special = CC_SET_ZNV;\n+\t      info->cc_special = OLD_CC_SET_ZNV;\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n \t      info->special = \"mov.w\\t%e0,%f0\\n\\texts.l\\t%S0\";\n-\t      info->cc_special = CC_SET_ZNV;\n+\t      info->cc_special = OLD_CC_SET_ZNV;\n \t      goto end;\n \t    }\n \t}\n@@ -3905,11 +3837,11 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      goto end;\n \t    case SHIFT_LSHIFTRT:\n \t      info->special = \"mov.w\\t%e0,%f0\\n\\tmov.b\\t%t0,%s0\\n\\textu.w\\t%f0\\n\\textu.l\\t%S0\";\n-\t      info->cc_special = CC_SET_ZNV;\n+\t      info->cc_special = OLD_CC_SET_ZNV;\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n \t      info->special = \"mov.w\\t%e0,%f0\\n\\tmov.b\\t%t0,%s0\\n\\texts.w\\t%f0\\n\\texts.l\\t%S0\";\n-\t      info->cc_special = CC_SET_ZNV;\n+\t      info->cc_special = OLD_CC_SET_ZNV;\n \t      goto end;\n \t    }\n \t}\n@@ -3927,7 +3859,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      if (TARGET_H8300H)\n \t\t{\n \t\t  info->special = \"sub.w\\t%f0,%f0\\n\\trotl.l\\t%S0\\n\\trotl.l\\t%S0\\n\\trotl.l\\t%S0\\n\\trotl.l\\t%S0\\n\\textu.l\\t%S0\";\n-\t\t  info->cc_special = CC_SET_ZNV;\n+\t\t  info->cc_special = OLD_CC_SET_ZNV;\n \t\t}\n \t      else\n \t\tinfo->special = \"sub.w\\t%f0,%f0\\n\\trotl.l\\t#2,%S0\\n\\trotl.l\\t#2,%S0\\n\\textu.l\\t%S0\";\n@@ -3950,12 +3882,12 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      if (TARGET_H8300H)\n \t\t{\n \t\t  info->special = \"sub.w\\t%f0,%f0\\n\\trotl.l\\t%S0\\n\\trotl.l\\t%S0\\n\\trotl.l\\t%S0\\n\\textu.l\\t%S0\";\n-\t\t  info->cc_special = CC_SET_ZNV;\n+\t\t  info->cc_special = OLD_CC_SET_ZNV;\n \t\t}\n \t      else\n \t\t{\n \t\t  info->special = \"sub.w\\t%f0,%f0\\n\\trotl.l\\t#2,%S0\\n\\trotl.l\\t%S0\\n\\textu.l\\t%S0\";\n-\t\t  info->cc_special = CC_SET_ZNV;\n+\t\t  info->cc_special = OLD_CC_SET_ZNV;\n \t\t}\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n@@ -3988,15 +3920,15 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t    {\n \t    case SHIFT_ASHIFT:\n \t      info->special = \"shlr.l\\t%S0\\n\\txor.l\\t%S0,%S0\\n\\trotxr.l\\t%S0\";\n-\t      info->cc_special = CC_SET_ZNV;\n+\t      info->cc_special = OLD_CC_SET_ZNV;\n \t      goto end;\n \t    case SHIFT_LSHIFTRT:\n \t      info->special = \"shll.l\\t%S0\\n\\txor.l\\t%S0,%S0\\n\\trotxl.l\\t%S0\";\n-\t      info->cc_special = CC_SET_ZNV;\n+\t      info->cc_special = OLD_CC_SET_ZNV;\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n \t      info->special = \"shll\\t%e0\\n\\tsubx\\t%w0,%w0\\n\\texts.w\\t%T0\\n\\texts.l\\t%S0\";\n-\t      info->cc_special = CC_SET_ZNV;\n+\t      info->cc_special = OLD_CC_SET_ZNV;\n \t      goto end;\n \t    }\n \t}\n@@ -4459,7 +4391,7 @@ compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n       \n     case SHIFT_ROT_AND:\n       /* This case always ends with an and instruction.  */\n-      return CC_SET_ZNV;\n+      return OLD_CC_SET_ZNV;\n       \n     case SHIFT_LOOP:\n       /* A loop to shift by a \"large\" constant value.\n@@ -4469,7 +4401,7 @@ compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n \t  if (n % 2)\n \t    return info.cc_inline;\n \t}\n-      return CC_CLOBBER;\n+      return OLD_CC_CLOBBER;\n       \n     default:\n       gcc_unreachable ();"}, {"sha": "7c9cc324f39eaa15417715d11f58f84f5fd69731", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=5ddb6eca28a2b58656c5d786a4462024ab74618f", "patch": "@@ -131,7 +131,7 @@\n ;; compare - compare instruction\n ;; clobber - value of cc is unknown\n \n-(define_attr \"cc\" \"none,none_0hit,set_znv,set_zn,compare,clobber\"\n+(define_attr \"old_cc\" \"none,none_0hit,set_znv,set_zn,compare,clobber\"\n   (const_string \"clobber\"))\n \n ;; Type of delay slot.  NONE means the instruction has no delay slot."}, {"sha": "c07dbaf999c105dc6da936593c03760949644cb6", "filename": "gcc/config/h8300/jumpcall.md", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Fjumpcall.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Fjumpcall.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fjumpcall.md?ref=5ddb6eca28a2b58656c5d786a4462024ab74618f", "patch": "@@ -46,8 +46,7 @@\n   else\n     return \"b%k1\t.Lh8BR%=\\;jmp\t@%l0\\\\n.Lh8BR%=:\";\n }\n- [(set_attr \"type\" \"branch\")\n-   (set_attr \"cc\" \"none\")])\n+ [(set_attr \"type\" \"branch\")])\n \n \n (define_insn \"*branch_1_false\"\n@@ -65,8 +64,7 @@\n   else\n     return \"b%j1\t.Lh8BR%=\\;jmp\t@%l0\\\\n.Lh8BR%=:\";\n }\n- [(set_attr \"type\" \"branch\")\n-   (set_attr \"cc\" \"none\")])\n+ [(set_attr \"type\" \"branch\")])\n \n ;; The brabc/brabs patterns have been disabled because their length computation\n ;; is horribly broken.  When we call out to a function via a SYMBOL_REF we get\n@@ -168,8 +166,7 @@\n    (set (attr \"delay_slot\")\n \t(if_then_else (match_test \"TARGET_H8300SX\")\n \t\t      (const_string \"jump\")\n-\t\t      (const_string \"none\")))\n-   (set_attr \"cc\" \"none\")])\n+\t\t      (const_string \"none\")))])\n \n ;; This is a define expand, because pointers may be either 16 or 32 bits.\n \n@@ -190,8 +187,7 @@\n       return \"jmp\t@%S0\";\n     abort ();\n   }\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"2\")])\n+  [(set_attr \"length\" \"2\")])\n \n ;; This is a define expand, because pointers may be either 16 or 32 bits.\n \n@@ -210,8 +206,7 @@\n       return \"jmp\t@%S0\";\n     abort ();\n   }\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"2\")])\n+  [(set_attr \"length\" \"2\")])\n \n ;; Call subroutine with no return value.\n "}, {"sha": "eb99c20b55d6e69eb65971fecbcafe04be6aa168", "filename": "gcc/config/h8300/logical.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Flogical.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Flogical.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Flogical.md?ref=5ddb6eca28a2b58656c5d786a4462024ab74618f", "patch": "@@ -278,8 +278,7 @@\n       return \"not.l\t%S0\";\n     gcc_unreachable ();\n   }\n-  [(set_attr \"length_table\" \"unary\")\n-   (set_attr \"cc\" \"set_znv\")])\n+  [(set_attr \"length_table\" \"unary\")])\n \n ;; The next four peephole2's will try to transform\n ;;"}, {"sha": "a05119f33ac2d9eeca1d788f2fc414f3c40f37fa", "filename": "gcc/config/h8300/save.md", "status": "removed", "additions": 0, "deletions": 403, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46314c78061a5156bac44a317c87d32b00d4295/gcc%2Fconfig%2Fh8300%2Fsave.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46314c78061a5156bac44a317c87d32b00d4295/gcc%2Fconfig%2Fh8300%2Fsave.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fsave.md?ref=b46314c78061a5156bac44a317c87d32b00d4295", "patch": "@@ -1,403 +0,0 @@\n-;; ----------------------------------------------------------------------\n-;; MULTIPLY INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-\n-;; Note that the H8/300 can only handle umulqihi3.\n-\n-(define_expand \"mulqihi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"\"))\n-\t\t ;; intentionally-mismatched modes\n-\t\t (match_operand:QI 2 \"reg_or_nibble_operand\" \"\")))]\n-  \"\"\n-  {\n-    if (GET_MODE (operands[2]) != VOIDmode)\n-      operands[2] = gen_rtx_SIGN_EXTEND (HImode, operands[2]);\n-  })\n-\n-(define_insn_and_split \"*mulqihi3_const\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t\t (match_operand:QI 2 \"nibble_operand\" \"IP4>X\")))]\n-  \"TARGET_H8300SX\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (mult:HI (sign_extend:HI (match_dup 1)) (match_dup 2)))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"*mulqihi3_const_clobber_flags\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t\t (match_operand:QI 2 \"nibble_operand\" \"IP4>X\")))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_H8300SX\"\n-  \"mulxs.b\t%X2,%T0\"\n-  [(set_attr \"length\" \"4\")])\n-\n-(define_insn \"*mulqihi3_const_set_flags\"\n-  [(set (reg:CCZN CC_REG)\n-\t(compare:CCZN\n-\t  (mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t\t   (match_operand:QI 2 \"nibble_operand\" \"IP4>X\"))\n-\t  (const_int 0)))\n-   (set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (sign_extend:HI (match_dup 1)) (match_dup 2)))]\n-  \"TARGET_H8300SX\"\n-  \"mulxs.b\t%X2,%T0\"\n-  [(set_attr \"length\" \"4\")])\n-\n-(define_insn_and_split \"*mulqihi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t\t (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (mult:HI (sign_extend:HI (match_dup 1))\n-\t\t\t    (sign_extend:HI (match_dup 2))))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"*mulqihi3_clobber_flags\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t\t (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))\n-   (clobber (reg:CC CC_REG))]\n-  \"\"\n-  \"mulxs.b\t%X2,%T0\"\n-  [(set_attr \"length\" \"4\")])\n-\n-(define_insn \"*mulqihi3_set_flags\"\n-  [(set (reg:CCZN CC_REG)\n-\t(compare:CCZN\n-\t  (mult:HI\n-\t    (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t    (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"r\")))\n-\t  (const_int 0)))\n-   (set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (sign_extend:HI (match_dup 1)) (sign_extend (match_dup 2))))]\n-  \"\"\n-  \"mulxs.b\t%X2,%T0\"\n-  [(set_attr \"length\" \"4\")])\n-\n-(define_expand \"mulhisi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n-\t\t ;; intentionally-mismatched modes\n-\t\t (match_operand:HI 2 \"reg_or_nibble_operand\" \"\")))]\n-  \"\"\n-  {\n-    if (GET_MODE (operands[2]) != VOIDmode)\n-      operands[2] = gen_rtx_SIGN_EXTEND (SImode, operands[2]);\n-  })\n-\n-(define_insn_and_split \"*mulhisi3_const\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t\t (match_operand:SI 2 \"nibble_operand\" \"IP4>X\")))]\n-  \"TARGET_H8300SX\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (mult:SI (sign_extend:SI (match_dup 1)) (match_dup 2)))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"*mulhisi3_const_clobber_flags\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t\t (match_operand:SI 2 \"nibble_operand\" \"IP4>X\")))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_H8300SX\"\n-  \"mulxs.w\t%T2,%S0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_zn\")])\n-\n-(define_insn_and_split \"*mulhisi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (mult:SI (sign_extend:SI (match_dup 1))\n-\t\t\t    (sign_extend:SI (match_dup 2))))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"*mulhisi3_clobber_flags\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))\n-   (clobber (reg:CC CC_REG))]\n-  \"\"\n-  \"mulxs.w\t%T2,%S0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_zn\")])\n-\n-(define_expand \"umulqihi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"\"))\n-\t\t ;; intentionally-mismatched modes\n-\t\t (match_operand:QI 2 \"reg_or_nibble_operand\" \"\")))]\n-  \"\"\n-  {\n-    if (GET_MODE (operands[2]) != VOIDmode)\n-      operands[2] = gen_rtx_ZERO_EXTEND (HImode, operands[2]);\n-  })\n-\n-(define_insn_and_split \"*umulqihi3_const\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t\t (match_operand:QI 2 \"nibble_operand\" \"IP4>X\")))]\n-  \"TARGET_H8300SX\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (mult:HI (zero_extend:HI (match_dup 1)) (match_dup 2)))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"*umulqihi3_const_clobber_flags\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t\t (match_operand:QI 2 \"nibble_operand\" \"IP4>X\")))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_H8300SX\"\n-  \"mulxu.b\t%X2,%T0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_zn\")])\n-\n-(define_insn_and_split \"*umulqihi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t\t (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (mult:HI (zero_extend:HI (match_dup 1))\n-\t\t\t    (zero_extend:HI (match_dup 2))))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"*umulqihi3_clobber_flags\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t\t (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))\n-   (clobber (reg:CC CC_REG))]\n-  \"\"\n-  \"mulxu.b\t%X2,%T0\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-(define_expand \"umulhisi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n-\t\t ;; intentionally-mismatched modes\n-\t\t (match_operand:HI 2 \"reg_or_nibble_operand\" \"\")))]\n-  \"\"\n-  {\n-    if (GET_MODE (operands[2]) != VOIDmode)\n-      operands[2] = gen_rtx_ZERO_EXTEND (SImode, operands[2]);\n-  })\n-\n-(define_insn_and_split \"*umulhisi3_const\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t\t (match_operand:SI 2 \"nibble_operand\" \"IP4>X\")))]\n-  \"TARGET_H8300SX\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (mult:SI (zero_extend:SI (match_dup 1)) (match_dup 2)))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"*umulhisi3_const_clobber_flags\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t\t (match_operand:SI 2 \"nibble_operand\" \"IP4>X\")))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_H8300SX\"\n-  \"mulxu.w\t%T2,%S0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_zn\")])\n-\n-(define_insn_and_split \"*umulhisi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (mult:SI (zero_extend:SI (match_dup 1))\n-\t\t\t    (zero_extend:SI (match_dup 2))))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"*umulhisi3_clobber_flags\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))\n-   (clobber (reg:CC CC_REG))]\n-  \"\"\n-  \"mulxu.w\t%T2,%S0\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-;; We could have used mulu.[wl] here, but mulu.[lw] is only available\n-;; on a H8SX with a multiplier, whereas muls.w seems to be available\n-;; on all H8SX variants.\n-\n-(define_insn_and_split \"mul<mode>3\"\n-  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n-        (mult:HSI (match_operand:HSI 1 \"register_operand\" \"%0\")\n-\t\t  (match_operand:HSI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))]\n-  \"TARGET_H8300SX\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0) (mult:HSI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"mul<mode>3_clobber_flags\"\n-  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n-        (mult:HSI (match_operand:HSI 1 \"register_operand\" \"%0\")\n-\t\t  (match_operand:HSI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_H8300SX\"\n-  { return <MODE>mode == HImode ? \"muls.w\\\\t%T2,%T0\" : \"muls.l\\\\t%S2,%S0\"; }\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_zn\")])\n-\n-(define_insn_and_split \"smulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(truncate:SI\n-\t (lshiftrt:DI\n-\t  (mult:DI\n-\t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t   (sign_extend:DI (match_operand:SI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))\n-\t  (const_int 32))))]\n-  \"TARGET_H8300SXMUL\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (truncate:SI (lshiftrt:DI (mult:DI\n-\t\t\t\t\t       (sign_extend:DI (match_dup 1))\n-\t\t\t\t\t       (sign_extend:DI (match_dup 2)))\n-\t\t\t\t\t     (const_int 32))))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"smulsi3_highpart_clobber_flags\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(truncate:SI\n-\t (lshiftrt:DI\n-\t  (mult:DI\n-\t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t   (sign_extend:DI (match_operand:SI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))\n-\t  (const_int 32))))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_H8300SXMUL\"\n-  \"muls/u.l\\\\t%S2,%S0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_zn\")])\n-\n-(define_insn_and_split \"umulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(truncate:SI\n-\t  (ashiftrt:DI\n-\t    (mult:DI\n-\t      (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t      (zero_extend:DI (match_operand:SI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))\n-\t    (const_int 32))))]\n-  \"TARGET_H8300SX\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (truncate:SI (ashiftrt:DI (mult:DI \n-\t\t\t\t\t       (zero_extend:DI (match_dup 1))\n-\t\t\t\t\t       (zero_extend:DI (match_dup 2)))\n-\t\t\t\t\t     (const_int 32))))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"umulsi3_highpart_clobber_flags\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(truncate:SI\n-\t  (ashiftrt:DI\n-\t    (mult:DI\n-\t      (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t      (zero_extend:DI (match_operand:SI 2 \"reg_or_nibble_operand\" \"r IP4>X\")))\n-\t    (const_int 32))))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_H8300SX\"\n-  \"mulu/u.l\\\\t%S2,%S0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-;; This is a \"bridge\" instruction.  Combine can't cram enough insns\n-;; together to crate a MAC instruction directly, but it can create\n-;; this instruction, which then allows combine to create the real\n-;; MAC insn.\n-;;\n-;; Unfortunately, if combine doesn't create a MAC instruction, this\n-;; insn must generate reasonably correct code.  Egad.\n-\n-(define_insn_and_split \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(mult:SI\n-\t  (sign_extend:SI\n-\t    (mem:HI (post_inc:SI (match_operand:SI 1 \"register_operand\" \"r\"))))\n-\t  (sign_extend:SI\n-\t    (mem:HI (post_inc:SI (match_operand:SI 2 \"register_operand\" \"r\"))))))]\n-  \"TARGET_MAC\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (mult:SI (sign_extend:SI\n-\t\t\t      (mem:HI (post_inc:SI (match_dup 1))))\n-\t\t\t    (sign_extend:SI\n-\t\t\t      (mem:HI (post_inc:SI (match_dup 2))))))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(mult:SI\n-\t  (sign_extend:SI\n-\t    (mem:HI (post_inc:SI (match_operand:SI 1 \"register_operand\" \"r\"))))\n-\t  (sign_extend:SI\n-\t    (mem:HI (post_inc:SI (match_operand:SI 2 \"register_operand\" \"r\"))))))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_MAC\"\n-  \"clrmac\\;mac\t@%2+,@%1+\"\n-  [(set_attr \"length\" \"6\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn_and_split \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(plus:SI (mult:SI\n-\t  (sign_extend:SI (mem:HI\n-\t    (post_inc:SI (match_operand:SI 1 \"register_operand\" \"r\"))))\n-\t  (sign_extend:SI (mem:HI\n-\t    (post_inc:SI (match_operand:SI 2 \"register_operand\" \"r\")))))\n-\t      (match_operand:SI 3 \"register_operand\" \"0\")))]\n-  \"TARGET_MAC\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (plus:SI\n-\t\t     (mult:SI\n-\t\t\t(sign_extend:SI (mem:HI (post_inc:SI (match_dup 1))))\n-\t\t\t(sign_extend:SI (mem:HI (post_inc:SI (match_dup 2)))))))\n-\t      (clobber (reg:CC CC_REG))])])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(plus:SI (mult:SI\n-\t  (sign_extend:SI (mem:HI\n-\t    (post_inc:SI (match_operand:SI 1 \"register_operand\" \"r\"))))\n-\t  (sign_extend:SI (mem:HI\n-\t    (post_inc:SI (match_operand:SI 2 \"register_operand\" \"r\")))))\n-\t      (match_operand:SI 3 \"register_operand\" \"0\")))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_MAC\"\n-  \"mac\t@%2+,@%1+\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-"}, {"sha": "e9f6ddcf075f32e8e0106b23a509084a047388e5", "filename": "gcc/config/h8300/testcompare.md", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ddb6eca28a2b58656c5d786a4462024ab74618f/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Ftestcompare.md?ref=5ddb6eca28a2b58656c5d786a4462024ab74618f", "patch": "@@ -24,8 +24,7 @@\n ;;\t\t\t\t  (const_int 0)))\n ;;\t      (clobber (scratch:QI))])]\n ;;  \"\"\n-;;  [(set_attr \"length\" \"2,8,10\")\n-;;   (set_attr \"cc\" \"set_zn,set_zn,set_zn\")])\n+;;  [(set_attr \"length\" \"2,8,10\")])\n ;;\n ;;(define_insn \"\"\n ;;  [(set (cc0)\n@@ -35,8 +34,7 @@\n ;;\t\t (const_int 0)))]\n ;;  \"INTVAL (operands[1]) <= 15\"\n ;;  \"btst\t%Z1,%Y0\"\n-;;  [(set_attr \"length\" \"2\")\n-;;   (set_attr \"cc\" \"set_zn\")])\n+;;  [(set_attr \"length\" \"2\")])\n ;;\n ;;(define_insn_and_split \"*tstsi_upper_bit\"\n ;;  [(set (cc0)\n@@ -71,8 +69,7 @@\n ;;\t\t (const_int 0)))]\n ;;  \"\"\n ;;  \"btst\t%w1,%w0\"\n-;;  [(set_attr \"length\" \"2\")\n-;;   (set_attr \"cc\" \"set_zn\")])\n+;;  [(set_attr \"length\" \"2\")])\n ;;\n ;;(define_insn_and_split \"*tstsi_variable_bit_qi\"\n ;;  [(set (cc0)\n@@ -99,8 +96,7 @@\n ;;\t\t\t    (const_int 0)))\n ;;\t      (clobber (scratch:QI))])]\n ;;  \"\"\n-;;  [(set_attr \"length\" \"2,8,10\")\n-;;   (set_attr \"cc\" \"set_zn,set_zn,set_zn\")])\n+;;  [(set_attr \"length\" \"2,8,10\")])\n \n (define_insn \"*tst<mode>\"\n   [(set (reg:CCZN CC_REG)\n@@ -116,8 +112,7 @@\n       return \"mov.l\t%S0,%S0\";\n     gcc_unreachable ();\n   }\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set_znv\")])\n+  [(set_attr \"length\" \"2\")])\n \n (define_insn \"*tsthi_upper\"\n   [(set (reg:CCZN CC_REG)\n@@ -135,8 +130,7 @@\n \t\t (const_int 0)))]\n   \"reload_completed\"\n   \"mov.w\t%e0,%e0\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set_znv\")])\n+  [(set_attr \"length\" \"2\")])\n \n (define_insn \"*cmpqi\"\n   [(set (reg:CC CC_REG)"}]}