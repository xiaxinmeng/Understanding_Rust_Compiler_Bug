{"sha": "4dba290c35d2d5023173c6a2d75741b1a4d549ab", "node_id": "C_kwDOANBUbNoAKDRkYmEyOTBjMzVkMmQ1MDIzMTczYzZhMmQ3NTc0MWIxYTRkNTQ5YWI", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-12-14T23:30:25Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-12-16T10:25:01Z"}, "message": "Add initial name-resolution for match-expr", "tree": {"sha": "b28ac925df0e28c95cd5a6ad84173935783f346d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b28ac925df0e28c95cd5a6ad84173935783f346d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dba290c35d2d5023173c6a2d75741b1a4d549ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dba290c35d2d5023173c6a2d75741b1a4d549ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dba290c35d2d5023173c6a2d75741b1a4d549ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dba290c35d2d5023173c6a2d75741b1a4d549ab/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3629645386ad503606f29f95c2e16d0600df6e20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3629645386ad503606f29f95c2e16d0600df6e20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3629645386ad503606f29f95c2e16d0600df6e20"}], "stats": {"total": 218, "additions": 209, "deletions": 9}, "files": [{"sha": "a4054285bbd27875e9f4b6a52143630c907804b4", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=4dba290c35d2d5023173c6a2d75741b1a4d549ab", "patch": "@@ -77,6 +77,7 @@ GRS_OBJS = \\\n     rust/rust-hir-map.o \\\n     rust/rust-ast-lower.o \\\n     rust/rust-ast-resolve.o \\\n+    rust/rust-ast-resolve-pattern.o \\\n     rust/rust-hir-type-check.o \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\"}, {"sha": "48dcc1067762e5b68ad7513367b4c16803bdd377", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=4dba290c35d2d5023173c6a2d75741b1a4d549ab", "patch": "@@ -4337,23 +4337,26 @@ struct MatchCase\n private:\n   MatchArm arm;\n   std::unique_ptr<Expr> expr;\n+  NodeId node_id;\n \n   /* TODO: does whether trailing comma exists need to be stored? currently\n    * assuming it is only syntactical and has no effect on meaning. */\n \n public:\n   MatchCase (MatchArm arm, std::unique_ptr<Expr> expr)\n-    : arm (std::move (arm)), expr (std::move (expr))\n+    : arm (std::move (arm)), expr (std::move (expr)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   MatchCase (const MatchCase &other)\n-    : arm (other.arm), expr (other.expr->clone_expr ())\n+    : arm (other.arm), expr (other.expr->clone_expr ()), node_id (other.node_id)\n   {}\n \n   MatchCase &operator= (const MatchCase &other)\n   {\n     arm = other.arm;\n     expr = other.expr->clone_expr ();\n+    node_id = other.node_id;\n \n     return *this;\n   }\n@@ -4378,6 +4381,8 @@ struct MatchCase\n     rust_assert (!arm.is_error ());\n     return arm;\n   }\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n #if 0"}, {"sha": "d46bf0e9fa47c6c0ad952199d259e1ba56391f93", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=4dba290c35d2d5023173c6a2d75741b1a4d549ab", "patch": "@@ -456,7 +456,17 @@ class StructPatternField\n   std::vector<Attribute> outer_attrs;\n   Location locus;\n \n+protected:\n+  NodeId node_id;\n+\n public:\n+  enum ItemType\n+  {\n+    TUPLE_PAT,\n+    IDENT_PAT,\n+    IDENT\n+  };\n+\n   virtual ~StructPatternField () {}\n \n   // Unique pointer custom clone function\n@@ -474,14 +484,18 @@ class StructPatternField\n \n   virtual void mark_for_strip () = 0;\n   virtual bool is_marked_for_strip () const = 0;\n+  virtual ItemType get_item_type () const = 0;\n+\n+  NodeId get_node_id () const { return node_id; }\n \n   // TODO: seems kinda dodgy. Think of better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n protected:\n-  StructPatternField (std::vector<Attribute> outer_attribs, Location locus)\n-    : outer_attrs (std::move (outer_attribs)), locus (locus)\n+  StructPatternField (std::vector<Attribute> outer_attribs, Location locus,\n+\t\t      NodeId node_id)\n+    : outer_attrs (std::move (outer_attribs)), locus (locus), node_id (node_id)\n   {}\n \n   // Clone function implementation as pure virtual method\n@@ -499,15 +513,17 @@ class StructPatternFieldTuplePat : public StructPatternField\n \t\t\t      std::unique_ptr<Pattern> tuple_pattern,\n \t\t\t      std::vector<Attribute> outer_attribs,\n \t\t\t      Location locus)\n-    : StructPatternField (std::move (outer_attribs), locus), index (index),\n-      tuple_pattern (std::move (tuple_pattern))\n+    : StructPatternField (std::move (outer_attribs), locus,\n+\t\t\t  Analysis::Mappings::get ()->get_next_node_id ()),\n+      index (index), tuple_pattern (std::move (tuple_pattern))\n   {}\n \n   // Copy constructor requires clone\n   StructPatternFieldTuplePat (StructPatternFieldTuplePat const &other)\n     : StructPatternField (other), index (other.index)\n   {\n     // guard to prevent null dereference (only required if error state)\n+    node_id = other.get_node_id ();\n     if (other.tuple_pattern != nullptr)\n       tuple_pattern = other.tuple_pattern->clone_pattern ();\n   }\n@@ -519,6 +535,7 @@ class StructPatternFieldTuplePat : public StructPatternField\n     StructPatternField::operator= (other);\n     index = other.index;\n     // outer_attrs = other.outer_attrs;\n+    node_id = other.get_node_id ();\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.tuple_pattern != nullptr)\n@@ -552,6 +569,8 @@ class StructPatternFieldTuplePat : public StructPatternField\n     return tuple_pattern;\n   }\n \n+  ItemType get_item_type () const override final { return ItemType::TUPLE_PAT; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -572,7 +591,8 @@ class StructPatternFieldIdentPat : public StructPatternField\n \t\t\t      std::unique_ptr<Pattern> ident_pattern,\n \t\t\t      std::vector<Attribute> outer_attrs,\n \t\t\t      Location locus)\n-    : StructPatternField (std::move (outer_attrs), locus),\n+    : StructPatternField (std::move (outer_attrs), locus,\n+\t\t\t  Analysis::Mappings::get ()->get_next_node_id ()),\n       ident (std::move (ident)), ident_pattern (std::move (ident_pattern))\n   {}\n \n@@ -581,6 +601,7 @@ class StructPatternFieldIdentPat : public StructPatternField\n     : StructPatternField (other), ident (other.ident)\n   {\n     // guard to prevent null dereference (only required if error state)\n+    node_id = other.get_node_id ();\n     if (other.ident_pattern != nullptr)\n       ident_pattern = other.ident_pattern->clone_pattern ();\n   }\n@@ -592,6 +613,7 @@ class StructPatternFieldIdentPat : public StructPatternField\n     StructPatternField::operator= (other);\n     ident = other.ident;\n     // outer_attrs = other.outer_attrs;\n+    node_id = other.get_node_id ();\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.ident_pattern != nullptr)\n@@ -618,13 +640,17 @@ class StructPatternFieldIdentPat : public StructPatternField\n     return ident_pattern == nullptr;\n   }\n \n+  const Identifier &get_identifier () const { return ident; }\n+\n   // TODO: is this better? Or is a \"vis_pattern\" better?\n   std::unique_ptr<Pattern> &get_ident_pattern ()\n   {\n     rust_assert (ident_pattern != nullptr);\n     return ident_pattern;\n   }\n \n+  ItemType get_item_type () const override final { return ItemType::IDENT_PAT; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -644,8 +670,9 @@ class StructPatternFieldIdent : public StructPatternField\n public:\n   StructPatternFieldIdent (Identifier ident, bool is_ref, bool is_mut,\n \t\t\t   std::vector<Attribute> outer_attrs, Location locus)\n-    : StructPatternField (std::move (outer_attrs), locus), has_ref (is_ref),\n-      has_mut (is_mut), ident (std::move (ident))\n+    : StructPatternField (std::move (outer_attrs), locus,\n+\t\t\t  Analysis::Mappings::get ()->get_next_node_id ()),\n+      has_ref (is_ref), has_mut (is_mut), ident (std::move (ident))\n   {}\n \n   std::string as_string () const override;\n@@ -656,6 +683,14 @@ class StructPatternFieldIdent : public StructPatternField\n   void mark_for_strip () override { ident = {}; }\n   bool is_marked_for_strip () const override { return ident.empty (); }\n \n+  const Identifier &get_identifier () const { return ident; }\n+\n+  ItemType get_item_type () const override final { return ItemType::IDENT; }\n+\n+  bool is_ref () const { return has_ref; }\n+\n+  bool is_mut () const { return has_mut; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -827,6 +862,12 @@ class StructPattern : public Pattern\n class TupleStructItems\n {\n public:\n+  enum ItemType\n+  {\n+    RANGE,\n+    NO_RANGE\n+  };\n+\n   virtual ~TupleStructItems () {}\n \n   // TODO: should this store location data?\n@@ -841,6 +882,8 @@ class TupleStructItems\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  virtual ItemType get_item_type () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual TupleStructItems *clone_tuple_struct_items_impl () const = 0;\n@@ -890,6 +933,8 @@ class TupleStructItemsNoRange : public TupleStructItems\n     return patterns;\n   }\n \n+  ItemType get_item_type () const override final { return ItemType::NO_RANGE; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -966,6 +1011,8 @@ class TupleStructItemsRange : public TupleStructItems\n     return upper_patterns;\n   }\n \n+  ItemType get_item_type () const override final { return ItemType::RANGE; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "5f496a664de8e9630750761df12a1738c83ccf5e", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=4dba290c35d2d5023173c6a2d75741b1a4d549ab", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-ast-resolve-struct-expr-field.h\"\n #include \"rust-ast-verify-assignee.h\"\n #include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-pattern.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -409,6 +410,41 @@ class ResolveExpr : public ResolverBase\n     ResolveExpr::go (expr.get_dereferenced_expr ().get (), expr.get_node_id ());\n   }\n \n+  void visit (AST::MatchExpr &expr) override\n+  {\n+    ResolveExpr::go (expr.get_scrutinee_expr ().get (), expr.get_node_id ());\n+    for (auto &match_case : expr.get_match_cases ())\n+      {\n+\t// each arm is in its own scope\n+\tNodeId scope_node_id = match_case.get_node_id ();\n+\tresolver->get_name_scope ().push (scope_node_id);\n+\tresolver->get_type_scope ().push (scope_node_id);\n+\tresolver->get_label_scope ().push (scope_node_id);\n+\tresolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+\tresolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\tresolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+\t// resolve\n+\tAST::MatchArm &arm = match_case.get_arm ();\n+\tif (arm.has_match_arm_guard ())\n+\t  ResolveExpr::go (arm.get_guard_expr ().get (), expr.get_node_id ());\n+\n+\t// insert any possible new patterns\n+\tfor (auto &pattern : arm.get_patterns ())\n+\t  {\n+\t    PatternDeclaration::go (pattern.get (), expr.get_node_id ());\n+\t  }\n+\n+\t// resolve the body\n+\tResolveExpr::go (match_case.get_expr ().get (), expr.get_node_id ());\n+\n+\t// done\n+\tresolver->get_name_scope ().pop ();\n+\tresolver->get_type_scope ().pop ();\n+\tresolver->get_label_scope ().pop ();\n+      }\n+  }\n+\n private:\n   ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "c97a83f843ea43f57d1c5fe1b37513e3ad9e2899", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=4dba290c35d2d5023173c6a2d75741b1a4d549ab", "patch": "@@ -0,0 +1,104 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+PatternDeclaration::visit (AST::PathInExpression &pattern)\n+{\n+  ResolveExpr::go (&pattern, parent);\n+}\n+\n+void\n+PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n+{\n+  ResolveExpr::go (&pattern.get_path (), parent);\n+\n+  std::unique_ptr<AST::TupleStructItems> &items = pattern.get_items ();\n+  switch (items->get_item_type ())\n+    {\n+      case AST::TupleStructItems::RANGE: {\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+\n+      case AST::TupleStructItems::NO_RANGE: {\n+\tAST::TupleStructItemsNoRange &items_no_range\n+\t  = static_cast<AST::TupleStructItemsNoRange &> (*items.get ());\n+\n+\tfor (auto &inner_pattern : items_no_range.get_patterns ())\n+\t  {\n+\t    PatternDeclaration::go (inner_pattern.get (),\n+\t\t\t\t    pattern.get_node_id ());\n+\t  }\n+      }\n+      break;\n+    }\n+}\n+\n+void\n+PatternDeclaration::visit (AST::StructPattern &pattern)\n+{\n+  ResolveExpr::go (&pattern.get_path (), parent);\n+\n+  auto &struct_pattern_elems = pattern.get_struct_pattern_elems ();\n+  for (auto &field : struct_pattern_elems.get_struct_pattern_fields ())\n+    {\n+      switch (field->get_item_type ())\n+\t{\n+\t  case AST::StructPatternField::ItemType::TUPLE_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT: {\n+\t    AST::StructPatternFieldIdent &ident\n+\t      = static_cast<AST::StructPatternFieldIdent &> (*field.get ());\n+\n+\t    resolver->get_name_scope ().insert (\n+\t      CanonicalPath::new_seg (ident.get_node_id (),\n+\t\t\t\t      ident.get_identifier ()),\n+\t      ident.get_node_id (), pattern.get_locus ());\n+\t    resolver->insert_new_definition (\n+\t      ident.get_node_id (),\n+\t      Definition{ident.get_node_id (), pattern.get_node_id ()});\n+\t    resolver->mark_decl_mutability (ident.get_node_id (),\n+\t\t\t\t\t    ident.is_mut ());\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n+  // TODO\n+  rust_assert (!struct_pattern_elems.has_etc ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "57c73ba345634c212014d968051efbab346607d4", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dba290c35d2d5023173c6a2d75741b1a4d549ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=4dba290c35d2d5023173c6a2d75741b1a4d549ab", "patch": "@@ -83,6 +83,13 @@ class PatternDeclaration : public ResolverBase\n \t\t\t\t    pattern.get_is_mut ());\n   }\n \n+  // cases in a match expression\n+  void visit (AST::PathInExpression &pattern) override;\n+\n+  void visit (AST::StructPattern &pattern) override;\n+\n+  void visit (AST::TupleStructPattern &pattern) override;\n+\n private:\n   PatternDeclaration (NodeId parent) : ResolverBase (parent) {}\n };"}]}