{"sha": "2465dcc257488294138948de82a734c31b504ecf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ2NWRjYzI1NzQ4ODI5NDEzODk0OGRlODJhNzM0YzMxYjUwNGVjZg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-06-14T18:54:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-06-14T18:54:17Z"}, "message": "lto-streamer.c (cached_bp): Remove.\n\n2010-06-14  Richard Guenther  <rguenther@suse.de>\n\n\t* lto-streamer.c (cached_bp): Remove.\n\t(bitpack_delete): Likewise.\n\t(bitpack_create): Likewise.\n\t(bp_get_next_word): Likewise.\n\t(bp_pack_value, bp_unpack_value): Move ...\n\t* lto-streamer.h (bp_pack_value, bp_unpack_value): ... here.\n\tRe-implement.\n\t(struct bitpack_d): Likewise.\n\t(bitpack_create, lto_output_bitpack, lto_input_bitpack):\n\tNew inline functions.\n\t* lto-streamer-out.c (lto_output_bitpack): Remove.\n\t(pack_ts_base_value_fields): Adjust.  Avoid conditional\n\tbitpacking.\n\t(pack_value_fields): Adjust.\n\t(lto_write_tree): Likewise.\n\t(output_gimple_stmt): Likewise.\n\t(output_function): Likewise.\n\t* lto-streamer-in.c (input_gimple_stmt): Adjust.\n\t(input_function): Likewise.\n\t(unpack_ts_base_value_fields): Adjust.  Avoid conditional\n\tbitpacking.\n\t(lto_input_bitpack): Remove.\n\t(lto_materialize_tree): Adjust.\n\t* Makefile.in (ipa-prop.o): Add $(LTO_STREAMER_H) dependency.\n\t* lto-cgraph.c (lto_output_edge): Adjust.\n\t(lto_output_node): Likewise.\n\t(lto_output_varpool_node): Likewise.\n\t(lto_output_ref): Likewise.\n\t(input_node): Likewise.\n\t(input_varpool_node): Likewise.\n\t(input_ref): Likewise.\n\t(input_edge): Likewise.\n\t(output_node_opt_summary): Likewise.\n\t(input_node_opt_summary): Likewise.\n\t* ipa-pure-const.c (pure_const_write_summary): Likewise.\n\t(pure_const_read_summary): Likewise.\n\t* ipa-prop.c (ipa_write_indirect_edge_info): Likewise.\n\t(ipa_read_indirect_edge_info): Likewise.\n\t(ipa_write_node_info): Likewise.\n\t(ipa_read_node_info): Likewise.\n\nFrom-SVN: r160760", "tree": {"sha": "1c5576f53e0b1246f2c6689424de8733223cce84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c5576f53e0b1246f2c6689424de8733223cce84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2465dcc257488294138948de82a734c31b504ecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2465dcc257488294138948de82a734c31b504ecf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2465dcc257488294138948de82a734c31b504ecf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2465dcc257488294138948de82a734c31b504ecf/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "808081b47f28975725f1a648cb92632a7a399be5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/808081b47f28975725f1a648cb92632a7a399be5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/808081b47f28975725f1a648cb92632a7a399be5"}], "stats": {"total": 734, "additions": 328, "deletions": 406}, "files": [{"sha": "c4f9c04cb264bd000146f67d452b8cb562aaf898", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2465dcc257488294138948de82a734c31b504ecf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2465dcc257488294138948de82a734c31b504ecf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2465dcc257488294138948de82a734c31b504ecf", "patch": "@@ -1,3 +1,46 @@\n+2010-06-14  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-streamer.c (cached_bp): Remove.\n+\t(bitpack_delete): Likewise.\n+\t(bitpack_create): Likewise.\n+\t(bp_get_next_word): Likewise.\n+\t(bp_pack_value, bp_unpack_value): Move ...\n+\t* lto-streamer.h (bp_pack_value, bp_unpack_value): ... here.\n+\tRe-implement.\n+\t(struct bitpack_d): Likewise.\n+\t(bitpack_create, lto_output_bitpack, lto_input_bitpack):\n+\tNew inline functions.\n+\t* lto-streamer-out.c (lto_output_bitpack): Remove.\n+\t(pack_ts_base_value_fields): Adjust.  Avoid conditional\n+\tbitpacking.\n+\t(pack_value_fields): Adjust.\n+\t(lto_write_tree): Likewise.\n+\t(output_gimple_stmt): Likewise.\n+\t(output_function): Likewise.\n+\t* lto-streamer-in.c (input_gimple_stmt): Adjust.\n+\t(input_function): Likewise.\n+\t(unpack_ts_base_value_fields): Adjust.  Avoid conditional\n+\tbitpacking.\n+\t(lto_input_bitpack): Remove.\n+\t(lto_materialize_tree): Adjust.\n+\t* Makefile.in (ipa-prop.o): Add $(LTO_STREAMER_H) dependency.\n+\t* lto-cgraph.c (lto_output_edge): Adjust.\n+\t(lto_output_node): Likewise.\n+\t(lto_output_varpool_node): Likewise.\n+\t(lto_output_ref): Likewise.\n+\t(input_node): Likewise.\n+\t(input_varpool_node): Likewise.\n+\t(input_ref): Likewise.\n+\t(input_edge): Likewise.\n+\t(output_node_opt_summary): Likewise.\n+\t(input_node_opt_summary): Likewise.\n+\t* ipa-pure-const.c (pure_const_write_summary): Likewise.\n+\t(pure_const_read_summary): Likewise.\n+\t* ipa-prop.c (ipa_write_indirect_edge_info): Likewise.\n+\t(ipa_read_indirect_edge_info): Likewise.\n+\t(ipa_write_node_info): Likewise.\n+\t(ipa_read_node_info): Likewise.\n+\n 2010-06-14  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/44534"}, {"sha": "98ed23db7d006878424aac19996ea20f7c06680b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2465dcc257488294138948de82a734c31b504ecf/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2465dcc257488294138948de82a734c31b504ecf/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2465dcc257488294138948de82a734c31b504ecf", "patch": "@@ -2995,7 +2995,7 @@ ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) \\\n    $(TREE_INLINE_H) $(GIMPLE_H) $(GIMPLE_FOLD_H) $(TIMEVAR_H) \\\n-   tree-pretty-print.h gimple-pretty-print.h\n+   tree-pretty-print.h gimple-pretty-print.h $(LTO_STREAMER_H)\n ipa-ref.o : ipa-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H)  $(TREE_H) $(TARGET_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) $(GGC_H) "}, {"sha": "38eb3c08388ed94ae7d8d9516bed15545eac81ef", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2465dcc257488294138948de82a734c31b504ecf/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2465dcc257488294138948de82a734c31b504ecf/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=2465dcc257488294138948de82a734c31b504ecf", "patch": "@@ -2403,14 +2403,13 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n \t\t\t      struct cgraph_edge *cs)\n {\n   struct cgraph_indirect_call_info *ii = cs->indirect_info;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n \n   lto_output_sleb128_stream (ob->main_stream, ii->param_index);\n   lto_output_sleb128_stream (ob->main_stream, ii->anc_offset);\n-  bp = bitpack_create ();\n-  bp_pack_value (bp, ii->polymorphic, 1);\n-  lto_output_bitpack (ob->main_stream, bp);\n-  bitpack_delete (bp);\n+  bp = bitpack_create (ob->main_stream);\n+  bp_pack_value (&bp, ii->polymorphic, 1);\n+  lto_output_bitpack (&bp);\n \n   if (ii->polymorphic)\n     {\n@@ -2428,13 +2427,12 @@ ipa_read_indirect_edge_info (struct lto_input_block *ib,\n \t\t\t     struct cgraph_edge *cs)\n {\n   struct cgraph_indirect_call_info *ii = cs->indirect_info;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n \n   ii->param_index = (int) lto_input_sleb128 (ib);\n   ii->anc_offset = (HOST_WIDE_INT) lto_input_sleb128 (ib);\n   bp = lto_input_bitpack (ib);\n-  ii->polymorphic = bp_unpack_value (bp, 1);\n-  bitpack_delete (bp);\n+  ii->polymorphic = bp_unpack_value (&bp, 1);\n   if (ii->polymorphic)\n     {\n       ii->otr_token = (HOST_WIDE_INT) lto_input_sleb128 (ib);\n@@ -2452,26 +2450,25 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int j;\n   struct cgraph_edge *e;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n \n   encoder = ob->decl_state->cgraph_node_encoder;\n   node_ref = lto_cgraph_encoder_encode (encoder, node);\n   lto_output_uleb128_stream (ob->main_stream, node_ref);\n \n-  bp = bitpack_create ();\n-  bp_pack_value (bp, info->called_with_var_arguments, 1);\n-  bp_pack_value (bp, info->uses_analysis_done, 1);\n+  bp = bitpack_create (ob->main_stream);\n+  bp_pack_value (&bp, info->called_with_var_arguments, 1);\n+  bp_pack_value (&bp, info->uses_analysis_done, 1);\n   gcc_assert (info->modification_analysis_done\n \t      || ipa_get_param_count (info) == 0);\n   gcc_assert (!info->node_enqueued);\n   gcc_assert (!info->ipcp_orig_node);\n   for (j = 0; j < ipa_get_param_count (info); j++)\n     {\n-      bp_pack_value (bp, info->params[j].modified, 1);\n-      bp_pack_value (bp, info->params[j].used, 1);\n+      bp_pack_value (&bp, info->params[j].modified, 1);\n+      bp_pack_value (&bp, info->params[j].used, 1);\n     }\n-  lto_output_bitpack (ob->main_stream, bp);\n-  bitpack_delete (bp);\n+  lto_output_bitpack (&bp);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n@@ -2494,13 +2491,13 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int k;\n   struct cgraph_edge *e;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n \n   ipa_initialize_node_params (node);\n \n   bp = lto_input_bitpack (ib);\n-  info->called_with_var_arguments = bp_unpack_value (bp, 1);\n-  info->uses_analysis_done = bp_unpack_value (bp, 1);\n+  info->called_with_var_arguments = bp_unpack_value (&bp, 1);\n+  info->uses_analysis_done = bp_unpack_value (&bp, 1);\n   if (ipa_get_param_count (info) != 0)\n     {\n       info->modification_analysis_done = true;\n@@ -2509,10 +2506,9 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n   info->node_enqueued = false;\n   for (k = 0; k < ipa_get_param_count (info); k++)\n     {\n-      info->params[k].modified = bp_unpack_value (bp, 1);\n-      info->params[k].used = bp_unpack_value (bp, 1);\n+      info->params[k].modified = bp_unpack_value (&bp, 1);\n+      info->params[k].used = bp_unpack_value (&bp, 1);\n     }\n-  bitpack_delete (bp);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);"}, {"sha": "bc17b0c81bb0016c1d28dcd82eefa0902c599ba2", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2465dcc257488294138948de82a734c31b504ecf/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2465dcc257488294138948de82a734c31b504ecf/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=2465dcc257488294138948de82a734c31b504ecf", "patch": "@@ -943,7 +943,7 @@ pure_const_write_summary (cgraph_node_set set,\n       node = csi_node (csi);\n       if (node->analyzed && has_function_state (node))\n \t{\n-\t  struct bitpack_d *bp;\n+\t  struct bitpack_d bp;\n \t  funct_state fs;\n \t  int node_ref;\n \t  lto_cgraph_encoder_t encoder;\n@@ -956,14 +956,13 @@ pure_const_write_summary (cgraph_node_set set,\n \n \t  /* Note that flags will need to be read in the opposite\n \t     order as we are pushing the bitflags into FLAGS.  */\n-\t  bp = bitpack_create ();\n-\t  bp_pack_value (bp, fs->pure_const_state, 2);\n-\t  bp_pack_value (bp, fs->state_previously_known, 2);\n-\t  bp_pack_value (bp, fs->looping_previously_known, 1);\n-\t  bp_pack_value (bp, fs->looping, 1);\n-\t  bp_pack_value (bp, fs->can_throw, 1);\n-\t  lto_output_bitpack (ob->main_stream, bp);\n-\t  bitpack_delete (bp);\n+\t  bp = bitpack_create (ob->main_stream);\n+\t  bp_pack_value (&bp, fs->pure_const_state, 2);\n+\t  bp_pack_value (&bp, fs->state_previously_known, 2);\n+\t  bp_pack_value (&bp, fs->looping_previously_known, 1);\n+\t  bp_pack_value (&bp, fs->looping, 1);\n+\t  bp_pack_value (&bp, fs->can_throw, 1);\n+\t  lto_output_bitpack (&bp);\n \t}\n     }\n \n@@ -998,7 +997,7 @@ pure_const_read_summary (void)\n \t    {\n \t      unsigned int index;\n \t      struct cgraph_node *node;\n-\t      struct bitpack_d *bp;\n+\t      struct bitpack_d bp;\n \t      funct_state fs;\n \t      lto_cgraph_encoder_t encoder;\n \n@@ -1013,12 +1012,12 @@ pure_const_read_summary (void)\n \t\t pushed into FLAGS).  */\n \t      bp = lto_input_bitpack (ib);\n \t      fs->pure_const_state\n-\t\t\t= (enum pure_const_state_e) bp_unpack_value (bp, 2);\n+\t\t\t= (enum pure_const_state_e) bp_unpack_value (&bp, 2);\n \t      fs->state_previously_known\n-\t\t\t= (enum pure_const_state_e) bp_unpack_value (bp, 2);\n-\t      fs->looping_previously_known = bp_unpack_value (bp, 1);\n-\t      fs->looping = bp_unpack_value (bp, 1);\n-\t      fs->can_throw = bp_unpack_value (bp, 1);\n+\t\t\t= (enum pure_const_state_e) bp_unpack_value (&bp, 2);\n+\t      fs->looping_previously_known = bp_unpack_value (&bp, 1);\n+\t      fs->looping = bp_unpack_value (&bp, 1);\n+\t      fs->can_throw = bp_unpack_value (&bp, 1);\n \t      if (dump_file)\n \t\t{\n \t\t  int flags = flags_from_decl_or_type (node->decl);\n@@ -1042,7 +1041,6 @@ pure_const_read_summary (void)\n \t\t  if (fs->can_throw)\n \t\t    fprintf (dump_file,\"  function is locally throwing\\n\");\n \t\t}\n-\t      bitpack_delete (bp);\n \t    }\n \n \t  lto_destroy_simple_input_block (file_data,"}, {"sha": "9722a80784224bd936b95835f784e45c85949484", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 94, "deletions": 103, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2465dcc257488294138948de82a734c31b504ecf/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2465dcc257488294138948de82a734c31b504ecf/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=2465dcc257488294138948de82a734c31b504ecf", "patch": "@@ -260,7 +260,7 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n {\n   unsigned int uid;\n   intptr_t ref;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n \n   if (edge->indirect_unknown_callee)\n     lto_output_uleb128_stream (ob->main_stream, LTO_cgraph_indirect_edge);\n@@ -280,32 +280,31 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n \n   lto_output_sleb128_stream (ob->main_stream, edge->count);\n \n-  bp = bitpack_create ();\n+  bp = bitpack_create (ob->main_stream);\n   uid = flag_wpa ? edge->lto_stmt_uid : gimple_uid (edge->call_stmt);\n-  bp_pack_value (bp, uid, HOST_BITS_PER_INT);\n-  bp_pack_value (bp, edge->inline_failed, HOST_BITS_PER_INT);\n-  bp_pack_value (bp, edge->frequency, HOST_BITS_PER_INT);\n-  bp_pack_value (bp, edge->loop_nest, 30);\n-  bp_pack_value (bp, edge->indirect_inlining_edge, 1);\n-  bp_pack_value (bp, edge->call_stmt_cannot_inline_p, 1);\n-  bp_pack_value (bp, edge->can_throw_external, 1);\n+  bp_pack_value (&bp, uid, HOST_BITS_PER_INT);\n+  bp_pack_value (&bp, edge->inline_failed, HOST_BITS_PER_INT);\n+  bp_pack_value (&bp, edge->frequency, HOST_BITS_PER_INT);\n+  bp_pack_value (&bp, edge->loop_nest, 30);\n+  bp_pack_value (&bp, edge->indirect_inlining_edge, 1);\n+  bp_pack_value (&bp, edge->call_stmt_cannot_inline_p, 1);\n+  bp_pack_value (&bp, edge->can_throw_external, 1);\n   if (edge->indirect_unknown_callee)\n     {\n       int flags = edge->indirect_info->ecf_flags;\n-      bp_pack_value (bp, (flags & ECF_CONST) != 0, 1);\n-      bp_pack_value (bp, (flags & ECF_PURE) != 0, 1);\n-      bp_pack_value (bp, (flags & ECF_NORETURN) != 0, 1);\n-      bp_pack_value (bp, (flags & ECF_MALLOC) != 0, 1);\n-      bp_pack_value (bp, (flags & ECF_NOTHROW) != 0, 1);\n-      bp_pack_value (bp, (flags & ECF_RETURNS_TWICE) != 0, 1);\n+      bp_pack_value (&bp, (flags & ECF_CONST) != 0, 1);\n+      bp_pack_value (&bp, (flags & ECF_PURE) != 0, 1);\n+      bp_pack_value (&bp, (flags & ECF_NORETURN) != 0, 1);\n+      bp_pack_value (&bp, (flags & ECF_MALLOC) != 0, 1);\n+      bp_pack_value (&bp, (flags & ECF_NOTHROW) != 0, 1);\n+      bp_pack_value (&bp, (flags & ECF_RETURNS_TWICE) != 0, 1);\n       /* Flags that should not appear on indirect calls.  */\n       gcc_assert (!(flags & (ECF_LOOPING_CONST_OR_PURE\n \t\t\t     | ECF_MAY_BE_ALLOCA\n \t\t\t     | ECF_SIBCALL\n \t\t\t     | ECF_NOVOPS)));\n     }\n-  lto_output_bitpack (ob->main_stream, bp);\n-  bitpack_delete (bp);\n+  lto_output_bitpack (&bp);\n }\n \n /* Return if LIST contain references from other partitions.  */\n@@ -404,7 +403,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t\t varpool_node_set vset)\n {\n   unsigned int tag;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n   bool boundary_p;\n   intptr_t ref;\n   bool in_other_partition = false;\n@@ -458,30 +457,6 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   lto_output_fn_decl_index (ob->decl_state, ob->main_stream, node->decl);\n   lto_output_sleb128_stream (ob->main_stream, node->count);\n \n-  bp = bitpack_create ();\n-  bp_pack_value (bp, node->local.local, 1);\n-  bp_pack_value (bp, node->local.externally_visible, 1);\n-  bp_pack_value (bp, node->local.finalized, 1);\n-  bp_pack_value (bp, node->local.inlinable, 1);\n-  bp_pack_value (bp, node->local.versionable, 1);\n-  bp_pack_value (bp, node->local.disregard_inline_limits, 1);\n-  bp_pack_value (bp, node->local.redefined_extern_inline, 1);\n-  bp_pack_value (bp, node->local.vtable_method, 1);\n-  bp_pack_value (bp, node->needed, 1);\n-  bp_pack_value (bp, node->address_taken, 1);\n-  bp_pack_value (bp, node->abstract_and_needed, 1);\n-  bp_pack_value (bp, tag == LTO_cgraph_analyzed_node\n-\t\t && !DECL_EXTERNAL (node->decl)\n-\t\t && (reachable_from_other_partition_p (node, set)\n-\t\t     || referenced_from_other_partition_p (&node->ref_list, set, vset)), 1);\n-  bp_pack_value (bp, node->lowered, 1);\n-  bp_pack_value (bp, in_other_partition, 1);\n-  bp_pack_value (bp, node->alias, 1);\n-  bp_pack_value (bp, node->finalized_by_frontend, 1);\n-  bp_pack_value (bp, node->frequency, 2);\n-  lto_output_bitpack (ob->main_stream, bp);\n-  bitpack_delete (bp);\n-\n   if (tag == LTO_cgraph_analyzed_node)\n     {\n       lto_output_sleb128_stream (ob->main_stream,\n@@ -514,6 +489,29 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n     ref = LCC_NOT_FOUND;\n   lto_output_sleb128_stream (ob->main_stream, ref);\n \n+  bp = bitpack_create (ob->main_stream);\n+  bp_pack_value (&bp, node->local.local, 1);\n+  bp_pack_value (&bp, node->local.externally_visible, 1);\n+  bp_pack_value (&bp, node->local.finalized, 1);\n+  bp_pack_value (&bp, node->local.inlinable, 1);\n+  bp_pack_value (&bp, node->local.versionable, 1);\n+  bp_pack_value (&bp, node->local.disregard_inline_limits, 1);\n+  bp_pack_value (&bp, node->local.redefined_extern_inline, 1);\n+  bp_pack_value (&bp, node->local.vtable_method, 1);\n+  bp_pack_value (&bp, node->needed, 1);\n+  bp_pack_value (&bp, node->address_taken, 1);\n+  bp_pack_value (&bp, node->abstract_and_needed, 1);\n+  bp_pack_value (&bp, tag == LTO_cgraph_analyzed_node\n+\t\t && !DECL_EXTERNAL (node->decl)\n+\t\t && (reachable_from_other_partition_p (node, set)\n+\t\t     || referenced_from_other_partition_p (&node->ref_list, set, vset)), 1);\n+  bp_pack_value (&bp, node->lowered, 1);\n+  bp_pack_value (&bp, in_other_partition, 1);\n+  bp_pack_value (&bp, node->alias, 1);\n+  bp_pack_value (&bp, node->finalized_by_frontend, 1);\n+  bp_pack_value (&bp, node->frequency, 2);\n+  lto_output_bitpack (&bp);\n+\n   if (node->same_body)\n     {\n       struct cgraph_node *alias;\n@@ -561,17 +559,17 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n \t\t         cgraph_node_set set, varpool_node_set vset)\n {\n   bool boundary_p = !varpool_node_in_set_p (node, vset) && node->analyzed;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n   struct varpool_node *alias;\n   int count = 0;\n   int ref;\n \n   lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->decl);\n-  bp = bitpack_create ();\n-  bp_pack_value (bp, node->externally_visible, 1);\n-  bp_pack_value (bp, node->force_output, 1);\n-  bp_pack_value (bp, node->finalized, 1);\n-  bp_pack_value (bp, node->alias, 1);\n+  bp = bitpack_create (ob->main_stream);\n+  bp_pack_value (&bp, node->externally_visible, 1);\n+  bp_pack_value (&bp, node->force_output, 1);\n+  bp_pack_value (&bp, node->finalized, 1);\n+  bp_pack_value (&bp, node->alias, 1);\n   gcc_assert (!node->alias || !node->extra_name);\n   gcc_assert (node->finalized || !node->analyzed);\n   gcc_assert (node->needed);\n@@ -580,22 +578,21 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n      labels and share them across LTRANS partitions.  */\n   if (DECL_IN_CONSTANT_POOL (node->decl))\n     {\n-      bp_pack_value (bp, 0, 1);  /* used_from_other_parition.  */\n-      bp_pack_value (bp, 0, 1);  /* in_other_partition.  */\n+      bp_pack_value (&bp, 0, 1);  /* used_from_other_parition.  */\n+      bp_pack_value (&bp, 0, 1);  /* in_other_partition.  */\n     }\n   else\n     {\n-      bp_pack_value (bp, node->analyzed\n+      bp_pack_value (&bp, node->analyzed\n \t\t     && referenced_from_other_partition_p (&node->ref_list,\n \t\t\t\t\t\t\t   set, vset), 1);\n-      bp_pack_value (bp, boundary_p, 1);  /* in_other_partition.  */\n+      bp_pack_value (&bp, boundary_p, 1);  /* in_other_partition.  */\n     }\n   /* Also emit any extra name aliases.  */\n   for (alias = node->extra_name; alias; alias = alias->next)\n     count++;\n-  bp_pack_value (bp, count != 0, 1);\n-  lto_output_bitpack (ob->main_stream, bp);\n-  bitpack_delete (bp);\n+  bp_pack_value (&bp, count != 0, 1);\n+  lto_output_bitpack (&bp);\n   if (node->same_comdat_group && !boundary_p)\n     {\n       ref = lto_varpool_encoder_lookup (varpool_encoder, node->same_comdat_group);\n@@ -621,11 +618,11 @@ lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n \t\tlto_cgraph_encoder_t encoder,\n \t\tlto_varpool_encoder_t varpool_encoder)\n {\n-  struct bitpack_d *bp = bitpack_create ();\n-  bp_pack_value (bp, ref->refered_type, 1);\n-  bp_pack_value (bp, ref->use, 2);\n-  lto_output_bitpack (ob->main_stream, bp);\n-  bitpack_delete (bp);\n+  struct bitpack_d bp;\n+  bp = bitpack_create (ob->main_stream);\n+  bp_pack_value (&bp, ref->refered_type, 1);\n+  bp_pack_value (&bp, ref->use, 2);\n+  lto_output_bitpack (&bp);\n   if (ref->refered_type == IPA_REF_CGRAPH)\n     {\n       int nref = lto_cgraph_encoder_lookup (encoder, ipa_ref_node (ref));\n@@ -981,7 +978,7 @@ input_node (struct lto_file_decl_data *file_data,\n {\n   tree fn_decl;\n   struct cgraph_node *node;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n   int stack_size = 0;\n   unsigned decl_index;\n   int ref = LCC_NOT_FOUND, ref2 = LCC_NOT_FOUND;\n@@ -1006,7 +1003,6 @@ input_node (struct lto_file_decl_data *file_data,\n     node = cgraph_node (fn_decl);\n \n   node->count = lto_input_sleb128 (ib);\n-  bp = lto_input_bitpack (ib);\n \n   if (tag == LTO_cgraph_analyzed_node)\n     {\n@@ -1020,7 +1016,6 @@ input_node (struct lto_file_decl_data *file_data,\n     }\n \n   ref2 = lto_input_sleb128 (ib);\n-  same_body_count = lto_input_uleb128 (ib);\n \n   /* Make sure that we have not read this node before.  Nodes that\n      have already been read will have their tag stored in the 'aux'\n@@ -1030,17 +1025,18 @@ input_node (struct lto_file_decl_data *file_data,\n     internal_error (\"bytecode stream: found multiple instances of cgraph \"\n \t\t    \"node %d\", node->uid);\n \n-  input_overwrite_node (file_data, node, tag, bp, stack_size, self_time,\n+  bp = lto_input_bitpack (ib);\n+  input_overwrite_node (file_data, node, tag, &bp, stack_size, self_time,\n   \t\t\ttime_inlining_benefit, self_size,\n \t\t\tsize_inlining_benefit);\n-  bitpack_delete (bp);\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->global.inlined_to = (cgraph_node_ptr) (intptr_t) ref;\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->same_comdat_group = (cgraph_node_ptr) (intptr_t) ref2;\n \n+  same_body_count = lto_input_uleb128 (ib);\n   while (same_body_count-- > 0)\n     {\n       tree alias_decl;\n@@ -1081,7 +1077,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   int decl_index;\n   tree var_decl;\n   struct varpool_node *node;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n   bool aliases_p;\n   int count;\n   int ref = LCC_NOT_FOUND;\n@@ -1092,17 +1088,16 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->lto_file_data = file_data;\n \n   bp = lto_input_bitpack (ib);\n-  node->externally_visible = bp_unpack_value (bp, 1);\n-  node->force_output = bp_unpack_value (bp, 1);\n-  node->finalized = bp_unpack_value (bp, 1);\n-  node->alias = bp_unpack_value (bp, 1);\n+  node->externally_visible = bp_unpack_value (&bp, 1);\n+  node->force_output = bp_unpack_value (&bp, 1);\n+  node->finalized = bp_unpack_value (&bp, 1);\n+  node->alias = bp_unpack_value (&bp, 1);\n   node->analyzed = node->finalized; \n-  node->used_from_other_partition = bp_unpack_value (bp, 1);\n-  node->in_other_partition = bp_unpack_value (bp, 1);\n-  aliases_p = bp_unpack_value (bp, 1);\n+  node->used_from_other_partition = bp_unpack_value (&bp, 1);\n+  node->in_other_partition = bp_unpack_value (&bp, 1);\n+  aliases_p = bp_unpack_value (&bp, 1);\n   if (node->finalized)\n     varpool_mark_needed_node (node);\n-  bitpack_delete (bp);\n   ref = lto_input_sleb128 (ib);\n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->same_comdat_group = (struct varpool_node *) (intptr_t) ref;\n@@ -1131,14 +1126,13 @@ input_ref (struct lto_input_block *ib,\n {\n   struct cgraph_node *node = NULL;\n   struct varpool_node *varpool_node = NULL;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n   enum ipa_ref_type type;\n   enum ipa_ref_use use;\n \n   bp = lto_input_bitpack (ib);\n-  type = (enum ipa_ref_type) bp_unpack_value (bp, 1);\n-  use = (enum ipa_ref_use) bp_unpack_value (bp, 2);\n-  bitpack_delete (bp);\n+  type = (enum ipa_ref_type) bp_unpack_value (&bp, 1);\n+  use = (enum ipa_ref_use) bp_unpack_value (&bp, 2);\n   if (type == IPA_REF_CGRAPH)\n     node = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n   else\n@@ -1163,7 +1157,7 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n   int freq;\n   unsigned int nest;\n   cgraph_inline_failed_t inline_failed;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n   enum ld_plugin_symbol_resolution caller_resolution;\n   int ecf_flags = 0;\n \n@@ -1183,11 +1177,11 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n   count = (gcov_type) lto_input_sleb128 (ib);\n \n   bp = lto_input_bitpack (ib);\n-  stmt_id = (unsigned int) bp_unpack_value (bp, HOST_BITS_PER_INT);\n-  inline_failed = (cgraph_inline_failed_t) bp_unpack_value (bp,\n+  stmt_id = (unsigned int) bp_unpack_value (&bp, HOST_BITS_PER_INT);\n+  inline_failed = (cgraph_inline_failed_t) bp_unpack_value (&bp,\n \t\t\t\t\t\t\t    HOST_BITS_PER_INT);\n-  freq = (int) bp_unpack_value (bp, HOST_BITS_PER_INT);\n-  nest = (unsigned) bp_unpack_value (bp, 30);\n+  freq = (int) bp_unpack_value (&bp, HOST_BITS_PER_INT);\n+  nest = (unsigned) bp_unpack_value (&bp, 30);\n \n   /* If the caller was preempted, don't create the edge.\n      ???  Should we ever have edges from a preempted caller?  */\n@@ -1201,28 +1195,27 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n   else\n     edge = cgraph_create_edge (caller, callee, NULL, count, freq, nest);\n \n-  edge->indirect_inlining_edge = bp_unpack_value (bp, 1);\n+  edge->indirect_inlining_edge = bp_unpack_value (&bp, 1);\n   edge->lto_stmt_uid = stmt_id;\n   edge->inline_failed = inline_failed;\n-  edge->call_stmt_cannot_inline_p = bp_unpack_value (bp, 1);\n-  edge->can_throw_external = bp_unpack_value (bp, 1);\n+  edge->call_stmt_cannot_inline_p = bp_unpack_value (&bp, 1);\n+  edge->can_throw_external = bp_unpack_value (&bp, 1);\n   if (indirect)\n     {\n-      if (bp_unpack_value (bp, 1))\n+      if (bp_unpack_value (&bp, 1))\n \tecf_flags |= ECF_CONST;\n-      if (bp_unpack_value (bp, 1))\n+      if (bp_unpack_value (&bp, 1))\n \tecf_flags |= ECF_PURE;\n-      if (bp_unpack_value (bp, 1))\n+      if (bp_unpack_value (&bp, 1))\n \tecf_flags |= ECF_NORETURN;\n-      if (bp_unpack_value (bp, 1))\n+      if (bp_unpack_value (&bp, 1))\n \tecf_flags |= ECF_MALLOC;\n-      if (bp_unpack_value (bp, 1))\n+      if (bp_unpack_value (&bp, 1))\n \tecf_flags |= ECF_NOTHROW;\n-      if (bp_unpack_value (bp, 1))\n+      if (bp_unpack_value (&bp, 1))\n \tecf_flags |= ECF_RETURNS_TWICE;\n       edge->indirect_info->ecf_flags = ecf_flags;\n     }\n-  bitpack_delete (bp);\n }\n \n \n@@ -1470,7 +1463,7 @@ output_node_opt_summary (struct output_block *ob,\n   unsigned int index;\n   bitmap_iterator bi;\n   struct ipa_replace_map *map;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n   int i;\n \n   lto_output_uleb128_stream (ob->main_stream,\n@@ -1497,11 +1490,10 @@ output_node_opt_summary (struct output_block *ob,\n       gcc_assert (parm);\n       lto_output_uleb128_stream (ob->main_stream, parm_num);\n       lto_output_tree (ob, map->new_tree, true);\n-      bp = bitpack_create ();\n-      bp_pack_value (bp, map->replace_p, 1);\n-      bp_pack_value (bp, map->ref_p, 1);\n-      lto_output_bitpack (ob->main_stream, bp);\n-      bitpack_delete (bp);\n+      bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, map->replace_p, 1);\n+      bp_pack_value (&bp, map->ref_p, 1);\n+      lto_output_bitpack (&bp);\n     }\n }\n \n@@ -1547,7 +1539,7 @@ input_node_opt_summary (struct cgraph_node *node,\n   int i;\n   int count;\n   int bit;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n \n   count = lto_input_uleb128 (ib_main);\n   if (count)\n@@ -1580,9 +1572,8 @@ input_node_opt_summary (struct cgraph_node *node,\n       map->old_tree = NULL;\n       map->new_tree = lto_input_tree (ib_main, data_in);\n       bp = lto_input_bitpack (ib_main);\n-      map->replace_p = bp_unpack_value (bp, 1);\n-      map->ref_p = bp_unpack_value (bp, 1);\n-      bitpack_delete (bp);\n+      map->replace_p = bp_unpack_value (&bp, 1);\n+      map->ref_p = bp_unpack_value (&bp, 1);\n     }\n }\n "}, {"sha": "e875460fa0b6cf2d69ba60396e113ec272abe3f9", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 32, "deletions": 55, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2465dcc257488294138948de82a734c31b504ecf/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2465dcc257488294138948de82a734c31b504ecf/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=2465dcc257488294138948de82a734c31b504ecf", "patch": "@@ -1001,20 +1001,19 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n   enum gimple_code code;\n   unsigned HOST_WIDE_INT num_ops;\n   size_t i;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n \n   code = lto_tag_to_gimple_code (tag);\n \n   /* Read the tuple header.  */\n   bp = lto_input_bitpack (ib);\n-  num_ops = bp_unpack_value (bp, sizeof (unsigned) * 8);\n+  num_ops = bp_unpack_value (&bp, sizeof (unsigned) * 8);\n   stmt = gimple_alloc (code, num_ops);\n-  stmt->gsbase.no_warning = bp_unpack_value (bp, 1);\n+  stmt->gsbase.no_warning = bp_unpack_value (&bp, 1);\n   if (is_gimple_assign (stmt))\n-    stmt->gsbase.nontemporal_move = bp_unpack_value (bp, 1);\n-  stmt->gsbase.has_volatile_ops = bp_unpack_value (bp, 1);\n-  stmt->gsbase.subcode = bp_unpack_value (bp, 16);\n-  bitpack_delete (bp);\n+    stmt->gsbase.nontemporal_move = bp_unpack_value (&bp, 1);\n+  stmt->gsbase.has_volatile_ops = bp_unpack_value (&bp, 1);\n+  stmt->gsbase.subcode = bp_unpack_value (&bp, 16);\n \n   /* Read location information.  */\n   gimple_set_location (stmt, lto_input_location (ib, data_in));\n@@ -1291,7 +1290,7 @@ input_function (tree fn_decl, struct data_in *data_in,\n   enum LTO_tags tag;\n   gimple *stmts;\n   basic_block bb;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n   struct cgraph_node *node;\n   tree args, narg, oarg;\n \n@@ -1304,22 +1303,21 @@ input_function (tree fn_decl, struct data_in *data_in,\n \n   /* Read all the attributes for FN.  */\n   bp = lto_input_bitpack (ib);\n-  fn->is_thunk = bp_unpack_value (bp, 1);\n-  fn->has_local_explicit_reg_vars = bp_unpack_value (bp, 1);\n-  fn->after_tree_profile = bp_unpack_value (bp, 1);\n-  fn->returns_pcc_struct = bp_unpack_value (bp, 1);\n-  fn->returns_struct = bp_unpack_value (bp, 1);\n-  fn->can_throw_non_call_exceptions = bp_unpack_value (bp, 1);\n-  fn->always_inline_functions_inlined = bp_unpack_value (bp, 1);\n-  fn->after_inlining = bp_unpack_value (bp, 1);\n-  fn->dont_save_pending_sizes_p = bp_unpack_value (bp, 1);\n-  fn->stdarg = bp_unpack_value (bp, 1);\n-  fn->has_nonlocal_label = bp_unpack_value (bp, 1);\n-  fn->calls_alloca = bp_unpack_value (bp, 1);\n-  fn->calls_setjmp = bp_unpack_value (bp, 1);\n-  fn->va_list_fpr_size = bp_unpack_value (bp, 8);\n-  fn->va_list_gpr_size = bp_unpack_value (bp, 8);\n-  bitpack_delete (bp);\n+  fn->is_thunk = bp_unpack_value (&bp, 1);\n+  fn->has_local_explicit_reg_vars = bp_unpack_value (&bp, 1);\n+  fn->after_tree_profile = bp_unpack_value (&bp, 1);\n+  fn->returns_pcc_struct = bp_unpack_value (&bp, 1);\n+  fn->returns_struct = bp_unpack_value (&bp, 1);\n+  fn->can_throw_non_call_exceptions = bp_unpack_value (&bp, 1);\n+  fn->always_inline_functions_inlined = bp_unpack_value (&bp, 1);\n+  fn->after_inlining = bp_unpack_value (&bp, 1);\n+  fn->dont_save_pending_sizes_p = bp_unpack_value (&bp, 1);\n+  fn->stdarg = bp_unpack_value (&bp, 1);\n+  fn->has_nonlocal_label = bp_unpack_value (&bp, 1);\n+  fn->calls_alloca = bp_unpack_value (&bp, 1);\n+  fn->calls_setjmp = bp_unpack_value (&bp, 1);\n+  fn->va_list_fpr_size = bp_unpack_value (&bp, 8);\n+  fn->va_list_gpr_size = bp_unpack_value (&bp, 8);\n \n   /* Input the current IL state of the function.  */\n   fn->curr_properties = lto_input_uleb128 (ib);\n@@ -1581,12 +1579,16 @@ unpack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n \t so we skip it here.  */\n       TREE_PUBLIC (expr) = (unsigned) bp_unpack_value (bp, 1);\n     }\n+  else\n+    bp_unpack_value (bp, 4);\n   TREE_ADDRESSABLE (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TREE_THIS_VOLATILE (expr) = (unsigned) bp_unpack_value (bp, 1);\n   if (DECL_P (expr))\n     DECL_UNSIGNED (expr) = (unsigned) bp_unpack_value (bp, 1);\n   else if (TYPE_P (expr))\n     TYPE_UNSIGNED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  else\n+    bp_unpack_value (bp, 1);\n   TREE_ASM_WRITTEN (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TREE_NO_WARNING (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TREE_USED (expr) = (unsigned) bp_unpack_value (bp, 1);\n@@ -1597,8 +1599,10 @@ unpack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n   TREE_DEPRECATED (expr) = (unsigned) bp_unpack_value (bp, 1);\n   if (TYPE_P (expr))\n     TYPE_SATURATING (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  if (TREE_CODE (expr) == SSA_NAME)\n+  else if (TREE_CODE (expr) == SSA_NAME)\n     SSA_NAME_IS_DEFAULT_DEF (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  else\n+    bp_unpack_value (bp, 1);\n }\n \n \n@@ -1858,32 +1862,6 @@ unpack_value_fields (struct bitpack_d *bp, tree expr)\n }\n \n \n-/* Read a bitpack from input block IB.  */\n-\n-struct bitpack_d *\n-lto_input_bitpack (struct lto_input_block *ib)\n-{\n-  unsigned i, num_words;\n-  struct bitpack_d *bp;\n-\n-  bp = bitpack_create ();\n-\n-  /* If we are about to read more than a handful of words, something\n-     is wrong.  This check is overly strict, but it acts as an early\n-     warning.  No streamed object has hundreds of bits in its fields.  */\n-  num_words = lto_input_uleb128 (ib);\n-  gcc_assert (num_words < 20);\n-\n-  for (i = 0; i < num_words; i++)\n-    {\n-      bitpack_word_t w = lto_input_uleb128 (ib);\n-      VEC_safe_push (bitpack_word_t, heap, bp->values, w);\n-    }\n-\n-  return bp;\n-}\n-\n-\n /* Materialize a new tree from input block IB using descriptors in\n    DATA_IN.  The code for the new tree should match TAG.  Store in\n    *IX_P the index into the reader cache where the new tree is stored.  */\n@@ -1892,7 +1870,7 @@ static tree\n lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n \t\t      enum LTO_tags tag, int *ix_p)\n {\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n   enum tree_code code;\n   tree result;\n #ifdef LTO_STREAMER_DEBUG\n@@ -1957,12 +1935,11 @@ lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n \n   /* The first word in BP contains the code of the tree that we\n      are about to read.  */\n-  code = (enum tree_code) bp_unpack_value (bp, 16);\n+  code = (enum tree_code) bp_unpack_value (&bp, 16);\n   lto_tag_check (lto_tree_code_to_tag (code), tag);\n \n   /* Unpack all the value fields from BP.  */\n-  unpack_value_fields (bp, result);\n-  bitpack_delete (bp);\n+  unpack_value_fields (&bp, result);\n \n   /* Enter RESULT in the reader cache.  This will make RESULT\n      available so that circular references in the rest of the tree"}, {"sha": "6ee2eda27844f6709f0cca0f91f790961a54bbff", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 39, "deletions": 53, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2465dcc257488294138948de82a734c31b504ecf/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2465dcc257488294138948de82a734c31b504ecf/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=2465dcc257488294138948de82a734c31b504ecf", "patch": "@@ -151,20 +151,6 @@ destroy_output_block (struct output_block *ob)\n }\n \n \n-/* Output bitpack BP to output stream S.  */\n-\n-void\n-lto_output_bitpack (struct lto_output_stream *s, struct bitpack_d *bp)\n-{\n-  unsigned i;\n-  bitpack_word_t v;\n-\n-  lto_output_uleb128_stream (s, VEC_length (bitpack_word_t, bp->values));\n-  for (i = 0; VEC_iterate (bitpack_word_t, bp->values, i, v); i++)\n-    lto_output_uleb128_stream (s, v);\n-}\n-\n-\n /* Output STRING of LEN characters to the string\n    table in OB. The string might or might not include a trailing '\\0'.\n    Then put the index onto the INDEX_STREAM.  */\n@@ -335,12 +321,16 @@ pack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n \t so we skip it here.  */\n       bp_pack_value (bp, TREE_PUBLIC (expr), 1);\n     }\n+  else\n+    bp_pack_value (bp, 0, 4);\n   bp_pack_value (bp, TREE_ADDRESSABLE (expr), 1);\n   bp_pack_value (bp, TREE_THIS_VOLATILE (expr), 1);\n   if (DECL_P (expr))\n     bp_pack_value (bp, DECL_UNSIGNED (expr), 1);\n   else if (TYPE_P (expr))\n     bp_pack_value (bp, TYPE_UNSIGNED (expr), 1);\n+  else\n+    bp_pack_value (bp, 0, 1);\n   /* We write debug info two times, do not confuse the second one.  */\n   bp_pack_value (bp, TYPE_P (expr) ? 0 : TREE_ASM_WRITTEN (expr), 1);\n   bp_pack_value (bp, TREE_NO_WARNING (expr), 1);\n@@ -352,8 +342,10 @@ pack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n   bp_pack_value (bp, TREE_DEPRECATED (expr), 1);\n   if (TYPE_P (expr))\n     bp_pack_value (bp, TYPE_SATURATING (expr), 1);\n-  if (TREE_CODE (expr) == SSA_NAME)\n+  else if (TREE_CODE (expr) == SSA_NAME)\n     bp_pack_value (bp, SSA_NAME_IS_DEFAULT_DEF (expr), 1);\n+  else\n+    bp_pack_value (bp, 0, 1);\n }\n \n \n@@ -544,14 +536,12 @@ pack_ts_block_value_fields (struct bitpack_d *bp, tree expr)\n \n /* Pack all the non-pointer fields in EXPR into a bit pack.  */\n \n-static struct bitpack_d *\n-pack_value_fields (tree expr)\n+static void\n+pack_value_fields (struct bitpack_d *bp, tree expr)\n {\n   enum tree_code code;\n-  struct bitpack_d *bp;\n \n   code = TREE_CODE (expr);\n-  bp = bitpack_create ();\n \n   /* Note that all these functions are highly sensitive to changes in\n      the types and sizes of each of the fields being packed.  */\n@@ -598,8 +588,6 @@ pack_value_fields (tree expr)\n       /* This is only used by High GIMPLE.  */\n       gcc_unreachable ();\n     }\n-\n-  return bp;\n }\n \n \n@@ -1294,17 +1282,17 @@ lto_output_builtin_tree (struct output_block *ob, tree expr, int ix)\n static void\n lto_write_tree (struct output_block *ob, tree expr, bool ref_p, int ix)\n {\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n \n   /* Write the header, containing everything needed to materialize\n      EXPR on the reading side.  */\n   lto_output_tree_header (ob, expr, ix);\n \n   /* Pack all the non-pointer fields in EXPR into a bitpack and write\n      the resulting bitpack.  */\n-  bp = pack_value_fields (expr);\n-  lto_output_bitpack (ob->main_stream, bp);\n-  bitpack_delete (bp);\n+  bp = bitpack_create (ob->main_stream);\n+  pack_value_fields (&bp, expr);\n+  lto_output_bitpack (&bp);\n \n   /* Write all the pointer fields in EXPR.  */\n   lto_output_tree_pointers (ob, expr, ref_p);\n@@ -1661,23 +1649,22 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n   unsigned i;\n   enum gimple_code code;\n   enum LTO_tags tag;\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n \n   /* Emit identifying tag.  */\n   code = gimple_code (stmt);\n   tag = lto_gimple_code_to_tag (code);\n   output_record_start (ob, tag);\n \n   /* Emit the tuple header.  */\n-  bp = bitpack_create ();\n-  bp_pack_value (bp, gimple_num_ops (stmt), sizeof (unsigned) * 8);\n-  bp_pack_value (bp, gimple_no_warning_p (stmt), 1);\n+  bp = bitpack_create (ob->main_stream);\n+  bp_pack_value (&bp, gimple_num_ops (stmt), sizeof (unsigned) * 8);\n+  bp_pack_value (&bp, gimple_no_warning_p (stmt), 1);\n   if (is_gimple_assign (stmt))\n-    bp_pack_value (bp, gimple_assign_nontemporal_move_p (stmt), 1);\n-  bp_pack_value (bp, gimple_has_volatile_ops (stmt), 1);\n-  bp_pack_value (bp, stmt->gsbase.subcode, 16);\n-  lto_output_bitpack (ob->main_stream, bp);\n-  bitpack_delete (bp);\n+    bp_pack_value (&bp, gimple_assign_nontemporal_move_p (stmt), 1);\n+  bp_pack_value (&bp, gimple_has_volatile_ops (stmt), 1);\n+  bp_pack_value (&bp, stmt->gsbase.subcode, 16);\n+  lto_output_bitpack (&bp);\n \n   /* Emit location information for the statement.  */\n   lto_output_location (ob, gimple_location (stmt));\n@@ -1848,7 +1835,7 @@ produce_asm (struct output_block *ob, tree fn)\n static void\n output_function (struct cgraph_node *node)\n {\n-  struct bitpack_d *bp;\n+  struct bitpack_d bp;\n   tree function;\n   struct function *fn;\n   basic_block bb;\n@@ -1873,24 +1860,23 @@ output_function (struct cgraph_node *node)\n   output_record_start (ob, LTO_function);\n \n   /* Write all the attributes for FN.  */\n-  bp = bitpack_create ();\n-  bp_pack_value (bp, fn->is_thunk, 1);\n-  bp_pack_value (bp, fn->has_local_explicit_reg_vars, 1);\n-  bp_pack_value (bp, fn->after_tree_profile, 1);\n-  bp_pack_value (bp, fn->returns_pcc_struct, 1);\n-  bp_pack_value (bp, fn->returns_struct, 1);\n-  bp_pack_value (bp, fn->can_throw_non_call_exceptions, 1);\n-  bp_pack_value (bp, fn->always_inline_functions_inlined, 1);\n-  bp_pack_value (bp, fn->after_inlining, 1);\n-  bp_pack_value (bp, fn->dont_save_pending_sizes_p, 1);\n-  bp_pack_value (bp, fn->stdarg, 1);\n-  bp_pack_value (bp, fn->has_nonlocal_label, 1);\n-  bp_pack_value (bp, fn->calls_alloca, 1);\n-  bp_pack_value (bp, fn->calls_setjmp, 1);\n-  bp_pack_value (bp, fn->va_list_fpr_size, 8);\n-  bp_pack_value (bp, fn->va_list_gpr_size, 8);\n-  lto_output_bitpack (ob->main_stream, bp);\n-  bitpack_delete (bp);\n+  bp = bitpack_create (ob->main_stream);\n+  bp_pack_value (&bp, fn->is_thunk, 1);\n+  bp_pack_value (&bp, fn->has_local_explicit_reg_vars, 1);\n+  bp_pack_value (&bp, fn->after_tree_profile, 1);\n+  bp_pack_value (&bp, fn->returns_pcc_struct, 1);\n+  bp_pack_value (&bp, fn->returns_struct, 1);\n+  bp_pack_value (&bp, fn->can_throw_non_call_exceptions, 1);\n+  bp_pack_value (&bp, fn->always_inline_functions_inlined, 1);\n+  bp_pack_value (&bp, fn->after_inlining, 1);\n+  bp_pack_value (&bp, fn->dont_save_pending_sizes_p, 1);\n+  bp_pack_value (&bp, fn->stdarg, 1);\n+  bp_pack_value (&bp, fn->has_nonlocal_label, 1);\n+  bp_pack_value (&bp, fn->calls_alloca, 1);\n+  bp_pack_value (&bp, fn->calls_setjmp, 1);\n+  bp_pack_value (&bp, fn->va_list_fpr_size, 8);\n+  bp_pack_value (&bp, fn->va_list_gpr_size, 8);\n+  lto_output_bitpack (&bp);\n \n   /* Output current IL state of the function.  */\n   output_uleb128 (ob, fn->curr_properties);"}, {"sha": "406096015f4a6d56c2bcd3e4ee8e967fc506ab88", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2465dcc257488294138948de82a734c31b504ecf/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2465dcc257488294138948de82a734c31b504ecf/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=2465dcc257488294138948de82a734c31b504ecf", "patch": "@@ -266,147 +266,6 @@ print_lto_report (void)\n \t     lto_section_name[i], lto_stats.section_size[i]);\n }\n \n-/* We cache a single bitpack assuming that usually at most one is\n-   life.  This saves repeated re-allocations.  */\n-static struct bitpack_d *cached_bp;\n-\n-/* Create a new bitpack.  */\n-\n-struct bitpack_d *\n-bitpack_create (void)\n-{\n-  if (cached_bp)\n-    {\n-      struct bitpack_d *bp = cached_bp;\n-      cached_bp = NULL;\n-      return bp;\n-    }\n-  return XCNEW (struct bitpack_d);\n-}\n-\n-\n-/* Free the memory used by bitpack BP.  */\n-\n-void\n-bitpack_delete (struct bitpack_d *bp)\n-{\n-  if (!cached_bp)\n-    {\n-      bp->num_bits = 0;\n-      bp->first_unused_bit = 0;\n-      VEC_truncate (bitpack_word_t, bp->values, 0);\n-      cached_bp = bp;\n-      return;\n-    }\n-  VEC_free (bitpack_word_t, heap, bp->values);\n-  free (bp);\n-}\n-\n-\n-/* Return an index to the word in bitpack BP that contains the\n-   next NBITS.  */\n-\n-static inline unsigned\n-bp_get_next_word (struct bitpack_d *bp, unsigned nbits)\n-{\n-  unsigned last, ix;\n-\n-  /* In principle, the next word to use is determined by the\n-     number of bits already processed in BP.  */\n-  ix = bp->num_bits / BITS_PER_BITPACK_WORD;\n-\n-  /* All the encoded bit patterns in BP are contiguous, therefore if\n-     the next NBITS would straddle over two different words, move the\n-     index to the next word and update the number of encoded bits\n-     by adding up the hole of unused bits created by this move.  */\n-  bp->first_unused_bit %= BITS_PER_BITPACK_WORD;\n-  last = bp->first_unused_bit + nbits - 1;\n-  if (last >= BITS_PER_BITPACK_WORD)\n-    {\n-      ix++;\n-      bp->num_bits += (BITS_PER_BITPACK_WORD - bp->first_unused_bit);\n-      bp->first_unused_bit = 0;\n-    }\n-\n-  return ix;\n-}\n-\n-\n-/* Pack NBITS of value VAL into bitpack BP.  */\n-\n-void\n-bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n-{\n-  unsigned ix;\n-  bitpack_word_t word;\n-\n-  /* We cannot encode more bits than BITS_PER_BITPACK_WORD.  */\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (nbits > 0 && nbits <= BITS_PER_BITPACK_WORD);\n-#endif\n-\n-  /* Compute which word will contain the next NBITS.  */\n-  ix = bp_get_next_word (bp, nbits);\n-  if (ix >= VEC_length (bitpack_word_t, bp->values))\n-    {\n-      /* If there is no room left in the last word of the values\n-\t array, add a new word.  Additionally, we should only\n-\t need to add a single word, since every pack operation cannot\n-\t use more bits than fit in a single word.  */\n-      VEC_safe_push (bitpack_word_t, heap, bp->values, 0);\n-    }\n-\n-  /* Grab the last word to pack VAL into.  */\n-  word = VEC_index (bitpack_word_t, bp->values, ix);\n-\n-  /* To fit VAL in WORD, we need to shift VAL to the left to\n-     skip the bottom BP->FIRST_UNUSED_BIT bits.  */\n-  val <<= bp->first_unused_bit;\n-\n-  /* Update WORD with VAL.  */\n-  word |= val;\n-\n-  /* Update BP.  */\n-  VEC_replace (bitpack_word_t, bp->values, ix, word);\n-  bp->num_bits += nbits;\n-  bp->first_unused_bit += nbits;\n-}\n-\n-\n-/* Unpack the next NBITS from bitpack BP.  */\n-\n-bitpack_word_t\n-bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n-{\n-  bitpack_word_t val, word, mask;\n-  unsigned ix;\n-\n-  /* We cannot decode more bits than BITS_PER_BITPACK_WORD.  */\n-  gcc_checking_assert (nbits > 0 && nbits <= BITS_PER_BITPACK_WORD);\n-\n-  /* Compute which word contains the next NBITS.  */\n-  ix = bp_get_next_word (bp, nbits);\n-  word = VEC_index (bitpack_word_t, bp->values, ix);\n-\n-  /* Compute the mask to get NBITS from WORD.  */\n-  mask = (nbits == BITS_PER_BITPACK_WORD)\n-\t ? (bitpack_word_t) -1\n-\t : ((bitpack_word_t) 1 << nbits) - 1;\n-\n-  /* Shift WORD to the right to skip over the bits already decoded\n-     in word.  */\n-  word >>= bp->first_unused_bit;\n-\n-  /* Apply the mask to obtain the requested value.  */\n-  val = word & mask;\n-\n-  /* Update BP->NUM_BITS for the next unpack operation.  */\n-  bp->num_bits += nbits;\n-  bp->first_unused_bit += nbits;\n-\n-  return val;\n-}\n-\n \n /* Check that all the TS_* structures handled by the lto_output_* and\n    lto_input_* routines are exactly ALL the structures defined in"}, {"sha": "cc38b22d179fc2e3a3d62bdb2e3e68065dda4c48", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 87, "deletions": 15, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2465dcc257488294138948de82a734c31b504ecf/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2465dcc257488294138948de82a734c31b504ecf/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=2465dcc257488294138948de82a734c31b504ecf", "patch": "@@ -156,17 +156,14 @@ DEF_VEC_ALLOC_I(bitpack_word_t, heap);\n \n struct bitpack_d\n {\n-  /* Total number of bits packed/unpacked so far.  */\n-  size_t num_bits;\n+  /* The position of the first unused or unconsumed bit in the word.  */\n+  unsigned pos;\n \n-  /* Values are stored contiguously, so there may be internal\n-     fragmentation (words with unused bits).  Therefore, we need to\n-     keep track of the first available bit in the last word of the\n-     bitpack.  */\n-  size_t first_unused_bit;\n+  /* The current word we are (un)packing.  */\n+  bitpack_word_t word;\n \n-  /* Vector of words holding the packed values.  */\n-  VEC(bitpack_word_t, heap) *values;\n+  /* The lto_output_stream or the lto_input_block we are streaming to/from.  */\n+  void *stream;\n };\n \n /* Tags representing the various IL objects written to the bytecode file\n@@ -820,10 +817,6 @@ extern bitmap lto_bitmap_alloc (void);\n extern void lto_bitmap_free (bitmap);\n extern char *lto_get_section_name (int, const char *);\n extern void print_lto_report (void);\n-extern struct bitpack_d *bitpack_create (void);\n-extern void bitpack_delete (struct bitpack_d *);\n-extern void bp_pack_value (struct bitpack_d *, bitpack_word_t, unsigned);\n-extern bitpack_word_t bp_unpack_value (struct bitpack_d *, unsigned);\n extern bool lto_streamer_cache_insert (struct lto_streamer_cache_d *, tree,\n \t\t\t\t       int *, unsigned *);\n extern bool lto_streamer_cache_insert_at (struct lto_streamer_cache_d *, tree,\n@@ -851,7 +844,6 @@ extern void lto_input_function_body (struct lto_file_decl_data *, tree,\n \t\t\t\t     const char *);\n extern void lto_input_constructors_and_inits (struct lto_file_decl_data *,\n \t\t\t\t\t      const char *);\n-extern struct bitpack_d *lto_input_bitpack (struct lto_input_block *);\n extern void lto_init_reader (void);\n extern struct data_in *lto_data_in_create (struct lto_file_decl_data *,\n \t\t\t\t    const char *, unsigned,\n@@ -864,7 +856,6 @@ extern void lto_register_decl_definition (tree, struct lto_file_decl_data *);\n extern struct output_block *create_output_block (enum lto_section_type);\n extern void destroy_output_block (struct output_block *);\n extern void lto_output_tree (struct output_block *, tree, bool);\n-extern void lto_output_bitpack (struct lto_output_stream *, struct bitpack_d *);\n extern void produce_asm (struct output_block *ob, tree fn);\n \n \n@@ -1077,4 +1068,85 @@ DEFINE_DECL_STREAM_FUNCS (TYPE_DECL, type_decl)\n DEFINE_DECL_STREAM_FUNCS (NAMESPACE_DECL, namespace_decl)\n DEFINE_DECL_STREAM_FUNCS (LABEL_DECL, label_decl)\n \n+/* Returns a new bit-packing context for bit-packing into S.  */\n+static inline struct bitpack_d\n+bitpack_create (struct lto_output_stream *s)\n+{\n+  struct bitpack_d bp;\n+  bp.pos = 0;\n+  bp.word = 0;\n+  bp.stream = (void *)s;\n+  return bp;\n+}\n+\n+/* Pack the NBITS bit sized value VAL into the bit-packing context BP.  */\n+static inline void\n+bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n+{\n+  bitpack_word_t word = bp->word;\n+  int pos = bp->pos;\n+  /* If val does not fit into the current bitpack word switch to the\n+     next one.  */\n+  if (pos + nbits > BITS_PER_BITPACK_WORD)\n+    {\n+      lto_output_uleb128_stream ((struct lto_output_stream *) bp->stream, word);\n+      word = val;\n+      pos = nbits;\n+    }\n+  else\n+    {\n+      word |= val << pos;\n+      pos += nbits;\n+    }\n+  bp->word = word;\n+  bp->pos = pos;\n+}\n+\n+/* Finishes bit-packing of BP.  */\n+static inline void\n+lto_output_bitpack (struct bitpack_d *bp)\n+{\n+  lto_output_uleb128_stream ((struct lto_output_stream *) bp->stream,\n+\t\t\t     bp->word);\n+  bp->word = 0;\n+  bp->pos = 0;\n+}\n+\n+/* Returns a new bit-packing context for bit-unpacking from IB.  */\n+static inline struct bitpack_d\n+lto_input_bitpack (struct lto_input_block *ib)\n+{\n+  struct bitpack_d bp;\n+  bp.word = lto_input_uleb128 (ib);\n+  bp.pos = 0;\n+  bp.stream = (void *)ib;\n+  return bp;\n+}\n+\n+/* Unpacks NBITS bits from the bit-packing context BP and returns them.  */\n+static inline bitpack_word_t\n+bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n+{\n+  bitpack_word_t mask, val;\n+  int pos = bp->pos;\n+\n+  mask = (nbits == BITS_PER_BITPACK_WORD\n+\t  ? (bitpack_word_t) -1\n+\t  : ((bitpack_word_t) 1 << nbits) - 1);\n+\n+  /* If there are not continuous nbits in the current bitpack word\n+     switch to the next one.  */\n+  if (pos + nbits > BITS_PER_BITPACK_WORD)\n+    {\n+      bp->word = val = lto_input_uleb128 ((struct lto_input_block *)bp->stream);\n+      bp->pos = nbits;\n+      return val & mask;\n+    }\n+  val = bp->word;\n+  val >>= pos;\n+  bp->pos = pos + nbits;\n+\n+  return val & mask;\n+}\n+\n #endif /* GCC_LTO_STREAMER_H  */"}]}