{"sha": "e361382f655dcba3b6538d9157c6d378db57158b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM2MTM4MmY2NTVkY2JhM2I2NTM4ZDkxNTdjNmQzNzhkYjU3MTU4Yg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-11-28T08:18:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-11-28T08:18:59Z"}, "message": "cfgexpand.c (struct stack_vars_data): Add asan_base and asan_alignb fields.\n\n\t* cfgexpand.c (struct stack_vars_data): Add asan_base and asan_alignb\n\tfields.\n\t(expand_stack_vars): For -fsanitize=address, use (and set initially)\n\tdata->asan_base as base for vars and update asan_alignb.\n\t(expand_used_vars): Initialize data.asan_base and data.asan_alignb.\n\tPass them to asan_emit_stack_protection.\n\t* asan.c (asan_detect_stack_use_after_return): New variable.\n\t(asan_emit_stack_protection): Add pbase and alignb arguments.\n\tImplement use after return sanitization.\n\t* asan.h (asan_emit_stack_protection): Adjust prototype.\n\t(ASAN_STACK_MAGIC_USE_AFTER_RET, ASAN_STACK_RETIRED_MAGIC): Define.\n\nFrom-SVN: r205476", "tree": {"sha": "b8e14dee616a6f5428fd7b804709a5da8b7d3073", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8e14dee616a6f5428fd7b804709a5da8b7d3073"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e361382f655dcba3b6538d9157c6d378db57158b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e361382f655dcba3b6538d9157c6d378db57158b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e361382f655dcba3b6538d9157c6d378db57158b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e361382f655dcba3b6538d9157c6d378db57158b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8b5e12023b56dfc83c037053612b08f5ee7eac61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b5e12023b56dfc83c037053612b08f5ee7eac61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b5e12023b56dfc83c037053612b08f5ee7eac61"}], "stats": {"total": 181, "additions": 164, "deletions": 17}, "files": [{"sha": "c4a1a221240f071e2a036c30631c5d7bc02191e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e361382f655dcba3b6538d9157c6d378db57158b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e361382f655dcba3b6538d9157c6d378db57158b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e361382f655dcba3b6538d9157c6d378db57158b", "patch": "@@ -1,3 +1,17 @@\n+2013-11-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cfgexpand.c (struct stack_vars_data): Add asan_base and asan_alignb\n+\tfields.\n+\t(expand_stack_vars): For -fsanitize=address, use (and set initially)\n+\tdata->asan_base as base for vars and update asan_alignb.\n+\t(expand_used_vars): Initialize data.asan_base and data.asan_alignb.\n+\tPass them to asan_emit_stack_protection.\n+\t* asan.c (asan_detect_stack_use_after_return): New variable.\n+\t(asan_emit_stack_protection): Add pbase and alignb arguments.\n+\tImplement use after return sanitization.\n+\t* asan.h (asan_emit_stack_protection): Adjust prototype.\n+\t(ASAN_STACK_MAGIC_USE_AFTER_RET, ASAN_STACK_RETIRED_MAGIC): Define.\n+\n 2013-11-28  Sergey Ostanevich  <sergos.gnu@gmail.com>\n \n \t* common.opt: Introduced a new option -fsimd-cost-model."}, {"sha": "2245d6dd807ccb5889fbf8a676b3438a14e821df", "filename": "gcc/asan.c", "status": "modified", "additions": 119, "deletions": 10, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e361382f655dcba3b6538d9157c6d378db57158b/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e361382f655dcba3b6538d9157c6d378db57158b/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=e361382f655dcba3b6538d9157c6d378db57158b", "patch": "@@ -237,6 +237,9 @@ alias_set_type asan_shadow_set = -1;\n    alias set is used for all shadow memory accesses.  */\n static GTY(()) tree shadow_ptr_types[2];\n \n+/* Decl for __asan_option_detect_stack_use_after_return.  */\n+static GTY(()) tree asan_detect_stack_use_after_return;\n+\n /* Hashtable support for memory references used by gimple\n    statements.  */\n \n@@ -950,20 +953,26 @@ asan_function_start (void)\n    and DECLS is an array of representative decls for each var partition.\n    LENGTH is the length of the OFFSETS array, DECLS array is LENGTH / 2 - 1\n    elements long (OFFSETS include gap before the first variable as well\n-   as gaps after each stack variable).  */\n+   as gaps after each stack variable).  PBASE is, if non-NULL, some pseudo\n+   register which stack vars DECL_RTLs are based on.  Either BASE should be\n+   assigned to PBASE, when not doing use after return protection, or\n+   corresponding address based on __asan_stack_malloc* return value.  */\n \n rtx\n-asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n-\t\t\t    int length)\n+asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n+\t\t\t    HOST_WIDE_INT *offsets, tree *decls, int length)\n {\n-  rtx shadow_base, shadow_mem, ret, mem;\n+  rtx shadow_base, shadow_mem, ret, mem, orig_base, lab;\n   char buf[30];\n   unsigned char shadow_bytes[4];\n-  HOST_WIDE_INT base_offset = offsets[length - 1], offset, prev_offset;\n+  HOST_WIDE_INT base_offset = offsets[length - 1];\n+  HOST_WIDE_INT base_align_bias = 0, offset, prev_offset;\n+  HOST_WIDE_INT asan_frame_size = offsets[0] - base_offset;\n   HOST_WIDE_INT last_offset, last_size;\n   int l;\n   unsigned char cur_shadow_byte = ASAN_STACK_MAGIC_LEFT;\n   tree str_cst, decl, id;\n+  int use_after_return_class = -1;\n \n   if (shadow_ptr_types[0] == NULL_TREE)\n     asan_init_shadow_ptr_types ();\n@@ -993,10 +1002,67 @@ asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n   str_cst = asan_pp_string (&asan_pp);\n \n   /* Emit the prologue sequence.  */\n+  if (asan_frame_size > 32 && asan_frame_size <= 65536 && pbase)\n+    {\n+      use_after_return_class = floor_log2 (asan_frame_size - 1) - 5;\n+      /* __asan_stack_malloc_N guarantees alignment\n+         N < 6 ? (64 << N) : 4096 bytes.  */\n+      if (alignb > (use_after_return_class < 6\n+\t\t    ? (64U << use_after_return_class) : 4096U))\n+\tuse_after_return_class = -1;\n+      else if (alignb > ASAN_RED_ZONE_SIZE && (asan_frame_size & (alignb - 1)))\n+\tbase_align_bias = ((asan_frame_size + alignb - 1)\n+\t\t\t   & ~(alignb - HOST_WIDE_INT_1)) - asan_frame_size;\n+    }\n+  if (use_after_return_class == -1 && pbase)\n+    emit_move_insn (pbase, base);\n   base = expand_binop (Pmode, add_optab, base,\n-\t\t       gen_int_mode (base_offset, Pmode),\n+\t\t       gen_int_mode (base_offset - base_align_bias, Pmode),\n \t\t       NULL_RTX, 1, OPTAB_DIRECT);\n+  orig_base = NULL_RTX;\n+  if (use_after_return_class != -1)\n+    {\n+      if (asan_detect_stack_use_after_return == NULL_TREE)\n+\t{\n+\t  id = get_identifier (\"__asan_option_detect_stack_use_after_return\");\n+\t  decl = build_decl (BUILTINS_LOCATION, VAR_DECL, id,\n+\t\t\t     integer_type_node);\n+\t  SET_DECL_ASSEMBLER_NAME (decl, id);\n+\t  TREE_ADDRESSABLE (decl) = 1;\n+\t  DECL_ARTIFICIAL (decl) = 1;\n+\t  DECL_IGNORED_P (decl) = 1;\n+\t  DECL_EXTERNAL (decl) = 1;\n+\t  TREE_STATIC (decl) = 1;\n+\t  TREE_PUBLIC (decl) = 1;\n+\t  TREE_USED (decl) = 1;\n+\t  asan_detect_stack_use_after_return = decl;\n+\t}\n+      orig_base = gen_reg_rtx (Pmode);\n+      emit_move_insn (orig_base, base);\n+      ret = expand_normal (asan_detect_stack_use_after_return);\n+      lab = gen_label_rtx ();\n+      int very_likely = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1);\n+      emit_cmp_and_jump_insns (ret, const0_rtx, EQ, NULL_RTX,\n+\t\t\t       VOIDmode, 0, lab, very_likely);\n+      snprintf (buf, sizeof buf, \"__asan_stack_malloc_%d\",\n+\t\tuse_after_return_class);\n+      ret = init_one_libfunc (buf);\n+      rtx addr = convert_memory_address (ptr_mode, base);\n+      ret = emit_library_call_value (ret, NULL_RTX, LCT_NORMAL, ptr_mode, 2,\n+\t\t\t\t     GEN_INT (asan_frame_size\n+\t\t\t\t\t      + base_align_bias),\n+\t\t\t\t     TYPE_MODE (pointer_sized_int_node),\n+\t\t\t\t     addr, ptr_mode);\n+      ret = convert_memory_address (Pmode, ret);\n+      emit_move_insn (base, ret);\n+      emit_label (lab);\n+      emit_move_insn (pbase, expand_binop (Pmode, add_optab, base,\n+\t\t\t\t\t   gen_int_mode (base_align_bias\n+\t\t\t\t\t\t\t - base_offset, Pmode),\n+\t\t\t\t\t   NULL_RTX, 1, OPTAB_DIRECT));\n+    }\n   mem = gen_rtx_MEM (ptr_mode, base);\n+  mem = adjust_address (mem, VOIDmode, base_align_bias);\n   emit_move_insn (mem, gen_int_mode (ASAN_STACK_FRAME_MAGIC, ptr_mode));\n   mem = adjust_address (mem, VOIDmode, GET_MODE_SIZE (ptr_mode));\n   emit_move_insn (mem, expand_normal (str_cst));\n@@ -1020,10 +1086,10 @@ asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n   shadow_base = expand_binop (Pmode, lshr_optab, base,\n \t\t\t      GEN_INT (ASAN_SHADOW_SHIFT),\n \t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n-  shadow_base = expand_binop (Pmode, add_optab, shadow_base,\n-\t\t\t      gen_int_mode (targetm.asan_shadow_offset (),\n-\t\t\t\t\t    Pmode),\n-\t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n+  shadow_base\n+    = plus_constant (Pmode, shadow_base,\n+\t\t     targetm.asan_shadow_offset ()\n+\t\t     + (base_align_bias >> ASAN_SHADOW_SHIFT));\n   gcc_assert (asan_shadow_set != -1\n \t      && (ASAN_RED_ZONE_SIZE >> ASAN_SHADOW_SHIFT) == 4);\n   shadow_mem = gen_rtx_MEM (SImode, shadow_base);\n@@ -1074,6 +1140,47 @@ asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n   /* Construct epilogue sequence.  */\n   start_sequence ();\n \n+  lab = NULL_RTX;  \n+  if (use_after_return_class != -1)\n+    {\n+      rtx lab2 = gen_label_rtx ();\n+      char c = (char) ASAN_STACK_MAGIC_USE_AFTER_RET;\n+      int very_likely = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1);\n+      emit_cmp_and_jump_insns (orig_base, base, EQ, NULL_RTX,\n+\t\t\t       VOIDmode, 0, lab2, very_likely);\n+      shadow_mem = gen_rtx_MEM (BLKmode, shadow_base);\n+      set_mem_alias_set (shadow_mem, asan_shadow_set);\n+      mem = gen_rtx_MEM (ptr_mode, base);\n+      mem = adjust_address (mem, VOIDmode, base_align_bias);\n+      emit_move_insn (mem, gen_int_mode (ASAN_STACK_RETIRED_MAGIC, ptr_mode));\n+      unsigned HOST_WIDE_INT sz = asan_frame_size >> ASAN_SHADOW_SHIFT;\n+      if (use_after_return_class < 5\n+\t  && can_store_by_pieces (sz, builtin_memset_read_str, &c,\n+\t\t\t\t  BITS_PER_UNIT, true))\n+\tstore_by_pieces (shadow_mem, sz, builtin_memset_read_str, &c,\n+\t\t\t BITS_PER_UNIT, true, 0);\n+      else if (use_after_return_class >= 5\n+\t       || !set_storage_via_setmem (shadow_mem,\n+\t\t\t\t\t   GEN_INT (sz),\n+\t\t\t\t\t   gen_int_mode (c, QImode),\n+\t\t\t\t\t   BITS_PER_UNIT, BITS_PER_UNIT,\n+\t\t\t\t\t   -1, sz, sz, sz))\n+\t{\n+\t  snprintf (buf, sizeof buf, \"__asan_stack_free_%d\",\n+\t\t    use_after_return_class);\n+\t  ret = init_one_libfunc (buf);\n+\t  rtx addr = convert_memory_address (ptr_mode, base);\n+\t  rtx orig_addr = convert_memory_address (ptr_mode, orig_base);\n+\t  emit_library_call (ret, LCT_NORMAL, ptr_mode, 3, addr, ptr_mode,\n+\t\t\t     GEN_INT (asan_frame_size + base_align_bias),\n+\t\t\t     TYPE_MODE (pointer_sized_int_node),\n+\t\t\t     orig_addr, ptr_mode);\n+\t}\n+      lab = gen_label_rtx ();\n+      emit_jump (lab);\n+      emit_label (lab2);\n+    }\n+\n   shadow_mem = gen_rtx_MEM (BLKmode, shadow_base);\n   set_mem_alias_set (shadow_mem, asan_shadow_set);\n   prev_offset = base_offset;\n@@ -1106,6 +1213,8 @@ asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n     }\n \n   do_pending_stack_adjust ();\n+  if (lab)\n+    emit_label (lab);\n \n   ret = get_insns ();\n   end_sequence ();"}, {"sha": "42383c48525b2ee7009686a701595a1fe081fe76", "filename": "gcc/asan.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e361382f655dcba3b6538d9157c6d378db57158b/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e361382f655dcba3b6538d9157c6d378db57158b/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=e361382f655dcba3b6538d9157c6d378db57158b", "patch": "@@ -23,7 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n \n extern void asan_function_start (void);\n extern void asan_finish_file (void);\n-extern rtx asan_emit_stack_protection (rtx, HOST_WIDE_INT *, tree *, int);\n+extern rtx asan_emit_stack_protection (rtx, rtx, unsigned int, HOST_WIDE_INT *,\n+\t\t\t\t       tree *, int);\n extern bool asan_protect_global (tree);\n extern void initialize_sanitizer_builtins (void);\n extern tree asan_dynamic_init_call (bool);\n@@ -49,8 +50,10 @@ extern alias_set_type asan_shadow_set;\n #define ASAN_STACK_MAGIC_MIDDLE\t\t0xf2\n #define ASAN_STACK_MAGIC_RIGHT\t\t0xf3\n #define ASAN_STACK_MAGIC_PARTIAL\t0xf4\n+#define ASAN_STACK_MAGIC_USE_AFTER_RET\t0xf5\n \n-#define ASAN_STACK_FRAME_MAGIC\t0x41b58ab3\n+#define ASAN_STACK_FRAME_MAGIC\t\t0x41b58ab3\n+#define ASAN_STACK_RETIRED_MAGIC\t0x45e0360e\n \n /* Return true if DECL should be guarded on the stack.  */\n "}, {"sha": "622b7ea7fa2a9749b267e4aa0af8eacf39273a6e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e361382f655dcba3b6538d9157c6d378db57158b/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e361382f655dcba3b6538d9157c6d378db57158b/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=e361382f655dcba3b6538d9157c6d378db57158b", "patch": "@@ -890,6 +890,12 @@ struct stack_vars_data\n \n   /* Vector of partition representative decls in between the paddings.  */\n   vec<tree> asan_decl_vec;\n+\n+  /* Base pseudo register for Address Sanitizer protected automatic vars.  */\n+  rtx asan_base;\n+\n+  /* Alignment needed for the Address Sanitizer protected automatic vars.  */\n+  unsigned int asan_alignb;\n };\n \n /* A subroutine of expand_used_vars.  Give each partition representative\n@@ -974,6 +980,7 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n       alignb = stack_vars[i].alignb;\n       if (alignb * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n \t{\n+\t  base = virtual_stack_vars_rtx;\n \t  if ((flag_sanitize & SANITIZE_ADDRESS) && pred)\n \t    {\n \t      HOST_WIDE_INT prev_offset = frame_offset;\n@@ -1002,10 +1009,13 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \t      if (repr_decl == NULL_TREE)\n \t\trepr_decl = stack_vars[i].decl;\n \t      data->asan_decl_vec.safe_push (repr_decl);\n+\t      data->asan_alignb = MAX (data->asan_alignb, alignb);\n+\t      if (data->asan_base == NULL)\n+\t\tdata->asan_base = gen_reg_rtx (Pmode);\n+\t      base = data->asan_base;\n \t    }\n \t  else\n \t    offset = alloc_stack_frame_space (stack_vars[i].size, alignb);\n-\t  base = virtual_stack_vars_rtx;\n \t  base_align = crtl->max_used_stack_slot_alignment;\n \t}\n       else\n@@ -1792,6 +1802,8 @@ expand_used_vars (void)\n \n       data.asan_vec = vNULL;\n       data.asan_decl_vec = vNULL;\n+      data.asan_base = NULL_RTX;\n+      data.asan_alignb = 0;\n \n       /* Reorder decls to be protected by iterating over the variables\n \t array multiple times, and allocating out of each phase in turn.  */\n@@ -1816,16 +1828,25 @@ expand_used_vars (void)\n       if (!data.asan_vec.is_empty ())\n \t{\n \t  HOST_WIDE_INT prev_offset = frame_offset;\n-\t  HOST_WIDE_INT offset\n-\t    = alloc_stack_frame_space (ASAN_RED_ZONE_SIZE,\n-\t\t\t\t       ASAN_RED_ZONE_SIZE);\n+\t  HOST_WIDE_INT offset, sz, redzonesz;\n+\t  redzonesz = ASAN_RED_ZONE_SIZE;\n+\t  sz = data.asan_vec[0] - prev_offset;\n+\t  if (data.asan_alignb > ASAN_RED_ZONE_SIZE\n+\t      && data.asan_alignb <= 4096\n+\t      && sz + ASAN_RED_ZONE_SIZE >= data.asan_alignb)\n+\t    redzonesz = ((sz + ASAN_RED_ZONE_SIZE + data.asan_alignb - 1)\n+\t\t\t & ~(data.asan_alignb - HOST_WIDE_INT_1)) - sz;\n+\t  offset\n+\t    = alloc_stack_frame_space (redzonesz, ASAN_RED_ZONE_SIZE);\n \t  data.asan_vec.safe_push (prev_offset);\n \t  data.asan_vec.safe_push (offset);\n \n \t  var_end_seq\n \t    = asan_emit_stack_protection (virtual_stack_vars_rtx,\n+\t\t\t\t\t  data.asan_base,\n+\t\t\t\t\t  data.asan_alignb,\n \t\t\t\t\t  data.asan_vec.address (),\n-\t\t\t\t\t  data.asan_decl_vec. address (),\n+\t\t\t\t\t  data.asan_decl_vec.address (),\n \t\t\t\t\t  data.asan_vec.length ());\n \t}\n "}]}