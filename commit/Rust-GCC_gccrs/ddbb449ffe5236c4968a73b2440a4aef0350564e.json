{"sha": "ddbb449ffe5236c4968a73b2440a4aef0350564e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRiYjQ0OWZmZTUyMzZjNDk2OGE3M2IyNDQwYTRhZWYwMzUwNTY0ZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2014-06-06T01:04:22Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2014-06-06T01:04:22Z"}, "message": "re PR target/61300 (powerpc64le miscompile with K&R-style function definition at -O0)\n\n\tPR target/61300\n\t* doc/tm.texi.in (INCOMING_REG_PARM_STACK_SPACE): Document.\n\t* doc/tm.texi: Regenerate.\n\t* function.c (INCOMING_REG_PARM_STACK_SPACE): Provide default.\n\tUse throughout in place of REG_PARM_STACK_SPACE.\n\t* config/rs6000/rs6000.c (rs6000_reg_parm_stack_space): Add\n\t\"incoming\" param.  Pass to rs6000_function_parms_need_stack.\n\t(rs6000_function_parms_need_stack): Add \"incoming\" param, ignore\n\tprototype_p when incoming.  Use function decl when incoming\n\tto handle K&R style functions.\n\t* config/rs6000/rs6000.h (REG_PARM_STACK_SPACE): Adjust.\n\t(INCOMING_REG_PARM_STACK_SPACE): Define.\n\nFrom-SVN: r211296", "tree": {"sha": "23c342a3de8e01fa8b6546969fa6002664b39812", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23c342a3de8e01fa8b6546969fa6002664b39812"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddbb449ffe5236c4968a73b2440a4aef0350564e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddbb449ffe5236c4968a73b2440a4aef0350564e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddbb449ffe5236c4968a73b2440a4aef0350564e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddbb449ffe5236c4968a73b2440a4aef0350564e/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "424ce7d729c3bdb240615b36052f75c6ac852943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/424ce7d729c3bdb240615b36052f75c6ac852943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/424ce7d729c3bdb240615b36052f75c6ac852943"}], "stats": {"total": 113, "additions": 92, "deletions": 21}, "files": [{"sha": "af977a09fdcc1d44d5200d465c3ecef78817980b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddbb449ffe5236c4968a73b2440a4aef0350564e", "patch": "@@ -1,3 +1,18 @@\n+2014-06-06  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/61300\n+\t* doc/tm.texi.in (INCOMING_REG_PARM_STACK_SPACE): Document.\n+\t* doc/tm.texi: Regenerate.\n+\t* function.c (INCOMING_REG_PARM_STACK_SPACE): Provide default.\n+\tUse throughout in place of REG_PARM_STACK_SPACE.\n+\t* config/rs6000/rs6000.c (rs6000_reg_parm_stack_space): Add\n+\t\"incoming\" param.  Pass to rs6000_function_parms_need_stack.\n+\t(rs6000_function_parms_need_stack): Add \"incoming\" param, ignore\n+\tprototype_p when incoming.  Use function decl when incoming\n+\tto handle K&R style functions.\n+\t* config/rs6000/rs6000.h (REG_PARM_STACK_SPACE): Adjust.\n+\t(INCOMING_REG_PARM_STACK_SPACE): Define.\n+\n 2014-06-05  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>\n \n \tPR target/52472"}, {"sha": "07d84db45e15d5744c639165d3e4f26be2bbe4e9", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=ddbb449ffe5236c4968a73b2440a4aef0350564e", "patch": "@@ -163,7 +163,7 @@ extern tree altivec_resolve_overloaded_builtin (location_t, tree, void *);\n extern rtx rs6000_libcall_value (enum machine_mode);\n extern rtx rs6000_va_arg (tree, tree);\n extern int function_ok_for_sibcall (tree);\n-extern int rs6000_reg_parm_stack_space (tree);\n+extern int rs6000_reg_parm_stack_space (tree, bool);\n extern void rs6000_elf_declare_function_name (FILE *, const char *, tree);\n extern bool rs6000_elf_in_small_data_p (const_tree);\n #ifdef ARGS_SIZE_RTX"}, {"sha": "e264e94008bd897706129c0b1bfa4b92d5b5213c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ddbb449ffe5236c4968a73b2440a4aef0350564e", "patch": "@@ -10479,35 +10479,65 @@ rs6000_parm_needs_stack (cumulative_args_t args_so_far, tree type)\n    list, or passes any parameter in memory.  */\n \n static bool\n-rs6000_function_parms_need_stack (tree fun)\n+rs6000_function_parms_need_stack (tree fun, bool incoming)\n {\n-  function_args_iterator args_iter;\n-  tree arg_type;\n+  tree fntype, result;\n   CUMULATIVE_ARGS args_so_far_v;\n   cumulative_args_t args_so_far;\n \n   if (!fun)\n     /* Must be a libcall, all of which only use reg parms.  */\n     return false;\n+\n+  fntype = fun;\n   if (!TYPE_P (fun))\n-    fun = TREE_TYPE (fun);\n+    fntype = TREE_TYPE (fun);\n \n   /* Varargs functions need the parameter save area.  */\n-  if (!prototype_p (fun) || stdarg_p (fun))\n+  if ((!incoming && !prototype_p (fntype)) || stdarg_p (fntype))\n     return true;\n \n-  INIT_CUMULATIVE_INCOMING_ARGS (args_so_far_v, fun, NULL_RTX);\n+  INIT_CUMULATIVE_INCOMING_ARGS (args_so_far_v, fntype, NULL_RTX);\n   args_so_far = pack_cumulative_args (&args_so_far_v);\n \n-  if (aggregate_value_p (TREE_TYPE (fun), fun))\n+  /* When incoming, we will have been passed the function decl.\n+     It is necessary to use the decl to handle K&R style functions,\n+     where TYPE_ARG_TYPES may not be available.  */\n+  if (incoming)\n     {\n-      tree type = build_pointer_type (TREE_TYPE (fun));\n-      rs6000_parm_needs_stack (args_so_far, type);\n+      gcc_assert (DECL_P (fun));\n+      result = DECL_RESULT (fun);\n     }\n+  else\n+    result = TREE_TYPE (fntype);\n \n-  FOREACH_FUNCTION_ARGS (fun, arg_type, args_iter)\n-    if (rs6000_parm_needs_stack (args_so_far, arg_type))\n-      return true;\n+  if (result && aggregate_value_p (result, fntype))\n+    {\n+      if (!TYPE_P (result))\n+\tresult = TREE_TYPE (result);\n+      result = build_pointer_type (result);\n+      rs6000_parm_needs_stack (args_so_far, result);\n+    }\n+\n+  if (incoming)\n+    {\n+      tree parm;\n+\n+      for (parm = DECL_ARGUMENTS (fun);\n+\t   parm && parm != void_list_node;\n+\t   parm = TREE_CHAIN (parm))\n+\tif (rs6000_parm_needs_stack (args_so_far, TREE_TYPE (parm)))\n+\t  return true;\n+    }\n+  else\n+    {\n+      function_args_iterator args_iter;\n+      tree arg_type;\n+\n+      FOREACH_FUNCTION_ARGS (fntype, arg_type, args_iter)\n+\tif (rs6000_parm_needs_stack (args_so_far, arg_type))\n+\t  return true;\n+    }\n \n   return false;\n }\n@@ -10519,7 +10549,7 @@ rs6000_function_parms_need_stack (tree fun)\n    all parameters in registers.  */\n \n int\n-rs6000_reg_parm_stack_space (tree fun)\n+rs6000_reg_parm_stack_space (tree fun, bool incoming)\n {\n   int reg_parm_stack_space;\n \n@@ -10537,7 +10567,7 @@ rs6000_reg_parm_stack_space (tree fun)\n     case ABI_ELFv2:\n       /* ??? Recomputing this every time is a bit expensive.  Is there\n \t a place to cache this information?  */\n-      if (rs6000_function_parms_need_stack (fun))\n+      if (rs6000_function_parms_need_stack (fun, incoming))\n \treg_parm_stack_space = TARGET_64BIT ? 64 : 32;\n       else\n \treg_parm_stack_space = 0;"}, {"sha": "f01143ce21e4d93a8d96e3f754cb770855969568", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=ddbb449ffe5236c4968a73b2440a4aef0350564e", "patch": "@@ -1602,7 +1602,14 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n /* Define this if stack space is still allocated for a parameter passed\n    in a register.  The value is the number of bytes allocated to this\n    area.  */\n-#define REG_PARM_STACK_SPACE(FNDECL) rs6000_reg_parm_stack_space((FNDECL))\n+#define REG_PARM_STACK_SPACE(FNDECL) \\\n+  rs6000_reg_parm_stack_space ((FNDECL), false)\n+\n+/* Define this macro if space guaranteed when compiling a function body\n+   is different to space required when making a call, a situation that\n+   can arise with K&R style function definitions.  */\n+#define INCOMING_REG_PARM_STACK_SPACE(FNDECL) \\\n+  rs6000_reg_parm_stack_space ((FNDECL), true)\n \n /* Define this if the above stack space is to be considered part of the\n    space allocated by the caller.  */"}, {"sha": "c27263077b1633759d470c996c42cbcd73fa7869", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ddbb449ffe5236c4968a73b2440a4aef0350564e", "patch": "@@ -3799,6 +3799,13 @@ which.\n @c above is overfull.  not sure what to do.  --mew 5feb93  did\n @c something, not sure if it looks good.  --mew 10feb93\n \n+@defmac INCOMING_REG_PARM_STACK_SPACE (@var{fndecl})\n+Like @code{REG_PARM_STACK_SPACE}, but for incoming register arguments.\n+Define this macro if space guaranteed when compiling a function body\n+is different to space required when making a call, a situation that\n+can arise with K&R style function definitions.\n+@end defmac\n+\n @defmac OUTGOING_REG_PARM_STACK_SPACE (@var{fntype})\n Define this to a nonzero value if it is the responsibility of the\n caller to allocate the area reserved for arguments passed in registers"}, {"sha": "dd72b985d042bcdc56e8de5fd1b7f3b322ff4194", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=ddbb449ffe5236c4968a73b2440a4aef0350564e", "patch": "@@ -3351,6 +3351,13 @@ which.\n @c above is overfull.  not sure what to do.  --mew 5feb93  did\n @c something, not sure if it looks good.  --mew 10feb93\n \n+@defmac INCOMING_REG_PARM_STACK_SPACE (@var{fndecl})\n+Like @code{REG_PARM_STACK_SPACE}, but for incoming register arguments.\n+Define this macro if space guaranteed when compiling a function body\n+is different to space required when making a call, a situation that\n+can arise with K&R style function definitions.\n+@end defmac\n+\n @defmac OUTGOING_REG_PARM_STACK_SPACE (@var{fntype})\n Define this to a nonzero value if it is the responsibility of the\n caller to allocate the area reserved for arguments passed in registers"}, {"sha": "a85ad462a7d087fddd198a6c035867fbba24a7cf", "filename": "gcc/function.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbb449ffe5236c4968a73b2440a4aef0350564e/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ddbb449ffe5236c4968a73b2440a4aef0350564e", "patch": "@@ -1348,9 +1348,13 @@ static int cfa_offset;\n #define STACK_POINTER_OFFSET\t0\n #endif\n \n+#if defined (REG_PARM_STACK_SPACE) && !defined (INCOMING_REG_PARM_STACK_SPACE)\n+#define INCOMING_REG_PARM_STACK_SPACE REG_PARM_STACK_SPACE\n+#endif\n+\n /* If not defined, pick an appropriate default for the offset of dynamically\n    allocated memory depending on the value of ACCUMULATE_OUTGOING_ARGS,\n-   REG_PARM_STACK_SPACE, and OUTGOING_REG_PARM_STACK_SPACE.  */\n+   INCOMING_REG_PARM_STACK_SPACE, and OUTGOING_REG_PARM_STACK_SPACE.  */\n \n #ifndef STACK_DYNAMIC_OFFSET\n \n@@ -1362,12 +1366,12 @@ static int cfa_offset;\n    `crtl->outgoing_args_size'.  Nevertheless, we must allow\n    for it when allocating stack dynamic objects.  */\n \n-#if defined(REG_PARM_STACK_SPACE)\n+#ifdef INCOMING_REG_PARM_STACK_SPACE\n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n ((ACCUMULATE_OUTGOING_ARGS\t\t\t\t\t\t      \\\n   ? (crtl->outgoing_args_size\t\t\t\t      \\\n      + (OUTGOING_REG_PARM_STACK_SPACE ((!(FNDECL) ? NULL_TREE : TREE_TYPE (FNDECL))) ? 0 \\\n-\t\t\t\t\t       : REG_PARM_STACK_SPACE (FNDECL))) \\\n+\t\t\t\t\t       : INCOMING_REG_PARM_STACK_SPACE (FNDECL))) \\\n   : 0) + (STACK_POINTER_OFFSET))\n #else\n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n@@ -2224,8 +2228,9 @@ assign_parms_initialize_all (struct assign_parm_data_all *all)\n #endif\n   all->args_so_far = pack_cumulative_args (&all->args_so_far_v);\n \n-#ifdef REG_PARM_STACK_SPACE\n-  all->reg_parm_stack_space = REG_PARM_STACK_SPACE (current_function_decl);\n+#ifdef INCOMING_REG_PARM_STACK_SPACE\n+  all->reg_parm_stack_space\n+    = INCOMING_REG_PARM_STACK_SPACE (current_function_decl);\n #endif\n }\n "}]}