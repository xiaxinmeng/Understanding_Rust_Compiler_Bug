{"sha": "4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRmOWM0MWRlNWNhNWEzYTNkNmIyN2QzOTQ1ZTJkOTQwMWYxMTVjNQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-05-03T12:14:07Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-05-03T12:14:07Z"}, "message": "Optimize locale::_M_impl->_M_names for the most common cases...\n\n2004-05-03  Paolo Carlini  <pcarlini@suse.de>\n\n\tOptimize locale::_M_impl->_M_names for the most common cases:\n\t!_M_names[0] means unnamed; !_M_names[1] means all the categories\n\tthe same name (_M_names[0] && _M_names[1] means that the full set\n\tof _M_names must be processed, the general case).\n\t* include/bits/locale_classes.h (locale::_Impl::_M_check_same_name):\n\tTweak, saving work when !_M_names[1].\n\t(locale::locale(const locale&, _Facet*): Simplify: now just setting\n\t_M_names[0] = 0 means unnamed.\n\t* src/locale.cc (locale::operator==): Deal first with the common,\n\teasy cases, otherwise fall back to locale::name().\n\t(locale::name()): Tweak, if !_M_names[0] just return \"*\".\n\t(locale::_Impl::_Impl(const _Impl&, size_t): Tweak, early stop\n\tcopying __imp._M_names if !__imp._M_names[0] or !__imp._M_names[1].\n\t* src/locale_init.cc (locale::_Impl::_Impl(size_t)): Tweak.\n\t* src/localename.cc (locale::_Impl::_Impl(const char*, size_t):\n\tSimplify when !std::strchr, just updating _M_names[0]; clean up.\n\t(locale::_Impl::_M_replace_categories): When !_M_names[1] prepare\n\tfor the general case (full set of names), then do the usual work;\n\tclean up.\n\n\t* src/locale.cc (locale::name()): Reserve space in __ret.\n\t* src/locale_init.cc (locale::global(const locale&)): Save\n\tthe name in a temporary.\n\t* src/localename.cc (locale::locale(const char*)): Reserve space\n\tin __str.\n\nFrom-SVN: r81430", "tree": {"sha": "adeda0cd9647262ca6172ca50e4e8ce89f154b80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adeda0cd9647262ca6172ca50e4e8ce89f154b80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5/comments", "author": null, "committer": null, "parents": [{"sha": "9f4fd324ab932c0fbb3bf28f7230f17236ba2daa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f4fd324ab932c0fbb3bf28f7230f17236ba2daa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f4fd324ab932c0fbb3bf28f7230f17236ba2daa"}], "stats": {"total": 156, "additions": 96, "deletions": 60}, "files": [{"sha": "ba311c5242a3d5c803dc6393b688ca0e129e8b77", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5", "patch": "@@ -1,3 +1,31 @@\n+2004-05-03  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tOptimize locale::_M_impl->_M_names for the most common cases:\n+\t!_M_names[0] means unnamed; !_M_names[1] means all the categories\n+\tthe same name (_M_names[0] && _M_names[1] means that the full set\n+\tof _M_names must be processed, the general case).\n+\t* include/bits/locale_classes.h (locale::_Impl::_M_check_same_name):\n+\tTweak, saving work when !_M_names[1].\n+\t(locale::locale(const locale&, _Facet*): Simplify: now just setting\n+\t_M_names[0] = 0 means unnamed.\n+\t* src/locale.cc (locale::operator==): Deal first with the common,\n+\teasy cases, otherwise fall back to locale::name().\n+\t(locale::name()): Tweak, if !_M_names[0] just return \"*\".\n+\t(locale::_Impl::_Impl(const _Impl&, size_t): Tweak, early stop\n+\tcopying __imp._M_names if !__imp._M_names[0] or !__imp._M_names[1].\n+\t* src/locale_init.cc (locale::_Impl::_Impl(size_t)): Tweak.\n+\t* src/localename.cc (locale::_Impl::_Impl(const char*, size_t):\n+\tSimplify when !std::strchr, just updating _M_names[0]; clean up.\n+\t(locale::_Impl::_M_replace_categories): When !_M_names[1] prepare\n+\tfor the general case (full set of names), then do the usual work;\n+\tclean up.\n+\n+\t* src/locale.cc (locale::name()): Reserve space in __ret.\n+\t* src/locale_init.cc (locale::global(const locale&)): Save\n+\tthe name in a temporary.\n+\t* src/localename.cc (locale::locale(const char*)): Reserve space\n+\tin __str.\n+\n 2004-04-29  Paolo Carlini  <pcarlini@suse.de>\n \n \t* src/locale.cc (locale::operator==): Always avoid constructing"}, {"sha": "5366d6524336e1c693e7b2dbc2dec1cb12973cfb", "filename": "libstdc++-v3/include/bits/locale_classes.h", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h?ref=4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5", "patch": "@@ -534,8 +534,10 @@ namespace std\n     _M_check_same_name()\n     {\n       bool __ret = true;\n-      for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)\n-\t__ret = std::strcmp(_M_names[__i], _M_names[__i + 1]) == 0;\n+      if (_M_names[1])\n+\t// We must actually compare all the _M_names: can be all equal!\n+\tfor (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)\n+\t  __ret = std::strcmp(_M_names[__i], _M_names[__i + 1]) == 0;\n       return __ret;\n     }\n \n@@ -569,30 +571,15 @@ namespace std\n     {\n       _M_impl = new _Impl(*__other._M_impl, 1);\n \n-      char* _M_tmp_names[_S_categories_size];\n-      size_t __i = 0;\n       try\n-\t{\n-\t  for (; __i < _S_categories_size; ++__i)\n-\t    {\n-\t      _M_tmp_names[__i] = new char[2];\n-\t      std::strcpy(_M_tmp_names[__i], \"*\");\n-\t    }\n-\t  _M_impl->_M_install_facet(&_Facet::id, __f);\n-\t}\n+\t{ _M_impl->_M_install_facet(&_Facet::id, __f); }\n       catch(...)\n \t{\n \t  _M_impl->_M_remove_reference();\n-\t  for (size_t __j = 0; __j < __i; ++__j)\n-\t    delete [] _M_tmp_names[__j];\n \t  __throw_exception_again;\n \t}\n-\n-      for (size_t __k = 0; __k < _S_categories_size; ++__k)\n-\t{\n-\t  delete [] _M_impl->_M_names[__k];\n-\t  _M_impl->_M_names[__k] = _M_tmp_names[__k];\n-\t}\n+      delete [] _M_impl->_M_names[0];\n+      _M_impl->_M_names[0] = 0;   // Unnamed.\n     }\n } // namespace std\n "}, {"sha": "64d0c6227aea6f4a0d7b30c54d578d729704f474", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5", "patch": "@@ -70,15 +70,21 @@ namespace std\n   bool\n   locale::operator==(const locale& __rhs) const throw()\n   {\n-    bool __ret = true;\n+    // Deal first with the common cases, fast to process: refcopies,\n+    // unnamed (i.e., !_M_names[0]), \"simple\" (!_M_names[1] => all the\n+    // categories same name, i.e., _M_names[0]). Otherwise fall back\n+    // to the general locale::name().\n+    bool __ret;\n     if (_M_impl == __rhs._M_impl)\n-      ;\n-    else if (!std::strcmp(_M_impl->_M_names[0], \"*\"))\n+      __ret = true;\n+    else if (!_M_impl->_M_names[0] || !__rhs._M_impl->_M_names[0]\n+\t     || std::strcmp(_M_impl->_M_names[0],\n+\t\t\t    __rhs._M_impl->_M_names[0]) != 0)\n       __ret = false;\n+    else if (!_M_impl->_M_names[1] && !__rhs._M_impl->_M_names[1])\n+      __ret = true;\n     else\n-      for (size_t __i = 0; __ret && __i < _S_categories_size; ++__i)\n-\t__ret = !std::strcmp(_M_impl->_M_names[__i],\n-\t\t\t     __rhs._M_impl->_M_names[__i]);\n+      __ret = this->name() == __rhs.name();\n     return __ret;\n   }\n \n@@ -95,10 +101,13 @@ namespace std\n   locale::name() const\n   {\n     string __ret;\n-    if (_M_impl->_M_check_same_name())\n+    if (!_M_impl->_M_names[0])\n+      __ret = '*';\n+    else if (_M_impl->_M_check_same_name())\n       __ret = _M_impl->_M_names[0];\n     else\n       {\n+\t__ret.reserve(128);\n \t__ret += _S_categories[0];\n \t__ret += '=';\n \t__ret += _M_impl->_M_names[0]; \n@@ -242,12 +251,13 @@ namespace std\n \tfor (size_t __i = 0; __i < _S_categories_size; ++__i)\n \t  _M_names[__i] = 0;\n \n-\t// Name all the categories.\n-\tfor (size_t __i = 0; __i < _S_categories_size; ++__i)\n+\t// Name the categories.\n+\tfor (size_t __i = 0; (__i < _S_categories_size\n+\t\t\t      && __imp._M_names[__i]); ++__i)\n \t  {\n-\t    char* __new = new char[std::strlen(__imp._M_names[__i]) + 1];\n-\t    std::strcpy(__new, __imp._M_names[__i]);\n-\t    _M_names[__i] = __new;\n+\t    const size_t __len = std::strlen(__imp._M_names[__i]) + 1;\n+\t    _M_names[__i] = new char[__len];\n+\t    std::memcpy(_M_names[__i], __imp._M_names[__i], __len);\n \t  }\n       }\n     catch(...)\n@@ -354,7 +364,6 @@ namespace std\n       }\n   }\n \n-\n   // locale::id\n   // Definitions for static const data members of locale::id\n   _Atomic_word locale::id::_S_refcount;  // init'd to 0 by linker"}, {"sha": "d5a337f5b3716603f0ffe39482b822a38cb51d06", "filename": "libstdc++-v3/src/locale_init.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc?ref=4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5", "patch": "@@ -114,9 +114,10 @@ namespace std\n     __glibcxx_mutex_lock(__gnu_internal::locale_global_mutex);\n     _Impl* __old = _S_global;\n     __other._M_impl->_M_add_reference();\n-    _S_global = __other._M_impl; \n-    if (__other.name() != \"*\")\n-      setlocale(LC_ALL, __other.name().c_str());\n+    _S_global = __other._M_impl;\n+    const string __other_name = __other.name();\n+    if (__other_name != \"*\")\n+      setlocale(LC_ALL, __other_name.c_str());\n    __glibcxx_mutex_unlock(__gnu_internal::locale_global_mutex);\n \n     // Reference count sanity check: one reference removed for the\n@@ -255,13 +256,12 @@ namespace std\n     for (size_t __i = 0; __i < _M_facets_size; ++__i)\n       _M_facets[__i] = _M_caches[__i] = 0;\n \n-    // Name all the categories.\n+    // Name the categories.\n     _M_names = new (&name_vec) char*[_S_categories_size];\n-    for (size_t __i = 0; __i < _S_categories_size; ++__i)\n-      {\n-\t_M_names[__i] = new (&name_c[__i]) char[2];\n-\tstd::strcpy(_M_names[__i], locale::facet::_S_get_c_name());\n-      }\n+    _M_names[0] = new (&name_c[0]) char[2];\n+    std::memcpy(_M_names[0], locale::facet::_S_get_c_name(), 2);\n+    for (size_t __i = 1; __i < _S_categories_size; ++__i)\n+      _M_names[__i] = 0;\n \n     // This is needed as presently the C++ version of \"C\" locales\n     // != data in the underlying locale model for __timepunct,"}, {"sha": "ca09b065156903c3dbbe9b22673b01a7d745986f", "filename": "libstdc++-v3/src/localename.cc", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc?ref=4df9c41de5ca5a3a3d6b27d3945e2d9401f115c5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -34,7 +34,6 @@ namespace std\n {\n   using namespace __gnu_cxx;\n \n-  \n   locale::locale(const char* __s)\n   {\n     if (__s)\n@@ -95,6 +94,7 @@ namespace std\n \t\tif (__i < _S_categories_size)\n \t\t  {\n \t\t    string __str;\n+\t\t    __str.reserve(128);\n \t\t    for (size_t __j = 0; __j < __i; ++__j)\n \t\t      {\n \t\t\t__str += _S_categories[__j];\n@@ -199,15 +199,12 @@ namespace std\n \tfor (size_t __i = 0; __i < _S_categories_size; ++__i)\n \t  _M_names[__i] = 0;\n \n-\t// Name all the categories.\n+\t// Name the categories.\n \tconst size_t __len = std::strlen(__s);\n \tif (!std::strchr(__s, ';'))\n \t  {\n-\t    for (size_t __i = 0; __i < _S_categories_size; ++__i)\n-\t      {\n-\t\t_M_names[__i] = new char[__len + 1];\n-\t\tstd::strcpy(_M_names[__i], __s);\n-\t      }\n+\t    _M_names[0] = new char[__len + 1];\n+\t    std::memcpy(_M_names[0], __s, __len + 1);\t    \n \t  }\n \telse\n \t  {\n@@ -218,10 +215,9 @@ namespace std\n \t\tconst char* __end = std::strchr(__beg, ';');\n \t\tif (!__end)\n \t\t  __end = __s + __len;\n-\t\tchar* __new = new char[__end - __beg + 1];\n-\t\tstd::memcpy(__new, __beg, __end - __beg);\n-\t\t__new[__end - __beg] = '\\0';\n-\t\t_M_names[__i] = __new;\n+\t\t_M_names[__i] = new char[__end - __beg + 1];\n+\t\tstd::memcpy(_M_names[__i], __beg, __end - __beg);\n+\t\t_M_names[__i][__end - __beg] = '\\0';\n \t      }\n \t  }\n  \n@@ -271,19 +267,35 @@ namespace std\n   locale::_Impl::\n   _M_replace_categories(const _Impl* __imp, category __cat)\n   {\n-    for (size_t __ix = 0; __ix < _S_categories_size; ++__ix)\n+    category __mask = 1;\n+    const bool __have_names = _M_names[0] && __imp->_M_names[0];\n+    for (size_t __ix = 0; __ix < _S_categories_size; ++__ix, __mask <<= 1)\n       {\n-\tconst category __mask = 1 << __ix;\n \tif (__mask & __cat)\n \t  {\n \t    // Need to replace entry in _M_facets with other locale's info.\n \t    _M_replace_category(__imp, _S_facet_categories[__ix]);\n \t    // If both have names, go ahead and mangle.\n-\t    if (std::strcmp(_M_names[__ix], \"*\") != 0 \n-\t\t&& std::strcmp(__imp->_M_names[__ix], \"*\") != 0)\n+\t    if (__have_names)\n \t      {\n-\t\tchar* __new = new char[std::strlen(__imp->_M_names[__ix]) + 1];\n-\t\tstd::strcpy(__new, __imp->_M_names[__ix]);\n+\t\tif (!_M_names[1])\n+\t\t  {\n+\t\t    // A full set of _M_names must be prepared, all identical\n+\t\t    // to _M_names[0] to begin with. Then, below, a few will\n+\t\t    // be replaced by the corresponding __imp->_M_names. I.e.,\n+\t\t    // not a \"simple\" locale anymore (see locale::operator==).\n+\t\t    const size_t __len = std::strlen(_M_names[0]) + 1;\n+\t\t    for (size_t __i = 1; __i < _S_categories_size; ++__i)\n+\t\t      {\n+\t\t\t_M_names[__i] = new char[__len];\n+\t\t\tstd::memcpy(_M_names[__i], _M_names[0], __len);\n+\t\t      }\n+\t\t  }\n+\t\tchar* __src = __imp->_M_names[__ix] ? __imp->_M_names[__ix]\n+\t\t                                    : __imp->_M_names[0];\n+\t\tconst size_t __len = std::strlen(__src) + 1;\n+\t\tchar* __new = new char[__len];\n+\t\tstd::memcpy(__new, __src, __len);\n \t\tdelete [] _M_names[__ix];\n \t\t_M_names[__ix] = __new;\n \t      }"}]}