{"sha": "d720518f39c7716e3fe21fb4976b5b25d6365d20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcyMDUxOGYzOWM3NzE2ZTNmZTIxZmI0OTc2YjViMjVkNjM2NWQyMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-10-22T03:09:41Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-10-22T03:09:41Z"}, "message": "lock-and-run.sh: Check for process existence rather than timeout.\n\n\t* lock-and-run.sh: Check for process existence rather than timeout.\n\nMatthias Klose noted that on less powerful targets, a link might take more\nthan 5 minutes; he mentions a figure of 3 hours for an LTO link.  So this\npatch changes the timeout to a check for whether the locking process still\nexists.  If the lock exists in an erroneous state (no pid file or can't\nsignal the pid) for 30 sec, steal it.\n\nFrom-SVN: r277277", "tree": {"sha": "081e576bd7106d08adef95d482eaf850883fc051", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/081e576bd7106d08adef95d482eaf850883fc051"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d720518f39c7716e3fe21fb4976b5b25d6365d20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d720518f39c7716e3fe21fb4976b5b25d6365d20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d720518f39c7716e3fe21fb4976b5b25d6365d20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d720518f39c7716e3fe21fb4976b5b25d6365d20/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0bfdd2d4f97ee20288137f2ef8e510ba531d2b65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bfdd2d4f97ee20288137f2ef8e510ba531d2b65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bfdd2d4f97ee20288137f2ef8e510ba531d2b65"}], "stats": {"total": 44, "additions": 32, "deletions": 12}, "files": [{"sha": "5e6c6620d17364cb468f08463d3cbd770c0a2ad6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d720518f39c7716e3fe21fb4976b5b25d6365d20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d720518f39c7716e3fe21fb4976b5b25d6365d20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d720518f39c7716e3fe21fb4976b5b25d6365d20", "patch": "@@ -1,3 +1,7 @@\n+2019-10-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* lock-and-run.sh: Check for process existence rather than timeout.\n+\n 2019-10-21  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* expr.c (expand_expr_real_2): Don't widen constant op1 when expanding"}, {"sha": "22bc436565cc0dee76202a3248cdc3ad253642a1", "filename": "gcc/lock-and-run.sh", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d720518f39c7716e3fe21fb4976b5b25d6365d20/gcc%2Flock-and-run.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d720518f39c7716e3fe21fb4976b5b25d6365d20/gcc%2Flock-and-run.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flock-and-run.sh?ref=d720518f39c7716e3fe21fb4976b5b25d6365d20", "patch": "@@ -1,33 +1,49 @@\n #! /bin/sh\n-# Shell-based mutex using mkdir.\n+# Shell-based mutex using mkdir.  This script is used in make to prefer\n+# serialized execution to avoid consuming too much RAM.  If reusing it,\n+# bear in mind that the lock-breaking logic is not race-free, so disable\n+# it in err() if concurrent execution could cause more serious problems.\n \n+self=`basename $0`\n lockdir=\"$1\" prog=\"$2\"; shift 2 || exit 1\n \n # Remember when we started trying to acquire the lock.\n count=0\n-touch lock-stamp.$$\n \n-trap 'rm -r \"$lockdir\" lock-stamp.$$' 0\n+err () {\n+    if test -f $lockdir/lock-$1.$$; then\n+\techo \"$self: *** (PID $$) removing stale $lockdir\" >&2\n+\trm -rf $lockdir\n+\t# Possible variant for uses where races are more problematic:\n+\t#echo \"$self: *** (PID $$) giving up, maybe rm -r $lockdir\" >&2\n+\t#exit 42\n+    else\n+\ttouch $lockdir/lock-$1.$$\n+    fi\n+}\n \n until mkdir \"$lockdir\" 2>/dev/null; do\n     # Say something periodically so the user knows what's up.\n     if [ `expr $count % 30` = 0 ]; then\n-\t# Reset if the lock has been renewed.\n-\tif [ -n \"`find \\\"$lockdir\\\" -newer lock-stamp.$$`\" ]; then\n-\t    touch lock-stamp.$$\n-\t    count=1\n-\t# Steal the lock after 5 minutes.\n-\telif [ $count = 300 ]; then\n-\t    echo removing stale $lockdir >&2\n-\t    rm -r \"$lockdir\"\n+\t# Check for valid lock.\n+\tif pid=`cat $lockdir/pid 2>/dev/null` && kill -0 $pid 2>/dev/null; then\n+\t    echo \"$self: (PID $$) waiting $count sec to acquire $lockdir from PID $pid\" >&2\n+\telif test -z \"$pid\"; then\n+\t    echo \"$self: (PID $$) cannot read $lockdir/pid\" >&2\n+\t    err nopid\n \telse\n-\t    echo waiting to acquire $lockdir >&2\n+\t    echo \"$self: (PID $$) cannot signal $lockdir owner PID $pid\" >&2\n+\t    err dead\n \tfi\n     fi\n     sleep 1\n     count=`expr $count + 1`\n done\n \n+trap 'rm -rf \"$lockdir\"' 0\n+echo $$ > $lockdir/pidT && mv $lockdir/pidT $lockdir/pid\n+echo \"$self: (PID $$) acquired $lockdir after $count seconds\" >&2\n+\n echo $prog \"$@\"\n $prog \"$@\"\n "}]}