{"sha": "5dcfdccd32b5b06a29caf45469203c67da526b41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRjZmRjY2QzMmI1YjA2YTI5Y2FmNDU0NjkyMDNjNjdkYTUyNmI0MQ==", "commit": {"author": {"name": "Kirill Yukhin", "email": "kirill.yukhin@intel.com", "date": "2012-05-02T15:32:01Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2012-05-02T15:32:01Z"}, "message": "ChangeLog entry:\n\n        * coretypes (MEMMODEL_MASK): New.\n        * builtins.c (get_memmodel): Add val. Call target.memmodel_check\n        and return new variable.\n        (expand_builtin_atomic_exchange):  Mask memmodel values.\n        (expand_builtin_atomic_compare_exchange): Ditto.\n        (expand_builtin_atomic_load): Ditto.\n        (expand_builtin_atomic_store): Ditto.\n        (expand_builtin_atomic_clear): Ditto.\n        * doc/extend.texi: Mention port-dependent memory model flags.\n        * config/i386/cpuid.h (bit_HLE): New.\n        * config/i386/driver-i386.c (host_detect_local_cpu): Detect\n        HLE support.\n        * config/i386/i386-protos.h (ix86_generate_hle_prefix): New.\n        * config/i386/i386-c.c (ix86_target_macros_internal): Set\n        HLE defines.\n        (ix86_target_string)<-mhle>: New.\n        (ix86_valid_target_attribute_inner_p)<OPT_mhle>: Ditto.\n        * config/i386/i386.c (ix86_target_string)<OPTION_MASK_ISA_HLE>:\n        New.\n        (ix86_valid_target_attribute_inner_p)<OPT_mhle>: Ditto.\n        (ix86_option_override_internal)<PTA_HLE>: New switch, set it\n        enabled for generic, generic64 and core-avx2.\n        (ix86_print_operand): Generate HLE lock prefixes.\n        (ix86_memmodel_check): New.\n        (TARGET_MEMMODEL_CHECK): Ditto.\n        * config/i386/i386.h (OPTION_ISA_HLE): Ditto.\n        (IX86_HLE_ACQUIRE): Ditto.\n        (IX86_HLE_RELEASE): Ditto.\n        * config/i386/i386.h (ix86_generate_hle_prefix): Ditto.\n        * config/i386/i386.opt (mhle): Ditto.\n        * config/i386/sync.md(atomic_compare_and_swap<mode>): Pass\n        success model to instruction emitter.\n        (atomic_fetch_add<mode>): Ditto.\n        (atomic_exchange<mode>): Ditto.\n        (atomic_add<mode>): Ditto.\n        (atomic_sub<mode>): Ditto.\n        (atomic_<code><mode>): Ditto.\n        (*atomic_compare_and_swap_doubledi_pic): Ditto.\n        (atomic_compare_and_swap_single<mode>): Define and use argument\n        for success model.\n        (atomic_compare_and_swap_double<mode>): Ditto.\n        * configure.ac: Check if assembler support HLE prefixes.\n        * configure: Regenerate.\n        * config.in: Ditto.\n\ntestsuite/ChangeLog entry:\n\n        * gcc.target/i386/hle-cmpxchg-acq-1.c: New.\n        * gcc.target/i386/hle-cmpxchg-rel-1.c: Ditto.\n        * gcc.target/i386/hle-add-acq-1.c: Ditto.\n        * gcc.target/i386/hle-add-rel-1.c: Ditto.\n        * gcc.target/i386/hle-and-acq-1.c: Ditto.\n        * gcc.target/i386/hle-and-rel-1.c: Ditto.\n        * gcc.target/i386/hle-or-acq-1.c: Ditto.\n        * gcc.target/i386/hle-or-rel-1.c: Ditto.\n        * gcc.target/i386/hle-sub-acq-1.c: Ditto.\n        * gcc.target/i386/hle-sub-rel-1.c: Ditto.\n        * gcc.target/i386/hle-xadd-acq-1.c: Ditto.\n        * gcc.target/i386/hle-xadd-rel-1.c: Ditto.\n        * gcc.target/i386/hle-xchg-acq-1.c: Ditto.\n        * gcc.target/i386/hle-xchg-rel-1.c: Ditto.\n        * gcc.target/i386/hle-xor-acq-1.c: Ditto.\n        * gcc.target/i386/hle-xor-rel-1.c: Ditto.\n\n\n\nCo-Authored-By: Andi Kleen <ak@linux.intel.com>\n\nFrom-SVN: r187051", "tree": {"sha": "646070e1ed039d18a1ce731130e83a8dc29bb3f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/646070e1ed039d18a1ce731130e83a8dc29bb3f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dcfdccd32b5b06a29caf45469203c67da526b41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dcfdccd32b5b06a29caf45469203c67da526b41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dcfdccd32b5b06a29caf45469203c67da526b41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dcfdccd32b5b06a29caf45469203c67da526b41/comments", "author": null, "committer": null, "parents": [{"sha": "68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e"}], "stats": {"total": 452, "additions": 415, "deletions": 37}, "files": [{"sha": "dd86cb8130f73ddd1dc2ff4c3276883365ed76af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -1,3 +1,51 @@\n+2012-05-02  Kirill Yukhin  <kirill.yukhin@intel.com>\n+\t    Andi Kleen <ak@linux.intel.com>\n+\n+\t* coretypes (MEMMODEL_MASK): New.\n+\t* builtins.c (get_memmodel): Add val. Call target.memmodel_check\n+\tand return new variable.\n+\t(expand_builtin_atomic_exchange):  Mask memmodel values.\n+\t(expand_builtin_atomic_compare_exchange): Ditto.\n+\t(expand_builtin_atomic_load): Ditto.\n+\t(expand_builtin_atomic_store): Ditto.\n+\t(expand_builtin_atomic_clear): Ditto.\n+\t* doc/extend.texi: Mention port-dependent memory model flags.\n+\t* config/i386/cpuid.h (bit_HLE): New.\n+\t* config/i386/driver-i386.c (host_detect_local_cpu): Detect\n+\tHLE support.\n+\t* config/i386/i386-protos.h (ix86_generate_hle_prefix): New.\n+\t* config/i386/i386-c.c (ix86_target_macros_internal): Set\n+\tHLE defines.\n+\t(ix86_target_string)<-mhle>: New.\n+\t(ix86_valid_target_attribute_inner_p)<OPT_mhle>: Ditto.\n+\t* config/i386/i386.c (ix86_target_string)<OPTION_MASK_ISA_HLE>:\n+\tNew.\n+\t(ix86_valid_target_attribute_inner_p)<OPT_mhle>: Ditto.\n+\t(ix86_option_override_internal)<PTA_HLE>: New switch, set it\n+\tenabled for generic, generic64 and core-avx2.\n+\t(ix86_print_operand): Generate HLE lock prefixes.\n+\t(ix86_memmodel_check): New.\n+\t(TARGET_MEMMODEL_CHECK): Ditto.\n+\t* config/i386/i386.h (OPTION_ISA_HLE): Ditto.\n+\t(IX86_HLE_ACQUIRE): Ditto.\n+\t(IX86_HLE_RELEASE): Ditto.\n+\t* config/i386/i386.h (ix86_generate_hle_prefix): Ditto.\n+\t* config/i386/i386.opt (mhle): Ditto.\n+\t* config/i386/sync.md(atomic_compare_and_swap<mode>): Pass\n+\tsuccess model to instruction emitter.\n+\t(atomic_fetch_add<mode>): Ditto.\n+\t(atomic_exchange<mode>): Ditto.\n+\t(atomic_add<mode>): Ditto.\n+\t(atomic_sub<mode>): Ditto.\n+\t(atomic_<code><mode>): Ditto.\n+\t(*atomic_compare_and_swap_doubledi_pic): Ditto.\n+\t(atomic_compare_and_swap_single<mode>): Define and use argument\n+\tfor success model.\n+\t(atomic_compare_and_swap_double<mode>): Ditto.\n+\t* configure.ac: Check if assembler support HLE prefixes.\n+\t* configure: Regenerate.\n+\t* config.in: Ditto.\n+\n 2012-05-02  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR middle-end/53153"}, {"sha": "72e259194a72242557d941655b57fdd7b00409c7", "filename": "gcc/builtins.c", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -5338,20 +5338,33 @@ static enum memmodel\n get_memmodel (tree exp)\n {\n   rtx op;\n+  unsigned HOST_WIDE_INT val;\n \n   /* If the parameter is not a constant, it's a run time value so we'll just\n      convert it to MEMMODEL_SEQ_CST to avoid annoying runtime checking.  */\n   if (TREE_CODE (exp) != INTEGER_CST)\n     return MEMMODEL_SEQ_CST;\n \n   op = expand_normal (exp);\n-  if (INTVAL (op) < 0 || INTVAL (op) >= MEMMODEL_LAST)\n+\n+  val = INTVAL (op);\n+  if (targetm.memmodel_check)\n+    val = targetm.memmodel_check (val);\n+  else if (val & ~MEMMODEL_MASK)\n+    {\n+      warning (OPT_Winvalid_memory_model,\n+\t       \"Unknown architecture specifier in memory model to builtin.\");\n+      return MEMMODEL_SEQ_CST;\n+    }\n+\n+  if ((INTVAL(op) & MEMMODEL_MASK) >= MEMMODEL_LAST)\n     {\n       warning (OPT_Winvalid_memory_model,\n \t       \"invalid memory model argument to builtin\");\n       return MEMMODEL_SEQ_CST;\n     }\n-  return (enum memmodel) INTVAL (op);\n+\n+  return (enum memmodel) val;\n }\n \n /* Expand the __atomic_exchange intrinsic:\n@@ -5366,7 +5379,7 @@ expand_builtin_atomic_exchange (enum machine_mode mode, tree exp, rtx target)\n   enum memmodel model;\n \n   model = get_memmodel (CALL_EXPR_ARG (exp, 2));\n-  if (model == MEMMODEL_CONSUME)\n+  if ((model & MEMMODEL_MASK) == MEMMODEL_CONSUME)\n     {\n       error (\"invalid memory model for %<__atomic_exchange%>\");\n       return NULL_RTX;\n@@ -5402,7 +5415,8 @@ expand_builtin_atomic_compare_exchange (enum machine_mode mode, tree exp,\n   success = get_memmodel (CALL_EXPR_ARG (exp, 4));\n   failure = get_memmodel (CALL_EXPR_ARG (exp, 5));\n \n-  if (failure == MEMMODEL_RELEASE || failure == MEMMODEL_ACQ_REL)\n+  if ((failure & MEMMODEL_MASK) == MEMMODEL_RELEASE\n+      || (failure & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)\n     {\n       error (\"invalid failure memory model for %<__atomic_compare_exchange%>\");\n       return NULL_RTX;\n@@ -5453,8 +5467,8 @@ expand_builtin_atomic_load (enum machine_mode mode, tree exp, rtx target)\n   enum memmodel model;\n \n   model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n-  if (model == MEMMODEL_RELEASE\n-      || model == MEMMODEL_ACQ_REL)\n+  if ((model & MEMMODEL_MASK) == MEMMODEL_RELEASE\n+      || (model & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)\n     {\n       error (\"invalid memory model for %<__atomic_load%>\");\n       return NULL_RTX;\n@@ -5482,9 +5496,9 @@ expand_builtin_atomic_store (enum machine_mode mode, tree exp)\n   enum memmodel model;\n \n   model = get_memmodel (CALL_EXPR_ARG (exp, 2));\n-  if (model != MEMMODEL_RELAXED\n-      && model != MEMMODEL_SEQ_CST\n-      && model != MEMMODEL_RELEASE)\n+  if ((model & MEMMODEL_MASK) != MEMMODEL_RELAXED\n+      && (model & MEMMODEL_MASK) != MEMMODEL_SEQ_CST\n+      && (model & MEMMODEL_MASK) != MEMMODEL_RELEASE)\n     {\n       error (\"invalid memory model for %<__atomic_store%>\");\n       return NULL_RTX;\n@@ -5590,7 +5604,8 @@ expand_builtin_atomic_clear (tree exp)\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n   model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n \n-  if (model == MEMMODEL_ACQUIRE || model == MEMMODEL_ACQ_REL)\n+  if ((model & MEMMODEL_MASK) == MEMMODEL_ACQUIRE\n+      || (model & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)\n     {\n       error (\"invalid memory model for %<__atomic_store%>\");\n       return const0_rtx;"}, {"sha": "53214522a5c2fafb1d8440cdacb968db4521de03", "filename": "gcc/config.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -350,6 +350,11 @@\n #undef HAVE_AS_IX86_SAHF\n #endif\n \n+/* Define if your assembler supports HLE prefixes. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_IX86_HLE\n+#endif\n+\n \n /* Define if your assembler supports the swap suffix. */\n #ifndef USED_FOR_TARGET"}, {"sha": "a9d25c565cf996373c995963b5649d9506971d96", "filename": "gcc/config/i386/cpuid.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fcpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fcpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcpuid.h?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -66,6 +66,7 @@\n /* Extended Features (%eax == 7) */\n #define bit_FSGSBASE\t(1 << 0)\n #define bit_BMI\t\t(1 << 3)\n+#define bit_HLE\t\t(1 << 4)\n #define bit_AVX2\t(1 << 5)\n #define bit_BMI2\t(1 << 8)\n #define bit_RTM\t\t(1 << 11)"}, {"sha": "34cd096109ebe3f58747583af07397ab9c56b998", "filename": "gcc/config/i386/driver-i386.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdriver-i386.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -397,6 +397,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n   unsigned int has_pclmul = 0, has_abm = 0, has_lwp = 0;\n   unsigned int has_fma = 0, has_fma4 = 0, has_xop = 0;\n   unsigned int has_bmi = 0, has_bmi2 = 0, has_tbm = 0, has_lzcnt = 0;\n+  unsigned int has_hle = 0;\n \n   bool arch;\n \n@@ -456,6 +457,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n       __cpuid_count (7, 0, eax, ebx, ecx, edx);\n \n       has_bmi = ebx & bit_BMI;\n+      has_hle = ebx & bit_HLE;\n       has_avx2 = ebx & bit_AVX2;\n       has_bmi2 = ebx & bit_BMI2;\n     }\n@@ -726,10 +728,12 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n       const char *sse4_2 = has_sse4_2 ? \" -msse4.2\" : \" -mno-sse4.2\";\n       const char *sse4_1 = has_sse4_1 ? \" -msse4.1\" : \" -mno-sse4.1\";\n       const char *lzcnt = has_lzcnt ? \" -mlzcnt\" : \" -mno-lzcnt\";\n+      const char *hle = has_hle ? \" -mhle\" : \"-mno-hle\";\n \n       options = concat (options, cx16, sahf, movbe, ase, pclmul,\n \t\t\tpopcnt, abm, lwp, fma, fma4, xop, bmi, bmi2,\n-\t\t\ttbm, avx, avx2, sse4_2, sse4_1, lzcnt, NULL);\n+\t\t\ttbm, avx, avx2, sse4_2, sse4_1, lzcnt,\n+\t\t\thle, NULL);\n     }\n \n done:"}, {"sha": "c6551e2cbb69be881d4a0db909241e7f6d33558a", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -54,6 +54,7 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n   size_t tune_len = strlen (ix86_tune_string);\n   int last_arch_char = ix86_arch_string[arch_len - 1];\n   int last_tune_char = ix86_tune_string[tune_len - 1];\n+  char hle_macro[64];\n \n   /* Built-ins based on -march=.  */\n   switch (arch)\n@@ -293,6 +294,12 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n     def_or_undef (parse_in, \"__SSE_MATH__\");\n   if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE2))\n     def_or_undef (parse_in, \"__SSE2_MATH__\");\n+\n+  sprintf (hle_macro, \"__ATOMIC_HLE_ACQUIRE=%d\", IX86_HLE_ACQUIRE);\n+  def_or_undef (parse_in, hle_macro);\n+\n+  sprintf (hle_macro, \"__ATOMIC_HLE_RELEASE=%d\", IX86_HLE_RELEASE);\n+  def_or_undef (parse_in, hle_macro);\n }\n \n \f"}, {"sha": "46daee10cd739d15323dde81137711a78b7f5c05", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -2679,6 +2679,7 @@ ix86_target_string (HOST_WIDE_INT isa, int flags, const char *arch,\n     { \"-mbmi\",\t\tOPTION_MASK_ISA_BMI },\n     { \"-mbmi2\", \tOPTION_MASK_ISA_BMI2 },\n     { \"-mlzcnt\",\tOPTION_MASK_ISA_LZCNT },\n+    { \"-mhle\",\t\tOPTION_MASK_ISA_HLE },\n     { \"-mtbm\",\t\tOPTION_MASK_ISA_TBM },\n     { \"-mpopcnt\",\tOPTION_MASK_ISA_POPCNT },\n     { \"-mmovbe\",\tOPTION_MASK_ISA_MOVBE },\n@@ -2954,6 +2955,7 @@ ix86_option_override_internal (bool main_args_p)\n #define PTA_AVX2\t\t(HOST_WIDE_INT_1 << 30)\n #define PTA_BMI2\t \t(HOST_WIDE_INT_1 << 31)\n #define PTA_RTM\t\t \t(HOST_WIDE_INT_1 << 32)\n+#define PTA_HLE\t \t\t(HOST_WIDE_INT_1 << 33)\n /* if this reaches 64, need to widen struct pta flags below */\n \n   static struct pta\n@@ -3012,7 +3014,7 @@ ix86_option_override_internal (bool main_args_p)\n \t| PTA_SSSE3 | PTA_SSE4_1 | PTA_SSE4_2 | PTA_AVX | PTA_AVX2\n \t| PTA_CX16 | PTA_POPCNT | PTA_AES | PTA_PCLMUL | PTA_FSGSBASE\n \t| PTA_RDRND | PTA_F16C | PTA_BMI | PTA_BMI2 | PTA_LZCNT\n-        | PTA_FMA | PTA_MOVBE | PTA_RTM},\n+       | PTA_FMA | PTA_MOVBE | PTA_RTM | PTA_HLE},\n       {\"atom\", PROCESSOR_ATOM, CPU_ATOM,\n \tPTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n \t| PTA_SSSE3 | PTA_CX16 | PTA_MOVBE},\n@@ -3075,9 +3077,10 @@ ix86_option_override_internal (bool main_args_p)\n         PTA_64BIT | PTA_MMX |  PTA_SSE  | PTA_SSE2 | PTA_SSE3\n         | PTA_SSSE3 | PTA_SSE4A |PTA_ABM | PTA_CX16},\n       {\"generic32\", PROCESSOR_GENERIC32, CPU_PENTIUMPRO,\n-\t0 /* flags are only used for -march switch.  */ },\n+\tPTA_HLE /* flags are only used for -march switch.  */ },\n       {\"generic64\", PROCESSOR_GENERIC64, CPU_GENERIC64,\n-\tPTA_64BIT /* flags are only used for -march switch.  */ },\n+\tPTA_64BIT\n+        | PTA_HLE /* flags are only used for -march switch.  */ },\n     };\n \n   /* -mrecip options.  */\n@@ -3430,6 +3433,9 @@ ix86_option_override_internal (bool main_args_p)\n \tif (processor_alias_table[i].flags & PTA_RTM\n \t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_RTM))\n \t  ix86_isa_flags |= OPTION_MASK_ISA_RTM;\n+\tif (processor_alias_table[i].flags & PTA_HLE\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_HLE))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_HLE;\n \tif (processor_alias_table[i].flags & (PTA_PREFETCH_SSE | PTA_SSE))\n \t  x86_prefetch_sse = true;\n \n@@ -4251,6 +4257,7 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[],\n     IX86_ATTR_ISA (\"rdrnd\",\tOPT_mrdrnd),\n     IX86_ATTR_ISA (\"f16c\",\tOPT_mf16c),\n     IX86_ATTR_ISA (\"rtm\",\tOPT_mrtm),\n+    IX86_ATTR_ISA (\"hle\",\tOPT_mhle),\n \n     /* enum options */\n     IX86_ATTR_ENUM (\"fpmath=\",\tOPT_mfpmath_),\n@@ -14340,6 +14347,24 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t  x = adjust_address_nv (x, DImode, 8);\n \t  break;\n \n+\tcase 'K':\n+\t  gcc_assert (CONST_INT_P (x));\n+\n+\t  if (INTVAL (x) & IX86_HLE_ACQUIRE)\n+#ifdef HAVE_AS_IX86_HLE\n+\t    fputs (\"xacquire \", file);\n+#else\n+\t    fputs (\"\\n\" ASM_BYTE \"0xf2\\n\\t\", file);\n+#endif\n+\t  else if (INTVAL (x) & IX86_HLE_RELEASE)\n+#ifdef HAVE_AS_IX86_HLE\n+\t    fputs (\"xrelease \", file);\n+#else\n+\t    fputs (\"\\n\" ASM_BYTE \"0xf3\\n\\t\", file);\n+#endif\n+\t  /* We do not want to print value of the operand.  */\n+\t  return;\n+\n \tcase '+':\n \t  {\n \t    rtx x;\n@@ -39302,6 +39327,38 @@ ix86_autovectorize_vector_sizes (void)\n   return (TARGET_AVX && !TARGET_PREFER_AVX128) ? 32 | 16 : 0;\n }\n \n+/* Validate target specific memory model bits in VAL. */\n+\n+static unsigned HOST_WIDE_INT\n+ix86_memmodel_check (unsigned HOST_WIDE_INT val)\n+{\n+  unsigned HOST_WIDE_INT model = val & MEMMODEL_MASK;\n+  unsigned HOST_WIDE_INT strong;\n+\n+  if (val & ~(unsigned HOST_WIDE_INT)(IX86_HLE_ACQUIRE|IX86_HLE_RELEASE\n+\t\t\t\t      |MEMMODEL_MASK)\n+      || ((val & IX86_HLE_ACQUIRE) && (val & IX86_HLE_RELEASE)))\n+    {\n+      warning (OPT_Winvalid_memory_model,\n+\t       \"Unknown architecture specific memory model\");\n+      return MEMMODEL_SEQ_CST;\n+    }\n+  strong = (model == MEMMODEL_ACQ_REL || model == MEMMODEL_SEQ_CST);\n+  if (val & IX86_HLE_ACQUIRE && !(model == MEMMODEL_ACQUIRE || strong))\n+    {\n+      warning (OPT_Winvalid_memory_model,\n+              \"HLE_ACQUIRE not used with ACQUIRE or stronger memory model\");\n+      return MEMMODEL_SEQ_CST | IX86_HLE_ACQUIRE;\n+    }\n+   if (val & IX86_HLE_RELEASE && !(model == MEMMODEL_RELEASE || strong))\n+    {\n+      warning (OPT_Winvalid_memory_model,\n+              \"HLE_RELEASE not used with RELEASE or stronger memory model\");\n+      return MEMMODEL_SEQ_CST | IX86_HLE_RELEASE;\n+    }\n+  return val;\n+}\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY ix86_return_in_memory\n@@ -39401,6 +39458,9 @@ ix86_autovectorize_vector_sizes (void)\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL ix86_function_ok_for_sibcall\n \n+#undef TARGET_MEMMODEL_CHECK\n+#define TARGET_MEMMODEL_CHECK ix86_memmodel_check\n+\n #ifdef HAVE_AS_TLS\n #undef TARGET_HAVE_TLS\n #define TARGET_HAVE_TLS true"}, {"sha": "09442604c9667aa69a281f1f7e0d17eef5682065", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -75,6 +75,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_RDRND\tOPTION_ISA_RDRND\n #define TARGET_F16C\tOPTION_ISA_F16C\n #define TARGET_RTM      OPTION_ISA_RTM\n+#define TARGET_HLE\tOPTION_ISA_HLE\n \n #define TARGET_LP64\tOPTION_ABI_64\n #define TARGET_X32\tOPTION_ABI_X32\n@@ -2344,6 +2345,9 @@ extern void debug_dispatch_window (int);\n #define TARGET_RECIP_VEC_DIV\t((recip_mask & RECIP_MASK_VEC_DIV) != 0)\n #define TARGET_RECIP_VEC_SQRT\t((recip_mask & RECIP_MASK_VEC_SQRT) != 0)\n \n+#define IX86_HLE_ACQUIRE (1 << 16)\n+#define IX86_HLE_RELEASE (1 << 17)\n+\n /*\n Local variables:\n version-control: t"}, {"sha": "9da00cc53d46f1b11caaa9d38df693ab199f8b40", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -58,6 +58,7 @@\n ;; X -- don't print any sort of PIC '@' suffix for a symbol.\n ;; & -- print some in-use local-dynamic symbol name.\n ;; H -- print a memory address offset by 8; used for sse high-parts\n+;; K -- print HLE lock prefix\n ;; Y -- print condition for XOP pcom* instruction.\n ;; + -- print a branch hint as 'cs' or 'ds' prefix\n ;; ; -- print a semicolon (after prefixes due to bug in older gas)."}, {"sha": "db34e1fc073958ba4dd003c9510488b11758fd7b", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -528,6 +528,10 @@ mlzcnt\n Target Report Mask(ISA_LZCNT) Var(ix86_isa_flags) Save\n Support LZCNT built-in function and code generation\n \n+mhle\n+Target Report Mask(ISA_HLE) Var(ix86_isa_flags) Save\n+Support Hardware Lock Elision prefixes\n+\n mtbm\n Target Report Mask(ISA_TBM) Var(ix86_isa_flags) Save\n Support TBM built-in functions and code generation"}, {"sha": "e02a949631ec56c87bd35ed4a29da1a8544d6357", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -315,8 +315,9 @@\n    (match_operand:SI 7 \"const_int_operand\")]\t;; failure model\n   \"TARGET_CMPXCHG\"\n {\n-  emit_insn (gen_atomic_compare_and_swap_single<mode>\n-\t     (operands[1], operands[2], operands[3], operands[4]));\n+  emit_insn\n+   (gen_atomic_compare_and_swap_single<mode>\n+    (operands[1], operands[2], operands[3], operands[4], operands[6]));\n   ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n \t\t     const0_rtx);\n   DONE;\n@@ -344,8 +345,9 @@\n {\n   if (<MODE>mode == DImode && TARGET_64BIT)\n     {\n-      emit_insn (gen_atomic_compare_and_swap_singledi\n-\t\t (operands[1], operands[2], operands[3], operands[4]));\n+      emit_insn\n+       (gen_atomic_compare_and_swap_singledi\n+\t(operands[1], operands[2], operands[3], operands[4], operands[6]));\n     }\n   else\n     {\n@@ -370,7 +372,7 @@\n \tmem = replace_equiv_address (mem, force_reg (Pmode, XEXP (mem, 0)));\n \n       emit_insn (gen_atomic_compare_and_swap_double<mode>\n-\t\t (lo_o, hi_o, mem, lo_e, hi_e, lo_n, hi_n));\n+\t\t (lo_o, hi_o, mem, lo_e, hi_e, lo_n, hi_n, operands[6]));\n     }\n   ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n \t\t     const0_rtx);\n@@ -382,14 +384,15 @@\n \t(unspec_volatile:SWI\n \t  [(match_operand:SWI 1 \"memory_operand\" \"+m\")\n \t   (match_operand:SWI 2 \"register_operand\" \"0\")\n-\t   (match_operand:SWI 3 \"register_operand\" \"<r>\")]\n+\t   (match_operand:SWI 3 \"register_operand\" \"<r>\")\n+\t   (match_operand:SI 4 \"const_int_operand\")]\n \t  UNSPECV_CMPXCHG_1))\n    (set (match_dup 1)\n \t(unspec_volatile:SWI [(const_int 0)] UNSPECV_CMPXCHG_2))\n    (set (reg:CCZ FLAGS_REG)\n         (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG_3))]\n   \"TARGET_CMPXCHG\"\n-  \"lock{%;} cmpxchg{<imodesuffix>}\\t{%3, %1|%1, %3}\")\n+  \"lock{%;} %K4cmpxchg{<imodesuffix>}\\t{%3, %1|%1, %3}\")\n \n ;; For double-word compare and swap, we are obliged to play tricks with\n ;; the input newval (op5:op6) because the Intel register numbering does\n@@ -403,7 +406,8 @@\n \t   (match_operand:<DCASHMODE> 3 \"register_operand\" \"0\")\n \t   (match_operand:<DCASHMODE> 4 \"register_operand\" \"1\")\n \t   (match_operand:<DCASHMODE> 5 \"register_operand\" \"b\")\n-\t   (match_operand:<DCASHMODE> 6 \"register_operand\" \"c\")]\n+\t   (match_operand:<DCASHMODE> 6 \"register_operand\" \"c\")\n+\t   (match_operand:SI 7 \"const_int_operand\")]\n \t  UNSPECV_CMPXCHG_1))\n    (set (match_operand:<DCASHMODE> 1 \"register_operand\" \"=d\")\n \t(unspec_volatile:<DCASHMODE> [(const_int 0)] UNSPECV_CMPXCHG_2))\n@@ -412,7 +416,7 @@\n    (set (reg:CCZ FLAGS_REG)\n         (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG_4))]\n   \"\"\n-  \"lock{%;} cmpxchg<doublemodesuffix>b\\t%2\")\n+  \"lock{%;} %K7cmpxchg<doublemodesuffix>b\\t%2\")\n \n ;; Theoretically we'd like to use constraint \"r\" (any reg) for op5,\n ;; but that includes ecx.  If op5 and op6 are the same (like when\n@@ -430,7 +434,8 @@\n \t   (match_operand:SI 3 \"register_operand\" \"0\")\n \t   (match_operand:SI 4 \"register_operand\" \"1\")\n \t   (match_operand:SI 5 \"register_operand\" \"SD\")\n-\t   (match_operand:SI 6 \"register_operand\" \"c\")]\n+\t   (match_operand:SI 6 \"register_operand\" \"c\")\n+\t   (match_operand:SI 7 \"const_int_operand\")]\n \t  UNSPECV_CMPXCHG_1))\n    (set (match_operand:SI 1 \"register_operand\" \"=d\")\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_2))\n@@ -439,7 +444,7 @@\n    (set (reg:CCZ FLAGS_REG)\n         (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG_4))]\n   \"!TARGET_64BIT && TARGET_CMPXCHG8B && flag_pic\"\n-  \"xchg{l}\\t%%ebx, %5\\;lock{%;} cmpxchg8b\\t%2\\;xchg{l}\\t%%ebx, %5\")\n+  \"xchg{l}\\t%%ebx, %5\\;lock{%;} %K7cmpxchg8b\\t%2\\;xchg{l}\\t%%ebx, %5\")\n \n ;; For operand 2 nonmemory_operand predicate is used instead of\n ;; register_operand to allow combiner to better optimize atomic\n@@ -455,7 +460,7 @@\n \t\t  (match_operand:SWI 2 \"nonmemory_operand\" \"0\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_XADD\"\n-  \"lock{%;} xadd{<imodesuffix>}\\t{%0, %1|%1, %0}\")\n+  \"lock{%;} %K3xadd{<imodesuffix>}\\t{%0, %1|%1, %0}\")\n \n ;; This peephole2 and following insn optimize\n ;; __sync_fetch_and_add (x, -N) == N into just lock {add,sub,inc,dec}\n@@ -526,7 +531,7 @@\n    (set (match_dup 1)\n \t(match_operand:SWI 2 \"register_operand\" \"0\"))]\t\t;; input\n   \"\"\n-  \"xchg{<imodesuffix>}\\t{%1, %0|%0, %1}\")\n+  \"%K3xchg{<imodesuffix>}\\t{%1, %0|%0, %1}\")\n \n (define_insn \"atomic_add<mode>\"\n   [(set (match_operand:SWI 0 \"memory_operand\" \"+m\")\n@@ -541,15 +546,15 @@\n   if (TARGET_USE_INCDEC)\n     {\n       if (operands[1] == const1_rtx)\n-\treturn \"lock{%;} inc{<imodesuffix>}\\t%0\";\n+\treturn \"lock{%;} %K2inc{<imodesuffix>}\\t%0\";\n       if (operands[1] == constm1_rtx)\n-\treturn \"lock{%;} dec{<imodesuffix>}\\t%0\";\n+\treturn \"lock{%;} %K2dec{<imodesuffix>}\\t%0\";\n     }\n \n   if (x86_maybe_negate_const_int (&operands[1], <MODE>mode))\n-    return \"lock{%;} sub{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+    return \"lock{%;} %K2sub{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n \n-  return \"lock{%;} add{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+  return \"lock{%;} %K2add{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n })\n \n (define_insn \"atomic_sub<mode>\"\n@@ -565,15 +570,15 @@\n   if (TARGET_USE_INCDEC)\n     {\n       if (operands[1] == const1_rtx)\n-\treturn \"lock{%;} dec{<imodesuffix>}\\t%0\";\n+\treturn \"lock{%;} %K2dec{<imodesuffix>}\\t%0\";\n       if (operands[1] == constm1_rtx)\n-\treturn \"lock{%;} inc{<imodesuffix>}\\t%0\";\n+\treturn \"lock{%;} %K2inc{<imodesuffix>}\\t%0\";\n     }\n \n   if (x86_maybe_negate_const_int (&operands[1], <MODE>mode))\n-    return \"lock{%;} add{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+    return \"lock{%;} %K2add{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n \n-  return \"lock{%;} sub{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+  return \"lock{%;} %K2sub{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n })\n \n (define_insn \"atomic_<logic><mode>\"\n@@ -585,4 +590,4 @@\n \t  UNSPECV_LOCK))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n-  \"lock{%;} <logic>{<imodesuffix>}\\t{%1, %0|%0, %1}\")\n+  \"lock{%;} %K2<logic>{<imodesuffix>}\\t{%1, %0|%0, %1}\")"}, {"sha": "223f21805e0fe580ee0f0f3c3a5ebae9206dfe88", "filename": "gcc/configure", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -24626,6 +24626,39 @@ if test $gcc_cv_as_ix86_sahf = yes; then\n \n $as_echo \"#define HAVE_AS_IX86_SAHF 1\" >>confdefs.h\n \n+fi\n+\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for hle prefixes\" >&5\n+$as_echo_n \"checking assembler for hle prefixes... \" >&6; }\n+if test \"${gcc_cv_as_ix86_hle+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_ix86_hle=no\n+  if test x$gcc_cv_as != x; then\n+    $as_echo '.code64\n+       lock xacquire cmpxchg %esi, (%rcx)\n+       ' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_ix86_hle=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_ix86_hle\" >&5\n+$as_echo \"$gcc_cv_as_ix86_hle\" >&6; }\n+if test $gcc_cv_as_ix86_hle = yes; then\n+\n+$as_echo \"#define HAVE_AS_IX86_HLE 1\" >>confdefs.h\n+\n fi\n \n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for swap suffix\" >&5"}, {"sha": "86b4bea102d18568b164a50981be68015dfc5330", "filename": "gcc/configure.ac", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -3597,6 +3597,14 @@ foo:\tnop\n       [AC_DEFINE(HAVE_AS_IX86_SAHF, 1,\n         [Define if your assembler supports the sahf mnemonic in 64bit mode.])])\n \n+    gcc_GAS_CHECK_FEATURE([hle prefixes],\n+      gcc_cv_as_ix86_hle,,,\n+      [.code64\n+       lock xacquire cmpxchg %esi, (%rcx)\n+       ],,\n+      [AC_DEFINE(HAVE_AS_IX86_HLE, 1,\n+        [Define if your assembler supports HLE prefixes.])])\n+\n     gcc_GAS_CHECK_FEATURE([swap suffix],\n       gcc_cv_as_ix86_swap,,,\n       [movl.s %esp, %ebp],,"}, {"sha": "0e16b7b6a2f47f87262ba0af4e6b55b8ddceb34e", "filename": "gcc/coretypes.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -194,5 +194,8 @@ enum memmodel\n   MEMMODEL_LAST = 6\n };\n \n+/* Suppose that higher bits are target dependant. */\n+#define MEMMODEL_MASK ((1<<16)-1)\n+\n #endif /* coretypes.h */\n "}, {"sha": "5d55ea853a5b62750c160b15f79d69994406b245", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -7093,7 +7093,8 @@ to the same names in the C++11 standard.  Refer there or to the\n atomic synchronization} for more detailed definitions.  These memory\n models integrate both barriers to code motion as well as synchronization\n requirements with other threads. These are listed in approximately\n-ascending order of strength.\n+ascending order of strength. It is also possible to use target specific\n+flags for memory model flags, like Hardware Lock Elision.\n \n @table  @code\n @item __ATOMIC_RELAXED"}, {"sha": "e3245d0f9937f1f47630d9aeeb44c783977454ac", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -11362,6 +11362,11 @@ MIPS, where add-immediate takes a 16-bit signed value,\n @code{TARGET_CONST_ANCHOR} is set to @samp{0x8000}.  The default value\n is zero, which disables this optimization.  @end deftypevr\n \n+@deftypefn {Target Hook} {unsigned HOST_WIDE_INT} TARGET_MEMMODEL_CHECK (unsigned HOST_WIDE_INT @var{val})\n+Validate target specific memory model mask bits. When NULL no target specific\n+memory model bits are allowed.\n+@end deftypefn\n+\n @deftypevr {Target Hook} {unsigned char} TARGET_ATOMIC_TEST_AND_SET_TRUEVAL\n This value should be set if the result written by @code{atomic_test_and_set} is not exactly 1, i.e. the @code{bool} @code{true}.\n @end deftypevr"}, {"sha": "51687ce854683ed7e030c28bbc5166cc64026605", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -11242,4 +11242,9 @@ MIPS, where add-immediate takes a 16-bit signed value,\n @code{TARGET_CONST_ANCHOR} is set to @samp{0x8000}.  The default value\n is zero, which disables this optimization.  @end deftypevr\n \n+@hook TARGET_MEMMODEL_CHECK\n+Validate target specific memory model mask bits. When NULL no target specific\n+memory model bits are allowed.\n+@end deftypefn\n+\n @hook TARGET_ATOMIC_TEST_AND_SET_TRUEVAL"}, {"sha": "f50235424096872acde76144957d93430705fa0d", "filename": "gcc/target.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -1940,6 +1940,12 @@ DEFHOOKPOD\n  \"\",\n  unsigned HOST_WIDE_INT, 0)\n \n+/* Defines, which target-dependent bits (upper 16) are used by port  */\n+DEFHOOK\n+(memmodel_check,\n+ \"\",\n+ unsigned HOST_WIDE_INT, (unsigned HOST_WIDE_INT val), NULL)\n+\n /* Functions relating to calls - argument passing, returns, etc.  */\n /* Members of struct call have no special macro prefix.  */\n HOOK_VECTOR (TARGET_CALLS, calls)"}, {"sha": "c447969966b733e9affc75e769a3d143670159c0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -1,3 +1,22 @@\n+2012-05-02  Kirill Yukhin  <kirill.yukhin@intel.com>\n+\n+\t* gcc.target/i386/hle-cmpxchg-acq-1.c: New.\n+\t* gcc.target/i386/hle-cmpxchg-rel-1.c: Ditto.\n+\t* gcc.target/i386/hle-add-acq-1.c: Ditto.\n+\t* gcc.target/i386/hle-add-rel-1.c: Ditto.\n+\t* gcc.target/i386/hle-and-acq-1.c: Ditto.\n+\t* gcc.target/i386/hle-and-rel-1.c: Ditto.\n+\t* gcc.target/i386/hle-or-acq-1.c: Ditto.\n+\t* gcc.target/i386/hle-or-rel-1.c: Ditto.\n+\t* gcc.target/i386/hle-sub-acq-1.c: Ditto.\n+\t* gcc.target/i386/hle-sub-rel-1.c: Ditto.\n+\t* gcc.target/i386/hle-xadd-acq-1.c: Ditto.\n+\t* gcc.target/i386/hle-xadd-rel-1.c: Ditto.\n+\t* gcc.target/i386/hle-xchg-acq-1.c: Ditto.\n+\t* gcc.target/i386/hle-xchg-rel-1.c: Ditto.\n+\t* gcc.target/i386/hle-xor-acq-1.c: Ditto.\n+\t* gcc.target/i386/hle-xor-rel-1.c: Ditto.\n+\n 2012-05-02  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR middle-end/53153"}, {"sha": "06d3126cb001d048bf11a1dfeabb194c0c4c9959", "filename": "gcc/testsuite/gcc.target/i386/hle-add-acq-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-add-acq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-add-acq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-add-acq-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xacquire\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+add\" } } */\n+\n+void\n+hle_add (int *p, int v)\n+{\n+  __atomic_fetch_add (p, v, __ATOMIC_ACQUIRE | __ATOMIC_HLE_ACQUIRE);\n+}"}, {"sha": "32ba10e0d25f0b9f2861dac1103ae243da69d283", "filename": "gcc/testsuite/gcc.target/i386/hle-add-rel-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-add-rel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-add-rel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-add-rel-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xrelease\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+add\" } } */\n+\n+void\n+hle_add (int *p, int v)\n+{\n+  __atomic_fetch_add (p, v, __ATOMIC_RELEASE | __ATOMIC_HLE_RELEASE);\n+}"}, {"sha": "321aa4e5750bb0e7de6ef2593dd5cedb277bdb14", "filename": "gcc/testsuite/gcc.target/i386/hle-and-acq-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-and-acq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-and-acq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-and-acq-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xacquire\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+and\" } } */\n+\n+void\n+hle_and (int *p, int v)\n+{\n+  __atomic_fetch_and (p, v, __ATOMIC_ACQUIRE | __ATOMIC_HLE_ACQUIRE);\n+}"}, {"sha": "b746678e0a47911b2adcd67fbef942b86ff7efa8", "filename": "gcc/testsuite/gcc.target/i386/hle-and-rel-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-and-rel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-and-rel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-and-rel-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xrelease\\|\\.byte\\[ \\t\\]+0xf3\\)\\[ \\t\\n\\]+and\" } } */\n+\n+void\n+hle_and (int *p, int v)\n+{\n+  __atomic_fetch_and (p, v, __ATOMIC_RELEASE | __ATOMIC_HLE_RELEASE);\n+}"}, {"sha": "8b43e548a2c8c7569c083eddb1b1cc4d2d2edda1", "filename": "gcc/testsuite/gcc.target/i386/hle-cmpxchg-acq-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-cmpxchg-acq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-cmpxchg-acq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-cmpxchg-acq-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xacquire\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+cmpxchg\" } } */\n+\n+int\n+hle_cmpxchg (int *p, int oldv, int newv)\n+{\n+  return __atomic_compare_exchange_n (p, &oldv, newv, 0, __ATOMIC_ACQUIRE | __ATOMIC_HLE_ACQUIRE, __ATOMIC_ACQUIRE);\n+}"}, {"sha": "85495429175f0f0f3308bd04b912a5dfcffc05d6", "filename": "gcc/testsuite/gcc.target/i386/hle-cmpxchg-rel-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-cmpxchg-rel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-cmpxchg-rel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-cmpxchg-rel-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xrelease\\|\\.byte\\[ \\t\\]+0xf3\\)\\[ \\t\\n\\]+cmpxchg\" } } */\n+\n+int\n+hle_cmpxchg (int *p, int oldv, int newv)\n+{\n+  return __atomic_compare_exchange_n (p, &oldv, newv, 0, __ATOMIC_RELEASE | __ATOMIC_HLE_RELEASE, __ATOMIC_ACQUIRE);\n+}"}, {"sha": "b742993925e632453b14f18e75274ea708cc7ad3", "filename": "gcc/testsuite/gcc.target/i386/hle-or-acq-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-or-acq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-or-acq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-or-acq-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xacquire\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+or\" } } */\n+\n+void\n+hle_or (int *p, int v)\n+{\n+  __atomic_or_fetch (p, 1, __ATOMIC_ACQUIRE | __ATOMIC_HLE_ACQUIRE);\n+}"}, {"sha": "fda4f3261f6220d9cd38c8fbd9371a792150b01a", "filename": "gcc/testsuite/gcc.target/i386/hle-or-rel-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-or-rel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-or-rel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-or-rel-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xrelease\\|\\.byte\\[ \\t\\]+0xf3\\)\\[ \\t\\n\\]+or\" } } */\n+\n+void\n+hle_xor (int *p, int v)\n+{\n+  __atomic_fetch_or (p, v, __ATOMIC_RELEASE | __ATOMIC_HLE_RELEASE);\n+}"}, {"sha": "c9efa4ae348fc866b31ec2f595288c42ae17377f", "filename": "gcc/testsuite/gcc.target/i386/hle-sub-acq-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-sub-acq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-sub-acq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-sub-acq-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xacquire\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+sub\" } } */\n+\n+void\n+hle_sub (int *p, int v)\n+{\n+  __atomic_fetch_sub (p, v, __ATOMIC_ACQUIRE | __ATOMIC_HLE_ACQUIRE);\n+}"}, {"sha": "55cf86ab34fc4f5e6f017ee8638acdf234db69b4", "filename": "gcc/testsuite/gcc.target/i386/hle-sub-rel-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-sub-rel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-sub-rel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-sub-rel-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xrelease\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+sub\" } } */\n+\n+void\n+hle_sub (int *p, int v)\n+{\n+  __atomic_fetch_sub (p, v, __ATOMIC_RELEASE | __ATOMIC_HLE_RELEASE);\n+}"}, {"sha": "b4f1e2213d93fe53b31e765d4bf8e064e11cdb22", "filename": "gcc/testsuite/gcc.target/i386/hle-xadd-acq-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xadd-acq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xadd-acq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xadd-acq-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xacquire\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+xadd\" } } */\n+\n+int\n+hle_xadd (int *p, int v)\n+{\n+  return __atomic_fetch_add (p, v, __ATOMIC_ACQUIRE | __ATOMIC_HLE_ACQUIRE);\n+}"}, {"sha": "9351b43dea5ab7f2e7ed432ee4fc88ea2ec54474", "filename": "gcc/testsuite/gcc.target/i386/hle-xadd-rel-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xadd-rel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xadd-rel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xadd-rel-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xrelease\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+xadd\" } } */\n+\n+int\n+hle_xadd (int *p, int v)\n+{\n+  return __atomic_fetch_add (p, v, __ATOMIC_RELEASE | __ATOMIC_HLE_RELEASE);\n+}"}, {"sha": "441c454700ddefbc14d821c1f3d75663a7eb558f", "filename": "gcc/testsuite/gcc.target/i386/hle-xchg-acq-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xchg-acq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xchg-acq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xchg-acq-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"\\[ \\n\\t\\]+\\(xacquire\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+xchg\" } } */\n+\n+int\n+hle_xchg (int *p, int v)\n+{\n+  return __atomic_exchange_n (p, v, __ATOMIC_ACQUIRE | __ATOMIC_HLE_ACQUIRE);\n+}"}, {"sha": "706e483f1b89052006744b07171958acc46be7eb", "filename": "gcc/testsuite/gcc.target/i386/hle-xchg-rel-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xchg-rel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xchg-rel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xchg-rel-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"\\[ \\n\\t\\]+\\(xrelease\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+xchg\" } } */\n+\n+int\n+hle_xchg (int *p, int v)\n+{\n+  return __atomic_exchange_n (p, v, __ATOMIC_RELEASE | __ATOMIC_HLE_RELEASE);\n+}"}, {"sha": "f219b58f5ff1b4b19e32b94caeec9487a2f6f1b6", "filename": "gcc/testsuite/gcc.target/i386/hle-xor-acq-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xor-acq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xor-acq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xor-acq-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xacquire\\|\\.byte\\[ \\t\\]+0xf2\\)\\[ \\t\\n\\]+xor\" } } */\n+\n+void\n+hle_xor (int *p, int v)\n+{\n+  __atomic_fetch_xor (p, v, __ATOMIC_ACQUIRE | __ATOMIC_HLE_ACQUIRE);\n+}"}, {"sha": "16a5c42dc57b5ebd68dc40de10ff54640a8232a3", "filename": "gcc/testsuite/gcc.target/i386/hle-xor-rel-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xor-rel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dcfdccd32b5b06a29caf45469203c67da526b41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xor-rel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhle-xor-rel-1.c?ref=5dcfdccd32b5b06a29caf45469203c67da526b41", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mhle\" } */\n+/* { dg-final { scan-assembler \"lock\\[ \\n\\t\\]+\\(xrelease\\|\\.byte\\[ \\t\\]+0xf3\\)\\[ \\t\\n\\]+xor\" } } */\n+\n+void\n+hle_xor (int *p, int v)\n+{\n+  __atomic_fetch_xor (p, v, __ATOMIC_RELEASE | __ATOMIC_HLE_RELEASE);\n+}"}]}