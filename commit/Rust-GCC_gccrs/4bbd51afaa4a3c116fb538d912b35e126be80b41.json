{"sha": "4bbd51afaa4a3c116fb538d912b35e126be80b41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJiZDUxYWZhYTRhM2MxMTZmYjUzOGQ5MTJiMzVlMTI2YmU4MGI0MQ==", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2021-03-31T17:26:30Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2021-04-06T13:22:16Z"}, "message": "[PR99781] Update correctly reg notes in LRA for multi-registers and set up biggest mode safely\n\nThe PR is about incorrect use of partial_subreg_p for unordered modes.\nI found 2 places of dangerous comparing unordered modes in LRA.  The\npatch removes dangerous use of paradoxical_subreg_p and\npartial_subreg_p in split_reg and process_bb_lives.  The both places\nused them to solve PR77761 long time ago.  But the problem was also\nfixed by later patches too (if there is no hard reg explicitly, it\nhave VOIDmode and we use natural mode to split hard reg live,\notherwise we use the biggest explicitly used mode for hard reg\nsplitting).  The PR also says about inaccurate update of reg notes in\nLRA.  It happens for reg notes which refer for multi-registers.  The\npatch also fixes this issue.\n\ngcc/ChangeLog:\n\n\tPR target/99781\n\t* lra-constraints.c (split_reg): Don't check paradoxical_subreg_p.\n\t* lra-lives.c (clear_sparseset_regnos, regnos_in_sparseset_p): New\n\tfunctions.\n\t(process_bb_lives): Don't update biggest mode of hard reg for\n\timplicit in multi-register group.  Use the new functions for\n\tupdating dead_set and unused_set by register notes.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/99781\n\t* g++.target/aarch64/sve/pr99781.C: New.", "tree": {"sha": "39256860f1918487bb7fd4bc249dbe5b1994c5bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39256860f1918487bb7fd4bc249dbe5b1994c5bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bbd51afaa4a3c116fb538d912b35e126be80b41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bbd51afaa4a3c116fb538d912b35e126be80b41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bbd51afaa4a3c116fb538d912b35e126be80b41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bbd51afaa4a3c116fb538d912b35e126be80b41/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "498d2ba5849cd0888ad473a2ff953ede106262c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498d2ba5849cd0888ad473a2ff953ede106262c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498d2ba5849cd0888ad473a2ff953ede106262c5"}], "stats": {"total": 86, "additions": 62, "deletions": 24}, "files": [{"sha": "62bcfc317721806f1612c1b732bad4b238fde888", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbd51afaa4a3c116fb538d912b35e126be80b41/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbd51afaa4a3c116fb538d912b35e126be80b41/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=4bbd51afaa4a3c116fb538d912b35e126be80b41", "patch": "@@ -5796,12 +5796,11 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n       nregs = 1;\n       mode = lra_reg_info[hard_regno].biggest_mode;\n       machine_mode reg_rtx_mode = GET_MODE (regno_reg_rtx[hard_regno]);\n-      /* A reg can have a biggest_mode of VOIDmode if it was only ever seen\n-\t as part of a multi-word register.  In that case, or if the biggest\n-\t mode was larger than a register, just use the reg_rtx.  Otherwise,\n-\t limit the size to that of the biggest access in the function.  */\n-      if (mode == VOIDmode\n-\t  || paradoxical_subreg_p (mode, reg_rtx_mode))\n+      /* A reg can have a biggest_mode of VOIDmode if it was only ever seen as\n+\t part of a multi-word register.  In that case, just use the reg_rtx.\n+\t Otherwise, limit the size to that of the biggest access in the\n+\t function.  */\n+      if (mode == VOIDmode)\n \t{\n \t  original_reg = regno_reg_rtx[hard_regno];\n \t  mode = reg_rtx_mode;"}, {"sha": "29531843c633654583a21d06b8b9f9c707a7edf0", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbd51afaa4a3c116fb538d912b35e126be80b41/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbd51afaa4a3c116fb538d912b35e126be80b41/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=4bbd51afaa4a3c116fb538d912b35e126be80b41", "patch": "@@ -615,6 +615,32 @@ reg_early_clobber_p (const struct lra_insn_reg *reg, int n_alt)\n \t     && TEST_BIT (reg->early_clobber_alts, n_alt)));\n }\n \n+/* Clear pseudo REGNO in SET or all hard registers of REGNO in MODE in SET.  */\n+static void\n+clear_sparseset_regnos (sparseset set, int regno, enum machine_mode mode)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      sparseset_clear_bit (dead_set, regno);\n+      return;\n+    }\n+  for (int last = end_hard_regno (mode, regno); regno < last; regno++)\n+    sparseset_clear_bit (set, regno);\n+}\n+\n+/* Return true if pseudo REGNO is in SET or all hard registers of REGNO in MODE\n+   are in SET.  */\n+static bool\n+regnos_in_sparseset_p (sparseset set, int regno, enum machine_mode mode)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return sparseset_bit_p (dead_set, regno);\n+  for (int last = end_hard_regno (mode, regno); regno < last; regno++)\n+    if (!sparseset_bit_p (set, regno))\n+      return false;\n+  return true;\n+}\n+\n /* Process insns of the basic block BB to update pseudo live ranges,\n    pseudo hard register conflicts, and insn notes.  We do it on\n    backward scan of BB insns.  CURR_POINT is the program point where\n@@ -739,24 +765,13 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       /* Update max ref width and hard reg usage.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \t{\n-\t  int i, regno = reg->regno;\n+\t  int regno = reg->regno;\n \n \t  if (partial_subreg_p (lra_reg_info[regno].biggest_mode,\n \t\t\t\treg->biggest_mode))\n \t    lra_reg_info[regno].biggest_mode = reg->biggest_mode;\n \t  if (HARD_REGISTER_NUM_P (regno))\n-\t    {\n-\t      lra_hard_reg_usage[regno] += freq;\n-\t      /* A hard register explicitly can be used in small mode,\n-\t\t but implicitly it can be used in natural mode as a\n-\t\t part of multi-register group.  Process this case\n-\t\t here.  */\n-\t      for (i = 1; i < hard_regno_nregs (regno, reg->biggest_mode); i++)\n-\t\tif (partial_subreg_p (lra_reg_info[regno + i].biggest_mode,\n-\t\t\t\t      GET_MODE (regno_reg_rtx[regno + i])))\n-\t\t  lra_reg_info[regno + i].biggest_mode\n-\t\t    = GET_MODE (regno_reg_rtx[regno + i]);\n-\t    }\n+\t    lra_hard_reg_usage[regno] += freq;\n \t}\n \n       call_p = CALL_P (curr_insn);\n@@ -991,19 +1006,25 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t    ;\n \t  else if (REG_P (XEXP (link, 0)))\n \t    {\n-\t      regno = REGNO (XEXP (link, 0));\n+\t      rtx note_reg = XEXP (link, 0);\n+\t      int note_regno = REGNO (note_reg);\n+\n \t      if ((REG_NOTE_KIND (link) == REG_DEAD\n-\t\t   && ! sparseset_bit_p (dead_set, regno))\n+\t\t   && ! regnos_in_sparseset_p (dead_set, note_regno,\n+\t\t\t\t\t       GET_MODE (note_reg)))\n \t\t  || (REG_NOTE_KIND (link) == REG_UNUSED\n-\t\t      && ! sparseset_bit_p (unused_set, regno)))\n+\t\t      && ! regnos_in_sparseset_p (unused_set, note_regno,\n+\t\t\t\t\t\t  GET_MODE (note_reg))))\n \t\t{\n \t\t  *link_loc = XEXP (link, 1);\n \t\t  continue;\n \t\t}\n \t      if (REG_NOTE_KIND (link) == REG_DEAD)\n-\t\tsparseset_clear_bit (dead_set, regno);\n+\t\tclear_sparseset_regnos (dead_set, note_regno,\n+\t\t\t\t\tGET_MODE (note_reg));\n \t      else if (REG_NOTE_KIND (link) == REG_UNUSED)\n-\t\tsparseset_clear_bit (unused_set, regno);\n+\t\tclear_sparseset_regnos (unused_set, note_regno,\n+\t\t\t\t\tGET_MODE (note_reg));\n \t    }\n \t  link_loc = &XEXP (link, 1);\n \t}"}, {"sha": "21da8e04d8ff5df774b2618e9eef9127be85a8ea", "filename": "gcc/testsuite/g++.target/aarch64/sve/pr99781.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbd51afaa4a3c116fb538d912b35e126be80b41/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fpr99781.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbd51afaa4a3c116fb538d912b35e126be80b41/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fpr99781.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fpr99781.C?ref=4bbd51afaa4a3c116fb538d912b35e126be80b41", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=armv8-a+sve\" } */\n+\n+#include <stdint.h>\n+\n+typedef int32_t vnx4si __attribute__((vector_size(32)));\n+\n+void\n+foo (int32_t val)\n+{\n+  register vnx4si x asm (\"z0\");\n+  register vnx4si y asm (\"z1\");\n+  asm volatile (\"\" : \"=w\" (y));\n+  val += 1;\n+  vnx4si z = { val, val, val, val, val, val, val, val };\n+  x = (vnx4si) { -1, 0, 0, -1, 0, -1, 0, -1 } ? z : y;\n+  asm volatile (\"\" :: \"w\" (x));\n+}"}]}