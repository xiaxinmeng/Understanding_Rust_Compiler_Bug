{"sha": "c68da89c455fce41d03acecff5883099b1c97424", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY4ZGE4OWM0NTVmY2U0MWQwM2FjZWNmZjU4ODMwOTliMWM5NzQyNA==", "commit": {"author": {"name": "Ken Raeburn", "email": "raeburn@cygnus.com", "date": "1999-02-01T12:50:53Z"}, "committer": {"name": "Ken Raeburn", "email": "raeburn@gcc.gnu.org", "date": "1999-02-01T12:50:53Z"}, "message": "Use varrays for constant-equivalence data:\n\n* varray.h (struct const_equiv_data): New type.\n(union varray_data_tag): New element const_equiv.\n(VARRAY_CONST_EQUIV_INIT, VARRAY_CONST_EQUIV): New macros.\n(VARRAY_SIZE): New macro, returns number of elements.\n* integrate.h: Include varray.h.\n(struct inline_remap): Replace const_equiv_map, const_age_map and\nconst_equiv_map_size with a const_equiv_varray element.\n(MAYBE_EXTEND_CONST_EQUIV_VARRAY): New macro; grows varray if needed.\n(SET_CONST_EQUIV_DATA): New macro; sets rtx and age fields simultaneously,\ngrowing the varray if needed.\n* integrate.c (global_const_equiv_map, global_const_equiv_map_size): Deleted,\nreplaced by....\n(global_const_equiv_varray): New variable.\n(expand_inline_function): References changed.\n* integrate.h: Update declarations.\n* integrate.c (process_reg_parm, expand_inline_function,\ncopy_rtx_and_substitute, try_constants, subst_constants, mark_stores): Use\nvarray allocation and accessor macros, new integrate.h macros, and\nglobal_const_equiv_varray.  Don't conditionalize non-NULL stores on array size;\ninstead, expand the array as needed.\n* unroll.c (unroll_loop): Likewise.\n* unroll.c (unroll_loop): Initialize const_equiv_varray element to zero.  After\nallocating varray, always exit through bottom of function, where it can be\ndeallocated if needed.  Don't explicitly reallocate const_equiv_map storage;\ninstead, just ensure the varray has been initialized, and update the global\nreference.\n\nFrom-SVN: r24956", "tree": {"sha": "6e36a17f813c9f393e14690ca6a6478095b3fcb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e36a17f813c9f393e14690ca6a6478095b3fcb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c68da89c455fce41d03acecff5883099b1c97424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c68da89c455fce41d03acecff5883099b1c97424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c68da89c455fce41d03acecff5883099b1c97424", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c68da89c455fce41d03acecff5883099b1c97424/comments", "author": null, "committer": null, "parents": [{"sha": "9594b1b2a1bad01f95ac82d6bf44cb98a34a14d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9594b1b2a1bad01f95ac82d6bf44cb98a34a14d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9594b1b2a1bad01f95ac82d6bf44cb98a34a14d9"}], "stats": {"total": 296, "additions": 177, "deletions": 119}, "files": [{"sha": "724f5b03cf649ce0eaa325436ab1aef546282265", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c68da89c455fce41d03acecff5883099b1c97424/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c68da89c455fce41d03acecff5883099b1c97424/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c68da89c455fce41d03acecff5883099b1c97424", "patch": "@@ -1,3 +1,39 @@\n+Mon Feb  1 15:00:02 1999  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\tUse varrays for constant-equivalence data:\n+\n+\t* varray.h (struct const_equiv_data): New type.\n+\t(union varray_data_tag): New element const_equiv.\n+\t(VARRAY_CONST_EQUIV_INIT, VARRAY_CONST_EQUIV): New macros.\n+\t(VARRAY_SIZE): New macro, returns number of elements.\n+\t* integrate.h: Include varray.h.\n+\t(struct inline_remap): Replace const_equiv_map, const_age_map and\n+\tconst_equiv_map_size with a const_equiv_varray element.\n+\t(MAYBE_EXTEND_CONST_EQUIV_VARRAY): New macro; grows varray if\n+\tneeded.\n+\t(SET_CONST_EQUIV_DATA): New macro; sets rtx and age fields\n+\tsimultaneously, growing the varray if needed.\n+\n+\t* integrate.c (global_const_equiv_map,\n+\tglobal_const_equiv_map_size): Deleted, replaced by....\n+\t(global_const_equiv_varray): New variable.\n+\t(expand_inline_function): References changed.\n+\t* integrate.h: Update declarations.\n+\n+\t* integrate.c (process_reg_parm, expand_inline_function,\n+\tcopy_rtx_and_substitute, try_constants, subst_constants,\n+\tmark_stores): Use varray allocation and accessor macros, new\n+\tintegrate.h macros, and global_const_equiv_varray.  Don't\n+\tconditionalize non-NULL stores on array size; instead, expand the\n+\tarray as needed.\n+\t* unroll.c (unroll_loop): Likewise.\n+\n+\t* unroll.c (unroll_loop): Initialize const_equiv_varray element to\n+\tzero.  After allocating varray, always exit through bottom of\n+\tfunction, where it can be deallocated if needed.  Don't explicitly\n+\treallocate const_equiv_map storage; instead, just ensure the\n+\tvarray has been initialized, and update the global reference.\n+\n Mon Feb  1 09:40:25 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* system.h (inline, const): Handle these for stage2 (and later) gcc."}, {"sha": "c001e788054a342f85f4cde740e51958812a7f53", "filename": "gcc/integrate.c", "status": "modified", "additions": 54, "deletions": 75, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c68da89c455fce41d03acecff5883099b1c97424/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c68da89c455fce41d03acecff5883099b1c97424/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c68da89c455fce41d03acecff5883099b1c97424", "patch": "@@ -1301,8 +1301,7 @@ copy_for_inline (orig)\n    with a function called from note_stores.  Be *very* careful that this\n    is used properly in the presence of recursion.  */\n \n-rtx *global_const_equiv_map;\n-int global_const_equiv_map_size;\n+varray_type global_const_equiv_varray;\n \f\n #define FIXED_BASE_PLUS_P(X) \\\n   (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == CONST_INT\t\\\n@@ -1332,12 +1331,8 @@ process_reg_param (map, loc, copy)\n     {\n       rtx temp = copy_to_mode_reg (GET_MODE (loc), copy);\n       REG_USERVAR_P (temp) = REG_USERVAR_P (loc);\n-      if ((CONSTANT_P (copy) || FIXED_BASE_PLUS_P (copy))\n-\t  && REGNO (temp) < map->const_equiv_map_size)\n-\t{\n-\t  map->const_equiv_map[REGNO (temp)] = copy;\n-\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n-\t}\n+      if (CONSTANT_P (copy) || FIXED_BASE_PLUS_P (copy))\n+\tSET_CONST_EQUIV_DATA (map, temp, copy, CONST_AGE_PARM);\n       copy = temp;\n     }\n   map->reg_map[REGNO (loc)] = copy;\n@@ -1392,7 +1387,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   rtx loc;\n   rtx stack_save = 0;\n   rtx temp;\n-  struct inline_remap *map;\n+  struct inline_remap *map = 0;\n #ifdef HAVE_cc0\n   rtx cc0_insn = 0;\n #endif\n@@ -1554,30 +1549,25 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n   map->integrating = 1;\n \n-  /* const_equiv_map maps pseudos in our routine to constants, so it needs to\n-     be large enough for all our pseudos.  This is the number we are currently\n-     using plus the number in the called routine, plus 15 for each arg,\n-     five to compute the virtual frame pointer, and five for the return value.\n-     This should be enough for most cases.  We do not reference entries\n-     outside the range of the map.\n+  /* const_equiv_varray maps pseudos in our routine to constants, so\n+     it needs to be large enough for all our pseudos.  This is the\n+     number we are currently using plus the number in the called\n+     routine, plus 15 for each arg, five to compute the virtual frame\n+     pointer, and five for the return value.  This should be enough\n+     for most cases.  We do not reference entries outside the range of\n+     the map.\n \n      ??? These numbers are quite arbitrary and were obtained by\n      experimentation.  At some point, we should try to allocate the\n      table after all the parameters are set up so we an more accurately\n      estimate the number of pseudos we will need.  */\n \n-  map->const_equiv_map_size\n-    = max_reg_num () + (max_regno - FIRST_PSEUDO_REGISTER) + 15 * nargs + 10;\n-\n-  map->const_equiv_map\n-    = (rtx *)alloca (map->const_equiv_map_size * sizeof (rtx));\n-  bzero ((char *) map->const_equiv_map,\n-\t map->const_equiv_map_size * sizeof (rtx));\n-\n-  map->const_age_map\n-    = (unsigned *)alloca (map->const_equiv_map_size * sizeof (unsigned));\n-  bzero ((char *) map->const_age_map,\n-\t map->const_equiv_map_size * sizeof (unsigned));\n+  VARRAY_CONST_EQUIV_INIT (map->const_equiv_varray,\n+\t\t\t   (max_reg_num ()\n+\t\t\t    + (max_regno - FIRST_PSEUDO_REGISTER)\n+\t\t\t    + 15 * nargs\n+\t\t\t    + 10),\n+\t\t\t   \"expand_inline_function\");\n   map->const_age = 0;\n \n   /* Record the current insn in case we have to set up pointers to frame\n@@ -1646,12 +1636,8 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t  if (GET_CODE (copy) != REG)\n \t    {\n \t      temp = copy_addr_to_reg (copy);\n-\t      if ((CONSTANT_P (copy) || FIXED_BASE_PLUS_P (copy))\n-\t\t  && REGNO (temp) < map->const_equiv_map_size)\n-\t\t{\n-\t\t  map->const_equiv_map[REGNO (temp)] = copy;\n-\t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n-\t\t}\n+\t      if (CONSTANT_P (copy) || FIXED_BASE_PLUS_P (copy))\n+\t\tSET_CONST_EQUIV_DATA (map, temp, copy, CONST_AGE_PARM);\n \t      copy = temp;\n \t    }\n \t  map->reg_map[REGNO (XEXP (loc, 0))] = copy;\n@@ -1751,17 +1737,16 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t      temp = force_reg (Pmode, temp);\n \t      map->reg_map[REGNO (XEXP (loc, 0))] = temp;\n \n-\t      if ((CONSTANT_P (structure_value_addr)\n-\t\t   || GET_CODE (structure_value_addr) == ADDRESSOF\n-\t\t   || (GET_CODE (structure_value_addr) == PLUS\n-\t\t       && (XEXP (structure_value_addr, 0)\n-\t\t\t   == virtual_stack_vars_rtx)\n-\t\t       && (GET_CODE (XEXP (structure_value_addr, 1))\n-\t\t\t   == CONST_INT)))\n-\t\t  && REGNO (temp) < map->const_equiv_map_size)\n+\t      if (CONSTANT_P (structure_value_addr)\n+\t\t  || GET_CODE (structure_value_addr) == ADDRESSOF\n+\t\t  || (GET_CODE (structure_value_addr) == PLUS\n+\t\t      && (XEXP (structure_value_addr, 0)\n+\t\t\t  == virtual_stack_vars_rtx)\n+\t\t      && (GET_CODE (XEXP (structure_value_addr, 1))\n+\t\t\t  == CONST_INT)))\n \t\t{\n-\t\t  map->const_equiv_map[REGNO (temp)] = structure_value_addr;\n-\t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n+\t\t  SET_CONST_EQUIV_DATA (map, temp, structure_value_addr,\n+\t\t\t\t\tCONST_AGE_PARM);\n \t\t}\n \t    }\n \t  else\n@@ -1864,10 +1849,9 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   /* Clean up stack so that variables might have smaller offsets.  */\n   do_pending_stack_adjust ();\n \n-  /* Save a copy of the location of const_equiv_map for mark_stores, called\n-     via note_stores.  */\n-  global_const_equiv_map = map->const_equiv_map;\n-  global_const_equiv_map_size = map->const_equiv_map_size;\n+  /* Save a copy of the location of const_equiv_varray for\n+     mark_stores, called via note_stores.  */\n+  global_const_equiv_varray = map->const_equiv_varray;\n \n   /* If the called function does an alloca, save and restore the\n      stack pointer around the call.  This saves stack space, but\n@@ -2051,7 +2035,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n \t  /* Be lazy and assume CALL_INSNs clobber all hard registers.  */\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    map->const_equiv_map[i] = 0;\n+\t    VARRAY_CONST_EQUIV (map->const_equiv_varray, i).rtx = 0;\n \t  break;\n \n \tcase CODE_LABEL:\n@@ -2186,6 +2170,8 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   /* Make sure we free the things we explicitly allocated with xmalloc.  */\n   if (real_label_map)\n     free (real_label_map);\n+  if (map)\n+    VARRAY_FREE (map->const_equiv_varray);\n \n   return target;\n }\n@@ -2389,11 +2375,7 @@ copy_rtx_and_substitute (orig, map)\n \t\t\t\tSTACK_BOUNDARY / BITS_PER_UNIT);\n #endif\n \n-\t      if (REGNO (temp) < map->const_equiv_map_size)\n-\t\t{\n-\t\t  map->const_equiv_map[REGNO (temp)] = loc;\n-\t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n-\t\t}\n+\t      SET_CONST_EQUIV_DATA (map, temp, loc, CONST_AGE_PARM);\n \n \t      seq = gen_sequence ();\n \t      end_sequence ();\n@@ -2424,11 +2406,7 @@ copy_rtx_and_substitute (orig, map)\n \t\t\t\tSTACK_BOUNDARY / BITS_PER_UNIT);\n #endif\n \n-\t      if (REGNO (temp) < map->const_equiv_map_size)\n-\t\t{\n-\t\t  map->const_equiv_map[REGNO (temp)] = loc;\n-\t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n-\t\t}\n+\t      SET_CONST_EQUIV_DATA (map, temp, loc, CONST_AGE_PARM);\n \n \t      seq = gen_sequence ();\n \t      end_sequence ();\n@@ -2710,7 +2688,7 @@ copy_rtx_and_substitute (orig, map)\n \n \t  copy_rtx_and_substitute (SET_DEST (orig), map);\n \t  equiv_reg = map->reg_map[REGNO (SET_DEST (orig))];\n-\t  equiv_loc = map->const_equiv_map[REGNO (equiv_reg)];\n+\t  equiv_loc = VARRAY_CONST_EQUIV (map->const_equiv_varray, REGNO (equiv_reg)).rtx;\n \t  loc_offset\n \t    = GET_CODE (equiv_loc) == REG ? 0 : INTVAL (XEXP (equiv_loc, 1));\n \t  return gen_rtx_SET (VOIDmode, SET_DEST (orig),\n@@ -2836,16 +2814,15 @@ try_constants (insn, map)\n \t{\n \t  int regno = REGNO (map->equiv_sets[i].dest);\n \n-\t  if (regno < map->const_equiv_map_size\n-\t      && (map->const_equiv_map[regno] == 0\n-\t\t  /* Following clause is a hack to make case work where GNU C++\n-\t\t     reassigns a variable to make cse work right.  */\n-\t\t  || ! rtx_equal_p (map->const_equiv_map[regno],\n-\t\t\t\t    map->equiv_sets[i].equiv)))\n-\t    {\n-\t      map->const_equiv_map[regno] = map->equiv_sets[i].equiv;\n-\t      map->const_age_map[regno] = map->const_age;\n-\t    }\n+\t  MAYBE_EXTEND_CONST_EQUIV_VARRAY (map, regno);\n+\t  if (VARRAY_CONST_EQUIV (map->const_equiv_varray, regno).rtx == 0\n+\t      /* Following clause is a hack to make case work where GNU C++\n+\t\t reassigns a variable to make cse work right.  */\n+\t      || ! rtx_equal_p (VARRAY_CONST_EQUIV (map->const_equiv_varray,\n+\t\t\t\t\t\t    regno).rtx,\n+\t\t\t\tmap->equiv_sets[i].equiv))\n+\t    SET_CONST_EQUIV_DATA (map, map->equiv_sets[i].dest,\n+\t\t\t\t  map->equiv_sets[i].equiv, map->const_age);\n \t}\n       else if (map->equiv_sets[i].dest == pc_rtx)\n \tmap->last_pc_value = map->equiv_sets[i].equiv;\n@@ -2915,12 +2892,14 @@ subst_constants (loc, insn, map)\n \t hard regs used as user variables with constants.  */\n       {\n \tint regno = REGNO (x);\n+\tstruct const_equiv_data *p;\n \n \tif (! (regno < FIRST_PSEUDO_REGISTER && REG_USERVAR_P (x))\n-\t    && regno < map->const_equiv_map_size\n-\t    && map->const_equiv_map[regno] != 0\n-\t    && map->const_age_map[regno] >= map->const_age)\n-\t  validate_change (insn, loc, map->const_equiv_map[regno], 1);\n+\t    && regno < VARRAY_SIZE (map->const_equiv_varray)\n+\t    && (p = &VARRAY_CONST_EQUIV (map->const_equiv_varray, regno),\n+\t\tp->rtx != 0)\n+\t    && p->age >= map->const_age)\n+\t  validate_change (insn, loc, p->rtx, 1);\n \treturn;\n       }\n \n@@ -3163,8 +3142,8 @@ mark_stores (dest, x)\n       if (regno != VIRTUAL_INCOMING_ARGS_REGNUM\n \t  && regno != VIRTUAL_STACK_VARS_REGNUM)\n \tfor (i = regno; i <= last_reg; i++)\n-\t  if (i < global_const_equiv_map_size)\n-\t    global_const_equiv_map[i] = 0;\n+\t  if (i < VARRAY_SIZE (global_const_equiv_varray))\n+\t    VARRAY_CONST_EQUIV (global_const_equiv_varray, i).rtx = 0;\n     }\n }\n \f"}, {"sha": "03825591bc0d2ba30022ec5621fdd03121f7062e", "filename": "gcc/integrate.h", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c68da89c455fce41d03acecff5883099b1c97424/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c68da89c455fce41d03acecff5883099b1c97424/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=c68da89c455fce41d03acecff5883099b1c97424", "patch": "@@ -18,6 +18,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#include \"varray.h\"\n+\n /* This structure is used to remap objects in the function being inlined to\n    those belonging to the calling function.  It is passed by\n    expand_inline_function to its children.\n@@ -67,19 +69,15 @@ struct inline_remap\n      pseudos that contain pointers into the replacement area allocated for\n      this inline instance.  These pseudos are then marked as being equivalent\n      to the appropriate address and substituted if valid.  */\n-  rtx *const_equiv_map;\n-  /* Number of entries in const_equiv_map and const_arg_map.  */\n-  int const_equiv_map_size;\n+  varray_type const_equiv_varray;\n   /* This is incremented for each new basic block.\n-     It is used to store in const_age_map to record the domain of validity\n-     of each entry in const_equiv_map.\n+     It is used to store in the age field to record the domain of validity\n+     of each entry in const_equiv_varray.\n      A value of -1 indicates an entry for a reg which is a parm.\n      All other values are \"positive\".  */\n #define CONST_AGE_PARM (-1)\n   unsigned int const_age;\n-  /* In parallel with const_equiv_map, record the valid age for each entry.\n-     The entry is invalid if its age is less than const_age.  */\n-  unsigned int *const_age_map;\n+\n   /* Target of the inline function being expanded, or NULL if none.  */\n   rtx inline_target;\n   /* When an insn is being copied by copy_rtx_and_substitute,\n@@ -128,9 +126,29 @@ extern rtx get_label_from_map PROTO((struct inline_remap *, int));\n /* Set the label indicated.  */\n #define set_label_in_map(MAP, I, X) ((MAP)->label_map[I] = (X))\n \n-/* Unfortunately, we need a global copy of const_equiv map for communication\n-   with a function called from note_stores.  Be *very* careful that this\n-   is used properly in the presence of recursion.  */\n-\n-extern rtx *global_const_equiv_map;\n-extern int global_const_equiv_map_size;\n+/* Unfortunately, we need a global copy of const_equiv varray for\n+   communication with a function called from note_stores.  Be *very*\n+   careful that this is used properly in the presence of recursion.  */\n+\n+extern varray_type global_const_equiv_varray;\n+\n+#define MAYBE_EXTEND_CONST_EQUIV_VARRAY(MAP,MAX)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if ((MAX) >= VARRAY_SIZE ((MAP)->const_equiv_varray))\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        int is_global = (global_const_equiv_varray\t\t\t\\\n+\t\t\t == (MAP)->const_equiv_varray);\t\t\t\\\n+        VARRAY_GROW ((MAP)->const_equiv_varray, (MAX)+1);\t\t\\\n+\tif (is_global)\t\t\t\t\t\t\t\\\n+\t   global_const_equiv_varray = (MAP)->const_equiv_varray;\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define SET_CONST_EQUIV_DATA(MAP,REG,RTX,AGE)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    struct const_equiv_data *p;\t\t\t\t\t\t\\\n+    MAYBE_EXTEND_CONST_EQUIV_VARRAY ((MAP), REGNO (REG));\t\t\\\n+    p = &VARRAY_CONST_EQUIV ((MAP)->const_equiv_varray, REGNO (REG));\t\\\n+    p->rtx = (RTX);\t\t\t\t\t\t\t\\\n+    p->age = (AGE);\t\t\t\t\t\t\t\\\n+  }"}, {"sha": "0d1787c0e520e78a2f599c4e3e34497269b3578f", "filename": "gcc/unroll.c", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c68da89c455fce41d03acecff5883099b1c97424/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c68da89c455fce41d03acecff5883099b1c97424/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=c68da89c455fce41d03acecff5883099b1c97424", "patch": "@@ -239,7 +239,6 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   char *local_label;\n   char *local_regno;\n   int maxregnum;\n-  int new_maxregnum;\n   rtx exit_label = 0;\n   rtx start_label;\n   struct iv_class *bl;\n@@ -684,6 +683,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   map = (struct inline_remap *) alloca (sizeof (struct inline_remap));\n \n   map->integrating = 0;\n+  map->const_equiv_varray = 0;\n \n   /* Allocate the label map.  */\n \n@@ -873,12 +873,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n \t  map->reg_map = (rtx *) alloca (maxregnum * sizeof (rtx));\n \n-\t  map->const_equiv_map = (rtx *) alloca (maxregnum * sizeof (rtx));\n-\t  map->const_age_map = (unsigned *) alloca (maxregnum\n-\t\t\t\t\t\t    * sizeof (unsigned));\n-\t  map->const_equiv_map_size = maxregnum;\n-\t  global_const_equiv_map = map->const_equiv_map;\n-\t  global_const_equiv_map_size = maxregnum;\n+\t  VARRAY_CONST_EQUIV_INIT (map->const_equiv_varray, maxregnum,\n+\t\t\t\t   \"unroll_loop\");\n+\t  global_const_equiv_varray = map->const_equiv_varray;\n \n \t  init_reg_map (map, maxregnum);\n \n@@ -1045,9 +1042,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t\t\t\tPREV_INSN (loop_start));\n \n \t      bzero ((char *) map->insn_map, max_insnno * sizeof (rtx));\n-\t      bzero ((char *) map->const_equiv_map, maxregnum * sizeof (rtx));\n-\t      bzero ((char *) map->const_age_map,\n-\t\t     maxregnum * sizeof (unsigned));\n+\t      bzero ((char *) &VARRAY_CONST_EQUIV (map->const_equiv_varray, 0),\n+\t\t     (VARRAY_SIZE (map->const_equiv_varray)\n+\t\t      * sizeof (struct const_equiv_data)));\n \t      map->const_age = 0;\n \n \t      for (j = 0; j < max_labelno; j++)\n@@ -1113,7 +1110,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream, \"Unrolling failure: Naive unrolling not being done.\\n\");\n-      return;\n+      goto egress;\n     }\n \n   /* At this point, we are guaranteed to unroll the loop.  */\n@@ -1149,19 +1146,11 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n   init_reg_map (map, maxregnum);\n \n-  /* Space is needed in some of the map for new registers, so new_maxregnum\n-     is an (over)estimate of how many registers will exist at the end.  */\n-  new_maxregnum = maxregnum + (temp * unroll_number * 2);\n-\n-  /* Must realloc space for the constant maps, because the number of registers\n-     may have changed.  */\n-\n-  map->const_equiv_map = (rtx *) alloca (new_maxregnum * sizeof (rtx));\n-  map->const_age_map = (unsigned *) alloca (new_maxregnum * sizeof (unsigned));\n-\n-  map->const_equiv_map_size = new_maxregnum;\n-  global_const_equiv_map = map->const_equiv_map;\n-  global_const_equiv_map_size = new_maxregnum;\n+  if (map->const_equiv_varray == 0)\n+    VARRAY_CONST_EQUIV_INIT (map->const_equiv_varray,\n+\t\t\t     maxregnum + temp * unroll_number * 2,\n+\t\t\t     \"unroll_loop\");\n+  global_const_equiv_varray = map->const_equiv_varray;\n \n   /* Search the list of bivs and givs to find ones which need to be remapped\n      when split, and set their reg_map entry appropriately.  */\n@@ -1202,8 +1191,8 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   for (i = 0; i < unroll_number; i++)\n     {\n       bzero ((char *) map->insn_map, max_insnno * sizeof (rtx));\n-      bzero ((char *) map->const_equiv_map, new_maxregnum * sizeof (rtx));\n-      bzero ((char *) map->const_age_map, new_maxregnum * sizeof (unsigned));\n+      bzero ((char *) &VARRAY_CONST_EQUIV (map->const_equiv_varray, 0),\n+\t     VARRAY_SIZE (map->const_equiv_varray) * sizeof (struct const_equiv_data));\n       map->const_age = 0;\n \n       for (j = 0; j < max_labelno; j++)\n@@ -1280,6 +1269,10 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n      not taken.  */\n   if (exit_label)\n     emit_label_after (exit_label, loop_end);\n+\n+ egress:\n+  if (map && map->const_equiv_varray)\n+    VARRAY_FREE (map->const_equiv_varray);\n }\n \f\n /* Return true if the loop can be safely, and profitably, preconditioned\n@@ -1949,9 +1942,10 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t    {\n \t      int regno = REGNO (SET_DEST (pattern));\n \n-\t      if (regno < map->const_equiv_map_size\n-\t\t  && map->const_age_map[regno] == map->const_age)\n-\t\tmap->const_age_map[regno] = -1;\n+\t      if (regno < VARRAY_SIZE (map->const_equiv_varray)\n+\t\t  && (VARRAY_CONST_EQUIV (map->const_equiv_varray, regno).age\n+\t\t      == map->const_age))\n+\t\tVARRAY_CONST_EQUIV (map->const_equiv_varray, regno).age = -1;\n \t    }\n \t  break;\n \t  \n@@ -2106,7 +2100,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \n \t  /* Be lazy and assume CALL_INSNs clobber all hard registers.  */\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    map->const_equiv_map[i] = 0;\n+\t    VARRAY_CONST_EQUIV (map->const_equiv_varray, i).rtx = 0;\n \t  break;\n \t  \n \tcase CODE_LABEL:"}, {"sha": "5905773d1909440df0109e49e9e4f0f10ced4548", "filename": "gcc/varray.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c68da89c455fce41d03acecff5883099b1c97424/gcc%2Fvarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c68da89c455fce41d03acecff5883099b1c97424/gcc%2Fvarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.h?ref=c68da89c455fce41d03acecff5883099b1c97424", "patch": "@@ -30,6 +30,30 @@\n #include \"system.h\"\n #endif\n \n+/* Auxiliary structure used inside the varray structure, used for\n+   function integration data.  */\n+\n+struct const_equiv_data {\n+  /* Map pseudo reg number in calling function to equivalent constant.  We\n+     cannot in general substitute constants into parameter pseudo registers,\n+     since some machine descriptions (many RISCs) won't always handle\n+     the resulting insns.  So if an incoming parameter has a constant\n+     equivalent, we record it here, and if the resulting insn is\n+     recognizable, we go with it.\n+\n+     We also use this mechanism to convert references to incoming arguments\n+     and stacked variables.  copy_rtx_and_substitute will replace the virtual\n+     incoming argument and virtual stacked variables registers with new\n+     pseudos that contain pointers into the replacement area allocated for\n+     this inline instance.  These pseudos are then marked as being equivalent\n+     to the appropriate address and substituted if valid.  */\n+  rtx rtx;\n+\n+  /* Record the valid age for each entry.  The entry is invalid if its\n+     age is less than const_age.  */\n+  unsigned age;\n+};\n+\n /* Union of various array types that are used.  */\n typedef union varray_data_tag {\n   char\t\t\t c[1];\n@@ -50,6 +74,7 @@ typedef union varray_data_tag {\n   struct bitmap_head_def *bitmap[1];\n   struct sched_info_tag\t *sched[1];\n   struct reg_info_def\t *reg[1];\n+  struct const_equiv_data const_equiv[1];\n } varray_data;\n \n /* Virtual array of pointers header.  */\n@@ -118,6 +143,9 @@ extern varray_type varray_init\tPROTO ((size_t, size_t, const char *));\n #define VARRAY_REG_INIT(va, num, name) \\\n   va = varray_init (num, sizeof (struct reg_info_def *), name)\n \n+#define VARRAY_CONST_EQUIV_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (struct const_equiv_data), name)\n+\n /* Free up memory allocated by the virtual array, but do not free any of the\n    elements involved.  */\n #define VARRAY_FREE(vp) \\\n@@ -128,6 +156,8 @@ extern varray_type varray_grow\tPROTO((varray_type, size_t));\n \n #define VARRAY_GROW(VA, N) ((VA) = varray_grow (VA, N))\n \n+#define VARRAY_SIZE(VA)\t((VA)->num_elements)\n+\n /* Check for VARRAY_xxx macros being in bound, return N for use as an\n    index.  */\n #ifdef ENABLE_CHECKING\n@@ -159,5 +189,6 @@ extern varray_type varray_grow\tPROTO((varray_type, size_t));\n #define VARRAY_BITMAP(VA, N)\t((VA)->data.bitmap[ VARRAY_CHECK (VA, N) ])\n #define VARRAY_SCHED(VA, N)\t((VA)->data.sched[ VARRAY_CHECK (VA, N) ])\n #define VARRAY_REG(VA, N)\t((VA)->data.reg[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_CONST_EQUIV(VA, N) ((VA)->data.const_equiv[ VARRAY_CHECK (VA, N) ])\n \n #endif /* _VARRAY_H_ */"}]}