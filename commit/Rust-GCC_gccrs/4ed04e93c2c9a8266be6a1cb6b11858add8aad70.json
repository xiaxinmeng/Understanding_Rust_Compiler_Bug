{"sha": "4ed04e93c2c9a8266be6a1cb6b11858add8aad70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVkMDRlOTNjMmM5YTgyNjZiZTZhMWNiNmIxMTg1OGFkZDhhYWQ3MA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-01-17T19:44:53Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-01-17T19:44:53Z"}, "message": "i386.h (MASK_CLASS_P): New define.\n\n\t* config/i386/i386.h (MASK_CLASS_P): New define.\n\t* config/i386/i386.c (inline_secondary_memory_needed): Ensure that\n\tthere are no registers from different register sets also when\n\tmask registers are used.  Update function comment.\n\t* config/i386/i386.md (*movsi_internal): Split (*k/*krm) alternative\n\tto (*k/*r) and (*k/*km) alternatives.\n\nFrom-SVN: r244548", "tree": {"sha": "05d8f4b8e7738daf739bc8f37269e88b56fa8c53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05d8f4b8e7738daf739bc8f37269e88b56fa8c53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ed04e93c2c9a8266be6a1cb6b11858add8aad70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed04e93c2c9a8266be6a1cb6b11858add8aad70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ed04e93c2c9a8266be6a1cb6b11858add8aad70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed04e93c2c9a8266be6a1cb6b11858add8aad70/comments", "author": null, "committer": null, "parents": [{"sha": "8144a493ddc0083b06d303f51a8e34d16c122c8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8144a493ddc0083b06d303f51a8e34d16c122c8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8144a493ddc0083b06d303f51a8e34d16c122c8c"}], "stats": {"total": 60, "additions": 37, "deletions": 23}, "files": [{"sha": "15a07182aa495935a2b2b93293acad443c679da4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed04e93c2c9a8266be6a1cb6b11858add8aad70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed04e93c2c9a8266be6a1cb6b11858add8aad70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ed04e93c2c9a8266be6a1cb6b11858add8aad70", "patch": "@@ -1,3 +1,12 @@\n+2017-01-17  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.h (MASK_CLASS_P): New define.\n+\t* config/i386/i386.c (inline_secondary_memory_needed): Ensure that\n+\tthere are no registers from different register sets also when\n+\tmask registers are used.  Update function comment.\n+\t* config/i386/i386.md (*movsi_internal): Split (*k/*krm) alternative\n+\tto (*k/*r) and (*k/*km) alternatives.\n+\n 2017-01-17  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.md (eh_return): Remove pattern and splitter.\n@@ -216,7 +225,7 @@\n \tdefinitions accordingly.\n \n 2017-01-17  Kito Cheng  <kito.cheng@gmail.com>\n-            Kuan-Lin Chen  <kuanlinchentw@gmail.com>\n+\t    Kuan-Lin Chen  <kuanlinchentw@gmail.com>\n \n \tPR target/79079\n \t* internal-fn.c (expand_mul_overflow): Use convert_modes instead of\n@@ -295,14 +304,14 @@\n \n \tRevert:\n \t2016-12-02  Tadek Kijkowski  <tkijkowski@gmail.com>\n-        * Makefile.in (PREPROCESSOR_DEFINES): Add a level of indirection\n-        for several include directories that may be relative to sysroot.\n-        * config/i386/x-mingw32 (gplus_includedir): Define.\n-        (gplus_tool_includedir, gplus_backward_include_dir): Likewise.\n-        (native_system_includedir): Likewise.\n-        * config/i386/mingw32.h (STANDARD_STARTFILE_PREFIX_1): Do not\n-        override if TARGET_SYSTEM_ROOT is defined.\n-        (NATIVE_SYSTEM_HEADER_DIR): Likewise.\n+\t* Makefile.in (PREPROCESSOR_DEFINES): Add a level of indirection\n+\tfor several include directories that may be relative to sysroot.\n+\t* config/i386/x-mingw32 (gplus_includedir): Define.\n+\t(gplus_tool_includedir, gplus_backward_include_dir): Likewise.\n+\t(native_system_includedir): Likewise.\n+\t* config/i386/mingw32.h (STANDARD_STARTFILE_PREFIX_1): Do not\n+\toverride if TARGET_SYSTEM_ROOT is defined.\n+\t(NATIVE_SYSTEM_HEADER_DIR): Likewise.\n \n \tPR tree-optimization/79090\n \tPR tree-optimization/33562"}, {"sha": "eb4781d9239c6f825de1b81ee874bdc70505e95f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed04e93c2c9a8266be6a1cb6b11858add8aad70/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed04e93c2c9a8266be6a1cb6b11858add8aad70/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4ed04e93c2c9a8266be6a1cb6b11858add8aad70", "patch": "@@ -39868,31 +39868,34 @@ ix86_class_likely_spilled_p (reg_class_t rclass)\n   return false;\n }\n \n-/* If we are copying between general and FP registers, we need a memory\n-   location. The same is true for SSE and MMX registers.\n+/* If we are copying between registers from different register sets\n+   (e.g. FP and integer), we may need a memory location.\n \n-   To optimize register_move_cost performance, allow inline variant.\n-\n-   The macro can't work reliably when one of the CLASSES is class containing\n-   registers from multiple units (SSE, MMX, integer).  We avoid this by never\n-   combining those units in single alternative in the machine description.\n+   The function can't work reliably when one of the CLASSES is a class\n+   containing registers from multiple sets.  We avoid this by never combining\n+   different sets in a single alternative in the machine description.\n    Ensure that this constraint holds to avoid unexpected surprises.\n \n-   When STRICT is false, we are being called from REGISTER_MOVE_COST, so do not\n-   enforce these sanity checks.  */\n+   When STRICT is false, we are being called from REGISTER_MOVE_COST,\n+   so do not enforce these sanity checks.\n+\n+   To optimize register_move_cost performance, define inline variant.  */\n \n static inline bool\n inline_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n \t\t\t\tmachine_mode mode, int strict)\n {\n   if (lra_in_progress && (class1 == NO_REGS || class2 == NO_REGS))\n     return false;\n+\n   if (MAYBE_FLOAT_CLASS_P (class1) != FLOAT_CLASS_P (class1)\n       || MAYBE_FLOAT_CLASS_P (class2) != FLOAT_CLASS_P (class2)\n       || MAYBE_SSE_CLASS_P (class1) != SSE_CLASS_P (class1)\n       || MAYBE_SSE_CLASS_P (class2) != SSE_CLASS_P (class2)\n       || MAYBE_MMX_CLASS_P (class1) != MMX_CLASS_P (class1)\n-      || MAYBE_MMX_CLASS_P (class2) != MMX_CLASS_P (class2))\n+      || MAYBE_MMX_CLASS_P (class2) != MMX_CLASS_P (class2)\n+      || MAYBE_MASK_CLASS_P (class1) != MASK_CLASS_P (class1)\n+      || MAYBE_MASK_CLASS_P (class2) != MASK_CLASS_P (class2))\n     {\n       gcc_assert (!strict || lra_in_progress);\n       return true;\n@@ -39902,7 +39905,7 @@ inline_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n     return true;\n \n   /* Between mask and general, we have moves no larger than word size.  */\n-  if ((MAYBE_MASK_CLASS_P (class1) != MAYBE_MASK_CLASS_P (class2))\n+  if ((MASK_CLASS_P (class1) != MASK_CLASS_P (class2))\n       && (GET_MODE_SIZE (mode) > UNITS_PER_WORD))\n   return true;\n "}, {"sha": "aeacf0f29dabb6bec715cad33ea8670b32cde990", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed04e93c2c9a8266be6a1cb6b11858add8aad70/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed04e93c2c9a8266be6a1cb6b11858add8aad70/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=4ed04e93c2c9a8266be6a1cb6b11858add8aad70", "patch": "@@ -1378,6 +1378,8 @@ enum reg_class\n   reg_class_subset_p ((CLASS), ALL_SSE_REGS)\n #define MMX_CLASS_P(CLASS) \\\n   ((CLASS) == MMX_REGS)\n+#define MASK_CLASS_P(CLASS) \\\n+  reg_class_subset_p ((CLASS), MASK_REGS)\n #define MAYBE_INTEGER_CLASS_P(CLASS) \\\n   reg_classes_intersect_p ((CLASS), GENERAL_REGS)\n #define MAYBE_FLOAT_CLASS_P(CLASS) \\"}, {"sha": "1d58ceb773ab7801af6088d0e8314422e3fbdedd", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed04e93c2c9a8266be6a1cb6b11858add8aad70/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed04e93c2c9a8266be6a1cb6b11858add8aad70/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=4ed04e93c2c9a8266be6a1cb6b11858add8aad70", "patch": "@@ -2324,9 +2324,9 @@\n \n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t\"=r,m ,*y,*y,?rm,?*y,*v,*v,*v,m ,?r ,?r,?*Yi,*k  ,*rm\")\n+\t\t\t\"=r,m ,*y,*y,?rm,?*y,*v,*v,*v,m ,?r ,?r,?*Yi,*k,*k ,*rm\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t\"g ,re,C ,*y,*y ,rm ,C ,*v,m ,*v,*Yj,*v,r   ,*krm,*k\"))]\n+\t\t\t\"g ,re,C ,*y,*y ,rm ,C ,*v,m ,*v,*Yj,*v,r   ,*r,*km,*k\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n@@ -2403,7 +2403,7 @@\n \t      (const_string \"sselog1\")\n \t    (eq_attr \"alternative\" \"7,8,9,10,12\")\n \t      (const_string \"ssemov\")\n-\t    (eq_attr \"alternative\" \"13,14\")\n+\t    (eq_attr \"alternative\" \"13,14,15\")\n \t      (const_string \"mskmov\")\n \t    (and (match_operand 0 \"register_operand\")\n \t\t (match_operand 1 \"pic_32bit_operand\"))"}]}