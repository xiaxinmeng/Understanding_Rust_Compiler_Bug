{"sha": "3b2d7c47c40faaf768857fdde27e18a801453d94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IyZDdjNDdjNDBmYWFmNzY4ODU3ZmRkZTI3ZTE4YTgwMTQ1M2Q5NA==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@redhat.com", "date": "2003-09-17T19:06:55Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2003-09-17T19:06:55Z"}, "message": "[multiple changes]\n\n2003-09-16  Graydon Hoare  <graydon@redhat.com>\n\n\t* java/awt/BufferedImage.java (setData): Support non-component\n\tsample models.\n\t(getData): Same.\n\n2003-09-10  Graydon Hoare  <graydon@redhat.com>\n\n\t* java/awt/geom/AffineTransform.java(transform): Fix airthmetic bugs.\n\t* java/awt/geom/Arc2D.java: Approximate arc segments with cubics.\n\nFrom-SVN: r71472", "tree": {"sha": "1b8a9b7ac4a553f1917df84bf7861cd9b07999a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b8a9b7ac4a553f1917df84bf7861cd9b07999a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b2d7c47c40faaf768857fdde27e18a801453d94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2d7c47c40faaf768857fdde27e18a801453d94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b2d7c47c40faaf768857fdde27e18a801453d94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2d7c47c40faaf768857fdde27e18a801453d94/comments", "author": null, "committer": null, "parents": [{"sha": "eb26c76c647b9ce601f44f1c1e714875dbf9c6f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb26c76c647b9ce601f44f1c1e714875dbf9c6f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb26c76c647b9ce601f44f1c1e714875dbf9c6f4"}], "stats": {"total": 176, "additions": 121, "deletions": 55}, "files": [{"sha": "6c208a493ccd83582983847346eb244372c1b507", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2d7c47c40faaf768857fdde27e18a801453d94/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2d7c47c40faaf768857fdde27e18a801453d94/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3b2d7c47c40faaf768857fdde27e18a801453d94", "patch": "@@ -1,3 +1,14 @@\n+2003-09-16  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* java/awt/BufferedImage.java (setData): Support non-component\n+\tsample models.\n+\t(getData): Same.\n+\n+2003-09-10  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* java/awt/geom/AffineTransform.java(transform): Fix airthmetic bugs.\n+\t* java/awt/geom/Arc2D.java: Approximate arc segments with cubics.\n+\n 2003-09-17  Mohan Embar  <gnustuff@thisiscool.com>\n \n \t* configure.in: Standardized help text case of"}, {"sha": "d479763be8ca29e541dd9cea8fdf1db61d5fb63e", "filename": "libjava/java/awt/geom/AffineTransform.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2d7c47c40faaf768857fdde27e18a801453d94/libjava%2Fjava%2Fawt%2Fgeom%2FAffineTransform.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2d7c47c40faaf768857fdde27e18a801453d94/libjava%2Fjava%2Fawt%2Fgeom%2FAffineTransform.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2FAffineTransform.java?ref=3b2d7c47c40faaf768857fdde27e18a801453d94", "patch": "@@ -1089,7 +1089,7 @@ public void transform(float[] srcPts, int srcOff,\n         float x = srcPts[srcOff++];\n         float y = srcPts[srcOff++];\n         dstPts[dstOff++] = (float) (m00 * x + m01 * y + m02);\n-        dstPts[dstOff++] = (float) (m10 * x + m10 * y + m12);\n+        dstPts[dstOff++] = (float) (m10 * x + m11 * y + m12);\n       }\n   }\n \n@@ -1123,7 +1123,7 @@ public void transform(double[] srcPts, int srcOff,\n         double x = srcPts[srcOff++];\n         double y = srcPts[srcOff++];\n         dstPts[dstOff++] = m00 * x + m01 * y + m02;\n-        dstPts[dstOff++] = m10 * x + m10 * y + m12;\n+        dstPts[dstOff++] = m10 * x + m11 * y + m12;\n       }\n   }\n \n@@ -1148,7 +1148,7 @@ public void transform(float[] srcPts, int srcOff,\n         float x = srcPts[srcOff++];\n         float y = srcPts[srcOff++];\n         dstPts[dstOff++] = m00 * x + m01 * y + m02;\n-        dstPts[dstOff++] = m10 * x + m10 * y + m12;\n+        dstPts[dstOff++] = m10 * x + m11 * y + m12;\n       }\n   }\n \n@@ -1173,7 +1173,7 @@ public void transform(double[] srcPts, int srcOff,\n         double x = srcPts[srcOff++];\n         double y = srcPts[srcOff++];\n         dstPts[dstOff++] = (float) (m00 * x + m01 * y + m02);\n-        dstPts[dstOff++] = (float) (m10 * x + m10 * y + m12);\n+        dstPts[dstOff++] = (float) (m10 * x + m11 * y + m12);\n       }\n   }\n "}, {"sha": "2eb9650cf884ab707f632c06a684ba74904fefae", "filename": "libjava/java/awt/geom/Arc2D.java", "status": "modified", "additions": 84, "deletions": 45, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2d7c47c40faaf768857fdde27e18a801453d94/libjava%2Fjava%2Fawt%2Fgeom%2FArc2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2d7c47c40faaf768857fdde27e18a801453d94/libjava%2Fjava%2Fawt%2Fgeom%2FArc2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2FArc2D.java?ref=3b2d7c47c40faaf768857fdde27e18a801453d94", "patch": "@@ -582,11 +582,11 @@ static final class ArcIterator implements PathIterator\n         limit = -1;\n       else if (e == 0)\n         limit = type;\n-      else if (e <= 90)\n+      else if (e <= Math.PI / 2.0)\n         limit = type + 1;\n-      else if (e <= 180)\n+      else if (e <= Math.PI)\n         limit = type + 2;\n-      else if (e <= 270)\n+      else if (e <= 3.0 * (Math.PI / 2.0))\n         limit = type + 3;\n       else\n         limit = type + 4;\n@@ -649,36 +649,11 @@ public void next()\n      */\n     public int currentSegment(float[] coords)\n     {\n-      if (current > limit)\n-        throw new NoSuchElementException(\"arc iterator out of bounds\");\n-      if (current == 0)\n-        {\n-          coords[0] = (float) (Math.cos(start) * w + x) / 2;\n-          coords[1] = (float) (Math.sin(start) * h + y) / 2;\n-          if (xform != null)\n-            xform.transform(coords, 0, coords, 0, 1);\n-          return SEG_MOVETO;\n-        }\n-      if (type != OPEN && current == limit)\n-        return SEG_CLOSE;\n-      if (type == PIE && current == limit - 1)\n-        {\n-          coords[0] = (float) (x + w / 2);\n-          coords[1] = (float) (y + h / 2);\n-          if (xform != null)\n-            xform.transform(coords, 0, coords, 0, 1);\n-          return SEG_LINETO;\n-        }\n-      // XXX Fill coords with 2 control points and next quarter point\n-      coords[0] = (float) 0;\n-      coords[1] = (float) 0;\n-      coords[2] = (float) 0;\n-      coords[3] = (float) 0;\n-      coords[4] = (float) 0;\n-      coords[5] = (float) 0;\n-      if (xform != null)\n-        xform.transform(coords, 0, coords, 0, 3);\n-      return SEG_CUBICTO;\n+      double[] double_coords = new double[6];\n+      int code = currentSegment (double_coords);\n+      for (int i = 0; i < 6; ++i)\n+        coords[i] = (float) double_coords[i];\n+      return code;\n     }\n \n     /**\n@@ -691,35 +666,99 @@ public int currentSegment(float[] coords)\n      */\n     public int currentSegment(double[] coords)\n     {\n+      double rx = w/2;\n+      double ry = h/2;\n+      double xmid = x + rx;\n+      double ymid = y + ry;\n+     \n       if (current > limit)\n         throw new NoSuchElementException(\"arc iterator out of bounds\");\n+\n       if (current == 0)\n         {\n-          coords[0] = (Math.cos(start) * w + x) / 2;\n-          coords[1] = (Math.sin(start) * h + y) / 2;\n+          coords[0] = xmid + rx * Math.cos(start);\n+          coords[1] = ymid - ry * Math.sin(start);\n           if (xform != null)\n             xform.transform(coords, 0, coords, 0, 1);\n           return SEG_MOVETO;\n         }\n+\n       if (type != OPEN && current == limit)\n         return SEG_CLOSE;\n-      if (type == PIE && current == limit - 1)\n+\n+      if ((current == limit - 1) &&\n+          (type == PIE) || (type == CHORD))\n         {\n-          coords[0] = (float) (x + w / 2);\n-          coords[1] = (float) (y + h / 2);\n+          if (type == PIE)\n+            {\n+              coords[0] = xmid;\n+              coords[1] = ymid;\n+            }\n+          else if (type == CHORD)\n+            {\n+              coords[0] = xmid + rx * Math.cos(start);\n+              coords[1] = ymid - ry * Math.sin(start);\n+            }\n           if (xform != null)\n             xform.transform(coords, 0, coords, 0, 1);\n           return SEG_LINETO;\n         }\n-      // XXX Fill coords with 2 control points and next quarter point\n-      coords[0] = 0;\n-      coords[1] = 0;\n-      coords[2] = 0;\n-      coords[3] = 0;\n-      coords[4] = 0;\n-      coords[5] = 0;\n+\n+      // note that this produces a cubic approximation of the arc segment,\n+      // not a true ellipsoid. there's no ellipsoid path segment code,\n+      // unfortunately. the cubic approximation looks about right, though.\n+\n+      double kappa = (Math.sqrt(2.0) - 1.0) * (4.0 / 3.0);\n+      double quad = (Math.PI / 2.0);\n+\n+      double curr_begin = start + (current - 1) * quad;\n+      double curr_extent = Math.min((start + extent) - curr_begin, quad);\n+      double portion_of_a_quadrant = curr_extent / quad;\n+\n+      double x0 = xmid + rx * Math.cos(curr_begin);\n+      double y0 = ymid - ry * Math.sin(curr_begin);\n+      \n+      double x1 = xmid + rx * Math.cos(curr_begin + curr_extent);\n+      double y1 = ymid - ry * Math.sin(curr_begin + curr_extent);\n+\n+      AffineTransform trans = new AffineTransform ();\n+      double [] cvec = new double[2];\n+      double len = kappa * portion_of_a_quadrant; \n+      double angle = curr_begin; \n+\n+      // in a hypothetical \"first quadrant\" setting, our first control\n+      // vector would be sticking up, from [1,0] to [1,kappa].\n+      //\n+      // let us recall however that in java2d, y coords are upside down\n+      // from what one would consider \"normal\" first quadrant rules, so we\n+      // will *subtract* the y value of this control vector from our first\n+      // point.\n+      \n+      cvec[0] = 0;\n+      cvec[1] = len;\n+      trans.scale (rx, ry);\n+      trans.rotate (angle);\n+      trans.transform(cvec, 0, cvec, 0, 1);\n+      coords[0] = x0 + cvec[0];\n+      coords[1] = y0 - cvec[1];\n+\n+      // control vector #2 would, ideally, be sticking out and to the\n+      // right, in a first quadrant arc segment. again, subtraction of y.\n+\n+      cvec[0] = 0;\n+      cvec[1] = -len;\n+      trans.rotate (curr_extent);\n+      trans.transform(cvec, 0, cvec, 0, 1);\n+      coords[2] = x1 + cvec[0];\n+      coords[3] = y1 - cvec[1];\n+      \n+      // end point\n+      coords[4] = x1;\n+      coords[5] = y1;\n+\n       if (xform != null)\n         xform.transform(coords, 0, coords, 0, 3);\n+\n       return SEG_CUBICTO;\n     }\n   } // class ArcIterator"}, {"sha": "8c6ead242a566814c65fc81bbd372548b2b2e835", "filename": "libjava/java/awt/image/BufferedImage.java", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b2d7c47c40faaf768857fdde27e18a801453d94/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b2d7c47c40faaf768857fdde27e18a801453d94/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java?ref=3b2d7c47c40faaf768857fdde27e18a801453d94", "patch": "@@ -267,9 +267,16 @@ public WritableRaster copyData(WritableRaster dest)\n       raster.createWritableChild(x, y, w, h, x, y,\n \t\t\t\t null  // same bands\n \t\t\t\t );\n-    \n-    // Refer to ComponentDataBlitOp for optimized data blitting:\n-    ComponentDataBlitOp.INSTANCE.filter(src, dest);\n+    if (src.getSampleModel () instanceof ComponentSampleModel\n+        && dest.getSampleModel () instanceof ComponentSampleModel)\n+      // Refer to ComponentDataBlitOp for optimized data blitting:\n+      ComponentDataBlitOp.INSTANCE.filter(src, dest);\n+    else\n+      {\n+        // slower path\n+        int samples[] = src.getPixels (x, y, w, h, (int [])null);\n+        dest.setPixels (x, y, w, h, samples);\n+      }\n     return dest;\n   }\n \n@@ -540,9 +547,18 @@ public void setData(Raster src)\n       raster.createWritableChild(x, y, w, h, x, y,\n \t\t\t\t null  // same bands\n \t\t\t\t );\n-    \n-    // Refer to ComponentDataBlitOp for optimized data blitting:\n-    ComponentDataBlitOp.INSTANCE.filter(src, dest);\n+\n+    if (src.getSampleModel () instanceof ComponentSampleModel\n+        && dest.getSampleModel () instanceof ComponentSampleModel)\n+\n+      // Refer to ComponentDataBlitOp for optimized data blitting:\n+      ComponentDataBlitOp.INSTANCE.filter(src, dest);\n+    else\n+      {\n+        // slower path\n+        int samples[] = src.getPixels (x, y, w, h, (int [])null);\n+        dest.setPixels (x, y, w, h, samples);\n+      }\n   }\n \n   public void setRGB(int x, int y, int argb)"}]}