{"sha": "8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ1N2JkYWRkMmQ5YzJlNWM5NTUxNWNhN2E1ODNkN2I0MDdiNTVjNA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-03-03T23:56:45Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-03-04T00:04:48Z"}, "message": "Correct a workaround for vectorized stores.\n\nResolves:\nPR middle-end/96963 - -Wstringop-overflow false positive with -ftree-vectorize when assigning consecutive char struct members\nPR middle-end/94655 - -Wstringop-overflow on implicit string assignment with vectorized char store\n\ngcc/ChangeLog:\n\n\tPR middle-end/96963\n\tPR middle-end/94655\n\t* builtins.c (handle_array_ref): New helper.\n\t(handle_mem_ref): New helper.\n\t(compute_objsize_r): Factor out ARRAY_REF and MEM_REF handling\n\tinto new helper functions.  Correct a workaround for vectorized\n\tassignments.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/96963\n\tPR middle-end/94655\n\t* gcc.dg/Wstringop-overflow-47.c: Xfail tests.\n\t* gcc.dg/Wstringop-overflow-65.c: New test.\n\t* gcc.dg/Warray-bounds-69.c: Same.", "tree": {"sha": "c7dbd3442b2ad0a283689ae61e707540dd8bc34b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7dbd3442b2ad0a283689ae61e707540dd8bc34b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a5a1e278f91fd7e67fdfbdb8d2f2f72dd566c99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a5a1e278f91fd7e67fdfbdb8d2f2f72dd566c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a5a1e278f91fd7e67fdfbdb8d2f2f72dd566c99"}], "stats": {"total": 397, "additions": 308, "deletions": 89}, "files": [{"sha": "41e336c071c4444738e55ba0a41782d05e311475", "filename": "gcc/builtins.c", "status": "modified", "additions": 128, "deletions": 86, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4", "patch": "@@ -5209,7 +5209,7 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2],\n   return NULL_TREE;\n }\n \n-/* A helper of compute_objsize() to determine the size from an assignment\n+/* A helper of compute_objsize_r() to determine the size from an assignment\n    statement STMT with the RHS of either MIN_EXPR or MAX_EXPR.  */\n \n static bool\n@@ -5287,6 +5287,129 @@ handle_min_max_size (gimple *stmt, int ostype, access_ref *pref,\n   return true;\n }\n \n+/* A helper of compute_objsize_r() to determine the size from ARRAY_REF\n+   AREF.  ADDR is true if PTR is the operand of ADDR_EXPR.  Return true\n+   on success and false on failure.  */\n+\n+static bool\n+handle_array_ref (tree aref, bool addr, int ostype, access_ref *pref,\n+\t\t  ssa_name_limit_t &snlim, pointer_query *qry)\n+{\n+  gcc_assert (TREE_CODE (aref) == ARRAY_REF);\n+\n+  ++pref->deref;\n+\n+  tree arefop = TREE_OPERAND (aref, 0);\n+  tree reftype = TREE_TYPE (arefop);\n+  if (!addr && TREE_CODE (TREE_TYPE (reftype)) == POINTER_TYPE)\n+    /* Avoid arrays of pointers.  FIXME: Hande pointers to arrays\n+       of known bound.  */\n+    return false;\n+\n+  if (!compute_objsize_r (arefop, ostype, pref, snlim, qry))\n+    return false;\n+\n+  offset_int orng[2];\n+  tree off = pref->eval (TREE_OPERAND (aref, 1));\n+  range_query *const rvals = qry ? qry->rvals : NULL;\n+  if (!get_offset_range (off, NULL, orng, rvals))\n+    {\n+      /* Set ORNG to the maximum offset representable in ptrdiff_t.  */\n+      orng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n+      orng[0] = -orng[1] - 1;\n+    }\n+\n+  /* Convert the array index range determined above to a byte\n+     offset.  */\n+  tree lowbnd = array_ref_low_bound (aref);\n+  if (!integer_zerop (lowbnd) && tree_fits_uhwi_p (lowbnd))\n+    {\n+      /* Adjust the index by the low bound of the array domain\n+\t (normally zero but 1 in Fortran).  */\n+      unsigned HOST_WIDE_INT lb = tree_to_uhwi (lowbnd);\n+      orng[0] -= lb;\n+      orng[1] -= lb;\n+    }\n+\n+  tree eltype = TREE_TYPE (aref);\n+  tree tpsize = TYPE_SIZE_UNIT (eltype);\n+  if (!tpsize || TREE_CODE (tpsize) != INTEGER_CST)\n+    {\n+      pref->add_max_offset ();\n+      return true;\n+    }\n+\n+  offset_int sz = wi::to_offset (tpsize);\n+  orng[0] *= sz;\n+  orng[1] *= sz;\n+\n+  if (ostype && TREE_CODE (eltype) == ARRAY_TYPE)\n+    {\n+      /* Except for the permissive raw memory functions which use\n+\t the size of the whole object determined above, use the size\n+\t of the referenced array.  Because the overall offset is from\n+\t the beginning of the complete array object add this overall\n+\t offset to the size of array.  */\n+      offset_int sizrng[2] =\n+\t{\n+\t pref->offrng[0] + orng[0] + sz,\n+\t pref->offrng[1] + orng[1] + sz\n+\t};\n+      if (sizrng[1] < sizrng[0])\n+\tstd::swap (sizrng[0], sizrng[1]);\n+      if (sizrng[0] >= 0 && sizrng[0] <= pref->sizrng[0])\n+\tpref->sizrng[0] = sizrng[0];\n+      if (sizrng[1] >= 0 && sizrng[1] <= pref->sizrng[1])\n+\tpref->sizrng[1] = sizrng[1];\n+    }\n+\n+  pref->add_offset (orng[0], orng[1]);\n+  return true;\n+}\n+\n+/* A helper of compute_objsize_r() to determine the size from MEM_REF\n+   MREF.  Return true on success and false on failure.  */\n+\n+static bool\n+handle_mem_ref (tree mref, int ostype, access_ref *pref,\n+\t\tssa_name_limit_t &snlim, pointer_query *qry)\n+{\n+  gcc_assert (TREE_CODE (mref) == MEM_REF);\n+\n+  ++pref->deref;\n+\n+  if (VECTOR_TYPE_P (TREE_TYPE (mref)))\n+    {\n+      /* Hack: Give up for MEM_REFs of vector types; those may be\n+\t synthesized from multiple assignments to consecutive data\n+\t members (see PR 93200 and 96963).\n+\t FIXME: Vectorized assignments should only be present after\n+\t vectorization so this hack is only necessary after it has\n+\t run and could be avoided in calls from prior passes (e.g.,\n+\t tree-ssa-strlen.c).\n+\t FIXME: Deal with this more generally, e.g., by marking up\n+\t such MEM_REFs at the time they're created.  */\n+      return false;\n+    }\n+\n+  tree mrefop = TREE_OPERAND (mref, 0);\n+  if (!compute_objsize_r (mrefop, ostype, pref, snlim, qry))\n+    return false;\n+\n+  offset_int orng[2];\n+  tree off = pref->eval (TREE_OPERAND (mref, 1));\n+  range_query *const rvals = qry ? qry->rvals : NULL;\n+  if (!get_offset_range (off, NULL, orng, rvals))\n+    {\n+      /* Set ORNG to the maximum offset representable in ptrdiff_t.  */\n+      orng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n+      orng[0] = -orng[1] - 1;\n+    }\n+\n+  pref->add_offset (orng[0], orng[1]);\n+  return true;\n+}\n+\n /* Helper to compute the size of the object referenced by the PTR\n    expression which must have pointer type, using Object Size type\n    OSTYPE (only the least significant 2 bits are used).\n@@ -5419,92 +5542,11 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n       return true;\n     }\n \n-  if (code == ARRAY_REF || code == MEM_REF)\n-    {\n-      ++pref->deref;\n-\n-      tree ref = TREE_OPERAND (ptr, 0);\n-      tree reftype = TREE_TYPE (ref);\n-      if (!addr && code == ARRAY_REF\n-\t  && TREE_CODE (TREE_TYPE (reftype)) == POINTER_TYPE)\n-\t/* Avoid arrays of pointers.  FIXME: Hande pointers to arrays\n-\t   of known bound.  */\n-\treturn false;\n-\n-      if (code == MEM_REF && TREE_CODE (reftype) == POINTER_TYPE)\n-\t{\n-\t  /* Give up for MEM_REFs of vector types; those may be synthesized\n-\t     from multiple assignments to consecutive data members.  See PR\n-\t     93200.\n-\t     FIXME: Deal with this more generally, e.g., by marking up such\n-\t     MEM_REFs at the time they're created.  */\n-\t  reftype = TREE_TYPE (reftype);\n-\t  if (TREE_CODE (reftype) == VECTOR_TYPE)\n-\t    return false;\n-\t}\n-\n-      if (!compute_objsize_r (ref, ostype, pref, snlim, qry))\n-\treturn false;\n-\n-      offset_int orng[2];\n-      tree off = pref->eval (TREE_OPERAND (ptr, 1));\n-      if (!get_offset_range (off, NULL, orng, rvals))\n-\t{\n-\t  /* Set ORNG to the maximum offset representable in ptrdiff_t.  */\n-\t  orng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n-\t  orng[0] = -orng[1] - 1;\n-\t}\n-\n-      if (TREE_CODE (ptr) == ARRAY_REF)\n-\t{\n-\t  /* Convert the array index range determined above to a byte\n-\t     offset.  */\n-\t  tree lowbnd = array_ref_low_bound (ptr);\n-\t  if (!integer_zerop (lowbnd) && tree_fits_uhwi_p (lowbnd))\n-\t    {\n-\t      /* Adjust the index by the low bound of the array domain\n-\t\t (normally zero but 1 in Fortran).  */\n-\t      unsigned HOST_WIDE_INT lb = tree_to_uhwi (lowbnd);\n-\t      orng[0] -= lb;\n-\t      orng[1] -= lb;\n-\t    }\n-\n-\t  tree eltype = TREE_TYPE (ptr);\n-\t  tree tpsize = TYPE_SIZE_UNIT (eltype);\n-\t  if (!tpsize || TREE_CODE (tpsize) != INTEGER_CST)\n-\t    {\n-\t      pref->add_max_offset ();\n-\t      return true;\n-\t    }\n-\n-\t  offset_int sz = wi::to_offset (tpsize);\n-\t  orng[0] *= sz;\n-\t  orng[1] *= sz;\n-\n-\t  if (ostype && TREE_CODE (eltype) == ARRAY_TYPE)\n-\t    {\n-\t      /* Except for the permissive raw memory functions which use\n-\t\t the size of the whole object determined above, use the size\n-\t\t of the referenced array.  Because the overall offset is from\n-\t\t the beginning of the complete array object add this overall\n-\t\t offset to the size of array.  */\n-\t      offset_int sizrng[2] =\n-\t\t{\n-\t\t pref->offrng[0] + orng[0] + sz,\n-\t\t pref->offrng[1] + orng[1] + sz\n-\t\t};\n-\t      if (sizrng[1] < sizrng[0])\n-\t\tstd::swap (sizrng[0], sizrng[1]);\n-\t      if (sizrng[0] >= 0 && sizrng[0] <= pref->sizrng[0])\n-\t\tpref->sizrng[0] = sizrng[0];\n-\t      if (sizrng[1] >= 0 && sizrng[1] <= pref->sizrng[1])\n-\t\tpref->sizrng[1] = sizrng[1];\n-\t    }\n-\t}\n+  if (code == ARRAY_REF)\n+    return handle_array_ref (ptr, addr, ostype, pref, snlim, qry);\n \n-      pref->add_offset (orng[0], orng[1]);\n-      return true;\n-    }\n+  if (code == MEM_REF)\n+    return handle_mem_ref (ptr, ostype, pref, snlim, qry);\n \n   if (code == TARGET_MEM_REF)\n     {"}, {"sha": "5a95577412473c23e8c788c78a2dd4d97ea270f5", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-69.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-69.c?ref=8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4", "patch": "@@ -0,0 +1,74 @@\n+/* Verify that storing a bigger vector into smaller space is diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Warray-bounds\" } */\n+\n+typedef __INT16_TYPE__                         int16_t;\n+typedef __attribute__ ((__vector_size__ (32))) char C32;\n+\n+typedef __attribute__ ((__vector_size__ (64))) int16_t I16_64;\n+\n+void sink (void*);\n+\n+\n+void nowarn_c32 (char c)\n+{\n+  extern char nowarn_a32[32];\n+\n+  void *p = nowarn_a32;\n+  *(C32*)p = (C32){ c };\n+  sink (p);\n+\n+  char a32[32];\n+  p = a32;\n+  *(C32*)p = (C32){ c };\n+  sink (p);\n+}\n+\n+/* The invalid stores below are diagnosed by -Warray-bounds only\n+   because it doesn't use compute_objsize().  If/when that changes\n+   the function might need adjusting to avoid the hack put in place\n+   to avoid false positives due to vectorization.  */\n+\n+void warn_c32 (char c)\n+{\n+  extern char warn_a32[32];   // { dg-message \"'warn_a32'\" \"note\" }\n+\n+  void *p = warn_a32 + 1;\n+  *(C32*)p = (C32){ c };      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  /* Verify a local variable too. */\n+  char a32[32];               // { dg-message \"'a32'\" }\n+  p = a32 + 1;\n+  *(C32*)p = (C32){ c };      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+}\n+\n+\n+void nowarn_i16_64 (int16_t i)\n+{\n+  extern char nowarn_a64[64];\n+\n+  void *p = nowarn_a64;\n+  I16_64 *q = (I16_64*)p;\n+  *q = (I16_64){ i };\n+\n+  char a64[64];\n+  q = (I16_64*)a64;\n+  *q = (I16_64){ i };\n+  sink (q);\n+}\n+\n+void warn_i16_64 (int16_t i)\n+{\n+  extern char warn_a64[64];   // { dg-message \"'warn_a64'\" }\n+\n+  void *p = warn_a64 + 1;\n+  I16_64 *q = (I16_64*)p;\n+  *q = (I16_64){ i };         // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  char a64[64];               // { dg-message \"'a64'\" }\n+  p = a64 + 1;\n+  q = (I16_64*)p;\n+  *q = (I16_64){ i };         // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+}"}, {"sha": "9bfc84af5697f4a4ee0e7609dab66841a49fb445", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-47.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c?ref=8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4", "patch": "@@ -24,17 +24,22 @@ void nowarn_c32 (char c)\n   sink (p);\n }\n \n+/* The tests below fail as a result of the hack for PR 96963.  However,\n+   with -Wall, the invalid stores are diagnosed by -Warray-bounds which\n+   runs before vectorization and so doesn't need the hack.  If/when\n+   -Warray changes to use compute_objsize() this will need adjusting.  */\n+\n void warn_c32 (char c)\n {\n-  extern char warn_a32[32];   // { dg-message \"at offset 32 into destination object 'warn_a32' of size 32\" \"note\" }\n+  extern char warn_a32[32];   // { dg-message \"at offset 32 into destination object 'warn_a32' of size 32\" \"pr97027\" { xfail *-*-* } }\n \n   void *p = warn_a32 + 1;\n-  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" }\n+  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" { xfail *-*-* } }\n \n   /* Verify a local variable too. */\n   char a32[32];\n   p = a32 + 1;\n-  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" }\n+  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" { xfail *-*-* } }\n   sink (p);\n }\n "}, {"sha": "9f82d73e3114c0fda0f4971dae2dc7c356df3bde", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-65.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-65.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-65.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-65.c?ref=8d57bdadd2d9c2e5c95515ca7a583d7b407b55c4", "patch": "@@ -0,0 +1,98 @@\n+/* PR middle-end/96963 - -Wstringop-overflow false positive with\n+   -ftree-vectorize when assigning consecutive char struct members\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftree-vectorize\" } */\n+\n+void sink (void*);\n+\n+struct Char\n+{\n+  int i;\n+  char c, d, e, f;\n+  char a[2], b[2];\n+};\n+\n+void nowarn_char_assign (struct Char *p)\n+{\n+  sink (&p->c);\n+\n+  /* Verify the bogus warning triggered by the tree-ssa-strlen.c pass\n+     is not issued.  */\n+  p->c = 1;         // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+  p->d = 2;\n+  p->e = 3;\n+  p->f = 4;\n+}\n+\n+void nowarn_char_array_assign (struct Char *p)\n+{\n+  sink (p->a);\n+\n+  p->a[0] = 1;      // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+  p->a[1] = 2;\n+  p->b[0] = 3;\n+  p->b[1] = 4;\n+}\n+\n+void warn_char_array_assign_interior (struct Char *p)\n+{\n+  sink (p->a);\n+\n+  p->a[0] = 1;\n+  p->a[1] = 2;\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Warray-bounds\"\n+  /* Warnings are only suppressed for trailing arrays.  Verify\n+     one is issued for an interior array.  */\n+  p->a[2] = 5;      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+#pragma GCC diagnostic pop\n+}\n+\n+void warn_char_array_assign_trailing (struct Char *p)\n+{\n+  /* This is separated from warn_char_array_assign_interior because\n+     otherwise GCC removes the store to p->a[2] as dead since it's\n+     overwritten by p->b[0].  */\n+  sink (p->b);\n+\n+  p->b[0] = 3;\n+  p->b[1] = 4;\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Warray-bounds\"\n+  /* Warnings are only suppressed for trailing arrays with at most\n+     one element.  Verify one is issued for a two-element array.  */\n+  p->b[2] = 5;      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+#pragma GCC diagnostic pop\n+}\n+\n+\n+/* Also verify there's no warning for other types than char (even though\n+   the problem was limited to chars and -Wstringop-overflow should only\n+   trigger for character accesses).  */\n+\n+struct Short\n+{\n+  int i;\n+  short c, d, e, f;\n+  short a[2], b[2];\n+};\n+\n+void nowarn_short_assign (struct Short *p)\n+{\n+  sink (&p->c);\n+\n+  p->c = 1;\n+  p->d = 2;\n+  p->e = 3;\n+  p->f = 4;\n+}\n+\n+void nowarn_short_array_assign (struct Short *p)\n+{\n+  sink (p->a);\n+\n+  p->a[0] = 1;\n+  p->a[1] = 2;\n+  p->b[0] = 3;\n+  p->b[1] = 4;\n+}"}]}