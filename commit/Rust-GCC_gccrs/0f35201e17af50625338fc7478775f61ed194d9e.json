{"sha": "0f35201e17af50625338fc7478775f61ed194d9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYzNTIwMWUxN2FmNTA2MjUzMzhmYzc0Nzg3NzVmNjFlZDE5NGQ5ZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2006-04-18T23:45:47Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2006-04-18T23:45:47Z"}, "message": "re PR rtl-optimization/26026 (power of 2 mod missing optimisation)\n\n\tPR rtl-optimization/26026\n\t* fold-const.c (fold_binary): Optimize div and mod where the divisor\n\tis a known power of two shifted left a variable amount.\n\nFrom-SVN: r113060", "tree": {"sha": "f0c3476c5279bc39e419859f887be884c47c8f87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0c3476c5279bc39e419859f887be884c47c8f87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f35201e17af50625338fc7478775f61ed194d9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f35201e17af50625338fc7478775f61ed194d9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f35201e17af50625338fc7478775f61ed194d9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f35201e17af50625338fc7478775f61ed194d9e/comments", "author": null, "committer": null, "parents": [{"sha": "76f7a74ff6e0603026f74c23559b8b9fae209a10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f7a74ff6e0603026f74c23559b8b9fae209a10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76f7a74ff6e0603026f74c23559b8b9fae209a10"}], "stats": {"total": 60, "additions": 39, "deletions": 21}, "files": [{"sha": "f8968eaa2a10a9a0e4865b82a1715d8cdd213cf8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f35201e17af50625338fc7478775f61ed194d9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f35201e17af50625338fc7478775f61ed194d9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f35201e17af50625338fc7478775f61ed194d9e", "patch": "@@ -1,3 +1,9 @@\n+2006-04-19  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR rtl-optimization/26026\n+\t* fold-const.c (fold_binary): Optimize div and mod where the divisor\n+\tis a known power of two shifted left a variable amount.\n+\n 2006-04-18  Geoffrey Keating  <geoffk@apple.com>\n \n \t* dwarf2out.c (prune_unused_types_update_strings): Don't add strings"}, {"sha": "39bd36689d5bab60a9d45d2e4bd0dc5cd445c18a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f35201e17af50625338fc7478775f61ed194d9e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f35201e17af50625338fc7478775f61ed194d9e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0f35201e17af50625338fc7478775f61ed194d9e", "patch": "@@ -9600,8 +9600,27 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       return NULL_TREE;\n \n     case TRUNC_DIV_EXPR:\n-    case ROUND_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n+      /* Simplify A / (B << N) where A and B are positive and B is\n+\t a power of 2, to A >> (N + log2(B)).  */\n+      if (TREE_CODE (arg1) == LSHIFT_EXPR\n+\t  && (TYPE_UNSIGNED (type) || tree_expr_nonnegative_p (arg0)))\n+\t{\n+\t  tree sval = TREE_OPERAND (arg1, 0);\n+\t  if (integer_pow2p (sval) && tree_int_cst_sgn (sval) > 0)\n+\t    {\n+\t      tree sh_cnt = TREE_OPERAND (arg1, 1);\n+\t      unsigned long pow2 = exact_log2 (TREE_INT_CST_LOW (sval));\n+\n+\t      sh_cnt = fold_build2 (PLUS_EXPR, TREE_TYPE (sh_cnt),\n+\t\t\t\t    sh_cnt, build_int_cst (NULL_TREE, pow2));\n+\t      return fold_build2 (RSHIFT_EXPR, type,\n+\t\t\t\t  fold_convert (type, arg0), sh_cnt);\n+\t    }\n+\t}\n+      /* Fall thru */\n+\n+    case ROUND_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n       if (integer_onep (arg1))\n@@ -9671,31 +9690,24 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \treturn omit_one_operand (type, integer_zero_node, arg0);\n \n       /* Optimize TRUNC_MOD_EXPR by a power of two into a BIT_AND_EXPR,\n-         i.e. \"X % C\" into \"X & C2\", if X and C are positive.  */\n+         i.e. \"X % C\" into \"X & (C - 1)\", if X and C are positive.  */\n       if ((code == TRUNC_MOD_EXPR || code == FLOOR_MOD_EXPR)\n-\t  && (TYPE_UNSIGNED (type) || tree_expr_nonnegative_p (arg0))\n-\t  && integer_pow2p (arg1) && tree_int_cst_sgn (arg1) >= 0)\n+\t  && (TYPE_UNSIGNED (type) || tree_expr_nonnegative_p (arg0)))\n \t{\n-\t  unsigned HOST_WIDE_INT high, low;\n-\t  tree mask;\n-\t  int l;\n+\t  tree c = arg1;\n+\t  /* Also optimize A % (C << N)  where C is a power of 2,\n+\t     to A & ((C << N) - 1).  */\n+\t  if (TREE_CODE (arg1) == LSHIFT_EXPR)\n+\t    c = TREE_OPERAND (arg1, 0);\n \n-\t  l = tree_log2 (arg1);\n-\t  if (l >= HOST_BITS_PER_WIDE_INT)\n-\t    {\n-\t      high = ((unsigned HOST_WIDE_INT) 1\n-\t\t      << (l - HOST_BITS_PER_WIDE_INT)) - 1;\n-\t      low = -1;\n-\t    }\n-\t  else\n+\t  if (integer_pow2p (c) && tree_int_cst_sgn (c) > 0)\n \t    {\n-\t      high = 0;\n-\t      low = ((unsigned HOST_WIDE_INT) 1 << l) - 1;\n+\t      tree mask = fold_build2 (MINUS_EXPR, TREE_TYPE (arg1),\n+\t\t\t\t       arg1, integer_one_node);\n+\t      return fold_build2 (BIT_AND_EXPR, type,\n+\t\t\t\t  fold_convert (type, arg0),\n+\t\t\t\t  fold_convert (type, mask));\n \t    }\n-\n-\t  mask = build_int_cst_wide (type, low, high);\n-\t  return fold_build2 (BIT_AND_EXPR, type,\n-\t\t\t      fold_convert (type, arg0), mask);\n \t}\n \n       /* X % -C is the same as X % C.  */"}]}