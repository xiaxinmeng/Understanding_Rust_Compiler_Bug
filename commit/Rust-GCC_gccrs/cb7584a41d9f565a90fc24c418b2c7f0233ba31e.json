{"sha": "cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I3NTg0YTQxZDlmNTY1YTkwZmMyNGM0MThiMmM3ZjAyMzNiYTMxZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-06-27T10:39:49Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-21T07:22:50Z"}, "message": "[Ada] Support of attributes Image, Put_Image, Val and Width for 128-bit types\n\ngcc/ada/\n\n\t* Makefile.rtl (GNATRTL_NONTASKING_OBJS): Add s-widint,\n\ts-widthi, s-widuns, s-widuns.\n\t(GNATRTL_128BIT_OBJS): Add s-imglllb, s-imgllli, s-imglllu, s-imglllw,\n\ts-valllli, s-vallllu, s-widllli, s-widlllu.\n\t* exp_imgv.adb (Expand_Image_Attribute): Deal with 128-bit types.\n\t(Expand_Value_Attribute): Likewise.\n\t(Expand_Width_Attribute): Likewise.\n\t* exp_put_image.adb (Build_Elementary_Put_Image_Call): Likewise.\n\t* krunch.adb (Krunch): Deal with s-img, s-val and s-wid prefixes.\n\t* rtsfind.ads (RTU_Id): Add System_Img_LLLI, System_Img_LLLU,\n\tSystem_Val_LLLI, System_Val_LLL, System_Wid_Int, System_Wid_LLLI,\n\tSystem_Wid_LLLU, System_Wid_Uns).\n\t(RE_Id): Add RE_Image_Long_Long_Long_Integer,\n\tRE_Image_Long_Long_Long_Unsigned,\n\tRE_Put_Image_Long_Long_Long_Integer,\n\tRE_Put_Image_Long_Long_Long_Unsigned,\n\tRE_Long_Long_Long_Unsigned, RE_Value_Long_Long_Long_Integer,\n\tRE_Value_Long_Long_Long_Unsigned, RE_Width_Integer,\n\tRE_Width_Long_Long_Long_Integer, RE_Width_Long_Long_Long_Unsigned,\n\tRE_Width_Unsigned, RE_Image_Long_Long_Long_Integer,\n\tRE_Image_Long_Long_Long_Unsigned, RE_Put_Image_Long_Long_Long_Integer,\n\tRE_Put_Image_Long_Long_Long_Unsigned, RE_Long_Long_Long_Unsigned,\n\tRE_Value_Long_Long_Long_Integer, RE_Value_Long_Long_Long_Unsigned,\n\tRE_Width_Integer, RE_Width_Long_Long_Long_Integer,\n\tRE_Width_Long_Long_Long_Unsigned, RE_Width_Unsigned.\n\t* libgnat/s-imageb.ads, libgnat/s-imageb.adb: New generic\n\tpackage.\n\t* libgnat/s-imagei.ads, libgnat/s-imagei.adb: Likewise.\n\t* libgnat/s-imageu.ads, libgnat/s-imageu.adb: Likewise.\n\t* libgnat/s-imagew.ads, libgnat/s-imagew.adb: Likewise.\n\t* libgnat/s-imgbiu.ads: Instantiate System.Image_B.\n\t* libgnat/s-imgbiu.adb: Add pragma No_Body.\n\t* libgnat/s-imgint.ads: Instantiate System.Image_I.\n\t* libgnat/s-imgint.adb: Add pragma No_Body.\n\t* libgnat/s-imgllb.ads: Instantiate System.Image_B.\n\t* libgnat/s-imgllb.adb: Add pragma No_Body0\n\t* libgnat/s-imglli.ads: Instantiate System.Image_I.\n\t* libgnat/s-imglli.adb: Add pragma No_Body.\n\t* libgnat/s-imglllb.ads: Instantiate System.Image_B.\n\t* libgnat/s-imgllli.ads: Instantiate System.Image_I.\n\t* libgnat/s-imglllu.ads: Instantiate System.Image_U.\n\t* libgnat/s-imglllw.ads: Instantiate System.Image_W.\n\t* libgnat/s-imgllu.ads: Instantiate System.Image_U.\n\t* libgnat/s-imgllu.adb: Add pragma No_Body.\n\t* libgnat/s-imgllw.ads: Instantiate System.Image_W.\n\t* libgnat/s-imgllw.adb: Add pragma No_Body.\n\t* libgnat/s-imgrea.adb: Remove clauses for System.Unsigned_Types.\n\t* libgnat/s-imguns.ads: Instantiate System.Image_U.\n\t* libgnat/s-imguns.adb: Add pragma No_Body.\n\t* libgnat/s-imgwiu.ads: Instantiate System.Image_W.\n\t* libgnat/s-imgwiu.adb: Add pragma No_Body.\n\t* libgnat/s-putima.ads (Long_Long_Long_Unsigned): New subtype.\n\t(Put_Image_Long_Long_Long_Unsigned): New procedure.\n\t* libgnat/s-putima.adb (Small): Rename to Integer_Images.\n\t(Large): Rename to LL_Integer_Images.\n\t(LLL_Integer_Images): New instantiation.\n\t(Put_Image_Long_Long_Long_Integer): New renaming.\n\t(Put_Image_Long_Long_Long_Unsigned): Likewise.\n\t* libgnat/s-valint.ads: Instantiate System.Value_I.\n\t* libgnat/s-valint.adb: Add pragma No_Body.\n\t* libgnat/s-vallli.ads: Instantiate System.Value_I.\n\t* libgnat/s-vallli.adb: Add pragma No_Body.\n\t* libgnat/s-valllli.ads: Instantiate System.Value_I.\n\t* libgnat/s-vallllu.ads: Instantiate System.Value_U.\n\t* libgnat/s-valllu.ads: Instantiate System.Value_U.\n\t* libgnat/s-valllu.adb: Add pragma No_Body.\n\t* libgnat/s-valuei.ads, libgnat/s-valuei.adb: New generic\n\tpackage.\n\t* libgnat/s-valueu.ads, libgnat/s-valueu.adb: Likewise.\n\t* libgnat/s-valuns.ads: Instantiate System.Value_U.\n\t* libgnat/s-valuns.adb: Add pragma No_Body.\n\t* libgnat/s-widint.ads: Instantiate System.Width_I.\n\t* libgnat/s-widlli.ads: Likewise.\n\t* libgnat/s-widlli.adb: Add pragma No_Body.\n\t* libgnat/s-widllli.ads: Instantiate System.Width_I.\n\t* libgnat/s-widlllu.ads: Instantiate System.Width_U.\n\t* libgnat/s-widllu.ads: Likewise.\n\t* libgnat/s-widllu.adb: Add pragma No_Body.\n\t* libgnat/s-widthi.ads, libgnat/s-widthi.adb: New generic\n\tpackage.\n\t* libgnat/s-widthu.ads, libgnat/s-widthu.adb: Likewise.\n\t* libgnat/s-widuns.ads: Instantiate System.Width_U.", "tree": {"sha": "7ef8b462ba914a8cdfa99de9f3845ffbe5ef0a7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ef8b462ba914a8cdfa99de9f3845ffbe5ef0a7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a219511d1d20775ea418de1b7e60dd90030c8354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a219511d1d20775ea418de1b7e60dd90030c8354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a219511d1d20775ea418de1b7e60dd90030c8354"}], "stats": {"total": 4530, "additions": 2516, "deletions": 2014}, "files": [{"sha": "61da47bb330d65608a26856ff04822b364121594", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -604,6 +604,10 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-geveop$(objext) \\\n   s-gloloc$(objext) \\\n   s-htable$(objext) \\\n+  s-imageb$(objext) \\\n+  s-imagei$(objext) \\\n+  s-imageu$(objext) \\\n+  s-imagew$(objext) \\\n   s-imenne$(objext) \\\n   s-imgbiu$(objext) \\\n   s-imgboo$(objext) \\\n@@ -738,6 +742,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-vallli$(objext) \\\n   s-valllu$(objext) \\\n   s-valrea$(objext) \\\n+  s-valuei$(objext) \\\n+  s-valueu$(objext) \\\n   s-valuns$(objext) \\\n   s-valuti$(objext) \\\n   s-valwch$(objext) \\\n@@ -752,8 +758,12 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-widboo$(objext) \\\n   s-widcha$(objext) \\\n   s-widenu$(objext) \\\n+  s-widint$(objext) \\\n   s-widlli$(objext) \\\n   s-widllu$(objext) \\\n+  s-widthi$(objext) \\\n+  s-widthu$(objext) \\\n+  s-widuns$(objext) \\\n   s-widwch$(objext) \\\n   s-wwdcha$(objext) \\\n   s-wwdenu$(objext) \\\n@@ -883,6 +893,10 @@ GNATRTL_128BIT_OBJS = \\\n   s-exnllli$(objext) \\\n   s-expllli$(objext) \\\n   s-explllu$(objext) \\\n+  s-imglllb$(objext) \\\n+  s-imgllli$(objext) \\\n+  s-imglllu$(objext) \\\n+  s-imglllw$(objext) \\\n   s-pack65$(objext)  \\\n   s-pack66$(objext)  \\\n   s-pack67$(objext)  \\\n@@ -945,7 +959,11 @@ GNATRTL_128BIT_OBJS = \\\n   s-pack124$(objext) \\\n   s-pack125$(objext) \\\n   s-pack126$(objext) \\\n-  s-pack127$(objext)\n+  s-pack127$(objext) \\\n+  s-valllli$(objext) \\\n+  s-vallllu$(objext) \\\n+  s-widllli$(objext) \\\n+  s-widlllu$(objext)\n \n # Shared library version\n LIB_VERSION = $(strip $(shell grep ' Library_Version :' $(GNAT_SRC)/gnatvsn.ads | sed -e 's/.*\"\\(.*\\)\".*/\\1/'))"}, {"sha": "5850b5d2fe140cc2645f044694fc663986053b53", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -570,21 +570,27 @@ package body Exp_Imgv is\n          Tent := Rtyp;\n \n       elsif Is_Signed_Integer_Type (Rtyp) then\n-         if Esize (Rtyp) <= Esize (Standard_Integer) then\n+         if Esize (Rtyp) <= Standard_Integer_Size then\n             Imid := RE_Image_Integer;\n             Tent := Standard_Integer;\n-         else\n+         elsif Esize (Rtyp) <= Standard_Long_Long_Integer_Size then\n             Imid := RE_Image_Long_Long_Integer;\n             Tent := Standard_Long_Long_Integer;\n+         else\n+            Imid := RE_Image_Long_Long_Long_Integer;\n+            Tent := Standard_Long_Long_Long_Integer;\n          end if;\n \n       elsif Is_Modular_Integer_Type (Rtyp) then\n          if Modulus (Rtyp) <= Modulus (RTE (RE_Unsigned)) then\n             Imid := RE_Image_Unsigned;\n             Tent := RTE (RE_Unsigned);\n-         else\n+         elsif Modulus (Rtyp) <= Modulus (RTE (RE_Long_Long_Unsigned)) then\n             Imid := RE_Image_Long_Long_Unsigned;\n             Tent := RTE (RE_Long_Long_Unsigned);\n+         else\n+            Imid := RE_Image_Long_Long_Long_Unsigned;\n+            Tent := RTE (RE_Long_Long_Long_Unsigned);\n          end if;\n \n       elsif Is_Fixed_Point_Type (Rtyp) and then Has_Decimal_Small (Rtyp) then\n@@ -895,20 +901,22 @@ package body Exp_Imgv is\n            Make_Integer_Literal (Loc,\n              Intval => Int (Wide_Character_Encoding_Method)));\n \n-      elsif     Rtyp = Base_Type (Standard_Short_Short_Integer)\n-        or else Rtyp = Base_Type (Standard_Short_Integer)\n-        or else Rtyp = Base_Type (Standard_Integer)\n-      then\n-         Vid := RE_Value_Integer;\n-\n       elsif Is_Signed_Integer_Type (Rtyp) then\n-         Vid := RE_Value_Long_Long_Integer;\n+         if Esize (Rtyp) <= Standard_Integer_Size then\n+            Vid := RE_Value_Integer;\n+         elsif Esize (Rtyp) <= Standard_Long_Long_Integer_Size then\n+            Vid := RE_Value_Long_Long_Integer;\n+         else\n+            Vid := RE_Value_Long_Long_Long_Integer;\n+         end if;\n \n       elsif Is_Modular_Integer_Type (Rtyp) then\n          if Modulus (Rtyp) <= Modulus (RTE (RE_Unsigned)) then\n             Vid := RE_Value_Unsigned;\n-         else\n+         elsif Modulus (Rtyp) <= Modulus (RTE (RE_Long_Long_Unsigned)) then\n             Vid := RE_Value_Long_Long_Unsigned;\n+         else\n+            Vid := RE_Value_Long_Long_Long_Unsigned;\n          end if;\n \n       elsif Is_Decimal_Fixed_Point_Type (Rtyp) then\n@@ -1415,14 +1423,30 @@ package body Exp_Imgv is\n       --  Signed integer types\n \n       elsif Is_Signed_Integer_Type (Rtyp) then\n-         XX := RE_Width_Long_Long_Integer;\n-         YY := Standard_Long_Long_Integer;\n+         if Esize (Rtyp) <= Standard_Integer_Size then\n+            XX := RE_Width_Integer;\n+            YY := Standard_Integer;\n+         elsif Esize (Rtyp) <= Standard_Long_Long_Integer_Size then\n+            XX := RE_Width_Long_Long_Integer;\n+            YY := Standard_Long_Long_Integer;\n+         else\n+            XX := RE_Width_Long_Long_Long_Integer;\n+            YY := Standard_Long_Long_Long_Integer;\n+         end if;\n \n       --  Modular integer types\n \n       elsif Is_Modular_Integer_Type (Rtyp) then\n-         XX := RE_Width_Long_Long_Unsigned;\n-         YY := RTE (RE_Long_Long_Unsigned);\n+         if Modulus (Rtyp) <= Modulus (RTE (RE_Unsigned)) then\n+            XX := RE_Width_Unsigned;\n+            YY := RTE (RE_Unsigned);\n+         elsif Modulus (Rtyp) <= Modulus (RTE (RE_Long_Long_Unsigned)) then\n+            XX := RE_Width_Long_Long_Unsigned;\n+            YY := RTE (RE_Long_Long_Unsigned);\n+         else\n+            XX := RE_Width_Long_Long_Long_Unsigned;\n+            YY := RTE (RE_Long_Long_Long_Unsigned);\n+         end if;\n \n       --  Real types\n "}, {"sha": "3fae3174ea1cd0c0b5cd96f921244aa722318802", "filename": "gcc/ada/exp_put_image.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Fexp_put_image.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Fexp_put_image.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_put_image.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -300,17 +300,21 @@ package body Exp_Put_Image is\n       if Is_Signed_Integer_Type (U_Type) then\n          if P_Size <= Standard_Integer_Size then\n             Lib_RE := RE_Put_Image_Integer;\n-         else\n-            pragma Assert (P_Size <= Standard_Long_Long_Integer_Size);\n+         elsif P_Size <= Standard_Long_Long_Integer_Size then\n             Lib_RE := RE_Put_Image_Long_Long_Integer;\n+         else\n+            pragma Assert (P_Size <= Standard_Long_Long_Long_Integer_Size);\n+            Lib_RE := RE_Put_Image_Long_Long_Long_Integer;\n          end if;\n \n       elsif Is_Modular_Integer_Type (U_Type) then\n          if P_Size <= Standard_Integer_Size then -- Yes, Integer\n             Lib_RE := RE_Put_Image_Unsigned;\n-         else\n-            pragma Assert (P_Size <= Standard_Long_Long_Integer_Size);\n+         elsif P_Size <= Standard_Long_Long_Integer_Size then\n             Lib_RE := RE_Put_Image_Long_Long_Unsigned;\n+         else\n+            pragma Assert (P_Size <= Standard_Long_Long_Long_Integer_Size);\n+            Lib_RE := RE_Put_Image_Long_Long_Long_Unsigned;\n          end if;\n \n       elsif Is_Access_Type (U_Type) then"}, {"sha": "ceeba11a38b9104f01f5286b582f60b136990e5b", "filename": "gcc/ada/krunch.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Fkrunch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Fkrunch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fkrunch.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -92,6 +92,9 @@ begin\n       if Buffer (Curlen - 2 .. Curlen) = \"128\"\n         or else Buffer (3 .. 9) = \"exn_lll\"\n         or else Buffer (3 .. 9) = \"exp_lll\"\n+        or else Buffer (3 .. 9) = \"img_lll\"\n+        or else Buffer (3 .. 9) = \"val_lll\"\n+        or else Buffer (3 .. 9) = \"wid_lll\"\n         or else (Buffer (3 .. 6) = \"pack\" and then Curlen = 10)\n       then\n          if Buffer (3 .. 15) = \"compare_array\" then"}, {"sha": "72e8fb369e06c1caedba3f5bbefe7b1ec8b2ae45", "filename": "gcc/ada/libgnat/s-imageb.adb", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imageb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imageb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imageb.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,156 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M A G E _ B                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Image_B is\n+\n+   -----------------------------\n+   -- Set_Image_Based_Integer --\n+   -----------------------------\n+\n+   procedure Set_Image_Based_Integer\n+     (V : Int;\n+      B : Natural;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural)\n+   is\n+      Start : Natural;\n+\n+   begin\n+      --  Positive case can just use the unsigned circuit directly\n+\n+      if V >= 0 then\n+         Set_Image_Based_Unsigned (Uns (V), B, W, S, P);\n+\n+      --  Negative case has to set a minus sign. Note also that we have to be\n+      --  careful not to generate overflow with the largest negative number.\n+\n+      else\n+         P := P + 1;\n+         S (P) := ' ';\n+         Start := P;\n+\n+         declare\n+            pragma Suppress (Overflow_Check);\n+            pragma Suppress (Range_Check);\n+         begin\n+            Set_Image_Based_Unsigned (Uns (-V), B, W - 1, S, P);\n+         end;\n+\n+         --  Set minus sign in last leading blank location. Because of the\n+         --  code above, there must be at least one such location.\n+\n+         while S (Start + 1) = ' ' loop\n+            Start := Start + 1;\n+         end loop;\n+\n+         S (Start) := '-';\n+      end if;\n+\n+   end Set_Image_Based_Integer;\n+\n+   ------------------------------\n+   -- Set_Image_Based_Unsigned --\n+   ------------------------------\n+\n+   procedure Set_Image_Based_Unsigned\n+     (V : Uns;\n+      B : Natural;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural)\n+   is\n+      Start : constant Natural := P;\n+      F, T  : Natural;\n+      BU    : constant Uns := Uns (B);\n+      Hex   : constant array\n+                (Uns range 0 .. 15) of Character := \"0123456789ABCDEF\";\n+\n+      procedure Set_Digits (T : Uns);\n+      --  Set digits of absolute value of T\n+\n+      ----------------\n+      -- Set_Digits --\n+      ----------------\n+\n+      procedure Set_Digits (T : Uns) is\n+      begin\n+         if T >= BU then\n+            Set_Digits (T / BU);\n+            P := P + 1;\n+            S (P) := Hex (T mod BU);\n+         else\n+            P := P + 1;\n+            S (P) := Hex (T);\n+         end if;\n+      end Set_Digits;\n+\n+   --  Start of processing for Set_Image_Based_Unsigned\n+\n+   begin\n+\n+      if B >= 10 then\n+         P := P + 1;\n+         S (P) := '1';\n+      end if;\n+\n+      P := P + 1;\n+      S (P) := Character'Val (Character'Pos ('0') + B mod 10);\n+\n+      P := P + 1;\n+      S (P) := '#';\n+\n+      Set_Digits (V);\n+\n+      P := P + 1;\n+      S (P) := '#';\n+\n+      --  Add leading spaces if required by width parameter\n+\n+      if P - Start < W then\n+         F := P;\n+         P := Start + W;\n+         T := P;\n+\n+         while F > Start loop\n+            S (T) := S (F);\n+            T := T - 1;\n+            F := F - 1;\n+         end loop;\n+\n+         for J in Start + 1 .. T loop\n+            S (J) := ' ';\n+         end loop;\n+      end if;\n+\n+   end Set_Image_Based_Unsigned;\n+\n+end System.Image_B;"}, {"sha": "109f5c7914e8fe65b3c2765596c37d3fc515d131", "filename": "gcc/ada/libgnat/s-imageb.ads", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imageb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imageb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imageb.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,75 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M A G E _ B                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Contains the routine for computing the image in based format of signed and\n+--  unsigned integers for use by Text_IO.Integer_IO and Text_IO.Modular_IO.\n+\n+generic\n+\n+   type Int is range <>;\n+\n+   type Uns is mod <>;\n+\n+package System.Image_B is\n+   pragma Pure;\n+\n+   procedure Set_Image_Based_Integer\n+     (V : Int;\n+      B : Natural;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural);\n+   --  Sets the signed image of V in based format, using base value B (2..16)\n+   --  starting at S (P + 1), updating P to point to the last character stored.\n+   --  The image includes a leading minus sign if necessary, but no leading\n+   --  spaces unless W is positive, in which case leading spaces are output if\n+   --  necessary to ensure that the output string is no less than W characters\n+   --  long. The caller promises that the buffer is large enough and no check\n+   --  is made for this. Constraint_Error will not necessarily be raised if\n+   --  this is violated, since it is perfectly valid to compile this unit with\n+   --  checks off.\n+\n+   procedure Set_Image_Based_Unsigned\n+     (V : Uns;\n+      B : Natural;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural);\n+   --  Sets the unsigned image of V in based format, using base value B (2..16)\n+   --  starting at S (P + 1), updating P to point to the last character stored.\n+   --  The image includes no leading spaces unless W is positive, in which case\n+   --  leading spaces are output if necessary to ensure that the output string\n+   --  is no less than W characters long. The caller promises that the buffer\n+   --  is large enough and no check is made for this. Constraint_Error will not\n+   --  necessarily be raised if this is violated, since it is perfectly valid\n+   --  to compile this unit with checks off).\n+\n+end System.Image_B;"}, {"sha": "c739dfb8af6d68bf048e5c5460ad3433e682689f", "filename": "gcc/ada/libgnat/s-imagei.adb", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imagei.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imagei.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagei.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,121 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M A G E _ I                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Image_I is\n+\n+   subtype Non_Positive is Int range Int'First .. 0;\n+\n+   procedure Set_Digits\n+     (T : Non_Positive;\n+      S : in out String;\n+      P : in out Natural);\n+   --  Set digits of absolute value of T, which is zero or negative. We work\n+   --  with the negative of the value so that the largest negative number is\n+   --  not a special case.\n+\n+   -------------------\n+   -- Image_Integer --\n+   -------------------\n+\n+   procedure Image_Integer\n+     (V : Int;\n+      S : in out String;\n+      P : out Natural)\n+   is\n+      pragma Assert (S'First = 1);\n+\n+   begin\n+      if V >= 0 then\n+         S (1) := ' ';\n+         P := 1;\n+      else\n+         P := 0;\n+      end if;\n+\n+      Set_Image_Integer (V, S, P);\n+   end Image_Integer;\n+\n+   ----------------\n+   -- Set_Digits --\n+   ----------------\n+\n+   procedure Set_Digits\n+     (T : Non_Positive;\n+      S : in out String;\n+      P : in out Natural)\n+   is\n+   begin\n+      if T <= -10 then\n+         Set_Digits (T / 10, S, P);\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the Set_Image_Integer\n+         --  specification, the caller guarantees that S is long enough to\n+         --  hold the result.\n+         P := P + 1;\n+         S (P) := Character'Val (48 - (T rem 10));\n+\n+      else\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the Set_Image_Integer\n+         --  specification, the caller guarantees that S is long enough to\n+         --  hold the result.\n+         P := P + 1;\n+         S (P) := Character'Val (48 - T);\n+      end if;\n+   end Set_Digits;\n+\n+   -----------------------\n+   -- Set_Image_Integer --\n+   -----------------------\n+\n+   procedure Set_Image_Integer\n+     (V : Int;\n+      S : in out String;\n+      P : in out Natural)\n+   is\n+   begin\n+      if V >= 0 then\n+         Set_Digits (-V, S, P);\n+\n+      else\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the specification,\n+         --  the caller guarantees that S is long enough to hold the result.\n+         P := P + 1;\n+         S (P) := '-';\n+         Set_Digits (V, S, P);\n+      end if;\n+   end Set_Image_Integer;\n+\n+end System.Image_I;"}, {"sha": "2163af8c53b9568c62b6e05fc4772fe21432dd45", "filename": "gcc/ada/libgnat/s-imagei.ads", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imagei.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imagei.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagei.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M A G E _ I                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines for supporting the Image attribute for\n+--  signed integer types, and also for conversion operations required in\n+--  Text_IO.Integer_IO for such types.\n+\n+generic\n+\n+   type Int is range <>;\n+\n+package System.Image_I is\n+   pragma Pure;\n+\n+   procedure Image_Integer\n+     (V : Int;\n+      S : in out String;\n+      P : out Natural);\n+   --  Computes Int'Image (V) and stores the result in S (1 .. P)\n+   --  setting the resulting value of P. The caller guarantees that S\n+   --  is long enough to hold the result, and that S'First is 1.\n+\n+   procedure Set_Image_Integer\n+     (V : Int;\n+      S : in out String;\n+      P : in out Natural);\n+   --  Stores the image of V in S starting at S (P + 1), P is updated to point\n+   --  to the last character stored. The value stored is identical to the value\n+   --  of Int'Image (V) except that no leading space is stored when V is\n+   --  non-negative. The caller guarantees that S is long enough to hold the\n+   --  result. S need not have a lower bound of 1.\n+\n+end System.Image_I;"}, {"sha": "c995d554d1773d20b0126453e959d7366a45e994", "filename": "gcc/ada/libgnat/s-imageu.adb", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imageu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imageu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imageu.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,79 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M A G E _ U                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Image_U is\n+\n+   --------------------\n+   -- Image_Unsigned --\n+   --------------------\n+\n+   procedure Image_Unsigned\n+     (V : Uns;\n+      S : in out String;\n+      P : out Natural)\n+   is\n+      pragma Assert (S'First = 1);\n+   begin\n+      S (1) := ' ';\n+      P := 1;\n+      Set_Image_Unsigned (V, S, P);\n+   end Image_Unsigned;\n+\n+   ------------------------\n+   -- Set_Image_Unsigned --\n+   ------------------------\n+\n+   procedure Set_Image_Unsigned\n+     (V : Uns;\n+      S : in out String;\n+      P : in out Natural)\n+   is\n+   begin\n+      if V >= 10 then\n+         Set_Image_Unsigned (V / 10, S, P);\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the specification,\n+         --  the caller guarantees that S is long enough to hold the result.\n+         P := P + 1;\n+         S (P) := Character'Val (48 + (V rem 10));\n+\n+      else\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the specification,\n+         --  the caller guarantees that S is long enough to hold the result.\n+         P := P + 1;\n+         S (P) := Character'Val (48 + V);\n+      end if;\n+   end Set_Image_Unsigned;\n+\n+end System.Image_U;"}, {"sha": "39e738a6ba91420ce31b636110aff61187c77711", "filename": "gcc/ada/libgnat/s-imageu.ads", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imageu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imageu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imageu.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,62 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M A G E _ U                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines for supporting the Image attribute for\n+--  modular integer types, and also for conversion operations required in\n+--  Text_IO.Modular_IO for such types.\n+\n+generic\n+\n+   type Uns is mod <>;\n+\n+package System.Image_U is\n+   pragma Pure;\n+\n+   procedure Image_Unsigned\n+     (V : Uns;\n+      S : in out String;\n+      P : out Natural);\n+   pragma Inline (Image_Unsigned);\n+   --  Computes Uns'Image (V) and stores the result in S (1 .. P) setting\n+   --  the resulting value of P. The caller guarantees that S is long enough to\n+   --  hold the result, and that S'First is 1.\n+\n+   procedure Set_Image_Unsigned\n+     (V : Uns;\n+      S : in out String;\n+      P : in out Natural);\n+   --  Stores the image of V in S starting at S (P + 1), P is updated to point\n+   --  to the last character stored. The value stored is identical to the value\n+   --  of Uns'Image (V) except that no leading space is stored. The caller\n+   --  guarantees that S is long enough to hold the result. S need not have a\n+   --  lower bound of 1.\n+\n+end System.Image_U;"}, {"sha": "dd3b96eb430141616ab13fa83a0c7a1fb6f7f6be", "filename": "gcc/ada/libgnat/s-imagew.adb", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imagew.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imagew.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagew.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,152 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M A G E _ W                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Image_W is\n+\n+   -----------------------------\n+   -- Set_Image_Width_Integer --\n+   -----------------------------\n+\n+   procedure Set_Image_Width_Integer\n+     (V : Int;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural)\n+   is\n+      Start : Natural;\n+\n+   begin\n+      --  Positive case can just use the unsigned circuit directly\n+\n+      if V >= 0 then\n+         Set_Image_Width_Unsigned (Uns (V), W, S, P);\n+\n+      --  Negative case has to set a minus sign. Note also that we have to be\n+      --  careful not to generate overflow with the largest negative number.\n+\n+      else\n+         P := P + 1;\n+         S (P) := ' ';\n+         Start := P;\n+\n+         declare\n+            pragma Suppress (Overflow_Check);\n+            pragma Suppress (Range_Check);\n+         begin\n+            Set_Image_Width_Unsigned (Uns (-V), W - 1, S, P);\n+         end;\n+\n+         --  Set minus sign in last leading blank location. Because of the\n+         --  code above, there must be at least one such location.\n+\n+         while S (Start + 1) = ' ' loop\n+            Start := Start + 1;\n+         end loop;\n+\n+         S (Start) := '-';\n+      end if;\n+\n+   end Set_Image_Width_Integer;\n+\n+   ------------------------------\n+   -- Set_Image_Width_Unsigned --\n+   ------------------------------\n+\n+   procedure Set_Image_Width_Unsigned\n+     (V : Uns;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural)\n+   is\n+      Start : constant Natural := P;\n+      F, T  : Natural;\n+\n+      procedure Set_Digits (T : Uns);\n+      --  Set digits of absolute value of T\n+\n+      ----------------\n+      -- Set_Digits --\n+      ----------------\n+\n+      procedure Set_Digits (T : Uns) is\n+      begin\n+         if T >= 10 then\n+            Set_Digits (T / 10);\n+            pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                           P < Natural'Last);\n+            --  No check is done since, as documented in the specification,\n+            --  the caller guarantees that S is long enough to hold the result.\n+            P := P + 1;\n+            S (P) := Character'Val (T mod 10 + Character'Pos ('0'));\n+\n+         else\n+            pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                           P < Natural'Last);\n+            --  No check is done since, as documented in the specification,\n+            --  the caller guarantees that S is long enough to hold the result.\n+            P := P + 1;\n+            S (P) := Character'Val (T + Character'Pos ('0'));\n+         end if;\n+      end Set_Digits;\n+\n+   --  Start of processing for Set_Image_Width_Unsigned\n+\n+   begin\n+      Set_Digits (V);\n+\n+      --  Add leading spaces if required by width parameter\n+\n+      if P - Start < W then\n+         F := P;\n+         P := P + (W - (P - Start));\n+         T := P;\n+\n+         while F > Start loop\n+            pragma Assert (T >= S'First and T <= S'Last and\n+                           F >= S'First and F <= S'Last);\n+            --  No check is done since, as documented in the specification,\n+            --  the caller guarantees that S is long enough to hold the result.\n+            S (T) := S (F);\n+            T := T - 1;\n+            F := F - 1;\n+         end loop;\n+\n+         for J in Start + 1 .. T loop\n+            pragma Assert (J >= S'First and J <= S'Last);\n+            --  No check is done since, as documented in the specification,\n+            --  the caller guarantees that S is long enough to hold the result.\n+            S (J) := ' ';\n+         end loop;\n+      end if;\n+\n+   end Set_Image_Width_Unsigned;\n+\n+end System.Image_W;"}, {"sha": "14c0c603896de25382249fd3e2b955faa67f2c4d", "filename": "gcc/ada/libgnat/s-imagew.ads", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imagew.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imagew.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagew.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,73 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M A G E _ W                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Contains the routine for computing the image  of signed and unsigned\n+--  integers up to Integer for use by Text_IO.Integer_IO and\n+--  Text_IO.Modular_IO.\n+\n+generic\n+\n+   type Int is range <>;\n+\n+   type Uns is mod <>;\n+\n+package System.Image_W is\n+   pragma Pure;\n+\n+   procedure Set_Image_Width_Integer\n+     (V : Int;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural);\n+   --  Sets the signed image of V in decimal format, starting at S (P + 1),\n+   --  updating P to point to the last character stored. The image includes\n+   --  a leading minus sign if necessary, but no leading spaces unless W is\n+   --  positive, in which case leading spaces are output if necessary to ensure\n+   --  that the output string is no less than W characters long. The caller\n+   --  promises that the buffer is large enough and no check is made for this.\n+   --  Constraint_Error will not necessarily be raised if this is violated,\n+   --  since it is perfectly valid to compile this unit with checks off.\n+\n+   procedure Set_Image_Width_Unsigned\n+     (V : Uns;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural);\n+   --  Sets the unsigned image of V in decimal format, starting at S (P + 1),\n+   --  updating P to point to the last character stored. The image includes no\n+   --  leading spaces unless W is positive, in which case leading spaces are\n+   --  output if necessary to ensure that the output string is no less than\n+   --  W characters long. The caller promises that the buffer is large enough\n+   --  and no check is made for this. Constraint_Error will not necessarily be\n+   --  raised if this is violated, since it is perfectly valid to compile this\n+   --  unit with checks off.\n+\n+end System.Image_W;"}, {"sha": "fbbbcecf4dc9b1c202bf3b1f5ca0c457564cd2d0", "filename": "gcc/ada/libgnat/s-imgbiu.adb", "status": "modified", "additions": 4, "deletions": 126, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgbiu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgbiu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgbiu.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,130 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Img_BIU is\n-\n-   -----------------------------\n-   -- Set_Image_Based_Integer --\n-   -----------------------------\n-\n-   procedure Set_Image_Based_Integer\n-     (V : Integer;\n-      B : Natural;\n-      W : Integer;\n-      S : out String;\n-      P : in out Natural)\n-   is\n-      Start : Natural;\n-\n-   begin\n-      --  Positive case can just use the unsigned circuit directly\n-\n-      if V >= 0 then\n-         Set_Image_Based_Unsigned (Unsigned (V), B, W, S, P);\n-\n-      --  Negative case has to set a minus sign. Note also that we have to be\n-      --  careful not to generate overflow with the largest negative number.\n-\n-      else\n-         P := P + 1;\n-         S (P) := ' ';\n-         Start := P;\n-\n-         declare\n-            pragma Suppress (Overflow_Check);\n-            pragma Suppress (Range_Check);\n-         begin\n-            Set_Image_Based_Unsigned (Unsigned (-V), B, W - 1, S, P);\n-         end;\n-\n-         --  Set minus sign in last leading blank location. Because of the\n-         --  code above, there must be at least one such location.\n-\n-         while S (Start + 1) = ' ' loop\n-            Start := Start + 1;\n-         end loop;\n-\n-         S (Start) := '-';\n-      end if;\n-\n-   end Set_Image_Based_Integer;\n-\n-   ------------------------------\n-   -- Set_Image_Based_Unsigned --\n-   ------------------------------\n-\n-   procedure Set_Image_Based_Unsigned\n-     (V : Unsigned;\n-      B : Natural;\n-      W : Integer;\n-      S : out String;\n-      P : in out Natural)\n-   is\n-      Start : constant Natural := P;\n-      F, T  : Natural;\n-      BU    : constant Unsigned := Unsigned (B);\n-      Hex   : constant array\n-                (Unsigned range 0 .. 15) of Character := \"0123456789ABCDEF\";\n-\n-      procedure Set_Digits (T : Unsigned);\n-      --  Set digits of absolute value of T\n-\n-      ----------------\n-      -- Set_Digits --\n-      ----------------\n-\n-      procedure Set_Digits (T : Unsigned) is\n-      begin\n-         if T >= BU then\n-            Set_Digits (T / BU);\n-            P := P + 1;\n-            S (P) := Hex (T mod BU);\n-         else\n-            P := P + 1;\n-            S (P) := Hex (T);\n-         end if;\n-      end Set_Digits;\n-\n-   --  Start of processing for Set_Image_Based_Unsigned\n-\n-   begin\n-\n-      if B >= 10 then\n-         P := P + 1;\n-         S (P) := '1';\n-      end if;\n-\n-      P := P + 1;\n-      S (P) := Character'Val (Character'Pos ('0') + B mod 10);\n-\n-      P := P + 1;\n-      S (P) := '#';\n-\n-      Set_Digits (V);\n-\n-      P := P + 1;\n-      S (P) := '#';\n-\n-      --  Add leading spaces if required by width parameter\n-\n-      if P - Start < W then\n-         F := P;\n-         P := Start + W;\n-         T := P;\n-\n-         while F > Start loop\n-            S (T) := S (F);\n-            T := T - 1;\n-            F := F - 1;\n-         end loop;\n-\n-         for J in Start + 1 .. T loop\n-            S (J) := ' ';\n-         end loop;\n-      end if;\n-\n-   end Set_Image_Based_Unsigned;\n-\n-end System.Img_BIU;\n+pragma No_Body;"}, {"sha": "9cf24ae85ab5122870a13019273c722d1e9f7fe5", "filename": "gcc/ada/libgnat/s-imgbiu.ads", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgbiu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgbiu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgbiu.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -30,43 +30,33 @@\n ------------------------------------------------------------------------------\n \n --  Contains the routine for computing the image in based format of signed and\n---  unsigned integers whose size <= Integer'Size for use by Text_IO.Integer_IO\n---  and Text_IO.Modular_IO.\n+--  unsigned integers up to Integer for use by Text_IO.Integer_IO and\n+--  Text_IO.Modular_IO.\n \n+with System.Image_B;\n with System.Unsigned_Types;\n \n package System.Img_BIU is\n    pragma Pure;\n \n+   subtype Unsigned is Unsigned_Types.Unsigned;\n+\n+   package Impl is new Image_B (Integer, Unsigned);\n+\n    procedure Set_Image_Based_Integer\n      (V : Integer;\n       B : Natural;\n       W : Integer;\n       S : out String;\n-      P : in out Natural);\n-   --  Sets the signed image of V in based format, using base value B (2..16)\n-   --  starting at S (P + 1), updating P to point to the last character stored.\n-   --  The image includes a leading minus sign if necessary, but no leading\n-   --  spaces unless W is positive, in which case leading spaces are output if\n-   --  necessary to ensure that the output string is no less than W characters\n-   --  long. The caller promises that the buffer is large enough and no check\n-   --  is made for this. Constraint_Error will not necessarily be raised if\n-   --  this is violated, since it is perfectly valid to compile this unit with\n-   --  checks off.\n+      P : in out Natural)\n+     renames Impl.Set_Image_Based_Integer;\n \n    procedure Set_Image_Based_Unsigned\n-     (V : System.Unsigned_Types.Unsigned;\n+     (V : Unsigned;\n       B : Natural;\n       W : Integer;\n       S : out String;\n-      P : in out Natural);\n-   --  Sets the unsigned image of V in based format, using base value B (2..16)\n-   --  starting at S (P + 1), updating P to point to the last character stored.\n-   --  The image includes no leading spaces unless W is positive, in which case\n-   --  leading spaces are output if necessary to ensure that the output string\n-   --  is no less than W characters long. The caller promises that the buffer\n-   --  is large enough and no check is made for this. Constraint_Error will not\n-   --  necessarily be raised if this is violated, since it is perfectly valid\n-   --  to compile this unit with checks off).\n+      P : in out Natural)\n+     renames Impl.Set_Image_Based_Unsigned;\n \n end System.Img_BIU;"}, {"sha": "acadd1c494da93bcdbb7747a3b4ab9af539518ec", "filename": "gcc/ada/libgnat/s-imgint.adb", "status": "modified", "additions": 4, "deletions": 87, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgint.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,91 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body System.Img_Int is\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-   subtype Non_Positive is Integer range Integer'First .. 0;\n-\n-   procedure Set_Digits\n-     (T : Non_Positive;\n-      S : in out String;\n-      P : in out Natural);\n-   --  Set digits of absolute value of T, which is zero or negative. We work\n-   --  with the negative of the value so that the largest negative number is\n-   --  not a special case.\n-\n-   -------------------\n-   -- Image_Integer --\n-   -------------------\n-\n-   procedure Image_Integer\n-     (V : Integer;\n-      S : in out String;\n-      P : out Natural)\n-   is\n-      pragma Assert (S'First = 1);\n-\n-   begin\n-      if V >= 0 then\n-         S (1) := ' ';\n-         P := 1;\n-      else\n-         P := 0;\n-      end if;\n-\n-      Set_Image_Integer (V, S, P);\n-   end Image_Integer;\n-\n-   ----------------\n-   -- Set_Digits --\n-   ----------------\n-\n-   procedure Set_Digits\n-     (T : Non_Positive;\n-      S : in out String;\n-      P : in out Natural)\n-   is\n-   begin\n-      if T <= -10 then\n-         Set_Digits (T / 10, S, P);\n-         pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                        P < Natural'Last);\n-         --  No check is done since, as documented in the Set_Image_Integer\n-         --  specification, the caller guarantees that S is long enough to\n-         --  hold the result.\n-         P := P + 1;\n-         S (P) := Character'Val (48 - (T rem 10));\n-      else\n-         pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                        P < Natural'Last);\n-         --  No check is done since, as documented in the Set_Image_Integer\n-         --  specification, the caller guarantees that S is long enough to\n-         --  hold the result.\n-         P := P + 1;\n-         S (P) := Character'Val (48 - T);\n-      end if;\n-   end Set_Digits;\n-\n-   -----------------------\n-   -- Set_Image_Integer --\n-   -----------------------\n-\n-   procedure Set_Image_Integer\n-     (V : Integer;\n-      S : in out String;\n-      P : in out Natural)\n-   is\n-   begin\n-      if V >= 0 then\n-         Set_Digits (-V, S, P);\n-      else\n-         pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                        P < Natural'Last);\n-         --  No check is done since, as documented in the specification,\n-         --  the caller guarantees that S is long enough to hold the result.\n-         P := P + 1;\n-         S (P) := '-';\n-         Set_Digits (V, S, P);\n-      end if;\n-   end Set_Image_Integer;\n-\n-end System.Img_Int;\n+pragma No_Body;"}, {"sha": "08ce31db437465e0087f0145407c57149ae98236", "filename": "gcc/ada/libgnat/s-imgint.ads", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgint.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -30,28 +30,26 @@\n ------------------------------------------------------------------------------\n \n --  This package contains the routines for supporting the Image attribute for\n---  signed integer types up to Size Integer'Size, and also for conversion\n---  operations required in Text_IO.Integer_IO for such types.\n+--  signed integer types up to Integer, and also for conversion operations\n+--  required in Text_IO.Integer_IO for such types.\n+\n+with System.Image_I;\n \n package System.Img_Int is\n    pragma Pure;\n \n+   package Impl is new Image_I (Integer);\n+\n    procedure Image_Integer\n      (V : Integer;\n       S : in out String;\n-      P : out Natural);\n-   --  Computes Integer'Image (V) and stores the result in S (1 .. P)\n-   --  setting the resulting value of P. The caller guarantees that S\n-   --  is long enough to hold the result, and that S'First is 1.\n+      P : out Natural)\n+     renames Impl.Image_Integer;\n \n    procedure Set_Image_Integer\n      (V : Integer;\n       S : in out String;\n-      P : in out Natural);\n-   --  Stores the image of V in S starting at S (P + 1), P is updated to point\n-   --  to the last character stored. The value stored is identical to the value\n-   --  of Integer'Image (V) except that no leading space is stored when V is\n-   --  non-negative. The caller guarantees that S is long enough to hold the\n-   --  result. S need not have a lower bound of 1.\n+      P : in out Natural)\n+     renames Impl.Set_Image_Integer;\n \n end System.Img_Int;"}, {"sha": "90ba5ce90b1b40c588b06ccc6ed37d3b58096b71", "filename": "gcc/ada/libgnat/s-imgllb.adb", "status": "modified", "additions": 4, "deletions": 129, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllb.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,133 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Img_LLB is\n-\n-   ---------------------------------------\n-   -- Set_Image_Based_Long_Long_Integer --\n-   ---------------------------------------\n-\n-   procedure Set_Image_Based_Long_Long_Integer\n-     (V : Long_Long_Integer;\n-      B : Natural;\n-      W : Integer;\n-      S : out String;\n-      P : in out Natural)\n-   is\n-      Start : Natural;\n-\n-   begin\n-      --  Positive case can just use the unsigned circuit directly\n-\n-      if V >= 0 then\n-         Set_Image_Based_Long_Long_Unsigned\n-           (Long_Long_Unsigned (V), B, W, S, P);\n-\n-      --  Negative case has to set a minus sign. Note also that we have to be\n-      --  careful not to generate overflow with the largest negative number.\n-\n-      else\n-         P := P + 1;\n-         S (P) := ' ';\n-         Start := P;\n-\n-         declare\n-            pragma Suppress (Overflow_Check);\n-            pragma Suppress (Range_Check);\n-         begin\n-            Set_Image_Based_Long_Long_Unsigned\n-              (Long_Long_Unsigned (-V), B, W - 1, S, P);\n-         end;\n-\n-         --  Set minus sign in last leading blank location. Because of the\n-         --  code above, there must be at least one such location.\n-\n-         while S (Start + 1) = ' ' loop\n-            Start := Start + 1;\n-         end loop;\n-\n-         S (Start) := '-';\n-      end if;\n-\n-   end Set_Image_Based_Long_Long_Integer;\n-\n-   ----------------------------------------\n-   -- Set_Image_Based_Long_Long_Unsigned --\n-   ----------------------------------------\n-\n-   procedure Set_Image_Based_Long_Long_Unsigned\n-     (V : Long_Long_Unsigned;\n-      B : Natural;\n-      W : Integer;\n-      S : out String;\n-      P : in out Natural)\n-   is\n-      Start : constant Natural := P;\n-      F, T  : Natural;\n-      BU    : constant Long_Long_Unsigned := Long_Long_Unsigned (B);\n-      Hex   : constant array\n-                (Long_Long_Unsigned range 0 .. 15) of Character :=\n-                                                         \"0123456789ABCDEF\";\n-\n-      procedure Set_Digits (T : Long_Long_Unsigned);\n-      --  Set digits of absolute value of T\n-\n-      ----------------\n-      -- Set_Digits --\n-      ----------------\n-\n-      procedure Set_Digits (T : Long_Long_Unsigned) is\n-      begin\n-         if T >= BU then\n-            Set_Digits (T / BU);\n-            P := P + 1;\n-            S (P) := Hex (T mod BU);\n-         else\n-            P := P + 1;\n-            S (P) := Hex (T);\n-         end if;\n-      end Set_Digits;\n-\n-   --  Start of processing for Set_Image_Based_Long_Long_Unsigned\n-\n-   begin\n-\n-      if B >= 10 then\n-         P := P + 1;\n-         S (P) := '1';\n-      end if;\n-\n-      P := P + 1;\n-      S (P) := Character'Val (Character'Pos ('0') + B mod 10);\n-\n-      P := P + 1;\n-      S (P) := '#';\n-\n-      Set_Digits (V);\n-\n-      P := P + 1;\n-      S (P) := '#';\n-\n-      --  Add leading spaces if required by width parameter\n-\n-      if P - Start < W then\n-         F := P;\n-         P := Start + W;\n-         T := P;\n-\n-         while F > Start loop\n-            S (T) := S (F);\n-            T := T - 1;\n-            F := F - 1;\n-         end loop;\n-\n-         for J in Start + 1 .. T loop\n-            S (J) := ' ';\n-         end loop;\n-      end if;\n-\n-   end Set_Image_Based_Long_Long_Unsigned;\n-\n-end System.Img_LLB;\n+pragma No_Body;"}, {"sha": "bfaf2ee46f6cf8742fc12068b7c981a94942bd92", "filename": "gcc/ada/libgnat/s-imgllb.ads", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllb.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -30,43 +30,33 @@\n ------------------------------------------------------------------------------\n \n --  Contains the routine for computing the image in based format of signed and\n---  unsigned integers whose size > Integer'Size for use by Text_IO.Integer_IO\n---  and Text_IO.Modular_IO.\n+--  unsigned integers larger than Integer for use by Text_IO.Integer_IO and\n+--  Text_IO.Modular_IO.\n \n+with System.Image_B;\n with System.Unsigned_Types;\n \n package System.Img_LLB is\n    pragma Preelaborate;\n \n+   subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n+\n+   package Impl is new Image_B (Long_Long_Integer, Long_Long_Unsigned);\n+\n    procedure Set_Image_Based_Long_Long_Integer\n      (V : Long_Long_Integer;\n       B : Natural;\n       W : Integer;\n       S : out String;\n-      P : in out Natural);\n-   --  Sets the signed image of V in based format, using base value B (2..16)\n-   --  starting at S (P + 1), updating P to point to the last character stored.\n-   --  The image includes a leading minus sign if necessary, but no leading\n-   --  spaces unless W is positive, in which case leading spaces are output if\n-   --  necessary to ensure that the output string is no less than W characters\n-   --  long. The caller promises that the buffer is large enough and no check\n-   --  is made for this. Constraint_Error will not necessarily be raised if\n-   --  this is violated, since it is perfectly valid to compile this unit with\n-   --  checks off.\n+      P : in out Natural)\n+     renames Impl.Set_Image_Based_Integer;\n \n    procedure Set_Image_Based_Long_Long_Unsigned\n-     (V : System.Unsigned_Types.Long_Long_Unsigned;\n+     (V : Long_Long_Unsigned;\n       B : Natural;\n       W : Integer;\n       S : out String;\n-      P : in out Natural);\n-   --  Sets the unsigned image of V in based format, using base value B (2..16)\n-   --  starting at S (P + 1), updating P to point to the last character stored.\n-   --  The image includes no leading spaces unless W is positive, in which case\n-   --  leading spaces are output if necessary to ensure that the output string\n-   --  is no less than W characters long. The caller promises that the buffer\n-   --  is large enough and no check is made for this. Constraint_Error will not\n-   --  necessarily be raised if this is violated, since it is perfectly valid\n-   --  to compile this unit with checks off).\n+      P : in out Natural)\n+     renames Impl.Set_Image_Based_Unsigned;\n \n end System.Img_LLB;"}, {"sha": "cdaeb7eba387da37666d1f0cde1c5b52f34e291c", "filename": "gcc/ada/libgnat/s-imglli.adb", "status": "modified", "additions": 4, "deletions": 87, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imglli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imglli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglli.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,91 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body System.Img_LLI is\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-   subtype Non_Positive is Long_Long_Integer\n-                        range Long_Long_Integer'First .. 0;\n-\n-   procedure Set_Digits\n-     (T : Non_Positive;\n-      S : in out String;\n-      P : in out Natural);\n-   --  Set digits of absolute value of T, which is zero or negative. We work\n-   --  with the negative of the value so that the largest negative number is\n-   --  not a special case.\n-\n-   -----------------------------\n-   -- Image_Long_Long_Integer --\n-   -----------------------------\n-\n-   procedure Image_Long_Long_Integer\n-     (V : Long_Long_Integer;\n-      S : in out String;\n-      P : out Natural)\n-   is\n-      pragma Assert (S'First = 1);\n-\n-   begin\n-      if V >= 0 then\n-         S (1) := ' ';\n-         P := 1;\n-      else\n-         P := 0;\n-      end if;\n-\n-      Set_Image_Long_Long_Integer (V, S, P);\n-   end Image_Long_Long_Integer;\n-\n-   ----------------\n-   -- Set_Digits --\n-   ----------------\n-\n-   procedure Set_Digits\n-     (T : Non_Positive;\n-      S : in out String;\n-      P : in out Natural)\n-   is\n-   begin\n-      if T <= -10 then\n-         Set_Digits (T / 10, S, P);\n-         pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                        P < Natural'Last);\n-         --  No check is done as documented in the Set_Image_Long_Long_Integer\n-         --  specification: The caller guarantees that S is long enough to\n-         --  hold the result.\n-         P := P + 1;\n-         S (P) := Character'Val (48 - (T rem 10));\n-      else\n-         pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                        P < Natural'Last);\n-         --  No check is done as documented in the Set_Image_Long_Long_Integer\n-         --  specification: The caller guarantees that S is long enough to\n-         --  hold the result.\n-         P := P + 1;\n-         S (P) := Character'Val (48 - T);\n-      end if;\n-   end Set_Digits;\n-\n-   ---------------------------------\n-   -- Set_Image_Long_Long_Integer --\n-   --------------------------------\n-\n-   procedure Set_Image_Long_Long_Integer\n-     (V : Long_Long_Integer;\n-      S : in out String;\n-      P : in out Natural) is\n-   begin\n-      if V >= 0 then\n-         Set_Digits (-V, S, P);\n-      else\n-         pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                        P < Natural'Last);\n-         --  No check is done as documented in the specification:\n-         --  The caller guarantees that S is long enough to hold the result.\n-         P := P + 1;\n-         S (P) := '-';\n-         Set_Digits (V, S, P);\n-      end if;\n-   end Set_Image_Long_Long_Integer;\n-\n-end System.Img_LLI;\n+pragma No_Body;"}, {"sha": "49defc5746d21a82fac3891b46085fe161e1c025", "filename": "gcc/ada/libgnat/s-imglli.ads", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imglli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imglli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglli.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -30,28 +30,26 @@\n ------------------------------------------------------------------------------\n \n --  This package contains the routines for supporting the Image attribute for\n---  signed integer types larger than Size Integer'Size, and also for conversion\n---  operations required in Text_IO.Integer_IO for such types.\n+--  signed integer types larger Integer, and also for conversion operations\n+--  required in Text_IO.Integer_IO for such types.\n+\n+with System.Image_I;\n \n package System.Img_LLI is\n    pragma Pure;\n \n+   package Impl is new Image_I (Long_Long_Integer);\n+\n    procedure Image_Long_Long_Integer\n      (V : Long_Long_Integer;\n       S : in out String;\n-      P : out Natural);\n-   --  Computes Long_Long_Integer'Image (V) and stores the result in\n-   --  S (1 .. P) setting the resulting value of P. The caller guarantees\n-   --  that S is long enough to hold the result, and that S'First is 1.\n+      P : out Natural)\n+     renames Impl.Image_Integer;\n \n    procedure Set_Image_Long_Long_Integer\n      (V : Long_Long_Integer;\n       S : in out String;\n-      P : in out Natural);\n-   --  Stores the image of V in S starting at S (P + 1), P is updated to point\n-   --  to the last character stored. The value stored is identical to the value\n-   --  of Long_Long_Integer'Image (V) except that no leading space is stored\n-   --  when V is non-negative. The caller guarantees that S is long enough to\n-   --  hold the result. S need not have a lower bound of 1.\n+      P : in out Natural)\n+     renames Impl.Set_Image_Integer;\n \n end System.Img_LLI;"}, {"sha": "b2460376527ddd755951d2be612ad2998bc8a858", "filename": "gcc/ada/libgnat/s-imglllb.ads", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imglllb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imglllb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglllb.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,63 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . I M G _ L L L B                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Contains the routine for computing the image in based format of signed and\n+--  unsigned integers larger than Long_Long_Integer for use by\n+--  Text_IO.Integer_IO and Text_IO.Modular_IO.\n+\n+with System.Image_B;\n+with System.Unsigned_Types;\n+\n+package System.Img_LLLB is\n+   pragma Preelaborate;\n+\n+   subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n+\n+   package Impl is\n+    new Image_B (Long_Long_Long_Integer, Long_Long_Long_Unsigned);\n+\n+   procedure Set_Image_Based_Long_Long_Long_Integer\n+     (V : Long_Long_Long_Integer;\n+      B : Natural;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural)\n+     renames Impl.Set_Image_Based_Integer;\n+\n+   procedure Set_Image_Based_Long_Long_Long_Unsigned\n+     (V : Long_Long_Long_Unsigned;\n+      B : Natural;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural)\n+     renames Impl.Set_Image_Based_Unsigned;\n+\n+end System.Img_LLLB;"}, {"sha": "c6d41f9cbf713242dc5891a92bcf7bf6d0455548", "filename": "gcc/ada/libgnat/s-imgllli.ads", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,55 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . I M G _ L L L I                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines for supporting the Image attribute for\n+--  signed integer types larger than Long_Long_Integer, and also for conversion\n+--  operations required in Text_IO.Integer_IO for such types.\n+\n+with System.Image_I;\n+\n+package System.Img_LLLI is\n+   pragma Pure;\n+\n+   package Impl is new Image_I (Long_Long_Long_Integer);\n+\n+   procedure Image_Long_Long_Long_Integer\n+     (V : Long_Long_Long_Integer;\n+      S : in out String;\n+      P : out Natural)\n+     renames Impl.Image_Integer;\n+\n+   procedure Set_Image_Long_Long_Long_Integer\n+     (V : Long_Long_Long_Integer;\n+      S : in out String;\n+      P : in out Natural)\n+     renames Impl.Set_Image_Integer;\n+\n+end System.Img_LLLI;"}, {"sha": "8b6f16a2cf215484f918c4d16eb86eecf2e3ee84", "filename": "gcc/ada/libgnat/s-imglllu.ads", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,58 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . I M G _ L L L U                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines for supporting the Image attribute for\n+--  modular integer types larger than Long_Long_Unsigned, and also for\n+--  conversion operations required in Text_IO.Modular_IO for such types.\n+\n+with System.Image_U;\n+with System.Unsigned_Types;\n+\n+package System.Img_LLLU is\n+   pragma Pure;\n+\n+   subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n+\n+   package Impl is new Image_U (Long_Long_Long_Unsigned);\n+\n+   procedure Image_Long_Long_Long_Unsigned\n+     (V : Long_Long_Long_Unsigned;\n+      S : in out String;\n+      P : out Natural)\n+     renames Impl.Image_Unsigned;\n+\n+   procedure Set_Image_Long_Long_Long_Unsigned\n+     (V : Long_Long_Long_Unsigned;\n+      S : in out String;\n+      P : in out Natural)\n+     renames Impl.Set_Image_Unsigned;\n+\n+end System.Img_LLLU;"}, {"sha": "de33f186e26e0c6665bc98a6ee5e02382ceb0747", "filename": "gcc/ada/libgnat/s-imglllw.ads", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imglllw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imglllw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglllw.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M G _ L L W                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Contains the routine for computing the image  of signed and unsigned\n+--  integers larger than Integer for use by Text_IO.Integer_IO and\n+--  Text_IO.Modular_IO.\n+\n+with System.Image_W;\n+with System.Unsigned_Types;\n+\n+package System.Img_LLLW is\n+   pragma Pure;\n+\n+   subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n+\n+   package Impl is\n+    new Image_W (Long_Long_Long_Integer, Long_Long_Long_Unsigned);\n+\n+   procedure Set_Image_Width_Long_Long_Long_Integer\n+     (V : Long_Long_Long_Integer;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural)\n+     renames Impl.Set_Image_Width_Integer;\n+\n+   procedure Set_Image_Width_Long_Long_Long_Unsigned\n+     (V : Long_Long_Long_Unsigned;\n+      W : Integer;\n+      S : out String;\n+      P : in out Natural)\n+     renames Impl.Set_Image_Width_Unsigned;\n+\n+end System.Img_LLLW;"}, {"sha": "680b11b8e8789ebaea242681ed9a5f8dbe8c05fa", "filename": "gcc/ada/libgnat/s-imgllu.adb", "status": "modified", "additions": 4, "deletions": 49, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllu.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,53 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Img_LLU is\n-\n-   ------------------------------\n-   -- Image_Long_Long_Unsigned --\n-   ------------------------------\n-\n-   procedure Image_Long_Long_Unsigned\n-     (V : System.Unsigned_Types.Long_Long_Unsigned;\n-      S : in out String;\n-      P : out Natural)\n-   is\n-      pragma Assert (S'First = 1);\n-   begin\n-      S (1) := ' ';\n-      P := 1;\n-      Set_Image_Long_Long_Unsigned (V, S, P);\n-   end Image_Long_Long_Unsigned;\n-\n-   ----------------------------------\n-   -- Set_Image_Long_Long_Unsigned --\n-   ----------------------------------\n-\n-   procedure Set_Image_Long_Long_Unsigned\n-     (V : Long_Long_Unsigned;\n-      S : in out String;\n-      P : in out Natural)\n-   is\n-   begin\n-      if V >= 10 then\n-         Set_Image_Long_Long_Unsigned (V / 10, S, P);\n-         pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                        P < Natural'Last);\n-         --  No check is done since, as documented in the specification, the\n-         --  caller guarantees that S is long enough to hold the result.\n-         P := P + 1;\n-         S (P) := Character'Val (48 + (V rem 10));\n-\n-      else\n-         pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                        P < Natural'Last);\n-         --  No check is done since, as documented in the specification, the\n-         --  caller guarantees that S is long enough to hold the result.\n-         P := P + 1;\n-         S (P) := Character'Val (48 + V);\n-      end if;\n-   end Set_Image_Long_Long_Unsigned;\n-\n-end System.Img_LLU;\n+pragma No_Body;"}, {"sha": "dabc68d0a1733f2c866007aaf1c25cd1152d256b", "filename": "gcc/ada/libgnat/s-imgllu.ads", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -30,32 +30,29 @@\n ------------------------------------------------------------------------------\n \n --  This package contains the routines for supporting the Image attribute for\n---  unsigned (modular) integer types larger than Size Unsigned'Size, and also\n---  for conversion operations required in Text_IO.Modular_IO for such types.\n+--  modular integer types larger than Unsigned, and also for conversion\n+--  operations required in Text_IO.Modular_IO for such types.\n \n+with System.Image_U;\n with System.Unsigned_Types;\n \n package System.Img_LLU is\n    pragma Pure;\n \n+   subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n+\n+   package Impl is new Image_U (Long_Long_Unsigned);\n+\n    procedure Image_Long_Long_Unsigned\n-     (V : System.Unsigned_Types.Long_Long_Unsigned;\n+     (V : Long_Long_Unsigned;\n       S : in out String;\n-      P : out Natural);\n-   pragma Inline (Image_Long_Long_Unsigned);\n-\n-   --  Computes Long_Long_Unsigned'Image (V) and stores the result in\n-   --  S (1 .. P) setting the resulting value of P. The caller guarantees\n-   --  that S is long enough to hold the result, and that S'First is 1.\n+      P : out Natural)\n+     renames Impl.Image_Unsigned;\n \n    procedure Set_Image_Long_Long_Unsigned\n-     (V : System.Unsigned_Types.Long_Long_Unsigned;\n+     (V : Long_Long_Unsigned;\n       S : in out String;\n-      P : in out Natural);\n-   --  Stores the image of V in S starting at S (P + 1), P is updated to point\n-   --  to the last character stored. The value stored is identical to the value\n-   --  of Long_Long_Unsigned'Image (V) except that no leading space is stored.\n-   --  The caller guarantees that S is long enough to hold the result. S need\n-   --  not have a lower bound of 1.\n+      P : in out Natural)\n+     renames Impl.Set_Image_Unsigned;\n \n end System.Img_LLU;"}, {"sha": "5702a93264358966975f3379677d94fd5ca4f0fe", "filename": "gcc/ada/libgnat/s-imgllw.adb", "status": "modified", "additions": 4, "deletions": 108, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllw.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,112 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Img_LLW is\n-\n-   ---------------------------------------\n-   -- Set_Image_Width_Long_Long_Integer --\n-   ---------------------------------------\n-\n-   procedure Set_Image_Width_Long_Long_Integer\n-     (V : Long_Long_Integer;\n-      W : Integer;\n-      S : out String;\n-      P : in out Natural)\n-   is\n-      Start : Natural;\n-\n-   begin\n-      --  Positive case can just use the unsigned circuit directly\n-\n-      if V >= 0 then\n-         Set_Image_Width_Long_Long_Unsigned\n-           (Long_Long_Unsigned (V), W, S, P);\n-\n-      --  Negative case has to set a minus sign. Note also that we have to be\n-      --  careful not to generate overflow with the largest negative number.\n-\n-      else\n-         P := P + 1;\n-         S (P) := ' ';\n-         Start := P;\n-\n-         declare\n-            pragma Suppress (Overflow_Check);\n-            pragma Suppress (Range_Check);\n-         begin\n-            Set_Image_Width_Long_Long_Unsigned\n-              (Long_Long_Unsigned (-V), W - 1, S, P);\n-         end;\n-\n-         --  Set minus sign in last leading blank location. Because of the\n-         --  code above, there must be at least one such location.\n-\n-         while S (Start + 1) = ' ' loop\n-            Start := Start + 1;\n-         end loop;\n-\n-         S (Start) := '-';\n-      end if;\n-\n-   end Set_Image_Width_Long_Long_Integer;\n-\n-   ----------------------------------------\n-   -- Set_Image_Width_Long_Long_Unsigned --\n-   ----------------------------------------\n-\n-   procedure Set_Image_Width_Long_Long_Unsigned\n-     (V : Long_Long_Unsigned;\n-      W : Integer;\n-      S : out String;\n-      P : in out Natural)\n-   is\n-      Start : constant Natural := P;\n-      F, T  : Natural;\n-\n-      procedure Set_Digits (T : Long_Long_Unsigned);\n-      --  Set digits of absolute value of T\n-\n-      ----------------\n-      -- Set_Digits --\n-      ----------------\n-\n-      procedure Set_Digits (T : Long_Long_Unsigned) is\n-      begin\n-         if T >= 10 then\n-            Set_Digits (T / 10);\n-            P := P + 1;\n-            S (P) := Character'Val (T mod 10 + Character'Pos ('0'));\n-         else\n-            P := P + 1;\n-            S (P) := Character'Val (T + Character'Pos ('0'));\n-         end if;\n-      end Set_Digits;\n-\n-   --  Start of processing for Set_Image_Width_Long_Long_Unsigned\n-\n-   begin\n-      Set_Digits (V);\n-\n-      --  Add leading spaces if required by width parameter\n-\n-      if P - Start < W then\n-         F := P;\n-         P := P + (W - (P - Start));\n-         T := P;\n-\n-         while F > Start loop\n-            S (T) := S (F);\n-            T := T - 1;\n-            F := F - 1;\n-         end loop;\n-\n-         for J in Start + 1 .. T loop\n-            S (J) := ' ';\n-         end loop;\n-      end if;\n-\n-   end Set_Image_Width_Long_Long_Unsigned;\n-\n-end System.Img_LLW;\n+pragma No_Body;"}, {"sha": "12986e5b37acfce19225243acb165c7287b1777b", "filename": "gcc/ada/libgnat/s-imgllw.ads", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgllw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllw.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -30,40 +30,31 @@\n ------------------------------------------------------------------------------\n \n --  Contains the routine for computing the image  of signed and unsigned\n---  integers whose size > Integer'Size for use by Text_IO.Integer_IO,\n+--  integers larger than Integer for use by Text_IO.Integer_IO and\n --  Text_IO.Modular_IO.\n \n+with System.Image_W;\n with System.Unsigned_Types;\n \n package System.Img_LLW is\n    pragma Pure;\n \n+   subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n+\n+   package Impl is new Image_W (Long_Long_Integer, Long_Long_Unsigned);\n+\n    procedure Set_Image_Width_Long_Long_Integer\n      (V : Long_Long_Integer;\n       W : Integer;\n       S : out String;\n-      P : in out Natural);\n-   --  Sets the signed image of V in decimal format, starting at S (P + 1),\n-   --  updating P to point to the last character stored. The image includes\n-   --  a leading minus sign if necessary, but no leading spaces unless W is\n-   --  positive, in which case leading spaces are output if necessary to ensure\n-   --  that the output string is no less than W characters long. The caller\n-   --  promises that the buffer is large enough and no check is made for this.\n-   --  Constraint_Error will not necessarily be raised if this is violated,\n-   --  since it is perfectly valid to compile this unit with checks off.\n+      P : in out Natural)\n+     renames Impl.Set_Image_Width_Integer;\n \n    procedure Set_Image_Width_Long_Long_Unsigned\n-     (V : System.Unsigned_Types.Long_Long_Unsigned;\n+     (V : Long_Long_Unsigned;\n       W : Integer;\n       S : out String;\n-      P : in out Natural);\n-   --  Sets the unsigned image of V in decimal format, starting at S (P + 1),\n-   --  updating P to point to the last character stored. The image includes no\n-   --  leading spaces unless W is positive, in which case leading spaces are\n-   --  output if necessary to ensure that the output string is no less than\n-   --  W characters long. The caller promises that the buffer is large enough\n-   --  and no check is made for this. Constraint_Error will not necessarily be\n-   --  raised if this is violated, since it is perfectly valid to compile this\n-   --  unit with checks off.\n+      P : in out Natural)\n+     renames Impl.Set_Image_Width_Unsigned;\n \n end System.Img_LLW;"}, {"sha": "3c3ffe1594daaf6e880441c08be937523eb2b902", "filename": "gcc/ada/libgnat/s-imgrea.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,10 +29,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Img_LLU;        use System.Img_LLU;\n-with System.Img_Uns;        use System.Img_Uns;\n-with System.Powten_Table;   use System.Powten_Table;\n-with System.Unsigned_Types; use System.Unsigned_Types;\n+with System.Img_LLU;      use System.Img_LLU;\n+with System.Img_Uns;      use System.Img_Uns;\n+with System.Powten_Table; use System.Powten_Table;\n with System.Float_Control;\n \n package body System.Img_Real is"}, {"sha": "8db42b416cee8fb227b0acbd0920ad24b7e05c35", "filename": "gcc/ada/libgnat/s-imguns.adb", "status": "modified", "additions": 4, "deletions": 49, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imguns.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imguns.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguns.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,53 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Img_Uns is\n-\n-   --------------------\n-   -- Image_Unsigned --\n-   --------------------\n-\n-   procedure Image_Unsigned\n-     (V : System.Unsigned_Types.Unsigned;\n-      S : in out String;\n-      P : out Natural)\n-   is\n-      pragma Assert (S'First = 1);\n-   begin\n-      S (1) := ' ';\n-      P := 1;\n-      Set_Image_Unsigned (V, S, P);\n-   end Image_Unsigned;\n-\n-   ------------------------\n-   -- Set_Image_Unsigned --\n-   ------------------------\n-\n-   procedure Set_Image_Unsigned\n-     (V : Unsigned;\n-      S : in out String;\n-      P : in out Natural)\n-   is\n-      pragma Assert (S'First = 1);\n-   begin\n-      if V >= 10 then\n-         Set_Image_Unsigned (V / 10, S, P);\n-         pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                        P < Natural'Last);\n-         --  No check is done since, as documented in the specification,\n-         --  the caller guarantees that S is long enough to hold the result.\n-         P := P + 1;\n-         S (P) := Character'Val (48 + (V rem 10));\n-      else\n-         pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                        P < Natural'Last);\n-         --  No check is done since, as documented in the specification,\n-         --  the caller guarantees that S is long enough to hold the result.\n-         P := P + 1;\n-         S (P) := Character'Val (48 + V);\n-      end if;\n-   end Set_Image_Unsigned;\n-\n-end System.Img_Uns;\n+pragma No_Body;"}, {"sha": "746fff125bb63e740baca441eac3c9c5281ff0d1", "filename": "gcc/ada/libgnat/s-imguns.ads", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imguns.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imguns.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguns.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -30,31 +30,29 @@\n ------------------------------------------------------------------------------\n \n --  This package contains the routines for supporting the Image attribute for\n---  modular integer types up to size Unsigned'Size, and also for conversion\n---  operations required in Text_IO.Modular_IO for such types.\n+--  modular integer types up to Unsigned, and also for conversion operations\n+--  required in Text_IO.Modular_IO for such types.\n \n+with System.Image_U;\n with System.Unsigned_Types;\n \n package System.Img_Uns is\n    pragma Pure;\n \n+   subtype Unsigned is Unsigned_Types.Unsigned;\n+\n+   package Impl is new Image_U (Unsigned);\n+\n    procedure Image_Unsigned\n-     (V : System.Unsigned_Types.Unsigned;\n+     (V : Unsigned;\n       S : in out String;\n-      P : out Natural);\n-   pragma Inline (Image_Unsigned);\n-   --  Computes Unsigned'Image (V) and stores the result in S (1 .. P) setting\n-   --  the resulting value of P. The caller guarantees that S is long enough to\n-   --  hold the result, and that S'First is 1.\n+      P : out Natural)\n+     renames Impl.Image_Unsigned;\n \n    procedure Set_Image_Unsigned\n-     (V : System.Unsigned_Types.Unsigned;\n+     (V : Unsigned;\n       S : in out String;\n-      P : in out Natural);\n-   --  Stores the image of V in S starting at S (P + 1), P is updated to point\n-   --  to the last character stored. The value stored is identical to the value\n-   --  of Unsigned'Image (V) except that no leading space is stored. The caller\n-   --  guarantees that S is long enough to hold the result. S need not have a\n-   --  lower bound of 1.\n+      P : in out Natural)\n+     renames Impl.Set_Image_Unsigned;\n \n end System.Img_Uns;"}, {"sha": "9f04cce0c4e2552d703a94b73c106cddf3acaccc", "filename": "gcc/ada/libgnat/s-imgwiu.adb", "status": "modified", "additions": 4, "deletions": 121, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgwiu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgwiu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgwiu.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,125 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Img_WIU is\n-\n-   -----------------------------\n-   -- Set_Image_Width_Integer --\n-   -----------------------------\n-\n-   procedure Set_Image_Width_Integer\n-     (V : Integer;\n-      W : Integer;\n-      S : out String;\n-      P : in out Natural)\n-   is\n-      Start : Natural;\n-\n-   begin\n-      --  Positive case can just use the unsigned circuit directly\n-\n-      if V >= 0 then\n-         Set_Image_Width_Unsigned (Unsigned (V), W, S, P);\n-\n-      --  Negative case has to set a minus sign. Note also that we have to be\n-      --  careful not to generate overflow with the largest negative number.\n-\n-      else\n-         P := P + 1;\n-         S (P) := ' ';\n-         Start := P;\n-\n-         declare\n-            pragma Suppress (Overflow_Check);\n-            pragma Suppress (Range_Check);\n-         begin\n-            Set_Image_Width_Unsigned (Unsigned (-V), W - 1, S, P);\n-         end;\n-\n-         --  Set minus sign in last leading blank location. Because of the\n-         --  code above, there must be at least one such location.\n-\n-         while S (Start + 1) = ' ' loop\n-            Start := Start + 1;\n-         end loop;\n-\n-         S (Start) := '-';\n-      end if;\n-\n-   end Set_Image_Width_Integer;\n-\n-   ------------------------------\n-   -- Set_Image_Width_Unsigned --\n-   ------------------------------\n-\n-   procedure Set_Image_Width_Unsigned\n-     (V : Unsigned;\n-      W : Integer;\n-      S : out String;\n-      P : in out Natural)\n-   is\n-      Start : constant Natural := P;\n-      F, T  : Natural;\n-\n-      procedure Set_Digits (T : Unsigned);\n-      --  Set digits of absolute value of T\n-\n-      ----------------\n-      -- Set_Digits --\n-      ----------------\n-\n-      procedure Set_Digits (T : Unsigned) is\n-      begin\n-         if T >= 10 then\n-            Set_Digits (T / 10);\n-            pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                           P < Natural'Last);\n-            --  No check is done since, as documented in the specification,\n-            --  the caller guarantees that S is long enough to hold the result.\n-            P := P + 1;\n-            S (P) := Character'Val (T mod 10 + Character'Pos ('0'));\n-         else\n-            pragma Assert (P >= (S'First - 1) and P < S'Last and\n-                           P < Natural'Last);\n-            --  No check is done since, as documented in the specification,\n-            --  the caller guarantees that S is long enough to hold the result.\n-            P := P + 1;\n-            S (P) := Character'Val (T + Character'Pos ('0'));\n-         end if;\n-      end Set_Digits;\n-\n-   --  Start of processing for Set_Image_Width_Unsigned\n-\n-   begin\n-      Set_Digits (V);\n-\n-      --  Add leading spaces if required by width parameter\n-\n-      if P - Start < W then\n-         F := P;\n-         P := P + (W - (P - Start));\n-         T := P;\n-\n-         while F > Start loop\n-            pragma Assert (T >= S'First and T <= S'Last and\n-                           F >= S'First and F <= S'Last);\n-            --  No check is done since, as documented in the specification,\n-            --  the caller guarantees that S is long enough to hold the result.\n-            S (T) := S (F);\n-            T := T - 1;\n-            F := F - 1;\n-         end loop;\n-\n-         for J in Start + 1 .. T loop\n-            pragma Assert (J >= S'First and J <= S'Last);\n-            --  No check is done since, as documented in the specification,\n-            --  the caller guarantees that S is long enough to hold the result.\n-            S (J) := ' ';\n-         end loop;\n-      end if;\n-\n-   end Set_Image_Width_Unsigned;\n-\n-end System.Img_WIU;\n+pragma No_Body;"}, {"sha": "89515e8155d77f43700e0f7422f396f6bf12c627", "filename": "gcc/ada/libgnat/s-imgwiu.ads", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgwiu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-imgwiu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgwiu.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -30,40 +30,31 @@\n ------------------------------------------------------------------------------\n \n --  Contains the routine for computing the image  of signed and unsigned\n---  integers whose size <= Integer'Size for use by Text_IO.Integer_IO\n---  and Text_IO.Modular_IO.\n+--  integers up to Integer for use by Text_IO.Integer_IO and\n+--  Text_IO.Modular_IO.\n \n+with System.Image_W;\n with System.Unsigned_Types;\n \n package System.Img_WIU is\n    pragma Pure;\n \n+   subtype Unsigned is Unsigned_Types.Unsigned;\n+\n+   package Impl is new Image_W (Integer, Unsigned);\n+\n    procedure Set_Image_Width_Integer\n      (V : Integer;\n       W : Integer;\n       S : out String;\n-      P : in out Natural);\n-   --  Sets the signed image of V in decimal format, starting at S (P + 1),\n-   --  updating P to point to the last character stored. The image includes\n-   --  a leading minus sign if necessary, but no leading spaces unless W is\n-   --  positive, in which case leading spaces are output if necessary to ensure\n-   --  that the output string is no less than W characters long. The caller\n-   --  promises that the buffer is large enough and no check is made for this.\n-   --  Constraint_Error will not necessarily be raised if this is violated,\n-   --  since it is perfectly valid to compile this unit with checks off.\n+      P : in out Natural)\n+     renames Impl.Set_Image_Width_Integer;\n \n    procedure Set_Image_Width_Unsigned\n-     (V : System.Unsigned_Types.Unsigned;\n+     (V : Unsigned;\n       W : Integer;\n       S : out String;\n-      P : in out Natural);\n-   --  Sets the unsigned image of V in decimal format, starting at S (P + 1),\n-   --  updating P to point to the last character stored. The image includes no\n-   --  leading spaces unless W is positive, in which case leading spaces are\n-   --  output if necessary to ensure that the output string is no less than\n-   --  W characters long. The caller promises that the buffer is large enough\n-   --  and no check is made for this. Constraint_Error will not necessarily be\n-   --  raised if this is violated, since it is perfectly valid to compile this\n-   --  unit with checks off.\n+      P : in out Natural)\n+     renames Impl.Set_Image_Width_Unsigned;\n \n end System.Img_WIU;"}, {"sha": "925c3b969f6f96e89f42379d26a4dca0ba222d69", "filename": "gcc/ada/libgnat/s-putima.adb", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-putima.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-putima.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-putima.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -93,21 +93,30 @@ package body System.Put_Images is\n \n    end Generic_Integer_Images;\n \n-   package Small is new Generic_Integer_Images (Integer, Unsigned, Base => 10);\n-   package Large is new Generic_Integer_Images\n+   package Integer_Images is new Generic_Integer_Images\n+     (Integer, Unsigned, Base => 10);\n+   package LL_Integer_Images is new Generic_Integer_Images\n      (Long_Long_Integer, Long_Long_Unsigned, Base => 10);\n+   package LLL_Integer_Images is new Generic_Integer_Images\n+     (Long_Long_Long_Integer, Long_Long_Long_Unsigned, Base => 10);\n \n    procedure Put_Image_Integer (S : in out Sink'Class; X : Integer)\n-     renames Small.Put_Image;\n+     renames Integer_Images.Put_Image;\n    procedure Put_Image_Long_Long_Integer\n      (S : in out Sink'Class; X : Long_Long_Integer)\n-     renames Large.Put_Image;\n+     renames LL_Integer_Images.Put_Image;\n+   procedure Put_Image_Long_Long_Long_Integer\n+     (S : in out Sink'Class; X : Long_Long_Long_Integer)\n+     renames LLL_Integer_Images.Put_Image;\n \n    procedure Put_Image_Unsigned (S : in out Sink'Class; X : Unsigned)\n-     renames Small.Put_Image;\n+     renames Integer_Images.Put_Image;\n    procedure Put_Image_Long_Long_Unsigned\n      (S : in out Sink'Class; X : Long_Long_Unsigned)\n-     renames Large.Put_Image;\n+     renames LL_Integer_Images.Put_Image;\n+   procedure Put_Image_Long_Long_Long_Unsigned\n+     (S : in out Sink'Class; X : Long_Long_Long_Unsigned)\n+     renames LLL_Integer_Images.Put_Image;\n \n    type Signed_Address is range\n      -2**(Standard'Address_Size - 1) .. 2**(Standard'Address_Size - 1) - 1;"}, {"sha": "1d2a11d3aa5048a671a58f710378fc3b7f8a79f9", "filename": "gcc/ada/libgnat/s-putima.ads", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-putima.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-putima.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-putima.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -37,10 +37,11 @@ package System.Put_Images with Pure is\n    --  This package contains subprograms that are called by the generated code\n    --  for the 'Put_Image attribute.\n    --\n-   --  For an integer type that fits in Integer, the actual parameter is\n+   --  For a signed integer type that fits in Integer, the actual parameter is\n    --  converted to Integer, and Put_Image_Integer is called. For larger types,\n-   --  Put_Image_Long_Long_Integer is used. Other numeric types are treated\n-   --  similarly. Access values are unchecked-converted to either Thin_Pointer\n+   --  Put_Image_Long_Long_Integer or Put_Image_Long_Long_Long_Integer is used.\n+   --  For a modular integer type, this is similar with Integer replaced with\n+   --  Unsigned. Access values are unchecked-converted to either Thin_Pointer\n    --  or Fat_Pointer, and Put_Image_Thin_Pointer or Put_Image_Fat_Pointer is\n    --  called. The Before/Between/After procedures are called before printing\n    --  the components of a composite type, between pairs of components, and\n@@ -54,13 +55,18 @@ package System.Put_Images with Pure is\n    procedure Put_Image_Integer (S : in out Sink'Class; X : Integer);\n    procedure Put_Image_Long_Long_Integer\n      (S : in out Sink'Class; X : Long_Long_Integer);\n+   procedure Put_Image_Long_Long_Long_Integer\n+     (S : in out Sink'Class; X : Long_Long_Long_Integer);\n \n-   subtype Unsigned is System.Unsigned_Types.Unsigned;\n-   subtype Long_Long_Unsigned is System.Unsigned_Types.Long_Long_Unsigned;\n+   subtype Unsigned is Unsigned_Types.Unsigned;\n+   subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n+   subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n \n    procedure Put_Image_Unsigned (S : in out Sink'Class; X : Unsigned);\n    procedure Put_Image_Long_Long_Unsigned\n      (S : in out Sink'Class; X : Long_Long_Unsigned);\n+   procedure Put_Image_Long_Long_Long_Unsigned\n+     (S : in out Sink'Class; X : Long_Long_Long_Unsigned);\n \n    type Byte is new Character with Alignment => 1;\n    type Byte_String is array (Positive range <>) of Byte with Alignment => 1;"}, {"sha": "983d2d1b8e5f15c45996f132f8ca3541c1f20bf0", "filename": "gcc/ada/libgnat/s-valint.adb", "status": "modified", "additions": 4, "deletions": 86, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valint.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,90 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n-with System.Val_Uns;        use System.Val_Uns;\n-with System.Val_Util;       use System.Val_Util;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Val_Int is\n-\n-   ------------------\n-   -- Scan_Integer --\n-   ------------------\n-\n-   function Scan_Integer\n-     (Str : String;\n-      Ptr : not null access Integer;\n-      Max : Integer) return Integer\n-   is\n-      Uval : Unsigned;\n-      --  Unsigned result\n-\n-      Minus : Boolean := False;\n-      --  Set to True if minus sign is present, otherwise to False\n-\n-      Start : Positive;\n-      --  Saves location of first non-blank (not used in this case)\n-\n-   begin\n-      Scan_Sign (Str, Ptr, Max, Minus, Start);\n-\n-      if Str (Ptr.all) not in '0' .. '9' then\n-         Ptr.all := Start;\n-         Bad_Value (Str);\n-      end if;\n-\n-      Uval := Scan_Raw_Unsigned (Str, Ptr, Max);\n-\n-      --  Deal with overflow cases, and also with maximum negative number\n-\n-      if Uval > Unsigned (Integer'Last) then\n-         if Minus and then Uval = Unsigned (-(Integer'First)) then\n-            return Integer'First;\n-         else\n-            Bad_Value (Str);\n-         end if;\n-\n-      --  Negative values\n-\n-      elsif Minus then\n-         return -(Integer (Uval));\n-\n-      --  Positive values\n-\n-      else\n-         return Integer (Uval);\n-      end if;\n-   end Scan_Integer;\n-\n-   -------------------\n-   -- Value_Integer --\n-   -------------------\n-\n-   function Value_Integer (Str : String) return Integer is\n-   begin\n-      --  We have to special case Str'Last = Positive'Last because the normal\n-      --  circuit ends up setting P to Str'Last + 1 which is out of bounds. We\n-      --  deal with this by converting to a subtype which fixes the bounds.\n-\n-      if Str'Last = Positive'Last then\n-         declare\n-            subtype NT is String (1 .. Str'Length);\n-         begin\n-            return Value_Integer (NT (Str));\n-         end;\n-\n-      --  Normal case where Str'Last < Positive'Last\n-\n-      else\n-         declare\n-            V : Integer;\n-            P : aliased Integer := Str'First;\n-         begin\n-            V := Scan_Integer (Str, P'Access, Str'Last);\n-            Scan_Trailing_Blanks (Str, P);\n-            return V;\n-         end;\n-      end if;\n-   end Value_Integer;\n-\n-end System.Val_Int;\n+pragma No_Body;"}, {"sha": "8a3c55ecc95ed704247760f38d7c465eff2bbb37", "filename": "gcc/ada/libgnat/s-valint.ads", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valint.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -32,42 +32,24 @@\n --  This package contains routines for scanning signed Integer values for use\n --  in Text_IO.Integer_IO, and the Value attribute.\n \n+with System.Unsigned_Types;\n+with System.Val_Uns;\n+with System.Value_I;\n+\n package System.Val_Int is\n    pragma Preelaborate;\n \n+   subtype Unsigned is Unsigned_Types.Unsigned;\n+\n+   package Impl is new Value_I (Integer, Unsigned, Val_Uns.Scan_Raw_Unsigned);\n+\n    function Scan_Integer\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Integer;\n-   --  This function scans the string starting at Str (Ptr.all) for a valid\n-   --  integer according to the syntax described in (RM 3.5(43)). The substring\n-   --  scanned extends no further than Str (Max). There are three cases for the\n-   --  return:\n-   --\n-   --  If a valid integer is found after scanning past any initial spaces, then\n-   --  Ptr.all is updated past the last character of the integer (but trailing\n-   --  spaces are not scanned out).\n-   --\n-   --  If no valid integer is found, then Ptr.all points either to an initial\n-   --  non-digit character, or to Max + 1 if the field is all spaces and the\n-   --  exception Constraint_Error is raised.\n-   --\n-   --  If a syntactically valid integer is scanned, but the value is out of\n-   --  range, or, in the based case, the base value is out of range or there\n-   --  is an out of range digit, then Ptr.all points past the integer, and\n-   --  Constraint_Error is raised.\n-   --\n-   --  Note: these rules correspond to the requirements for leaving the pointer\n-   --  positioned in Text_Io.Get\n-   --\n-   --  Note: if Str is null, i.e. if Max is less than Ptr, then this is a\n-   --  special case of an all-blank string, and Ptr is unchanged, and hence\n-   --  is greater than Max as required in this case.\n+      Max : Integer) return Integer\n+     renames Impl.Scan_Integer;\n \n-   function Value_Integer (Str : String) return Integer;\n-   --  Used in computing X'Value (Str) where X is a signed integer type whose\n-   --  base range does not exceed the base range of Integer. Str is the string\n-   --  argument of the attribute. Constraint_Error is raised if the string is\n-   --  malformed, or if the value is out of range.\n+   function Value_Integer (Str : String) return Integer\n+     renames Impl.Value_Integer;\n \n end System.Val_Int;"}, {"sha": "eadab12a949d14099a2b91ecf8e49834d0c5dbcb", "filename": "gcc/ada/libgnat/s-vallli.adb", "status": "modified", "additions": 4, "deletions": 88, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-vallli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-vallli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vallli.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,92 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n-with System.Val_LLU;        use System.Val_LLU;\n-with System.Val_Util;       use System.Val_Util;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Val_LLI is\n-\n-   ----------------------------\n-   -- Scan_Long_Long_Integer --\n-   ----------------------------\n-\n-   function Scan_Long_Long_Integer\n-     (Str  : String;\n-      Ptr  : not null access Integer;\n-      Max  : Integer) return Long_Long_Integer\n-   is\n-      Uval : Long_Long_Unsigned;\n-      --  Unsigned result\n-\n-      Minus : Boolean := False;\n-      --  Set to True if minus sign is present, otherwise to False\n-\n-      Start : Positive;\n-      --  Saves location of first non-blank\n-\n-   begin\n-      Scan_Sign (Str, Ptr, Max, Minus, Start);\n-\n-      if Str (Ptr.all) not in '0' .. '9' then\n-         Ptr.all := Start;\n-         Bad_Value (Str);\n-      end if;\n-\n-      Uval := Scan_Raw_Long_Long_Unsigned (Str, Ptr, Max);\n-\n-      --  Deal with overflow cases, and also with maximum negative number\n-\n-      if Uval > Long_Long_Unsigned (Long_Long_Integer'Last) then\n-         if Minus\n-           and then Uval = Long_Long_Unsigned (-(Long_Long_Integer'First))\n-         then\n-            return Long_Long_Integer'First;\n-         else\n-            Bad_Value (Str);\n-         end if;\n-\n-      --  Negative values\n-\n-      elsif Minus then\n-         return -(Long_Long_Integer (Uval));\n-\n-      --  Positive values\n-\n-      else\n-         return Long_Long_Integer (Uval);\n-      end if;\n-   end Scan_Long_Long_Integer;\n-\n-   -----------------------------\n-   -- Value_Long_Long_Integer --\n-   -----------------------------\n-\n-   function Value_Long_Long_Integer (Str : String) return Long_Long_Integer is\n-   begin\n-      --  We have to special case Str'Last = Positive'Last because the normal\n-      --  circuit ends up setting P to Str'Last + 1 which is out of bounds. We\n-      --  deal with this by converting to a subtype which fixes the bounds.\n-\n-      if Str'Last = Positive'Last then\n-         declare\n-            subtype NT is String (1 .. Str'Length);\n-         begin\n-            return Value_Long_Long_Integer (NT (Str));\n-         end;\n-\n-      --  Normal case where Str'Last < Positive'Last\n-\n-      else\n-         declare\n-            V : Long_Long_Integer;\n-            P : aliased Integer := Str'First;\n-         begin\n-            V := Scan_Long_Long_Integer (Str, P'Access, Str'Last);\n-            Scan_Trailing_Blanks (Str, P);\n-            return V;\n-         end;\n-      end if;\n-   end Value_Long_Long_Integer;\n-\n-end System.Val_LLI;\n+pragma No_Body;"}, {"sha": "e53873e4cb614f3c85d1c721dba2ccd2dab1d2ec", "filename": "gcc/ada/libgnat/s-vallli.ads", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-vallli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-vallli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vallli.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -32,42 +32,27 @@\n --  This package contains routines for scanning signed Long_Long_Integer\n --  values for use in Text_IO.Integer_IO, and the Value attribute.\n \n+with System.Unsigned_Types;\n+with System.Val_LLU;\n+with System.Value_I;\n+\n package System.Val_LLI is\n    pragma Preelaborate;\n \n+   subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n+\n+   package Impl is new\n+     Value_I (Long_Long_Integer,\n+              Long_Long_Unsigned,\n+              Val_LLU.Scan_Raw_Long_Long_Unsigned);\n+\n    function Scan_Long_Long_Integer\n      (Str  : String;\n       Ptr  : not null access Integer;\n-      Max  : Integer) return Long_Long_Integer;\n-   --  This function scans the string starting at Str (Ptr.all) for a valid\n-   --  integer according to the syntax described in (RM 3.5(43)). The substring\n-   --  scanned extends no further than Str (Max). There are three cases for the\n-   --  return:\n-   --\n-   --  If a valid integer is found after scanning past any initial spaces, then\n-   --  Ptr.all is updated past the last character of the integer (but trailing\n-   --  spaces are not scanned out).\n-   --\n-   --  If no valid integer is found, then Ptr.all points either to an initial\n-   --  non-digit character, or to Max + 1 if the field is all spaces and the\n-   --  exception Constraint_Error is raised.\n-   --\n-   --  If a syntactically valid integer is scanned, but the value is out of\n-   --  range, or, in the based case, the base value is out of range or there\n-   --  is an out of range digit, then Ptr.all points past the integer, and\n-   --  Constraint_Error is raised.\n-   --\n-   --  Note: these rules correspond to the requirements for leaving the pointer\n-   --  positioned in Text_Io.Get\n-   --\n-   --  Note: if Str is null, i.e. if Max is less than Ptr, then this is a\n-   --  special case of an all-blank string, and Ptr is unchanged, and hence\n-   --  is greater than Max as required in this case.\n+      Max  : Integer) return Long_Long_Integer\n+     renames Impl.Scan_Integer;\n \n-   function Value_Long_Long_Integer (Str : String) return Long_Long_Integer;\n-   --  Used in computing X'Value (Str) where X is a signed integer type whose\n-   --  base range exceeds the base range of Integer. Str is the string argument\n-   --  of the attribute. Constraint_Error is raised if the string is malformed,\n-   --  or if the value is out of range.\n+   function Value_Long_Long_Integer (Str : String) return Long_Long_Integer\n+     renames Impl.Value_Integer;\n \n end System.Val_LLI;"}, {"sha": "9ab7161e057ac97f05cfc4ef4519004ffd4f88f3", "filename": "gcc/ada/libgnat/s-valllli.ads", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valllli.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,59 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . V A L _ L L L I                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for scanning signed Long_Long_Long_Integer\n+--  values for use in Text_IO.Integer_IO, and the Value attribute.\n+\n+with System.Unsigned_Types;\n+with System.Val_LLLU;\n+with System.Value_I;\n+\n+package System.Val_LLLI is\n+   pragma Preelaborate;\n+\n+   subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n+\n+   package Impl is new\n+     Value_I (Long_Long_Long_Integer,\n+              Long_Long_Long_Unsigned,\n+              Val_LLLU.Scan_Raw_Long_Long_Long_Unsigned);\n+\n+   function Scan_Long_Long_Long_Integer\n+     (Str  : String;\n+      Ptr  : not null access Integer;\n+      Max  : Integer) return Long_Long_Long_Integer\n+     renames Impl.Scan_Integer;\n+\n+   function Value_Long_Long_Long_Integer\n+      (Str : String) return Long_Long_Long_Integer\n+     renames Impl.Value_Integer;\n+\n+end System.Val_LLLI;"}, {"sha": "34ce28288f260772ddf3fa6508b7660acc2a8e93", "filename": "gcc/ada/libgnat/s-vallllu.ads", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-vallllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-vallllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vallllu.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . V A L _ L L L U                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for scanning modular Long_Long_Unsigned\n+--  values for use in Text_IO.Modular_IO, and the Value attribute.\n+\n+with System.Unsigned_Types;\n+with System.Value_U;\n+\n+package System.Val_LLLU is\n+   pragma Preelaborate;\n+\n+   subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n+\n+   package Impl is new Value_U (Long_Long_Long_Unsigned);\n+\n+   function Scan_Raw_Long_Long_Long_Unsigned\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer) return Long_Long_Long_Unsigned\n+     renames Impl.Scan_Raw_Unsigned;\n+\n+   function Scan_Long_Long_Long_Unsigned\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer) return Long_Long_Long_Unsigned\n+     renames Impl.Scan_Unsigned;\n+\n+   function Value_Long_Long_Long_Unsigned\n+     (Str : String) return Long_Long_Long_Unsigned\n+     renames Impl.Value_Unsigned;\n+\n+end System.Val_LLLU;"}, {"sha": "1afb6324c51688ce757468014f36a4b7c827e29a", "filename": "gcc/ada/libgnat/s-valllu.adb", "status": "modified", "additions": 4, "deletions": 298, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valllu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valllu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valllu.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,302 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n-with System.Val_Util;       use System.Val_Util;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Val_LLU is\n-\n-   ---------------------------------\n-   -- Scan_Raw_Long_Long_Unsigned --\n-   ---------------------------------\n-\n-   function Scan_Raw_Long_Long_Unsigned\n-     (Str : String;\n-      Ptr : not null access Integer;\n-      Max : Integer) return Long_Long_Unsigned\n-   is\n-      P : Integer;\n-      --  Local copy of the pointer\n-\n-      Uval : Long_Long_Unsigned;\n-      --  Accumulated unsigned integer result\n-\n-      Expon : Integer;\n-      --  Exponent value\n-\n-      Overflow : Boolean := False;\n-      --  Set True if overflow is detected at any point\n-\n-      Base_Char : Character;\n-      --  Base character (# or :) in based case\n-\n-      Base : Long_Long_Unsigned := 10;\n-      --  Base value (reset in based case)\n-\n-      Digit : Long_Long_Unsigned;\n-      --  Digit value\n-\n-   begin\n-      --  We do not tolerate strings with Str'Last = Positive'Last\n-\n-      if Str'Last = Positive'Last then\n-         raise Program_Error with\n-           \"string upper bound is Positive'Last, not supported\";\n-      end if;\n-\n-      P := Ptr.all;\n-      Uval := Character'Pos (Str (P)) - Character'Pos ('0');\n-      P := P + 1;\n-\n-      --  Scan out digits of what is either the number or the base.\n-      --  In either case, we are definitely scanning out in base 10.\n-\n-      declare\n-         Umax : constant := (Long_Long_Unsigned'Last - 9) / 10;\n-         --  Max value which cannot overflow on accumulating next digit\n-\n-         Umax10 : constant := Long_Long_Unsigned'Last / 10;\n-         --  Numbers bigger than Umax10 overflow if multiplied by 10\n-\n-      begin\n-         --  Loop through decimal digits\n-         loop\n-            exit when P > Max;\n-\n-            Digit := Character'Pos (Str (P)) - Character'Pos ('0');\n-\n-            --  Non-digit encountered\n-\n-            if Digit > 9 then\n-               if Str (P) = '_' then\n-                  Scan_Underscore (Str, P, Ptr, Max, False);\n-               else\n-                  exit;\n-               end if;\n-\n-            --  Accumulate result, checking for overflow\n-\n-            else\n-               if Uval <= Umax then\n-                  Uval := 10 * Uval + Digit;\n-\n-               elsif Uval > Umax10 then\n-                  Overflow := True;\n-\n-               else\n-                  Uval := 10 * Uval + Digit;\n-\n-                  if Uval < Umax10 then\n-                     Overflow := True;\n-                  end if;\n-               end if;\n-\n-               P := P + 1;\n-            end if;\n-         end loop;\n-      end;\n-\n-      Ptr.all := P;\n-\n-      --  Deal with based case. We recognize either the standard '#' or the\n-      --  allowed alternative replacement ':' (see RM J.2(3)).\n-\n-      if P < Max and then (Str (P) = '#' or else Str (P) = ':') then\n-         Base_Char := Str (P);\n-         P := P + 1;\n-         Base := Uval;\n-         Uval := 0;\n-\n-         --  Check base value. Overflow is set True if we find a bad base, or\n-         --  a digit that is out of range of the base. That way, we scan out\n-         --  the numeral that is still syntactically correct, though illegal.\n-         --  We use a safe base of 16 for this scan, to avoid zero divide.\n-\n-         if Base not in 2 .. 16 then\n-            Overflow := True;\n-            Base := 16;\n-         end if;\n-\n-         --  Scan out based integer\n-\n-         declare\n-            Umax : constant Long_Long_Unsigned :=\n-                     (Long_Long_Unsigned'Last - Base + 1) / Base;\n-            --  Max value which cannot overflow on accumulating next digit\n-\n-            UmaxB : constant Long_Long_Unsigned :=\n-                      Long_Long_Unsigned'Last / Base;\n-            --  Numbers bigger than UmaxB overflow if multiplied by base\n-\n-         begin\n-            --  Loop to scan out based integer value\n-\n-            loop\n-               --  We require a digit at this stage\n-\n-               if Str (P) in '0' .. '9' then\n-                  Digit := Character'Pos (Str (P)) - Character'Pos ('0');\n-\n-               elsif Str (P) in 'A' .. 'F' then\n-                  Digit :=\n-                    Character'Pos (Str (P)) - (Character'Pos ('A') - 10);\n-\n-               elsif Str (P) in 'a' .. 'f' then\n-                  Digit :=\n-                    Character'Pos (Str (P)) - (Character'Pos ('a') - 10);\n-\n-               --  If we don't have a digit, then this is not a based number\n-               --  after all, so we use the value we scanned out as the base\n-               --  (now in Base), and the pointer to the base character was\n-               --  already stored in Ptr.all.\n-\n-               else\n-                  Uval := Base;\n-                  exit;\n-               end if;\n-\n-               --  If digit is too large, just signal overflow and continue.\n-               --  The idea here is to keep scanning as long as the input is\n-               --  syntactically valid, even if we have detected overflow\n-\n-               if Digit >= Base then\n-                  Overflow := True;\n-\n-               --  Here we accumulate the value, checking overflow\n-\n-               elsif Uval <= Umax then\n-                  Uval := Base * Uval + Digit;\n-\n-               elsif Uval > UmaxB then\n-                  Overflow := True;\n-\n-               else\n-                  Uval := Base * Uval + Digit;\n-\n-                  if Uval < UmaxB then\n-                     Overflow := True;\n-                  end if;\n-               end if;\n-\n-               --  If at end of string with no base char, not a based number\n-               --  but we signal Constraint_Error and set the pointer past\n-               --  the end of the field, since this is what the ACVC tests\n-               --  seem to require, see CE3704N, line 204.\n-\n-               P := P + 1;\n-\n-               if P > Max then\n-                  Ptr.all := P;\n-                  Bad_Value (Str);\n-               end if;\n-\n-               --  If terminating base character, we are done with loop\n-\n-               if Str (P) = Base_Char then\n-                  Ptr.all := P + 1;\n-                  exit;\n-\n-               --  Deal with underscore\n-\n-               elsif Str (P) = '_' then\n-                  Scan_Underscore (Str, P, Ptr, Max, True);\n-               end if;\n-\n-            end loop;\n-         end;\n-      end if;\n-\n-      --  Come here with scanned unsigned value in Uval. The only remaining\n-      --  required step is to deal with exponent if one is present.\n-\n-      Expon := Scan_Exponent (Str, Ptr, Max);\n-\n-      if Expon /= 0 and then Uval /= 0 then\n-\n-         --  For non-zero value, scale by exponent value. No need to do this\n-         --  efficiently, since use of exponent in integer literals is rare,\n-         --  and in any case the exponent cannot be very large.\n-\n-         declare\n-            UmaxB : constant Long_Long_Unsigned :=\n-                      Long_Long_Unsigned'Last / Base;\n-            --  Numbers bigger than UmaxB overflow if multiplied by base\n-\n-         begin\n-            for J in 1 .. Expon loop\n-               if Uval > UmaxB then\n-                  Overflow := True;\n-                  exit;\n-               end if;\n-\n-               Uval := Uval * Base;\n-            end loop;\n-         end;\n-      end if;\n-\n-      --  Return result, dealing with sign and overflow\n-\n-      if Overflow then\n-         Bad_Value (Str);\n-      else\n-         return Uval;\n-      end if;\n-   end Scan_Raw_Long_Long_Unsigned;\n-\n-   -----------------------------\n-   -- Scan_Long_Long_Unsigned --\n-   -----------------------------\n-\n-   function Scan_Long_Long_Unsigned\n-     (Str : String;\n-      Ptr : not null access Integer;\n-      Max : Integer) return Long_Long_Unsigned\n-   is\n-      Start : Positive;\n-      --  Save location of first non-blank character\n-\n-   begin\n-      Scan_Plus_Sign (Str, Ptr, Max, Start);\n-\n-      if Str (Ptr.all) not in '0' .. '9' then\n-         Ptr.all := Start;\n-         raise Constraint_Error;\n-      end if;\n-\n-      return Scan_Raw_Long_Long_Unsigned (Str, Ptr, Max);\n-   end Scan_Long_Long_Unsigned;\n-\n-   ------------------------------\n-   -- Value_Long_Long_Unsigned --\n-   ------------------------------\n-\n-   function Value_Long_Long_Unsigned\n-     (Str : String) return Long_Long_Unsigned\n-   is\n-   begin\n-      --  We have to special case Str'Last = Positive'Last because the normal\n-      --  circuit ends up setting P to Str'Last + 1 which is out of bounds. We\n-      --  deal with this by converting to a subtype which fixes the bounds.\n-\n-      if Str'Last = Positive'Last then\n-         declare\n-            subtype NT is String (1 .. Str'Length);\n-         begin\n-            return Value_Long_Long_Unsigned (NT (Str));\n-         end;\n-\n-      --  Normal case where Str'Last < Positive'Last\n-\n-      else\n-         declare\n-            V : Long_Long_Unsigned;\n-            P : aliased Integer := Str'First;\n-         begin\n-            V := Scan_Long_Long_Unsigned (Str, P'Access, Str'Last);\n-            Scan_Trailing_Blanks (Str, P);\n-            return V;\n-         end;\n-      end if;\n-   end Value_Long_Long_Unsigned;\n-\n-end System.Val_LLU;\n+pragma No_Body;"}, {"sha": "5c0300c8560a80ea3a1c1637c79965cac654e1c8", "filename": "gcc/ada/libgnat/s-valllu.ads", "status": "modified", "additions": 11, "deletions": 79, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valllu.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -33,97 +33,29 @@\n --  values for use in Text_IO.Modular_IO, and the Value attribute.\n \n with System.Unsigned_Types;\n+with System.Value_U;\n \n package System.Val_LLU is\n    pragma Preelaborate;\n \n+   subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n+\n+   package Impl is new Value_U (Long_Long_Unsigned);\n+\n    function Scan_Raw_Long_Long_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return System.Unsigned_Types.Long_Long_Unsigned;\n-   --  This function scans the string starting at Str (Ptr.all) for a valid\n-   --  integer according to the syntax described in (RM 3.5(43)). The substring\n-   --  scanned extends no further than Str (Max).  Note: this does not scan\n-   --  leading or trailing blanks, nor leading sign.\n-   --\n-   --  There are three cases for the return:\n-   --\n-   --  If a valid integer is found, then Ptr.all is updated past the last\n-   --  character of the integer.\n-   --\n-   --  If no valid integer is found, then Ptr.all points either to an initial\n-   --  non-digit character, or to Max + 1 if the field is all spaces and the\n-   --  exception Constraint_Error is raised.\n-   --\n-   --  If a syntactically valid integer is scanned, but the value is out of\n-   --  range, or, in the based case, the base value is out of range or there\n-   --  is an out of range digit, then Ptr.all points past the integer, and\n-   --  Constraint_Error is raised.\n-   --\n-   --  Note: these rules correspond to the requirements for leaving the pointer\n-   --  positioned in Text_IO.Get. Note that the rules as stated in the RM would\n-   --  seem to imply that for a case like:\n-   --\n-   --    8#12345670009#\n-   --\n-   --  the pointer should be left at the first # having scanned out the longest\n-   --  valid integer literal (8), but in fact in this case the pointer points\n-   --  past the final # and Constraint_Error is raised. This is the behavior\n-   --  expected for Text_IO and enforced by the ACATS tests.\n-   --\n-   --  If a based literal is malformed in that a character other than a valid\n-   --  hexadecimal digit is encountered during scanning out the digits after\n-   --  the # (this includes the case of using the wrong terminator, : instead\n-   --  of # or vice versa) there are two cases. If all the digits before the\n-   --  non-digit are in range of the base, as in\n-   --\n-   --    8#100x00#\n-   --    8#100:\n-   --\n-   --  then in this case, the \"base\" value before the initial # is returned as\n-   --  the result, and the pointer points to the initial # character on return.\n-   --\n-   --  If an out of range digit has been detected before the invalid character,\n-   --  as in:\n-   --\n-   --   8#900x00#\n-   --   8#900:\n-   --\n-   --  then the pointer is also left at the initial # character, but constraint\n-   --  error is raised reflecting the encounter of an out of range digit.\n-   --\n-   --  Finally if we have an unterminated fixed-point constant where the final\n-   --  # or : character is missing, Constraint_Error is raised and the pointer\n-   --  is left pointing past the last digit, as in:\n-   --\n-   --   8#22\n-   --\n-   --  This string results in a Constraint_Error with the pointer pointing\n-   --  past the second 2.\n-   --\n-   --  Note: if Str is empty, i.e. if Max is less than Ptr, then this is a\n-   --  special case of an all-blank string, and Ptr is unchanged, and hence\n-   --  is greater than Max as required in this case.\n-   --\n-   --  Note: this routine should not be called with Str'Last = Positive'Last.\n-   --  If this occurs Program_Error is raised with a message noting that this\n-   --  case is not supported. Most such cases are eliminated by the caller.\n+      Max : Integer) return Long_Long_Unsigned\n+     renames Impl.Scan_Raw_Unsigned;\n \n    function Scan_Long_Long_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return System.Unsigned_Types.Long_Long_Unsigned;\n-   --  Same as Scan_Raw_Long_Long_Unsigned, except scans optional leading\n-   --  blanks, and an optional leading plus sign.\n-   --\n-   --  Note: if a minus sign is present, Constraint_Error will be raised.\n-   --  Note: trailing blanks are not scanned.\n+      Max : Integer) return Long_Long_Unsigned\n+     renames Impl.Scan_Unsigned;\n \n    function Value_Long_Long_Unsigned\n-     (Str : String) return System.Unsigned_Types.Long_Long_Unsigned;\n-   --  Used in computing X'Value (Str) where X is a modular integer type whose\n-   --  modulus exceeds the range of System.Unsigned_Types.Unsigned. Str is the\n-   --  string argument of the attribute. Constraint_Error is raised if the\n-   --  string is malformed, or if the value is out of range.\n+     (Str : String) return Long_Long_Unsigned\n+     renames Impl.Value_Unsigned;\n \n end System.Val_LLU;"}, {"sha": "1bc8b32f8537e36ea842531016c5063040f4de7f", "filename": "gcc/ada/libgnat/s-valuei.adb", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuei.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,116 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . V A L U E _ I                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Val_Util; use System.Val_Util;\n+\n+package body System.Value_I is\n+\n+   ------------------\n+   -- Scan_Integer --\n+   ------------------\n+\n+   function Scan_Integer\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer) return Int\n+   is\n+      Uval : Uns;\n+      --  Unsigned result\n+\n+      Minus : Boolean := False;\n+      --  Set to True if minus sign is present, otherwise to False\n+\n+      Start : Positive;\n+      --  Saves location of first non-blank (not used in this case)\n+\n+   begin\n+      Scan_Sign (Str, Ptr, Max, Minus, Start);\n+\n+      if Str (Ptr.all) not in '0' .. '9' then\n+         Ptr.all := Start;\n+         Bad_Value (Str);\n+      end if;\n+\n+      Uval := Scan_Raw_Unsigned (Str, Ptr, Max);\n+\n+      --  Deal with overflow cases, and also with maximum negative number\n+\n+      if Uval > Uns (Int'Last) then\n+         if Minus and then Uval = Uns (-(Int'First)) then\n+            return Int'First;\n+         else\n+            Bad_Value (Str);\n+         end if;\n+\n+      --  Negative values\n+\n+      elsif Minus then\n+         return -(Int (Uval));\n+\n+      --  Positive values\n+\n+      else\n+         return Int (Uval);\n+      end if;\n+   end Scan_Integer;\n+\n+   -------------------\n+   -- Value_Integer --\n+   -------------------\n+\n+   function Value_Integer (Str : String) return Int is\n+   begin\n+      --  We have to special case Str'Last = Positive'Last because the normal\n+      --  circuit ends up setting P to Str'Last + 1 which is out of bounds. We\n+      --  deal with this by converting to a subtype which fixes the bounds.\n+\n+      if Str'Last = Positive'Last then\n+         declare\n+            subtype NT is String (1 .. Str'Length);\n+         begin\n+            return Value_Integer (NT (Str));\n+         end;\n+\n+      --  Normal case where Str'Last < Positive'Last\n+\n+      else\n+         declare\n+            V : Int;\n+            P : aliased Integer := Str'First;\n+         begin\n+            V := Scan_Integer (Str, P'Access, Str'Last);\n+            Scan_Trailing_Blanks (Str, P);\n+            return V;\n+         end;\n+      end if;\n+   end Value_Integer;\n+\n+end System.Value_I;"}, {"sha": "13f4f8cf23b7212f2fca4ca7f741b7d72beab666", "filename": "gcc/ada/libgnat/s-valuei.ads", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valuei.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valuei.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuei.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,84 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . V A L U E _ I                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for scanning signed integer values for use\n+--  in Text_IO.Integer_IO, and the Value attribute.\n+\n+generic\n+\n+   type Int is range <>;\n+\n+   type Uns is mod <>;\n+\n+   with function Scan_Raw_Unsigned\n+          (Str : String;\n+           Ptr : not null access Integer;\n+           Max : Integer) return Uns;\n+\n+package System.Value_I is\n+   pragma Preelaborate;\n+\n+   function Scan_Integer\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer) return Int;\n+   --  This function scans the string starting at Str (Ptr.all) for a valid\n+   --  integer according to the syntax described in (RM 3.5(43)). The substring\n+   --  scanned extends no further than Str (Max). There are three cases for the\n+   --  return:\n+   --\n+   --  If a valid integer is found after scanning past any initial spaces, then\n+   --  Ptr.all is updated past the last character of the integer (but trailing\n+   --  spaces are not scanned out).\n+   --\n+   --  If no valid integer is found, then Ptr.all points either to an initial\n+   --  non-digit character, or to Max + 1 if the field is all spaces and the\n+   --  exception Constraint_Error is raised.\n+   --\n+   --  If a syntactically valid integer is scanned, but the value is out of\n+   --  range, or, in the based case, the base value is out of range or there\n+   --  is an out of range digit, then Ptr.all points past the integer, and\n+   --  Constraint_Error is raised.\n+   --\n+   --  Note: these rules correspond to the requirements for leaving the pointer\n+   --  positioned in Text_Io.Get\n+   --\n+   --  Note: if Str is null, i.e. if Max is less than Ptr, then this is a\n+   --  special case of an all-blank string, and Ptr is unchanged, and hence\n+   --  is greater than Max as required in this case.\n+\n+   function Value_Integer (Str : String) return Int;\n+   --  Used in computing X'Value (Str) where X is a signed integer type whose\n+   --  base range does not exceed the base range of Integer. Str is the string\n+   --  argument of the attribute. Constraint_Error is raised if the string is\n+   --  malformed, or if the value is out of range.\n+\n+end System.Value_I;"}, {"sha": "75bef07fde17882421d5b4711d07b0fb5580bfc7", "filename": "gcc/ada/libgnat/s-valueu.adb", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valueu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valueu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valueu.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,324 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . V A L U E _ U                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Val_Util; use System.Val_Util;\n+\n+package body System.Value_U is\n+\n+   -----------------------\n+   -- Scan_Raw_Unsigned --\n+   -----------------------\n+\n+   function Scan_Raw_Unsigned\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer) return Uns\n+   is\n+      P : Integer;\n+      --  Local copy of the pointer\n+\n+      Uval : Uns;\n+      --  Accumulated unsigned integer result\n+\n+      Expon : Integer;\n+      --  Exponent value\n+\n+      Overflow : Boolean := False;\n+      --  Set True if overflow is detected at any point\n+\n+      Base_Char : Character;\n+      --  Base character (# or :) in based case\n+\n+      Base : Uns := 10;\n+      --  Base value (reset in based case)\n+\n+      Digit : Uns;\n+      --  Digit value\n+\n+   begin\n+      --  We do not tolerate strings with Str'Last = Positive'Last\n+\n+      if Str'Last = Positive'Last then\n+         raise Program_Error with\n+           \"string upper bound is Positive'Last, not supported\";\n+      end if;\n+\n+      P := Ptr.all;\n+      Uval := Character'Pos (Str (P)) - Character'Pos ('0');\n+      P := P + 1;\n+\n+      --  Scan out digits of what is either the number or the base.\n+      --  In either case, we are definitely scanning out in base 10.\n+\n+      declare\n+         Umax : constant Uns := (Uns'Last - 9) / 10;\n+         --  Max value which cannot overflow on accumulating next digit\n+\n+         Umax10 : constant Uns := Uns'Last / 10;\n+         --  Numbers bigger than Umax10 overflow if multiplied by 10\n+\n+      begin\n+         --  Loop through decimal digits\n+         loop\n+            exit when P > Max;\n+\n+            Digit := Character'Pos (Str (P)) - Character'Pos ('0');\n+\n+            --  Non-digit encountered\n+\n+            if Digit > 9 then\n+               if Str (P) = '_' then\n+                  Scan_Underscore (Str, P, Ptr, Max, False);\n+               else\n+                  exit;\n+               end if;\n+\n+            --  Accumulate result, checking for overflow\n+\n+            else\n+               if Uval <= Umax then\n+                  Uval := 10 * Uval + Digit;\n+\n+               elsif Uval > Umax10 then\n+                  Overflow := True;\n+\n+               else\n+                  Uval := 10 * Uval + Digit;\n+\n+                  if Uval < Umax10 then\n+                     Overflow := True;\n+                  end if;\n+               end if;\n+\n+               P := P + 1;\n+            end if;\n+         end loop;\n+      end;\n+\n+      Ptr.all := P;\n+\n+      --  Deal with based case. We recognize either the standard '#' or the\n+      --  allowed alternative replacement ':' (see RM J.2(3)).\n+\n+      if P < Max and then (Str (P) = '#' or else Str (P) = ':') then\n+         Base_Char := Str (P);\n+         P := P + 1;\n+         Base := Uval;\n+         Uval := 0;\n+\n+         --  Check base value. Overflow is set True if we find a bad base, or\n+         --  a digit that is out of range of the base. That way, we scan out\n+         --  the numeral that is still syntactically correct, though illegal.\n+         --  We use a safe base of 16 for this scan, to avoid zero divide.\n+\n+         if Base not in 2 .. 16 then\n+            Overflow := True;\n+            Base := 16;\n+         end if;\n+\n+         --  Scan out based integer\n+\n+         declare\n+            Umax : constant Uns := (Uns'Last - Base + 1) / Base;\n+            --  Max value which cannot overflow on accumulating next digit\n+\n+            UmaxB : constant Uns := Uns'Last / Base;\n+            --  Numbers bigger than UmaxB overflow if multiplied by base\n+\n+         begin\n+            --  Loop to scan out based integer value\n+\n+            loop\n+               --  We require a digit at this stage\n+\n+               if Str (P) in '0' .. '9' then\n+                  Digit := Character'Pos (Str (P)) - Character'Pos ('0');\n+\n+               elsif Str (P) in 'A' .. 'F' then\n+                  Digit :=\n+                    Character'Pos (Str (P)) - (Character'Pos ('A') - 10);\n+\n+               elsif Str (P) in 'a' .. 'f' then\n+                  Digit :=\n+                    Character'Pos (Str (P)) - (Character'Pos ('a') - 10);\n+\n+               --  If we don't have a digit, then this is not a based number\n+               --  after all, so we use the value we scanned out as the base\n+               --  (now in Base), and the pointer to the base character was\n+               --  already stored in Ptr.all.\n+\n+               else\n+                  Uval := Base;\n+                  exit;\n+               end if;\n+\n+               --  If digit is too large, just signal overflow and continue.\n+               --  The idea here is to keep scanning as long as the input is\n+               --  syntactically valid, even if we have detected overflow\n+\n+               if Digit >= Base then\n+                  Overflow := True;\n+\n+               --  Here we accumulate the value, checking overflow\n+\n+               elsif Uval <= Umax then\n+                  Uval := Base * Uval + Digit;\n+\n+               elsif Uval > UmaxB then\n+                  Overflow := True;\n+\n+               else\n+                  Uval := Base * Uval + Digit;\n+\n+                  if Uval < UmaxB then\n+                     Overflow := True;\n+                  end if;\n+               end if;\n+\n+               --  If at end of string with no base char, not a based number\n+               --  but we signal Constraint_Error and set the pointer past\n+               --  the end of the field, since this is what the ACVC tests\n+               --  seem to require, see CE3704N, line 204.\n+\n+               P := P + 1;\n+\n+               if P > Max then\n+                  Ptr.all := P;\n+                  Bad_Value (Str);\n+               end if;\n+\n+               --  If terminating base character, we are done with loop\n+\n+               if Str (P) = Base_Char then\n+                  Ptr.all := P + 1;\n+                  exit;\n+\n+               --  Deal with underscore\n+\n+               elsif Str (P) = '_' then\n+                  Scan_Underscore (Str, P, Ptr, Max, True);\n+               end if;\n+\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  Come here with scanned unsigned value in Uval. The only remaining\n+      --  required step is to deal with exponent if one is present.\n+\n+      Expon := Scan_Exponent (Str, Ptr, Max);\n+\n+      if Expon /= 0 and then Uval /= 0 then\n+\n+         --  For non-zero value, scale by exponent value. No need to do this\n+         --  efficiently, since use of exponent in integer literals is rare,\n+         --  and in any case the exponent cannot be very large.\n+\n+         declare\n+            UmaxB : constant Uns := Uns'Last / Base;\n+            --  Numbers bigger than UmaxB overflow if multiplied by base\n+\n+         begin\n+            for J in 1 .. Expon loop\n+               if Uval > UmaxB then\n+                  Overflow := True;\n+                  exit;\n+               end if;\n+\n+               Uval := Uval * Base;\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  Return result, dealing with sign and overflow\n+\n+      if Overflow then\n+         Bad_Value (Str);\n+      else\n+         return Uval;\n+      end if;\n+   end Scan_Raw_Unsigned;\n+\n+   -------------------\n+   -- Scan_Unsigned --\n+   -------------------\n+\n+   function Scan_Unsigned\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer) return Uns\n+   is\n+      Start : Positive;\n+      --  Save location of first non-blank character\n+\n+   begin\n+      Scan_Plus_Sign (Str, Ptr, Max, Start);\n+\n+      if Str (Ptr.all) not in '0' .. '9' then\n+         Ptr.all := Start;\n+         Bad_Value (Str);\n+      end if;\n+\n+      return Scan_Raw_Unsigned (Str, Ptr, Max);\n+   end Scan_Unsigned;\n+\n+   --------------------\n+   -- Value_Unsigned --\n+   --------------------\n+\n+   function Value_Unsigned (Str : String) return Uns is\n+   begin\n+      --  We have to special case Str'Last = Positive'Last because the normal\n+      --  circuit ends up setting P to Str'Last + 1 which is out of bounds. We\n+      --  deal with this by converting to a subtype which fixes the bounds.\n+\n+      if Str'Last = Positive'Last then\n+         declare\n+            subtype NT is String (1 .. Str'Length);\n+         begin\n+            return Value_Unsigned (NT (Str));\n+         end;\n+\n+      --  Normal case where Str'Last < Positive'Last\n+\n+      else\n+         declare\n+            V : Uns;\n+            P : aliased Integer := Str'First;\n+         begin\n+            V := Scan_Unsigned (Str, P'Access, Str'Last);\n+            Scan_Trailing_Blanks (Str, P);\n+            return V;\n+         end;\n+      end if;\n+   end Value_Unsigned;\n+\n+end System.Value_U;"}, {"sha": "ad8256c8ab2940efde7f8d0280d5418d1f168cfc", "filename": "gcc/ada/libgnat/s-valueu.ads", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valueu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valueu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valueu.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,131 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . V A L U E _ U                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for scanning modular Unsigned\n+--  values for use in Text_IO.Modular_IO, and the Value attribute.\n+\n+generic\n+\n+   type Uns is mod <>;\n+\n+package System.Value_U is\n+   pragma Preelaborate;\n+\n+   function Scan_Raw_Unsigned\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer) return Uns;\n+   --  This function scans the string starting at Str (Ptr.all) for a valid\n+   --  integer according to the syntax described in (RM 3.5(43)). The substring\n+   --  scanned extends no further than Str (Max).  Note: this does not scan\n+   --  leading or trailing blanks, nor leading sign.\n+   --\n+   --  There are three cases for the return:\n+   --\n+   --  If a valid integer is found, then Ptr.all is updated past the last\n+   --  character of the integer.\n+   --\n+   --  If no valid integer is found, then Ptr.all points either to an initial\n+   --  non-digit character, or to Max + 1 if the field is all spaces and the\n+   --  exception Constraint_Error is raised.\n+   --\n+   --  If a syntactically valid integer is scanned, but the value is out of\n+   --  range, or, in the based case, the base value is out of range or there\n+   --  is an out of range digit, then Ptr.all points past the integer, and\n+   --  Constraint_Error is raised.\n+   --\n+   --  Note: these rules correspond to the requirements for leaving the pointer\n+   --  positioned in Text_IO.Get. Note that the rules as stated in the RM would\n+   --  seem to imply that for a case like:\n+   --\n+   --    8#12345670009#\n+   --\n+   --  the pointer should be left at the first # having scanned out the longest\n+   --  valid integer literal (8), but in fact in this case the pointer points\n+   --  past the final # and Constraint_Error is raised. This is the behavior\n+   --  expected for Text_IO and enforced by the ACATS tests.\n+   --\n+   --  If a based literal is malformed in that a character other than a valid\n+   --  hexadecimal digit is encountered during scanning out the digits after\n+   --  the # (this includes the case of using the wrong terminator, : instead\n+   --  of # or vice versa) there are two cases. If all the digits before the\n+   --  non-digit are in range of the base, as in\n+   --\n+   --    8#100x00#\n+   --    8#100:\n+   --\n+   --  then in this case, the \"base\" value before the initial # is returned as\n+   --  the result, and the pointer points to the initial # character on return.\n+   --\n+   --  If an out of range digit has been detected before the invalid character,\n+   --  as in:\n+   --\n+   --   8#900x00#\n+   --   8#900:\n+   --\n+   --  then the pointer is also left at the initial # character, but constraint\n+   --  error is raised reflecting the encounter of an out of range digit.\n+   --\n+   --  Finally if we have an unterminated fixed-point constant where the final\n+   --  # or : character is missing, Constraint_Error is raised and the pointer\n+   --  is left pointing past the last digit, as in:\n+   --\n+   --   8#22\n+   --\n+   --  This string results in a Constraint_Error with the pointer pointing\n+   --  past the second 2.\n+   --\n+   --  Note: if Str is empty, i.e. if Max is less than Ptr, then this is a\n+   --  special case of an all-blank string, and Ptr is unchanged, and hence\n+   --  is greater than Max as required in this case.\n+   --\n+   --  Note: this routine should not be called with Str'Last = Positive'Last.\n+   --  If this occurs Program_Error is raised with a message noting that this\n+   --  case is not supported. Most such cases are eliminated by the caller.\n+\n+   function Scan_Unsigned\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer) return Uns;\n+   --  Same as Scan_Raw_Unsigned, except scans optional leading\n+   --  blanks, and an optional leading plus sign.\n+   --\n+   --  Note: if a minus sign is present, Constraint_Error will be raised.\n+   --  Note: trailing blanks are not scanned.\n+\n+   function Value_Unsigned\n+     (Str : String) return Uns;\n+   --  Used in computing X'Value (Str) where X is a modular integer type whose\n+   --  modulus does not exceed the range of System.Unsigned_Types.Unsigned. Str\n+   --  is the string argument of the attribute. Constraint_Error is raised if\n+   --  the string is malformed, or if the value is out of range.\n+\n+end System.Value_U;"}, {"sha": "b710a9b8a65832094d8a7fe79fab143d15cec94e", "filename": "gcc/ada/libgnat/s-valuns.adb", "status": "modified", "additions": 4, "deletions": 293, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valuns.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valuns.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuns.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,297 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n-with System.Val_Util;       use System.Val_Util;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Val_Uns is\n-\n-   -----------------------\n-   -- Scan_Raw_Unsigned --\n-   -----------------------\n-\n-   function Scan_Raw_Unsigned\n-     (Str : String;\n-      Ptr : not null access Integer;\n-      Max : Integer) return Unsigned\n-   is\n-      P : Integer;\n-      --  Local copy of the pointer\n-\n-      Uval : Unsigned;\n-      --  Accumulated unsigned integer result\n-\n-      Expon : Integer;\n-      --  Exponent value\n-\n-      Overflow : Boolean := False;\n-      --  Set True if overflow is detected at any point\n-\n-      Base_Char : Character;\n-      --  Base character (# or :) in based case\n-\n-      Base : Unsigned := 10;\n-      --  Base value (reset in based case)\n-\n-      Digit : Unsigned;\n-      --  Digit value\n-\n-   begin\n-      --  We do not tolerate strings with Str'Last = Positive'Last\n-\n-      if Str'Last = Positive'Last then\n-         raise Program_Error with\n-           \"string upper bound is Positive'Last, not supported\";\n-      end if;\n-\n-      P := Ptr.all;\n-      Uval := Character'Pos (Str (P)) - Character'Pos ('0');\n-      P := P + 1;\n-\n-      --  Scan out digits of what is either the number or the base.\n-      --  In either case, we are definitely scanning out in base 10.\n-\n-      declare\n-         Umax : constant := (Unsigned'Last - 9) / 10;\n-         --  Max value which cannot overflow on accumulating next digit\n-\n-         Umax10 : constant := Unsigned'Last / 10;\n-         --  Numbers bigger than Umax10 overflow if multiplied by 10\n-\n-      begin\n-         --  Loop through decimal digits\n-         loop\n-            exit when P > Max;\n-\n-            Digit := Character'Pos (Str (P)) - Character'Pos ('0');\n-\n-            --  Non-digit encountered\n-\n-            if Digit > 9 then\n-               if Str (P) = '_' then\n-                  Scan_Underscore (Str, P, Ptr, Max, False);\n-               else\n-                  exit;\n-               end if;\n-\n-            --  Accumulate result, checking for overflow\n-\n-            else\n-               if Uval <= Umax then\n-                  Uval := 10 * Uval + Digit;\n-\n-               elsif Uval > Umax10 then\n-                  Overflow := True;\n-\n-               else\n-                  Uval := 10 * Uval + Digit;\n-\n-                  if Uval < Umax10 then\n-                     Overflow := True;\n-                  end if;\n-               end if;\n-\n-               P := P + 1;\n-            end if;\n-         end loop;\n-      end;\n-\n-      Ptr.all := P;\n-\n-      --  Deal with based case. We recognize either the standard '#' or the\n-      --  allowed alternative replacement ':' (see RM J.2(3)).\n-\n-      if P < Max and then (Str (P) = '#' or else Str (P) = ':') then\n-         Base_Char := Str (P);\n-         P := P + 1;\n-         Base := Uval;\n-         Uval := 0;\n-\n-         --  Check base value. Overflow is set True if we find a bad base, or\n-         --  a digit that is out of range of the base. That way, we scan out\n-         --  the numeral that is still syntactically correct, though illegal.\n-         --  We use a safe base of 16 for this scan, to avoid zero divide.\n-\n-         if Base not in 2 .. 16 then\n-            Overflow := True;\n-            Base := 16;\n-         end if;\n-\n-         --  Scan out based integer\n-\n-         declare\n-            Umax : constant Unsigned := (Unsigned'Last - Base + 1) / Base;\n-            --  Max value which cannot overflow on accumulating next digit\n-\n-            UmaxB : constant Unsigned := Unsigned'Last / Base;\n-            --  Numbers bigger than UmaxB overflow if multiplied by base\n-\n-         begin\n-            --  Loop to scan out based integer value\n-\n-            loop\n-               --  We require a digit at this stage\n-\n-               if Str (P) in '0' .. '9' then\n-                  Digit := Character'Pos (Str (P)) - Character'Pos ('0');\n-\n-               elsif Str (P) in 'A' .. 'F' then\n-                  Digit :=\n-                    Character'Pos (Str (P)) - (Character'Pos ('A') - 10);\n-\n-               elsif Str (P) in 'a' .. 'f' then\n-                  Digit :=\n-                    Character'Pos (Str (P)) - (Character'Pos ('a') - 10);\n-\n-               --  If we don't have a digit, then this is not a based number\n-               --  after all, so we use the value we scanned out as the base\n-               --  (now in Base), and the pointer to the base character was\n-               --  already stored in Ptr.all.\n-\n-               else\n-                  Uval := Base;\n-                  exit;\n-               end if;\n-\n-               --  If digit is too large, just signal overflow and continue.\n-               --  The idea here is to keep scanning as long as the input is\n-               --  syntactically valid, even if we have detected overflow\n-\n-               if Digit >= Base then\n-                  Overflow := True;\n-\n-               --  Here we accumulate the value, checking overflow\n-\n-               elsif Uval <= Umax then\n-                  Uval := Base * Uval + Digit;\n-\n-               elsif Uval > UmaxB then\n-                  Overflow := True;\n-\n-               else\n-                  Uval := Base * Uval + Digit;\n-\n-                  if Uval < UmaxB then\n-                     Overflow := True;\n-                  end if;\n-               end if;\n-\n-               --  If at end of string with no base char, not a based number\n-               --  but we signal Constraint_Error and set the pointer past\n-               --  the end of the field, since this is what the ACVC tests\n-               --  seem to require, see CE3704N, line 204.\n-\n-               P := P + 1;\n-\n-               if P > Max then\n-                  Ptr.all := P;\n-                  Bad_Value (Str);\n-               end if;\n-\n-               --  If terminating base character, we are done with loop\n-\n-               if Str (P) = Base_Char then\n-                  Ptr.all := P + 1;\n-                  exit;\n-\n-               --  Deal with underscore\n-\n-               elsif Str (P) = '_' then\n-                  Scan_Underscore (Str, P, Ptr, Max, True);\n-               end if;\n-\n-            end loop;\n-         end;\n-      end if;\n-\n-      --  Come here with scanned unsigned value in Uval. The only remaining\n-      --  required step is to deal with exponent if one is present.\n-\n-      Expon := Scan_Exponent (Str, Ptr, Max);\n-\n-      if Expon /= 0 and then Uval /= 0 then\n-\n-         --  For non-zero value, scale by exponent value. No need to do this\n-         --  efficiently, since use of exponent in integer literals is rare,\n-         --  and in any case the exponent cannot be very large.\n-\n-         declare\n-            UmaxB : constant Unsigned := Unsigned'Last / Base;\n-            --  Numbers bigger than UmaxB overflow if multiplied by base\n-\n-         begin\n-            for J in 1 .. Expon loop\n-               if Uval > UmaxB then\n-                  Overflow := True;\n-                  exit;\n-               end if;\n-\n-               Uval := Uval * Base;\n-            end loop;\n-         end;\n-      end if;\n-\n-      --  Return result, dealing with sign and overflow\n-\n-      if Overflow then\n-         Bad_Value (Str);\n-      else\n-         return Uval;\n-      end if;\n-   end Scan_Raw_Unsigned;\n-\n-   -------------------\n-   -- Scan_Unsigned --\n-   -------------------\n-\n-   function Scan_Unsigned\n-     (Str : String;\n-      Ptr : not null access Integer;\n-      Max : Integer) return Unsigned\n-   is\n-      Start : Positive;\n-      --  Save location of first non-blank character\n-\n-   begin\n-      Scan_Plus_Sign (Str, Ptr, Max, Start);\n-\n-      if Str (Ptr.all) not in '0' .. '9' then\n-         Ptr.all := Start;\n-         Bad_Value (Str);\n-      end if;\n-\n-      return Scan_Raw_Unsigned (Str, Ptr, Max);\n-   end Scan_Unsigned;\n-\n-   --------------------\n-   -- Value_Unsigned --\n-   --------------------\n-\n-   function Value_Unsigned (Str : String) return Unsigned is\n-   begin\n-      --  We have to special case Str'Last = Positive'Last because the normal\n-      --  circuit ends up setting P to Str'Last + 1 which is out of bounds. We\n-      --  deal with this by converting to a subtype which fixes the bounds.\n-\n-      if Str'Last = Positive'Last then\n-         declare\n-            subtype NT is String (1 .. Str'Length);\n-         begin\n-            return Value_Unsigned (NT (Str));\n-         end;\n-\n-      --  Normal case where Str'Last < Positive'Last\n-\n-      else\n-         declare\n-            V : Unsigned;\n-            P : aliased Integer := Str'First;\n-         begin\n-            V := Scan_Unsigned (Str, P'Access, Str'Last);\n-            Scan_Trailing_Blanks (Str, P);\n-            return V;\n-         end;\n-      end if;\n-   end Value_Unsigned;\n-\n-end System.Val_Uns;\n+pragma No_Body;"}, {"sha": "84b7a7d08c4bc62b3396898c3d1e781bd5c8bdca", "filename": "gcc/ada/libgnat/s-valuns.ads", "status": "modified", "additions": 11, "deletions": 79, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valuns.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-valuns.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuns.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -33,97 +33,29 @@\n --  values for use in Text_IO.Modular_IO, and the Value attribute.\n \n with System.Unsigned_Types;\n+with System.Value_U;\n \n package System.Val_Uns is\n    pragma Preelaborate;\n \n+   subtype Unsigned is Unsigned_Types.Unsigned;\n+\n+   package Impl is new Value_U (Unsigned);\n+\n    function Scan_Raw_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return System.Unsigned_Types.Unsigned;\n-   --  This function scans the string starting at Str (Ptr.all) for a valid\n-   --  integer according to the syntax described in (RM 3.5(43)). The substring\n-   --  scanned extends no further than Str (Max).  Note: this does not scan\n-   --  leading or trailing blanks, nor leading sign.\n-   --\n-   --  There are three cases for the return:\n-   --\n-   --  If a valid integer is found, then Ptr.all is updated past the last\n-   --  character of the integer.\n-   --\n-   --  If no valid integer is found, then Ptr.all points either to an initial\n-   --  non-digit character, or to Max + 1 if the field is all spaces and the\n-   --  exception Constraint_Error is raised.\n-   --\n-   --  If a syntactically valid integer is scanned, but the value is out of\n-   --  range, or, in the based case, the base value is out of range or there\n-   --  is an out of range digit, then Ptr.all points past the integer, and\n-   --  Constraint_Error is raised.\n-   --\n-   --  Note: these rules correspond to the requirements for leaving the pointer\n-   --  positioned in Text_IO.Get. Note that the rules as stated in the RM would\n-   --  seem to imply that for a case like:\n-   --\n-   --    8#12345670009#\n-   --\n-   --  the pointer should be left at the first # having scanned out the longest\n-   --  valid integer literal (8), but in fact in this case the pointer points\n-   --  past the final # and Constraint_Error is raised. This is the behavior\n-   --  expected for Text_IO and enforced by the ACATS tests.\n-   --\n-   --  If a based literal is malformed in that a character other than a valid\n-   --  hexadecimal digit is encountered during scanning out the digits after\n-   --  the # (this includes the case of using the wrong terminator, : instead\n-   --  of # or vice versa) there are two cases. If all the digits before the\n-   --  non-digit are in range of the base, as in\n-   --\n-   --    8#100x00#\n-   --    8#100:\n-   --\n-   --  then in this case, the \"base\" value before the initial # is returned as\n-   --  the result, and the pointer points to the initial # character on return.\n-   --\n-   --  If an out of range digit has been detected before the invalid character,\n-   --  as in:\n-   --\n-   --   8#900x00#\n-   --   8#900:\n-   --\n-   --  then the pointer is also left at the initial # character, but constraint\n-   --  error is raised reflecting the encounter of an out of range digit.\n-   --\n-   --  Finally if we have an unterminated fixed-point constant where the final\n-   --  # or : character is missing, Constraint_Error is raised and the pointer\n-   --  is left pointing past the last digit, as in:\n-   --\n-   --   8#22\n-   --\n-   --  This string results in a Constraint_Error with the pointer pointing\n-   --  past the second 2.\n-   --\n-   --  Note: if Str is empty, i.e. if Max is less than Ptr, then this is a\n-   --  special case of an all-blank string, and Ptr is unchanged, and hence\n-   --  is greater than Max as required in this case.\n-   --\n-   --  Note: this routine should not be called with Str'Last = Positive'Last.\n-   --  If this occurs Program_Error is raised with a message noting that this\n-   --  case is not supported. Most such cases are eliminated by the caller.\n+      Max : Integer) return Unsigned\n+     renames Impl.Scan_Raw_Unsigned;\n \n    function Scan_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return System.Unsigned_Types.Unsigned;\n-   --  Same as Scan_Raw_Unsigned, except scans optional leading\n-   --  blanks, and an optional leading plus sign.\n-   --\n-   --  Note: if a minus sign is present, Constraint_Error will be raised.\n-   --  Note: trailing blanks are not scanned.\n+      Max : Integer) return Unsigned\n+     renames Impl.Scan_Unsigned;\n \n    function Value_Unsigned\n-     (Str : String) return System.Unsigned_Types.Unsigned;\n-   --  Used in computing X'Value (Str) where X is a modular integer type whose\n-   --  modulus does not exceed the range of System.Unsigned_Types.Unsigned. Str\n-   --  is the string argument of the attribute. Constraint_Error is raised if\n-   --  the string is malformed, or if the value is out of range.\n+     (Str : String) return Unsigned\n+     renames Impl.Value_Unsigned;\n \n end System.Val_Uns;"}, {"sha": "630627755e0206dc4ca1abefb8e18f82fc6f212e", "filename": "gcc/ada/libgnat/s-widint.ads", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widint.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,41 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . W I D _ I N T                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Width attribute for signed integers up to Integer\n+\n+with System.Width_I;\n+\n+package System.Wid_Int is\n+\n+   function Width_Integer is new Width_I (Integer);\n+   pragma Pure_Function (Width_Integer);\n+\n+end System.Wid_Int;"}, {"sha": "65b1ab4617860b9e9de79a2603fb013cfe9a6f64", "filename": "gcc/ada/libgnat/s-widlli.adb", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widlli.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,45 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body System.Wid_LLI is\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-   -----------------------------\n-   -- Width_Long_Long_Integer --\n-   -----------------------------\n-\n-   function Width_Long_Long_Integer\n-     (Lo, Hi : Long_Long_Integer)\n-      return   Natural\n-   is\n-      W : Natural;\n-      T : Long_Long_Integer;\n-\n-   begin\n-      if Lo > Hi then\n-         return 0;\n-\n-      else\n-         --  Minimum value is 2, one for sign, one for digit\n-\n-         W := 2;\n-\n-         --  Get max of absolute values, but avoid bomb if we have the maximum\n-         --  negative number (note that First + 1 has same digits as First)\n-\n-         T := Long_Long_Integer'Max (\n-                abs (Long_Long_Integer'Max (Lo, Long_Long_Integer'First + 1)),\n-                abs (Long_Long_Integer'Max (Hi, Long_Long_Integer'First + 1)));\n-\n-         --  Increase value if more digits required\n-\n-         while T >= 10 loop\n-            T := T / 10;\n-            W := W + 1;\n-         end loop;\n-\n-         return W;\n-      end if;\n-\n-   end Width_Long_Long_Integer;\n-\n-end System.Wid_LLI;\n+pragma No_Body;"}, {"sha": "a67050ed0b84d94c12f08a31fcac61585e7c9cd3", "filename": "gcc/ada/libgnat/s-widlli.ads", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widlli.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,17 +29,13 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routine used for Width attribute for all\n---  non-static signed integer subtypes. Note we only have one routine,\n---  since this seems a fairly marginal function.\n+--  Width attribute for signed integers larger than Integer\n+\n+with System.Width_I;\n \n package System.Wid_LLI is\n-   pragma Pure;\n \n-   function Width_Long_Long_Integer\n-     (Lo, Hi : Long_Long_Integer)\n-      return   Natural;\n-   --  Compute Width attribute for non-static type derived from a signed\n-   --  Integer type. The arguments Lo, Hi are the bounds of the type.\n+   function Width_Long_Long_Integer is new Width_I (Long_Long_Integer);\n+   pragma Pure_Function (Width_Long_Long_Integer);\n \n end System.Wid_LLI;"}, {"sha": "80ab9d1e1128c4d3efa4f7db176c41bec992f881", "filename": "gcc/ada/libgnat/s-widllli.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widllli.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,42 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . W I D _ L L L I                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Width attribute for signed integers larger than Long_Long_Integer\n+\n+with System.Width_I;\n+\n+package System.Wid_LLLI is\n+\n+   function Width_Long_Long_Long_Integer is\n+     new Width_I (Long_Long_Long_Integer);\n+   pragma Pure_Function (Width_Long_Long_Long_Integer);\n+\n+end System.Wid_LLLI;"}, {"sha": "6f84837593fb8272ee59387e8b1b4f2ec11ec99c", "filename": "gcc/ada/libgnat/s-widlllu.ads", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widlllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widlllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widlllu.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,45 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . W I D _ L L L U                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Width attribute for modular integers larger than Long_Long_Integer\n+\n+with System.Width_U;\n+with System.Unsigned_Types;\n+\n+package System.Wid_LLLU is\n+\n+   subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n+\n+   function Width_Long_Long_Long_Unsigned is\n+     new Width_U (Long_Long_Long_Unsigned);\n+   pragma Pure_Function (Width_Long_Long_Long_Unsigned);\n+\n+end System.Wid_LLLU;"}, {"sha": "840f0a02e732412a67365d3435422b7f83ed65cb", "filename": "gcc/ada/libgnat/s-widllu.adb", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widllu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widllu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widllu.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,45 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Wid_LLU is\n-\n-   ------------------------------\n-   -- Width_Long_Long_Unsigned --\n-   ------------------------------\n-\n-   function Width_Long_Long_Unsigned\n-     (Lo, Hi : Long_Long_Unsigned)\n-      return   Natural\n-   is\n-      W : Natural;\n-      T : Long_Long_Unsigned;\n-\n-   begin\n-      if Lo > Hi then\n-         return 0;\n-\n-      else\n-         --  Minimum value is 2, one for sign, one for digit\n-\n-         W := 2;\n-\n-         --  Get max of absolute values, but avoid bomb if we have the maximum\n-         --  negative number (note that First + 1 has same digits as First)\n-\n-         T := Long_Long_Unsigned'Max (Lo, Hi);\n-\n-         --  Increase value if more digits required\n-\n-         while T >= 10 loop\n-            T := T / 10;\n-            W := W + 1;\n-         end loop;\n-\n-         return W;\n-      end if;\n-\n-   end Width_Long_Long_Unsigned;\n-\n-end System.Wid_LLU;\n+pragma No_Body;"}, {"sha": "e77eb554af368d0eb580b6387c3238c7f7a0aacb", "filename": "gcc/ada/libgnat/s-widllu.ads", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widllu.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -29,19 +29,16 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routine used for Width attribute for all\n---  non-static unsigned integer (modular integer) subtypes. Note we only\n---  have one routine, since this seems a fairly marginal function.\n+--  Width attribute for modular integers larger than Integer\n \n+with System.Width_U;\n with System.Unsigned_Types;\n \n package System.Wid_LLU is\n-   pragma Pure;\n \n-   function Width_Long_Long_Unsigned\n-     (Lo, Hi : System.Unsigned_Types.Long_Long_Unsigned)\n-      return   Natural;\n-   --  Compute Width attribute for non-static type derived from a modular\n-   --  integer type. The arguments Lo, Hi are the bounds of the type.\n+   subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n+\n+   function Width_Long_Long_Unsigned is new Width_U (Long_Long_Unsigned);\n+   pragma Pure_Function (Width_Long_Long_Unsigned);\n \n end System.Wid_LLU;"}, {"sha": "dee60681a2112ecfb5c2c4c4920353646b7500ca", "filename": "gcc/ada/libgnat/s-widthi.adb", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widthi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widthi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widthi.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,62 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . W I D T H _ I                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+function System.Width_I (Lo, Hi : Int) return Natural is\n+   W : Natural;\n+   T : Int;\n+\n+begin\n+   if Lo > Hi then\n+      return 0;\n+\n+   else\n+      --  Minimum value is 2, one for sign, one for digit\n+\n+      W := 2;\n+\n+      --  Get max of absolute values, but avoid bomb if we have the maximum\n+      --  negative number (note that First + 1 has same digits as First)\n+\n+      T := Int'Max (\n+             abs (Int'Max (Lo, Int'First + 1)),\n+             abs (Int'Max (Hi, Int'First + 1)));\n+\n+      --  Increase value if more digits required\n+\n+      while T >= 10 loop\n+         T := T / 10;\n+         W := W + 1;\n+      end loop;\n+\n+      return W;\n+   end if;\n+\n+end System.Width_I;"}, {"sha": "570ac2026510398abae048a94afa3a42b8d07429", "filename": "gcc/ada/libgnat/s-widthi.ads", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widthi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widthi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widthi.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,39 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . W I D T H _ I                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Compute Width attribute for non-static type derived from a signed integer\n+--  type. The arguments Lo, Hi are the bounds of the type.\n+\n+generic\n+\n+   type Int is range <>;\n+\n+function System.Width_I (Lo, Hi : Int) return Natural;"}, {"sha": "2469e30da51faab4dbb441f14538f3309e4c8af9", "filename": "gcc/ada/libgnat/s-widthu.adb", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widthu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widthu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widthu.adb?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . W I D T H _ U                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+function System.Width_U (Lo, Hi : Uns) return Natural is\n+   W : Natural;\n+   T : Uns;\n+\n+begin\n+   if Lo > Hi then\n+      return 0;\n+\n+   else\n+      --  Minimum value is 2, one for sign, one for digit\n+\n+      W := 2;\n+\n+      --  Get max of absolute values, but avoid bomb if we have the maximum\n+      --  negative number (note that First + 1 has same digits as First)\n+\n+      T := Uns'Max (Lo, Hi);\n+\n+      --  Increase value if more digits required\n+\n+      while T >= 10 loop\n+         T := T / 10;\n+         W := W + 1;\n+      end loop;\n+\n+      return W;\n+   end if;\n+\n+end System.Width_U;"}, {"sha": "28617381bb88f10758491be5c694a11243700949", "filename": "gcc/ada/libgnat/s-widthu.ads", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widthu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widthu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widthu.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,39 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . W I D T H _ U                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Compute Width attribute for non-static type derived from a modular integer\n+--  type. The arguments Lo, Hi are the bounds of the type.\n+\n+generic\n+\n+   type Uns is mod <>;\n+\n+function System.Width_U (Lo, Hi : Uns) return Natural;"}, {"sha": "d93d3e218da84ad85b810594634e18206334ab59", "filename": "gcc/ada/libgnat/s-widuns.ads", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widuns.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Flibgnat%2Fs-widuns.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widuns.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -0,0 +1,44 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . W I D _ U N S                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Width attribute for modular integers up to Integer\n+\n+with System.Width_U;\n+with System.Unsigned_Types;\n+\n+package System.Wid_Uns is\n+\n+   subtype Unsigned is Unsigned_Types.Unsigned;\n+\n+   function Width_Unsigned is new Width_U (Unsigned);\n+   pragma Pure_Function (Width_Unsigned);\n+\n+end System.Wid_Uns;"}, {"sha": "01f33a0e24616493376f13f8d3466003042b7354", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7584a41d9f565a90fc24c418b2c7f0233ba31e/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=cb7584a41d9f565a90fc24c418b2c7f0233ba31e", "patch": "@@ -258,7 +258,9 @@ package Rtsfind is\n       System_Img_Int,\n       System_Img_LLD,\n       System_Img_LLI,\n+      System_Img_LLLI,\n       System_Img_LLU,\n+      System_Img_LLLU,\n       System_Img_Name,\n       System_Img_Real,\n       System_Img_Uns,\n@@ -420,7 +422,9 @@ package Rtsfind is\n       System_Val_Int,\n       System_Val_LLD,\n       System_Val_LLI,\n+      System_Val_LLLI,\n       System_Val_LLU,\n+      System_Val_LLLU,\n       System_Val_Name,\n       System_Val_Real,\n       System_Val_Uns,\n@@ -431,9 +435,13 @@ package Rtsfind is\n       System_Wid_Bool,\n       System_Wid_Char,\n       System_Wid_Enum,\n+      System_Wid_Int,\n       System_Wid_LLI,\n+      System_Wid_LLLI,\n       System_Wid_LLU,\n+      System_Wid_LLLU,\n       System_Wid_Name,\n+      System_Wid_Uns,\n       System_Wid_WChar,\n       System_WWd_Char,\n       System_WWd_Enum,\n@@ -956,8 +964,12 @@ package Rtsfind is\n \n      RE_Image_Long_Long_Integer,         -- System.Img_LLI\n \n+     RE_Image_Long_Long_Long_Integer,    -- System.Img_LLLI\n+\n      RE_Image_Long_Long_Unsigned,        -- System.Img_LLU\n \n+     RE_Image_Long_Long_Long_Unsigned,   -- System.Img_LLLU\n+\n      RE_Image_Ordinary_Fixed_Point,      -- System.Img_Real\n      RE_Image_Floating_Point,            -- System.Img_Real\n \n@@ -1616,8 +1628,10 @@ package Rtsfind is\n \n      RE_Put_Image_Integer,               -- System.Put_Images\n      RE_Put_Image_Long_Long_Integer,     -- System.Put_Images\n+     RE_Put_Image_Long_Long_Long_Integer, -- System.Put_Images\n      RE_Put_Image_Unsigned,              -- System.Put_Images\n      RE_Put_Image_Long_Long_Unsigned,    -- System.Put_Images\n+     RE_Put_Image_Long_Long_Long_Unsigned, -- System.Put_Images\n      RE_Put_Image_Thin_Pointer,          -- System.Put_Images\n      RE_Put_Image_Fat_Pointer,           -- System.Put_Images\n      RE_Put_Image_Access_Subp,           -- System.Put_Images\n@@ -1965,6 +1979,7 @@ package Rtsfind is\n      RE_Bits_4,                          -- System.Unsigned_Types\n      RE_Float_Unsigned,                  -- System.Unsigned_Types\n      RE_Long_Long_Unsigned,              -- System.Unsigned_Types\n+     RE_Long_Long_Long_Unsigned,         -- System.Unsigned_Types\n      RE_Packed_Byte,                     -- System.Unsigned_Types\n      RE_Packed_Bytes1,                   -- System.Unsigned_Types\n      RE_Packed_Bytes2,                   -- System.Unsigned_Types\n@@ -1990,8 +2005,12 @@ package Rtsfind is\n \n      RE_Value_Long_Long_Integer,         -- System.Val_LLI\n \n+     RE_Value_Long_Long_Long_Integer,    -- System.Val_LLLI\n+\n      RE_Value_Long_Long_Unsigned,        -- System.Val_LLU\n \n+     RE_Value_Long_Long_Long_Unsigned,   -- System.Val_LLLU\n+\n      RE_Value_Real,                      -- System.Val_Real\n \n      RE_Value_Unsigned,                  -- System.Val_Uns\n@@ -2032,10 +2051,18 @@ package Rtsfind is\n      RE_Width_Enumeration_16,            -- System.Wid_Enum\n      RE_Width_Enumeration_32,            -- System.Wid_Enum\n \n+     RE_Width_Integer,                   -- System.Wid_Int\n+\n      RE_Width_Long_Long_Integer,         -- System.Wid_LLI\n \n+     RE_Width_Long_Long_Long_Integer,    -- System.Wid_LLLI\n+\n      RE_Width_Long_Long_Unsigned,        -- System.Wid_LLU\n \n+     RE_Width_Long_Long_Long_Unsigned,   -- System.Wid_LLLU\n+\n+     RE_Width_Unsigned,                  -- System.Wid_Uns\n+\n      RE_Width_Wide_Character,            -- System.Wid_WChar\n      RE_Width_Wide_Wide_Character,       -- System.Wid_WChar\n \n@@ -2592,8 +2619,12 @@ package Rtsfind is\n \n      RE_Image_Long_Long_Integer          => System_Img_LLI,\n \n+     RE_Image_Long_Long_Long_Integer     => System_Img_LLLI,\n+\n      RE_Image_Long_Long_Unsigned         => System_Img_LLU,\n \n+     RE_Image_Long_Long_Long_Unsigned    => System_Img_LLLU,\n+\n      RE_Image_Ordinary_Fixed_Point       => System_Img_Real,\n      RE_Image_Floating_Point             => System_Img_Real,\n \n@@ -3372,8 +3403,10 @@ package Rtsfind is\n \n      RE_Put_Image_Integer                => System_Put_Images,\n      RE_Put_Image_Long_Long_Integer      => System_Put_Images,\n+     RE_Put_Image_Long_Long_Long_Integer => System_Put_Images,\n      RE_Put_Image_Unsigned               => System_Put_Images,\n      RE_Put_Image_Long_Long_Unsigned     => System_Put_Images,\n+     RE_Put_Image_Long_Long_Long_Unsigned => System_Put_Images,\n      RE_Put_Image_Thin_Pointer           => System_Put_Images,\n      RE_Put_Image_Fat_Pointer            => System_Put_Images,\n      RE_Put_Image_Access_Subp            => System_Put_Images,\n@@ -3601,6 +3634,7 @@ package Rtsfind is\n      RE_Bits_4                           => System_Unsigned_Types,\n      RE_Float_Unsigned                   => System_Unsigned_Types,\n      RE_Long_Long_Unsigned               => System_Unsigned_Types,\n+     RE_Long_Long_Long_Unsigned          => System_Unsigned_Types,\n      RE_Packed_Byte                      => System_Unsigned_Types,\n      RE_Packed_Bytes1                    => System_Unsigned_Types,\n      RE_Packed_Bytes2                    => System_Unsigned_Types,\n@@ -3626,8 +3660,12 @@ package Rtsfind is\n \n      RE_Value_Long_Long_Integer          => System_Val_LLI,\n \n+     RE_Value_Long_Long_Long_Integer     => System_Val_LLLI,\n+\n      RE_Value_Long_Long_Unsigned         => System_Val_LLU,\n \n+     RE_Value_Long_Long_Long_Unsigned    => System_Val_LLLU,\n+\n      RE_Value_Real                       => System_Val_Real,\n \n      RE_Value_Unsigned                   => System_Val_Uns,\n@@ -3669,10 +3707,18 @@ package Rtsfind is\n      RE_Width_Enumeration_16             => System_Wid_Enum,\n      RE_Width_Enumeration_32             => System_Wid_Enum,\n \n+     RE_Width_Integer                    => System_Wid_Int,\n+\n      RE_Width_Long_Long_Integer          => System_Wid_LLI,\n \n+     RE_Width_Long_Long_Long_Integer     => System_Wid_LLLI,\n+\n      RE_Width_Long_Long_Unsigned         => System_Wid_LLU,\n \n+     RE_Width_Long_Long_Long_Unsigned    => System_Wid_LLLU,\n+\n+     RE_Width_Unsigned                   => System_Wid_Uns,\n+\n      RE_Width_Wide_Character             => System_Wid_WChar,\n      RE_Width_Wide_Wide_Character        => System_Wid_WChar,\n "}]}