{"sha": "a42cd965521407872308f03bea01f1bb5bd8303d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQyY2Q5NjU1MjE0MDc4NzIzMDhmMDNiZWEwMWYxYmI1YmQ4MzAzZA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1999-10-17T09:21:25Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-17T09:21:25Z"}, "message": "basic-block.h (pre_edge_lcm, [...]): Prototype for exported functions.\n\n        * basic-block.h (pre_edge_lcm, pre_edge_rev_lcm, compute_available):\n        Prototype for exported functions.\n        (pre_lcm, pre_rev_lcm): Remove prototypes.\n        * gcse.c (compute_ae_kill): Add ae_gen and ae_kill as parameters.\n        (compute_available): Move to lcm.c, and change parameter order.\n        (one_classic_gcse_pass): Call compute_ae_kill with parameters.\n        (pre_insert, s_preds, s_succs, num_preds, num_succs): Delete.\n        (gcse_main): No longer call compute_preds_succs.  Rebuild the\n        set table after reach pre pass.\n        (pre_insert_map, pre_delete_map, edge_list): New.\n        (alloc_pre_mem): Allocate edge vectors.\n        (free_pre_mem): Delete edge vectors.\n        (compute_pre_data): Call new edge based lcm routines.\n        (process_insert_insn): New function.\n        (insert_insn_end_bb): Use it.\n        (pre_edge_insert): New function.\n        (pre_insert_copy_insn): Formatting fixes.  Update BLOCK_END as\n        needed.\n        (pre_insert_copies): Revamp using new edge based lcm outputs.\n        (pre_delete): Likewise.\n        (one_pre_gcse_pass): Insert & remove fake edges to the exit\n        block.\n        (compute_code_hoist_vbeinout): New new edge based routines.\n        * lcm.c: Remove all the old LCM functions.  Replace with new ones\n        that work with the new cfg datastructures and work with edges\n        instead of blocks.\n\nFrom-SVN: r30055", "tree": {"sha": "a9c88cfc54dee85d6e21ed00bc01acd4ac483f1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9c88cfc54dee85d6e21ed00bc01acd4ac483f1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a42cd965521407872308f03bea01f1bb5bd8303d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42cd965521407872308f03bea01f1bb5bd8303d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a42cd965521407872308f03bea01f1bb5bd8303d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42cd965521407872308f03bea01f1bb5bd8303d/comments", "author": null, "committer": null, "parents": [{"sha": "3cce638b2b10ea1657b9d15f911dc4ff71ce64a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cce638b2b10ea1657b9d15f911dc4ff71ce64a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cce638b2b10ea1657b9d15f911dc4ff71ce64a8"}], "stats": {"total": 1373, "additions": 654, "deletions": 719}, "files": [{"sha": "de1764764c335801dc095877342ab5f2c74e33db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42cd965521407872308f03bea01f1bb5bd8303d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42cd965521407872308f03bea01f1bb5bd8303d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a42cd965521407872308f03bea01f1bb5bd8303d", "patch": "@@ -6,8 +6,23 @@ Sun Oct 17 02:09:50 1999  Andrew MacLeod  <amacleod@cygnus.com>\n \t* gcse.c (compute_ae_kill): Add ae_gen and ae_kill as parameters.\n \t(compute_available): Move to lcm.c, and change parameter order.\n \t(one_classic_gcse_pass): Call compute_ae_kill with parameters.\n-\t(pre_insert): Delete.\n-\t\n+\t(pre_insert, s_preds, s_succs, num_preds, num_succs): Delete.\n+\t(gcse_main): No longer call compute_preds_succs.  Rebuild the\n+\tset table after reach pre pass.\n+\t(pre_insert_map, pre_delete_map, edge_list): New.\n+\t(alloc_pre_mem): Allocate edge vectors.\n+\t(free_pre_mem): Delete edge vectors.\n+\t(compute_pre_data): Call new edge based lcm routines.\n+\t(process_insert_insn): New function.\n+\t(insert_insn_end_bb): Use it.\n+\t(pre_edge_insert): New function.\n+\t(pre_insert_copy_insn): Formatting fixes.  Update BLOCK_END as\n+\tneeded.\n+\t(pre_insert_copies): Revamp using new edge based lcm outputs.\n+\t(pre_delete): Likewise.\n+\t(one_pre_gcse_pass): Insert & remove fake edges to the exit\n+\tblock.\n+\t(compute_code_hoist_vbeinout): New new edge based routines.\n \t* lcm.c: Remove all the old LCM functions.  Replace with new ones\n \tthat work with the new cfg datastructures and work with edges\n \tinstead of blocks."}, {"sha": "693726c4678b051aafd844232a9f94d1ee88080b", "filename": "gcc/basic-block.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42cd965521407872308f03bea01f1bb5bd8303d/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42cd965521407872308f03bea01f1bb5bd8303d/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=a42cd965521407872308f03bea01f1bb5bd8303d", "patch": "@@ -310,11 +310,13 @@ extern void update_life_info\tPROTO ((sbitmap, enum update_life_extent));\n extern int count_or_remove_death_notes\tPROTO ((sbitmap, int));\n \n /* In lcm.c */\n-extern void pre_lcm \t\t\tPROTO ((int, int, int_list_ptr *,\n-\t\t\t\t\t\tint_list_ptr *,\n-\t\t\t\t\t\tsbitmap *, sbitmap *,\n-\t\t\t\t\t\tsbitmap *, sbitmap *));\n-extern void pre_rev_lcm \t\tPROTO ((int, int, int_list_ptr *,\n-\t\t\t\t\t\tint_list_ptr *,\n-\t\t\t\t\t\tsbitmap *, sbitmap *,\n+extern struct edge_list *pre_edge_lcm \tPROTO ((FILE *, int, sbitmap *,\n+\t\t\t\t\t\tsbitmap *, sbitmap *, \n+\t\t\t\t\t\tsbitmap *, sbitmap **,\n+\t\t\t\t\t\tsbitmap **));\n+extern struct edge_list *pre_edge_rev_lcm PROTO ((FILE *, int, sbitmap *,\n+\t\t\t\t\t\t  sbitmap *, sbitmap *, \n+\t\t\t\t\t\t  sbitmap *, sbitmap **, \n+\t\t\t\t\t\t  sbitmap **));\n+extern int compute_available\t\tPROTO ((sbitmap *, sbitmap *,\n \t\t\t\t\t\tsbitmap *, sbitmap *));"}, {"sha": "eb564c0826c49ba85d6c4e45aab035dca6c9b852", "filename": "gcc/gcse.c", "status": "modified", "additions": 167, "deletions": 132, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42cd965521407872308f03bea01f1bb5bd8303d/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42cd965521407872308f03bea01f1bb5bd8303d/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=a42cd965521407872308f03bea01f1bb5bd8303d", "patch": "@@ -126,6 +126,10 @@ Boston, MA 02111-1307, USA.  */\n    Steven Muchnick\n    Morgan Kaufmann, 1997\n \n+   Building an Optimizing Compiler\n+   Robert Morgan\n+   Digital Press, 1998\n+\n    People wishing to speed up the code here should read:\n      Elimination Algorithms for Data Flow Analysis\n      B.G. Ryder, M.C. Paull\n@@ -285,14 +289,6 @@ static FILE *gcse_file;\n \n static int run_jump_opt_after_gcse;\n \n-/* Element I is a list of I's predecessors/successors.  */\n-static int_list_ptr *s_preds;\n-static int_list_ptr *s_succs;\n-\n-/* Element I is the number of predecessors/successors of basic block I.  */\n-static int *num_preds;\n-static int *num_succs;\n-\n /* Bitmaps are normally not included in debugging dumps.\n    However it's useful to be able to print them from GDB.\n    We could create special functions for this, but it's simpler to\n@@ -591,7 +587,6 @@ static void compute_pre_data\t  PROTO ((void));\n static int pre_expr_reaches_here_p    PROTO ((int, struct expr *,\n \t\t\t\t\t      int, int, char *));\n static void insert_insn_end_bb\tPROTO ((struct expr *, int, int));\n-static void pre_insert\t\tPROTO ((struct expr **));\n static void pre_insert_copy_insn      PROTO ((struct expr *, rtx));\n static void pre_insert_copies\t PROTO ((void));\n static int pre_delete\t\t PROTO ((void));\n@@ -617,8 +612,7 @@ static void alloc_avail_expr_mem      PROTO ((int, int));\n static void free_avail_expr_mem       PROTO ((void));\n static void compute_ae_gen\t    PROTO ((void));\n static int expr_killed_p\t      PROTO ((rtx, int));\n-static void compute_ae_kill\t   PROTO ((void));\n-static void compute_available\t PROTO ((void));\n+static void compute_ae_kill\t   PROTO ((sbitmap *, sbitmap *));\n static int expr_reaches_here_p\tPROTO ((struct occr *, struct expr *,\n \t\t\t\t\t      int, int, char *));\n static rtx computing_insn\t     PROTO ((struct expr *, rtx));\n@@ -664,6 +658,9 @@ gcse_main (f, file)\n   max_gcse_regno = max_reg_num ();\n   find_basic_blocks (f, max_gcse_regno, file, 1);\n \n+  if (file)\n+    dump_flow_info (file);\n+\n   /* Return if there's nothing to do.  */\n   if (n_basic_blocks <= 1)\n     {\n@@ -695,18 +692,7 @@ gcse_main (f, file)\n     }\n \n   gcc_obstack_init (&gcse_obstack);\n-\n-  /* Allocate and compute predecessors/successors.  */\n-\n-  s_preds = (int_list_ptr *) alloca (n_basic_blocks * sizeof (int_list_ptr));\n-  s_succs = (int_list_ptr *) alloca (n_basic_blocks * sizeof (int_list_ptr));\n-  num_preds = (int *) alloca (n_basic_blocks * sizeof (int));\n-  num_succs = (int *) alloca (n_basic_blocks * sizeof (int));\n-  bytes_used = 4 * n_basic_blocks * sizeof (int_list_ptr);\n-  compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n-\n-  if (file)\n-    dump_bb_data (file, s_preds, s_succs, 0);\n+  bytes_used = 0;\n \n   /* Record where pseudo-registers are set.\n      This data is kept accurate during each pass.\n@@ -748,7 +734,13 @@ gcse_main (f, file)\n       if (optimize_size)\n \tchanged |= one_classic_gcse_pass (pass + 1);\n       else\n-\tchanged |= one_pre_gcse_pass (pass + 1);\n+        {\n+\t  changed |= one_pre_gcse_pass (pass + 1);\n+\t  free_reg_set_mem ();\n+\t  alloc_reg_set_mem (max_reg_num ());\n+\t  compute_sets (f);\n+\t  run_jump_opt_after_gcse = 1;\n+\t}\n \n       if (max_pass_bytes < bytes_used)\n \tmax_pass_bytes = bytes_used;\n@@ -2846,7 +2838,8 @@ expr_killed_p (x, bb)\n /* Compute the set of available expressions killed in each basic block.  */\n \n static void\n-compute_ae_kill ()\n+compute_ae_kill (ae_gen, ae_kill)\n+     sbitmap *ae_gen, *ae_kill;\n {\n   int bb,i;\n \n@@ -2868,41 +2861,6 @@ compute_ae_kill ()\n \t}\n     }\n }\n-\n-/* Compute available expressions.\n-\n-   Implement the algorithm to find available expressions\n-   as given in the Aho Sethi Ullman book, pages 627-631.  */\n-\n-static void\n-compute_available ()\n-{\n-  int bb, changed, passes;\n-\n-  sbitmap_zero (ae_in[0]);\n-\n-  sbitmap_copy (ae_out[0] /*dst*/, ae_gen[0] /*src*/);\n-\n-  for (bb = 1; bb < n_basic_blocks; bb++)\n-    sbitmap_difference (ae_out[bb], u_bitmap, ae_kill[bb]);\n-    \n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n-    {\n-      changed = 0;\n-      for (bb = 1; bb < n_basic_blocks; bb++)\n-\t{\n-\t  sbitmap_intersection_of_preds (ae_in[bb], ae_out, bb);\n-\t  changed |= sbitmap_union_of_diff (ae_out[bb], ae_gen[bb],\n-\t\t\t\t\t    ae_in[bb], ae_kill[bb]);\n-\t}\n-      passes++;\n-    }\n-\n-  if (gcse_file)\n-    fprintf (gcse_file, \"avail expr computation: %d passes\\n\", passes);\n-}\n \f\n /* Actually perform the Classic GCSE optimizations.  */\n \n@@ -3364,12 +3322,15 @@ one_classic_gcse_pass (pass)\n \t\t     expr_hash_table_size, n_exprs);\n   if (n_exprs > 0)\n     {\n+      int passes;\n       compute_kill_rd ();\n       compute_rd ();\n       alloc_avail_expr_mem (n_basic_blocks, n_exprs);\n       compute_ae_gen ();\n-      compute_ae_kill ();\n-      compute_available ();\n+      compute_ae_kill (ae_gen, ae_kill);\n+      passes = compute_available (ae_gen, ae_kill, ae_out, ae_in);\n+      if (gcse_file)\n+\tfprintf (gcse_file, \"avail expr computation: %d passes\\n\", passes);\n       changed = classic_gcse ();\n       free_avail_expr_mem ();\n     }\n@@ -4111,6 +4072,15 @@ static sbitmap *pre_optimal;\n /* Nonzero for expressions which are redundant in a particular block.  */\n static sbitmap *pre_redundant;\n \n+/* Nonzero for expressions which should be inserted on a specific edge.  */\n+static sbitmap *pre_insert_map;\n+\n+/* Nonzero for expressions which should be deleted in a specific block.  */\n+static sbitmap *pre_delete_map;\n+\n+/* Contains the edge_list returned by pre_edge_lcm.  */\n+static struct edge_list *edge_list;\n+\n static sbitmap *temp_bitmap;\n \n /* Redundant insns.  */\n@@ -4127,9 +4097,16 @@ alloc_pre_mem (n_blocks, n_exprs)\n   antloc = sbitmap_vector_alloc (n_blocks, n_exprs);\n \n   temp_bitmap = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  pre_optimal = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  pre_redundant = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  pre_optimal = NULL;\n+  pre_redundant = NULL;\n+  pre_insert_map = NULL;\n+  pre_delete_map = NULL;\n+  ae_in = NULL;\n+  ae_out = NULL;\n+  u_bitmap = NULL;\n   transpout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  ae_kill = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  /* pre_insert and pre_delete are allocated later.  */\n }\n \n /* Free vars used for PRE analysis.  */\n@@ -4141,10 +4118,31 @@ free_pre_mem ()\n   free (comp);\n   free (antloc);\n \n-  free (temp_bitmap);\n-  free (pre_optimal);\n-  free (pre_redundant);\n-  free (transpout);\n+  if (pre_optimal)\n+    free (pre_optimal);\n+  if (pre_redundant)\n+    free (pre_redundant);\n+  if (pre_insert_map)\n+    free (pre_insert_map);\n+  if (pre_delete_map)\n+    free (pre_delete_map);\n+  if (transpout)\n+    free (transpout);\n+\n+  if (ae_in)\n+    free (ae_in);\n+  if (ae_out)\n+    free (ae_out);\n+  if (ae_kill)\n+    free (ae_kill);\n+  if (u_bitmap)\n+    free (u_bitmap);\n+\n+  transp = comp = antloc = NULL;\n+  pre_optimal = pre_redundant = pre_insert_map = pre_delete_map = NULL;\n+  transpout = ae_in = ae_out = ae_kill = NULL;\n+  u_bitmap = NULL;\n+\n }\n \n /* Top level routine to do the dataflow analysis needed by PRE.  */\n@@ -4154,8 +4152,10 @@ compute_pre_data ()\n {\n   compute_local_properties (transp, comp, antloc, 0);\n   compute_transpout ();\n-  pre_lcm (n_basic_blocks, n_exprs, s_preds, s_succs, transp,\n-\t   antloc, pre_redundant, pre_optimal);\n+  sbitmap_vector_zero (ae_kill, n_basic_blocks);\n+  compute_ae_kill (comp, ae_kill);\n+  edge_list = pre_edge_lcm (gcse_file, n_exprs, transp, comp, antloc,\n+\t\t\t    ae_kill, &pre_insert_map, &pre_delete_map);\n }\n \n \f\n@@ -4231,6 +4231,29 @@ pre_expr_reaches_here_p (occr_bb, expr, bb, check_pre_comp, visited)\n   return 0;\n }\n \f\n+\n+/* Given an expr, generate RTL which we can insert at the end of a BB,\n+   or on an edge.  Set the block number of any insns generated to \n+   the value of BB.  */\n+\n+static rtx\n+process_insert_insn (expr)\n+     struct expr *expr;\n+{\n+  rtx reg = expr->reaching_reg;\n+  rtx pat, copied_expr;\n+  rtx first_new_insn;\n+\n+  start_sequence ();\n+  copied_expr = copy_rtx (expr->expr);\n+  emit_move_insn (reg, copied_expr);\n+  first_new_insn = get_insns ();\n+  pat = gen_sequence ();\n+  end_sequence ();\n+\n+  return pat;\n+}\n+  \n /* Add EXPR to the end of basic block BB.\n \n    This is used by both the PRE and code hoisting.\n@@ -4249,15 +4272,9 @@ insert_insn_end_bb (expr, bb, pre)\n   rtx new_insn;\n   rtx reg = expr->reaching_reg;\n   int regno = REGNO (reg);\n-  rtx pat, copied_expr;\n-  rtx first_new_insn;\n+  rtx pat;\n \n-  start_sequence ();\n-  copied_expr = copy_rtx (expr->expr);\n-  emit_move_insn (reg, copied_expr);\n-  first_new_insn = get_insns ();\n-  pat = gen_sequence ();\n-  end_sequence ();\n+  pat = process_insert_insn (expr);\n \n   /* If the last insn is a jump, insert EXPR in front [taking care to\n      handle cc0, etc. properly].  */\n@@ -4407,37 +4424,34 @@ insert_insn_end_bb (expr, bb, pre)\n     }\n }\n \n-/* Insert partially redundant expressions at the ends of appropriate basic\n-   blocks making them fully redundant.  */\n+/* Insert partially redundant expressions on edges in the CFG to make\n+   the expressions fully redundant.  */\n \n-static void\n-pre_insert (index_map)\n+static int\n+pre_edge_insert (edge_list, index_map)\n+     struct edge_list *edge_list;\n      struct expr **index_map;\n {\n-  int bb, i, set_size;\n+  int e, i, num_edges, set_size, did_insert = 0;\n   sbitmap *inserted;\n \n-  /* Compute INSERT = PRE_OPTIMAL & ~PRE_REDUNDANT. \n-     Where INSERT is nonzero, we add the expression at the end of the basic\n-     block if it reaches any of the deleted expressions.  */\n+  /* Where PRE_INSERT_MAP is nonzero, we add the expression on that edge\n+     if it reaches any of the deleted expressions.  */\n \n-  set_size = pre_optimal[0]->size;\n-  inserted = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n-  sbitmap_vector_zero (inserted, n_basic_blocks);\n+  set_size = pre_insert_map[0]->size;\n+  num_edges = NUM_EDGES (edge_list);\n+  inserted = sbitmap_vector_alloc (num_edges, n_exprs);\n+  sbitmap_vector_zero (inserted, num_edges);\n \n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  for (e = 0; e < num_edges; e++)\n     {\n       int indx;\n+      basic_block pred = INDEX_EDGE_PRED_BB (edge_list, e);\n+      int bb = pred->index;\n \n-      /* This computes the number of potential insertions we need.  */\n-      sbitmap_not (temp_bitmap[bb], pre_redundant[bb]);\n-      sbitmap_a_and_b (temp_bitmap[bb], temp_bitmap[bb], pre_optimal[bb]);\n-\n-      /* TEMP_BITMAP[bb] now contains a bitmap of the expressions that we need\n-\t to insert at the end of this basic block.  */\n       for (i = indx = 0; i < set_size; i++, indx += SBITMAP_ELT_BITS)\n \t{\n-\t  SBITMAP_ELT_TYPE insert = temp_bitmap[bb]->elms[i];\n+\t  SBITMAP_ELT_TYPE insert = pre_insert_map[e]->elms[i];\n \t  int j;\n \n \t  for (j = indx; insert && j < n_exprs; j++, insert >>= 1)\n@@ -4453,23 +4467,49 @@ pre_insert (index_map)\n \t\t      if (! occr->deleted_p)\n \t\t\tcontinue;\n \n-\t\t      /* Insert this expression at the end of BB if it would\n-\t\t\t reach the deleted occurence.  */\n-\t\t      if (!TEST_BIT (inserted[bb], j)\n-\t\t\t  && pre_expr_reaches_here_p (bb, expr,\n+\t\t      /* Insert this expression on this edge if if it would\n+\t\t\t reach the deleted occurence in BB.  */\n+\t\t      if (!TEST_BIT (inserted[e], j)\n+\t\t\t  && (bb == ENTRY_BLOCK \n+\t\t\t      || pre_expr_reaches_here_p (bb, expr,\n \t\t\t\t\t\t   BLOCK_NUM (occr->insn), 0,\n-\t\t\t\t\t\t   NULL))\n+\t\t\t\t\t\t   NULL)))\n \t\t\t{\n-\t\t\t  SET_BIT (inserted[bb], j);\n-\t\t\t  insert_insn_end_bb (index_map[j], bb, 1);\n+\t\t\t  rtx insn;\n+\t\t\t  edge eg = INDEX_EDGE (edge_list, e);\n+\t\t\t  /* We can't insert anything on an abnormal \n+\t\t\t     and critical edge, so we insert the\n+\t\t\t     insn at the end of the previous block. There\n+\t\t\t     are several alternatives detailed in \n+\t\t\t     Morgans book P277 (sec 10.5) for handling \n+\t\t\t     this situation.  This one is easiest for now.  */\n+\n+\t\t\t  if ((eg->flags & EDGE_ABNORMAL) == EDGE_ABNORMAL)\n+\t\t\t    {\n+\t\t\t      insert_insn_end_bb (index_map[j], bb, 0);\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      insn = process_insert_insn (index_map[j]);\n+\t\t\t      insert_insn_on_edge (insn, eg);\n+\t\t\t    }\n+\t\t\t  if (gcse_file)\n+\t\t\t    {\n+\t\t\t      fprintf (gcse_file,\n+\t\t\t\t       \"PRE/HOIST: edge (%d,%d), copy expression %d\\n\",\n+\t\t\t\t        bb,\n+\t\t\t\t\tINDEX_EDGE_SUCC_BB (edge_list, e)->index, expr->bitmap_index);\n+\t\t\t    }\n+\t\t\t  SET_BIT (inserted[e], j);\n+\t\t\t  did_insert = 1;\n+\t\t\t  gcse_create_count++;\n \t\t\t}\n \t\t    }\n \t\t}\n \t    }\n \t}\n     }\n-\n-  sbitmap_vector_free (inserted);\n+  return did_insert;\n }\n \n /* Copy the result of INSN to REG.\n@@ -4485,23 +4525,26 @@ pre_insert_copy_insn (expr, insn)\n   int indx = expr->bitmap_index;\n   rtx set = single_set (insn);\n   rtx new_insn;\n+  int bb = BLOCK_NUM (insn);\n \n   if (!set)\n     abort ();\n   new_insn = emit_insn_after (gen_rtx_SET (VOIDmode, reg, SET_DEST (set)),\n \t\t\t      insn);\n   /* Keep block number table up to date.  */\n-  set_block_num (new_insn, BLOCK_NUM (insn));\n+  set_block_num (new_insn, bb);\n   /* Keep register set table up to date.  */\n   record_one_set (regno, new_insn);\n+  if (insn == BLOCK_END (bb))\n+    BLOCK_END (bb) = new_insn;\n \n   gcse_create_count++;\n \n   if (gcse_file)\n-    {\n-      fprintf (gcse_file, \"PRE: bb %d, insn %d, copying expression %d in insn %d to reg %d\\n\",\n-\t       BLOCK_NUM (insn), INSN_UID (new_insn), indx, INSN_UID (insn), regno);\n-    }\n+    fprintf (gcse_file,\n+\t     \"PRE: bb %d, insn %d, copy expression %d in insn %d to reg %d\\n\",\n+\t      BLOCK_NUM (insn), INSN_UID (new_insn), indx,\n+\t      INSN_UID (insn), regno);\n }\n \n /* Copy available expressions that reach the redundant expression\n@@ -4512,11 +4555,6 @@ pre_insert_copies ()\n {\n   int i, bb;\n \n-  for (bb = 0; bb < n_basic_blocks; bb++)\n-    {\n-      sbitmap_a_and_b (temp_bitmap[bb], pre_optimal[bb], pre_redundant[bb]);\n-    }\n-\n   /* For each available expression in the table, copy the result to\n      `reaching_reg' if the expression reaches a deleted one.\n \n@@ -4550,10 +4588,6 @@ pre_insert_copies ()\n \t      for (avail = expr->avail_occr; avail != NULL; avail = avail->next)\n \t\t{\n \t\t  rtx insn = avail->insn;\n-\t\t  int bb = BLOCK_NUM (insn);\n-\n-\t\t  if (!TEST_BIT (temp_bitmap[bb], expr->bitmap_index))\n-\t\t    continue;\n \n \t\t  /* No need to handle this one if handled already.  */\n \t\t  if (avail->copied_p)\n@@ -4591,10 +4625,7 @@ pre_delete ()\n   /* Compute the expressions which are redundant and need to be replaced by\n      copies from the reaching reg to the target reg.  */\n   for (bb = 0; bb < n_basic_blocks; bb++)\n-    {\n-      sbitmap_not (temp_bitmap[bb], pre_optimal[bb]);\n-      sbitmap_a_and_b (temp_bitmap[bb], temp_bitmap[bb], pre_redundant[bb]);\n-    }\n+    sbitmap_copy (temp_bitmap[bb], pre_delete_map[bb]);\n \n   changed = 0;\n   for (i = 0; i < expr_hash_table_size; i++)\n@@ -4681,7 +4712,7 @@ pre_delete ()\n static int\n pre_gcse ()\n {\n-  int i;\n+  int i, did_insert;\n   int changed;\n   struct expr **index_map;\n \n@@ -4708,13 +4739,15 @@ pre_gcse ()\n      - we know which insns are redundant when we go to create copies  */\n   changed = pre_delete ();\n \n-  /* Insert insns in places that make partially redundant expressions\n-     fully redundant.  */\n-  pre_insert (index_map);\n-\n+  did_insert = pre_edge_insert (edge_list, index_map);\n   /* In other places with reaching expressions, copy the expression to the\n-     specially allocated pseudo-reg that reaches the redundant expression.  */\n+     specially allocated pseudo-reg that reaches the redundant expr.  */\n   pre_insert_copies ();\n+  if (did_insert)\n+    {\n+      commit_edge_insertions ();\n+      changed = 1;\n+    }\n \n   free (pre_redundant_insns);\n \n@@ -4735,6 +4768,7 @@ one_pre_gcse_pass (pass)\n   gcse_create_count = 0;\n \n   alloc_expr_hash_table (max_cuid);\n+  add_noreturn_fake_exit_edges ();\n   compute_expr_hash_table ();\n   if (gcse_file)\n     dump_hash_table (gcse_file, \"Expression\", expr_hash_table,\n@@ -4744,8 +4778,10 @@ one_pre_gcse_pass (pass)\n       alloc_pre_mem (n_basic_blocks, n_exprs);\n       compute_pre_data ();\n       changed |= pre_gcse ();\n+      free_edge_list (edge_list);\n       free_pre_mem ();\n     }\n+  remove_fake_edges ();\n   free_expr_hash_table ();\n \n   if (gcse_file)\n@@ -5194,8 +5230,7 @@ compute_code_hoist_vbeinout ()\n \t  changed |= sbitmap_a_or_b_and_c (hoist_vbein[bb], antloc[bb],\n \t\t\t\t\t   hoist_vbeout[bb], transp[bb]);\n \t  if (bb != n_basic_blocks - 1)\n-\t    sbitmap_intersect_of_successors (hoist_vbeout[bb], hoist_vbein,\n-\t\t\t\t\t     bb, s_succs);\n+\t    sbitmap_intersection_of_succs (hoist_vbeout[bb], hoist_vbein, bb);\n \t}\n       passes++;\n     }"}, {"sha": "c0e272107bb9967eb6520311841e510ca36e8a49", "filename": "gcc/lcm.c", "status": "modified", "additions": 461, "deletions": 578, "changes": 1039, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42cd965521407872308f03bea01f1bb5bd8303d/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42cd965521407872308f03bea01f1bb5bd8303d/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=a42cd965521407872308f03bea01f1bb5bd8303d", "patch": "@@ -62,214 +62,51 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"basic-block.h\"\n \n-static void compute_antinout \tPROTO ((int, int_list_ptr *, sbitmap *,\n-\t\t\t\t\tsbitmap *, sbitmap *, sbitmap *));\n-static void compute_earlyinout\tPROTO ((int, int, int_list_ptr *, sbitmap *,\n-\t\t\t\t\tsbitmap *, sbitmap *, sbitmap *));\n-static void compute_delayinout  PROTO ((int, int, int_list_ptr *, sbitmap *,\n-\t\t\t\t\tsbitmap *, sbitmap *,\n-\t\t\t\t\tsbitmap *, sbitmap *));\n-static void compute_latein\tPROTO ((int, int, int_list_ptr *, sbitmap *,\n-\t\t\t\t\tsbitmap *, sbitmap *));\n-static void compute_isoinout\tPROTO ((int, int_list_ptr *, sbitmap *,\n-\t\t\t\t\tsbitmap *, sbitmap *, sbitmap *));\n-static void compute_optimal\tPROTO ((int, sbitmap *,\n-\t\t\t\t\tsbitmap *, sbitmap *));\n-static void compute_redundant\tPROTO ((int, int, sbitmap *,\n-\t\t\t\t\tsbitmap *, sbitmap *, sbitmap *));\n-\n-/* Similarly, but for the reversed flowgraph.  */\n-static void compute_avinout \tPROTO ((int, int_list_ptr *, sbitmap *,\n-\t\t\t\t\tsbitmap *, sbitmap *, sbitmap *));\n-static void compute_fartherinout\tPROTO ((int, int, int_list_ptr *,\n-\t\t\t\t\t\tsbitmap *, sbitmap *,\n-\t\t\t\t\t\tsbitmap *, sbitmap *));\n-static void compute_earlierinout  PROTO ((int, int, int_list_ptr *, sbitmap *,\n-\t\t\t\t\t  sbitmap *, sbitmap *,\n-\t\t\t\t\t  sbitmap *, sbitmap *));\n-static void compute_firstout\tPROTO ((int, int, int_list_ptr *, sbitmap *,\n-\t\t\t\t\tsbitmap *, sbitmap *));\n-static void compute_rev_isoinout PROTO ((int, int_list_ptr *, sbitmap *,\n-\t\t\t\t\t sbitmap *, sbitmap *, sbitmap *));\n-\n-/* Given local properties TRANSP, ANTLOC, return the redundant and optimal\n-   computation points for expressions.\n-\n-   To reduce overall memory consumption, we allocate memory immediately\n-   before its needed and deallocate it as soon as possible.  */\n-void\n-pre_lcm (n_blocks, n_exprs, s_preds, s_succs, transp,\n-\t antloc, redundant, optimal)\n-     int n_blocks;\n-     int n_exprs;\n-     int_list_ptr *s_preds;\n-     int_list_ptr *s_succs;\n-     sbitmap *transp;\n-     sbitmap *antloc;\n-     sbitmap *redundant;\n-     sbitmap *optimal;\n-{\n-  sbitmap *antin, *antout, *earlyin, *earlyout, *delayin, *delayout;\n-  sbitmap *latein, *isoin, *isoout;\n-\n-  /* Compute global anticipatability.  ANTOUT is not needed except to\n-     compute ANTIN, so free its memory as soon as we return from\n-     compute_antinout.  */\n-  antin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  antout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  compute_antinout (n_blocks, s_succs, antloc,\n-\t\t    transp, antin, antout);\n-  free (antout);\n-  antout = NULL;\n-\n-  /* Compute earliestness.  EARLYOUT is not needed except to compute\n-     EARLYIN, so free its memory as soon as we return from\n-     compute_earlyinout.  */\n-  earlyin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  earlyout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  compute_earlyinout (n_blocks, n_exprs, s_preds, transp, antin,\n-\t\t      earlyin, earlyout);\n-  free (earlyout);\n-  earlyout = NULL;\n-\n-  /* Compute delayedness.  DELAYOUT is not needed except to compute\n-     DELAYIN, so free its memory as soon as we return from\n-     compute_delayinout.  We also no longer need ANTIN and EARLYIN.  */\n-  delayin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  delayout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  compute_delayinout (n_blocks, n_exprs, s_preds, antloc,\n-\t\t      antin, earlyin, delayin, delayout);\n-  free (delayout);\n-  delayout = NULL;\n-  free (antin);\n-  antin = NULL;\n-  free (earlyin);\n-  earlyin = NULL;\n-\n-  /* Compute latestness.  We no longer need DELAYIN after we compute\n-     LATEIN.  */\n-  latein = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  compute_latein (n_blocks, n_exprs, s_succs, antloc, delayin, latein);\n-  free (delayin);\n-  delayin = NULL;\n-\n-  /* Compute isolatedness.  ISOIN is not needed except to compute\n-     ISOOUT, so free its memory as soon as we return from\n-     compute_isoinout.  */\n-  isoin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  isoout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  compute_isoinout (n_blocks, s_succs, antloc, latein, isoin, isoout);\n-  free (isoin);\n-  isoin = NULL;\n-\n-  /* Now compute optimal placement points and the redundant expressions.  */\n-  compute_optimal (n_blocks, latein, isoout, optimal);\n-  compute_redundant (n_blocks, n_exprs, antloc, latein, isoout, redundant);\n-  free (latein);\n-  latein = NULL;\n-  free (isoout);\n-  isoout = NULL;\n-}\n-\n-/* Given local properties TRANSP, AVLOC, return the redundant and optimal\n-   computation points for expressions on the reverse flowgraph.\n-\n-   To reduce overall memory consumption, we allocate memory immediately\n-   before its needed and deallocate it as soon as possible.  */\n-\n-void\n-pre_rev_lcm (n_blocks, n_exprs, s_preds, s_succs, transp,\n-\t     avloc, redundant, optimal)\n-     int n_blocks;\n-     int n_exprs;\n-     int_list_ptr *s_preds;\n-     int_list_ptr *s_succs;\n-     sbitmap *transp;\n-     sbitmap *avloc;\n-     sbitmap *redundant;\n-     sbitmap *optimal;\n-{\n-  sbitmap *avin, *avout, *fartherin, *fartherout, *earlierin, *earlierout;\n-  sbitmap *firstout, *rev_isoin, *rev_isoout;\n-\n-  /* Compute global availability.  AVIN is not needed except to\n-     compute AVOUT, so free its memory as soon as we return from\n-     compute_avinout.  */\n-  avin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  avout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  compute_avinout (n_blocks, s_preds, avloc, transp, avin, avout);\n-  free (avin);\n-  avin = NULL;\n-\n-  /* Compute fartherness.  FARTHERIN is not needed except to compute\n-     FARTHEROUT, so free its memory as soon as we return from\n-     compute_earlyinout.  */\n-  fartherin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  fartherout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  compute_fartherinout (n_blocks, n_exprs, s_succs, transp,\n-\t\t\tavout, fartherin, fartherout);\n-  free (fartherin);\n-  fartherin = NULL;\n-\n-  /* Compute earlierness.  EARLIERIN is not needed except to compute\n-     EARLIEROUT, so free its memory as soon as we return from\n-     compute_delayinout.  We also no longer need AVOUT and FARTHEROUT.  */\n-  earlierin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  earlierout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  compute_earlierinout (n_blocks, n_exprs, s_succs, avloc,\n-\t\t        avout, fartherout, earlierin, earlierout);\n-  free (earlierin);\n-  earlierin = NULL;\n-  free (avout);\n-  avout = NULL;\n-  free (fartherout);\n-  fartherout = NULL;\n-\n-  /* Compute firstness.  We no longer need EARLIEROUT after we compute\n-     FIRSTOUT.  */\n-  firstout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  compute_firstout (n_blocks, n_exprs, s_preds, avloc, earlierout, firstout);\n-  free (earlierout);\n-  earlierout = NULL;\n-\n-  /* Compute rev_isolatedness.  ISOIN is not needed except to compute\n-     ISOOUT, so free its memory as soon as we return from\n-     compute_isoinout.  */\n-  rev_isoin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  rev_isoout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  compute_rev_isoinout (n_blocks, s_preds, avloc, firstout,\n-\t\t\trev_isoin, rev_isoout);\n-  free (rev_isoout);\n-  rev_isoout = NULL;\n-\n-  /* Now compute optimal placement points and the redundant expressions.  */\n-  compute_optimal (n_blocks, firstout, rev_isoin, optimal);\n-  compute_redundant (n_blocks, n_exprs, avloc, firstout, rev_isoin, redundant);\n-  free (firstout);\n-  firstout = NULL;\n-  free (rev_isoin);\n-  rev_isoin = NULL;\n-}\n-\n-/* Compute expression anticipatability at entrance and exit of each block.  */\n+/* Edge based LCM routines.  */\n+static void compute_antinout_edge  PROTO ((sbitmap *, sbitmap *,\n+\t\t\t\t\t   sbitmap *, sbitmap *));\n+static void compute_earliest  PROTO((struct edge_list *, int, sbitmap *,\n+\t\t\t\t     sbitmap *, sbitmap *, sbitmap *,\n+\t\t\t\t     sbitmap *));\n+static void compute_laterin  PROTO((struct edge_list *, int, sbitmap *,\n+\t\t\t\t     sbitmap *, sbitmap *, sbitmap *));\n+static void compute_insert_delete  PROTO ((struct edge_list *edge_list,\n+\t\t\t\t\t   sbitmap *, sbitmap *, sbitmap *,\n+\t\t\t\t\t   sbitmap *, sbitmap *));\n+\n+/* Edge based LCM routines on a reverse flowgraph.  */\n+static void compute_farthest\tPROTO  ((struct edge_list *, int, sbitmap *,\n+\t\t\t\t\t sbitmap *, sbitmap*, sbitmap *,\n+\t\t\t\t\t sbitmap *));\n+static void compute_nearerout\tPROTO((struct edge_list *, int, sbitmap *,\n+\t\t\t\t       sbitmap *, sbitmap *, sbitmap *));\n+static void compute_rev_insert_delete  PROTO ((struct edge_list *edge_list,\n+\t\t\t\t\t       sbitmap *, sbitmap *, sbitmap *,\n+\t\t\t\t\t       sbitmap *, sbitmap *));\n+\n+\f\n+/* Edge based lcm routines.  */\n+\n+/* Compute expression anticipatability at entrance and exit of each block. \n+   This is done based on the flow graph, and not on the pred-succ lists.  \n+   Other than that, its pretty much identical to compute_antinout.  */\n \n static void\n-compute_antinout (n_blocks, s_succs, antloc, transp, antin, antout)\n-     int n_blocks;\n-     int_list_ptr *s_succs;\n+compute_antinout_edge (antloc, transp, antin, antout)\n      sbitmap *antloc;\n      sbitmap *transp;\n      sbitmap *antin;\n      sbitmap *antout;\n {\n-  int bb, changed, passes;\n+  int i, changed, passes;\n   sbitmap old_changed, new_changed;\n+  edge e;\n \n-  sbitmap_zero (antout[n_blocks - 1]);\n-  sbitmap_vector_ones (antin, n_blocks);\n+  sbitmap_vector_zero (antout, n_basic_blocks);\n+  sbitmap_vector_ones (antin, n_basic_blocks);\n \n-  old_changed = sbitmap_alloc (n_blocks);\n-  new_changed = sbitmap_alloc (n_blocks);\n+  old_changed = sbitmap_alloc (n_basic_blocks);\n+  new_changed = sbitmap_alloc (n_basic_blocks);\n   sbitmap_ones (old_changed);\n \n   passes = 0;\n@@ -278,522 +115,568 @@ compute_antinout (n_blocks, s_succs, antloc, transp, antin, antout)\n     {\n       changed = 0;\n       sbitmap_zero (new_changed);\n+\n       /* We scan the blocks in the reverse order to speed up\n \t the convergence.  */\n-      for (bb = n_blocks - 1; bb >= 0; bb--)\n+      for (i = n_basic_blocks - 1; i >= 0; i--)\n \t{\n-\t  int_list_ptr ps;\n-\n+\t  basic_block bb = BASIC_BLOCK (i);\n \t  /* If none of the successors of this block have changed,\n \t     then this block is not going to change.  */\n-\t  for (ps = s_succs[bb] ; ps; ps = ps->next)\n+\t  for (e = bb->succ ; e; e = e->succ_next)\n \t    {\n-\t      if (INT_LIST_VAL (ps) == EXIT_BLOCK\n-\t\t  || INT_LIST_VAL (ps) == ENTRY_BLOCK)\n+\t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tbreak;\n \n-\t      if (TEST_BIT (old_changed, INT_LIST_VAL (ps))\n-\t\t  || TEST_BIT (new_changed, INT_LIST_VAL (ps)))\n+\t      if (TEST_BIT (old_changed, e->dest->index)\n+\t\t  || TEST_BIT (new_changed, e->dest->index))\n \t\tbreak;\n \t    }\n \n-\t  if (!ps)\n+\t  if (!e)\n \t    continue;\n \n-\t  if (bb != n_blocks - 1)\n-\t    sbitmap_intersect_of_successors (antout[bb], antin,\n-\t\t\t\t\t     bb, s_succs);\n- \t  if (sbitmap_a_or_b_and_c (antin[bb], antloc[bb],\n-\t\t\t\t    transp[bb], antout[bb]))\n+          /* If an Exit blocks is the ONLY successor, its has a zero ANTIN, \n+\t     which is the opposite of the default definition for an \n+\t     intersection of succs definition.  */\n+\t  if (e->dest == EXIT_BLOCK_PTR && e->succ_next == NULL \n+\t      && e->src->succ == e)\n+\t    sbitmap_zero (antout[bb->index]);\n+\t  else\n+\t    {\n+\t      sbitmap_intersection_of_succs (antout[bb->index],\n+\t\t\t\t\t     antin, \n+\t\t\t\t\t     bb->index);\n+\t    }\n+\n+ \t  if (sbitmap_a_or_b_and_c (antin[bb->index], antloc[bb->index],\n+\t\t\t\t    transp[bb->index], antout[bb->index]))\n \t    {\n \t      changed = 1;\n-\t      SET_BIT (new_changed, bb);\n+\t      SET_BIT (new_changed, bb->index);\n \t    }\n \t}\n       sbitmap_copy (old_changed, new_changed);\n       passes++;\n     }\n+\n   free (old_changed);\n   free (new_changed);\n }\n \n-/* Compute expression earliestness at entrance and exit of each block.\n-\n-   From Advanced Compiler Design and Implementation pp411.\n-\n-   An expression is earliest at the entrance to basic block BB if no\n-   block from entry to block BB both evaluates the expression and\n-   produces the same value as evaluating it at the entry to block BB\n-   does.  Similarly for earlistness at basic block BB exit.  */\n-\n+/* Compute the earliest vector for edge based lcm.  */\n static void\n-compute_earlyinout (n_blocks, n_exprs, s_preds, transp, antin,\n-\t\t    earlyin, earlyout)\n-     int n_blocks;\n+compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n+     struct edge_list *edge_list;\n      int n_exprs;\n-     int_list_ptr *s_preds;\n-     sbitmap *transp;\n-     sbitmap *antin;\n-     sbitmap *earlyin;\n-     sbitmap *earlyout;\n+     sbitmap *antin, *antout, *avout, *kill, *earliest;\n {\n-  int bb, changed, passes;\n-  sbitmap temp_bitmap;\n-  sbitmap old_changed, new_changed;\n-\n-  temp_bitmap = sbitmap_alloc (n_exprs);\n+  sbitmap difference, temp_bitmap;\n+  int x, num_edges; \n+  basic_block pred, succ;\n \n-  sbitmap_vector_zero (earlyout, n_blocks);\n-  sbitmap_ones (earlyin[0]);\n+  num_edges = NUM_EDGES (edge_list);\n \n-  old_changed = sbitmap_alloc (n_blocks);\n-  new_changed = sbitmap_alloc (n_blocks);\n-  sbitmap_ones (old_changed);\n+  difference = sbitmap_alloc (n_exprs);\n+  temp_bitmap = sbitmap_alloc (n_exprs);\n \n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n+  for (x = 0; x < num_edges; x++)\n     {\n-      changed = 0;\n-      sbitmap_zero (new_changed);\n-      for (bb = 0; bb < n_blocks; bb++)\n-\t{\n-\t  int_list_ptr ps;\n-\n-\t  /* If none of the predecessors of this block have changed,\n-\t     then this block is not going to change.  */\n-\t  for (ps = s_preds[bb] ; ps; ps = ps->next)\n+      pred = INDEX_EDGE_PRED_BB (edge_list, x);\n+      succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n+      if (pred == ENTRY_BLOCK_PTR)\n+\tsbitmap_copy (earliest[x], antin[succ->index]);\n+      else\n+        {\n+\t  if (succ == EXIT_BLOCK_PTR)\n \t    {\n-\t      if (INT_LIST_VAL (ps) == EXIT_BLOCK\n-\t\t  || INT_LIST_VAL (ps) == ENTRY_BLOCK)\n-\t\tbreak;\n-\n-\t      if (TEST_BIT (old_changed, INT_LIST_VAL (ps))\n-\t\t  || TEST_BIT (new_changed, INT_LIST_VAL (ps)))\n-\t\tbreak;\n+\t      sbitmap_zero (earliest[x]);\n \t    }\n-\n-\t  if (!ps)\n-\t    continue;\n-\n-\t  if (bb != 0)\n-\t    sbitmap_union_of_predecessors (earlyin[bb], earlyout,\n-\t\t\t\t\t   bb, s_preds);\n-\t  sbitmap_not (temp_bitmap, transp[bb]);\n-\t  if (sbitmap_union_of_diff (earlyout[bb], temp_bitmap,\n-\t\t\t\t     earlyin[bb], antin[bb]))\n+\t  else\n \t    {\n-\t      changed = 1;\n-\t      SET_BIT (new_changed, bb);\n+\t      sbitmap_difference (difference, antin[succ->index], \n+\t      \t\t\t  avout[pred->index]);\n+\t      sbitmap_not (temp_bitmap, antout[pred->index]);\n+\t      sbitmap_a_and_b_or_c (earliest[x], difference, kill[pred->index], \n+\t\t\t\t    temp_bitmap);\n \t    }\n \t}\n-      sbitmap_copy (old_changed, new_changed);\n-      passes++;\n     }\n-  free (old_changed);\n-  free (new_changed);\n   free (temp_bitmap);\n+  free (difference);\n }\n \n-/* Compute expression delayedness at entrance and exit of each block.\n-\n-   From Advanced Compiler Design and Implementation pp411.\n-\n-   An expression is delayed at the entrance to BB if it is anticipatable\n-   and earliest at that point and if all subsequent computations of\n-   the expression are in block BB.   */\n-\n+/* Compute later and laterin vectors for edge based lcm.  */\n static void\n-compute_delayinout (n_blocks, n_exprs, s_preds, antloc,\n-\t\t    antin, earlyin, delayin, delayout)\n-     int n_blocks;\n+compute_laterin (edge_list, n_exprs,\n+\t\t earliest, antloc, later, laterin)\n+     struct edge_list *edge_list;\n      int n_exprs;\n-     int_list_ptr *s_preds;\n-     sbitmap *antloc;\n-     sbitmap *antin;\n-     sbitmap *earlyin;\n-     sbitmap *delayin;\n-     sbitmap *delayout;\n+     sbitmap *earliest, *antloc, *later, *laterin;\n {\n-  int bb, changed, passes;\n-  sbitmap *anti_and_early;\n-  sbitmap temp_bitmap;\n+  sbitmap difference, temp_bitmap;\n+  int x, num_edges; \n+  basic_block pred, succ;\n+  int done = 0;\n \n-  temp_bitmap = sbitmap_alloc (n_exprs);\n+  num_edges = NUM_EDGES (edge_list);\n \n-  /* This is constant throughout the flow equations below, so compute\n-     it once to save time.  */\n-  anti_and_early = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  for (bb = 0; bb < n_blocks; bb++)\n-    sbitmap_a_and_b (anti_and_early[bb], antin[bb], earlyin[bb]);\n-  \n-  sbitmap_vector_zero (delayout, n_blocks);\n-  sbitmap_copy (delayin[0], anti_and_early[0]);\n+  /* Laterin has an extra block allocated for the exit block.  */\n+  sbitmap_vector_ones (laterin, n_basic_blocks + 1);\n+  sbitmap_vector_zero (later, num_edges);\n \n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n+  /* Initialize laterin to the intersection of EARLIEST for all edges\n+     from predecessors to this block. */\n+\n+  for (x = 0; x < num_edges; x++)\n     {\n-      changed = 0;\n-      for (bb = 0; bb < n_blocks; bb++)\n+      succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n+      pred = INDEX_EDGE_PRED_BB (edge_list, x);\n+      if (succ != EXIT_BLOCK_PTR)\n+\tsbitmap_a_and_b (laterin[succ->index], laterin[succ->index], \n+\t\t\t earliest[x]);\n+      /* We already know the correct value of later for edges from\n+         the entry node, so set it now.  */\n+      if (pred == ENTRY_BLOCK_PTR)\n+\tsbitmap_copy (later[x], earliest[x]);\n+    }\n+\n+  difference = sbitmap_alloc (n_exprs);\n+\n+  while (!done)\n+    {\n+      done = 1;\n+      for (x = 0; x < num_edges; x++)\n \t{\n-\t  if (bb != 0)\n+          pred = INDEX_EDGE_PRED_BB (edge_list, x);\n+\t  if (pred != ENTRY_BLOCK_PTR)\n \t    {\n-\t      sbitmap_intersect_of_predecessors (temp_bitmap, delayout,\n-\t\t\t\t\t\t bb, s_preds);\n-\t      changed |= sbitmap_a_or_b (delayin[bb],\n-\t\t\t\t\t anti_and_early[bb],\n-\t\t\t\t\t temp_bitmap);\n+\t      sbitmap_difference (difference, laterin[pred->index], \n+\t      \t\t\t  antloc[pred->index]);\n+\t      if (sbitmap_a_or_b (later[x], difference, earliest[x]))\n+\t\tdone = 0;\n \t    }\n-\t  sbitmap_not (temp_bitmap, antloc[bb]);\n-\t  changed |= sbitmap_a_and_b (delayout[bb],\n-\t\t\t\t      temp_bitmap,\n-\t\t\t\t      delayin[bb]);\n \t}\n-      passes++;\n+      if (done)\n+        break;\n+\n+      sbitmap_vector_ones (laterin, n_basic_blocks);\n+\n+      for (x = 0; x < num_edges; x++)\n+\t{\n+\t  succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n+\t  if (succ != EXIT_BLOCK_PTR)\n+\t    sbitmap_a_and_b (laterin[succ->index], laterin[succ->index], \n+\t    \t\t     later[x]);\n+\t  else\n+\t    /* We allocated an extra block for the exit node.  */\n+\t    sbitmap_a_and_b (laterin[n_basic_blocks], laterin[n_basic_blocks], \n+\t    \t\t     later[x]);\n+\t}\n     }\n \n-  /* We're done with this, so go ahead and free it's memory now instead\n-     of waiting until the end of pre.  */\n-  free (anti_and_early);\n-  free (temp_bitmap);\n+  free (difference);\n }\n \n-/* Compute latestness.\n+/* Compute the insertion and deletion points for edge based LCM.  */\n+static void\n+compute_insert_delete (edge_list, antloc, later, laterin,\n+\t\t       insert, delete)\n+     struct edge_list *edge_list;\n+     sbitmap *antloc, *later, *laterin, *insert, *delete;\n+{\n+  int x;\n \n-   From Advanced Compiler Design and Implementation pp412.\n+  for (x = 0; x < n_basic_blocks; x++)\n+    sbitmap_difference (delete[x], antloc[x], laterin[x]);\n+     \n+  for (x = 0; x < NUM_EDGES (edge_list); x++)\n+    {\n+      basic_block b = INDEX_EDGE_SUCC_BB (edge_list, x);\n+      if (b == EXIT_BLOCK_PTR)\n+\tsbitmap_difference (insert[x], later[x], laterin[n_basic_blocks]);\n+      else\n+\tsbitmap_difference (insert[x], later[x], laterin[b->index]);\n+    }\n+}\n \n-   An expression is latest at the entrance to block BB if that is an optimal\n-   point for computing the expression and if on every path from block BB's\n-   entrance to the exit block, any optimal computation point for the \n-   expression occurs after one of the points at which the expression was\n-   computed in the original flowgraph.  */\n+/* Given local properties TRANSP, ANTLOC, AVOUT, KILL return the \n+   insert and delete vectors for edge based LCM.  Returns an\n+   edgelist which is used to map the insert vector to what edge\n+   an expression should be inserted on.  */\n \n-static void\n-compute_latein (n_blocks, n_exprs, s_succs, antloc, delayin, latein)\n-     int n_blocks;\n+struct edge_list *\n+pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n+     FILE *file;\n      int n_exprs;\n-     int_list_ptr *s_succs;\n+     sbitmap *transp;\n+     sbitmap *avloc;\n      sbitmap *antloc;\n-     sbitmap *delayin;\n-     sbitmap *latein;\n+     sbitmap *kill;\n+     sbitmap **insert;\n+     sbitmap **delete;\n {\n-  int bb;\n-  sbitmap temp_bitmap;\n+  sbitmap *antin, *antout, *earliest;\n+  sbitmap *avin, *avout;\n+  sbitmap *later, *laterin;\n+  struct edge_list *edge_list;\n+  int num_edges;\n \n-  temp_bitmap = sbitmap_alloc (n_exprs);\n+  edge_list = create_edge_list ();\n+  num_edges = NUM_EDGES (edge_list);\n \n-  for (bb = 0; bb < n_blocks; bb++)\n+#ifdef LCM_DEBUG_INFO\n+  if (file)\n     {\n-      /* The last block is succeeded only by the exit block; therefore,\n-\t temp_bitmap will not be set by the following call!  */\n-      if (bb == n_blocks - 1)\n-\t{\n-          sbitmap_intersect_of_successors (temp_bitmap, delayin,\n-\t\t\t\t           bb, s_succs);\n-\t  sbitmap_not (temp_bitmap, temp_bitmap);\n-\t}\n-      else\n-\tsbitmap_ones (temp_bitmap);\n-      sbitmap_a_and_b_or_c (latein[bb], delayin[bb],\n-\t\t\t    antloc[bb], temp_bitmap);\n+      fprintf (file, \"Edge List:\\n\");\n+      verify_edge_list (file, edge_list);\n+      print_edge_list (file, edge_list);\n+      dump_sbitmap_vector (file, \"transp\", \"\", transp, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"antloc\", \"\", antloc, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"avloc\", \"\", avloc, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"kill\", \"\", kill, n_basic_blocks);\n     }\n-  free (temp_bitmap);\n-}\n-\n-/* Compute isolated.\n+#endif\n \n-   From Advanced Compiler Design and Implementation pp413.\n+  /* Compute global availability.  */\n+  avin = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  avout = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  compute_available (avloc, kill, avout, avin);\n \n-   A computationally optimal placement for the evaluation of an expression\n-   is defined to be isolated if and only if on every path from a successor\n-   of the block in which it is computed to the exit block, every original\n-   computation of the expression is preceded by the optimal placement point.  */\n-\n-static void\n-compute_isoinout (n_blocks, s_succs, antloc, latein, isoin, isoout)\n-     int n_blocks;\n-     int_list_ptr *s_succs;\n-     sbitmap *antloc;\n-     sbitmap *latein;\n-     sbitmap *isoin;\n-     sbitmap *isoout;\n-{\n-  int bb, changed, passes;\n+  free (avin);\n \n-  sbitmap_vector_zero (isoin, n_blocks);\n-  sbitmap_zero (isoout[n_blocks - 1]);\n+  /* Compute global anticipatability.  */\n+  antin = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  antout = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  compute_antinout_edge (antloc, transp, antin, antout);\n \n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n+#ifdef LCM_DEBUG_INFO\n+  if (file)\n     {\n-      changed = 0;\n-      for (bb = n_blocks - 1; bb >= 0; bb--)\n-\t{\n-\t  if (bb != n_blocks - 1)\n-\t    sbitmap_intersect_of_successors (isoout[bb], isoin,\n-\t\t\t\t\t     bb, s_succs);\n-\t  changed |= sbitmap_union_of_diff (isoin[bb], latein[bb],\n-\t\t\t\t\t    isoout[bb], antloc[bb]);\n-\t}\n-      passes++;\n+      dump_sbitmap_vector (file, \"antin\", \"\", antin, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"antout\", \"\", antout, n_basic_blocks);\n     }\n-}\n+#endif\n \n-/* Compute the set of expressions which have optimal computational points\n-   in each basic block.  This is the set of expressions that are latest, but\n-   that are not isolated in the block.  */\n+  /* Compute earliestness.  */\n+  earliest = sbitmap_vector_alloc (num_edges, n_exprs);\n+  compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest);\n \n-static void\n-compute_optimal (n_blocks, latein, isoout, optimal)\n-     int n_blocks;\n-     sbitmap *latein;\n-     sbitmap *isoout;\n-     sbitmap *optimal;\n-{\n-  int bb;\n+#ifdef LCM_DEBUG_INFO\n+  if (file)\n+    dump_sbitmap_vector (file, \"earliest\", \"\", earliest, num_edges);\n+#endif\n \n-  for (bb = 0; bb < n_blocks; bb++)\n-    sbitmap_difference (optimal[bb], latein[bb], isoout[bb]);\n-}\n+  free (antout);\n+  free (antin);\n+  free (avout);\n \n-/* Compute the set of expressions that are redundant in a block.  They are\n-   the expressions that are used in the block and that are neither isolated\n-   or latest.  */\n+  later = sbitmap_vector_alloc (num_edges, n_exprs);\n+  /* Allocate an extra element for the exit block in the laterin vector.  */\n+  laterin = sbitmap_vector_alloc (n_basic_blocks + 1, n_exprs);\n+  compute_laterin (edge_list, n_exprs, earliest, antloc, later, laterin);\n \n-static void\n-compute_redundant (n_blocks, n_exprs, antloc, latein, isoout, redundant)\n-     int n_blocks;\n-     int n_exprs;\n-     sbitmap *antloc;\n-     sbitmap *latein;\n-     sbitmap *isoout;\n-     sbitmap *redundant;\n-{\n-  int bb;\n-  sbitmap temp_bitmap;\n+#ifdef LCM_DEBUG_INFO\n+  if (file)\n+    {\n+      dump_sbitmap_vector (file, \"laterin\", \"\", laterin, n_basic_blocks + 1);\n+      dump_sbitmap_vector (file, \"later\", \"\", later, num_edges);\n+    }\n+#endif\n \n-  temp_bitmap = sbitmap_alloc (n_exprs);\n+  free (earliest);\n+\n+  *insert = sbitmap_vector_alloc (num_edges, n_exprs);\n+  *delete = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  compute_insert_delete (edge_list, antloc, later, laterin, *insert, *delete);\n \n-  for (bb = 0; bb < n_blocks; bb++)\n+  free (laterin);\n+  free (later);\n+\n+#ifdef LCM_DEBUG_INFO\n+  if (file)\n     {\n-      sbitmap_a_or_b (temp_bitmap, latein[bb], isoout[bb]);\n-      sbitmap_difference (redundant[bb], antloc[bb], temp_bitmap);\n+      dump_sbitmap_vector (file, \"pre_insert_map\", \"\", *insert, num_edges);\n+      dump_sbitmap_vector (file, \"pre_delete_map\", \"\", *delete, n_basic_blocks);\n     }\n-  free (temp_bitmap);\n-}\n+#endif\n \n-/* Compute expression availability at entrance and exit of each block.  */\n+  return edge_list;\n+}\n \n-static void\n-compute_avinout (n_blocks, s_preds, avloc, transp, avin, avout)\n-     int n_blocks;\n-     int_list_ptr *s_preds;\n-     sbitmap *avloc;\n-     sbitmap *transp;\n-     sbitmap *avin;\n-     sbitmap *avout;\n+/* Compute the AVIN and AVOUT vectors from the AVLOC and KILL vectors.\n+   Return the number of passes we performed to iterate to a solution.  */\n+int\n+compute_available (avloc, kill, avout, avin)\n+     sbitmap *avloc, *kill, *avout, *avin;  \n {\n   int bb, changed, passes;\n+  int last = n_basic_blocks - 1;\n \n   sbitmap_zero (avin[0]);\n-  sbitmap_vector_ones (avout, n_blocks);\n+  sbitmap_copy (avout[0] /*dst*/, avloc[0] /*src*/);\n \n+  for (bb = 1; bb < n_basic_blocks; bb++)\n+    sbitmap_not (avout[bb], kill[bb]);\n+    \n   passes = 0;\n   changed = 1;\n   while (changed)\n     {\n       changed = 0;\n-      for (bb = 0; bb < n_blocks; bb++)\n-\t{\n-\t  if (bb != 0)\n-\t    sbitmap_intersect_of_predecessors (avin[bb], avout,\n-\t\t\t\t\t       bb, s_preds);\n-\t  changed |= sbitmap_a_or_b_and_c (avout[bb], avloc[bb],\n-\t\t\t\t\t   transp[bb], avin[bb]);\n-\t}\n+      for (bb = 1; bb < n_basic_blocks; bb++)\n+        {\n+          sbitmap_intersection_of_preds (avin[bb], avout, bb);\n+          changed |= sbitmap_union_of_diff (avout[bb], avloc[bb],\n+                                            avin[bb], kill[bb]);\n+        }\n       passes++;\n     }\n+  return passes;\n }\n \n-/* Compute expression latestness.\n-\n-   This is effectively the same as earliestness computed on the reverse\n-   flow graph.  */\n-\n+/* Compute the farthest vector for edge based lcm.  */\n static void\n-compute_fartherinout (n_blocks, n_exprs, s_succs,\n-\t\t      transp, avout, fartherin, fartherout)\n-     int n_blocks;\n+compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin, \n+\t\t  kill, farthest)\n+     struct edge_list *edge_list;\n      int n_exprs;\n-     int_list_ptr *s_succs;\n-     sbitmap *transp;\n-     sbitmap *avout;\n-     sbitmap *fartherin;\n-     sbitmap *fartherout;\n+     sbitmap *st_avout, *st_avin, *st_antin, *kill, *farthest;\n {\n-  int bb, changed, passes;\n-  sbitmap temp_bitmap;\n+  sbitmap difference, temp_bitmap;\n+  int x, num_edges; \n+  basic_block pred, succ;\n \n-  temp_bitmap = sbitmap_alloc (n_exprs);\n+  num_edges = NUM_EDGES (edge_list);\n \n-  sbitmap_vector_zero (fartherin, n_blocks);\n-  sbitmap_ones (fartherout[n_blocks - 1]);\n+  difference = sbitmap_alloc (n_exprs);\n+  temp_bitmap = sbitmap_alloc (n_exprs);\n \n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n+  for (x = 0; x < num_edges; x++)\n     {\n-      changed = 0;\n-      for (bb = n_blocks - 1; bb >= 0; bb--)\n+      pred = INDEX_EDGE_PRED_BB (edge_list, x);\n+      succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n+      if (succ == EXIT_BLOCK_PTR)\n+\tsbitmap_copy (farthest[x], st_avout[pred->index]);\n+      else\n \t{\n-\t  if (bb != n_blocks - 1)\n-\t    sbitmap_union_of_successors (fartherout[bb], fartherin,\n-\t\t\t\t\t bb, s_succs);\n-\t  sbitmap_not (temp_bitmap, transp[bb]);\n-\t  changed |= sbitmap_union_of_diff (fartherin[bb], temp_bitmap,\n-\t\t\t\t\t    fartherout[bb], avout[bb]);\n+\t  if (pred == ENTRY_BLOCK_PTR)\n+\t    {\n+\t      sbitmap_zero (farthest[x]);\n+\t    }\n+\t  else\n+\t    {\n+\t      sbitmap_difference (difference, st_avout[pred->index], \n+\t\t\t\t  st_antin[succ->index]);\n+\t      sbitmap_not (temp_bitmap, st_avin[succ->index]);\n+\t      sbitmap_a_and_b_or_c (farthest[x], difference, \n+\t\t\t\t    kill[succ->index], temp_bitmap);\n+\t    }\n \t}\n-      passes++;\n     }\n-\n   free (temp_bitmap);\n+  free (difference);\n }\n \n-/* Compute expression earlierness at entrance and exit of each block.\n-\n-   This is effectively the same as delayedness computed on the reverse\n-   flow graph.  */\n-\n+/* Compute nearer and nearerout vectors for edge based lcm.  */\n static void\n-compute_earlierinout (n_blocks, n_exprs, s_succs, avloc,\n-\t\t      avout, fartherout, earlierin, earlierout)\n-     int n_blocks;\n+compute_nearerout (edge_list, n_exprs,\n+\t\t   farthest, st_avloc, nearer, nearerout)\n+     struct edge_list *edge_list;\n      int n_exprs;\n-     int_list_ptr *s_succs;\n-     sbitmap *avloc;\n-     sbitmap *avout;\n-     sbitmap *fartherout;\n-     sbitmap *earlierin;\n-     sbitmap *earlierout;\n+     sbitmap *farthest, *st_avloc, *nearer, *nearerout;\n {\n-  int bb, changed, passes;\n-  sbitmap *av_and_farther;\n-  sbitmap temp_bitmap;\n+  sbitmap difference, temp_bitmap;\n+  int x, num_edges; \n+  basic_block pred, succ;\n+  int done = 0;\n \n-  temp_bitmap = sbitmap_alloc (n_exprs);\n+  num_edges = NUM_EDGES (edge_list);\n \n-  /* This is constant throughout the flow equations below, so compute\n-     it once to save time.  */\n-  av_and_farther = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  for (bb = 0; bb < n_blocks; bb++)\n-    sbitmap_a_and_b (av_and_farther[bb], avout[bb], fartherout[bb]);\n-  \n-  sbitmap_vector_zero (earlierin, n_blocks);\n-  sbitmap_copy (earlierout[n_blocks - 1], av_and_farther[n_blocks - 1]);\n+  /* nearout has an extra block allocated for the entry block.  */\n+  sbitmap_vector_ones (nearerout, n_basic_blocks + 1);\n+  sbitmap_vector_zero (nearer, num_edges);\n \n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n+  /* Initialize nearerout to the intersection of FARTHEST for all edges\n+     from predecessors to this block. */\n+\n+  for (x = 0; x < num_edges; x++)\n     {\n-      changed = 0;\n-      for (bb = n_blocks - 1; bb >= 0; bb--)\n+      succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n+      pred = INDEX_EDGE_PRED_BB (edge_list, x);\n+      if (pred != ENTRY_BLOCK_PTR)\n+        {\n+\t  sbitmap_a_and_b (nearerout[pred->index], nearerout[pred->index], \n+\t\t\t   farthest[x]);\n+\t}\n+      /* We already know the correct value of nearer for edges to \n+         the exit node.  */\n+      if (succ == EXIT_BLOCK_PTR)\n+\tsbitmap_copy (nearer[x], farthest[x]);\n+    }\n+\n+  difference = sbitmap_alloc (n_exprs);\n+\n+  while (!done)\n+    {\n+      done = 1;\n+      for (x = 0; x < num_edges; x++)\n \t{\n-\t  if (bb != n_blocks - 1)\n+          succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n+\t  if (succ != EXIT_BLOCK_PTR)\n \t    {\n-\t      sbitmap_intersect_of_successors (temp_bitmap, earlierin,\n-\t\t\t\t\t       bb, s_succs);\n-\t      changed |= sbitmap_a_or_b (earlierout[bb],\n-\t\t\t\t\t av_and_farther[bb],\n-\t\t\t\t\t temp_bitmap);\n+\t      sbitmap_difference (difference, nearerout[succ->index], \n+\t\t\t\t  st_avloc[succ->index]);\n+\t      if (sbitmap_a_or_b (nearer[x], difference, farthest[x]))\n+\t\tdone = 0;\n \t    }\n-\t  sbitmap_not (temp_bitmap, avloc[bb]);\n-\t  changed |= sbitmap_a_and_b (earlierin[bb],\n-\t\t\t\t      temp_bitmap,\n-\t\t\t\t      earlierout[bb]);\n \t}\n-      passes++;\n-    }\n \n-  /* We're done with this, so go ahead and free it's memory now instead\n-     of waiting until the end of pre.  */\n-  free (av_and_farther);\n-  free (temp_bitmap);\n-}\n+      if (done)\n+        break;\n \n-/* Compute firstness. \n+      sbitmap_vector_zero (nearerout, n_basic_blocks);\n+\n+      for (x = 0; x < num_edges; x++)\n+\t{\n+\t  pred = INDEX_EDGE_PRED_BB (edge_list, x);\n+\t  if (pred != ENTRY_BLOCK_PTR)\n+\t      sbitmap_a_and_b (nearerout[pred->index], \n+\t\t\t       nearerout[pred->index], nearer[x]);\n+\t    else\n+\t      sbitmap_a_and_b (nearerout[n_basic_blocks], \n+\t\t\t       nearerout[n_basic_blocks], nearer[x]);\n+\t}\n+    }\n \n-   This is effectively the same as latestness computed on the reverse\n-   flow graph.  */\n+  free (difference);\n+}\n \n+/* Compute the insertion and deletion points for edge based LCM.  */\n static void\n-compute_firstout (n_blocks, n_exprs, s_preds, avloc, earlierout, firstout)\n-     int n_blocks;\n-     int n_exprs;\n-     int_list_ptr *s_preds;\n-     sbitmap *avloc;\n-     sbitmap *earlierout;\n-     sbitmap *firstout;\n+compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n+\t\t\t   insert, delete)\n+     struct edge_list *edge_list;\n+     sbitmap *st_avloc, *nearer, *nearerout, *insert, *delete;\n {\n-  int bb;\n-  sbitmap temp_bitmap;\n+  int x;\n \n-  temp_bitmap = sbitmap_alloc (n_exprs);\n-\n-  for (bb = 0; bb < n_blocks; bb++)\n+  for (x = 0; x < n_basic_blocks; x++)\n+    sbitmap_difference (delete[x], st_avloc[x], nearerout[x]);\n+     \n+  for (x = 0; x < NUM_EDGES (edge_list); x++)\n     {\n-      /* The first block is preceded only by the entry block; therefore,\n-\t temp_bitmap will not be set by the following call!  */\n-      if (bb != 0)\n-\t{\n-\t  sbitmap_intersect_of_predecessors (temp_bitmap, earlierout,\n-\t\t\t\t\t     bb, s_preds);\n-\t  sbitmap_not (temp_bitmap, temp_bitmap);\n-\t}\n+      basic_block b = INDEX_EDGE_PRED_BB (edge_list, x);\n+      if (b == ENTRY_BLOCK_PTR)\n+\tsbitmap_difference (insert[x], nearer[x], nearerout[n_basic_blocks]);\n       else\n-\t{\n-\t  sbitmap_ones (temp_bitmap);\n-\t}\n-      sbitmap_a_and_b_or_c (firstout[bb], earlierout[bb],\n-\t\t\t    avloc[bb], temp_bitmap);\n+\tsbitmap_difference (insert[x], nearer[x], nearerout[b->index]);\n     }\n-  free (temp_bitmap);\n }\n \n-/* Compute reverse isolated.\n-\n-   This is effectively the same as isolatedness computed on the reverse\n-   flow graph.  */\n+/* Given local properties TRANSP, ST_AVLOC, ST_ANTLOC, KILL return the \n+   insert and delete vectors for edge based reverse LCM.  Returns an\n+   edgelist which is used to map the insert vector to what edge\n+   an expression should be inserted on.  */\n \n-static void\n-compute_rev_isoinout (n_blocks, s_preds, avloc, firstout,\n-\t\t      rev_isoin, rev_isoout)\n-     int n_blocks;\n-     int_list_ptr *s_preds;\n-     sbitmap *avloc;\n-     sbitmap *firstout;\n-     sbitmap *rev_isoin;\n-     sbitmap *rev_isoout;\n+struct edge_list *\n+pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill, \n+\t\t  insert, delete)\n+     FILE *file;\n+     int n_exprs;\n+     sbitmap *transp;\n+     sbitmap *st_avloc;\n+     sbitmap *st_antloc;\n+     sbitmap *kill;\n+     sbitmap **insert;\n+     sbitmap **delete;\n {\n-  int bb, changed, passes;\n+  sbitmap *st_antin, *st_antout;\n+  sbitmap *st_avout, *st_avin, *farthest;\n+  sbitmap *nearer, *nearerout;\n+  struct edge_list *edge_list;\n+  int x,num_edges;\n+\n+  edge_list = create_edge_list ();\n+  num_edges = NUM_EDGES (edge_list);\n+\n+  st_antin = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  st_antout = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  sbitmap_vector_zero (st_antin, n_basic_blocks);\n+  sbitmap_vector_zero (st_antout, n_basic_blocks);\n+  compute_antinout_edge (st_antloc, transp, st_antin, st_antout);\n+\n+  /* Compute global anticipatability.  */\n+  st_avout = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  st_avin = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  compute_available (st_avloc, kill, st_avout, st_avin);\n+\n+#ifdef LCM_DEBUG_INFO\n+  if (file)\n+    {\n+      fprintf (file, \"Edge List:\\n\");\n+      verify_edge_list (file, edge_list);\n+      print_edge_list (file, edge_list);\n+      dump_sbitmap_vector (file, \"transp\", \"\", transp, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"st_avloc\", \"\", st_avloc, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"st_antloc\", \"\", st_antloc, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"st_antin\", \"\", st_antin, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"st_antout\", \"\", st_antout, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"st_kill\", \"\", kill, n_basic_blocks);\n+    }\n+#endif\n \n-  sbitmap_vector_zero (rev_isoout, n_blocks);\n-  sbitmap_zero (rev_isoin[0]);\n+#ifdef LCM_DEBUG_INFO\n+  if (file)\n+    {\n+      dump_sbitmap_vector (file, \"st_avout\", \"\", st_avout, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"st_avin\", \"\", st_avin, n_basic_blocks);\n+    }\n+#endif\n \n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n+  /* Compute farthestness.  */\n+  farthest = sbitmap_vector_alloc (num_edges, n_exprs);\n+  compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin, \n+\t\t    kill, farthest);\n+\n+#ifdef LCM_DEBUG_INFO\n+  if (file)\n+    dump_sbitmap_vector (file, \"farthest\", \"\", farthest, num_edges);\n+#endif\n+\n+  free (st_avin);\n+  free (st_avout);\n+\n+  nearer = sbitmap_vector_alloc (num_edges, n_exprs);\n+  /* Allocate an extra element for the entry block.  */\n+  nearerout = sbitmap_vector_alloc (n_basic_blocks + 1, n_exprs);\n+  compute_nearerout (edge_list, n_exprs, farthest, st_avloc, nearer, nearerout);\n+\n+#ifdef LCM_DEBUG_INFO\n+  if (file)\n     {\n-      changed = 0;\n-      for (bb = 0; bb < n_blocks; bb++)\n-\t{\n-\t  if (bb != 0)\n-\t    sbitmap_intersect_of_predecessors (rev_isoin[bb], rev_isoout,\n-\t\t\t\t\t       bb, s_preds);\n-\t  changed |= sbitmap_union_of_diff (rev_isoout[bb], firstout[bb],\n-\t\t\t\t\t    rev_isoin[bb], avloc[bb]);\n-\t}\n-      passes++;\n+      dump_sbitmap_vector (file, \"nearerout\", \"\", nearerout, \n+\t\t\t   n_basic_blocks + 1);\n+      dump_sbitmap_vector (file, \"nearer\", \"\", nearer, num_edges);\n     }\n+#endif\n+\n+  free (farthest);\n+\n+  *insert = sbitmap_vector_alloc (num_edges, n_exprs);\n+  *delete = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout, *insert, *delete);\n+\n+  free (nearerout);\n+  free (nearer);\n+\n+#ifdef LCM_DEBUG_INFO\n+  if (file)\n+    {\n+      dump_sbitmap_vector (file, \"pre_insert_map\", \"\", *insert, num_edges);\n+      dump_sbitmap_vector (file, \"pre_delete_map\", \"\", *delete, n_basic_blocks);\n+    }\n+#endif\n+\n+  return edge_list;\n }"}]}