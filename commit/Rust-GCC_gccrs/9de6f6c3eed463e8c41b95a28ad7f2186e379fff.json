{"sha": "9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRlNmY2YzNlZWQ0NjNlOGM0MWI5NWEyOGFkN2YyMTg2ZTM3OWZmZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-03-26T02:11:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-03-26T02:11:57Z"}, "message": "re PR ipa/60315 (template constructor switch optimization)\n\n\n\tPR ipa/60315\n\t* cif-code.def (UNREACHABLE) New code.\n\t* ipa-inline.c (inline_small_functions): Skip edges to __builtlin_unreachable.\n\t(estimate_edge_growth): Allow edges to __builtlin_unreachable.\n\t* ipa-inline-analysis.c (edge_set_predicate): Redirect edges with false\n\tpredicate to __bulitin_unreachable.\n\t(set_cond_stmt_execution_predicate): Fix issue when invert_tree_comparison\n\treturns ERROR_MARK.\n\t* ipa-pure-const.c (propagate_pure_const, propagate_nothrow): Do not\n\tpropagate to inline clones.\n\t* cgraph.c (verify_edge_corresponds_to_fndecl): Allow redirection\n\tto unreachable.\n\t* ipa-cp.c (create_specialized_node): Be ready for new node to appear.\n\t* cgraphclones.c (cgraph_clone_node): If call destination is already\n\tureachable, do not redirect it back.\n\t* tree-inline.c (fold_marked_statements): Hanlde calls becoming\n\tunreachable.\n\nFrom-SVN: r208831", "tree": {"sha": "58c27722a6391d91e8bbfcb902c1edc28e754d14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58c27722a6391d91e8bbfcb902c1edc28e754d14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/comments", "author": null, "committer": null, "parents": [{"sha": "d7636f5609dc4325d145b82adc9dd977d079303e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7636f5609dc4325d145b82adc9dd977d079303e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7636f5609dc4325d145b82adc9dd977d079303e"}], "stats": {"total": 118, "additions": 105, "deletions": 13}, "files": [{"sha": "64ef5c059f85d4242c57bda26f5982ae71d97e53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "patch": "@@ -1,3 +1,23 @@\n+2014-03-25  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/60315\n+\t* cif-code.def (UNREACHABLE) New code.\n+\t* ipa-inline.c (inline_small_functions): Skip edges to __builtlin_unreachable.\n+\t(estimate_edge_growth): Allow edges to __builtlin_unreachable.\n+\t* ipa-inline-analysis.c (edge_set_predicate): Redirect edges with false\n+\tpredicate to __bulitin_unreachable.\n+\t(set_cond_stmt_execution_predicate): Fix issue when invert_tree_comparison\n+\treturns ERROR_MARK.\n+\t* ipa-pure-const.c (propagate_pure_const, propagate_nothrow): Do not\n+\tpropagate to inline clones.\n+\t* cgraph.c (verify_edge_corresponds_to_fndecl): Allow redirection\n+\tto unreachable.\n+\t* ipa-cp.c (create_specialized_node): Be ready for new node to appear.\n+\t* cgraphclones.c (cgraph_clone_node): If call destination is already\n+\tureachable, do not redirect it back.\n+\t* tree-inline.c (fold_marked_statements): Hanlde calls becoming\n+\tunreachable.\n+\n 2014-03-25  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-pure-const.c (propagate_pure_const, propagate_nothrow):"}, {"sha": "586ef797abae40069827e7d9f2f0afb3a9986a21", "filename": "gcc/cgraph.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "patch": "@@ -2612,6 +2612,12 @@ verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n       || node->in_other_partition\n       || e->callee->in_other_partition)\n     return false;\n+\n+  /* Optimizers can redirect unreachable calls or calls triggering undefined\n+     behaviour to builtin_unreachable.  */\n+  if (DECL_BUILT_IN_CLASS (e->callee->decl) == BUILT_IN_NORMAL\n+      && DECL_FUNCTION_CODE (e->callee->decl) == BUILT_IN_UNREACHABLE)\n+    return false;\n   node = cgraph_function_or_thunk_node (node, NULL);\n \n   if (e->callee->former_clone_of != node->decl"}, {"sha": "b2eb8ab5ce9aff3ec004839eb09de716292b9a19", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "patch": "@@ -238,8 +238,12 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   FOR_EACH_VEC_ELT (redirect_callers, i, e)\n     {\n       /* Redirect calls to the old version node to point to its new\n-\t version.  */\n-      cgraph_redirect_edge_callee (e, new_node);\n+\t version.  The only exception is when the edge was proved to\n+\t be unreachable during the clonning procedure.  */\n+      if (!e->callee\n+\t  || DECL_BUILT_IN_CLASS (e->callee->decl) != BUILT_IN_NORMAL\n+\t  || DECL_FUNCTION_CODE (e->callee->decl) != BUILT_IN_UNREACHABLE)\n+        cgraph_redirect_edge_callee (e, new_node);\n     }\n \n "}, {"sha": "ce64d96b6900fee023c4c6f5562d681dde08a6c5", "filename": "gcc/cif-code.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fcif-code.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fcif-code.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcif-code.def?ref=9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "patch": "@@ -127,3 +127,7 @@ DEFCIFCODE(USES_COMDAT_LOCAL, CIF_FINAL_NORMAL,\n /* We can't inline because of mismatched caller/callee attributes.  */\n DEFCIFCODE(ATTRIBUTE_MISMATCH, CIF_FINAL_NORMAL,\n \t   N_(\"function attribute mismatch\"))\n+\n+/* We proved that the call is unreachable.  */\n+DEFCIFCODE(UNREACHABLE, CIF_FINAL_NORMAL,\n+\t   N_(\"unreachable\"))"}, {"sha": "05de8572492c066dd8b708f5b72b3c04525c4784", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "patch": "@@ -2811,9 +2811,7 @@ create_specialized_node (struct cgraph_node *node,\n       if (aggvals)\n \tipa_dump_agg_replacement_values (dump_file, aggvals);\n     }\n-  gcc_checking_assert (ipa_node_params_vector.exists ()\n-\t\t       && (ipa_node_params_vector.length ()\n-\t\t\t   > (unsigned) cgraph_max_uid));\n+  ipa_check_create_node_params ();\n   update_profiling_info (node, new_node);\n   new_info = IPA_NODE_REF (new_node);\n   new_info->ipcp_orig_node = node;"}, {"sha": "ebc46a90cbf5f67f392f228fae1ed7e0d54637e5", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "patch": "@@ -746,6 +746,20 @@ static void\n edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n {\n   struct inline_edge_summary *es = inline_edge_summary (e);\n+\n+  /* If the edge is determined to be never executed, redirect it\n+     to BUILTIN_UNREACHABLE to save inliner from inlining into it.  */\n+  if (predicate && false_predicate_p (predicate) && e->callee)\n+    {\n+      struct cgraph_node *callee = !e->inline_failed ? e->callee : NULL;\n+\n+      cgraph_redirect_edge_callee (e,\n+\t\t\t\t   cgraph_get_create_node\n+\t\t\t\t     (builtin_decl_implicit (BUILT_IN_UNREACHABLE)));\n+      e->inline_failed = CIF_UNREACHABLE;\n+      if (callee)\n+\tcgraph_remove_node_and_inline_clones (callee, NULL);\n+    }\n   if (predicate && !true_predicate_p (predicate))\n     {\n       if (!es->predicate)\n@@ -1724,12 +1738,20 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n-\t  struct predicate p = add_condition (summary, index, &aggpos,\n-\t\t\t\t\t      e->flags & EDGE_TRUE_VALUE\n-\t\t\t\t\t      ? code : inverted_code,\n-\t\t\t\t\t      gimple_cond_rhs (last));\n-\t  e->aux = pool_alloc (edge_predicate_pool);\n-\t  *(struct predicate *) e->aux = p;\n+\t  enum tree_code this_code = (e->flags & EDGE_TRUE_VALUE\n+\t\t\t\t      ? code : inverted_code);\n+\t  /* invert_tree_comparison will return ERROR_MARK on FP\n+\t     comparsions that are not EQ/NE instead of returning proper\n+\t     unordered one.  Be sure it is not confused with NON_CONSTANT.  */\n+\t  if (this_code != ERROR_MARK)\n+\t    {\n+\t      struct predicate p = add_condition (summary, index, &aggpos,\n+\t\t\t\t\t\t  e->flags & EDGE_TRUE_VALUE\n+\t\t\t\t\t\t  ? code : inverted_code,\n+\t\t\t\t\t\t  gimple_cond_rhs (last));\n+\t      e->aux = pool_alloc (edge_predicate_pool);\n+\t      *(struct predicate *) e->aux = p;\n+\t    }\n \t}\n     }\n "}, {"sha": "da83c4014e42721a0c4c770641a46df3e09be435", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "patch": "@@ -1685,7 +1685,7 @@ inline_small_functions (void)\n       edge = (struct cgraph_edge *) fibheap_extract_min (edge_heap);\n       gcc_assert (edge->aux);\n       edge->aux = NULL;\n-      if (!edge->inline_failed)\n+      if (!edge->inline_failed || !edge->callee->analyzed)\n \tcontinue;\n \n       /* Be sure that caches are maintained consistent.  "}, {"sha": "48136d22b52cabb5489b8a7bdf8f099a10dd78fe", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "patch": "@@ -285,7 +285,8 @@ static inline int\n estimate_edge_growth (struct cgraph_edge *edge)\n {\n #ifdef ENABLE_CHECKING\n-  gcc_checking_assert (inline_edge_summary (edge)->call_stmt_size);\n+  gcc_checking_assert (inline_edge_summary (edge)->call_stmt_size\n+\t\t       || !edge->callee->analyzed);\n #endif\n   return (estimate_edge_size (edge)\n \t  - inline_edge_summary (edge)->call_stmt_size);"}, {"sha": "9c745e10834c52115437acdc994e0f2ad340018a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "patch": "@@ -1,3 +1,8 @@\n+2014-03-25  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/60315\n+\t* testsuite/g++.dg/torture/pr60315.C: New testcase.\n+\n 2014-03-25  Martin Jambor  <mjambor@suse.cz>\n \n \tPR ipa/60600"}, {"sha": "7f1226085047c384488ff73ffd91a37a7c9b5a8b", "filename": "gcc/testsuite/g++.dg/torture/pr60315.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60315.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de6f6c3eed463e8c41b95a28ad7f2186e379fff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60315.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60315.C?ref=9de6f6c3eed463e8c41b95a28ad7f2186e379fff", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile }\n+struct Base {\n+    virtual int f() = 0;\n+};\n+\n+struct Derived : public Base {\n+    virtual int f() final override {\n+        return 42;\n+    }\n+};\n+\n+extern Base* b;\n+\n+int main() {\n+    return (static_cast<Derived*>(b)->*(&Derived::f))();\n+}\n+// { dg-do compile }\n+struct Base {\n+    virtual int f() = 0;\n+};\n+\n+struct Derived : public Base {\n+    virtual int f() final override {\n+        return 42;\n+    }\n+};\n+\n+extern Base* b;\n+\n+int main() {\n+    return (static_cast<Derived*>(b)->*(&Derived::f))();\n+}"}]}