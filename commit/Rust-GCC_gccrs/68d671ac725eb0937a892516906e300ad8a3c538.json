{"sha": "68d671ac725eb0937a892516906e300ad8a3c538", "node_id": "C_kwDOANBUbNoAKDY4ZDY3MWFjNzI1ZWIwOTM3YTg5MjUxNjkwNmUzMDBhZDhhM2M1Mzg", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-01-30T18:19:07Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-04-06T08:47:21Z"}, "message": "gccrs: Refactor the type unification code\n\nThis refactors the unification systems to be a consistent interface using\nswitch statements and simple functions instead of the old clunky visitor\nsystem. This is more maintainable as it is harder to miss cases when we\ncan take advantages of switch statements.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>\n\ngcc/rust/ChangeLog:\n\n\t* Make-lang.in: update names\n\t* backend/rust-compile-expr.cc (CompileExpr::resolve_method_address):\n\tupdate to use new interface\n\t* typecheck/rust-coercion.cc (TypeCoercionRules::coerce_borrowed_pointer): likewise\n\t* typecheck/rust-hir-type-check-base.cc (TypeCheckBase::unify_site): likewise\n\t* typecheck/rust-tyty.cc (BaseType::destructure): likewise\n\t(InferType::unify): removed old unify interface\n\t(ErrorType::unify): likewise\n\t(ADTType::unify): likewise\n\t(TupleType::unify): likewise\n\t(FnType::unify): likewise\n\t(FnPtr::unify): likewise\n\t(ClosureType::unify): likewise\n\t(ArrayType::unify): likewise\n\t(SliceType::unify): likewise\n\t(BoolType::unify): likewise\n\t(IntType::unify): likewise\n\t(UintType::unify): likewise\n\t(FloatType::unify): likewise\n\t(USizeType::unify): likewise\n\t(ISizeType::unify): likewise\n\t(CharType::unify): likewise\n\t(ReferenceType::unify): likewise\n\t(PointerType::unify): likewise\n\t(ParamType::unify): likewise\n\t(StrType::unify): likewise\n\t(NeverType::unify): likewise\n\t(PlaceholderType::unify): likewise\n\t(ProjectionType::unify): likewise\n\t(DynamicObjectType::unify): likewise\n\t* typecheck/rust-tyty.h: update destructure interface\n\t* typecheck/rust-tyty-rules.h: Removed.\n\t* typecheck/rust-unify.cc: New file.\n\t* typecheck/rust-unify.h: New file.\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/never_type_err1.rs: Moved to...\n\t* rust/compile/never_type1.rs: ...here. It now works", "tree": {"sha": "accf7cc2ee74f71bc984454badd328fb553ebb59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/accf7cc2ee74f71bc984454badd328fb553ebb59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68d671ac725eb0937a892516906e300ad8a3c538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d671ac725eb0937a892516906e300ad8a3c538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68d671ac725eb0937a892516906e300ad8a3c538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d671ac725eb0937a892516906e300ad8a3c538/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42c28bcfdde1f81c4908c08ee5e2da6e1c4bd93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e42c28bcfdde1f81c4908c08ee5e2da6e1c4bd93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e42c28bcfdde1f81c4908c08ee5e2da6e1c4bd93"}], "stats": {"total": 3428, "additions": 1807, "deletions": 1621}, "files": [{"sha": "1d2f34d791952afa6a73fa3087e727ecc8c6549d", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=68d671ac725eb0937a892516906e300ad8a3c538", "patch": "@@ -134,6 +134,7 @@ GRS_OBJS = \\\n     rust/rust-hir-path-probe.o \\\n     rust/rust-coercion.o \\\n     rust/rust-casts.o \\\n+    rust/rust-unify.o \\\n     rust/rust-hir-type-check-base.o \\\n     rust/rust-autoderef.o \\\n     rust/rust-substitution-mapper.o \\"}, {"sha": "d7945dbf26b5226c082980b3d07a931cad344100", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=68d671ac725eb0937a892516906e300ad8a3c538", "patch": "@@ -26,6 +26,7 @@\n #include \"rust-compile-block.h\"\n #include \"rust-compile-implitem.h\"\n #include \"rust-constexpr.h\"\n+#include \"rust-unify.h\"\n #include \"rust-gcc.h\"\n \n #include \"fold-const.h\"\n@@ -2006,7 +2007,10 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n \t{\n \t  TyTy::BaseType *infer_impl_call\n \t    = candidate_call->infer_substitions (expr_locus);\n-\t  monomorphized = infer_impl_call->unify (fntype);\n+\t  monomorphized = Resolver::UnifyRules::Resolve (\n+\t    TyTy::TyWithLocation (infer_impl_call),\n+\t    TyTy::TyWithLocation (fntype), expr_locus, true /* commit */,\n+\t    true /* emit_errors */);\n \t}\n \n       return CompileInherentImplItem::Compile (impl_item, ctx, monomorphized);"}, {"sha": "bea40840fbffc028739930a9a89a6be8fd79f10f", "filename": "gcc/rust/typecheck/rust-coercion.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc?ref=68d671ac725eb0937a892516906e300ad8a3c538", "patch": "@@ -18,6 +18,7 @@\n \n #include \"rust-hir-type-check-base.h\"\n #include \"rust-coercion.h\"\n+#include \"rust-unify.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -218,7 +219,10 @@ TypeCoercionRules::coerce_borrowed_pointer (TyTy::BaseType *receiver,\n \t// we might be able to replace this with a can_eq because we default\n \t// back to a final unity anyway\n \trust_debug (\"coerce_borrowed_pointer -- unify\");\n-\tTyTy::BaseType *result = receiver->unify (expected);\n+\tTyTy::BaseType *result\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (receiver),\n+\t\t\t\t TyTy::TyWithLocation (expected), locus,\n+\t\t\t\t true /* commit */, true /* emit_errors */);\n \treturn CoercionResult{{}, result};\n       }\n     }"}, {"sha": "6e42b7b7b232501e3d339a4a22d26aec5bfe46af", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=68d671ac725eb0937a892516906e300ad8a3c538", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-implitem.h\"\n #include \"rust-coercion.h\"\n+#include \"rust-unify.h\"\n #include \"rust-casts.h\"\n \n namespace Rust {\n@@ -359,18 +360,8 @@ TypeCheckBase::unify_site (HirId id, TyTy::TyWithLocation lhs,\n   rust_debug (\"unify_site id={%u} expected={%s} expr={%s}\", id,\n \t      expected->debug_str ().c_str (), expr->debug_str ().c_str ());\n \n-  TyTy::BaseType *unified = expected->unify (expr);\n-  if (unified->get_kind () == TyTy::TypeKind::ERROR)\n-    {\n-      RichLocation r (unify_locus);\n-      r.add_range (lhs.get_locus ());\n-      r.add_range (rhs.get_locus ());\n-      rust_error_at (r, \"expected %<%s%> got %<%s%>\",\n-\t\t     expected->get_name ().c_str (),\n-\t\t     expr->get_name ().c_str ());\n-    }\n-\n-  return unified;\n+  return UnifyRules::Resolve (lhs, rhs, unify_locus, true /*commit*/,\n+\t\t\t      true /*emit_error*/);\n }\n \n TyTy::BaseType *"}, {"sha": "cfe269221bd2135b40c6395a5b647c1315f32e79", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "removed", "additions": 0, "deletions": 1406, "changes": 1406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42c28bcfdde1f81c4908c08ee5e2da6e1c4bd93/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42c28bcfdde1f81c4908c08ee5e2da6e1c4bd93/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=e42c28bcfdde1f81c4908c08ee5e2da6e1c4bd93", "patch": "@@ -1,1406 +0,0 @@\n-// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_TYTY_RULES\n-#define RUST_TYTY_RULES\n-\n-#include \"rust-diagnostics.h\"\n-#include \"rust-tyty.h\"\n-#include \"rust-tyty-visitor.h\"\n-#include \"rust-hir-map.h\"\n-#include \"rust-hir-type-check.h\"\n-\n-namespace Rust {\n-namespace TyTy {\n-\n-/* Rules specify how to unify two Ty. For example, the result of unifying the\n-   two tuples (u64, A) and (B, i64) would be (u64, i64).\n-\n-   Performing a unification requires a double dispatch. To illustrate, suppose\n-   we want to unify `ty1` and `ty2`. Here's what it looks like:\n-     1. The caller calls `ty1.unify(ty2)`. This is the first dispatch.\n-     2. `ty1` creates a rule specific to its type(e.g. TupleRules).\n-     3. The rule calls `ty2.accept_vis(rule)`. This is the second dispatch.\n-     4. `ty2` calls `rule.visit(*this)`, which will method-overload to the\n-\t      correct implementation at compile time.\n-\n-   The nice thing about Rules is that they seperate unification logic from the\n-   representation of Ty. To support unifying a new Ty, implement its\n-   `accept_vis` and `unify` method to pass the unification request to Rules.\n-   Then, create a new `XXXRules` class and implement one `visit` method for\n-   every Ty it can unify with. */\n-class BaseRules : public TyVisitor\n-{\n-public:\n-  virtual ~BaseRules () {}\n-\n-  /* Unify two ty. Returns a pointer to the newly-created unified ty, or nullptr\n-     if the two types cannot be unified. The caller is responsible for releasing\n-     the memory of the returned ty.\n-\n-     This method is meant to be used internally by Ty. If you're trying to unify\n-     two ty, you can simply call `unify` on ty themselves. */\n-  virtual BaseType *unify (BaseType *other)\n-  {\n-    if (other->get_kind () == TypeKind::PARAM)\n-      {\n-\tParamType *p = static_cast<ParamType *> (other);\n-\tother = p->resolve ();\n-      }\n-    else if (other->get_kind () == TypeKind::PLACEHOLDER)\n-      {\n-\tPlaceholderType *p = static_cast<PlaceholderType *> (other);\n-\tif (p->can_resolve ())\n-\t  {\n-\t    other = p->resolve ();\n-\t    return get_base ()->unify (other);\n-\t  }\n-      }\n-    else if (other->get_kind () == TypeKind::PROJECTION)\n-      {\n-\tProjectionType *p = static_cast<ProjectionType *> (other);\n-\tother = p->get ();\n-\treturn get_base ()->unify (other);\n-      }\n-\n-    other->accept_vis (*this);\n-    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n-      return resolved;\n-\n-    resolved->append_reference (get_base ()->get_ref ());\n-    resolved->append_reference (other->get_ref ());\n-    for (auto ref : get_base ()->get_combined_refs ())\n-      resolved->append_reference (ref);\n-    for (auto ref : other->get_combined_refs ())\n-      resolved->append_reference (ref);\n-\n-    other->append_reference (resolved->get_ref ());\n-    other->append_reference (get_base ()->get_ref ());\n-    get_base ()->append_reference (resolved->get_ref ());\n-    get_base ()->append_reference (other->get_ref ());\n-\n-    bool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n-    bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n-    bool results_is_non_general_infer_var\n-      = (result_is_infer_var\n-\t && (static_cast<InferType *> (resolved))->get_infer_kind ()\n-\t      != TyTy::InferType::GENERAL);\n-    if (result_resolved || results_is_non_general_infer_var)\n-      {\n-\tfor (auto &ref : resolved->get_combined_refs ())\n-\t  {\n-\t    TyTy::BaseType *ref_tyty = nullptr;\n-\t    bool ok = context->lookup_type (ref, &ref_tyty);\n-\t    if (!ok)\n-\t      continue;\n-\n-\t    // if any of the types are inference variables lets fix them\n-\t    if (ref_tyty->get_kind () == TyTy::TypeKind::INFER)\n-\t      {\n-\t\tcontext->insert_type (\n-\t\t  Analysis::NodeMapping (mappings->get_current_crate (),\n-\t\t\t\t\t UNKNOWN_NODEID, ref,\n-\t\t\t\t\t UNKNOWN_LOCAL_DEFID),\n-\t\t  resolved->clone ());\n-\t      }\n-\t  }\n-      }\n-    return resolved;\n-  }\n-\n-  virtual void visit (TupleType &) override {}\n-\n-  virtual void visit (ADTType &) override {}\n-\n-  virtual void visit (InferType &) override {}\n-\n-  virtual void visit (FnType &) override {}\n-\n-  virtual void visit (FnPtr &) override {}\n-\n-  virtual void visit (ArrayType &) override {}\n-\n-  virtual void visit (SliceType &) override {}\n-\n-  virtual void visit (BoolType &) override {}\n-\n-  virtual void visit (IntType &) override {}\n-\n-  virtual void visit (UintType &) override {}\n-\n-  virtual void visit (USizeType &) override {}\n-\n-  virtual void visit (ISizeType &) override {}\n-\n-  virtual void visit (FloatType &) override {}\n-\n-  virtual void visit (ErrorType &) override {}\n-\n-  virtual void visit (CharType &) override {}\n-\n-  virtual void visit (ReferenceType &) override {}\n-\n-  virtual void visit (PointerType &) override {}\n-\n-  virtual void visit (ParamType &) override {}\n-\n-  virtual void visit (StrType &) override {}\n-\n-  virtual void visit (NeverType &) override {}\n-\n-  virtual void visit (PlaceholderType &) override {}\n-\n-  virtual void visit (ProjectionType &) override {}\n-\n-  virtual void visit (DynamicObjectType &) override {}\n-\n-  virtual void visit (ClosureType &) override {}\n-\n-protected:\n-  BaseRules (BaseType *base)\n-    : mappings (Analysis::Mappings::get ()),\n-      context (Resolver::TypeCheckContext::get ()),\n-      resolved (new ErrorType (base->get_ref (), base->get_ref ()))\n-  {}\n-\n-  Analysis::Mappings *mappings;\n-  Resolver::TypeCheckContext *context;\n-\n-  /* Temporary storage for the result of a unification.\n-     We could return the result directly instead of storing it in the rule\n-     object, but that involves modifying the visitor pattern to accommodate\n-     the return value, which is too complex. */\n-  BaseType *resolved;\n-\n-private:\n-  /* Returns a pointer to the ty that created this rule. */\n-  virtual BaseType *get_base () = 0;\n-};\n-\n-class InferRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  InferRules (InferType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (BoolType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (IntType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (UintType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (USizeType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (ISizeType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (FloatType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (ArrayType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (SliceType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (ADTType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (TupleType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    switch (base->get_infer_kind ())\n-      {\n-      case InferType::InferTypeKind::GENERAL:\n-\tresolved = type.clone ();\n-\treturn;\n-\n-\tcase InferType::InferTypeKind::INTEGRAL: {\n-\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n-\t    {\n-\t      resolved = type.clone ();\n-\t      return;\n-\t    }\n-\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n-\t    {\n-\t      resolved = base->clone ();\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-\n-\tcase InferType::InferTypeKind::FLOAT: {\n-\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-\t    {\n-\t      resolved = type.clone ();\n-\t      return;\n-\t    }\n-\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n-\t    {\n-\t      resolved = base->clone ();\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (CharType &type) override\n-  {\n-    {\n-      bool is_valid\n-\t= (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-      if (is_valid)\n-\t{\n-\t  resolved = type.clone ();\n-\t  return;\n-\t}\n-\n-      BaseRules::visit (type);\n-    }\n-  }\n-\n-  void visit (ReferenceType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (PointerType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (ParamType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (DynamicObjectType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (ClosureType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  InferType *base;\n-};\n-\n-class FnRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  FnRules (FnType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnType &type) override\n-  {\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto a = base->param_at (i).second;\n-\tauto b = type.param_at (i).second;\n-\n-\tauto unified_param = a->unify (b);\n-\tif (unified_param == nullptr)\n-\t  {\n-\t    BaseRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    auto unified_return\n-      = base->get_return_type ()->unify (type.get_return_type ());\n-    if (unified_return == nullptr)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FnType *base;\n-};\n-\n-class FnptrRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  FnptrRules (FnPtr *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnPtr &type) override\n-  {\n-    auto this_ret_type = base->get_return_type ();\n-    auto other_ret_type = type.get_return_type ();\n-    auto unified_result = this_ret_type->unify (other_ret_type);\n-    if (unified_result == nullptr\n-\t|| unified_result->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto this_param = base->param_at (i);\n-\tauto other_param = type.param_at (i);\n-\tauto unified_param = this_param->unify (other_param);\n-\tif (unified_param == nullptr\n-\t    || unified_param->get_kind () == TypeKind::ERROR)\n-\t  {\n-\t    BaseRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnType &type) override\n-  {\n-    auto this_ret_type = base->get_return_type ();\n-    auto other_ret_type = type.get_return_type ();\n-    auto unified_result = this_ret_type->unify (other_ret_type);\n-    if (unified_result == nullptr\n-\t|| unified_result->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto this_param = base->param_at (i);\n-\tauto other_param = type.param_at (i).second;\n-\tauto unified_param = this_param->unify (other_param);\n-\tif (unified_param == nullptr\n-\t    || unified_param->get_kind () == TypeKind::ERROR)\n-\t  {\n-\t    BaseRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FnPtr *base;\n-};\n-\n-class ClosureRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ClosureRules (ClosureType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (ClosureType &type) override\n-  {\n-    if (base->get_def_id () != type.get_def_id ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *args_res\n-      = base->get_parameters ().unify (&type.get_parameters ());\n-    if (args_res == nullptr || args_res->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *res\n-      = base->get_result_type ().unify (&type.get_result_type ());\n-    if (res == nullptr || res->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ClosureType *base;\n-};\n-\n-class ArrayRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ArrayRules (ArrayType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (ArrayType &type) override\n-  {\n-    // check base type\n-    auto base_resolved\n-      = base->get_element_type ()->unify (type.get_element_type ());\n-    if (base_resolved == nullptr)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved\n-      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n-\t\t       type.get_ident ().locus, type.get_capacity_expr (),\n-\t\t       TyVar (base_resolved->get_ref ()));\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ArrayType *base;\n-};\n-\n-class SliceRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  SliceRules (SliceType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (SliceType &type) override\n-  {\n-    // check base type\n-    auto base_resolved\n-      = base->get_element_type ()->unify (type.get_element_type ());\n-    if (base_resolved == nullptr)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new SliceType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t      type.get_ident ().locus,\n-\t\t\t      TyVar (base_resolved->get_ref ()));\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  SliceType *base;\n-};\n-\n-class BoolRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  BoolRules (BoolType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (BoolType &type) override\n-  {\n-    resolved = new BoolType (type.get_ref (), type.get_ty_ref ());\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    switch (type.get_infer_kind ())\n-      {\n-      case InferType::InferTypeKind::GENERAL:\n-\tresolved = base->clone ();\n-\tbreak;\n-\n-      default:\n-\tBaseRules::visit (type);\n-\tbreak;\n-      }\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  BoolType *base;\n-};\n-\n-class IntRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  IntRules (IntType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (IntType &type) override\n-  {\n-    if (type.get_int_kind () != base->get_int_kind ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved\n-      = new IntType (type.get_ref (), type.get_ty_ref (), type.get_int_kind ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  IntType *base;\n-};\n-\n-class UintRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  UintRules (UintType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (UintType &type) override\n-  {\n-    if (type.get_uint_kind () != base->get_uint_kind ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new UintType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t     type.get_uint_kind ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  UintType *base;\n-};\n-\n-class FloatRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  FloatRules (FloatType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FloatType &type) override\n-  {\n-    if (type.get_float_kind () != base->get_float_kind ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new FloatType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t      type.get_float_kind ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FloatType *base;\n-};\n-\n-class ADTRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ADTRules (ADTType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (ADTType &type) override\n-  {\n-    if (base->get_adt_kind () != type.get_adt_kind ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->number_of_variants () != type.number_of_variants ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < type.number_of_variants (); ++i)\n-      {\n-\tTyTy::VariantDef *a = base->get_variants ().at (i);\n-\tTyTy::VariantDef *b = type.get_variants ().at (i);\n-\n-\tif (a->num_fields () != b->num_fields ())\n-\t  {\n-\t    BaseRules::visit (type);\n-\t    return;\n-\t  }\n-\n-\tfor (size_t j = 0; j < a->num_fields (); j++)\n-\t  {\n-\t    TyTy::StructFieldType *base_field = a->get_field_at_index (j);\n-\t    TyTy::StructFieldType *other_field = b->get_field_at_index (j);\n-\n-\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n-\n-\t    BaseType *unified_ty = this_field_ty->unify (other_field_ty);\n-\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t      return;\n-\t  }\n-      }\n-\n-    // generic args for the unit-struct case\n-    if (type.is_unit () && base->is_unit ())\n-      {\n-\trust_assert (type.get_num_substitutions ()\n-\t\t     == base->get_num_substitutions ());\n-\n-\tfor (size_t i = 0; i < type.get_num_substitutions (); i++)\n-\t  {\n-\t    auto &a = base->get_substs ().at (i);\n-\t    auto &b = type.get_substs ().at (i);\n-\n-\t    auto pa = a.get_param_ty ();\n-\t    auto pb = b.get_param_ty ();\n-\n-\t    auto res = pa->unify (pb);\n-\t    if (res->get_kind () == TyTy::TypeKind::ERROR)\n-\t      {\n-\t\treturn;\n-\t      }\n-\t  }\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ADTType *base;\n-};\n-\n-class TupleRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  TupleRules (TupleType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (TupleType &type) override\n-  {\n-    if (base->num_fields () != type.num_fields ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    std::vector<TyVar> fields;\n-    for (size_t i = 0; i < base->num_fields (); i++)\n-      {\n-\tBaseType *bo = base->get_field (i);\n-\tBaseType *fo = type.get_field (i);\n-\n-\tBaseType *unified_ty = bo->unify (fo);\n-\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-\n-\tfields.push_back (TyVar (unified_ty->get_ref ()));\n-      }\n-\n-    resolved = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t\t    type.get_ident ().locus, fields);\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  TupleType *base;\n-};\n-\n-class USizeRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  USizeRules (USizeType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (USizeType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  USizeType *base;\n-};\n-\n-class ISizeRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ISizeRules (ISizeType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (ISizeType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ISizeType *base;\n-};\n-\n-class CharRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  CharRules (CharType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (CharType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  CharType *base;\n-};\n-\n-class ReferenceRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ReferenceRules (ReferenceType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (ReferenceType &type) override\n-  {\n-    auto base_type = base->get_base ();\n-    auto other_base_type = type.get_base ();\n-\n-    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n-    if (base_resolved == nullptr\n-\t|| base_resolved->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    // rust is permissive about mutablity here you can always go from mutable to\n-    // immutable but not the otherway round\n-    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n-    if (!mutability_ok)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new ReferenceType (base->get_ref (), base->get_ty_ref (),\n-\t\t\t\t  TyVar (base_resolved->get_ref ()),\n-\t\t\t\t  base->mutability ());\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ReferenceType *base;\n-};\n-\n-class PointerRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  PointerRules (PointerType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (PointerType &type) override\n-  {\n-    auto base_type = base->get_base ();\n-    auto other_base_type = type.get_base ();\n-\n-    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n-    if (base_resolved == nullptr\n-\t|| base_resolved->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    // rust is permissive about mutablity here you can always go from mutable to\n-    // immutable but not the otherway round\n-    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n-    if (!mutability_ok)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new PointerType (base->get_ref (), base->get_ty_ref (),\n-\t\t\t\tTyVar (base_resolved->get_ref ()),\n-\t\t\t\tbase->mutability ());\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  PointerType *base;\n-};\n-\n-class ParamRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ParamRules (ParamType *base) : BaseRules (base), base (base) {}\n-\n-  // param types are a placeholder we shouldn't have cases where we unify\n-  // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n-  //\n-  // foo<i32>{ a: 123 }.\n-  // Then this enforces the i32 type to be referenced on the\n-  // field via an hirid.\n-  //\n-  // rust also allows for a = foo{a:123}; Where we can use an Inference Variable\n-  // to handle the typing of the struct\n-  BaseType *unify (BaseType *other) override final\n-  {\n-    if (!base->can_resolve ())\n-      return BaseRules::unify (other);\n-\n-    auto lookup = base->resolve ();\n-    return lookup->unify (other);\n-  }\n-\n-  void visit (ParamType &type) override\n-  {\n-    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ParamType *base;\n-};\n-\n-class StrRules : public BaseRules\n-{\n-  // FIXME we will need a enum for the StrType like ByteBuf etc..\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  StrRules (StrType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (StrType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  StrType *base;\n-};\n-\n-class NeverRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  NeverRules (NeverType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (NeverType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  NeverType *base;\n-};\n-\n-class PlaceholderRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  PlaceholderRules (PlaceholderType *base) : BaseRules (base), base (base) {}\n-\n-  BaseType *unify (BaseType *other) override final\n-  {\n-    if (!base->can_resolve ())\n-      return BaseRules::unify (other);\n-\n-    BaseType *lookup = base->resolve ();\n-    return lookup->unify (other);\n-  }\n-\n-  void visit (PlaceholderType &type) override\n-  {\n-    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  PlaceholderType *base;\n-};\n-\n-class DynamicRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  DynamicRules (DynamicObjectType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-  void visit (DynamicObjectType &type) override\n-  {\n-    if (base->num_specified_bounds () != type.num_specified_bounds ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    if (!base->bounds_compatible (type, ref_locus, true))\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  DynamicObjectType *base;\n-};\n-\n-} // namespace TyTy\n-} // namespace Rust\n-\n-#endif // RUST_TYTY_RULES"}, {"sha": "fe5aa2b059c0cdf9710c9b23228571242f0ad7f0", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 60, "deletions": 169, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=68d671ac725eb0937a892516906e300ad8a3c538", "patch": "@@ -30,7 +30,6 @@\n #include \"rust-hir-trait-reference.h\"\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-trait-resolve.h\"\n-#include \"rust-tyty-rules.h\"\n #include \"rust-tyty-cmp.h\"\n \n #include \"options.h\"\n@@ -376,6 +375,58 @@ BaseType::get_root () const\n   return root;\n }\n \n+BaseType *\n+BaseType::destructure ()\n+{\n+  int recurisve_ops = 0;\n+  BaseType *x = this;\n+  while (true)\n+    {\n+      if (recurisve_ops++ >= rust_max_recursion_depth)\n+\t{\n+\t  rust_error_at (\n+\t    Location (),\n+\t    \"%<recursion depth%> count exceeds limit of %i (use \"\n+\t    \"%<frust-max-recursion-depth=%> to increase the limit)\",\n+\t    rust_max_recursion_depth);\n+\t  return new ErrorType (get_ref ());\n+\t}\n+\n+      switch (x->get_kind ())\n+\t{\n+\t  case TyTy::TypeKind::PARAM: {\n+\t    TyTy::ParamType *p = static_cast<TyTy::ParamType *> (x);\n+\t    TyTy::BaseType *pr = p->resolve ();\n+\t    if (pr == x)\n+\t      return pr;\n+\n+\t    x = pr;\n+\t  }\n+\t  break;\n+\n+\t  case TyTy::TypeKind::PLACEHOLDER: {\n+\t    TyTy::PlaceholderType *p = static_cast<TyTy::PlaceholderType *> (x);\n+\t    if (!p->can_resolve ())\n+\t      return p;\n+\n+\t    x = p->resolve ();\n+\t  }\n+\t  break;\n+\n+\t  case TyTy::TypeKind::PROJECTION: {\n+\t    TyTy::ProjectionType *p = static_cast<TyTy::ProjectionType *> (x);\n+\t    x = p->get ();\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  return x;\n+\t}\n+    }\n+\n+  return x;\n+}\n+\n const BaseType *\n BaseType::destructure () const\n {\n@@ -397,14 +448,20 @@ BaseType::destructure () const\n \t{\n \t  case TyTy::TypeKind::PARAM: {\n \t    const TyTy::ParamType *p = static_cast<const TyTy::ParamType *> (x);\n-\t    x = p->resolve ();\n+\t    const TyTy::BaseType *pr = p->resolve ();\n+\t    if (pr == x)\n+\t      return pr;\n+\n+\t    x = pr;\n \t  }\n \t  break;\n \n \t  case TyTy::TypeKind::PLACEHOLDER: {\n \t    const TyTy::PlaceholderType *p\n \t      = static_cast<const TyTy::PlaceholderType *> (x);\n-\t    rust_assert (p->can_resolve ());\n+\t    if (!p->can_resolve ())\n+\t      return p;\n+\n \t    x = p->resolve ();\n \t  }\n \t  break;\n@@ -512,13 +569,6 @@ InferType::as_string () const\n   return \"<infer::error>\";\n }\n \n-BaseType *\n-InferType::unify (BaseType *other)\n-{\n-  InferRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n InferType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -637,12 +687,6 @@ ErrorType::as_string () const\n   return \"<tyty::error>\";\n }\n \n-BaseType *\n-ErrorType::unify (BaseType *other)\n-{\n-  return this;\n-}\n-\n bool\n ErrorType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1009,13 +1053,6 @@ ADTType::as_string () const\n   return identifier + subst_as_string () + \"{\" + variants_buffer + \"}\";\n }\n \n-BaseType *\n-ADTType::unify (BaseType *other)\n-{\n-  ADTRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ADTType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1278,13 +1315,6 @@ TupleType::get_field (size_t index) const\n   return fields.at (index).get_tyty ();\n }\n \n-BaseType *\n-TupleType::unify (BaseType *other)\n-{\n-  TupleRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n TupleType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1385,13 +1415,6 @@ FnType::as_string () const\n   return \"fn\" + subst_as_string () + \" (\" + params_str + \") -> \" + ret_str;\n }\n \n-BaseType *\n-FnType::unify (BaseType *other)\n-{\n-  FnRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n FnType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1616,13 +1639,6 @@ FnPtr::as_string () const\n   return \"fnptr (\" + params_str + \") -> \" + get_return_type ()->as_string ();\n }\n \n-BaseType *\n-FnPtr::unify (BaseType *other)\n-{\n-  FnptrRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n FnPtr::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1696,13 +1712,6 @@ ClosureType::as_string () const\n   return \"|\" + params_buf + \"| {\" + result_type.get_tyty ()->as_string () + \"}\";\n }\n \n-BaseType *\n-ClosureType::unify (BaseType *other)\n-{\n-  ClosureRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ClosureType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1812,13 +1821,6 @@ ArrayType::as_string () const\n   return \"[\" + get_element_type ()->as_string () + \":\" + \"CAPACITY\" + \"]\";\n }\n \n-BaseType *\n-ArrayType::unify (BaseType *other)\n-{\n-  ArrayRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ArrayType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1895,13 +1897,6 @@ SliceType::as_string () const\n   return \"[\" + get_element_type ()->as_string () + \"]\";\n }\n \n-BaseType *\n-SliceType::unify (BaseType *other)\n-{\n-  SliceRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n SliceType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2006,13 +2001,6 @@ BoolType::as_string () const\n   return \"bool\";\n }\n \n-BaseType *\n-BoolType::unify (BaseType *other)\n-{\n-  BoolRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n BoolType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2094,13 +2082,6 @@ IntType::as_string () const\n   return \"__unknown_int_type\";\n }\n \n-BaseType *\n-IntType::unify (BaseType *other)\n-{\n-  IntRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n IntType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2200,13 +2181,6 @@ UintType::as_string () const\n   return \"__unknown_uint_type\";\n }\n \n-BaseType *\n-UintType::unify (BaseType *other)\n-{\n-  UintRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n UintType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2306,13 +2280,6 @@ FloatType::as_string () const\n   return \"__unknown_float_type\";\n }\n \n-BaseType *\n-FloatType::unify (BaseType *other)\n-{\n-  FloatRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n FloatType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2389,13 +2356,6 @@ USizeType::as_string () const\n   return \"usize\";\n }\n \n-BaseType *\n-USizeType::unify (BaseType *other)\n-{\n-  USizeRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n USizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2461,13 +2421,6 @@ ISizeType::as_string () const\n   return \"isize\";\n }\n \n-BaseType *\n-ISizeType::unify (BaseType *other)\n-{\n-  ISizeRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ISizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2533,13 +2486,6 @@ CharType::as_string () const\n   return \"char\";\n }\n \n-BaseType *\n-CharType::unify (BaseType *other)\n-{\n-  CharRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n CharType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2655,13 +2601,6 @@ ReferenceType::get_name () const\n \t + get_base ()->get_name ();\n }\n \n-BaseType *\n-ReferenceType::unify (BaseType *other)\n-{\n-  ReferenceRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ReferenceType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2821,13 +2760,6 @@ PointerType::get_name () const\n \t + get_base ()->get_name ();\n }\n \n-BaseType *\n-PointerType::unify (BaseType *other)\n-{\n-  PointerRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n PointerType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2964,13 +2896,6 @@ ParamType::get_name () const\n   return resolve ()->get_name ();\n }\n \n-BaseType *\n-ParamType::unify (BaseType *other)\n-{\n-  ParamRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ParamType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -3130,13 +3055,6 @@ StrType::as_string () const\n   return \"str\";\n }\n \n-BaseType *\n-StrType::unify (BaseType *other)\n-{\n-  StrRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n StrType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -3202,13 +3120,6 @@ NeverType::as_string () const\n   return \"!\";\n }\n \n-BaseType *\n-NeverType::unify (BaseType *other)\n-{\n-  NeverRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n NeverType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -3295,13 +3206,6 @@ PlaceholderType::as_string () const\n \t + \">\";\n }\n \n-BaseType *\n-PlaceholderType::unify (BaseType *other)\n-{\n-  PlaceholderRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n PlaceholderType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -3465,12 +3369,6 @@ ProjectionType::as_string () const\n   return \"<Projection=\" + subst_as_string () + \"::\" + base->as_string () + \">\";\n }\n \n-BaseType *\n-ProjectionType::unify (BaseType *other)\n-{\n-  return base->unify (other);\n-}\n-\n bool\n ProjectionType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -3602,13 +3500,6 @@ DynamicObjectType::as_string () const\n   return \"dyn [\" + raw_bounds_as_string () + \"]\";\n }\n \n-BaseType *\n-DynamicObjectType::unify (BaseType *other)\n-{\n-  DynamicRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n DynamicObjectType::can_eq (const BaseType *other, bool emit_errors) const\n {"}, {"sha": "d2cf5b07fc155d2db9904d6eee9d8fea20a26947", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=68d671ac725eb0937a892516906e300ad8a3c538", "patch": "@@ -105,11 +105,6 @@ class BaseType : public TypeBoundsMappings\n \n   virtual std::string get_name () const = 0;\n \n-  // Unify two types. Returns a pointer to the newly-created unified ty, or\n-  // nullptr if the two ty cannot be unified. The caller is responsible for\n-  // releasing the memory of the returned ty.\n-  virtual BaseType *unify (BaseType *other) = 0;\n-\n   // similar to unify but does not actually perform type unification but\n   // determines whether they are compatible. Consider the following\n   //\n@@ -177,6 +172,7 @@ class BaseType : public TypeBoundsMappings\n \n   // This will get the monomorphized type from Params, Placeholders or\n   // Projections if available or error\n+  BaseType *destructure ();\n   const BaseType *destructure () const;\n \n   const RustIdent &get_ident () const;\n@@ -221,8 +217,6 @@ class InferType : public BaseType\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n-\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n@@ -255,7 +249,6 @@ class ErrorType : public BaseType\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n@@ -284,7 +277,6 @@ class ParamType : public BaseType\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n@@ -361,7 +353,6 @@ class TupleType : public BaseType\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -598,7 +589,6 @@ class ADTType : public BaseType, public SubstitutionRef\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -738,7 +728,6 @@ class FnType : public BaseType, public SubstitutionRef\n \n   std::string get_identifier () const { return identifier; }\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -858,7 +847,6 @@ class FnPtr : public BaseType\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -938,7 +926,6 @@ class ClosureType : public BaseType, public SubstitutionRef\n   std::string as_string () const override;\n   std::string get_name () const override final { return as_string (); }\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1007,7 +994,6 @@ class ArrayType : public BaseType\n \n   std::string get_name () const override final { return as_string (); }\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1055,7 +1041,6 @@ class SliceType : public BaseType\n \n   std::string get_name () const override final { return as_string (); }\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1089,7 +1074,6 @@ class BoolType : public BaseType\n \n   std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n@@ -1120,7 +1104,6 @@ class IntType : public BaseType\n \n   std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   IntKind get_int_kind () const;\n@@ -1159,7 +1142,6 @@ class UintType : public BaseType\n \n   std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   UintKind get_uint_kind () const;\n@@ -1194,7 +1176,6 @@ class FloatType : public BaseType\n   std::string as_string () const override;\n   std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   FloatKind get_float_kind () const;\n@@ -1222,7 +1203,6 @@ class USizeType : public BaseType\n   std::string as_string () const override;\n   std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n@@ -1243,7 +1223,6 @@ class ISizeType : public BaseType\n   std::string as_string () const override;\n   std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n@@ -1263,7 +1242,6 @@ class CharType : public BaseType\n   std::string as_string () const override;\n   std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n@@ -1284,7 +1262,6 @@ class StrType : public BaseType\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1311,7 +1288,6 @@ class ReferenceType : public BaseType\n \n   std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1354,7 +1330,6 @@ class PointerType : public BaseType\n   std::string as_string () const override;\n   std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1401,7 +1376,6 @@ class NeverType : public BaseType\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n@@ -1428,7 +1402,6 @@ class PlaceholderType : public BaseType\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n@@ -1478,7 +1451,6 @@ class ProjectionType : public BaseType, public SubstitutionRef\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n@@ -1524,7 +1496,6 @@ class DynamicObjectType : public BaseType\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;"}, {"sha": "072f76133bcf30c8bc9907a4871e85977cf2e6f7", "filename": "gcc/rust/typecheck/rust-unify.cc", "status": "added", "additions": 1640, "deletions": 0, "changes": 1640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-unify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-unify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-unify.cc?ref=68d671ac725eb0937a892516906e300ad8a3c538", "patch": "@@ -0,0 +1,1640 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-unify.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+UnifyRules::UnifyRules (TyTy::TyWithLocation lhs, TyTy::TyWithLocation rhs,\n+\t\t\tLocation locus, bool commit_flag, bool emit_error)\n+  : lhs (lhs), rhs (rhs), locus (locus), commit_flag (commit_flag),\n+    emit_error (emit_error), mappings (*Analysis::Mappings::get ()),\n+    context (*TypeCheckContext::get ())\n+{}\n+\n+TyTy::BaseType *\n+UnifyRules::Resolve (TyTy::TyWithLocation lhs, TyTy::TyWithLocation rhs,\n+\t\t     Location locus, bool commit_flag, bool emit_error)\n+{\n+  UnifyRules r (lhs, rhs, locus, commit_flag, emit_error);\n+  TyTy::BaseType *result = r.go ();\n+\n+  if (r.commit_flag)\n+    r.commit (result);\n+\n+  bool failed = result->get_kind () == TyTy::TypeKind::ERROR;\n+  if (failed && r.emit_error)\n+    r.emit_type_mismatch ();\n+\n+  return result;\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::get_base ()\n+{\n+  return lhs.get_ty ()->destructure ();\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::get_other ()\n+{\n+  return rhs.get_ty ()->destructure ();\n+}\n+\n+void\n+UnifyRules::commit (TyTy::BaseType *resolved)\n+{\n+  resolved->append_reference (get_base ()->get_ref ());\n+  resolved->append_reference (get_other ()->get_ref ());\n+  for (auto ref : get_base ()->get_combined_refs ())\n+    resolved->append_reference (ref);\n+  for (auto ref : get_other ()->get_combined_refs ())\n+    resolved->append_reference (ref);\n+\n+  get_other ()->append_reference (resolved->get_ref ());\n+  get_other ()->append_reference (get_base ()->get_ref ());\n+  get_base ()->append_reference (resolved->get_ref ());\n+  get_base ()->append_reference (get_other ()->get_ref ());\n+\n+  bool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n+  bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n+  bool results_is_non_general_infer_var\n+    = (result_is_infer_var\n+       && (static_cast<TyTy::InferType *> (resolved))->get_infer_kind ()\n+\t    != TyTy::InferType::GENERAL);\n+  if (result_resolved || results_is_non_general_infer_var)\n+    {\n+      for (auto &ref : resolved->get_combined_refs ())\n+\t{\n+\t  TyTy::BaseType *ref_tyty = nullptr;\n+\t  bool ok = context.lookup_type (ref, &ref_tyty);\n+\t  if (!ok)\n+\t    continue;\n+\n+\t  // if any of the types are inference variables lets fix them\n+\t  if (ref_tyty->get_kind () == TyTy::TypeKind::INFER)\n+\t    {\n+\t      auto node = Analysis::NodeMapping (mappings.get_current_crate (),\n+\t\t\t\t\t\t UNKNOWN_NODEID, ref,\n+\t\t\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\t      context.insert_type (node, resolved->clone ());\n+\t    }\n+\t}\n+    }\n+}\n+\n+void\n+UnifyRules::emit_type_mismatch () const\n+{\n+  TyTy::BaseType *expected = lhs.get_ty ();\n+  TyTy::BaseType *expr = rhs.get_ty ();\n+\n+  RichLocation r (locus);\n+  r.add_range (lhs.get_locus ());\n+  r.add_range (rhs.get_locus ());\n+  rust_error_at (r, \"expected %<%s%> got %<%s%>\",\n+\t\t expected->get_name ().c_str (), expr->get_name ().c_str ());\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::go ()\n+{\n+  TyTy::BaseType *ltype = lhs.get_ty ();\n+  TyTy::BaseType *rtype = rhs.get_ty ();\n+\n+  ltype = lhs.get_ty ()->destructure ();\n+  rtype = rhs.get_ty ()->destructure ();\n+\n+  rust_debug (\"unify::go ltype={%s} rtype={%s}\", ltype->debug_str ().c_str (),\n+\t      rtype->debug_str ().c_str ());\n+\n+  switch (ltype->get_kind ())\n+    {\n+    case TyTy::INFER:\n+      return expect_inference_variable (static_cast<TyTy::InferType *> (ltype),\n+\t\t\t\t\trtype);\n+\n+    case TyTy::ADT:\n+      return expect_adt (static_cast<TyTy::ADTType *> (ltype), rtype);\n+\n+    case TyTy::STR:\n+      return expect_str (static_cast<TyTy::StrType *> (ltype), rtype);\n+\n+    case TyTy::REF:\n+      return expect_reference (static_cast<TyTy::ReferenceType *> (ltype),\n+\t\t\t       rtype);\n+\n+    case TyTy::POINTER:\n+      return expect_pointer (static_cast<TyTy::PointerType *> (ltype), rtype);\n+\n+    case TyTy::PARAM:\n+      return expect_param (static_cast<TyTy::ParamType *> (ltype), rtype);\n+\n+    case TyTy::ARRAY:\n+      return expect_array (static_cast<TyTy::ArrayType *> (ltype), rtype);\n+\n+    case TyTy::SLICE:\n+      return expect_slice (static_cast<TyTy::SliceType *> (ltype), rtype);\n+\n+    case TyTy::FNDEF:\n+      return expect_fndef (static_cast<TyTy::FnType *> (ltype), rtype);\n+\n+    case TyTy::FNPTR:\n+      return expect_fnptr (static_cast<TyTy::FnPtr *> (ltype), rtype);\n+\n+    case TyTy::TUPLE:\n+      return expect_tuple (static_cast<TyTy::TupleType *> (ltype), rtype);\n+\n+    case TyTy::BOOL:\n+      return expect_bool (static_cast<TyTy::BoolType *> (ltype), rtype);\n+\n+    case TyTy::CHAR:\n+      return expect_char (static_cast<TyTy::CharType *> (ltype), rtype);\n+\n+    case TyTy::INT:\n+      return expect_int (static_cast<TyTy::IntType *> (ltype), rtype);\n+\n+    case TyTy::UINT:\n+      return expect_uint (static_cast<TyTy::UintType *> (ltype), rtype);\n+\n+    case TyTy::FLOAT:\n+      return expect_float (static_cast<TyTy::FloatType *> (ltype), rtype);\n+\n+    case TyTy::USIZE:\n+      return expect_usize (static_cast<TyTy::USizeType *> (ltype), rtype);\n+\n+    case TyTy::ISIZE:\n+      return expect_isize (static_cast<TyTy::ISizeType *> (ltype), rtype);\n+\n+    case TyTy::NEVER:\n+      return expect_never (static_cast<TyTy::NeverType *> (ltype), rtype);\n+\n+    case TyTy::PLACEHOLDER:\n+      return expect_placeholder (static_cast<TyTy::PlaceholderType *> (ltype),\n+\t\t\t\t rtype);\n+\n+    case TyTy::PROJECTION:\n+      return expect_projection (static_cast<TyTy::ProjectionType *> (ltype),\n+\t\t\t\trtype);\n+\n+    case TyTy::DYNAMIC:\n+      return expect_dyn (static_cast<TyTy::DynamicObjectType *> (ltype), rtype);\n+\n+    case TyTy::CLOSURE:\n+      return expect_closure (static_cast<TyTy::ClosureType *> (ltype), rtype);\n+\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_inference_variable (TyTy::InferType *ltype,\n+\t\t\t\t       TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tswitch (ltype->get_infer_kind ())\n+\t  {\n+\t  case TyTy::InferType::InferTypeKind::GENERAL:\n+\t    return rtype->clone ();\n+\n+\t    case TyTy::InferType::InferTypeKind::INTEGRAL: {\n+\t      bool is_valid = r->get_infer_kind ()\n+\t\t\t\t== TyTy::InferType::InferTypeKind::INTEGRAL\n+\t\t\t      || r->get_infer_kind ()\n+\t\t\t\t   == TyTy::InferType::InferTypeKind::GENERAL;\n+\t      if (is_valid)\n+\t\treturn rtype->clone ();\n+\t    }\n+\t    break;\n+\n+\t    case TyTy::InferType::InferTypeKind::FLOAT: {\n+\t      bool is_valid\n+\t\t= r->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT\n+\t\t  || r->get_infer_kind ()\n+\t\t       == TyTy::InferType::InferTypeKind::GENERAL;\n+\t      if (is_valid)\n+\t\treturn rtype->clone ();\n+\t    }\n+\t    break;\n+\t  }\n+      }\n+      break;\n+\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+      case TyTy::ISIZE: {\n+\tbool is_valid = (ltype->get_infer_kind ()\n+\t\t\t == TyTy::InferType::InferTypeKind::GENERAL)\n+\t\t\t|| (ltype->get_infer_kind ()\n+\t\t\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+\tif (is_valid)\n+\t  return rtype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::FLOAT: {\n+\tbool is_valid = (ltype->get_infer_kind ()\n+\t\t\t == TyTy::InferType::InferTypeKind::GENERAL)\n+\t\t\t|| (ltype->get_infer_kind ()\n+\t\t\t    == TyTy::InferType::InferTypeKind::FLOAT);\n+\tif (is_valid)\n+\t  return rtype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+      case TyTy::CLOSURE: {\n+\tbool is_valid = (ltype->get_infer_kind ()\n+\t\t\t == TyTy::InferType::InferTypeKind::GENERAL);\n+\tif (is_valid)\n+\t  return rtype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_adt (TyTy::ADTType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::ADT: {\n+\tTyTy::ADTType &type = *static_cast<TyTy::ADTType *> (rtype);\n+\tif (ltype->get_adt_kind () != type.get_adt_kind ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tif (ltype->get_identifier ().compare (type.get_identifier ()) != 0)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tif (ltype->number_of_variants () != type.number_of_variants ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tfor (size_t i = 0; i < type.number_of_variants (); ++i)\n+\t  {\n+\t    TyTy::VariantDef *a = ltype->get_variants ().at (i);\n+\t    TyTy::VariantDef *b = type.get_variants ().at (i);\n+\n+\t    if (a->num_fields () != b->num_fields ())\n+\t      {\n+\t\treturn new TyTy::ErrorType (0);\n+\t      }\n+\n+\t    for (size_t j = 0; j < a->num_fields (); j++)\n+\t      {\n+\t\tTyTy::StructFieldType *base_field = a->get_field_at_index (j);\n+\t\tTyTy::StructFieldType *other_field = b->get_field_at_index (j);\n+\n+\t\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t\tTyTy::BaseType *unified_ty\n+\t\t  = UnifyRules::Resolve (TyTy::TyWithLocation (this_field_ty),\n+\t\t\t\t\t TyTy::TyWithLocation (other_field_ty),\n+\t\t\t\t\t locus, commit_flag,\n+\t\t\t\t\t false /* emit_error */);\n+\t\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t\t  {\n+\t\t    return new TyTy::ErrorType (0);\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\t// generic args for the unit-struct case\n+\tif (type.is_unit () && ltype->is_unit ())\n+\t  {\n+\t    rust_assert (type.get_num_substitutions ()\n+\t\t\t == ltype->get_num_substitutions ());\n+\n+\t    for (size_t i = 0; i < type.get_num_substitutions (); i++)\n+\t      {\n+\t\tauto &a = ltype->get_substs ().at (i);\n+\t\tauto &b = type.get_substs ().at (i);\n+\n+\t\tauto pa = a.get_param_ty ();\n+\t\tauto pb = b.get_param_ty ();\n+\n+\t\tauto res\n+\t\t  = UnifyRules::Resolve (TyTy::TyWithLocation (pa),\n+\t\t\t\t\t TyTy::TyWithLocation (pb), locus,\n+\t\t\t\t\t commit_flag, false /* emit_error */);\n+\t\tif (res->get_kind () == TyTy::TypeKind::ERROR)\n+\t\t  {\n+\t\t    return new TyTy::ErrorType (0);\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\treturn type.clone ();\n+      }\n+      break;\n+\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_str (TyTy::StrType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::STR:\n+      return rtype->clone ();\n+\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_reference (TyTy::ReferenceType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::REF: {\n+\tTyTy::ReferenceType &type = *static_cast<TyTy::ReferenceType *> (rtype);\n+\tauto base_type = ltype->get_base ();\n+\tauto other_base_type = type.get_base ();\n+\n+\tTyTy::BaseType *base_resolved\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (base_type),\n+\t\t\t\t TyTy::TyWithLocation (other_base_type), locus,\n+\t\t\t\t commit_flag, false /* emit_error */);\n+\tif (base_resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\t// rust is permissive about mutablity here you can always go from\n+\t// mutable to immutable but not the otherway round\n+\tbool mutability_ok = ltype->is_mutable () ? type.is_mutable () : true;\n+\tif (!mutability_ok)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn new TyTy::ReferenceType (ltype->get_ref (), ltype->get_ty_ref (),\n+\t\t\t\t\tTyTy::TyVar (base_resolved->get_ref ()),\n+\t\t\t\t\tltype->mutability ());\n+      }\n+      break;\n+\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_pointer (TyTy::PointerType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::POINTER: {\n+\tTyTy::PointerType &type = *static_cast<TyTy::PointerType *> (rtype);\n+\tauto base_type = ltype->get_base ();\n+\tauto other_base_type = type.get_base ();\n+\n+\tTyTy::BaseType *base_resolved\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (base_type),\n+\t\t\t\t TyTy::TyWithLocation (other_base_type), locus,\n+\t\t\t\t commit_flag, false /* emit_error */);\n+\tif (base_resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\t// rust is permissive about mutablity here you can always go from\n+\t// mutable to immutable but not the otherway round\n+\tbool mutability_ok = ltype->is_mutable () ? type.is_mutable () : true;\n+\tif (!mutability_ok)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn new TyTy::PointerType (ltype->get_ref (), ltype->get_ty_ref (),\n+\t\t\t\t      TyTy::TyVar (base_resolved->get_ref ()),\n+\t\t\t\t      ltype->mutability ());\n+      }\n+      break;\n+\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_param (TyTy::ParamType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::PARAM: {\n+\tTyTy::ParamType &type = *static_cast<TyTy::ParamType *> (rtype);\n+\t// bool symbol_matches\n+\t//   = ltype->get_symbol ().compare (type.get_symbol ()) == 0;\n+\t// // TODO\n+\t// // I think rustc checks a debruinj index\n+\t// if (symbol_matches)\n+\t//   {\n+\t//     return type.clone ();\n+\t//   }\n+\n+\t// matching symbol is not going to work when we mix symbol's and have\n+\t// nested generics\n+\n+\t// bounds match? FIXME\n+\n+\treturn type.clone ();\n+      }\n+      break;\n+\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_array (TyTy::ArrayType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::ARRAY: {\n+\tTyTy::ArrayType &type = *static_cast<TyTy::ArrayType *> (rtype);\n+\tTyTy::BaseType *element_unify = UnifyRules::Resolve (\n+\t  TyTy::TyWithLocation (ltype->get_element_type ()),\n+\t  TyTy::TyWithLocation (type.get_element_type ()), locus, commit_flag,\n+\t  false /* emit_error*/);\n+\n+\tif (element_unify->get_kind () != TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t\ttype.get_ident ().locus,\n+\t\t\t\t\ttype.get_capacity_expr (),\n+\t\t\t\t\tTyTy::TyVar (\n+\t\t\t\t\t  element_unify->get_ref ()));\n+\t  }\n+      }\n+      break;\n+\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_slice (TyTy::SliceType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::SLICE: {\n+\tTyTy::SliceType &type = *static_cast<TyTy::SliceType *> (rtype);\n+\tTyTy::BaseType *element_unify = UnifyRules::Resolve (\n+\t  TyTy::TyWithLocation (ltype->get_element_type ()),\n+\t  TyTy::TyWithLocation (type.get_element_type ()), locus, commit_flag,\n+\t  false /* emit_error*/);\n+\n+\tif (element_unify->get_kind () != TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::SliceType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t\ttype.get_ident ().locus,\n+\t\t\t\t\tTyTy::TyVar (\n+\t\t\t\t\t  element_unify->get_ref ()));\n+\t  }\n+      }\n+      break;\n+\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_fndef (TyTy::FnType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::FNDEF: {\n+\tTyTy::FnType &type = *static_cast<TyTy::FnType *> (rtype);\n+\tif (ltype->num_params () != type.num_params ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tfor (size_t i = 0; i < ltype->num_params (); i++)\n+\t  {\n+\t    auto a = ltype->param_at (i).second;\n+\t    auto b = type.param_at (i).second;\n+\n+\t    auto unified_param\n+\t      = UnifyRules::Resolve (TyTy::TyWithLocation (a),\n+\t\t\t\t     TyTy::TyWithLocation (b), locus,\n+\t\t\t\t     commit_flag, false /* emit_errors */);\n+\t    if (unified_param->get_kind () == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\treturn new TyTy::ErrorType (0);\n+\t      }\n+\t  }\n+\n+\tauto unified_return\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (\n+\t\t\t\t   ltype->get_return_type ()),\n+\t\t\t\t TyTy::TyWithLocation (type.get_return_type ()),\n+\t\t\t\t locus, commit_flag, false /* emit_errors */);\n+\tif (unified_return->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNPTR:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_fnptr (TyTy::FnPtr *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::FNPTR: {\n+\tTyTy::FnPtr &type = *static_cast<TyTy::FnPtr *> (rtype);\n+\tif (ltype->num_params () != type.num_params ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tfor (size_t i = 0; i < ltype->num_params (); i++)\n+\t  {\n+\t    auto a = ltype->param_at (i);\n+\t    auto b = type.param_at (i);\n+\n+\t    auto unified_param\n+\t      = UnifyRules::Resolve (TyTy::TyWithLocation (a),\n+\t\t\t\t     TyTy::TyWithLocation (b), locus,\n+\t\t\t\t     commit_flag, false /* emit_errors */);\n+\t    if (unified_param->get_kind () == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\treturn new TyTy::ErrorType (0);\n+\t      }\n+\t  }\n+\n+\tauto unified_return\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (\n+\t\t\t\t   ltype->get_return_type ()),\n+\t\t\t\t TyTy::TyWithLocation (type.get_return_type ()),\n+\t\t\t\t locus, commit_flag, false /* emit_errors */);\n+\tif (unified_return->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::FNDEF: {\n+\tTyTy::FnType &type = *static_cast<TyTy::FnType *> (rtype);\n+\tauto this_ret_type = ltype->get_return_type ();\n+\tauto other_ret_type = type.get_return_type ();\n+\n+\tauto unified_result\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (this_ret_type),\n+\t\t\t\t TyTy::TyWithLocation (other_ret_type), locus,\n+\t\t\t\t commit_flag, false /*emit_errors*/);\n+\tif (unified_result->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tif (ltype->num_params () != type.num_params ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tfor (size_t i = 0; i < ltype->num_params (); i++)\n+\t  {\n+\t    auto this_param = ltype->param_at (i);\n+\t    auto other_param = type.param_at (i).second;\n+\n+\t    auto unified_param\n+\t      = UnifyRules::Resolve (TyTy::TyWithLocation (this_param),\n+\t\t\t\t     TyTy::TyWithLocation (other_param), locus,\n+\t\t\t\t     commit_flag, false /* emit_errors */);\n+\t    if (unified_param->get_kind () == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\treturn new TyTy::ErrorType (0);\n+\t      }\n+\t  }\n+\n+\treturn ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_tuple (TyTy::TupleType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::TUPLE: {\n+\tTyTy::TupleType &type = *static_cast<TyTy::TupleType *> (rtype);\n+\tif (ltype->num_fields () != type.num_fields ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tstd::vector<TyTy::TyVar> fields;\n+\tfor (size_t i = 0; i < ltype->num_fields (); i++)\n+\t  {\n+\t    TyTy::BaseType *bo = ltype->get_field (i);\n+\t    TyTy::BaseType *fo = type.get_field (i);\n+\n+\t    TyTy::BaseType *unified_ty\n+\t      = UnifyRules::Resolve (TyTy::TyWithLocation (bo),\n+\t\t\t\t     TyTy::TyWithLocation (fo), locus,\n+\t\t\t\t     commit_flag, false /* emit_errors */);\n+\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return new TyTy::ErrorType (0);\n+\n+\t    fields.push_back (TyTy::TyVar (unified_ty->get_ref ()));\n+\t  }\n+\n+\treturn new TyTy::TupleType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t    type.get_ident ().locus, fields);\n+      }\n+      break;\n+\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_bool (TyTy::BoolType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::BOOL:\n+      return rtype->clone ();\n+\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_char (TyTy::CharType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::CHAR:\n+      return rtype->clone ();\n+\n+    case TyTy::INT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_int (TyTy::IntType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL\n+\t    || r->get_infer_kind () == TyTy::InferType::InferTypeKind::INTEGRAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::INT: {\n+\tTyTy::IntType &type = *static_cast<TyTy::IntType *> (rtype);\n+\tbool is_valid = ltype->get_int_kind () == type.get_int_kind ();\n+\tif (is_valid)\n+\t  return new TyTy::IntType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t    type.get_int_kind ());\n+      }\n+      break;\n+\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_uint (TyTy::UintType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL\n+\t    || r->get_infer_kind () == TyTy::InferType::InferTypeKind::INTEGRAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::UINT: {\n+\tTyTy::UintType &type = *static_cast<TyTy::UintType *> (rtype);\n+\tbool is_valid = ltype->get_uint_kind () == type.get_uint_kind ();\n+\tif (is_valid)\n+\t  return new TyTy::UintType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t     type.get_uint_kind ());\n+      }\n+      break;\n+\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_float (TyTy::FloatType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL\n+\t    || r->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::FLOAT: {\n+\tTyTy::FloatType &type = *static_cast<TyTy::FloatType *> (rtype);\n+\tbool is_valid = ltype->get_float_kind () == type.get_float_kind ();\n+\tif (is_valid)\n+\t  return new TyTy::FloatType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t      type.get_float_kind ());\n+      }\n+      break;\n+\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_isize (TyTy::ISizeType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () != TyTy::InferType::InferTypeKind::FLOAT;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::ISIZE:\n+      return rtype->clone ();\n+\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_usize (TyTy::USizeType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () != TyTy::InferType::InferTypeKind::FLOAT;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::USIZE:\n+      return rtype->clone ();\n+\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_never (TyTy::NeverType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::NEVER:\n+      return rtype->clone ();\n+\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::SLICE:\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_placeholder (TyTy::PlaceholderType *ltype,\n+\t\t\t\tTyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::PLACEHOLDER: {\n+\tTyTy::PlaceholderType &type\n+\t  = *static_cast<TyTy::PlaceholderType *> (rtype);\n+\tbool symbol_match\n+\t  = ltype->get_symbol ().compare (type.get_symbol ()) == 0;\n+\tif (symbol_match)\n+\t  {\n+\t    return type.clone ();\n+\t  }\n+      }\n+      break;\n+\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::SLICE:\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_projection (TyTy::ProjectionType *ltype,\n+\t\t\t       TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      // FIXME\n+    case TyTy::PROJECTION:\n+      gcc_unreachable ();\n+      break;\n+\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::SLICE:\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_dyn (TyTy::DynamicObjectType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::DYNAMIC: {\n+\tTyTy::DynamicObjectType &type\n+\t  = *static_cast<TyTy::DynamicObjectType *> (rtype);\n+\tif (ltype->num_specified_bounds () != type.num_specified_bounds ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tif (!ltype->bounds_compatible (type, locus, true))\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::CLOSURE:\n+    case TyTy::SLICE:\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_closure (TyTy::ClosureType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::CLOSURE: {\n+\tTyTy::ClosureType &type = *static_cast<TyTy::ClosureType *> (rtype);\n+\tif (ltype->get_def_id () != type.get_def_id ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tTyTy::BaseType *args_res\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (\n+\t\t\t\t   &ltype->get_parameters ()),\n+\t\t\t\t TyTy::TyWithLocation (&type.get_parameters ()),\n+\t\t\t\t locus, commit_flag, false /* emit_error */);\n+\tif (args_res->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tTyTy::BaseType *res = UnifyRules::Resolve (\n+\t  TyTy::TyWithLocation (&ltype->get_result_type ()),\n+\t  TyTy::TyWithLocation (&type.get_result_type ()), locus, commit_flag,\n+\t  false /* emit_error */);\n+\tif (res == nullptr || res->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::SLICE:\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "6e46b9642a60ae577aff78ded2ff5a5b3394f83a", "filename": "gcc/rust/typecheck/rust-unify.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-unify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Frust%2Ftypecheck%2Frust-unify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-unify.h?ref=68d671ac725eb0937a892516906e300ad8a3c538", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_UNIFY\n+#define RUST_UNIFY\n+\n+#include \"rust-tyty-util.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class UnifyRules\n+{\n+public:\n+  static TyTy::BaseType *Resolve (TyTy::TyWithLocation lhs,\n+\t\t\t\t  TyTy::TyWithLocation rhs, Location locus,\n+\t\t\t\t  bool commit_flag, bool emit_error);\n+\n+protected:\n+  TyTy::BaseType *expect_inference_variable (TyTy::InferType *ltype,\n+\t\t\t\t\t     TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_adt (TyTy::ADTType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_str (TyTy::StrType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_reference (TyTy::ReferenceType *ltype,\n+\t\t\t\t    TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_pointer (TyTy::PointerType *ltype,\n+\t\t\t\t  TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_param (TyTy::ParamType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_array (TyTy::ArrayType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_slice (TyTy::SliceType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_fndef (TyTy::FnType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_fnptr (TyTy::FnPtr *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_tuple (TyTy::TupleType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_bool (TyTy::BoolType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_char (TyTy::CharType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_int (TyTy::IntType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_uint (TyTy::UintType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_float (TyTy::FloatType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_isize (TyTy::ISizeType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_usize (TyTy::USizeType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_never (TyTy::NeverType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_placeholder (TyTy::PlaceholderType *ltype,\n+\t\t\t\t      TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_projection (TyTy::ProjectionType *ltype,\n+\t\t\t\t     TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_dyn (TyTy::DynamicObjectType *ltype,\n+\t\t\t      TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_closure (TyTy::ClosureType *ltype,\n+\t\t\t\t  TyTy::BaseType *rtype);\n+\n+private:\n+  UnifyRules (TyTy::TyWithLocation lhs, TyTy::TyWithLocation rhs,\n+\t      Location locus, bool commit_flag, bool emit_error);\n+\n+  void emit_type_mismatch () const;\n+  void commit (TyTy::BaseType *resolved);\n+  TyTy::BaseType *go ();\n+\n+  TyTy::BaseType *get_base ();\n+  TyTy::BaseType *get_other ();\n+\n+  TyTy::TyWithLocation lhs;\n+  TyTy::TyWithLocation rhs;\n+  Location locus;\n+  bool commit_flag;\n+  bool emit_error;\n+\n+  Analysis::Mappings &mappings;\n+  TypeCheckContext &context;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_UNIFY"}, {"sha": "8d56176fee3ec58b6734a35002fa7e634e71ef34", "filename": "gcc/testsuite/rust/compile/never_type1.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Ftestsuite%2Frust%2Fcompile%2Fnever_type1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d671ac725eb0937a892516906e300ad8a3c538/gcc%2Ftestsuite%2Frust%2Fcompile%2Fnever_type1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fnever_type1.rs?ref=68d671ac725eb0937a892516906e300ad8a3c538", "patch": "@@ -1,8 +1,7 @@\n fn test() {\n     let a;\n \n-    // FIXME: Unimplemented features\n-    a = if true { // { dg-error \"expected .T.. got .!.\" }\n+    a = if true {\n         return;\n     } else {\n         return;", "previous_filename": "gcc/testsuite/rust/compile/never_type_err1.rs"}]}