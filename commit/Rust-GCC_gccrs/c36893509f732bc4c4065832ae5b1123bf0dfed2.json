{"sha": "c36893509f732bc4c4065832ae5b1123bf0dfed2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM2ODkzNTA5ZjczMmJjNGM0MDY1ODMyYWU1YjExMjNiZjBkZmVkMg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2005-04-15T16:29:34Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2005-04-15T16:29:34Z"}, "message": "tree-ssa.texi: Grammer/abbreviation updates.\n\n\n\n2005-04-15  Andrew Macleod  <amacleod@redhat.com>\n\n\t* doc/tree-ssa.texi: Grammer/abbreviation updates.\n\nFrom-SVN: r98190", "tree": {"sha": "9bd608be33b9dbc9bb112884069a1c08035d5939", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bd608be33b9dbc9bb112884069a1c08035d5939"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c36893509f732bc4c4065832ae5b1123bf0dfed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c36893509f732bc4c4065832ae5b1123bf0dfed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c36893509f732bc4c4065832ae5b1123bf0dfed2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c36893509f732bc4c4065832ae5b1123bf0dfed2/comments", "author": null, "committer": null, "parents": [{"sha": "c764b8b1be5ae72fd733814be834fe4273386b28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c764b8b1be5ae72fd733814be834fe4273386b28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c764b8b1be5ae72fd733814be834fe4273386b28"}], "stats": {"total": 43, "additions": 27, "deletions": 16}, "files": [{"sha": "774ff0eab19f1917f9ac330577a857f647b4cb86", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36893509f732bc4c4065832ae5b1123bf0dfed2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36893509f732bc4c4065832ae5b1123bf0dfed2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c36893509f732bc4c4065832ae5b1123bf0dfed2", "patch": "@@ -1,3 +1,7 @@\n+2005-04-15  Andrew Macleod  <amacleod@redhat.com>\n+\n+\t* doc/tree-ssa.texi: Grammer/abbreviation updates.\n+\n 2005-04-15  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-vect-transform.c (vectorizable_store): Mark necessary"}, {"sha": "2665b839a8698ba74e4d0350686db6f7ea59920b", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36893509f732bc4c4065832ae5b1123bf0dfed2/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36893509f732bc4c4065832ae5b1123bf0dfed2/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=c36893509f732bc4c4065832ae5b1123bf0dfed2", "patch": "@@ -886,13 +886,13 @@ print_ops (tree stmt)\n @}\n @end smallexample\n \n-Operands use to be updated lazily via calls to @code{get_stmt_operands}.  \n-This function is now deprecated and operands are updated as soon as the stmt is\n-finished via a call to @code{update_stmt}.  If statement elements are\n-changed via @code{SET_USE} or @code{SET_DEF}, no further action need be \n-taken (ie, those macros take care of whatever updating is required).  If\n-changes are made by manipulating the statement's tree directly, then a call \n-must be made to @code{update_stmt} when complete.  Calling one of the \n+Operands were once updated lazily via calls to @code{get_stmt_operands}.\n+This function is now deprecated and operands are updated as soon as the\n+statement is finished via a call to @code{update_stmt}.  If statement elements\n+are changed via @code{SET_USE} or @code{SET_DEF}, then no further action is\n+required (ie, those macros take care of updating the statement).  If\n+changes are made by manipulating the statement's tree directly, then a call\n+must be made to @code{update_stmt} when complete.  Calling one of the\n @code{bsi_insert} routines or @code{bsi_replace} performs an implicit call\n to @code{update_stmt}.\n \n@@ -1033,6 +1033,10 @@ iterators, you may examine every use of any @code{SSA_NAME}. For instance,\n to change each use of @code{ssa_var} to @code{ssa_var2}:\n \n @smallexample\n+  use_operand_p imm_use_p;\n+  imm_use_iterator iterator;\n+  tree ssa_var\n+\n   FOR_EACH_IMM_USE_SAFE (imm_use_p, iterator, ssa_var)\n     SET_USE (imm_use_p, ssa_var_2);\n @end smallexample\n@@ -1073,27 +1077,30 @@ Some useful functions and macros:\n single use of @code{ssa_var}.\n @item   @code{single_imm_use (ssa_var, use_operand_p *ptr, tree *stmt)} :\n Returns true if there is only a single use of @code{ssa_var}, and also returns\n-the use pointer and stmt it occurs in in the second and third parameters.\n+the use pointer and statement it occurs in in the second and third parameters.\n @item   @code{num_imm_uses (ssa_var)} : Returns the number of immediate uses of\n-@code{ssa_var}. Its better not to use this if possible since it simply\n+@code{ssa_var}. It is better not to use this if possible since it simply\n utilizes a loop to count the uses.\n @item  @code{PHI_ARG_INDEX_FROM_USE (use_p)} : Given a use within a @code{PHI}\n node, return the index number for the use.  An assert is triggered if the use\n isn't located in a @code{PHI} node.\n-@item  @code{USE_STMT (use_p)} : Return the stmt a use occurs in.\n+@item  @code{USE_STMT (use_p)} : Return the statement a use occurs in.\n @end enumerate\n \n Note that uses are not put into an immediate use list until their statement is\n actually inserted into the instruction stream via a @code{bsi_*} routine.  \n \n-It is also still possible to utilize lazy updating of stmts, but this should be used only when absolutely required.  Both alias analysis and the dominator \n-optimizations currently do this.  \n+It is also still possible to utilize lazy updating of statements, but this \n+should be used only when absolutely required.  Both alias analysis and the \n+dominator optimizations currently do this.  \n \n When lazy updating is being used, the immediate use information is out of date \n-and cannot be used reliably.  Lazy updating is achieved by simply marking stmts \n-modified via calls to @code{mark_stmt_modified} instead of @code{update_stmt}.\n-When lazy updating is no longer required, all the modified stmts must have \n-@code{update_stmt} called in order to bring them up to date.  This must be done before the optimization is finished, or @code{verify_ssa} will trigger an abort.\n+and cannot be used reliably.  Lazy updating is achieved by simply marking\n+statements modified via calls to @code{mark_stmt_modified} instead of \n+@code{update_stmt}.  When lazy updating is no longer required, all the \n+modified statements must have @code{update_stmt} called in order to bring them \n+up to date.  This must be done before the optimization is finished, or \n+@code{verify_ssa} will trigger an abort.\n \n This is done with a simple loop over the instruction stream:\n @smallexample"}]}