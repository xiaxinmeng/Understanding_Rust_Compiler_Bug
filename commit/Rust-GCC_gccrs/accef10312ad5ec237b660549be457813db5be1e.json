{"sha": "accef10312ad5ec237b660549be457813db5be1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNjZWYxMDMxMmFkNWVjMjM3YjY2MDU0OWJlNDU3ODEzZGI1YmUxZQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-12-15T08:29:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-12-15T08:29:37Z"}, "message": "regclass.c (record_reg_classes): Update comment for merging register class preferences in reg->reg copies.\n\n        * regclass.c (record_reg_classes): Update comment for merging\n        register class preferences in reg->reg copies.  Tighten conditions\n        for merging register class preferences in reg->reg copies.\n\nFrom-SVN: r30943", "tree": {"sha": "ac5a8b637849f198ae987e71ed632f2b7741c227", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac5a8b637849f198ae987e71ed632f2b7741c227"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/accef10312ad5ec237b660549be457813db5be1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/accef10312ad5ec237b660549be457813db5be1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/accef10312ad5ec237b660549be457813db5be1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/accef10312ad5ec237b660549be457813db5be1e/comments", "author": null, "committer": null, "parents": [{"sha": "705e873389db13b190d723bb2ece757d65ba57d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/705e873389db13b190d723bb2ece757d65ba57d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/705e873389db13b190d723bb2ece757d65ba57d9"}], "stats": {"total": 36, "additions": 27, "deletions": 9}, "files": [{"sha": "40c1180d579ea2e09c7b9e276d77f5171afcc2aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/accef10312ad5ec237b660549be457813db5be1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/accef10312ad5ec237b660549be457813db5be1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=accef10312ad5ec237b660549be457813db5be1e", "patch": "@@ -1,3 +1,9 @@\n+Wed Dec 15 01:23:29 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* regclass.c (record_reg_classes): Update comment for merging\n+\tregister class preferences in reg->reg copies.  Tighten conditions\n+\tfor merging register class preferences in reg->reg copies.\n+\n Wed Dec 15 02:19:32 1999  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.md (tablejumpdi): Generate DImode LABEL_REF."}, {"sha": "ea131c0a8d3ef7a69c9ed3aa022b77e22ca573e2", "filename": "gcc/regclass.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/accef10312ad5ec237b660549be457813db5be1e/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/accef10312ad5ec237b660549be457813db5be1e/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=accef10312ad5ec237b660549be457813db5be1e", "patch": "@@ -1622,11 +1622,18 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n     }\n \n   /* If this insn is a single set copying operand 1 to operand 0\n-     and one is a pseudo with the other a hard reg that is in its\n-     own register class, set the cost of that register class to -1.\n-     Do this only when source dies to avoid stressing of register\n-     allocator by preferrencing two coliding registers into single\n-     place.  */\n+     and one operand is a pseudo with the other a hard reg or a pseudo\n+     that prefers a register that is in its own register class then\n+     we may want to adjust the cost of that register class to -1.\n+ \n+     Avoid the adjustment if the source does not die to avoid stressing of\n+     register allocator by preferrencing two coliding registers into single\n+     class.\n+\n+     Also avoid the adjustment if a copy between registers of the class\n+     is expensive (ten times the cost of a default copy is considered\n+     arbitrarily expensive).  This avoids losing when the preferred class\n+     is very expensive as the source of a copy instruction.  */\n \n   if ((set = single_set (insn)) != 0\n       && ops[0] == SET_DEST (set) && ops[1] == SET_SRC (set)\n@@ -1640,10 +1647,15 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t  int class;\n \t  int nr;\n \n-\t  if (regno >= FIRST_PSEUDO_REGISTER && reg_pref != 0\n-\t      && (reg_class_size[(unsigned char) reg_pref[regno].prefclass]\n-\t\t  == CLASS_MAX_NREGS (reg_pref[regno].prefclass, mode)))\n-\t    op_costs[i].cost[(unsigned char) reg_pref[regno].prefclass] = -1;\n+\t  if (regno >= FIRST_PSEUDO_REGISTER && reg_pref != 0)\n+\t    {\n+\t      enum reg_class pref = reg_pref[regno].prefclass;\n+\n+\t      if ((reg_class_size[(unsigned char) pref]\n+\t\t   == CLASS_MAX_NREGS (pref, mode))\n+\t\t  && REGISTER_MOVE_COST (pref, pref) < 10 * 2)\n+\t\top_costs[i].cost[(unsigned char) pref] = -1;\n+\t    }\n \t  else if (regno < FIRST_PSEUDO_REGISTER)\n \t    for (class = 0; class < N_REG_CLASSES; class++)\n \t      if (TEST_HARD_REG_BIT (reg_class_contents[class], regno)"}]}