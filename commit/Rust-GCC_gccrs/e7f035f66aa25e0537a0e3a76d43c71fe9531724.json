{"sha": "e7f035f66aa25e0537a0e3a76d43c71fe9531724", "node_id": "C_kwDOANBUbNoAKGU3ZjAzNWY2NmFhMjVlMDUzN2EwZTNhNzZkNDNjNzFmZTk1MzE3MjQ", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-20T23:19:30Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-22T18:48:30Z"}, "message": "Convert CFN_BUILT_IN_GOACC_DIM_* to range-ops.\n\n\t* gimple-range-fold.cc (range_of_builtin_int_call): Remove case\n\tfor CFN_GOACC_DIM_*.\n\t* gimple-range-op.cc (class cfn_goacc_dim): New.\n\t(gimple_range_op_handler::maybe_builtin_call): Set arguments.", "tree": {"sha": "2f455dd061bd681205e35cfead88c3f308ffc360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f455dd061bd681205e35cfead88c3f308ffc360"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7f035f66aa25e0537a0e3a76d43c71fe9531724", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f035f66aa25e0537a0e3a76d43c71fe9531724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f035f66aa25e0537a0e3a76d43c71fe9531724", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f035f66aa25e0537a0e3a76d43c71fe9531724/comments", "author": null, "committer": null, "parents": [{"sha": "c750e675cb77f283ff991682db7740bc5f6d4cf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c750e675cb77f283ff991682db7740bc5f6d4cf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c750e675cb77f283ff991682db7740bc5f6d4cf4"}], "stats": {"total": 66, "additions": 47, "deletions": 19}, "files": [{"sha": "5e8a13e73374bd6839c4ade05c2566f5b8493961", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f035f66aa25e0537a0e3a76d43c71fe9531724/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f035f66aa25e0537a0e3a76d43c71fe9531724/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=e7f035f66aa25e0537a0e3a76d43c71fe9531724", "patch": "@@ -889,25 +889,6 @@ fold_using_range::range_of_builtin_int_call (irange &r, gcall *call,\n       r.set (build_zero_cst (type), build_one_cst (type));\n       return true;\n \n-    case CFN_GOACC_DIM_SIZE:\n-    case CFN_GOACC_DIM_POS:\n-      // Optimizing these two internal functions helps the loop\n-      // optimizer eliminate outer comparisons.  Size is [1,N]\n-      // and pos is [0,N-1].\n-      {\n-\tbool is_pos = func == CFN_GOACC_DIM_POS;\n-\tint axis = oacc_get_ifn_dim_arg (call);\n-\tint size = oacc_get_fn_dim_size (current_function_decl, axis);\n-\tif (!size)\n-\t  // If it's dynamic, the backend might know a hardware limitation.\n-\t  size = targetm.goacc.dim_limit (axis);\n-\n-\tr.set (build_int_cst (type, is_pos ? 0 : 1),\n-\t       size\n-\t       ? build_int_cst (type, size - is_pos) : vrp_val_max (type));\n-\treturn true;\n-      }\n-\n     default:\n       break;\n     }"}, {"sha": "76295466e65b471fc3853ef4fb90d9f85e30c14f", "filename": "gcc/gimple-range-op.cc", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f035f66aa25e0537a0e3a76d43c71fe9531724/gcc%2Fgimple-range-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f035f66aa25e0537a0e3a76d43c71fe9531724/gcc%2Fgimple-range-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.cc?ref=e7f035f66aa25e0537a0e3a76d43c71fe9531724", "patch": "@@ -635,6 +635,34 @@ class cfn_strlen : public range_operator\n   }\n } op_cfn_strlen;\n \n+\n+// Implement range operator for CFN_BUILT_IN_GOACC_DIM\n+class cfn_goacc_dim : public range_operator\n+{\n+public:\n+  cfn_goacc_dim (bool is_pos) { m_is_pos = is_pos; }\n+  using range_operator::fold_range;\n+  virtual bool fold_range (irange &r, tree type, const irange &lh,\n+\t\t\t   const irange &, relation_kind) const\n+  {\n+    tree axis_tree;\n+    if (!lh.singleton_p (&axis_tree))\n+      return false;\n+    HOST_WIDE_INT axis = TREE_INT_CST_LOW (axis_tree);\n+    int size = oacc_get_fn_dim_size (current_function_decl, axis);\n+    if (!size)\n+      // If it's dynamic, the backend might know a hardware limitation.\n+      size = targetm.goacc.dim_limit (axis);\n+\n+    r.set (build_int_cst (type, m_is_pos ? 0 : 1),\n+\t   size\n+\t   ? build_int_cst (type, size - m_is_pos) : vrp_val_max (type));\n+    return true;\n+  }\n+private:\n+  bool m_is_pos;\n+} op_cfn_goacc_dim_size (false), op_cfn_goacc_dim_pos (true);\n+\n // Set up a gimple_range_op_handler for any built in function which can be\n // supported via range-ops.\n \n@@ -748,6 +776,25 @@ gimple_range_op_handler::maybe_builtin_call ()\n \tbreak;\n       }\n \n+    // Optimizing these two internal functions helps the loop\n+    // optimizer eliminate outer comparisons.  Size is [1,N]\n+    // and pos is [0,N-1].\n+    case CFN_GOACC_DIM_SIZE:\n+      // This call will ensure all the asserts are triggered.\n+      oacc_get_ifn_dim_arg (call);\n+      m_op1 = gimple_call_arg (call, 0);\n+      m_valid = true;\n+      m_int = &op_cfn_goacc_dim_size;\n+      break;\n+\n+    case CFN_GOACC_DIM_POS:\n+      // This call will ensure all the asserts are triggered.\n+      oacc_get_ifn_dim_arg (call);\n+      m_op1 = gimple_call_arg (call, 0);\n+      m_valid = true;\n+      m_int = &op_cfn_goacc_dim_pos;\n+      break;\n+\n     default:\n       break;\n     }"}]}