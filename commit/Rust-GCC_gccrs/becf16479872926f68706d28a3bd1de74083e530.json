{"sha": "becf16479872926f68706d28a3bd1de74083e530", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVjZjE2NDc5ODcyOTI2ZjY4NzA2ZDI4YTNiZDFkZTc0MDgzZTUzMA==", "commit": {"author": {"name": "J. David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2000-12-07T01:06:47Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-12-07T01:06:47Z"}, "message": "pa.c: Include expr.h before c-tree.h.\n\n        * pa.c: Include expr.h before c-tree.h.\n        (remove_useless_addtr_insns): Use reverse_condition_maybe_unordered\n        instead of reverse_condition.\n        (print_operand): Correct predicates for GT, GE, LT and LE.  Add\n        predicates for LTGT, UNLE, UNLT, UNGE, UNGT, UNEQ, UNORDERED and\n        ORDERED.\n        (cmpib_comparison_operator): Add GEU and LTU codes.\n        * pa.h (PREDICATE_CODES): Add codes for cmpib_comparison_operator.\n        * pa.md (bltgt, bunle, bunlt, bunge, bungt, buneq, bunordered,\n        bordered): New float conditional branch patterns.\n\nFrom-SVN: r38082", "tree": {"sha": "f02f445316610f6635bf8e69134d1ba9b864edf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f02f445316610f6635bf8e69134d1ba9b864edf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/becf16479872926f68706d28a3bd1de74083e530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/becf16479872926f68706d28a3bd1de74083e530", "html_url": "https://github.com/Rust-GCC/gccrs/commit/becf16479872926f68706d28a3bd1de74083e530", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/becf16479872926f68706d28a3bd1de74083e530/comments", "author": null, "committer": null, "parents": [{"sha": "b2d98afe06d7d658404dc3b68a2645dd423d5b06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2d98afe06d7d658404dc3b68a2645dd423d5b06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2d98afe06d7d658404dc3b68a2645dd423d5b06"}], "stats": {"total": 170, "additions": 162, "deletions": 8}, "files": [{"sha": "cd11dd88442622722829f0c1ca250c2d30953a22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becf16479872926f68706d28a3bd1de74083e530/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becf16479872926f68706d28a3bd1de74083e530/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=becf16479872926f68706d28a3bd1de74083e530", "patch": "@@ -1,3 +1,16 @@\n+2000-11-06  J. David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* pa.c: Include expr.h before c-tree.h.\n+\t(remove_useless_addtr_insns): Use reverse_condition_maybe_unordered\n+\tinstead of reverse_condition.\n+\t(print_operand): Correct predicates for GT, GE, LT and LE.  Add\n+\tpredicates for LTGT, UNLE, UNLT, UNGE, UNGT, UNEQ, UNORDERED and\n+\tORDERED.\n+\t(cmpib_comparison_operator): Add GEU and LTU codes.\n+\t* pa.h (PREDICATE_CODES): Add codes for cmpib_comparison_operator.\n+\t* pa.md (bltgt, bunle, bunlt, bunge, bungt, buneq, bunordered,\n+\tbordered): New float conditional branch patterns.\n+\n Wed Dec  6 21:03:41 2000  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* final.c (final_addr_vec_align): Fix clipping to BIGGEST_ALIGNMENT."}, {"sha": "e9211eee8787c7d9a0c5d0dcb5d882c2ee006452", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becf16479872926f68706d28a3bd1de74083e530/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becf16479872926f68706d28a3bd1de74083e530/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=becf16479872926f68706d28a3bd1de74083e530", "patch": "@@ -34,9 +34,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"tree.h\"\n #include \"reload.h\"\n+#include \"expr.h\"\n #include \"c-tree.h\"\n #include \"function.h\"\n-#include \"expr.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n@@ -2642,7 +2642,8 @@ remove_useless_addtr_insns (insns, check_notes)\n \t\t  /* Reverse our condition.  */\n \t\t  tmp = PATTERN (insn);\n \t\t  PUT_CODE (XEXP (tmp, 1),\n-\t\t\t    reverse_condition (GET_CODE (XEXP (tmp, 1))));\n+\t\t    reverse_condition_maybe_unordered (GET_CODE (XEXP (tmp,\n+\t\t      1))));\n \t\t}\n \t    }\n \t}\n@@ -3921,8 +3922,8 @@ print_operand (file, x, code)\n \t  abort ();\n \t}\n       return;\n-    /* For floating point comparisons.  Need special conditions to deal\n-       with NaNs properly.  */\n+    /* For floating point comparisons. Note that the output predicates are the\n+       complement of the desired mode. */\n     case 'Y':\n       switch (GET_CODE (x))\n \t{\n@@ -3931,13 +3932,29 @@ print_operand (file, x, code)\n \tcase NE:\n \t  fputs (\"=\", file);  break;\n \tcase GT:\n-\t  fputs (\"<=\", file);  break;\n+\t  fputs (\"!>\", file);  break;\n \tcase GE:\n-\t  fputs (\"<\", file);  break;\n+\t  fputs (\"!>=\", file);  break;\n \tcase LT:\n-\t  fputs (\">=\", file);  break;\n+\t  fputs (\"!<\", file);  break;\n \tcase LE:\n+\t  fputs (\"!<=\", file);  break;\n+\tcase LTGT:\n+\t  fputs (\"!<>\", file);  break;\n+\tcase UNLE:\n \t  fputs (\">\", file);  break;\n+\tcase UNLT:\n+\t  fputs (\">=\", file);  break;\n+\tcase UNGE:\n+\t  fputs (\"<\", file);  break;\n+\tcase UNGT:\n+\t  fputs (\"<=\", file);  break;\n+\tcase UNEQ:\n+\t  fputs (\"<>\", file);  break;\n+\tcase UNORDERED:\n+\t  fputs (\"<=>\", file);  break;\n+\tcase ORDERED:\n+\t  fputs (\"!<=>\", file);  break;\n \tdefault:\n \t  abort ();\n \t}\n@@ -7046,9 +7063,11 @@ cmpib_comparison_operator (op, mode)\n           && (GET_CODE (op) == EQ\n \t      || GET_CODE (op) == NE\n \t      || GET_CODE (op) == GT\n-\t      || GET_CODE (op) == GE\n \t      || GET_CODE (op) == GTU\n+\t      || GET_CODE (op) == GE\n+\t      || GET_CODE (op) == GEU\n \t      || GET_CODE (op) == LT\n+\t      || GET_CODE (op) == LTU\n \t      || GET_CODE (op) == LE\n \t      || GET_CODE (op) == LEU));\n }"}, {"sha": "f920c0fb46581cf66b69f0734d98123f3fa1d20e", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becf16479872926f68706d28a3bd1de74083e530/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becf16479872926f68706d28a3bd1de74083e530/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=becf16479872926f68706d28a3bd1de74083e530", "patch": "@@ -2052,4 +2052,6 @@ while (0)\n   {\"basereg_operand\", {REG}},\t\t\t\t\t\t\\\n   {\"div_operand\", {REG, CONST_INT}},\t\t\t\t\t\\\n   {\"ireg_operand\", {REG}},\t\t\t\t\t\t\\\n+  {\"cmpib_comparison_operator\", {EQ, NE, LT, LTU, LE, LEU,\t\t\\\n+   GT, GTU, GE, GEU}},\t\t\t\t\t\t\t\\\n   {\"movb_comparison_operator\", {EQ, NE, LT, GE}},"}, {"sha": "d2f7ebfdcdc9e0d412dc642772cb2a53501e22fb", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becf16479872926f68706d28a3bd1de74083e530/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becf16479872926f68706d28a3bd1de74083e530/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=becf16479872926f68706d28a3bd1de74083e530", "patch": "@@ -1369,6 +1369,126 @@\n   operands[2] = hppa_compare_op1;\n }\")\n \n+(define_expand \"bltgt\"\n+  [(set (pc)\n+\t(if_then_else (ltgt (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type == CMP_SI)\n+    FAIL;\n+  emit_insn (gen_cmp_fp (LTGT, hppa_compare_op0, hppa_compare_op1));\n+  emit_bcond_fp (NE, operands[0]);\n+  DONE;\n+}\")\n+\n+(define_expand \"bunle\"\n+  [(set (pc)\n+\t(if_then_else (unle (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type == CMP_SI)\n+    FAIL;\n+  emit_insn (gen_cmp_fp (UNLE, hppa_compare_op0, hppa_compare_op1));\n+  emit_bcond_fp (NE, operands[0]);\n+  DONE;\n+}\")\n+\n+(define_expand \"bunlt\"\n+  [(set (pc)\n+\t(if_then_else (unlt (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type == CMP_SI)\n+    FAIL;\n+  emit_insn (gen_cmp_fp (UNLT, hppa_compare_op0, hppa_compare_op1));\n+  emit_bcond_fp (NE, operands[0]);\n+  DONE;\n+}\")\n+\n+(define_expand \"bunge\"\n+  [(set (pc)\n+\t(if_then_else (unge (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type == CMP_SI)\n+    FAIL;\n+  emit_insn (gen_cmp_fp (UNGE, hppa_compare_op0, hppa_compare_op1));\n+  emit_bcond_fp (NE, operands[0]);\n+  DONE;\n+}\")\n+\n+(define_expand \"bungt\"\n+  [(set (pc)\n+\t(if_then_else (ungt (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type == CMP_SI)\n+    FAIL;\n+  emit_insn (gen_cmp_fp (UNGT, hppa_compare_op0, hppa_compare_op1));\n+  emit_bcond_fp (NE, operands[0]);\n+  DONE;\n+}\")\n+\n+(define_expand \"buneq\"\n+  [(set (pc)\n+\t(if_then_else (uneq (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type == CMP_SI)\n+    FAIL;\n+  emit_insn (gen_cmp_fp (UNEQ, hppa_compare_op0, hppa_compare_op1));\n+  emit_bcond_fp (NE, operands[0]);\n+  DONE;\n+}\")\n+\n+(define_expand \"bunordered\"\n+  [(set (pc)\n+\t(if_then_else (unordered (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type == CMP_SI)\n+    FAIL;\n+  emit_insn (gen_cmp_fp (UNORDERED, hppa_compare_op0, hppa_compare_op1));\n+  emit_bcond_fp (NE, operands[0]);\n+  DONE;\n+}\")\n+\n+(define_expand \"bordered\"\n+  [(set (pc)\n+\t(if_then_else (ordered (match_dup 1) (match_dup 2))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (hppa_branch_type == CMP_SI)\n+    FAIL;\n+  emit_insn (gen_cmp_fp (ORDERED, hppa_compare_op0, hppa_compare_op1));\n+  emit_bcond_fp (NE, operands[0]);\n+  DONE;\n+}\")\n+\n ;; Match the branch patterns.\n \n "}]}