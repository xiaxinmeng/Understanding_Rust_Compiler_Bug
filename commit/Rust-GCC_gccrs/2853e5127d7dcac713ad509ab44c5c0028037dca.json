{"sha": "2853e5127d7dcac713ad509ab44c5c0028037dca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg1M2U1MTI3ZDdkY2FjNzEzYWQ1MDlhYjQ0YzVjMDAyODAzN2RjYQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-10-23T06:59:17Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-10-23T06:59:17Z"}, "message": "re PR fortran/18022 (problem with structure and calling a function)\n\n2005-10-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/18022\n\t* trans-expr.c (gfc_trans_arrayfunc_assign): Return NULL\n\tif there is a component ref during an array ref to force\n\tuse of temporary in assignment.\n\n\tPR fortran/24311\n\tPR fortran/24384\n\t* fortran/iresolve.c (check_charlen_present): New function to\n\tadd a charlen to the typespec, in the case of constant\n\texpressions.\n\t(gfc_resolve_merge, gfc_resolve_spread): Call.the above.\n\t(gfc_resolve_spread): Make calls to library functions that\n\thandle the case of the spread intrinsic with a scalar source.\n\t* libgfortran/intrinsics/spread_generic.c (spread_internal\n\t_scalar): New function that handles the special case of spread\n\twith a scalar source. This has interface functions -\n\t(spread_scalar, spread_char_scalar): New functions to interface\n\twith the calls specified in gfc_resolve_spread.\n\n2005-10-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/18022\n\tgfortran.dg/assign_func_dtcomp_1.f90: New test.\n\n\tPR fortran/24311\n\tgfortran.dg/merge_char_const.f90: New test.\n\n\tPR fortran/24384\n\tgfortran.dg/spread_scalar_source.f90: New test.\n\nFrom-SVN: r105810", "tree": {"sha": "9f2a2b5bf1f6c52982a3bc0ed7bb093beffbac06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f2a2b5bf1f6c52982a3bc0ed7bb093beffbac06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2853e5127d7dcac713ad509ab44c5c0028037dca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2853e5127d7dcac713ad509ab44c5c0028037dca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2853e5127d7dcac713ad509ab44c5c0028037dca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2853e5127d7dcac713ad509ab44c5c0028037dca/comments", "author": null, "committer": null, "parents": [{"sha": "1903e03eca6df0458899a4b3f89a505251d1e7c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1903e03eca6df0458899a4b3f89a505251d1e7c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1903e03eca6df0458899a4b3f89a505251d1e7c6"}], "stats": {"total": 273, "additions": 270, "deletions": 3}, "files": [{"sha": "af155949c7fcf8530cac6e1e9c26093c20872e5d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2853e5127d7dcac713ad509ab44c5c0028037dca", "patch": "@@ -1,3 +1,19 @@\n+2005-10-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/18022\n+\t* trans-expr.c (gfc_trans_arrayfunc_assign): Return NULL\n+\tif there is a component ref during an array ref to force\n+\tuse of temporary in assignment.\n+\n+\tPR fortran/24311\n+\tPR fortran/24384\n+\t* fortran/iresolve.c (check_charlen_present): New function to\n+\tadd a charlen to the typespec, in the case of constant\n+\texpressions.\n+\t(gfc_resolve_merge, gfc_resolve_spread): Call.the above.\n+\t(gfc_resolve_spread): Make calls to library functions that\n+\thandle the case of the spread intrinsic with a scalar source.\n+\n 2005-10-22  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/24426"}, {"sha": "9cba18bd1efc4d1745135ed3500483300643a81b", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=2853e5127d7dcac713ad509ab44c5c0028037dca", "patch": "@@ -59,6 +59,21 @@ gfc_get_string (const char *format, ...)\n   return IDENTIFIER_POINTER (ident);\n }\n \n+/* MERGE and SPREAD need to have source charlen's present for passing\n+   to the result expression.  */\n+static void\n+check_charlen_present (gfc_expr *source)\n+{\n+  if (source->expr_type == EXPR_CONSTANT && source->ts.cl == NULL)\n+    {\n+      source->ts.cl = gfc_get_charlen ();\n+      source->ts.cl->next = gfc_current_ns->cl_list;\n+      gfc_current_ns->cl_list = source->ts.cl;\n+      source->ts.cl->length = gfc_int_expr (source->value.character.length);\n+      source->rank = 0;\n+    }\n+}\n+\n /********************** Resolution functions **********************/\n \n \n@@ -996,6 +1011,9 @@ gfc_resolve_merge (gfc_expr * f, gfc_expr * tsource,\n \t\t   gfc_expr * fsource ATTRIBUTE_UNUSED,\n \t\t   gfc_expr * mask ATTRIBUTE_UNUSED)\n {\n+  if (tsource->ts.type == BT_CHARACTER)\n+    check_charlen_present (tsource);\n+\n   f->ts = tsource->ts;\n   f->value.function.name =\n     gfc_get_string (\"__merge_%c%d\", gfc_type_letter (tsource->ts.type),\n@@ -1395,11 +1413,19 @@ gfc_resolve_spread (gfc_expr * f, gfc_expr * source,\n \t\t    gfc_expr * dim,\n \t\t    gfc_expr * ncopies)\n {\n+  if (source->ts.type == BT_CHARACTER)\n+    check_charlen_present (source);\n+\n   f->ts = source->ts;\n   f->rank = source->rank + 1;\n-  f->value.function.name = (source->ts.type == BT_CHARACTER\n-\t\t\t    ? PREFIX(\"spread_char\")\n-\t\t\t    : PREFIX(\"spread\"));\n+  if (source->rank == 0)\n+    f->value.function.name = (source->ts.type == BT_CHARACTER\n+\t\t\t      ? PREFIX(\"spread_char_scalar\")\n+\t\t\t      : PREFIX(\"spread_scalar\"));\n+  else\n+    f->value.function.name = (source->ts.type == BT_CHARACTER\n+\t\t\t      ? PREFIX(\"spread_char\")\n+\t\t\t      : PREFIX(\"spread\"));\n \n   gfc_resolve_dim_arg (dim);\n   gfc_resolve_index (ncopies, 1);"}, {"sha": "fe5e24bdb078a7649e4d4fefa6b6a18e369d01d8", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=2853e5127d7dcac713ad509ab44c5c0028037dca", "patch": "@@ -2591,6 +2591,8 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n {\n   gfc_se se;\n   gfc_ss *ss;\n+  gfc_ref * ref;\n+  bool seen_array_ref;\n \n   /* The caller has already checked rank>0 and expr_type == EXPR_FUNCTION.  */\n   if (expr2->value.function.isym && !gfc_is_intrinsic_libcall (expr2))\n@@ -2605,6 +2607,20 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   if (gfc_ref_needs_temporary_p (expr1->ref))\n     return NULL;\n \n+  /* Check that no LHS component references appear during an array\n+     reference. This is needed because we do not have the means to\n+     span any arbitrary stride with an array descriptor. This check\n+     is not needed for the rhs because the function result has to be\n+     a complete type.  */\n+  seen_array_ref = false;\n+  for (ref = expr1->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_ARRAY)\n+\tseen_array_ref= true;\n+      else if (ref->type == REF_COMPONENT && seen_array_ref)\n+\treturn NULL;\n+    }\n+\n   /* Check for a dependency.  */\n   if (gfc_check_fncall_dependency (expr1, expr2))\n     return NULL;"}, {"sha": "af24da127679a8a07fd1bd34821c2b4e31a198be", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2853e5127d7dcac713ad509ab44c5c0028037dca", "patch": "@@ -1,3 +1,14 @@\n+2005-10-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/18022\n+\tgfortran.dg/assign_func_dtcomp_1.f90: New test.\n+\n+\tPR fortran/24311\n+\tgfortran.dg/merge_char_const.f90: New test.\n+\n+\tPR fortran/24384\n+\tgfortran.dg/spread_scalar_source.f90: New test.\n+\n 2005-10-22  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* g++.old-deja/g++.jason/thunk2.C: Guard test with { target fpic }."}, {"sha": "385eb2715f68e522d6083195ef354f70616cd0b5", "filename": "gcc/testsuite/gfortran.dg/assign_func_dtcomp_1.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_func_dtcomp_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_func_dtcomp_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_func_dtcomp_1.f90?ref=2853e5127d7dcac713ad509ab44c5c0028037dca", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+! { dg-options \"-O0\" }\n+!\n+! Test fix for PR18022.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!\n+program assign_func_dtcomp\n+ implicit none\n+ type                         ::  mytype\n+   real                       ::  x\n+   real                       ::  y\n+ end type mytype\n+ type (mytype), dimension (4) ::  z\n+\n+ type                         ::  thytype\n+   real                       ::  x(4)\n+ end type thytype\n+ type (thytype)               ::  w\n+ real, dimension (4)          ::  a = (/1.,2.,3.,4./)\n+ real, dimension (4)          ::  b = (/5.,6.,7.,8./)\n+\n+\n+! Test the original problem is fixed.\n+ z(:)%x = foo (a)\n+ z(:)%y = foo (b)\n+\n+\n+ if (any(z%x.ne.a).or.any(z%y.ne.b)) call abort ()\n+\n+! Make sure we did not break anything on the way.\n+ w%x(:) = foo (b)\n+ a = foo (b)\n+\n+ if (any(w%x.ne.b).or.any(a.ne.b)) call abort ()\n+\n+contains\n+\n+ function foo (v) result (ans)\n+   real, dimension (:), intent(in)   ::  v\n+   real, dimension (size(v))  ::  ans\n+   ans = v\n+ end function foo\n+\n+\n+end program assign_func_dtcomp\n+"}, {"sha": "32c87f51000ae75b61a074f6bd6acacc25362841", "filename": "gcc/testsuite/gfortran.dg/merge_char_const.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_char_const.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_char_const.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmerge_char_const.f90?ref=2853e5127d7dcac713ad509ab44c5c0028037dca", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+! { dg-options \"-O0\" }\n+! This tests the patch for PR24311 in which the PRINT statement would\n+! ICE on trying to print a MERGE statement with character constants\n+! for the first two arguments.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!\n+  integer, dimension(6) :: i = (/1,0,0,1,1,0/)\n+  print '(6a1)', Merge (\"a\", \"b\", i  == 1) ! { dg-output \"abbaab\" }\n+  end\n+\n+"}, {"sha": "c253165cc36161b4abfe907fa81a27a15d94476b", "filename": "gcc/testsuite/gfortran.dg/spread_scalar_source.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ftestsuite%2Fgfortran.dg%2Fspread_scalar_source.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2853e5127d7dcac713ad509ab44c5c0028037dca/gcc%2Ftestsuite%2Fgfortran.dg%2Fspread_scalar_source.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fspread_scalar_source.f90?ref=2853e5127d7dcac713ad509ab44c5c0028037dca", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do run }\n+! { dg-options \"-O0\" }\n+\n+  character*1 :: i, j(10)\n+  character*8 :: buffer\n+  integer*1 :: ii, jj(10)\n+  type :: mytype\n+    real*8 :: x\n+    integer*1 :: i\n+    character*15 :: ch\n+  end type mytype\n+  type(mytype) :: iii, jjj(10)\n+\n+  i = \"w\"\n+  ii = 42\n+  iii = mytype (41.9999_8, 77, \"test_of_spread_\")\n+\n+! Test constant sources.\n+\n+  j = spread (\"z\", 1 , 10)\n+  if (any (j /= \"z\")) call abort ()\n+  jj = spread (19, 1 , 10)\n+  if (any (jj /= 19)) call abort ()\n+\n+! Test variable sources.\n+\n+  j = spread (i, 1 , 10)\n+  if (any (j /= \"w\")) call abort ()\n+  jj = spread (ii, 1 , 10)\n+  if (any (jj /= 42)) call abort ()\n+  jjj = spread (iii, 1 , 10)\n+  if (any (jjj%x /= 41.9999_8)) call abort ()\n+  if (any (jjj%i /= 77)) call abort ()\n+  if (any (jjj%ch /= \"test_of_spread_\")) call abort ()\n+\n+! Check that spread != 1 is OK.\n+\n+  jj(2:10:2) = spread (1, 1, 5)\n+  if (any (jj(1:9:2) /= 42) .or. any (jj(2:10:2) /= 1)) call abort ()\n+\n+! Finally, check that temporaries and trans-io.c work correctly.\n+\n+  write (buffer, '(4a1)') spread (i, 1 , 4)\n+  if (trim(buffer) /= \"wwww\") call abort ()\n+  write (buffer, '(4a1)') spread (\"r\", 1 , 4)\n+  if (trim(buffer) /= \"rrrr\") call abort ()\n+  write (buffer, '(4i2)') spread (ii, 1 , 4)\n+  if (trim(buffer) /= \"42424242\") call abort ()\n+  write (buffer, '(4i2)') spread (31, 1 , 4)\n+  if (trim(buffer) /= \"31313131\") call abort ()\n+\n+  end\n\\ No newline at end of file"}, {"sha": "3666964d6c98e6db8527be3d188e5f9a234ff4b5", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2853e5127d7dcac713ad509ab44c5c0028037dca/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2853e5127d7dcac713ad509ab44c5c0028037dca/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=2853e5127d7dcac713ad509ab44c5c0028037dca", "patch": "@@ -1,3 +1,12 @@\n+2005-10-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/24384\n+\t* intrinsics/spread_generic.c (spread_internal_scalar): New\n+\tfunction that handles the special case of spread with a scalar\n+\tsource. This has new interface functions -\n+\t(spread_scalar, spread_char_scalar): New functions to interface\n+\twith the calls specified in gfc_resolve_spread.\n+\n 2005-10-21  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR libfortran/24383"}, {"sha": "bdcc0d11c12783bef9ac8f16fc0f511f688f5f80", "filename": "libgfortran/intrinsics/spread_generic.c", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2853e5127d7dcac713ad509ab44c5c0028037dca/libgfortran%2Fintrinsics%2Fspread_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2853e5127d7dcac713ad509ab44c5c0028037dca/libgfortran%2Fintrinsics%2Fspread_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fspread_generic.c?ref=2853e5127d7dcac713ad509ab44c5c0028037dca", "patch": "@@ -176,6 +176,49 @@ spread_internal (gfc_array_char *ret, const gfc_array_char *source,\n     }\n }\n \n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+static void\n+spread_internal_scalar (gfc_array_char *ret, const char *source,\n+\t\t\tconst index_type *along, const index_type *pncopies,\n+\t\t\tindex_type size)\n+{\n+  int n;\n+  int ncopies = *pncopies;\n+  char * dest;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (*along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * size);\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ret->dim[0].stride == 0)\n+\tret->dim[0].stride = 1;\n+\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      dest = (char*)(ret->data + n*size*ret->dim[0].stride);\n+      memcpy (dest , source, size);\n+    }\n+}\n+\n extern void spread (gfc_array_char *, const gfc_array_char *,\n \t\t    const index_type *, const index_type *);\n export_proto(spread);\n@@ -200,3 +243,37 @@ spread_char (gfc_array_char *ret,\n {\n   spread_internal (ret, source, along, pncopies, source_length);\n }\n+\n+/* The following are the prototypes for the versions of spread with a\n+   scalar source.  */\n+\n+extern void spread_scalar (gfc_array_char *, const char *,\n+\t\t\t   const index_type *, const index_type *);\n+export_proto(spread_scalar);\n+\n+void\n+spread_scalar (gfc_array_char *ret, const char *source,\n+\t       const index_type *along, const index_type *pncopies)\n+{\n+  if (!ret->dtype)\n+    runtime_error (\"return array missing descriptor in spread()\");\n+  spread_internal_scalar (ret, source, along, pncopies, GFC_DESCRIPTOR_SIZE (ret));\n+}\n+\n+\n+extern void spread_char_scalar (gfc_array_char *, GFC_INTEGER_4,\n+\t\t\t\tconst char *, const index_type *,\n+\t\t\t\tconst index_type *, GFC_INTEGER_4);\n+export_proto(spread_char_scalar);\n+\n+void\n+spread_char_scalar (gfc_array_char *ret,\n+\t\t    GFC_INTEGER_4 ret_length __attribute__((unused)),\n+\t\t    const char *source, const index_type *along,\n+\t\t    const index_type *pncopies, GFC_INTEGER_4 source_length)\n+{\n+  if (!ret->dtype)\n+    runtime_error (\"return array missing descriptor in spread()\");\n+  spread_internal_scalar (ret, source, along, pncopies, source_length);\n+}\n+"}]}