{"sha": "77880ae492b7b33e709c40806d03ea4b363be957", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc4ODBhZTQ5MmI3YjMzZTcwOWM0MDgwNmQwM2VhNGIzNjNiZTk1Nw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-09-10T11:12:15Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-09-10T11:12:15Z"}, "message": "class.c, [...]: Fix comment typos.\n\n\t* class.c, cp-tree.h, decl.c, decl2.c, mangle.c,\n\tname-lookup.h, parser.c, search.c, semantics.c, typeck2.c: Fix\n\tcomment typos.\n\nFrom-SVN: r87292", "tree": {"sha": "9770f858b960f918d1d485d785228404ef76fbd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9770f858b960f918d1d485d785228404ef76fbd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77880ae492b7b33e709c40806d03ea4b363be957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77880ae492b7b33e709c40806d03ea4b363be957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77880ae492b7b33e709c40806d03ea4b363be957", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77880ae492b7b33e709c40806d03ea4b363be957/comments", "author": null, "committer": null, "parents": [{"sha": "cad79bac6cdcd3fb0e6b1764819242fcee552297", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad79bac6cdcd3fb0e6b1764819242fcee552297", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cad79bac6cdcd3fb0e6b1764819242fcee552297"}], "stats": {"total": 52, "additions": 29, "deletions": 23}, "files": [{"sha": "ab3da7f06b434df3a6e8f698196f8462ae6f5793", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=77880ae492b7b33e709c40806d03ea4b363be957", "patch": "@@ -1,3 +1,9 @@\n+2004-09-10  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* class.c, cp-tree.h, decl.c, decl2.c, mangle.c,\n+\tname-lookup.h, parser.c, search.c, semantics.c, typeck2.c: Fix\n+\tcomment typos.\n+\n 2004-09-09  Ziemowit Laski  <zlaski@apple.com>\n \n \t* typeck.c (build_c_cast): Preserve the cast if casting"}, {"sha": "e15a38d17212937e2e096d33bcd13e7953f0f0cd", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=77880ae492b7b33e709c40806d03ea4b363be957", "patch": "@@ -1247,7 +1247,7 @@ check_bases (tree t,\n /* Determine all the primary bases within T.  Sets BINFO_PRIMARY_BASE_P for\n    those that are primaries.  Sets BINFO_LOST_PRIMARY_P for those\n    that have had a nearly-empty virtual primary base stolen by some\n-   other base in the heirarchy.  Determines CLASSTYPE_PRIMARY_BASE for\n+   other base in the hierarchy.  Determines CLASSTYPE_PRIMARY_BASE for\n    T.  */\n \n static void\n@@ -1320,7 +1320,7 @@ determine_primary_bases (tree t)\n   /* A \"nearly-empty\" virtual base class can be the primary base\n      class, if no non-virtual polymorphic base can be found.  Look for\n      a nearly-empty virtual dynamic base that is not already a primary\n-     base of something in the heirarchy.  If there is no such base,\n+     base of something in the hierarchy.  If there is no such base,\n      just pick the first nearly-empty virtual base.  */\n \n   for (base_binfo = TREE_CHAIN (type_binfo); base_binfo;\n@@ -3072,7 +3072,7 @@ check_field_decls (tree t, tree *access_decls,\n \tuser at least implemented the cleanup correctly, and a destructor\n \tis needed to free dynamic memory.\n \t\n-     This seems enough for pratical purposes.  */\n+     This seems enough for practical purposes.  */\n     if (warn_ecpp\n \t&& has_pointers\n \t&& TYPE_HAS_CONSTRUCTOR (t)"}, {"sha": "acbb3c8883ce302c8f8137df70f0bf2663025633", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=77880ae492b7b33e709c40806d03ea4b363be957", "patch": "@@ -313,7 +313,7 @@ struct tree_baselink GTY(())\n   tree access_binfo;\n };\n \n-/* The different kinds of ids that we ecounter.  */\n+/* The different kinds of ids that we encounter.  */\n \n typedef enum cp_id_kind\n {\n@@ -738,8 +738,8 @@ struct language_function GTY(())\n #define cp_function_chain (cfun->language)\n \n /* In a constructor destructor, the point at which all derived class\n-   destroying/contruction has been has been done. Ie. just before a\n-   constuctor returns, or before any base class destroying will be done\n+   destroying/construction has been has been done. Ie. just before a\n+   constructor returns, or before any base class destroying will be done\n    in a destructor.  */\n \n #define cdtor_label cp_function_chain->x_cdtor_label"}, {"sha": "84a5d9a8da9c02cd3c07767cb68125dd5a8f2da3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=77880ae492b7b33e709c40806d03ea4b363be957", "patch": "@@ -1427,7 +1427,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n          A namespace-name or namespace-alias shall not be declared as\n \t the name of any other entity in the same declarative region.\n \t A namespace-name defined at global scope shall not be\n-\t declared as the name of any other entity in any glogal scope\n+\t declared as the name of any other entity in any global scope\n \t of the program.  */\n       error (\"declaration of `namespace %D' conflicts with\", newdecl);\n       cp_error_at (\"previous declaration of `namespace %D' here\", olddecl);\n@@ -5763,7 +5763,7 @@ set_linkage_for_static_data_member (tree decl)\n   TREE_STATIC (decl) = 1;\n   /* For non-template classes, static data members are always put\n      out in exactly those files where they are defined, just as\n-     with ordinarly namespace-scope variables.  */\n+     with ordinary namespace-scope variables.  */\n   if (!processing_template_decl)\n     DECL_INTERFACE_KNOWN (decl) = 1;\n }\n@@ -6145,7 +6145,7 @@ get_scope_of_declarator (const cp_declarator *declarator)\n       && TREE_CODE (declarator->u.id.name) == SCOPE_REF)\n     return TREE_OPERAND (declarator->u.id.name, 0);\n \n-  /* Otherwise, the declarator is not a quablified name; the entity will\n+  /* Otherwise, the declarator is not a qualified name; the entity will\n      be declared in the current scope.  */\n   return NULL_TREE;\n }\n@@ -6257,7 +6257,7 @@ check_special_function_return_type (special_function_kind sfk,\n       if (type)\n \terror (\"return type specification for destructor invalid\");\n       /* We can't use the proper return type here because we run into\n-\t problems with abiguous bases and covariant returns.\n+\t problems with ambiguous bases and covariant returns.\n \t Java classes are left unchanged because (void *) isn't a valid\n \t Java type, and we don't want to change the Java ABI.  */\n       if (targetm.cxx.cdtor_returns_this () && !TYPE_FOR_JAVA (optype))\n@@ -9109,8 +9109,8 @@ xref_basetypes (tree ref, tree base_list)\n {\n   tree *basep;\n   tree binfo, base_binfo;\n-  unsigned max_vbases = 0; /* Maxium direct & indirect virtual bases. */\n-  unsigned max_bases = 0;  /* Maxium direct bases.  */\n+  unsigned max_vbases = 0; /* Maximum direct & indirect virtual bases. */\n+  unsigned max_bases = 0;  /* Maximum direct bases.  */\n   int i;\n   tree default_access;\n   tree igo_prev; /* Track Inheritance Graph Order.  */\n@@ -9232,7 +9232,7 @@ xref_basetypes (tree ref, tree base_list)\n       if (CLASS_TYPE_P (basetype) && !dependent_type_p (basetype))\n \t{\n \t  base_binfo = TYPE_BINFO (basetype);\n-\t  /* The orignal basetype could have been a typedef'd type.  */\n+\t  /* The original basetype could have been a typedef'd type.  */\n \t  basetype = BINFO_TYPE (base_binfo);\n \n \t  /* Inherit flags from the base.  */\n@@ -9431,7 +9431,7 @@ finish_enum (tree enumtype)\n      narrower than their underlying type are suitably zero or sign\n      extended to fill their mode.  g++ doesn't make these guarantees.\n      Until the middle-end can represent such paradoxical types, we\n-     set the TYPE_PRECISON to the width of the underlying type.  */\n+     set the TYPE_PRECISION to the width of the underlying type.  */\n   TYPE_PRECISION (enumtype) = TYPE_PRECISION (underlying_type);\n \n   set_min_and_max_values_for_integral_type (enumtype, precision, unsignedp);"}, {"sha": "38aa21a6c70679cb62c0971b30f5fc09feb7dbd2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=77880ae492b7b33e709c40806d03ea4b363be957", "patch": "@@ -578,7 +578,7 @@ check_java_method (tree method)\n \n /* Sanity check: report error if this function FUNCTION is not\n    really a member of the class (CTYPE) it is supposed to belong to.\n-   TEMPLATE_PARMS is used to specifiy the template parameters of a member\n+   TEMPLATE_PARMS is used to specify the template parameters of a member\n    template passed as FUNCTION_DECL. If the member template is passed as a \n    TEMPLATE_DECL, it can be NULL since the parameters can be extracted\n    from the declaration. If the function is not a function template, it\n@@ -2998,7 +2998,7 @@ cp_finish_file (void)\n \treconsider = true;\n \n       /* Ask the back end to emit functions and variables that are\n-\t enqued.  These emissions may result in marking more entities\n+\t enqueued.  These emissions may result in marking more entities\n \t as needed.  */\n       if (cgraph_assemble_pending_functions ())\n \treconsider = true;"}, {"sha": "a3d885a4aacc870f684f784bdbf3d1e9c97dd69d", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=77880ae492b7b33e709c40806d03ea4b363be957", "patch": "@@ -2167,7 +2167,7 @@ write_template_arg_literal (const tree value)\n   write_char ('E');\n }\n \n-/* Non-terminal <tempalate-arg>.  \n+/* Non-terminal <template-arg>.  \n \n      <template-arg> ::= <type>                        # type\n                     ::= L <type> </value/ number> E   # literal"}, {"sha": "7c73f3f1d725916bd891e370dd1857e75b77eb87", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=77880ae492b7b33e709c40806d03ea4b363be957", "patch": "@@ -231,7 +231,7 @@ struct cp_binding_level GTY(())\n \n     /* The kind of scope that this object represents.  However, a\n        SK_TEMPLATE_SPEC scope is represented with KIND set to\n-       SK_TEMPALTE_PARMS and EXPLICIT_SPEC_P set to true.  */\n+       SK_TEMPLATE_PARMS and EXPLICIT_SPEC_P set to true.  */\n     ENUM_BITFIELD (scope_kind) kind : 4;\n \n     /* True if this scope is an SK_TEMPLATE_SPEC scope.  This field is"}, {"sha": "0f6821e546b31bee81a27e2bf6eb1354cb7cbe62", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=77880ae492b7b33e709c40806d03ea4b363be957", "patch": "@@ -4226,7 +4226,7 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n      If we are in an integral constant expression context, then we might\n      could accept any constant expression; hard to say without analysis.\n      Rather than open the barn door too wide right away, allow only integer\n-     constant expresions here.  */\n+     constant expressions here.  */\n   if (for_offsetof)\n     index = cp_parser_constant_expression (parser, false, NULL);\n   else"}, {"sha": "906491ed02c13c6717315072d9b8247acf996cd3", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=77880ae492b7b33e709c40806d03ea4b363be957", "patch": "@@ -2140,8 +2140,8 @@ check_hidden_convs (tree binfo, int virtual_depth, int virtualness,\n /* Helper for lookup_conversions_r.  PARENT_CONVS is a list of lists\n    of conversion functions, the first slot will be for the current\n    binfo, if MY_CONVS is non-NULL.  CHILD_CONVS is the list of lists\n-   of conversion functions from childen of the current binfo,\n-   concatenated with conversions from elsewhere in the heirarchy --\n+   of conversion functions from children of the current binfo,\n+   concatenated with conversions from elsewhere in the hierarchy --\n    that list begins with OTHER_CONVS.  Return a single list of lists\n    containing only conversions from the current binfo and its\n    children.  */"}, {"sha": "95d09f1d201246102bd98b7a48fba1d7ef9a82b2", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=77880ae492b7b33e709c40806d03ea4b363be957", "patch": "@@ -1348,7 +1348,7 @@ check_accessibility_of_qualified_id (tree decl,\n   tree scope;\n   tree qualifying_type = NULL_TREE;\n \n-  /* If we're not checking, return imediately.  */\n+  /* If we're not checking, return immediately.  */\n   if (deferred_access_no_check)\n     return;\n   "}, {"sha": "548d08990bd347593a18f0dd01a48f8625c6e7b6", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77880ae492b7b33e709c40806d03ea4b363be957/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=77880ae492b7b33e709c40806d03ea4b363be957", "patch": "@@ -207,7 +207,7 @@ complete_type_check_abstract (tree type)\n       pat = prev;\n \n       /* Go through the list, and call abstract_virtuals_error for each\n-\telement: it will issue a diagostic if the type is abstract.  */\n+\telement: it will issue a diagnostic if the type is abstract.  */\n       while (pat)\n \t{\n \t  gcc_assert (type == pat->type);"}]}