{"sha": "e61c8e230ac099c617f5daf275ab7c020935237c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYxYzhlMjMwYWMwOTljNjE3ZjVkYWYyNzVhYjdjMDIwOTM1MjM3Yw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-02-06T06:24:21Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-02-06T06:24:21Z"}, "message": "[multiple changes]\n\n\n2003-02-06  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* testsuite/22_locale/codecvt/encoding/wchar_t/1.cc (test01):\n\tExplicitly use the \"C\" locale.\n\t* testsuite/22_locale/codecvt/max_length/wchar_t/1.cc (test01): Same.\n\n2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n\n\tDR 75\n\tDR 305\n\tPR libstdc++/9028 (partial)\n\tPR libstdc++/9224\n\tPR libstdc++/9246\n\tPR libstdc++/9247\n\n\t* src/codecvt.cc\n\t(codecvt<wchar_t, char, mbstate_t>::do_encoding,\n\tcodecvt<wchar_t, char, mbstate_t>::do_length,\n\tcodecvt<wchar_t, char, mbstate_t>::do_max_length):\n\tMove...\n\t* config/locale/generic/codecvt_members.cc:  ...here.\n\t* config/locale/gnu/codecvt_members.cc:  ...and here.\n\n\t* config/locale/generic/codecvt_members.cc,\n\t* config/locale/gnu/codecvt_members.cc\n\t(codecvt<wchar_t, char, mbstate_t>::do_encoding\n\tcodecvt<wchar_t, char, mbstate_t>::do_in,\n\tcodecvt<wchar_t, char, mbstate_t>::do_length,\n\tcodecvt<wchar_t, char, mbstate_t>::do_max_length,\n\tcodecvt<wchar_t, char, mbstate_t>::do_out):\n\tNew implementation that handles stateless encodings,\n\tincluding UTF-8.\n\n\t* config/locale/generic/codecvt_members.cc,\n\t* config/locale/gnu/codecvt_members.cc,\n\t* config/locale/ieee_1003.1-2001/codecvt_specializations.h,\n\t* include/bits/codecvt.h,\n\t* src/codecvt.cc\n\t(codecvt::length, codecvt::do_length):\n\tChange type of first argument of length and do_length from\n\t'const state_type&' to 'state_type&' according to DR 75.\n\n\t* testsuite/22_locale/codecvt/always_noconv/wchar_t/1.cc:  Cleanup.\n\t* testsuite/22_locale/codecvt/always_noconv/wchar_t/2.cc:  New test.\n\t* testsuite/22_locale/codecvt/always_noconv/wchar_t/3.cc:  New test.\n\t* testsuite/22_locale/codecvt/always_noconv/wchar_t/4.cc:  New test.\n\t* testsuite/22_locale/codecvt/encoding/wchar_t/1.cc:\n\tCleanup and check for correct return value from encoding\n\tfor \"C\" locale.\n\t* testsuite/22_locale/codecvt/encoding/wchar_t/2.cc:  New test.\n\t* testsuite/22_locale/codecvt/encoding/wchar_t/3.cc:  New test.\n\t* testsuite/22_locale/codecvt/encoding/wchar_t/4.cc:  New test.\n\t* testsuite/22_locale/codecvt/in/wchar_t/1.cc:  Cleanup.\n\t* testsuite/22_locale/codecvt/in/wchar_t/2.cc:  New test.\n\t* testsuite/22_locale/codecvt/in/wchar_t/3.cc:  New test.\n\t* testsuite/22_locale/codecvt/in/wchar_t/4.cc:  New test.\n\t* testsuite/22_locale/codecvt/in/wchar_t/5.cc:  New test.\n\t* testsuite/22_locale/codecvt/in/wchar_t/6.cc:  New test.\n\t* testsuite/22_locale/codecvt/in/wchar_t/7.cc:  New test.\n\t* testsuite/22_locale/codecvt/in/wchar_t/8.cc:  New test.\n\t* testsuite/22_locale/codecvt/in/wchar_t/9.cc:  New test.\n\t* testsuite/22_locale/codecvt/length/char/1.cc:  Cleanup.\n\t* testsuite/22_locale/codecvt/length/char/2.cc:  New test.\n\t* testsuite/22_locale/codecvt/length/wchar_t/1.cc:  Cleanup.\n\t* testsuite/22_locale/codecvt/length/wchar_t/2.cc:  New test.\n\t* testsuite/22_locale/codecvt/length/wchar_t/3.cc:  New test.\n\t* testsuite/22_locale/codecvt/length/wchar_t/4.cc:  New test.\n\t* testsuite/22_locale/codecvt/length/wchar_t/5.cc:  New test.\n\t* testsuite/22_locale/codecvt/length/wchar_t/6.cc:  New test.\n\t* testsuite/22_locale/codecvt/length/wchar_t/7.cc:  New test.\n\t* testsuite/22_locale/codecvt/max_length/wchar_t/1.cc:  Cleanup.\n\t* testsuite/22_locale/codecvt/max_length/wchar_t/2.cc:  New test.\n\t* testsuite/22_locale/codecvt/max_length/wchar_t/3.cc:  New test.\n\t* testsuite/22_locale/codecvt/max_length/wchar_t/4.cc:  New test.\n\t* testsuite/22_locale/codecvt/out/wchar_t/1.cc:  Cleanup.\n\t* testsuite/22_locale/codecvt/out/wchar_t/2.cc:  New test.\n\t* testsuite/22_locale/codecvt/out/wchar_t/3.cc:  New test.\n\t* testsuite/22_locale/codecvt/out/wchar_t/4.cc:  New test.\n\t* testsuite/22_locale/codecvt/out/wchar_t/5.cc:  New test.\n\t* testsuite/22_locale/codecvt/out/wchar_t/6.cc:  New test.\n\t* testsuite/22_locale/codecvt/out/wchar_t/7.cc:  New test.\n\t* testsuite/22_locale/codecvt/unicode/1.cc:  New test.\n\t* testsuite/22_locale/codecvt/unshift/wchar_t/1.cc:  Cleanup.\n\t* testsuite/22_locale/codecvt/unshift/wchar_t/2.cc:  New test.\n\t* testsuite/22_locale/codecvt/unshift/wchar_t/3.cc:  New test.\n\t* testsuite/22_locale/codecvt/unshfit/wchar_t/4.cc:  New test.\n\nFrom-SVN: r62474", "tree": {"sha": "5b66a4db806018fb8b5a582655230d4ceea85b36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b66a4db806018fb8b5a582655230d4ceea85b36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e61c8e230ac099c617f5daf275ab7c020935237c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e61c8e230ac099c617f5daf275ab7c020935237c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e61c8e230ac099c617f5daf275ab7c020935237c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e61c8e230ac099c617f5daf275ab7c020935237c/comments", "author": null, "committer": null, "parents": [{"sha": "2e2a38cd06646304a0d566ee0b6eca09a22df1b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e2a38cd06646304a0d566ee0b6eca09a22df1b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e2a38cd06646304a0d566ee0b6eca09a22df1b8"}], "stats": {"total": 3719, "additions": 3464, "deletions": 255}, "files": [{"sha": "d6f6855bc0a5a52f5afb72ffef3cd60cc1fafac1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -1,3 +1,90 @@\n+2003-02-06  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* testsuite/22_locale/codecvt/encoding/wchar_t/1.cc (test01):\n+\tExplicitly use the \"C\" locale.\n+\t* testsuite/22_locale/codecvt/max_length/wchar_t/1.cc (test01): Same.\n+\t\n+2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+\tDR 75\n+\tDR 305\n+\tPR libstdc++/9028 (partial)\n+\tPR libstdc++/9224\n+\tPR libstdc++/9246\n+\tPR libstdc++/9247\n+\n+\t* src/codecvt.cc\n+\t(codecvt<wchar_t, char, mbstate_t>::do_encoding,\n+\tcodecvt<wchar_t, char, mbstate_t>::do_length,\n+\tcodecvt<wchar_t, char, mbstate_t>::do_max_length):\n+\tMove...\n+\t* config/locale/generic/codecvt_members.cc:  ...here.\n+\t* config/locale/gnu/codecvt_members.cc:  ...and here.\n+\n+\t* config/locale/generic/codecvt_members.cc,\n+\t* config/locale/gnu/codecvt_members.cc\n+\t(codecvt<wchar_t, char, mbstate_t>::do_encoding\n+\tcodecvt<wchar_t, char, mbstate_t>::do_in,\n+\tcodecvt<wchar_t, char, mbstate_t>::do_length,\n+\tcodecvt<wchar_t, char, mbstate_t>::do_max_length,\n+\tcodecvt<wchar_t, char, mbstate_t>::do_out):\n+\tNew implementation that handles stateless encodings,\n+\tincluding UTF-8.\n+\n+\t* config/locale/generic/codecvt_members.cc,\n+\t* config/locale/gnu/codecvt_members.cc,\n+\t* config/locale/ieee_1003.1-2001/codecvt_specializations.h,\n+\t* include/bits/codecvt.h,\n+\t* src/codecvt.cc\n+\t(codecvt::length, codecvt::do_length):\n+\tChange type of first argument of length and do_length from\n+\t'const state_type&' to 'state_type&' according to DR 75.\n+\n+\t* testsuite/22_locale/codecvt/always_noconv/wchar_t/1.cc:  Cleanup.\n+\t* testsuite/22_locale/codecvt/always_noconv/wchar_t/2.cc:  New test.\n+\t* testsuite/22_locale/codecvt/always_noconv/wchar_t/3.cc:  New test.\n+\t* testsuite/22_locale/codecvt/always_noconv/wchar_t/4.cc:  New test.\n+\t* testsuite/22_locale/codecvt/encoding/wchar_t/1.cc:\n+\tCleanup and check for correct return value from encoding\n+\tfor \"C\" locale.\n+\t* testsuite/22_locale/codecvt/encoding/wchar_t/2.cc:  New test.\n+\t* testsuite/22_locale/codecvt/encoding/wchar_t/3.cc:  New test.\n+\t* testsuite/22_locale/codecvt/encoding/wchar_t/4.cc:  New test.\n+\t* testsuite/22_locale/codecvt/in/wchar_t/1.cc:  Cleanup.\n+\t* testsuite/22_locale/codecvt/in/wchar_t/2.cc:  New test.\n+\t* testsuite/22_locale/codecvt/in/wchar_t/3.cc:  New test.\n+\t* testsuite/22_locale/codecvt/in/wchar_t/4.cc:  New test.\n+\t* testsuite/22_locale/codecvt/in/wchar_t/5.cc:  New test.\n+\t* testsuite/22_locale/codecvt/in/wchar_t/6.cc:  New test.\n+\t* testsuite/22_locale/codecvt/in/wchar_t/7.cc:  New test.\n+\t* testsuite/22_locale/codecvt/in/wchar_t/8.cc:  New test.\n+\t* testsuite/22_locale/codecvt/in/wchar_t/9.cc:  New test.\n+\t* testsuite/22_locale/codecvt/length/char/1.cc:  Cleanup.\n+\t* testsuite/22_locale/codecvt/length/char/2.cc:  New test.\n+\t* testsuite/22_locale/codecvt/length/wchar_t/1.cc:  Cleanup.\n+\t* testsuite/22_locale/codecvt/length/wchar_t/2.cc:  New test.\n+\t* testsuite/22_locale/codecvt/length/wchar_t/3.cc:  New test.\n+\t* testsuite/22_locale/codecvt/length/wchar_t/4.cc:  New test.\n+\t* testsuite/22_locale/codecvt/length/wchar_t/5.cc:  New test.\n+\t* testsuite/22_locale/codecvt/length/wchar_t/6.cc:  New test.\n+\t* testsuite/22_locale/codecvt/length/wchar_t/7.cc:  New test.\n+\t* testsuite/22_locale/codecvt/max_length/wchar_t/1.cc:  Cleanup.\n+\t* testsuite/22_locale/codecvt/max_length/wchar_t/2.cc:  New test.\n+\t* testsuite/22_locale/codecvt/max_length/wchar_t/3.cc:  New test.\n+\t* testsuite/22_locale/codecvt/max_length/wchar_t/4.cc:  New test.\n+\t* testsuite/22_locale/codecvt/out/wchar_t/1.cc:  Cleanup.\n+\t* testsuite/22_locale/codecvt/out/wchar_t/2.cc:  New test.\n+\t* testsuite/22_locale/codecvt/out/wchar_t/3.cc:  New test.\n+\t* testsuite/22_locale/codecvt/out/wchar_t/4.cc:  New test.\n+\t* testsuite/22_locale/codecvt/out/wchar_t/5.cc:  New test.\n+\t* testsuite/22_locale/codecvt/out/wchar_t/6.cc:  New test.\n+\t* testsuite/22_locale/codecvt/out/wchar_t/7.cc:  New test.\n+\t* testsuite/22_locale/codecvt/unicode/1.cc:  New test.\n+\t* testsuite/22_locale/codecvt/unshift/wchar_t/1.cc:  Cleanup.\n+\t* testsuite/22_locale/codecvt/unshift/wchar_t/2.cc:  New test.\n+\t* testsuite/22_locale/codecvt/unshift/wchar_t/3.cc:  New test.\n+\t* testsuite/22_locale/codecvt/unshfit/wchar_t/4.cc:  New test.\n+\n 2003-02-05  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/bits/locale_facets.tcc (time_put::do_put): Use __write."}, {"sha": "bd685107533aa27488098f7fc81356513f93e687", "filename": "libstdc++-v3/config/locale/generic/codecvt_members.cc", "status": "modified", "additions": 129, "deletions": 31, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgeneric%2Fcodecvt_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgeneric%2Fcodecvt_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgeneric%2Fcodecvt_members.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -46,25 +46,42 @@ namespace std\n \t extern_type* __to, extern_type* __to_end,\n \t extern_type*& __to_next) const\n   {\n-    result __ret = error;\n-    size_t __len = std::min(__from_end - __from, __to_end - __to);\n-    size_t __conv = wcsrtombs(__to, &__from, __len, &__state);\n-\n-    if (__conv == __len)\n-      {\n-\t__from_next = __from;\n-\t__to_next = __to + __conv;\n-\t__ret = ok;\n-      }\n-    else if (__conv > 0 && __conv < __len)\n+    result __ret = ok;\n+    // The conversion must be done using a temporary destination buffer\n+    // since it is not possible to pass the size of the buffer to wcrtomb\n+    extern_type __buf[MB_LEN_MAX];\n+    // A temporary state must be used since the result of the last\n+    // conversion may be thrown away.\n+    state_type __tmp_state(__state);\n+    \n+    // The conversion must be done by calling wcrtomb in a loop rather\n+    // than using wcsrtombs because wcsrtombs assumes that the input is\n+    // zero-terminated.\n+    while (__from < __from_end && __to < __to_end)\n       {\n-\t__from_next = __from;\n-\t__to_next = __to + __conv;\n-\t__ret = partial;\n+\tsize_t __conv = wcrtomb(__buf, *__from, &__tmp_state);\n+\tif (__conv == static_cast<size_t>(-1))\n+\t  {\n+\t    __ret = error;\n+\t    break;\n+\t  }\n+\telse if (__conv > static_cast<size_t>(__to_end - __to))\n+\t  {\n+\t    __ret = partial;\n+\t    break;\n+\t  }\n+\n+\tmemcpy(__to, __buf, __conv);\n+\t__state = __tmp_state;\n+\t__to += __conv;\n+\t__from++;\n       }\n-    else\n-      __ret = error;\n-\t\n+\n+    if (__ret == ok && __from < __from_end)\n+      __ret = partial;\n+\n+    __from_next = __from;\n+    __to_next = __to;\n     return __ret; \n   }\n   \n@@ -75,25 +92,106 @@ namespace std\n \tintern_type* __to, intern_type* __to_end,\n \tintern_type*& __to_next) const\n   {\n-    result __ret = error;\n-    size_t __len = std::min(__from_end - __from, __to_end - __to);\n-    size_t __conv = mbsrtowcs(__to, &__from, __len, &__state);\n+    result __ret = ok;\n+    // This temporary state object is neccessary so __state won't be modified\n+    // if [__from, __from_end) is a partial multibyte character.\n+    state_type __tmp_state(__state);\n \n-    if (__conv == __len)\n+    // Conversion must be done by calling mbrtowc in a loop rather than\n+    // by calling mbsrtowcs because mbsrtowcs assumes that the input\n+    // sequence is zero-terminated.\n+    while (__from < __from_end && __to < __to_end)\n       {\n-\t__from_next = __from;\n-\t__to_next = __to + __conv;\n-\t__ret = ok;\n+\tsize_t __conv = mbrtowc(__to, __from, __from_end - __from,\n+\t\t\t\t&__tmp_state);\n+\tif (__conv == static_cast<size_t>(-1))\n+\t  {\n+\t    __ret = error;\n+\t    break;\n+\t  }\n+\telse if (__conv == static_cast<size_t>(-2))\n+\t  {\n+\t    // It is unclear what to return in this case (see DR 382).\n+\t    __ret = partial;\n+\t    break;\n+\t  }\n+\telse if (__conv == 0)\n+\t  {\n+\t    // XXX Probably wrong for stateful encodings\n+\t    __conv = 1;\n+\t    *__to = L'\\0';\n+\t  }\n+\n+\t__state = __tmp_state;\n+\t__to++;\n+\t__from += __conv;\n       }\n-    else if (__conv > 0 && __conv < __len)\n+\n+    // It is not clear that __from < __from_end implies __ret != ok\n+    // (see DR 382).\n+    if (__ret == ok && __from < __from_end)\n+      __ret = partial;\n+\n+    __from_next = __from;\n+    __to_next = __to;\n+    return __ret; \n+  }\n+\n+  int \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_encoding() const throw()\n+  {\n+    // XXX This implementation assumes that the encoding is\n+    // stateless and is either single-byte or variable-width.\n+    int __ret = 0;\n+    if (MB_CUR_MAX == 1)\n+      __ret = 1;\n+    return __ret;\n+  }  \n+\n+  int \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_max_length() const throw()\n+  {\n+    // XXX Probably wrong for stateful encodings.\n+    int __ret = MB_CUR_MAX;\n+    return __ret;\n+  }\n+  \n+  int \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_length(state_type& __state, const extern_type* __from,\n+\t    const extern_type* __end, size_t __max) const\n+  {\n+    int __ret = 0;\n+    state_type __tmp_state(__state);\n+\n+    while (__from < __end && __max)\n       {\n-\t__from_next = __from;\n-\t__to_next = __to + __conv;\n-\t__ret = partial;\n+\tsize_t __conv = mbrtowc(NULL, __from, __end - __from, &__tmp_state);\n+\tif (__conv == static_cast<size_t>(-1))\n+\t  {\n+\t    // Invalid source character\n+\t    break;\n+\t  }\n+\telse if (__conv == static_cast<size_t>(-2))\n+\t  {\n+\t    // Remainder of input does not form a complete destination\n+\t    // character.\n+\t    break;\n+\t  }\n+\telse if (__conv == 0)\n+\t  {\n+\t    // XXX Probably wrong for stateful encodings\n+\t    __conv = 1;\n+\t  }\n+\n+\t__state = __tmp_state;\n+\t__from += __conv;\n+\t__ret += __conv;\n+\t__max--;\n       }\n-    else\n-      __ret = error;\n-\t\n+\n     return __ret; \n   }\n #endif"}, {"sha": "b093385a586435578d462a724c74289c07398be8", "filename": "libstdc++-v3/config/locale/gnu/codecvt_members.cc", "status": "modified", "additions": 153, "deletions": 34, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -47,31 +47,50 @@ namespace std\n \t extern_type* __to, extern_type* __to_end,\n \t extern_type*& __to_next) const\n   {\n-    result __ret = error;\n-    size_t __len = std::min(__from_end - __from, __to_end - __to);\n+    result __ret = ok;\n+    // The conversion must be done using a temporary destination buffer\n+    // since it is not possible to pass the size of the buffer to wcrtomb\n+    extern_type __buf[MB_LEN_MAX];\n+    // A temporary state must be used since the result of the last\n+    // conversion may be thrown away.\n+    state_type __tmp_state(__state);\n+    \n #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n     __c_locale __old = __uselocale(_M_c_locale_codecvt);\n #endif\n-    size_t __conv = wcsrtombs(__to, &__from, __len, &__state);\n+\n+    // The conversion must be done by calling wcrtomb in a loop rather\n+    // than using wcsrtombs because wcsrtombs assumes that the input is\n+    // zero-terminated.\n+    while (__from < __from_end && __to < __to_end)\n+      {\n+\tsize_t __conv = wcrtomb(__buf, *__from, &__tmp_state);\n+\tif (__conv == static_cast<size_t>(-1))\n+\t  {\n+\t    __ret = error;\n+\t    break;\n+\t  }\n+\telse if (__conv > static_cast<size_t>(__to_end - __to))\n+\t  {\n+\t    __ret = partial;\n+\t    break;\n+\t  }\n+\n+\tmemcpy(__to, __buf, __conv);\n+\t__state = __tmp_state;\n+\t__to += __conv;\n+\t__from++;\n+      }\n+\n #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n     __uselocale(__old);\n #endif\n \n-    if (__conv == __len)\n-      {\n-\t__from_next = __from;\n-\t__to_next = __to + __conv;\n-\t__ret = ok;\n-      }\n-    else if (__conv > 0 && __conv < __len)\n-      {\n-\t__from_next = __from;\n-\t__to_next = __to + __conv;\n-\t__ret = partial;\n-      }\n-    else\n-      __ret = error;\n-\t\n+    if (__ret == ok && __from < __from_end)\n+      __ret = partial;\n+\n+    __from_next = __from;\n+    __to_next = __to;\n     return __ret; \n   }\n   \n@@ -82,31 +101,131 @@ namespace std\n \tintern_type* __to, intern_type* __to_end,\n \tintern_type*& __to_next) const\n   {\n-    result __ret = error;\n-    size_t __len = std::min(__from_end - __from, __to_end - __to);\n+    result __ret = ok;\n+    // This temporary state object is neccessary so __state won't be modified\n+    // if [__from, __from_end) is a partial multibyte character.\n+    state_type __tmp_state(__state);\n #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n     __c_locale __old = __uselocale(_M_c_locale_codecvt);\n #endif\n-    size_t __conv = mbsrtowcs(__to, &__from, __len, &__state);\n+\n+    // Conversion must be done by calling mbrtowc in a loop rather than\n+    // by calling mbsrtowcs because mbsrtowcs assumes that the input\n+    // sequence is zero-terminated.\n+    while (__from < __from_end && __to < __to_end)\n+      {\n+\tsize_t __conv = mbrtowc(__to, __from, __from_end - __from,\n+\t\t\t\t&__tmp_state);\n+\tif (__conv == static_cast<size_t>(-1))\n+\t  {\n+\t    __ret = error;\n+\t    break;\n+\t  }\n+\telse if (__conv == static_cast<size_t>(-2))\n+\t  {\n+\t    // It is unclear what to return in this case (see DR 382).\n+\t    __ret = partial;\n+\t    break;\n+\t  }\n+\telse if (__conv == 0)\n+\t  {\n+\t    // XXX Probably wrong for stateful encodings\n+\t    __conv = 1;\n+\t    *__to = L'\\0';\n+\t  }\n+\n+\t__state = __tmp_state;\n+\t__to++;\n+\t__from += __conv;\n+      }\n+\n #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n     __uselocale(__old);\n #endif\n \n-    if (__conv == __len)\n-      {\n-\t__from_next = __from;\n-\t__to_next = __to + __conv;\n-\t__ret = ok;\n-      }\n-    else if (__conv > 0 && __conv < __len)\n+    // It is not clear that __from < __from_end implies __ret != ok\n+    // (see DR 382).\n+    if (__ret == ok && __from < __from_end)\n+      __ret = partial;\n+\n+    __from_next = __from;\n+    __to_next = __to;\n+    return __ret; \n+  }\n+\n+  int \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_encoding() const throw()\n+  {\n+    // XXX This implementation assumes that the encoding is\n+    // stateless and is either single-byte or variable-width.\n+    int __ret = 0;\n+#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n+    __c_locale __old = __uselocale(_M_c_locale_codecvt);\n+#endif\n+    if (MB_CUR_MAX == 1)\n+      __ret = 1;\n+#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n+    __uselocale(__old);\n+#endif\n+    return __ret;\n+  }  \n+\n+  int \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_max_length() const throw()\n+  {\n+#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n+    __c_locale __old = __uselocale(_M_c_locale_codecvt);\n+#endif\n+    // XXX Probably wrong for stateful encodings.\n+    int __ret = MB_CUR_MAX;\n+#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n+    __uselocale(__old);\n+#endif\n+    return __ret;\n+  }\n+  \n+  int \n+  codecvt<wchar_t, char, mbstate_t>::\n+  do_length(state_type& __state, const extern_type* __from,\n+\t    const extern_type* __end, size_t __max) const\n+  {\n+    int __ret = 0;\n+    state_type __tmp_state(__state);\n+#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n+    __c_locale __old = __uselocale(_M_c_locale_codecvt);\n+#endif\n+\n+    while (__from < __end && __max)\n       {\n-\t__from_next = __from;\n-\t__to_next = __to + __conv;\n-\t__ret = partial;\n+\tsize_t __conv = mbrtowc(NULL, __from, __end - __from, &__tmp_state);\n+\tif (__conv == static_cast<size_t>(-1))\n+\t  {\n+\t    // Invalid source character\n+\t    break;\n+\t  }\n+\telse if (__conv == static_cast<size_t>(-2))\n+\t  {\n+\t    // Remainder of input does not form a complete destination\n+\t    // character.\n+\t    break;\n+\t  }\n+\telse if (__conv == 0)\n+\t  {\n+\t    // XXX Probably wrong for stateful encodings\n+\t    __conv = 1;\n+\t  }\n+\n+\t__state = __tmp_state;\n+\t__from += __conv;\n+\t__ret += __conv;\n+\t__max--;\n       }\n-    else\n-      __ret = error;\n-\t\n+\n+#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n+    __uselocale(__old);\n+#endif\n     return __ret; \n   }\n #endif"}, {"sha": "45c069d342ecb98eb4fe5f7e959a93d26682954e", "filename": "libstdc++-v3/config/locale/ieee_1003.1-2001/codecvt_specializations.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fieee_1003.1-2001%2Fcodecvt_specializations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fieee_1003.1-2001%2Fcodecvt_specializations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fieee_1003.1-2001%2Fcodecvt_specializations.h?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -230,7 +230,7 @@\n       do_always_noconv() const throw();\n \n       virtual int \n-      do_length(const state_type&, const extern_type* __from, \n+      do_length(state_type&, const extern_type* __from, \n \t\tconst extern_type* __end, size_t __max) const;\n \n       virtual int \n@@ -447,7 +447,7 @@\n   template<typename _InternT, typename _ExternT>\n     int \n     codecvt<_InternT, _ExternT, __enc_traits>::\n-    do_length(const state_type&, const extern_type* __from, \n+    do_length(state_type&, const extern_type* __from, \n \t      const extern_type* __end, size_t __max) const\n     { return std::min(__max, static_cast<size_t>(__end - __from)); }\n "}, {"sha": "45d5f3a29158aac5397ffc86654e14548bce3987", "filename": "libstdc++-v3/include/bits/codecvt.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -106,7 +106,7 @@\n       { return this->do_always_noconv(); }\n \n       int\n-      length(const state_type& __state, const extern_type* __from,\n+      length(state_type& __state, const extern_type* __from,\n \t     const extern_type* __end, size_t __max) const\n       { return this->do_length(__state, __from, __end, __max); }\n \n@@ -144,7 +144,7 @@\n       do_always_noconv() const throw() = 0;\n \n       virtual int \n-      do_length(const state_type&, const extern_type* __from, \n+      do_length(state_type&, const extern_type* __from, \n \t\tconst extern_type* __end, size_t __max) const = 0;\n \n       virtual int \n@@ -204,7 +204,7 @@\n       do_always_noconv() const throw();\n \n       virtual int \n-      do_length(const state_type&, const extern_type* __from, \n+      do_length(state_type&, const extern_type* __from, \n \t\tconst extern_type* __end, size_t __max) const;\n \n       virtual int \n@@ -264,7 +264,7 @@\n       do_always_noconv() const throw();\n \n       virtual int \n-      do_length(const state_type&, const extern_type* __from, \n+      do_length(state_type&, const extern_type* __from, \n \t\tconst extern_type* __end, size_t __max) const;\n \n       virtual int \n@@ -324,7 +324,7 @@\n       bool do_always_noconv() const throw();\n \n       virtual \n-      int do_length(const state_type&, const extern_type* __from,\n+      int do_length(state_type&, const extern_type* __from,\n \t\t    const extern_type* __end, size_t __max) const;\n \n       virtual int "}, {"sha": "a44256d5f7aaa8e933fa2e35c8bffec69a72811c", "filename": "libstdc++-v3/src/codecvt.cc", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -108,7 +108,7 @@ namespace std\n   \n   int \n   codecvt<char, char, mbstate_t>::\n-  do_length (const state_type&, const extern_type* __from,\n+  do_length (state_type&, const extern_type* __from,\n \t     const extern_type* __end, size_t __max) const\n   { return std::min(__max, static_cast<size_t>(__end - __from)); }\n   \n@@ -138,29 +138,14 @@ namespace std\n   do_unshift(state_type&, extern_type* __to,\n \t     extern_type*, extern_type*& __to_next) const\n   {\n+    // XXX Probably wrong for stateful encodings\n     __to_next = __to;\n     return noconv;\n   }\n   \n-  int \n-  codecvt<wchar_t, char, mbstate_t>::\n-  do_encoding() const throw()\n-  { return sizeof(wchar_t); }\n-  \n   bool \n   codecvt<wchar_t, char, mbstate_t>::\n   do_always_noconv() const throw()\n   { return false; }\n-  \n-  int \n-  codecvt<wchar_t, char, mbstate_t>::\n-  do_length(const state_type&, const extern_type* __from,\n-\t    const extern_type* __end, size_t __max) const\n-  { return std::min(__max, static_cast<size_t>(__end - __from)); }\n-\n-  int \n-  codecvt<wchar_t, char, mbstate_t>::\n-  do_max_length() const throw()\n-  { return 1; }\n #endif //  _GLIBCPP_USE_WCHAR_T\n } // namespace std"}, {"sha": "25d66af0d6872eeb27ba9e95bea44597b7fb945e", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/always_noconv/wchar_t/1.cc", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F1.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -23,49 +23,17 @@\n #include <locale>\n #include <testsuite_hooks.h>\n \n-// Need to explicitly set the state(mbstate_t) to zero.\n-// How to do this is not specified by the ISO C99 standard, so we\n-// might need to add some operators to make the intuiative case\n-// work:\n-//   w_codecvt::state_type state00;\n-//   state00 = 0;  \n-// or, can use this explicit \"C\" initialization:\n-//   w_codecvt::state_type state01 = {0, 0};\n-// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n-void\n-zero_state(std::mbstate_t& state)\n-{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n-\n // Required instantiation\n // codecvt<wchar_t, char, mbstate_t>\n void test01()\n {\n   using namespace std;\n   typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n-  typedef codecvt_base::result\t\t\tresult;\n-  typedef wchar_t\t\t\t\tint_type;\n-  typedef char\t\t\t\t\text_type;\n-  typedef char_traits<wchar_t>\t\t\tint_traits;\n-  typedef char_traits<char>\t\t\text_traits;\n-\n-  bool \t\t\ttest = true;\n-  const ext_type* \te_lit = \"black pearl jasmine tea\";\n-  const ext_type*       efrom_next;\n-  const int_type* \ti_lit = L\"black pearl jasmine tea\";\n-  const int_type*       ifrom_next;\n-  int \t\t\tsize = strlen(e_lit);\n-  ext_type* \t\te_arr = new ext_type[size + 1];\n-  ext_type*\t\teto_next;\n-  int_type* \t\ti_arr = new int_type[size + 1];\n-  int_type*\t\tito_next;\n \n   locale \t\tloc;\n   const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n \n   VERIFY( !cvt->always_noconv() );\n-\n-  delete [] e_arr;\n-  delete [] i_arr;\n }\n \n int main ()"}, {"sha": "19e73985f192a09419130252fb34554d8a2777d9", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/always_noconv/wchar_t/2.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F2.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,46 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Baseline test in ISO-8859-1 locale\n+void test02()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-1\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  VERIFY( !cvt->always_noconv() );\n+}\n+\n+int main ()\n+{\n+  test02();\n+  return 0;\n+}"}, {"sha": "8681276f6b15923c782e9beab2bc777561ab949e", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/always_noconv/wchar_t/3.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F3.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,46 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Baseline test in ISO-8859-15 locale\n+void test03()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-15\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  VERIFY( !cvt->always_noconv() );\n+}\n+\n+int main ()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "36bc3a183bdae0e6717ed1f66a1ae083d39fef47", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/always_noconv/wchar_t/4.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Falways_noconv%2Fwchar_t%2F4.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,46 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Baseline test in UTF-8 locale\n+void test04()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+\n+  locale \t\tloc (\"en_US.UTF-8\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  VERIFY( !cvt->always_noconv() );\n+}\n+\n+int main ()\n+{\n+  test04();\n+  return 0;\n+}"}, {"sha": "d2fa938e892373f3d1f35643e0f21b04188e3233", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/encoding/wchar_t/1.cc", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F1.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -23,50 +23,19 @@\n #include <locale>\n #include <testsuite_hooks.h>\n \n-// Need to explicitly set the state(mbstate_t) to zero.\n-// How to do this is not specified by the ISO C99 standard, so we\n-// might need to add some operators to make the intuiative case\n-// work:\n-//   w_codecvt::state_type state00;\n-//   state00 = 0;  \n-// or, can use this explicit \"C\" initialization:\n-//   w_codecvt::state_type state01 = {0, 0};\n-// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n-void\n-zero_state(std::mbstate_t& state)\n-{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n-\n // Required instantiation\n // codecvt<wchar_t, char, mbstate_t>\n void test01()\n {\n   using namespace std;\n   typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n-  typedef codecvt_base::result\t\t\tresult;\n-  typedef wchar_t\t\t\t\tint_type;\n-  typedef char\t\t\t\t\text_type;\n-  typedef char_traits<wchar_t>\t\t\tint_traits;\n-  typedef char_traits<char>\t\t\text_traits;\n-\n   bool \t\t\ttest = true;\n-  const ext_type* \te_lit = \"black pearl jasmine tea\";\n-  const ext_type*       efrom_next;\n-  const int_type* \ti_lit = L\"black pearl jasmine tea\";\n-  const int_type*       ifrom_next;\n-  int \t\t\tsize = strlen(e_lit);\n-  ext_type* \t\te_arr = new ext_type[size + 1];\n-  ext_type*\t\teto_next;\n-  int_type* \t\ti_arr = new int_type[size + 1];\n-  int_type*\t\tito_next;\n \n-  locale \t\tloc;\n-  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+  locale \t\tloc_c = locale::classic();\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc_c); \n \n   int i = cvt->encoding();\n-  VERIFY( i == 4 ); // Target-dependent.\n-\n-  delete [] e_arr;\n-  delete [] i_arr;\n+  VERIFY( i == 1 ); // Depends both on target and locale.\n }\n \n int main ()"}, {"sha": "9c7f5d040e6beab82e2d3413eed58d7dcb9fb2f1", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/encoding/wchar_t/2.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F2.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,48 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Test do_encoding with ISO-8859-1 locale.\n+void test02()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  bool \t\t\ttest = true;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-1\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  int i = cvt->encoding();\n+  VERIFY( i == 1 ); // ISO-8859-1 is a single-byte encoding\n+}\n+\n+int main ()\n+{\n+  test02();\n+  return 0;\n+}"}, {"sha": "98a8961113e01649662f76b3a0b125ba405e267c", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/encoding/wchar_t/3.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F3.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,48 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Test do_encoding with ISO-8859-15 locale.\n+void test03()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  bool \t\t\ttest = true;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-15\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  int i = cvt->encoding();\n+  VERIFY( i == 1 ); // ISO-8859-15 is a single-byte encoding\n+}\n+\n+int main ()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "f2ada106694ee1f81d49c7f5e7523095b7a02865", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/encoding/wchar_t/4.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fencoding%2Fwchar_t%2F4.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,48 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Test do_encoding with UTF-8 locale.\n+void test04()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  bool \t\t\ttest = true;\n+\n+  locale \t\tloc (\"en_US.UTF-8\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  int i = cvt->encoding();\n+  VERIFY( i == 0 ); // UTF-8 is a stateless multibyte encoding\n+}\n+\n+int main ()\n+{\n+  test04();\n+  return 0;\n+}"}, {"sha": "d5a410a7741855c31b906b4df567234a347434f0", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/in/wchar_t/1.cc", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F1.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -38,6 +38,8 @@ zero_state(std::mbstate_t& state)\n \n // Required instantiation\n // codecvt<wchar_t, char, mbstate_t>\n+//\n+// Baseline test for \"C\" locale\n void test01()\n {\n   using namespace std;\n@@ -46,17 +48,16 @@ void test01()\n   typedef wchar_t\t\t\t\tint_type;\n   typedef char\t\t\t\t\text_type;\n   typedef char_traits<wchar_t>\t\t\tint_traits;\n-  typedef char_traits<char>\t\t\text_traits;\n \n   bool \t\t\ttest = true;\n   const ext_type* \te_lit = \"black pearl jasmine tea\";\n   const ext_type*       efrom_next;\n   const int_type* \ti_lit = L\"black pearl jasmine tea\";\n-  const int_type*       ifrom_next;\n   int \t\t\tsize = strlen(e_lit);\n-  ext_type* \t\te_arr = new ext_type[size + 1];\n-  ext_type*\t\teto_next;\n   int_type* \t\ti_arr = new int_type[size + 1];\n+  int_type* \t\ti_ref = new int_type[size + 1];\n+  wmemset(i_arr, 0xdeadbeef, size + 1);\n+  wmemset(i_ref, 0xdeadbeef, size + 1);\n   int_type*\t\tito_next;\n \n   locale \t\tloc;\n@@ -68,12 +69,13 @@ void test01()\n   result r1 = cvt->in(state01, e_lit, e_lit + size, efrom_next, \n \t\t      i_arr, i_arr + size, ito_next);\n   VERIFY( r1 == codecvt_base::ok );\n-  VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n   VERIFY( efrom_next == e_lit + size );\n   VERIFY( ito_next == i_arr + size );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n+  VERIFY( !int_traits::compare(ito_next, i_ref, 1) );\n \n-  delete [] e_arr;\n   delete [] i_arr;\n+  delete [] i_ref;\n }\n \n int main ()"}, {"sha": "d9e55ef3858b55b47029c4bd8ccfbec5426693b0", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/in/wchar_t/2.cc", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F2.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,114 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Baseline test for ISO-8859-1. Converts entire charset.\n+void test02()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<wchar_t>\t\t\tint_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit =\n+    \"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    \"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    \"'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\"\n+    \"abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\"\n+    \"\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\"\n+    \"\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\"\n+    \"\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\"\n+    \"\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n+    \"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\"\n+    \"\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n+    \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n+    \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\"\n+    \"\\xff\";\n+\n+  const ext_type*       efrom_next;\n+  const int_type* \ti_lit =\n+    L\"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    L\"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    L\"'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\"\n+    L\"abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\"\n+    L\"\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\"\n+    L\"\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\"\n+    L\"\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\"\n+    L\"\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n+    L\"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\"\n+    L\"\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n+    L\"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n+    L\"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\"\n+    L\"\\xff\";\n+\n+  int \t\t\tsize = strlen(e_lit);\n+  int_type* \t\ti_arr = new int_type[size + 1];\n+  int_type* \t\ti_ref = new int_type[size + 1];\n+  wmemset(i_arr, 0xdeadbeef, size + 1);\n+  wmemset(i_ref, 0xdeadbeef, size + 1);\n+  int_type*\t\tito_next;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-1\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // in\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1 = cvt->in(state01, e_lit, e_lit + size, efrom_next, \n+\t\t      i_arr, i_arr + size, ito_next);\n+  VERIFY( r1 == codecvt_base::ok );\n+  VERIFY( efrom_next == e_lit + size );\n+  VERIFY( ito_next == i_arr + size );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n+  VERIFY( !int_traits::compare(ito_next, i_ref, 1) );\n+\n+  delete [] i_arr;\n+  delete [] i_ref;\n+}\n+\n+int main ()\n+{\n+  test02();\n+  return 0;\n+}"}, {"sha": "152e7e9fe4f35a65aa8bdd6012f2c29c8c1f1ea7", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/in/wchar_t/3.cc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F3.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,128 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Baseline test for ISO-8859-15. Converts entire charset.\n+void test03()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<wchar_t>\t\t\tint_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit =\n+    \"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    \"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    \"'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\"\n+    \"abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\"\n+    \"\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\"\n+    \"\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\"\n+    \"\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\"\n+    \"\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n+    \"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\"\n+    \"\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n+    \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n+    \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\"\n+    \"\\xff\";\n+\n+  const ext_type*       efrom_next;\n+  const int_type \ti_lit[] = {\n+    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc,\n+    0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, L'!',\n+    L'\"', L'#', L'$', L'%', L'&', L'\\'', L'(', L')', L'*', L'+',\n+    L',', L'-', L'.', L'/', L'0', L'1', L'2', L'3', L'4', L'5',\n+    L'6', L'7', L'8', L'9', L':', L';', L'<', L'=', L'>', L'?',\n+    L'@', L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H', L'I',\n+    L'J', L'K', L'L', L'M', L'N', L'O', L'P', L'Q', L'R', L'S',\n+    L'T', L'U', L'V', L'W', L'X', L'Y', L'Z', L'[', L'\\\\', L']',\n+    L'^', L'_', L'`', L'a', L'b', L'c', L'd', L'e', L'f', L'g',\n+    L'h', L'i', L'j', L'k', L'l', L'm', L'n', L'o', L'p', L'q',\n+    L'r', L's', L't', L'u', L'v', L'w', L'x', L'y', L'z', L'{',\n+    L'|', L'}', L'~', 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,\n+    0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\n+    0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n+    0x20ac, 0xa5, 0x160, 0xa7, 0x161, 0xa9, 0xaa, 0xab, 0xac, 0xad,\n+    0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0x17d, 0xb5, 0xb6, 0xb7,\n+    0x17e, 0xb9, 0xba, 0xbb, 0x152, 0x153, 0x178, 0xbf, 0xc0, 0xc1,\n+    0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n+    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5,\n+    0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,\n+    0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n+    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd,\n+    0xfe, 0xff, 0x0\n+  };\n+\n+  int \t\t\tsize = strlen(e_lit);\n+  int_type* \t\ti_arr = new int_type[size + 1];\n+  int_type* \t\ti_ref = new int_type[size + 1];\n+  wmemset(i_arr, 0xdeadbeef, size + 1);\n+  wmemset(i_ref, 0xdeadbeef, size + 1);\n+  int_type*\t\tito_next;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-15\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // in\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1 = cvt->in(state01, e_lit, e_lit + size, efrom_next, \n+\t\t      i_arr, i_arr + size, ito_next);\n+  VERIFY( r1 == codecvt_base::ok );\n+  VERIFY( efrom_next == e_lit + size );\n+  VERIFY( ito_next == i_arr + size );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n+  VERIFY( !int_traits::compare(ito_next, i_ref, 1) );\n+\n+  delete [] i_arr;\n+  delete [] i_ref;\n+}\n+\n+int main ()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "c916a16b6c9adf3696c38e8136b8c67da1e2ba0b", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/in/wchar_t/4.cc", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F4.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,136 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Baseline test for UTF-8. Converts a selection of characters into\n+// an array that is known to be of the exact needed size.\n+void test04()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<wchar_t>\t\t\tint_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit =\n+    \"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    \"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    \"'()*+,-./0123456789:;<=>?@}~\\x7f\\xc2\\x80\\xc2\\x81\\xc2\\x82\\xc2\"\n+    \"\\x83\\xc2\\x84\\xc2\\x85\\xc2\\x86\\xc2\\x87\\xc2\\x88\\xc2\\x89\\xc2\\x8a\"\n+    \"\\xc2\\x8b\\xc2\\x8c\\xc2\\x8d\\xc2\\x8e\\xc2\\x8f\\xc2\\x90\\xc2\\x91\\xc2\"\n+    \"\\x92\\xc2\\x93\\xc2\\x94\\xc2\\x95\\xc2\\x96\\xc2\\x97\\xc2\\x98\\xc2\\x99\"\n+    \"\\xc2\\x9a\\xc2\\x9b\\xc2\\x9c\\xc3\\xba\\xc3\\xbb\\xc3\\xbc\\xc3\\xbd\\xc3\"\n+    \"\\xbe\\xc3\\xbf\\xc4\\x80\\xc4\\x81\\xc4\\x82\\xc4\\x83\\xc4\\x84\\xc4\\x85\"\n+    \"\\xc4\\x86\\xc4\\x87\\xc4\\x88\\xc4\\x89\\xc4\\x8a\\xc4\\x8b\\xc4\\x8c\\xc4\"\n+    \"\\x8d\\xc4\\x8e\\xc4\\x8f\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93\\xc4\\x94\"\n+    \"\\xc4\\x95\\xc4\\x96\\xc4\\x97\\xc4\\x98\\xc4\\x99\\xdf\\xb8\\xdf\\xb9\\xdf\"\n+    \"\\xba\\xdf\\xbb\\xdf\\xbc\\xdf\\xbd\\xdf\\xbe\\xdf\\xbf\\xe0\\xa0\\x80\\xe0\"\n+    \"\\xa0\\x81\\xe0\\xa0\\x82\\xe0\\xa0\\x83\\xe0\\xa0\\x84\\xe0\\xa0\\x85\\xe0\"\n+    \"\\xa0\\x86\\xe0\\xa0\\x87\\xe0\\xa0\\x88\\xe0\\xa0\\x89\\xe0\\xa0\\x8a\\xe0\"\n+    \"\\xa0\\x8b\\xe0\\xa0\\x8c\\xe0\\xa0\\x8d\\xe0\\xa0\\x8e\\xe0\\xa0\\x8f\\xe0\"\n+    \"\\xa0\\x90\\xe0\\xa0\\x91\\xe0\\xa0\\x92\\xe0\\xa0\\x93\\xe0\\xa0\\x94\\xe0\"\n+    \"\\xa0\\x95\\xe0\\xa0\\x96\\xe0\\xa0\\x97\\x1\\x2\\x4\\x8\\x10\\x20@\\xc2\\x80\"\n+    \"\\xc4\\x80\\xc8\\x80\\xd0\\x80\\xe0\\xa0\\x80\\xe1\\x80\\x80\\xe2\\x80\\x80\"\n+    \"\\xe4\\x80\\x80\\xe8\\x80\\x80\\xf0\\x90\\x80\\x80\\xf0\\xa0\\x80\\x80\\xf1\"\n+    \"\\x80\\x80\\x80\\xf2\\x80\\x80\\x80\\xf4\\x80\\x80\\x80\\xf8\\x88\\x80\\x80\"\n+    \"\\x80\\xf8\\x90\\x80\\x80\\x80\\xf8\\xa0\\x80\\x80\\x80\\xf9\\x80\\x80\\x80\"\n+    \"\\x80\\xfa\\x80\\x80\\x80\\x80\\xfc\\x84\\x80\\x80\\x80\\x80\\xfc\\x88\\x80\"\n+    \"\\x80\\x80\\x80\\xfc\\x90\\x80\\x80\\x80\\x80\\xfc\\xa0\\x80\\x80\\x80\\x80\"\n+    \"\\xfd\\x80\\x80\\x80\\x80\\x80\";\n+\n+  const ext_type*       efrom_next;\n+  const int_type \ti_lit[] = {\n+    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc,\n+    0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, L'!',\n+    L'\"', L'#', L'$', L'%', L'&', L'\\'', L'(', L')', L'*', L'+',\n+    L',', L'-', L'.', L'/', L'0', L'1', L'2', L'3', L'4', L'5',\n+    L'6', L'7', L'8', L'9', L':', L';', L'<', L'=', L'>', L'?',\n+    L'@', L'}', L'~', 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,\n+    0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\n+    0x9a, 0x9b, 0x9c, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x100,\n+    0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107, 0x108, 0x109,\n+    0x10a, 0x10b, 0x10c, 0x10d, 0x10e, 0x10f, 0x110, 0x111, 0x112,\n+    0x113, 0x114, 0x115, 0x116, 0x117, 0x118, 0x119, 0x7f8, 0x7f9,\n+    0x7fa, 0x7fb, 0x7fc, 0x7fd, 0x7fe, 0x7ff, 0x800, 0x801, 0x802,\n+    0x803, 0x804, 0x805, 0x806, 0x807, 0x808, 0x809, 0x80a, 0x80b,\n+    0x80c, 0x80d, 0x80e, 0x80f, 0x810, 0x811, 0x812, 0x813, 0x814,\n+    0x815, 0x816, 0x817, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, L'@',\n+    0x80, 0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000,\n+    0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 0x400000,\n+    0x800000, 0x1000000, 0x2000000, 0x4000000, 0x8000000, 0x10000000,\n+    0x20000000, 0x40000000, 0x0\n+  };\n+\n+  int \t\t\tesize = strlen(e_lit);\n+  int \t\t\tisize = wcslen(i_lit);\n+  int_type* \t\ti_arr = new int_type[esize + 1];\n+  int_type* \t\ti_ref = new int_type[esize + 1];\n+  wmemset(i_arr, 0xdeadbeef, esize + 1);\n+  wmemset(i_ref, 0xdeadbeef, esize + 1);\n+  int_type*\t\tito_next;\n+\n+  locale \t\tloc (\"en_US.UTF-8\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // in\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1 = cvt->in(state01, e_lit, e_lit + esize, efrom_next, \n+\t\t      i_arr, i_arr + isize, ito_next);\n+  VERIFY( r1 == codecvt_base::ok );\n+  VERIFY( efrom_next == e_lit + esize );\n+  VERIFY( ito_next == i_arr + isize );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, isize) ); \n+  VERIFY( !int_traits::compare(ito_next, i_ref, esize + 1 - isize) );\n+\n+  delete [] i_arr;\n+  delete [] i_ref;\n+}\n+\n+int main ()\n+{\n+  test04();\n+  return 0;\n+}"}, {"sha": "ec65f60c6928135fbd4fba7529a2470688e65bb3", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/in/wchar_t/5.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F5.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,86 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Test handling of '\\0' characters in input\n+// libstdc++/9246\n+void test05()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<wchar_t>\t\t\tint_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type \te_lit[] = { '\\0', '\\0', 'f', '\\0' };\n+  const ext_type*       efrom_next;\n+  const int_type \ti_lit[] = { L'\\0', L'\\0', L'f', L'\\0' };\n+  int \t\t\tsize = sizeof(e_lit);\n+  int_type* \t\ti_arr = new int_type[size + 1];\n+  int_type* \t\ti_ref = new int_type[size + 1];\n+  wmemset(i_arr, 0xdeadbeef, size + 1);\n+  wmemset(i_ref, 0xdeadbeef, size + 1);\n+  int_type*\t\tito_next;\n+\n+  locale \t\tloc;\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // in\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1 = cvt->in(state01, e_lit, e_lit + size, efrom_next, \n+\t\t      i_arr, i_arr + size, ito_next);\n+  VERIFY( r1 == codecvt_base::ok );\n+  VERIFY( efrom_next == e_lit + size );\n+  VERIFY( ito_next == i_arr + size );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n+  VERIFY( !int_traits::compare(ito_next, i_ref, 1) );\n+\n+  delete [] i_arr;\n+  delete [] i_ref;\n+}\n+\n+int main ()\n+{\n+  test05();\n+  return 0;\n+}"}, {"sha": "1be30323b8b3c0d45a122d471b0e20f41660e72c", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/in/wchar_t/6.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F6.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,86 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Test handling of output buffer that is too small.\n+// libstdc++/9247\n+void test06()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<wchar_t>\t\t\tint_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit = \"black pearl jasmine tea\";\n+  const ext_type*       efrom_next;\n+  const int_type* \ti_lit = L\"black pearl jasmine tea\";\n+  int \t\t\tsize = strlen(e_lit);\n+  int_type* \t\ti_arr = new int_type[size + 1];\n+  int_type* \t\ti_ref = new int_type[size + 1];\n+  wmemset(i_arr, 0xdeadbeef, size + 1);\n+  wmemset(i_ref, 0xdeadbeef, size + 1);\n+  int_type*\t\tito_next;\n+\n+  locale \t\tloc;\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // in\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1 = cvt->in(state01, e_lit, e_lit + size, efrom_next, \n+\t\t      i_arr, i_arr + 1, ito_next);\n+  VERIFY( r1 == codecvt_base::partial );\n+  VERIFY( efrom_next == e_lit + 1 );\n+  VERIFY( ito_next == i_arr + 1 );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, 1) );\n+  VERIFY( !int_traits::compare(ito_next, i_ref, size) );\n+\n+  delete [] i_arr;\n+  delete [] i_ref;\n+}\n+\n+int main ()\n+{\n+  test06();\n+  return 0;\n+}"}, {"sha": "f692e9cee6eeb7edb2754a3b45b6828d9797a275", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/in/wchar_t/7.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F7.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,86 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Test handling of illegal input sequence in UTF-8.\n+void test07()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<wchar_t>\t\t\tint_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit = \"a\\xc0\\xff\";\n+  const ext_type*       efrom_next;\n+  const int_type* \ti_lit = L\"a\";\n+  int \t\t\tsize = strlen(e_lit);\n+  int_type* \t\ti_arr = new int_type[size + 1];\n+  int_type* \t\ti_ref = new int_type[size + 1];\n+  wmemset(i_arr, 0xdeadbeef, size + 1);\n+  wmemset(i_ref, 0xdeadbeef, size + 1);\n+  int_type*\t\tito_next;\n+\n+  locale \t\tloc (\"en_US.UTF-8\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // in\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1 = cvt->in(state01, e_lit, e_lit + size, efrom_next, \n+\t\t      i_arr, i_arr + size, ito_next);\n+  VERIFY( r1 == codecvt_base::error );\n+  VERIFY( efrom_next == e_lit + 1 );\n+  VERIFY( ito_next == i_arr + 1 );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, 1) );\n+  VERIFY( !int_traits::compare(ito_next, i_ref, size) );\n+\n+  delete [] i_arr;\n+  delete [] i_ref;\n+}\n+\n+int main ()\n+{\n+  test07();\n+  return 0;\n+}"}, {"sha": "28b1fa04f80ee14d497a21a829930f7c54bc3b3e", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/in/wchar_t/8.cc", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F8.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F8.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F8.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,135 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Test UTF-8 with output buffer larger than needed.\n+void test08()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<wchar_t>\t\t\tint_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit =\n+    \"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    \"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    \"'()*+,-./0123456789:;<=>?@}~\\x7f\\xc2\\x80\\xc2\\x81\\xc2\\x82\\xc2\"\n+    \"\\x83\\xc2\\x84\\xc2\\x85\\xc2\\x86\\xc2\\x87\\xc2\\x88\\xc2\\x89\\xc2\\x8a\"\n+    \"\\xc2\\x8b\\xc2\\x8c\\xc2\\x8d\\xc2\\x8e\\xc2\\x8f\\xc2\\x90\\xc2\\x91\\xc2\"\n+    \"\\x92\\xc2\\x93\\xc2\\x94\\xc2\\x95\\xc2\\x96\\xc2\\x97\\xc2\\x98\\xc2\\x99\"\n+    \"\\xc2\\x9a\\xc2\\x9b\\xc2\\x9c\\xc3\\xba\\xc3\\xbb\\xc3\\xbc\\xc3\\xbd\\xc3\"\n+    \"\\xbe\\xc3\\xbf\\xc4\\x80\\xc4\\x81\\xc4\\x82\\xc4\\x83\\xc4\\x84\\xc4\\x85\"\n+    \"\\xc4\\x86\\xc4\\x87\\xc4\\x88\\xc4\\x89\\xc4\\x8a\\xc4\\x8b\\xc4\\x8c\\xc4\"\n+    \"\\x8d\\xc4\\x8e\\xc4\\x8f\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93\\xc4\\x94\"\n+    \"\\xc4\\x95\\xc4\\x96\\xc4\\x97\\xc4\\x98\\xc4\\x99\\xdf\\xb8\\xdf\\xb9\\xdf\"\n+    \"\\xba\\xdf\\xbb\\xdf\\xbc\\xdf\\xbd\\xdf\\xbe\\xdf\\xbf\\xe0\\xa0\\x80\\xe0\"\n+    \"\\xa0\\x81\\xe0\\xa0\\x82\\xe0\\xa0\\x83\\xe0\\xa0\\x84\\xe0\\xa0\\x85\\xe0\"\n+    \"\\xa0\\x86\\xe0\\xa0\\x87\\xe0\\xa0\\x88\\xe0\\xa0\\x89\\xe0\\xa0\\x8a\\xe0\"\n+    \"\\xa0\\x8b\\xe0\\xa0\\x8c\\xe0\\xa0\\x8d\\xe0\\xa0\\x8e\\xe0\\xa0\\x8f\\xe0\"\n+    \"\\xa0\\x90\\xe0\\xa0\\x91\\xe0\\xa0\\x92\\xe0\\xa0\\x93\\xe0\\xa0\\x94\\xe0\"\n+    \"\\xa0\\x95\\xe0\\xa0\\x96\\xe0\\xa0\\x97\\x1\\x2\\x4\\x8\\x10\\x20@\\xc2\\x80\"\n+    \"\\xc4\\x80\\xc8\\x80\\xd0\\x80\\xe0\\xa0\\x80\\xe1\\x80\\x80\\xe2\\x80\\x80\"\n+    \"\\xe4\\x80\\x80\\xe8\\x80\\x80\\xf0\\x90\\x80\\x80\\xf0\\xa0\\x80\\x80\\xf1\"\n+    \"\\x80\\x80\\x80\\xf2\\x80\\x80\\x80\\xf4\\x80\\x80\\x80\\xf8\\x88\\x80\\x80\"\n+    \"\\x80\\xf8\\x90\\x80\\x80\\x80\\xf8\\xa0\\x80\\x80\\x80\\xf9\\x80\\x80\\x80\"\n+    \"\\x80\\xfa\\x80\\x80\\x80\\x80\\xfc\\x84\\x80\\x80\\x80\\x80\\xfc\\x88\\x80\"\n+    \"\\x80\\x80\\x80\\xfc\\x90\\x80\\x80\\x80\\x80\\xfc\\xa0\\x80\\x80\\x80\\x80\"\n+    \"\\xfd\\x80\\x80\\x80\\x80\\x80\";\n+\n+  const ext_type*       efrom_next;\n+  const int_type \ti_lit[] = {\n+    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc,\n+    0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, L'!',\n+    L'\"', L'#', L'$', L'%', L'&', L'\\'', L'(', L')', L'*', L'+',\n+    L',', L'-', L'.', L'/', L'0', L'1', L'2', L'3', L'4', L'5',\n+    L'6', L'7', L'8', L'9', L':', L';', L'<', L'=', L'>', L'?',\n+    L'@', L'}', L'~', 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,\n+    0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\n+    0x9a, 0x9b, 0x9c, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x100,\n+    0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107, 0x108, 0x109,\n+    0x10a, 0x10b, 0x10c, 0x10d, 0x10e, 0x10f, 0x110, 0x111, 0x112,\n+    0x113, 0x114, 0x115, 0x116, 0x117, 0x118, 0x119, 0x7f8, 0x7f9,\n+    0x7fa, 0x7fb, 0x7fc, 0x7fd, 0x7fe, 0x7ff, 0x800, 0x801, 0x802,\n+    0x803, 0x804, 0x805, 0x806, 0x807, 0x808, 0x809, 0x80a, 0x80b,\n+    0x80c, 0x80d, 0x80e, 0x80f, 0x810, 0x811, 0x812, 0x813, 0x814,\n+    0x815, 0x816, 0x817, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, L'@',\n+    0x80, 0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000,\n+    0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 0x400000,\n+    0x800000, 0x1000000, 0x2000000, 0x4000000, 0x8000000, 0x10000000,\n+    0x20000000, 0x40000000, 0x0\n+  };\n+\n+  int \t\t\tesize = strlen(e_lit);\n+  int \t\t\tisize = wcslen(i_lit);\n+  int_type* \t\ti_arr = new int_type[esize + 1];\n+  int_type* \t\ti_ref = new int_type[esize + 1];\n+  wmemset(i_arr, 0xdeadbeef, esize + 1);\n+  wmemset(i_ref, 0xdeadbeef, esize + 1);\n+  int_type*\t\tito_next;\n+\n+  locale \t\tloc (\"en_US.UTF-8\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // in\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1 = cvt->in(state01, e_lit, e_lit + esize, efrom_next, \n+\t\t      i_arr, i_arr + esize, ito_next);\n+  VERIFY( r1 == codecvt_base::ok );\n+  VERIFY( efrom_next == e_lit + esize );\n+  VERIFY( ito_next == i_arr + isize );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, isize) );\n+  VERIFY( !int_traits::compare(ito_next, i_ref, esize + 1 - isize) );\n+\n+  delete [] i_arr;\n+  delete [] i_ref;\n+}\n+\n+int main ()\n+{\n+  test08();\n+  return 0;\n+}"}, {"sha": "0ddebc771a97111be0b65cea569657f0e3117c8f", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/in/wchar_t/9.cc", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F9.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F9.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fin%2Fwchar_t%2F9.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,158 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Test one source character at a time for UTF-8\n+void test09()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<wchar_t>\t\t\tint_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit =\n+    \"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    \"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    \"'()*+,-./0123456789:;<=>?@}~\\x7f\\xc2\\x80\\xc2\\x81\\xc2\\x82\\xc2\"\n+    \"\\x83\\xc2\\x84\\xc2\\x85\\xc2\\x86\\xc2\\x87\\xc2\\x88\\xc2\\x89\\xc2\\x8a\"\n+    \"\\xc2\\x8b\\xc2\\x8c\\xc2\\x8d\\xc2\\x8e\\xc2\\x8f\\xc2\\x90\\xc2\\x91\\xc2\"\n+    \"\\x92\\xc2\\x93\\xc2\\x94\\xc2\\x95\\xc2\\x96\\xc2\\x97\\xc2\\x98\\xc2\\x99\"\n+    \"\\xc2\\x9a\\xc2\\x9b\\xc2\\x9c\\xc3\\xba\\xc3\\xbb\\xc3\\xbc\\xc3\\xbd\\xc3\"\n+    \"\\xbe\\xc3\\xbf\\xc4\\x80\\xc4\\x81\\xc4\\x82\\xc4\\x83\\xc4\\x84\\xc4\\x85\"\n+    \"\\xc4\\x86\\xc4\\x87\\xc4\\x88\\xc4\\x89\\xc4\\x8a\\xc4\\x8b\\xc4\\x8c\\xc4\"\n+    \"\\x8d\\xc4\\x8e\\xc4\\x8f\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93\\xc4\\x94\"\n+    \"\\xc4\\x95\\xc4\\x96\\xc4\\x97\\xc4\\x98\\xc4\\x99\\xdf\\xb8\\xdf\\xb9\\xdf\"\n+    \"\\xba\\xdf\\xbb\\xdf\\xbc\\xdf\\xbd\\xdf\\xbe\\xdf\\xbf\\xe0\\xa0\\x80\\xe0\"\n+    \"\\xa0\\x81\\xe0\\xa0\\x82\\xe0\\xa0\\x83\\xe0\\xa0\\x84\\xe0\\xa0\\x85\\xe0\"\n+    \"\\xa0\\x86\\xe0\\xa0\\x87\\xe0\\xa0\\x88\\xe0\\xa0\\x89\\xe0\\xa0\\x8a\\xe0\"\n+    \"\\xa0\\x8b\\xe0\\xa0\\x8c\\xe0\\xa0\\x8d\\xe0\\xa0\\x8e\\xe0\\xa0\\x8f\\xe0\"\n+    \"\\xa0\\x90\\xe0\\xa0\\x91\\xe0\\xa0\\x92\\xe0\\xa0\\x93\\xe0\\xa0\\x94\\xe0\"\n+    \"\\xa0\\x95\\xe0\\xa0\\x96\\xe0\\xa0\\x97\\x1\\x2\\x4\\x8\\x10\\x20@\\xc2\\x80\"\n+    \"\\xc4\\x80\\xc8\\x80\\xd0\\x80\\xe0\\xa0\\x80\\xe1\\x80\\x80\\xe2\\x80\\x80\"\n+    \"\\xe4\\x80\\x80\\xe8\\x80\\x80\\xf0\\x90\\x80\\x80\\xf0\\xa0\\x80\\x80\\xf1\"\n+    \"\\x80\\x80\\x80\\xf2\\x80\\x80\\x80\\xf4\\x80\\x80\\x80\\xf8\\x88\\x80\\x80\"\n+    \"\\x80\\xf8\\x90\\x80\\x80\\x80\\xf8\\xa0\\x80\\x80\\x80\\xf9\\x80\\x80\\x80\"\n+    \"\\x80\\xfa\\x80\\x80\\x80\\x80\\xfc\\x84\\x80\\x80\\x80\\x80\\xfc\\x88\\x80\"\n+    \"\\x80\\x80\\x80\\xfc\\x90\\x80\\x80\\x80\\x80\\xfc\\xa0\\x80\\x80\\x80\\x80\"\n+    \"\\xfd\\x80\\x80\\x80\\x80\\x80\";\n+\n+  const ext_type*       efrom = e_lit;\n+  const ext_type*       efrom_next;\n+  const int_type \ti_lit[] = {\n+    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc,\n+    0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, L'!',\n+    L'\"', L'#', L'$', L'%', L'&', L'\\'', L'(', L')', L'*', L'+',\n+    L',', L'-', L'.', L'/', L'0', L'1', L'2', L'3', L'4', L'5',\n+    L'6', L'7', L'8', L'9', L':', L';', L'<', L'=', L'>', L'?',\n+    L'@', L'}', L'~', 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,\n+    0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\n+    0x9a, 0x9b, 0x9c, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x100,\n+    0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107, 0x108, 0x109,\n+    0x10a, 0x10b, 0x10c, 0x10d, 0x10e, 0x10f, 0x110, 0x111, 0x112,\n+    0x113, 0x114, 0x115, 0x116, 0x117, 0x118, 0x119, 0x7f8, 0x7f9,\n+    0x7fa, 0x7fb, 0x7fc, 0x7fd, 0x7fe, 0x7ff, 0x800, 0x801, 0x802,\n+    0x803, 0x804, 0x805, 0x806, 0x807, 0x808, 0x809, 0x80a, 0x80b,\n+    0x80c, 0x80d, 0x80e, 0x80f, 0x810, 0x811, 0x812, 0x813, 0x814,\n+    0x815, 0x816, 0x817, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, L'@',\n+    0x80, 0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000,\n+    0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 0x400000,\n+    0x800000, 0x1000000, 0x2000000, 0x4000000, 0x8000000, 0x10000000,\n+    0x20000000, 0x40000000, 0x0\n+  };\n+\n+  int \t\t\tesize = strlen(e_lit);\n+  int \t\t\tisize = wcslen(i_lit);\n+  int_type* \t\ti_arr = new int_type[esize + 1];\n+  int_type* \t\ti_ref = new int_type[esize + 1];\n+  wmemset(i_arr, 0xdeadbeef, esize + 1);\n+  wmemset(i_ref, 0xdeadbeef, esize + 1);\n+  int_type*\t\tito = i_arr;\n+  int_type*\t\tito_next;\n+\n+  locale \t\tloc (\"en_US.UTF-8\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // in\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1;\n+\n+  for (int i = 0; i <= esize; ++i)\n+    {\n+      r1 = cvt->in(state01, efrom, e_lit + i, efrom_next, \n+\t\t   ito, i_arr + esize, ito_next);\n+      \n+      printf(\"%d %d %d %x %x\\n\", efrom - e_lit, i, efrom_next - e_lit,\n+\t     efrom[-1], ito[-1]);\n+\n+      // It it not clear if partial should ever be returned here\n+      // (see DR 382).\n+      VERIFY( r1 == codecvt_base::ok || r1 == codecvt_base::partial );\n+      VERIFY( efrom_next >= efrom );\n+      VERIFY( efrom_next <= e_lit + i );\n+      VERIFY( ito_next >= ito );\n+      VERIFY( ito_next <= i_arr + isize );\n+      VERIFY( !int_traits::compare(i_arr, i_lit, ito_next - i_arr) ); \n+      VERIFY( !int_traits::compare(ito_next, i_ref,\n+\t\t\t\t   i_arr + esize + 1 - ito_next) );\n+\n+      efrom = efrom_next;\n+      ito = ito_next;\n+    }\n+\n+  VERIFY( r1 == codecvt_base::ok );\n+  VERIFY( efrom_next == e_lit + esize );\n+  VERIFY( ito_next == i_arr + isize );\n+\n+  delete [] i_arr;\n+  delete [] i_ref;\n+}\n+\n+int main ()\n+{\n+  test09();\n+  return 0;\n+}"}, {"sha": "3ea244dcbb0d9f5cbb4447c822968e5da4fe8b16", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/length/char/1.cc", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fchar%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fchar%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fchar%2F1.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -33,26 +33,14 @@ void test01()\n \n   bool \t\t\ttest = true;\n   const char* \t\tc_lit = \"black pearl jasmine tea\";\n-  const char* \t        from_next;\n   int \t\t\tsize = 25;\n-  char* \t\tc_arr = new char[size];\n-  char*                 c_ref = new char[size];\n-  char*\t\t\tto_next;\n \n   locale \t\tloc = locale::classic();\n   c_codecvt::state_type state;\n   const c_codecvt* \tcvt = &use_facet<c_codecvt>(loc); \n \n-  // According to the resolution of DR19 (see also libstd++/9168), in\n-  // case of degenerate conversion ('noconv'), \"there are no changes to\n-  // the values in [to, to_limit).\"\n-  memset(c_ref, 'X', size);\n-\n   int j = cvt->length(state, c_lit, c_lit + size, 5);\n   VERIFY( j == 5 );\n-\n-  delete [] c_arr;\n-  delete [] c_ref;\n }\n \n int main ()"}, {"sha": "6e0a7e96f2ea0516468fe1522106b7845b96a621", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/length/char/2.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fchar%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fchar%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fchar%2F2.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,69 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+bool length_called = false;\n+\n+class length_codecvt : public std::codecvt<char, char, std::mbstate_t>\n+{\n+  typedef std::codecvt<char, char, std::mbstate_t> c_codecvt;\n+\n+public:\n+  // DR75: type of first argument of do_length is state_type&\n+  virtual int do_length(state_type& state, const extern_type* from,\n+                        const extern_type* end, std::size_t max) const\n+  {\n+    length_called = true;\n+    return c_codecvt::do_length(state, from, end, max);\n+  }\n+};\n+\n+// Required instantiation, degenerate conversion.\n+// codecvt<char, char, mbstate_t>\n+//\n+// libstdc++/9224\n+void test02()\n+{\n+  using namespace std;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef codecvt<char, char, mbstate_t> \tc_codecvt;\n+\n+  bool \t\t\ttest = true;\n+  const char* \t\tc_lit = \"black pearl jasmine tea\";\n+  int \t\t\tsize = 25;\n+\n+  locale \t\tloc (locale::classic(), new length_codecvt);\n+  c_codecvt::state_type state;\n+  const c_codecvt* \tcvt = &use_facet<c_codecvt>(loc); \n+\n+  length_called = false;\n+  cvt->length(state, c_lit, c_lit + size, 5);\n+  VERIFY( length_called );\n+}\n+\n+int main ()\n+{\n+  test02();\n+  return 0;\n+}"}, {"sha": "100de8567fccf546788c1d8a498205e7a26c9e6e", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/length/wchar_t/1.cc", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F1.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -42,22 +42,11 @@ void test01()\n {\n   using namespace std;\n   typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n-  typedef codecvt_base::result\t\t\tresult;\n-  typedef wchar_t\t\t\t\tint_type;\n   typedef char\t\t\t\t\text_type;\n-  typedef char_traits<wchar_t>\t\t\tint_traits;\n-  typedef char_traits<char>\t\t\text_traits;\n \n   bool \t\t\ttest = true;\n   const ext_type* \te_lit = \"black pearl jasmine tea\";\n-  const ext_type*       efrom_next;\n-  const int_type* \ti_lit = L\"black pearl jasmine tea\";\n-  const int_type*       ifrom_next;\n   int \t\t\tsize = strlen(e_lit);\n-  ext_type* \t\te_arr = new ext_type[size + 1];\n-  ext_type*\t\teto_next;\n-  int_type* \t\ti_arr = new int_type[size + 1];\n-  int_type*\t\tito_next;\n \n   locale \t\tloc;\n   const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n@@ -66,9 +55,6 @@ void test01()\n   zero_state(state04);\n   int j = cvt->length(state04, e_lit, e_lit + size, 5);\n   VERIFY( j == 5 );\n-\n-  delete [] e_arr;\n-  delete [] i_arr;\n }\n \n int main ()"}, {"sha": "0e90fbdc833383e1c6fe3ce7f353cded761c21dc", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/length/wchar_t/2.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F2.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,88 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test02()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef char\t\t\t\t\text_type;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit =\n+    \"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    \"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    \"'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\"\n+    \"abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\"\n+    \"\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\"\n+    \"\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\"\n+    \"\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\"\n+    \"\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n+    \"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\"\n+    \"\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n+    \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n+    \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\"\n+    \"\\xff\";\n+  int \t\t\tsize = strlen(e_lit);\n+\n+  locale \t\tloc (\"en_US.ISO-8859-1\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  int i = cvt->length(state01, e_lit, e_lit + size, 5);\n+  VERIFY( i == 5 );\n+\n+  w_codecvt::state_type state02;\n+  zero_state(state02);\n+  int j = cvt->length(state02, e_lit, e_lit + size, size);\n+  VERIFY( j == size );\n+\n+  w_codecvt::state_type state03;\n+  zero_state(state03);\n+  int k = cvt->length(state03, e_lit, e_lit + size, size * 2);\n+  VERIFY( k == size );\n+}\n+\n+int main ()\n+{\n+  test02();\n+  return 0;\n+}"}, {"sha": "8031c3edee0caf7342de852cea74ae55c3aab00e", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/length/wchar_t/3.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F3.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,88 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test03()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef char\t\t\t\t\text_type;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit =\n+    \"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    \"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    \"'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\"\n+    \"abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\"\n+    \"\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\"\n+    \"\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\"\n+    \"\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\"\n+    \"\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n+    \"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\"\n+    \"\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n+    \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n+    \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\"\n+    \"\\xff\";\n+  int \t\t\tsize = strlen(e_lit);\n+\n+  locale \t\tloc (\"en_US.ISO-8859-15\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  int i = cvt->length(state01, e_lit, e_lit + size, 5);\n+  VERIFY( i == 5 );\n+\n+  w_codecvt::state_type state02;\n+  zero_state(state02);\n+  int j = cvt->length(state02, e_lit, e_lit + size, size);\n+  VERIFY( j == size );\n+\n+  w_codecvt::state_type state03;\n+  zero_state(state03);\n+  int k = cvt->length(state03, e_lit, e_lit + size, size * 2);\n+  VERIFY( k == size );\n+}\n+\n+int main ()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "6a802bd2856c8631954638547755307457436cbc", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/length/wchar_t/4.cc", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F4.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,127 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test04()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit =\n+    \"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    \"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    \"'()*+,-./0123456789:;<=>?@}~\\x7f\\xc2\\x80\\xc2\\x81\\xc2\\x82\\xc2\"\n+    \"\\x83\\xc2\\x84\\xc2\\x85\\xc2\\x86\\xc2\\x87\\xc2\\x88\\xc2\\x89\\xc2\\x8a\"\n+    \"\\xc2\\x8b\\xc2\\x8c\\xc2\\x8d\\xc2\\x8e\\xc2\\x8f\\xc2\\x90\\xc2\\x91\\xc2\"\n+    \"\\x92\\xc2\\x93\\xc2\\x94\\xc2\\x95\\xc2\\x96\\xc2\\x97\\xc2\\x98\\xc2\\x99\"\n+    \"\\xc2\\x9a\\xc2\\x9b\\xc2\\x9c\\xc3\\xba\\xc3\\xbb\\xc3\\xbc\\xc3\\xbd\\xc3\"\n+    \"\\xbe\\xc3\\xbf\\xc4\\x80\\xc4\\x81\\xc4\\x82\\xc4\\x83\\xc4\\x84\\xc4\\x85\"\n+    \"\\xc4\\x86\\xc4\\x87\\xc4\\x88\\xc4\\x89\\xc4\\x8a\\xc4\\x8b\\xc4\\x8c\\xc4\"\n+    \"\\x8d\\xc4\\x8e\\xc4\\x8f\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93\\xc4\\x94\"\n+    \"\\xc4\\x95\\xc4\\x96\\xc4\\x97\\xc4\\x98\\xc4\\x99\\xdf\\xb8\\xdf\\xb9\\xdf\"\n+    \"\\xba\\xdf\\xbb\\xdf\\xbc\\xdf\\xbd\\xdf\\xbe\\xdf\\xbf\\xe0\\xa0\\x80\\xe0\"\n+    \"\\xa0\\x81\\xe0\\xa0\\x82\\xe0\\xa0\\x83\\xe0\\xa0\\x84\\xe0\\xa0\\x85\\xe0\"\n+    \"\\xa0\\x86\\xe0\\xa0\\x87\\xe0\\xa0\\x88\\xe0\\xa0\\x89\\xe0\\xa0\\x8a\\xe0\"\n+    \"\\xa0\\x8b\\xe0\\xa0\\x8c\\xe0\\xa0\\x8d\\xe0\\xa0\\x8e\\xe0\\xa0\\x8f\\xe0\"\n+    \"\\xa0\\x90\\xe0\\xa0\\x91\\xe0\\xa0\\x92\\xe0\\xa0\\x93\\xe0\\xa0\\x94\\xe0\"\n+    \"\\xa0\\x95\\xe0\\xa0\\x96\\xe0\\xa0\\x97\\x1\\x2\\x4\\x8\\x10\\x20@\\xc2\\x80\"\n+    \"\\xc4\\x80\\xc8\\x80\\xd0\\x80\\xe0\\xa0\\x80\\xe1\\x80\\x80\\xe2\\x80\\x80\"\n+    \"\\xe4\\x80\\x80\\xe8\\x80\\x80\\xf0\\x90\\x80\\x80\\xf0\\xa0\\x80\\x80\\xf1\"\n+    \"\\x80\\x80\\x80\\xf2\\x80\\x80\\x80\\xf4\\x80\\x80\\x80\\xf8\\x88\\x80\\x80\"\n+    \"\\x80\\xf8\\x90\\x80\\x80\\x80\\xf8\\xa0\\x80\\x80\\x80\\xf9\\x80\\x80\\x80\"\n+    \"\\x80\\xfa\\x80\\x80\\x80\\x80\\xfc\\x84\\x80\\x80\\x80\\x80\\xfc\\x88\\x80\"\n+    \"\\x80\\x80\\x80\\xfc\\x90\\x80\\x80\\x80\\x80\\xfc\\xa0\\x80\\x80\\x80\\x80\"\n+    \"\\xfd\\x80\\x80\\x80\\x80\\x80\";\n+\n+  const ext_type*       efrom_next;\n+  const int_type \ti_lit[] = {\n+    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc,\n+    0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, L'!',\n+    L'\"', L'#', L'$', L'%', L'&', L'\\'', L'(', L')', L'*', L'+',\n+    L',', L'-', L'.', L'/', L'0', L'1', L'2', L'3', L'4', L'5',\n+    L'6', L'7', L'8', L'9', L':', L';', L'<', L'=', L'>', L'?',\n+    L'@', L'}', L'~', 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,\n+    0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\n+    0x9a, 0x9b, 0x9c, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x100,\n+    0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107, 0x108, 0x109,\n+    0x10a, 0x10b, 0x10c, 0x10d, 0x10e, 0x10f, 0x110, 0x111, 0x112,\n+    0x113, 0x114, 0x115, 0x116, 0x117, 0x118, 0x119, 0x7f8, 0x7f9,\n+    0x7fa, 0x7fb, 0x7fc, 0x7fd, 0x7fe, 0x7ff, 0x800, 0x801, 0x802,\n+    0x803, 0x804, 0x805, 0x806, 0x807, 0x808, 0x809, 0x80a, 0x80b,\n+    0x80c, 0x80d, 0x80e, 0x80f, 0x810, 0x811, 0x812, 0x813, 0x814,\n+    0x815, 0x816, 0x817, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, L'@',\n+    0x80, 0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000,\n+    0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 0x400000,\n+    0x800000, 0x1000000, 0x2000000, 0x4000000, 0x8000000, 0x10000000,\n+    0x20000000, 0x40000000, 0x0\n+  };\n+\n+  int \t\t\tesize = strlen(e_lit);\n+  int \t\t\tisize = wcslen(i_lit);\n+\n+  locale \t\tloc (\"en_US.UTF-8\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  int i = cvt->length(state01, e_lit, e_lit + esize, 5);\n+  VERIFY( i == 5 );\n+\n+  w_codecvt::state_type state02;\n+  zero_state(state02);\n+  int j = cvt->length(state02, e_lit, e_lit + esize, isize);\n+  VERIFY( j == esize );\n+\n+  w_codecvt::state_type state03;\n+  zero_state(state03);\n+  int k = cvt->length(state03, e_lit, e_lit + esize, esize * 2);\n+  VERIFY( k == esize );\n+}\n+\n+int main ()\n+{\n+  test04();\n+  return 0;\n+}"}, {"sha": "284233e7b6bf7afdab7b582b7c119c2aab8f2cc9", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/length/wchar_t/5.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F5.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,64 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test05()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef char\t\t\t\t\text_type;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type \te_lit[] = { '\\0', '\\0', 'f', '\\0' };\n+  int \t\t\tsize = sizeof(e_lit);\n+\n+  locale \t\tloc;\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  w_codecvt::state_type state04;\n+  zero_state(state04);\n+  int j = cvt->length(state04, e_lit, e_lit + size, 5);\n+  VERIFY( j == size );\n+}\n+\n+int main ()\n+{\n+  test05();\n+  return 0;\n+}"}, {"sha": "76c151edf05ceda35087c13e173f96c7c15bb76f", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/length/wchar_t/6.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F6.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,84 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+bool length_called = false;\n+\n+class length_codecvt : public std::codecvt<wchar_t, char, std::mbstate_t>\n+{\n+  typedef std::codecvt<wchar_t, char, std::mbstate_t> w_codecvt;\n+\n+public:\n+  // DR75: type of first argument of do_length is state_type&\n+  virtual int do_length(state_type& state, const extern_type* from,\n+                        const extern_type* end, std::size_t max) const\n+  {\n+    length_called = true;\n+    return w_codecvt::do_length(state, from, end, max);\n+  }\n+};\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// libstdc++/9224\n+void test06()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef char\t\t\t\t\text_type;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit = \"black pearl jasmine tea\";\n+  int \t\t\tsize = strlen(e_lit);\n+\n+  locale \t\tloc;\n+  loc = locale(loc, new length_codecvt);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  w_codecvt::state_type state04;\n+  zero_state(state04);\n+  length_called = false;\n+  cvt->length(state04, e_lit, e_lit + size, 5);\n+  VERIFY( length_called );\n+}\n+\n+int main ()\n+{\n+  test06();\n+  return 0;\n+}"}, {"sha": "8a275e35a37dccf793411009c58d86bd0f33dfcf", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/length/wchar_t/7.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Flength%2Fwchar_t%2F7.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,79 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Test handling of illegal input sequence in UTF-8.\n+void test07()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit = \"a\\xc0\\xff\";\n+  const ext_type*       efrom_next;\n+  int \t\t\tsize = strlen(e_lit);\n+\n+  locale \t\tloc (\"en_US.UTF-8\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  int i = cvt->length(state01, e_lit, e_lit + size, 1);\n+  VERIFY( i == 1 );\n+\n+  w_codecvt::state_type state02;\n+  zero_state(state02);\n+  int j = cvt->length(state02, e_lit, e_lit + size, size);\n+  VERIFY( j == 1 );\n+\n+  w_codecvt::state_type state03;\n+  zero_state(state03);\n+  int k = cvt->length(state03, e_lit, e_lit + size, size * 2);\n+  VERIFY( k == 1 );\n+}\n+\n+int main ()\n+{\n+  test07();\n+  return 0;\n+}"}, {"sha": "b2995e3b2fb318b0fec62e83f70b37e100878e50", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/max_length/wchar_t/1.cc", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F1.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -23,51 +23,18 @@\n #include <locale>\n #include <testsuite_hooks.h>\n \n-\n-// Need to explicitly set the state(mbstate_t) to zero.\n-// How to do this is not specified by the ISO C99 standard, so we\n-// might need to add some operators to make the intuiative case\n-// work:\n-//   w_codecvt::state_type state00;\n-//   state00 = 0;  \n-// or, can use this explicit \"C\" initialization:\n-//   w_codecvt::state_type state01 = {0, 0};\n-// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n-void\n-zero_state(std::mbstate_t& state)\n-{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n-\n // Required instantiation\n // codecvt<wchar_t, char, mbstate_t>\n void test01()\n {\n   using namespace std;\n   typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n-  typedef codecvt_base::result\t\t\tresult;\n-  typedef wchar_t\t\t\t\tint_type;\n-  typedef char\t\t\t\t\text_type;\n-  typedef char_traits<wchar_t>\t\t\tint_traits;\n-  typedef char_traits<char>\t\t\text_traits;\n \n-  bool \t\t\ttest = true;\n-  const ext_type* \te_lit = \"black pearl jasmine tea\";\n-  const ext_type*       efrom_next;\n-  const int_type* \ti_lit = L\"black pearl jasmine tea\";\n-  const int_type*       ifrom_next;\n-  int \t\t\tsize = strlen(e_lit);\n-  ext_type* \t\te_arr = new ext_type[size + 1];\n-  ext_type*\t\teto_next;\n-  int_type* \t\ti_arr = new int_type[size + 1];\n-  int_type*\t\tito_next;\n-\n-  locale \t\tloc;\n-  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+  locale \t\tloc_c = locale::classic();\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc_c); \n \n   int k = cvt->max_length();\n   VERIFY( k == 1 );\n-\n-  delete [] e_arr;\n-  delete [] i_arr;\n }\n \n int main ()"}, {"sha": "37fdf5444496a3a31817c25ff0bb8c5eb7a87300", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/max_length/wchar_t/2.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F2.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,45 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test02()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-1\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  int k = cvt->max_length();\n+  VERIFY( k == 1 ); // ISO-8859-1 is a single-byte encoding\n+}\n+\n+int main ()\n+{\n+  test02();\n+  return 0;\n+}"}, {"sha": "d6778d18a0764f658b9ae6c97522a31184864f47", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/max_length/wchar_t/3.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F3.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,45 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test03()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-15\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  int k = cvt->max_length();\n+  VERIFY( k == 1 ); // ISO-8859-15 is a single-byte encoding\n+}\n+\n+int main ()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "fd85941ab374c025ac95572334d7b1b5aba2394f", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/max_length/wchar_t/4.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fmax_length%2Fwchar_t%2F4.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,47 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test04()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+\n+  locale \t\tloc (\"en_US.UTF-8\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  int k = cvt->max_length();\n+  // Each UCS-4 wide character can be converted to at most 6 narrow\n+  // characters in the UTF-8 encoding.\n+  VERIFY( k == 6 ); \n+}\n+\n+int main ()\n+{\n+  test04();\n+  return 0;\n+}"}, {"sha": "82a57c6fdbdd85974ed3329f19ff020e7d8f99b5", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/out/wchar_t/1.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F1.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -45,19 +45,18 @@ void test01()\n   typedef codecvt_base::result\t\t\tresult;\n   typedef wchar_t\t\t\t\tint_type;\n   typedef char\t\t\t\t\text_type;\n-  typedef char_traits<wchar_t>\t\t\tint_traits;\n   typedef char_traits<char>\t\t\text_traits;\n \n   bool \t\t\ttest = true;\n   const ext_type* \te_lit = \"black pearl jasmine tea\";\n-  const ext_type*       efrom_next;\n   const int_type* \ti_lit = L\"black pearl jasmine tea\";\n   const int_type*       ifrom_next;\n   int \t\t\tsize = strlen(e_lit);\n   ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type* \t\te_ref = new ext_type[size + 1];\n+  memset(e_arr, 0xf0, size + 1);\n+  memset(e_ref, 0xf0, size + 1);\n   ext_type*\t\teto_next;\n-  int_type* \t\ti_arr = new int_type[size + 1];\n-  int_type*\t\tito_next;\n \n   locale \t\tloc;\n   const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n@@ -68,12 +67,13 @@ void test01()\n   result r2 = cvt->out(state02, i_lit, i_lit + size, ifrom_next, \n \t\t       e_arr, e_arr + size, eto_next);\n   VERIFY( r2 == codecvt_base::ok );\n-  VERIFY( !ext_traits::compare(e_arr, e_lit, size) ); \n   VERIFY( ifrom_next == i_lit + size );\n   VERIFY( eto_next == e_arr + size );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, size) );\n+  VERIFY( !ext_traits::compare(eto_next, e_ref, 1) );\n \n   delete [] e_arr;\n-  delete [] i_arr;\n+  delete [] e_ref;\n }\n \n int main ()"}, {"sha": "c2e807da594ad78e981701eccc8ce36e7d4a2992", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/out/wchar_t/2.cc", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F2.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,112 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test02()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<char>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit =\n+    \"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    \"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    \"'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\"\n+    \"abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\"\n+    \"\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\"\n+    \"\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\"\n+    \"\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\"\n+    \"\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n+    \"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\"\n+    \"\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n+    \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n+    \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\"\n+    \"\\xff\";\n+\n+  const int_type* \ti_lit =\n+    L\"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    L\"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    L\"'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\"\n+    L\"abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\"\n+    L\"\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\"\n+    L\"\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\"\n+    L\"\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\"\n+    L\"\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n+    L\"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\"\n+    L\"\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n+    L\"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n+    L\"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\"\n+    L\"\\xff\";\n+\n+  const int_type*       ifrom_next;\n+  int \t\t\tsize = strlen(e_lit);\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type* \t\te_ref = new ext_type[size + 1];\n+  memset(e_arr, 0xf0, size + 1);\n+  memset(e_ref, 0xf0, size + 1);\n+  ext_type*\t\teto_next;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-1\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // out\n+  w_codecvt::state_type state02;\n+  zero_state(state02);  \n+  result r2 = cvt->out(state02, i_lit, i_lit + size, ifrom_next, \n+\t\t       e_arr, e_arr + size, eto_next);\n+  VERIFY( r2 == codecvt_base::ok );\n+  VERIFY( ifrom_next == i_lit + size );\n+  VERIFY( eto_next == e_arr + size );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, size) );\n+  VERIFY( !ext_traits::compare(eto_next, e_ref, 1) );\n+\n+  delete [] e_arr;\n+  delete [] e_ref;\n+}\n+\n+int main ()\n+{\n+  test02();\n+  return 0;\n+}"}, {"sha": "d92e01c7d2bdc299ce88e74677a8924ba289354f", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/out/wchar_t/3.cc", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F3.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,126 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test03()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<char>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit =\n+    \"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    \"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    \"'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\"\n+    \"abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\"\n+    \"\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\"\n+    \"\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\"\n+    \"\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\"\n+    \"\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n+    \"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\"\n+    \"\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n+    \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n+    \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\"\n+    \"\\xff\";\n+\n+  const int_type \ti_lit[] = {\n+    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc,\n+    0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, L'!',\n+    L'\"', L'#', L'$', L'%', L'&', L'\\'', L'(', L')', L'*', L'+',\n+    L',', L'-', L'.', L'/', L'0', L'1', L'2', L'3', L'4', L'5',\n+    L'6', L'7', L'8', L'9', L':', L';', L'<', L'=', L'>', L'?',\n+    L'@', L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H', L'I',\n+    L'J', L'K', L'L', L'M', L'N', L'O', L'P', L'Q', L'R', L'S',\n+    L'T', L'U', L'V', L'W', L'X', L'Y', L'Z', L'[', L'\\\\', L']',\n+    L'^', L'_', L'`', L'a', L'b', L'c', L'd', L'e', L'f', L'g',\n+    L'h', L'i', L'j', L'k', L'l', L'm', L'n', L'o', L'p', L'q',\n+    L'r', L's', L't', L'u', L'v', L'w', L'x', L'y', L'z', L'{',\n+    L'|', L'}', L'~', 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,\n+    0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\n+    0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n+    0x20ac, 0xa5, 0x160, 0xa7, 0x161, 0xa9, 0xaa, 0xab, 0xac, 0xad,\n+    0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0x17d, 0xb5, 0xb6, 0xb7,\n+    0x17e, 0xb9, 0xba, 0xbb, 0x152, 0x153, 0x178, 0xbf, 0xc0, 0xc1,\n+    0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n+    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5,\n+    0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,\n+    0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n+    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd,\n+    0xfe, 0xff, 0x0\n+  };\n+\n+  const int_type*       ifrom_next;\n+  int \t\t\tsize = strlen(e_lit);\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type* \t\te_ref = new ext_type[size + 1];\n+  memset(e_arr, 0xf0, size + 1);\n+  memset(e_ref, 0xf0, size + 1);\n+  ext_type*\t\teto_next;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-15\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // out\n+  w_codecvt::state_type state02;\n+  zero_state(state02);  \n+  result r2 = cvt->out(state02, i_lit, i_lit + size, ifrom_next, \n+\t\t       e_arr, e_arr + size, eto_next);\n+  VERIFY( r2 == codecvt_base::ok );\n+  VERIFY( ifrom_next == i_lit + size );\n+  VERIFY( eto_next == e_arr + size );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, size) );\n+  VERIFY( !ext_traits::compare(eto_next, e_ref, 1) );\n+\n+  delete [] e_arr;\n+  delete [] e_ref;\n+}\n+\n+int main ()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "626ff70efe44f8cbf998a15ba04faf4e2e871ff4", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/out/wchar_t/4.cc", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F4.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,133 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test04()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<char>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit =\n+    \"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    \"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    \"'()*+,-./0123456789:;<=>?@}~\\x7f\\xc2\\x80\\xc2\\x81\\xc2\\x82\\xc2\"\n+    \"\\x83\\xc2\\x84\\xc2\\x85\\xc2\\x86\\xc2\\x87\\xc2\\x88\\xc2\\x89\\xc2\\x8a\"\n+    \"\\xc2\\x8b\\xc2\\x8c\\xc2\\x8d\\xc2\\x8e\\xc2\\x8f\\xc2\\x90\\xc2\\x91\\xc2\"\n+    \"\\x92\\xc2\\x93\\xc2\\x94\\xc2\\x95\\xc2\\x96\\xc2\\x97\\xc2\\x98\\xc2\\x99\"\n+    \"\\xc2\\x9a\\xc2\\x9b\\xc2\\x9c\\xc3\\xba\\xc3\\xbb\\xc3\\xbc\\xc3\\xbd\\xc3\"\n+    \"\\xbe\\xc3\\xbf\\xc4\\x80\\xc4\\x81\\xc4\\x82\\xc4\\x83\\xc4\\x84\\xc4\\x85\"\n+    \"\\xc4\\x86\\xc4\\x87\\xc4\\x88\\xc4\\x89\\xc4\\x8a\\xc4\\x8b\\xc4\\x8c\\xc4\"\n+    \"\\x8d\\xc4\\x8e\\xc4\\x8f\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93\\xc4\\x94\"\n+    \"\\xc4\\x95\\xc4\\x96\\xc4\\x97\\xc4\\x98\\xc4\\x99\\xdf\\xb8\\xdf\\xb9\\xdf\"\n+    \"\\xba\\xdf\\xbb\\xdf\\xbc\\xdf\\xbd\\xdf\\xbe\\xdf\\xbf\\xe0\\xa0\\x80\\xe0\"\n+    \"\\xa0\\x81\\xe0\\xa0\\x82\\xe0\\xa0\\x83\\xe0\\xa0\\x84\\xe0\\xa0\\x85\\xe0\"\n+    \"\\xa0\\x86\\xe0\\xa0\\x87\\xe0\\xa0\\x88\\xe0\\xa0\\x89\\xe0\\xa0\\x8a\\xe0\"\n+    \"\\xa0\\x8b\\xe0\\xa0\\x8c\\xe0\\xa0\\x8d\\xe0\\xa0\\x8e\\xe0\\xa0\\x8f\\xe0\"\n+    \"\\xa0\\x90\\xe0\\xa0\\x91\\xe0\\xa0\\x92\\xe0\\xa0\\x93\\xe0\\xa0\\x94\\xe0\"\n+    \"\\xa0\\x95\\xe0\\xa0\\x96\\xe0\\xa0\\x97\\x1\\x2\\x4\\x8\\x10\\x20@\\xc2\\x80\"\n+    \"\\xc4\\x80\\xc8\\x80\\xd0\\x80\\xe0\\xa0\\x80\\xe1\\x80\\x80\\xe2\\x80\\x80\"\n+    \"\\xe4\\x80\\x80\\xe8\\x80\\x80\\xf0\\x90\\x80\\x80\\xf0\\xa0\\x80\\x80\\xf1\"\n+    \"\\x80\\x80\\x80\\xf2\\x80\\x80\\x80\\xf4\\x80\\x80\\x80\\xf8\\x88\\x80\\x80\"\n+    \"\\x80\\xf8\\x90\\x80\\x80\\x80\\xf8\\xa0\\x80\\x80\\x80\\xf9\\x80\\x80\\x80\"\n+    \"\\x80\\xfa\\x80\\x80\\x80\\x80\\xfc\\x84\\x80\\x80\\x80\\x80\\xfc\\x88\\x80\"\n+    \"\\x80\\x80\\x80\\xfc\\x90\\x80\\x80\\x80\\x80\\xfc\\xa0\\x80\\x80\\x80\\x80\"\n+    \"\\xfd\\x80\\x80\\x80\\x80\\x80\";\n+\n+  const int_type \ti_lit[] = {\n+    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc,\n+    0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, L'!',\n+    L'\"', L'#', L'$', L'%', L'&', L'\\'', L'(', L')', L'*', L'+',\n+    L',', L'-', L'.', L'/', L'0', L'1', L'2', L'3', L'4', L'5',\n+    L'6', L'7', L'8', L'9', L':', L';', L'<', L'=', L'>', L'?',\n+    L'@', L'}', L'~', 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,\n+    0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\n+    0x9a, 0x9b, 0x9c, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x100,\n+    0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107, 0x108, 0x109,\n+    0x10a, 0x10b, 0x10c, 0x10d, 0x10e, 0x10f, 0x110, 0x111, 0x112,\n+    0x113, 0x114, 0x115, 0x116, 0x117, 0x118, 0x119, 0x7f8, 0x7f9,\n+    0x7fa, 0x7fb, 0x7fc, 0x7fd, 0x7fe, 0x7ff, 0x800, 0x801, 0x802,\n+    0x803, 0x804, 0x805, 0x806, 0x807, 0x808, 0x809, 0x80a, 0x80b,\n+    0x80c, 0x80d, 0x80e, 0x80f, 0x810, 0x811, 0x812, 0x813, 0x814,\n+    0x815, 0x816, 0x817, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, L'@',\n+    0x80, 0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000,\n+    0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 0x400000,\n+    0x800000, 0x1000000, 0x2000000, 0x4000000, 0x8000000, 0x10000000,\n+    0x20000000, 0x40000000, 0x0\n+  };\n+\n+  const int_type*       ifrom_next;\n+  int \t\t\tesize = strlen(e_lit);\n+  int \t\t\tisize = wcslen(i_lit);\n+  ext_type* \t\te_arr = new ext_type[esize + 1];\n+  ext_type* \t\te_ref = new ext_type[esize + 1];\n+  memset(e_arr, 0xf0, esize + 1);\n+  memset(e_ref, 0xf0, esize + 1);\n+  ext_type*\t\teto_next;\n+\n+  locale \t\tloc (\"en_US.UTF-8\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // out\n+  w_codecvt::state_type state02;\n+  zero_state(state02);  \n+  result r2 = cvt->out(state02, i_lit, i_lit + isize, ifrom_next, \n+\t\t       e_arr, e_arr + esize, eto_next);\n+  VERIFY( r2 == codecvt_base::ok );\n+  VERIFY( ifrom_next == i_lit + isize );\n+  VERIFY( eto_next == e_arr + esize );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, esize) );\n+  VERIFY( !ext_traits::compare(eto_next, e_ref, 1) );\n+\n+  delete [] e_arr;\n+  delete [] e_ref;\n+}\n+\n+int main ()\n+{\n+  test04();\n+  return 0;\n+}"}, {"sha": "13ca4b28719541dddcefe50d588f4cb6204a5950", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/out/wchar_t/5.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F5.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,86 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Test handling of '\\0' characters in input\n+// libstdc++/9246\n+void test05()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<char>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type \te_lit[] = { '\\0', '\\0', 'f', '\\0' };\n+  const int_type \ti_lit[] = { L'\\0', L'\\0', L'f', L'\\0' };\n+  const int_type*       ifrom_next;\n+  int \t\t\tsize = sizeof(e_lit);\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type* \t\te_ref = new ext_type[size + 1];\n+  memset(e_arr, 0xf0, size + 1);\n+  memset(e_ref, 0xf0, size + 1);\n+  ext_type*\t\teto_next;\n+\n+  locale \t\tloc;\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // out\n+  w_codecvt::state_type state02;\n+  zero_state(state02);  \n+  result r2 = cvt->out(state02, i_lit, i_lit + size, ifrom_next, \n+\t\t       e_arr, e_arr + size, eto_next);\n+  VERIFY( r2 == codecvt_base::ok );\n+  VERIFY( ifrom_next == i_lit + size );\n+  VERIFY( eto_next == e_arr + size );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, size) );\n+  VERIFY( !ext_traits::compare(eto_next, e_ref, 1) );\n+\n+  delete [] e_arr;\n+  delete [] e_ref;\n+}\n+\n+int main ()\n+{\n+  test05();\n+  return 0;\n+}"}, {"sha": "9ee2770bafdcdbc5b918a515897f534346d301f7", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/out/wchar_t/6.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F6.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,86 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+//\n+// Test handling of output buffer that is too small.\n+// libstdc++/9247\n+void test06()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<char>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit = \"black pearl jasmine tea\";\n+  const int_type* \ti_lit = L\"black pearl jasmine tea\";\n+  const int_type*       ifrom_next;\n+  int \t\t\tsize = strlen(e_lit);\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type* \t\te_ref = new ext_type[size + 1];\n+  memset(e_arr, 0xf0, size + 1);\n+  memset(e_ref, 0xf0, size + 1);\n+  ext_type*\t\teto_next;\n+\n+  locale \t\tloc;\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // out\n+  w_codecvt::state_type state02;\n+  zero_state(state02);  \n+  result r2 = cvt->out(state02, i_lit, i_lit + size, ifrom_next, \n+\t\t       e_arr, e_arr + 1, eto_next);\n+  VERIFY( r2 == codecvt_base::partial );\n+  VERIFY( ifrom_next == i_lit + 1 );\n+  VERIFY( eto_next == e_arr + 1 );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, 1) );\n+  VERIFY( !ext_traits::compare(eto_next, e_ref, size) );\n+\n+  delete [] e_arr;\n+  delete [] e_ref;\n+}\n+\n+int main ()\n+{\n+  test06();\n+  return 0;\n+}"}, {"sha": "3ea57c05c038472ed0d3137328b36076dfa4b4a5", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/out/wchar_t/7.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fout%2Fwchar_t%2F7.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,84 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test03()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<char>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit = \"a\";\n+  const int_type \ti_lit[] = { L'a', 0x20ac, 0x0 };\n+  const int_type*       ifrom_next;\n+  int \t\t\tsize = wcslen(i_lit);\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type* \t\te_ref = new ext_type[size + 1];\n+  memset(e_arr, 0xf0, size + 1);\n+  memset(e_ref, 0xf0, size + 1);\n+  ext_type*\t\teto_next;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-1\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // out\n+  w_codecvt::state_type state02;\n+  zero_state(state02);  \n+  result r2 = cvt->out(state02, i_lit, i_lit + size, ifrom_next, \n+\t\t       e_arr, e_arr + size, eto_next);\n+  VERIFY( r2 == codecvt_base::error );\n+  VERIFY( ifrom_next == i_lit + 1 );\n+  VERIFY( eto_next == e_arr + 1 );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, 1) );\n+  VERIFY( !ext_traits::compare(eto_next, e_ref, size) );\n+\n+  delete [] e_arr;\n+  delete [] e_ref;\n+}\n+\n+int main ()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "b96b22c599123bf68a11a40ee22010a196a0972e", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/unicode/1.cc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funicode%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funicode%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funicode%2F1.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,147 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+\n+\n+#ifdef _GLIBCPP_USE___ENC_TRAITS\n+\n+// Need some char_traits specializations for this to work.\n+typedef unsigned short\t\t\tunicode_t;\n+\n+namespace std\n+{\n+  template<>\n+    struct char_traits<unicode_t>\n+    {\n+      typedef unicode_t \tchar_type;\n+      // Unsigned as wint_t is unsigned.\n+      typedef unsigned long  \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2);\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+      { return memcmp(__s1, __s2, __n); }\n+\n+      static size_t\n+      length(const char_type* __s);\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a);\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, size_t __n);\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n)\n+      {  return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a);\n+\n+      static char_type \n+      to_char_type(const int_type& __c);\n+\n+      static int_type \n+      to_int_type(const char_type& __c);\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2);\n+\n+      static int_type \n+      eof(); \n+\n+      static int_type \n+      not_eof(const int_type& __c);\n+    };\n+}\n+\n+void\n+initialize_state(std::__enc_traits& state)\n+{ state._M_init(); }\n+\n+bool length_called = false;\n+\n+class length_codecvt : public std::codecvt<unicode_t, char, std::__enc_traits>\n+{\n+  typedef std::codecvt<unicode_t, char, std::__enc_traits> unicode_codecvt;\n+\n+public:\n+  // DR75: type of first argument of do_length is state_type&\n+  virtual int do_length(state_type& state, const extern_type* from,\n+                        const extern_type* end, std::size_t max) const\n+  {\n+    length_called = true;\n+    return unicode_codecvt::do_length(state, from, end, max);\n+  }\n+};\n+\n+// Partial specialization using __enc_traits.\n+// codecvt<unicode_t, char, __enc_traits>\n+// UNICODE - UCS2 (big endian)\n+void test01()\n+{\n+  using namespace std;\n+  typedef unicode_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef __enc_traits\t\t\t\tenc_type;\n+  typedef codecvt<int_type, ext_type, enc_type>\tunicode_codecvt;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit = \"black pearl jasmine tea\";\n+  int \t\t\tsize = strlen(e_lit);\n+\n+  // construct a locale object with the specialized facet.\n+  locale \t\tloc(locale::classic(), new length_codecvt);\n+  // sanity check the constructed locale has the specialized facet.\n+  VERIFY( has_facet<unicode_codecvt>(loc) );\n+  const unicode_codecvt&\tcvt = use_facet<unicode_codecvt>(loc); \n+\n+  unicode_codecvt::state_type state04(\"UCS-2BE\", \"ISO-8859-15\", 0xfeff, 0);\n+  initialize_state(state04);\n+  length_called = false;\n+  cvt.length(state04, e_lit, e_lit + size, 5);\n+  VERIFY( length_called );\n+}\n+#endif // _GLIBCPP_USE___ENC_TRAITS\n+\n+int main ()\n+{\n+#if _GLIBCPP_USE___ENC_TRAITS\n+  test01();\n+#endif \n+\n+  return 0;\n+}"}, {"sha": "65aaea05056a963662a22bdd58a08c20d936fd21", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/unshift/wchar_t/1.cc", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F1.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -45,43 +45,16 @@ void test01()\n   typedef codecvt_base::result\t\t\tresult;\n   typedef wchar_t\t\t\t\tint_type;\n   typedef char\t\t\t\t\text_type;\n-  typedef char_traits<wchar_t>\t\t\tint_traits;\n-  typedef char_traits<char>\t\t\text_traits;\n \n   bool \t\t\ttest = true;\n   const ext_type* \te_lit = \"black pearl jasmine tea\";\n-  const ext_type*       efrom_next;\n-  const int_type* \ti_lit = L\"black pearl jasmine tea\";\n-  const int_type*       ifrom_next;\n   int \t\t\tsize = strlen(e_lit);\n   ext_type* \t\te_arr = new ext_type[size + 1];\n   ext_type*\t\teto_next;\n-  int_type* \t\ti_arr = new int_type[size + 1];\n-  int_type*\t\tito_next;\n \n   locale \t\tloc;\n   const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n \n-  // in\n-  w_codecvt::state_type state01;\n-  zero_state(state01);\n-  result r1 = cvt->in(state01, e_lit, e_lit + size, efrom_next, \n-\t\t      i_arr, i_arr + size, ito_next);\n-  VERIFY( r1 == codecvt_base::ok );\n-  VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n-  VERIFY( efrom_next == e_lit + size );\n-  VERIFY( ito_next == i_arr + size );\n-\n-  // out\n-  w_codecvt::state_type state02;\n-  zero_state(state02);  \n-  result r2 = cvt->out(state02, i_lit, i_lit + size, ifrom_next, \n-\t\t       e_arr, e_arr + size, eto_next);\n-  VERIFY( r2 == codecvt_base::ok );\n-  VERIFY( !ext_traits::compare(e_arr, e_lit, size) ); \n-  VERIFY( ifrom_next == i_lit + size );\n-  VERIFY( eto_next == e_arr + size );\n-\n   // unshift\n   strcpy(e_arr, e_lit);\n   w_codecvt::state_type state03;\n@@ -90,6 +63,8 @@ void test01()\n   VERIFY( r3 == codecvt_base::noconv );\n   VERIFY( !strcmp(e_arr, e_lit) ); \n   VERIFY( eto_next == e_arr );\n+\n+  delete [] e_arr;\n }\n \n int main ()"}, {"sha": "77e3b9292dd450592112959231af27222ff56087", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/unshift/wchar_t/2.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F2.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,107 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test02()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<char>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const int_type* \ti_lit =\n+    L\"\\x1\\x2\\x3\\x4\\x5\\x6\\x7\\x8\\x9\\xa\\xb\\xc\\xd\\xe\\xf\\x10\\x11\\x12\\x13\"\n+    L\"\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20!\\\"#$%&\"\n+    L\"'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\"\n+    L\"abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\"\n+    L\"\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\"\n+    L\"\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\"\n+    L\"\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\"\n+    L\"\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n+    L\"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\"\n+    L\"\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n+    L\"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n+    L\"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\"\n+    L\"\\xff\";\n+\n+  const int_type*       ifrom_next;\n+  int \t\t\tsize = wcslen(i_lit);\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type* \t\te_ref = new ext_type[size + 1];\n+  memset(e_arr, 0xf0, size + 1);\n+  memset(e_ref, 0xf0, size + 1);\n+  ext_type*\t\teto_next;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-1\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // unshift\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1 = cvt->unshift(state01, e_arr, e_arr + size, eto_next);\n+  VERIFY( r1 == codecvt_base::noconv );\n+  VERIFY( !ext_traits::compare(e_arr, e_ref, size + 1) ); \n+  VERIFY( eto_next == e_arr );\n+\n+  for (int i = 0; i < size; ++i)\n+    {\n+      w_codecvt::state_type state02;\n+      zero_state(state02);\n+      cvt->out(state02, i_lit + i, i_lit + i + 1, ifrom_next, \n+\t       e_arr, e_arr + size, eto_next);\n+      memset(e_arr, 0xf0, size + 1);\n+      result r2 = cvt->unshift(state02, e_arr, e_arr + size, eto_next);\n+      VERIFY( r2 == codecvt_base::noconv );\n+      VERIFY( !ext_traits::compare(e_arr, e_ref, size + 1) ); \n+      VERIFY( eto_next == e_arr );\n+    }\n+\n+  delete [] e_arr;\n+  delete [] e_ref;\n+}\n+\n+int main ()\n+{\n+  test02();\n+  return 0;\n+}"}, {"sha": "a828090b14dfe285d976e29c2abc6f0c6f402e54", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/unshift/wchar_t/3.cc", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F3.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,121 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test03()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<char>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const int_type \ti_lit[] = {\n+    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc,\n+    0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, L'!',\n+    L'\"', L'#', L'$', L'%', L'&', L'\\'', L'(', L')', L'*', L'+',\n+    L',', L'-', L'.', L'/', L'0', L'1', L'2', L'3', L'4', L'5',\n+    L'6', L'7', L'8', L'9', L':', L';', L'<', L'=', L'>', L'?',\n+    L'@', L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H', L'I',\n+    L'J', L'K', L'L', L'M', L'N', L'O', L'P', L'Q', L'R', L'S',\n+    L'T', L'U', L'V', L'W', L'X', L'Y', L'Z', L'[', L'\\\\', L']',\n+    L'^', L'_', L'`', L'a', L'b', L'c', L'd', L'e', L'f', L'g',\n+    L'h', L'i', L'j', L'k', L'l', L'm', L'n', L'o', L'p', L'q',\n+    L'r', L's', L't', L'u', L'v', L'w', L'x', L'y', L'z', L'{',\n+    L'|', L'}', L'~', 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,\n+    0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\n+    0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n+    0x20ac, 0xa5, 0x160, 0xa7, 0x161, 0xa9, 0xaa, 0xab, 0xac, 0xad,\n+    0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0x17d, 0xb5, 0xb6, 0xb7,\n+    0x17e, 0xb9, 0xba, 0xbb, 0x152, 0x153, 0x178, 0xbf, 0xc0, 0xc1,\n+    0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n+    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5,\n+    0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,\n+    0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n+    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd,\n+    0xfe, 0xff, 0x0\n+  };\n+\n+  const int_type*       ifrom_next;\n+  int \t\t\tsize = wcslen(i_lit);\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type* \t\te_ref = new ext_type[size + 1];\n+  memset(e_arr, 0xf0, size + 1);\n+  memset(e_ref, 0xf0, size + 1);\n+  ext_type*\t\teto_next;\n+\n+  locale \t\tloc (\"en_US.ISO-8859-15\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // unshift\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1 = cvt->unshift(state01, e_arr, e_arr + size, eto_next);\n+  VERIFY( r1 == codecvt_base::noconv );\n+  VERIFY( !ext_traits::compare(e_arr, e_ref, size + 1) ); \n+  VERIFY( eto_next == e_arr );\n+\n+  for (int i = 0; i < size; ++i)\n+    {\n+      w_codecvt::state_type state02;\n+      zero_state(state02);\n+      cvt->out(state02, i_lit + i, i_lit + i + 1, ifrom_next, \n+\t       e_arr, e_arr + size, eto_next);\n+      memset(e_arr, 0xf0, size + 1);\n+      result r2 = cvt->unshift(state02, e_arr, e_arr + size, eto_next);\n+      VERIFY( r2 == codecvt_base::noconv );\n+      VERIFY( !ext_traits::compare(e_arr, e_ref, size + 1) ); \n+      VERIFY( eto_next == e_arr );\n+    }\n+\n+  delete [] e_arr;\n+  delete [] e_ref;\n+}\n+\n+int main ()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "09a91ed559767fca3459afa29dbe0327ae4bac41", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/unshift/wchar_t/4.cc", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c8e230ac099c617f5daf275ab7c020935237c/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Funshift%2Fwchar_t%2F4.cc?ref=e61c8e230ac099c617f5daf275ab7c020935237c", "patch": "@@ -0,0 +1,116 @@\n+// 2003-02-06  Petur Runolfsson  <peturr02@ru.is>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C99 standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(std::mbstate_t& state)\n+{ std::memset(&state, 0, sizeof(std::mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test04()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<char>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const int_type \ti_lit[] = {\n+    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc,\n+    0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, L'!',\n+    L'\"', L'#', L'$', L'%', L'&', L'\\'', L'(', L')', L'*', L'+',\n+    L',', L'-', L'.', L'/', L'0', L'1', L'2', L'3', L'4', L'5',\n+    L'6', L'7', L'8', L'9', L':', L';', L'<', L'=', L'>', L'?',\n+    L'@', L'}', L'~', 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,\n+    0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\n+    0x9a, 0x9b, 0x9c, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x100,\n+    0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107, 0x108, 0x109,\n+    0x10a, 0x10b, 0x10c, 0x10d, 0x10e, 0x10f, 0x110, 0x111, 0x112,\n+    0x113, 0x114, 0x115, 0x116, 0x117, 0x118, 0x119, 0x7f8, 0x7f9,\n+    0x7fa, 0x7fb, 0x7fc, 0x7fd, 0x7fe, 0x7ff, 0x800, 0x801, 0x802,\n+    0x803, 0x804, 0x805, 0x806, 0x807, 0x808, 0x809, 0x80a, 0x80b,\n+    0x80c, 0x80d, 0x80e, 0x80f, 0x810, 0x811, 0x812, 0x813, 0x814,\n+    0x815, 0x816, 0x817, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, L'@',\n+    0x80, 0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000,\n+    0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 0x400000,\n+    0x800000, 0x1000000, 0x2000000, 0x4000000, 0x8000000, 0x10000000,\n+    0x20000000, 0x40000000, 0x0\n+  };\n+\n+  const int_type*       ifrom_next;\n+  int \t\t\tsize = wcslen(i_lit);\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type* \t\te_ref = new ext_type[size + 1];\n+  memset(e_arr, 0xf0, size + 1);\n+  memset(e_ref, 0xf0, size + 1);\n+  ext_type*\t\teto_next;\n+\n+  locale \t\tloc (\"en_US.UTF-8\");\n+  locale::global(loc);\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // unshift\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1 = cvt->unshift(state01, e_arr, e_arr + size, eto_next);\n+  VERIFY( r1 == codecvt_base::noconv );\n+  VERIFY( !ext_traits::compare(e_arr, e_ref, size + 1) ); \n+  VERIFY( eto_next == e_arr );\n+\n+  for (int i = 0; i < size; ++i)\n+    {\n+      w_codecvt::state_type state02;\n+      zero_state(state02);\n+      cvt->out(state02, i_lit + i, i_lit + i + 1, ifrom_next, \n+\t       e_arr, e_arr + size, eto_next);\n+      memset(e_arr, 0xf0, size + 1);\n+      result r2 = cvt->unshift(state02, e_arr, e_arr + size, eto_next);\n+      VERIFY( r2 == codecvt_base::noconv );\n+      VERIFY( !ext_traits::compare(e_arr, e_ref, size + 1) ); \n+      VERIFY( eto_next == e_arr );\n+    }\n+\n+  delete [] e_arr;\n+  delete [] e_ref;\n+}\n+\n+int main ()\n+{\n+  test04();\n+  return 0;\n+}"}]}