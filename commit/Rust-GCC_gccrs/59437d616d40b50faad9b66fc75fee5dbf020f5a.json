{"sha": "59437d616d40b50faad9b66fc75fee5dbf020f5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk0MzdkNjE2ZDQwYjUwZmFhZDliNjZmYzc1ZmVlNWRiZjAyMGY1YQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-01-11T20:04:33Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-01-11T20:04:33Z"}, "message": "re PR libgcj/18840 (java.io.BufferedInputStream.read(byte[],..) methods don't attempt to read as much as possible)\n\n\tPR libgcj/18840:\n\t* java/io/BufferedInputStream.java (read): Repeatedly read to\n\tfill buffer.\n\t(refill): Change test to see if buffer must be grown.\n\nFrom-SVN: r93192", "tree": {"sha": "61f76ba61e9483c05e909e7c3f63f785ead32d36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61f76ba61e9483c05e909e7c3f63f785ead32d36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59437d616d40b50faad9b66fc75fee5dbf020f5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59437d616d40b50faad9b66fc75fee5dbf020f5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59437d616d40b50faad9b66fc75fee5dbf020f5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59437d616d40b50faad9b66fc75fee5dbf020f5a/comments", "author": null, "committer": null, "parents": [{"sha": "6c25a4f7cbb1debbe1822ea9135c6b470ba06b6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c25a4f7cbb1debbe1822ea9135c6b470ba06b6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c25a4f7cbb1debbe1822ea9135c6b470ba06b6d"}], "stats": {"total": 42, "additions": 35, "deletions": 7}, "files": [{"sha": "1276a680cde18cff62c54de2b5dc396212de2e42", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59437d616d40b50faad9b66fc75fee5dbf020f5a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59437d616d40b50faad9b66fc75fee5dbf020f5a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=59437d616d40b50faad9b66fc75fee5dbf020f5a", "patch": "@@ -1,3 +1,10 @@\n+2005-01-11  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/18840:\n+\t* java/io/BufferedInputStream.java (read): Repeatedly read to\n+\tfill buffer.\n+\t(refill): Change test to see if buffer must be grown.\n+\n 2005-01-10  Tom Tromey  <tromey@redhat.com>\n \n \t* mauve-libgcj: Exclude some swing tests."}, {"sha": "5343f0762b619eeb461edee53a898c2ecb3b3e45", "filename": "libjava/java/io/BufferedInputStream.java", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59437d616d40b50faad9b66fc75fee5dbf020f5a/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59437d616d40b50faad9b66fc75fee5dbf020f5a/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedInputStream.java?ref=59437d616d40b50faad9b66fc75fee5dbf020f5a", "patch": "@@ -1,5 +1,5 @@\n /* BufferedInputStream.java -- An input stream that implements buffering\n-   Copyright (C) 1998, 1999, 2001, 2004  Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2004, 2005  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -198,7 +198,7 @@ public synchronized void mark(int readlimit)\n   {\n     marktarget = marklimit = readlimit;\n     if (marklimit > CHUNKSIZE)\n-\tmarklimit = CHUNKSIZE;\n+      marklimit = CHUNKSIZE;\n     markpos = pos;\n   }\n \n@@ -241,7 +241,10 @@ public synchronized int read() throws IOException\n    * This method reads bytes from a stream and stores them into a caller\n    * supplied buffer.  It starts storing the data at index <code>off</code>\n    * into the buffer and attempts to read <code>len</code> bytes.  This method\n-   * can return before reading the number of bytes requested.\n+   * can return before reading the number of bytes requested, but it will try\n+   * to read the requested number of bytes by repeatedly calling the underlying\n+   * stream as long as available() for this stream continues to return a\n+   * non-zero value (or until the requested number of bytes have been read).\n    * The actual number of bytes read is returned as an int.  A -1 is returned\n    * to indicate the end of the stream.\n    * <p>\n@@ -263,16 +266,34 @@ public synchronized int read(byte[] b, int off, int len) throws IOException\n     if (off < 0 || len < 0 || b.length - off < len)\n       throw new IndexOutOfBoundsException();\n \n+    if (len == 0)\n+      return 0;\n+\n     if (pos >= count && !refill())\n       return -1;\t\t// No bytes were read before EOF.\n \n     int totalBytesRead = Math.min(count - pos, len);\n     System.arraycopy(buf, pos, b, off, totalBytesRead);\n     pos += totalBytesRead;\n+    off += totalBytesRead;\n+    len -= totalBytesRead;\n \n     if (markpos >= 0 && pos - markpos > marktarget)\n       markpos = -1;\n \n+    while (len > 0 && super.available() > 0 && refill())\n+      {\n+\tint remain = Math.min(count - pos, len);\n+\tSystem.arraycopy(buf, pos, b, off, remain);\n+\tpos += remain;\n+\toff += remain;\n+\tlen -= remain;\n+\ttotalBytesRead += remain;\n+\n+\tif (markpos >= 0 && pos - markpos > marktarget)\n+\t  markpos = -1;\n+      }\n+\n     return totalBytesRead;\n   }\n \n@@ -311,7 +332,7 @@ public synchronized void reset() throws IOException\n   public synchronized long skip(long n) throws IOException\n   {\n     if (buf == null)\n-\tthrow new IOException(\"Stream closed.\");\n+      throw new IOException(\"Stream closed.\");\n \n     final long origN = n;\n \n@@ -343,7 +364,7 @@ public synchronized long skip(long n) throws IOException\n   boolean refill() throws IOException\n   {\n     if (buf == null)\n-\tthrow new IOException(\"Stream closed.\");\n+      throw new IOException(\"Stream closed.\");\n \n     if (markpos < 0)\n       count = pos = 0;\n@@ -357,7 +378,7 @@ else if (markpos > 0)\n \tpos -= markpos;\n \tmarkpos = 0;\n       }\n-    else if (marktarget >= buf.length && marklimit < marktarget)\t// BTW, markpos == 0\n+    else if (count >= buf.length && count < marktarget)\t// BTW, markpos == 0\n       {\n \t// Need to grow the buffer now to have room for marklimit bytes.\n \t// Note that the new buffer is one greater than marklimit.\n@@ -378,6 +399,6 @@ else if (marktarget >= buf.length && marklimit < marktarget)\t// BTW, markpos ==\n       return false;\n \n     count += numread;\n-    return true;\n+    return numread > 0;\n   }\n }"}]}