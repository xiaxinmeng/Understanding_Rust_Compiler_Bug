{"sha": "d0442491d506497f9c7e8bfa6f0e9edb16d21306", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA0NDI0OTFkNTA2NDk3ZjljN2U4YmZhNmYwZTllZGIxNmQyMTMwNg==", "commit": {"author": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2019-06-14T18:41:20Z"}, "committer": {"name": "Harald Anlauf", "email": "anlauf@gcc.gnu.org", "date": "2019-06-14T18:41:20Z"}, "message": "re PR fortran/90577 (FAIL: gfortran.dg/lrshift_1.f90 with -O(2|3) and -flto)\n\n2019-06-14  Harald Anlauf  <anlauf@gmx.de>\n\n\tPR fortran/90577\n\tPR fortran/90578\n\t* trans-intrinsic.c (gfc_conv_intrinsic_shift): Properly\n\tdistinguish logical/arithmetic shifts.\n\t* intrinsic.texi: Update documentation for SHIFTR/SHIFTL/SHIFTA\n\t(Fortran 2008) and LSHIFT/RSHIFT (GNU extensions).\n\n\tPR fortran/90577\n\tPR fortran/90578\n\t* gfortran.dg/lrshift_1.f90: Adjust testcase.\n\t* gfortran.dg/shiftalr_3.f90: New testcase.\n\nFrom-SVN: r272309", "tree": {"sha": "c3615319bcfcff103f8bbc0cd88ef23de4955beb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3615319bcfcff103f8bbc0cd88ef23de4955beb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0442491d506497f9c7e8bfa6f0e9edb16d21306", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0442491d506497f9c7e8bfa6f0e9edb16d21306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0442491d506497f9c7e8bfa6f0e9edb16d21306", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0442491d506497f9c7e8bfa6f0e9edb16d21306/comments", "author": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a8566e938ca4c6d5c8a631397e15216d0d6a720f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8566e938ca4c6d5c8a631397e15216d0d6a720f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8566e938ca4c6d5c8a631397e15216d0d6a720f"}], "stats": {"total": 121, "additions": 97, "deletions": 24}, "files": [{"sha": "def18108517d550757c2c7fa4fb3f1502467d605", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d0442491d506497f9c7e8bfa6f0e9edb16d21306", "patch": "@@ -1,3 +1,12 @@\n+2019-06-14  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/90577\n+\tPR fortran/90578\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_shift): Properly\n+\tdistinguish logical/arithmetic shifts.\n+\t* intrinsic.texi: Update documentation for SHIFTR/SHIFTL/SHIFTA\n+\t(Fortran 2008) and LSHIFT/RSHIFT (GNU extensions).\n+\n 2019-06-14  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/89646"}, {"sha": "f390761dc3d69fd9214e2d41d01d08200460f495", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=d0442491d506497f9c7e8bfa6f0e9edb16d21306", "patch": "@@ -9689,10 +9689,10 @@ The return value is a @code{INTEGER(4)} variable.\n @table @asis\n @item @emph{Description}:\n @code{LSHIFT} returns a value corresponding to @var{I} with all of the\n-bits shifted left by @var{SHIFT} places.  If the absolute value of\n-@var{SHIFT} is greater than @code{BIT_SIZE(I)}, the value is undefined. \n-Bits shifted out from the left end are lost; zeros are shifted in from\n-the opposite end.\n+bits shifted left by @var{SHIFT} places.  @var{SHIFT} shall be\n+nonnegative and less than or equal to @code{BIT_SIZE(I)}, otherwise\n+the result value is undefined.  Bits shifted out from the left end are\n+lost; zeros are shifted in from the opposite end.\n \n This function has been superseded by the @code{ISHFT} intrinsic, which\n is standard in Fortran 95 and later, and the @code{SHIFTL} intrinsic,\n@@ -12244,11 +12244,12 @@ The value returned is equal to\n @table @asis\n @item @emph{Description}:\n @code{RSHIFT} returns a value corresponding to @var{I} with all of the\n-bits shifted right by @var{SHIFT} places.  If the absolute value of\n-@var{SHIFT} is greater than @code{BIT_SIZE(I)}, the value is undefined.\n-Bits shifted out from the right end are lost. The fill is arithmetic: the\n-bits shifted in from the left end are equal to the leftmost bit, which in\n-two's complement representation is the sign bit.\n+bits shifted right by @var{SHIFT} places.  @var{SHIFT} shall be\n+nonnegative and less than or equal to @code{BIT_SIZE(I)}, otherwise\n+the result value is undefined.  Bits shifted out from the right end\n+are lost. The fill is arithmetic: the bits shifted in from the left\n+end are equal to the leftmost bit, which in two's complement\n+representation is the sign bit.\n \n This function has been superseded by the @code{SHIFTA} intrinsic, which\n is standard in Fortran 2008 and later.\n@@ -12783,11 +12784,12 @@ END PROGRAM\n @table @asis\n @item @emph{Description}:\n @code{SHIFTA} returns a value corresponding to @var{I} with all of the\n-bits shifted right by @var{SHIFT} places.  If the absolute value of\n-@var{SHIFT} is greater than @code{BIT_SIZE(I)}, the value is undefined.\n-Bits shifted out from the right end are lost. The fill is arithmetic: the\n-bits shifted in from the left end are equal to the leftmost bit, which in\n-two's complement representation is the sign bit.\n+bits shifted right by @var{SHIFT} places.  @var{SHIFT} that be\n+nonnegative and less than or equal to @code{BIT_SIZE(I)}, otherwise\n+the result value is undefined.  Bits shifted out from the right end\n+are lost. The fill is arithmetic: the bits shifted in from the left\n+end are equal to the leftmost bit, which in two's complement\n+representation is the sign bit.\n \n @item @emph{Standard}:\n Fortran 2008 and later\n@@ -12823,10 +12825,10 @@ The return value is of type @code{INTEGER} and of the same kind as\n @table @asis\n @item @emph{Description}:\n @code{SHIFTL} returns a value corresponding to @var{I} with all of the\n-bits shifted left by @var{SHIFT} places.  If the absolute value of\n-@var{SHIFT} is greater than @code{BIT_SIZE(I)}, the value is undefined.\n-Bits shifted out from the left end are lost, and bits shifted in from\n-the right end are set to 0.\n+bits shifted left by @var{SHIFT} places.  @var{SHIFT} shall be\n+nonnegative and less than or equal to @code{BIT_SIZE(I)}, otherwise\n+the result value is undefined.  Bits shifted out from the left end are\n+lost, and bits shifted in from the right end are set to 0.\n \n @item @emph{Standard}:\n Fortran 2008 and later\n@@ -12862,10 +12864,10 @@ The return value is of type @code{INTEGER} and of the same kind as\n @table @asis\n @item @emph{Description}:\n @code{SHIFTR} returns a value corresponding to @var{I} with all of the\n-bits shifted right by @var{SHIFT} places.  If the absolute value of\n-@var{SHIFT} is greater than @code{BIT_SIZE(I)}, the value is undefined.\n-Bits shifted out from the right end are lost, and bits shifted in from\n-the left end are set to 0.\n+bits shifted right by @var{SHIFT} places.  @var{SHIFT} shall be\n+nonnegative and less than or equal to @code{BIT_SIZE(I)}, otherwise\n+the result value is undefined.  Bits shifted out from the right end\n+are lost, and bits shifted in from the left end are set to 0.\n \n @item @emph{Standard}:\n Fortran 2008 and later"}, {"sha": "cc041f9eea706ecd5a5e917b1f790daac268b798", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=d0442491d506497f9c7e8bfa6f0e9edb16d21306", "patch": "@@ -6346,6 +6346,7 @@ gfc_conv_intrinsic_shift (gfc_se * se, gfc_expr * expr, bool right_shift,\n \t\t\t  bool arithmetic)\n {\n   tree args[2], type, num_bits, cond;\n+  tree bigshift;\n \n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n \n@@ -6365,6 +6366,18 @@ gfc_conv_intrinsic_shift (gfc_se * se, gfc_expr * expr, bool right_shift,\n   if (!arithmetic)\n     se->expr = fold_convert (type, se->expr);\n \n+  if (!arithmetic)\n+    bigshift = build_int_cst (type, 0);\n+  else\n+    {\n+      tree nonneg = fold_build2_loc (input_location, GE_EXPR,\n+\t\t\t\t     logical_type_node, args[0],\n+\t\t\t\t     build_int_cst (TREE_TYPE (args[0]), 0));\n+      bigshift = fold_build3_loc (input_location, COND_EXPR, type, nonneg,\n+\t\t\t\t  build_int_cst (type, 0),\n+\t\t\t\t  build_int_cst (type, -1));\n+    }\n+\n   /* The Fortran standard allows shift widths <= BIT_SIZE(I), whereas\n      gcc requires a shift width < BIT_SIZE(I), so we have to catch this\n      special case.  */\n@@ -6373,7 +6386,7 @@ gfc_conv_intrinsic_shift (gfc_se * se, gfc_expr * expr, bool right_shift,\n \t\t\t  args[1], num_bits);\n \n   se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond,\n-\t\t\t      build_int_cst (type, 0), se->expr);\n+\t\t\t      bigshift, se->expr);\n }\n \n /* ISHFT (I, SHIFT) = (abs (shift) >= BIT_SIZE (i))"}, {"sha": "7332d53d8e08479b885aeabe5484927f80a622f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d0442491d506497f9c7e8bfa6f0e9edb16d21306", "patch": "@@ -1,3 +1,10 @@\n+2019-06-14  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/90577\n+\tPR fortran/90578\n+\t* gfortran.dg/lrshift_1.f90: Adjust testcase.\n+\t* gfortran.dg/shiftalr_3.f90: New testcase.\n+\n 2019-06-14  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/89646"}, {"sha": "d262921e4b158b056d5beb9c9727fec8522bce4b", "filename": "gcc/testsuite/gfortran.dg/lrshift_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ftestsuite%2Fgfortran.dg%2Flrshift_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ftestsuite%2Fgfortran.dg%2Flrshift_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flrshift_1.f90?ref=d0442491d506497f9c7e8bfa6f0e9edb16d21306", "patch": "@@ -10,7 +10,7 @@ program test_rshift_lshift\n          1, 2, 127, 128, 129, huge(i)/2, huge(i) /)\n \n   do n = 1, size(i)\n-    do j = -30, 30\n+    do j = 0, 31\n       if (lshift(i(n),j) /= c_lshift(i(n),j)) STOP 1\n       if (rshift(i(n),j) /= c_rshift(i(n),j)) STOP 2\n     end do"}, {"sha": "4eb0ba728b359f268436c5f2ea2e81a132774f5b", "filename": "gcc/testsuite/gfortran.dg/shiftalr_3.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ftestsuite%2Fgfortran.dg%2Fshiftalr_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0442491d506497f9c7e8bfa6f0e9edb16d21306/gcc%2Ftestsuite%2Fgfortran.dg%2Fshiftalr_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fshiftalr_3.f90?ref=d0442491d506497f9c7e8bfa6f0e9edb16d21306", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+!\n+! Test shift intrinsics when the SHIFT argument equals BIT_SIZE(arg1).\n+\n+program test\n+  implicit none\n+  ! Test compile-time simplifications\n+  if (ishft  (-1, 32) /=  0) stop 1 !  0 -> simplify_shift OK\n+  if (ishft  (-1,-32) /=  0) stop 2 !  0 -> simplify_shift OK\n+  if (shiftl (-1, 32) /=  0) stop 3 !  0 -> simplify_shift OK\n+  if (shiftr (-1, 32) /=  0) stop 4 !  0 -> simplify_shift OK\n+  if (shifta (-1, 32) /= -1) stop 5 ! -1 -> simplify_shift OK\n+  if (rshift (-1, 32) /= -1) stop 6 ! -1 -> simplify_shift OK\n+  if (lshift (-1, 32) /=  0) stop 7 !  0 -> simplify_shift OK\n+  ! Test run-time\n+  call foo (-1)\n+contains\n+  subroutine foo (n)\n+    integer(4) :: i, j, k, n\n+    integer, parameter :: bb = bit_size (n)\n+    ! Test code generated by gfc_conv_intrinsic_ishft\n+    i = ishft  (n, bb) ! Logical (left)  shift (Fortran 2008)\n+    j = ishft  (n,-bb) ! Logical (right) shift (Fortran 2008)\n+    if (i /= 0) stop 11\n+    if (j /= 0) stop 12\n+    ! Test code generated by gfc_conv_intrinsic_shift:\n+    i = shiftl (n, bb) ! Logical    left  shift (Fortran 2008)\n+    j = shiftr (n, bb) ! Logical    right shift (Fortran 2008)\n+    k = shifta (n, bb) ! Arithmetic right shift (Fortran 2008)\n+    if (i /=  0) stop 13\n+    if (j /=  0) stop 14\n+    if (k /= -1) stop 15\n+    i = lshift (n, bb) ! Logical    left  shift (GNU extension)\n+    j = rshift (n, bb) ! Arithmetic right shift (GNU extension)\n+    if (i /=  0) stop 16\n+    if (j /= -1) stop 17\n+    do i = bb-1,bb\n+       if (shifta (n, i) /= -1) stop 18\n+       if (rshift (n, i) /= -1) stop 19\n+    end do\n+  end subroutine foo\n+end program test"}]}