{"sha": "baa3015d8efebd731701d6985bb7a7083db244a8", "node_id": "C_kwDOANBUbNoAKGJhYTMwMTVkOGVmZWJkNzMxNzAxZDY5ODViYjdhNzA4M2RiMjQ0YTg", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-06-11T11:05:39Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-06T13:29:48Z"}, "message": "[Ada] Fix incorrect itype sharing for case expression in limited type return\n\nThe compiler aborts with an internal error in gigi, but the problem is an\nitype incorrectly shared between several branches of an if_statement that\nhas been created for a Build-In-Place return.\n\nThree branches of this if_statement contain an allocator statement and\nthe latter two have been obtained as the result of calling New_Copy_Tree\non the first; now the initialization expression of the first had also been\nobtained as the result of calling New_Copy_Tree on the original tree, and\nthese chained calls to New_Copy_Tree run afoul of an issue with the copy\nof itypes after the rewrite of an aggregate as an expression with actions.\n\nFixing this issue looks quite delicate, so this fixes the incorrect sharing\nby replacing the chained calls to New_Copy_Tree with repeated calls on the\noriginal expression, which is more elegant in any case.\n\ngcc/ada/\n\n\t* exp_ch3.adb (Make_Allocator_For_BIP_Return): New local function.\n\t(Expand_N_Object_Declaration): Use it to build the three allocators\n\tfor a Build-In-Place return with an unconstrained type.  Update the\n\thead comment after other recent changes.", "tree": {"sha": "2b0106fa74f3849d43088aacaefda7fdc5ce1699", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b0106fa74f3849d43088aacaefda7fdc5ce1699"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/baa3015d8efebd731701d6985bb7a7083db244a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baa3015d8efebd731701d6985bb7a7083db244a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baa3015d8efebd731701d6985bb7a7083db244a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baa3015d8efebd731701d6985bb7a7083db244a8/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56311a3c9f207c83a08f964e65687b2ba302799e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56311a3c9f207c83a08f964e65687b2ba302799e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56311a3c9f207c83a08f964e65687b2ba302799e"}], "stats": {"total": 148, "additions": 76, "deletions": 72}, "files": [{"sha": "38552eff92214413d252a5a01d354631d51cbbbb", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 76, "deletions": 72, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3015d8efebd731701d6985bb7a7083db244a8/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3015d8efebd731701d6985bb7a7083db244a8/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=baa3015d8efebd731701d6985bb7a7083db244a8", "patch": "@@ -7980,16 +7980,11 @@ package body Exp_Ch3 is\n             --  the value one, then the caller has passed access to an\n             --  existing object for use as the return object. If the value\n             --  is two, then the return object must be allocated on the\n-            --  secondary stack. Otherwise, the object must be allocated in\n-            --  a storage pool. We generate an if statement to test the\n-            --  implicit allocation formal and initialize a local access\n-            --  value appropriately, creating allocators in the secondary\n-            --  stack and global heap cases. The special formal also exists\n-            --  and must be tested when the function has a tagged result,\n-            --  even when the result subtype is constrained, because in\n-            --  general such functions can be called in dispatching contexts\n-            --  and must be handled similarly to functions with a class-wide\n-            --  result.\n+            --  secondary stack. If the value is three, then the return\n+            --  object must be allocated on the heap. Otherwise, the object\n+            --  must be allocated in a storage pool. We generate an if\n+            --  statement to test the BIP_Alloc_Form formal and initialize\n+            --  a local access value appropriately.\n \n             if Needs_BIP_Alloc_Form (Func_Id) then\n                declare\n@@ -8005,6 +8000,73 @@ package body Exp_Ch3 is\n                   Pool_Id          : constant Entity_Id :=\n                     Make_Temporary (Loc, 'P');\n \n+                  function Make_Allocator_For_BIP_Return return Node_Id;\n+                  --  Make an allocator for the BIP return being processed\n+\n+                  -----------------------------------\n+                  -- Make_Allocator_For_BIP_Return --\n+                  -----------------------------------\n+\n+                  function Make_Allocator_For_BIP_Return return Node_Id is\n+                     Alloc : Node_Id;\n+\n+                  begin\n+                     if Present (Expr_Q)\n+                       and then not Is_Delayed_Aggregate (Expr_Q)\n+                       and then not No_Initialization (N)\n+                     then\n+                        --  Always use the type of the expression for the\n+                        --  qualified expression, rather than the result type.\n+                        --  In general we cannot always use the result type\n+                        --  for the allocator, because the expression might be\n+                        --  of a specific type, such as in the case of an\n+                        --  aggregate or even a nonlimited object when the\n+                        --  result type is a limited class-wide interface type.\n+\n+                        Alloc :=\n+                          Make_Allocator (Loc,\n+                            Expression =>\n+                              Make_Qualified_Expression (Loc,\n+                                Subtype_Mark =>\n+                                  New_Occurrence_Of (Etype (Expr_Q), Loc),\n+                                Expression   => New_Copy_Tree (Expr_Q)));\n+\n+                     else\n+                        --  If the function returns a class-wide type we cannot\n+                        --  use the return type for the allocator. Instead we\n+                        --  use the type of the expression, which must be an\n+                        --  aggregate of a definite type.\n+\n+                        if Is_Class_Wide_Type (Ret_Obj_Typ) then\n+                           Alloc :=\n+                             Make_Allocator (Loc,\n+                               Expression =>\n+                                 New_Occurrence_Of (Etype (Expr_Q), Loc));\n+\n+                        else\n+                           Alloc :=\n+                             Make_Allocator (Loc,\n+                               Expression =>\n+                                 New_Occurrence_Of (Ret_Obj_Typ, Loc));\n+                        end if;\n+\n+                        --  If the object requires default initialization then\n+                        --  that will happen later following the elaboration of\n+                        --  the object renaming. If we don't turn it off here\n+                        --  then the object will be default initialized twice.\n+\n+                        Set_No_Initialization (Alloc);\n+                     end if;\n+\n+                     --  Set the flag indicating that the allocator came from\n+                     --  a build-in-place return statement, so we can avoid\n+                     --  adjusting the allocated object.\n+\n+                     Set_Alloc_For_BIP_Return (Alloc);\n+\n+                     return Alloc;\n+                  end Make_Allocator_For_BIP_Return;\n+\n                   Alloc_Obj_Id   : Entity_Id;\n                   Alloc_Obj_Decl : Node_Id;\n                   Alloc_Stmt      : Node_Id;\n@@ -8049,71 +8111,15 @@ package body Exp_Ch3 is\n \n                   Insert_Action (N, Alloc_Obj_Decl);\n \n-                     --  Create allocators for both the secondary stack and\n-                     --  global heap. If there's an initialization expression,\n-                     --  then create these as initialized allocators.\n-\n-                  if Present (Expr_Q)\n-                    and then not Is_Delayed_Aggregate (Expr_Q)\n-                    and then not No_Initialization (N)\n-                  then\n-                     --  Always use the type of the expression for the\n-                     --  qualified expression, rather than the result type.\n-                     --  In general we cannot always use the result type\n-                     --  for the allocator, because the expression might be\n-                     --  of a specific type, such as in the case of an\n-                     --  aggregate or even a nonlimited object when the\n-                     --  result type is a limited class-wide interface type.\n-\n-                     Heap_Allocator :=\n-                       Make_Allocator (Loc,\n-                         Expression =>\n-                           Make_Qualified_Expression (Loc,\n-                             Subtype_Mark =>\n-                               New_Occurrence_Of (Etype (Expr_Q), Loc),\n-                             Expression   => New_Copy_Tree (Expr_Q)));\n-\n-                  else\n-                     --  If the function returns a class-wide type we cannot\n-                     --  use the return type for the allocator. Instead we\n-                     --  use the type of the expression, which must be an\n-                     --  aggregate of a definite type.\n+                  --  First create the Heap_Allocator\n \n-                     if Is_Class_Wide_Type (Ret_Obj_Typ) then\n-                        Heap_Allocator :=\n-                          Make_Allocator (Loc,\n-                            Expression =>\n-                              New_Occurrence_Of (Etype (Expr_Q), Loc));\n-\n-                     else\n-                        Heap_Allocator :=\n-                          Make_Allocator (Loc,\n-                            Expression =>\n-                              New_Occurrence_Of (Ret_Obj_Typ, Loc));\n-                     end if;\n-\n-                     --  If the object requires default initialization then\n-                     --  that will happen later following the elaboration of\n-                     --  the object renaming. If we don't turn it off here\n-                     --  then the object will be default initialized twice.\n-\n-                     Set_No_Initialization (Heap_Allocator);\n-                  end if;\n-\n-                  --  Set the flag indicating that the allocator came from\n-                  --  a build-in-place return statement, so we can avoid\n-                  --  adjusting the allocated object. Note that this flag\n-                  --  will be inherited by the copies made below.\n-\n-                  Set_Alloc_For_BIP_Return (Heap_Allocator);\n+                  Heap_Allocator := Make_Allocator_For_BIP_Return;\n \n                   --  The Pool_Allocator is just like the Heap_Allocator,\n                   --  except we set Storage_Pool and Procedure_To_Call so\n                   --  it will use the user-defined storage pool.\n \n-                  Pool_Allocator := New_Copy_Tree (Heap_Allocator);\n-\n-                  pragma Assert (Alloc_For_BIP_Return (Pool_Allocator));\n+                  Pool_Allocator := Make_Allocator_For_BIP_Return;\n \n                   --  Do not generate the renaming of the build-in-place\n                   --  pool parameter on ZFP because the parameter is not\n@@ -8154,9 +8160,7 @@ package body Exp_Ch3 is\n                   --  allocation.\n \n                   else\n-                     SS_Allocator := New_Copy_Tree (Heap_Allocator);\n-\n-                     pragma Assert (Alloc_For_BIP_Return (SS_Allocator));\n+                     SS_Allocator := Make_Allocator_For_BIP_Return;\n \n                      --  The heap and pool allocators are marked as\n                      --  Comes_From_Source since they correspond to an"}]}