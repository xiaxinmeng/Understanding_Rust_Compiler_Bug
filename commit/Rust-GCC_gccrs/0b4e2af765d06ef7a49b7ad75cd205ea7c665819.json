{"sha": "0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI0ZTJhZjc2NWQwNmVmN2E0OWI3YWQ3NWNkMjA1ZWE3YzY2NTgxOQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-09-17T22:23:51Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-09-17T22:23:51Z"}, "message": "re PR fortran/37274 ([Regression on 4.3?] error: type name is ambiguous.)\n\n2008-09-18  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/37274\n\tPR fortran/36374\n\t* module.c (check_for_ambiguous): New function to test loaded\n\tsymbol for ambiguity with fixup symbol.\n\t(read_module): Call check_for_ambiguous.\n\t(write_symtree): Do not write the symtree for symbols coming\n\tfrom an interface body.\n\n\tPR fortran/36374\n\t* resolve.c (count_specific_procs ): New function to count the\n\tnumber of specific procedures with the same name as the generic\n\tand emit appropriate errors for and actual argument reference.\n\t(resolve_assumed_size_actual): Add new argument no_formal_args.\n\tCorrect logic around passing generic procedures as arguments.\n\tCall count_specific_procs from two locations.\n\t(resolve_function): Evaluate and pass no_formal_args.\n\t(resolve call): The same and clean up a bit by using csym more\n\twidely.\n\n\tPR fortran/36454\n\t* symbol.c (gfc_add_access): Access can be updated if use\n\tassociated and not private.\n\n2008-09-18  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/37274\n\t* gfortran.dg/used_types_22.f90: New test.\n\t* gfortran.dg/used_types_23.f90: New test.\n\n\tPR fortran/36374\n\t* gfortran.dg/generic_17.f90: New test.\n\t* gfortran.dg/ambiguous_specific_2.f90: New test.\n\t* gfortran.dg/generic_actual_arg.f90: Add test for case that is\n\tnot ambiguous.\n\n\tPR fortran/36454\n\t* gfortran.dg/access_spec_3.f90: New test.\n\nFrom-SVN: r140434", "tree": {"sha": "4541f82a616fe793fb7f6ddd9ad66a7cad888b0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4541f82a616fe793fb7f6ddd9ad66a7cad888b0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/comments", "author": null, "committer": null, "parents": [{"sha": "c0b290997fa10dd3978c43c1dcdef8838fb15e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0b290997fa10dd3978c43c1dcdef8838fb15e98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0b290997fa10dd3978c43c1dcdef8838fb15e98"}], "stats": {"total": 663, "additions": 619, "deletions": 44}, "files": [{"sha": "73424965b53db6905d2bf857396d9f06afc9dcb3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "patch": "@@ -1,3 +1,28 @@\n+2008-09-18  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/37274\n+\tPR fortran/36374\n+\t* module.c (check_for_ambiguous): New function to test loaded\n+\tsymbol for ambiguity with fixup symbol.\n+\t(read_module): Call check_for_ambiguous.\n+\t(write_symtree): Do not write the symtree for symbols coming\n+\tfrom an interface body.\n+\n+\tPR fortran/36374\n+\t* resolve.c (count_specific_procs ): New function to count the\n+\tnumber of specific procedures with the same name as the generic\n+\tand emit appropriate errors for and actual argument reference.\n+\t(resolve_assumed_size_actual): Add new argument no_formal_args.\n+\tCorrect logic around passing generic procedures as arguments.\n+\tCall count_specific_procs from two locations.\n+\t(resolve_function): Evaluate and pass no_formal_args.\n+\t(resolve call): The same and clean up a bit by using csym more\n+\twidely.\n+\n+\tPR fortran/36454\n+\t* symbol.c (gfc_add_access): Access can be updated if use\n+\tassociated and not private.\n+\n 2008-09-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/37536"}, {"sha": "762114c2b75391e8aa90da9d4dcd8309f497058b", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "patch": "@@ -3944,6 +3944,48 @@ read_cleanup (pointer_info *p)\n }\n \n \n+/* It is not quite enough to check for ambiguity in the symbols by\n+   the loaded symbol and the new symbol not being identical.  */\n+static bool\n+check_for_ambiguous (gfc_symbol *st_sym, pointer_info *info)\n+{\n+  gfc_symbol *rsym;\n+  module_locus locus;\n+  symbol_attribute attr;\n+\n+  rsym = info->u.rsym.sym;\n+  if (st_sym == rsym)\n+    return false;\n+\n+  /* Identical derived types are not ambiguous and will be rolled up\n+     later.  */\n+  if (st_sym->attr.flavor == FL_DERIVED\n+\t&& rsym->attr.flavor == FL_DERIVED\n+\t&& gfc_compare_derived_types (st_sym, rsym))\n+    return false;\n+\n+  /* If the existing symbol is generic from a different module and\n+     the new symbol is generic there can be no ambiguity.  */\n+  if (st_sym->attr.generic\n+\t&& st_sym->module\n+\t&& strcmp (st_sym->module, module_name))\n+    {\n+      /* The new symbol's attributes have not yet been read.  Since\n+\t we need attr.generic, read it directly.  */\n+      get_module_locus (&locus);\n+      set_module_locus (&info->u.rsym.where);\n+      mio_lparen ();\n+      attr.generic = 0;\n+      mio_symbol_attribute (&attr);\n+      set_module_locus (&locus);\n+      if (attr.generic)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+\n /* Read a module file.  */\n \n static void\n@@ -4085,7 +4127,7 @@ read_module (void)\n \t  if (st != NULL)\n \t    {\n \t      /* Check for ambiguous symbols.  */\n-\t      if (st->n.sym != info->u.rsym.sym)\n+\t      if (check_for_ambiguous (st->n.sym, info))\n \t\tst->ambiguous = 1;\n \t      info->u.rsym.symtree = st;\n \t    }\n@@ -4579,6 +4621,14 @@ write_symtree (gfc_symtree *st)\n   pointer_info *p;\n \n   sym = st->n.sym;\n+\n+  /* A symbol in an interface body must not be visible in the\n+     module file.  */\n+  if (sym->ns != gfc_current_ns\n+\t&& sym->ns->proc_name\n+\t&& sym->ns->proc_name->attr.if_source == IFSRC_IFBODY)\n+    return;\n+\n   if (!gfc_check_access (sym->attr.access, sym->ns->default_access)\n       || (sym->attr.flavor == FL_PROCEDURE && sym->attr.generic\n \t  && !sym->attr.subroutine && !sym->attr.function))"}, {"sha": "a11b90d21f5b37f3f1cee3d92d217f876ce06ecb", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 65, "deletions": 39, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "patch": "@@ -1040,20 +1040,53 @@ resolve_assumed_size_actual (gfc_expr *e)\n }\n \n \n+/* Check a generic procedure, passed as an actual argument, to see if\n+   there is a matching specific name.  If none, it is an error, and if\n+   more than one, the reference is ambiguous.  */\n+static int\n+count_specific_procs (gfc_expr *e)\n+{\n+  int n;\n+  gfc_interface *p;\n+  gfc_symbol *sym;\n+\t\n+  n = 0;\n+  sym = e->symtree->n.sym;\n+\n+  for (p = sym->generic; p; p = p->next)\n+    if (strcmp (sym->name, p->sym->name) == 0)\n+      {\n+\te->symtree = gfc_find_symtree (p->sym->ns->sym_root,\n+\t\t\t\t       sym->name);\n+\tn++;\n+      }\n+\n+  if (n > 1)\n+    gfc_error (\"'%s' at %L is ambiguous\", e->symtree->n.sym->name,\n+\t       &e->where);\n+\n+  if (n == 0)\n+    gfc_error (\"GENERIC procedure '%s' is not allowed as an actual \"\n+\t       \"argument at %L\", sym->name, &e->where);\n+\n+  return n;\n+}\n+\n /* Resolve an actual argument list.  Most of the time, this is just\n    resolving the expressions in the list.\n    The exception is that we sometimes have to decide whether arguments\n    that look like procedure arguments are really simple variable\n    references.  */\n \n static gfc_try\n-resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n+resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n+\t\t\tbool no_formal_args)\n {\n   gfc_symbol *sym;\n   gfc_symtree *parent_st;\n   gfc_expr *e;\n   int save_need_full_assumed_size;\n-\n+\t\n   for (; arg; arg = arg->next)\n     {\n       e = arg->expr;\n@@ -1072,12 +1105,11 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n \t  continue;\n \t}\n \n-      if (e->expr_type == EXPR_VARIABLE && e->symtree->ambiguous)\n-\t{\n-\t  gfc_error (\"'%s' at %L is ambiguous\", e->symtree->n.sym->name,\n-\t\t     &e->where);\n-\t  return FAILURE;\n-\t}\n+      if (e->expr_type == FL_VARIABLE\n+\t    && e->symtree->n.sym->attr.generic\n+\t    && no_formal_args\n+\t    && count_specific_procs (e) != 1)\n+\treturn FAILURE;\n \n       if (e->ts.type != BT_PROCEDURE)\n \t{\n@@ -1138,23 +1170,11 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n \n \t  /* Check if a generic interface has a specific procedure\n \t    with the same name before emitting an error.  */\n-\t  if (sym->attr.generic)\n-\t    {\n-\t      gfc_interface *p;\n-\t      for (p = sym->generic; p; p = p->next)\n-\t\tif (strcmp (sym->name, p->sym->name) == 0)\n-\t\t  {\n-\t\t    e->symtree = gfc_find_symtree\n-\t\t\t\t\t   (p->sym->ns->sym_root, sym->name);\n-\t\t    sym = p->sym;\n-\t\t    break;\n-\t\t  }\n-\n-\t      if (p == NULL || e->symtree == NULL)\n-\t\tgfc_error (\"GENERIC procedure '%s' is not \"\n-\t\t\t   \"allowed as an actual argument at %L\", sym->name,\n-\t\t\t   &e->where);\n-\t    }\n+\t  if (sym->attr.generic && count_specific_procs (e) != 1)\n+\t    return FAILURE;\n+\t  \n+\t  /* Just in case a specific was found for the expression.  */\n+\t  sym = e->symtree->n.sym;\n \n \t  /* If the symbol is the function that names the current (or\n \t     parent) scope, then we really have a variable reference.  */\n@@ -2199,6 +2219,7 @@ resolve_function (gfc_expr *expr)\n   gfc_try t;\n   int temp;\n   procedure_type p = PROC_INTRINSIC;\n+  bool no_formal_args;\n \n   sym = NULL;\n   if (expr->symtree)\n@@ -2238,7 +2259,9 @@ resolve_function (gfc_expr *expr)\n   if (expr->symtree && expr->symtree->n.sym)\n     p = expr->symtree->n.sym->attr.proc;\n \n-  if (resolve_actual_arglist (expr->value.function.actual, p) == FAILURE)\n+  no_formal_args = sym && is_external_proc (sym) && sym->formal == NULL;\n+  if (resolve_actual_arglist (expr->value.function.actual,\n+\t\t\t      p, no_formal_args) == FAILURE)\n       return FAILURE;\n \n   /* Need to setup the call to the correct c_associated, depending on\n@@ -2817,26 +2840,27 @@ resolve_call (gfc_code *c)\n {\n   gfc_try t;\n   procedure_type ptype = PROC_INTRINSIC;\n+  gfc_symbol *csym;\n+  bool no_formal_args;\n+\n+  csym = c->symtree ? c->symtree->n.sym : NULL;\n \n-  if (c->symtree && c->symtree->n.sym\n-      && c->symtree->n.sym->ts.type != BT_UNKNOWN)\n+  if (csym && csym->ts.type != BT_UNKNOWN)\n     {\n       gfc_error (\"'%s' at %L has a type, which is not consistent with \"\n-\t\t \"the CALL at %L\", c->symtree->n.sym->name,\n-\t\t &c->symtree->n.sym->declared_at, &c->loc);\n+\t\t \"the CALL at %L\", csym->name, &csym->declared_at, &c->loc);\n       return FAILURE;\n     }\n \n   /* If external, check for usage.  */\n-  if (c->symtree && is_external_proc (c->symtree->n.sym))\n-    resolve_global_procedure (c->symtree->n.sym, &c->loc, 1);\n+  if (csym && is_external_proc (csym))\n+    resolve_global_procedure (csym, &c->loc, 1);\n \n   /* Subroutines without the RECURSIVE attribution are not allowed to\n    * call themselves.  */\n-  if (c->symtree && c->symtree->n.sym && !c->symtree->n.sym->attr.recursive)\n+  if (csym && !csym->attr.recursive)\n     {\n-      gfc_symbol *csym, *proc;\n-      csym = c->symtree->n.sym;\n+      gfc_symbol *proc;\n       proc = gfc_current_ns->proc_name;\n       if (csym == proc)\n       {\n@@ -2859,18 +2883,20 @@ resolve_call (gfc_code *c)\n      of procedure, once the procedure itself is resolved.  */\n   need_full_assumed_size++;\n \n-  if (c->symtree && c->symtree->n.sym)\n-    ptype = c->symtree->n.sym->attr.proc;\n+  if (csym)\n+    ptype = csym->attr.proc;\n \n-  if (resolve_actual_arglist (c->ext.actual, ptype) == FAILURE)\n+  no_formal_args = csym && is_external_proc (csym) && csym->formal == NULL;\n+  if (resolve_actual_arglist (c->ext.actual, ptype,\n+\t\t\t      no_formal_args) == FAILURE)\n     return FAILURE;\n \n   /* Resume assumed_size checking.  */\n   need_full_assumed_size--;\n \n   t = SUCCESS;\n   if (c->resolved_sym == NULL)\n-    switch (procedure_kind (c->symtree->n.sym))\n+    switch (procedure_kind (csym))\n       {\n       case PTYPE_GENERIC:\n \tt = resolve_generic_s (c);"}, {"sha": "37f07dfaa84c67a0f991129bc9e64867ce62bc21", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "patch": "@@ -1446,7 +1446,8 @@ gfc_add_access (symbol_attribute *attr, gfc_access access,\n \t\tconst char *name, locus *where)\n {\n \n-  if (attr->access == ACCESS_UNKNOWN)\n+  if (attr->access == ACCESS_UNKNOWN\n+\t|| (attr->use_assoc && attr->access != ACCESS_PRIVATE))\n     {\n       attr->access = access;\n       return check_conflict (attr, name, where);"}, {"sha": "1b034bb70cd2ad6a68625665950e3ac75872a344", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "patch": "@@ -1,3 +1,18 @@\n+2008-09-18  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/37274\n+\t* gfortran.dg/used_types_22.f90: New test.\n+\t* gfortran.dg/used_types_23.f90: New test.\n+\n+\tPR fortran/36374\n+\t* gfortran.dg/generic_17.f90: New test.\n+\t* gfortran.dg/ambiguous_specific_2.f90: New test.\n+\t* gfortran.dg/generic_actual_arg.f90: Add test for case that is\n+\tnot ambiguous.\n+\n+\tPR fortran/36454\n+\t* gfortran.dg/access_spec_3.f90: New test.\n+\n 2008-09-17  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/static_initializer3.ads: New test."}, {"sha": "9a076b66c546306e89af34f672c446b39fcbf8c5", "filename": "gcc/testsuite/gfortran.dg/access_spec_3.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Faccess_spec_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Faccess_spec_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Faccess_spec_3.f90?ref=0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do compile }\n+!\n+! Tests the fix for PR36454, where the PUBLIC declaration for\n+! aint and bint was rejected because the access was already set.\n+!\n+! Contributed by Thomas Orgis <thomas.orgis@awi.de>\n+\n+module base\n+        integer :: baseint\n+end module\n+\n+module a\n+        use base, ONLY: aint => baseint\n+end module\n+\n+module b\n+        use base, ONLY: bint => baseint\n+end module\n+\n+module c\n+        use a\n+        use b\n+        private\n+        public :: aint, bint\n+end module\n+\n+program user\n+        use c, ONLY: aint, bint\n+\n+        aint = 3\n+        bint = 8\n+        write(*,*) aint\n+end program\n+! { dg-final { cleanup-modules \"base a b c\" } }"}, {"sha": "4597b3c8630375cbc2338b2cc395020d9de98ec3", "filename": "gcc/testsuite/gfortran.dg/ambiguous_specific_2.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Fambiguous_specific_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Fambiguous_specific_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fambiguous_specific_2.f90?ref=0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do compile }\n+! Checks the fix for PR33542 does not throw an error if there is no\n+! ambiguity in the specific interfaces of foo.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+MODULE M1\n+   INTERFACE FOO\n+     MODULE PROCEDURE FOO\n+   END INTERFACE\n+CONTAINS\n+   SUBROUTINE FOO(I)\n+     INTEGER, INTENT(IN) :: I\n+     WRITE(*,*) 'INTEGER'\n+   END SUBROUTINE FOO\n+END MODULE M1\n+\n+MODULE M2\n+   INTERFACE FOO\n+     MODULE PROCEDURE FOOFOO\n+   END INTERFACE\n+CONTAINS\n+   SUBROUTINE FOOFOO(R)\n+     REAL, INTENT(IN) :: R\n+     WRITE(*,*) 'REAL'\n+   END SUBROUTINE FOOFOO\n+END MODULE M2\n+\n+PROGRAM P\n+   USE M1\n+   USE M2\n+   implicit none\n+   external bar\n+   CALL FOO(10)\n+   CALL FOO(10.)\n+   call bar (foo) \n+END PROGRAM P\n+\n+SUBROUTINE bar (arg)\n+  EXTERNAL arg\n+END SUBROUTINE bar\n+! { dg-final { cleanup-modules \"m1 m2\" } }"}, {"sha": "968d9c10c3707e8c8d4db0c303dc9051222e9260", "filename": "gcc/testsuite/gfortran.dg/generic_17.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_17.f90?ref=0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+! Test the patch for PR36374 in which the different\n+! symbols for 'foobar' would be incorrectly flagged as\n+! ambiguous in foo_mod.\n+!\n+! Contributed by Salvatore Filippone  <sfilippone@uniroma2.it>\n+!\n+module s_foo_mod\r\n+  type s_foo_type\r\n+    real(kind(1.e0)) :: v\r\n+  end type s_foo_type\r\n+  interface foobar\r\n+    subroutine s_foobar(x)\r\n+      import \r\n+      type(s_foo_type), intent (inout) :: x\r\n+    end subroutine s_foobar\r\n+  end interface\r\n+end module s_foo_mod\r\n+\r\n+module d_foo_mod\r\n+  type d_foo_type\r\n+    real(kind(1.d0)) :: v\r\n+  end type d_foo_type\r\n+  interface foobar\r\n+    subroutine d_foobar(x)\r\n+      import  \r\n+      type(d_foo_type), intent (inout) :: x\r\n+    end subroutine d_foobar\r\n+  end interface\r\n+end module d_foo_mod\r\n+\r\n+module foo_mod\r\n+  use s_foo_mod\r\n+  use d_foo_mod\r\n+end module foo_mod\r\n+\r\n+subroutine s_foobar(x)  \r\n+  use foo_mod\r\n+end subroutine s_foobar\r\n+! { dg-final { cleanup-modules \"s_foo_mod d_foo_mod foo_mod\" } }"}, {"sha": "9cf0d8eb00462711fd680855a427831e0939009a", "filename": "gcc/testsuite/gfortran.dg/generic_actual_arg.f90", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_actual_arg.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_actual_arg.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_actual_arg.f90?ref=0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "patch": "@@ -2,11 +2,14 @@\n ! Tests fix for PR20886 in which the passing of a generic procedure as\n ! an actual argument was not detected.\n !\n+! The second module and the check that CALCULATION2 is a good actual\n+! argument was added following the fix for PR26374.\n+!\n ! Contributed by Joost VandeVondele  <jv244@cam.ac.uk> \n !\n MODULE TEST\n INTERFACE CALCULATION\n-  MODULE PROCEDURE C1,C2\n+  MODULE PROCEDURE C1, C2\n END INTERFACE\n CONTAINS\n SUBROUTINE C1(r)\n@@ -16,11 +19,27 @@ SUBROUTINE C2(r)\n  REAL :: r\n END SUBROUTINE\n END MODULE TEST\n+\n+MODULE TEST2\n+INTERFACE CALCULATION2\n+  MODULE PROCEDURE CALCULATION2, C3\n+END INTERFACE\n+CONTAINS\n+SUBROUTINE CALCULATION2(r)\n+ INTEGER :: r\n+END SUBROUTINE\n+SUBROUTINE C3(r)\n+ REAL :: r\n+END SUBROUTINE\n+END MODULE TEST2\n     \n USE TEST\n-CALL F(CALCULATION) ! { dg-error \"GENERIC procedure\" } \n+USE TEST2\n+CALL F(CALCULATION)  ! { dg-error \"GENERIC procedure\" } \n+\n+CALL F(CALCULATION2) ! OK because there is a same name specific \n END\n \n SUBROUTINE F()\n END SUBROUTINE\n-! { dg-final { cleanup-modules \"TEST\" } }\n+! { dg-final { cleanup-modules \"TEST TEST2\" } }"}, {"sha": "2a5ae451a3dce2198cae42cbc579f1f0ea5e04a7", "filename": "gcc/testsuite/gfortran.dg/used_types_22.f90", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_22.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_22.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_22.f90?ref=0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "patch": "@@ -0,0 +1,294 @@\n+! { dg-do compile }\n+! Tests the fix for PR37274 a regression in which the derived type,\n+! 'vector' of the function results contained in 'class_motion' is\n+! private and is incorrectly detected to be ambiguous in 'smooth_mesh'.\n+!\n+! Contributed by Salvatore Filippone  <sfilippone@uniroma2.it>\n+!\n+module class_vector\r\n+\r\n+  implicit none\r\n+\r\n+  private ! Default\r\n+  public :: vector                                  \r\n+  public :: vector_ \r\n+\r\n+  type vector\r\n+     private\r\n+     real(kind(1.d0)) :: x\r\n+     real(kind(1.d0)) :: y\r\n+     real(kind(1.d0)) :: z\r\n+  end type vector\r\n+\r\n+contains\r\n+  ! ----- Constructors -----\r\n+\r\n+  ! Public default constructor\r\n+  elemental function vector_(x,y,z)\r\n+    type(vector) :: vector_\r\n+    real(kind(1.d0)), intent(in) :: x, y, z\r\n+\r\n+    vector_ = vector(x,y,z)\r\n+\r\n+  end function vector_\r\n+\r\n+end module class_vector\r\n+\r\n+module class_dimensions\r\n+\r\n+  implicit none\r\n+\r\n+  private ! Default\r\n+  public :: dimensions\r\n+\r\n+  type dimensions\r\n+     private\r\n+     integer :: l\r\n+     integer :: m\r\n+     integer :: t\r\n+     integer :: theta\r\n+  end type dimensions\r\n+\r\n+\r\n+end module class_dimensions\r\n+\r\n+module tools_math\r\n+\r\n+  implicit none\r\n+\r\n+\r\n+  interface lin_interp\r\n+     function lin_interp_s(f1,f2,fac)\r\n+       real(kind(1.d0)) :: lin_interp_s\r\n+       real(kind(1.d0)), intent(in) :: f1, f2\r\n+       real(kind(1.d0)), intent(in) :: fac\r\n+     end function lin_interp_s\r\n+\r\n+     function lin_interp_v(f1,f2,fac)\r\n+       use class_vector\r\n+       type(vector) :: lin_interp_v\r\n+       type(vector),     intent(in) :: f1, f2\r\n+       real(kind(1.d0)), intent(in) :: fac\r\n+     end function lin_interp_v\r\n+  end interface\r\n+\r\n+\r\n+  interface pwl_deriv\r\n+     subroutine pwl_deriv_x_s(dydx,x,y_data,x_data)\r\n+       real(kind(1.d0)), intent(out) :: dydx\r\n+       real(kind(1.d0)), intent(in) :: x\r\n+       real(kind(1.d0)), intent(in) :: y_data(:)\r\n+       real(kind(1.d0)), intent(in) :: x_data(:)\r\n+     end subroutine pwl_deriv_x_s\r\n+\r\n+     subroutine pwl_deriv_x_v(dydx,x,y_data,x_data)\r\n+       real(kind(1.d0)), intent(out) :: dydx(:)\r\n+       real(kind(1.d0)), intent(in) :: x\r\n+       real(kind(1.d0)), intent(in) :: y_data(:,:)\r\n+       real(kind(1.d0)), intent(in) :: x_data(:)\r\n+     end subroutine pwl_deriv_x_v\r\n+\r\n+     subroutine pwl_deriv_x_vec(dydx,x,y_data,x_data)\r\n+       use class_vector\r\n+       type(vector), intent(out) :: dydx\r\n+       real(kind(1.d0)), intent(in) :: x\r\n+       type(vector), intent(in) :: y_data(:)\r\n+       real(kind(1.d0)), intent(in) :: x_data(:)\r\n+     end subroutine pwl_deriv_x_vec\r\n+  end interface\r\n+\r\n+end module tools_math\r\n+\r\n+module class_motion\r\n+\r\n+  use class_vector\r\n+ \r\n+  implicit none\r\n+  \r\n+  private \r\n+  public :: motion \r\n+  public :: get_displacement, get_velocity\r\n+\r\n+  type motion\r\n+     private\r\n+     integer :: surface_motion\r\n+     integer :: vertex_motion\r\n+     !\r\n+     integer :: iml\r\n+     real(kind(1.d0)), allocatable :: law_x(:) \r\n+     type(vector), allocatable :: law_y(:)  \r\n+  end type motion\r\n+\r\n+contains\r\n+\r\n+\r\n+  function get_displacement(mot,x1,x2)\r\n+    use tools_math\r\n+\r\n+    type(vector) :: get_displacement\r\n+    type(motion), intent(in) :: mot\r\n+    real(kind(1.d0)), intent(in) :: x1, x2\r\n+    !\r\n+    integer :: i1, i2, i3, i4\r\n+    type(vector) :: p1, p2, v_A, v_B, v_C, v_D\r\n+    type(vector) :: i_trap_1, i_trap_2, i_trap_3\r\n+\r\n+    get_displacement = vector_(0.d0,0.d0,0.d0)\r\n+    \r\n+  end function get_displacement\r\n+\r\n+\r\n+  function get_velocity(mot,x)\r\n+    use tools_math\r\n+\r\n+    type(vector) :: get_velocity\r\n+    type(motion), intent(in) :: mot\r\n+    real(kind(1.d0)), intent(in) :: x\r\n+    !\r\n+    type(vector) :: v\r\n+    \r\n+    get_velocity = vector_(0.d0,0.d0,0.d0)\r\n+    \r\n+  end function get_velocity\r\n+  \r\n+  \r\n+\r\n+end module class_motion\r\n+\r\n+module class_bc_math\r\n+  \r\n+  implicit none\r\n+\r\n+  private \r\n+  public :: bc_math                           \r\n+\r\n+  type bc_math\r\n+     private\r\n+     integer :: id\r\n+     integer :: nbf\r\n+     real(kind(1.d0)), allocatable :: a(:) \r\n+     real(kind(1.d0)), allocatable :: b(:) \r\n+     real(kind(1.d0)), allocatable :: c(:) \r\n+  end type bc_math\r\n+\r\n+  \r\n+end module class_bc_math\r\n+\r\n+module class_bc\r\n+\r\n+  use class_bc_math\r\n+  use class_motion\r\n+\r\n+  implicit none\r\n+\r\n+  private \r\n+  public :: bc_poly                          \r\n+  public :: get_abc, &\r\n+       &    get_displacement, get_velocity  \r\n+\r\n+  type bc_poly\r\n+     private\r\n+     integer :: id\r\n+     type(motion) :: mot\r\n+     type(bc_math), pointer :: math => null()\r\n+  end type bc_poly\r\n+\r\n+\r\n+  interface get_displacement\r\n+     module procedure get_displacement, get_bc_motion_displacement\r\n+  end interface\r\n+\r\n+  interface get_velocity\r\n+     module procedure get_velocity, get_bc_motion_velocity\r\n+  end interface\r\n+\r\n+  interface get_abc\r\n+     module procedure get_abc_s, get_abc_v\r\n+  end interface\r\n+  \r\n+contains\r\n+\r\n+\r\n+  subroutine get_abc_s(bc,dim,id,a,b,c)\r\n+    use class_dimensions\r\n+    \r\n+    type(bc_poly), intent(in) :: bc\r\n+    type(dimensions), intent(in) :: dim\r\n+    integer, intent(out) :: id\r\n+    real(kind(1.d0)), intent(inout) :: a(:)\r\n+    real(kind(1.d0)), intent(inout) :: b(:)\r\n+    real(kind(1.d0)), intent(inout) :: c(:)\r\n+    \r\n+    \r\n+  end subroutine get_abc_s\r\n+\r\n+\r\n+  subroutine get_abc_v(bc,dim,id,a,b,c)\r\n+    use class_dimensions\r\n+    use class_vector\r\n+\r\n+    type(bc_poly), intent(in) :: bc\r\n+    type(dimensions), intent(in) :: dim\r\n+    integer, intent(out) :: id\r\n+    real(kind(1.d0)), intent(inout) :: a(:)\r\n+    real(kind(1.d0)), intent(inout) :: b(:)\r\n+    type(vector),     intent(inout) :: c(:)\r\n+\r\n+    \r\n+  end subroutine get_abc_v\r\n+\r\n+\r\n+\r\n+  function get_bc_motion_displacement(bc,x1,x2)result(res)\r\n+    use class_vector\r\n+    type(vector) :: res\r\n+    type(bc_poly), intent(in) :: bc\r\n+    real(kind(1.d0)), intent(in) :: x1, x2\r\n+    \r\n+    res = get_displacement(bc%mot,x1,x2)\r\n+\r\n+  end function get_bc_motion_displacement\r\n+\r\n+\r\n+  function get_bc_motion_velocity(bc,x)result(res)\r\n+    use class_vector\r\n+    type(vector) :: res\r\n+    type(bc_poly), intent(in) :: bc\r\n+    real(kind(1.d0)), intent(in) :: x\r\n+\r\n+    res = get_velocity(bc%mot,x)\r\n+\r\n+  end function get_bc_motion_velocity\r\n+\r\n+\r\n+end module class_bc\r\n+\r\n+module tools_mesh_basics\r\n+  \r\n+  implicit none\r\n+  \r\n+  interface\r\n+     function geom_tet_center(v1,v2,v3,v4)\r\n+       use class_vector\r\n+       type(vector) :: geom_tet_center\r\n+       type(vector), intent(in) :: v1, v2, v3, v4\r\n+     end function geom_tet_center\r\n+  end interface\r\n+\r\n+\r\n+end module tools_mesh_basics\r\n+\r\n+\r\n+subroutine smooth_mesh\r\n+\r\n+  use class_bc\r\n+  use class_vector\r\n+  use tools_mesh_basics\r\n+\r\n+  implicit none\r\n+\r\n+  type(vector) :: new_pos  ! the new vertex position, after smoothing\r\n+\r\n+end subroutine smooth_mesh\r\n+! { dg-final { cleanup-modules \"class_vector class_dimensions tools_math\" } }\n+! { dg-final { cleanup-modules \"class_motion class_bc_math class_bc tools_mesh_basics\" } }"}, {"sha": "7374223693f2f0cfe81c0ef29cfbefb99ebf20c3", "filename": "gcc/testsuite/gfortran.dg/used_types_23.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_23.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4e2af765d06ef7a49b7ad75cd205ea7c665819/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_23.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_23.f90?ref=0b4e2af765d06ef7a49b7ad75cd205ea7c665819", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+! Tests the fix for PR37274 comment 4 in which the use associated 'vector' was\r\n+! passed up from the interface to the module 'tools_math'.\n+!\n+! Contributed by Mikael Morin  <mikael.morin@tele2.fr>\n+!\n+module class_vector\r\n+  implicit none\r\n+  type vector\r\n+  end type vector\r\n+end module class_vector\r\n+\r\n+module tools_math\r\n+  implicit none\r\n+  interface lin_interp\r\n+     function lin_interp_v()\r\n+       use class_vector\r\n+       type(vector) :: lin_interp_v\r\n+     end function lin_interp_v\r\n+  end interface\r\n+end module tools_math\r\n+\r\n+module smooth_mesh\r\n+  use tools_math\r\n+  implicit none\r\n+  type(vector ) :: new_pos  ! { dg-error \"used before it is defined\" }\r\n+end module smooth_mesh\r\n+\r\n+! { dg-final { cleanup-modules \"class_vector tools_math smooth_mesh\" } }"}]}