{"sha": "d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZmZDFmMDdhYzFmMjFmMGRkODQyMDIwODgxMDJiN2I3N2JjZDEwNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-05-02T09:06:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-05-02T09:06:41Z"}, "message": "[multiple changes]\n\n2017-05-02  Bob Duff  <duff@adacore.com>\n\n\t* sem_attr.adb (Attribute_Enum_Rep): Disallow T'Enum_Rep.\n\n2017-05-02  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* s-os_lib.ads: Minor typo fix.\n\n2017-05-02  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* gnatls.adb: Merge and refactor code from Prj.Env and remove\n\tthis deprecated dependency.\n\n2017-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.ads: minor comment addition.\n\n2017-05-02  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch3.adb (Build_Derived_Record_Type): Fix a few typos and\n\tpastos in part #3 of the head comment.\n\n2017-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch3.adb (Freeze_Type): Do not generate an invariant\n\tprocedure body for a local (sub)type declaration within a\n\tpredicate function. Invariant checks do not apply to these, and\n\tthe expansion of the procedure will happen in the wrong scope,\n\tleading to misplaced freeze nodes.\n\n2017-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.adb (Insert_Library_Level_Action): Use proper scope\n\tto analyze generated actions.  If the main unit is a body,\n\tthe required scope is that of the corresponding unit declaration.\n\n2017-05-02  Arnaud Charlet  <charlet@adacore.com>\n\n\t* einfo.adb (Declaration_Node): flip branches of\n\tan IF statement to avoid repeated negations in its condition;\n\tno change in semantics, only to improve readability.\n\nFrom-SVN: r247480", "tree": {"sha": "090074251d194c3bc6f75ede05214292ce38ebfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/090074251d194c3bc6f75ede05214292ce38ebfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/comments", "author": null, "committer": null, "parents": [{"sha": "2d249f52b53c9c4b0d6fdbd1490f3871d1df5d40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d249f52b53c9c4b0d6fdbd1490f3871d1df5d40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d249f52b53c9c4b0d6fdbd1490f3871d1df5d40"}], "stats": {"total": 602, "additions": 556, "deletions": 46}, "files": [{"sha": "77477d4d4177eed036874b4827800d86e63a37ef", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "patch": "@@ -1,3 +1,45 @@\n+2017-05-02  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_attr.adb (Attribute_Enum_Rep): Disallow T'Enum_Rep.\n+\n+2017-05-02  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* s-os_lib.ads: Minor typo fix.\n+\n+2017-05-02  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* gnatls.adb: Merge and refactor code from Prj.Env and remove\n+\tthis deprecated dependency.\n+\n+2017-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.ads: minor comment addition.\n+\n+2017-05-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch3.adb (Build_Derived_Record_Type): Fix a few typos and\n+\tpastos in part #3 of the head comment.\n+\n+2017-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch3.adb (Freeze_Type): Do not generate an invariant\n+\tprocedure body for a local (sub)type declaration within a\n+\tpredicate function. Invariant checks do not apply to these, and\n+\tthe expansion of the procedure will happen in the wrong scope,\n+\tleading to misplaced freeze nodes.\n+\n+2017-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.adb (Insert_Library_Level_Action): Use proper scope\n+\tto analyze generated actions.  If the main unit is a body,\n+\tthe required scope is that of the corresponding unit declaration.\n+\n+2017-05-02  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* einfo.adb (Declaration_Node): flip branches of\n+\tan IF statement to avoid repeated negations in its condition;\n+\tno change in semantics, only to improve readability.\n+\n 2017-05-02  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_case.adb: Remove extra spaces in parameter declarations."}, {"sha": "2d283db30dad8f72ca0d9cf5276e9846412c47e7", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "patch": "@@ -7117,15 +7117,13 @@ package body Einfo is\n       end if;\n \n       loop\n-         if Nkind (P) /= N_Selected_Component\n-           and then Nkind (P) /= N_Expanded_Name\n-           and then\n-             not (Nkind (P) = N_Defining_Program_Unit_Name\n-                   and then Is_Child_Unit (Id))\n+         if Nkind_In (P, N_Selected_Component, N_Expanded_Name)\n+           or else (Nkind (P) = N_Defining_Program_Unit_Name\n+                    and then Is_Child_Unit (Id))\n          then\n-            return P;\n-         else\n             P := Parent (P);\n+         else\n+            return P;\n          end if;\n       end loop;\n    end Declaration_Node;"}, {"sha": "6d9bdaab8c69cb47fa14ff2d84b6fd84a0d24657", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "patch": "@@ -7554,8 +7554,19 @@ package body Exp_Ch3 is\n \n       --  Non-interface types\n \n+      --  Do not generate invariant procedure within other assertion\n+      --  subprograms, which may involve local declarations of local\n+      --  subtypes to which these checks don't apply.\n+\n       elsif Has_Invariants (Def_Id) then\n-         Build_Invariant_Procedure_Body (Def_Id);\n+         if Within_Internal_Subprogram\n+          or else (Ekind (Current_Scope) = E_Function\n+                    and then Is_Predicate_Function (Current_Scope))\n+         then\n+            null;\n+         else\n+            Build_Invariant_Procedure_Body (Def_Id);\n+         end if;\n       end if;\n \n       Restore_Ghost_Mode (Saved_GM);"}, {"sha": "8270ea5499c64d277742d9bb3a70abe4c900b5a1", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "patch": "@@ -7491,8 +7491,10 @@ package body Exp_Util is\n       Aux : constant Node_Id := Aux_Decls_Node (Cunit (Main_Unit));\n \n    begin\n-      Push_Scope (Cunit_Entity (Main_Unit));\n-      --  ??? should this be Current_Sem_Unit instead of Main_Unit?\n+      Push_Scope (Cunit_Entity (Current_Sem_Unit));\n+      --  And not Main_Unit as previously. If the main unit is a body,\n+      --  the scope needed to analyze the actions is the entity of the\n+      --  corresponding declaration.\n \n       if No (Actions (Aux)) then\n          Set_Actions (Aux, New_List (N));"}, {"sha": "1873cb10b227392f7243b1969c833c889bc76356", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "patch": "@@ -1177,7 +1177,9 @@ package Exp_Util is\n    function Within_Internal_Subprogram return Boolean;\n    --  Indicates that some expansion is taking place within the body of a\n    --  predefined primitive operation. Some expansion activity (e.g. predicate\n-   --  checks) is disabled in such.\n+   --  checks) is disabled in such. Because we want to detect invalid uses\n+   --  of function calls within predicates (which lead to infinite recursion)\n+   --  predicate functions themselves are not considered internal here.\n \n private\n    pragma Inline (Duplicate_Subexpr);"}, {"sha": "b31277bb5bc90bf5e4a8ef3c6aa40c8c8d57aed4", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 469, "deletions": 24, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "patch": "@@ -23,31 +23,32 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+pragma Ada_2012;\n+\n with ALI;         use ALI;\n with ALI.Util;    use ALI.Util;\n with Binderr;     use Binderr;\n with Butil;       use Butil;\n with Csets;       use Csets;\n with Fname;       use Fname;\n with Gnatvsn;     use Gnatvsn;\n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with Makeutl;     use Makeutl;\n with Namet;       use Namet;\n with Opt;         use Opt;\n with Osint;       use Osint;\n with Osint.L;     use Osint.L;\n with Output;      use Output;\n-with Prj.Env;     use Prj.Env;\n with Rident;      use Rident;\n with Sdefault;\n with Snames;\n with Stringt;\n with Switch;      use Switch;\n with Types;       use Types;\n \n-with Ada.Command_Line; use Ada.Command_Line;\n-\n-with GNAT.Command_Line; use GNAT.Command_Line;\n-with GNAT.Case_Util;    use GNAT.Case_Util;\n+with GNAT.Case_Util;            use GNAT.Case_Util;\n+with GNAT.Command_Line;         use GNAT.Command_Line;\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n procedure Gnatls is\n    pragma Ident (Gnat_Static_Version_String);\n@@ -59,7 +60,7 @@ procedure Gnatls is\n    --  Label displayed in verbose mode before the directories in the project\n    --  search path. Do not modify without checking NOTE above.\n \n-   Prj_Path : Prj.Env.Project_Search_Path;\n+   Prj_Path : String_Access;\n \n    Max_Column : constant := 80;\n \n@@ -212,6 +213,46 @@ procedure Gnatls is\n \n    end GNATDIST;\n \n+   ------------------------------\n+   -- Support for project path --\n+   ------------------------------\n+\n+   package Prj_Env is\n+\n+      procedure Initialize_Default_Project_Path\n+        (Self         : in out String_Access;\n+         Target_Name  : String;\n+         Runtime_Name : String := \"\");\n+      --  Initialize Self. It will then contain the default project path on\n+      --  the given target and runtime (including directories specified by the\n+      --  environment variables GPR_PROJECT_PATH_FILE, GPR_PROJECT_PATH and\n+      --  ADA_PROJECT_PATH). If one of the directory or Target_Name is \"-\",\n+      --  then the path contains only those directories specified by the\n+      --  environment variables (except \"-\"). This does nothing if Self has\n+      --  already been initialized.\n+\n+      procedure Add_Directories\n+        (Self    : in out String_Access;\n+         Path    : String;\n+         Prepend : Boolean := False);\n+      --  Add one or more directories to the path. Directories added with this\n+      --  procedure are added in order after the current directory and before\n+      --  the path given by the environment variable GPR_PROJECT_PATH. A value\n+      --  of \"-\" will remove the default project directory from the project\n+      --  path.\n+      --\n+      --  Calls to this subprogram must be performed before the first call to\n+      --  Find_Project below, or PATH will be added at the end of the search\n+      --  path.\n+\n+      function Get_Runtime_Path\n+        (Self : String_Access;\n+         Path : String) return String_Access;\n+      --  Compute the full path for the project-based runtime name.\n+      --  Path is simply searched on the project path.\n+\n+   end Prj_Env;\n+\n    -----------------\n    -- Add_Lib_Dir --\n    -----------------\n@@ -1187,6 +1228,412 @@ procedure Gnatls is\n       end if;\n    end Output_Unit;\n \n+   package body Prj_Env is\n+\n+      Uninitialized_Prefix : constant String := '#' & Path_Separator;\n+      --  Prefix to indicate that the project path has not been initialized\n+      --  yet. Must be two characters long\n+\n+      ---------------------\n+      -- Add_Directories --\n+      ---------------------\n+\n+      procedure Add_Directories\n+        (Self    : in out String_Access;\n+         Path    : String;\n+         Prepend : Boolean := False)\n+      is\n+         Tmp : String_Access;\n+      begin\n+         if Self = null then\n+            Self := new String'(Uninitialized_Prefix & Path);\n+         else\n+            Tmp := Self;\n+            if Prepend then\n+               Self := new String'(Path & Path_Separator & Tmp.all);\n+            else\n+               Self := new String'(Tmp.all & Path_Separator & Path);\n+            end if;\n+            Free (Tmp);\n+         end if;\n+\n+      end Add_Directories;\n+\n+      -------------------------------------\n+      -- Initialize_Default_Project_Path --\n+      -------------------------------------\n+\n+      procedure Initialize_Default_Project_Path\n+        (Self         : in out String_Access;\n+         Target_Name  : String;\n+         Runtime_Name : String := \"\")\n+      is\n+         Add_Default_Dir : Boolean := Target_Name /= \"-\";\n+         First           : Positive;\n+         Last            : Positive;\n+\n+         Ada_Project_Path      : constant String := \"ADA_PROJECT_PATH\";\n+         Gpr_Project_Path      : constant String := \"GPR_PROJECT_PATH\";\n+         Gpr_Project_Path_File : constant String := \"GPR_PROJECT_PATH_FILE\";\n+         --  Names of alternate env. variables that contain path name(s) of\n+         --  directories where project files may reside. They are taken into\n+         --  account in this order: GPR_PROJECT_PATH_FILE, GPR_PROJECT_PATH,\n+         --  ADA_PROJECT_PATH.\n+\n+         Gpr_Prj_Path_File : String_Access;\n+         Gpr_Prj_Path      : String_Access;\n+         Ada_Prj_Path      : String_Access;\n+         --  The path name(s) of directories where project files may reside.\n+         --  May be empty.\n+\n+         Prefix  : String_Ptr;\n+         Runtime : String_Ptr;\n+\n+         procedure Add_Target (Suffix : String);\n+         --  Add :<prefix>/<target>/Suffix to the project path\n+\n+         FD  : File_Descriptor;\n+         Len : Integer;\n+\n+         ----------------\n+         -- Add_Target --\n+         ----------------\n+\n+         procedure Add_Target (Suffix : String) is\n+            Extra_Sep : constant String :=\n+               (if Target_Name (Target_Name'Last) = '/' then\n+                  \"\"\n+                else\n+                  (1 => Directory_Separator));\n+            --  Note: Target_Name has a trailing / when it comes from Sdefault\n+         begin\n+            Add_Str_To_Name_Buffer\n+              (Path_Separator & Prefix.all & Target_Name & Extra_Sep & Suffix);\n+         end Add_Target;\n+\n+      --  Start of processing for Initialize_Default_Project_Path\n+\n+      begin\n+         if Self /= null\n+            and then (Self'Length = 0\n+                      or else Self (Self'First) /= '#')\n+         then\n+            return;\n+         end if;\n+\n+         --  The current directory is always first in the search path. Since\n+         --  the Project_Path currently starts with '#:' as a sign that it\n+         --  isn't initialized, we simply replace '#' with '.'\n+\n+         if Self = null then\n+            Self := new String'('.' & Path_Separator);\n+         else\n+            Self (Self'First) := '.';\n+         end if;\n+\n+         --  Then the reset of the project path (if any) currently contains the\n+         --  directories added through Add_Search_Project_Directory\n+\n+         --  If environment variables are defined and not empty, add their\n+         --  content\n+\n+         Gpr_Prj_Path_File := Getenv (Gpr_Project_Path_File);\n+         Gpr_Prj_Path      := Getenv (Gpr_Project_Path);\n+         Ada_Prj_Path      := Getenv (Ada_Project_Path);\n+\n+         if Gpr_Prj_Path_File.all /= \"\" then\n+\n+            FD := Open_Read (Gpr_Prj_Path_File.all, GNAT.OS_Lib.Text);\n+\n+            if FD = Invalid_FD then\n+               Osint.Fail (\"warning: could not read project path file \"\"\" &\n+                           Gpr_Prj_Path_File.all & \"\"\"\");\n+            end if;\n+\n+            Len := Integer (File_Length (FD));\n+\n+            declare\n+               Buffer : String (1 .. Len);\n+               Index  : Positive := 1;\n+               Last   : Positive;\n+               Tmp    : String_Access;\n+\n+            begin\n+               --  Read the file\n+\n+               Len := Read (FD, Buffer (1)'Address, Len);\n+               Close (FD);\n+\n+               --  Scan the file line by line\n+\n+               while Index < Buffer'Last loop\n+\n+                  --  Find the end of line\n+\n+                  Last := Index;\n+                  while Last <= Buffer'Last\n+                    and then Buffer (Last) /= ASCII.LF\n+                    and then Buffer (Last) /= ASCII.CR\n+                  loop\n+                     Last := Last + 1;\n+                  end loop;\n+\n+                  --  Ignore empty lines\n+\n+                  if Last > Index then\n+                     Tmp := Self;\n+                     Self :=\n+                       new String'\n+                         (Tmp.all & Path_Separator &\n+                          Buffer (Index .. Last - 1));\n+                     Free (Tmp);\n+                  end if;\n+\n+                  --  Find the beginning of the next line\n+\n+                  Index := Last;\n+                  while Buffer (Index) = ASCII.CR or else\n+                        Buffer (Index) = ASCII.LF\n+                  loop\n+                     Index := Index + 1;\n+                  end loop;\n+               end loop;\n+            end;\n+\n+         end if;\n+\n+         if Gpr_Prj_Path.all /= \"\" then\n+            Add_Directories (Self, Gpr_Prj_Path.all);\n+         end if;\n+\n+         Free (Gpr_Prj_Path);\n+\n+         if Ada_Prj_Path.all /= \"\" then\n+            Add_Directories (Self, Ada_Prj_Path.all);\n+         end if;\n+\n+         Free (Ada_Prj_Path);\n+\n+         --  Copy to Name_Buffer, since we will need to manipulate the path\n+\n+         Name_Len := Self'Length;\n+         Name_Buffer (1 .. Name_Len) := Self.all;\n+\n+         --  Scan the directory path to see if \"-\" is one of the directories.\n+         --  Remove each occurrence of \"-\" and set Add_Default_Dir to False.\n+         --  Also resolve relative paths and symbolic links.\n+\n+         First := 3;\n+         loop\n+            while First <= Name_Len\n+              and then (Name_Buffer (First) = Path_Separator)\n+            loop\n+               First := First + 1;\n+            end loop;\n+\n+            exit when First > Name_Len;\n+\n+            Last := First;\n+\n+            while Last < Name_Len\n+              and then Name_Buffer (Last + 1) /= Path_Separator\n+            loop\n+               Last := Last + 1;\n+            end loop;\n+\n+            --  If the directory is \"-\", set Add_Default_Dir to False and\n+            --  remove from path.\n+\n+            if Name_Buffer (First .. Last) = \"-\" then\n+               Add_Default_Dir := False;\n+\n+               for J in Last + 1 .. Name_Len loop\n+                  Name_Buffer (J - 2) :=\n+                    Name_Buffer (J);\n+               end loop;\n+\n+               Name_Len := Name_Len - 2;\n+\n+               --  After removing the '-', go back one character to get the\n+               --  next directory correctly.\n+\n+               Last := Last - 1;\n+\n+            else\n+               declare\n+                  New_Dir : constant String :=\n+                              Normalize_Pathname\n+                                (Name_Buffer (First .. Last),\n+                                 Resolve_Links => Opt.Follow_Links_For_Dirs);\n+                  New_Len  : Positive;\n+                  New_Last : Positive;\n+\n+               begin\n+                  --  If the absolute path was resolved and is different from\n+                  --  the original, replace original with the resolved path.\n+\n+                  if New_Dir /= Name_Buffer (First .. Last)\n+                    and then New_Dir'Length /= 0\n+                  then\n+                     New_Len := Name_Len + New_Dir'Length - (Last - First + 1);\n+                     New_Last := First + New_Dir'Length - 1;\n+                     Name_Buffer (New_Last + 1 .. New_Len) :=\n+                       Name_Buffer (Last + 1 .. Name_Len);\n+                     Name_Buffer (First .. New_Last) := New_Dir;\n+                     Name_Len := New_Len;\n+                     Last := New_Last;\n+                  end if;\n+               end;\n+            end if;\n+\n+            First := Last + 1;\n+         end loop;\n+\n+         Free (Self);\n+\n+         --  Set the initial value of Current_Project_Path\n+\n+         if Add_Default_Dir then\n+            if Sdefault.Search_Dir_Prefix = null then\n+\n+               --  gprbuild case\n+\n+               Prefix := new String'(Executable_Prefix_Path);\n+\n+            else\n+               Prefix := new String'(Sdefault.Search_Dir_Prefix.all\n+                                     & \"..\" & Dir_Separator\n+                                     & \"..\" & Dir_Separator\n+                                     & \"..\" & Dir_Separator\n+                                     & \"..\" & Dir_Separator);\n+            end if;\n+\n+            if Prefix.all /= \"\" then\n+               if Target_Name /= \"\" then\n+\n+                  if Runtime_Name /= \"\" then\n+                     if Base_Name (Runtime_Name) = Runtime_Name then\n+\n+                        --  $prefix/$target/$runtime/lib/gnat\n+                        Add_Target\n+                          (Runtime_Name & Directory_Separator &\n+                           \"lib\" & Directory_Separator & \"gnat\");\n+\n+                        --  $prefix/$target/$runtime/share/gpr\n+                        Add_Target\n+                          (Runtime_Name & Directory_Separator &\n+                             \"share\" & Directory_Separator & \"gpr\");\n+\n+                     else\n+                        Runtime :=\n+                          new String'(Normalize_Pathname (Runtime_Name));\n+\n+                        --  $runtime_dir/lib/gnat\n+                        Add_Str_To_Name_Buffer\n+                          (Path_Separator & Runtime.all & Directory_Separator &\n+                           \"lib\" & Directory_Separator & \"gnat\");\n+\n+                        --  $runtime_dir/share/gpr\n+                        Add_Str_To_Name_Buffer\n+                          (Path_Separator & Runtime.all & Directory_Separator &\n+                           \"share\" & Directory_Separator & \"gpr\");\n+                     end if;\n+                  end if;\n+\n+                  --  $prefix/$target/lib/gnat\n+                  Add_Target\n+                    (\"lib\" & Directory_Separator & \"gnat\");\n+\n+                  --  $prefix/$target/share/gpr\n+                  Add_Target\n+                    (\"share\" & Directory_Separator & \"gpr\");\n+               end if;\n+\n+               --  $prefix/share/gpr\n+\n+               Add_Str_To_Name_Buffer\n+                 (Path_Separator & Prefix.all & \"share\"\n+                  & Directory_Separator & \"gpr\");\n+\n+               --  $prefix/lib/gnat\n+\n+               Add_Str_To_Name_Buffer\n+                 (Path_Separator & Prefix.all & \"lib\"\n+                  & Directory_Separator & \"gnat\");\n+            end if;\n+\n+            Free (Prefix);\n+         end if;\n+\n+         Self := new String'(Name_Buffer (1 .. Name_Len));\n+      end Initialize_Default_Project_Path;\n+\n+      -----------------------\n+      -- Get_Runtime_Path --\n+      -----------------------\n+\n+      function Get_Runtime_Path\n+        (Self : String_Access;\n+         Path : String) return String_Access\n+      is\n+         First : Natural;\n+         Last  : Natural;\n+\n+      begin\n+\n+         if Is_Absolute_Path (Path) then\n+            if Is_Directory (Path) then\n+               return new String'(Path);\n+            else\n+               return null;\n+            end if;\n+\n+         else\n+            --  Because we don't want to resolve symbolic links, we cannot\n+            --  use Locate_Regular_File. So, we try each possible path\n+            --  successively.\n+\n+            First := Self'First;\n+            while First <= Self'Last loop\n+               while First <= Self'Last\n+                 and then Self (First) = Path_Separator\n+               loop\n+                  First := First + 1;\n+               end loop;\n+\n+               exit when First > Self'Last;\n+\n+               Last := First;\n+               while Last < Self'Last\n+                 and then Self (Last + 1) /= Path_Separator\n+               loop\n+                  Last := Last + 1;\n+               end loop;\n+\n+               Name_Len := 0;\n+\n+               if not Is_Absolute_Path (Self (First .. Last)) then\n+                  Add_Str_To_Name_Buffer (Get_Current_Dir);  -- ??? System call\n+                  Add_Char_To_Name_Buffer (Directory_Separator);\n+               end if;\n+\n+               Add_Str_To_Name_Buffer (Self (First .. Last));\n+               Add_Char_To_Name_Buffer (Directory_Separator);\n+               Add_Str_To_Name_Buffer (Path);\n+\n+               if Is_Directory (Name_Buffer (1 .. Name_Len)) then\n+                  return new String'(Name_Buffer (1 .. Name_Len));\n+               end if;\n+\n+               First := Last + 1;\n+            end loop;\n+         end if;\n+\n+         return null;\n+      end Get_Runtime_Path;\n+\n+   end Prj_Env;\n+\n    -----------------\n    -- Reset_Print --\n    -----------------\n@@ -1225,7 +1672,7 @@ procedure Gnatls is\n       if Src_Path /= null and then Lib_Path /= null then\n          Add_Search_Dirs (Src_Path, Include);\n          Add_Search_Dirs (Lib_Path, Objects);\n-         Initialize_Default_Project_Path\n+         Prj_Env.Initialize_Default_Project_Path\n            (Prj_Path,\n             Target_Name  => Sdefault.Target_Name.all,\n             Runtime_Name => Name);\n@@ -1240,12 +1687,12 @@ procedure Gnatls is\n \n       --  Try to find the RTS on the project path. First setup the project path\n \n-      Initialize_Default_Project_Path\n+      Prj_Env.Initialize_Default_Project_Path\n         (Prj_Path,\n          Target_Name  => Sdefault.Target_Name.all,\n          Runtime_Name => Name);\n \n-      Rts_Full_Path := Get_Runtime_Path (Prj_Path, Name);\n+      Rts_Full_Path := Prj_Env.Get_Runtime_Path (Prj_Path, Name);\n \n       if Rts_Full_Path /= null then\n \n@@ -1330,7 +1777,7 @@ procedure Gnatls is\n          --  Processing for -aP<dir>\n \n          elsif Argv'Length > 3 and then Argv (1 .. 3) = \"-aP\" then\n-            Add_Directories (Prj_Path, Argv (4 .. Argv'Last));\n+            Prj_Env.Add_Directories (Prj_Path, Argv (4 .. Argv'Last));\n \n          --  Processing for -nostdinc\n \n@@ -1719,36 +2166,34 @@ begin\n       Write_Str (\"   <Current_Directory>\");\n       Write_Eol;\n \n-      Initialize_Default_Project_Path\n+      Prj_Env.Initialize_Default_Project_Path\n         (Prj_Path, Target_Name => Sdefault.Target_Name.all);\n \n       declare\n-         Project_Path : String_Access;\n          First        : Natural;\n          Last         : Natural;\n \n       begin\n-         Get_Path (Prj_Path, Project_Path);\n \n-         if Project_Path.all /= \"\" then\n-            First := Project_Path'First;\n+         if Prj_Path.all /= \"\" then\n+            First := Prj_Path'First;\n             loop\n-               while First <= Project_Path'Last\n-                 and then (Project_Path (First) = Path_Separator)\n+               while First <= Prj_Path'Last\n+                 and then (Prj_Path (First) = Path_Separator)\n                loop\n                   First := First + 1;\n                end loop;\n \n-               exit when First > Project_Path'Last;\n+               exit when First > Prj_Path'Last;\n \n                Last := First;\n-               while Last < Project_Path'Last\n-                 and then Project_Path (Last + 1) /= Path_Separator\n+               while Last < Prj_Path'Last\n+                 and then Prj_Path (Last + 1) /= Path_Separator\n                loop\n                   Last := Last + 1;\n                end loop;\n \n-               if First /= Last or else Project_Path (First) /= '.' then\n+               if First /= Last or else Prj_Path (First) /= '.' then\n \n                   --  If the directory is \".\", skip it as it is the current\n                   --  directory and it is already the first directory in the\n@@ -1758,7 +2203,7 @@ begin\n                   Write_Str\n                     (Normalize\n                       (To_Host_Dir_Spec\n-                        (Project_Path (First .. Last), True).all));\n+                        (Prj_Path (First .. Last), True).all));\n                   Write_Eol;\n                end if;\n \n@@ -1778,7 +2223,7 @@ begin\n \n    if not More_Lib_Files then\n       if not Print_Usage and then not Verbose_Mode then\n-         if Argument_Count = 0 then\n+         if Arg_Count = 1 then\n             Usage;\n          else\n             Try_Help;"}, {"sha": "5fba00aad64a4b292af4c4770d4979e97ca8899c", "filename": "gcc/ada/s-os_lib.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1995-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -366,7 +366,7 @@ package System.OS_Lib is\n \n    type Large_File_Size is range -2**63 .. 2**63 - 1;\n    --  Maximum supported size for a file (8 exabytes = 8 million terabytes,\n-   --  should be enough to accomodate all possible needs for quite a while).\n+   --  should be enough to accommodate all possible needs for quite a while).\n \n    function File_Length64 (FD : File_Descriptor) return Large_File_Size;\n    pragma Import (C, File_Length64, \"__gnat_file_length\");"}, {"sha": "7f2d105865db3513574a753290cc0d782e6d480a", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "patch": "@@ -3763,13 +3763,23 @@ package body Sem_Attr is\n       --------------\n \n       when Attribute_Enum_Rep =>\n+         --  T'Enum_Rep (X) case\n+\n          if Present (E1) then\n             Check_E1;\n             Check_Discrete_Type;\n             Resolve (E1, P_Base_Type);\n \n-         elsif not Is_Discrete_Type (Etype (P)) then\n-            Error_Attr_P (\"prefix of % attribute must be of discrete type\");\n+         --  X'Enum_Rep case.  X must be an object or enumeration literal, and\n+         --  it must be of a discrete type.\n+\n+         elsif not ((Is_Object_Reference (P)\n+                       or else (Is_Entity_Name (P)\n+                                  and then Ekind (Entity (P)) =\n+                                             E_Enumeration_Literal))\n+                    and then Is_Discrete_Type (Etype (P)))\n+         then\n+            Error_Attr_P (\"prefix of % attribute must be discrete object\");\n          end if;\n \n          Set_Etype (N, Universal_Integer);"}, {"sha": "b15ee3d49beb2271daaf20c4a865548dac620ccd", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6fd1f07ac1f21f0dd84202088102b7b77bcd104/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d6fd1f07ac1f21f0dd84202088102b7b77bcd104", "patch": "@@ -8028,7 +8028,7 @@ package body Sem_Ch3 is\n    --  3. DISCRIMINANTS IN DERIVED UNTAGGED RECORD TYPES\n \n    --  We have spoken about stored discriminants in point 1 (introduction)\n-   --  above. There are two sort of stored discriminants: implicit and\n+   --  above. There are two sorts of stored discriminants: implicit and\n    --  explicit. As long as the derived type inherits the same discriminants as\n    --  the root record type, stored discriminants are the same as regular\n    --  discriminants, and are said to be implicit. However, if any discriminant\n@@ -8047,7 +8047,7 @@ package body Sem_Ch3 is\n    --           type T4 (Y : Int) is new T3 (Y, 99);\n \n    --  The following table summarizes the discriminants and stored\n-   --  discriminants in R and T1 through T4.\n+   --  discriminants in R and T1 through T4:\n \n    --   Type      Discrim     Stored Discrim  Comment\n    --    R      (D1, D2, D3)   (D1, D2, D3)   Girder discrims implicit in R\n@@ -8058,7 +8058,7 @@ package body Sem_Ch3 is\n \n    --  Field Corresponding_Discriminant (abbreviated CD below) allows us to\n    --  find the corresponding discriminant in the parent type, while\n-   --  Original_Record_Component (abbreviated ORC below), the actual physical\n+   --  Original_Record_Component (abbreviated ORC below) the actual physical\n    --  component that is renamed. Finally the field Is_Completely_Hidden\n    --  (abbreviated ICH below) is set for all explicit stored discriminants\n    --  (see einfo.ads for more info). For the above example this gives:\n@@ -8085,10 +8085,10 @@ package body Sem_Ch3 is\n    --                 D2 in T3   empty    itself    yes\n    --                 D3 in T3   empty    itself    yes\n \n-   --                 Y  in T4  X1 in T3  D3 in T3   no\n-   --                 D1 in T3   empty    itself    yes\n-   --                 D2 in T3   empty    itself    yes\n-   --                 D3 in T3   empty    itself    yes\n+   --                 Y  in T4  X1 in T3  D3 in T4   no\n+   --                 D1 in T4   empty    itself    yes\n+   --                 D2 in T4   empty    itself    yes\n+   --                 D3 in T4   empty    itself    yes\n \n    --  4. DISCRIMINANTS IN DERIVED TAGGED RECORD TYPES\n "}]}