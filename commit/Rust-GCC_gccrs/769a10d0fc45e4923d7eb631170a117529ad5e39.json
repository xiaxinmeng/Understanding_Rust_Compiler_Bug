{"sha": "769a10d0fc45e4923d7eb631170a117529ad5e39", "node_id": "C_kwDOANBUbNoAKDc2OWExMGQwZmM0NWU0OTIzZDdlYjYzMTE3MGExMTc1MjlhZDVlMzk", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-03-11T16:39:54Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2022-10-11T10:49:25Z"}, "message": "amdgcn: vec_init for multiple vector sizes\n\nImplements vec_init when the input is a vector of smaller vectors, or of\nvector MEM types, or a smaller vector duplicated several times.\n\ngcc/ChangeLog:\n\n\t* config/gcn/gcn-valu.md (vec_init<V_ALL:mode><V_ALL_ALT:mode>): New.\n\t* config/gcn/gcn.cc (GEN_VN): Add andvNsi3, subvNsi3.\n\t(GEN_VNM): Add gathervNm_expr.\n\t(GEN_VN_NOEXEC): Add vec_seriesvNsi.\n\t(gcn_expand_vector_init): Add initialization of vectors from smaller\n\tvectors.", "tree": {"sha": "2b6d788d18bef12800eb81d4777cc33f3f5e20ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b6d788d18bef12800eb81d4777cc33f3f5e20ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/769a10d0fc45e4923d7eb631170a117529ad5e39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/769a10d0fc45e4923d7eb631170a117529ad5e39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/769a10d0fc45e4923d7eb631170a117529ad5e39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/769a10d0fc45e4923d7eb631170a117529ad5e39/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cfe08555034b29f301dcfb99a3691c81b2e2def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cfe08555034b29f301dcfb99a3691c81b2e2def", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cfe08555034b29f301dcfb99a3691c81b2e2def"}], "stats": {"total": 169, "additions": 143, "deletions": 26}, "files": [{"sha": "f708e587f387775110062ff95a38d587b6f1cfd7", "filename": "gcc/config/gcn/gcn-valu.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/769a10d0fc45e4923d7eb631170a117529ad5e39/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/769a10d0fc45e4923d7eb631170a117529ad5e39/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md?ref=769a10d0fc45e4923d7eb631170a117529ad5e39", "patch": "@@ -893,6 +893,16 @@\n     DONE;\n   })\n \n+(define_expand \"vec_init<V_ALL:mode><V_ALL_ALT:mode>\"\n+  [(match_operand:V_ALL 0 \"register_operand\")\n+   (match_operand:V_ALL_ALT 1)]\n+  \"<V_ALL:SCALAR_MODE>mode == <V_ALL_ALT:SCALAR_MODE>mode\n+   && MODE_VF (<V_ALL_ALT:MODE>mode) < MODE_VF (<V_ALL:MODE>mode)\"\n+  {\n+    gcn_expand_vector_init (operands[0], operands[1]);\n+    DONE;\n+  })\n+\n ;; }}}\n ;; {{{ Scatter / Gather\n "}, {"sha": "3dc294c2d2f434abaac022ebcefcc9c5d8a30533", "filename": "gcc/config/gcn/gcn.cc", "status": "modified", "additions": 133, "deletions": 26, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/769a10d0fc45e4923d7eb631170a117529ad5e39/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/769a10d0fc45e4923d7eb631170a117529ad5e39/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.cc?ref=769a10d0fc45e4923d7eb631170a117529ad5e39", "patch": "@@ -1365,12 +1365,17 @@ GEN_VN (add,di3_vcc_zext_dup2, A(rtx dest, rtx src1, rtx src2, rtx vcc),\n \tA(dest, src1, src2, vcc))\n GEN_VN (addc,si3, A(rtx dest, rtx src1, rtx src2, rtx vccout, rtx vccin),\n \tA(dest, src1, src2, vccout, vccin))\n+GEN_VN (and,si3, A(rtx dest, rtx src1, rtx src2), A(dest, src1, src2))\n GEN_VN (ashl,si3, A(rtx dest, rtx src, rtx shift), A(dest, src, shift))\n GEN_VNM_NOEXEC (ds_bpermute,, A(rtx dest, rtx addr, rtx src, rtx exec),\n \t\tA(dest, addr, src, exec))\n+GEN_VNM (gather,_expr, A(rtx dest, rtx addr, rtx as, rtx vol),\n+\t A(dest, addr, as, vol))\n GEN_VNM (mov,, A(rtx dest, rtx src), A(dest, src))\n GEN_VN (mul,si3_dup, A(rtx dest, rtx src1, rtx src2), A(dest, src1, src2))\n+GEN_VN (sub,si3, A(rtx dest, rtx src1, rtx src2), A(dest, src1, src2))\n GEN_VNM (vec_duplicate,, A(rtx dest, rtx src), A(dest, src))\n+GEN_VN_NOEXEC (vec_series,si, A(rtx dest, rtx x, rtx c), A(dest, x, c))\n \n #undef GEN_VNM\n #undef GEN_VN\n@@ -1993,44 +1998,146 @@ regno_ok_for_index_p (int regno)\n void\n gcn_expand_vector_init (rtx op0, rtx vec)\n {\n-  int64_t initialized_mask = 0;\n-  int64_t curr_mask = 1;\n+  rtx val[64];\n   machine_mode mode = GET_MODE (op0);\n   int vf = GET_MODE_NUNITS (mode);\n+  machine_mode addrmode = VnMODE (vf, DImode);\n+  machine_mode offsetmode = VnMODE (vf, SImode);\n \n-  rtx val = XVECEXP (vec, 0, 0);\n+  int64_t mem_mask = 0;\n+  int64_t item_mask[64];\n+  rtx ramp = gen_reg_rtx (offsetmode);\n+  rtx addr = gen_reg_rtx (addrmode);\n \n-  for (int i = 1; i < vf; i++)\n-    if (rtx_equal_p (val, XVECEXP (vec, 0, i)))\n-      curr_mask |= (int64_t) 1 << i;\n+  int unit_size = GET_MODE_SIZE (GET_MODE_INNER (GET_MODE (op0)));\n+  emit_insn (gen_mulvNsi3_dup (ramp, gen_rtx_REG (offsetmode, VGPR_REGNO (1)),\n+\t\t\t       GEN_INT (unit_size)));\n \n-  if (gcn_constant_p (val))\n-    emit_move_insn (op0, gcn_vec_constant (mode, val));\n-  else\n+  bool simple_repeat = true;\n+\n+  /* Expand nested vectors into one vector.  */\n+  int item_count = XVECLEN (vec, 0);\n+  for (int i = 0, j = 0; i < item_count; i++)\n+    {\n+      rtx item = XVECEXP (vec, 0, i);\n+      machine_mode mode = GET_MODE (item);\n+      int units = VECTOR_MODE_P (mode) ? GET_MODE_NUNITS (mode) : 1;\n+      item_mask[j] = (((uint64_t)-1)>>(64-units)) << j;\n+\n+      if (simple_repeat && i != 0)\n+\tsimple_repeat = item == XVECEXP (vec, 0, i-1);\n+\n+      /* If its a vector of values then copy them into the final location.  */\n+      if (GET_CODE (item) == CONST_VECTOR)\n+\t{\n+\t  for (int k = 0; k < units; k++)\n+\t    val[j++] = XVECEXP (item, 0, k);\n+\t  continue;\n+\t}\n+      /* Otherwise, we have a scalar or an expression that expands...  */\n+\n+      if (MEM_P (item))\n+\t{\n+\t  rtx base = XEXP (item, 0);\n+\t  if (MEM_ADDR_SPACE (item) == DEFAULT_ADDR_SPACE\n+\t      && REG_P (base))\n+\t    {\n+\t      /* We have a simple vector load.  We can put the addresses in\n+\t\t the vector, combine it with any other such MEMs, and load it\n+\t\t all with a single gather at the end.  */\n+\t      int64_t mask = ((0xffffffffffffffffUL\n+\t\t\t       >> (64-GET_MODE_NUNITS (mode)))\n+\t\t\t      << j);\n+\t      rtx exec = get_exec (mask);\n+\t      emit_insn (gen_subvNsi3\n+\t\t\t (ramp, ramp,\n+\t\t\t  gcn_vec_constant (offsetmode, j*unit_size),\n+\t\t\t  ramp, exec));\n+\t      emit_insn (gen_addvNdi3_zext_dup2\n+\t\t\t (addr, ramp, base,\n+\t\t\t  (mem_mask ? addr : gcn_gen_undef (addrmode)),\n+\t\t\t  exec));\n+\t      mem_mask |= mask;\n+\t    }\n+\t  else\n+\t    /* The MEM is non-trivial, so let's load it independently.  */\n+\t    item = force_reg (mode, item);\n+\t}\n+      else if (!CONST_INT_P (item) && !CONST_DOUBLE_P (item))\n+\t/* The item may be a symbol_ref, or something else non-trivial.  */\n+\titem = force_reg (mode, item);\n+\n+      /* Duplicate the vector across each item.\n+\t It is either a smaller vector register that needs shifting,\n+\t or a MEM that needs loading.  */\n+      val[j] = item;\n+      j += units;\n+    }\n+\n+  int64_t initialized_mask = 0;\n+  rtx prev = NULL;\n+\n+  if (mem_mask)\n     {\n-      val = force_reg (GET_MODE_INNER (mode), val);\n-      emit_insn (gen_vec_duplicatevNm (op0, val));\n+      emit_insn (gen_gathervNm_expr\n+\t\t (op0, gen_rtx_PLUS (addrmode, addr,\n+\t\t\t\t     gen_rtx_VEC_DUPLICATE (addrmode,\n+\t\t\t\t\t\t\t    const0_rtx)),\n+\t\t  GEN_INT (DEFAULT_ADDR_SPACE), GEN_INT (0),\n+\t\t  NULL, get_exec (mem_mask)));\n+      prev = op0;\n+      initialized_mask = mem_mask;\n     }\n-  initialized_mask |= curr_mask;\n-  for (int i = 1; i < vf; i++)\n+\n+  if (simple_repeat && item_count > 1 && !prev)\n+    {\n+      /* Special case for instances of {A, B, A, B, A, B, ....}, etc.  */\n+      rtx src = gen_rtx_SUBREG (mode, val[0], 0);\n+      rtx input_vf_mask = GEN_INT (GET_MODE_NUNITS (GET_MODE (val[0]))-1);\n+\n+      rtx permutation = gen_reg_rtx (VnMODE (vf, SImode));\n+      emit_insn (gen_vec_seriesvNsi (permutation, GEN_INT (0), GEN_INT (1)));\n+      rtx mask_dup = gen_reg_rtx (VnMODE (vf, SImode));\n+      emit_insn (gen_vec_duplicatevNsi (mask_dup, input_vf_mask));\n+      emit_insn (gen_andvNsi3 (permutation, permutation, mask_dup));\n+      emit_insn (gen_ashlvNsi3 (permutation, permutation, GEN_INT (2)));\n+      emit_insn (gen_ds_bpermutevNm (op0, permutation, src, get_exec (mode)));\n+      return;\n+    }\n+\n+  /* Write each value, elementwise, but coalesce matching values into one\n+     instruction, where possible.  */\n+  for (int i = 0; i < vf; i++)\n     if (!(initialized_mask & ((int64_t) 1 << i)))\n       {\n-\tcurr_mask = (int64_t) 1 << i;\n-\trtx val = XVECEXP (vec, 0, i);\n-\n-\tfor (int j = i + 1; j < vf; j++)\n-\t  if (rtx_equal_p (val, XVECEXP (vec, 0, j)))\n-\t    curr_mask |= (int64_t) 1 << j;\n-\tif (gcn_constant_p (val))\n-\t  emit_insn (gen_movvNm (op0, gcn_vec_constant (mode, val), op0,\n-\t\t\t\t get_exec (curr_mask)));\n+\tif (gcn_constant_p (val[i]))\n+\t  emit_insn (gen_movvNm (op0, gcn_vec_constant (mode, val[i]), prev,\n+\t\t\t\t get_exec (item_mask[i])));\n+\telse if (VECTOR_MODE_P (GET_MODE (val[i]))\n+\t\t && (GET_MODE_NUNITS (GET_MODE (val[i])) == vf\n+\t\t     || i == 0))\n+\t  emit_insn (gen_movvNm (op0, gen_rtx_SUBREG (mode, val[i], 0), prev,\n+\t\t\t\t get_exec (item_mask[i])));\n+\telse if (VECTOR_MODE_P (GET_MODE (val[i])))\n+\t  {\n+\t    rtx permutation = gen_reg_rtx (VnMODE (vf, SImode));\n+\t    emit_insn (gen_vec_seriesvNsi (permutation, GEN_INT (-i*4),\n+\t\t\t\t\t   GEN_INT (4)));\n+\t    rtx tmp = gen_reg_rtx (mode);\n+\t    emit_insn (gen_ds_bpermutevNm (tmp, permutation,\n+\t\t\t\t\t   gen_rtx_SUBREG (mode, val[i], 0),\n+\t\t\t\t\t   get_exec (-1)));\n+\t    emit_insn (gen_movvNm (op0, tmp, prev, get_exec (item_mask[i])));\n+\t  }\n \telse\n \t  {\n-\t    val = force_reg (GET_MODE_INNER (mode), val);\n-\t    emit_insn (gen_vec_duplicatevNm (op0, val, op0,\n-\t\t\t\t\t     get_exec (curr_mask)));\n+\t    rtx reg = force_reg (GET_MODE_INNER (mode), val[i]);\n+\t    emit_insn (gen_vec_duplicatevNm (op0, reg, prev,\n+\t\t\t\t\t     get_exec (item_mask[i])));\n \t  }\n-\tinitialized_mask |= curr_mask;\n+\n+\tinitialized_mask |= item_mask[i];\n+\tprev = op0;\n       }\n }\n "}]}