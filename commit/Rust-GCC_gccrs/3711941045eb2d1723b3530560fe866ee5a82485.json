{"sha": "3711941045eb2d1723b3530560fe866ee5a82485", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcxMTk0MTA0NWViMmQxNzIzYjM1MzA1NjBmZTg2NmVlNWE4MjQ4NQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-08-02T10:06:47Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-08-02T10:06:47Z"}, "message": "re PR target/40457 (use stm and ldm to access consecutive memory words)\n\n\tPR target/40457\n\t* config/arm/arm.h (arm_regs_in_sequence): Declare.\n\t* config/arm/arm-protos.h (emit_ldm_seq, emit_stm_seq,\n\tload_multiple_sequence, store_multiple_sequence): Delete\n\tdeclarations.\n\t(arm_gen_load_multiple, arm_gen_store_multiple): Adjust\n\tdeclarations.\n\t* config/arm/ldmstm.md: New file.\n\t* config/arm/arm.c (arm_regs_in_sequence): New array.\n\t(load_multiple_sequence): Now static.  New args SAVED_ORDER,\n\tCHECK_REGS.  All callers changed.\n\tIf SAVED_ORDER is nonnull, copy the computed order into it.\n\tIf CHECK_REGS is false, don't sort REGS.  Handle Thumb mode.\n\t(store_multiple_sequence): Now static.  New args NOPS_TOTAL,\n\tSAVED_ORDER, REG_RTXS and CHECK_REGS.  All callers changed.\n\tIf SAVED_ORDER is nonnull, copy the computed order into it.\n\tIf CHECK_REGS is false, don't sort REGS.  Set up REG_RTXS just\n\tlike REGS.  Handle Thumb mode.\n\t(arm_gen_load_multiple_1): New function, broken out of\n\tarm_gen_load_multiple.\n\t(arm_gen_store_multiple_1): New function, broken out of\n\tarm_gen_store_multiple.\n\t(arm_gen_multiple_op): New function, with code from\n\tarm_gen_load_multiple and arm_gen_store_multiple moved here.\n\t(arm_gen_load_multiple, arm_gen_store_multiple): Now just\n\twrappers around arm_gen_multiple_op.  Remove argument UP, all callers\n\tchanged.\n\t(gen_ldm_seq, gen_stm_seq, gen_const_stm_seq): New functions.\n\t* config/arm/predicates.md (commutative_binary_operator): New.\n\t(load_multiple_operation, store_multiple_operation): Handle more\n\tvariants of these patterns with different starting offsets.  Handle\n\tThumb-1.\n\t* config/arm/arm.md: Include \"ldmstm.md\".\n\t(ldmsi_postinc4, ldmsi_postinc4_thumb1, ldmsi_postinc3, ldmsi_postinc2,\n\tldmsi4, ldmsi3, ldmsi2, stmsi_postinc4, stmsi_postinc4_thumb1,\n\tstmsi_postinc3, stmsi_postinc2, stmsi4, stmsi3, stmsi2 and related\n\tpeepholes): Delete.\n\t* config/arm/ldmstm.md: New file.\n\t* config/arm/arm-ldmstm.ml: New file.\n\ntestsuite/\n\tPR target/40457\n\t* gcc.target/arm/pr40457-1.c: New test.\n\t* gcc.target/arm/pr40457-2.c: New test.\n\nFrom-SVN: r162815", "tree": {"sha": "9950f9dbf01dcd739509a644ed4b34132dc79cee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9950f9dbf01dcd739509a644ed4b34132dc79cee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3711941045eb2d1723b3530560fe866ee5a82485", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3711941045eb2d1723b3530560fe866ee5a82485", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3711941045eb2d1723b3530560fe866ee5a82485", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3711941045eb2d1723b3530560fe866ee5a82485/comments", "author": null, "committer": null, "parents": [{"sha": "0bd44ba2e1130ed35a194ee32e033af7efe14495", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd44ba2e1130ed35a194ee32e033af7efe14495", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bd44ba2e1130ed35a194ee32e033af7efe14495"}], "stats": {"total": 2643, "additions": 2111, "deletions": 532}, "files": [{"sha": "f0c2969830c2ed3a1ef3df76f0ebe49f9c4178c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3711941045eb2d1723b3530560fe866ee5a82485", "patch": "@@ -45,6 +45,46 @@\n \t(movdi, arm_movsf_soft_insn, arm_movdf_soft_insn): Define them\n \tand allow for TARGET_32BIT.\n \n+\tPR target/40457\n+\t* config/arm/arm.h (arm_regs_in_sequence): Declare.\n+\t* config/arm/arm-protos.h (emit_ldm_seq, emit_stm_seq,\n+\tload_multiple_sequence, store_multiple_sequence): Delete\n+\tdeclarations.\n+\t(arm_gen_load_multiple, arm_gen_store_multiple): Adjust\n+\tdeclarations.\n+\t* config/arm/ldmstm.md: New file.\n+\t* config/arm/arm.c (arm_regs_in_sequence): New array.\n+\t(load_multiple_sequence): Now static.  New args SAVED_ORDER,\n+\tCHECK_REGS.  All callers changed.\n+\tIf SAVED_ORDER is nonnull, copy the computed order into it.\n+\tIf CHECK_REGS is false, don't sort REGS.  Handle Thumb mode.\n+\t(store_multiple_sequence): Now static.  New args NOPS_TOTAL,\n+\tSAVED_ORDER, REG_RTXS and CHECK_REGS.  All callers changed.\n+\tIf SAVED_ORDER is nonnull, copy the computed order into it.\n+\tIf CHECK_REGS is false, don't sort REGS.  Set up REG_RTXS just\n+\tlike REGS.  Handle Thumb mode.\n+\t(arm_gen_load_multiple_1): New function, broken out of\n+\tarm_gen_load_multiple.\n+\t(arm_gen_store_multiple_1): New function, broken out of\n+\tarm_gen_store_multiple.\n+\t(arm_gen_multiple_op): New function, with code from\n+\tarm_gen_load_multiple and arm_gen_store_multiple moved here.\n+\t(arm_gen_load_multiple, arm_gen_store_multiple): Now just\n+\twrappers around arm_gen_multiple_op.  Remove argument UP, all callers\n+\tchanged.\n+\t(gen_ldm_seq, gen_stm_seq, gen_const_stm_seq): New functions.\n+\t* config/arm/predicates.md (commutative_binary_operator): New.\n+\t(load_multiple_operation, store_multiple_operation): Handle more\n+\tvariants of these patterns with different starting offsets.  Handle\n+\tThumb-1.\n+\t* config/arm/arm.md: Include \"ldmstm.md\".\n+\t(ldmsi_postinc4, ldmsi_postinc4_thumb1, ldmsi_postinc3, ldmsi_postinc2,\n+\tldmsi4, ldmsi3, ldmsi2, stmsi_postinc4, stmsi_postinc4_thumb1,\n+\tstmsi_postinc3, stmsi_postinc2, stmsi4, stmsi3, stmsi2 and related\n+\tpeepholes): Delete.\n+\t* config/arm/ldmstm.md: New file.\n+\t* config/arm/arm-ldmstm.ml: New file.\n+\n 2010-08-02  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* config/arm/arm.c (COSTS_N_INSNS): Remove definition."}, {"sha": "b841a1d836d2a9355ef5f1a28fabf97071081b48", "filename": "gcc/config/arm/arm-ldmstm.ml", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Farm-ldmstm.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Farm-ldmstm.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-ldmstm.ml?ref=3711941045eb2d1723b3530560fe866ee5a82485", "patch": "@@ -0,0 +1,332 @@\n+(* Auto-generate ARM ldm/stm patterns\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.\n+\n+   This is an O'Caml program.  The O'Caml compiler is available from:\n+\n+     http://caml.inria.fr/\n+\n+   Or from your favourite OS's friendly packaging system. Tested with version\n+   3.09.2, though other versions will probably work too.\n+\n+   Run with:\n+     ocaml arm-ldmstm.ml >/path/to/gcc/config/arm/ldmstm.ml\n+*)\n+\n+type amode = IA | IB | DA | DB\n+\n+type optype = IN | OUT | INOUT\n+\n+let rec string_of_addrmode addrmode =\n+  match addrmode with\n+    IA -> \"ia\" | IB -> \"ib\" | DA -> \"da\" | DB -> \"db\"\n+\n+let rec initial_offset addrmode nregs =\n+  match addrmode with\n+    IA -> 0\n+  | IB -> 4\n+  | DA -> -4 * nregs + 4\n+  | DB -> -4 * nregs\n+\n+let rec final_offset addrmode nregs =\n+  match addrmode with\n+    IA -> nregs * 4\n+  | IB -> nregs * 4\n+  | DA -> -4 * nregs\n+  | DB -> -4 * nregs\n+\n+let constr thumb =\n+  if thumb then \"l\" else \"rk\"\n+\n+let inout_constr op_type =\n+  match op_type with\n+  OUT -> \"=&\"\n+  | INOUT -> \"+&\"\n+  | IN -> \"\"\n+\n+let destreg nregs first op_type thumb =\n+  if not first then\n+    Printf.sprintf \"(match_dup %d)\" (nregs + 1)\n+  else\n+    Printf.sprintf (\"(match_operand:SI %d \\\"s_register_operand\\\" \\\"%s%s\\\")\")\n+      (nregs + 1) (inout_constr op_type) (constr thumb)\n+\n+let write_ldm_set thumb nregs offset opnr first =\n+  let indent = \"     \" in\n+  Printf.printf \"%s\" (if first then \"    [\" else indent);\n+  Printf.printf \"(set (match_operand:SI %d \\\"arm_hard_register_operand\\\" \\\"\\\")\\n\" opnr;\n+  Printf.printf \"%s     (mem:SI \" indent;\n+  begin if offset != 0 then Printf.printf \"(plus:SI \" end;\n+  Printf.printf \"%s\" (destreg nregs first IN thumb);\n+  begin if offset != 0 then Printf.printf \"\\n%s             (const_int %d))\" indent offset end;\n+  Printf.printf \"))\"\n+\n+let write_stm_set thumb nregs offset opnr first =\n+  let indent = \"     \" in\n+  Printf.printf \"%s\" (if first then \"    [\" else indent);\n+  Printf.printf \"(set (mem:SI \";\n+  begin if offset != 0 then Printf.printf \"(plus:SI \" end;\n+  Printf.printf \"%s\" (destreg nregs first IN thumb);\n+  begin if offset != 0 then Printf.printf \" (const_int %d))\" offset end;\n+  Printf.printf \")\\n%s     (match_operand:SI %d \\\"arm_hard_register_operand\\\" \\\"\\\"))\" indent opnr \n+\n+let write_ldm_peep_set extra_indent nregs opnr first =\n+  let indent = \"   \" ^ extra_indent in\n+  Printf.printf \"%s\" (if first then extra_indent ^ \"  [\" else indent);\n+  Printf.printf \"(set (match_operand:SI %d \\\"s_register_operand\\\" \\\"\\\")\\n\" opnr;\n+  Printf.printf \"%s     (match_operand:SI %d \\\"memory_operand\\\" \\\"\\\"))\" indent (nregs + opnr)\n+\n+let write_stm_peep_set extra_indent nregs opnr first =\n+  let indent = \"   \" ^ extra_indent in\n+  Printf.printf \"%s\" (if first then extra_indent ^ \"  [\" else indent);\n+  Printf.printf \"(set (match_operand:SI %d \\\"memory_operand\\\" \\\"\\\")\\n\" (nregs + opnr);\n+  Printf.printf \"%s     (match_operand:SI %d \\\"s_register_operand\\\" \\\"\\\"))\" indent opnr\n+\n+let write_any_load optype nregs opnr first =\n+  let indent = \"   \" in\n+  Printf.printf \"%s\" (if first then \"  [\" else indent);\n+  Printf.printf \"(set (match_operand:SI %d \\\"s_register_operand\\\" \\\"\\\")\\n\" opnr;\n+  Printf.printf \"%s     (match_operand:SI %d \\\"%s\\\" \\\"\\\"))\" indent (nregs * 2 + opnr) optype\n+\n+let write_const_store nregs opnr first =\n+  let indent = \"   \" in\n+  Printf.printf \"%s(set (match_operand:SI %d \\\"memory_operand\\\" \\\"\\\")\\n\" indent (nregs + opnr);\n+  Printf.printf \"%s     (match_dup %d))\" indent opnr\n+\n+let write_const_stm_peep_set nregs opnr first =\n+  write_any_load \"const_int_operand\" nregs opnr first;\n+  Printf.printf \"\\n\";\n+  write_const_store nregs opnr false\n+\n+  \n+let rec write_pat_sets func opnr offset first n_left =\n+  func offset opnr first;\n+  begin\n+    if n_left > 1 then begin\n+      Printf.printf \"\\n\";\n+      write_pat_sets func (opnr + 1) (offset + 4) false (n_left - 1);\n+    end else\n+      Printf.printf \"]\"\n+  end\n+\n+let rec write_peep_sets func opnr first n_left =\n+  func opnr first;\n+  begin\n+    if n_left > 1 then begin\n+      Printf.printf \"\\n\";\n+      write_peep_sets func (opnr + 1) false (n_left - 1);\n+    end\n+  end\n+    \n+let can_thumb addrmode update is_store =\n+  match addrmode, update, is_store with\n+    (* Thumb1 mode only supports IA with update.  However, for LDMIA,\n+       if the address register also appears in the list of loaded\n+       registers, the loaded value is stored, hence the RTL pattern\n+       to describe such an insn does not have an update.  We check\n+       in the match_parallel predicate that the condition described\n+       above is met.  *)\n+    IA, _, false -> true\n+  | IA, true, true -> true\n+  | _ -> false\n+\n+let target addrmode thumb =\n+  match addrmode, thumb with\n+    IA, true -> \"TARGET_THUMB1\"\n+  | IA, false -> \"TARGET_32BIT\"\n+  | DB, false -> \"TARGET_32BIT\"\n+  | _, false -> \"TARGET_ARM\"\n+\n+let write_pattern_1 name ls addrmode nregs write_set_fn update thumb =\n+  let astr = string_of_addrmode addrmode in\n+  Printf.printf \"(define_insn \\\"*%s%s%d_%s%s\\\"\\n\"\n+    (if thumb then \"thumb_\" else \"\") name nregs astr\n+    (if update then \"_update\" else \"\");\n+  Printf.printf \"  [(match_parallel 0 \\\"%s_multiple_operation\\\"\\n\" ls;\n+  begin\n+    if update then begin\n+      Printf.printf \"    [(set %s\\n          (plus:SI %s\"\n+\t(destreg nregs true INOUT thumb) (destreg nregs false IN thumb);\n+      Printf.printf \" (const_int %d)))\\n\"\n+\t(final_offset addrmode nregs)\n+    end\n+  end;\n+  write_pat_sets\n+    (write_set_fn thumb nregs) 1\n+    (initial_offset addrmode nregs)\n+    (not update) nregs;\n+  Printf.printf \")]\\n  \\\"%s && XVECLEN (operands[0], 0) == %d\\\"\\n\"\n+    (target addrmode thumb)\n+    (if update then nregs + 1 else nregs);\n+  Printf.printf \"  \\\"%s%%(%s%%)\\\\t%%%d%s, {\"\n+    name astr (nregs + 1) (if update then \"!\" else \"\");\n+  for n = 1 to nregs; do\n+    Printf.printf \"%%%d%s\" n (if n < nregs then \", \" else \"\")\n+  done;\n+  Printf.printf \"}\\\"\\n\";\n+  Printf.printf \"  [(set_attr \\\"type\\\" \\\"%s%d\\\")\" ls nregs;\n+  begin if not thumb then\n+    Printf.printf \"\\n   (set_attr \\\"predicable\\\" \\\"yes\\\")\";\n+  end;\n+  Printf.printf \"])\\n\\n\"\n+\n+let write_ldm_pattern addrmode nregs update =\n+  write_pattern_1 \"ldm\" \"load\" addrmode nregs write_ldm_set update false;\n+  begin if can_thumb addrmode update false then\n+    write_pattern_1 \"ldm\" \"load\" addrmode nregs write_ldm_set update true;\n+  end\n+\n+let write_stm_pattern addrmode nregs update =\n+  write_pattern_1 \"stm\" \"store\" addrmode nregs write_stm_set update false;\n+  begin if can_thumb addrmode update true then\n+    write_pattern_1 \"stm\" \"store\" addrmode nregs write_stm_set update true;\n+  end\n+\n+let write_ldm_commutative_peephole thumb =\n+  let nregs = 2 in\n+  Printf.printf \"(define_peephole2\\n\";\n+  write_peep_sets (write_ldm_peep_set \"\" nregs) 0 true nregs;\n+  let indent = \"   \" in\n+  if thumb then begin\n+    Printf.printf \"\\n%s(set (match_operand:SI %d \\\"s_register_operand\\\" \\\"\\\")\\n\" indent (nregs * 2);\n+    Printf.printf \"%s     (match_operator:SI %d \\\"commutative_binary_operator\\\"\\n\" indent (nregs * 2 + 1);\n+    Printf.printf \"%s      [(match_operand:SI %d \\\"s_register_operand\\\" \\\"\\\")\\n\" indent (nregs * 2 + 2);\n+    Printf.printf \"%s       (match_operand:SI %d \\\"s_register_operand\\\" \\\"\\\")]))]\\n\" indent (nregs * 2 + 3)\n+  end else begin\n+    Printf.printf \"\\n%s(parallel\\n\" indent;\n+    Printf.printf \"%s  [(set (match_operand:SI %d \\\"s_register_operand\\\" \\\"\\\")\\n\" indent (nregs * 2);\n+    Printf.printf \"%s        (match_operator:SI %d \\\"commutative_binary_operator\\\"\\n\" indent (nregs * 2 + 1);\n+    Printf.printf \"%s         [(match_operand:SI %d \\\"s_register_operand\\\" \\\"\\\")\\n\" indent (nregs * 2 + 2);\n+    Printf.printf \"%s          (match_operand:SI %d \\\"s_register_operand\\\" \\\"\\\")]))\\n\" indent (nregs * 2 + 3);\n+    Printf.printf \"%s   (clobber (reg:CC CC_REGNUM))])]\\n\" indent\n+  end;\n+  Printf.printf \"  \\\"(((operands[%d] == operands[0] && operands[%d] == operands[1])\\n\" (nregs * 2 + 2) (nregs * 2 + 3);\n+  Printf.printf \"     || (operands[%d] == operands[0] && operands[%d] == operands[1]))\\n\" (nregs * 2 + 3) (nregs * 2 + 2);\n+  Printf.printf \"    && peep2_reg_dead_p (%d, operands[0]) && peep2_reg_dead_p (%d, operands[1]))\\\"\\n\" (nregs + 1) (nregs + 1);\n+  begin\n+    if thumb then\n+      Printf.printf \"  [(set (match_dup %d) (match_op_dup %d [(match_dup %d) (match_dup %d)]))]\\n\"\n+\t(nregs * 2) (nregs * 2 + 1) (nregs * 2 + 2) (nregs * 2 + 3)\n+    else begin\n+      Printf.printf \"  [(parallel\\n\";\n+      Printf.printf \"    [(set (match_dup %d) (match_op_dup %d [(match_dup %d) (match_dup %d)]))\\n\"\n+\t(nregs * 2) (nregs * 2 + 1) (nregs * 2 + 2) (nregs * 2 + 3);\n+      Printf.printf \"     (clobber (reg:CC CC_REGNUM))])]\\n\"\n+    end\n+  end;\n+  Printf.printf \"{\\n  if (!gen_ldm_seq (operands, %d, true))\\n    FAIL;\\n\" nregs;\n+  Printf.printf \"})\\n\\n\"\n+\n+let write_ldm_peephole nregs =\n+  Printf.printf \"(define_peephole2\\n\";\n+  write_peep_sets (write_ldm_peep_set \"\" nregs) 0 true nregs;\n+  Printf.printf \"]\\n  \\\"\\\"\\n  [(const_int 0)]\\n{\\n\";\n+  Printf.printf \"  if (gen_ldm_seq (operands, %d, false))\\n    DONE;\\n  else\\n    FAIL;\\n})\\n\\n\" nregs\n+\n+let write_ldm_peephole_b nregs =\n+  if nregs > 2 then begin\n+    Printf.printf \"(define_peephole2\\n\";\n+    write_ldm_peep_set \"\" nregs 0 true;\n+    Printf.printf \"\\n   (parallel\\n\";\n+    write_peep_sets (write_ldm_peep_set \"  \" nregs) 1 true (nregs - 1);\n+    Printf.printf \"])]\\n  \\\"\\\"\\n  [(const_int 0)]\\n{\\n\";\n+    Printf.printf \"  if (gen_ldm_seq (operands, %d, false))\\n    DONE;\\n  else\\n    FAIL;\\n})\\n\\n\" nregs\n+  end\n+\n+let write_stm_peephole nregs =\n+  Printf.printf \"(define_peephole2\\n\";\n+  write_peep_sets (write_stm_peep_set \"\" nregs) 0 true nregs;\n+  Printf.printf \"]\\n  \\\"\\\"\\n  [(const_int 0)]\\n{\\n\";\n+  Printf.printf \"  if (gen_stm_seq (operands, %d))\\n    DONE;\\n  else\\n    FAIL;\\n})\\n\\n\" nregs\n+\n+let write_stm_peephole_b nregs =\n+  if nregs > 2 then begin\n+    Printf.printf \"(define_peephole2\\n\";\n+    write_stm_peep_set \"\" nregs 0 true;\n+    Printf.printf \"\\n   (parallel\\n\";\n+    write_peep_sets (write_stm_peep_set \"\" nregs) 1 true (nregs - 1);\n+    Printf.printf \"]\\n  \\\"\\\"\\n  [(const_int 0)]\\n{\\n\";\n+    Printf.printf \"  if (gen_stm_seq (operands, %d))\\n    DONE;\\n  else\\n    FAIL;\\n})\\n\\n\" nregs\n+  end\n+\n+let write_const_stm_peephole_a nregs =\n+  Printf.printf \"(define_peephole2\\n\";\n+  write_peep_sets (write_const_stm_peep_set nregs) 0 true nregs;\n+  Printf.printf \"]\\n  \\\"\\\"\\n  [(const_int 0)]\\n{\\n\";\n+  Printf.printf \"  if (gen_const_stm_seq (operands, %d))\\n    DONE;\\n  else\\n    FAIL;\\n})\\n\\n\" nregs\n+\n+let write_const_stm_peephole_b nregs =\n+  Printf.printf \"(define_peephole2\\n\";\n+  write_peep_sets (write_any_load \"const_int_operand\" nregs) 0 true nregs;\n+  Printf.printf \"\\n\";\n+  write_peep_sets (write_const_store nregs) 0 false nregs;\n+  Printf.printf \"]\\n  \\\"\\\"\\n  [(const_int 0)]\\n{\\n\";\n+  Printf.printf \"  if (gen_const_stm_seq (operands, %d))\\n    DONE;\\n  else\\n    FAIL;\\n})\\n\\n\" nregs\n+\n+let patterns () =\n+  let addrmodes = [ IA; IB; DA; DB ]  in\n+  let sizes = [ 4; 3; 2] in\n+  List.iter\n+    (fun n ->\n+      List.iter\n+\t(fun addrmode ->\n+\t  write_ldm_pattern addrmode n false;\n+\t  write_ldm_pattern addrmode n true;\n+\t  write_stm_pattern addrmode n false;\n+\t  write_stm_pattern addrmode n true)\n+\taddrmodes;\n+      write_ldm_peephole n;\n+      write_ldm_peephole_b n;\n+      write_const_stm_peephole_a n;\n+      write_const_stm_peephole_b n;\n+      write_stm_peephole n;)\n+    sizes;\n+  write_ldm_commutative_peephole false;\n+  write_ldm_commutative_peephole true\n+\n+let print_lines = List.iter (fun s -> Format.printf \"%s@\\n\" s)\n+\n+(* Do it.  *)\n+\n+let _ = \n+  print_lines [\n+\"/* ARM ldm/stm instruction patterns.  This file was automatically generated\";\n+\"   using arm-ldmstm.ml.  Please do not edit manually.\";\n+\"\";\n+\"   Copyright (C) 2010 Free Software Foundation, Inc.\";\n+\"   Contributed by CodeSourcery.\";\n+\"\";\n+\"   This file is part of GCC.\";\n+\"\";\n+\"   GCC is free software; you can redistribute it and/or modify it\";\n+\"   under the terms of the GNU General Public License as published\";\n+\"   by the Free Software Foundation; either version 3, or (at your\";\n+\"   option) any later version.\";\n+\"\";\n+\"   GCC is distributed in the hope that it will be useful, but WITHOUT\";\n+\"   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\";\n+\"   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\";\n+\"   License for more details.\";\n+\"\";\n+\"   You should have received a copy of the GNU General Public License and\";\n+\"   a copy of the GCC Runtime Library Exception along with this program;\";\n+\"   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\";\n+\"   <http://www.gnu.org/licenses/>.  */\";\n+\"\"];\n+  patterns ();"}, {"sha": "e5a6b4544cda9047ff4d558acad991250ec9d2f1", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=3711941045eb2d1723b3530560fe866ee5a82485", "patch": "@@ -98,14 +98,11 @@ extern int symbol_mentioned_p (rtx);\n extern int label_mentioned_p (rtx);\n extern RTX_CODE minmax_code (rtx);\n extern int adjacent_mem_locations (rtx, rtx);\n-extern int load_multiple_sequence (rtx *, int, int *, int *, HOST_WIDE_INT *);\n-extern const char *emit_ldm_seq (rtx *, int);\n-extern int store_multiple_sequence (rtx *, int, int *, int *, HOST_WIDE_INT *);\n-extern const char * emit_stm_seq (rtx *, int);\n-extern rtx arm_gen_load_multiple (int, int, rtx, int, int,\n-\t\t\t\t  rtx, HOST_WIDE_INT *);\n-extern rtx arm_gen_store_multiple (int, int, rtx, int, int,\n-\t\t\t\t   rtx, HOST_WIDE_INT *);\n+extern bool gen_ldm_seq (rtx *, int, bool);\n+extern bool gen_stm_seq (rtx *, int);\n+extern bool gen_const_stm_seq (rtx *, int);\n+extern rtx arm_gen_load_multiple (int *, int, rtx, int, rtx, HOST_WIDE_INT *);\n+extern rtx arm_gen_store_multiple (int *, int, rtx, int, rtx, HOST_WIDE_INT *);\n extern int arm_gen_movmemqi (rtx *);\n extern enum machine_mode arm_select_cc_mode (RTX_CODE, rtx, rtx);\n extern enum machine_mode arm_select_dominance_cc_mode (rtx, rtx,"}, {"sha": "9073702b37947cb8318ec639fec253f300b729f1", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 442, "deletions": 190, "changes": 632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=3711941045eb2d1723b3530560fe866ee5a82485", "patch": "@@ -739,6 +739,12 @@ static const char * const arm_condition_codes[] =\n   \"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\"\n };\n \n+/* The register numbers in sequence, for passing to arm_gen_load_multiple.  */\n+int arm_regs_in_sequence[] =\n+{\n+  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n+};\n+\n #define ARM_LSL_NAME (TARGET_UNIFIED_ASM ? \"lsl\" : \"asl\")\n #define streq(string1, string2) (strcmp (string1, string2) == 0)\n \n@@ -9225,13 +9231,29 @@ compute_offset_order (int nops, HOST_WIDE_INT *unsorted_offsets, int *order,\n   return true;\n }\n \n-int\n-load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n-\t\t\tHOST_WIDE_INT *load_offset)\n+/* Used to determine in a peephole whether a sequence of load\n+   instructions can be changed into a load-multiple instruction.\n+   NOPS is the number of separate load instructions we are examining.  The\n+   first NOPS entries in OPERANDS are the destination registers, the\n+   next NOPS entries are memory operands.  If this function is\n+   successful, *BASE is set to the common base register of the memory\n+   accesses; *LOAD_OFFSET is set to the first memory location's offset\n+   from that base register.\n+   REGS is an array filled in with the destination register numbers.\n+   SAVED_ORDER (if nonnull), is an array filled in with an order that maps\n+   insn numbers to to an ascending order of stores.  If CHECK_REGS is true,\n+   the sequence of registers in REGS matches the loads from ascending memory\n+   locations, and the function verifies that the register numbers are\n+   themselves ascending.  If CHECK_REGS is false, the register numbers\n+   are stored in the order they are found in the operands.  */\n+static int\n+load_multiple_sequence (rtx *operands, int nops, int *regs, int *saved_order,\n+\t\t\tint *base, HOST_WIDE_INT *load_offset, bool check_regs)\n {\n   int unsorted_regs[MAX_LDM_STM_OPS];\n   HOST_WIDE_INT unsorted_offsets[MAX_LDM_STM_OPS];\n   int order[MAX_LDM_STM_OPS];\n+  rtx base_reg_rtx = NULL;\n   int base_reg = -1;\n   int i, ldm_case;\n \n@@ -9275,21 +9297,26 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \t\t  == CONST_INT)))\n \t{\n \t  if (i == 0)\n-\t    base_reg = REGNO (reg);\n-\t  else\n \t    {\n-\t      if (base_reg != (int) REGNO (reg))\n-\t\t/* Not addressed from the same base register.  */\n+\t      base_reg = REGNO (reg);\n+\t      base_reg_rtx = reg;\n+\t      if (TARGET_THUMB1 && base_reg > LAST_LO_REGNUM)\n \t\treturn 0;\n \t    }\n+\t  else if (base_reg != (int) REGNO (reg))\n+\t    /* Not addressed from the same base register.  */\n+\t    return 0;\n+\n \t  unsorted_regs[i] = (GET_CODE (operands[i]) == REG\n \t\t\t      ? REGNO (operands[i])\n \t\t\t      : REGNO (SUBREG_REG (operands[i])));\n \n \t  /* If it isn't an integer register, or if it overwrites the\n \t     base register but isn't the last insn in the list, then\n \t     we can't do this.  */\n-\t  if (unsorted_regs[i] < 0 || unsorted_regs[i] > 14\n+\t  if (unsorted_regs[i] < 0\n+\t      || (TARGET_THUMB1 && unsorted_regs[i] > LAST_LO_REGNUM)\n+\t      || unsorted_regs[i] > 14\n \t      || (i != nops - 1 && unsorted_regs[i] == base_reg))\n \t    return 0;\n \n@@ -9307,26 +9334,34 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n      order[0] has been set to the lowest offset in the list.  Sort\n      the offsets into order, verifying that they are adjacent, and\n      check that the register numbers are ascending.  */\n-  if (!compute_offset_order (nops, unsorted_offsets, order, unsorted_regs))\n+  if (!compute_offset_order (nops, unsorted_offsets, order,\n+\t\t\t     check_regs ? unsorted_regs : NULL))\n     return 0;\n \n+  if (saved_order)\n+    memcpy (saved_order, order, sizeof order);\n+\n   if (base)\n     {\n       *base = base_reg;\n \n       for (i = 0; i < nops; i++)\n-\tregs[i] = unsorted_regs[order[i]];\n+\tregs[i] = unsorted_regs[check_regs ? order[i] : i];\n \n       *load_offset = unsorted_offsets[order[0]];\n     }\n \n+  if (TARGET_THUMB1\n+      && !peep2_reg_dead_p (nops, base_reg_rtx))\n+    return 0;\n+\n   if (unsorted_offsets[order[0]] == 0)\n     ldm_case = 1; /* ldmia */\n   else if (TARGET_ARM && unsorted_offsets[order[0]] == 4)\n     ldm_case = 2; /* ldmib */\n   else if (TARGET_ARM && unsorted_offsets[order[nops - 1]] == 0)\n     ldm_case = 3; /* ldmda */\n-  else if (unsorted_offsets[order[nops - 1]] == -4)\n+  else if (TARGET_32BIT && unsorted_offsets[order[nops - 1]] == -4)\n     ldm_case = 4; /* ldmdb */\n   else if (const_ok_for_arm (unsorted_offsets[order[0]])\n \t   || const_ok_for_arm (-unsorted_offsets[order[0]]))\n@@ -9342,72 +9377,34 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n   return ldm_case;\n }\n \n-const char *\n-emit_ldm_seq (rtx *operands, int nops)\n-{\n-  int regs[MAX_LDM_STM_OPS];\n-  int base_reg;\n-  HOST_WIDE_INT offset;\n-  char buf[100];\n-  int i;\n-\n-  switch (load_multiple_sequence (operands, nops, regs, &base_reg, &offset))\n-    {\n-    case 1:\n-      strcpy (buf, \"ldm%(ia%)\\t\");\n-      break;\n-\n-    case 2:\n-      strcpy (buf, \"ldm%(ib%)\\t\");\n-      break;\n-\n-    case 3:\n-      strcpy (buf, \"ldm%(da%)\\t\");\n-      break;\n-\n-    case 4:\n-      strcpy (buf, \"ldm%(db%)\\t\");\n-      break;\n-\n-    case 5:\n-      if (offset >= 0)\n-\tsprintf (buf, \"add%%?\\t%s%s, %s%s, #%ld\", REGISTER_PREFIX,\n-\t\t reg_names[regs[0]], REGISTER_PREFIX, reg_names[base_reg],\n-\t\t (long) offset);\n-      else\n-\tsprintf (buf, \"sub%%?\\t%s%s, %s%s, #%ld\", REGISTER_PREFIX,\n-\t\t reg_names[regs[0]], REGISTER_PREFIX, reg_names[base_reg],\n-\t\t (long) -offset);\n-      output_asm_insn (buf, operands);\n-      base_reg = regs[0];\n-      strcpy (buf, \"ldm%(ia%)\\t\");\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  sprintf (buf + strlen (buf), \"%s%s, {%s%s\", REGISTER_PREFIX,\n-\t   reg_names[base_reg], REGISTER_PREFIX, reg_names[regs[0]]);\n-\n-  for (i = 1; i < nops; i++)\n-    sprintf (buf + strlen (buf), \", %s%s\", REGISTER_PREFIX,\n-\t     reg_names[regs[i]]);\n-\n-  strcat (buf, \"}\\t%@ phole ldm\");\n-\n-  output_asm_insn (buf, operands);\n-  return \"\";\n-}\n-\n-int\n-store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n-\t\t\t HOST_WIDE_INT * load_offset)\n+/* Used to determine in a peephole whether a sequence of store instructions can\n+   be changed into a store-multiple instruction.\n+   NOPS is the number of separate store instructions we are examining.\n+   NOPS_TOTAL is the total number of instructions recognized by the peephole\n+   pattern.\n+   The first NOPS entries in OPERANDS are the source registers, the next\n+   NOPS entries are memory operands.  If this function is successful, *BASE is\n+   set to the common base register of the memory accesses; *LOAD_OFFSET is set\n+   to the first memory location's offset from that base register.  REGS is an\n+   array filled in with the source register numbers, REG_RTXS (if nonnull) is\n+   likewise filled with the corresponding rtx's.\n+   SAVED_ORDER (if nonnull), is an array filled in with an order that maps insn\n+   numbers to to an ascending order of stores.\n+   If CHECK_REGS is true, the sequence of registers in *REGS matches the stores\n+   from ascending memory locations, and the function verifies that the register\n+   numbers are themselves ascending.  If CHECK_REGS is false, the register\n+   numbers are stored in the order they are found in the operands.  */\n+static int\n+store_multiple_sequence (rtx *operands, int nops, int nops_total,\n+\t\t\t int *regs, rtx *reg_rtxs, int *saved_order, int *base,\n+\t\t\t HOST_WIDE_INT *load_offset, bool check_regs)\n {\n   int unsorted_regs[MAX_LDM_STM_OPS];\n+  rtx unsorted_reg_rtxs[MAX_LDM_STM_OPS];\n   HOST_WIDE_INT unsorted_offsets[MAX_LDM_STM_OPS];\n   int order[MAX_LDM_STM_OPS];\n   int base_reg = -1;\n+  rtx base_reg_rtx = NULL;\n   int i, stm_case;\n \n   /* Can only handle up to MAX_LDM_STM_OPS insns at present, though could be\n@@ -9449,17 +9446,27 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \t      && (GET_CODE (offset = XEXP (XEXP (operands[nops + i], 0), 1))\n \t\t  == CONST_INT)))\n \t{\n-\t  unsorted_regs[i] = (GET_CODE (operands[i]) == REG\n-\t\t\t      ? REGNO (operands[i])\n-\t\t\t      : REGNO (SUBREG_REG (operands[i])));\n+\t  unsorted_reg_rtxs[i] = (GET_CODE (operands[i]) == REG\n+\t\t\t\t  ? operands[i] : SUBREG_REG (operands[i]));\n+\t  unsorted_regs[i] = REGNO (unsorted_reg_rtxs[i]);\n+\n \t  if (i == 0)\n-\t    base_reg = REGNO (reg);\n+\t    {\n+\t      base_reg = REGNO (reg);\n+\t      base_reg_rtx = reg;\n+\t      if (TARGET_THUMB1 && base_reg > LAST_LO_REGNUM)\n+\t\treturn 0;\n+\t    }\n \t  else if (base_reg != (int) REGNO (reg))\n \t    /* Not addressed from the same base register.  */\n \t    return 0;\n \n \t  /* If it isn't an integer register, then we can't do this.  */\n-\t  if (unsorted_regs[i] < 0 || unsorted_regs[i] > 14)\n+\t  if (unsorted_regs[i] < 0\n+\t      || (TARGET_THUMB1 && unsorted_regs[i] > LAST_LO_REGNUM)\n+\t      || (TARGET_THUMB2 && unsorted_regs[i] == base_reg)\n+\t      || (TARGET_THUMB2 && unsorted_regs[i] == SP_REGNUM)\n+\t      || unsorted_regs[i] > 14)\n \t    return 0;\n \n \t  unsorted_offsets[i] = INTVAL (offset);\n@@ -9476,26 +9483,38 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n      order[0] has been set to the lowest offset in the list.  Sort\n      the offsets into order, verifying that they are adjacent, and\n      check that the register numbers are ascending.  */\n-  if (!compute_offset_order (nops, unsorted_offsets, order, unsorted_regs))\n+  if (!compute_offset_order (nops, unsorted_offsets, order,\n+\t\t\t     check_regs ? unsorted_regs : NULL))\n     return 0;\n \n+  if (saved_order)\n+    memcpy (saved_order, order, sizeof order);\n+\n   if (base)\n     {\n       *base = base_reg;\n \n       for (i = 0; i < nops; i++)\n-\tregs[i] = unsorted_regs[order[i]];\n+\t{\n+\t  regs[i] = unsorted_regs[check_regs ? order[i] : i];\n+\t  if (reg_rtxs)\n+\t    reg_rtxs[i] = unsorted_reg_rtxs[check_regs ? order[i] : i];\n+\t}\n \n       *load_offset = unsorted_offsets[order[0]];\n     }\n \n+  if (TARGET_THUMB1\n+      && !peep2_reg_dead_p (nops_total, base_reg_rtx))\n+    return 0;\n+\n   if (unsorted_offsets[order[0]] == 0)\n     stm_case = 1; /* stmia */\n   else if (TARGET_ARM && unsorted_offsets[order[0]] == 4)\n     stm_case = 2; /* stmib */\n   else if (TARGET_ARM && unsorted_offsets[order[nops - 1]] == 0)\n     stm_case = 3; /* stmda */\n-  else if (unsorted_offsets[order[nops - 1]] == -4)\n+  else if (TARGET_32BIT && unsorted_offsets[order[nops - 1]] == -4)\n     stm_case = 4; /* stmdb */\n   else\n     return 0;\n@@ -9505,62 +9524,21 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \n   return stm_case;\n }\n-\n-const char *\n-emit_stm_seq (rtx *operands, int nops)\n-{\n-  int regs[MAX_LDM_STM_OPS];\n-  int base_reg;\n-  HOST_WIDE_INT offset;\n-  char buf[100];\n-  int i;\n-\n-  switch (store_multiple_sequence (operands, nops, regs, &base_reg, &offset))\n-    {\n-    case 1:\n-      strcpy (buf, \"stm%(ia%)\\t\");\n-      break;\n-\n-    case 2:\n-      strcpy (buf, \"stm%(ib%)\\t\");\n-      break;\n-\n-    case 3:\n-      strcpy (buf, \"stm%(da%)\\t\");\n-      break;\n-\n-    case 4:\n-      strcpy (buf, \"stm%(db%)\\t\");\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  sprintf (buf + strlen (buf), \"%s%s, {%s%s\", REGISTER_PREFIX,\n-\t   reg_names[base_reg], REGISTER_PREFIX, reg_names[regs[0]]);\n-\n-  for (i = 1; i < nops; i++)\n-    sprintf (buf + strlen (buf), \", %s%s\", REGISTER_PREFIX,\n-\t     reg_names[regs[i]]);\n-\n-  strcat (buf, \"}\\t%@ phole stm\");\n-\n-  output_asm_insn (buf, operands);\n-  return \"\";\n-}\n \f\n /* Routines for use in generating RTL.  */\n \n-rtx\n-arm_gen_load_multiple (int base_regno, int count, rtx from, int up,\n-\t\t       int write_back, rtx basemem, HOST_WIDE_INT *offsetp)\n+/* Generate a load-multiple instruction.  COUNT is the number of loads in\n+   the instruction; REGS and MEMS are arrays containing the operands.\n+   BASEREG is the base register to be used in addressing the memory operands.\n+   WBACK_OFFSET is nonzero if the instruction should update the base\n+   register.  */\n+\n+static rtx\n+arm_gen_load_multiple_1 (int count, int *regs, rtx *mems, rtx basereg,\n+\t\t\t HOST_WIDE_INT wback_offset)\n {\n-  HOST_WIDE_INT offset = *offsetp;\n   int i = 0, j;\n   rtx result;\n-  int sign = up ? 1 : -1;\n-  rtx mem, addr;\n \n   /* XScale has load-store double instructions, but they have stricter\n      alignment requirements than load-store multiple, so we cannot\n@@ -9597,18 +9575,10 @@ arm_gen_load_multiple (int base_regno, int count, rtx from, int up,\n       start_sequence ();\n \n       for (i = 0; i < count; i++)\n-\t{\n-\t  addr = plus_constant (from, i * 4 * sign);\n-\t  mem = adjust_automodify_address (basemem, SImode, addr, offset);\n-\t  emit_move_insn (gen_rtx_REG (SImode, base_regno + i), mem);\n-\t  offset += 4 * sign;\n-\t}\n+\temit_move_insn (gen_rtx_REG (SImode, regs[i]), mems[i]);\n \n-      if (write_back)\n-\t{\n-\t  emit_move_insn (from, plus_constant (from, count * 4 * sign));\n-\t  *offsetp = offset;\n-\t}\n+      if (wback_offset != 0)\n+\temit_move_insn (basereg, plus_constant (basereg, wback_offset));\n \n       seq = get_insns ();\n       end_sequence ();\n@@ -9617,41 +9587,40 @@ arm_gen_load_multiple (int base_regno, int count, rtx from, int up,\n     }\n \n   result = gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t     rtvec_alloc (count + (write_back ? 1 : 0)));\n-  if (write_back)\n+\t\t\t     rtvec_alloc (count + (wback_offset != 0 ? 1 : 0)));\n+  if (wback_offset != 0)\n     {\n       XVECEXP (result, 0, 0)\n-\t= gen_rtx_SET (VOIDmode, from, plus_constant (from, count * 4 * sign));\n+\t= gen_rtx_SET (VOIDmode, basereg,\n+\t\t       plus_constant (basereg, wback_offset));\n       i = 1;\n       count++;\n     }\n \n   for (j = 0; i < count; i++, j++)\n-    {\n-      addr = plus_constant (from, j * 4 * sign);\n-      mem = adjust_automodify_address_nv (basemem, SImode, addr, offset);\n-      XVECEXP (result, 0, i)\n-\t= gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, base_regno + j), mem);\n-      offset += 4 * sign;\n-    }\n-\n-  if (write_back)\n-    *offsetp = offset;\n+    XVECEXP (result, 0, i)\n+      = gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, regs[j]), mems[j]);\n \n   return result;\n }\n \n-rtx\n-arm_gen_store_multiple (int base_regno, int count, rtx to, int up,\n-\t\t\tint write_back, rtx basemem, HOST_WIDE_INT *offsetp)\n+/* Generate a store-multiple instruction.  COUNT is the number of stores in\n+   the instruction; REGS and MEMS are arrays containing the operands.\n+   BASEREG is the base register to be used in addressing the memory operands.\n+   WBACK_OFFSET is nonzero if the instruction should update the base\n+   register.  */\n+\n+static rtx\n+arm_gen_store_multiple_1 (int count, int *regs, rtx *mems, rtx basereg,\n+\t\t\t  HOST_WIDE_INT wback_offset)\n {\n-  HOST_WIDE_INT offset = *offsetp;\n   int i = 0, j;\n   rtx result;\n-  int sign = up ? 1 : -1;\n-  rtx mem, addr;\n \n-  /* See arm_gen_load_multiple for discussion of\n+  if (GET_CODE (basereg) == PLUS)\n+    basereg = XEXP (basereg, 0);\n+\n+  /* See arm_gen_load_multiple_1 for discussion of\n      the pros/cons of ldm/stm usage for XScale.  */\n   if (arm_tune_xscale && count <= 2 && ! optimize_size)\n     {\n@@ -9660,18 +9629,10 @@ arm_gen_store_multiple (int base_regno, int count, rtx to, int up,\n       start_sequence ();\n \n       for (i = 0; i < count; i++)\n-\t{\n-\t  addr = plus_constant (to, i * 4 * sign);\n-\t  mem = adjust_automodify_address (basemem, SImode, addr, offset);\n-\t  emit_move_insn (mem, gen_rtx_REG (SImode, base_regno + i));\n-\t  offset += 4 * sign;\n-\t}\n+\temit_move_insn (mems[i], gen_rtx_REG (SImode, regs[i]));\n \n-      if (write_back)\n-\t{\n-\t  emit_move_insn (to, plus_constant (to, count * 4 * sign));\n-\t  *offsetp = offset;\n-\t}\n+      if (wback_offset != 0)\n+\temit_move_insn (basereg, plus_constant (basereg, wback_offset));\n \n       seq = get_insns ();\n       end_sequence ();\n@@ -9680,29 +9641,319 @@ arm_gen_store_multiple (int base_regno, int count, rtx to, int up,\n     }\n \n   result = gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t     rtvec_alloc (count + (write_back ? 1 : 0)));\n-  if (write_back)\n+\t\t\t     rtvec_alloc (count + (wback_offset != 0 ? 1 : 0)));\n+  if (wback_offset != 0)\n     {\n       XVECEXP (result, 0, 0)\n-\t= gen_rtx_SET (VOIDmode, to,\n-\t\t       plus_constant (to, count * 4 * sign));\n+\t= gen_rtx_SET (VOIDmode, basereg,\n+\t\t       plus_constant (basereg, wback_offset));\n       i = 1;\n       count++;\n     }\n \n   for (j = 0; i < count; i++, j++)\n+    XVECEXP (result, 0, i)\n+      = gen_rtx_SET (VOIDmode, mems[j], gen_rtx_REG (SImode, regs[j]));\n+\n+  return result;\n+}\n+\n+/* Generate either a load-multiple or a store-multiple instruction.  This\n+   function can be used in situations where we can start with a single MEM\n+   rtx and adjust its address upwards.\n+   COUNT is the number of operations in the instruction, not counting a\n+   possible update of the base register.  REGS is an array containing the\n+   register operands.\n+   BASEREG is the base register to be used in addressing the memory operands,\n+   which are constructed from BASEMEM.\n+   WRITE_BACK specifies whether the generated instruction should include an\n+   update of the base register.\n+   OFFSETP is used to pass an offset to and from this function; this offset\n+   is not used when constructing the address (instead BASEMEM should have an\n+   appropriate offset in its address), it is used only for setting\n+   MEM_OFFSET.  It is updated only if WRITE_BACK is true.*/\n+\n+static rtx\n+arm_gen_multiple_op (bool is_load, int *regs, int count, rtx basereg,\n+\t\t     bool write_back, rtx basemem, HOST_WIDE_INT *offsetp)\n+{\n+  rtx mems[MAX_LDM_STM_OPS];\n+  HOST_WIDE_INT offset = *offsetp;\n+  int i;\n+\n+  gcc_assert (count <= MAX_LDM_STM_OPS);\n+\n+  if (GET_CODE (basereg) == PLUS)\n+    basereg = XEXP (basereg, 0);\n+\n+  for (i = 0; i < count; i++)\n     {\n-      addr = plus_constant (to, j * 4 * sign);\n-      mem = adjust_automodify_address_nv (basemem, SImode, addr, offset);\n-      XVECEXP (result, 0, i)\n-\t= gen_rtx_SET (VOIDmode, mem, gen_rtx_REG (SImode, base_regno + j));\n-      offset += 4 * sign;\n+      rtx addr = plus_constant (basereg, i * 4);\n+      mems[i] = adjust_automodify_address_nv (basemem, SImode, addr, offset);\n+      offset += 4;\n     }\n \n   if (write_back)\n     *offsetp = offset;\n \n-  return result;\n+  if (is_load)\n+    return arm_gen_load_multiple_1 (count, regs, mems, basereg,\n+\t\t\t\t    write_back ? 4 * count : 0);\n+  else\n+    return arm_gen_store_multiple_1 (count, regs, mems, basereg,\n+\t\t\t\t     write_back ? 4 * count : 0);\n+}\n+\n+rtx\n+arm_gen_load_multiple (int *regs, int count, rtx basereg, int write_back,\n+\t\t       rtx basemem, HOST_WIDE_INT *offsetp)\n+{\n+  return arm_gen_multiple_op (TRUE, regs, count, basereg, write_back, basemem,\n+\t\t\t      offsetp);\n+}\n+\n+rtx\n+arm_gen_store_multiple (int *regs, int count, rtx basereg, int write_back,\n+\t\t\trtx basemem, HOST_WIDE_INT *offsetp)\n+{\n+  return arm_gen_multiple_op (FALSE, regs, count, basereg, write_back, basemem,\n+\t\t\t      offsetp);\n+}\n+\n+/* Called from a peephole2 expander to turn a sequence of loads into an\n+   LDM instruction.  OPERANDS are the operands found by the peephole matcher;\n+   NOPS indicates how many separate loads we are trying to combine.  SORT_REGS\n+   is true if we can reorder the registers because they are used commutatively\n+   subsequently.\n+   Returns true iff we could generate a new instruction.  */\n+\n+bool\n+gen_ldm_seq (rtx *operands, int nops, bool sort_regs)\n+{\n+  int regs[MAX_LDM_STM_OPS], mem_order[MAX_LDM_STM_OPS];\n+  rtx mems[MAX_LDM_STM_OPS];\n+  int i, j, base_reg;\n+  rtx base_reg_rtx;\n+  HOST_WIDE_INT offset;\n+  int write_back = FALSE;\n+  int ldm_case;\n+  rtx addr;\n+\n+  ldm_case = load_multiple_sequence (operands, nops, regs, mem_order,\n+\t\t\t\t     &base_reg, &offset, !sort_regs);\n+\n+  if (ldm_case == 0)\n+    return false;\n+\n+  if (sort_regs)\n+    for (i = 0; i < nops - 1; i++)\n+      for (j = i + 1; j < nops; j++)\n+\tif (regs[i] > regs[j])\n+\t  {\n+\t    int t = regs[i];\n+\t    regs[i] = regs[j];\n+\t    regs[j] = t;\n+\t  }\n+  base_reg_rtx = gen_rtx_REG (Pmode, base_reg);\n+\n+  if (TARGET_THUMB1)\n+    {\n+      gcc_assert (peep2_reg_dead_p (nops, base_reg_rtx));\n+      gcc_assert (ldm_case == 1 || ldm_case == 5);\n+      write_back = TRUE;\n+    }\n+\n+  if (ldm_case == 5)\n+    {\n+      rtx newbase = TARGET_THUMB1 ? base_reg_rtx : gen_rtx_REG (SImode, regs[0]);\n+      emit_insn (gen_addsi3 (newbase, base_reg_rtx, GEN_INT (offset)));\n+      offset = 0;\n+      if (!TARGET_THUMB1)\n+\t{\n+\t  base_reg = regs[0];\n+\t  base_reg_rtx = newbase;\n+\t}\n+    }\n+\n+  for (i = 0; i < nops; i++)\n+    {\n+      addr = plus_constant (base_reg_rtx, offset + i * 4);\n+      mems[i] = adjust_automodify_address_nv (operands[nops + mem_order[i]],\n+\t\t\t\t\t      SImode, addr, 0);\n+    }\n+  emit_insn (arm_gen_load_multiple_1 (nops, regs, mems, base_reg_rtx,\n+\t\t\t\t      write_back ? offset + i * 4 : 0));\n+  return true;\n+}\n+\n+/* Called from a peephole2 expander to turn a sequence of stores into an\n+   STM instruction.  OPERANDS are the operands found by the peephole matcher;\n+   NOPS indicates how many separate stores we are trying to combine.\n+   Returns true iff we could generate a new instruction.  */\n+\n+bool\n+gen_stm_seq (rtx *operands, int nops)\n+{\n+  int i;\n+  int regs[MAX_LDM_STM_OPS], mem_order[MAX_LDM_STM_OPS];\n+  rtx mems[MAX_LDM_STM_OPS];\n+  int base_reg;\n+  rtx base_reg_rtx;\n+  HOST_WIDE_INT offset;\n+  int write_back = FALSE;\n+  int stm_case;\n+  rtx addr;\n+  bool base_reg_dies;\n+\n+  stm_case = store_multiple_sequence (operands, nops, nops, regs, NULL,\n+\t\t\t\t      mem_order, &base_reg, &offset, true);\n+\n+  if (stm_case == 0)\n+    return false;\n+\n+  base_reg_rtx = gen_rtx_REG (Pmode, base_reg);\n+\n+  base_reg_dies = peep2_reg_dead_p (nops, base_reg_rtx);\n+  if (TARGET_THUMB1)\n+    {\n+      gcc_assert (base_reg_dies);\n+      write_back = TRUE;\n+    }\n+\n+  if (stm_case == 5)\n+    {\n+      gcc_assert (base_reg_dies);\n+      emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, GEN_INT (offset)));\n+      offset = 0;\n+    }\n+\n+  addr = plus_constant (base_reg_rtx, offset);\n+\n+  for (i = 0; i < nops; i++)\n+    {\n+      addr = plus_constant (base_reg_rtx, offset + i * 4);\n+      mems[i] = adjust_automodify_address_nv (operands[nops + mem_order[i]],\n+\t\t\t\t\t      SImode, addr, 0);\n+    }\n+  emit_insn (arm_gen_store_multiple_1 (nops, regs, mems, base_reg_rtx,\n+\t\t\t\t       write_back ? offset + i * 4 : 0));\n+  return true;\n+}\n+\n+/* Called from a peephole2 expander to turn a sequence of stores that are\n+   preceded by constant loads into an STM instruction.  OPERANDS are the\n+   operands found by the peephole matcher; NOPS indicates how many\n+   separate stores we are trying to combine; there are 2 * NOPS\n+   instructions in the peephole.\n+   Returns true iff we could generate a new instruction.  */\n+\n+bool\n+gen_const_stm_seq (rtx *operands, int nops)\n+{\n+  int regs[MAX_LDM_STM_OPS], sorted_regs[MAX_LDM_STM_OPS];\n+  int reg_order[MAX_LDM_STM_OPS], mem_order[MAX_LDM_STM_OPS];\n+  rtx reg_rtxs[MAX_LDM_STM_OPS], orig_reg_rtxs[MAX_LDM_STM_OPS];\n+  rtx mems[MAX_LDM_STM_OPS];\n+  int base_reg;\n+  rtx base_reg_rtx;\n+  HOST_WIDE_INT offset;\n+  int write_back = FALSE;\n+  int stm_case;\n+  rtx addr;\n+  bool base_reg_dies;\n+  int i, j;\n+  HARD_REG_SET allocated;\n+\n+  stm_case = store_multiple_sequence (operands, nops, 2 * nops, regs, reg_rtxs,\n+\t\t\t\t      mem_order, &base_reg, &offset, false);\n+\n+  if (stm_case == 0)\n+    return false;\n+\n+  memcpy (orig_reg_rtxs, reg_rtxs, sizeof orig_reg_rtxs);\n+\n+  /* If the same register is used more than once, try to find a free\n+     register.  */\n+  CLEAR_HARD_REG_SET (allocated);\n+  for (i = 0; i < nops; i++)\n+    {\n+      for (j = i + 1; j < nops; j++)\n+\tif (regs[i] == regs[j])\n+\t  {\n+\t    rtx t = peep2_find_free_register (0, nops * 2,\n+\t\t\t\t\t      TARGET_THUMB1 ? \"l\" : \"r\",\n+\t\t\t\t\t      SImode, &allocated);\n+\t    if (t == NULL_RTX)\n+\t      return false;\n+\t    reg_rtxs[i] = t;\n+\t    regs[i] = REGNO (t);\n+\t  }\n+    }\n+\n+  /* Compute an ordering that maps the register numbers to an ascending\n+     sequence.  */\n+  reg_order[0] = 0;\n+  for (i = 0; i < nops; i++)\n+    if (regs[i] < regs[reg_order[0]])\n+      reg_order[0] = i;\n+\n+  for (i = 1; i < nops; i++)\n+    {\n+      int this_order = reg_order[i - 1];\n+      for (j = 0; j < nops; j++)\n+\tif (regs[j] > regs[reg_order[i - 1]]\n+\t    && (this_order == reg_order[i - 1]\n+\t\t|| regs[j] < regs[this_order]))\n+\t  this_order = j;\n+      reg_order[i] = this_order;\n+    }\n+\n+  /* Ensure that registers that must be live after the instruction end\n+     up with the correct value.  */\n+  for (i = 0; i < nops; i++)\n+    {\n+      int this_order = reg_order[i];\n+      if ((this_order != mem_order[i]\n+\t   || orig_reg_rtxs[this_order] != reg_rtxs[this_order])\n+\t  && !peep2_reg_dead_p (nops * 2, orig_reg_rtxs[this_order]))\n+\treturn false;\n+    }\n+\n+  /* Load the constants.  */\n+  for (i = 0; i < nops; i++)\n+    {\n+      rtx op = operands[2 * nops + mem_order[i]];\n+      sorted_regs[i] = regs[reg_order[i]];\n+      emit_move_insn (reg_rtxs[reg_order[i]], op);\n+    }\n+\n+  base_reg_rtx = gen_rtx_REG (Pmode, base_reg);\n+\n+  base_reg_dies = peep2_reg_dead_p (nops * 2, base_reg_rtx);\n+  if (TARGET_THUMB1)\n+    {\n+      gcc_assert (base_reg_dies);\n+      write_back = TRUE;\n+    }\n+\n+  if (stm_case == 5)\n+    {\n+      gcc_assert (base_reg_dies);\n+      emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, GEN_INT (offset)));\n+      offset = 0;\n+    }\n+\n+  addr = plus_constant (base_reg_rtx, offset);\n+\n+  for (i = 0; i < nops; i++)\n+    {\n+      addr = plus_constant (base_reg_rtx, offset + i * 4);\n+      mems[i] = adjust_automodify_address_nv (operands[nops + mem_order[i]],\n+\t\t\t\t\t      SImode, addr, 0);\n+    }\n+  emit_insn (arm_gen_store_multiple_1 (nops, sorted_regs, mems, base_reg_rtx,\n+\t\t\t\t       write_back ? offset + i * 4 : 0));\n+  return true;\n }\n \n int\n@@ -9738,20 +9989,21 @@ arm_gen_movmemqi (rtx *operands)\n   for (i = 0; in_words_to_go >= 2; i+=4)\n     {\n       if (in_words_to_go > 4)\n-\temit_insn (arm_gen_load_multiple (0, 4, src, TRUE, TRUE,\n-\t\t\t\t\t  srcbase, &srcoffset));\n+\temit_insn (arm_gen_load_multiple (arm_regs_in_sequence, 4, src,\n+\t\t\t\t\t  TRUE, srcbase, &srcoffset));\n       else\n-\temit_insn (arm_gen_load_multiple (0, in_words_to_go, src, TRUE,\n-\t\t\t\t\t  FALSE, srcbase, &srcoffset));\n+\temit_insn (arm_gen_load_multiple (arm_regs_in_sequence, in_words_to_go,\n+\t\t\t\t\t  src, FALSE, srcbase,\n+\t\t\t\t\t  &srcoffset));\n \n       if (out_words_to_go)\n \t{\n \t  if (out_words_to_go > 4)\n-\t    emit_insn (arm_gen_store_multiple (0, 4, dst, TRUE, TRUE,\n-\t\t\t\t\t       dstbase, &dstoffset));\n+\t    emit_insn (arm_gen_store_multiple (arm_regs_in_sequence, 4, dst,\n+\t\t\t\t\t       TRUE, dstbase, &dstoffset));\n \t  else if (out_words_to_go != 1)\n-\t    emit_insn (arm_gen_store_multiple (0, out_words_to_go,\n-\t\t\t\t\t       dst, TRUE,\n+\t    emit_insn (arm_gen_store_multiple (arm_regs_in_sequence,\n+\t\t\t\t\t       out_words_to_go, dst,\n \t\t\t\t\t       (last_bytes == 0\n \t\t\t\t\t\t? FALSE : TRUE),\n \t\t\t\t\t       dstbase, &dstoffset));"}, {"sha": "29f31f2f6523a098843ca34f24f822cb85fe5942", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=3711941045eb2d1723b3530560fe866ee5a82485", "patch": "@@ -1096,6 +1096,9 @@ extern int arm_structure_size_boundary;\n   ((MODE) == TImode || (MODE) == EImode || (MODE) == OImode \\\n    || (MODE) == CImode || (MODE) == XImode)\n \n+/* The register numbers in sequence, for passing to arm_gen_load_multiple.  */\n+extern int arm_regs_in_sequence[];\n+\n /* The order in which register should be allocated.  It is good to use ip\n    since no saving is required (though calls clobber it) and it never contains\n    function parameters.  It is quite good to use lr since other calls may"}, {"sha": "719653285fad0f8290b72db5d0226e9187bc1154", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 13, "deletions": 319, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=3711941045eb2d1723b3530560fe866ee5a82485", "patch": "@@ -6209,7 +6209,7 @@\n \n ;; load- and store-multiple insns\n ;; The arm can load/store any set of registers, provided that they are in\n-;; ascending order; but that is beyond GCC so stick with what it knows.\n+;; ascending order, but these expanders assume a contiguous set.\n \n (define_expand \"load_multiple\"\n   [(match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n@@ -6230,126 +6230,12 @@\n     FAIL;\n \n   operands[3]\n-    = arm_gen_load_multiple (REGNO (operands[0]), INTVAL (operands[2]),\n+    = arm_gen_load_multiple (arm_regs_in_sequence + REGNO (operands[0]),\n+\t\t\t     INTVAL (operands[2]),\n \t\t\t     force_reg (SImode, XEXP (operands[1], 0)),\n-\t\t\t     TRUE, FALSE, operands[1], &offset);\n+\t\t\t     FALSE, operands[1], &offset);\n })\n \n-;; Load multiple with write-back\n-\n-(define_insn \"*ldmsi_postinc4\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n-\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n-\t\t   (const_int 16)))\n-     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (match_dup 2)))\n-     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 2) (const_int 4))))\n-     (set (match_operand:SI 5 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 2) (const_int 8))))\n-     (set (match_operand:SI 6 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 2) (const_int 12))))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 5\"\n-  \"ldm%(ia%)\\\\t%1!, {%3, %4, %5, %6}\"\n-  [(set_attr \"type\" \"load4\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n-(define_insn \"*ldmsi_postinc4_thumb1\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 1 \"s_register_operand\" \"=l\")\n-\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n-\t\t   (const_int 16)))\n-     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (match_dup 2)))\n-     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 2) (const_int 4))))\n-     (set (match_operand:SI 5 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 2) (const_int 8))))\n-     (set (match_operand:SI 6 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 2) (const_int 12))))])]\n-  \"TARGET_THUMB1 && XVECLEN (operands[0], 0) == 5\"\n-  \"ldmia\\\\t%1!, {%3, %4, %5, %6}\"\n-  [(set_attr \"type\" \"load4\")]\n-)\n-\n-(define_insn \"*ldmsi_postinc3\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n-\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n-\t\t   (const_int 12)))\n-     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (match_dup 2)))\n-     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 2) (const_int 4))))\n-     (set (match_operand:SI 5 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 2) (const_int 8))))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n-  \"ldm%(ia%)\\\\t%1!, {%3, %4, %5}\"\n-  [(set_attr \"type\" \"load3\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n-(define_insn \"*ldmsi_postinc2\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n-\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n-\t\t   (const_int 8)))\n-     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (match_dup 2)))\n-     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 2) (const_int 4))))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n-  \"ldm%(ia%)\\\\t%1!, {%3, %4}\"\n-  [(set_attr \"type\" \"load2\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n-;; Ordinary load multiple\n-\n-(define_insn \"*ldmsi4\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\")))\n-     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n-     (set (match_operand:SI 5 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 1) (const_int 12))))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n-  \"ldm%(ia%)\\\\t%1, {%2, %3, %4, %5}\"\n-  [(set_attr \"type\" \"load4\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n-(define_insn \"*ldmsi3\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\")))\n-     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 1) (const_int 8))))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n-  \"ldm%(ia%)\\\\t%1, {%2, %3, %4}\"\n-  [(set_attr \"type\" \"load3\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n-(define_insn \"*ldmsi2\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\")))\n-     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n-\t  (mem:SI (plus:SI (match_dup 1) (const_int 4))))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 2\"\n-  \"ldm%(ia%)\\\\t%1, {%2, %3}\"\n-  [(set_attr \"type\" \"load2\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n (define_expand \"store_multiple\"\n   [(match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n                           (match_operand:SI 1 \"\" \"\"))\n@@ -6369,125 +6255,12 @@\n     FAIL;\n \n   operands[3]\n-    = arm_gen_store_multiple (REGNO (operands[1]), INTVAL (operands[2]),\n+    = arm_gen_store_multiple (arm_regs_in_sequence + REGNO (operands[1]),\n+\t\t\t      INTVAL (operands[2]),\n \t\t\t      force_reg (SImode, XEXP (operands[0], 0)),\n-\t\t\t      TRUE, FALSE, operands[0], &offset);\n+\t\t\t      FALSE, operands[0], &offset);\n })\n \n-;; Store multiple with write-back\n-\n-(define_insn \"*stmsi_postinc4\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n-\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n-\t\t   (const_int 16)))\n-     (set (mem:SI (match_dup 2))\n-\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n-\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 2) (const_int 8)))\n-\t  (match_operand:SI 5 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 2) (const_int 12)))\n-\t  (match_operand:SI 6 \"arm_hard_register_operand\" \"\"))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 5\"\n-  \"stm%(ia%)\\\\t%1!, {%3, %4, %5, %6}\"\n-  [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"store4\")]\n-)\n-\n-(define_insn \"*stmsi_postinc4_thumb1\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (match_operand:SI 1 \"s_register_operand\" \"=l\")\n-\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n-\t\t   (const_int 16)))\n-     (set (mem:SI (match_dup 2))\n-\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n-\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 2) (const_int 8)))\n-\t  (match_operand:SI 5 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 2) (const_int 12)))\n-\t  (match_operand:SI 6 \"arm_hard_register_operand\" \"\"))])]\n-  \"TARGET_THUMB1 && XVECLEN (operands[0], 0) == 5\"\n-  \"stmia\\\\t%1!, {%3, %4, %5, %6}\"\n-  [(set_attr \"type\" \"store4\")]\n-)\n-\n-(define_insn \"*stmsi_postinc3\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n-\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n-\t\t   (const_int 12)))\n-     (set (mem:SI (match_dup 2))\n-\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n-\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 2) (const_int 8)))\n-\t  (match_operand:SI 5 \"arm_hard_register_operand\" \"\"))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n-  \"stm%(ia%)\\\\t%1!, {%3, %4, %5}\"\n-  [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"store3\")]\n-)\n-\n-(define_insn \"*stmsi_postinc2\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n-\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n-\t\t   (const_int 8)))\n-     (set (mem:SI (match_dup 2))\n-\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n-\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n-  \"stm%(ia%)\\\\t%1!, {%3, %4}\"\n-  [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"store2\")]\n-)\n-\n-;; Ordinary store multiple\n-\n-(define_insn \"*stmsi4\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))\n-\t  (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n-\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 8)))\n-\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 12)))\n-\t  (match_operand:SI 5 \"arm_hard_register_operand\" \"\"))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n-  \"stm%(ia%)\\\\t%1, {%2, %3, %4, %5}\"\n-  [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"store4\")]\n-)\n-\n-(define_insn \"*stmsi3\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))\n-\t  (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n-\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 8)))\n-\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n-  \"stm%(ia%)\\\\t%1, {%2, %3, %4}\"\n-  [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"store3\")]\n-)\n-\n-(define_insn \"*stmsi2\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))\n-\t  (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n-\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))])]\n-  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 2\"\n-  \"stm%(ia%)\\\\t%1, {%2, %3}\"\n-  [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"store2\")]\n-)\n \n ;; Move a block of memory if it is word aligned and MORE than 2 words long.\n ;; We could let this apply for blocks of less than this, but it clobbers so\n@@ -8395,8 +8168,8 @@\n \tif (REGNO (reg) == R0_REGNUM)\n \t  {\n \t    /* On thumb we have to use a write-back instruction.  */\n-\t    emit_insn (arm_gen_store_multiple (R0_REGNUM, 4, addr, TRUE,\n-\t\t\tTARGET_THUMB ? TRUE : FALSE, mem, &offset));\n+\t    emit_insn (arm_gen_store_multiple (arm_regs_in_sequence, 4, addr,\n+ \t\t       TARGET_THUMB ? TRUE : FALSE, mem, &offset));\n \t    size = TARGET_ARM ? 16 : 0;\n \t  }\n \telse\n@@ -8442,8 +8215,8 @@\n \tif (REGNO (reg) == R0_REGNUM)\n \t  {\n \t    /* On thumb we have to use a write-back instruction.  */\n-\t    emit_insn (arm_gen_load_multiple (R0_REGNUM, 4, addr, TRUE,\n-\t\t\tTARGET_THUMB ? TRUE : FALSE, mem, &offset));\n+\t    emit_insn (arm_gen_load_multiple (arm_regs_in_sequence, 4, addr,\n+ \t\t       TARGET_THUMB ? TRUE : FALSE, mem, &offset));\n \t    size = TARGET_ARM ? 16 : 0;\n \t  }\n \telse\n@@ -10036,87 +9809,6 @@\n   \"\"\n )\n \n-; Peepholes to spot possible load- and store-multiples, if the ordering is\n-; reversed, check that the memory references aren't volatile.\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=rk\")\n-        (match_operand:SI 4 \"memory_operand\" \"m\"))\n-   (set (match_operand:SI 1 \"s_register_operand\" \"=rk\")\n-        (match_operand:SI 5 \"memory_operand\" \"m\"))\n-   (set (match_operand:SI 2 \"s_register_operand\" \"=rk\")\n-        (match_operand:SI 6 \"memory_operand\" \"m\"))\n-   (set (match_operand:SI 3 \"s_register_operand\" \"=rk\")\n-        (match_operand:SI 7 \"memory_operand\" \"m\"))]\n-  \"TARGET_ARM && load_multiple_sequence (operands, 4, NULL, NULL, NULL)\"\n-  \"*\n-  return emit_ldm_seq (operands, 4);\n-  \"\n-)\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=rk\")\n-        (match_operand:SI 3 \"memory_operand\" \"m\"))\n-   (set (match_operand:SI 1 \"s_register_operand\" \"=rk\")\n-        (match_operand:SI 4 \"memory_operand\" \"m\"))\n-   (set (match_operand:SI 2 \"s_register_operand\" \"=rk\")\n-        (match_operand:SI 5 \"memory_operand\" \"m\"))]\n-  \"TARGET_ARM && load_multiple_sequence (operands, 3, NULL, NULL, NULL)\"\n-  \"*\n-  return emit_ldm_seq (operands, 3);\n-  \"\n-)\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=rk\")\n-        (match_operand:SI 2 \"memory_operand\" \"m\"))\n-   (set (match_operand:SI 1 \"s_register_operand\" \"=rk\")\n-        (match_operand:SI 3 \"memory_operand\" \"m\"))]\n-  \"TARGET_ARM && load_multiple_sequence (operands, 2, NULL, NULL, NULL)\"\n-  \"*\n-  return emit_ldm_seq (operands, 2);\n-  \"\n-)\n-\n-(define_peephole\n-  [(set (match_operand:SI 4 \"memory_operand\" \"=m\")\n-        (match_operand:SI 0 \"s_register_operand\" \"rk\"))\n-   (set (match_operand:SI 5 \"memory_operand\" \"=m\")\n-        (match_operand:SI 1 \"s_register_operand\" \"rk\"))\n-   (set (match_operand:SI 6 \"memory_operand\" \"=m\")\n-        (match_operand:SI 2 \"s_register_operand\" \"rk\"))\n-   (set (match_operand:SI 7 \"memory_operand\" \"=m\")\n-        (match_operand:SI 3 \"s_register_operand\" \"rk\"))]\n-  \"TARGET_ARM && store_multiple_sequence (operands, 4, NULL, NULL, NULL)\"\n-  \"*\n-  return emit_stm_seq (operands, 4);\n-  \"\n-)\n-\n-(define_peephole\n-  [(set (match_operand:SI 3 \"memory_operand\" \"=m\")\n-        (match_operand:SI 0 \"s_register_operand\" \"rk\"))\n-   (set (match_operand:SI 4 \"memory_operand\" \"=m\")\n-        (match_operand:SI 1 \"s_register_operand\" \"rk\"))\n-   (set (match_operand:SI 5 \"memory_operand\" \"=m\")\n-        (match_operand:SI 2 \"s_register_operand\" \"rk\"))]\n-  \"TARGET_ARM && store_multiple_sequence (operands, 3, NULL, NULL, NULL)\"\n-  \"*\n-  return emit_stm_seq (operands, 3);\n-  \"\n-)\n-\n-(define_peephole\n-  [(set (match_operand:SI 2 \"memory_operand\" \"=m\")\n-        (match_operand:SI 0 \"s_register_operand\" \"rk\"))\n-   (set (match_operand:SI 3 \"memory_operand\" \"=m\")\n-        (match_operand:SI 1 \"s_register_operand\" \"rk\"))]\n-  \"TARGET_ARM && store_multiple_sequence (operands, 2, NULL, NULL, NULL)\"\n-  \"*\n-  return emit_stm_seq (operands, 2);\n-  \"\n-)\n-\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(and:SI (ge:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n@@ -10906,6 +10598,8 @@\n   \"\n )\n \n+;; Load the load/store multiple patterns\n+(include \"ldmstm.md\")\n ;; Load the FPA co-processor patterns\n (include \"fpa.md\")\n ;; Load the Maverick co-processor patterns"}, {"sha": "5db4a3269968b396e9ae811dc616e7e1adb3291d", "filename": "gcc/config/arm/ldmstm.md", "status": "added", "additions": 1191, "deletions": 0, "changes": 1191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Fldmstm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Fldmstm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fldmstm.md?ref=3711941045eb2d1723b3530560fe866ee5a82485", "patch": "@@ -0,0 +1,1191 @@\n+/* ARM ldm/stm instruction patterns.  This file was automatically generated\n+   using arm-ldmstm.ml.  Please do not edit manually.\n+\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+(define_insn \"*ldm4_ia\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_operand:SI 5 \"s_register_operand\" \"rk\")))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 4))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 8))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 12))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%(ia%)\\t%5, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*thumb_ldm4_ia\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_operand:SI 5 \"s_register_operand\" \"l\")))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 4))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 8))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 12))))])]\n+  \"TARGET_THUMB1 && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%(ia%)\\t%5, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"load4\")])\n+\n+(define_insn \"*ldm4_ia_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 5 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 5) (const_int 16)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 5)))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 4))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 8))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 12))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 5\"\n+  \"ldm%(ia%)\\t%5!, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*thumb_ldm4_ia_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 5 \"s_register_operand\" \"+&l\")\n+          (plus:SI (match_dup 5) (const_int 16)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 5)))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 4))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 8))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 12))))])]\n+  \"TARGET_THUMB1 && XVECLEN (operands[0], 0) == 5\"\n+  \"ldm%(ia%)\\t%5!, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"load4\")])\n+\n+(define_insn \"*stm4_ia\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (match_operand:SI 5 \"s_register_operand\" \"rk\"))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 8)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 12)))\n+          (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n+  \"stm%(ia%)\\t%5, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"store4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm4_ia_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 5 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 5) (const_int 16)))\n+     (set (mem:SI (match_dup 5))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 8)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 12)))\n+          (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 5\"\n+  \"stm%(ia%)\\t%5!, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"store4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*thumb_stm4_ia_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 5 \"s_register_operand\" \"+&l\")\n+          (plus:SI (match_dup 5) (const_int 16)))\n+     (set (mem:SI (match_dup 5))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 8)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 12)))\n+          (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_THUMB1 && XVECLEN (operands[0], 0) == 5\"\n+  \"stm%(ia%)\\t%5!, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"store4\")])\n+\n+(define_insn \"*ldm4_ib\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_operand:SI 5 \"s_register_operand\" \"rk\")\n+                  (const_int 4))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 8))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 12))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 16))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%(ib%)\\t%5, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm4_ib_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 5 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 5) (const_int 16)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 4))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 8))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 12))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int 16))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 5\"\n+  \"ldm%(ib%)\\t%5!, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm4_ib\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (plus:SI (match_operand:SI 5 \"s_register_operand\" \"rk\") (const_int 4)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 8)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 12)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 16)))\n+          (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"stm%(ib%)\\t%5, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"store4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm4_ib_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 5 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 5) (const_int 16)))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 4)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 8)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 12)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int 16)))\n+          (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 5\"\n+  \"stm%(ib%)\\t%5!, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"store4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm4_da\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_operand:SI 5 \"s_register_operand\" \"rk\")\n+                  (const_int -12))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -8))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -4))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 5)))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%(da%)\\t%5, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm4_da_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 5 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 5) (const_int -16)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -12))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -8))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -4))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 5)))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 5\"\n+  \"ldm%(da%)\\t%5!, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm4_da\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (plus:SI (match_operand:SI 5 \"s_register_operand\" \"rk\") (const_int -12)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -8)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -4)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (match_dup 5))\n+          (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"stm%(da%)\\t%5, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"store4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm4_da_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 5 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 5) (const_int -16)))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -12)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -8)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -4)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (match_dup 5))\n+          (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 5\"\n+  \"stm%(da%)\\t%5!, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"store4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm4_db\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_operand:SI 5 \"s_register_operand\" \"rk\")\n+                  (const_int -16))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -12))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -8))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -4))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%(db%)\\t%5, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm4_db_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 5 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 5) (const_int -16)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -16))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -12))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -8))))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 5)\n+                  (const_int -4))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 5\"\n+  \"ldm%(db%)\\t%5!, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm4_db\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (plus:SI (match_operand:SI 5 \"s_register_operand\" \"rk\") (const_int -16)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -12)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -8)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -4)))\n+          (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n+  \"stm%(db%)\\t%5, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"store4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm4_db_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 5 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 5) (const_int -16)))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -16)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -12)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -8)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 5) (const_int -4)))\n+          (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 5\"\n+  \"stm%(db%)\\t%5!, {%1, %2, %3, %4}\"\n+  [(set_attr \"type\" \"store4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 4 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"\")\n+        (match_operand:SI 5 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 2 \"s_register_operand\" \"\")\n+        (match_operand:SI 6 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 3 \"s_register_operand\" \"\")\n+        (match_operand:SI 7 \"memory_operand\" \"\"))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_ldm_seq (operands, 4, false))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 4 \"memory_operand\" \"\"))\n+   (parallel\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"\")\n+          (match_operand:SI 5 \"memory_operand\" \"\"))\n+     (set (match_operand:SI 2 \"s_register_operand\" \"\")\n+          (match_operand:SI 6 \"memory_operand\" \"\"))\n+     (set (match_operand:SI 3 \"s_register_operand\" \"\")\n+          (match_operand:SI 7 \"memory_operand\" \"\"))])]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_ldm_seq (operands, 4, false))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 8 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 4 \"memory_operand\" \"\")\n+        (match_dup 0))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"\")\n+        (match_operand:SI 9 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 5 \"memory_operand\" \"\")\n+        (match_dup 1))\n+   (set (match_operand:SI 2 \"s_register_operand\" \"\")\n+        (match_operand:SI 10 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 6 \"memory_operand\" \"\")\n+        (match_dup 2))\n+   (set (match_operand:SI 3 \"s_register_operand\" \"\")\n+        (match_operand:SI 11 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 7 \"memory_operand\" \"\")\n+        (match_dup 3))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_const_stm_seq (operands, 4))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 8 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"\")\n+        (match_operand:SI 9 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 2 \"s_register_operand\" \"\")\n+        (match_operand:SI 10 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 3 \"s_register_operand\" \"\")\n+        (match_operand:SI 11 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 4 \"memory_operand\" \"\")\n+        (match_dup 0))\n+   (set (match_operand:SI 5 \"memory_operand\" \"\")\n+        (match_dup 1))\n+   (set (match_operand:SI 6 \"memory_operand\" \"\")\n+        (match_dup 2))\n+   (set (match_operand:SI 7 \"memory_operand\" \"\")\n+        (match_dup 3))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_const_stm_seq (operands, 4))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 4 \"memory_operand\" \"\")\n+        (match_operand:SI 0 \"s_register_operand\" \"\"))\n+   (set (match_operand:SI 5 \"memory_operand\" \"\")\n+        (match_operand:SI 1 \"s_register_operand\" \"\"))\n+   (set (match_operand:SI 6 \"memory_operand\" \"\")\n+        (match_operand:SI 2 \"s_register_operand\" \"\"))\n+   (set (match_operand:SI 7 \"memory_operand\" \"\")\n+        (match_operand:SI 3 \"s_register_operand\" \"\"))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_stm_seq (operands, 4))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_insn \"*ldm3_ia\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_operand:SI 4 \"s_register_operand\" \"rk\")))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 4))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 8))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%(ia%)\\t%4, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"load3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*thumb_ldm3_ia\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_operand:SI 4 \"s_register_operand\" \"l\")))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 4))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 8))))])]\n+  \"TARGET_THUMB1 && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%(ia%)\\t%4, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"load3\")])\n+\n+(define_insn \"*ldm3_ia_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 4 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 4) (const_int 12)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 4)))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 4))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 8))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%(ia%)\\t%4!, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"load3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*thumb_ldm3_ia_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 4 \"s_register_operand\" \"+&l\")\n+          (plus:SI (match_dup 4) (const_int 12)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 4)))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 4))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 8))))])]\n+  \"TARGET_THUMB1 && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%(ia%)\\t%4!, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"load3\")])\n+\n+(define_insn \"*stm3_ia\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (match_operand:SI 4 \"s_register_operand\" \"rk\"))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int 4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int 8)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n+  \"stm%(ia%)\\t%4, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"store3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm3_ia_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 4 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 4) (const_int 12)))\n+     (set (mem:SI (match_dup 4))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int 4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int 8)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n+  \"stm%(ia%)\\t%4!, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"store3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*thumb_stm3_ia_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 4 \"s_register_operand\" \"+&l\")\n+          (plus:SI (match_dup 4) (const_int 12)))\n+     (set (mem:SI (match_dup 4))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int 4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int 8)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_THUMB1 && XVECLEN (operands[0], 0) == 4\"\n+  \"stm%(ia%)\\t%4!, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"store3\")])\n+\n+(define_insn \"*ldm3_ib\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_operand:SI 4 \"s_register_operand\" \"rk\")\n+                  (const_int 4))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 8))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 12))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%(ib%)\\t%4, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"load3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm3_ib_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 4 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 4) (const_int 12)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 4))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 8))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int 12))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%(ib%)\\t%4!, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"load3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm3_ib\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (plus:SI (match_operand:SI 4 \"s_register_operand\" \"rk\") (const_int 4)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int 8)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int 12)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"stm%(ib%)\\t%4, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"store3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm3_ib_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 4 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 4) (const_int 12)))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int 4)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int 8)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int 12)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"stm%(ib%)\\t%4!, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"store3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm3_da\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_operand:SI 4 \"s_register_operand\" \"rk\")\n+                  (const_int -8))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int -4))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 4)))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%(da%)\\t%4, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"load3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm3_da_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 4 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 4) (const_int -12)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int -8))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int -4))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 4)))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%(da%)\\t%4!, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"load3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm3_da\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (plus:SI (match_operand:SI 4 \"s_register_operand\" \"rk\") (const_int -8)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int -4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (match_dup 4))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"stm%(da%)\\t%4, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"store3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm3_da_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 4 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 4) (const_int -12)))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int -8)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int -4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (match_dup 4))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n+  \"stm%(da%)\\t%4!, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"store3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm3_db\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_operand:SI 4 \"s_register_operand\" \"rk\")\n+                  (const_int -12))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int -8))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int -4))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%(db%)\\t%4, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"load3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm3_db_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 4 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 4) (const_int -12)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int -12))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int -8))))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 4)\n+                  (const_int -4))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n+  \"ldm%(db%)\\t%4!, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"load3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm3_db\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (plus:SI (match_operand:SI 4 \"s_register_operand\" \"rk\") (const_int -12)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int -8)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int -4)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n+  \"stm%(db%)\\t%4, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"store3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm3_db_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 4 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 4) (const_int -12)))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int -12)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int -8)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 4) (const_int -4)))\n+          (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 4\"\n+  \"stm%(db%)\\t%4!, {%1, %2, %3}\"\n+  [(set_attr \"type\" \"store3\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 3 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"\")\n+        (match_operand:SI 4 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 2 \"s_register_operand\" \"\")\n+        (match_operand:SI 5 \"memory_operand\" \"\"))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_ldm_seq (operands, 3, false))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 3 \"memory_operand\" \"\"))\n+   (parallel\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"\")\n+          (match_operand:SI 4 \"memory_operand\" \"\"))\n+     (set (match_operand:SI 2 \"s_register_operand\" \"\")\n+          (match_operand:SI 5 \"memory_operand\" \"\"))])]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_ldm_seq (operands, 3, false))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 6 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 3 \"memory_operand\" \"\")\n+        (match_dup 0))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"\")\n+        (match_operand:SI 7 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 4 \"memory_operand\" \"\")\n+        (match_dup 1))\n+   (set (match_operand:SI 2 \"s_register_operand\" \"\")\n+        (match_operand:SI 8 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 5 \"memory_operand\" \"\")\n+        (match_dup 2))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_const_stm_seq (operands, 3))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 6 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"\")\n+        (match_operand:SI 7 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 2 \"s_register_operand\" \"\")\n+        (match_operand:SI 8 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 3 \"memory_operand\" \"\")\n+        (match_dup 0))\n+   (set (match_operand:SI 4 \"memory_operand\" \"\")\n+        (match_dup 1))\n+   (set (match_operand:SI 5 \"memory_operand\" \"\")\n+        (match_dup 2))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_const_stm_seq (operands, 3))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 3 \"memory_operand\" \"\")\n+        (match_operand:SI 0 \"s_register_operand\" \"\"))\n+   (set (match_operand:SI 4 \"memory_operand\" \"\")\n+        (match_operand:SI 1 \"s_register_operand\" \"\"))\n+   (set (match_operand:SI 5 \"memory_operand\" \"\")\n+        (match_operand:SI 2 \"s_register_operand\" \"\"))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_stm_seq (operands, 3))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_insn \"*ldm2_ia\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_operand:SI 3 \"s_register_operand\" \"rk\")))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 3)\n+                  (const_int 4))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 2\"\n+  \"ldm%(ia%)\\t%3, {%1, %2}\"\n+  [(set_attr \"type\" \"load2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*thumb_ldm2_ia\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_operand:SI 3 \"s_register_operand\" \"l\")))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 3)\n+                  (const_int 4))))])]\n+  \"TARGET_THUMB1 && XVECLEN (operands[0], 0) == 2\"\n+  \"ldm%(ia%)\\t%3, {%1, %2}\"\n+  [(set_attr \"type\" \"load2\")])\n+\n+(define_insn \"*ldm2_ia_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 3 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 3) (const_int 8)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 3)))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 3)\n+                  (const_int 4))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%(ia%)\\t%3!, {%1, %2}\"\n+  [(set_attr \"type\" \"load2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*thumb_ldm2_ia_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 3 \"s_register_operand\" \"+&l\")\n+          (plus:SI (match_dup 3) (const_int 8)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 3)))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 3)\n+                  (const_int 4))))])]\n+  \"TARGET_THUMB1 && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%(ia%)\\t%3!, {%1, %2}\"\n+  [(set_attr \"type\" \"load2\")])\n+\n+(define_insn \"*stm2_ia\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (match_operand:SI 3 \"s_register_operand\" \"rk\"))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 3) (const_int 4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 2\"\n+  \"stm%(ia%)\\t%3, {%1, %2}\"\n+  [(set_attr \"type\" \"store2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm2_ia_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 3 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 3) (const_int 8)))\n+     (set (mem:SI (match_dup 3))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 3) (const_int 4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n+  \"stm%(ia%)\\t%3!, {%1, %2}\"\n+  [(set_attr \"type\" \"store2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*thumb_stm2_ia_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 3 \"s_register_operand\" \"+&l\")\n+          (plus:SI (match_dup 3) (const_int 8)))\n+     (set (mem:SI (match_dup 3))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 3) (const_int 4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_THUMB1 && XVECLEN (operands[0], 0) == 3\"\n+  \"stm%(ia%)\\t%3!, {%1, %2}\"\n+  [(set_attr \"type\" \"store2\")])\n+\n+(define_insn \"*ldm2_ib\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_operand:SI 3 \"s_register_operand\" \"rk\")\n+                  (const_int 4))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 3)\n+                  (const_int 8))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 2\"\n+  \"ldm%(ib%)\\t%3, {%1, %2}\"\n+  [(set_attr \"type\" \"load2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm2_ib_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 3 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 3) (const_int 8)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 3)\n+                  (const_int 4))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 3)\n+                  (const_int 8))))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%(ib%)\\t%3!, {%1, %2}\"\n+  [(set_attr \"type\" \"load2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm2_ib\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (plus:SI (match_operand:SI 3 \"s_register_operand\" \"rk\") (const_int 4)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 3) (const_int 8)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 2\"\n+  \"stm%(ib%)\\t%3, {%1, %2}\"\n+  [(set_attr \"type\" \"store2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm2_ib_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 3 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 3) (const_int 8)))\n+     (set (mem:SI (plus:SI (match_dup 3) (const_int 4)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 3) (const_int 8)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"stm%(ib%)\\t%3!, {%1, %2}\"\n+  [(set_attr \"type\" \"store2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm2_da\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_operand:SI 3 \"s_register_operand\" \"rk\")\n+                  (const_int -4))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 3)))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 2\"\n+  \"ldm%(da%)\\t%3, {%1, %2}\"\n+  [(set_attr \"type\" \"load2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm2_da_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 3 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 3) (const_int -8)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 3)\n+                  (const_int -4))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (match_dup 3)))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%(da%)\\t%3!, {%1, %2}\"\n+  [(set_attr \"type\" \"load2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm2_da\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (plus:SI (match_operand:SI 3 \"s_register_operand\" \"rk\") (const_int -4)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (match_dup 3))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 2\"\n+  \"stm%(da%)\\t%3, {%1, %2}\"\n+  [(set_attr \"type\" \"store2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm2_da_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 3 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 3) (const_int -8)))\n+     (set (mem:SI (plus:SI (match_dup 3) (const_int -4)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (match_dup 3))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n+  \"stm%(da%)\\t%3!, {%1, %2}\"\n+  [(set_attr \"type\" \"store2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm2_db\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_operand:SI 3 \"s_register_operand\" \"rk\")\n+                  (const_int -8))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 3)\n+                  (const_int -4))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 2\"\n+  \"ldm%(db%)\\t%3, {%1, %2}\"\n+  [(set_attr \"type\" \"load2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*ldm2_db_update\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 3 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 3) (const_int -8)))\n+     (set (match_operand:SI 1 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 3)\n+                  (const_int -8))))\n+     (set (match_operand:SI 2 \"arm_hard_register_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 3)\n+                  (const_int -4))))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n+  \"ldm%(db%)\\t%3!, {%1, %2}\"\n+  [(set_attr \"type\" \"load2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm2_db\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (mem:SI (plus:SI (match_operand:SI 3 \"s_register_operand\" \"rk\") (const_int -8)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 3) (const_int -4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 2\"\n+  \"stm%(db%)\\t%3, {%1, %2}\"\n+  [(set_attr \"type\" \"store2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*stm2_db_update\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 3 \"s_register_operand\" \"+&rk\")\n+          (plus:SI (match_dup 3) (const_int -8)))\n+     (set (mem:SI (plus:SI (match_dup 3) (const_int -8)))\n+          (match_operand:SI 1 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 3) (const_int -4)))\n+          (match_operand:SI 2 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_32BIT && XVECLEN (operands[0], 0) == 3\"\n+  \"stm%(db%)\\t%3!, {%1, %2}\"\n+  [(set_attr \"type\" \"store2\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 2 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"\")\n+        (match_operand:SI 3 \"memory_operand\" \"\"))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_ldm_seq (operands, 2, false))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 4 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 2 \"memory_operand\" \"\")\n+        (match_dup 0))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"\")\n+        (match_operand:SI 5 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 3 \"memory_operand\" \"\")\n+        (match_dup 1))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_const_stm_seq (operands, 2))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 4 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"\")\n+        (match_operand:SI 5 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 2 \"memory_operand\" \"\")\n+        (match_dup 0))\n+   (set (match_operand:SI 3 \"memory_operand\" \"\")\n+        (match_dup 1))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_const_stm_seq (operands, 2))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 2 \"memory_operand\" \"\")\n+        (match_operand:SI 0 \"s_register_operand\" \"\"))\n+   (set (match_operand:SI 3 \"memory_operand\" \"\")\n+        (match_operand:SI 1 \"s_register_operand\" \"\"))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (gen_stm_seq (operands, 2))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 2 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"\")\n+        (match_operand:SI 3 \"memory_operand\" \"\"))\n+   (parallel\n+     [(set (match_operand:SI 4 \"s_register_operand\" \"\")\n+           (match_operator:SI 5 \"commutative_binary_operator\"\n+            [(match_operand:SI 6 \"s_register_operand\" \"\")\n+             (match_operand:SI 7 \"s_register_operand\" \"\")]))\n+      (clobber (reg:CC CC_REGNUM))])]\n+  \"(((operands[6] == operands[0] && operands[7] == operands[1])\n+     || (operands[7] == operands[0] && operands[6] == operands[1]))\n+    && peep2_reg_dead_p (3, operands[0]) && peep2_reg_dead_p (3, operands[1]))\"\n+  [(parallel\n+    [(set (match_dup 4) (match_op_dup 5 [(match_dup 6) (match_dup 7)]))\n+     (clobber (reg:CC CC_REGNUM))])]\n+{\n+  if (!gen_ldm_seq (operands, 2, true))\n+    FAIL;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+        (match_operand:SI 2 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 1 \"s_register_operand\" \"\")\n+        (match_operand:SI 3 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 4 \"s_register_operand\" \"\")\n+        (match_operator:SI 5 \"commutative_binary_operator\"\n+         [(match_operand:SI 6 \"s_register_operand\" \"\")\n+          (match_operand:SI 7 \"s_register_operand\" \"\")]))]\n+  \"(((operands[6] == operands[0] && operands[7] == operands[1])\n+     || (operands[7] == operands[0] && operands[6] == operands[1]))\n+    && peep2_reg_dead_p (3, operands[0]) && peep2_reg_dead_p (3, operands[1]))\"\n+  [(set (match_dup 4) (match_op_dup 5 [(match_dup 6) (match_dup 7)]))]\n+{\n+  if (!gen_ldm_seq (operands, 2, true))\n+    FAIL;\n+})\n+"}, {"sha": "235545bf22fb11c14066ef9af797e8003022facb", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 59, "deletions": 15, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=3711941045eb2d1723b3530560fe866ee5a82485", "patch": "@@ -206,6 +206,11 @@\n   (and (match_code \"ior,xor,and\")\n        (match_test \"mode == GET_MODE (op)\")))\n \n+;; True for commutative operators\n+(define_special_predicate \"commutative_binary_operator\"\n+  (and (match_code \"ior,xor,and,plus\")\n+       (match_test \"mode == GET_MODE (op)\")))\n+\n ;; True for shift operators.\n (define_special_predicate \"shift_operator\"\n   (and (ior (ior (and (match_code \"mult\")\n@@ -333,20 +338,25 @@\n   (match_code \"parallel\")\n {\n   HOST_WIDE_INT count = XVECLEN (op, 0);\n-  int dest_regno;\n+  unsigned dest_regno;\n   rtx src_addr;\n   HOST_WIDE_INT i = 1, base = 0;\n+  HOST_WIDE_INT offset = 0;\n   rtx elt;\n+  bool addr_reg_loaded = false;\n+  bool update = false;\n \n   if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET)\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || !REG_P (SET_DEST (XVECEXP (op, 0, 0))))\n     return false;\n \n   /* Check to see if this might be a write-back.  */\n   if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)\n     {\n       i++;\n       base = 1;\n+      update = true;\n \n       /* Now check it more carefully.  */\n       if (GET_CODE (SET_DEST (elt)) != REG\n@@ -365,6 +375,15 @@\n \n   dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, i - 1)));\n   src_addr = XEXP (SET_SRC (XVECEXP (op, 0, i - 1)), 0);\n+  if (GET_CODE (src_addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (src_addr, 1)) != CONST_INT)\n+\treturn false;\n+      offset = INTVAL (XEXP (src_addr, 1));\n+      src_addr = XEXP (src_addr, 0);\n+    }\n+  if (!REG_P (src_addr))\n+    return false;\n \n   for (; i < count; i++)\n     {\n@@ -373,26 +392,38 @@\n       if (GET_CODE (elt) != SET\n           || GET_CODE (SET_DEST (elt)) != REG\n           || GET_MODE (SET_DEST (elt)) != SImode\n-          || REGNO (SET_DEST (elt)) != (unsigned int)(dest_regno + i - base)\n+          || REGNO (SET_DEST (elt)) <= dest_regno\n           || GET_CODE (SET_SRC (elt)) != MEM\n           || GET_MODE (SET_SRC (elt)) != SImode\n-          || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n-          || !rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n-          || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n-          || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != (i - base) * 4)\n+          || ((GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n+\t       || !rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n+\t       || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n+\t       || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != offset + (i - base) * 4)\n+\t      && (!REG_P (XEXP (SET_SRC (elt), 0))\n+\t\t  || offset + (i - base) * 4 != 0)))\n         return false;\n+      dest_regno = REGNO (SET_DEST (elt));\n+      if (dest_regno == REGNO (src_addr))\n+        addr_reg_loaded = true;\n     }\n-\n+  /* For Thumb, we only have updating instructions.  If the pattern does\n+     not describe an update, it must be because the address register is\n+     in the list of loaded registers - on the hardware, this has the effect\n+     of overriding the update.  */\n+  if (update && addr_reg_loaded)\n+    return false;\n+  if (TARGET_THUMB1)\n+    return update || addr_reg_loaded;\n   return true;\n })\n \n (define_special_predicate \"store_multiple_operation\"\n   (match_code \"parallel\")\n {\n   HOST_WIDE_INT count = XVECLEN (op, 0);\n-  int src_regno;\n+  unsigned src_regno;\n   rtx dest_addr;\n-  HOST_WIDE_INT i = 1, base = 0;\n+  HOST_WIDE_INT i = 1, base = 0, offset = 0;\n   rtx elt;\n \n   if (count <= 1\n@@ -423,21 +454,34 @@\n   src_regno = REGNO (SET_SRC (XVECEXP (op, 0, i - 1)));\n   dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, i - 1)), 0);\n \n+  if (GET_CODE (dest_addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (dest_addr, 1)) != CONST_INT)\n+\treturn false;\n+      offset = INTVAL (XEXP (dest_addr, 1));\n+      dest_addr = XEXP (dest_addr, 0);\n+    }\n+  if (!REG_P (dest_addr))\n+    return false;\n+\n   for (; i < count; i++)\n     {\n       elt = XVECEXP (op, 0, i);\n \n       if (GET_CODE (elt) != SET\n           || GET_CODE (SET_SRC (elt)) != REG\n           || GET_MODE (SET_SRC (elt)) != SImode\n-          || REGNO (SET_SRC (elt)) != (unsigned int)(src_regno + i - base)\n+          || REGNO (SET_SRC (elt)) <= src_regno\n           || GET_CODE (SET_DEST (elt)) != MEM\n           || GET_MODE (SET_DEST (elt)) != SImode\n-          || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n-          || !rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n-          || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n-          || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != (i - base) * 4)\n+          || ((GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n+\t       || !rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n+\t       || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n+               || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != offset + (i - base) * 4)\n+\t      && (!REG_P (XEXP (SET_DEST (elt), 0))\n+\t\t  || offset + (i - base) * 4 != 0)))\n         return false;\n+      src_regno = REGNO (SET_SRC (elt));\n     }\n \n   return true;"}, {"sha": "136a73961ee44427f8e62aa17e25adf47f5a6c49", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3711941045eb2d1723b3530560fe866ee5a82485", "patch": "@@ -1,3 +1,9 @@\n+2010-08-02  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR target/40457\n+\t* gcc.target/arm/pr40457-1.c: New test.\n+\t* gcc.target/arm/pr40457-2.c: New test.\n+\n 2010-08-01  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44912"}, {"sha": "815fd38f097549168d9c808b53917e7fade9ddb0", "filename": "gcc/testsuite/gcc.target/arm/pr40457-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40457-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40457-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40457-1.c?ref=3711941045eb2d1723b3530560fe866ee5a82485", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"-Os\" }  */\n+/* { dg-do compile } */\n+\n+int bar(int* p)\n+{\n+  int x = p[0] + p[1];\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler \"ldm\" } } */"}, {"sha": "187f7bf7f844f2816978d3c61473f7359053caa3", "filename": "gcc/testsuite/gcc.target/arm/pr40457-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40457-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3711941045eb2d1723b3530560fe866ee5a82485/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40457-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr40457-2.c?ref=3711941045eb2d1723b3530560fe866ee5a82485", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"-O2\" }  */\n+/* { dg-do compile } */\n+\n+void foo(int* p)\n+{\n+  p[0] = 1;\n+  p[1] = 0;\n+}\n+\n+/* { dg-final { scan-assembler \"stm\" } } */"}]}