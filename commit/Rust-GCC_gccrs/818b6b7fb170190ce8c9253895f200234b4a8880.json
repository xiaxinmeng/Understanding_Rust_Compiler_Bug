{"sha": "818b6b7fb170190ce8c9253895f200234b4a8880", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE4YjZiN2ZiMTcwMTkwY2U4YzkyNTM4OTVmMjAwMjM0YjRhODg4MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-06-02T18:38:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-06-02T18:38:04Z"}, "message": "rtl.h (CC0_P): New.\n\n        * rtl.h (CC0_P): New.\n        * gcse.c (cprop_jump): Use it with single_set.  Tweak dump text.\n        (cprop_insn): Allow any mode register; use CC0_P.  CSE out single_set.\n        (bypass_block): Save old dest block for dump text.\n        (bypass_conditional_jumps): Allow any mode register; use CC0_P.\n        Allow only true SET insns, not single_set.\n\nFrom-SVN: r54178", "tree": {"sha": "6b027b33c8c4e85a23edfe4f8ac6fc92a468e261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b027b33c8c4e85a23edfe4f8ac6fc92a468e261"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/818b6b7fb170190ce8c9253895f200234b4a8880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/818b6b7fb170190ce8c9253895f200234b4a8880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/818b6b7fb170190ce8c9253895f200234b4a8880", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/818b6b7fb170190ce8c9253895f200234b4a8880/comments", "author": null, "committer": null, "parents": [{"sha": "61b78ce13ff63efb2f669ec2c872c423ef4ad245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b78ce13ff63efb2f669ec2c872c423ef4ad245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61b78ce13ff63efb2f669ec2c872c423ef4ad245"}], "stats": {"total": 72, "additions": 40, "deletions": 32}, "files": [{"sha": "1bf04eb060aefb00ce1890b459148d01f030cfc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b6b7fb170190ce8c9253895f200234b4a8880/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b6b7fb170190ce8c9253895f200234b4a8880/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=818b6b7fb170190ce8c9253895f200234b4a8880", "patch": "@@ -1,3 +1,12 @@\n+2002-06-02  Richard Henderson  <rth@redhat.com>\n+\n+\t* rtl.h (CC0_P): New.\n+\t* gcse.c (cprop_jump): Use it with single_set.  Tweak dump text.\n+\t(cprop_insn): Allow any mode register; use CC0_P.  CSE out single_set.\n+\t(bypass_block): Save old dest block for dump text.\n+\t(bypass_conditional_jumps): Allow any mode register; use CC0_P.\n+\tAllow only true SET insns, not single_set.\n+\n 2002-06-02  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* diagnostic.c (diagnostic_finish): Rename to output_flush.\n@@ -3338,7 +3347,6 @@ config/alpha:\n \t(CPP_SPEC): Remove ieee defines.\n \t* freebsd.h, netbsd.h: Remove ieee defines and cpp_cpu.\n \n->>>>>>> 1.14095\n 2002-05-14  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (ix86_save_reg): Make regno unsigned."}, {"sha": "cd2481096afaa6c8adee7afb6d0ae2d294f1a912", "filename": "gcc/gcse.c", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b6b7fb170190ce8c9253895f200234b4a8880/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b6b7fb170190ce8c9253895f200234b4a8880/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=818b6b7fb170190ce8c9253895f200234b4a8880", "patch": "@@ -4079,7 +4079,7 @@ find_avail_set (regno, insn)\n /* Subroutine of cprop_insn that tries to propagate constants into\n    JUMP_INSNS.  JUMP must be a conditional jump.  If SETCC is non-NULL\n    it is the instruction that immediately preceeds JUMP, and must be a\n-   single SET of a CC_MODE register.  FROM is what we will try to replace,\n+   single SET of a register.  FROM is what we will try to replace,\n    SRC is the constant we will try to substitute for it.  Returns nonzero\n    if a change was made. */\n \n@@ -4127,7 +4127,7 @@ cprop_jump (bb, setcc, jump, from, src)\n \n #ifdef HAVE_cc0\n   /* Delete the cc0 setter.  */\n-  if (setcc != NULL && SET_DEST (PATTERN (setcc)) == cc0_rtx)\n+  if (setcc != NULL && CC0_P (SET_DEST (single_set (setcc))))\n     delete_insn (setcc);\n #endif\n \n@@ -4137,7 +4137,7 @@ cprop_jump (bb, setcc, jump, from, src)\n   if (gcse_file != NULL)\n     {\n       fprintf (gcse_file,\n-\t       \"CONST-PROP: Replacing reg %d in insn %d with constant \",\n+\t       \"CONST-PROP: Replacing reg %d in jump_insn %d with constant \",\n \t       REGNO (from), INSN_UID (jump));\n       print_rtl (gcse_file, src);\n       fprintf (gcse_file, \"\\n\");\n@@ -4205,20 +4205,19 @@ cprop_insn (bb, insn, alter_jumps)\n       /* Constant propagation.  */\n       if (CONSTANT_P (src))\n \t{\n-\t  /* Check for MODE_CC setting instructions followed by\n+\t  rtx sset;\n+\n+\t  /* Check for reg or cc0 setting instructions followed by\n \t     conditional branch instructions first.  */\n \t  if (alter_jumps\n-\t      && single_set (insn)\n+\t      && (sset = single_set (insn)) != NULL\n \t      && any_condjump_p (NEXT_INSN (insn))\n               && onlyjump_p (NEXT_INSN (insn)))\n \t    {\n-\t      rtx dest = SET_DEST (PATTERN (insn));\n-\t      if ((GET_MODE_CLASS (GET_MODE (dest)) == MODE_CC\n-#ifdef HAVE_cc0\n-\t\t   || dest == cc0_rtx\n-#endif\n-\t\t  ) && cprop_jump (bb, insn, NEXT_INSN (insn),\n-\t\t\t\t   reg_used->reg_rtx, src))\n+\t      rtx dest = SET_DEST (sset);\n+\t      if ((REG_P (dest) || CC0_P (dest))\n+\t\t  && cprop_jump (bb, insn, NEXT_INSN (insn),\n+\t\t\t\t reg_used->reg_rtx, src))\n \t\t{\n \t\t  changed = 1;\n \t\t  break;\n@@ -4430,7 +4429,7 @@ bypass_block (bb, setcc, jump)\n {\n   rtx insn, note;\n   edge e, enext;\n-  int i,change;\n+  int i, change;\n \n   insn = (setcc != NULL) ? setcc : jump;\n \n@@ -4449,7 +4448,7 @@ bypass_block (bb, setcc, jump)\n \t{\n \t  struct reg_use *reg_used = &reg_use_table[i];\n           unsigned int regno = REGNO (reg_used->reg_rtx);\n-\t  basic_block dest;\n+\t  basic_block dest, old_dest;\n           struct expr *set;\n           rtx src, new;\n \n@@ -4480,27 +4479,26 @@ bypass_block (bb, setcc, jump)\n \n \t  /* Once basic block indices are stable, we should be able\n \t     to use redirect_edge_and_branch_force instead.  */\n-\t  if ((dest != NULL) && (dest != e->dest)\n+\t  old_dest = e->dest;\n+\t  if (dest != NULL && dest != old_dest\n \t      && redirect_edge_and_branch (e, dest))\n \t    {\n-\t      /* Copy the MODE_CC setter to the redirected edge.\n+\t      /* Copy the register setter to the redirected edge.\n \t\t Don't copy CC0 setters, as CC0 is dead after jump.  */\n \t      if (setcc)\n \t\t{\n \t\t  rtx pat = PATTERN (setcc);\n-\t\t  if (GET_MODE_CLASS (GET_MODE (SET_DEST (pat))) == MODE_CC)\n+\t\t  if (!CC0_P (SET_DEST (pat)))\n \t\t    insert_insn_on_edge (copy_insn (pat), e);\n \t\t}\n \n \t      if (gcse_file != NULL)\n \t\t{\n-\t\t  fprintf (gcse_file, \"JUMP-BYPASS: Replacing reg %d in \",\n-\t\t\t   regno);\n-\t\t  fprintf (gcse_file, \"insn %d with constant \",\n-\t\t\t   INSN_UID (jump));\n+\t\t  fprintf (gcse_file, \"JUMP-BYPASS: Proved reg %d in jump_insn %d equals constant \",\n+\t\t\t   regno, INSN_UID (jump));\n \t\t  print_rtl (gcse_file, SET_SRC (set->expr));\n \t\t  fprintf (gcse_file, \"\\nBypass edge from %d->%d to %d\\n\",\n-\t\t\t   e->src->index, e->dest->index, dest->index);\n+\t\t\t   e->src->index, old_dest->index, dest->index);\n \t\t}\n \t      change = 1;\n \t      break;\n@@ -4541,19 +4539,14 @@ bypass_conditional_jumps ()\n \t       insn = NEXT_INSN (insn))\n \t    if (GET_CODE (insn) == INSN)\n \t      {\n-\t\trtx set = single_set (insn);\n \t\tif (setcc)\n \t\t  break;\n-\t\tif (!set)\n+\t\tif (GET_CODE (PATTERN (setcc)) != SET)\n \t\t  break;\n \n-\t\tdest = SET_DEST (set);\n-\t\tif (GET_MODE_CLASS (GET_MODE (dest)) == MODE_CC)\n-\t\t  setcc = insn;\n-#ifdef HAVE_cc0\n-\t\telse if (dest == cc0_rtx)\n+\t\tdest = SET_DEST (PATTERN (setcc));\n+\t\tif (REG_P (dest) || CC0_P (dest))\n \t\t  setcc = insn;\n-#endif\n \t\telse\n \t\t  break;\n \t      }\n@@ -4568,7 +4561,7 @@ bypass_conditional_jumps ()\n \t}\n     }\n \n-  /* If we bypassed any MODE_CC setting insns, we inserted a\n+  /* If we bypassed any register setting insns, we inserted a\n      copy on the redirected edge.  These need to be commited.  */\n   if (changed)\n     commit_edge_insertions();"}, {"sha": "b1218d0ef1c1151f04073e4e2a0976e9a6fc96cd", "filename": "gcc/rtl.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b6b7fb170190ce8c9253895f200234b4a8880/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b6b7fb170190ce8c9253895f200234b4a8880/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=818b6b7fb170190ce8c9253895f200234b4a8880", "patch": "@@ -237,6 +237,13 @@ struct rtvec_def {\n /* Predicate yielding nonzero iff X is a barrier insn.  */\n #define BARRIER_P(X) (GET_CODE (X) == BARRIER)\n \n+/* Predicate yielding nonzero iff X is cc0.  */\n+#ifdef HAVE_cc0\n+#define CC0_P(X) ((X) == cc0_rtx)\n+#else\n+#define CC0_P(X) 0\n+#endif\n+\n /* Predicate yielding nonzero iff X is a data for a jump table.  */\n #define JUMP_TABLE_DATA_P(INSN) \\\n   (JUMP_P (INSN) && (GET_CODE (PATTERN (INSN)) == ADDR_VEC || \\"}]}