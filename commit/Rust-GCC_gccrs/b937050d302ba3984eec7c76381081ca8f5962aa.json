{"sha": "b937050d302ba3984eec7c76381081ca8f5962aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkzNzA1MGQzMDJiYTM5ODRlZWM3Yzc2MzgxMDgxY2E4ZjU5NjJhYQ==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2020-01-10T19:32:53Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2020-01-10T19:32:53Z"}, "message": "PR90838: Support ctz idioms\n\nSupport common idioms for count trailing zeroes using an array lookup.\nThe canonical form is array[((x & -x) * C) >> SHIFT] where C is a magic\nconstant which when multiplied by a power of 2 creates a unique value\nin the top 5 or 6 bits.  This is then indexed into a table which maps it\nto the number of trailing zeroes.  When the table is valid, we emit a\nsequence using the target defined value for ctz (0):\n\nint ctz1 (unsigned x)\n{\n  static const char table[32] =\n    {\n      0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,\n      31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9\n    };\n\n  return table[((unsigned)((x & -x) * 0x077CB531U)) >> 27];\n}\n\nIs optimized to:\n\n\trbit\tw0, w0\n\tclz\tw0, w0\n\tand\tw0, w0, 31\n\tret\n\n    gcc/\n\tPR tree-optimization/90838\n\t* tree-ssa-forwprop.c (check_ctz_array): Add new function.\n\t(check_ctz_string): Likewise.\n\t(optimize_count_trailing_zeroes): Likewise.\n\t(simplify_count_trailing_zeroes): Likewise.\n\t(pass_forwprop::execute): Try ctz simplification.\n\t* match.pd: Add matching for ctz idioms.\n\n    testsuite/\n\tPR tree-optimization/90838\n\t* testsuite/gcc.target/aarch64/pr90838.c: New test.\n\nFrom-SVN: r280132", "tree": {"sha": "f169a714f75186893d8fb45d460e280a09e4402e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f169a714f75186893d8fb45d460e280a09e4402e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b937050d302ba3984eec7c76381081ca8f5962aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b937050d302ba3984eec7c76381081ca8f5962aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b937050d302ba3984eec7c76381081ca8f5962aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b937050d302ba3984eec7c76381081ca8f5962aa/comments", "author": null, "committer": null, "parents": [{"sha": "9869896730f3055850034c05c596828d517fa9a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9869896730f3055850034c05c596828d517fa9a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9869896730f3055850034c05c596828d517fa9a2"}], "stats": {"total": 272, "additions": 272, "deletions": 0}, "files": [{"sha": "acdebad529916a0aa9b4b70138f32024678fd1e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b937050d302ba3984eec7c76381081ca8f5962aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b937050d302ba3984eec7c76381081ca8f5962aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b937050d302ba3984eec7c76381081ca8f5962aa", "patch": "@@ -1,3 +1,13 @@\n+2020-01-10  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\tPR tree-optimization/90838\n+\t* tree-ssa-forwprop.c (check_ctz_array): Add new function.\n+\t(check_ctz_string): Likewise.\n+\t(optimize_count_trailing_zeroes): Likewise.\n+\t(simplify_count_trailing_zeroes): Likewise.\n+\t(pass_forwprop::execute): Try ctz simplification.\n+\t* match.pd: Add matching for ctz idioms.\n+\n 2020-01-10  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_invalid_conversion): New function"}, {"sha": "5fee394e7af2f21db9dc4550b8ed014351619052", "filename": "gcc/match.pd", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b937050d302ba3984eec7c76381081ca8f5962aa/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b937050d302ba3984eec7c76381081ca8f5962aa/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=b937050d302ba3984eec7c76381081ca8f5962aa", "patch": "@@ -6152,3 +6152,11 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (simplify\n  (vec_perm vec_same_elem_p@0 @0 @1)\n  @0)\n+\n+/* Match count trailing zeroes for simplify_count_trailing_zeroes in fwprop.\n+   The canonical form is array[((x & -x) * C) >> SHIFT] where C is a magic\n+   constant which when multiplied by a power of 2 contains a unique value\n+   in the top 5 or 6 bits.  This is then indexed into a table which maps it\n+   to the number of trailing zeroes.  */\n+(match (ctz_table_index @1 @2 @3)\n+  (rshift (mult (bit_and:c (negate @1) @1) INTEGER_CST@2) INTEGER_CST@3))"}, {"sha": "42820ef16eaef3b034971355a8401f9280a94245", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b937050d302ba3984eec7c76381081ca8f5962aa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b937050d302ba3984eec7c76381081ca8f5962aa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b937050d302ba3984eec7c76381081ca8f5962aa", "patch": "@@ -1,3 +1,7 @@\n+2020-01-10  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* testsuite/gcc.target/aarch64/pr90838.c: New test.\n+\n 2020-01-10  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n \n \t* g++.target/aarch64/bfloat_cpp_typecheck.C: New test."}, {"sha": "bff3144c0d1b3984016e5a404e986eae785c73ed", "filename": "gcc/testsuite/gcc.target/aarch64/pr90838.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b937050d302ba3984eec7c76381081ca8f5962aa/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr90838.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b937050d302ba3984eec7c76381081ca8f5962aa/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr90838.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr90838.c?ref=b937050d302ba3984eec7c76381081ca8f5962aa", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+int ctz1 (unsigned x)\n+{\n+  static const char table[32] =\n+    {\n+      0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,\n+      31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9\n+    };\n+\n+  return table[((unsigned)((x & -x) * 0x077CB531U)) >> 27];\n+}\n+\n+int ctz2 (unsigned x)\n+{\n+  const int u = 0;\n+  static short table[64] =\n+    {\n+      32, 0, 1,12, 2, 6, u,13, 3, u, 7, u, u, u, u,14,\n+      10, 4, u, u, 8, u, u,25, u, u, u, u, u,21,27,15,\n+      31,11, 5, u, u, u, u, u, 9, u, u,24, u, u,20,26,\n+      30, u, u, u, u,23, u,19,29, u,22,18,28,17,16, u\n+    };\n+\n+  x = (x & -x) * 0x0450FBAF;\n+  return table[x >> 26];\n+}\n+\n+int ctz3 (unsigned x)\n+{\n+  static int table[32] =\n+    {\n+      0, 1, 2,24, 3,19, 6,25, 22, 4,20,10,16, 7,12,26,\n+      31,23,18, 5,21, 9,15,11,30,17, 8,14,29,13,28,27\n+    };\n+\n+  if (x == 0) return 32;\n+  x = (x & -x) * 0x04D7651F;\n+  return table[x >> 27];\n+}\n+\n+static const unsigned long long magic = 0x03f08c5392f756cdULL;\n+\n+static const char table[64] = {\n+     0,  1, 12,  2, 13, 22, 17,  3,\n+    14, 33, 23, 36, 18, 58, 28,  4,\n+    62, 15, 34, 26, 24, 48, 50, 37,\n+    19, 55, 59, 52, 29, 44, 39,  5,\n+    63, 11, 21, 16, 32, 35, 57, 27,\n+    61, 25, 47, 49, 54, 51, 43, 38,\n+    10, 20, 31, 56, 60, 46, 53, 42,\n+     9, 30, 45, 41,  8, 40,  7,  6,\n+};\n+\n+int ctz4 (unsigned long x)\n+{\n+  unsigned long lsb = x & -x;\n+  return table[(lsb * magic) >> 58];\n+}\n+\n+/* { dg-final { scan-assembler-times \"clz\\t\" 4 } } */\n+/* { dg-final { scan-assembler-times \"and\\t\" 2 } } */\n+/* { dg-final { scan-assembler-not \"cmp\\t.*0\" } } */"}, {"sha": "aced6eb2d9139cae277593022415bc5efdf45175", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b937050d302ba3984eec7c76381081ca8f5962aa/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b937050d302ba3984eec7c76381081ca8f5962aa/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=b937050d302ba3984eec7c76381081ca8f5962aa", "patch": "@@ -48,6 +48,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optabs-tree.h\"\n #include \"tree-vector-builder.h\"\n #include \"vec-perm-indices.h\"\n+#include \"internal-fn.h\"\n+#include \"cgraph.h\"\n \n /* This pass propagates the RHS of assignment statements into use\n    sites of the LHS of the assignment.  It's basically a specialized\n@@ -1778,6 +1780,188 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n   return true;\n }\n \n+\n+/* Check whether an array contains a valid ctz table.  */\n+static bool\n+check_ctz_array (tree ctor, unsigned HOST_WIDE_INT mulc,\n+\t\t HOST_WIDE_INT &zero_val, unsigned shift, unsigned bits)\n+{\n+  tree elt, idx;\n+  unsigned HOST_WIDE_INT i, mask;\n+  unsigned matched = 0;\n+\n+  mask = ((HOST_WIDE_INT_1U << (bits - shift)) - 1) << shift;\n+\n+  zero_val = 0;\n+\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), i, idx, elt)\n+    {\n+      if (TREE_CODE (idx) != INTEGER_CST || TREE_CODE (elt) != INTEGER_CST)\n+\treturn false;\n+      if (i > bits * 2)\n+\treturn false;\n+\n+      unsigned HOST_WIDE_INT index = tree_to_shwi (idx);\n+      HOST_WIDE_INT val = tree_to_shwi (elt);\n+\n+      if (index == 0)\n+\t{\n+\t  zero_val = val;\n+\t  matched++;\n+\t}\n+\n+      if (val >= 0 && val < bits && (((mulc << val) & mask) >> shift) == index)\n+\tmatched++;\n+\n+      if (matched > bits)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Check whether a string contains a valid ctz table.  */\n+static bool\n+check_ctz_string (tree string, unsigned HOST_WIDE_INT mulc,\n+\t\t  HOST_WIDE_INT &zero_val, unsigned shift, unsigned bits)\n+{\n+  unsigned HOST_WIDE_INT len = TREE_STRING_LENGTH (string);\n+  unsigned HOST_WIDE_INT mask;\n+  unsigned matched = 0;\n+  const unsigned char *p = (const unsigned char *) TREE_STRING_POINTER (string);\n+\n+  if (len < bits || len > bits * 2)\n+    return false;\n+\n+  mask = ((HOST_WIDE_INT_1U << (bits - shift)) - 1) << shift;\n+\n+  zero_val = p[0];\n+\n+  for (unsigned i = 0; i < len; i++)\n+    if (p[i] < bits && (((mulc << p[i]) & mask) >> shift) == i)\n+      matched++;\n+\n+  return matched == bits;\n+}\n+\n+/* Recognize count trailing zeroes idiom.\n+   The canonical form is array[((x & -x) * C) >> SHIFT] where C is a magic\n+   constant which when multiplied by a power of 2 creates a unique value\n+   in the top 5 or 6 bits.  This is then indexed into a table which maps it\n+   to the number of trailing zeroes.  Array[0] is returned so the caller can\n+   emit an appropriate sequence depending on whether ctz (0) is defined on\n+   the target.  */\n+static bool\n+optimize_count_trailing_zeroes (tree array_ref, tree x, tree mulc,\n+\t\t\t\ttree tshift, HOST_WIDE_INT &zero_val)\n+{\n+  tree type = TREE_TYPE (array_ref);\n+  tree array = TREE_OPERAND (array_ref, 0);\n+\n+  gcc_assert (TREE_CODE (mulc) == INTEGER_CST);\n+  gcc_assert (TREE_CODE (tshift) == INTEGER_CST);\n+\n+  tree input_type = TREE_TYPE (x);\n+  unsigned input_bits = tree_to_shwi (TYPE_SIZE (input_type));\n+\n+  /* Check the array is not wider than integer type and the input is a 32-bit\n+     or 64-bit type.  */\n+  if (TYPE_PRECISION (type) > 32)\n+    return false;\n+  if (input_bits != 32 && input_bits != 64)\n+    return false;\n+\n+  if (!direct_internal_fn_supported_p (IFN_CTZ, input_type, OPTIMIZE_FOR_BOTH))\n+    return false;\n+\n+  /* Check the lower bound of the array is zero.  */\n+  tree low = array_ref_low_bound (array_ref);\n+  if (!low || !integer_zerop (low))\n+    return false;\n+\n+  unsigned shiftval = tree_to_uhwi (tshift);\n+\n+  /* Check the shift extracts the top 5..7 bits.  */\n+  if (shiftval < input_bits - 7 || shiftval > input_bits - 5)\n+    return false;\n+\n+  tree ctor = ctor_for_folding (array);\n+  if (!ctor)\n+    return false;\n+\n+  unsigned HOST_WIDE_INT val = tree_to_uhwi (mulc);\n+\n+  if (TREE_CODE (ctor) == CONSTRUCTOR)\n+    return check_ctz_array (ctor, val, zero_val, shiftval, input_bits);\n+\n+  if (TREE_CODE (ctor) == STRING_CST)\n+    return check_ctz_string (ctor, val, zero_val, shiftval, input_bits);\n+\n+  return false;\n+}\n+\n+/* Match.pd function to match the ctz expression.  */\n+extern bool gimple_ctz_table_index (tree, tree *, tree (*)(tree));\n+\n+static bool\n+simplify_count_trailing_zeroes (gimple_stmt_iterator *gsi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  tree array_ref = gimple_assign_rhs1 (stmt);\n+  tree res_ops[3];\n+  HOST_WIDE_INT zero_val;\n+\n+  gcc_checking_assert (TREE_CODE (array_ref) == ARRAY_REF);\n+\n+  if (!gimple_ctz_table_index (TREE_OPERAND (array_ref, 1), &res_ops[0], NULL))\n+    return false;\n+\n+  if (optimize_count_trailing_zeroes (array_ref, res_ops[0],\n+\t\t\t\t      res_ops[1], res_ops[2], zero_val))\n+    {\n+      tree type = TREE_TYPE (res_ops[0]);\n+      HOST_WIDE_INT ctzval;\n+      HOST_WIDE_INT type_size = tree_to_shwi (TYPE_SIZE (type));\n+      bool zero_ok = CTZ_DEFINED_VALUE_AT_ZERO (TYPE_MODE (type), ctzval) == 2;\n+\n+      /* Skip if there is no value defined at zero, or if we can't easily\n+\t return the correct value for zero.  */\n+      if (!zero_ok)\n+\treturn false;\n+      if (zero_val != ctzval && !(zero_val == 0 && ctzval == type_size))\n+\treturn false;\n+\n+      gimple_seq seq = NULL;\n+      gimple *g;\n+      gcall *call = gimple_build_call_internal (IFN_CTZ, 1, res_ops[0]);\n+      gimple_set_location (call, gimple_location (stmt));\n+      gimple_set_lhs (call, make_ssa_name (integer_type_node));\n+      gimple_seq_add_stmt (&seq, call);\n+\n+      tree prev_lhs = gimple_call_lhs (call);\n+\n+      /* Emit ctz (x) & 31 if ctz (0) is 32 but we need to return 0.  */\n+      if (zero_val == 0 && ctzval == type_size)\n+\t{\n+\t  g = gimple_build_assign (make_ssa_name (integer_type_node),\n+\t\t\t\t   BIT_AND_EXPR, prev_lhs,\n+\t\t\t\t   build_int_cst (integer_type_node,\n+\t\t\t\t\t\t  type_size - 1));\n+\t  gimple_set_location (g, gimple_location (stmt));\n+\t  gimple_seq_add_stmt (&seq, g);\n+\t  prev_lhs = gimple_assign_lhs (g);\n+\t}\n+\n+      g = gimple_build_assign (gimple_assign_lhs (stmt), NOP_EXPR, prev_lhs);\n+      gimple_seq_add_stmt (&seq, g);\n+      gsi_replace_with_seq (gsi, seq, true);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n /* Combine an element access with a shuffle.  Returns true if there were\n    any changes made, else it returns false.  */\n  \n@@ -2874,6 +3058,8 @@ pass_forwprop::execute (function *fun)\n \t\t    else if (code == CONSTRUCTOR\n \t\t\t     && TREE_CODE (TREE_TYPE (rhs1)) == VECTOR_TYPE)\n \t\t      changed = simplify_vector_constructor (&gsi);\n+\t\t    else if (code == ARRAY_REF)\n+\t\t      changed = simplify_count_trailing_zeroes (&gsi);\n \t\t    break;\n \t\t  }\n "}]}