{"sha": "305caf424d1720f082b9cdfc072d29ae553afebc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA1Y2FmNDI0ZDE3MjBmMDgyYjljZGZjMDcyZDI5YWU1NTNhZmViYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-18T09:28:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-18T09:28:45Z"}, "message": "[multiple changes]\n\n2010-06-18  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_eval.adb (Test_In_Range): New subprogram, factoring duplicated\n\tcode between...\n\t(Is_In_Range, Is_Out_Of_Range): Reimplement in terms of call to\n\tTest_In_Range.\n\n2010-06-18  Robert Dewar  <dewar@adacore.com>\n\n\t* sprint.adb: Minor change in output format for expression wi actions.\n\t* par-ch3.adb: Minor code reorganization.  Minor reformatting.\n\t* sem_ch5.adb: Minor comment fix.\n\n2010-06-18  Robert Dewar  <dewar@adacore.com>\n\n\t* debug.adb: New debug flag -gnatd.L to control\n\tBack_End_Handles_Limited_Types.\n\t* exp_ch4.adb (Expand_N_Conditional_Expression): Let back end handle\n\tlimited case if Back_End_Handles_Limited_Types is True.\n\t(Expand_N_Conditional_Expression): Use N_Expression_With_Actions to\n\tsimplify expansion if Use_Expression_With_Actions is True.\n\t* gnat1drv.adb (Adjust_Global_Switches): Set\n\tBack_End_Handles_Limited_Types.\n\t* opt.ads (Back_End_Handles_Limited_Types): New flag.\n\n2010-06-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Rewrite_Operator_As_Call): Do not rewrite user-defined\n\tintrinsic operator if expansion is not enabled, because in an\n\tinstantiation the original operator must be present to verify the\n\tlegality of the operation.\n\nFrom-SVN: r160969", "tree": {"sha": "6009e90ea7479e11dd52df04ad0e7acb8b2ec5d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6009e90ea7479e11dd52df04ad0e7acb8b2ec5d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/305caf424d1720f082b9cdfc072d29ae553afebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305caf424d1720f082b9cdfc072d29ae553afebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/305caf424d1720f082b9cdfc072d29ae553afebc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305caf424d1720f082b9cdfc072d29ae553afebc/comments", "author": null, "committer": null, "parents": [{"sha": "e1be7706e0d50dedc47cd7302d3a39daff1970b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1be7706e0d50dedc47cd7302d3a39daff1970b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1be7706e0d50dedc47cd7302d3a39daff1970b0"}], "stats": {"total": 773, "additions": 475, "deletions": 298}, "files": [{"sha": "4f6d00292f408bb7e732247a09e85ce28dd6071f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=305caf424d1720f082b9cdfc072d29ae553afebc", "patch": "@@ -1,3 +1,35 @@\n+2010-06-18  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_eval.adb (Test_In_Range): New subprogram, factoring duplicated\n+\tcode between...\n+\t(Is_In_Range, Is_Out_Of_Range): Reimplement in terms of call to\n+\tTest_In_Range.\n+\n+2010-06-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sprint.adb: Minor change in output format for expression wi actions.\n+\t* par-ch3.adb: Minor code reorganization.  Minor reformatting.\n+\t* sem_ch5.adb: Minor comment fix.\n+\n+2010-06-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* debug.adb: New debug flag -gnatd.L to control\n+\tBack_End_Handles_Limited_Types.\n+\t* exp_ch4.adb (Expand_N_Conditional_Expression): Let back end handle\n+\tlimited case if Back_End_Handles_Limited_Types is True.\n+\t(Expand_N_Conditional_Expression): Use N_Expression_With_Actions to\n+\tsimplify expansion if Use_Expression_With_Actions is True.\n+\t* gnat1drv.adb (Adjust_Global_Switches): Set\n+\tBack_End_Handles_Limited_Types.\n+\t* opt.ads (Back_End_Handles_Limited_Types): New flag.\n+\n+2010-06-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Rewrite_Operator_As_Call): Do not rewrite user-defined\n+\tintrinsic operator if expansion is not enabled, because in an\n+\tinstantiation the original operator must be present to verify the\n+\tlegality of the operation.\n+\n 2010-06-18  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_disp.adb, sem_ch12.adb: Minor reformatting"}, {"sha": "cc1dc5b64a7a047f2bfceea773c03fd0430d4bbc", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=305caf424d1720f082b9cdfc072d29ae553afebc", "patch": "@@ -76,7 +76,7 @@ package body Debug is\n    --  dJ   Output debugging trace info for JGNAT (Java VM version of GNAT)\n    --  dK   Kill all error messages\n    --  dL   Output trace information on elaboration checking\n-   --  dM   Asssume all variables are modified (no current values)\n+   --  dM   Assume all variables are modified (no current values)\n    --  dN   No file name information in exception messages\n    --  dO   Output immediate error messages\n    --  dP   Do not check for controlled objects in preelaborable packages\n@@ -129,7 +129,7 @@ package body Debug is\n    --  d.I  SCIL generation mode\n    --  d.J  Parallel SCIL generation mode\n    --  d.K\n-   --  d.L\n+   --  d.L  Depend on back end for limited types in conditional expressions\n    --  d.M\n    --  d.N\n    --  d.O  Dump internal SCO tables\n@@ -567,6 +567,11 @@ package body Debug is\n    --       This means in particular not writing the same files under the\n    --       same directory.\n \n+   --  d.L  Normally the front end generates special expansion for conditional\n+   --       expressions of a limited type. This debug flag removes this special\n+   --       case expansion, leaving it up to the back end to handle conditional\n+   --       expressions correctly.\n+\n    --  d.O  Dump internal SCO tables. Before outputting the SCO information to\n    --       the ALI file, the internal SCO tables (SCO_Table/SCO_Unit_Table)\n    --       are dumped for debugging purposes."}, {"sha": "821103c79f62ea81cb615838572edf36cc1b391f", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 102, "deletions": 61, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=305caf424d1720f082b9cdfc072d29ae553afebc", "patch": "@@ -3882,7 +3882,7 @@ package body Exp_Ch4 is\n    -- Expand_N_Conditional_Expression --\n    -------------------------------------\n \n-   --  Expand into expression actions if then/else actions present\n+   --  Deal with limited types and expression actions\n \n    procedure Expand_N_Conditional_Expression (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n@@ -3898,26 +3898,11 @@ package body Exp_Ch4 is\n       P_Decl : Node_Id;\n \n    begin\n-      --  If either then or else actions are present, then given:\n+      --  If the type is limited or unconstrained, we expand as follows to\n+      --  avoid any possibility of improper copies.\n \n-      --     if cond then then-expr else else-expr end\n-\n-      --  we insert the following sequence of actions (using Insert_Actions):\n-\n-      --      Cnn : typ;\n-      --      if cond then\n-      --         <<then actions>>\n-      --         Cnn := then-expr;\n-      --      else\n-      --         <<else actions>>\n-      --         Cnn := else-expr\n-      --      end if;\n-\n-      --  and replace the conditional expression by a reference to Cnn\n-\n-      --  If the type is limited or unconstrained, the above expansion is\n-      --  not legal, because it involves either an uninitialized object\n-      --  or an illegal assignment. Instead, we generate:\n+      --  Note: it may be possible to avoid this special processing if the\n+      --  back end uses its own mechanisms for handling by-reference types ???\n \n       --      type Ptr is access all Typ;\n       --      Cnn : Ptr;\n@@ -3931,7 +3916,12 @@ package body Exp_Ch4 is\n \n       --  and replace the conditional expresion by a reference to Cnn.all.\n \n-      if Is_By_Reference_Type (Typ) then\n+      --  This special case can be skipped if the back end handles limited\n+      --  types properly and ensures that no incorrect copies are made.\n+\n+      if Is_By_Reference_Type (Typ)\n+        and then not Back_End_Handles_Limited_Types\n+      then\n          Cnn := Make_Temporary (Loc, 'C', N);\n \n          P_Decl :=\n@@ -3979,40 +3969,82 @@ package body Exp_Ch4 is\n       --  associated with either branch.\n \n       elsif Present (Then_Actions (N)) or else Present (Else_Actions (N)) then\n-         Cnn := Make_Temporary (Loc, 'C', N);\n \n-         Decl :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Cnn,\n-             Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+         --  We have two approaches to handling this. If we are allowed to use\n+         --  N_Expression_With_Actions, then we can just wrap the actions into\n+         --  the appropriate expression.\n+\n+         if Use_Expression_With_Actions then\n+            if Present (Then_Actions (N)) then\n+               Rewrite (Thenx,\n+                 Make_Expression_With_Actions (Sloc (Thenx),\n+                   Actions    => Then_Actions (N),\n+                   Expression => Relocate_Node (Thenx)));\n+               Analyze_And_Resolve (Thenx, Typ);\n+            end if;\n \n-         New_If :=\n-           Make_Implicit_If_Statement (N,\n-             Condition => Relocate_Node (Cond),\n+            if Present (Else_Actions (N)) then\n+               Rewrite (Elsex,\n+                 Make_Expression_With_Actions (Sloc (Elsex),\n+                   Actions    => Else_Actions (N),\n+                   Expression => Relocate_Node (Elsex)));\n+               Analyze_And_Resolve (Elsex, Typ);\n+            end if;\n \n-             Then_Statements => New_List (\n-               Make_Assignment_Statement (Sloc (Thenx),\n-                 Name       => New_Occurrence_Of (Cnn, Sloc (Thenx)),\n-                 Expression => Relocate_Node (Thenx))),\n+            return;\n \n-             Else_Statements => New_List (\n-               Make_Assignment_Statement (Sloc (Elsex),\n-                 Name       => New_Occurrence_Of (Cnn, Sloc (Elsex)),\n-                 Expression => Relocate_Node (Elsex))));\n+            --  if we can't use N_Expression_With_Actions nodes, then we insert\n+            --  the following sequence of actions (using Insert_Actions):\n \n-         Set_Assignment_OK (Name (First (Then_Statements (New_If))));\n-         Set_Assignment_OK (Name (First (Else_Statements (New_If))));\n+            --      Cnn : typ;\n+            --      if cond then\n+            --         <<then actions>>\n+            --         Cnn := then-expr;\n+            --      else\n+            --         <<else actions>>\n+            --         Cnn := else-expr\n+            --      end if;\n \n-         New_N := New_Occurrence_Of (Cnn, Loc);\n+            --  and replace the conditional expression by a reference to Cnn\n \n-      else\n-         --  No expansion needed, gigi handles it like a C conditional\n-         --  expression.\n+         else\n+            Cnn := Make_Temporary (Loc, 'C', N);\n+\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Cnn,\n+                Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+\n+            New_If :=\n+              Make_Implicit_If_Statement (N,\n+                Condition       => Relocate_Node (Cond),\n+\n+                Then_Statements => New_List (\n+                  Make_Assignment_Statement (Sloc (Thenx),\n+                    Name       => New_Occurrence_Of (Cnn, Sloc (Thenx)),\n+                    Expression => Relocate_Node (Thenx))),\n+\n+                Else_Statements => New_List (\n+                  Make_Assignment_Statement (Sloc (Elsex),\n+                    Name       => New_Occurrence_Of (Cnn, Sloc (Elsex)),\n+                    Expression => Relocate_Node (Elsex))));\n \n+            Set_Assignment_OK (Name (First (Then_Statements (New_If))));\n+            Set_Assignment_OK (Name (First (Else_Statements (New_If))));\n+\n+            New_N := New_Occurrence_Of (Cnn, Loc);\n+         end if;\n+\n+         --  If no actions then no expansion needed, gigi will handle it using\n+         --  the same approach as a C conditional expression.\n+\n+      else\n          return;\n       end if;\n \n-      --  Move the SLOC of the parent If statement to the newly created one and\n+      --  Fall through here for either the limited expansion, or the case of\n+      --  inserting actions for non-limited types. In both these cases, we must\n+      --  move the SLOC of the parent If statement to the newly created one and\n       --  change it to the SLOC of the expression which, after expansion, will\n       --  correspond to what is being evaluated.\n \n@@ -4143,7 +4175,8 @@ package body Exp_Ch4 is\n          Analyze_And_Resolve (N, Rtyp);\n \n          Error_Msg_N (\"?explicit membership test may be optimized away\", N);\n-         Error_Msg_N (\"\\?use ''Valid attribute instead\", N);\n+         Error_Msg_N -- CODEFIX\n+           (\"\\?use ''Valid attribute instead\", N);\n          return;\n       end Substitute_Valid_Check;\n \n@@ -4267,8 +4300,10 @@ package body Exp_Ch4 is\n \n             if Lcheck = LT or else Ucheck = GT then\n                if Warn1 then\n-                  Error_Msg_N (\"?range test optimized away\", N);\n-                  Error_Msg_N (\"\\?value is known to be out of range\", N);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"?range test optimized away\", N);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"\\?value is known to be out of range\", N);\n                end if;\n \n                Rewrite (N,\n@@ -4283,8 +4318,10 @@ package body Exp_Ch4 is\n \n             elsif Lcheck in Compare_GE and then Ucheck in Compare_LE then\n                if Warn1 then\n-                  Error_Msg_N (\"?range test optimized away\", N);\n-                  Error_Msg_N (\"\\?value is known to be in range\", N);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"?range test optimized away\", N);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"\\?value is known to be in range\", N);\n                end if;\n \n                Rewrite (N,\n@@ -4300,8 +4337,10 @@ package body Exp_Ch4 is\n \n             elsif Lcheck in Compare_GE then\n                if Warn2 and then not In_Instance then\n-                  Error_Msg_N (\"?lower bound test optimized away\", Lo);\n-                  Error_Msg_N (\"\\?value is known to be in range\", Lo);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"?lower bound test optimized away\", Lo);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"\\?value is known to be in range\", Lo);\n                end if;\n \n                Rewrite (N,\n@@ -4318,8 +4357,10 @@ package body Exp_Ch4 is\n \n             elsif Ucheck in Compare_LE then\n                if Warn2 and then not In_Instance then\n-                  Error_Msg_N (\"?upper bound test optimized away\", Hi);\n-                  Error_Msg_N (\"\\?value is known to be in range\", Hi);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"?upper bound test optimized away\", Hi);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"\\?value is known to be in range\", Hi);\n                end if;\n \n                Rewrite (N,\n@@ -4343,25 +4384,25 @@ package body Exp_Ch4 is\n                --  Result is out of range for valid value\n \n                if Lcheck = LT or else Ucheck = GT then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"?value can only be in range if it is invalid\", N);\n \n                --  Result is in range for valid value\n \n                elsif Lcheck in Compare_GE and then Ucheck in Compare_LE then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"?value can only be out of range if it is invalid\", N);\n \n                --  Lower bound check succeeds if value is valid\n \n                elsif Warn2 and then Lcheck in Compare_GE then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"?lower bound check only fails if it is invalid\", Lo);\n \n                --  Upper bound  check succeeds if value is valid\n \n                elsif Warn2 and then Ucheck in Compare_LE then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"?upper bound check only fails for invalid values\", Hi);\n                end if;\n             end if;\n@@ -9692,7 +9733,7 @@ package body Exp_Ch4 is\n                  and then Is_Integer_Type (Etype (Left_Opnd (N)))\n                  and then not Has_Warnings_Off (Etype (Left_Opnd (N)))\n                then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"can never be greater than, could replace by \"\"'=\"\"?\", N);\n                   Warning_Generated := True;\n                end if;\n@@ -9717,7 +9758,7 @@ package body Exp_Ch4 is\n                  and then Is_Integer_Type (Etype (Left_Opnd (N)))\n                  and then not Has_Warnings_Off (Etype (Left_Opnd (N)))\n                then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"can never be less than, could replace by \"\"'=\"\"?\", N);\n                   Warning_Generated := True;\n                end if;\n@@ -9755,11 +9796,11 @@ package body Exp_Ch4 is\n               and then not In_Instance\n             then\n                if True_Result then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"condition can only be False if invalid values present?\",\n                      N);\n                elsif False_Result then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"condition can only be True if invalid values present?\",\n                      N);\n                end if;"}, {"sha": "47f877412b02ecd00ba5a3e94d65035146cdf944", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=305caf424d1720f082b9cdfc072d29ae553afebc", "patch": "@@ -359,6 +359,30 @@ procedure Gnat1drv is\n       else\n          Use_Expression_With_Actions := False;\n       end if;\n+\n+      --  Set switch indicating if back end can handle limited types, and\n+      --  guarantee that no incorrect copies are made (e.g. in the context\n+      --  of a conditional expression).\n+\n+      --  Debug flag -gnatd.L decisively sets usage on\n+\n+      if Debug_Flag_Dot_XX then\n+         Back_End_Handles_Limited_Types := True;\n+\n+      --  If no debug flag, usage off for AAMP, VM, SCIL cases\n+\n+      elsif AAMP_On_Target\n+        or else VM_Target /= No_VM\n+        or else Generate_SCIL\n+      then\n+         Back_End_Handles_Limited_Types := False;\n+\n+         --  Otherwise normal gcc back end, for now still turn flag off by\n+         --  default, since we have not verified proper back end handling.\n+\n+      else\n+         Back_End_Handles_Limited_Types := False;\n+      end if;\n    end Adjust_Global_Switches;\n \n    --------------------"}, {"sha": "50625ec9a220e2a4e713d60185a23a97bb6af4ce", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=305caf424d1720f082b9cdfc072d29ae553afebc", "patch": "@@ -172,6 +172,15 @@ package Opt is\n    --  also set true if certain Unchecked_Conversion instantiations require\n    --  checking based on annotated values.\n \n+   Back_End_Handles_Limited_Types : Boolean;\n+   --  This flag is set true if the back end can properly handle limited or\n+   --  other by reference types, and avoid copies. If this flag is False, then\n+   --  the front end does special expansion for conditional expressions to make\n+   --  sure that no copy occurs. If the flag is True, then the expansion for\n+   --  conditional expressions relies on the back end properly handling things.\n+   --  Currently the default is False for all cases (set in gnat1drv). The\n+   --  default can be modified using -gnatd.L (sets the flag True).\n+\n    Bind_Alternate_Main_Name : Boolean := False;\n    --  GNATBIND\n    --  True if main should be called Alternate_Main_Name.all.\n@@ -1239,12 +1248,12 @@ package Opt is\n    --  Set to True if -h (-gnath for the compiler) switch encountered\n    --  requesting usage information\n \n-   Use_Expression_With_Actions : Boolean := False;\n+   Use_Expression_With_Actions : Boolean;\n    --  The N_Expression_With_Actions node has been introduced relatively\n    --  recently, and not all back ends are prepared to handle it yet. So\n    --  we use this flag to suppress its use during a transitional period.\n-   --  Currently the default is False for all cases except the standard\n-   --  GCC back end. The default can be modified using -gnatd.X/-gnatd.Y.\n+   --  Currently the default is False for all cases (set in gnat1drv).\n+   --  The default can be modified using -gnatd.X/-gnatd.Y.\n \n    Use_Pragma_Linker_Constructor : Boolean := False;\n    --  GNATBIND"}, {"sha": "78aa3d1797725648ff04e3e8ede57dda44acb2da", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 82, "deletions": 48, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=305caf424d1720f082b9cdfc072d29ae553afebc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -125,7 +125,7 @@ package body Ch3 is\n       elsif Nkind_In (N, N_In, N_Not_In)\n         and then Paren_Count (N) = 0\n       then\n-         Error_Msg_N\n+         Error_Msg_N -- CODEFIX???\n            (\"|this expression must be parenthesized!\", N);\n          Error_Msg_N\n            (\"\\|since extensions (and set notation) are allowed\", N);\n@@ -385,7 +385,8 @@ package body Ch3 is\n          Scan; -- past = used in place of IS\n \n       elsif Token = Tok_Renames then\n-         Error_Msg_SC (\"RENAMES should be IS\");\n+         Error_Msg_SC  -- CODEFIX\n+           (\"RENAMES should be IS\");\n          Scan; -- past RENAMES used in place of IS\n \n       else\n@@ -440,7 +441,8 @@ package body Ch3 is\n            or else Token = Tok_Record\n            or else Token = Tok_Null\n          then\n-            Error_Msg_AP (\"TAGGED expected\");\n+            Error_Msg_AP -- CODEFIX???\n+              (\"TAGGED expected\");\n          end if;\n       end if;\n \n@@ -455,7 +457,8 @@ package body Ch3 is\n       --  Special check for misuse of Aliased\n \n       if Token = Tok_Aliased or else Token_Name = Name_Aliased then\n-         Error_Msg_SC (\"ALIASED not allowed in type definition\");\n+         Error_Msg_SC -- CODEFIX???\n+           (\"ALIASED not allowed in type definition\");\n          Scan; -- past ALIASED\n       end if;\n \n@@ -677,7 +680,8 @@ package body Ch3 is\n                   elsif Abstract_Present\n                     and then Prev_Token /= Tok_Tagged\n                   then\n-                     Error_Msg_SP (\"TAGGED expected\");\n+                     Error_Msg_SP -- CODEFIX???\n+                       (\"TAGGED expected\");\n                   end if;\n \n                   Typedef_Node := P_Record_Definition;\n@@ -812,7 +816,7 @@ package body Ch3 is\n                         if Nkind (Typedef_Node) =\n                           N_Derived_Type_Definition\n                         then\n-                           Error_Msg_N\n+                           Error_Msg_N -- CODEFIX???\n                              (\"SYNCHRONIZED not allowed for record extension\",\n                               Typedef_Node);\n                         else\n@@ -827,7 +831,8 @@ package body Ch3 is\n \n                   else\n                      if Token /= Tok_Interface then\n-                        Error_Msg_SC (\"NEW or INTERFACE expected\");\n+                        Error_Msg_SC -- CODEFIX???\n+                          (\"NEW or INTERFACE expected\");\n                      end if;\n \n                      Typedef_Node :=\n@@ -918,7 +923,8 @@ package body Ch3 is\n             Set_Abstract_Present (Typedef_Node, Abstract_Present);\n \n          elsif Abstract_Present then\n-            Error_Msg (\"ABSTRACT not allowed here, ignored\", Abstract_Loc);\n+            Error_Msg -- CODEFIX???\n+              (\"ABSTRACT not allowed here, ignored\", Abstract_Loc);\n          end if;\n \n          Decl_Node := New_Node (N_Full_Type_Declaration, Type_Loc);\n@@ -972,7 +978,8 @@ package body Ch3 is\n       TF_Is;\n \n       if Token = Tok_New then\n-         Error_Msg_SC (\"NEW ignored (only allowed in type declaration)\");\n+         Error_Msg_SC  -- CODEFIX\n+           (\"NEW ignored (only allowed in type declaration)\");\n          Scan; -- past NEW\n       end if;\n \n@@ -1034,11 +1041,13 @@ package body Ch3 is\n             end if;\n \n          else\n-            Error_Msg_SP (\"NULL expected\");\n+            Error_Msg_SP -- CODEFIX???\n+              (\"NULL expected\");\n          end if;\n \n          if Token = Tok_New then\n-            Error_Msg (\"`NOT NULL` comes after NEW, not before\", Not_Loc);\n+            Error_Msg -- CODEFIX???\n+              (\"`NOT NULL` comes after NEW, not before\", Not_Loc);\n          end if;\n \n          return True;\n@@ -1090,7 +1099,8 @@ package body Ch3 is\n          return Subtype_Mark;\n       else\n          if Not_Null_Present then\n-            Error_Msg_SP (\"`NOT NULL` not allowed if constraint given\");\n+            Error_Msg_SP -- CODEFIX???\n+              (\"`NOT NULL` not allowed if constraint given\");\n          end if;\n \n          Indic_Node := New_Node (N_Subtype_Indication, Sloc (Subtype_Mark));\n@@ -1358,8 +1368,9 @@ package body Ch3 is\n       procedure No_List is\n       begin\n          if Num_Idents > 1 then\n-            Error_Msg (\"identifier list not allowed for RENAMES\",\n-                       Sloc (Idents (2)));\n+            Error_Msg -- CODEFIX???\n+              (\"identifier list not allowed for RENAMES\",\n+               Sloc (Idents (2)));\n          end if;\n \n          List_OK := False;\n@@ -1379,7 +1390,8 @@ package body Ch3 is\n             Check_Misspelling_Of (Tok_Renames);\n \n             if Token = Tok_Renames then\n-               Error_Msg_SP (\"|extra \"\":\"\" ignored\");\n+               Error_Msg_SP -- CODEFIX\n+                 (\"|extra \"\":\"\" ignored\");\n                Scan; -- past RENAMES\n                return True;\n             else\n@@ -1433,7 +1445,8 @@ package body Ch3 is\n          Scan; -- past :=\n \n          if Token = Tok_Constant then\n-            Error_Msg_SP (\"colon expected\");\n+            Error_Msg_SP -- CODEFIX???\n+              (\"colon expected\");\n \n          else\n             Restore_Scan_State (Scan_State);\n@@ -1553,7 +1566,7 @@ package body Ch3 is\n \n             if Present (Init_Expr) then\n                if Not_Null_Present then\n-                  Error_Msg_SP\n+                  Error_Msg_SP -- CODEFIX???\n                     (\"`NOT NULL` not allowed in numeric expression\");\n                end if;\n \n@@ -1604,7 +1617,7 @@ package body Ch3 is\n                end if;\n \n                if Token = Tok_Renames then\n-                  Error_Msg\n+                  Error_Msg -- CODEFIX???\n                     (\"CONSTANT not permitted in renaming declaration\",\n                      Con_Loc);\n                   Scan; -- Past renames\n@@ -1720,7 +1733,7 @@ package body Ch3 is\n \n                if Token_Is_Renames then\n                   if Ada_Version < Ada_05 then\n-                     Error_Msg_SP\n+                     Error_Msg_SP -- CODEFIX???\n                        (\"`NOT NULL` not allowed in object renaming\");\n                      raise Error_Resync;\n \n@@ -1750,9 +1763,10 @@ package body Ch3 is\n                   --  illegal\n \n                   if Token_Is_Renames then\n-                     Error_Msg_N (\"constraint not allowed in object renaming \"\n-                                  & \"declaration\",\n-                                  Constraint (Object_Definition (Decl_Node)));\n+                     Error_Msg_N -- CODEFIX???\n+                       (\"constraint not allowed in object renaming \"\n+                        & \"declaration\",\n+                        Constraint (Object_Definition (Decl_Node)));\n                      raise Error_Resync;\n                   end if;\n                end if;\n@@ -1812,7 +1826,7 @@ package body Ch3 is\n                --  a constraint on the Type_Node and renames, which is illegal\n \n                if Token_Is_Renames then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"constraint not allowed in object renaming declaration\",\n                      Constraint (Object_Definition (Decl_Node)));\n                   raise Error_Resync;\n@@ -1965,7 +1979,8 @@ package body Ch3 is\n          end loop;\n \n          if Token /= Tok_With then\n-            Error_Msg_SC (\"WITH expected\");\n+            Error_Msg_SC -- CODEFIX???\n+              (\"WITH expected\");\n             raise Error_Resync;\n          end if;\n       end if;\n@@ -1981,7 +1996,7 @@ package body Ch3 is\n          T_With; -- past WITH or give error message\n \n          if Token = Tok_Limited then\n-            Error_Msg_SC\n+            Error_Msg_SC -- CODEFIX???\n               (\"LIMITED keyword not allowed in private extension\");\n             Scan; -- ignore LIMITED\n          end if;\n@@ -2107,7 +2122,6 @@ package body Ch3 is\n       Range_Node : Node_Id;\n       Save_Loc   : Source_Ptr;\n \n-\n    --  Start of processing for P_Range_Or_Subtype_Mark\n \n    begin\n@@ -2170,14 +2184,20 @@ package body Ch3 is\n             return Expr_Node;\n          end if;\n \n+      --  Simple expression case\n+\n+      elsif Expr_Form = EF_Simple and then Allow_Simple_Expression then\n+         return Expr_Node;\n+\n       --  Here we have some kind of error situation. Check for junk parens\n       --  then return what we have, caller will deal with other errors.\n \n       else\n          if Nkind (Expr_Node) in N_Subexpr\n            and then Paren_Count (Expr_Node) /= 0\n          then\n-            Error_Msg (\"|parentheses not allowed for subtype mark\", Save_Loc);\n+            Error_Msg -- CODEFIX???\n+              (\"|parentheses not allowed for subtype mark\", Save_Loc);\n             Set_Paren_Count (Expr_Node, 0);\n          end if;\n \n@@ -2652,7 +2672,8 @@ package body Ch3 is\n          end if;\n \n          if Aliased_Present then\n-            Error_Msg_SP (\"ALIASED not allowed here\");\n+            Error_Msg_SP -- CODEFIX???\n+              (\"ALIASED not allowed here\");\n          end if;\n \n          Set_Subtype_Indication     (CompDef_Node, Empty);\n@@ -3299,7 +3320,8 @@ package body Ch3 is\n \n                if Token = Tok_Colon then\n                   Restore_Scan_State (Scan_State);\n-                  Error_Msg_SC (\"component may not follow variant part\");\n+                  Error_Msg_SC -- CODEFIX???\n+                    (\"component may not follow variant part\");\n                   Discard_Junk_Node (P_Component_List);\n \n                elsif Token = Tok_Case then\n@@ -3392,7 +3414,8 @@ package body Ch3 is\n             Set_Defining_Identifier (Decl_Node, Idents (Ident));\n \n             if Token = Tok_Constant then\n-               Error_Msg_SC (\"constant components are not permitted\");\n+               Error_Msg_SC -- CODEFIX???\n+                 (\"constant components are not permitted\");\n                Scan;\n             end if;\n \n@@ -3420,7 +3443,8 @@ package body Ch3 is\n                end if;\n \n                if Aliased_Present then\n-                  Error_Msg_SP (\"ALIASED not allowed here\");\n+                  Error_Msg_SP -- CODEFIX???\n+                    (\"ALIASED not allowed here\");\n                end if;\n \n                Set_Subtype_Indication (CompDef_Node, Empty);\n@@ -3434,7 +3458,7 @@ package body Ch3 is\n                Set_Null_Exclusion_Present (CompDef_Node, Not_Null_Present);\n \n                if Token = Tok_Array then\n-                  Error_Msg_SC\n+                  Error_Msg_SC -- CODEFIX???\n                     (\"anonymous arrays not allowed as components\");\n                   raise Error_Resync;\n                end if;\n@@ -3514,7 +3538,8 @@ package body Ch3 is\n          Error_Msg (\"discriminant name expected\", Sloc (Case_Node));\n \n       elsif Paren_Count (Case_Node) /= 0 then\n-         Error_Msg (\"|discriminant name may not be parenthesized\",\n+         Error_Msg -- CODEFIX???\n+           (\"|discriminant name may not be parenthesized\",\n                     Sloc (Case_Node));\n          Set_Paren_Count (Case_Node, 0);\n       end if;\n@@ -3698,7 +3723,8 @@ package body Ch3 is\n          end if;\n \n          if Token = Tok_Comma then\n-            Error_Msg_SC (\"\"\",\"\" should be \"\"'|\"\"\");\n+            Error_Msg_SC -- CODEFIX\n+              (\"\"\",\"\" should be \"\"'|\"\"\");\n          else\n             exit when Token /= Tok_Vertical_Bar;\n          end if;\n@@ -3745,8 +3771,9 @@ package body Ch3 is\n       end if;\n \n       if Abstract_Present then\n-         Error_Msg_SP (\"ABSTRACT not allowed in interface type definition \" &\n-                       \"(RM 3.9.4(2/2))\");\n+         Error_Msg_SP -- CODEFIX???\n+           (\"ABSTRACT not allowed in interface type definition \" &\n+            \"(RM 3.9.4(2/2))\");\n       end if;\n \n       Scan; -- past INTERFACE\n@@ -3768,7 +3795,8 @@ package body Ch3 is\n \n       else\n          if Token /= Tok_And then\n-            Error_Msg_AP (\"AND expected\");\n+            Error_Msg_AP -- CODEFIX???\n+              (\"AND expected\");\n          else\n             Scan; -- past AND\n          end if;\n@@ -3854,7 +3882,8 @@ package body Ch3 is\n             Scan; -- past possible junk subprogram name\n \n             if Token = Tok_Left_Paren or else Token = Tok_Semicolon then\n-               Error_Msg_SP (\"unexpected subprogram name ignored\");\n+               Error_Msg_SP -- CODEFIX???\n+                 (\"unexpected subprogram name ignored\");\n                return;\n \n             else\n@@ -4035,7 +4064,7 @@ package body Ch3 is\n \n          if Token = Tok_All then\n             if Ada_Version < Ada_05 then\n-               Error_Msg_SP\n+               Error_Msg_SP -- CODEFIX???\n                  (\"ALL is not permitted for anonymous access types\");\n             end if;\n \n@@ -4246,7 +4275,8 @@ package body Ch3 is\n \n          when Tok_With =>\n             Check_Bad_Layout;\n-            Error_Msg_SC (\"WITH can only appear in context clause\");\n+            Error_Msg_SC -- CODEFIX???\n+              (\"WITH can only appear in context clause\");\n             raise Error_Resync;\n \n          --  BEGIN terminates the scan of a sequence of declarations unless\n@@ -4284,7 +4314,8 @@ package body Ch3 is\n                   --  Otherwise we saved the semicolon position, so complain\n \n                   else\n-                     Error_Msg (\"|\"\";\"\" should be IS\", SIS_Semicolon_Sloc);\n+                     Error_Msg -- CODEFIX\n+                       (\"|\"\";\"\" should be IS\", SIS_Semicolon_Sloc);\n                   end if;\n \n                   --  The next job is to fix up any declarations that occurred\n@@ -4410,7 +4441,8 @@ package body Ch3 is\n             if In_Spec then\n                Done := True;\n             else\n-               Error_Msg_SC (\"PRIVATE not allowed in body\");\n+               Error_Msg_SC -- CODEFIX???\n+                 (\"PRIVATE not allowed in body\");\n                Scan; -- past PRIVATE\n             end if;\n \n@@ -4519,17 +4551,17 @@ package body Ch3 is\n             Kind = N_Task_Body or else\n             Kind = N_Protected_Body\n          then\n-            Error_Msg\n+            Error_Msg -- CODEFIX???\n               (\"proper body not allowed in package spec\", Sloc (Decl));\n \n          --  Test for body stub scanned, not acceptable as basic decl item\n \n          elsif Kind in N_Body_Stub then\n-            Error_Msg\n+            Error_Msg -- CODEFIX???\n               (\"body stub not allowed in package spec\", Sloc (Decl));\n \n          elsif Kind = N_Assignment_Statement then\n-            Error_Msg\n+            Error_Msg -- CODEFIX???\n               (\"assignment statement not allowed in package spec\",\n                  Sloc (Decl));\n          end if;\n@@ -4618,15 +4650,17 @@ package body Ch3 is\n          --  not allowed in package spec. This message never gets changed.\n \n          if In_Spec then\n-            Error_Msg_SC (\"statement not allowed in package spec\");\n+            Error_Msg_SC -- CODEFIX???\n+              (\"statement not allowed in package spec\");\n \n          --  If in declarative part, then we give the message complaining\n          --  about finding a statement when a declaration is expected. This\n          --  gets changed to a complaint about a missing BEGIN if we later\n          --  find that no BEGIN is present.\n \n          else\n-            Error_Msg_SC (\"statement not allowed in declarative part\");\n+            Error_Msg_SC -- CODEFIX???\n+              (\"statement not allowed in declarative part\");\n          end if;\n \n          --  Capture message Id. This is used for two purposes, first to"}, {"sha": "007376a5e98cac35761509d49e63ac5cda21e8f6", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=305caf424d1720f082b9cdfc072d29ae553afebc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -558,7 +558,8 @@ package body Sem_Ch5 is\n         and then not Is_Tag_Indeterminate (Rhs)\n         and then not Is_Dynamically_Tagged (Rhs)\n       then\n-         Error_Msg_N (\"dynamically tagged expression required!\", Rhs);\n+         Error_Msg_N -- CODEFIX???\n+           (\"dynamically tagged expression required!\", Rhs);\n       end if;\n \n       --  Propagate the tag from a class-wide target to the rhs when the rhs\n@@ -572,7 +573,7 @@ package body Sem_Ch5 is\n               and then Is_Entity_Name (Name (Rhs))\n               and then Is_Abstract_Subprogram (Entity (Name (Rhs)))\n          then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"call to abstract function must be dispatching\", Name (Rhs));\n \n          elsif Nkind (Rhs) = N_Qualified_Expression\n@@ -581,7 +582,7 @@ package body Sem_Ch5 is\n               and then\n                 Is_Abstract_Subprogram (Entity (Name (Expression (Rhs))))\n          then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"call to abstract function must be dispatching\",\n                 Name (Expression (Rhs)));\n          end if;\n@@ -693,10 +694,10 @@ package body Sem_Ch5 is\n         and then Nkind (Original_Node (Rhs)) not in N_Op\n       then\n          if Nkind (Lhs) in N_Has_Entity then\n-            Error_Msg_NE\n+            Error_Msg_NE -- CODEFIX\n               (\"?useless assignment of & to itself!\", N, Entity (Lhs));\n          else\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX\n               (\"?useless assignment of object to itself!\", N);\n          end if;\n       end if;\n@@ -948,7 +949,7 @@ package body Sem_Ch5 is\n       --  the case statement has a non static choice.\n \n       procedure Process_Statements (Alternative : Node_Id);\n-      --  Analyzes all the statements associated to a case alternative.\n+      --  Analyzes all the statements associated with a case alternative.\n       --  Needed by the generic instantiation below.\n \n       package Case_Choices_Processing is new\n@@ -1635,10 +1636,11 @@ package body Sem_Ch5 is\n                         else\n                            --  Both of them are user-defined\n \n-                           Error_Msg_N\n+                           Error_Msg_N -- CODEFIX???\n                              (\"ambiguous bounds in range of iteration\",\n                                R_Copy);\n-                           Error_Msg_N (\"\\possible interpretations:\", R_Copy);\n+                           Error_Msg_N -- CODEFIX???\n+                             (\"\\possible interpretations:\", R_Copy);\n                            Error_Msg_NE (\"\\\\} \", R_Copy, Found);\n                            Error_Msg_NE (\"\\\\} \", R_Copy, It.Typ);\n                            exit;\n@@ -1890,7 +1892,7 @@ package body Sem_Ch5 is\n                               if Compile_Time_Compare\n                                    (L, H, Assume_Valid => False) = GT\n                               then\n-                                 Error_Msg_N\n+                                 Error_Msg_N -- CODEFIX???\n                                    (\"?loop range is null, \"\n                                     & \"loop will not execute\",\n                                     DS);\n@@ -1944,7 +1946,8 @@ package body Sem_Ch5 is\n                                     Intval (Original_Node (H)) = Uint_1)\n                         then\n                            Error_Msg_N (\"?loop range may be null\", DS);\n-                           Error_Msg_N (\"\\?bounds may be wrong way round\", DS);\n+                           Error_Msg_N -- CODEFIX???\n+                             (\"\\?bounds may be wrong way round\", DS);\n                         end if;\n                      end;\n                   end if;\n@@ -2241,7 +2244,8 @@ package body Sem_Ch5 is\n \n                   --  Now issue the warning\n \n-                  Error_Msg (\"?unreachable code!\", Error_Loc);\n+                  Error_Msg -- CODEFIX???\n+                    (\"?unreachable code!\", Error_Loc);\n                end if;\n \n             --  If the unconditional transfer of control instruction is"}, {"sha": "1b1307d2158947bed7c124475f3b778f17575098", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 145, "deletions": 140, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=305caf424d1720f082b9cdfc072d29ae553afebc", "patch": "@@ -126,6 +126,10 @@ package body Sem_Eval is\n    --  This is the actual cache, with entries consisting of node/value pairs,\n    --  and the impossible value Node_High_Bound used for unset entries.\n \n+   type Range_Membership is (In_Range, Out_Of_Range, Unknown);\n+   --  Range membership may either be statically known to be in range or out\n+   --  of range, or not statically known. Used for Test_In_Range below.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -210,6 +214,18 @@ package body Sem_Eval is\n    --  Same processing, except applies to an expression N with two operands\n    --  Op1 and Op2.\n \n+   function Test_In_Range\n+     (N            : Node_Id;\n+      Typ          : Entity_Id;\n+      Assume_Valid : Boolean;\n+      Fixed_Int    : Boolean;\n+      Int_Real     : Boolean) return Range_Membership;\n+   --  Common processing for Is_In_Range and Is_Out_Of_Range:\n+   --  Returns In_Range or Out_Of_Range if it can be guaranteed at compile time\n+   --  that expression N is known to be in or out of range of the subtype Typ.\n+   --  If not compile time known, Unknown is returned.\n+   --  See documentation of Is_In_Range for complete description of parameters.\n+\n    procedure To_Bits (U : Uint; B : out Bits);\n    --  Converts a Uint value to a bit string of length B'Length\n \n@@ -3896,70 +3912,9 @@ package body Sem_Eval is\n       Fixed_Int    : Boolean := False;\n       Int_Real     : Boolean := False) return Boolean\n    is\n-      Val  : Uint;\n-      Valr : Ureal;\n-\n-      pragma Warnings (Off, Assume_Valid);\n-      --  For now Assume_Valid is unreferenced since the current implementation\n-      --  always returns False if N is not a compile time known value, but we\n-      --  keep the parameter to allow for future enhancements in which we try\n-      --  to get the information in the variable case as well.\n-\n    begin\n-      --  Universal types have no range limits, so always in range\n-\n-      if Typ = Universal_Integer or else Typ = Universal_Real then\n-         return True;\n-\n-      --  Never in range if not scalar type. Don't know if this can\n-      --  actually happen, but our spec allows it, so we must check!\n-\n-      elsif not Is_Scalar_Type (Typ) then\n-         return False;\n-\n-      --  Never in range unless we have a compile time known value\n-\n-      elsif not Compile_Time_Known_Value (N) then\n-         return False;\n-\n-      --  General processing with a known compile time value\n-\n-      else\n-         declare\n-            Lo       : Node_Id;\n-            Hi       : Node_Id;\n-            LB_Known : Boolean;\n-            UB_Known : Boolean;\n-\n-         begin\n-            Lo := Type_Low_Bound  (Typ);\n-            Hi := Type_High_Bound (Typ);\n-\n-            LB_Known := Compile_Time_Known_Value (Lo);\n-            UB_Known := Compile_Time_Known_Value (Hi);\n-\n-            --  Fixed point types should be considered as such only if flag\n-            --  Fixed_Int is set to False.\n-\n-            if Is_Floating_Point_Type (Typ)\n-              or else (Is_Fixed_Point_Type (Typ) and then not Fixed_Int)\n-              or else Int_Real\n-            then\n-               Valr := Expr_Value_R (N);\n-\n-               return LB_Known and then Valr >= Expr_Value_R (Lo)\n-                        and then\n-                      UB_Known and then Valr <= Expr_Value_R (Hi);\n-\n-            else\n-               Val := Expr_Value (N);\n-\n-               return LB_Known and then Val >= Expr_Value (Lo)\n-                        and then\n-                      UB_Known and then Val <= Expr_Value (Hi);\n-            end if;\n-         end;\n-      end if;\n+      return Test_In_Range (N, Typ, Assume_Valid, Fixed_Int, Int_Real)\n+               = In_Range;\n    end Is_In_Range;\n \n    -------------------\n@@ -4083,78 +4038,9 @@ package body Sem_Eval is\n       Fixed_Int    : Boolean := False;\n       Int_Real     : Boolean := False) return Boolean\n    is\n-      Val  : Uint;\n-      Valr : Ureal;\n-\n-      pragma Warnings (Off, Assume_Valid);\n-      --  For now Assume_Valid is unreferenced since the current implementation\n-      --  always returns False if N is not a compile time known value, but we\n-      --  keep the parameter to allow for future enhancements in which we try\n-      --  to get the information in the variable case as well.\n-\n    begin\n-      --  Universal types have no range limits, so always in range\n-\n-      if Typ = Universal_Integer or else Typ = Universal_Real then\n-         return False;\n-\n-      --  Never out of range if not scalar type. Don't know if this can\n-      --  actually happen, but our spec allows it, so we must check!\n-\n-      elsif not Is_Scalar_Type (Typ) then\n-         return False;\n-\n-      --  Never out of range if this is a generic type, since the bounds\n-      --  of generic types are junk. Note that if we only checked for\n-      --  static expressions (instead of compile time known values) below,\n-      --  we would not need this check, because values of a generic type\n-      --  can never be static, but they can be known at compile time.\n-\n-      elsif Is_Generic_Type (Typ) then\n-         return False;\n-\n-      --  Never out of range unless we have a compile time known value\n-\n-      elsif not Compile_Time_Known_Value (N) then\n-         return False;\n-\n-      else\n-         declare\n-            Lo       : Node_Id;\n-            Hi       : Node_Id;\n-            LB_Known : Boolean;\n-            UB_Known : Boolean;\n-\n-         begin\n-            Lo := Type_Low_Bound (Typ);\n-            Hi := Type_High_Bound (Typ);\n-\n-            LB_Known := Compile_Time_Known_Value (Lo);\n-            UB_Known := Compile_Time_Known_Value (Hi);\n-\n-            --  Real types (note that fixed-point types are not treated as\n-            --  being of a real type if the flag Fixed_Int is set, since in\n-            --  that case they are regarded as integer types).\n-\n-            if Is_Floating_Point_Type (Typ)\n-              or else (Is_Fixed_Point_Type (Typ) and then not Fixed_Int)\n-              or else Int_Real\n-            then\n-               Valr := Expr_Value_R (N);\n-\n-               return (LB_Known and then Valr < Expr_Value_R (Lo))\n-                        or else\n-                      (UB_Known and then Expr_Value_R (Hi) < Valr);\n-\n-            else\n-               Val := Expr_Value (N);\n-\n-               return (LB_Known and then Val < Expr_Value (Lo))\n-                        or else\n-                      (UB_Known and then Expr_Value (Hi) < Val);\n-            end if;\n-         end;\n-      end if;\n+      return Test_In_Range (N, Typ, Assume_Valid, Fixed_Int, Int_Real)\n+               = Out_Of_Range;\n    end Is_Out_Of_Range;\n \n    ---------------------\n@@ -4472,12 +4358,12 @@ package body Sem_Eval is\n          --  A constrained numeric subtype never matches an unconstrained\n          --  subtype, i.e. both types must be constrained or unconstrained.\n \n-         --  To understand the requirement for this test, see RM 4.9.1(1). As\n-         --  is made clear in RM 3.5.4(11), type Integer, for example is a\n-         --  constrained subtype with constraint bounds matching the bounds of\n-         --  its corresponding unconstrained base type. In this situation,\n-         --  Integer and Integer'Base do not statically match, even though they\n-         --  have the same bounds.\n+         --  To understand the requirement for this test, see RM 4.9.1(1).\n+         --  As is made clear in RM 3.5.4(11), type Integer, for example is\n+         --  a constrained subtype with constraint bounds matching the bounds\n+         --  of its corresponding unconstrained base type. In this situation,\n+         --  Integer and Integer'Base do not statically match, even though\n+         --  they have the same bounds.\n \n          --  We only apply this test to types in Standard and types that appear\n          --  in user programs. That way, we do not have to be too careful about\n@@ -4877,6 +4763,125 @@ package body Sem_Eval is\n       end if;\n    end Test_Expression_Is_Foldable;\n \n+   -------------------\n+   -- Test_In_Range --\n+   -------------------\n+\n+   function Test_In_Range\n+     (N            : Node_Id;\n+      Typ          : Entity_Id;\n+      Assume_Valid : Boolean;\n+      Fixed_Int    : Boolean;\n+      Int_Real     : Boolean) return Range_Membership\n+   is\n+      Val  : Uint;\n+      Valr : Ureal;\n+\n+      pragma Warnings (Off, Assume_Valid);\n+      --  For now Assume_Valid is unreferenced since the current implementation\n+      --  always returns Unknown if N is not a compile time known value, but we\n+      --  keep the parameter to allow for future enhancements in which we try\n+      --  to get the information in the variable case as well.\n+\n+   begin\n+      --  Universal types have no range limits, so always in range\n+\n+      if Typ = Universal_Integer or else Typ = Universal_Real then\n+         return In_Range;\n+\n+      --  Never known if not scalar type. Don't know if this can actually\n+      --  happen, but our spec allows it, so we must check!\n+\n+      elsif not Is_Scalar_Type (Typ) then\n+         return Unknown;\n+\n+      --  Never known if this is a generic type, since the bounds of generic\n+      --  types are junk. Note that if we only checked for static expressions\n+      --  (instead of compile time known values) below, we would not need this\n+      --  check, because values of a generic type can never be static, but they\n+      --  can be known at compile time.\n+\n+      elsif Is_Generic_Type (Typ) then\n+         return Unknown;\n+\n+      --  Never known unless we have a compile time known value\n+\n+      elsif not Compile_Time_Known_Value (N) then\n+         return Unknown;\n+\n+      --  General processing with a known compile time value\n+\n+      else\n+         declare\n+            Lo       : Node_Id;\n+            Hi       : Node_Id;\n+\n+            LB_Known : Boolean;\n+            HB_Known : Boolean;\n+\n+         begin\n+            Lo := Type_Low_Bound  (Typ);\n+            Hi := Type_High_Bound (Typ);\n+\n+            LB_Known := Compile_Time_Known_Value (Lo);\n+            HB_Known := Compile_Time_Known_Value (Hi);\n+\n+            --  Fixed point types should be considered as such only if flag\n+            --  Fixed_Int is set to False.\n+\n+            if Is_Floating_Point_Type (Typ)\n+              or else (Is_Fixed_Point_Type (Typ) and then not Fixed_Int)\n+              or else Int_Real\n+            then\n+               Valr := Expr_Value_R (N);\n+\n+               if LB_Known and HB_Known then\n+                  if Valr >= Expr_Value_R (Lo)\n+                       and then\n+                     Valr <= Expr_Value_R (Hi)\n+                  then\n+                     return In_Range;\n+                  else\n+                     return Out_Of_Range;\n+                  end if;\n+\n+               elsif (LB_Known and then Valr < Expr_Value_R (Lo))\n+                       or else\n+                     (HB_Known and then Valr > Expr_Value_R (Hi))\n+               then\n+                  return Out_Of_Range;\n+\n+               else\n+                  return Unknown;\n+               end if;\n+\n+            else\n+               Val := Expr_Value (N);\n+\n+               if LB_Known and HB_Known then\n+                  if Val >= Expr_Value (Lo)\n+                       and then\n+                     Val <= Expr_Value (Hi)\n+                  then\n+                     return In_Range;\n+                  else\n+                     return Out_Of_Range;\n+                  end if;\n+\n+               elsif (LB_Known and then Val < Expr_Value (Lo))\n+                       or else\n+                     (HB_Known and then Val > Expr_Value (Hi))\n+               then\n+                  return Out_Of_Range;\n+\n+               else\n+                  return Unknown;\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+   end Test_In_Range;\n+\n    --------------\n    -- To_Bits --\n    --------------"}, {"sha": "1a2012960d7c4654dc71c24901778a24a17c50a2", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 54, "deletions": 30, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=305caf424d1720f082b9cdfc072d29ae553afebc", "patch": "@@ -214,7 +214,8 @@ package body Sem_Res is\n    --  to the corresponding predefined operator, with suitable conversions.\n \n    procedure Resolve_Intrinsic_Unary_Operator (N : Node_Id; Typ : Entity_Id);\n-   --  Ditto, for unary operators (only arithmetic ones)\n+   --  Ditto, for unary operators (arithmetic ones and \"not\" on signed\n+   --  integer types for VMS).\n \n    procedure Rewrite_Operator_As_Call (N : Node_Id; Nam : Entity_Id);\n    --  If an operator node resolves to a call to a user-defined operator,\n@@ -273,27 +274,29 @@ package body Sem_Res is\n \n    begin\n       if Nkind (C) = N_Character_Literal then\n-         Error_Msg_N (\"ambiguous character literal\", C);\n+         Error_Msg_N -- CODEFIX???\n+           (\"ambiguous character literal\", C);\n \n          --  First the ones in Standard\n \n-         Error_Msg_N\n+         Error_Msg_N -- CODEFIX???\n            (\"\\\\possible interpretation: Character!\", C);\n-         Error_Msg_N\n+         Error_Msg_N -- CODEFIX???\n            (\"\\\\possible interpretation: Wide_Character!\", C);\n \n          --  Include Wide_Wide_Character in Ada 2005 mode\n \n          if Ada_Version >= Ada_05 then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"\\\\possible interpretation: Wide_Wide_Character!\", C);\n          end if;\n \n          --  Now any other types that match\n \n          E := Current_Entity (C);\n          while Present (E) loop\n-            Error_Msg_NE (\"\\\\possible interpretation:}!\", C, Etype (E));\n+            Error_Msg_NE -- CODEFIX???\n+              (\"\\\\possible interpretation:}!\", C, Etype (E));\n             E := Homonym (E);\n          end loop;\n       end if;\n@@ -633,9 +636,10 @@ package body Sem_Res is\n    procedure Check_For_Visible_Operator (N : Node_Id; T : Entity_Id) is\n    begin\n       if Is_Invisible_Operator (N, T) then\n-         Error_Msg_NE\n+         Error_Msg_NE -- CODEFIX\n            (\"operator for} is not directly visible!\", N, First_Subtype (T));\n-         Error_Msg_N (\"use clause would make operation legal!\", N);\n+         Error_Msg_N -- CODEFIX\n+           (\"use clause would make operation legal!\", N);\n       end if;\n    end Check_For_Visible_Operator;\n \n@@ -1752,7 +1756,8 @@ package body Sem_Res is\n            and then Is_Entity_Name (Name (Arg))\n            and then Is_Overloaded (Name (Arg))\n          then\n-            Error_Msg_NE (\"ambiguous call to&\", Arg, Name (Arg));\n+            Error_Msg_NE -- CODEFIX???\n+              (\"ambiguous call to&\", Arg, Name (Arg));\n \n             --  Could use comments on what is going on here ???\n \n@@ -1761,9 +1766,11 @@ package body Sem_Res is\n                Error_Msg_Sloc := Sloc (It.Nam);\n \n                if Nkind (Parent (It.Nam)) = N_Full_Type_Declaration then\n-                  Error_Msg_N (\"interpretation (inherited) #!\", Arg);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"interpretation (inherited) #!\", Arg);\n                else\n-                  Error_Msg_N (\"interpretation #!\", Arg);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"interpretation #!\", Arg);\n                end if;\n \n                Get_Next_Interp (I, It);\n@@ -2058,7 +2065,7 @@ package body Sem_Res is\n                         if Nkind (N) = N_Function_Call\n                           and then Nkind (Name (N)) = N_Explicit_Dereference\n                         then\n-                           Error_Msg_N\n+                           Error_Msg_N -- CODEFIX???\n                              (\"ambiguous expression \"\n                                & \"(cannot resolve indirect call)!\", N);\n                         else\n@@ -2070,7 +2077,7 @@ package body Sem_Res is\n                         Ambiguous := True;\n \n                         if Nkind (Parent (Seen)) = N_Full_Type_Declaration then\n-                           Error_Msg_N\n+                           Error_Msg_N -- CODEFIX???\n                              (\"\\\\possible interpretation (inherited)#!\", N);\n                         else\n                            Error_Msg_N -- CODEFIX\n@@ -2148,19 +2155,19 @@ package body Sem_Res is\n                         if  It.Typ = Universal_Fixed\n                           and then Scope (It.Nam) = Standard_Standard\n                         then\n-                           Error_Msg_N\n+                           Error_Msg_N -- CODEFIX???\n                              (\"\\\\possible interpretation as \" &\n                                 \"universal_fixed operation \" &\n                                   \"(RM 4.5.5 (19))\", N);\n                         else\n-                           Error_Msg_N\n+                           Error_Msg_N -- CODEFIX???\n                              (\"\\\\possible interpretation (predefined)#!\", N);\n                         end if;\n \n                      elsif\n                        Nkind (Parent (It.Nam)) = N_Full_Type_Declaration\n                      then\n-                        Error_Msg_N\n+                        Error_Msg_N -- CODEFIX???\n                           (\"\\\\possible interpretation (inherited)#!\", N);\n                      else\n                         Error_Msg_N -- CODEFIX\n@@ -2908,7 +2915,7 @@ package body Sem_Res is\n                --  Introduce an implicit 'Access in prefix\n \n                if not Is_Aliased_View (Act) then\n-                  Error_Msg_NE\n+                  Error_Msg_NE -- CODEFIX???\n                     (\"object in prefixed call to& must be aliased\"\n                          & \" (RM-2005 4.3.1 (13))\",\n                     Prefix (Act), Nam);\n@@ -4199,7 +4206,8 @@ package body Sem_Res is\n          declare\n             Loc : constant Source_Ptr := Sloc (N);\n          begin\n-            Error_Msg_N (\"?allocation from empty storage pool!\", N);\n+            Error_Msg_N -- CODEFIX???\n+              (\"?allocation from empty storage pool!\", N);\n             Error_Msg_N (\"\\?Storage_Error will be raised at run time!\", N);\n             Insert_Action (N,\n               Make_Raise_Storage_Error (Loc,\n@@ -6352,7 +6360,8 @@ package body Sem_Res is\n            and then Entity (R) = Standard_True\n            and then Comes_From_Source (R)\n          then\n-            Error_Msg_N (\"?comparison with True is redundant!\", R);\n+            Error_Msg_N -- CODEFIX\n+              (\"?comparison with True is redundant!\", R);\n          end if;\n \n          Check_Unset_Reference (L);\n@@ -6676,6 +6685,13 @@ package body Sem_Res is\n       Arg2 : Node_Id;\n \n    begin\n+      --  We must preserve the original entity in a generic setting, so that\n+      --  the legality of the operation can be verified in an instance.\n+\n+      if not Expander_Active then\n+         return;\n+      end if;\n+\n       Op := Entity (N);\n       while Scope (Op) /= Standard_Standard loop\n          Op := Homonym (Op);\n@@ -7365,7 +7381,7 @@ package body Sem_Res is\n \n       elsif Typ = Universal_Integer or else Typ = Any_Modular then\n          if Parent_Is_Boolean then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"operand of not must be enclosed in parentheses\",\n                Right_Opnd (N));\n          else\n@@ -7387,7 +7403,8 @@ package body Sem_Res is\n            and then not Is_Boolean_Type (Typ)\n            and then Parent_Is_Boolean\n          then\n-            Error_Msg_N (\"?not expression should be parenthesized here!\", N);\n+            Error_Msg_N -- CODEFIX???\n+              (\"?not expression should be parenthesized here!\", N);\n          end if;\n \n          --  Warn on double negation if checking redundant constructs\n@@ -7398,7 +7415,8 @@ package body Sem_Res is\n            and then Root_Type (Typ) = Standard_Boolean\n            and then Nkind (Right_Opnd (N)) = N_Op_Not\n          then\n-            Error_Msg_N (\"redundant double negation?\", N);\n+            Error_Msg_N -- CODEFIX???\n+              (\"redundant double negation?\", N);\n          end if;\n \n          --  Complete resolution and evaluation of NOT\n@@ -8578,7 +8596,8 @@ package body Sem_Res is\n \n                if From_With_Type (Opnd) then\n                   Error_Msg_Qual_Level := 99;\n-                  Error_Msg_NE (\"missing WITH clause on package &\", N,\n+                  Error_Msg_NE -- CODEFIX\n+                    (\"missing WITH clause on package &\", N,\n                     Cunit_Entity (Get_Source_Unit (Base_Type (Opnd))));\n                   Error_Msg_N\n                     (\"type conversions require visibility of the full view\",\n@@ -8590,7 +8609,8 @@ package body Sem_Res is\n                       and then Present (Non_Limited_View (Etype (Target))))\n                then\n                   Error_Msg_Qual_Level := 99;\n-                  Error_Msg_NE (\"missing WITH clause on package &\", N,\n+                  Error_Msg_NE -- CODEFIX\n+                    (\"missing WITH clause on package &\", N,\n                     Cunit_Entity (Get_Source_Unit (Base_Type (Target))));\n                   Error_Msg_N\n                     (\"type conversions require visibility of the full view\",\n@@ -8682,7 +8702,7 @@ package body Sem_Res is\n          Determine_Range (Right_Opnd (N), OK, Lo, Hi);\n \n          if OK and then Hi >= Lo and then Lo >= 0 then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX\n              (\"?abs applied to known non-negative value has no effect\", N);\n          end if;\n       end if;\n@@ -8820,7 +8840,7 @@ package body Sem_Res is\n \n                --  If we fall through warning should be issued\n \n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"?unary minus expression should be parenthesized here!\", N);\n             end if;\n          end if;\n@@ -9201,9 +9221,12 @@ package body Sem_Res is\n \n       procedure Fixed_Point_Error is\n       begin\n-         Error_Msg_N (\"ambiguous universal_fixed_expression\", N);\n-         Error_Msg_NE (\"\\\\possible interpretation as}\", N, T1);\n-         Error_Msg_NE (\"\\\\possible interpretation as}\", N, T2);\n+         Error_Msg_N -- CODEFIX???\n+           (\"ambiguous universal_fixed_expression\", N);\n+         Error_Msg_NE -- CODEFIX???\n+            (\"\\\\possible interpretation as}\", N, T1);\n+         Error_Msg_NE -- CODEFIX???\n+            (\"\\\\possible interpretation as}\", N, T2);\n       end Fixed_Point_Error;\n \n    --  Start of processing for Unique_Fixed_Point_Type\n@@ -10049,7 +10072,8 @@ package body Sem_Res is\n          and then Is_Access_Type (Opnd_Type)\n       then\n          Error_Msg_N (\"target type must be general access type!\", N);\n-         Error_Msg_NE (\"add ALL to }!\", N, Target_Type);\n+         Error_Msg_NE -- CODEFIX\n+            (\"add ALL to }!\", N, Target_Type);\n          return False;\n \n       else"}, {"sha": "a7fc6e72d99a2af2d58190206fc012a559c7a627", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305caf424d1720f082b9cdfc072d29ae553afebc/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=305caf424d1720f082b9cdfc072d29ae553afebc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1513,7 +1513,6 @@ package body Sprint is\n             Indent_Begin;\n             Write_Indent_Str_Sloc (\"do\");\n             Indent_Begin;\n-            Write_Indent;\n             Sprint_Node_List (Actions (Node));\n             Indent_End;\n             Write_Indent;"}]}