{"sha": "097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk3ZjgyZWM5ZDE5Y2NiNTQyMGM4ZGY5OGNmMzVlMTg5OGI0ZmRhYg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-08-20T21:06:46Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-08-20T21:06:46Z"}, "message": "Add support for grouping of related diagnostics (PR other/84889)\n\nWe often emit logically-related groups of diagnostics.\n\nA relatively simple case is this:\n\n  if (warning_at (body_loc, OPT_Wmultistatement_macros,\n                  \"macro expands to multiple statements\"))\n    inform (guard_loc, \"some parts of macro expansion are not guarded by \"\n            \"this %qs clause\", guard_tinfo_to_string (keyword));\n\nwhere the \"note\" diagnostic issued by the \"inform\" call\nis guarded by the -Wmultistatement_macros warning.\n\nMore complicated examples can be seen in the C++ frontend,\nwhere e.g. print_z_candidates can lead to numerous \"note\"\ndiagnostics being emitted.\n\nI'm looking at various ways to improve how we handle such related\ndiagnostics, but, prior to this patch, there was no explicit\nrelationship between these diagnostics: the diagnostics subsystem\nhad no way of \"knowing\" that these were related.\n\nThis patch introduces a simple way to group the diagnostics:\nan auto_diagnostic_group class: all diagnostics emitted within\nthe lifetime of an auto_diagnostic_group instance are logically\ngrouped.\n\nHence in the above example, the two diagnostics can be grouped\nby simply adding an auto_diagnostic_group instance:\n\n  auto_diagnostic_group d;\n  if (warning_at (body_loc, OPT_Wmultistatement_macros,\n                  \"macro expands to multiple statements\"))\n    inform (guard_loc, \"some parts of macro expansion are not guarded by \"\n            \"this %qs clause\", guard_tinfo_to_string (keyword));\n\nSome more awkard cases are of the form:\n\n  if (some_condition\n      && warning_at (...)\n      && more_conditions)\n    inform (...);\n\nwhich thus need restructuring to:\n\n  if (some_condition)\n    {\n      auto_diagnostic_group d;\n      warning_at (...);\n      if (more_conditions)\n        inform (...);\n    }\n\nso that the lifetime of the auto_diagnostic_group groups the\nwarning_at and the inform call.\n\nNesting is handled by simply tracking a nesting depth within the\ndiagnostic_context.: all diagnostics are treated as grouped until the\nfinal auto_diagnostic_group is popped.\n\ndiagnostic.c uses this internally, so that all diagnostics are part of\na group - those that are \"by themselves\" are treated as being part of\na group with one element.\n\nThe diagnostic_context gains optional callbacks for displaying the\nstart of a group (when the first diagnostic is emitted within it), and\nthe end of a group (for when the group was non-empty); these callbacks\nare unused by default, but a test plugin demonstrates them (and verifies\nthat the machinery is working).\n\nAs noted above, I'm looking at various ways to use the grouping to\nimprove how we output the diagnostics.\n\nFWIW, I experimented with a more involved implementation, of the form:\n\n  diagnostic_group d;\n  if (d.warning_at (body_loc, OPT_Wmultistatement_macros,\n                    \"macro expands to multiple statements\"))\n    d.inform (guard_loc, \"some parts of macro expansion are not guarded by \"\n              \"this %qs clause\", guard_tinfo_to_string (keyword));\n\nwhich had the advantage of allowing auto-detection of the places where\ngroups were needed (by converting ::warning_at's return type to bool),\nbut it was a much more invasive patch, especially when dealing with\nthe places in the C++ frontend that can emit numerous notes after\nan error or warning (and thus having to pass the group around)\nHence I went with this simpler approach.\n\ngcc/c-family/ChangeLog:\n\tPR other/84889\n\t* c-attribs.c (common_handle_aligned_attribute): Add\n\tauto_diagnostic_group instance.\n\t* c-indentation.c (warn_for_misleading_indentation): Likewise.\n\t* c-opts.c (c_common_post_options): Likewise.\n\t* c-warn.c (warn_logical_not_parentheses): Likewise.\n\t(warn_duplicated_cond_add_or_warn): Likewise.\n\t(warn_for_multistatement_macros): Likewise.\n\ngcc/c/ChangeLog:\n\tPR other/84889\n\t* c-decl.c (pushtag): Add auto_diagnostic_group instance.\n\t(diagnose_mismatched_decls): Likewise, in various places.\n\t(warn_if_shadowing): Likewise.\n\t(implicit_decl_warning): Likewise.\n\t(implicitly_declare): Likewise.\n\t(undeclared_variable): Likewise.\n\t(declare_label): Likewise.\n\t(grokdeclarator): Likewise.\n\t(start_function): Likewise.\n\t* c-parser.c (c_parser_declaration_or_fndef): Likewise.\n\t(c_parser_parameter_declaration): Likewise.\n\t(c_parser_binary_expression): Likewise.\n\t* c-typeck.c (c_expr_sizeof_expr): Likewise.\n\t(parser_build_binary_op): Likewise.\n\t(build_unary_op): Likewise.\n\t(error_init): Likewise.\n\t(pedwarn_init): Likewise.\n\t(warning_init): Likewise.\n\t(convert_for_assignment): Likewise.\n\ngcc/cp/ChangeLog:\n\tPR other/84889\n\t* call.c (build_user_type_conversion_1): Add auto_diagnostic_group\n\tinstance(s).\n\t(print_error_for_call_failure): Likewise.\n\t(build_op_call_1): Likewise.\n\t(build_conditional_expr_1): Likewise.\n\t(build_new_op_1): Likewise.\n\t(build_op_delete_call): Likewise.\n\t(convert_like_real): Likewise.\n\t(build_over_call): Likewise.\n\t(build_new_method_call_1): Likewise.\n\t(joust): Likewise.\n\t* class.c (check_tag): Likewise.\n\t(finish_struct_anon_r): Likewise.\n\t(one_inherited_ctor): Likewise.\n\t(finalize_literal_type_property): Likewise.\n\t(explain_non_literal_class): Likewise.\n\t(find_flexarrays): Likewise.\n\t(resolve_address_of_overloaded_function): Likewise.\n\t* constexpr.c (ensure_literal_type_for_constexpr_object): Likewise.\n\t(is_valid_constexpr_fn): Likewise.\n\t(cx_check_missing_mem_inits): Likewise.\n\t* cp-gimplify.c (cp_genericize_r): Likewise.\n\t* cvt.c (maybe_warn_nodiscard): Likewise.\n\t* decl.c (warn_extern_redeclared_static): Likewise.\n\t(check_redeclaration_exception_specification): Likewise.\n\t(check_no_redeclaration_friend_default_args): Likewise.\n\t(duplicate_decls): Likewise.\n\t(redeclaration_error_message): Likewise.\n\t(warn_misplaced_attr_for_class_type): Likewise.\n\t* decl2.c (finish_static_data_member_decl): Likewise.\n\t(no_linkage_error): Likewise.\n\t(cp_warn_deprecated_use): Likewise.\n\t* error.c (qualified_name_lookup_error): Likewise.\n\t* friend.c (make_friend_class): Likewise.\n\t(do_friend): Likewise.\n\t* init.c (perform_member_init): Likewise.\n\t(build_new_1): Likewise.\n\t(build_vec_delete_1): Likewise.\n\t(build_delete): Likewise.\n\t* lex.c (unqualified_name_lookup_error): Likewise.\n\t* name-lookup.c (check_extern_c_conflict): Likewise.\n\t(inform_shadowed): New function.\n\t(check_local_shadow): Add auto_diagnostic_group instances,\n\treplacing goto \"inform_shadowed\" label with call to subroutine.\n\t(set_local_extern_decl_linkage): Add auto_diagnostic_group\n\tinstance(s).\n\t* parser.c (cp_parser_diagnose_invalid_type_name): Likewise.\n\t(cp_parser_namespace_name): Likewise.\n\t* pt.c (check_specialization_namespace): Likewise.\n\t(check_template_variable): Likewise.\n\t(warn_spec_missing_attributes): Likewise.\n\t(check_explicit_specialization): Likewise.\n\t(process_partial_specialization): Likewise.\n\t(lookup_template_class_1): Likewise.\n\t(finish_template_variable): Likewise.\n\t(do_auto_deduction): Likewise.\n\t* search.c (check_final_overrider): Likewise.\n\t(look_for_overrides_r): Likewise.\n\t* tree.c (maybe_warn_parm_abi): Likewise.\n\t* typeck.c (cxx_sizeof_expr): Likewise.\n\t(cp_build_function_call_vec): Likewise.\n\t(cp_build_binary_op): Likewise.\n\t(convert_for_assignment): Likewise.\n\t(maybe_warn_about_returning_address_of_local): Likewise.\n\t* typeck2.c (abstract_virtuals_error_sfinae): Likewise.\n\t(check_narrowing): Likewise.\n\ngcc/ChangeLog:\n\tPR other/84889\n\t* attribs.c (diag_attr_exclusions): Add auto_diagnostic_group instance.\n\t(decl_attributes): Likewise.\n\t* calls.c (maybe_warn_nonstring_arg): Add auto_diagnostic_group\n\tinstance.\n\t* cgraphunit.c (maybe_diag_incompatible_alias): Likewise.\n\t* diagnostic-core.h (class auto_diagnostic_group): New class.\n\t* diagnostic.c (diagnostic_initialize): Initialize the new fields.\n\t(diagnostic_report_diagnostic): Handle the first diagnostics within\n\ta group.\n\t(emit_diagnostic): Add auto_diagnostic_group instance.\n\t(inform): Likewise.\n\t(inform_n): Likewise.\n\t(warning): Likewise.\n\t(warning_at): Likewise.\n\t(warning_n): Likewise.\n\t(pedwarn): Likewise.\n\t(permerror): Likewise.\n\t(error): Likewise.\n\t(error_n): Likewise.\n\t(error_at): Likewise.\n\t(sorry): Likewise.\n\t(fatal_error): Likewise.\n\t(internal_error): Likewise.\n\t(internal_error_no_backtrace): Likewise.\n\t(auto_diagnostic_group::auto_diagnostic_group): New ctor.\n\t(auto_diagnostic_group::~auto_diagnostic_group): New dtor.\n\t* diagnostic.h (struct diagnostic_context): Add fields\n\t\"diagnostic_group_nesting_depth\",\n\t\"diagnostic_group_emission_count\", \"begin_group_cb\",\n\t\"end_group_cb\".\n\t* gimple-ssa-isolate-paths.c (find_implicit_erroneous_behavior):\n\tAdd auto_diagnostic_group instance(s).\n\t(find_explicit_erroneous_behavior): Likewise.\n\t* gimple-ssa-warn-alloca.c (pass_walloca::execute): Likewise.\n\t* gimple-ssa-warn-restrict.c (maybe_diag_offset_bounds): Likewise.\n\t* gimplify.c (warn_implicit_fallthrough_r): Likewise.\n\t(gimplify_va_arg_expr): Likewise.\n\t* hsa-gen.c (HSA_SORRY_ATV): Likewise.\n\t(HSA_SORRY_AT): Likewise.\n\t* ipa-devirt.c (compare_virtual_tables): Likewise.\n\t(warn_odr): Likewise.\n\t* multiple_target.c (expand_target_clones): Likewise.\n\t* opts-common.c (cmdline_handle_error): Likewise.\n\t* reginfo.c (globalize_reg): Likewise.\n\t* substring-locations.c (format_warning_n_va): Likewise.\n\t* tree-inline.c (expand_call_inline): Likewise.\n\t* tree-ssa-ccp.c (pass_post_ipa_warn::execute): Likewise.\n\t* tree-ssa-loop-niter.c\n\t(do_warn_aggressive_loop_optimizations): Likewise.\n\t* tree-ssa-uninit.c (warn_uninit): Likewise.\n\t* tree.c (warn_deprecated_use): Likewise.\n\ngcc/testsuite/ChangeLog:\n\tPR other/84889\n\t* gcc.dg/plugin/diagnostic-group-test-1.c: New test.\n\t* gcc.dg/plugin/diagnostic_group_plugin.c: New test.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the new tests.\n\nFrom-SVN: r263675", "tree": {"sha": "083d8bf17b0bcd664af40648942c7c901ba1ed58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/083d8bf17b0bcd664af40648942c7c901ba1ed58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a31505a339c847f0073c0ce9223a2b3c9bec6cef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a31505a339c847f0073c0ce9223a2b3c9bec6cef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a31505a339c847f0073c0ce9223a2b3c9bec6cef"}], "stats": {"total": 1157, "additions": 963, "deletions": 194}, "files": [{"sha": "515ea8a087a21bf568c37ca851552342d9a712f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1,3 +1,58 @@\n+2018-08-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR other/84889\n+\t* attribs.c (diag_attr_exclusions): Add auto_diagnostic_group instance.\n+\t(decl_attributes): Likewise.\n+\t* calls.c (maybe_warn_nonstring_arg): Add auto_diagnostic_group\n+\tinstance.\n+\t* cgraphunit.c (maybe_diag_incompatible_alias): Likewise.\n+\t* diagnostic-core.h (class auto_diagnostic_group): New class.\n+\t* diagnostic.c (diagnostic_initialize): Initialize the new fields.\n+\t(diagnostic_report_diagnostic): Handle the first diagnostics within\n+\ta group.\n+\t(emit_diagnostic): Add auto_diagnostic_group instance.\n+\t(inform): Likewise.\n+\t(inform_n): Likewise.\n+\t(warning): Likewise.\n+\t(warning_at): Likewise.\n+\t(warning_n): Likewise.\n+\t(pedwarn): Likewise.\n+\t(permerror): Likewise.\n+\t(error): Likewise.\n+\t(error_n): Likewise.\n+\t(error_at): Likewise.\n+\t(sorry): Likewise.\n+\t(fatal_error): Likewise.\n+\t(internal_error): Likewise.\n+\t(internal_error_no_backtrace): Likewise.\n+\t(auto_diagnostic_group::auto_diagnostic_group): New ctor.\n+\t(auto_diagnostic_group::~auto_diagnostic_group): New dtor.\n+\t* diagnostic.h (struct diagnostic_context): Add fields\n+\t\"diagnostic_group_nesting_depth\",\n+\t\"diagnostic_group_emission_count\", \"begin_group_cb\",\n+\t\"end_group_cb\".\n+\t* gimple-ssa-isolate-paths.c (find_implicit_erroneous_behavior):\n+\tAdd auto_diagnostic_group instance(s).\n+\t(find_explicit_erroneous_behavior): Likewise.\n+\t* gimple-ssa-warn-alloca.c (pass_walloca::execute): Likewise.\n+\t* gimple-ssa-warn-restrict.c (maybe_diag_offset_bounds): Likewise.\n+\t* gimplify.c (warn_implicit_fallthrough_r): Likewise.\n+\t(gimplify_va_arg_expr): Likewise.\n+\t* hsa-gen.c (HSA_SORRY_ATV): Likewise.\n+\t(HSA_SORRY_AT): Likewise.\n+\t* ipa-devirt.c (compare_virtual_tables): Likewise.\n+\t(warn_odr): Likewise.\n+\t* multiple_target.c (expand_target_clones): Likewise.\n+\t* opts-common.c (cmdline_handle_error): Likewise.\n+\t* reginfo.c (globalize_reg): Likewise.\n+\t* substring-locations.c (format_warning_n_va): Likewise.\n+\t* tree-inline.c (expand_call_inline): Likewise.\n+\t* tree-ssa-ccp.c (pass_post_ipa_warn::execute): Likewise.\n+\t* tree-ssa-loop-niter.c\n+\t(do_warn_aggressive_loop_optimizations): Likewise.\n+\t* tree-ssa-uninit.c (warn_uninit): Likewise.\n+\t* tree.c (warn_deprecated_use): Likewise.\n+\n 2018-08-20  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/87014"}, {"sha": "64700b6c8ce332d38c1dbbec744e14e4467c8d77", "filename": "gcc/attribs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -430,7 +430,7 @@ diag_attr_exclusions (tree last_decl, tree node, tree attrname,\n \n \t  /* Print a note?  */\n \t  bool note = last_decl != NULL_TREE;\n-\n+\t  auto_diagnostic_group d;\n \t  if (TREE_CODE (node) == FUNCTION_DECL\n \t      && DECL_BUILT_IN (node))\n \t    note &= warning (OPT_Wattributes,\n@@ -587,6 +587,7 @@ decl_attributes (tree *node, tree attributes, int flags,\n \t  /* This is a c++11 attribute that appertains to a\n \t     type-specifier, outside of the definition of, a class\n \t     type.  Ignore it.  */\n+\t  auto_diagnostic_group d;\n \t  if (warning (OPT_Wattributes, \"attribute ignored\"))\n \t    inform (input_location,\n \t\t    \"an attribute that appertains to a type-specifier \""}, {"sha": "aa52815cc751b29498b9fe782ac81405a6b06287", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1,3 +1,14 @@\n+2018-08-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR other/84889\n+\t* c-attribs.c (common_handle_aligned_attribute): Add\n+\tauto_diagnostic_group instance.\n+\t* c-indentation.c (warn_for_misleading_indentation): Likewise.\n+\t* c-opts.c (c_common_post_options): Likewise.\n+\t* c-warn.c (warn_logical_not_parentheses): Likewise.\n+\t(warn_duplicated_cond_add_or_warn): Likewise.\n+\t(warn_for_multistatement_macros): Likewise.\n+\n 2018-08-20  Nathan Sidwell  <nathan@acm.org>\n \n \t* c-ada-spec.c (macro_length, dump_ada_macros): Adjust macro parm"}, {"sha": "5454e09adbcbb6f9a992f6f38f3e2d17c86a0ede", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1881,6 +1881,7 @@ common_handle_aligned_attribute (tree *node, tree name, tree args, int flags,\n       bitalign /= BITS_PER_UNIT;\n \n       bool diagd = true;\n+      auto_diagnostic_group d;\n       if (DECL_USER_ALIGN (decl) || DECL_USER_ALIGN (last_decl))\n \tdiagd = warning (OPT_Wattributes,\n \t\t\t  \"ignoring attribute %<%E (%u)%> because it conflicts \""}, {"sha": "cff5aec23c23ab173fea705023be8174e4eac7f2", "filename": "gcc/c-family/c-indentation.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc-family%2Fc-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc-family%2Fc-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -609,6 +609,7 @@ warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t\t\t\t\t      body_tinfo,\n \t\t\t\t\t      next_tinfo))\n     {\n+      auto_diagnostic_group d;\n       if (warning_at (guard_tinfo.location, OPT_Wmisleading_indentation,\n \t\t      \"this %qs clause does not guard...\",\n \t\t      guard_tinfo_to_string (guard_tinfo.keyword)))"}, {"sha": "ec0577139d098184f952d3bb306ca2fba0f99dfb", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -931,6 +931,7 @@ c_common_post_options (const char **pfilename)\n       warn_abi_version = latest_abi_version;\n       if (flag_abi_version == latest_abi_version)\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (warning (OPT_Wabi, \"-Wabi won't warn about anything\"))\n \t    {\n \t      inform (input_location, \"-Wabi warns about differences \""}, {"sha": "ca259aa7bd0ca59e83d29eeae3d41d76bde221e0", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -491,6 +491,7 @@ warn_logical_not_parentheses (location_t location, enum tree_code code,\n       && integer_zerop (rhs))\n     return;\n \n+  auto_diagnostic_group d;\n   if (warning_at (location, OPT_Wlogical_not_parentheses,\n \t\t  \"logical not is only applied to the left hand side of \"\n \t\t  \"comparison\")\n@@ -2232,6 +2233,7 @@ warn_duplicated_cond_add_or_warn (location_t loc, tree cond, vec<tree> **chain)\n   FOR_EACH_VEC_ELT (**chain, ix, t)\n     if (operand_equal_p (cond, t, 0))\n       {\n+\tauto_diagnostic_group d;\n \tif (warning_at (loc, OPT_Wduplicated_cond,\n \t\t\t\"duplicated %<if%> condition\"))\n \t  inform (EXPR_LOCATION (t), \"previously used here\");\n@@ -2601,6 +2603,7 @@ warn_for_multistatement_macros (location_t body_loc, location_t next_loc,\n \treturn;\n     }\n \n+  auto_diagnostic_group d;\n   if (warning_at (body_loc, OPT_Wmultistatement_macros,\n \t\t  \"macro expands to multiple statements\"))\n     inform (guard_loc, \"some parts of macro expansion are not guarded by \""}, {"sha": "e943f0aac4a93a3158bf483c73ed0c9675098fcf", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1,3 +1,26 @@\n+2018-08-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR other/84889\n+\t* c-decl.c (pushtag): Add auto_diagnostic_group instance.\n+\t(diagnose_mismatched_decls): Likewise, in various places.\n+\t(warn_if_shadowing): Likewise.\n+\t(implicit_decl_warning): Likewise.\n+\t(implicitly_declare): Likewise.\n+\t(undeclared_variable): Likewise.\n+\t(declare_label): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(start_function): Likewise.\n+\t* c-parser.c (c_parser_declaration_or_fndef): Likewise.\n+\t(c_parser_parameter_declaration): Likewise.\n+\t(c_parser_binary_expression): Likewise.\n+\t* c-typeck.c (c_expr_sizeof_expr): Likewise.\n+\t(parser_build_binary_op): Likewise.\n+\t(build_unary_op): Likewise.\n+\t(error_init): Likewise.\n+\t(pedwarn_init): Likewise.\n+\t(warning_init): Likewise.\n+\t(convert_for_assignment): Likewise.\n+\n 2018-08-15  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-objc-common.c: Include \"gcc-rich-location.h\"."}, {"sha": "95249779e3c8350c2286f0ead1858d20f2b374ef", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1571,6 +1571,7 @@ pushtag (location_t loc, tree name, tree type)\n \t  && (TYPE_MAIN_VARIANT (TREE_TYPE (b->decl))\n \t      != TYPE_MAIN_VARIANT (type)))\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (warning_at (loc, OPT_Wc___compat,\n \t\t\t  (\"using %qD as both a typedef and a tag is \"\n \t\t\t   \"invalid in C++\"), b->decl)\n@@ -1823,8 +1824,6 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t\t\t   tree *newtypep, tree *oldtypep)\n {\n   tree newtype, oldtype;\n-  bool pedwarned = false;\n-  bool warned = false;\n   bool retval = true;\n \n #define DECL_EXTERN_INLINE(DECL) (DECL_DECLARED_INLINE_P (DECL)  \\\n@@ -1847,6 +1846,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    && DECL_BUILT_IN (olddecl)\n \t    && !C_DECL_DECLARED_BUILTIN (olddecl)))\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"%q+D redeclared as different kind of symbol\", newdecl);\n \t  locate_old_decl (olddecl);\n \t}\n@@ -1864,11 +1864,16 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n      given scope.  */\n   if (TREE_CODE (olddecl) == CONST_DECL)\n     {\n+      auto_diagnostic_group d;\n       error (\"redeclaration of enumerator %q+D\", newdecl);\n       locate_old_decl (olddecl);\n       return false;\n     }\n \n+  bool pedwarned = false;\n+  bool warned = false;\n+  auto_diagnostic_group d;\n+\n   if (!comptypes (oldtype, newtype))\n     {\n       if (TREE_CODE (olddecl) == FUNCTION_DECL\n@@ -2052,6 +2057,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t\t  )\n \t\t  && same_translation_unit_p (newdecl, olddecl))\n \t\t{\n+\t\t  auto_diagnostic_group d;\n \t\t  error (\"redefinition of %q+D\", newdecl);\n \t\t  locate_old_decl (olddecl);\n \t\t  return false;\n@@ -2062,11 +2068,14 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t the argument types must be checked specially.  */\n       else if (DECL_INITIAL (olddecl)\n \t       && !prototype_p (oldtype) && prototype_p (newtype)\n-\t       && TYPE_ACTUAL_ARG_TYPES (oldtype)\n-\t       && !validate_proto_after_old_defn (newdecl, newtype, oldtype))\n+\t       && TYPE_ACTUAL_ARG_TYPES (oldtype))\n \t{\n-\t  locate_old_decl (olddecl);\n-\t  return false;\n+\t  auto_diagnostic_group d;\n+\t  if (!validate_proto_after_old_defn (newdecl, newtype, oldtype))\n+\t    {\n+\t      locate_old_decl (olddecl);\n+\t      return false;\n+\t    }\n \t}\n       /* A non-static declaration (even an \"extern\") followed by a\n \t static declaration is undefined behavior per C99 6.2.2p3-5,7.\n@@ -2087,6 +2096,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t  if (!DECL_IS_BUILTIN (olddecl)\n \t      && !DECL_EXTERN_INLINE (olddecl))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error (\"static declaration of %q+D follows \"\n \t\t     \"non-static declaration\", newdecl);\n \t      locate_old_decl (olddecl);\n@@ -2097,6 +2107,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t{\n \t  if (DECL_CONTEXT (olddecl))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error (\"non-static declaration of %q+D follows \"\n \t\t     \"static declaration\", newdecl);\n \t      locate_old_decl (olddecl);\n@@ -2121,6 +2132,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t\t\t\t\tDECL_ATTRIBUTES (olddecl)) != NULL;\n \t  if (newa != olda)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error_at (input_location, \"%<gnu_inline%> attribute present on %q+D\",\n \t\t\tnewa ? newdecl : olddecl);\n \t      error_at (DECL_SOURCE_LOCATION (newa ? olddecl : newdecl),\n@@ -2141,6 +2153,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t}\n       else if (DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl))\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (DECL_THREAD_LOCAL_P (newdecl))\n \t    error (\"thread-local declaration of %q+D follows \"\n \t\t   \"non-thread-local declaration\", newdecl);\n@@ -2155,6 +2168,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       /* Multiple initialized definitions are not allowed (6.9p3,5).  */\n       if (DECL_INITIAL (newdecl) && DECL_INITIAL (olddecl))\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"redefinition of %q+D\", newdecl);\n \t  locate_old_decl (olddecl);\n \t  return false;\n@@ -2175,6 +2189,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    {\n \t      if (!DECL_FILE_SCOPE_P (olddecl))\n \t\t{\n+\t\t  auto_diagnostic_group d;\n \t\t  error (\"extern declaration of %q+D follows \"\n \t\t\t \"declaration with no linkage\", newdecl);\n \t\t  locate_old_decl (olddecl);\n@@ -2189,6 +2204,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    }\n \t  else\n \t    {\n+\t      auto_diagnostic_group d;\n \t      if (TREE_PUBLIC (newdecl))\n \t\terror (\"non-static declaration of %q+D follows \"\n \t\t       \"static declaration\", newdecl);\n@@ -2211,12 +2227,14 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    }\n \t  else if (DECL_EXTERNAL (olddecl))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error (\"declaration of %q+D with no linkage follows \"\n \t\t     \"extern declaration\", newdecl);\n \t      locate_old_decl (olddecl);\n \t    }\n \t  else\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error (\"redeclaration of %q+D with no linkage\", newdecl);\n \t      locate_old_decl (olddecl);\n \t    }\n@@ -2263,6 +2281,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       if (TREE_CODE (newdecl) == PARM_DECL\n \t  && (!TREE_ASM_WRITTEN (olddecl) || TREE_ASM_WRITTEN (newdecl)))\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"redefinition of parameter %q+D\", newdecl);\n \t  locate_old_decl (olddecl);\n \t  return false;\n@@ -2778,15 +2797,17 @@ warn_if_shadowing (tree new_decl)\n \t\t\t\t\t     DECL_SOURCE_LOCATION (b->decl))))\n       {\n \ttree old_decl = b->decl;\n-\tbool warned = false;\n \n \tif (old_decl == error_mark_node)\n \t  {\n \t    warning (OPT_Wshadow, \"declaration of %q+D shadows previous \"\n \t\t     \"non-variable\", new_decl);\n \t    break;\n \t  }\n-\telse if (TREE_CODE (old_decl) == PARM_DECL)\n+\n+\tbool warned = false;\n+\tauto_diagnostic_group d;\n+\tif (TREE_CODE (old_decl) == PARM_DECL)\n \t  {\n \t    enum opt_code warning_code;\n \n@@ -3123,6 +3144,7 @@ implicit_decl_warning (location_t loc, tree id, tree olddecl)\n     return;\n \n   bool warned;\n+  auto_diagnostic_group d;\n   name_hint hint;\n   if (!olddecl)\n     hint = lookup_name_fuzzy (id, FUZZY_LOOKUP_FUNCTION_NAME, loc);\n@@ -3435,6 +3457,7 @@ implicitly_declare (location_t loc, tree functionid)\n \t    {\n \t      if (!comptypes (newtype, TREE_TYPE (decl)))\n \t\t{\n+\t\t  auto_diagnostic_group d;\n \t\t  error_at (loc, \"incompatible implicit declaration of \"\n \t\t\t    \"function %qD\", decl);\n \t\t  locate_old_decl (decl);\n@@ -3487,6 +3510,7 @@ undeclared_variable (location_t loc, tree id)\n   static bool already = false;\n   struct c_scope *scope;\n \n+  auto_diagnostic_group d;\n   if (current_function_decl == NULL_TREE)\n     {\n       name_hint guessed_id = lookup_name_fuzzy (id, FUZZY_LOOKUP_NAME, loc);\n@@ -3686,6 +3710,7 @@ declare_label (tree name)\n      at this scope */\n   if (b && B_IN_CURRENT_SCOPE (b))\n     {\n+      auto_diagnostic_group d;\n       error (\"duplicate label declaration %qE\", name);\n       locate_old_decl (b->decl);\n \n@@ -3784,6 +3809,7 @@ define_label (location_t location, tree name)\n \t  || (DECL_CONTEXT (label) != current_function_decl\n \t      && C_DECLARED_LABEL_FLAG (label))))\n     {\n+      auto_diagnostic_group d;\n       error_at (location, \"duplicate label %qD\", label);\n       locate_old_decl (label);\n       return NULL_TREE;\n@@ -6720,6 +6746,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t  || (current_scope == file_scope && B_IN_EXTERNAL_SCOPE (b)))\n \t      && TYPE_MAIN_VARIANT (b->decl) != TYPE_MAIN_VARIANT (type))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      if (warning_at (declarator->id_loc, OPT_Wc___compat,\n \t\t\t      (\"using %qD as both a typedef and a tag is \"\n \t\t\t       \"invalid in C++\"), decl)\n@@ -8794,6 +8821,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t{\n \t  if (stdarg_p (TREE_TYPE (old_decl)))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      warning_at (loc, 0, \"%q+D defined as variadic function \"\n \t\t\t  \"without prototype\", decl1);\n \t      locate_old_decl (old_decl);"}, {"sha": "0d5dbea8f6770120e4c2360f11eed290e81b69bd", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1814,6 +1814,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t}\n       else\n \t{\n+\t  auto_diagnostic_group d;\n \t  name_hint hint = lookup_name_fuzzy (name, FUZZY_LOOKUP_TYPENAME,\n \t\t\t\t\t      here);\n \t  if (hint)\n@@ -4058,6 +4059,7 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n       c_parser_set_source_position_from_token (token);\n       if (c_parser_next_tokens_start_typename (parser, cla_prefer_type))\n \t{\n+\t  auto_diagnostic_group d;\n \t  name_hint hint = lookup_name_fuzzy (token->value,\n \t\t\t\t\t      FUZZY_LOOKUP_TYPENAME,\n \t\t\t\t\t      token->location);\n@@ -6873,14 +6875,18 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after,\n \t\t&& !(TREE_CODE (first_arg) == PARM_DECL\t\t\t      \\\n \t\t     && C_ARRAY_PARAMETER (first_arg)\t\t\t      \\\n \t\t     && warn_sizeof_array_argument))\t\t\t      \\\n-\t      if (warning_at (stack[sp].loc, OPT_Wsizeof_pointer_div,\t      \\\n-\t\t\t      \"division %<sizeof (%T) / sizeof (%T)%> does \"  \\\n-\t\t\t      \"not compute the number of array elements\",     \\\n-\t\t\t      type0, type1))\t\t\t\t      \\\n-\t\tif (DECL_P (first_arg))\t\t\t\t\t      \\\n-\t\t  inform (DECL_SOURCE_LOCATION (first_arg),\t\t      \\\n-\t\t\t  \"first %<sizeof%> operand was declared here\");      \\\n-\t  }\t\t\t\t\t\t\t\t      \\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tauto_diagnostic_group d;\t\t\t\t\t\\\n+\t\tif (warning_at (stack[sp].loc, OPT_Wsizeof_pointer_div, \\\n+\t\t\t\t  \"division %<sizeof (%T) / sizeof (%T)%> \" \\\n+\t\t\t\t  \"does not compute the number of array \" \\\n+\t\t\t\t  \"elements\",\t\t\t\t\\\n+\t\t\t\t  type0, type1))\t\t\t\\\n+\t\t  if (DECL_P (first_arg))\t\t\t\t\\\n+\t\t    inform (DECL_SOURCE_LOCATION (first_arg),\t\t\\\n+\t\t\t      \"first %<sizeof%> operand was declared here\"); \\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t      \\\n       default:\t\t\t\t\t\t\t\t      \\\n \tbreak;\t\t\t\t\t\t\t\t      \\"}, {"sha": "54c7967a06b84bc185d2601f25154506b1866147", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 54, "deletions": 24, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -2906,6 +2906,7 @@ c_expr_sizeof_expr (location_t loc, struct c_expr expr)\n       if (TREE_CODE (expr.value) == PARM_DECL\n \t  && C_ARRAY_PARAMETER (expr.value))\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (warning_at (loc, OPT_Wsizeof_array_argument,\n \t\t\t  \"%<sizeof%> on array function parameter %qE will \"\n \t\t\t  \"return size of %qT\", expr.value,\n@@ -3735,19 +3736,27 @@ parser_build_binary_op (location_t location, enum tree_code code,\n \t\t    \"comparison with string literal results in unspecified behavior\");\n       /* Warn for ptr == '\\0', it's likely that it should've been ptr[0].  */\n       if (POINTER_TYPE_P (type1)\n-\t   && null_pointer_constant_p (arg2.value)\n-\t   && char_type_p (type2)\n-\t   && warning_at (location, OPT_Wpointer_compare,\n-\t\t\t  \"comparison between pointer and zero character \"\n-\t\t\t  \"constant\"))\n-\tinform (arg1.get_start (), \"did you mean to dereference the pointer?\");\n+\t  && null_pointer_constant_p (arg2.value)\n+\t  && char_type_p (type2))\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  if (warning_at (location, OPT_Wpointer_compare,\n+\t\t\t    \"comparison between pointer and zero character \"\n+\t\t\t    \"constant\"))\n+\t    inform (arg1.get_start (),\n+\t\t      \"did you mean to dereference the pointer?\");\n+\t}\n       else if (POINTER_TYPE_P (type2)\n \t       && null_pointer_constant_p (arg1.value)\n-\t       && char_type_p (type1)\n-\t       && warning_at (location, OPT_Wpointer_compare,\n-\t\t\t      \"comparison between pointer and zero character \"\n-\t\t\t      \"constant\"))\n-\tinform (arg2.get_start (), \"did you mean to dereference the pointer?\");\n+\t       && char_type_p (type1))\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  if (warning_at (location, OPT_Wpointer_compare,\n+\t\t\t    \"comparison between pointer and zero character \"\n+\t\t\t    \"constant\"))\n+\t    inform (arg2.get_start (),\n+\t\t      \"did you mean to dereference the pointer?\");\n+\t}\n     }\n   else if (TREE_CODE_CLASS (code) == tcc_comparison\n \t   && (code1 == STRING_CST || code2 == STRING_CST))\n@@ -4288,13 +4297,16 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n \t    e = TREE_OPERAND (e, 1);\n \n \t  if ((TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE\n-\t       || truth_value_p (TREE_CODE (e)))\n-\t      && warning_at (location, OPT_Wbool_operation,\n-\t\t\t     \"%<~%> on a boolean expression\"))\n+\t       || truth_value_p (TREE_CODE (e))))\n \t    {\n-\t      gcc_rich_location richloc (location);\n-\t      richloc.add_fixit_insert_before (location, \"!\");\n-\t      inform (&richloc, \"did you mean to use logical not?\");\n+\t      auto_diagnostic_group d;\n+\t      if (warning_at (location, OPT_Wbool_operation,\n+\t\t\t\t\"%<~%> on a boolean expression\"))\n+\t\t{\n+\t\t  gcc_rich_location richloc (location);\n+\t\t  richloc.add_fixit_insert_before (location, \"!\");\n+\t\t  inform (&richloc, \"did you mean to use logical not?\");\n+\t\t}\n \t    }\n \t  if (!noconvert)\n \t    arg = default_conversion (arg);\n@@ -6197,6 +6209,8 @@ error_init (location_t loc, const char *gmsgid)\n {\n   char *ofwhat;\n \n+  auto_diagnostic_group d;\n+\n   /* The gmsgid may be a format string with %< and %>. */\n   error_at (loc, gmsgid);\n   ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n@@ -6216,7 +6230,7 @@ pedwarn_init (location_t loc, int opt, const char *gmsgid, ...)\n      it was defined to make sure macros defined in system headers\n      but used incorrectly elsewhere are diagnosed.  */\n   source_location exploc = expansion_point_location_if_in_system_header (loc);\n-\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   bool warned = emit_diagnostic_valist (DK_PEDWARN, exploc, opt, gmsgid, &ap);\n@@ -6238,6 +6252,8 @@ warning_init (location_t loc, int opt, const char *gmsgid)\n   char *ofwhat;\n   bool warned;\n \n+  auto_diagnostic_group d;\n+\n   /* Use the location where a macro was expanded rather than where\n      it was defined to make sure macros defined in system headers\n      but used incorrectly elsewhere are diagnosed.  */\n@@ -6379,8 +6395,11 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n     switch (errtype)                                                     \\\n       {                                                                  \\\n       case ic_argpass:                                                   \\\n-        if (pedwarn (PLOC, OPT, AR, parmnum, rname))\t\t\t \\\n-          inform_for_arg (fundecl, (PLOC), parmnum, type, rhstype);\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  auto_diagnostic_group d;\t\t\t\t\t\t\\\n+\t  if (pedwarn (PLOC, OPT, AR, parmnum, rname))\t\t\\\n+\t    inform_for_arg (fundecl, (PLOC), parmnum, type, rhstype); \\\n+\t}\t\t\t\t\t\t\t\t\\\n         break;                                                           \\\n       case ic_assign:                                                    \\\n         pedwarn (LOCATION, OPT, AS);                                     \\\n@@ -6405,8 +6424,11 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n     switch (errtype)                                                     \\\n       {                                                                  \\\n       case ic_argpass:                                                   \\\n-        if (pedwarn (PLOC, OPT, AR, parmnum, rname, QUALS))\t\t \\\n-          inform_for_arg (fundecl, (PLOC), parmnum, type, rhstype);\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\tauto_diagnostic_group d;\t\t\t\t\t\t\\\n+\tif (pedwarn (PLOC, OPT, AR, parmnum, rname, QUALS))\t\t\\\n+\t  inform_for_arg (fundecl, (PLOC), parmnum, type, rhstype);\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n         break;                                                           \\\n       case ic_assign:                                                    \\\n         pedwarn (LOCATION, OPT, AS, QUALS);\t\t\t\t \\\n@@ -6431,8 +6453,11 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n     switch (errtype)                                                     \\\n       {                                                                  \\\n       case ic_argpass:                                                   \\\n-        if (warning_at (PLOC, OPT, AR, parmnum, rname, QUALS))           \\\n-          inform_for_arg (fundecl, (PLOC), parmnum, type, rhstype);      \\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  auto_diagnostic_group d;\t\t\t\t\t\t\\\n+\t  if (warning_at (PLOC, OPT, AR, parmnum, rname, QUALS))\t\\\n+\t    inform_for_arg (fundecl, (PLOC), parmnum, type, rhstype); \\\n+\t}\t\t\t\t\t\t\t\t\\\n         break;                                                           \\\n       case ic_assign:                                                    \\\n         warning_at (LOCATION, OPT, AS, QUALS);                           \\\n@@ -6925,6 +6950,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t  {\n \t\t  case ic_argpass:\n \t\t    {\n+\t\t      auto_diagnostic_group d;\n \t\t      range_label_for_type_mismatch rhs_label (rhstype, type);\n \t\t      gcc_rich_location richloc (expr_loc, &rhs_label);\n \t\t      if (pedwarn (&richloc, OPT_Wpointer_sign,\n@@ -6984,6 +7010,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t    {\n \t    case ic_argpass:\n \t      {\n+\t\tauto_diagnostic_group d;\n \t\trange_label_for_type_mismatch rhs_label (rhstype, type);\n \t\tgcc_rich_location richloc (expr_loc, &rhs_label);\n \t\tif (pedwarn (&richloc, OPT_Wincompatible_pointer_types,\n@@ -7031,6 +7058,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t  {\n \t  case ic_argpass:\n \t    {\n+\t      auto_diagnostic_group d;\n \t      range_label_for_type_mismatch rhs_label (rhstype, type);\n \t      gcc_rich_location richloc (expr_loc, &rhs_label);\n \t      if (pedwarn (&richloc, OPT_Wint_conversion,\n@@ -7066,6 +7094,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t{\n \tcase ic_argpass:\n \t  {\n+\t    auto_diagnostic_group d;\n \t    range_label_for_type_mismatch rhs_label (rhstype, type);\n \t    gcc_rich_location richloc (expr_loc, &rhs_label);\n \t    if (pedwarn (&richloc, OPT_Wint_conversion,\n@@ -7109,6 +7138,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n     {\n     case ic_argpass:\n       {\n+\tauto_diagnostic_group d;\n \trange_label_for_type_mismatch rhs_label (rhstype, type);\n \tgcc_rich_location richloc (expr_loc, &rhs_label);\n \terror_at (&richloc, \"incompatible type for argument %d of %qE\", parmnum,"}, {"sha": "0fb10b182b1a34c4e9c4f786e592397a646f7eef", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1773,6 +1773,7 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \n       bool warned = false;\n \n+      auto_diagnostic_group d;\n       if (wi::ltu_p (asize, wibnd))\n \t{\n \t  if (bndrng[0] == bndrng[1])"}, {"sha": "208798f0dc7a8e636e91ff7bb70a1f5cff4c97cc", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1358,19 +1358,24 @@ maybe_diag_incompatible_alias (tree alias, tree target)\n \t{\n \t  funcptr = build_pointer_type (funcptr);\n \n+\t  auto_diagnostic_group d;\n \t  if (warning_at (DECL_SOURCE_LOCATION (target),\n \t\t\t  OPT_Wattribute_alias,\n \t\t\t  \"%<ifunc%> resolver for %qD should return %qT\",\n \t\t\t  alias, funcptr))\n \t    inform (DECL_SOURCE_LOCATION (alias),\n \t\t    \"resolver indirect function declared here\");\n \t}\n-      else if (warning_at (DECL_SOURCE_LOCATION (alias),\n-\t\t\t   OPT_Wattribute_alias,\n-\t\t\t   \"%qD alias between functions of incompatible \"\n-\t\t\t   \"types %qT and %qT\", alias, altype, targtype))\n-\tinform (DECL_SOURCE_LOCATION (target),\n-\t\t\"aliased declaration here\");\n+      else\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  if (warning_at (DECL_SOURCE_LOCATION (alias),\n+\t\t\t    OPT_Wattribute_alias,\n+\t\t\t    \"%qD alias between functions of incompatible \"\n+\t\t\t    \"types %qT and %qT\", alias, altype, targtype))\n+\t    inform (DECL_SOURCE_LOCATION (target),\n+\t\t      \"aliased declaration here\");\n+\t}\n     }\n }\n "}, {"sha": "28c09740aa697071a6b424d57348854e302cc14a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1,3 +1,73 @@\n+2018-08-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR other/84889\n+\t* call.c (build_user_type_conversion_1): Add auto_diagnostic_group\n+\tinstance(s).\n+\t(print_error_for_call_failure): Likewise.\n+\t(build_op_call_1): Likewise.\n+\t(build_conditional_expr_1): Likewise.\n+\t(build_new_op_1): Likewise.\n+\t(build_op_delete_call): Likewise.\n+\t(convert_like_real): Likewise.\n+\t(build_over_call): Likewise.\n+\t(build_new_method_call_1): Likewise.\n+\t(joust): Likewise.\n+\t* class.c (check_tag): Likewise.\n+\t(finish_struct_anon_r): Likewise.\n+\t(one_inherited_ctor): Likewise.\n+\t(finalize_literal_type_property): Likewise.\n+\t(explain_non_literal_class): Likewise.\n+\t(find_flexarrays): Likewise.\n+\t(resolve_address_of_overloaded_function): Likewise.\n+\t* constexpr.c (ensure_literal_type_for_constexpr_object): Likewise.\n+\t(is_valid_constexpr_fn): Likewise.\n+\t(cx_check_missing_mem_inits): Likewise.\n+\t* cp-gimplify.c (cp_genericize_r): Likewise.\n+\t* cvt.c (maybe_warn_nodiscard): Likewise.\n+\t* decl.c (warn_extern_redeclared_static): Likewise.\n+\t(check_redeclaration_exception_specification): Likewise.\n+\t(check_no_redeclaration_friend_default_args): Likewise.\n+\t(duplicate_decls): Likewise.\n+\t(redeclaration_error_message): Likewise.\n+\t(warn_misplaced_attr_for_class_type): Likewise.\n+\t* decl2.c (finish_static_data_member_decl): Likewise.\n+\t(no_linkage_error): Likewise.\n+\t(cp_warn_deprecated_use): Likewise.\n+\t* error.c (qualified_name_lookup_error): Likewise.\n+\t* friend.c (make_friend_class): Likewise.\n+\t(do_friend): Likewise.\n+\t* init.c (perform_member_init): Likewise.\n+\t(build_new_1): Likewise.\n+\t(build_vec_delete_1): Likewise.\n+\t(build_delete): Likewise.\n+\t* lex.c (unqualified_name_lookup_error): Likewise.\n+\t* name-lookup.c (check_extern_c_conflict): Likewise.\n+\t(inform_shadowed): New function.\n+\t(check_local_shadow): Add auto_diagnostic_group instances,\n+\treplacing goto \"inform_shadowed\" label with call to subroutine.\n+\t(set_local_extern_decl_linkage): Add auto_diagnostic_group\n+\tinstance(s).\n+\t* parser.c (cp_parser_diagnose_invalid_type_name): Likewise.\n+\t(cp_parser_namespace_name): Likewise.\n+\t* pt.c (check_specialization_namespace): Likewise.\n+\t(check_template_variable): Likewise.\n+\t(warn_spec_missing_attributes): Likewise.\n+\t(check_explicit_specialization): Likewise.\n+\t(process_partial_specialization): Likewise.\n+\t(lookup_template_class_1): Likewise.\n+\t(finish_template_variable): Likewise.\n+\t(do_auto_deduction): Likewise.\n+\t* search.c (check_final_overrider): Likewise.\n+\t(look_for_overrides_r): Likewise.\n+\t* tree.c (maybe_warn_parm_abi): Likewise.\n+\t* typeck.c (cxx_sizeof_expr): Likewise.\n+\t(cp_build_function_call_vec): Likewise.\n+\t(cp_build_binary_op): Likewise.\n+\t(convert_for_assignment): Likewise.\n+\t(maybe_warn_about_returning_address_of_local): Likewise.\n+\t* typeck2.c (abstract_virtuals_error_sfinae): Likewise.\n+\t(check_narrowing): Likewise.\n+\n 2018-08-17  David Malcolm  <dmalcolm@redhat.com>\n \n \t* typeck.c (string_conv_p): Extract location from EXP and use it"}, {"sha": "1f72ac863bde4ebe54d946582ba3c6d4f307db3c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -3968,6 +3968,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n     {\n       if (complain & tf_error)\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"conversion from %qH to %qI is ambiguous\",\n \t\t fromtype, totype);\n \t  print_z_candidates (location_of (expr), candidates);\n@@ -4280,6 +4281,7 @@ print_error_for_call_failure (tree fn, vec<tree, va_gc> *args,\n   if (targs)\n     name = lookup_template_function (name, targs);\n \n+  auto_diagnostic_group d;\n   if (!any_strictly_viable (candidates))\n     error_at (loc, \"no matching function for call to %<%D(%A)%>\",\n \t      name, build_tree_list_vec (args));\n@@ -4590,6 +4592,7 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n     {\n       if (complain & tf_error)\n         {\n+          auto_diagnostic_group d;\n           error (\"no match for call to %<(%T) (%A)%>\", TREE_TYPE (obj),\n \t\t build_tree_list_vec (*args));\n           print_z_candidates (location_of (TREE_TYPE (obj)), candidates);\n@@ -4603,6 +4606,7 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n \t{\n           if (complain & tf_error)\n             {\n+              auto_diagnostic_group d;\n               error (\"call of %<(%T) (%A)%> is ambiguous\", \n                      TREE_TYPE (obj), build_tree_list_vec (*args));\n               print_z_candidates (location_of (TREE_TYPE (obj)), candidates);\n@@ -5229,6 +5233,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t{\n           if (complain & tf_error)\n             {\n+              auto_diagnostic_group d;\n               op_error (loc, COND_EXPR, NOP_EXPR, arg1, arg2, arg3, FALSE);\n               print_z_candidates (loc, candidates);\n             }\n@@ -5860,6 +5865,7 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t\t  {\n \t\t    /* ... Otherwise, report the more generic\n \t\t       \"no matching operator found\" error */\n+\t\t    auto_diagnostic_group d;\n \t\t    op_error (loc, code, code2, arg1, arg2, arg3, FALSE);\n \t\t    print_z_candidates (loc, candidates);\n \t\t  }\n@@ -5875,6 +5881,7 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t{\n \t  if (complain & tf_error)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      op_error (loc, code, code2, arg1, arg2, arg3, TRUE);\n \t      print_z_candidates (loc, candidates);\n \t    }\n@@ -6311,14 +6318,18 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t     -Wc++14-compat.  */\n \t  else if (!flag_sized_deallocation)\n \t    {\n-\t      if ((complain & tf_warning)\n-\t\t  && warning (OPT_Wc__14_compat, msg1))\n-\t\tinform (DECL_SOURCE_LOCATION (fn), msg2, fn);\n+\t      if (complain & tf_warning)\n+\t\t{\n+\t\t  auto_diagnostic_group d;\n+\t\t  if (warning (OPT_Wc__14_compat, msg1))\n+\t\t    inform (DECL_SOURCE_LOCATION (fn), msg2, fn);\n+\t\t}\n \t      goto ok;\n \t    }\n \n \t  if (complain & tf_warning_or_error)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      if (permerror (input_location, msg1))\n \t\t{\n \t\t  /* Only mention C++14 for namespace-scope delete.  */\n@@ -6712,6 +6723,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t{\n \t  if (t->kind == ck_user && t->cand->reason)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      complained = permerror (loc, \"invalid user-defined conversion \"\n \t\t\t\t      \"from %qH to %qI\", TREE_TYPE (expr),\n \t\t\t\t      totype);\n@@ -6795,6 +6807,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    if (CONSTRUCTOR_NELTS (expr) == 0\n \t\t&& FUNCTION_FIRST_USER_PARMTYPE (convfn) != void_list_node)\n \t      {\n+\t\tauto_diagnostic_group d;\n \t\tif (pedwarn (loc, 0, \"converting to %qT from initializer list \"\n \t\t\t     \"would use explicit constructor %qD\",\n \t\t\t     totype, convfn))\n@@ -6973,6 +6986,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t{\n \t  if (complain & tf_error)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      maybe_print_user_conv_context (convs);\n \t      if (fn)\n \t\tinform (DECL_SOURCE_LOCATION (fn),\n@@ -7025,6 +7039,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       expr = build_temp (expr, totype, flags, &diag_kind, complain);\n       if (diag_kind && complain)\n \t{\n+\t  auto_diagnostic_group d;\n \t  maybe_print_user_conv_context (convs);\n \t  if (fn)\n \t    inform (DECL_SOURCE_LOCATION (fn),\n@@ -7040,6 +7055,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \tif (convs->bad_p && !next_conversion (convs)->bad_p)\n \t  {\n \t    tree extype = TREE_TYPE (expr);\n+\t    auto_diagnostic_group d;\n \t    if (TYPE_REF_IS_RVALUE (ref_type)\n \t\t&& lvalue_p (expr))\n \t      error_at (loc, \"cannot bind rvalue reference of type %qH to \"\n@@ -7931,6 +7947,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t{\n \t  if (complain & tf_error)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      if (permerror (input_location, \"passing %qT as %<this%> \"\n \t\t\t     \"argument discards qualifiers\",\n \t\t\t     TREE_TYPE (argtype)))\n@@ -9212,6 +9229,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \n       basetype = DECL_CONTEXT (fn);\n       name = constructor_name (basetype);\n+      auto_diagnostic_group d;\n       if (permerror (input_location,\n \t\t     \"cannot call constructor %<%T::%D%> directly\",\n \t\t     basetype, name))\n@@ -9350,6 +9368,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n     {\n       if (complain & tf_error)\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (!COMPLETE_OR_OPEN_TYPE_P (basetype))\n \t    cxx_incomplete_type_error (instance, basetype);\n \t  else if (optype)\n@@ -9393,6 +9412,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t      arglist = build_tree_list_vec (user_args);\n \t      if (skip_first_for_error)\n \t\targlist = TREE_CHAIN (arglist);\n+\t      auto_diagnostic_group d;\n \t      if (!any_strictly_viable (candidates))\n \t\terror (\"no matching function for call to %<%s(%A)%>\",\n \t\t       pretty_name, arglist);\n@@ -10299,6 +10319,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \t  tree source = source_type (w->convs[0]);\n \t  if (INDIRECT_TYPE_P (source))\n \t    source = TREE_TYPE (source);\n+\t  auto_diagnostic_group d;\n \t  if (warning (OPT_Wconversion, \"choosing %qD over %qD\", w->fn, l->fn)\n \t      && warning (OPT_Wconversion, \"  for conversion from %qH to %qI\",\n \t\t\t  source, w->second_conv->type)) \n@@ -10526,6 +10547,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \t\t{\n \t\t  if (complain & tf_error)\n \t\t    {\n+\t\t      auto_diagnostic_group d;\n \t\t      if (permerror (input_location,\n \t\t\t\t     \"default argument mismatch in \"\n \t\t\t\t     \"overload resolution\"))\n@@ -10577,6 +10599,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \t    return 0;\n \t  if (warn)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      pedwarn (input_location, 0,\n \t      \"ISO C++ says that these are ambiguous, even \"\n \t      \"though the worst conversion for the first is better than \""}, {"sha": "e11173d2e59bc5c08b31f44ec871ded2b819b957", "filename": "gcc/cp/class.c", "status": "modified", "additions": 47, "deletions": 28, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1331,26 +1331,30 @@ check_tag (tree tag, tree id, tree *tp, abi_tag_data *p)\n       /* Otherwise we're diagnosing missing tags.  */\n       if (TREE_CODE (p->t) == FUNCTION_DECL)\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (warning (OPT_Wabi_tag, \"%qD inherits the %E ABI tag \"\n \t\t       \"that %qT (used in its return type) has\",\n \t\t       p->t, tag, *tp))\n \t    inform (location_of (*tp), \"%qT declared here\", *tp);\n \t}\n       else if (VAR_P (p->t))\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (warning (OPT_Wabi_tag, \"%qD inherits the %E ABI tag \"\n \t\t       \"that %qT (used in its type) has\", p->t, tag, *tp))\n \t    inform (location_of (*tp), \"%qT declared here\", *tp);\n \t}\n       else if (TYPE_P (p->subob))\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (warning (OPT_Wabi_tag, \"%qT does not have the %E ABI tag \"\n \t\t       \"that base %qT has\", p->t, tag, p->subob))\n \t    inform (location_of (p->subob), \"%qT declared here\",\n \t\t    p->subob);\n \t}\n       else\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (warning (OPT_Wabi_tag, \"%qT does not have the %E ABI tag \"\n \t\t       \"that %qT (used in the type of %qD) has\",\n \t\t       p->t, tag, *tp, p->subob))\n@@ -2904,20 +2908,24 @@ finish_struct_anon_r (tree field, bool complain)\n \t{\n \t  /* We already complained about static data members in\n \t     finish_static_data_member_decl.  */\n-\t  if (!VAR_P (elt)\n-\t      && permerror (DECL_SOURCE_LOCATION (elt),\n-\t\t\t    TREE_CODE (TREE_TYPE (field)) == UNION_TYPE\n-\t\t\t    ? \"%q#D invalid; an anonymous union may \"\n-\t\t\t    \"only have public non-static data members\"\n-\t\t\t    : \"%q#D invalid; an anonymous struct may \"\n-\t\t\t    \"only have public non-static data members\", elt))\n+\t  if (!VAR_P (elt))\n \t    {\n-\t      static bool hint;\n-\t      if (flag_permissive && !hint)\n+\t      auto_diagnostic_group d;\n+\t      if (permerror (DECL_SOURCE_LOCATION (elt),\n+\t\t\t     TREE_CODE (TREE_TYPE (field)) == UNION_TYPE\n+\t\t\t     ? \"%q#D invalid; an anonymous union may \"\n+\t\t\t     \"only have public non-static data members\"\n+\t\t\t     : \"%q#D invalid; an anonymous struct may \"\n+\t\t\t     \"only have public non-static data members\", elt))\n \t\t{\n-\t\t  hint = true;\n-\t\t  inform (DECL_SOURCE_LOCATION (elt),\n-\t\t\t  \"this flexibility is deprecated and will be removed\");\n+\t\t  static bool hint;\n+\t\t  if (flag_permissive && !hint)\n+\t\t    {\n+\t\t      hint = true;\n+\t\t      inform (DECL_SOURCE_LOCATION (elt),\n+\t\t\t      \"this flexibility is deprecated and will be \"\n+\t\t\t      \"removed\");\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -3107,6 +3115,7 @@ one_inherited_ctor (tree ctor, tree t, tree using_decl)\n   one_inheriting_sig (t, ctor, new_parms, i);\n   if (parms == NULL_TREE)\n     {\n+      auto_diagnostic_group d;\n       if (warning (OPT_Winherited_variadic_ctor,\n \t\t   \"the ellipsis in %qD is not inherited\", ctor))\n \tinform (DECL_SOURCE_LOCATION (ctor), \"%qD declared here\", ctor);\n@@ -5399,11 +5408,14 @@ finalize_literal_type_property (tree t)\n \t  && !DECL_CONSTRUCTOR_P (fn))\n \t{\n \t  DECL_DECLARED_CONSTEXPR_P (fn) = false;\n-\t  if (!DECL_GENERATED_P (fn)\n-\t      && pedwarn (DECL_SOURCE_LOCATION (fn), OPT_Wpedantic,\n-\t\t\t  \"enclosing class of %<constexpr%> non-static member \"\n-\t\t\t  \"function %q+#D is not a literal type\", fn))\n-\t    explain_non_literal_class (t);\n+\t  if (!DECL_GENERATED_P (fn))\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      if (pedwarn (DECL_SOURCE_LOCATION (fn), OPT_Wpedantic,\n+\t\t\t     \"enclosing class of %<constexpr%> non-static \"\n+\t\t\t     \"member function %q+#D is not a literal type\", fn))\n+\t\texplain_non_literal_class (t);\n+\t    }\n \t}\n }\n \n@@ -5425,6 +5437,7 @@ explain_non_literal_class (tree t)\n     /* Already explained.  */\n     return;\n \n+  auto_diagnostic_group d;\n   inform (UNKNOWN_LOCATION, \"%q+T is not literal because:\", t);\n   if (cxx_dialect < cxx17 && LAMBDA_TYPE_P (t))\n     inform (UNKNOWN_LOCATION,\n@@ -6626,17 +6639,20 @@ find_flexarrays (tree t, flexmems_t *fmem, bool base_p,\n static void\n diagnose_invalid_flexarray (const flexmems_t *fmem)\n {\n-  if (fmem->array && fmem->enclosing\n-      && pedwarn (location_of (fmem->enclosing), OPT_Wpedantic,\n-\t\t  TYPE_DOMAIN (TREE_TYPE (fmem->array))\n-\t\t  ? G_(\"invalid use of %q#T with a zero-size array \"\n-\t\t       \"in %q#D\")\n-\t\t  : G_(\"invalid use of %q#T with a flexible array member \"\n-\t\t       \"in %q#T\"),\n-\t\t  DECL_CONTEXT (fmem->array),\n-\t\t  DECL_CONTEXT (fmem->enclosing)))\n-    inform (DECL_SOURCE_LOCATION (fmem->array),\n-\t    \"array member %q#D declared here\", fmem->array);\n+  if (fmem->array && fmem->enclosing)\n+    {\n+      auto_diagnostic_group d;\n+      if (pedwarn (location_of (fmem->enclosing), OPT_Wpedantic,\n+\t\t     TYPE_DOMAIN (TREE_TYPE (fmem->array))\n+\t\t     ? G_(\"invalid use of %q#T with a zero-size array \"\n+\t\t\t  \"in %q#D\")\n+\t\t     : G_(\"invalid use of %q#T with a flexible array member \"\n+\t\t\t  \"in %q#T\"),\n+\t\t     DECL_CONTEXT (fmem->array),\n+\t\t     DECL_CONTEXT (fmem->enclosing)))\n+\tinform (DECL_SOURCE_LOCATION (fmem->array),\n+\t\t  \"array member %q#D declared here\", fmem->array);\n+    }\n }\n \n /* Issue diagnostics for invalid flexible array members or zero-length\n@@ -6671,6 +6687,7 @@ diagnose_flexarrays (tree t, const flexmems_t *fmem)\n \t{\n \t  location_t loc = DECL_SOURCE_LOCATION (fmem->array);\n \n+\t  auto_diagnostic_group d;\n \t  if (pedwarn (loc, OPT_Wpedantic, msg, fmem->array, t))\n \t    {\n \t      inform (location_of (t), \"in the definition of %q#T\", t);\n@@ -6690,6 +6707,7 @@ diagnose_flexarrays (tree t, const flexmems_t *fmem)\n \t  location_t loc = DECL_SOURCE_LOCATION (fmem->array);\n \t  diagd = true;\n \n+\t  auto_diagnostic_group d;\n \t  error_at (loc, msg, fmem->array, t);\n \n \t  /* In the unlikely event that the member following the flexible\n@@ -7923,6 +7941,7 @@ resolve_address_of_overloaded_function (tree target_type,\n       if (!(complain & tf_error))\n \treturn error_mark_node;\n \n+      auto_diagnostic_group d;\n       if (permerror (input_location, \"assuming pointer to member %qD\", fn)\n \t  && !explained)\n \t{"}, {"sha": "54c8b5edf8d155d12635bdfdf096fc041464a370", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -97,6 +97,7 @@ ensure_literal_type_for_constexpr_object (tree decl)\n \t{\n \t  if (DECL_DECLARED_CONSTEXPR_P (decl))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error (\"the type %qT of %<constexpr%> variable %qD \"\n \t\t     \"is not literal\", type, decl);\n \t      explain_non_literal_class (type);\n@@ -106,6 +107,7 @@ ensure_literal_type_for_constexpr_object (tree decl)\n \t    {\n \t      if (!is_instantiation_of_constexpr (current_function_decl))\n \t\t{\n+\t\t  auto_diagnostic_group d;\n \t\t  error (\"variable %qD of non-literal type %qT in %<constexpr%> \"\n \t\t\t \"function\", decl, type);\n \t\t  explain_non_literal_class (type);\n@@ -200,6 +202,7 @@ is_valid_constexpr_fn (tree fun, bool complain)\n \t    ret = false;\n \t    if (complain)\n \t      {\n+\t\tauto_diagnostic_group d;\n \t\terror (\"invalid type for parameter %d of %<constexpr%> \"\n \t\t       \"function %q+#D\", DECL_PARM_INDEX (parm), fun);\n \t\texplain_non_literal_class (TREE_TYPE (parm));\n@@ -222,6 +225,7 @@ is_valid_constexpr_fn (tree fun, bool complain)\n \t  ret = false;\n \t  if (complain)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error (\"invalid return type %qT of %<constexpr%> function %q+D\",\n \t\t     rettype, fun);\n \t      explain_non_literal_class (rettype);\n@@ -234,11 +238,15 @@ is_valid_constexpr_fn (tree fun, bool complain)\n \t  && !CLASSTYPE_LITERAL_P (DECL_CONTEXT (fun)))\n \t{\n \t  ret = false;\n-\t  if (complain\n-\t      && pedwarn (DECL_SOURCE_LOCATION (fun), OPT_Wpedantic,\n-\t\t\t  \"enclosing class of %<constexpr%> non-static member \"\n-\t\t\t  \"function %q+#D is not a literal type\", fun))\n-\t    explain_non_literal_class (DECL_CONTEXT (fun));\n+\t  if (complain)\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      if (pedwarn (DECL_SOURCE_LOCATION (fun), OPT_Wpedantic,\n+\t\t\t     \"enclosing class of %<constexpr%> non-static\"\n+\t\t\t     \" member function %q+#D is not a literal type\",\n+\t\t\t     fun))\n+\t\texplain_non_literal_class (DECL_CONTEXT (fun));\n+\t    }\n \t}\n     }\n   else if (CLASSTYPE_VBASECLASSES (DECL_CONTEXT (fun)))\n@@ -818,6 +826,7 @@ cx_check_missing_mem_inits (tree ctype, tree body, bool complain)\n \t    }\n \t  if (!complain)\n \t    return true;\n+\t  auto_diagnostic_group d;\n \t  error (\"member %qD must be initialized by mem-initializer \"\n \t\t \"in %<constexpr%> constructor\", field);\n \t  inform (DECL_SOURCE_LOCATION (field), \"declared here\");\n@@ -4303,6 +4312,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t{\n \t  if (!ctx->quiet)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error (\"temporary of non-literal type %qT in a \"\n \t\t     \"constant expression\", TREE_TYPE (t));\n \t      explain_non_literal_class (TREE_TYPE (t));\n@@ -5995,6 +6005,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t{\n \t  if (flags & tf_error)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error_at (loc, \"temporary of non-literal type %qT in a \"\n \t\t\t\"constant expression\", TREE_TYPE (t));\n \t      explain_non_literal_class (TREE_TYPE (t));"}, {"sha": "f61099141026b793daab149f989ca2b14d265d48", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1420,12 +1420,15 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t  /* Never mind.  */;\n \telse if (wtd->try_block)\n \t  {\n-\t    if (TREE_CODE (wtd->try_block) == MUST_NOT_THROW_EXPR\n-\t\t&& warning_at (loc, OPT_Wterminate,\n-\t\t\t       \"throw will always call terminate()\")\n-\t\t&& cxx_dialect >= cxx11\n-\t\t&& DECL_DESTRUCTOR_P (current_function_decl))\n-\t      inform (loc, \"in C++11 destructors default to noexcept\");\n+\t    if (TREE_CODE (wtd->try_block) == MUST_NOT_THROW_EXPR)\n+\t      {\n+\t\tauto_diagnostic_group d;\n+\t\tif (warning_at (loc, OPT_Wterminate,\n+\t\t\t\t\"throw will always call terminate()\")\n+\t\t    && cxx_dialect >= cxx11\n+\t\t    && DECL_DESTRUCTOR_P (current_function_decl))\n+\t\t  inform (loc, \"in C++11 destructors default to noexcept\");\n+\t      }\n \t  }\n \telse\n \t  {"}, {"sha": "315b0d6a65acbeb2455478ca42e9cfae70d0089a", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1017,6 +1017,7 @@ maybe_warn_nodiscard (tree expr, impl_conv_void implicit)\n   if (implicit != ICV_CAST && fn\n       && lookup_attribute (\"nodiscard\", DECL_ATTRIBUTES (fn)))\n     {\n+      auto_diagnostic_group d;\n       if (warning_at (loc, OPT_Wunused_result,\n \t\t      \"ignoring return value of %qD, \"\n \t\t      \"declared with attribute nodiscard\", fn))\n@@ -1025,6 +1026,7 @@ maybe_warn_nodiscard (tree expr, impl_conv_void implicit)\n   else if (implicit != ICV_CAST\n \t   && lookup_attribute (\"nodiscard\", TYPE_ATTRIBUTES (rettype)))\n     {\n+      auto_diagnostic_group d;\n       if (warning_at (loc, OPT_Wunused_result,\n \t\t      \"ignoring returned value of type %qT, \"\n \t\t      \"declared with attribute nodiscard\", rettype))\n@@ -1043,6 +1045,7 @@ maybe_warn_nodiscard (tree expr, impl_conv_void implicit)\n \t result is used, so handle that case here.  */\n       if (fn)\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (warning_at (loc, OPT_Wunused_result,\n \t\t\t  \"ignoring return value of %qD, \"\n \t\t\t  \"declared with attribute warn_unused_result\","}, {"sha": "f6dbd6b11c36f907f33df89186f6d697921bbe8f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1133,6 +1133,7 @@ warn_extern_redeclared_static (tree newdecl, tree olddecl)\n       && DECL_ARTIFICIAL (olddecl))\n     return;\n \n+  auto_diagnostic_group d;\n   if (permerror (DECL_SOURCE_LOCATION (newdecl),\n \t\t \"%qD was declared %<extern%> and later %<static%>\", newdecl))\n     inform (DECL_SOURCE_LOCATION (olddecl),\n@@ -1176,6 +1177,7 @@ check_redeclaration_exception_specification (tree new_decl,\n \t= G_(\"declaration of %qF has a different exception specifier\");\n       bool complained = true;\n       location_t new_loc = DECL_SOURCE_LOCATION (new_decl);\n+      auto_diagnostic_group d;\n       if (DECL_IN_SYSTEM_HEADER (old_decl))\n \tcomplained = pedwarn (new_loc, OPT_Wsystem_headers, msg, new_decl);\n       else if (!flag_exceptions)\n@@ -1304,6 +1306,7 @@ check_no_redeclaration_friend_default_args (tree olddecl, tree newdecl,\n     if ((olddecl_hidden_friend_p && TREE_PURPOSE (t1))\n \t|| (DECL_FRIEND_P (newdecl) && TREE_PURPOSE (t2)))\n       {\n+\tauto_diagnostic_group d;\n \tif (permerror (DECL_SOURCE_LOCATION (newdecl),\n \t\t       \"friend declaration of %q#D specifies default \"\n \t\t       \"arguments and isn't the only declaration\", newdecl))\n@@ -1555,6 +1558,7 @@ next_arg:;\n \t\t\t\t    \"declaration %q#D\", newdecl, olddecl);\n \t\t\t  return error_mark_node;\n \t\t\t}\n+\t\t      auto_diagnostic_group d;\n \t\t      if (permerror (newdecl_loc,\n \t\t\t\t     \"new declaration %q#D ambiguates built-in\"\n \t\t\t\t     \" declaration %q#D\", newdecl, olddecl)\n@@ -1801,6 +1805,7 @@ next_arg:;\n       const char *errmsg = redeclaration_error_message (newdecl, olddecl);\n       if (errmsg)\n \t{\n+\t  auto_diagnostic_group d;\n \t  error_at (newdecl_loc, errmsg, newdecl);\n \t  if (DECL_NAME (olddecl) != NULL_TREE)\n \t    inform (olddecl_loc,\n@@ -1815,6 +1820,7 @@ next_arg:;\n \t       && prototype_p (TREE_TYPE (newdecl)))\n \t{\n \t  /* Prototype decl follows defn w/o prototype.  */\n+\t  auto_diagnostic_group d;\n \t  if (warning_at (newdecl_loc, 0,\n \t\t\t  \"prototype specified for %q#D\", newdecl))\n \t    inform (olddecl_loc,\n@@ -1856,6 +1862,7 @@ next_arg:;\n \t    }\n \t  else\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error_at (newdecl_loc,\n \t\t\t\"conflicting declaration of %q#D with %qL linkage\",\n \t\t\tnewdecl, DECL_LANGUAGE (newdecl));\n@@ -1893,6 +1900,7 @@ next_arg:;\n \t\t    if (simple_cst_equal (TREE_PURPOSE (t1),\n \t\t\t\t\t  TREE_PURPOSE (t2)) == 1)\n \t\t      {\n+\t\t\tauto_diagnostic_group d;\n \t\t\tif (permerror (newdecl_loc,\n \t\t\t\t       \"default argument given for parameter \"\n \t\t\t\t       \"%d of %q#D\", i, newdecl))\n@@ -1902,6 +1910,7 @@ next_arg:;\n \t\t      }\n \t\t    else\n \t\t      {\n+\t\t\tauto_diagnostic_group d;\n \t\t\terror_at (newdecl_loc,\n \t\t\t\t  \"default argument given for parameter %d \"\n \t\t\t\t  \"of %q#D\", i, newdecl);\n@@ -1977,6 +1986,7 @@ next_arg:;\n \t  && (! DECL_TEMPLATE_SPECIALIZATION (newdecl)\n \t      || DECL_TEMPLATE_SPECIALIZATION (olddecl)))\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (warning_at (newdecl_loc,\n \t\t\t  OPT_Wredundant_decls,\n \t\t\t  \"redundant redeclaration of %qD in same scope\",\n@@ -1990,6 +2000,7 @@ next_arg:;\n \t{\n \t  if (DECL_DELETED_FN (newdecl))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      error_at (newdecl_loc, \"deleted definition of %qD\", newdecl);\n \t      inform (olddecl_loc,\n \t\t      \"previous declaration of %qD\", olddecl);\n@@ -2567,6 +2578,7 @@ next_arg:;\n       && DECL_VISIBILITY_SPECIFIED (newdecl)\n       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n     {\n+      auto_diagnostic_group d;\n       if (warning_at (newdecl_loc, OPT_Wattributes,\n \t\t      \"%qD: visibility attribute ignored because it \"\n \t\t      \"conflicts with previous declaration\", newdecl))\n@@ -2986,12 +2998,15 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \t{\n \t  DECL_EXTERNAL (newdecl) = 1;\n \t  /* For now, only warn with explicit -Wdeprecated.  */\n-\t  if (global_options_set.x_warn_deprecated\n-\t      && warning_at (DECL_SOURCE_LOCATION (newdecl), OPT_Wdeprecated,\n-\t\t\t     \"redundant redeclaration of %<constexpr%> static \"\n-\t\t\t     \"data member %qD\", newdecl))\n-\t    inform (DECL_SOURCE_LOCATION (olddecl),\n-\t\t    \"previous declaration of %qD\", olddecl);\n+\t  if (global_options_set.x_warn_deprecated)\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      if (warning_at (DECL_SOURCE_LOCATION (newdecl), OPT_Wdeprecated,\n+\t\t\t\t\"redundant redeclaration of %<constexpr%> \"\n+\t\t\t\t\"static data member %qD\", newdecl))\n+\t\tinform (DECL_SOURCE_LOCATION (olddecl),\n+\t\t\t  \"previous declaration of %qD\", olddecl);\n+\t    }\n \t  return NULL;\n \t}\n \n@@ -4753,6 +4768,7 @@ warn_misplaced_attr_for_class_type (source_location location,\n {\n   gcc_assert (OVERLOAD_TYPE_P (class_type));\n \n+  auto_diagnostic_group d;\n   if (warning_at (location, OPT_Wattributes,\n \t\t  \"attribute ignored in declaration \"\n \t\t  \"of %q#T\", class_type))"}, {"sha": "a5ad0eed3ad6ed2253efe9938d743cf8762448ec", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -764,6 +764,7 @@ finish_static_data_member_decl (tree decl,\n \t t = CP_TYPE_CONTEXT (t))\n       if (TYPE_UNNAMED_P (t))\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (permerror (DECL_SOURCE_LOCATION (decl),\n \t\t\t \"static data member %qD in unnamed class\", decl))\n \t    inform (DECL_SOURCE_LOCATION (TYPE_NAME (t)),\n@@ -4287,6 +4288,7 @@ no_linkage_error (tree decl)\n   else if (TYPE_UNNAMED_P (t))\n     {\n       bool d = false;\n+      auto_diagnostic_group grp;\n       if (cxx_dialect >= cxx11)\n \td = permerror (DECL_SOURCE_LOCATION (decl), \"%q#D, declared using \"\n \t\t       \"unnamed type, is used but never defined\", decl);\n@@ -5208,6 +5210,7 @@ cp_warn_deprecated_use (tree decl, tsubst_flags_t complain)\n       && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n       && copy_fn_p (decl))\n     {\n+      auto_diagnostic_group d;\n       /* Don't warn about system library classes (c++/86342).  */\n       if (!DECL_IN_SYSTEM_HEADER (decl))\n \twarned = warning (OPT_Wdeprecated_copy,"}, {"sha": "452ecb954677769ff9c16b13e408cf64fbc43ee6", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -4270,12 +4270,14 @@ qualified_name_lookup_error (tree scope, tree name,\n     }\n   else if (scope != global_namespace)\n     {\n+      auto_diagnostic_group d;\n       error_at (location, \"%qD is not a member of %qD\", name, scope);\n       if (!suggest_alternative_in_explicit_scope (location, name, scope))\n \tsuggest_alternatives_for (location, name, false);\n     }\n   else\n     {\n+      auto_diagnostic_group d;\n       error_at (location, \"%<::%D%> has not been declared\", name);\n       suggest_alternatives_for (location, name, true);\n     }"}, {"sha": "ce85a806620c8b5e8a5f2312b616460b89416651", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -304,6 +304,7 @@ make_friend_class (tree type, tree friend_type, bool complain)\n       if (TYPE_TEMPLATE_INFO (friend_type)\n \t  && !PRIMARY_TEMPLATE_P (TYPE_TI_TEMPLATE (friend_type)))\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"%qT is not a template\", friend_type);\n \t  inform (location_of (friend_type), \"previous declaration here\");\n \t  if (TYPE_CLASS_SCOPE_P (friend_type)\n@@ -384,6 +385,7 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \t\t}\n \t      if (template_member_p && !DECL_CLASS_TEMPLATE_P (decl))\n \t\t{\n+\t\t  auto_diagnostic_group d;\n \t\t  error (\"%qT is not a member class template of %qT\",\n \t\t\t name, ctype);\n \t\t  inform (DECL_SOURCE_LOCATION (decl),\n@@ -393,6 +395,7 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \t      if (!template_member_p && (TREE_CODE (decl) != TYPE_DECL\n \t\t\t\t\t || !CLASS_TYPE_P (TREE_TYPE (decl))))\n \t\t{\n+\t\t  auto_diagnostic_group d;\n \t\t  error (\"%qT is not a nested class of %qT\",\n \t\t\t name, ctype);\n \t\t  inform (DECL_SOURCE_LOCATION (decl),\n@@ -636,6 +639,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t      static int explained;\n \t      bool warned;\n \n+\t      auto_diagnostic_group d;\n \t      warned = warning (OPT_Wnon_template_friend, \"friend declaration \"\n \t\t\t\t\"%q#D declares a non-template function\", decl);\n \t      if (! explained && warned)"}, {"sha": "15046b4257bc7aac7b561801820ff997d71e123c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -915,6 +915,7 @@ perform_member_init (tree member, tree init)\n \t    {\n \t      /* TYPE_NEEDS_CONSTRUCTING can be set just because we have a\n \t\t vtable; still give this diagnostic.  */\n+\t      auto_diagnostic_group d;\n \t      if (permerror (DECL_SOURCE_LOCATION (current_function_decl),\n \t\t\t     \"uninitialized const member in %q#T\", type))\n \t\tinform (DECL_SOURCE_LOCATION (member),\n@@ -932,13 +933,15 @@ perform_member_init (tree member, tree init)\n \t  /* member traversal: note it leaves init NULL */\n \t  if (TYPE_REF_P (type))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      if (permerror (DECL_SOURCE_LOCATION (current_function_decl),\n \t\t\t     \"uninitialized reference member in %q#T\", type))\n \t\tinform (DECL_SOURCE_LOCATION (member),\n \t\t\t\"%q#D should be initialized\", member);\n \t    }\n \t  else if (CP_TYPE_CONST_P (type))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      if (permerror (DECL_SOURCE_LOCATION (current_function_decl),\n \t\t\t     \"uninitialized const member in %q#T\", type))\n \t\t  inform (DECL_SOURCE_LOCATION (member),\n@@ -3255,6 +3258,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t  || CP_DECL_CONTEXT (alloc_fn) == global_namespace)\n       && !aligned_allocation_fn_p (alloc_fn))\n     {\n+      auto_diagnostic_group d;\n       if (warning (OPT_Waligned_new_, \"%<new%> of type %qT with extended \"\n \t\t   \"alignment %d\", elt_type, TYPE_ALIGN_UNIT (elt_type)))\n \t{\n@@ -3831,16 +3835,19 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \n   if (!COMPLETE_TYPE_P (type))\n     {\n-      if ((complain & tf_warning)\n-\t  && warning (OPT_Wdelete_incomplete,\n-\t\t      \"possible problem detected in invocation of \"\n-\t\t      \"delete [] operator:\"))\n-       {\n-         cxx_incomplete_type_diagnostic (base, type, DK_WARNING);\n-         inform (input_location, \"neither the destructor nor the \"\n-                 \"class-specific operator delete [] will be called, \"\n-                 \"even if they are declared when the class is defined\");\n-       }\n+      if (complain & tf_warning)\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  if (warning (OPT_Wdelete_incomplete,\n+\t\t\t \"possible problem detected in invocation of \"\n+\t\t\t \"delete [] operator:\"))\n+\t    {\n+\t      cxx_incomplete_type_diagnostic (base, type, DK_WARNING);\n+\t      inform (input_location, \"neither the destructor nor the \"\n+\t\t\t\"class-specific operator delete [] will be called, \"\n+\t\t\t\"even if they are declared when the class is defined\");\n+\t    }\n+\t}\n       /* This size won't actually be used.  */\n       size_exp = size_one_node;\n       goto no_destructor;\n@@ -4712,16 +4719,19 @@ build_delete (tree otype, tree addr, special_function_kind auto_delete,\n \t  complete_type (type);\n \t  if (!COMPLETE_TYPE_P (type))\n \t    {\n-\t      if ((complain & tf_warning)\n-\t\t  && warning (OPT_Wdelete_incomplete,\n-\t\t\t      \"possible problem detected in invocation of \"\n-\t\t\t      \"delete operator:\"))\n+\t      if (complain & tf_warning)\n \t\t{\n-\t\t  cxx_incomplete_type_diagnostic (addr, type, DK_WARNING);\n-\t\t  inform (input_location,\n-\t\t\t  \"neither the destructor nor the class-specific \"\n-\t\t\t  \"operator delete will be called, even if they are \"\n-\t\t\t  \"declared when the class is defined\");\n+\t\t  auto_diagnostic_group d;\n+\t\t  if (warning (OPT_Wdelete_incomplete,\n+\t\t\t\t \"possible problem detected in invocation of \"\n+\t\t\t\t \"delete operator:\"))\n+\t\t    {\n+\t\t      cxx_incomplete_type_diagnostic (addr, type, DK_WARNING);\n+\t\t      inform (input_location,\n+\t\t\t\t\"neither the destructor nor the class-specific \"\n+\t\t\t\t\"operator delete will be called, even if they \"\n+\t\t\t\t\"are declared when the class is defined\");\n+\t\t    }\n \t\t}\n \t    }\n \t  else if (deleting && warn_delnonvdtor"}, {"sha": "47b99c3c46927571393f44d1a5c66df5790d06c8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -499,6 +499,7 @@ unqualified_name_lookup_error (tree name, location_t loc)\n     {\n       if (!objc_diagnose_private_ivar (name))\n \t{\n+\t  auto_diagnostic_group d;\n \t  error_at (loc, \"%qD was not declared in this scope\", name);\n \t  suggest_alternatives_for (loc, name, true);\n \t}"}, {"sha": "8c7f68522da492220550683c45ae8f1676b1cd0d", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -2556,6 +2556,7 @@ check_extern_c_conflict (tree decl)\n \n       if (mismatch)\n \t{\n+\t  auto_diagnostic_group d;\n \t  pedwarn (input_location, 0,\n \t\t   \"conflicting C language linkage declaration %q#D\", decl);\n \t  inform (DECL_SOURCE_LOCATION (old),\n@@ -2604,6 +2605,15 @@ c_linkage_bindings (tree name)\n   return NULL_TREE;\n }\n \n+/* Subroutine of check_local_shadow.  */\n+\n+static void\n+inform_shadowed (tree shadowed)\n+{\n+  inform (DECL_SOURCE_LOCATION (shadowed),\n+\t  \"shadowed declaration is here\");\n+}\n+\n /* DECL is being declared at a local scope.  Emit suitable shadow\n    warnings.  */\n \n@@ -2631,7 +2641,6 @@ check_local_shadow (tree decl)\n       old_scope = binding->scope;\n     }\n \n-  tree shadowed = NULL_TREE;\n   if (old\n       && (TREE_CODE (old) == PARM_DECL\n \t  || VAR_P (old)\n@@ -2702,6 +2711,7 @@ check_local_shadow (tree decl)\n \t       && old_scope == current_binding_level->level_chain\n \t       && (old_scope->kind == sk_cond || old_scope->kind == sk_for))\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"redeclaration of %q#D\", decl);\n \t  inform (DECL_SOURCE_LOCATION (old),\n \t\t  \"%q#D previously declared here\", old);\n@@ -2724,6 +2734,7 @@ check_local_shadow (tree decl)\n \t\t       || current_binding_level->level_chain->kind == sk_catch)\n \t\t   && in_function_try_handler))\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (permerror (input_location, \"redeclaration of %q#D\", decl))\n \t    inform (DECL_SOURCE_LOCATION (old),\n \t\t    \"%q#D previously declared here\", old);\n@@ -2764,11 +2775,9 @@ check_local_shadow (tree decl)\n       else\n \tmsg = \"declaration of %qD shadows a previous local\";\n \n+      auto_diagnostic_group d;\n       if (warning_at (input_location, warning_code, msg, decl))\n-\t{\n-\t  shadowed = old;\n-\t  goto inform_shadowed;\n-\t}\n+\tinform_shadowed (old);\n       return;\n     }\n \n@@ -2793,14 +2802,12 @@ check_local_shadow (tree decl)\n \t    || TYPE_PTRFN_P (TREE_TYPE (decl))\n \t    || TYPE_PTRMEMFUNC_P (TREE_TYPE (decl)))\n \t  {\n+\t    auto_diagnostic_group d;\n \t    if (warning_at (input_location, OPT_Wshadow,\n \t\t\t    \"declaration of %qD shadows a member of %qT\",\n \t\t\t    decl, current_nonlambda_class_type ())\n \t\t&& DECL_P (member))\n-\t      {\n-\t\tshadowed = member;\n-\t\tgoto inform_shadowed;\n-\t      }\n+\t      inform_shadowed (member);\n \t  }\n \treturn;\n       }\n@@ -2815,20 +2822,15 @@ check_local_shadow (tree decl)\n       && !instantiating_current_function_p ())\n     /* XXX shadow warnings in outer-more namespaces */\n     {\n+      auto_diagnostic_group d;\n       if (warning_at (input_location, OPT_Wshadow,\n \t\t      \"declaration of %qD shadows a global declaration\",\n \t\t      decl))\n-\t{\n-\t  shadowed = old;\n-\t  goto inform_shadowed;\n-\t}\n+\tinform_shadowed (old);\n       return;\n     }\n \n   return;\n-\n- inform_shadowed:\n-  inform (DECL_SOURCE_LOCATION (shadowed), \"shadowed declaration is here\");\n }\n \n /* DECL is being pushed inside function CTX.  Set its context, if\n@@ -2954,6 +2956,7 @@ set_local_extern_decl_linkage (tree decl, bool shadowed)\n \t\t       && !comptypes (TREE_TYPE (decl), TREE_TYPE (other),\n \t\t\t\t      COMPARE_REDECLARATION)))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      if (permerror (DECL_SOURCE_LOCATION (decl),\n \t\t\t     \"local external declaration %q#D\", decl))\n \t\tinform (DECL_SOURCE_LOCATION (other),"}, {"sha": "aa5286b24ccbb6e7c8d77bffbcc60c15d7045744", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -3280,6 +3280,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree id,\n   to specify an argument list. Emit a useful error message.  */\n   if (DECL_TYPE_TEMPLATE_P (decl))\n     {\n+      auto_diagnostic_group d;\n       error_at (location,\n \t\t\"invalid use of template-name %qE without an argument list\",\n \t\tdecl);\n@@ -3296,6 +3297,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree id,\n   else if (!parser->scope)\n     {\n       /* Issue an error message.  */\n+      auto_diagnostic_group d;\n       name_hint hint;\n       if (TREE_CODE (id) == IDENTIFIER_NODE)\n \thint = lookup_name_fuzzy (id, FUZZY_LOOKUP_TYPENAME, location);\n@@ -3370,6 +3372,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree id,\n     {\n       if (TREE_CODE (parser->scope) == NAMESPACE_DECL)\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n \t    error_at (location_of (id),\n \t\t      \"%qE in namespace %qE does not name a template type\",\n@@ -3392,6 +3395,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree id,\n \t       && constructor_name_p (id, parser->scope))\n \t{\n \t  /* A<T>::A<T>() */\n+\t  auto_diagnostic_group d;\n \t  error_at (location, \"%<%T::%E%> names the constructor, not\"\n \t\t    \" the type\", parser->scope, id);\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n@@ -3417,6 +3421,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree id,\n \t}\n       else if (TYPE_P (parser->scope))\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (!COMPLETE_TYPE_P (parser->scope))\n \t    cxx_incomplete_type_error (location_of (id), NULL_TREE,\n \t\t\t\t       parser->scope);\n@@ -18615,6 +18620,7 @@ cp_parser_namespace_name (cp_parser* parser)\n     {\n       if (!cp_parser_uncommitted_to_tentative_parse_p (parser))\n \t{\n+\t  auto_diagnostic_group d;\n \t  error_at (token->location, \"%qD is not a namespace-name\", identifier);\n \t  if (namespace_decl == error_mark_node\n \t      && parser->scope && TREE_CODE (parser->scope) == NAMESPACE_DECL)"}, {"sha": "efed9a1bf60e92a911b2f9a3495eb0a6eb68bc71", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -800,6 +800,7 @@ check_specialization_namespace (tree tmpl)\n     return true;\n   else\n     {\n+      auto_diagnostic_group d;\n       if (permerror (input_location,\n \t\t     \"specialization of %qD in different namespace\", tmpl))\n \tinform (DECL_SOURCE_LOCATION (tmpl),\n@@ -2592,6 +2593,7 @@ check_template_variable (tree decl)\n     }\n   if (template_header_count > wanted)\n     {\n+      auto_diagnostic_group d;\n       bool warned = pedwarn (DECL_SOURCE_LOCATION (decl), 0,\n \t\t\t     \"too many template headers for %qD \"\n \t                     \"(should be %d)\",\n@@ -2724,6 +2726,7 @@ warn_spec_missing_attributes (tree tmpl, tree spec, tree attrlist)\n   if (!nattrs)\n     return;\n \n+  auto_diagnostic_group d;\n   if (warning_at (DECL_SOURCE_LOCATION (spec), OPT_Wmissing_attributes,\n \t\t  \"explicit specialization %q#D may be missing attributes\",\n \t\t  spec))\n@@ -3070,6 +3073,7 @@ check_explicit_specialization (tree declarator,\n \t  if (TREE_CODE (decl) == FUNCTION_DECL\n \t      && DECL_HIDDEN_FRIEND_P (tmpl))\n \t    {\n+\t      auto_diagnostic_group d;\n \t      if (pedwarn (DECL_SOURCE_LOCATION (decl), 0,\n \t\t\t   \"friend declaration %qD is not visible to \"\n \t\t\t   \"explicit specialization\", tmpl))\n@@ -4891,6 +4895,7 @@ process_partial_specialization (tree decl)\n \t   && TMPL_ARGS_DEPTH (specargs) == 1\n \t   && !get_partial_spec_bindings (maintmpl, maintmpl, specargs))\n     {\n+      auto_diagnostic_group d;\n       if (permerror (input_location, \"partial specialization %qD is not \"\n \t\t     \"more specialized than\", decl))\n \tinform (DECL_SOURCE_LOCATION (maintmpl), \"primary template %qD\",\n@@ -9354,6 +9359,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n         {\n           if (complain & tf_error)\n             {\n+\t      auto_diagnostic_group d;\n               error (\"template constraint failure\");\n               diagnose_constraints (input_location, gen_tmpl, arglist);\n             }\n@@ -9712,6 +9718,7 @@ finish_template_variable (tree var, tsubst_flags_t complain)\n     {\n       if (complain & tf_error)\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"use of invalid variable template %qE\", var);\n \t  diagnose_constraints (location_of (var), templ, arglist);\n \t}\n@@ -26888,6 +26895,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n           {\n             if (complain & tf_warning_or_error)\n               {\n+\t\tauto_diagnostic_group d;\n                 switch (context)\n                   {\n                   case adc_unspecified:"}, {"sha": "d700fe328f4ba1172566a3f402dc8e3cda62aec8", "filename": "gcc/cp/search.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1911,6 +1911,7 @@ check_final_overrider (tree overrider, tree basefn)\n \t/* GNU extension, allow trivial pointer conversions such as\n \t   converting to void *, or qualification conversion.  */\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (pedwarn (DECL_SOURCE_LOCATION (overrider), 0,\n \t\t       \"invalid covariant return type for %q#D\", overrider))\n \t    inform (DECL_SOURCE_LOCATION (basefn),\n@@ -1927,12 +1928,14 @@ check_final_overrider (tree overrider, tree basefn)\n     {\n       if (fail == 1)\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"invalid covariant return type for %q+#D\", overrider);\n \t  inform (DECL_SOURCE_LOCATION (basefn),\n \t\t  \"overridden function is %q#D\", basefn);\n \t}\n       else\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"conflicting return type specified for %q+#D\", overrider);\n \t  inform (DECL_SOURCE_LOCATION (basefn),\n \t\t  \"overridden function is %q#D\", basefn);\n@@ -1949,6 +1952,7 @@ check_final_overrider (tree overrider, tree basefn)\n \n   if (!comp_except_specs (base_throw, over_throw, ce_derived))\n     {\n+      auto_diagnostic_group d;\n       error (\"looser throw specifier for %q+#F\", overrider);\n       inform (DECL_SOURCE_LOCATION (basefn),\n \t      \"overridden function is %q#F\", basefn);\n@@ -1962,6 +1966,7 @@ check_final_overrider (tree overrider, tree basefn)\n       && !tx_safe_fn_type_p (base_type)\n       && !tx_safe_fn_type_p (over_type))\n     {\n+      auto_diagnostic_group d;\n       error (\"conflicting type attributes specified for %q+#D\", overrider);\n       inform (DECL_SOURCE_LOCATION (basefn),\n \t      \"overridden function is %q#D\", basefn);\n@@ -1978,6 +1983,7 @@ check_final_overrider (tree overrider, tree basefn)\n       && !lookup_attribute (\"transaction_safe_dynamic\",\n \t\t\t    DECL_ATTRIBUTES (basefn)))\n     {\n+      auto_diagnostic_group d;\n       error_at (DECL_SOURCE_LOCATION (overrider),\n \t\t\"%qD declared %<transaction_safe_dynamic%>\", overrider);\n       inform (DECL_SOURCE_LOCATION (basefn),\n@@ -1988,6 +1994,7 @@ check_final_overrider (tree overrider, tree basefn)\n     {\n       if (DECL_DELETED_FN (overrider))\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"deleted function %q+D overriding non-deleted function\",\n \t\t overrider);\n \t  inform (DECL_SOURCE_LOCATION (basefn),\n@@ -1996,6 +2003,7 @@ check_final_overrider (tree overrider, tree basefn)\n \t}\n       else\n \t{\n+\t  auto_diagnostic_group d;\n \t  error (\"non-deleted function %q+D overriding deleted function\",\n \t\t overrider);\n \t  inform (DECL_SOURCE_LOCATION (basefn),\n@@ -2005,6 +2013,7 @@ check_final_overrider (tree overrider, tree basefn)\n     }\n   if (DECL_FINAL_P (basefn))\n     {\n+      auto_diagnostic_group d;\n       error (\"virtual function %q+D overriding final function\", overrider);\n       inform (DECL_SOURCE_LOCATION (basefn),\n \t      \"overridden function is %qD\", basefn);\n@@ -2089,6 +2098,7 @@ look_for_overrides_r (tree type, tree fndecl)\n \t{\n \t  /* A static member function cannot match an inherited\n \t     virtual member function.  */\n+\t  auto_diagnostic_group d;\n \t  error (\"%q+#D cannot be declared\", fndecl);\n \t  error (\"  since %q+#D declared in base class\", fn);\n \t}"}, {"sha": "8a1d2993f946e8c12d726d5a90696420d07a6def", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -4031,6 +4031,7 @@ maybe_warn_parm_abi (tree t, location_t loc)\n       && classtype_has_non_deleted_move_ctor (t))\n     {\n       bool w;\n+      auto_diagnostic_group d;\n       if (flag_abi_version > 12)\n \tw = warning_at (loc, OPT_Wabi, \"-fabi-version=13 (GCC 8.2) fixes the \"\n \t\t\t\"calling convention for %qT, which was accidentally \"\n@@ -4043,6 +4044,7 @@ maybe_warn_parm_abi (tree t, location_t loc)\n       return;\n     }\n \n+  auto_diagnostic_group d;\n   if (warning_at (loc, OPT_Wabi, \"the calling convention for %qT changes in \"\n \t\t  \"-fabi-version=13 (GCC 8.2)\", t))\n     inform (location_of (t), \" because all of its copy and move \""}, {"sha": "99be38ed8f862c3674ee5270411c711e33726f11", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1691,6 +1691,7 @@ cxx_sizeof_expr (tree e, tsubst_flags_t complain)\n       && DECL_ARRAY_PARAMETER_P (e)\n       && (complain & tf_warning))\n     {\n+      auto_diagnostic_group d;\n       if (warning (OPT_Wsizeof_array_argument, \"%<sizeof%> on array function \"\n \t\t   \"parameter %qE will return size of %qT\", e, TREE_TYPE (e)))\n \tinform (DECL_SOURCE_LOCATION (e), \"declared here\");\n@@ -3699,6 +3700,7 @@ cp_build_function_call_vec (tree function, vec<tree, va_gc> **params,\n           && (complain & tf_error)\n           && !constraints_satisfied_p (function))\n         {\n+          auto_diagnostic_group d;\n           error (\"cannot call function %qD\", function);\n           location_t loc = DECL_SOURCE_LOCATION (function);\n           diagnose_constraints (loc, function, NULL_TREE);\n@@ -4467,13 +4469,16 @@ cp_build_binary_op (location_t location,\n \t\t   && DECL_ARRAY_PARAMETER_P (first_arg)\n \t\t   && warn_sizeof_array_argument)\n \t      && (complain & tf_warning))\n-\t    if (warning_at (location, OPT_Wsizeof_pointer_div,\n-\t\t\t    \"division %<sizeof (%T) / sizeof (%T)%> does \"\n-\t\t\t    \"not compute the number of array elements\",\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      if (warning_at (location, OPT_Wsizeof_pointer_div,\n+\t\t\t\t\"division %<sizeof (%T) / sizeof (%T)%> does \"\n+\t\t\t\t\"not compute the number of array elements\",\n \t\t\t    type0, type1))\n-\t      if (DECL_P (first_arg))\n-\t\tinform (DECL_SOURCE_LOCATION (first_arg),\n-\t\t\t\"first %<sizeof%> operand was declared here\");\n+\t\tif (DECL_P (first_arg))\n+\t\t  inform (DECL_SOURCE_LOCATION (first_arg),\n+\t\t\t    \"first %<sizeof%> operand was declared here\");\n+\t    }\n \t}\n \n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n@@ -4766,12 +4771,15 @@ cp_build_binary_op (location_t location,\n \t  else\n \t    result_type = type0;\n \n-\t  if (char_type_p (TREE_TYPE (orig_op1))\n-\t      && warning (OPT_Wpointer_compare,\n-\t\t\t  \"comparison between pointer and zero character \"\n-\t\t\t  \"constant\"))\n-\t    inform (input_location,\n-\t\t    \"did you mean to dereference the pointer?\");\n+\t  if (char_type_p (TREE_TYPE (orig_op1)))\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      if (warning (OPT_Wpointer_compare,\n+\t\t\t     \"comparison between pointer and zero character \"\n+\t\t\t     \"constant\"))\n+\t\tinform (input_location,\n+\t\t\t  \"did you mean to dereference the pointer?\");\n+\t    }\n \t  warn_for_null_address (location, op0, complain);\n \t}\n       else if (((code1 == POINTER_TYPE || TYPE_PTRDATAMEM_P (type1))\n@@ -4786,12 +4794,15 @@ cp_build_binary_op (location_t location,\n \t  else\n \t    result_type = type1;\n \n-\t  if (char_type_p (TREE_TYPE (orig_op0))\n-\t      && warning (OPT_Wpointer_compare,\n-\t\t\t  \"comparison between pointer and zero character \"\n-\t\t\t  \"constant\"))\n-\t    inform (input_location,\n-\t\t    \"did you mean to dereference the pointer?\");\n+\t  if (char_type_p (TREE_TYPE (orig_op0)))\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      if (warning (OPT_Wpointer_compare,\n+\t\t\t     \"comparison between pointer and zero character \"\n+\t\t\t     \"constant\"))\n+\t\tinform (input_location,\n+\t\t\t\"did you mean to dereference the pointer?\");\n+\t    }\n \t  warn_for_null_address (location, op1, complain);\n \t}\n       else if ((code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n@@ -8807,6 +8818,7 @@ convert_for_assignment (tree type, tree rhs,\n \t\t}\n \t      else if (fndecl)\n \t\t{\n+\t\t  auto_diagnostic_group d;\n \t\t  location_t loc = cp_expr_location (rhs);\n \t\t  range_label_for_type_mismatch rhs_label (rhstype, type);\n \t\t  range_label *label = &rhs_label;\n@@ -9087,6 +9099,7 @@ maybe_warn_about_returning_address_of_local (tree retval)\n \t   || TREE_PUBLIC (whats_returned)))\n     {\n       bool w = false;\n+      auto_diagnostic_group d;\n       if (TYPE_REF_P (valtype))\n \tw = warning_at (loc, OPT_Wreturn_local_addr,\n \t\t\t\"reference to local variable %qD returned\","}, {"sha": "f42f0c2bf0747b5a6f6dc6db58c5efe170738277", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -315,6 +315,7 @@ abstract_virtuals_error_sfinae (tree decl, tree type, abstract_class_use use,\n   if (!(complain & tf_error))\n     return 1;\n \n+  auto_diagnostic_group d;\n   if (decl)\n     {\n       if (VAR_P (decl))\n@@ -983,6 +984,7 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain, bool const_only)\n \t{\n \t  if (complain & tf_warning_or_error)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      if ((!almost_ok || pedantic)\n \t\t  && pedwarn (loc, OPT_Wnarrowing,\n \t\t\t      \"narrowing conversion of %qE from %qH to %qI\","}, {"sha": "e4ebe005ede532b67e94387cf4dc4f8006230f96", "filename": "gcc/diagnostic-core.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fdiagnostic-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fdiagnostic-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-core.h?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -36,6 +36,15 @@ typedef enum\n   DK_POP\n } diagnostic_t;\n \n+/* RAII-style class for grouping related diagnostics.  */\n+\n+class auto_diagnostic_group\n+{\n+ public:\n+  auto_diagnostic_group ();\n+  ~auto_diagnostic_group ();\n+};\n+\n extern const char *progname;\n \n extern const char *trim_filename (const char *);"}, {"sha": "aae0934d21a66a6a336a995eb05ee4f54167ebb2", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -180,6 +180,10 @@ diagnostic_initialize (diagnostic_context *context, int n_opts)\n   context->show_ruler_p = false;\n   context->parseable_fixits_p = false;\n   context->edit_context_ptr = NULL;\n+  context->diagnostic_group_nesting_depth = 0;\n+  context->diagnostic_group_emission_count = 0;\n+  context->begin_group_cb = NULL;\n+  context->end_group_cb = NULL;\n }\n \n /* Maybe initialize the color support. We require clients to do this\n@@ -986,6 +990,14 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n   else\n     ++diagnostic_kind_count (context, diagnostic->kind);\n \n+  /* Is this the initial diagnostic within the stack of groups?  */\n+  if (context->diagnostic_group_emission_count == 0)\n+    {\n+      if (context->begin_group_cb)\n+\tcontext->begin_group_cb (context);\n+    }\n+  context->diagnostic_group_emission_count++;\n+\n   diagnostic->message.x_data = &diagnostic->x_data;\n   diagnostic->x_data = NULL;\n   pp_format (context->printer, &diagnostic->message);\n@@ -1146,6 +1158,7 @@ bool\n emit_diagnostic (diagnostic_t kind, location_t location, int opt,\n \t\t const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, location);\n@@ -1169,6 +1182,7 @@ emit_diagnostic_valist (diagnostic_t kind, location_t location, int opt,\n void\n inform (location_t location, const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, location);\n@@ -1182,6 +1196,7 @@ inform (rich_location *richloc, const char *gmsgid, ...)\n {\n   gcc_assert (richloc);\n \n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   diagnostic_impl (richloc, -1, gmsgid, &ap, DK_NOTE);\n@@ -1196,6 +1211,7 @@ inform_n (location_t location, unsigned HOST_WIDE_INT n,\n {\n   va_list ap;\n   va_start (ap, plural_gmsgid);\n+  auto_diagnostic_group d;\n   rich_location richloc (line_table, location);\n   diagnostic_n_impl (&richloc, -1, n, singular_gmsgid, plural_gmsgid,\n \t\t     &ap, DK_NOTE);\n@@ -1208,6 +1224,7 @@ inform_n (location_t location, unsigned HOST_WIDE_INT n,\n bool\n warning (int opt, const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, input_location);\n@@ -1223,6 +1240,7 @@ warning (int opt, const char *gmsgid, ...)\n bool\n warning_at (location_t location, int opt, const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, location);\n@@ -1238,6 +1256,7 @@ warning_at (rich_location *richloc, int opt, const char *gmsgid, ...)\n {\n   gcc_assert (richloc);\n \n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   bool ret = diagnostic_impl (richloc, opt, gmsgid, &ap, DK_WARNING);\n@@ -1253,6 +1272,7 @@ warning_n (rich_location *richloc, int opt, unsigned HOST_WIDE_INT n,\n {\n   gcc_assert (richloc);\n \n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, plural_gmsgid);\n   bool ret = diagnostic_n_impl (richloc, opt, n,\n@@ -1270,6 +1290,7 @@ bool\n warning_n (location_t location, int opt, unsigned HOST_WIDE_INT n,\n \t   const char *singular_gmsgid, const char *plural_gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, plural_gmsgid);\n   rich_location richloc (line_table, location);\n@@ -1296,6 +1317,7 @@ warning_n (location_t location, int opt, unsigned HOST_WIDE_INT n,\n bool\n pedwarn (location_t location, int opt, const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, location);\n@@ -1311,6 +1333,7 @@ pedwarn (rich_location *richloc, int opt, const char *gmsgid, ...)\n {\n   gcc_assert (richloc);\n \n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   bool ret = diagnostic_impl (richloc, opt, gmsgid, &ap, DK_PEDWARN);\n@@ -1328,6 +1351,7 @@ pedwarn (rich_location *richloc, int opt, const char *gmsgid, ...)\n bool\n permerror (location_t location, const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, location);\n@@ -1343,6 +1367,7 @@ permerror (rich_location *richloc, const char *gmsgid, ...)\n {\n   gcc_assert (richloc);\n \n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   bool ret = diagnostic_impl (richloc, -1, gmsgid, &ap, DK_PERMERROR);\n@@ -1355,6 +1380,7 @@ permerror (rich_location *richloc, const char *gmsgid, ...)\n void\n error (const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, input_location);\n@@ -1368,6 +1394,7 @@ void\n error_n (location_t location, unsigned HOST_WIDE_INT n,\n \t const char *singular_gmsgid, const char *plural_gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, plural_gmsgid);\n   rich_location richloc (line_table, location);\n@@ -1380,6 +1407,7 @@ error_n (location_t location, unsigned HOST_WIDE_INT n,\n void\n error_at (location_t loc, const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, loc);\n@@ -1394,6 +1422,7 @@ error_at (rich_location *richloc, const char *gmsgid, ...)\n {\n   gcc_assert (richloc);\n \n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   diagnostic_impl (richloc, -1, gmsgid, &ap, DK_ERROR);\n@@ -1406,6 +1435,7 @@ error_at (rich_location *richloc, const char *gmsgid, ...)\n void\n sorry (const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, input_location);\n@@ -1427,6 +1457,7 @@ seen_error (void)\n void\n fatal_error (location_t loc, const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, loc);\n@@ -1443,6 +1474,7 @@ fatal_error (location_t loc, const char *gmsgid, ...)\n void\n internal_error (const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, input_location);\n@@ -1458,6 +1490,7 @@ internal_error (const char *gmsgid, ...)\n void\n internal_error_no_backtrace (const char *gmsgid, ...)\n {\n+  auto_diagnostic_group d;\n   va_list ap;\n   va_start (ap, gmsgid);\n   rich_location richloc (line_table, input_location);\n@@ -1515,6 +1548,33 @@ fancy_abort (const char *file, int line, const char *function)\n   internal_error (\"in %s, at %s:%d\", function, trim_filename (file), line);\n }\n \n+/* class auto_diagnostic_group.  */\n+\n+/* Constructor: \"push\" this group into global_dc.  */\n+\n+auto_diagnostic_group::auto_diagnostic_group ()\n+{\n+  global_dc->diagnostic_group_nesting_depth++;\n+}\n+\n+/* Destructor: \"pop\" this group from global_dc.  */\n+\n+auto_diagnostic_group::~auto_diagnostic_group ()\n+{\n+  if (--global_dc->diagnostic_group_nesting_depth == 0)\n+    {\n+      /* Handle the case where we've popped the final diagnostic group.\n+\t If any diagnostics were emitted, give the context a chance\n+\t to do something.  */\n+      if (global_dc->diagnostic_group_emission_count > 0)\n+\t{\n+\t  if (global_dc->end_group_cb)\n+\t    global_dc->end_group_cb (global_dc);\n+\t}\n+      global_dc->diagnostic_group_emission_count = 0;\n+    }\n+}\n+\n /* Really call the system 'abort'.  This has to go right at the end of\n    this file, so that there are no functions after it that call abort\n    and get the system abort instead of our macro.  */"}, {"sha": "34ea03bb6947c04ca18d704b2c59e723d2cf8e0e", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -222,6 +222,23 @@ struct diagnostic_context\n   /* If non-NULL, an edit_context to which fix-it hints should be\n      applied, for generating patches.  */\n   edit_context *edit_context_ptr;\n+\n+  /* How many diagnostic_group instances are currently alive.  */\n+  int diagnostic_group_nesting_depth;\n+\n+  /* How many diagnostics have been emitted since the bottommost\n+     diagnostic_group was pushed.  */\n+  int diagnostic_group_emission_count;\n+\n+  /* Optional callbacks for handling diagnostic groups.  */\n+\n+  /* If non-NULL, this will be called immediately before the first\n+     time a diagnostic is emitted within a stack of groups.  */\n+  void (*begin_group_cb) (diagnostic_context * context);\n+\n+  /* If non-NULL, this will be called when a stack of groups is\n+     popped if any diagnostics were emitted within that group.  */\n+  void (*end_group_cb) (diagnostic_context * context);\n };\n \n static inline void"}, {"sha": "e1fab61bedabedc078d5fcf034e2c1aaffdcc651", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -421,12 +421,15 @@ find_implicit_erroneous_behavior (void)\n \t\t\t  if (gimple_return_retval (return_stmt) != lhs)\n \t\t\t    continue;\n \n-\t\t\t  if (warning_at (gimple_location (use_stmt),\n-\t\t\t\t\t  OPT_Wreturn_local_addr,\n-\t\t\t\t\t  \"function may return address \"\n-\t\t\t\t\t  \"of local variable\"))\n-\t\t\t    inform (DECL_SOURCE_LOCATION(valbase),\n-\t\t\t\t    \"declared here\");\n+\t\t\t  {\n+\t\t\t    auto_diagnostic_group d;\n+\t\t\t    if (warning_at (gimple_location (use_stmt),\n+\t\t\t\t\t      OPT_Wreturn_local_addr,\n+\t\t\t\t\t      \"function may return address \"\n+\t\t\t\t\t      \"of local variable\"))\n+\t\t\t      inform (DECL_SOURCE_LOCATION(valbase),\n+\t\t\t\t\t\"declared here\");\n+\t\t\t  }\n \n \t\t\t  if (gimple_bb (use_stmt) == bb)\n \t\t\t    {\n@@ -543,10 +546,13 @@ find_explicit_erroneous_behavior (void)\n \t\t      else\n \t\t\tmsg = N_(\"function may return address of \"\n \t\t\t\t \"local variable\");\n-\n-\t\t      if (warning_at (gimple_location (stmt),\n-\t\t\t\t      OPT_Wreturn_local_addr, msg))\n-\t\t\tinform (DECL_SOURCE_LOCATION(valbase), \"declared here\");\n+\t\t      {\n+\t\t\tauto_diagnostic_group d;\n+\t\t\tif (warning_at (gimple_location (stmt),\n+\t\t\t\t\t  OPT_Wreturn_local_addr, msg))\n+\t\t\t  inform (DECL_SOURCE_LOCATION(valbase),\n+\t\t\t\t  \"declared here\");\n+\t\t      }\n \t\t      tree zero = build_zero_cst (TREE_TYPE (val));\n \t\t      gimple_return_set_retval (return_stmt, zero);\n \t\t      update_stmt (stmt);"}, {"sha": "434770772ae7b5c8ea74286bfb0b2b9bd2c1e988", "filename": "gcc/gimple-ssa-warn-alloca.c", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fgimple-ssa-warn-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fgimple-ssa-warn-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-alloca.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -532,29 +532,37 @@ pass_walloca::execute (function *fun)\n \t    case ALLOCA_OK:\n \t      break;\n \t    case ALLOCA_BOUND_MAYBE_LARGE:\n-\t      if (warning_at (loc, wcode,\n-\t\t\t      is_vla ? G_(\"argument to variable-length array \"\n-\t\t\t\t\t  \"may be too large\")\n-\t\t\t      : G_(\"argument to %<alloca%> may be too large\"))\n-\t\t  && t.limit != 0)\n-\t\t{\n-\t\t  print_decu (t.limit, buff);\n-\t\t  inform (loc, G_(\"limit is %wu bytes, but argument \"\n-\t\t\t\t  \"may be as large as %s\"),\n-\t\t\t  is_vla ? warn_vla_limit : warn_alloca_limit, buff);\n-\t\t}\n+\t      {\n+\t\tauto_diagnostic_group d;\n+\t\tif (warning_at (loc, wcode,\n+\t\t\t\tis_vla ? G_(\"argument to variable-length \"\n+\t\t\t\t\t    \"array may be too large\")\n+\t\t\t\t: G_(\"argument to %<alloca%> may be too \"\n+\t\t\t\t     \"large\"))\n+\t\t    && t.limit != 0)\n+\t\t  {\n+\t\t    print_decu (t.limit, buff);\n+\t\t    inform (loc, G_(\"limit is %wu bytes, but argument \"\n+\t\t\t\t    \"may be as large as %s\"),\n+\t\t\t    is_vla ? warn_vla_limit : warn_alloca_limit, buff);\n+\t\t  }\n+\t      }\n \t      break;\n \t    case ALLOCA_BOUND_DEFINITELY_LARGE:\n-\t      if (warning_at (loc, wcode,\n-\t\t\t      is_vla ? G_(\"argument to variable-length array \"\n-\t\t\t\t\t  \"is too large\")\n-\t\t\t      : G_(\"argument to %<alloca%> is too large\"))\n-\t\t  && t.limit != 0)\n-\t\t{\n-\t\t  print_decu (t.limit, buff);\n-\t\t  inform (loc, G_(\"limit is %wu bytes, but argument is %s\"),\n-\t\t\t  is_vla ? warn_vla_limit : warn_alloca_limit, buff);\n-\t\t}\n+\t      {\n+\t\tauto_diagnostic_group d;\n+\t\tif (warning_at (loc, wcode,\n+\t\t\t\tis_vla ? G_(\"argument to variable-length\"\n+\t\t\t\t\t    \" array is too large\")\n+\t\t\t\t: G_(\"argument to %<alloca%> is too large\"))\n+\t\t    && t.limit != 0)\n+\t\t  {\n+\t\t    print_decu (t.limit, buff);\n+\t\t    inform (loc, G_(\"limit is %wu bytes, but argument is %s\"),\n+\t\t\t      is_vla ? warn_vla_limit : warn_alloca_limit,\n+\t\t\t      buff);\n+\t\t  }\n+\t      }\n \t      break;\n \t    case ALLOCA_BOUND_UNKNOWN:\n \t      warning_at (loc, wcode,"}, {"sha": "977dd860ef7ad94c0997184aefb7c1bdb266fec3", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1618,6 +1618,7 @@ maybe_diag_offset_bounds (location_t loc, gimple *call, tree func, int strict,\n       if (DECL_P (ref.base)\n \t  && TREE_CODE (type = TREE_TYPE (ref.base)) == ARRAY_TYPE)\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (warning_at (loc, OPT_Warray_bounds,\n \t\t\t  \"%G%qD pointer overflow between offset %s \"\n \t\t\t  \"and size %s accessing array %qD with type %qT\",\n@@ -1650,6 +1651,7 @@ maybe_diag_offset_bounds (location_t loc, gimple *call, tree func, int strict,\n \n       if (DECL_P (ref.base))\n \t{\n+\t  auto_diagnostic_group d;\n \t  if ((ref.basesize < maxobjsize\n \t       && warning_at (loc, OPT_Warray_bounds,\n \t\t\t      form"}, {"sha": "e35137aec2c7193f8e345b20cd3ec3e79334ce20", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -2173,6 +2173,7 @@ warn_implicit_fallthrough_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \t  {\n \t    struct label_entry *l;\n \t    bool warned_p = false;\n+\t    auto_diagnostic_group d;\n \t    if (!should_warn_for_implicit_fallthrough (gsi_p, label))\n \t      /* Quiet.  */;\n \t    else if (gimple_code (prev) == GIMPLE_LABEL\n@@ -13079,6 +13080,7 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p,\n       /* Unfortunately, this is merely undefined, rather than a constraint\n \t violation, so we cannot make this an error.  If this call is never\n \t executed, the program is still strictly conforming.  */\n+      auto_diagnostic_group d;\n       warned = warning_at (xloc, 0,\n \t\t\t   \"%qT is promoted to %qT when passed through %<...%>\",\n \t\t\t   type, promoted_type);"}, {"sha": "6595bedac82b99ac91c7a6032bd3f1cf31f310fe", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -69,6 +69,7 @@ along with GCC; see the file COPYING3.  If not see\n   do \\\n   { \\\n     hsa_fail_cfun (); \\\n+    auto_diagnostic_group d; \\\n     if (warning_at (EXPR_LOCATION (hsa_cfun->m_decl), OPT_Whsa, \\\n \t\t    HSA_SORRY_MSG)) \\\n       inform (location, message, __VA_ARGS__); \\\n@@ -81,6 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n   do \\\n   { \\\n     hsa_fail_cfun (); \\\n+    auto_diagnostic_group d; \\\n     if (warning_at (EXPR_LOCATION (hsa_cfun->m_decl), OPT_Whsa, \\\n \t\t    HSA_SORRY_MSG)) \\\n       inform (location, message); \\"}, {"sha": "9564d651b2be9c5113d718918a921ad0c725eeae", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -749,6 +749,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t  prevailing = vtable;\n \t  vtable = tmp;\n \t}\n+      auto_diagnostic_group d;\n       if (warning_at (DECL_SOURCE_LOCATION\n \t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n \t\t      OPT_Wodr,\n@@ -790,22 +791,25 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t             && TREE_CODE (ref1->referred->decl) == FUNCTION_DECL))\n \t     && TREE_CODE (ref2->referred->decl) != FUNCTION_DECL)\n \t{\n-\t  if (!class_type->rtti_broken\n-\t      && warning_at (DECL_SOURCE_LOCATION\n-\t\t\t      (TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n-\t\t\t     OPT_Wodr,\n-\t\t\t     \"virtual table of type %qD contains RTTI \"\n-\t\t\t     \"information\",\n-\t\t\t     DECL_CONTEXT (vtable->decl)))\n+\t  if (!class_type->rtti_broken)\n \t    {\n-\t      inform (DECL_SOURCE_LOCATION\n-\t\t\t(TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n-\t\t      \"but is prevailed by one without from other translation \"\n-\t\t      \"unit\");\n-\t      inform (DECL_SOURCE_LOCATION\n-\t\t\t(TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n-\t\t      \"RTTI will not work on this type\");\n-\t      class_type->rtti_broken = true;\n+\t      auto_diagnostic_group d;\n+\t      if (warning_at (DECL_SOURCE_LOCATION\n+\t\t\t\t  (TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n+\t\t\t\tOPT_Wodr,\n+\t\t\t\t\"virtual table of type %qD contains RTTI \"\n+\t\t\t\t\"information\",\n+\t\t\t\tDECL_CONTEXT (vtable->decl)))\n+\t\t{\n+\t\t  inform (DECL_SOURCE_LOCATION\n+\t\t\t      (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t\t    \"but is prevailed by one without from other\"\n+\t\t\t    \" translation unit\");\n+\t\t  inform (DECL_SOURCE_LOCATION\n+\t\t\t      (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t\t    \"RTTI will not work on this type\");\n+\t\t  class_type->rtti_broken = true;\n+\t\t}\n \t    }\n \t  n2++;\n           end2 = !vtable->iterate_reference (n2, ref2);\n@@ -831,6 +835,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t  if (DECL_SIZE (prevailing->decl) != DECL_SIZE (vtable->decl))\n \t    {\n \t      class_type->odr_violated = true;\n+\t      auto_diagnostic_group d;\n \t      if (warning_at (DECL_SOURCE_LOCATION\n \t\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n \t\t\t      OPT_Wodr,\n@@ -859,6 +864,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t  if (TREE_CODE (ref1->referred->decl) != FUNCTION_DECL\n \t      && TREE_CODE (ref2->referred->decl) != FUNCTION_DECL)\n \t    {\n+\t      auto_diagnostic_group d;\n \t      if (warning_at (DECL_SOURCE_LOCATION\n \t\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n \t\t\t      OPT_Wodr,\n@@ -900,6 +906,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t      vtable = tmp;\n \t      ref1 = ref2;\n \t    }\n+\t  auto_diagnostic_group d;\n \t  if (warning_at (DECL_SOURCE_LOCATION\n \t\t\t    (TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n \t\t\t  OPT_Wodr,\n@@ -931,6 +938,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \n       /* And in the last case we have either mistmatch in between two virtual\n \t methods or two virtual table pointers.  */\n+      auto_diagnostic_group d;\n       if (warning_at (DECL_SOURCE_LOCATION\n \t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))), OPT_Wodr,\n \t\t      \"virtual table of type %qD violates \"\n@@ -986,6 +994,7 @@ warn_odr (tree t1, tree t2, tree st1, tree st2,\n   if (lto_location_cache::current_cache)\n     lto_location_cache::current_cache->apply_location_cache ();\n \n+  auto_diagnostic_group d;\n   if (!warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (t1)), OPT_Wodr,\n \t\t   \"type %qT violates the C++ One Definition Rule\",\n \t\t   t1))"}, {"sha": "a610d9a3345201178e5cd01289c11e43c4e8fffd", "filename": "gcc/multiple_target.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fmultiple_target.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fmultiple_target.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmultiple_target.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -347,6 +347,7 @@ expand_target_clones (struct cgraph_node *node, bool definition)\n   if (node->definition\n       && !tree_versionable_function_p (node->decl))\n     {\n+      auto_diagnostic_group d;\n       error_at (DECL_SOURCE_LOCATION (node->decl),\n \t\t\"clones for %<target_clones%> attribute cannot be created\");\n       const char *reason = NULL;"}, {"sha": "91586022f7f9d053ab3f127779dc0c5e7f230bed", "filename": "gcc/opts-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1266,6 +1266,7 @@ cmdline_handle_error (location_t loc, const struct cl_option *option,\n       unsigned int i;\n       char *s;\n \n+      auto_diagnostic_group d;\n       if (e->unknown_error)\n \terror_at (loc, e->unknown_error, arg);\n       else"}, {"sha": "33befa5d350e1d89f9635bc1d7e1e905218916f6", "filename": "gcc/reginfo.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -782,6 +782,7 @@ globalize_reg (tree decl, int i)\n \n   if (global_regs[i])\n     {\n+      auto_diagnostic_group d;\n       warning_at (loc, 0, \n \t\t  \"register of %qD used for multiple global register variables\",\n \t\t  decl);"}, {"sha": "1981394a3f0b8c3b394a2ff411d92a88bb71662b", "filename": "gcc/substring-locations.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fsubstring-locations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Fsubstring-locations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsubstring-locations.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -167,6 +167,7 @@ format_warning_n_va (const substring_loc &fmt_loc,\n   if (substring_within_range)\n     primary_label = fmt_label;\n \n+  auto_diagnostic_group d;\n   gcc_rich_location richloc (primary_loc, primary_label);\n \n   if (param_loc != UNKNOWN_LOCATION)"}, {"sha": "969e03658f9bbcd7ba8615c0070f33702b2b66c3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -1,3 +1,10 @@\n+2018-08-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR other/84889\n+\t* gcc.dg/plugin/diagnostic-group-test-1.c: New test.\n+\t* gcc.dg/plugin/diagnostic_group_plugin.c: New test.\n+\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the new tests.\n+\n 2018-08-20  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/87014"}, {"sha": "962cba6941a70cf213583025337457ed4f09b6c5", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-group-test-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-group-test-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-group-test-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-group-test-1.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-show-caret\" } */\n+\n+extern void __emit_warning (const char *message);\n+\n+static void test_1 (void)\n+{\n+  __emit_warning (\"warning 1\");\n+}\n+\n+/* { dg-begin-multiline-output \"\" }\n+================================= BEGIN GROUP ==============================\n+PREFIX\n+   __emit_warning (\"warning 1\");\n+   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+PREFIX: message for note\n+PREFIX:  some more detail\n+PREFIX:   yet more detail\n+---------------------------------- END GROUP -------------------------------\n+   { dg-end-multiline-output \"\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+================================= BEGIN GROUP ==============================\n+PREFIX: an unrelated message\n+---------------------------------- END GROUP -------------------------------\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "3083e127d65b58e42c21c498218437aec94c5c6b", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_group_plugin.c", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_group_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_group_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_group_plugin.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -0,0 +1,234 @@\n+/* { dg-options \"-O\" } */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"hash-table.h\"\n+#include \"vec.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"plugin-version.h\"\n+#include \"c-family/c-common.h\"\n+#include \"diagnostic.h\"\n+#include \"context.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+/* A custom pass for emitting dummy warnings from the middle-end.  */\n+\n+const pass_data pass_data_test_groups =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"test_groups\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_test_groups : public gimple_opt_pass\n+{\n+public:\n+  pass_test_groups(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_test_groups, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate (function *) { return true; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_test_groups\n+\n+/* Determine if STMT is a call with NUM_ARGS arguments to a function\n+   named FUNCNAME.\n+   If so, return STMT as a gcall *.  Otherwise return NULL.  */\n+\n+static gcall *\n+check_for_named_call (gimple *stmt,\n+\t\t      const char *funcname, unsigned int num_args)\n+{\n+  gcc_assert (funcname);\n+\n+  gcall *call = dyn_cast <gcall *> (stmt);\n+  if (!call)\n+    return NULL;\n+\n+  tree fndecl = gimple_call_fndecl (call);\n+  if (!fndecl)\n+    return NULL;\n+\n+  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), funcname))\n+    return NULL;\n+\n+  if (gimple_call_num_args (call) != num_args)\n+    {\n+      error_at (stmt->location, \"expected number of args: %i (got %i)\",\n+\t\tnum_args, gimple_call_num_args (call));\n+      return NULL;\n+    }\n+\n+  return call;\n+}\n+\n+/* Emit a warning at LOC.  */\n+\n+static void\n+emit_warning (location_t loc)\n+{\n+  source_range src_range = get_range_from_loc (line_table, loc);\n+  warning_at (loc, 0, \"range %i:%i-%i:%i\",\n+\t      LOCATION_LINE (src_range.m_start),\n+\t      LOCATION_COLUMN (src_range.m_start),\n+\t      LOCATION_LINE (src_range.m_finish),\n+\t      LOCATION_COLUMN (src_range.m_finish));\n+}\n+\n+/* Code for simulating the emission of a warning from the middle-end.\n+   Emit a warning for each call to a function named \"__emit_warning\".  */\n+\n+static void\n+test_groups (gimple *stmt)\n+{\n+  gcall *call = check_for_named_call (stmt, \"__emit_warning\", 1);\n+  if (!call)\n+    return;\n+\n+  /* We expect an ADDR_EXPR with a STRING_CST inside it for the\n+     initial arg.  */\n+  tree t_addr_string = gimple_call_arg (call, 0);\n+  if (TREE_CODE (t_addr_string) != ADDR_EXPR)\n+    {\n+      error_at (call->location, \"string literal required for arg 1\");\n+      return;\n+    }\n+\n+  tree t_string = TREE_OPERAND (t_addr_string, 0);\n+  if (TREE_CODE (t_string) != STRING_CST)\n+    {\n+      error_at (call->location, \"string literal required for arg 1\");\n+      return;\n+    }\n+\n+  {\n+    auto_diagnostic_group d;\n+    if (warning_at (call->location, 0, \"%s\", call,\n+\t\t    TREE_STRING_POINTER (t_string)))\n+      {\n+\tinform (call->location, \"message for note\");\n+\tinform (call->location, \" some more detail\");\n+\tinform (call->location, \"  yet more detail\");\n+      }\n+  }\n+  inform (call->location, \"an unrelated message\");\n+}\n+\n+/* Call test_groups on every statement within FUN.  */\n+\n+unsigned int\n+pass_test_groups::execute (function *fun)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple *stmt = gsi_stmt (gsi);\n+\ttest_groups (stmt);\n+      }\n+\n+  return 0;\n+}\n+\n+/* Custom diagnostic callback, to avoid having the path in the\n+   expected output.  */\n+\n+void\n+test_diagnostic_starter (diagnostic_context *context,\n+\t\t\t diagnostic_info *diagnostic)\n+{\n+  pp_set_prefix (context->printer, xstrdup (\"PREFIX: \"));\n+}\n+\n+/* Custom diagnostic callback, to avoid having the path in the\n+   expected output.  */\n+\n+void\n+test_diagnostic_start_span_fn (diagnostic_context *context,\n+\t\t\t       expanded_location exploc)\n+{\n+  pp_string (context->printer, \"START_SPAN_FN: \");\n+  pp_newline (context->printer);\n+}\n+\n+/* Custom diagnostic callback: loudly announce a new diagnostic group.  */\n+\n+static void\n+test_begin_group_cb (diagnostic_context * context)\n+{\n+  pp_string (context->printer,\n+\t     \"================================= BEGIN GROUP ==============================\");\n+  pp_newline (context->printer);\n+}\n+\n+/* Custom diagnostic callback: loudly announce the end of a\n+   diagnostic group.  */\n+\n+static void\n+test_end_group_cb (diagnostic_context * context)\n+{\n+  pp_string (context->printer,\n+\t     \"---------------------------------- END GROUP -------------------------------\");\n+  pp_newline_and_flush (context->printer);\n+}\n+\n+/* Entrypoint for the plugin.\n+   Install custom callbacks into the global_dc.\n+   Create and register the custom pass.  */\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  struct register_pass_info pass_info;\n+  const char *plugin_name = plugin_info->base_name;\n+  int argc = plugin_info->argc;\n+  struct plugin_argument *argv = plugin_info->argv;\n+\n+  if (!plugin_default_version_check (version, &gcc_version))\n+    return 1;\n+\n+  diagnostic_starter (global_dc) = test_diagnostic_starter;\n+  global_dc->start_span = test_diagnostic_start_span_fn;\n+  global_dc->begin_group_cb = test_begin_group_cb;\n+  global_dc->end_group_cb = test_end_group_cb;\n+\n+  pass_info.pass = new pass_test_groups (g);\n+  pass_info.reference_pass_name = \"*warn_function_noreturn\";\n+  pass_info.ref_pass_instance_number = 1;\n+  pass_info.pos_op = PASS_POS_INSERT_AFTER;\n+  register_callback (plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,\n+\t\t     &pass_info);\n+\n+  return 0;\n+}"}, {"sha": "46246a2449ec45b609c637f18fcb44de76b93ae6", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -69,6 +69,8 @@ set plugin_test_list [list \\\n     { poly-int-05_plugin.c poly-int-test-1.c } \\\n     { poly-int-06_plugin.c poly-int-test-1.c } \\\n     { poly-int-07_plugin.c poly-int-test-1.c } \\\n+    { diagnostic_group_plugin.c \\\n+\t  diagnostic-group-test-1.c } \\\n     { diagnostic_plugin_test_show_locus.c \\\n \t  diagnostic-test-show-locus-bw.c \\\n \t  diagnostic-test-show-locus-color.c \\"}, {"sha": "2b6bb5c0e3136e28d036827994d685f93fba3849", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -4427,6 +4427,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n \t       /* Avoid warnings during early inline pass. */\n \t       && symtab->global_info_ready)\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (warning (OPT_Winline, \"inlining failed in call to %q+F: %s\",\n \t\t       fn, _(cgraph_inline_failed_string (reason))))\n \t    {"}, {"sha": "d0f799eb39de067ec3ef84dab73e9181146b4b4b", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -3454,6 +3454,7 @@ pass_post_ipa_warn::execute (function *fun)\n \t\t\tcontinue;\n \n \t\t      location_t loc = gimple_location (stmt);\n+\t\t      auto_diagnostic_group d;\n \t\t      if (warning_at (loc, OPT_Wnonnull,\n \t\t\t\t      \"%Gargument %u null where non-null \"\n \t\t\t\t      \"expected\", stmt, i + 1))"}, {"sha": "7b6c91ca6daf0060657689a332baa65863a35012", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -3231,6 +3231,7 @@ do_warn_aggressive_loop_optimizations (struct loop *loop,\n   char buf[WIDE_INT_PRINT_BUFFER_SIZE];\n   print_dec (i_bound, buf, TYPE_UNSIGNED (TREE_TYPE (loop->nb_iterations))\n \t     ? UNSIGNED : SIGNED);\n+  auto_diagnostic_group d;\n   if (warning_at (gimple_location (stmt), OPT_Waggressive_loop_optimizations,\n \t\t  \"iteration %s invokes undefined behavior\", buf))\n     inform (gimple_location (estmt), \"within this loop\");"}, {"sha": "a93610084f2a101b5399a10128b64c3f407b111d", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -178,6 +178,7 @@ warn_uninit (enum opt_code wc, tree t, tree expr, tree var,\n   cfun_loc = DECL_SOURCE_LOCATION (cfun->decl);\n   xloc = expand_location (location);\n   floc = expand_location (cfun_loc);\n+  auto_diagnostic_group d;\n   if (warning_at (location, wc, gmsgid, expr))\n     {\n       TREE_NO_WARNING (expr) = 1;"}, {"sha": "dd3439f60c9649fa925bfedc551c9708fc1b4bdf", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f82ec9d19ccb5420c8df98cf35e1898b4fdab/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=097f82ec9d19ccb5420c8df98cf35e1898b4fdab", "patch": "@@ -12613,6 +12613,7 @@ warn_deprecated_use (tree node, tree attr)\n   bool w = false;\n   if (DECL_P (node))\n     {\n+      auto_diagnostic_group d;\n       if (msg)\n \tw = warning (OPT_Wdeprecated_declarations,\n \t\t     \"%qD is deprecated: %s\", node, (const char *) msg);\n@@ -12636,6 +12637,7 @@ warn_deprecated_use (tree node, tree attr)\n \t    what = DECL_NAME (TYPE_NAME (node));\n \t}\n \n+      auto_diagnostic_group d;\n       if (what)\n \t{\n \t  if (msg)"}]}