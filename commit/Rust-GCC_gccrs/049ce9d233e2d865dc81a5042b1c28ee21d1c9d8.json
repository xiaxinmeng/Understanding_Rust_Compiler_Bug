{"sha": "049ce9d233e2d865dc81a5042b1c28ee21d1c9d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ5Y2U5ZDIzM2UyZDg2NWRjODFhNTA0MmIxYzI4ZWUyMWQxYzlkOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-25T14:42:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-25T14:42:38Z"}, "message": "middle-end: __builtin_mul_overflow expansion improvements [PR95862]\n\nThe following patch adds some improvements for __builtin_mul_overflow\nexpansion.\nOne optimization is for the u1 * u2 -> sr case, as documented we normally\ndo:\n     u1 * u2 -> sr\n        res = (S) (u1 * u2)\n        ovf = res < 0 || main_ovf (true)\nwhere main_ovf (true) stands for jump on unsigned multiplication overflow.\nIf we know that the most significant bits of both operands are clear (such\nas when they are zero extended from something smaller), we can\nemit better coe by handling it like s1 * s2 -> sr, i.e. just jump on\noverflow after signed multiplication.\n\nAnother two cases are s1 * s2 -> ur or s1 * u2 -> ur, if we know the minimum\nprecision needed to encode all values of both arguments summed together\nis smaller or equal to destination precision (such as when the two arguments\nare sign (or zero) extended from half precision types, we know the overflows\nhappen only iff one argument is negative and the other argument is positive\n(not zero), because even if both have maximum possible values, the maximum\nis still representable (e.g. for char * char -> unsigned short\n0x7f * 0x7f = 0x3f01 and for char * unsigned char -> unsigned short\n0x7f * 0xffU = 0x7e81) and as the result is unsigned, all negative results\ndo overflow, but are also representable if we consider the result signed\n- all of them have the MSB set.  So, it is more efficient to just\ndo the normal multiplication in that case and compare the result considered\nas signed value against 0, if it is smaller, overflow happened.\n\nAnd the get_min_precision change is to improve the char to short handling,\nwe have there in the IL\n  _2 = (int) arg_1(D);\npromotion from C promotions from char or unsigned char arg, and the caller\nadds a NOP_EXPR cast to short or unsigned short.  get_min_precision punts\non the narrowing cast though, it handled only widening casts, but we can\nhandle narrowing casts fine too, by recursing on the narrowing cast operands\nand using it only if it has in the end smaller minimal precision, which\nwould duplicate the sign bits (or zero bits) to both the bits above the\nnarrowing conversion and also at least one below that.\n\n2020-10-25  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/95862\n\t* internal-fn.c (get_min_precision): For narrowing conversion, recurse\n\ton the operand and if the operand precision is smaller than the\n\tcurrent one, return that smaller precision.\n\t(expand_mul_overflow): For s1 * u2 -> ur and s1 * s2 -> ur cases\n\tif the sum of minimum precisions of both operands is smaller or equal\n\tto the result precision, just perform normal multiplication and\n\tset overflow to the sign bit of the multiplication result.  For\n\tu1 * u2 -> sr if both arguments have the MSB known zero, use\n\tnormal s1 * s2 -> sr expansion.\n\n\t* gcc.dg/builtin-artih-overflow-5.c: New test.", "tree": {"sha": "a80a966def3c2c5426c2f99469478c7fe4852552", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a80a966def3c2c5426c2f99469478c7fe4852552"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/049ce9d233e2d865dc81a5042b1c28ee21d1c9d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/049ce9d233e2d865dc81a5042b1c28ee21d1c9d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/049ce9d233e2d865dc81a5042b1c28ee21d1c9d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/049ce9d233e2d865dc81a5042b1c28ee21d1c9d8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45281f120da85e0513cb5daa793112a37157ee70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45281f120da85e0513cb5daa793112a37157ee70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45281f120da85e0513cb5daa793112a37157ee70"}], "stats": {"total": 170, "additions": 169, "deletions": 1}, "files": [{"sha": "7dad8da4031cdae0523b2e88458386fe4eb10f21", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/049ce9d233e2d865dc81a5042b1c28ee21d1c9d8/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/049ce9d233e2d865dc81a5042b1c28ee21d1c9d8/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=049ce9d233e2d865dc81a5042b1c28ee21d1c9d8", "patch": "@@ -553,6 +553,16 @@ get_min_precision (tree arg, signop sign)\n       if (++cnt > 30)\n \treturn prec + (orig_sign != sign);\n     }\n+  if (CONVERT_EXPR_P (arg)\n+      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (arg, 0)))\n+      && TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg, 0))) > prec)\n+    {\n+      /* We have e.g. (unsigned short) y_2 where int y_2 = (int) x_1(D);\n+\t If y_2's min precision is smaller than prec, return that.  */\n+      int oprec = get_min_precision (TREE_OPERAND (arg, 0), sign);\n+      if (oprec < prec)\n+\treturn oprec + (orig_sign != sign);\n+    }\n   if (TREE_CODE (arg) != SSA_NAME)\n     return prec + (orig_sign != sign);\n   wide_int arg_min, arg_max;\n@@ -1357,6 +1367,37 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t\t\t   NULL, done_label, profile_probability::very_likely ());\n \t  goto do_error_label;\n \tcase 3:\n+\t  if (get_min_precision (arg1, UNSIGNED)\n+\t      + get_min_precision (arg0, SIGNED) <= GET_MODE_PRECISION (mode))\n+\t    {\n+\t      /* If the first operand is sign extended from narrower type, the\n+\t\t second operand is zero extended from narrower type and\n+\t\t the sum of the two precisions is smaller or equal to the\n+\t\t result precision: if the first argument is at runtime\n+\t\t non-negative, maximum result will be 0x7e81 or 0x7f..fe80..01\n+\t\t and there will be no overflow, if the first argument is\n+\t\t negative and the second argument zero, the result will be\n+\t\t 0 and there will be no overflow, if the first argument is\n+\t\t negative and the second argument positive, the result when\n+\t\t treated as signed will be negative (minimum -0x7f80 or\n+\t\t -0x7f..f80..0) there there will be always overflow.  So, do\n+\t\t res = (U) (s1 * u2)\n+\t\t ovf = (S) res < 0  */\n+\t      struct separate_ops ops;\n+\t      ops.code = MULT_EXPR;\n+\t      ops.type\n+\t\t= build_nonstandard_integer_type (GET_MODE_PRECISION (mode),\n+\t\t\t\t\t\t  1);\n+\t      ops.op0 = make_tree (ops.type, op0);\n+\t      ops.op1 = make_tree (ops.type, op1);\n+\t      ops.op2 = NULL_TREE;\n+\t      ops.location = loc;\n+\t      res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t      do_compare_rtx_and_jump (res, const0_rtx, GE, false,\n+\t\t\t\t       mode, NULL_RTX, NULL, done_label,\n+\t\t\t\t       profile_probability::very_likely ());\n+\t      goto do_error_label;\n+\t    }\n \t  rtx_code_label *do_main_label;\n \t  do_main_label = gen_label_rtx ();\n \t  do_compare_rtx_and_jump (op0, const0_rtx, GE, false, mode, NULL_RTX,\n@@ -1374,7 +1415,16 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n   /* u1 * u2 -> sr  */\n   if (uns0_p && uns1_p && !unsr_p)\n     {\n-      uns = true;\n+      if ((pos_neg0 | pos_neg1) == 1)\n+\t{\n+\t  /* If both arguments are zero extended from narrower types,\n+\t     the MSB will be clear on both and so we can pretend it is\n+\t     a normal s1 * s2 -> sr multiplication.  */\n+\t  uns0_p = false;\n+\t  uns1_p = false;\n+\t}\n+      else\n+\tuns = true;\n       /* Rest of handling of this case after res is computed.  */\n       goto do_main;\n     }\n@@ -1455,6 +1505,37 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t\t\t       profile_probability::very_likely ());\n \t      goto do_error_label;\n \t    }\n+\t  if (get_min_precision (arg0, SIGNED)\n+\t      + get_min_precision (arg1, SIGNED) <= GET_MODE_PRECISION (mode))\n+\t    {\n+\t      /* If both operands are sign extended from narrower types and\n+\t\t the sum of the two precisions is smaller or equal to the\n+\t\t result precision: if both arguments are at runtime\n+\t\t non-negative, maximum result will be 0x3f01 or 0x3f..f0..01\n+\t\t and there will be no overflow, if both arguments are negative,\n+\t\t maximum result will be 0x40..00 and there will be no overflow\n+\t\t either, if one argument is positive and the other argument\n+\t\t negative, the result when treated as signed will be negative\n+\t\t and there will be always overflow, and if one argument is\n+\t\t zero and the other negative the result will be zero and no\n+\t\t overflow.  So, do\n+\t\t res = (U) (s1 * s2)\n+\t\t ovf = (S) res < 0  */\n+\t      struct separate_ops ops;\n+\t      ops.code = MULT_EXPR;\n+\t      ops.type\n+\t\t= build_nonstandard_integer_type (GET_MODE_PRECISION (mode),\n+\t\t\t\t\t\t  1);\n+\t      ops.op0 = make_tree (ops.type, op0);\n+\t      ops.op1 = make_tree (ops.type, op1);\n+\t      ops.op2 = NULL_TREE;\n+\t      ops.location = loc;\n+\t      res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t      do_compare_rtx_and_jump (res, const0_rtx, GE, false,\n+\t\t\t\t       mode, NULL_RTX, NULL, done_label,\n+\t\t\t\t       profile_probability::very_likely ());\n+\t      goto do_error_label;\n+\t    }\n \t  /* The general case, do all the needed comparisons at runtime.  */\n \t  rtx_code_label *do_main_label, *after_negate_label;\n \t  rtx rop0, rop1;"}, {"sha": "b43fd1859d43b743adc56c81d1bb1646963d36de", "filename": "gcc/testsuite/gcc.dg/builtin-artih-overflow-5.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/049ce9d233e2d865dc81a5042b1c28ee21d1c9d8/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-artih-overflow-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/049ce9d233e2d865dc81a5042b1c28ee21d1c9d8/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-artih-overflow-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-artih-overflow-5.c?ref=049ce9d233e2d865dc81a5042b1c28ee21d1c9d8", "patch": "@@ -0,0 +1,87 @@\n+/* PR rtl-optimization/95862 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+int\n+f1 (int a, int b)\n+{\n+  unsigned long long c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}\n+\n+int\n+f2 (int a, unsigned b)\n+{\n+  unsigned long long c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}\n+\n+int\n+f3 (unsigned a, unsigned b)\n+{\n+  long long c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}\n+\n+int\n+f4 (int a, unsigned b)\n+{\n+  long long c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}\n+\n+short\n+f5 (short a, short b)\n+{\n+  unsigned c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}\n+\n+short\n+f6 (short a, unsigned short b)\n+{\n+  unsigned c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}\n+\n+short\n+f7 (unsigned short a, unsigned short b)\n+{\n+  int c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}\n+\n+short\n+f8 (short a, unsigned short b)\n+{\n+  int c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}\n+\n+signed char\n+f9 (signed char a, signed char b)\n+{\n+  unsigned short c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}\n+\n+signed char\n+f10 (signed char a, unsigned char b)\n+{\n+  unsigned short c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}\n+\n+signed char\n+f11 (unsigned char a, unsigned char b)\n+{\n+  short c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}\n+\n+signed char\n+f12 (signed char a, unsigned char b)\n+{\n+  short c;\n+  return __builtin_mul_overflow (a, b, &c);\n+}"}]}