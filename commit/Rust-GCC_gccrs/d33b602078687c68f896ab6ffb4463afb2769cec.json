{"sha": "d33b602078687c68f896ab6ffb4463afb2769cec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMzYjYwMjA3ODY4N2M2OGY4OTZhYjZmZmI0NDYzYWZiMjc2OWNlYw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-08-16T18:17:46Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-08-16T18:17:46Z"}, "message": "re PR fortran/33072 (\"use mod, only: operator(.sub.)\" matches any procedure \"sub\")\n\n2007-08-16  Tobias Burnus  <burnus@net-b.de>\n\n\tPR fortran/33072\n\t* module.c (gfc_match_use): Mark user operators as such.\n\t(find_use_name_n): Distinguish between operators and other symbols.\n\t(find_use_name,number_use_names,mio_namelist,\n\t load_operator_interfaces,load_generic_interfaces,read_module,\n\t write_generic): Update find_use_name_n calls.\n\n2007-08-16  Tobias Burnus  <burnus@net-b.de>\n\n\tPR fortran/33072\n\t* gfortran.dg/use_9.f90: New.\n\nFrom-SVN: r127564", "tree": {"sha": "b7aface547b1121ec68ea7d64efa97dfd0004502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7aface547b1121ec68ea7d64efa97dfd0004502"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d33b602078687c68f896ab6ffb4463afb2769cec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d33b602078687c68f896ab6ffb4463afb2769cec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d33b602078687c68f896ab6ffb4463afb2769cec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d33b602078687c68f896ab6ffb4463afb2769cec/comments", "author": null, "committer": null, "parents": [{"sha": "75407da35c2a03618a8a5fe2d111efaa8437f3a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75407da35c2a03618a8a5fe2d111efaa8437f3a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75407da35c2a03618a8a5fe2d111efaa8437f3a2"}], "stats": {"total": 72, "additions": 54, "deletions": 18}, "files": [{"sha": "78e48524e8c3294036f04d53f9abfca22549aa71", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d33b602078687c68f896ab6ffb4463afb2769cec/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d33b602078687c68f896ab6ffb4463afb2769cec/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d33b602078687c68f896ab6ffb4463afb2769cec", "patch": "@@ -1,3 +1,12 @@\n+2007-08-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/33072\n+\t* module.c (gfc_match_use): Mark user operators as such.\n+\t(find_use_name_n): Distinguish between operators and other symbols.\n+\t(find_use_name,number_use_names,mio_namelist,\n+\t load_operator_interfaces,load_generic_interfaces,read_module,\n+\t write_generic): Update find_use_name_n calls.\n+\n 2007-08-15  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/29459"}, {"sha": "c5a5184f57a22c942a8ac76601b7efad7b51f52e", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d33b602078687c68f896ab6ffb4463afb2769cec/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d33b602078687c68f896ab6ffb4463afb2769cec/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=d33b602078687c68f896ab6ffb4463afb2769cec", "patch": "@@ -612,6 +612,9 @@ gfc_match_use (void)\n \t\t == FAILURE))\n \t    goto cleanup;\n \n+\t  if (type == INTERFACE_USER_OP)\n+\t    new->operator = INTRINSIC_USER;\n+\n \t  if (only_flag)\n \t    {\n \t      if (m != MATCH_YES)\n@@ -677,18 +680,22 @@ gfc_match_use (void)\n /* Given a name and a number, inst, return the inst name\n    under which to load this symbol. Returns NULL if this\n    symbol shouldn't be loaded. If inst is zero, returns\n-   the number of instances of this name.  */\n+   the number of instances of this name. If interface is\n+   true, a user-defined operator is sought, otherwise only\n+   non-operators are sought.  */\n \n static const char *\n-find_use_name_n (const char *name, int *inst)\n+find_use_name_n (const char *name, int *inst, bool interface)\n {\n   gfc_use_rename *u;\n   int i;\n \n   i = 0;\n   for (u = gfc_rename_list; u; u = u->next)\n     {\n-      if (strcmp (u->use_name, name) != 0)\n+      if (strcmp (u->use_name, name) != 0\n+\t  || (u->operator == INTRINSIC_USER && !interface)\n+\t  || (u->operator != INTRINSIC_USER &&  interface))\n \tcontinue;\n       if (++i == *inst)\n \tbreak;\n@@ -713,21 +720,21 @@ find_use_name_n (const char *name, int *inst)\n    Returns NULL if this symbol shouldn't be loaded.  */\n \n static const char *\n-find_use_name (const char *name)\n+find_use_name (const char *name, bool interface)\n {\n   int i = 1;\n-  return find_use_name_n (name, &i);\n+  return find_use_name_n (name, &i, interface);\n }\n \n \n /* Given a real name, return the number of use names associated with it.  */\n \n static int\n-number_use_names (const char *name)\n+number_use_names (const char *name, bool interface)\n {\n   int i = 0;\n   const char *c;\n-  c = find_use_name_n (name, &i);\n+  c = find_use_name_n (name, &i, interface);\n   return i;\n }\n \n@@ -2869,7 +2876,7 @@ mio_namelist (gfc_symbol *sym)\n \t conditionally?  */\n       if (sym->attr.flavor == FL_NAMELIST)\n \t{\n-\t  check_name = find_use_name (sym->name);\n+\t  check_name = find_use_name (sym->name, false);\n \t  if (check_name && strcmp (check_name, sym->name) != 0)\n \t    gfc_error (\"Namelist %s cannot be renamed by USE \"\n \t\t       \"association to %s\", sym->name, check_name);\n@@ -3131,7 +3138,7 @@ load_operator_interfaces (void)\n       mio_internal_string (module);\n \n       /* Decide if we need to load this one or not.  */\n-      p = find_use_name (name);\n+      p = find_use_name (name, true);\n       if (p == NULL)\n \t{\n \t  while (parse_atom () != ATOM_RPAREN);\n@@ -3168,18 +3175,18 @@ load_generic_interfaces (void)\n       mio_internal_string (name);\n       mio_internal_string (module);\n \n-      n = number_use_names (name);\n+      n = number_use_names (name, false);\n       n = n ? n : 1;\n \n       for (i = 1; i <= n; i++)\n \t{\n \t  /* Decide if we need to load this one or not.  */\n-\t  p = find_use_name_n (name, &i);\n+\t  p = find_use_name_n (name, &i, false);\n \n \t  if (p == NULL || gfc_find_symbol (p, NULL, 0, &sym))\n \t    {\n \t      while (parse_atom () != ATOM_RPAREN);\n-\t\tcontinue;\n+\t      continue;\n \t    }\n \n \t  if (sym == NULL)\n@@ -3548,14 +3555,14 @@ read_module (void)\n \n       /* See how many use names there are.  If none, go through the start\n \t of the loop at least once.  */\n-      nuse = number_use_names (name);\n+      nuse = number_use_names (name, false);\n       if (nuse == 0)\n \tnuse = 1;\n \n       for (j = 1; j <= nuse; j++)\n \t{\n \t  /* Get the jth local name for this symbol.  */\n-\t  p = find_use_name_n (name, &j);\n+\t  p = find_use_name_n (name, &j, false);\n \n \t  if (p == NULL && strcmp (name, module_name) == 0)\n \t    p = name;\n@@ -3958,7 +3965,7 @@ write_generic (gfc_symbol *sym)\n     sym->module = gfc_get_string (module_name);\n \n   /* See how many use names there are.  If none, use the symbol name.  */\n-  nuse = number_use_names (sym->name);\n+  nuse = number_use_names (sym->name, false);\n   if (nuse == 0)\n     {\n       mio_symbol_interface (&sym->name, &sym->module, &sym->generic);\n@@ -3968,7 +3975,7 @@ write_generic (gfc_symbol *sym)\n   for (j = 1; j <= nuse; j++)\n     {\n       /* Get the jth local name for this symbol.  */\n-      p = find_use_name_n (sym->name, &j);\n+      p = find_use_name_n (sym->name, &j, false);\n \n       mio_symbol_interface (&p, &sym->module, &sym->generic);\n     }"}, {"sha": "e5335014c017876ba182eefa47b63401d3b66e6e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d33b602078687c68f896ab6ffb4463afb2769cec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d33b602078687c68f896ab6ffb4463afb2769cec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d33b602078687c68f896ab6ffb4463afb2769cec", "patch": "@@ -1,6 +1,11 @@\n+2007-08-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/33072\n+\t* gfortran.dg/use_9.f90: New.\n+\n 2007-08-16  Seongbae Park <seongbae.park@gmail.com>\n \n-        * g++.dg/gcov/gcov-5.C: New test.\n+\t* g++.dg/gcov/gcov-5.C: New test.\n \n 2007-08-16  Seongbae Park  <seongbae.park@gmail.com>\n \n@@ -64,7 +69,7 @@\n \t* g++.dg/template/crash68.C: New.\n \n 2007-08-15  Maxim Kuvyrkov  <maxim@codesourcery.com>\n- \n+\n \t* gcc.dg/sibcall-3.c: Remove m68k from XFAIL list.\n \t* gcc.dg/sibcall-4.c: Ditto.\n "}, {"sha": "588f29dec97569ee71ba02f1dba0230d8bb2959d", "filename": "gcc/testsuite/gfortran.dg/use_9.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d33b602078687c68f896ab6ffb4463afb2769cec/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d33b602078687c68f896ab6ffb4463afb2769cec/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_9.f90?ref=d33b602078687c68f896ab6ffb4463afb2769cec", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+module test\n+  interface operator(.bar.)\n+     module procedure func\n+  end interface\n+contains\n+function func(a)\n+  integer,intent(in) :: a\n+  integer :: funct\n+  func = a+1\n+end function\n+end module test\n+\n+use test, only: operator(.func.) ! { dg-error \"not found in module 'test'\" }\n+end"}]}